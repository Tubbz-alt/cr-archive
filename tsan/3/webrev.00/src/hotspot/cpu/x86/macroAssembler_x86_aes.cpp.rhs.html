<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/macroAssembler_x86_aes.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2 * Copyright (c) 2019, Intel Corporation.</span>
   3 *
   4 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5 *
   6 * This code is free software; you can redistribute it and/or modify it
   7 * under the terms of the GNU General Public License version 2 only, as
   8 * published by the Free Software Foundation.
   9 *
  10 * This code is distributed in the hope that it will be useful, but WITHOUT
  11 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13 * version 2 for more details (a copy is included in the LICENSE file that
  14 * accompanied this code).
  15 *
  16 * You should have received a copy of the GNU General Public License version
  17 * 2 along with this work; if not, write to the Free Software Foundation,
  18 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19 *
  20 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21 * or visit www.oracle.com if you need additional information or have any
  22 * questions.
  23 *
  24 */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/assembler.hpp&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;runtime/stubRoutines.hpp&quot;
  30 #include &quot;macroAssembler_x86.hpp&quot;
  31 
  32 #ifdef _LP64
<a name="2" id="anc2"></a><span class="line-added">  33 </span>
<span class="line-added">  34 void MacroAssembler::roundEnc(XMMRegister key, int rnum) {</span>
<span class="line-added">  35     for (int xmm_reg_no = 0; xmm_reg_no &lt;=rnum; xmm_reg_no++) {</span>
<span class="line-added">  36       vaesenc(as_XMMRegister(xmm_reg_no), as_XMMRegister(xmm_reg_no), key, Assembler::AVX_512bit);</span>
<span class="line-added">  37     }</span>
<span class="line-added">  38 }</span>
<span class="line-added">  39 </span>
<span class="line-added">  40 void MacroAssembler::lastroundEnc(XMMRegister key, int rnum) {</span>
<span class="line-added">  41     for (int xmm_reg_no = 0; xmm_reg_no &lt;=rnum; xmm_reg_no++) {</span>
<span class="line-added">  42       vaesenclast(as_XMMRegister(xmm_reg_no), as_XMMRegister(xmm_reg_no), key, Assembler::AVX_512bit);</span>
<span class="line-added">  43     }</span>
<span class="line-added">  44 }</span>
<span class="line-added">  45 </span>
<span class="line-added">  46 void MacroAssembler::roundDec(XMMRegister key, int rnum) {</span>
<span class="line-added">  47     for (int xmm_reg_no = 0; xmm_reg_no &lt;=rnum; xmm_reg_no++) {</span>
<span class="line-added">  48       vaesdec(as_XMMRegister(xmm_reg_no), as_XMMRegister(xmm_reg_no), key, Assembler::AVX_512bit);</span>
<span class="line-added">  49     }</span>
<span class="line-added">  50 }</span>
<span class="line-added">  51 </span>
<span class="line-added">  52 void MacroAssembler::lastroundDec(XMMRegister key, int rnum) {</span>
<span class="line-added">  53     for (int xmm_reg_no = 0; xmm_reg_no &lt;=rnum; xmm_reg_no++) {</span>
<span class="line-added">  54       vaesdeclast(as_XMMRegister(xmm_reg_no), as_XMMRegister(xmm_reg_no), key, Assembler::AVX_512bit);</span>
<span class="line-added">  55     }</span>
<span class="line-added">  56 }</span>
<span class="line-added">  57 </span>
<span class="line-added">  58 // Load key and shuffle operation</span>
<span class="line-added">  59 void MacroAssembler::ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {</span>
<span class="line-added">  60     movdqu(xmmdst, Address(key, offset));</span>
<span class="line-added">  61     if (xmm_shuf_mask != NULL) {</span>
<span class="line-added">  62         pshufb(xmmdst, xmm_shuf_mask);</span>
<span class="line-added">  63     } else {</span>
<span class="line-added">  64        pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));</span>
<span class="line-added">  65     }</span>
<span class="line-added">  66    evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);</span>
<span class="line-added">  67 }</span>
<span class="line-added">  68 </span>
<span class="line-added">  69 // AES-ECB Encrypt Operation</span>
<span class="line-added">  70 void MacroAssembler::aesecb_encrypt(Register src_addr, Register dest_addr, Register key, Register len) {</span>
<span class="line-added">  71 </span>
<span class="line-added">  72     const Register pos = rax;</span>
<span class="line-added">  73     const Register rounds = r12;</span>
<span class="line-added">  74 </span>
<span class="line-added">  75     Label NO_PARTS, LOOP, Loop_start, LOOP2, AES192, END_LOOP, AES256, REMAINDER, LAST2, END, KEY_192, KEY_256, EXIT;</span>
<span class="line-added">  76     push(r13);</span>
<span class="line-added">  77     push(r12);</span>
<span class="line-added">  78 </span>
<span class="line-added">  79     // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge</span>
<span class="line-added">  80     // context for the registers used, where all instructions below are using 128-bit mode</span>
<span class="line-added">  81     // On EVEX without VL and BW, these instructions will all be AVX.</span>
<span class="line-added">  82     if (VM_Version::supports_avx512vlbw()) {</span>
<span class="line-added">  83        movl(rax, 0xffff);</span>
<span class="line-added">  84        kmovql(k1, rax);</span>
<span class="line-added">  85     }</span>
<span class="line-added">  86     push(len); // Save</span>
<span class="line-added">  87     push(rbx);</span>
<span class="line-added">  88 </span>
<span class="line-added">  89     vzeroupper();</span>
<span class="line-added">  90 </span>
<span class="line-added">  91     xorptr(pos, pos);</span>
<span class="line-added">  92 </span>
<span class="line-added">  93     // Calculate number of rounds based on key length(128, 192, 256):44 for 10-rounds, 52 for 12-rounds, 60 for 14-rounds</span>
<span class="line-added">  94     movl(rounds, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));</span>
<span class="line-added">  95 </span>
<span class="line-added">  96     // Load Key shuf mask</span>
<span class="line-added">  97     const XMMRegister xmm_key_shuf_mask = xmm31;  // used temporarily to swap key bytes up front</span>
<span class="line-added">  98     movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));</span>
<span class="line-added">  99 </span>
<span class="line-added"> 100     // Load and shuffle key based on number of rounds</span>
<span class="line-added"> 101     ev_load_key(xmm8, key, 0 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 102     ev_load_key(xmm9, key, 1 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 103     ev_load_key(xmm10, key, 2 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 104     ev_load_key(xmm23, key, 3 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 105     ev_load_key(xmm12, key, 4 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 106     ev_load_key(xmm13, key, 5 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 107     ev_load_key(xmm14, key, 6 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 108     ev_load_key(xmm15, key, 7 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 109     ev_load_key(xmm16, key, 8 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 110     ev_load_key(xmm17, key, 9 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 111     ev_load_key(xmm24, key, 10 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 112     cmpl(rounds, 52);</span>
<span class="line-added"> 113     jcc(Assembler::greaterEqual, KEY_192);</span>
<span class="line-added"> 114     jmp(Loop_start);</span>
<span class="line-added"> 115 </span>
<span class="line-added"> 116     bind(KEY_192);</span>
<span class="line-added"> 117     ev_load_key(xmm19, key, 11 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 118     ev_load_key(xmm20, key, 12 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 119     cmpl(rounds, 60);</span>
<span class="line-added"> 120     jcc(Assembler::equal, KEY_256);</span>
<span class="line-added"> 121     jmp(Loop_start);</span>
<span class="line-added"> 122 </span>
<span class="line-added"> 123     bind(KEY_256);</span>
<span class="line-added"> 124     ev_load_key(xmm21, key, 13 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 125     ev_load_key(xmm22, key, 14 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 126 </span>
<span class="line-added"> 127     bind(Loop_start);</span>
<span class="line-added"> 128     movq(rbx, len);</span>
<span class="line-added"> 129     // Divide length by 16 to convert it to number of blocks</span>
<span class="line-added"> 130     shrq(len, 4);</span>
<span class="line-added"> 131     shlq(rbx, 60);</span>
<span class="line-added"> 132     jcc(Assembler::equal, NO_PARTS);</span>
<span class="line-added"> 133     addq(len, 1);</span>
<span class="line-added"> 134     // Check if number of blocks is greater than or equal to 32</span>
<span class="line-added"> 135     // If true, 512 bytes are processed at a time (code marked by label LOOP)</span>
<span class="line-added"> 136     // If not, 16 bytes are processed (code marked by REMAINDER label)</span>
<span class="line-added"> 137     bind(NO_PARTS);</span>
<span class="line-added"> 138     movq(rbx, len);</span>
<span class="line-added"> 139     shrq(len, 5);</span>
<span class="line-added"> 140     jcc(Assembler::equal, REMAINDER);</span>
<span class="line-added"> 141     movl(r13, len);</span>
<span class="line-added"> 142     // Compute number of blocks that will be processed 512 bytes at a time</span>
<span class="line-added"> 143     // Subtract this from the total number of blocks which will then be processed by REMAINDER loop</span>
<span class="line-added"> 144     shlq(r13, 5);</span>
<span class="line-added"> 145     subq(rbx, r13);</span>
<span class="line-added"> 146     //Begin processing 512 bytes</span>
<span class="line-added"> 147     bind(LOOP);</span>
<span class="line-added"> 148     // Move 64 bytes of PT data into a zmm register, as a result 512 bytes of PT loaded in zmm0-7</span>
<span class="line-added"> 149     evmovdquq(xmm0, Address(src_addr, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 150     evmovdquq(xmm1, Address(src_addr, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 151     evmovdquq(xmm2, Address(src_addr, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 152     evmovdquq(xmm3, Address(src_addr, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 153     evmovdquq(xmm4, Address(src_addr, pos, Address::times_1, 4 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 154     evmovdquq(xmm5, Address(src_addr, pos, Address::times_1, 5 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 155     evmovdquq(xmm6, Address(src_addr, pos, Address::times_1, 6 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 156     evmovdquq(xmm7, Address(src_addr, pos, Address::times_1, 7 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 157     // Xor with the first round key</span>
<span class="line-added"> 158     evpxorq(xmm0, xmm0, xmm8, Assembler::AVX_512bit);</span>
<span class="line-added"> 159     evpxorq(xmm1, xmm1, xmm8, Assembler::AVX_512bit);</span>
<span class="line-added"> 160     evpxorq(xmm2, xmm2, xmm8, Assembler::AVX_512bit);</span>
<span class="line-added"> 161     evpxorq(xmm3, xmm3, xmm8, Assembler::AVX_512bit);</span>
<span class="line-added"> 162     evpxorq(xmm4, xmm4, xmm8, Assembler::AVX_512bit);</span>
<span class="line-added"> 163     evpxorq(xmm5, xmm5, xmm8, Assembler::AVX_512bit);</span>
<span class="line-added"> 164     evpxorq(xmm6, xmm6, xmm8, Assembler::AVX_512bit);</span>
<span class="line-added"> 165     evpxorq(xmm7, xmm7, xmm8, Assembler::AVX_512bit);</span>
<span class="line-added"> 166     // 9 Aes encode round operations</span>
<span class="line-added"> 167     roundEnc(xmm9,  7);</span>
<span class="line-added"> 168     roundEnc(xmm10, 7);</span>
<span class="line-added"> 169     roundEnc(xmm23, 7);</span>
<span class="line-added"> 170     roundEnc(xmm12, 7);</span>
<span class="line-added"> 171     roundEnc(xmm13, 7);</span>
<span class="line-added"> 172     roundEnc(xmm14, 7);</span>
<span class="line-added"> 173     roundEnc(xmm15, 7);</span>
<span class="line-added"> 174     roundEnc(xmm16, 7);</span>
<span class="line-added"> 175     roundEnc(xmm17, 7);</span>
<span class="line-added"> 176     cmpl(rounds, 52);</span>
<span class="line-added"> 177     jcc(Assembler::aboveEqual, AES192);</span>
<span class="line-added"> 178     // Aesenclast round operation for keysize = 128</span>
<span class="line-added"> 179     lastroundEnc(xmm24, 7);</span>
<span class="line-added"> 180     jmp(END_LOOP);</span>
<span class="line-added"> 181     //Additional 2 rounds of Aesenc operation for keysize = 192</span>
<span class="line-added"> 182     bind(AES192);</span>
<span class="line-added"> 183     roundEnc(xmm24, 7);</span>
<span class="line-added"> 184     roundEnc(xmm19, 7);</span>
<span class="line-added"> 185     cmpl(rounds, 60);</span>
<span class="line-added"> 186     jcc(Assembler::aboveEqual, AES256);</span>
<span class="line-added"> 187     // Aesenclast round for keysize = 192</span>
<span class="line-added"> 188     lastroundEnc(xmm20, 7);</span>
<span class="line-added"> 189     jmp(END_LOOP);</span>
<span class="line-added"> 190     // 2 rounds of Aesenc operation and Aesenclast for keysize = 256</span>
<span class="line-added"> 191     bind(AES256);</span>
<span class="line-added"> 192     roundEnc(xmm20, 7);</span>
<span class="line-added"> 193     roundEnc(xmm21, 7);</span>
<span class="line-added"> 194     lastroundEnc(xmm22, 7);</span>
<span class="line-added"> 195 </span>
<span class="line-added"> 196     bind(END_LOOP);</span>
<span class="line-added"> 197     // Move 512 bytes of CT to destination</span>
<span class="line-added"> 198     evmovdquq(Address(dest_addr, pos, Address::times_1, 0 * 64), xmm0, Assembler::AVX_512bit);</span>
<span class="line-added"> 199     evmovdquq(Address(dest_addr, pos, Address::times_1, 1 * 64), xmm1, Assembler::AVX_512bit);</span>
<span class="line-added"> 200     evmovdquq(Address(dest_addr, pos, Address::times_1, 2 * 64), xmm2, Assembler::AVX_512bit);</span>
<span class="line-added"> 201     evmovdquq(Address(dest_addr, pos, Address::times_1, 3 * 64), xmm3, Assembler::AVX_512bit);</span>
<span class="line-added"> 202     evmovdquq(Address(dest_addr, pos, Address::times_1, 4 * 64), xmm4, Assembler::AVX_512bit);</span>
<span class="line-added"> 203     evmovdquq(Address(dest_addr, pos, Address::times_1, 5 * 64), xmm5, Assembler::AVX_512bit);</span>
<span class="line-added"> 204     evmovdquq(Address(dest_addr, pos, Address::times_1, 6 * 64), xmm6, Assembler::AVX_512bit);</span>
<span class="line-added"> 205     evmovdquq(Address(dest_addr, pos, Address::times_1, 7 * 64), xmm7, Assembler::AVX_512bit);</span>
<span class="line-added"> 206 </span>
<span class="line-added"> 207     addq(pos, 512);</span>
<span class="line-added"> 208     decq(len);</span>
<span class="line-added"> 209     jcc(Assembler::notEqual, LOOP);</span>
<span class="line-added"> 210 </span>
<span class="line-added"> 211     bind(REMAINDER);</span>
<span class="line-added"> 212     vzeroupper();</span>
<span class="line-added"> 213     cmpq(rbx, 0);</span>
<span class="line-added"> 214     jcc(Assembler::equal, END);</span>
<span class="line-added"> 215     // Process 16 bytes at a time</span>
<span class="line-added"> 216     bind(LOOP2);</span>
<span class="line-added"> 217     movdqu(xmm1, Address(src_addr, pos, Address::times_1, 0));</span>
<span class="line-added"> 218     vpxor(xmm1, xmm1, xmm8, Assembler::AVX_128bit);</span>
<span class="line-added"> 219     // xmm2 contains shuffled key for Aesenclast operation.</span>
<span class="line-added"> 220     vmovdqu(xmm2, xmm24);</span>
<span class="line-added"> 221 </span>
<span class="line-added"> 222     vaesenc(xmm1, xmm1, xmm9, Assembler::AVX_128bit);</span>
<span class="line-added"> 223     vaesenc(xmm1, xmm1, xmm10, Assembler::AVX_128bit);</span>
<span class="line-added"> 224     vaesenc(xmm1, xmm1, xmm23, Assembler::AVX_128bit);</span>
<span class="line-added"> 225     vaesenc(xmm1, xmm1, xmm12, Assembler::AVX_128bit);</span>
<span class="line-added"> 226     vaesenc(xmm1, xmm1, xmm13, Assembler::AVX_128bit);</span>
<span class="line-added"> 227     vaesenc(xmm1, xmm1, xmm14, Assembler::AVX_128bit);</span>
<span class="line-added"> 228     vaesenc(xmm1, xmm1, xmm15, Assembler::AVX_128bit);</span>
<span class="line-added"> 229     vaesenc(xmm1, xmm1, xmm16, Assembler::AVX_128bit);</span>
<span class="line-added"> 230     vaesenc(xmm1, xmm1, xmm17, Assembler::AVX_128bit);</span>
<span class="line-added"> 231 </span>
<span class="line-added"> 232     cmpl(rounds, 52);</span>
<span class="line-added"> 233     jcc(Assembler::below, LAST2);</span>
<span class="line-added"> 234     vmovdqu(xmm2, xmm20);</span>
<span class="line-added"> 235     vaesenc(xmm1, xmm1, xmm24, Assembler::AVX_128bit);</span>
<span class="line-added"> 236     vaesenc(xmm1, xmm1, xmm19, Assembler::AVX_128bit);</span>
<span class="line-added"> 237     cmpl(rounds, 60);</span>
<span class="line-added"> 238     jcc(Assembler::below, LAST2);</span>
<span class="line-added"> 239     vmovdqu(xmm2, xmm22);</span>
<span class="line-added"> 240     vaesenc(xmm1, xmm1, xmm20, Assembler::AVX_128bit);</span>
<span class="line-added"> 241     vaesenc(xmm1, xmm1, xmm21, Assembler::AVX_128bit);</span>
<span class="line-added"> 242 </span>
<span class="line-added"> 243     bind(LAST2);</span>
<span class="line-added"> 244     // Aesenclast round</span>
<span class="line-added"> 245     vaesenclast(xmm1, xmm1, xmm2, Assembler::AVX_128bit);</span>
<span class="line-added"> 246     // Write 16 bytes of CT to destination</span>
<span class="line-added"> 247     movdqu(Address(dest_addr, pos, Address::times_1, 0), xmm1);</span>
<span class="line-added"> 248     addq(pos, 16);</span>
<span class="line-added"> 249     decq(rbx);</span>
<span class="line-added"> 250     jcc(Assembler::notEqual, LOOP2);</span>
<span class="line-added"> 251 </span>
<span class="line-added"> 252     bind(END);</span>
<span class="line-added"> 253     // Zero out the round keys</span>
<span class="line-added"> 254     evpxorq(xmm8, xmm8, xmm8, Assembler::AVX_512bit);</span>
<span class="line-added"> 255     evpxorq(xmm9, xmm9, xmm9, Assembler::AVX_512bit);</span>
<span class="line-added"> 256     evpxorq(xmm10, xmm10, xmm10, Assembler::AVX_512bit);</span>
<span class="line-added"> 257     evpxorq(xmm23, xmm23, xmm23, Assembler::AVX_512bit);</span>
<span class="line-added"> 258     evpxorq(xmm12, xmm12, xmm12, Assembler::AVX_512bit);</span>
<span class="line-added"> 259     evpxorq(xmm13, xmm13, xmm13, Assembler::AVX_512bit);</span>
<span class="line-added"> 260     evpxorq(xmm14, xmm14, xmm14, Assembler::AVX_512bit);</span>
<span class="line-added"> 261     evpxorq(xmm15, xmm15, xmm15, Assembler::AVX_512bit);</span>
<span class="line-added"> 262     evpxorq(xmm16, xmm16, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 263     evpxorq(xmm17, xmm17, xmm17, Assembler::AVX_512bit);</span>
<span class="line-added"> 264     evpxorq(xmm24, xmm24, xmm24, Assembler::AVX_512bit);</span>
<span class="line-added"> 265     cmpl(rounds, 44);</span>
<span class="line-added"> 266     jcc(Assembler::belowEqual, EXIT);</span>
<span class="line-added"> 267     evpxorq(xmm19, xmm19, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added"> 268     evpxorq(xmm20, xmm20, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 269     cmpl(rounds, 52);</span>
<span class="line-added"> 270     jcc(Assembler::belowEqual, EXIT);</span>
<span class="line-added"> 271     evpxorq(xmm21, xmm21, xmm21, Assembler::AVX_512bit);</span>
<span class="line-added"> 272     evpxorq(xmm22, xmm22, xmm22, Assembler::AVX_512bit);</span>
<span class="line-added"> 273     bind(EXIT);</span>
<span class="line-added"> 274     pop(rbx);</span>
<span class="line-added"> 275     pop(rax); // return length</span>
<span class="line-added"> 276     pop(r12);</span>
<span class="line-added"> 277     pop(r13);</span>
<span class="line-added"> 278 }</span>
<span class="line-added"> 279 </span>
<span class="line-added"> 280 // AES-ECB Decrypt Operation</span>
<span class="line-added"> 281 void MacroAssembler::aesecb_decrypt(Register src_addr, Register dest_addr, Register key, Register len)  {</span>
<span class="line-added"> 282 </span>
<span class="line-added"> 283     Label NO_PARTS, LOOP, Loop_start, LOOP2, AES192, END_LOOP, AES256, REMAINDER, LAST2, END, KEY_192, KEY_256, EXIT;</span>
<span class="line-added"> 284     const Register pos = rax;</span>
<span class="line-added"> 285     const Register rounds = r12;</span>
<span class="line-added"> 286     push(r13);</span>
<span class="line-added"> 287     push(r12);</span>
<span class="line-added"> 288 </span>
<span class="line-added"> 289     // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge</span>
<span class="line-added"> 290     // context for the registers used, where all instructions below are using 128-bit mode</span>
<span class="line-added"> 291     // On EVEX without VL and BW, these instructions will all be AVX.</span>
<span class="line-added"> 292     if (VM_Version::supports_avx512vlbw()) {</span>
<span class="line-added"> 293        movl(rax, 0xffff);</span>
<span class="line-added"> 294        kmovql(k1, rax);</span>
<span class="line-added"> 295     }</span>
<span class="line-added"> 296 </span>
<span class="line-added"> 297     push(len); // Save</span>
<span class="line-added"> 298     push(rbx);</span>
<span class="line-added"> 299 </span>
<span class="line-added"> 300     vzeroupper();</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302     xorptr(pos, pos);</span>
<span class="line-added"> 303     // Calculate number of rounds i.e. based on key length(128, 192, 256):44 for 10-rounds, 52 for 12-rounds, 60 for 14-rounds</span>
<span class="line-added"> 304     movl(rounds, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));</span>
<span class="line-added"> 305 </span>
<span class="line-added"> 306     // Load Key shuf mask</span>
<span class="line-added"> 307     const XMMRegister xmm_key_shuf_mask = xmm31;  // used temporarily to swap key bytes up front</span>
<span class="line-added"> 308     movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));</span>
<span class="line-added"> 309 </span>
<span class="line-added"> 310     // Load and shuffle round keys. The java expanded key ordering is rotated one position in decryption.</span>
<span class="line-added"> 311     // So the first round key is loaded from 1*16 here and last round key is loaded from 0*16</span>
<span class="line-added"> 312     ev_load_key(xmm9,  key, 1 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 313     ev_load_key(xmm10, key, 2 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 314     ev_load_key(xmm11, key, 3 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 315     ev_load_key(xmm12, key, 4 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 316     ev_load_key(xmm13, key, 5 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 317     ev_load_key(xmm14, key, 6 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 318     ev_load_key(xmm15, key, 7 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 319     ev_load_key(xmm16, key, 8 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 320     ev_load_key(xmm17, key, 9 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 321     ev_load_key(xmm18, key, 10 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 322     ev_load_key(xmm27, key, 0 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 323     cmpl(rounds, 52);</span>
<span class="line-added"> 324     jcc(Assembler::greaterEqual, KEY_192);</span>
<span class="line-added"> 325     jmp(Loop_start);</span>
<span class="line-added"> 326 </span>
<span class="line-added"> 327     bind(KEY_192);</span>
<span class="line-added"> 328     ev_load_key(xmm19, key, 11 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 329     ev_load_key(xmm20, key, 12 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 330     cmpl(rounds, 60);</span>
<span class="line-added"> 331     jcc(Assembler::equal, KEY_256);</span>
<span class="line-added"> 332     jmp(Loop_start);</span>
<span class="line-added"> 333 </span>
<span class="line-added"> 334     bind(KEY_256);</span>
<span class="line-added"> 335     ev_load_key(xmm21, key, 13 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 336     ev_load_key(xmm22, key, 14 * 16, xmm_key_shuf_mask);</span>
<span class="line-added"> 337     bind(Loop_start);</span>
<span class="line-added"> 338     movq(rbx, len);</span>
<span class="line-added"> 339     // Convert input length to number of blocks</span>
<span class="line-added"> 340     shrq(len, 4);</span>
<span class="line-added"> 341     shlq(rbx, 60);</span>
<span class="line-added"> 342     jcc(Assembler::equal, NO_PARTS);</span>
<span class="line-added"> 343     addq(len, 1);</span>
<span class="line-added"> 344     // Check if number of blocks is greater than/ equal to 32</span>
<span class="line-added"> 345     // If true, blocks then 512 bytes are processed at a time (code marked by label LOOP)</span>
<span class="line-added"> 346     // If not, 16 bytes are processed (code marked by label REMAINDER)</span>
<span class="line-added"> 347     bind(NO_PARTS);</span>
<span class="line-added"> 348     movq(rbx, len);</span>
<span class="line-added"> 349     shrq(len, 5);</span>
<span class="line-added"> 350     jcc(Assembler::equal, REMAINDER);</span>
<span class="line-added"> 351     movl(r13, len);</span>
<span class="line-added"> 352     // Compute number of blocks that will be processed as 512 bytes at a time</span>
<span class="line-added"> 353     // Subtract this from the total number of blocks, which will then be processed by REMAINDER loop.</span>
<span class="line-added"> 354     shlq(r13, 5);</span>
<span class="line-added"> 355     subq(rbx, r13);</span>
<span class="line-added"> 356 </span>
<span class="line-added"> 357     bind(LOOP);</span>
<span class="line-added"> 358     // Move 64 bytes of CT data into a zmm register, as a result 512 bytes of CT loaded in zmm0-7</span>
<span class="line-added"> 359     evmovdquq(xmm0, Address(src_addr, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 360     evmovdquq(xmm1, Address(src_addr, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 361     evmovdquq(xmm2, Address(src_addr, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 362     evmovdquq(xmm3, Address(src_addr, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 363     evmovdquq(xmm4, Address(src_addr, pos, Address::times_1, 4 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 364     evmovdquq(xmm5, Address(src_addr, pos, Address::times_1, 5 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 365     evmovdquq(xmm6, Address(src_addr, pos, Address::times_1, 6 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 366     evmovdquq(xmm7, Address(src_addr, pos, Address::times_1, 7 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 367     // Xor with the first round key</span>
<span class="line-added"> 368     evpxorq(xmm0, xmm0, xmm9, Assembler::AVX_512bit);</span>
<span class="line-added"> 369     evpxorq(xmm1, xmm1, xmm9, Assembler::AVX_512bit);</span>
<span class="line-added"> 370     evpxorq(xmm2, xmm2, xmm9, Assembler::AVX_512bit);</span>
<span class="line-added"> 371     evpxorq(xmm3, xmm3, xmm9, Assembler::AVX_512bit);</span>
<span class="line-added"> 372     evpxorq(xmm4, xmm4, xmm9, Assembler::AVX_512bit);</span>
<span class="line-added"> 373     evpxorq(xmm5, xmm5, xmm9, Assembler::AVX_512bit);</span>
<span class="line-added"> 374     evpxorq(xmm6, xmm6, xmm9, Assembler::AVX_512bit);</span>
<span class="line-added"> 375     evpxorq(xmm7, xmm7, xmm9, Assembler::AVX_512bit);</span>
<span class="line-added"> 376     // 9 rounds of Aesdec</span>
<span class="line-added"> 377     roundDec(xmm10, 7);</span>
<span class="line-added"> 378     roundDec(xmm11, 7);</span>
<span class="line-added"> 379     roundDec(xmm12, 7);</span>
<span class="line-added"> 380     roundDec(xmm13, 7);</span>
<span class="line-added"> 381     roundDec(xmm14, 7);</span>
<span class="line-added"> 382     roundDec(xmm15, 7);</span>
<span class="line-added"> 383     roundDec(xmm16, 7);</span>
<span class="line-added"> 384     roundDec(xmm17, 7);</span>
<span class="line-added"> 385     roundDec(xmm18, 7);</span>
<span class="line-added"> 386     cmpl(rounds, 52);</span>
<span class="line-added"> 387     jcc(Assembler::aboveEqual, AES192);</span>
<span class="line-added"> 388     // Aesdeclast round for keysize = 128</span>
<span class="line-added"> 389     lastroundDec(xmm27, 7);</span>
<span class="line-added"> 390     jmp(END_LOOP);</span>
<span class="line-added"> 391 </span>
<span class="line-added"> 392     bind(AES192);</span>
<span class="line-added"> 393     // 2 Additional rounds for keysize = 192</span>
<span class="line-added"> 394     roundDec(xmm19, 7);</span>
<span class="line-added"> 395     roundDec(xmm20, 7);</span>
<span class="line-added"> 396     cmpl(rounds, 60);</span>
<span class="line-added"> 397     jcc(Assembler::aboveEqual, AES256);</span>
<span class="line-added"> 398     // Aesdeclast round for keysize = 192</span>
<span class="line-added"> 399     lastroundDec(xmm27, 7);</span>
<span class="line-added"> 400     jmp(END_LOOP);</span>
<span class="line-added"> 401     bind(AES256);</span>
<span class="line-added"> 402     // 2 Additional rounds and Aesdeclast for keysize = 256</span>
<span class="line-added"> 403     roundDec(xmm21, 7);</span>
<span class="line-added"> 404     roundDec(xmm22, 7);</span>
<span class="line-added"> 405     lastroundDec(xmm27, 7);</span>
<span class="line-added"> 406 </span>
<span class="line-added"> 407     bind(END_LOOP);</span>
<span class="line-added"> 408     // Write 512 bytes of PT to the destination</span>
<span class="line-added"> 409     evmovdquq(Address(dest_addr, pos, Address::times_1, 0 * 64), xmm0, Assembler::AVX_512bit);</span>
<span class="line-added"> 410     evmovdquq(Address(dest_addr, pos, Address::times_1, 1 * 64), xmm1, Assembler::AVX_512bit);</span>
<span class="line-added"> 411     evmovdquq(Address(dest_addr, pos, Address::times_1, 2 * 64), xmm2, Assembler::AVX_512bit);</span>
<span class="line-added"> 412     evmovdquq(Address(dest_addr, pos, Address::times_1, 3 * 64), xmm3, Assembler::AVX_512bit);</span>
<span class="line-added"> 413     evmovdquq(Address(dest_addr, pos, Address::times_1, 4 * 64), xmm4, Assembler::AVX_512bit);</span>
<span class="line-added"> 414     evmovdquq(Address(dest_addr, pos, Address::times_1, 5 * 64), xmm5, Assembler::AVX_512bit);</span>
<span class="line-added"> 415     evmovdquq(Address(dest_addr, pos, Address::times_1, 6 * 64), xmm6, Assembler::AVX_512bit);</span>
<span class="line-added"> 416     evmovdquq(Address(dest_addr, pos, Address::times_1, 7 * 64), xmm7, Assembler::AVX_512bit);</span>
<span class="line-added"> 417 </span>
<span class="line-added"> 418     addq(pos, 512);</span>
<span class="line-added"> 419     decq(len);</span>
<span class="line-added"> 420     jcc(Assembler::notEqual, LOOP);</span>
<span class="line-added"> 421 </span>
<span class="line-added"> 422     bind(REMAINDER);</span>
<span class="line-added"> 423     vzeroupper();</span>
<span class="line-added"> 424     cmpq(rbx, 0);</span>
<span class="line-added"> 425     jcc(Assembler::equal, END);</span>
<span class="line-added"> 426     // Process 16 bytes at a time</span>
<span class="line-added"> 427     bind(LOOP2);</span>
<span class="line-added"> 428     movdqu(xmm1, Address(src_addr, pos, Address::times_1, 0));</span>
<span class="line-added"> 429     vpxor(xmm1, xmm1, xmm9, Assembler::AVX_128bit);</span>
<span class="line-added"> 430     // xmm2 contains shuffled key for Aesdeclast operation.</span>
<span class="line-added"> 431     vmovdqu(xmm2, xmm27);</span>
<span class="line-added"> 432 </span>
<span class="line-added"> 433     vaesdec(xmm1, xmm1, xmm10, Assembler::AVX_128bit);</span>
<span class="line-added"> 434     vaesdec(xmm1, xmm1, xmm11, Assembler::AVX_128bit);</span>
<span class="line-added"> 435     vaesdec(xmm1, xmm1, xmm12, Assembler::AVX_128bit);</span>
<span class="line-added"> 436     vaesdec(xmm1, xmm1, xmm13, Assembler::AVX_128bit);</span>
<span class="line-added"> 437     vaesdec(xmm1, xmm1, xmm14, Assembler::AVX_128bit);</span>
<span class="line-added"> 438     vaesdec(xmm1, xmm1, xmm15, Assembler::AVX_128bit);</span>
<span class="line-added"> 439     vaesdec(xmm1, xmm1, xmm16, Assembler::AVX_128bit);</span>
<span class="line-added"> 440     vaesdec(xmm1, xmm1, xmm17, Assembler::AVX_128bit);</span>
<span class="line-added"> 441     vaesdec(xmm1, xmm1, xmm18, Assembler::AVX_128bit);</span>
<span class="line-added"> 442 </span>
<span class="line-added"> 443     cmpl(rounds, 52);</span>
<span class="line-added"> 444     jcc(Assembler::below, LAST2);</span>
<span class="line-added"> 445     vaesdec(xmm1, xmm1, xmm19, Assembler::AVX_128bit);</span>
<span class="line-added"> 446     vaesdec(xmm1, xmm1, xmm20, Assembler::AVX_128bit);</span>
<span class="line-added"> 447     cmpl(rounds, 60);</span>
<span class="line-added"> 448     jcc(Assembler::below, LAST2);</span>
<span class="line-added"> 449     vaesdec(xmm1, xmm1, xmm21, Assembler::AVX_128bit);</span>
<span class="line-added"> 450     vaesdec(xmm1, xmm1, xmm22, Assembler::AVX_128bit);</span>
<span class="line-added"> 451 </span>
<span class="line-added"> 452     bind(LAST2);</span>
<span class="line-added"> 453     // Aesdeclast round</span>
<span class="line-added"> 454     vaesdeclast(xmm1, xmm1, xmm2, Assembler::AVX_128bit);</span>
<span class="line-added"> 455     // Write 16 bytes of PT to destination</span>
<span class="line-added"> 456     movdqu(Address(dest_addr, pos, Address::times_1, 0), xmm1);</span>
<span class="line-added"> 457     addq(pos, 16);</span>
<span class="line-added"> 458     decq(rbx);</span>
<span class="line-added"> 459     jcc(Assembler::notEqual, LOOP2);</span>
<span class="line-added"> 460 </span>
<span class="line-added"> 461     bind(END);</span>
<span class="line-added"> 462     // Zero out the round keys</span>
<span class="line-added"> 463     evpxorq(xmm8, xmm8, xmm8, Assembler::AVX_512bit);</span>
<span class="line-added"> 464     evpxorq(xmm9, xmm9, xmm9, Assembler::AVX_512bit);</span>
<span class="line-added"> 465     evpxorq(xmm10, xmm10, xmm10, Assembler::AVX_512bit);</span>
<span class="line-added"> 466     evpxorq(xmm11, xmm11, xmm11, Assembler::AVX_512bit);</span>
<span class="line-added"> 467     evpxorq(xmm12, xmm12, xmm12, Assembler::AVX_512bit);</span>
<span class="line-added"> 468     evpxorq(xmm13, xmm13, xmm13, Assembler::AVX_512bit);</span>
<span class="line-added"> 469     evpxorq(xmm14, xmm14, xmm14, Assembler::AVX_512bit);</span>
<span class="line-added"> 470     evpxorq(xmm15, xmm15, xmm15, Assembler::AVX_512bit);</span>
<span class="line-added"> 471     evpxorq(xmm16, xmm16, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 472     evpxorq(xmm17, xmm17, xmm17, Assembler::AVX_512bit);</span>
<span class="line-added"> 473     evpxorq(xmm18, xmm18, xmm18, Assembler::AVX_512bit);</span>
<span class="line-added"> 474     evpxorq(xmm27, xmm27, xmm27, Assembler::AVX_512bit);</span>
<span class="line-added"> 475     cmpl(rounds, 44);</span>
<span class="line-added"> 476     jcc(Assembler::belowEqual, EXIT);</span>
<span class="line-added"> 477     evpxorq(xmm19, xmm19, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added"> 478     evpxorq(xmm20, xmm20, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 479     cmpl(rounds, 52);</span>
<span class="line-added"> 480     jcc(Assembler::belowEqual, EXIT);</span>
<span class="line-added"> 481     evpxorq(xmm21, xmm21, xmm21, Assembler::AVX_512bit);</span>
<span class="line-added"> 482     evpxorq(xmm22, xmm22, xmm22, Assembler::AVX_512bit);</span>
<span class="line-added"> 483     bind(EXIT);</span>
<span class="line-added"> 484     pop(rbx);</span>
<span class="line-added"> 485     pop(rax); // return length</span>
<span class="line-added"> 486     pop(r12);</span>
<span class="line-added"> 487     pop(r13);</span>
<span class="line-added"> 488 }</span>
<span class="line-added"> 489 </span>
 490 // Multiply 128 x 128 bits, using 4 pclmulqdq operations
 491 void MacroAssembler::schoolbookAAD(int i, Register htbl, XMMRegister data,
 492     XMMRegister tmp0, XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3) {
 493     movdqu(xmm15, Address(htbl, i * 16));
 494     vpclmulhqlqdq(tmp3, data, xmm15); // 0x01
 495     vpxor(tmp2, tmp2, tmp3, Assembler::AVX_128bit);
 496     vpclmulldq(tmp3, data, xmm15); // 0x00
 497     vpxor(tmp0, tmp0, tmp3, Assembler::AVX_128bit);
 498     vpclmulhdq(tmp3, data, xmm15); // 0x11
 499     vpxor(tmp1, tmp1, tmp3, Assembler::AVX_128bit);
 500     vpclmullqhqdq(tmp3, data, xmm15); // 0x10
 501     vpxor(tmp2, tmp2, tmp3, Assembler::AVX_128bit);
 502 }
 503 
 504 // Multiply two 128 bit numbers resulting in a 256 bit value
 505 // Result of the multiplication followed by reduction stored in state
 506 void MacroAssembler::gfmul(XMMRegister tmp0, XMMRegister state) {
 507     const XMMRegister tmp1 = xmm4;
 508     const XMMRegister tmp2 = xmm5;
 509     const XMMRegister tmp3 = xmm6;
 510     const XMMRegister tmp4 = xmm7;
 511 
 512     vpclmulldq(tmp1, state, tmp0); //0x00  (a0 * b0)
 513     vpclmulhdq(tmp4, state, tmp0);//0x11 (a1 * b1)
 514     vpclmullqhqdq(tmp2, state, tmp0);//0x10 (a1 * b0)
 515     vpclmulhqlqdq(tmp3, state, tmp0); //0x01 (a0 * b1)
 516 
 517     vpxor(tmp2, tmp2, tmp3, Assembler::AVX_128bit); // (a0 * b1) + (a1 * b0)
 518 
 519     vpslldq(tmp3, tmp2, 8, Assembler::AVX_128bit);
 520     vpsrldq(tmp2, tmp2, 8, Assembler::AVX_128bit);
 521     vpxor(tmp1, tmp1, tmp3, Assembler::AVX_128bit); // tmp1 and tmp4 hold the result
 522     vpxor(tmp4, tmp4, tmp2, Assembler::AVX_128bit); // of carryless multiplication
 523     // Follows the reduction technique mentioned in
 524     // Shift-XOR reduction described in Gueron-Kounavis May 2010
 525     // First phase of reduction
 526     //
 527     vpslld(xmm8, tmp1, 31, Assembler::AVX_128bit); // packed right shift shifting &lt;&lt; 31
 528     vpslld(xmm9, tmp1, 30, Assembler::AVX_128bit); // packed right shift shifting &lt;&lt; 30
 529     vpslld(xmm10, tmp1, 25, Assembler::AVX_128bit);// packed right shift shifting &lt;&lt; 25
 530     // xor the shifted versions
 531     vpxor(xmm8, xmm8, xmm9, Assembler::AVX_128bit);
 532     vpxor(xmm8, xmm8, xmm10, Assembler::AVX_128bit);
 533     vpslldq(xmm9, xmm8, 12, Assembler::AVX_128bit);
 534     vpsrldq(xmm8, xmm8, 4, Assembler::AVX_128bit);
 535     vpxor(tmp1, tmp1, xmm9, Assembler::AVX_128bit);// first phase of the reduction complete
 536     //
 537     // Second phase of the reduction
 538     //
 539     vpsrld(xmm9, tmp1, 1, Assembler::AVX_128bit);// packed left shifting &gt;&gt; 1
 540     vpsrld(xmm10, tmp1, 2, Assembler::AVX_128bit);// packed left shifting &gt;&gt; 2
 541     vpsrld(xmm11, tmp1, 7, Assembler::AVX_128bit);// packed left shifting &gt;&gt; 7
 542     vpxor(xmm9, xmm9, xmm10, Assembler::AVX_128bit);// xor the shifted versions
 543     vpxor(xmm9, xmm9, xmm11, Assembler::AVX_128bit);
 544     vpxor(xmm9, xmm9, xmm8, Assembler::AVX_128bit);
 545     vpxor(tmp1, tmp1, xmm9, Assembler::AVX_128bit);
 546     vpxor(state, tmp4, tmp1, Assembler::AVX_128bit);// the result is in state
 547     ret(0);
 548 }
 549 
 550 // This method takes the subkey after expansion as input and generates 1 * 16 power of subkey H.
 551 // The power of H is used in reduction process for one block ghash
 552 void MacroAssembler::generateHtbl_one_block(Register htbl) {
 553     const XMMRegister t = xmm13;
 554 
 555     // load the original subkey hash
 556     movdqu(t, Address(htbl, 0));
 557     // shuffle using long swap mask
 558     movdqu(xmm10, ExternalAddress(StubRoutines::x86::ghash_long_swap_mask_addr()));
 559     vpshufb(t, t, xmm10, Assembler::AVX_128bit);
 560 
 561     // Compute H&#39; = GFMUL(H, 2)
 562     vpsrld(xmm3, t, 7, Assembler::AVX_128bit);
 563     movdqu(xmm4, ExternalAddress(StubRoutines::x86::ghash_shufflemask_addr()));
 564     vpshufb(xmm3, xmm3, xmm4, Assembler::AVX_128bit);
 565     movl(rax, 0xff00);
 566     movdl(xmm4, rax);
 567     vpshufb(xmm4, xmm4, xmm3, Assembler::AVX_128bit);
 568     movdqu(xmm5, ExternalAddress(StubRoutines::x86::ghash_polynomial_addr()));
 569     vpand(xmm5, xmm5, xmm4, Assembler::AVX_128bit);
 570     vpsrld(xmm3, t, 31, Assembler::AVX_128bit);
 571     vpslld(xmm4, t, 1, Assembler::AVX_128bit);
 572     vpslldq(xmm3, xmm3, 4, Assembler::AVX_128bit);
 573     vpxor(t, xmm4, xmm3, Assembler::AVX_128bit);// t holds p(x) &lt;&lt;1 or H * 2
 574 
 575     //Adding p(x)&lt;&lt;1 to xmm5 which holds the reduction polynomial
 576     vpxor(t, t, xmm5, Assembler::AVX_128bit);
 577     movdqu(Address(htbl, 1 * 16), t); // H * 2
 578 
 579     ret(0);
 580 }
 581 
 582 // This method takes the subkey after expansion as input and generates the remaining powers of subkey H.
 583 // The power of H is used in reduction process for eight block ghash
 584 void MacroAssembler::generateHtbl_eight_blocks(Register htbl) {
 585     const XMMRegister t = xmm13;
 586     const XMMRegister tmp0 = xmm1;
 587     Label GFMUL;
 588 
 589     movdqu(t, Address(htbl, 1 * 16));
 590     movdqu(tmp0, t);
 591 
 592     // tmp0 and t hold H. Now we compute powers of H by using GFMUL(H, H)
 593     call(GFMUL, relocInfo::none);
 594     movdqu(Address(htbl, 2 * 16), t); //H ^ 2 * 2
 595     call(GFMUL, relocInfo::none);
 596     movdqu(Address(htbl, 3 * 16), t); //H ^ 3 * 2
 597     call(GFMUL, relocInfo::none);
 598     movdqu(Address(htbl, 4 * 16), t); //H ^ 4 * 2
 599     call(GFMUL, relocInfo::none);
 600     movdqu(Address(htbl, 5 * 16), t); //H ^ 5 * 2
 601     call(GFMUL, relocInfo::none);
 602     movdqu(Address(htbl, 6 * 16), t); //H ^ 6 * 2
 603     call(GFMUL, relocInfo::none);
 604     movdqu(Address(htbl, 7 * 16), t); //H ^ 7 * 2
 605     call(GFMUL, relocInfo::none);
 606     movdqu(Address(htbl, 8 * 16), t); //H ^ 8 * 2
 607     ret(0);
 608 
 609     bind(GFMUL);
 610     gfmul(tmp0, t);
 611 }
 612 
 613 // Multiblock and single block GHASH computation using Shift XOR reduction technique
 614 void MacroAssembler::avx_ghash(Register input_state, Register htbl,
 615     Register input_data, Register blocks) {
 616 
 617     // temporary variables to hold input data and input state
 618     const XMMRegister data = xmm1;
 619     const XMMRegister state = xmm0;
 620     // temporary variables to hold intermediate results
 621     const XMMRegister tmp0 = xmm3;
 622     const XMMRegister tmp1 = xmm4;
 623     const XMMRegister tmp2 = xmm5;
 624     const XMMRegister tmp3 = xmm6;
 625     // temporary variables to hold byte and long swap masks
 626     const XMMRegister bswap_mask = xmm2;
 627     const XMMRegister lswap_mask = xmm14;
 628 
 629     Label GENERATE_HTBL_1_BLK, GENERATE_HTBL_8_BLKS, BEGIN_PROCESS, GFMUL, BLOCK8_REDUCTION,
 630           ONE_BLK_INIT, PROCESS_1_BLOCK, PROCESS_8_BLOCKS, SAVE_STATE, EXIT_GHASH;
 631 
 632     testptr(blocks, blocks);
 633     jcc(Assembler::zero, EXIT_GHASH);
 634 
 635     // Check if Hashtable (1*16) has been already generated
 636     // For anything less than 8 blocks, we generate only the first power of H.
 637     movdqu(tmp2, Address(htbl, 1 * 16));
 638     ptest(tmp2, tmp2);
 639     jcc(Assembler::notZero, BEGIN_PROCESS);
 640     call(GENERATE_HTBL_1_BLK, relocInfo::none);
 641 
 642     // Shuffle the input state
 643     bind(BEGIN_PROCESS);
 644     movdqu(lswap_mask, ExternalAddress(StubRoutines::x86::ghash_long_swap_mask_addr()));
 645     movdqu(state, Address(input_state, 0));
 646     vpshufb(state, state, lswap_mask, Assembler::AVX_128bit);
 647 
 648     cmpl(blocks, 8);
 649     jcc(Assembler::below, ONE_BLK_INIT);
 650     // If we have 8 blocks or more data, then generate remaining powers of H
 651     movdqu(tmp2, Address(htbl, 8 * 16));
 652     ptest(tmp2, tmp2);
 653     jcc(Assembler::notZero, PROCESS_8_BLOCKS);
 654     call(GENERATE_HTBL_8_BLKS, relocInfo::none);
 655 
 656     //Do 8 multiplies followed by a reduction processing 8 blocks of data at a time
 657     //Each block = 16 bytes.
 658     bind(PROCESS_8_BLOCKS);
 659     subl(blocks, 8);
 660     movdqu(bswap_mask, ExternalAddress(StubRoutines::x86::ghash_byte_swap_mask_addr()));
 661     movdqu(data, Address(input_data, 16 * 7));
 662     vpshufb(data, data, bswap_mask, Assembler::AVX_128bit);
 663     //Loading 1*16 as calculated powers of H required starts at that location.
 664     movdqu(xmm15, Address(htbl, 1 * 16));
 665     //Perform carryless multiplication of (H*2, data block #7)
 666     vpclmulhqlqdq(tmp2, data, xmm15);//a0 * b1
 667     vpclmulldq(tmp0, data, xmm15);//a0 * b0
 668     vpclmulhdq(tmp1, data, xmm15);//a1 * b1
 669     vpclmullqhqdq(tmp3, data, xmm15);//a1* b0
 670     vpxor(tmp2, tmp2, tmp3, Assembler::AVX_128bit);// (a0 * b1) + (a1 * b0)
 671 
 672     movdqu(data, Address(input_data, 16 * 6));
 673     vpshufb(data, data, bswap_mask, Assembler::AVX_128bit);
 674     // Perform carryless multiplication of (H^2 * 2, data block #6)
 675     schoolbookAAD(2, htbl, data, tmp0, tmp1, tmp2, tmp3);
 676 
 677     movdqu(data, Address(input_data, 16 * 5));
 678     vpshufb(data, data, bswap_mask, Assembler::AVX_128bit);
 679     // Perform carryless multiplication of (H^3 * 2, data block #5)
 680     schoolbookAAD(3, htbl, data, tmp0, tmp1, tmp2, tmp3);
 681     movdqu(data, Address(input_data, 16 * 4));
 682     vpshufb(data, data, bswap_mask, Assembler::AVX_128bit);
 683     // Perform carryless multiplication of (H^4 * 2, data block #4)
 684     schoolbookAAD(4, htbl, data, tmp0, tmp1, tmp2, tmp3);
 685     movdqu(data, Address(input_data, 16 * 3));
 686     vpshufb(data, data, bswap_mask, Assembler::AVX_128bit);
 687     // Perform carryless multiplication of (H^5 * 2, data block #3)
 688     schoolbookAAD(5, htbl, data, tmp0, tmp1, tmp2, tmp3);
 689     movdqu(data, Address(input_data, 16 * 2));
 690     vpshufb(data, data, bswap_mask, Assembler::AVX_128bit);
 691     // Perform carryless multiplication of (H^6 * 2, data block #2)
 692     schoolbookAAD(6, htbl, data, tmp0, tmp1, tmp2, tmp3);
 693     movdqu(data, Address(input_data, 16 * 1));
 694     vpshufb(data, data, bswap_mask, Assembler::AVX_128bit);
 695     // Perform carryless multiplication of (H^7 * 2, data block #1)
 696     schoolbookAAD(7, htbl, data, tmp0, tmp1, tmp2, tmp3);
 697     movdqu(data, Address(input_data, 16 * 0));
 698     // xor data block#0 with input state before perfoming carry-less multiplication
 699     vpshufb(data, data, bswap_mask, Assembler::AVX_128bit);
 700     vpxor(data, data, state, Assembler::AVX_128bit);
 701     // Perform carryless multiplication of (H^8 * 2, data block #0)
 702     schoolbookAAD(8, htbl, data, tmp0, tmp1, tmp2, tmp3);
 703     vpslldq(tmp3, tmp2, 8, Assembler::AVX_128bit);
 704     vpsrldq(tmp2, tmp2, 8, Assembler::AVX_128bit);
 705     vpxor(tmp0, tmp0, tmp3, Assembler::AVX_128bit);// tmp0, tmp1 contains aggregated results of
 706     vpxor(tmp1, tmp1, tmp2, Assembler::AVX_128bit);// the multiplication operation
 707 
 708     // we have the 2 128-bit partially accumulated multiplication results in tmp0:tmp1
 709     // with higher 128-bit in tmp1 and lower 128-bit in corresponding tmp0
 710     // Follows the reduction technique mentioned in
 711     // Shift-XOR reduction described in Gueron-Kounavis May 2010
 712     bind(BLOCK8_REDUCTION);
 713     // First Phase of the reduction
 714     vpslld(xmm8, tmp0, 31, Assembler::AVX_128bit); // packed right shifting &lt;&lt; 31
 715     vpslld(xmm9, tmp0, 30, Assembler::AVX_128bit); // packed right shifting &lt;&lt; 30
 716     vpslld(xmm10, tmp0, 25, Assembler::AVX_128bit); // packed right shifting &lt;&lt; 25
 717     // xor the shifted versions
 718     vpxor(xmm8, xmm8, xmm10, Assembler::AVX_128bit);
 719     vpxor(xmm8, xmm8, xmm9, Assembler::AVX_128bit);
 720 
 721     vpslldq(xmm9, xmm8, 12, Assembler::AVX_128bit);
 722     vpsrldq(xmm8, xmm8, 4, Assembler::AVX_128bit);
 723 
 724     vpxor(tmp0, tmp0, xmm9, Assembler::AVX_128bit); // first phase of reduction is complete
 725     // second phase of the reduction
 726     vpsrld(xmm9, tmp0, 1, Assembler::AVX_128bit); // packed left shifting &gt;&gt; 1
 727     vpsrld(xmm10, tmp0, 2, Assembler::AVX_128bit); // packed left shifting &gt;&gt; 2
 728     vpsrld(tmp2, tmp0, 7, Assembler::AVX_128bit); // packed left shifting &gt;&gt; 7
 729     // xor the shifted versions
 730     vpxor(xmm9, xmm9, xmm10, Assembler::AVX_128bit);
 731     vpxor(xmm9, xmm9, tmp2, Assembler::AVX_128bit);
 732     vpxor(xmm9, xmm9, xmm8, Assembler::AVX_128bit);
 733     vpxor(tmp0, xmm9, tmp0, Assembler::AVX_128bit);
 734     // Final result is in state
 735     vpxor(state, tmp0, tmp1, Assembler::AVX_128bit);
 736 
 737     lea(input_data, Address(input_data, 16 * 8));
 738     cmpl(blocks, 8);
 739     jcc(Assembler::below, ONE_BLK_INIT);
 740     jmp(PROCESS_8_BLOCKS);
 741 
 742     // Since this is one block operation we will only use H * 2 i.e. the first power of H
 743     bind(ONE_BLK_INIT);
 744     movdqu(tmp0, Address(htbl, 1 * 16));
 745     movdqu(bswap_mask, ExternalAddress(StubRoutines::x86::ghash_byte_swap_mask_addr()));
 746 
 747     //Do one (128 bit x 128 bit) carry-less multiplication at a time followed by a reduction.
 748     bind(PROCESS_1_BLOCK);
 749     cmpl(blocks, 0);
 750     jcc(Assembler::equal, SAVE_STATE);
 751     subl(blocks, 1);
 752     movdqu(data, Address(input_data, 0));
 753     vpshufb(data, data, bswap_mask, Assembler::AVX_128bit);
 754     vpxor(state, state, data, Assembler::AVX_128bit);
 755     // gfmul(H*2, state)
 756     call(GFMUL, relocInfo::none);
 757     addptr(input_data, 16);
 758     jmp(PROCESS_1_BLOCK);
 759 
 760     bind(SAVE_STATE);
 761     vpshufb(state, state, lswap_mask, Assembler::AVX_128bit);
 762     movdqu(Address(input_state, 0), state);
 763     jmp(EXIT_GHASH);
 764 
 765     bind(GFMUL);
 766     gfmul(tmp0, state);
 767 
 768     bind(GENERATE_HTBL_1_BLK);
 769     generateHtbl_one_block(htbl);
 770 
 771     bind(GENERATE_HTBL_8_BLKS);
 772     generateHtbl_eight_blocks(htbl);
 773 
 774     bind(EXIT_GHASH);
 775     // zero out xmm registers used for Htbl storage
 776     vpxor(xmm0, xmm0, xmm0, Assembler::AVX_128bit);
 777     vpxor(xmm1, xmm1, xmm1, Assembler::AVX_128bit);
 778     vpxor(xmm3, xmm3, xmm3, Assembler::AVX_128bit);
 779     vpxor(xmm15, xmm15, xmm15, Assembler::AVX_128bit);
 780 }
<a name="3" id="anc3"></a><span class="line-added"> 781 </span>
<span class="line-added"> 782 // AES Counter Mode using VAES instructions</span>
<span class="line-added"> 783 void MacroAssembler::aesctr_encrypt(Register src_addr, Register dest_addr, Register key, Register counter,</span>
<span class="line-added"> 784     Register len_reg, Register used, Register used_addr, Register saved_encCounter_start) {</span>
<span class="line-added"> 785 </span>
<span class="line-added"> 786     const Register rounds = 0;</span>
<span class="line-added"> 787     const Register pos = r12;</span>
<span class="line-added"> 788 </span>
<span class="line-added"> 789     Label PRELOOP_START, EXIT_PRELOOP, REMAINDER, REMAINDER_16, LOOP, END, EXIT, END_LOOP,</span>
<span class="line-added"> 790     AES192, AES256, AES192_REMAINDER16, REMAINDER16_END_LOOP, AES256_REMAINDER16,</span>
<span class="line-added"> 791     REMAINDER_8, REMAINDER_4, AES192_REMAINDER8, REMAINDER_LOOP, AES256_REMINDER,</span>
<span class="line-added"> 792     AES192_REMAINDER, END_REMAINDER_LOOP, AES256_REMAINDER8, REMAINDER8_END_LOOP,</span>
<span class="line-added"> 793     AES192_REMAINDER4, AES256_REMAINDER4, AES256_REMAINDER, END_REMAINDER4, EXTRACT_TAILBYTES,</span>
<span class="line-added"> 794     EXTRACT_TAIL_4BYTES, EXTRACT_TAIL_2BYTES, EXTRACT_TAIL_1BYTE, STORE_CTR;</span>
<span class="line-added"> 795 </span>
<span class="line-added"> 796     cmpl(len_reg, 0);</span>
<span class="line-added"> 797     jcc(Assembler::belowEqual, EXIT);</span>
<span class="line-added"> 798 </span>
<span class="line-added"> 799     movl(pos, 0);</span>
<span class="line-added"> 800     // if the number of used encrypted counter bytes &lt; 16,</span>
<span class="line-added"> 801     // XOR PT with saved encrypted counter to obtain CT</span>
<span class="line-added"> 802     bind(PRELOOP_START);</span>
<span class="line-added"> 803     cmpl(used, 16);</span>
<span class="line-added"> 804     jcc(Assembler::aboveEqual, EXIT_PRELOOP);</span>
<span class="line-added"> 805     movb(rbx, Address(saved_encCounter_start, used));</span>
<span class="line-added"> 806     xorb(rbx, Address(src_addr, pos));</span>
<span class="line-added"> 807     movb(Address(dest_addr, pos), rbx);</span>
<span class="line-added"> 808     addptr(pos, 1);</span>
<span class="line-added"> 809     addptr(used, 1);</span>
<span class="line-added"> 810     decrement(len_reg);</span>
<span class="line-added"> 811     jmp(PRELOOP_START);</span>
<span class="line-added"> 812 </span>
<span class="line-added"> 813     bind(EXIT_PRELOOP);</span>
<span class="line-added"> 814     movl(Address(used_addr, 0), used);</span>
<span class="line-added"> 815 </span>
<span class="line-added"> 816     // Calculate number of rounds i.e. 10, 12, 14,  based on key length(128, 192, 256).</span>
<span class="line-added"> 817     movl(rounds, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));</span>
<span class="line-added"> 818 </span>
<span class="line-added"> 819     vpxor(xmm0, xmm0, xmm0, Assembler::AVX_128bit);</span>
<span class="line-added"> 820     // Move initial counter value in xmm0</span>
<span class="line-added"> 821     movdqu(xmm0, Address(counter, 0));</span>
<span class="line-added"> 822     // broadcast counter value to zmm8</span>
<span class="line-added"> 823     evshufi64x2(xmm8, xmm0, xmm0, 0, Assembler::AVX_512bit);</span>
<span class="line-added"> 824 </span>
<span class="line-added"> 825     // load lbswap mask</span>
<span class="line-added"> 826     evmovdquq(xmm16, ExternalAddress(StubRoutines::x86::counter_mask_addr()), Assembler::AVX_512bit, r15);</span>
<span class="line-added"> 827 </span>
<span class="line-added"> 828     //shuffle counter using lbswap_mask</span>
<span class="line-added"> 829     vpshufb(xmm8, xmm8, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 830 </span>
<span class="line-added"> 831     // pre-increment and propagate counter values to zmm9-zmm15 registers.</span>
<span class="line-added"> 832     // Linc0 increments the zmm8 by 1 (initial value being 0), Linc4 increments the counters zmm9-zmm15 by 4</span>
<span class="line-added"> 833     // The counter is incremented after each block i.e. 16 bytes is processed;</span>
<span class="line-added"> 834     // each zmm register has 4 counter values as its MSB</span>
<span class="line-added"> 835     // the counters are incremented in parallel</span>
<span class="line-added"> 836     vpaddd(xmm8, xmm8, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 64), Assembler::AVX_512bit, r15);//linc0</span>
<span class="line-added"> 837     vpaddd(xmm9, xmm8, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//linc4(rip)</span>
<span class="line-added"> 838     vpaddd(xmm10, xmm9, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="line-added"> 839     vpaddd(xmm11, xmm10, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="line-added"> 840     vpaddd(xmm12, xmm11, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="line-added"> 841     vpaddd(xmm13, xmm12, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="line-added"> 842     vpaddd(xmm14, xmm13, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="line-added"> 843     vpaddd(xmm15, xmm14, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="line-added"> 844 </span>
<span class="line-added"> 845     // load linc32 mask in zmm register.linc32 increments counter by 32</span>
<span class="line-added"> 846     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 256), Assembler::AVX_512bit, r15);//Linc32</span>
<span class="line-added"> 847 </span>
<span class="line-added"> 848     // xmm31 contains the key shuffle mask.</span>
<span class="line-added"> 849     movdqu(xmm31, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));</span>
<span class="line-added"> 850     // Load key function loads 128 bit key and shuffles it. Then we broadcast the shuffled key to convert it into a 512 bit value.</span>
<span class="line-added"> 851     // For broadcasting the values to ZMM, vshufi64 is used instead of evbroadcasti64x2 as the source in this case is ZMM register</span>
<span class="line-added"> 852     // that holds shuffled key value.</span>
<span class="line-added"> 853     ev_load_key(xmm20, key, 0, xmm31);</span>
<span class="line-added"> 854     ev_load_key(xmm21, key, 1 * 16, xmm31);</span>
<span class="line-added"> 855     ev_load_key(xmm22, key, 2 * 16, xmm31);</span>
<span class="line-added"> 856     ev_load_key(xmm23, key, 3 * 16, xmm31);</span>
<span class="line-added"> 857     ev_load_key(xmm24, key, 4 * 16, xmm31);</span>
<span class="line-added"> 858     ev_load_key(xmm25, key, 5 * 16, xmm31);</span>
<span class="line-added"> 859     ev_load_key(xmm26, key, 6 * 16, xmm31);</span>
<span class="line-added"> 860     ev_load_key(xmm27, key, 7 * 16, xmm31);</span>
<span class="line-added"> 861     ev_load_key(xmm28, key, 8 * 16, xmm31);</span>
<span class="line-added"> 862     ev_load_key(xmm29, key, 9 * 16, xmm31);</span>
<span class="line-added"> 863     ev_load_key(xmm30, key, 10 * 16, xmm31);</span>
<span class="line-added"> 864 </span>
<span class="line-added"> 865     // Process 32 blocks or 512 bytes of data</span>
<span class="line-added"> 866     bind(LOOP);</span>
<span class="line-added"> 867     cmpl(len_reg, 512);</span>
<span class="line-added"> 868     jcc(Assembler::less, REMAINDER);</span>
<span class="line-added"> 869     subq(len_reg, 512);</span>
<span class="line-added"> 870     //Shuffle counter and Exor it with roundkey1. Result is stored in zmm0-7</span>
<span class="line-added"> 871     vpshufb(xmm0, xmm8, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 872     evpxorq(xmm0, xmm0, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 873     vpshufb(xmm1, xmm9, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 874     evpxorq(xmm1, xmm1, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 875     vpshufb(xmm2, xmm10, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 876     evpxorq(xmm2, xmm2, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 877     vpshufb(xmm3, xmm11, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 878     evpxorq(xmm3, xmm3, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 879     vpshufb(xmm4, xmm12, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 880     evpxorq(xmm4, xmm4, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 881     vpshufb(xmm5, xmm13, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 882     evpxorq(xmm5, xmm5, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 883     vpshufb(xmm6, xmm14, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 884     evpxorq(xmm6, xmm6, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 885     vpshufb(xmm7, xmm15, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 886     evpxorq(xmm7, xmm7, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 887     // Perform AES encode operations and put results in zmm0-zmm7.</span>
<span class="line-added"> 888     // This is followed by incrementing counter values in zmm8-zmm15.</span>
<span class="line-added"> 889     // Since we will be processing 32 blocks at a time, the counter is incremented by 32.</span>
<span class="line-added"> 890     roundEnc(xmm21, 7);</span>
<span class="line-added"> 891     vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added"> 892     roundEnc(xmm22, 7);</span>
<span class="line-added"> 893     vpaddq(xmm9, xmm9, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added"> 894     roundEnc(xmm23, 7);</span>
<span class="line-added"> 895     vpaddq(xmm10, xmm10, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added"> 896     roundEnc(xmm24, 7);</span>
<span class="line-added"> 897     vpaddq(xmm11, xmm11, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added"> 898     roundEnc(xmm25, 7);</span>
<span class="line-added"> 899     vpaddq(xmm12, xmm12, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added"> 900     roundEnc(xmm26, 7);</span>
<span class="line-added"> 901     vpaddq(xmm13, xmm13, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added"> 902     roundEnc(xmm27, 7);</span>
<span class="line-added"> 903     vpaddq(xmm14, xmm14, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added"> 904     roundEnc(xmm28, 7);</span>
<span class="line-added"> 905     vpaddq(xmm15, xmm15, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added"> 906     roundEnc(xmm29, 7);</span>
<span class="line-added"> 907 </span>
<span class="line-added"> 908     cmpl(rounds, 52);</span>
<span class="line-added"> 909     jcc(Assembler::aboveEqual, AES192);</span>
<span class="line-added"> 910     lastroundEnc(xmm30, 7);</span>
<span class="line-added"> 911     jmp(END_LOOP);</span>
<span class="line-added"> 912 </span>
<span class="line-added"> 913     bind(AES192);</span>
<span class="line-added"> 914     roundEnc(xmm30, 7);</span>
<span class="line-added"> 915     ev_load_key(xmm18, key, 11 * 16, xmm31);</span>
<span class="line-added"> 916     roundEnc(xmm18, 7);</span>
<span class="line-added"> 917     cmpl(rounds, 60);</span>
<span class="line-added"> 918     jcc(Assembler::aboveEqual, AES256);</span>
<span class="line-added"> 919     ev_load_key(xmm18, key, 12 * 16, xmm31);</span>
<span class="line-added"> 920     lastroundEnc(xmm18, 7);</span>
<span class="line-added"> 921     jmp(END_LOOP);</span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923     bind(AES256);</span>
<span class="line-added"> 924     ev_load_key(xmm18, key, 12 * 16, xmm31);</span>
<span class="line-added"> 925     roundEnc(xmm18, 7);</span>
<span class="line-added"> 926     ev_load_key(xmm18, key, 13 * 16, xmm31);</span>
<span class="line-added"> 927     roundEnc(xmm18, 7);</span>
<span class="line-added"> 928     ev_load_key(xmm18, key, 14 * 16, xmm31);</span>
<span class="line-added"> 929     lastroundEnc(xmm18, 7);</span>
<span class="line-added"> 930 </span>
<span class="line-added"> 931     // After AES encode rounds, the encrypted block cipher lies in zmm0-zmm7</span>
<span class="line-added"> 932     // xor encrypted block cipher and input plaintext and store resultant ciphertext</span>
<span class="line-added"> 933     bind(END_LOOP);</span>
<span class="line-added"> 934     evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 935     evmovdquq(Address(dest_addr, pos, Address::times_1, 0), xmm0, Assembler::AVX_512bit);</span>
<span class="line-added"> 936     evpxorq(xmm1, xmm1, Address(src_addr, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 937     evmovdquq(Address(dest_addr, pos, Address::times_1, 64), xmm1, Assembler::AVX_512bit);</span>
<span class="line-added"> 938     evpxorq(xmm2, xmm2, Address(src_addr, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 939     evmovdquq(Address(dest_addr, pos, Address::times_1, 2 * 64), xmm2, Assembler::AVX_512bit);</span>
<span class="line-added"> 940     evpxorq(xmm3, xmm3, Address(src_addr, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 941     evmovdquq(Address(dest_addr, pos, Address::times_1, 3 * 64), xmm3, Assembler::AVX_512bit);</span>
<span class="line-added"> 942     evpxorq(xmm4, xmm4, Address(src_addr, pos, Address::times_1, 4 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 943     evmovdquq(Address(dest_addr, pos, Address::times_1, 4 * 64), xmm4, Assembler::AVX_512bit);</span>
<span class="line-added"> 944     evpxorq(xmm5, xmm5, Address(src_addr, pos, Address::times_1, 5 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 945     evmovdquq(Address(dest_addr, pos, Address::times_1, 5 * 64), xmm5, Assembler::AVX_512bit);</span>
<span class="line-added"> 946     evpxorq(xmm6, xmm6, Address(src_addr, pos, Address::times_1, 6 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 947     evmovdquq(Address(dest_addr, pos, Address::times_1, 6 * 64), xmm6, Assembler::AVX_512bit);</span>
<span class="line-added"> 948     evpxorq(xmm7, xmm7, Address(src_addr, pos, Address::times_1, 7 * 64), Assembler::AVX_512bit);</span>
<span class="line-added"> 949     evmovdquq(Address(dest_addr, pos, Address::times_1, 7 * 64), xmm7, Assembler::AVX_512bit);</span>
<span class="line-added"> 950     addq(pos, 512);</span>
<span class="line-added"> 951     jmp(LOOP);</span>
<span class="line-added"> 952 </span>
<span class="line-added"> 953     // Encode 256, 128, 64 or 16 bytes at a time if length is less than 512 bytes</span>
<span class="line-added"> 954     bind(REMAINDER);</span>
<span class="line-added"> 955     cmpl(len_reg, 0);</span>
<span class="line-added"> 956     jcc(Assembler::equal, END);</span>
<span class="line-added"> 957     cmpl(len_reg, 256);</span>
<span class="line-added"> 958     jcc(Assembler::aboveEqual, REMAINDER_16);</span>
<span class="line-added"> 959     cmpl(len_reg, 128);</span>
<span class="line-added"> 960     jcc(Assembler::aboveEqual, REMAINDER_8);</span>
<span class="line-added"> 961     cmpl(len_reg, 64);</span>
<span class="line-added"> 962     jcc(Assembler::aboveEqual, REMAINDER_4);</span>
<span class="line-added"> 963     // At this point, we will process 16 bytes of data at a time.</span>
<span class="line-added"> 964     // So load xmm19 with counter increment value as 1</span>
<span class="line-added"> 965     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 80), Assembler::AVX_128bit, r15);</span>
<span class="line-added"> 966     jmp(REMAINDER_LOOP);</span>
<span class="line-added"> 967 </span>
<span class="line-added"> 968     // Each ZMM register can be used to encode 64 bytes of data, so we have 4 ZMM registers to encode 256 bytes of data</span>
<span class="line-added"> 969     bind(REMAINDER_16);</span>
<span class="line-added"> 970     subq(len_reg, 256);</span>
<span class="line-added"> 971     // As we process 16 blocks at a time, load mask for incrementing the counter value by 16</span>
<span class="line-added"> 972     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 320), Assembler::AVX_512bit, r15);//Linc16(rip)</span>
<span class="line-added"> 973     // shuffle counter and XOR counter with roundkey1</span>
<span class="line-added"> 974     vpshufb(xmm0, xmm8, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 975     evpxorq(xmm0, xmm0, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 976     vpshufb(xmm1, xmm9, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 977     evpxorq(xmm1, xmm1, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 978     vpshufb(xmm2, xmm10, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 979     evpxorq(xmm2, xmm2, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 980     vpshufb(xmm3, xmm11, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added"> 981     evpxorq(xmm3, xmm3, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added"> 982     // Increment counter values by 16</span>
<span class="line-added"> 983     vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added"> 984     vpaddq(xmm9, xmm9, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added"> 985     // AES encode rounds</span>
<span class="line-added"> 986     roundEnc(xmm21, 3);</span>
<span class="line-added"> 987     roundEnc(xmm22, 3);</span>
<span class="line-added"> 988     roundEnc(xmm23, 3);</span>
<span class="line-added"> 989     roundEnc(xmm24, 3);</span>
<span class="line-added"> 990     roundEnc(xmm25, 3);</span>
<span class="line-added"> 991     roundEnc(xmm26, 3);</span>
<span class="line-added"> 992     roundEnc(xmm27, 3);</span>
<span class="line-added"> 993     roundEnc(xmm28, 3);</span>
<span class="line-added"> 994     roundEnc(xmm29, 3);</span>
<span class="line-added"> 995 </span>
<span class="line-added"> 996     cmpl(rounds, 52);</span>
<span class="line-added"> 997     jcc(Assembler::aboveEqual, AES192_REMAINDER16);</span>
<span class="line-added"> 998     lastroundEnc(xmm30, 3);</span>
<span class="line-added"> 999     jmp(REMAINDER16_END_LOOP);</span>
<span class="line-added">1000 </span>
<span class="line-added">1001     bind(AES192_REMAINDER16);</span>
<span class="line-added">1002     roundEnc(xmm30, 3);</span>
<span class="line-added">1003     ev_load_key(xmm18, key, 11 * 16, xmm31);</span>
<span class="line-added">1004     roundEnc(xmm18, 3);</span>
<span class="line-added">1005     ev_load_key(xmm5, key, 12 * 16, xmm31);</span>
<span class="line-added">1006 </span>
<span class="line-added">1007     cmpl(rounds, 60);</span>
<span class="line-added">1008     jcc(Assembler::aboveEqual, AES256_REMAINDER16);</span>
<span class="line-added">1009     lastroundEnc(xmm5, 3);</span>
<span class="line-added">1010     jmp(REMAINDER16_END_LOOP);</span>
<span class="line-added">1011     bind(AES256_REMAINDER16);</span>
<span class="line-added">1012     roundEnc(xmm5, 3);</span>
<span class="line-added">1013     ev_load_key(xmm6, key, 13 * 16, xmm31);</span>
<span class="line-added">1014     roundEnc(xmm6, 3);</span>
<span class="line-added">1015     ev_load_key(xmm7, key, 14 * 16, xmm31);</span>
<span class="line-added">1016     lastroundEnc(xmm7, 3);</span>
<span class="line-added">1017 </span>
<span class="line-added">1018     // After AES encode rounds, the encrypted block cipher lies in zmm0-zmm3</span>
<span class="line-added">1019     // xor 256 bytes of PT with the encrypted counters to produce CT.</span>
<span class="line-added">1020     bind(REMAINDER16_END_LOOP);</span>
<span class="line-added">1021     evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0), Assembler::AVX_512bit);</span>
<span class="line-added">1022     evmovdquq(Address(dest_addr, pos, Address::times_1, 0), xmm0, Assembler::AVX_512bit);</span>
<span class="line-added">1023     evpxorq(xmm1, xmm1, Address(src_addr, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);</span>
<span class="line-added">1024     evmovdquq(Address(dest_addr, pos, Address::times_1, 1 * 64), xmm1, Assembler::AVX_512bit);</span>
<span class="line-added">1025     evpxorq(xmm2, xmm2, Address(src_addr, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);</span>
<span class="line-added">1026     evmovdquq(Address(dest_addr, pos, Address::times_1, 2 * 64), xmm2, Assembler::AVX_512bit);</span>
<span class="line-added">1027     evpxorq(xmm3, xmm3, Address(src_addr, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);</span>
<span class="line-added">1028     evmovdquq(Address(dest_addr, pos, Address::times_1, 3 * 64), xmm3, Assembler::AVX_512bit);</span>
<span class="line-added">1029     addq(pos, 256);</span>
<span class="line-added">1030 </span>
<span class="line-added">1031     cmpl(len_reg, 128);</span>
<span class="line-added">1032     jcc(Assembler::aboveEqual, REMAINDER_8);</span>
<span class="line-added">1033 </span>
<span class="line-added">1034     cmpl(len_reg, 64);</span>
<span class="line-added">1035     jcc(Assembler::aboveEqual, REMAINDER_4);</span>
<span class="line-added">1036     //load mask for incrementing the counter value by 1</span>
<span class="line-added">1037     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 80), Assembler::AVX_128bit, r15);//Linc0 + 16(rip)</span>
<span class="line-added">1038     jmp(REMAINDER_LOOP);</span>
<span class="line-added">1039 </span>
<span class="line-added">1040     // Each ZMM register can be used to encode 64 bytes of data, so we have 2 ZMM registers to encode 128 bytes of data</span>
<span class="line-added">1041     bind(REMAINDER_8);</span>
<span class="line-added">1042     subq(len_reg, 128);</span>
<span class="line-added">1043     // As we process 8 blocks at a time, load mask for incrementing the counter value by 8</span>
<span class="line-added">1044     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 192), Assembler::AVX_512bit, r15);//Linc8(rip)</span>
<span class="line-added">1045     // shuffle counters and xor with roundkey1</span>
<span class="line-added">1046     vpshufb(xmm0, xmm8, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added">1047     evpxorq(xmm0, xmm0, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added">1048     vpshufb(xmm1, xmm9, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added">1049     evpxorq(xmm1, xmm1, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added">1050     // increment counter by 8</span>
<span class="line-added">1051     vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added">1052     // AES encode</span>
<span class="line-added">1053     roundEnc(xmm21, 1);</span>
<span class="line-added">1054     roundEnc(xmm22, 1);</span>
<span class="line-added">1055     roundEnc(xmm23, 1);</span>
<span class="line-added">1056     roundEnc(xmm24, 1);</span>
<span class="line-added">1057     roundEnc(xmm25, 1);</span>
<span class="line-added">1058     roundEnc(xmm26, 1);</span>
<span class="line-added">1059     roundEnc(xmm27, 1);</span>
<span class="line-added">1060     roundEnc(xmm28, 1);</span>
<span class="line-added">1061     roundEnc(xmm29, 1);</span>
<span class="line-added">1062 </span>
<span class="line-added">1063     cmpl(rounds, 52);</span>
<span class="line-added">1064     jcc(Assembler::aboveEqual, AES192_REMAINDER8);</span>
<span class="line-added">1065     lastroundEnc(xmm30, 1);</span>
<span class="line-added">1066     jmp(REMAINDER8_END_LOOP);</span>
<span class="line-added">1067 </span>
<span class="line-added">1068     bind(AES192_REMAINDER8);</span>
<span class="line-added">1069     roundEnc(xmm30, 1);</span>
<span class="line-added">1070     ev_load_key(xmm18, key, 11 * 16, xmm31);</span>
<span class="line-added">1071     roundEnc(xmm18, 1);</span>
<span class="line-added">1072     ev_load_key(xmm5, key, 12 * 16, xmm31);</span>
<span class="line-added">1073     cmpl(rounds, 60);</span>
<span class="line-added">1074     jcc(Assembler::aboveEqual, AES256_REMAINDER8);</span>
<span class="line-added">1075     lastroundEnc(xmm5, 1);</span>
<span class="line-added">1076     jmp(REMAINDER8_END_LOOP);</span>
<span class="line-added">1077 </span>
<span class="line-added">1078     bind(AES256_REMAINDER8);</span>
<span class="line-added">1079     roundEnc(xmm5, 1);</span>
<span class="line-added">1080     ev_load_key(xmm6, key, 13 * 16, xmm31);</span>
<span class="line-added">1081     roundEnc(xmm6, 1);</span>
<span class="line-added">1082     ev_load_key(xmm7, key, 14 * 16, xmm31);</span>
<span class="line-added">1083     lastroundEnc(xmm7, 1);</span>
<span class="line-added">1084 </span>
<span class="line-added">1085     bind(REMAINDER8_END_LOOP);</span>
<span class="line-added">1086     // After AES encode rounds, the encrypted block cipher lies in zmm0-zmm1</span>
<span class="line-added">1087     // XOR PT with the encrypted counter and store as CT</span>
<span class="line-added">1088     evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);</span>
<span class="line-added">1089     evmovdquq(Address(dest_addr, pos, Address::times_1, 0 * 64), xmm0, Assembler::AVX_512bit);</span>
<span class="line-added">1090     evpxorq(xmm1, xmm1, Address(src_addr, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);</span>
<span class="line-added">1091     evmovdquq(Address(dest_addr, pos, Address::times_1, 1 * 64), xmm1, Assembler::AVX_512bit);</span>
<span class="line-added">1092     addq(pos, 128);</span>
<span class="line-added">1093 </span>
<span class="line-added">1094     cmpl(len_reg, 64);</span>
<span class="line-added">1095     jcc(Assembler::aboveEqual, REMAINDER_4);</span>
<span class="line-added">1096     // load mask for incrementing the counter value by 1</span>
<span class="line-added">1097     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 80), Assembler::AVX_128bit, r15);//Linc0 + 16(rip)</span>
<span class="line-added">1098     jmp(REMAINDER_LOOP);</span>
<span class="line-added">1099 </span>
<span class="line-added">1100     // Each ZMM register can be used to encode 64 bytes of data, so we have 1 ZMM register used in this block of code</span>
<span class="line-added">1101     bind(REMAINDER_4);</span>
<span class="line-added">1102     subq(len_reg, 64);</span>
<span class="line-added">1103     // As we process 4 blocks at a time, load mask for incrementing the counter value by 4</span>
<span class="line-added">1104     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="line-added">1105     // XOR counter with first roundkey</span>
<span class="line-added">1106     vpshufb(xmm0, xmm8, xmm16, Assembler::AVX_512bit);</span>
<span class="line-added">1107     evpxorq(xmm0, xmm0, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added">1108     // Increment counter</span>
<span class="line-added">1109     vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);</span>
<span class="line-added">1110     vaesenc(xmm0, xmm0, xmm21, Assembler::AVX_512bit);</span>
<span class="line-added">1111     vaesenc(xmm0, xmm0, xmm22, Assembler::AVX_512bit);</span>
<span class="line-added">1112     vaesenc(xmm0, xmm0, xmm23, Assembler::AVX_512bit);</span>
<span class="line-added">1113     vaesenc(xmm0, xmm0, xmm24, Assembler::AVX_512bit);</span>
<span class="line-added">1114     vaesenc(xmm0, xmm0, xmm25, Assembler::AVX_512bit);</span>
<span class="line-added">1115     vaesenc(xmm0, xmm0, xmm26, Assembler::AVX_512bit);</span>
<span class="line-added">1116     vaesenc(xmm0, xmm0, xmm27, Assembler::AVX_512bit);</span>
<span class="line-added">1117     vaesenc(xmm0, xmm0, xmm28, Assembler::AVX_512bit);</span>
<span class="line-added">1118     vaesenc(xmm0, xmm0, xmm29, Assembler::AVX_512bit);</span>
<span class="line-added">1119     cmpl(rounds, 52);</span>
<span class="line-added">1120     jcc(Assembler::aboveEqual, AES192_REMAINDER4);</span>
<span class="line-added">1121     vaesenclast(xmm0, xmm0, xmm30, Assembler::AVX_512bit);</span>
<span class="line-added">1122     jmp(END_REMAINDER4);</span>
<span class="line-added">1123 </span>
<span class="line-added">1124     bind(AES192_REMAINDER4);</span>
<span class="line-added">1125     vaesenc(xmm0, xmm0, xmm30, Assembler::AVX_512bit);</span>
<span class="line-added">1126     ev_load_key(xmm18, key, 11 * 16, xmm31);</span>
<span class="line-added">1127     vaesenc(xmm0, xmm0, xmm18, Assembler::AVX_512bit);</span>
<span class="line-added">1128     ev_load_key(xmm5, key, 12 * 16, xmm31);</span>
<span class="line-added">1129 </span>
<span class="line-added">1130     cmpl(rounds, 60);</span>
<span class="line-added">1131     jcc(Assembler::aboveEqual, AES256_REMAINDER4);</span>
<span class="line-added">1132     vaesenclast(xmm0, xmm0, xmm5, Assembler::AVX_512bit);</span>
<span class="line-added">1133     jmp(END_REMAINDER4);</span>
<span class="line-added">1134 </span>
<span class="line-added">1135     bind(AES256_REMAINDER4);</span>
<span class="line-added">1136     vaesenc(xmm0, xmm0, xmm5, Assembler::AVX_512bit);</span>
<span class="line-added">1137     ev_load_key(xmm6, key, 13 * 16, xmm31);</span>
<span class="line-added">1138     vaesenc(xmm0, xmm0, xmm6, Assembler::AVX_512bit);</span>
<span class="line-added">1139     ev_load_key(xmm7, key, 14 * 16, xmm31);</span>
<span class="line-added">1140     vaesenclast(xmm0, xmm0, xmm7, Assembler::AVX_512bit);</span>
<span class="line-added">1141     // After AES encode rounds, the encrypted block cipher lies in zmm0.</span>
<span class="line-added">1142     // XOR encrypted block cipher with PT and store 64 bytes of ciphertext</span>
<span class="line-added">1143     bind(END_REMAINDER4);</span>
<span class="line-added">1144     evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);</span>
<span class="line-added">1145     evmovdquq(Address(dest_addr, pos, Address::times_1, 0), xmm0, Assembler::AVX_512bit);</span>
<span class="line-added">1146     addq(pos, 64);</span>
<span class="line-added">1147     // load mask for incrementing the counter value by 1</span>
<span class="line-added">1148     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 80), Assembler::AVX_128bit, r15);//Linc0 + 16(rip)</span>
<span class="line-added">1149 </span>
<span class="line-added">1150     // For a single block, the AES rounds start here.</span>
<span class="line-added">1151     bind(REMAINDER_LOOP);</span>
<span class="line-added">1152     cmpl(len_reg, 0);</span>
<span class="line-added">1153     jcc(Assembler::belowEqual, END);</span>
<span class="line-added">1154     // XOR counter with first roundkey</span>
<span class="line-added">1155     vpshufb(xmm0, xmm8, xmm16, Assembler::AVX_128bit);</span>
<span class="line-added">1156     evpxorq(xmm0, xmm0, xmm20, Assembler::AVX_128bit);</span>
<span class="line-added">1157     vaesenc(xmm0, xmm0, xmm21, Assembler::AVX_128bit);</span>
<span class="line-added">1158     // Increment counter by 1</span>
<span class="line-added">1159     vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_128bit);</span>
<span class="line-added">1160     vaesenc(xmm0, xmm0, xmm22, Assembler::AVX_128bit);</span>
<span class="line-added">1161     vaesenc(xmm0, xmm0, xmm23, Assembler::AVX_128bit);</span>
<span class="line-added">1162     vaesenc(xmm0, xmm0, xmm24, Assembler::AVX_128bit);</span>
<span class="line-added">1163     vaesenc(xmm0, xmm0, xmm25, Assembler::AVX_128bit);</span>
<span class="line-added">1164     vaesenc(xmm0, xmm0, xmm26, Assembler::AVX_128bit);</span>
<span class="line-added">1165     vaesenc(xmm0, xmm0, xmm27, Assembler::AVX_128bit);</span>
<span class="line-added">1166     vaesenc(xmm0, xmm0, xmm28, Assembler::AVX_128bit);</span>
<span class="line-added">1167     vaesenc(xmm0, xmm0, xmm29, Assembler::AVX_128bit);</span>
<span class="line-added">1168 </span>
<span class="line-added">1169     cmpl(rounds, 52);</span>
<span class="line-added">1170     jcc(Assembler::aboveEqual, AES192_REMAINDER);</span>
<span class="line-added">1171     vaesenclast(xmm0, xmm0, xmm30, Assembler::AVX_128bit);</span>
<span class="line-added">1172     jmp(END_REMAINDER_LOOP);</span>
<span class="line-added">1173 </span>
<span class="line-added">1174     bind(AES192_REMAINDER);</span>
<span class="line-added">1175     vaesenc(xmm0, xmm0, xmm30, Assembler::AVX_128bit);</span>
<span class="line-added">1176     ev_load_key(xmm18, key, 11 * 16, xmm31);</span>
<span class="line-added">1177     vaesenc(xmm0, xmm0, xmm18, Assembler::AVX_128bit);</span>
<span class="line-added">1178     ev_load_key(xmm5, key, 12 * 16, xmm31);</span>
<span class="line-added">1179     cmpl(rounds, 60);</span>
<span class="line-added">1180     jcc(Assembler::aboveEqual, AES256_REMAINDER);</span>
<span class="line-added">1181     vaesenclast(xmm0, xmm0, xmm5, Assembler::AVX_128bit);</span>
<span class="line-added">1182     jmp(END_REMAINDER_LOOP);</span>
<span class="line-added">1183 </span>
<span class="line-added">1184     bind(AES256_REMAINDER);</span>
<span class="line-added">1185     vaesenc(xmm0, xmm0, xmm5, Assembler::AVX_128bit);</span>
<span class="line-added">1186     ev_load_key(xmm6, key, 13 * 16, xmm31);</span>
<span class="line-added">1187     vaesenc(xmm0, xmm0, xmm6, Assembler::AVX_128bit);</span>
<span class="line-added">1188     ev_load_key(xmm7, key, 14 * 16, xmm31);</span>
<span class="line-added">1189     vaesenclast(xmm0, xmm0, xmm7, Assembler::AVX_128bit);</span>
<span class="line-added">1190 </span>
<span class="line-added">1191     bind(END_REMAINDER_LOOP);</span>
<span class="line-added">1192     // If the length register is less than the blockSize i.e. 16</span>
<span class="line-added">1193     // then we store only those bytes of the CT to the destination</span>
<span class="line-added">1194     // corresponding to the length register value</span>
<span class="line-added">1195     // extracting the exact number of bytes is handled by EXTRACT_TAILBYTES</span>
<span class="line-added">1196     cmpl(len_reg, 16);</span>
<span class="line-added">1197     jcc(Assembler::less, EXTRACT_TAILBYTES);</span>
<span class="line-added">1198     subl(len_reg, 16);</span>
<span class="line-added">1199     // After AES encode rounds, the encrypted block cipher lies in xmm0.</span>
<span class="line-added">1200     // If the length register is equal to 16 bytes, store CT in dest after XOR operation.</span>
<span class="line-added">1201     evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0), Assembler::AVX_128bit);</span>
<span class="line-added">1202     evmovdquq(Address(dest_addr, pos, Address::times_1, 0), xmm0, Assembler::AVX_128bit);</span>
<span class="line-added">1203     addl(pos, 16);</span>
<span class="line-added">1204 </span>
<span class="line-added">1205     jmp(REMAINDER_LOOP);</span>
<span class="line-added">1206 </span>
<span class="line-added">1207     bind(EXTRACT_TAILBYTES);</span>
<span class="line-added">1208     // Save encrypted counter value in xmm0 for next invocation, before XOR operation</span>
<span class="line-added">1209     movdqu(Address(saved_encCounter_start, 0), xmm0);</span>
<span class="line-added">1210     // XOR encryted block cipher in xmm0 with PT to produce CT</span>
<span class="line-added">1211     evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0), Assembler::AVX_128bit);</span>
<span class="line-added">1212     // extract upto 15 bytes of CT from xmm0 as specified by length register</span>
<span class="line-added">1213     testptr(len_reg, 8);</span>
<span class="line-added">1214     jcc(Assembler::zero, EXTRACT_TAIL_4BYTES);</span>
<span class="line-added">1215     pextrq(Address(dest_addr, pos), xmm0, 0);</span>
<span class="line-added">1216     psrldq(xmm0, 8);</span>
<span class="line-added">1217     addl(pos, 8);</span>
<span class="line-added">1218     bind(EXTRACT_TAIL_4BYTES);</span>
<span class="line-added">1219     testptr(len_reg, 4);</span>
<span class="line-added">1220     jcc(Assembler::zero, EXTRACT_TAIL_2BYTES);</span>
<span class="line-added">1221     pextrd(Address(dest_addr, pos), xmm0, 0);</span>
<span class="line-added">1222     psrldq(xmm0, 4);</span>
<span class="line-added">1223     addq(pos, 4);</span>
<span class="line-added">1224     bind(EXTRACT_TAIL_2BYTES);</span>
<span class="line-added">1225     testptr(len_reg, 2);</span>
<span class="line-added">1226     jcc(Assembler::zero, EXTRACT_TAIL_1BYTE);</span>
<span class="line-added">1227     pextrw(Address(dest_addr, pos), xmm0, 0);</span>
<span class="line-added">1228     psrldq(xmm0, 2);</span>
<span class="line-added">1229     addl(pos, 2);</span>
<span class="line-added">1230     bind(EXTRACT_TAIL_1BYTE);</span>
<span class="line-added">1231     testptr(len_reg, 1);</span>
<span class="line-added">1232     jcc(Assembler::zero, END);</span>
<span class="line-added">1233     pextrb(Address(dest_addr, pos), xmm0, 0);</span>
<span class="line-added">1234     addl(pos, 1);</span>
<span class="line-added">1235 </span>
<span class="line-added">1236     bind(END);</span>
<span class="line-added">1237     // If there are no tail bytes, store counter value and exit</span>
<span class="line-added">1238     cmpl(len_reg, 0);</span>
<span class="line-added">1239     jcc(Assembler::equal, STORE_CTR);</span>
<span class="line-added">1240     movl(Address(used_addr, 0), len_reg);</span>
<span class="line-added">1241 </span>
<span class="line-added">1242     bind(STORE_CTR);</span>
<span class="line-added">1243     //shuffle updated counter and store it</span>
<span class="line-added">1244     vpshufb(xmm8, xmm8, xmm16, Assembler::AVX_128bit);</span>
<span class="line-added">1245     movdqu(Address(counter, 0), xmm8);</span>
<span class="line-added">1246     // Zero out counter and key registers</span>
<span class="line-added">1247     evpxorq(xmm8, xmm8, xmm8, Assembler::AVX_512bit);</span>
<span class="line-added">1248     evpxorq(xmm20, xmm20, xmm20, Assembler::AVX_512bit);</span>
<span class="line-added">1249     evpxorq(xmm21, xmm21, xmm21, Assembler::AVX_512bit);</span>
<span class="line-added">1250     evpxorq(xmm22, xmm22, xmm22, Assembler::AVX_512bit);</span>
<span class="line-added">1251     evpxorq(xmm23, xmm23, xmm23, Assembler::AVX_512bit);</span>
<span class="line-added">1252     evpxorq(xmm24, xmm24, xmm24, Assembler::AVX_512bit);</span>
<span class="line-added">1253     evpxorq(xmm25, xmm25, xmm25, Assembler::AVX_512bit);</span>
<span class="line-added">1254     evpxorq(xmm26, xmm26, xmm26, Assembler::AVX_512bit);</span>
<span class="line-added">1255     evpxorq(xmm27, xmm27, xmm27, Assembler::AVX_512bit);</span>
<span class="line-added">1256     evpxorq(xmm28, xmm28, xmm28, Assembler::AVX_512bit);</span>
<span class="line-added">1257     evpxorq(xmm29, xmm29, xmm29, Assembler::AVX_512bit);</span>
<span class="line-added">1258     evpxorq(xmm30, xmm30, xmm30, Assembler::AVX_512bit);</span>
<span class="line-added">1259     cmpl(rounds, 44);</span>
<span class="line-added">1260     jcc(Assembler::belowEqual, EXIT);</span>
<span class="line-added">1261     evpxorq(xmm18, xmm18, xmm18, Assembler::AVX_512bit);</span>
<span class="line-added">1262     evpxorq(xmm5, xmm5, xmm5, Assembler::AVX_512bit);</span>
<span class="line-added">1263     cmpl(rounds, 52);</span>
<span class="line-added">1264     jcc(Assembler::belowEqual, EXIT);</span>
<span class="line-added">1265     evpxorq(xmm6, xmm6, xmm6, Assembler::AVX_512bit);</span>
<span class="line-added">1266     evpxorq(xmm7, xmm7, xmm7, Assembler::AVX_512bit);</span>
<span class="line-added">1267     bind(EXIT);</span>
<span class="line-added">1268 }</span>
<span class="line-added">1269 </span>
1270 #endif // _LP64
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
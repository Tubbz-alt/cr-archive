<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRAssembler_x86.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LinearScan_x86.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -34,10 +34,11 @@</span>
  #include &quot;ci/ciObjArrayKlass.hpp&quot;
  #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;vmreg_x86.inline.hpp&quot;
  
  #ifdef ASSERT
  #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  #else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -384,10 +385,46 @@</span>
    LIR_Opr tmp = LIR_OprFact::illegalOpr;
    if (x-&gt;is_strictfp() &amp;&amp; (x-&gt;op() == Bytecodes::_dmul || x-&gt;op() == Bytecodes::_ddiv)) {
      tmp = new_register(T_DOUBLE);
    }
  
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+   if (x-&gt;op() == Bytecodes::_frem || x-&gt;op() == Bytecodes::_drem) {</span>
<span class="udiff-line-added">+     // frem and drem are implemented as a direct call into the runtime.</span>
<span class="udiff-line-added">+     LIRItem left(x-&gt;x(), this);</span>
<span class="udiff-line-added">+     LIRItem right(x-&gt;y(), this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     BasicType bt = as_BasicType(x-&gt;type());</span>
<span class="udiff-line-added">+     BasicTypeList signature(2);</span>
<span class="udiff-line-added">+     signature.append(bt);</span>
<span class="udiff-line-added">+     signature.append(bt);</span>
<span class="udiff-line-added">+     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const LIR_Opr result_reg = result_register_for(x-&gt;type());</span>
<span class="udiff-line-added">+     left.load_item_force(cc-&gt;at(0));</span>
<span class="udiff-line-added">+     right.load_item_force(cc-&gt;at(1));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     address entry = NULL;</span>
<span class="udiff-line-added">+     switch (x-&gt;op()) {</span>
<span class="udiff-line-added">+       case Bytecodes::_frem:</span>
<span class="udiff-line-added">+         entry = CAST_FROM_FN_PTR(address, SharedRuntime::frem);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       case Bytecodes::_drem:</span>
<span class="udiff-line-added">+         entry = CAST_FROM_FN_PTR(address, SharedRuntime::drem);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       default:</span>
<span class="udiff-line-added">+         ShouldNotReachHere();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     LIR_Opr result = rlock_result(x);</span>
<span class="udiff-line-added">+     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());</span>
<span class="udiff-line-added">+     __ move(result_reg, result);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);</span>
<span class="udiff-line-added">+     set_result(x, round_item(reg));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #else</span>
    if ((UseSSE &gt;= 1 &amp;&amp; x-&gt;op() == Bytecodes::_frem) || (UseSSE &gt;= 2 &amp;&amp; x-&gt;op() == Bytecodes::_drem)) {
      // special handling for frem and drem: no SSE instruction, so must use FPU with temporary fpu stack slots
      LIR_Opr fpu0, fpu1;
      if (x-&gt;op() == Bytecodes::_frem) {
        fpu0 = LIR_OprFact::single_fpu(0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -402,12 +439,12 @@</span>
      __ move(fpu0, reg);
  
    } else {
      arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
    }
<span class="udiff-line-removed">- </span>
    set_result(x, round_item(reg));
<span class="udiff-line-added">+ #endif // _LP64</span>
  }
  
  
  // for  _ladd, _lmul, _lsub, _ldiv, _lrem
  void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -442,13 +479,10 @@</span>
        entry = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
        break; // check if dividend is 0 is done elsewhere
      case Bytecodes::_ldiv:
        entry = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
        break; // check if dividend is 0 is done elsewhere
<span class="udiff-line-removed">-     case Bytecodes::_lmul:</span>
<span class="udiff-line-removed">-       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lmul);</span>
<span class="udiff-line-removed">-       break;</span>
      default:
        ShouldNotReachHere();
      }
  
      LIR_Opr result = rlock_result(x);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -669,11 +703,11 @@</span>
    }
  }
  
  LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
    LIR_Opr ill = LIR_OprFact::illegalOpr;  // for convenience
<span class="udiff-line-modified-removed">-   if (type == T_OBJECT || type == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(type)) {</span>
      cmp_value.load_item_force(FrameMap::rax_oop_opr);
      new_value.load_item();
      __ cas_obj(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
    } else if (type == T_INT) {
      cmp_value.load_item_force(FrameMap::rax_opr);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -691,11 +725,11 @@</span>
             result, T_INT);
    return result;
  }
  
  LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
<span class="udiff-line-modified-removed">-   bool is_oop = type == T_OBJECT || type == T_ARRAY;</span>
<span class="udiff-line-modified-added">+   bool is_oop = is_reference_type(type);</span>
    LIR_Opr result = new_register(type);
    value.load_item();
    // Because we want a 2-arg form of xchg and xadd
    __ move(value.result(), result);
    assert(type == T_INT || is_oop LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1143,10 +1177,19 @@</span>
      default:       ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
    }
  }
  
  void LIRGenerator::do_Convert(Convert* x) {
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+   LIRItem value(x-&gt;value(), this);</span>
<span class="udiff-line-added">+   value.load_item();</span>
<span class="udiff-line-added">+   LIR_Opr input = value.result();</span>
<span class="udiff-line-added">+   LIR_Opr result = rlock(x);</span>
<span class="udiff-line-added">+   __ convert(x-&gt;op(), input, result);</span>
<span class="udiff-line-added">+   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);</span>
<span class="udiff-line-added">+   set_result(x, result);</span>
<span class="udiff-line-added">+ #else</span>
    // flags that vary for the different operations and different SSE-settings
    bool fixed_input = false, fixed_result = false, round_result = false, needs_stub = false;
  
    switch (x-&gt;op()) {
      case Bytecodes::_i2l: // fall through
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1201,10 +1244,11 @@</span>
      __ move(conv_result, result);
    }
  
    assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
    set_result(x, result);
<span class="udiff-line-added">+ #endif // _LP64</span>
  }
  
  
  void LIRGenerator::do_NewInstance(NewInstance* x) {
    print_if_not_loaded(x);
</pre>
<center><a href="c1_LIRAssembler_x86.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LinearScan_x86.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
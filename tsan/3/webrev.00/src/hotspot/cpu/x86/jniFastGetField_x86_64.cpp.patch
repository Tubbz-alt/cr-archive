diff a/src/hotspot/cpu/x86/jniFastGetField_x86_64.cpp b/src/hotspot/cpu/x86/jniFastGetField_x86_64.cpp
--- a/src/hotspot/cpu/x86/jniFastGetField_x86_64.cpp
+++ b/src/hotspot/cpu/x86/jniFastGetField_x86_64.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2004, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -39,15 +39,14 @@
 // rax/xmm0: result
 // c_rarg0:    jni env
 // c_rarg1:    obj
 // c_rarg2:    jfield id
 
-static const Register rtmp          = r8;
-static const Register robj          = r9;
-static const Register rcounter      = r10;
-static const Register roffset       = r11;
-static const Register rcounter_addr = r11;
+static const Register rtmp     = rax; // r8 == c_rarg2 on Windows
+static const Register robj     = r9;
+static const Register roffset  = r10;
+static const Register rcounter = r11;
 
 // Warning: do not use rip relative addressing after the first counter load
 // since that may scratch r10!
 
 address JNI_FastGetField::generate_fast_get_int_field0(BasicType type) {
@@ -72,10 +71,19 @@
   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
   __ mov32 (rcounter, counter);
   __ mov   (robj, c_rarg1);
   __ testb (rcounter, 1);
   __ jcc (Assembler::notZero, slow);
+
+  if (JvmtiExport::can_post_field_access()) {
+    // Check to see if a field access watch has been set before we
+    // take the fast path.
+    assert_different_registers(rscratch1, robj, rcounter); // cmp32 clobbers rscratch1!
+    __ cmp32(ExternalAddress((address) JvmtiExport::get_field_access_count_addr()), 0);
+    __ jcc(Assembler::notZero, slow);
+  }
+
   __ mov   (roffset, c_rarg2);
   __ shrptr(roffset, 2);                         // offset
 
   // Both robj and rtmp are clobbered by try_resolve_jobject_in_native.
   BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();
@@ -162,10 +170,17 @@
   __ mov32 (rcounter, counter);
   __ mov   (robj, c_rarg1);
   __ testb (rcounter, 1);
   __ jcc (Assembler::notZero, slow);
 
+  if (JvmtiExport::can_post_field_access()) {
+    // Check to see if a field access watch has been set before we
+    // take the fast path.
+    __ cmp32(ExternalAddress((address) JvmtiExport::get_field_access_count_addr()), 0);
+    __ jcc(Assembler::notZero, slow);
+  }
+
   // Both robj and rtmp are clobbered by try_resolve_jobject_in_native.
   BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();
   bs->try_resolve_jobject_in_native(masm, /* jni_env */ c_rarg0, robj, rtmp, slow);
   DEBUG_ONLY(__ movl(rtmp, 0xDEADC0DE);)
 

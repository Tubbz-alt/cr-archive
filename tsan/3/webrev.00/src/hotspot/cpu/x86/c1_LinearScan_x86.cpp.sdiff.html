<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/c1_LinearScan_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_LinearScan_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Instruction.hpp&quot;
  27 #include &quot;c1/c1_LinearScan.hpp&quot;
  28 #include &quot;utilities/bitMap.inline.hpp&quot;
  29 
  30 





  31 //----------------------------------------------------------------------
  32 // Allocation of FPU stack slots (Intel x86 only)
  33 //----------------------------------------------------------------------
  34 
  35 void LinearScan::allocate_fpu_stack() {
  36   // First compute which FPU registers are live at the start of each basic block
  37   // (To minimize the amount of work we have to do if we have to merge FPU stacks)
  38   if (ComputeExactFPURegisterUsage) {
  39     Interval* intervals_in_register, *intervals_in_memory;
  40     create_unhandled_lists(&amp;intervals_in_register, &amp;intervals_in_memory, is_in_fpu_register, NULL);
  41 
  42     // ignore memory intervals by overwriting intervals_in_memory
  43     // the dummy interval is needed to enforce the walker to walk until the given id:
  44     // without it, the walker stops when the unhandled-list is empty -&gt; live information
  45     // beyond this point would be incorrect.
  46     Interval* dummy_interval = new Interval(any_reg);
  47     dummy_interval-&gt;add_range(max_jint - 2, max_jint - 1);
  48     dummy_interval-&gt;set_next(Interval::end());
  49     intervals_in_memory = dummy_interval;
  50 
</pre>
<hr />
<pre>
 798 void FpuStackAllocator::handle_opCall(LIR_OpCall* opCall) {
 799   LIR_Opr res = opCall-&gt;result_opr();
 800 
 801   // clear fpu-stack before call
 802   // it may contain dead values that could not have been remved by previous operations
 803   clear_fpu_stack(LIR_OprFact::illegalOpr);
 804   assert(sim()-&gt;is_empty(), &quot;fpu stack must be empty now&quot;);
 805 
 806   // compute debug information before (possible) fpu result is pushed
 807   compute_debug_information(opCall);
 808 
 809   if (res-&gt;is_fpu_register() &amp;&amp; !res-&gt;is_xmm_register()) {
 810     do_push(res);
 811     opCall-&gt;set_result_opr(to_fpu_stack_top(res));
 812   }
 813 }
 814 
 815 #ifndef PRODUCT
 816 void FpuStackAllocator::check_invalid_lir_op(LIR_Op* op) {
 817   switch (op-&gt;code()) {
<span class="line-removed"> 818     case lir_24bit_FPU:</span>
<span class="line-removed"> 819     case lir_reset_FPU:</span>
<span class="line-removed"> 820     case lir_ffree:</span>
<span class="line-removed"> 821       assert(false, &quot;operations not allowed in lir. If one of these operations is needed, check if they have fpu operands&quot;);</span>
<span class="line-removed"> 822       break;</span>
<span class="line-removed"> 823 </span>
 824     case lir_fpop_raw:
 825     case lir_fxch:
 826     case lir_fld:
 827       assert(false, &quot;operations only inserted by FpuStackAllocator&quot;);
 828       break;
 829 
 830     default:
 831       break;
 832   }
 833 }
 834 #endif
 835 
 836 
 837 void FpuStackAllocator::merge_insert_add(LIR_List* instrs, FpuStackSim* cur_sim, int reg) {
 838   LIR_Op1* move = new LIR_Op1(lir_move, LIR_OprFact::doubleConst(0), LIR_OprFact::double_fpu(reg)-&gt;make_fpu_stack_offset());
 839 
 840   instrs-&gt;instructions_list()-&gt;push(move);
 841 
 842   cur_sim-&gt;push(reg);
 843   move-&gt;set_result_opr(to_fpu_stack(move-&gt;result_opr()));
</pre>
<hr />
<pre>
1122     }
1123   }
1124 
1125 #ifndef PRODUCT
1126   // assertions that FPU stack state conforms to all successors&#39; states
1127   intArray* cur_state = sim()-&gt;write_state();
1128   for (int i = 0; i &lt; number_of_sux; i++) {
1129     BlockBegin* sux = block-&gt;sux_at(i);
1130     intArray* sux_state = sux-&gt;fpu_stack_state();
1131 
1132     assert(sux_state != NULL, &quot;no fpu state&quot;);
1133     assert(cur_state-&gt;length() == sux_state-&gt;length(), &quot;incorrect length&quot;);
1134     for (int i = 0; i &lt; cur_state-&gt;length(); i++) {
1135       assert(cur_state-&gt;at(i) == sux_state-&gt;at(i), &quot;element not equal&quot;);
1136     }
1137   }
1138 #endif
1139 
1140   return changed;
1141 }

</pre>
</td>
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Instruction.hpp&quot;
  27 #include &quot;c1/c1_LinearScan.hpp&quot;
  28 #include &quot;utilities/bitMap.inline.hpp&quot;
  29 
  30 
<span class="line-added">  31 #ifdef _LP64</span>
<span class="line-added">  32 void LinearScan::allocate_fpu_stack() {</span>
<span class="line-added">  33   // No FPU stack used on x86-64</span>
<span class="line-added">  34 }</span>
<span class="line-added">  35 #else</span>
  36 //----------------------------------------------------------------------
  37 // Allocation of FPU stack slots (Intel x86 only)
  38 //----------------------------------------------------------------------
  39 
  40 void LinearScan::allocate_fpu_stack() {
  41   // First compute which FPU registers are live at the start of each basic block
  42   // (To minimize the amount of work we have to do if we have to merge FPU stacks)
  43   if (ComputeExactFPURegisterUsage) {
  44     Interval* intervals_in_register, *intervals_in_memory;
  45     create_unhandled_lists(&amp;intervals_in_register, &amp;intervals_in_memory, is_in_fpu_register, NULL);
  46 
  47     // ignore memory intervals by overwriting intervals_in_memory
  48     // the dummy interval is needed to enforce the walker to walk until the given id:
  49     // without it, the walker stops when the unhandled-list is empty -&gt; live information
  50     // beyond this point would be incorrect.
  51     Interval* dummy_interval = new Interval(any_reg);
  52     dummy_interval-&gt;add_range(max_jint - 2, max_jint - 1);
  53     dummy_interval-&gt;set_next(Interval::end());
  54     intervals_in_memory = dummy_interval;
  55 
</pre>
<hr />
<pre>
 803 void FpuStackAllocator::handle_opCall(LIR_OpCall* opCall) {
 804   LIR_Opr res = opCall-&gt;result_opr();
 805 
 806   // clear fpu-stack before call
 807   // it may contain dead values that could not have been remved by previous operations
 808   clear_fpu_stack(LIR_OprFact::illegalOpr);
 809   assert(sim()-&gt;is_empty(), &quot;fpu stack must be empty now&quot;);
 810 
 811   // compute debug information before (possible) fpu result is pushed
 812   compute_debug_information(opCall);
 813 
 814   if (res-&gt;is_fpu_register() &amp;&amp; !res-&gt;is_xmm_register()) {
 815     do_push(res);
 816     opCall-&gt;set_result_opr(to_fpu_stack_top(res));
 817   }
 818 }
 819 
 820 #ifndef PRODUCT
 821 void FpuStackAllocator::check_invalid_lir_op(LIR_Op* op) {
 822   switch (op-&gt;code()) {






 823     case lir_fpop_raw:
 824     case lir_fxch:
 825     case lir_fld:
 826       assert(false, &quot;operations only inserted by FpuStackAllocator&quot;);
 827       break;
 828 
 829     default:
 830       break;
 831   }
 832 }
 833 #endif
 834 
 835 
 836 void FpuStackAllocator::merge_insert_add(LIR_List* instrs, FpuStackSim* cur_sim, int reg) {
 837   LIR_Op1* move = new LIR_Op1(lir_move, LIR_OprFact::doubleConst(0), LIR_OprFact::double_fpu(reg)-&gt;make_fpu_stack_offset());
 838 
 839   instrs-&gt;instructions_list()-&gt;push(move);
 840 
 841   cur_sim-&gt;push(reg);
 842   move-&gt;set_result_opr(to_fpu_stack(move-&gt;result_opr()));
</pre>
<hr />
<pre>
1121     }
1122   }
1123 
1124 #ifndef PRODUCT
1125   // assertions that FPU stack state conforms to all successors&#39; states
1126   intArray* cur_state = sim()-&gt;write_state();
1127   for (int i = 0; i &lt; number_of_sux; i++) {
1128     BlockBegin* sux = block-&gt;sux_at(i);
1129     intArray* sux_state = sux-&gt;fpu_stack_state();
1130 
1131     assert(sux_state != NULL, &quot;no fpu state&quot;);
1132     assert(cur_state-&gt;length() == sux_state-&gt;length(), &quot;incorrect length&quot;);
1133     for (int i = 0; i &lt; cur_state-&gt;length(); i++) {
1134       assert(cur_state-&gt;at(i) == sux_state-&gt;at(i), &quot;element not equal&quot;);
1135     }
1136   }
1137 #endif
1138 
1139   return changed;
1140 }
<span class="line-added">1141 #endif // _LP64</span>
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
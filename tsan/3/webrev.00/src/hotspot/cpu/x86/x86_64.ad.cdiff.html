<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="x86_32.ad.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../zero/assembler_zero.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 265,10 ***</span>
<span class="line-new-header">--- 265,13 ---</span>
  reg_class ptr_rbx_reg(RBX, RBX_H);
  
  // Singleton class for RSI pointer register
  reg_class ptr_rsi_reg(RSI, RSI_H);
  
<span class="line-added">+ // Singleton class for RBP pointer register</span>
<span class="line-added">+ reg_class ptr_rbp_reg(RBP, RBP_H);</span>
<span class="line-added">+ </span>
  // Singleton class for RDI pointer register
  reg_class ptr_rdi_reg(RDI, RDI_H);
  
  // Singleton class for stack pointer
  reg_class ptr_rsp_reg(RSP, RSP_H);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 544,11 ***</span>
  // emit 32 bit value and construct relocation entry from RelocationHolder
  void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  #ifdef ASSERT
    if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
        d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
<span class="line-modified">!     assert(Universe::heap()-&gt;is_in_reserved((address)(intptr_t)d32), &quot;should be real oop&quot;);</span>
      assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
    }
  #endif
    cbuf.relocate(cbuf.insts_mark(), rspec, format);
    cbuf.insts()-&gt;emit_int32(d32);
<span class="line-new-header">--- 547,11 ---</span>
  // emit 32 bit value and construct relocation entry from RelocationHolder
  void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  #ifdef ASSERT
    if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
        d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
<span class="line-modified">!     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);</span>
      assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
    }
  #endif
    cbuf.relocate(cbuf.insts_mark(), rspec, format);
    cbuf.insts()-&gt;emit_int32(d32);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 571,11 ***</span>
  // emit 64 bit value and construct relocation entry from RelocationHolder
  void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  #ifdef ASSERT
    if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
        d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
<span class="line-modified">!     assert(Universe::heap()-&gt;is_in_reserved((address)d64), &quot;should be real oop&quot;);</span>
      assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
    }
  #endif
    cbuf.relocate(cbuf.insts_mark(), rspec, format);
    cbuf.insts()-&gt;emit_int64(d64);
<span class="line-new-header">--- 574,11 ---</span>
  // emit 64 bit value and construct relocation entry from RelocationHolder
  void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  #ifdef ASSERT
    if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
        d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
<span class="line-modified">!     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);</span>
      assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
    }
  #endif
    cbuf.relocate(cbuf.insts_mark(), rspec, format);
    cbuf.insts()-&gt;emit_int64(d64);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 872,10 ***</span>
<span class="line-new-header">--- 875,25 ---</span>
    MacroAssembler _masm(&amp;cbuf);
  
    int framesize = C-&gt;frame_size_in_bytes();
    int bangsize = C-&gt;bang_size_in_bytes();
  
<span class="line-added">+   if (C-&gt;clinit_barrier_on_entry()) {</span>
<span class="line-added">+     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);</span>
<span class="line-added">+     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Label L_skip_barrier;</span>
<span class="line-added">+     Register klass = rscratch1;</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());</span>
<span class="line-added">+     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ bind(L_skip_barrier);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);
  
    C-&gt;set_frame_complete(cbuf.insts_size());
  
    if (C-&gt;has_mach_constant_base_node()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 916,23 ***</span>
    if (framesize) {
      st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
      st-&gt;print(&quot;\t&quot;);
    }
  
<span class="line-modified">!   st-&gt;print_cr(&quot;popq   rbp&quot;);</span>
    if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
      st-&gt;print(&quot;\t&quot;);
      if (SafepointMechanism::uses_thread_local_poll()) {
<span class="line-modified">!       st-&gt;print_cr(&quot;movq   rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;</span>
<span class="line-modified">!                    &quot;testl  rax, [rscratch1]\t&quot;</span>
                     &quot;# Safepoint: poll for GC&quot;);
      } else if (Assembler::is_polling_page_far()) {
<span class="line-modified">!       st-&gt;print_cr(&quot;movq   rscratch1, #polling_page_address\n\t&quot;</span>
<span class="line-modified">!                    &quot;testl  rax, [rscratch1]\t&quot;</span>
                     &quot;# Safepoint: poll for GC&quot;);
      } else {
<span class="line-modified">!       st-&gt;print_cr(&quot;testl  rax, [rip + #offset_to_poll_page]\t&quot;</span>
                     &quot;# Safepoint: poll for GC&quot;);
      }
    }
  }
  #endif
<span class="line-new-header">--- 934,23 ---</span>
    if (framesize) {
      st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
      st-&gt;print(&quot;\t&quot;);
    }
  
<span class="line-modified">!   st-&gt;print_cr(&quot;popq    rbp&quot;);</span>
    if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
      st-&gt;print(&quot;\t&quot;);
      if (SafepointMechanism::uses_thread_local_poll()) {
<span class="line-modified">!       st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;</span>
<span class="line-modified">!                    &quot;testl   rax, [rscratch1]\t&quot;</span>
                     &quot;# Safepoint: poll for GC&quot;);
      } else if (Assembler::is_polling_page_far()) {
<span class="line-modified">!       st-&gt;print_cr(&quot;movq    rscratch1, #polling_page_address\n\t&quot;</span>
<span class="line-modified">!                    &quot;testl   rax, [rscratch1]\t&quot;</span>
                     &quot;# Safepoint: poll for GC&quot;);
      } else {
<span class="line-modified">!       st-&gt;print_cr(&quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;</span>
                     &quot;# Safepoint: poll for GC&quot;);
      }
    }
  }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1041,12 ***</span>
  
  // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
  static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
                            int src_hi, int dst_hi, uint ireg, outputStream* st);
  
<span class="line-modified">! static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,</span>
<span class="line-modified">!                             int stack_offset, int reg, uint ireg, outputStream* st);</span>
  
  static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
                                        int dst_offset, uint ireg, outputStream* st) {
    if (cbuf) {
      MacroAssembler _masm(cbuf);
<span class="line-new-header">--- 1059,12 ---</span>
  
  // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
  static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
                            int src_hi, int dst_hi, uint ireg, outputStream* st);
  
<span class="line-modified">! int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,</span>
<span class="line-modified">!                      int stack_offset, int reg, uint ireg, outputStream* st);</span>
  
  static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
                                        int dst_offset, uint ireg, outputStream* st) {
    if (cbuf) {
      MacroAssembler _masm(cbuf);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1660,11 ***</span>
  
  bool Matcher::const_klass_prefer_decode() {
    // TODO: Either support matching DecodeNKlass (heap-based) in operand
    //       or condisider the following:
    // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified">!   //return Universe::narrow_klass_base() == NULL;</span>
    return true;
  }
  
  // Is it better to copy float constants, or load them directly from
  // memory?  Intel can load a float constant from a direct address,
<span class="line-new-header">--- 1678,11 ---</span>
  
  bool Matcher::const_klass_prefer_decode() {
    // TODO: Either support matching DecodeNKlass (heap-based) in operand
    //       or condisider the following:
    // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified">!   //return CompressedKlassPointers::base() == NULL;</span>
    return true;
  }
  
  // Is it better to copy float constants, or load them directly from
  // memory?  Intel can load a float constant from a direct address,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1680,13 ***</span>
  const bool Matcher::misaligned_doubles_ok = true;
  
  // No-op on amd64
  void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
  
<span class="line-modified">! // Advertise here if the CPU requires explicit rounding operations to</span>
<span class="line-modified">! // implement the UseStrictFP mode.</span>
<span class="line-removed">- const bool Matcher::strict_fp_requires_explicit_rounding = true;</span>
  
  // Are floats conerted to double when stored to stack during deoptimization?
  // On x64 it is stored without convertion so we can use normal access.
  bool Matcher::float_in_double() { return false; }
  
<span class="line-new-header">--- 1698,12 ---</span>
  const bool Matcher::misaligned_doubles_ok = true;
  
  // No-op on amd64
  void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
  
<span class="line-modified">! // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>
<span class="line-modified">! const bool Matcher::strict_fp_requires_explicit_rounding = false;</span>
  
  // Are floats conerted to double when stored to stack during deoptimization?
  // On x64 it is stored without convertion so we can use normal access.
  bool Matcher::float_in_double() { return false; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3099,10 ***</span>
<span class="line-new-header">--- 3116,30 ---</span>
    op_cost(15);
    format %{ %}
    interface(CONST_INTER);
  %}
  
<span class="line-added">+ operand immL_Pow2()</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   predicate(is_power_of_2(n-&gt;get_long()));</span>
<span class="line-added">+   match(ConL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   op_cost(15);</span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(CONST_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ operand immL_NotPow2()</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   predicate(is_power_of_2(~n-&gt;get_long()));</span>
<span class="line-added">+   match(ConL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   op_cost(15);</span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(CONST_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  // Long Immediate zero
  operand immL0()
  %{
    predicate(n-&gt;get_long() == 0L);
    match(ConL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3493,10 ***</span>
<span class="line-new-header">--- 3530,20 ---</span>
  
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="line-added">+ operand rbp_RegP()</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(ptr_rbp_reg));</span>
<span class="line-added">+   match(RegP);</span>
<span class="line-added">+   match(rRegP);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  // Used in rep stosq
  operand rdi_RegP()
  %{
    constraint(ALLOC_IN_RC(ptr_rdi_reg));
    match(RegP);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3670,76 ***</span>
  
     format %{ %}
     interface(REG_INTER);
  %}
  
<span class="line-removed">- // Vectors</span>
<span class="line-removed">- operand vecS() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectors_reg_vlbwdq));</span>
<span class="line-removed">-   match(VecS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Vectors</span>
<span class="line-removed">- operand legVecS() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectors_reg_legacy));</span>
<span class="line-removed">-   match(VecS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand vecD() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectord_reg_vlbwdq));</span>
<span class="line-removed">-   match(VecD);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand legVecD() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectord_reg_legacy));</span>
<span class="line-removed">-   match(VecD);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand vecX() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectorx_reg_vlbwdq));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand legVecX() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectorx_reg_legacy));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand vecY() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectory_reg_vlbwdq));</span>
<span class="line-removed">-   match(VecY);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand legVecY() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectory_reg_legacy));</span>
<span class="line-removed">-   match(VecY);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  //----------Memory Operands----------------------------------------------------
  // Direct Memory Operand
  // operand direct(immP addr)
  // %{
  //   match(addr);
<span class="line-new-header">--- 3717,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3912,13 ***</span>
    %}
  %}
  
  // Indirect Narrow Oop Plus Offset Operand
  // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
<span class="line-modified">! // we can&#39;t free r12 even with Universe::narrow_oop_base() == NULL.</span>
  operand indCompressedOopOffset(rRegN reg, immL32 off) %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() == Address::times_8));</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) off);
  
    op_cost(10);
    format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
<span class="line-new-header">--- 3893,13 ---</span>
    %}
  %}
  
  // Indirect Narrow Oop Plus Offset Operand
  // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
<span class="line-modified">! // we can&#39;t free r12 even with CompressedOops::base() == NULL.</span>
  operand indCompressedOopOffset(rRegN reg, immL32 off) %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) off);
  
    op_cost(10);
    format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3931,11 ***</span>
  %}
  
  // Indirect Memory Operand
  operand indirectNarrow(rRegN reg)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(DecodeN reg);
  
    format %{ &quot;[$reg]&quot; %}
    interface(MEMORY_INTER) %{
<span class="line-new-header">--- 3912,11 ---</span>
  %}
  
  // Indirect Memory Operand
  operand indirectNarrow(rRegN reg)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(DecodeN reg);
  
    format %{ &quot;[$reg]&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3947,11 ***</span>
  %}
  
  // Indirect Memory Plus Short Offset Operand
  operand indOffset8Narrow(rRegN reg, immL8 off)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) off);
  
    format %{ &quot;[$reg + $off (8-bit)]&quot; %}
    interface(MEMORY_INTER) %{
<span class="line-new-header">--- 3928,11 ---</span>
  %}
  
  // Indirect Memory Plus Short Offset Operand
  operand indOffset8Narrow(rRegN reg, immL8 off)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) off);
  
    format %{ &quot;[$reg + $off (8-bit)]&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3963,11 ***</span>
  %}
  
  // Indirect Memory Plus Long Offset Operand
  operand indOffset32Narrow(rRegN reg, immL32 off)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) off);
  
    format %{ &quot;[$reg + $off (32-bit)]&quot; %}
    interface(MEMORY_INTER) %{
<span class="line-new-header">--- 3944,11 ---</span>
  %}
  
  // Indirect Memory Plus Long Offset Operand
  operand indOffset32Narrow(rRegN reg, immL32 off)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) off);
  
    format %{ &quot;[$reg + $off (32-bit)]&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3979,11 ***</span>
  %}
  
  // Indirect Memory Plus Index Register Plus Offset Operand
  operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (AddP (DecodeN reg) lreg) off);
  
    op_cost(10);
    format %{&quot;[$reg + $off + $lreg]&quot; %}
<span class="line-new-header">--- 3960,11 ---</span>
  %}
  
  // Indirect Memory Plus Index Register Plus Offset Operand
  operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (AddP (DecodeN reg) lreg) off);
  
    op_cost(10);
    format %{&quot;[$reg + $off + $lreg]&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3996,11 ***</span>
  %}
  
  // Indirect Memory Plus Index Register Plus Offset Operand
  operand indIndexNarrow(rRegN reg, rRegL lreg)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) lreg);
  
    op_cost(10);
    format %{&quot;[$reg + $lreg]&quot; %}
<span class="line-new-header">--- 3977,11 ---</span>
  %}
  
  // Indirect Memory Plus Index Register Plus Offset Operand
  operand indIndexNarrow(rRegN reg, rRegL lreg)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) lreg);
  
    op_cost(10);
    format %{&quot;[$reg + $lreg]&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4013,11 ***</span>
  %}
  
  // Indirect Memory Times Scale Plus Index Register
  operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) (LShiftL lreg scale));
  
    op_cost(10);
    format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
<span class="line-new-header">--- 3994,11 ---</span>
  %}
  
  // Indirect Memory Times Scale Plus Index Register
  operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) (LShiftL lreg scale));
  
    op_cost(10);
    format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4030,11 ***</span>
  %}
  
  // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
  operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
  
    op_cost(10);
    format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
<span class="line-new-header">--- 4011,11 ---</span>
  %}
  
  // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
  operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
  
    op_cost(10);
    format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4048,11 ***</span>
  
  // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
  operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
  %{
    constraint(ALLOC_IN_RC(ptr_reg));
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);</span>
    match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
  
    op_cost(10);
    format %{&quot;[$reg + $off + $idx]&quot; %}
    interface(MEMORY_INTER) %{
<span class="line-new-header">--- 4029,11 ---</span>
  
  // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
  operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
  %{
    constraint(ALLOC_IN_RC(ptr_reg));
<span class="line-modified">!   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);</span>
    match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
  
    op_cost(10);
    format %{&quot;[$reg + $off + $idx]&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4065,11 ***</span>
  
  // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
  operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
  %{
    constraint(ALLOC_IN_RC(ptr_reg));
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);</span>
    match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
  
    op_cost(10);
    format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
    interface(MEMORY_INTER) %{
<span class="line-new-header">--- 4046,11 ---</span>
  
  // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
  operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
  %{
    constraint(ALLOC_IN_RC(ptr_reg));
<span class="line-modified">!   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);</span>
    match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
  
    op_cost(10);
    format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4243,204 ***</span>
      overflow(0x0, &quot;o&quot;);
      no_overflow(0x1, &quot;no&quot;);
    %}
  %}
  
<span class="line-removed">- // Operands for bound floating pointer register arguments</span>
<span class="line-removed">- operand rxmm0() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm0_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm1() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm1_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm2() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm2_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm3() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm3_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm4() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm4_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm5() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm5_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm6() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm6_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm7() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm7_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm8() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm8_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm9() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm9_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm10() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm10_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm11() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm11_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm12() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm12_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm13() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm13_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm14() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm14_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm15() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm15_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm16() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm16_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm17() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm17_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm18() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm18_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm19() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm19_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm20() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm20_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm21() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm21_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm22() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm22_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm23() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm23_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm24() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm24_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm25() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm25_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm26() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm26_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm27() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm27_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm28() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm28_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm29() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm29_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm30() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm30_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- operand rxmm31() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(xmm31_reg));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">-   format%{%}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  //----------OPERAND CLASSES----------------------------------------------------
  // Operand Classes are groups of operands that are used as to simplify
  // instruction definitions by not requiring the AD writer to specify separate
  // instructions for every form of operand when the instruction accepts
  // multiple operand types with the same basic encoding and format.  The classic
<span class="line-new-header">--- 4224,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5329,10 ***</span>
<span class="line-new-header">--- 5116,11 ---</span>
  
  // Load Pointer
  instruct loadP(rRegP dst, memory mem)
  %{
    match(Set dst (LoadP mem));
<span class="line-added">+   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);</span>
  
    ins_cost(125); // XXX
    format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
    opcode(0x8B);
    ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5526,11 ***</span>
      __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
   %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct maxF_reduction_reg(regF dst, regF a, regF b, regF xmmt, rRegI tmp, rFlagsReg cr) %{</span>
    predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
    match(Set dst (MaxF a b));
    effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
  
    format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
<span class="line-new-header">--- 5314,11 ---</span>
      __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
   %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{</span>
    predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
    match(Set dst (MaxF a b));
    effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
  
    format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5562,11 ***</span>
      __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct maxD_reduction_reg(regD dst, regD a, regD b, regD xmmt, rRegL tmp, rFlagsReg cr) %{</span>
    predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
    match(Set dst (MaxD a b));
    effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
  
    format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
<span class="line-new-header">--- 5350,11 ---</span>
      __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{</span>
    predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
    match(Set dst (MaxD a b));
    effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
  
    format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5598,11 ***</span>
      __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct minF_reduction_reg(regF dst, regF a, regF b, regF xmmt, rRegI tmp, rFlagsReg cr) %{</span>
    predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
    match(Set dst (MinF a b));
    effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
  
    format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
<span class="line-new-header">--- 5386,11 ---</span>
      __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{</span>
    predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
    match(Set dst (MinF a b));
    effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
  
    format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5634,11 ***</span>
      __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct minD_reduction_reg(regD dst, regD a, regD b, regD xmmt, rRegL tmp, rFlagsReg cr) %{</span>
    predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
    match(Set dst (MinD a b));
    effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
  
    format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
<span class="line-new-header">--- 5422,11 ---</span>
      __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{</span>
    predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
    match(Set dst (MinD a b));
    effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
  
    format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5750,11 ***</span>
  %}
  
  // Load Effective Address which uses Narrow (32-bits) oop
  instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() != 0));</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
    opcode(0x8D);
<span class="line-new-header">--- 5538,11 ---</span>
  %}
  
  // Load Effective Address which uses Narrow (32-bits) oop
  instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
    opcode(0x8D);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5762,11 ***</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110); // XXX
    format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
    opcode(0x8D);
<span class="line-new-header">--- 5550,11 ---</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110); // XXX
    format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
    opcode(0x8D);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5774,11 ***</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
    opcode(0x8D);
<span class="line-new-header">--- 5562,11 ---</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
    opcode(0x8D);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5786,11 ***</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
    opcode(0x8D);
<span class="line-new-header">--- 5574,11 ---</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
    opcode(0x8D);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5798,11 ***</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
    opcode(0x8D);
<span class="line-new-header">--- 5586,11 ---</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
    opcode(0x8D);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5810,11 ***</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
    opcode(0x8D);
<span class="line-new-header">--- 5598,11 ---</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
    opcode(0x8D);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5822,11 ***</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
    opcode(0x8D);
<span class="line-new-header">--- 5610,11 ---</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
    opcode(0x8D);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5834,11 ***</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
    opcode(0x8D);
<span class="line-new-header">--- 5622,11 ---</span>
    ins_pipe(ialu_reg_reg_fat);
  %}
  
  instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    match(Set dst mem);
  
    ins_cost(110);
    format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
    opcode(0x8D);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6198,11 ***</span>
    ins_pipe(ialu_mem_reg);
  %}
  
  instruct storeImmP0(memory mem, immP0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
    match(Set mem (StoreP mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
    ins_encode %{
<span class="line-new-header">--- 5986,11 ---</span>
    ins_pipe(ialu_mem_reg);
  %}
  
  instruct storeImmP0(memory mem, immP0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
    match(Set mem (StoreP mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6248,11 ***</span>
    ins_pipe(ialu_mem_reg);
  %}
  
  instruct storeImmN0(memory mem, immN0 zero)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_klass_base() == NULL);</span>
    match(Set mem (StoreN mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
    ins_encode %{
<span class="line-new-header">--- 6036,11 ---</span>
    ins_pipe(ialu_mem_reg);
  %}
  
  instruct storeImmN0(memory mem, immN0 zero)
  %{
<span class="line-modified">!   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedKlassPointers::base() == NULL);</span>
    match(Set mem (StoreN mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6291,11 ***</span>
  %}
  
  // Store Integer Immediate
  instruct storeImmI0(memory mem, immI0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
    match(Set mem (StoreI mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
    ins_encode %{
<span class="line-new-header">--- 6079,11 ---</span>
  %}
  
  // Store Integer Immediate
  instruct storeImmI0(memory mem, immI0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
    match(Set mem (StoreI mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6316,11 ***</span>
  %}
  
  // Store Long Immediate
  instruct storeImmL0(memory mem, immL0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
    match(Set mem (StoreL mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
    ins_encode %{
<span class="line-new-header">--- 6104,11 ---</span>
  %}
  
  // Store Long Immediate
  instruct storeImmL0(memory mem, immL0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
    match(Set mem (StoreL mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6341,11 ***</span>
  %}
  
  // Store Short/Char Immediate
  instruct storeImmC0(memory mem, immI0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
    match(Set mem (StoreC mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
    ins_encode %{
<span class="line-new-header">--- 6129,11 ---</span>
  %}
  
  // Store Short/Char Immediate
  instruct storeImmC0(memory mem, immI0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
    match(Set mem (StoreC mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6367,11 ***</span>
  %}
  
  // Store Byte Immediate
  instruct storeImmB0(memory mem, immI0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
    match(Set mem (StoreB mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
    ins_encode %{
<span class="line-new-header">--- 6155,11 ---</span>
  %}
  
  // Store Byte Immediate
  instruct storeImmB0(memory mem, immI0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
    match(Set mem (StoreB mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6392,11 ***</span>
  %}
  
  // Store CMS card-mark Immediate
  instruct storeImmCM0_reg(memory mem, immI0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
    match(Set mem (StoreCM mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
    ins_encode %{
<span class="line-new-header">--- 6180,11 ---</span>
  %}
  
  // Store CMS card-mark Immediate
  instruct storeImmCM0_reg(memory mem, immI0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
    match(Set mem (StoreCM mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6430,11 ***</span>
  %}
  
  // Store immediate Float value (it is faster than store from XMM register)
  instruct storeF0(memory mem, immF0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
    match(Set mem (StoreF mem zero));
  
    ins_cost(25); // XXX
    format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
    ins_encode %{
<span class="line-new-header">--- 6218,11 ---</span>
  %}
  
  // Store immediate Float value (it is faster than store from XMM register)
  instruct storeF0(memory mem, immF0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
    match(Set mem (StoreF mem zero));
  
    ins_cost(25); // XXX
    format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6468,11 ***</span>
  %}
  
  // Store immediate double 0.0 (it is faster than store from XMM register)
  instruct storeD0_imm(memory mem, immD0 src)
  %{
<span class="line-modified">!   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));</span>
    match(Set mem (StoreD mem src));
  
    ins_cost(50);
    format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
    opcode(0xC7); /* C7 /0 */
<span class="line-new-header">--- 6256,11 ---</span>
  %}
  
  // Store immediate double 0.0 (it is faster than store from XMM register)
  instruct storeD0_imm(memory mem, immD0 src)
  %{
<span class="line-modified">!   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));</span>
    match(Set mem (StoreD mem src));
  
    ins_cost(50);
    format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
    opcode(0xC7); /* C7 /0 */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6480,11 ***</span>
    ins_pipe(ialu_mem_imm);
  %}
  
  instruct storeD0(memory mem, immD0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
    match(Set mem (StoreD mem zero));
  
    ins_cost(25); // XXX
    format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
    ins_encode %{
<span class="line-new-header">--- 6268,11 ---</span>
    ins_pipe(ialu_mem_imm);
  %}
  
  instruct storeD0(memory mem, immD0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
    match(Set mem (StoreD mem zero));
  
    ins_cost(25); // XXX
    format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6548,10 ***</span>
<span class="line-new-header">--- 6336,51 ---</span>
      __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
    %}
    ins_pipe(pipe_slow); // XXX
  %}
  
<span class="line-added">+ instruct cacheWB(indirect addr)</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   predicate(VM_Version::supports_data_cache_line_flush());</span>
<span class="line-added">+   match(CacheWB addr);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_cost(100);</span>
<span class="line-added">+   format %{&quot;cache wb $addr&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);</span>
<span class="line-added">+     assert($addr$$disp == 0, &quot;should be&quot;);</span>
<span class="line-added">+     __ cache_wb(Address($addr$$base$$Register, 0));</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_slow); // XXX</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct cacheWBPreSync()</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   predicate(VM_Version::supports_data_cache_line_flush());</span>
<span class="line-added">+   match(CacheWBPreSync);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_cost(100);</span>
<span class="line-added">+   format %{&quot;cache wb presync&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     __ cache_wbsync(true);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_slow); // XXX</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct cacheWBPostSync()</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   predicate(VM_Version::supports_data_cache_line_flush());</span>
<span class="line-added">+   match(CacheWBPostSync);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_cost(100);</span>
<span class="line-added">+   format %{&quot;cache wb postsync&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     __ cache_wbsync(false);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_slow); // XXX</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  //----------BSWAP Instructions-------------------------------------------------
  instruct bytes_reverse_int(rRegI dst) %{
    match(Set dst (ReverseBytesI dst));
  
    format %{ &quot;bswapl  $dst&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6917,11 ***</span>
  
  // Convert compressed oop into int for vectors alignment masking
  // in case of 32bit oops (heap &lt; 4Gb).
  instruct convN2I(rRegI dst, rRegN src)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    match(Set dst (ConvL2I (CastP2X (DecodeN src))));
  
    format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
    ins_encode %{
      __ movl($dst$$Register, $src$$Register);
<span class="line-new-header">--- 6746,11 ---</span>
  
  // Convert compressed oop into int for vectors alignment masking
  // in case of 32bit oops (heap &lt; 4Gb).
  instruct convN2I(rRegI dst, rRegN src)
  %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    match(Set dst (ConvL2I (CastP2X (DecodeN src))));
  
    format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
    ins_encode %{
      __ movl($dst$$Register, $src$$Register);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7705,10 ***</span>
<span class="line-new-header">--- 7534,21 ---</span>
    ins_encode(/* empty encoding */);
    ins_cost(0);
    ins_pipe(empty);
  %}
  
<span class="line-added">+ instruct castLL(rRegL dst)</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   match(Set dst (CastLL dst));</span>
<span class="line-added">+ </span>
<span class="line-added">+   size(0);</span>
<span class="line-added">+   format %{ &quot;# castLL of $dst&quot; %}</span>
<span class="line-added">+   ins_encode(/* empty encoding */);</span>
<span class="line-added">+   ins_cost(0);</span>
<span class="line-added">+   ins_pipe(empty);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  // LoadP-locked same as a regular LoadP when used with compare-swap
  instruct loadPLocked(rRegP dst, memory mem)
  %{
    match(Set dst (LoadPLocked mem));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7725,10 ***</span>
<span class="line-new-header">--- 7565,11 ---</span>
  
  instruct storePConditional(memory heap_top_ptr,
                             rax_RegP oldval, rRegP newval,
                             rFlagsReg cr)
  %{
<span class="line-added">+   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
    match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
  
    format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
              &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
    opcode(0x0F, 0xB1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7776,11 ***</span>
  instruct compareAndSwapP(rRegI res,
                           memory mem_ptr,
                           rax_RegP oldval, rRegP newval,
                           rFlagsReg cr)
  %{
<span class="line-modified">!   predicate(VM_Version::supports_cx8());</span>
    match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
    match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
    effect(KILL cr, KILL oldval);
  
    format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
<span class="line-new-header">--- 7617,11 ---</span>
  instruct compareAndSwapP(rRegI res,
                           memory mem_ptr,
                           rax_RegP oldval, rRegP newval,
                           rFlagsReg cr)
  %{
<span class="line-modified">!   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
    match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
    match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
    effect(KILL cr, KILL oldval);
  
    format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8018,11 ***</span>
  instruct compareAndExchangeP(
                           memory mem_ptr,
                           rax_RegP oldval, rRegP newval,
                           rFlagsReg cr)
  %{
<span class="line-modified">!   predicate(VM_Version::supports_cx8());</span>
    match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
    effect(KILL cr);
  
    format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
              &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
<span class="line-new-header">--- 7859,11 ---</span>
  instruct compareAndExchangeP(
                           memory mem_ptr,
                           rax_RegP oldval, rRegP newval,
                           rFlagsReg cr)
  %{
<span class="line-modified">!   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
    match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
    effect(KILL cr);
  
    format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
              &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8163,10 ***</span>
<span class="line-new-header">--- 8004,11 ---</span>
    ins_pipe( pipe_cmpxchg );
  %}
  
  instruct xchgP( memory mem, rRegP newval) %{
    match(Set newval (GetAndSetP mem newval));
<span class="line-added">+   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
    format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
    ins_encode %{
      __ xchgq($newval$$Register, $mem$$Address);
    %}
    ins_pipe( pipe_cmpxchg );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8179,10 ***</span>
<span class="line-new-header">--- 8021,56 ---</span>
      __ xchgl($newval$$Register, $mem$$Address);
    %}
    ins_pipe( pipe_cmpxchg );
  %}
  
<span class="line-added">+ //----------Abs Instructions-------------------------------------------</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Integer Absolute Instructions</span>
<span class="line-added">+ instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   match(Set dst (AbsI src));</span>
<span class="line-added">+   effect(TEMP dst, TEMP tmp, KILL cr);</span>
<span class="line-added">+   format %{ &quot;movl $tmp, $src\n\t&quot;</span>
<span class="line-added">+             &quot;sarl $tmp, 31\n\t&quot;</span>
<span class="line-added">+             &quot;movl $dst, $src\n\t&quot;</span>
<span class="line-added">+             &quot;xorl $dst, $tmp\n\t&quot;</span>
<span class="line-added">+             &quot;subl $dst, $tmp\n&quot;</span>
<span class="line-added">+           %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     __ movl($tmp$$Register, $src$$Register);</span>
<span class="line-added">+     __ sarl($tmp$$Register, 31);</span>
<span class="line-added">+     __ movl($dst$$Register, $src$$Register);</span>
<span class="line-added">+     __ xorl($dst$$Register, $tmp$$Register);</span>
<span class="line-added">+     __ subl($dst$$Register, $tmp$$Register);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_pipe(ialu_reg_reg);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Long Absolute Instructions</span>
<span class="line-added">+ instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   match(Set dst (AbsL src));</span>
<span class="line-added">+   effect(TEMP dst, TEMP tmp, KILL cr);</span>
<span class="line-added">+   format %{ &quot;movq $tmp, $src\n\t&quot;</span>
<span class="line-added">+             &quot;sarq $tmp, 63\n\t&quot;</span>
<span class="line-added">+             &quot;movq $dst, $src\n\t&quot;</span>
<span class="line-added">+             &quot;xorq $dst, $tmp\n\t&quot;</span>
<span class="line-added">+             &quot;subq $dst, $tmp\n&quot;</span>
<span class="line-added">+           %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     __ movq($tmp$$Register, $src$$Register);</span>
<span class="line-added">+     __ sarq($tmp$$Register, 63);</span>
<span class="line-added">+     __ movq($dst$$Register, $src$$Register);</span>
<span class="line-added">+     __ xorq($dst$$Register, $tmp$$Register);</span>
<span class="line-added">+     __ subq($dst$$Register, $tmp$$Register);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_pipe(ialu_reg_reg);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  //----------Subtraction Instructions-------------------------------------------
  
  // Integer Subtraction Instructions
  instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
  %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9917,10 ***</span>
<span class="line-new-header">--- 9805,27 ---</span>
    ins_encode(REX_mem_wide(dst), OpcSE(src),
               RM_opc_mem(secondary, dst), Con8or32(src));
    ins_pipe(ialu_mem_imm);
  %}
  
<span class="line-added">+ instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   // con should be a pure 64-bit immediate given that not(con) is a power of 2</span>
<span class="line-added">+   // because AND/OR works well enough for 8/32-bit values.</span>
<span class="line-added">+   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);</span>
<span class="line-added">+ </span>
<span class="line-added">+   match(Set dst (StoreL dst (AndL (LoadL dst) con)));</span>
<span class="line-added">+   effect(KILL cr);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_cost(125);</span>
<span class="line-added">+   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     __ btrq($dst$$Address, log2_long(~$con$$constant));</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(ialu_mem_imm);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  // BMI1 instructions
  instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
    match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
    predicate(UseBMI1Instructions);
    effect(KILL cr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10110,10 ***</span>
<span class="line-new-header">--- 10015,27 ---</span>
    ins_encode(REX_mem_wide(dst), OpcSE(src),
               RM_opc_mem(secondary, dst), Con8or32(src));
    ins_pipe(ialu_mem_imm);
  %}
  
<span class="line-added">+ instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   // con should be a pure 64-bit power of 2 immediate</span>
<span class="line-added">+   // because AND/OR works well enough for 8/32-bit values.</span>
<span class="line-added">+   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);</span>
<span class="line-added">+ </span>
<span class="line-added">+   match(Set dst (StoreL dst (OrL (LoadL dst) con)));</span>
<span class="line-added">+   effect(KILL cr);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_cost(125);</span>
<span class="line-added">+   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     __ btsq($dst$$Address, log2_long($con$$constant));</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(ialu_mem_imm);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  // Xor Instructions
  // Xor Register with Register
  instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
  %{
    match(Set dst (XorL dst src));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10255,14 ***</span>
  instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
  %{
    match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
    effect(KILL cr);
    ins_cost(300);
<span class="line-modified">!   format %{ &quot;subl   $p,$q\t# cadd_cmpLTMask\n\t&quot;</span>
<span class="line-modified">!             &quot;jge    done\n\t&quot;</span>
<span class="line-modified">!             &quot;addl   $p,$y\n&quot;</span>
<span class="line-modified">!             &quot;done:  &quot; %}</span>
    ins_encode %{
      Register Rp = $p$$Register;
      Register Rq = $q$$Register;
      Register Ry = $y$$Register;
      Label done;
<span class="line-new-header">--- 10177,14 ---</span>
  instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
  %{
    match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
    effect(KILL cr);
    ins_cost(300);
<span class="line-modified">!   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;</span>
<span class="line-modified">!             &quot;jge     done\n\t&quot;</span>
<span class="line-modified">!             &quot;addl    $p,$y\n&quot;</span>
<span class="line-modified">!             &quot;done:   &quot; %}</span>
    ins_encode %{
      Register Rp = $p$$Register;
      Register Rq = $q$$Register;
      Register Ry = $y$$Register;
      Label done;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10280,14 ***</span>
    match(Set y (AndI (CmpLTMask p q) y));
    effect(KILL cr);
  
    ins_cost(300);
  
<span class="line-modified">!   format %{ &quot;cmpl     $p, $q\t# and_cmpLTMask\n\t&quot;</span>
<span class="line-modified">!             &quot;jlt      done\n\t&quot;</span>
<span class="line-modified">!             &quot;xorl     $y, $y\n&quot;</span>
<span class="line-modified">!             &quot;done:  &quot; %}</span>
    ins_encode %{
      Register Rp = $p$$Register;
      Register Rq = $q$$Register;
      Register Ry = $y$$Register;
      Label done;
<span class="line-new-header">--- 10202,14 ---</span>
    match(Set y (AndI (CmpLTMask p q) y));
    effect(KILL cr);
  
    ins_cost(300);
  
<span class="line-modified">!   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;</span>
<span class="line-modified">!             &quot;jlt     done\n\t&quot;</span>
<span class="line-modified">!             &quot;xorl    $y, $y\n&quot;</span>
<span class="line-modified">!             &quot;done:   &quot; %}</span>
    ins_encode %{
      Register Rp = $p$$Register;
      Register Rq = $q$$Register;
      Register Ry = $y$$Register;
      Label done;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10596,28 ***</span>
    ins_pipe(pipe_slow);
  %}
  
  //----------Arithmetic Conversion Instructions---------------------------------
  
<span class="line-removed">- instruct roundFloat_nop(regF dst)</span>
<span class="line-removed">- %{</span>
<span class="line-removed">-   match(Set dst (RoundFloat dst));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ins_cost(0);</span>
<span class="line-removed">-   ins_encode();</span>
<span class="line-removed">-   ins_pipe(empty);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct roundDouble_nop(regD dst)</span>
<span class="line-removed">- %{</span>
<span class="line-removed">-   match(Set dst (RoundDouble dst));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ins_cost(0);</span>
<span class="line-removed">-   ins_encode();</span>
<span class="line-removed">-   ins_pipe(empty);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  instruct convF2D_reg_reg(regD dst, regF src)
  %{
    match(Set dst (ConvF2D src));
  
    format %{ &quot;cvtss2sd $dst, $src&quot; %}
<span class="line-new-header">--- 10518,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10663,112 ***</span>
  // XXX do mem variants
  instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
  %{
    match(Set dst (ConvF2I src));
    effect(KILL cr);
<span class="line-modified">! </span>
<span class="line-removed">-   format %{ &quot;cvttss2sil $dst, $src\t# f2i\n\t&quot;</span>
<span class="line-removed">-             &quot;cmpl    $dst, #0x80000000\n\t&quot;</span>
<span class="line-removed">-             &quot;jne,s   done\n\t&quot;</span>
<span class="line-removed">-             &quot;subq    rsp, #8\n\t&quot;</span>
<span class="line-removed">-             &quot;movss   [rsp], $src\n\t&quot;</span>
<span class="line-removed">-             &quot;call    f2i_fixup\n\t&quot;</span>
<span class="line-removed">-             &quot;popq    $dst\n&quot;</span>
<span class="line-removed">-     &quot;done:   &quot;%}</span>
    ins_encode %{
<span class="line-modified">!     Label done;</span>
<span class="line-removed">-     __ cvttss2sil($dst$$Register, $src$$XMMRegister);</span>
<span class="line-removed">-     __ cmpl($dst$$Register, 0x80000000);</span>
<span class="line-removed">-     __ jccb(Assembler::notEqual, done);</span>
<span class="line-removed">-     __ subptr(rsp, 8);</span>
<span class="line-removed">-     __ movflt(Address(rsp, 0), $src$$XMMRegister);</span>
<span class="line-removed">-     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));</span>
<span class="line-removed">-     __ pop($dst$$Register);</span>
<span class="line-removed">-     __ bind(done);</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
  %{
    match(Set dst (ConvF2L src));
    effect(KILL cr);
<span class="line-modified">! </span>
<span class="line-removed">-   format %{ &quot;cvttss2siq $dst, $src\t# f2l\n\t&quot;</span>
<span class="line-removed">-             &quot;cmpq    $dst, [0x8000000000000000]\n\t&quot;</span>
<span class="line-removed">-             &quot;jne,s   done\n\t&quot;</span>
<span class="line-removed">-             &quot;subq    rsp, #8\n\t&quot;</span>
<span class="line-removed">-             &quot;movss   [rsp], $src\n\t&quot;</span>
<span class="line-removed">-             &quot;call    f2l_fixup\n\t&quot;</span>
<span class="line-removed">-             &quot;popq    $dst\n&quot;</span>
<span class="line-removed">-     &quot;done:   &quot;%}</span>
    ins_encode %{
<span class="line-modified">!     Label done;</span>
<span class="line-removed">-     __ cvttss2siq($dst$$Register, $src$$XMMRegister);</span>
<span class="line-removed">-     __ cmp64($dst$$Register,</span>
<span class="line-removed">-              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));</span>
<span class="line-removed">-     __ jccb(Assembler::notEqual, done);</span>
<span class="line-removed">-     __ subptr(rsp, 8);</span>
<span class="line-removed">-     __ movflt(Address(rsp, 0), $src$$XMMRegister);</span>
<span class="line-removed">-     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));</span>
<span class="line-removed">-     __ pop($dst$$Register);</span>
<span class="line-removed">-     __ bind(done);</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
  %{
    match(Set dst (ConvD2I src));
    effect(KILL cr);
<span class="line-modified">! </span>
<span class="line-removed">-   format %{ &quot;cvttsd2sil $dst, $src\t# d2i\n\t&quot;</span>
<span class="line-removed">-             &quot;cmpl    $dst, #0x80000000\n\t&quot;</span>
<span class="line-removed">-             &quot;jne,s   done\n\t&quot;</span>
<span class="line-removed">-             &quot;subq    rsp, #8\n\t&quot;</span>
<span class="line-removed">-             &quot;movsd   [rsp], $src\n\t&quot;</span>
<span class="line-removed">-             &quot;call    d2i_fixup\n\t&quot;</span>
<span class="line-removed">-             &quot;popq    $dst\n&quot;</span>
<span class="line-removed">-     &quot;done:   &quot;%}</span>
    ins_encode %{
<span class="line-modified">!     Label done;</span>
<span class="line-removed">-     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);</span>
<span class="line-removed">-     __ cmpl($dst$$Register, 0x80000000);</span>
<span class="line-removed">-     __ jccb(Assembler::notEqual, done);</span>
<span class="line-removed">-     __ subptr(rsp, 8);</span>
<span class="line-removed">-     __ movdbl(Address(rsp, 0), $src$$XMMRegister);</span>
<span class="line-removed">-     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));</span>
<span class="line-removed">-     __ pop($dst$$Register);</span>
<span class="line-removed">-     __ bind(done);</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
  %{
    match(Set dst (ConvD2L src));
    effect(KILL cr);
<span class="line-modified">! </span>
<span class="line-removed">-   format %{ &quot;cvttsd2siq $dst, $src\t# d2l\n\t&quot;</span>
<span class="line-removed">-             &quot;cmpq    $dst, [0x8000000000000000]\n\t&quot;</span>
<span class="line-removed">-             &quot;jne,s   done\n\t&quot;</span>
<span class="line-removed">-             &quot;subq    rsp, #8\n\t&quot;</span>
<span class="line-removed">-             &quot;movsd   [rsp], $src\n\t&quot;</span>
<span class="line-removed">-             &quot;call    d2l_fixup\n\t&quot;</span>
<span class="line-removed">-             &quot;popq    $dst\n&quot;</span>
<span class="line-removed">-     &quot;done:   &quot;%}</span>
    ins_encode %{
<span class="line-modified">!     Label done;</span>
<span class="line-removed">-     __ cvttsd2siq($dst$$Register, $src$$XMMRegister);</span>
<span class="line-removed">-     __ cmp64($dst$$Register,</span>
<span class="line-removed">-              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));</span>
<span class="line-removed">-     __ jccb(Assembler::notEqual, done);</span>
<span class="line-removed">-     __ subptr(rsp, 8);</span>
<span class="line-removed">-     __ movdbl(Address(rsp, 0), $src$$XMMRegister);</span>
<span class="line-removed">-     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));</span>
<span class="line-removed">-     __ pop($dst$$Register);</span>
<span class="line-removed">-     __ bind(done);</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct convI2F_reg_reg(regF dst, rRegI src)
<span class="line-new-header">--- 10567,46 ---</span>
  // XXX do mem variants
  instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
  %{
    match(Set dst (ConvF2I src));
    effect(KILL cr);
<span class="line-modified">!   format %{ &quot;convert_f2i $dst,$src&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ convert_f2i($dst$$Register, $src$$XMMRegister);</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
  %{
    match(Set dst (ConvF2L src));
    effect(KILL cr);
<span class="line-modified">!   format %{ &quot;convert_f2l $dst,$src&quot;%}</span>
    ins_encode %{
<span class="line-modified">!     __ convert_f2l($dst$$Register, $src$$XMMRegister);</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
  %{
    match(Set dst (ConvD2I src));
    effect(KILL cr);
<span class="line-modified">!   format %{ &quot;convert_d2i $dst,$src&quot;%}</span>
    ins_encode %{
<span class="line-modified">!     __ convert_d2i($dst$$Register, $src$$XMMRegister);</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
  %{
    match(Set dst (ConvD2L src));
    effect(KILL cr);
<span class="line-modified">!   format %{ &quot;convert_d2l $dst,$src&quot;%}</span>
    ins_encode %{
<span class="line-modified">!     __ convert_d2l($dst$$Register, $src$$XMMRegister);</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct convI2F_reg_reg(regF dst, rRegI src)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11233,11 ***</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<span class="line-modified">!                          rax_RegI result, legVecS tmp1, rFlagsReg cr)</span>
  %{
    predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
    match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
    effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
  
<span class="line-new-header">--- 11071,11 ---</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<span class="line-modified">!                          rax_RegI result, legRegD tmp1, rFlagsReg cr)</span>
  %{
    predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
    match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
    effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11249,11 ***</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<span class="line-modified">!                          rax_RegI result, legVecS tmp1, rFlagsReg cr)</span>
  %{
    predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
    match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
    effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
  
<span class="line-new-header">--- 11087,11 ---</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<span class="line-modified">!                          rax_RegI result, legRegD tmp1, rFlagsReg cr)</span>
  %{
    predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
    match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
    effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11265,11 ***</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<span class="line-modified">!                           rax_RegI result, legVecS tmp1, rFlagsReg cr)</span>
  %{
    predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
    match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
    effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
  
<span class="line-new-header">--- 11103,11 ---</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<span class="line-modified">!                           rax_RegI result, legRegD tmp1, rFlagsReg cr)</span>
  %{
    predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
    match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
    effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11281,11 ***</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
<span class="line-modified">!                           rax_RegI result, legVecS tmp1, rFlagsReg cr)</span>
  %{
    predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
    match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
    effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
  
<span class="line-new-header">--- 11119,11 ---</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
<span class="line-modified">!                           rax_RegI result, legRegD tmp1, rFlagsReg cr)</span>
  %{
    predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
    match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
    effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11298,163 ***</span>
    ins_pipe( pipe_slow );
  %}
  
  // fast search of substring with known size.
  instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<span class="line-modified">!                              rbx_RegI result, legVecS vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">!   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
  
<span class="line-modified">!   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
    ins_encode %{
      int icnt2 = (int)$int_cnt2$$constant;
      if (icnt2 &gt;= 16) {
        // IndexOf for constant substrings with size &gt;= 16 elements
        // which don&#39;t need to be loaded through stack.
        __ string_indexofC8($str1$$Register, $str2$$Register,
                            $cnt1$$Register, $cnt2$$Register,
                            icnt2, $result$$Register,
<span class="line-modified">!                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
      } else {
        // Small strings are loaded through stack if they cross page boundary.
        __ string_indexof($str1$$Register, $str2$$Register,
                          $cnt1$$Register, $cnt2$$Register,
                          icnt2, $result$$Register,
<span class="line-modified">!                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  // fast search of substring with known size.
  instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<span class="line-modified">!                              rbx_RegI result, legVecS vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">!   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
  
<span class="line-modified">!   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
    ins_encode %{
      int icnt2 = (int)$int_cnt2$$constant;
      if (icnt2 &gt;= 8) {
        // IndexOf for constant substrings with size &gt;= 8 elements
        // which don&#39;t need to be loaded through stack.
        __ string_indexofC8($str1$$Register, $str2$$Register,
                            $cnt1$$Register, $cnt2$$Register,
                            icnt2, $result$$Register,
<span class="line-modified">!                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
      } else {
        // Small strings are loaded through stack if they cross page boundary.
        __ string_indexof($str1$$Register, $str2$$Register,
                          $cnt1$$Register, $cnt2$$Register,
                          icnt2, $result$$Register,
<span class="line-modified">!                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  // fast search of substring with known size.
  instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<span class="line-modified">!                              rbx_RegI result, legVecS vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">!   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
  
<span class="line-modified">!   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
    ins_encode %{
      int icnt2 = (int)$int_cnt2$$constant;
      if (icnt2 &gt;= 8) {
        // IndexOf for constant substrings with size &gt;= 8 elements
        // which don&#39;t need to be loaded through stack.
        __ string_indexofC8($str1$$Register, $str2$$Register,
                            $cnt1$$Register, $cnt2$$Register,
                            icnt2, $result$$Register,
<span class="line-modified">!                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
      } else {
        // Small strings are loaded through stack if they cross page boundary.
        __ string_indexof($str1$$Register, $str2$$Register,
                          $cnt1$$Register, $cnt2$$Register,
                          icnt2, $result$$Register,
<span class="line-modified">!                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<span class="line-modified">!                          rbx_RegI result, legVecS vec, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">!   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
  
    format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof($str1$$Register, $str2$$Register,
                        $cnt1$$Register, $cnt2$$Register,
                        (-1), $result$$Register,
<span class="line-modified">!                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<span class="line-modified">!                          rbx_RegI result, legVecS vec, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">!   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
  
    format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof($str1$$Register, $str2$$Register,
                        $cnt1$$Register, $cnt2$$Register,
                        (-1), $result$$Register,
<span class="line-modified">!                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<span class="line-modified">!                          rbx_RegI result, legVecS vec, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">!   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
  
    format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof($str1$$Register, $str2$$Register,
                        $cnt1$$Register, $cnt2$$Register,
                        (-1), $result$$Register,
<span class="line-modified">!                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
<span class="line-modified">!                               rbx_RegI result, legVecS vec1, legVecS vec2, legVecS vec3, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics);
    match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
<span class="line-modified">!   effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);</span>
    format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
<span class="line-modified">!                            $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  // fast string equals
  instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
<span class="line-modified">!                        legVecS tmp1, legVecS tmp2, rbx_RegI tmp3, rFlagsReg cr)</span>
  %{
    match(Set result (StrEquals (Binary str1 str2) cnt));
    effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
  
    format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
<span class="line-new-header">--- 11136,163 ---</span>
    ins_pipe( pipe_slow );
  %}
  
  // fast search of substring with known size.
  instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<span class="line-modified">!                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">!   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
  
<span class="line-modified">!   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}</span>
    ins_encode %{
      int icnt2 = (int)$int_cnt2$$constant;
      if (icnt2 &gt;= 16) {
        // IndexOf for constant substrings with size &gt;= 16 elements
        // which don&#39;t need to be loaded through stack.
        __ string_indexofC8($str1$$Register, $str2$$Register,
                            $cnt1$$Register, $cnt2$$Register,
                            icnt2, $result$$Register,
<span class="line-modified">!                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
      } else {
        // Small strings are loaded through stack if they cross page boundary.
        __ string_indexof($str1$$Register, $str2$$Register,
                          $cnt1$$Register, $cnt2$$Register,
                          icnt2, $result$$Register,
<span class="line-modified">!                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  // fast search of substring with known size.
  instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<span class="line-modified">!                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">!   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
  
<span class="line-modified">!   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}</span>
    ins_encode %{
      int icnt2 = (int)$int_cnt2$$constant;
      if (icnt2 &gt;= 8) {
        // IndexOf for constant substrings with size &gt;= 8 elements
        // which don&#39;t need to be loaded through stack.
        __ string_indexofC8($str1$$Register, $str2$$Register,
                            $cnt1$$Register, $cnt2$$Register,
                            icnt2, $result$$Register,
<span class="line-modified">!                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
      } else {
        // Small strings are loaded through stack if they cross page boundary.
        __ string_indexof($str1$$Register, $str2$$Register,
                          $cnt1$$Register, $cnt2$$Register,
                          icnt2, $result$$Register,
<span class="line-modified">!                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  // fast search of substring with known size.
  instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<span class="line-modified">!                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">!   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
  
<span class="line-modified">!   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}</span>
    ins_encode %{
      int icnt2 = (int)$int_cnt2$$constant;
      if (icnt2 &gt;= 8) {
        // IndexOf for constant substrings with size &gt;= 8 elements
        // which don&#39;t need to be loaded through stack.
        __ string_indexofC8($str1$$Register, $str2$$Register,
                            $cnt1$$Register, $cnt2$$Register,
                            icnt2, $result$$Register,
<span class="line-modified">!                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
      } else {
        // Small strings are loaded through stack if they cross page boundary.
        __ string_indexof($str1$$Register, $str2$$Register,
                          $cnt1$$Register, $cnt2$$Register,
                          icnt2, $result$$Register,
<span class="line-modified">!                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<span class="line-modified">!                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">!   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
  
    format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof($str1$$Register, $str2$$Register,
                        $cnt1$$Register, $cnt2$$Register,
                        (-1), $result$$Register,
<span class="line-modified">!                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<span class="line-modified">!                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">!   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
  
    format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof($str1$$Register, $str2$$Register,
                        $cnt1$$Register, $cnt2$$Register,
                        (-1), $result$$Register,
<span class="line-modified">!                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<span class="line-modified">!                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">!   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
  
    format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof($str1$$Register, $str2$$Register,
                        $cnt1$$Register, $cnt2$$Register,
                        (-1), $result$$Register,
<span class="line-modified">!                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
<span class="line-modified">!                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)</span>
  %{
    predicate(UseSSE42Intrinsics);
    match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
<span class="line-modified">!   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);</span>
    format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
<span class="line-modified">!                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  // fast string equals
  instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
<span class="line-modified">!                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)</span>
  %{
    match(Set result (StrEquals (Binary str1 str2) cnt));
    effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
  
    format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11466,11 ***</span>
    ins_pipe( pipe_slow );
  %}
  
  // fast array equals
  instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
<span class="line-modified">!                        legVecS tmp1, legVecS tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)</span>
  %{
    predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
    match(Set result (AryEq ary1 ary2));
    effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
  
<span class="line-new-header">--- 11304,11 ---</span>
    ins_pipe( pipe_slow );
  %}
  
  // fast array equals
  instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
<span class="line-modified">!                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)</span>
  %{
    predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
    match(Set result (AryEq ary1 ary2));
    effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11482,11 ***</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
<span class="line-modified">!                       legVecS tmp1, legVecS tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)</span>
  %{
    predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
    match(Set result (AryEq ary1 ary2));
    effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
  
<span class="line-new-header">--- 11320,11 ---</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
<span class="line-modified">!                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)</span>
  %{
    predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
    match(Set result (AryEq ary1 ary2));
    effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11498,11 ***</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
<span class="line-modified">!                       legVecS tmp1, legVecS tmp2, rbx_RegI tmp3, rFlagsReg cr)</span>
  %{
    match(Set result (HasNegatives ary1 len));
    effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
  
    format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
<span class="line-new-header">--- 11336,11 ---</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
<span class="line-modified">!                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)</span>
  %{
    match(Set result (HasNegatives ary1 len));
    effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
  
    format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11513,11 ***</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  // fast char[] to byte[] compression
<span class="line-modified">! instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legVecS tmp1, legVecS tmp2, legVecS tmp3, legVecS tmp4,</span>
                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
    match(Set result (StrCompressedCopy src (Binary dst len)));
    effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
  
    format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
<span class="line-new-header">--- 11351,11 ---</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  // fast char[] to byte[] compression
<span class="line-modified">! instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,</span>
                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
    match(Set result (StrCompressedCopy src (Binary dst len)));
    effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
  
    format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11529,11 ***</span>
    ins_pipe( pipe_slow );
  %}
  
  // fast byte[] to char[] inflation
  instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
<span class="line-modified">!                         legVecS tmp1, rcx_RegI tmp2, rFlagsReg cr) %{</span>
    match(Set dummy (StrInflatedCopy src (Binary dst len)));
    effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
  
    format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
    ins_encode %{
<span class="line-new-header">--- 11367,11 ---</span>
    ins_pipe( pipe_slow );
  %}
  
  // fast byte[] to char[] inflation
  instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
<span class="line-modified">!                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{</span>
    match(Set dummy (StrInflatedCopy src (Binary dst len)));
    effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
  
    format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11543,11 ***</span>
    ins_pipe( pipe_slow );
  %}
  
  // encode char[] to byte[] in ISO_8859_1
  instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
<span class="line-modified">!                           legVecS tmp1, legVecS tmp2, legVecS tmp3, legVecS tmp4,</span>
                            rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
    match(Set result (EncodeISOArray src (Binary dst len)));
    effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
  
    format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
<span class="line-new-header">--- 11381,11 ---</span>
    ins_pipe( pipe_slow );
  %}
  
  // encode char[] to byte[] in ISO_8859_1
  instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
<span class="line-modified">!                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,</span>
                            rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
    match(Set result (EncodeISOArray src (Binary dst len)));
    effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
  
    format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11840,11 ***</span>
  
  instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
  %{
    match(Set cr (CmpU src zero));
  
<span class="line-modified">!   format %{ &quot;testl  $src, $src\t# unsigned&quot; %}</span>
    opcode(0x85);
    ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
    ins_pipe(ialu_cr_reg_imm);
  %}
  
<span class="line-new-header">--- 11678,11 ---</span>
  
  instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
  %{
    match(Set cr (CmpU src zero));
  
<span class="line-modified">!   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}</span>
    opcode(0x85);
    ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
    ins_pipe(ialu_cr_reg_imm);
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11859,10 ***</span>
<span class="line-new-header">--- 11697,11 ---</span>
  %}
  
  instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
  %{
    match(Set cr (CmpP op1 (LoadP op2)));
<span class="line-added">+   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);</span>
  
    ins_cost(500); // XXX
    format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
    opcode(0x3B); /* Opcode 3B /r */
    ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11884,11 ***</span>
  // Compare raw pointer (used in out-of-heap check).
  // Only works because non-oop pointers must be raw pointers
  // and raw pointers have no anti-dependencies.
  instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
  %{
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none);</span>
    match(Set cr (CmpP op1 (LoadP op2)));
  
    format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
    opcode(0x3B); /* Opcode 3B /r */
    ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
<span class="line-new-header">--- 11723,12 ---</span>
  // Compare raw pointer (used in out-of-heap check).
  // Only works because non-oop pointers must be raw pointers
  // and raw pointers have no anti-dependencies.
  instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
  %{
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;</span>
<span class="line-added">+             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);</span>
    match(Set cr (CmpP op1 (LoadP op2)));
  
    format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
    opcode(0x3B); /* Opcode 3B /r */
    ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11909,11 ***</span>
  
  // This will generate a signed flags result. This should be OK since
  // any compare to a zero should be eq/neq.
  instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
  %{
<span class="line-modified">!   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));</span>
    match(Set cr (CmpP (LoadP op) zero));
  
    ins_cost(500); // XXX
    format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
    opcode(0xF7); /* Opcode F7 /0 */
<span class="line-new-header">--- 11749,12 ---</span>
  
  // This will generate a signed flags result. This should be OK since
  // any compare to a zero should be eq/neq.
  instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
  %{
<span class="line-modified">!   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;</span>
<span class="line-added">+             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);</span>
    match(Set cr (CmpP (LoadP op) zero));
  
    ins_cost(500); // XXX
    format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
    opcode(0xF7); /* Opcode F7 /0 */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11922,11 ***</span>
    ins_pipe(ialu_cr_reg_imm);
  %}
  
  instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
    match(Set cr (CmpP (LoadP mem) zero));
  
    format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
    ins_encode %{
      __ cmpq(r12, $mem$$Address);
<span class="line-new-header">--- 11763,13 ---</span>
    ins_pipe(ialu_cr_reg_imm);
  %}
  
  instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
  %{
<span class="line-modified">!   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;</span>
<span class="line-added">+             (CompressedKlassPointers::base() == NULL) &amp;&amp;</span>
<span class="line-added">+             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);</span>
    match(Set cr (CmpP (LoadP mem) zero));
  
    format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
    ins_encode %{
      __ cmpq(r12, $mem$$Address);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12004,11 ***</span>
    ins_pipe(ialu_cr_reg_imm);
  %}
  
  instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_base() != NULL);</span>
    match(Set cr (CmpN (LoadN mem) zero));
  
    ins_cost(500); // XXX
    format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
    ins_encode %{
<span class="line-new-header">--- 11847,11 ---</span>
    ins_pipe(ialu_cr_reg_imm);
  %}
  
  instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
  %{
<span class="line-modified">!   predicate(CompressedOops::base() != NULL);</span>
    match(Set cr (CmpN (LoadN mem) zero));
  
    ins_cost(500); // XXX
    format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12017,11 ***</span>
    ins_pipe(ialu_cr_reg_mem);
  %}
  
  instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
  %{
<span class="line-modified">!   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
    match(Set cr (CmpN (LoadN mem) zero));
  
    format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
    ins_encode %{
      __ cmpl(r12, $mem$$Address);
<span class="line-new-header">--- 11860,11 ---</span>
    ins_pipe(ialu_cr_reg_mem);
  %}
  
  instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
  %{
<span class="line-modified">!   predicate(CompressedOops::base() == NULL &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
    match(Set cr (CmpN (LoadN mem) zero));
  
    format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
    ins_encode %{
      __ cmpl(r12, $mem$$Address);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12383,11 ***</span>
  instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
    match(If cop cmp);
    effect(USE labl);
  
    ins_cost(300);
<span class="line-modified">!   format %{ &quot;j$cop,u  $labl&quot; %}</span>
    size(6);
    ins_encode %{
      Label* L = $labl$$label;
      __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
    %}
<span class="line-new-header">--- 12226,11 ---</span>
  instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
    match(If cop cmp);
    effect(USE labl);
  
    ins_cost(300);
<span class="line-modified">!   format %{ &quot;j$cop,u   $labl&quot; %}</span>
    size(6);
    ins_encode %{
      Label* L = $labl$$label;
      __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12397,11 ***</span>
  instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
    match(If cop cmp);
    effect(USE labl);
  
    ins_cost(200);
<span class="line-modified">!   format %{ &quot;j$cop,u  $labl&quot; %}</span>
    size(6);
    ins_encode %{
      Label* L = $labl$$label;
      __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
    %}
<span class="line-new-header">--- 12240,11 ---</span>
  instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
    match(If cop cmp);
    effect(USE labl);
  
    ins_cost(200);
<span class="line-modified">!   format %{ &quot;j$cop,u   $labl&quot; %}</span>
    size(6);
    ins_encode %{
      Label* L = $labl$$label;
      __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12413,14 ***</span>
    effect(USE labl);
  
    ins_cost(200);
    format %{ $$template
      if ($cop$$cmpcode == Assembler::notEqual) {
<span class="line-modified">!       $$emit$$&quot;jp,u   $labl\n\t&quot;</span>
        $$emit$$&quot;j$cop,u   $labl&quot;
      } else {
<span class="line-modified">!       $$emit$$&quot;jp,u   done\n\t&quot;</span>
        $$emit$$&quot;j$cop,u   $labl\n\t&quot;
        $$emit$$&quot;done:&quot;
      }
    %}
    ins_encode %{
<span class="line-new-header">--- 12256,14 ---</span>
    effect(USE labl);
  
    ins_cost(200);
    format %{ $$template
      if ($cop$$cmpcode == Assembler::notEqual) {
<span class="line-modified">!       $$emit$$&quot;jp,u    $labl\n\t&quot;</span>
        $$emit$$&quot;j$cop,u   $labl&quot;
      } else {
<span class="line-modified">!       $$emit$$&quot;jp,u    done\n\t&quot;</span>
        $$emit$$&quot;j$cop,u   $labl\n\t&quot;
        $$emit$$&quot;done:&quot;
      }
    %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12618,14 ***</span>
    effect(USE labl);
  
    ins_cost(300);
    format %{ $$template
      if ($cop$$cmpcode == Assembler::notEqual) {
<span class="line-modified">!       $$emit$$&quot;jp,u,s   $labl\n\t&quot;</span>
<span class="line-modified">!       $$emit$$&quot;j$cop,u,s   $labl&quot;</span>
      } else {
<span class="line-modified">!       $$emit$$&quot;jp,u,s   done\n\t&quot;</span>
        $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
        $$emit$$&quot;done:&quot;
      }
    %}
    size(4);
<span class="line-new-header">--- 12461,14 ---</span>
    effect(USE labl);
  
    ins_cost(300);
    format %{ $$template
      if ($cop$$cmpcode == Assembler::notEqual) {
<span class="line-modified">!       $$emit$$&quot;jp,u,s  $labl\n\t&quot;</span>
<span class="line-modified">!       $$emit$$&quot;j$cop,u,s  $labl&quot;</span>
      } else {
<span class="line-modified">!       $$emit$$&quot;jp,u,s  done\n\t&quot;</span>
        $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
        $$emit$$&quot;done:&quot;
      }
    %}
    size(4);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12697,11 ***</span>
  %{
    predicate(!Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
    match(SafePoint);
    effect(KILL cr);
  
<span class="line-modified">!   format %{ &quot;testl  rax, [rip + #offset_to_poll_page]\t&quot;</span>
              &quot;# Safepoint: poll for GC&quot; %}
    ins_cost(125);
    ins_encode %{
      AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
      __ testl(rax, addr);
<span class="line-new-header">--- 12540,11 ---</span>
  %{
    predicate(!Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
    match(SafePoint);
    effect(KILL cr);
  
<span class="line-modified">!   format %{ &quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;</span>
              &quot;# Safepoint: poll for GC&quot; %}
    ins_cost(125);
    ins_encode %{
      AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
      __ testl(rax, addr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12713,11 ***</span>
  %{
    predicate(Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
    match(SafePoint poll);
    effect(KILL cr, USE poll);
  
<span class="line-modified">!   format %{ &quot;testl  rax, [$poll]\t&quot;</span>
              &quot;# Safepoint: poll for GC&quot; %}
    ins_cost(125);
    ins_encode %{
      __ relocate(relocInfo::poll_type);
      __ testl(rax, Address($poll$$Register, 0));
<span class="line-new-header">--- 12556,11 ---</span>
  %{
    predicate(Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
    match(SafePoint poll);
    effect(KILL cr, USE poll);
  
<span class="line-modified">!   format %{ &quot;testl   rax, [$poll]\t&quot;</span>
              &quot;# Safepoint: poll for GC&quot; %}
    ins_cost(125);
    ins_encode %{
      __ relocate(relocInfo::poll_type);
      __ testl(rax, Address($poll$$Register, 0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12729,11 ***</span>
  %{
    predicate(SafepointMechanism::uses_thread_local_poll());
    match(SafePoint poll);
    effect(KILL cr, USE poll);
  
<span class="line-modified">!   format %{ &quot;testl  rax, [$poll]\t&quot;</span>
              &quot;# Safepoint: poll for GC&quot; %}
    ins_cost(125);
    size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
    ins_encode %{
      __ relocate(relocInfo::poll_type);
<span class="line-new-header">--- 12572,11 ---</span>
  %{
    predicate(SafepointMechanism::uses_thread_local_poll());
    match(SafePoint poll);
    effect(KILL cr, USE poll);
  
<span class="line-modified">!   format %{ &quot;testl   rax, [$poll]\t&quot;</span>
              &quot;# Safepoint: poll for GC&quot; %}
    ins_cost(125);
    size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
    ins_encode %{
      __ relocate(relocInfo::poll_type);
</pre>
<center><a href="x86_32.ad.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../zero/assembler_zero.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
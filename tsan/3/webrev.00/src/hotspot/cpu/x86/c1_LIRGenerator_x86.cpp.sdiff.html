<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRAssembler_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LinearScan_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Compilation.hpp&quot;
  27 #include &quot;c1/c1_FrameMap.hpp&quot;
  28 #include &quot;c1/c1_Instruction.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArray.hpp&quot;
  34 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  35 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  36 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  37 #include &quot;runtime/sharedRuntime.hpp&quot;
  38 #include &quot;runtime/stubRoutines.hpp&quot;

  39 #include &quot;vmreg_x86.inline.hpp&quot;
  40 
  41 #ifdef ASSERT
  42 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  43 #else
  44 #define __ gen()-&gt;lir()-&gt;
  45 #endif
  46 
  47 // Item will be loaded into a byte register; Intel only
  48 void LIRItem::load_byte_item() {
  49   load_item();
  50   LIR_Opr res = result();
  51 
  52   if (!res-&gt;is_virtual() || !_gen-&gt;is_vreg_flag_set(res, LIRGenerator::byte_reg)) {
  53     // make sure that it is a byte register
  54     assert(!value()-&gt;type()-&gt;is_float() &amp;&amp; !value()-&gt;type()-&gt;is_double(),
  55            &quot;can&#39;t load floats in byte register&quot;);
  56     LIR_Opr reg = _gen-&gt;rlock_byte(T_BYTE);
  57     __ move(res, reg);
  58 
</pre>
<hr />
<pre>
 369     } else {
 370       must_load_right = UseSSE &lt; 2 &amp;&amp; (c-&gt;is_one_double() || c-&gt;is_zero_double());
 371     }
 372   }
 373 
 374   if (must_load_both) {
 375     // frem and drem destroy also right operand, so move it to a new register
 376     right.set_destroys_register();
 377     right.load_item();
 378   } else if (right.is_register() || must_load_right) {
 379     right.load_item();
 380   } else {
 381     right.dont_load_item();
 382   }
 383   LIR_Opr reg = rlock(x);
 384   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 385   if (x-&gt;is_strictfp() &amp;&amp; (x-&gt;op() == Bytecodes::_dmul || x-&gt;op() == Bytecodes::_ddiv)) {
 386     tmp = new_register(T_DOUBLE);
 387   }
 388 




































 389   if ((UseSSE &gt;= 1 &amp;&amp; x-&gt;op() == Bytecodes::_frem) || (UseSSE &gt;= 2 &amp;&amp; x-&gt;op() == Bytecodes::_drem)) {
 390     // special handling for frem and drem: no SSE instruction, so must use FPU with temporary fpu stack slots
 391     LIR_Opr fpu0, fpu1;
 392     if (x-&gt;op() == Bytecodes::_frem) {
 393       fpu0 = LIR_OprFact::single_fpu(0);
 394       fpu1 = LIR_OprFact::single_fpu(1);
 395     } else {
 396       fpu0 = LIR_OprFact::double_fpu(0);
 397       fpu1 = LIR_OprFact::double_fpu(1);
 398     }
 399     __ move(right.result(), fpu1); // order of left and right operand is important!
 400     __ move(left.result(), fpu0);
 401     __ rem (fpu0, fpu1, fpu0);
 402     __ move(fpu0, reg);
 403 
 404   } else {
 405     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
 406   }
<span class="line-removed"> 407 </span>
 408   set_result(x, round_item(reg));

 409 }
 410 
 411 
 412 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 413 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 414   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem ) {
 415     // long division is implemented as a direct call into the runtime
 416     LIRItem left(x-&gt;x(), this);
 417     LIRItem right(x-&gt;y(), this);
 418 
 419     // the check for division by zero destroys the right operand
 420     right.set_destroys_register();
 421 
 422     BasicTypeList signature(2);
 423     signature.append(T_LONG);
 424     signature.append(T_LONG);
 425     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 426 
 427     // check for division by zero (destroys registers of right operand!)
 428     CodeEmitInfo* info = state_for(x);
 429 
 430     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 431     left.load_item_force(cc-&gt;at(1));
 432     right.load_item();
 433 
 434     __ move(right.result(), cc-&gt;at(0));
 435 
 436     __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
 437     __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));
 438 
 439     address entry = NULL;
 440     switch (x-&gt;op()) {
 441     case Bytecodes::_lrem:
 442       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
 443       break; // check if dividend is 0 is done elsewhere
 444     case Bytecodes::_ldiv:
 445       entry = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
 446       break; // check if dividend is 0 is done elsewhere
<span class="line-removed"> 447     case Bytecodes::_lmul:</span>
<span class="line-removed"> 448       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lmul);</span>
<span class="line-removed"> 449       break;</span>
 450     default:
 451       ShouldNotReachHere();
 452     }
 453 
 454     LIR_Opr result = rlock_result(x);
 455     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 456     __ move(result_reg, result);
 457   } else if (x-&gt;op() == Bytecodes::_lmul) {
 458     // missing test if instr is commutative and if we should swap
 459     LIRItem left(x-&gt;x(), this);
 460     LIRItem right(x-&gt;y(), this);
 461 
 462     // right register is destroyed by the long mul, so it must be
 463     // copied to a new register.
 464     right.set_destroys_register();
 465 
 466     left.load_item();
 467     right.load_item();
 468 
 469     LIR_Opr reg = FrameMap::long0_opr;
</pre>
<hr />
<pre>
 654   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
 655   if (tag == longTag) {
 656     left.set_destroys_register();
 657   }
 658   left.load_item();
 659   right.load_item();
 660   LIR_Opr reg = rlock_result(x);
 661 
 662   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 663     Bytecodes::Code code = x-&gt;op();
 664     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 665   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 666     __ lcmp2int(left.result(), right.result(), reg);
 667   } else {
 668     Unimplemented();
 669   }
 670 }
 671 
 672 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 673   LIR_Opr ill = LIR_OprFact::illegalOpr;  // for convenience
<span class="line-modified"> 674   if (type == T_OBJECT || type == T_ARRAY) {</span>
 675     cmp_value.load_item_force(FrameMap::rax_oop_opr);
 676     new_value.load_item();
 677     __ cas_obj(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 678   } else if (type == T_INT) {
 679     cmp_value.load_item_force(FrameMap::rax_opr);
 680     new_value.load_item();
 681     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 682   } else if (type == T_LONG) {
 683     cmp_value.load_item_force(FrameMap::long0_opr);
 684     new_value.load_item_force(FrameMap::long1_opr);
 685     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 686   } else {
 687     Unimplemented();
 688   }
 689   LIR_Opr result = new_register(T_INT);
 690   __ cmove(lir_cond_equal, LIR_OprFact::intConst(1), LIR_OprFact::intConst(0),
 691            result, T_INT);
 692   return result;
 693 }
 694 
 695 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
<span class="line-modified"> 696   bool is_oop = type == T_OBJECT || type == T_ARRAY;</span>
 697   LIR_Opr result = new_register(type);
 698   value.load_item();
 699   // Because we want a 2-arg form of xchg and xadd
 700   __ move(value.result(), result);
 701   assert(type == T_INT || is_oop LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 702   __ xchg(addr, result, result, LIR_OprFact::illegalOpr);
 703   return result;
 704 }
 705 
 706 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 707   LIR_Opr result = new_register(type);
 708   value.load_item();
 709   // Because we want a 2-arg form of xchg and xadd
 710   __ move(value.result(), result);
 711   assert(type == T_INT LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 712   __ xadd(addr, result, result, LIR_OprFact::illegalOpr);
 713   return result;
 714 }
 715 
 716 void LIRGenerator::do_FmaIntrinsic(Intrinsic* x) {
</pre>
<hr />
<pre>
1128   length.load_item_force(cc-&gt;at(2));
1129   log2ArrayIndexScale.load_item_force(cc-&gt;at(3));
1130 
1131   __ call_runtime_leaf(StubRoutines::vectorizedMismatch(), getThreadTemp(), result_reg, cc-&gt;args());
1132   __ move(result_reg, result);
1133 }
1134 
1135 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
1136 // _i2b, _i2c, _i2s
1137 LIR_Opr fixed_register_for(BasicType type) {
1138   switch (type) {
1139     case T_FLOAT:  return FrameMap::fpu0_float_opr;
1140     case T_DOUBLE: return FrameMap::fpu0_double_opr;
1141     case T_INT:    return FrameMap::rax_opr;
1142     case T_LONG:   return FrameMap::long0_opr;
1143     default:       ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
1144   }
1145 }
1146 
1147 void LIRGenerator::do_Convert(Convert* x) {









1148   // flags that vary for the different operations and different SSE-settings
1149   bool fixed_input = false, fixed_result = false, round_result = false, needs_stub = false;
1150 
1151   switch (x-&gt;op()) {
1152     case Bytecodes::_i2l: // fall through
1153     case Bytecodes::_l2i: // fall through
1154     case Bytecodes::_i2b: // fall through
1155     case Bytecodes::_i2c: // fall through
1156     case Bytecodes::_i2s: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;
1157 
1158     case Bytecodes::_f2d: fixed_input = UseSSE == 1; fixed_result = false;       round_result = false;      needs_stub = false; break;
1159     case Bytecodes::_d2f: fixed_input = false;       fixed_result = UseSSE == 1; round_result = UseSSE &lt; 1; needs_stub = false; break;
1160     case Bytecodes::_i2f: fixed_input = false;       fixed_result = false;       round_result = UseSSE &lt; 1; needs_stub = false; break;
1161     case Bytecodes::_i2d: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;
1162     case Bytecodes::_f2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;
1163     case Bytecodes::_d2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;
1164     case Bytecodes::_l2f: fixed_input = false;       fixed_result = UseSSE &gt;= 1; round_result = UseSSE &lt; 1; needs_stub = false; break;
1165     case Bytecodes::_l2d: fixed_input = false;       fixed_result = UseSSE &gt;= 2; round_result = UseSSE &lt; 2; needs_stub = false; break;
1166     case Bytecodes::_f2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;
1167     case Bytecodes::_d2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;
</pre>
<hr />
<pre>
1186   assert(fixed_result == false || round_result == false, &quot;cannot set both&quot;);
1187   if (fixed_result) {
1188     conv_result = fixed_register_for(result-&gt;type());
1189   } else if (round_result) {
1190     result = new_register(result-&gt;type());
1191     set_vreg_flag(result, must_start_in_memory);
1192   }
1193 
1194   if (needs_stub) {
1195     stub = new ConversionStub(x-&gt;op(), conv_input, conv_result);
1196   }
1197 
1198   __ convert(x-&gt;op(), conv_input, conv_result, stub);
1199 
1200   if (result != conv_result) {
1201     __ move(conv_result, result);
1202   }
1203 
1204   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1205   set_result(x, result);

1206 }
1207 
1208 
1209 void LIRGenerator::do_NewInstance(NewInstance* x) {
1210   print_if_not_loaded(x);
1211 
1212   CodeEmitInfo* info = state_for(x, x-&gt;state());
1213   LIR_Opr reg = result_register_for(x-&gt;type());
1214   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1215                        FrameMap::rcx_oop_opr,
1216                        FrameMap::rdi_oop_opr,
1217                        FrameMap::rsi_oop_opr,
1218                        LIR_OprFact::illegalOpr,
1219                        FrameMap::rdx_metadata_opr, info);
1220   LIR_Opr result = rlock_result(x);
1221   __ move(reg, result);
1222 }
1223 
1224 
1225 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Compilation.hpp&quot;
  27 #include &quot;c1/c1_FrameMap.hpp&quot;
  28 #include &quot;c1/c1_Instruction.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArray.hpp&quot;
  34 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  35 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  36 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  37 #include &quot;runtime/sharedRuntime.hpp&quot;
  38 #include &quot;runtime/stubRoutines.hpp&quot;
<span class="line-added">  39 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  40 #include &quot;vmreg_x86.inline.hpp&quot;
  41 
  42 #ifdef ASSERT
  43 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  44 #else
  45 #define __ gen()-&gt;lir()-&gt;
  46 #endif
  47 
  48 // Item will be loaded into a byte register; Intel only
  49 void LIRItem::load_byte_item() {
  50   load_item();
  51   LIR_Opr res = result();
  52 
  53   if (!res-&gt;is_virtual() || !_gen-&gt;is_vreg_flag_set(res, LIRGenerator::byte_reg)) {
  54     // make sure that it is a byte register
  55     assert(!value()-&gt;type()-&gt;is_float() &amp;&amp; !value()-&gt;type()-&gt;is_double(),
  56            &quot;can&#39;t load floats in byte register&quot;);
  57     LIR_Opr reg = _gen-&gt;rlock_byte(T_BYTE);
  58     __ move(res, reg);
  59 
</pre>
<hr />
<pre>
 370     } else {
 371       must_load_right = UseSSE &lt; 2 &amp;&amp; (c-&gt;is_one_double() || c-&gt;is_zero_double());
 372     }
 373   }
 374 
 375   if (must_load_both) {
 376     // frem and drem destroy also right operand, so move it to a new register
 377     right.set_destroys_register();
 378     right.load_item();
 379   } else if (right.is_register() || must_load_right) {
 380     right.load_item();
 381   } else {
 382     right.dont_load_item();
 383   }
 384   LIR_Opr reg = rlock(x);
 385   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 386   if (x-&gt;is_strictfp() &amp;&amp; (x-&gt;op() == Bytecodes::_dmul || x-&gt;op() == Bytecodes::_ddiv)) {
 387     tmp = new_register(T_DOUBLE);
 388   }
 389 
<span class="line-added"> 390 #ifdef _LP64</span>
<span class="line-added"> 391   if (x-&gt;op() == Bytecodes::_frem || x-&gt;op() == Bytecodes::_drem) {</span>
<span class="line-added"> 392     // frem and drem are implemented as a direct call into the runtime.</span>
<span class="line-added"> 393     LIRItem left(x-&gt;x(), this);</span>
<span class="line-added"> 394     LIRItem right(x-&gt;y(), this);</span>
<span class="line-added"> 395 </span>
<span class="line-added"> 396     BasicType bt = as_BasicType(x-&gt;type());</span>
<span class="line-added"> 397     BasicTypeList signature(2);</span>
<span class="line-added"> 398     signature.append(bt);</span>
<span class="line-added"> 399     signature.append(bt);</span>
<span class="line-added"> 400     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);</span>
<span class="line-added"> 401 </span>
<span class="line-added"> 402     const LIR_Opr result_reg = result_register_for(x-&gt;type());</span>
<span class="line-added"> 403     left.load_item_force(cc-&gt;at(0));</span>
<span class="line-added"> 404     right.load_item_force(cc-&gt;at(1));</span>
<span class="line-added"> 405 </span>
<span class="line-added"> 406     address entry = NULL;</span>
<span class="line-added"> 407     switch (x-&gt;op()) {</span>
<span class="line-added"> 408       case Bytecodes::_frem:</span>
<span class="line-added"> 409         entry = CAST_FROM_FN_PTR(address, SharedRuntime::frem);</span>
<span class="line-added"> 410         break;</span>
<span class="line-added"> 411       case Bytecodes::_drem:</span>
<span class="line-added"> 412         entry = CAST_FROM_FN_PTR(address, SharedRuntime::drem);</span>
<span class="line-added"> 413         break;</span>
<span class="line-added"> 414       default:</span>
<span class="line-added"> 415         ShouldNotReachHere();</span>
<span class="line-added"> 416     }</span>
<span class="line-added"> 417 </span>
<span class="line-added"> 418     LIR_Opr result = rlock_result(x);</span>
<span class="line-added"> 419     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());</span>
<span class="line-added"> 420     __ move(result_reg, result);</span>
<span class="line-added"> 421   } else {</span>
<span class="line-added"> 422     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);</span>
<span class="line-added"> 423     set_result(x, round_item(reg));</span>
<span class="line-added"> 424   }</span>
<span class="line-added"> 425 #else</span>
 426   if ((UseSSE &gt;= 1 &amp;&amp; x-&gt;op() == Bytecodes::_frem) || (UseSSE &gt;= 2 &amp;&amp; x-&gt;op() == Bytecodes::_drem)) {
 427     // special handling for frem and drem: no SSE instruction, so must use FPU with temporary fpu stack slots
 428     LIR_Opr fpu0, fpu1;
 429     if (x-&gt;op() == Bytecodes::_frem) {
 430       fpu0 = LIR_OprFact::single_fpu(0);
 431       fpu1 = LIR_OprFact::single_fpu(1);
 432     } else {
 433       fpu0 = LIR_OprFact::double_fpu(0);
 434       fpu1 = LIR_OprFact::double_fpu(1);
 435     }
 436     __ move(right.result(), fpu1); // order of left and right operand is important!
 437     __ move(left.result(), fpu0);
 438     __ rem (fpu0, fpu1, fpu0);
 439     __ move(fpu0, reg);
 440 
 441   } else {
 442     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
 443   }

 444   set_result(x, round_item(reg));
<span class="line-added"> 445 #endif // _LP64</span>
 446 }
 447 
 448 
 449 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 450 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 451   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem ) {
 452     // long division is implemented as a direct call into the runtime
 453     LIRItem left(x-&gt;x(), this);
 454     LIRItem right(x-&gt;y(), this);
 455 
 456     // the check for division by zero destroys the right operand
 457     right.set_destroys_register();
 458 
 459     BasicTypeList signature(2);
 460     signature.append(T_LONG);
 461     signature.append(T_LONG);
 462     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 463 
 464     // check for division by zero (destroys registers of right operand!)
 465     CodeEmitInfo* info = state_for(x);
 466 
 467     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 468     left.load_item_force(cc-&gt;at(1));
 469     right.load_item();
 470 
 471     __ move(right.result(), cc-&gt;at(0));
 472 
 473     __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
 474     __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));
 475 
 476     address entry = NULL;
 477     switch (x-&gt;op()) {
 478     case Bytecodes::_lrem:
 479       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
 480       break; // check if dividend is 0 is done elsewhere
 481     case Bytecodes::_ldiv:
 482       entry = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
 483       break; // check if dividend is 0 is done elsewhere



 484     default:
 485       ShouldNotReachHere();
 486     }
 487 
 488     LIR_Opr result = rlock_result(x);
 489     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 490     __ move(result_reg, result);
 491   } else if (x-&gt;op() == Bytecodes::_lmul) {
 492     // missing test if instr is commutative and if we should swap
 493     LIRItem left(x-&gt;x(), this);
 494     LIRItem right(x-&gt;y(), this);
 495 
 496     // right register is destroyed by the long mul, so it must be
 497     // copied to a new register.
 498     right.set_destroys_register();
 499 
 500     left.load_item();
 501     right.load_item();
 502 
 503     LIR_Opr reg = FrameMap::long0_opr;
</pre>
<hr />
<pre>
 688   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
 689   if (tag == longTag) {
 690     left.set_destroys_register();
 691   }
 692   left.load_item();
 693   right.load_item();
 694   LIR_Opr reg = rlock_result(x);
 695 
 696   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 697     Bytecodes::Code code = x-&gt;op();
 698     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 699   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 700     __ lcmp2int(left.result(), right.result(), reg);
 701   } else {
 702     Unimplemented();
 703   }
 704 }
 705 
 706 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 707   LIR_Opr ill = LIR_OprFact::illegalOpr;  // for convenience
<span class="line-modified"> 708   if (is_reference_type(type)) {</span>
 709     cmp_value.load_item_force(FrameMap::rax_oop_opr);
 710     new_value.load_item();
 711     __ cas_obj(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 712   } else if (type == T_INT) {
 713     cmp_value.load_item_force(FrameMap::rax_opr);
 714     new_value.load_item();
 715     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 716   } else if (type == T_LONG) {
 717     cmp_value.load_item_force(FrameMap::long0_opr);
 718     new_value.load_item_force(FrameMap::long1_opr);
 719     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 720   } else {
 721     Unimplemented();
 722   }
 723   LIR_Opr result = new_register(T_INT);
 724   __ cmove(lir_cond_equal, LIR_OprFact::intConst(1), LIR_OprFact::intConst(0),
 725            result, T_INT);
 726   return result;
 727 }
 728 
 729 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
<span class="line-modified"> 730   bool is_oop = is_reference_type(type);</span>
 731   LIR_Opr result = new_register(type);
 732   value.load_item();
 733   // Because we want a 2-arg form of xchg and xadd
 734   __ move(value.result(), result);
 735   assert(type == T_INT || is_oop LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 736   __ xchg(addr, result, result, LIR_OprFact::illegalOpr);
 737   return result;
 738 }
 739 
 740 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 741   LIR_Opr result = new_register(type);
 742   value.load_item();
 743   // Because we want a 2-arg form of xchg and xadd
 744   __ move(value.result(), result);
 745   assert(type == T_INT LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 746   __ xadd(addr, result, result, LIR_OprFact::illegalOpr);
 747   return result;
 748 }
 749 
 750 void LIRGenerator::do_FmaIntrinsic(Intrinsic* x) {
</pre>
<hr />
<pre>
1162   length.load_item_force(cc-&gt;at(2));
1163   log2ArrayIndexScale.load_item_force(cc-&gt;at(3));
1164 
1165   __ call_runtime_leaf(StubRoutines::vectorizedMismatch(), getThreadTemp(), result_reg, cc-&gt;args());
1166   __ move(result_reg, result);
1167 }
1168 
1169 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
1170 // _i2b, _i2c, _i2s
1171 LIR_Opr fixed_register_for(BasicType type) {
1172   switch (type) {
1173     case T_FLOAT:  return FrameMap::fpu0_float_opr;
1174     case T_DOUBLE: return FrameMap::fpu0_double_opr;
1175     case T_INT:    return FrameMap::rax_opr;
1176     case T_LONG:   return FrameMap::long0_opr;
1177     default:       ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
1178   }
1179 }
1180 
1181 void LIRGenerator::do_Convert(Convert* x) {
<span class="line-added">1182 #ifdef _LP64</span>
<span class="line-added">1183   LIRItem value(x-&gt;value(), this);</span>
<span class="line-added">1184   value.load_item();</span>
<span class="line-added">1185   LIR_Opr input = value.result();</span>
<span class="line-added">1186   LIR_Opr result = rlock(x);</span>
<span class="line-added">1187   __ convert(x-&gt;op(), input, result);</span>
<span class="line-added">1188   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);</span>
<span class="line-added">1189   set_result(x, result);</span>
<span class="line-added">1190 #else</span>
1191   // flags that vary for the different operations and different SSE-settings
1192   bool fixed_input = false, fixed_result = false, round_result = false, needs_stub = false;
1193 
1194   switch (x-&gt;op()) {
1195     case Bytecodes::_i2l: // fall through
1196     case Bytecodes::_l2i: // fall through
1197     case Bytecodes::_i2b: // fall through
1198     case Bytecodes::_i2c: // fall through
1199     case Bytecodes::_i2s: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;
1200 
1201     case Bytecodes::_f2d: fixed_input = UseSSE == 1; fixed_result = false;       round_result = false;      needs_stub = false; break;
1202     case Bytecodes::_d2f: fixed_input = false;       fixed_result = UseSSE == 1; round_result = UseSSE &lt; 1; needs_stub = false; break;
1203     case Bytecodes::_i2f: fixed_input = false;       fixed_result = false;       round_result = UseSSE &lt; 1; needs_stub = false; break;
1204     case Bytecodes::_i2d: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;
1205     case Bytecodes::_f2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;
1206     case Bytecodes::_d2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;
1207     case Bytecodes::_l2f: fixed_input = false;       fixed_result = UseSSE &gt;= 1; round_result = UseSSE &lt; 1; needs_stub = false; break;
1208     case Bytecodes::_l2d: fixed_input = false;       fixed_result = UseSSE &gt;= 2; round_result = UseSSE &lt; 2; needs_stub = false; break;
1209     case Bytecodes::_f2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;
1210     case Bytecodes::_d2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;
</pre>
<hr />
<pre>
1229   assert(fixed_result == false || round_result == false, &quot;cannot set both&quot;);
1230   if (fixed_result) {
1231     conv_result = fixed_register_for(result-&gt;type());
1232   } else if (round_result) {
1233     result = new_register(result-&gt;type());
1234     set_vreg_flag(result, must_start_in_memory);
1235   }
1236 
1237   if (needs_stub) {
1238     stub = new ConversionStub(x-&gt;op(), conv_input, conv_result);
1239   }
1240 
1241   __ convert(x-&gt;op(), conv_input, conv_result, stub);
1242 
1243   if (result != conv_result) {
1244     __ move(conv_result, result);
1245   }
1246 
1247   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1248   set_result(x, result);
<span class="line-added">1249 #endif // _LP64</span>
1250 }
1251 
1252 
1253 void LIRGenerator::do_NewInstance(NewInstance* x) {
1254   print_if_not_loaded(x);
1255 
1256   CodeEmitInfo* info = state_for(x, x-&gt;state());
1257   LIR_Opr reg = result_register_for(x-&gt;type());
1258   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1259                        FrameMap::rcx_oop_opr,
1260                        FrameMap::rdi_oop_opr,
1261                        FrameMap::rsi_oop_opr,
1262                        LIR_OprFact::illegalOpr,
1263                        FrameMap::rdx_metadata_opr, info);
1264   LIR_Opr result = rlock_result(x);
1265   __ move(reg, result);
1266 }
1267 
1268 
1269 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRAssembler_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LinearScan_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
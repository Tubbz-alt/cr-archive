<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/assembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_ASSEMBLER_X86_HPP
  26 #define CPU_X86_ASSEMBLER_X86_HPP
  27 
  28 #include &quot;asm/register.hpp&quot;
  29 #include &quot;vm_version_x86.hpp&quot;
  30 
  31 class BiasedLockingCounters;
  32 
  33 // Contains all the definitions needed for x86 assembly code generation.
  34 
  35 // Calling convention
  36 class Argument {
  37  public:
  38   enum {
  39 #ifdef _LP64
  40 #ifdef _WIN64
  41     n_int_register_parameters_c   = 4, // rcx, rdx, r8, r9 (c_rarg0, c_rarg1, ...)
  42     n_float_register_parameters_c = 4,  // xmm0 - xmm3 (c_farg0, c_farg1, ... )
  43 #else
  44     n_int_register_parameters_c   = 6, // rdi, rsi, rdx, rcx, r8, r9 (c_rarg0, c_rarg1, ...)
  45     n_float_register_parameters_c = 8,  // xmm0 - xmm7 (c_farg0, c_farg1, ... )
  46 #endif // _WIN64
  47     n_int_register_parameters_j   = 6, // j_rarg0, j_rarg1, ...
  48     n_float_register_parameters_j = 8  // j_farg0, j_farg1, ...
  49 #else
  50     n_register_parameters = 0   // 0 registers used to pass arguments
  51 #endif // _LP64
  52   };
  53 };
  54 
  55 
  56 #ifdef _LP64
  57 // Symbolically name the register arguments used by the c calling convention.
  58 // Windows is different from linux/solaris. So much for standards...
  59 
  60 #ifdef _WIN64
  61 
  62 REGISTER_DECLARATION(Register, c_rarg0, rcx);
  63 REGISTER_DECLARATION(Register, c_rarg1, rdx);
  64 REGISTER_DECLARATION(Register, c_rarg2, r8);
  65 REGISTER_DECLARATION(Register, c_rarg3, r9);
  66 
  67 REGISTER_DECLARATION(XMMRegister, c_farg0, xmm0);
  68 REGISTER_DECLARATION(XMMRegister, c_farg1, xmm1);
  69 REGISTER_DECLARATION(XMMRegister, c_farg2, xmm2);
  70 REGISTER_DECLARATION(XMMRegister, c_farg3, xmm3);
  71 
  72 #else
  73 
  74 REGISTER_DECLARATION(Register, c_rarg0, rdi);
  75 REGISTER_DECLARATION(Register, c_rarg1, rsi);
  76 REGISTER_DECLARATION(Register, c_rarg2, rdx);
  77 REGISTER_DECLARATION(Register, c_rarg3, rcx);
  78 REGISTER_DECLARATION(Register, c_rarg4, r8);
  79 REGISTER_DECLARATION(Register, c_rarg5, r9);
  80 
  81 REGISTER_DECLARATION(XMMRegister, c_farg0, xmm0);
  82 REGISTER_DECLARATION(XMMRegister, c_farg1, xmm1);
  83 REGISTER_DECLARATION(XMMRegister, c_farg2, xmm2);
  84 REGISTER_DECLARATION(XMMRegister, c_farg3, xmm3);
  85 REGISTER_DECLARATION(XMMRegister, c_farg4, xmm4);
  86 REGISTER_DECLARATION(XMMRegister, c_farg5, xmm5);
  87 REGISTER_DECLARATION(XMMRegister, c_farg6, xmm6);
  88 REGISTER_DECLARATION(XMMRegister, c_farg7, xmm7);
  89 
  90 #endif // _WIN64
  91 
  92 // Symbolically name the register arguments used by the Java calling convention.
  93 // We have control over the convention for java so we can do what we please.
  94 // What pleases us is to offset the java calling convention so that when
  95 // we call a suitable jni method the arguments are lined up and we don&#39;t
  96 // have to do little shuffling. A suitable jni method is non-static and a
  97 // small number of arguments (two fewer args on windows)
  98 //
  99 //        |-------------------------------------------------------|
 100 //        | c_rarg0   c_rarg1  c_rarg2 c_rarg3 c_rarg4 c_rarg5    |
 101 //        |-------------------------------------------------------|
 102 //        | rcx       rdx      r8      r9      rdi*    rsi*       | windows (* not a c_rarg)
 103 //        | rdi       rsi      rdx     rcx     r8      r9         | solaris/linux
 104 //        |-------------------------------------------------------|
 105 //        | j_rarg5   j_rarg0  j_rarg1 j_rarg2 j_rarg3 j_rarg4    |
 106 //        |-------------------------------------------------------|
 107 
 108 REGISTER_DECLARATION(Register, j_rarg0, c_rarg1);
 109 REGISTER_DECLARATION(Register, j_rarg1, c_rarg2);
 110 REGISTER_DECLARATION(Register, j_rarg2, c_rarg3);
 111 // Windows runs out of register args here
 112 #ifdef _WIN64
 113 REGISTER_DECLARATION(Register, j_rarg3, rdi);
 114 REGISTER_DECLARATION(Register, j_rarg4, rsi);
 115 #else
 116 REGISTER_DECLARATION(Register, j_rarg3, c_rarg4);
 117 REGISTER_DECLARATION(Register, j_rarg4, c_rarg5);
 118 #endif /* _WIN64 */
 119 REGISTER_DECLARATION(Register, j_rarg5, c_rarg0);
 120 
 121 REGISTER_DECLARATION(XMMRegister, j_farg0, xmm0);
 122 REGISTER_DECLARATION(XMMRegister, j_farg1, xmm1);
 123 REGISTER_DECLARATION(XMMRegister, j_farg2, xmm2);
 124 REGISTER_DECLARATION(XMMRegister, j_farg3, xmm3);
 125 REGISTER_DECLARATION(XMMRegister, j_farg4, xmm4);
 126 REGISTER_DECLARATION(XMMRegister, j_farg5, xmm5);
 127 REGISTER_DECLARATION(XMMRegister, j_farg6, xmm6);
 128 REGISTER_DECLARATION(XMMRegister, j_farg7, xmm7);
 129 
 130 REGISTER_DECLARATION(Register, rscratch1, r10);  // volatile
 131 REGISTER_DECLARATION(Register, rscratch2, r11);  // volatile
 132 
 133 REGISTER_DECLARATION(Register, r12_heapbase, r12); // callee-saved
 134 REGISTER_DECLARATION(Register, r15_thread, r15); // callee-saved
 135 
 136 #else
 137 // rscratch1 will apear in 32bit code that is dead but of course must compile
 138 // Using noreg ensures if the dead code is incorrectly live and executed it
 139 // will cause an assertion failure
 140 #define rscratch1 noreg
 141 #define rscratch2 noreg
 142 
 143 #endif // _LP64
 144 
 145 // JSR 292
 146 // On x86, the SP does not have to be saved when invoking method handle intrinsics
 147 // or compiled lambda forms. We indicate that by setting rbp_mh_SP_save to noreg.
 148 REGISTER_DECLARATION(Register, rbp_mh_SP_save, noreg);
 149 
 150 // Address is an abstraction used to represent a memory location
 151 // using any of the amd64 addressing modes with one object.
 152 //
 153 // Note: A register location is represented via a Register, not
 154 //       via an address for efficiency &amp; simplicity reasons.
 155 
 156 class ArrayAddress;
 157 
 158 class Address {
 159  public:
 160   enum ScaleFactor {
 161     no_scale = -1,
 162     times_1  =  0,
 163     times_2  =  1,
 164     times_4  =  2,
 165     times_8  =  3,
 166     times_ptr = LP64_ONLY(times_8) NOT_LP64(times_4)
 167   };
 168   static ScaleFactor times(int size) {
 169     assert(size &gt;= 1 &amp;&amp; size &lt;= 8 &amp;&amp; is_power_of_2(size), &quot;bad scale size&quot;);
 170     if (size == 8)  return times_8;
 171     if (size == 4)  return times_4;
 172     if (size == 2)  return times_2;
 173     return times_1;
 174   }
 175   static int scale_size(ScaleFactor scale) {
 176     assert(scale != no_scale, &quot;&quot;);
 177     assert(((1 &lt;&lt; (int)times_1) == 1 &amp;&amp;
 178             (1 &lt;&lt; (int)times_2) == 2 &amp;&amp;
 179             (1 &lt;&lt; (int)times_4) == 4 &amp;&amp;
 180             (1 &lt;&lt; (int)times_8) == 8), &quot;&quot;);
 181     return (1 &lt;&lt; (int)scale);
 182   }
 183 
 184  private:
 185   Register         _base;
 186   Register         _index;
 187   XMMRegister      _xmmindex;
 188   ScaleFactor      _scale;
 189   int              _disp;
 190   bool             _isxmmindex;
 191   RelocationHolder _rspec;
 192 
 193   // Easily misused constructors make them private
 194   // %%% can we make these go away?
 195   NOT_LP64(Address(address loc, RelocationHolder spec);)
 196   Address(int disp, address loc, relocInfo::relocType rtype);
 197   Address(int disp, address loc, RelocationHolder spec);
 198 
 199  public:
 200 
 201  int disp() { return _disp; }
 202   // creation
 203   Address()
 204     : _base(noreg),
 205       _index(noreg),
 206       _xmmindex(xnoreg),
 207       _scale(no_scale),
 208       _disp(0),
 209       _isxmmindex(false){
 210   }
 211 
 212   // No default displacement otherwise Register can be implicitly
 213   // converted to 0(Register) which is quite a different animal.
 214 
 215   Address(Register base, int disp)
 216     : _base(base),
 217       _index(noreg),
 218       _xmmindex(xnoreg),
 219       _scale(no_scale),
 220       _disp(disp),
 221       _isxmmindex(false){
 222   }
 223 
 224   Address(Register base, Register index, ScaleFactor scale, int disp = 0)
 225     : _base (base),
 226       _index(index),
 227       _xmmindex(xnoreg),
 228       _scale(scale),
 229       _disp (disp),
 230       _isxmmindex(false) {
 231     assert(!index-&gt;is_valid() == (scale == Address::no_scale),
 232            &quot;inconsistent address&quot;);
 233   }
 234 
 235   Address(Register base, RegisterOrConstant index, ScaleFactor scale = times_1, int disp = 0)
 236     : _base (base),
 237       _index(index.register_or_noreg()),
 238       _xmmindex(xnoreg),
 239       _scale(scale),
 240       _disp (disp + (index.constant_or_zero() * scale_size(scale))),
 241       _isxmmindex(false){
 242     if (!index.is_register())  scale = Address::no_scale;
 243     assert(!_index-&gt;is_valid() == (scale == Address::no_scale),
 244            &quot;inconsistent address&quot;);
 245   }
 246 
 247   Address(Register base, XMMRegister index, ScaleFactor scale, int disp = 0)
 248     : _base (base),
 249       _index(noreg),
 250       _xmmindex(index),
 251       _scale(scale),
 252       _disp(disp),
 253       _isxmmindex(true) {
 254       assert(!index-&gt;is_valid() == (scale == Address::no_scale),
 255              &quot;inconsistent address&quot;);
 256   }
 257 
 258   Address plus_disp(int disp) const {
 259     Address a = (*this);
 260     a._disp += disp;
 261     return a;
 262   }
 263   Address plus_disp(RegisterOrConstant disp, ScaleFactor scale = times_1) const {
 264     Address a = (*this);
 265     a._disp += disp.constant_or_zero() * scale_size(scale);
 266     if (disp.is_register()) {
 267       assert(!a.index()-&gt;is_valid(), &quot;competing indexes&quot;);
 268       a._index = disp.as_register();
 269       a._scale = scale;
 270     }
 271     return a;
 272   }
 273   bool is_same_address(Address a) const {
 274     // disregard _rspec
 275     return _base == a._base &amp;&amp; _disp == a._disp &amp;&amp; _index == a._index &amp;&amp; _scale == a._scale;
 276   }
 277 
 278   // The following two overloads are used in connection with the
 279   // ByteSize type (see sizes.hpp).  They simplify the use of
 280   // ByteSize&#39;d arguments in assembly code. Note that their equivalent
 281   // for the optimized build are the member functions with int disp
 282   // argument since ByteSize is mapped to an int type in that case.
 283   //
 284   // Note: DO NOT introduce similar overloaded functions for WordSize
 285   // arguments as in the optimized mode, both ByteSize and WordSize
 286   // are mapped to the same type and thus the compiler cannot make a
 287   // distinction anymore (=&gt; compiler errors).
 288 
 289 #ifdef ASSERT
 290   Address(Register base, ByteSize disp)
 291     : _base(base),
 292       _index(noreg),
 293       _xmmindex(xnoreg),
 294       _scale(no_scale),
 295       _disp(in_bytes(disp)),
 296       _isxmmindex(false){
 297   }
 298 
 299   Address(Register base, Register index, ScaleFactor scale, ByteSize disp)
 300     : _base(base),
 301       _index(index),
 302       _xmmindex(xnoreg),
 303       _scale(scale),
 304       _disp(in_bytes(disp)),
 305       _isxmmindex(false){
 306     assert(!index-&gt;is_valid() == (scale == Address::no_scale),
 307            &quot;inconsistent address&quot;);
 308   }
 309   Address(Register base, RegisterOrConstant index, ScaleFactor scale, ByteSize disp)
 310     : _base (base),
 311       _index(index.register_or_noreg()),
 312       _xmmindex(xnoreg),
 313       _scale(scale),
 314       _disp (in_bytes(disp) + (index.constant_or_zero() * scale_size(scale))),
 315       _isxmmindex(false) {
 316     if (!index.is_register())  scale = Address::no_scale;
 317     assert(!_index-&gt;is_valid() == (scale == Address::no_scale),
 318            &quot;inconsistent address&quot;);
 319   }
 320 
 321 #endif // ASSERT
 322 
 323   // accessors
 324   bool        uses(Register reg) const { return _base == reg || _index == reg; }
 325   Register    base()             const { return _base;  }
 326   Register    index()            const { return _index; }
 327   XMMRegister xmmindex()         const { return _xmmindex; }
 328   ScaleFactor scale()            const { return _scale; }
 329   int         disp()             const { return _disp;  }
 330   bool        isxmmindex()       const { return _isxmmindex; }
 331 
 332   // Convert the raw encoding form into the form expected by the constructor for
 333   // Address.  An index of 4 (rsp) corresponds to having no index, so convert
 334   // that to noreg for the Address constructor.
 335   static Address make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc);
 336 
 337   static Address make_array(ArrayAddress);
 338 
 339  private:
 340   bool base_needs_rex() const {
 341     return _base != noreg &amp;&amp; _base-&gt;encoding() &gt;= 8;
 342   }
 343 
 344   bool index_needs_rex() const {
 345     return _index != noreg &amp;&amp;_index-&gt;encoding() &gt;= 8;
 346   }
 347 
 348   bool xmmindex_needs_rex() const {
 349     return _xmmindex != xnoreg &amp;&amp; _xmmindex-&gt;encoding() &gt;= 8;
 350   }
 351 
 352   relocInfo::relocType reloc() const { return _rspec.type(); }
 353 
 354   friend class Assembler;
 355   friend class MacroAssembler;
 356   friend class LIR_Assembler; // base/index/scale/disp
 357 };
 358 
 359 //
 360 // AddressLiteral has been split out from Address because operands of this type
 361 // need to be treated specially on 32bit vs. 64bit platforms. By splitting it out
 362 // the few instructions that need to deal with address literals are unique and the
 363 // MacroAssembler does not have to implement every instruction in the Assembler
 364 // in order to search for address literals that may need special handling depending
 365 // on the instruction and the platform. As small step on the way to merging i486/amd64
 366 // directories.
 367 //
 368 class AddressLiteral {
 369   friend class ArrayAddress;
 370   RelocationHolder _rspec;
 371   // Typically we use AddressLiterals we want to use their rval
 372   // However in some situations we want the lval (effect address) of the item.
 373   // We provide a special factory for making those lvals.
 374   bool _is_lval;
 375 
 376   // If the target is far we&#39;ll need to load the ea of this to
 377   // a register to reach it. Otherwise if near we can do rip
 378   // relative addressing.
 379 
 380   address          _target;
 381 
 382  protected:
 383   // creation
 384   AddressLiteral()
 385     : _is_lval(false),
 386       _target(NULL)
 387   {}
 388 
 389   public:
 390 
 391 
 392   AddressLiteral(address target, relocInfo::relocType rtype);
 393 
 394   AddressLiteral(address target, RelocationHolder const&amp; rspec)
 395     : _rspec(rspec),
 396       _is_lval(false),
 397       _target(target)
 398   {}
 399 
 400   AddressLiteral addr() {
 401     AddressLiteral ret = *this;
 402     ret._is_lval = true;
 403     return ret;
 404   }
 405 
 406 
 407  private:
 408 
 409   address target() { return _target; }
 410   bool is_lval() { return _is_lval; }
 411 
 412   relocInfo::relocType reloc() const { return _rspec.type(); }
 413   const RelocationHolder&amp; rspec() const { return _rspec; }
 414 
 415   friend class Assembler;
 416   friend class MacroAssembler;
 417   friend class Address;
 418   friend class LIR_Assembler;
 419 };
 420 
 421 // Convience classes
 422 class RuntimeAddress: public AddressLiteral {
 423 
 424   public:
 425 
 426   RuntimeAddress(address target) : AddressLiteral(target, relocInfo::runtime_call_type) {}
 427 
 428 };
 429 
 430 class ExternalAddress: public AddressLiteral {
 431  private:
 432   static relocInfo::relocType reloc_for_target(address target) {
 433     // Sometimes ExternalAddress is used for values which aren&#39;t
 434     // exactly addresses, like the card table base.
 435     // external_word_type can&#39;t be used for values in the first page
 436     // so just skip the reloc in that case.
 437     return external_word_Relocation::can_be_relocated(target) ? relocInfo::external_word_type : relocInfo::none;
 438   }
 439 
 440  public:
 441 
 442   ExternalAddress(address target) : AddressLiteral(target, reloc_for_target(target)) {}
 443 
 444 };
 445 
 446 class InternalAddress: public AddressLiteral {
 447 
 448   public:
 449 
 450   InternalAddress(address target) : AddressLiteral(target, relocInfo::internal_word_type) {}
 451 
 452 };
 453 
 454 // x86 can do array addressing as a single operation since disp can be an absolute
 455 // address amd64 can&#39;t. We create a class that expresses the concept but does extra
 456 // magic on amd64 to get the final result
 457 
 458 class ArrayAddress {
 459   private:
 460 
 461   AddressLiteral _base;
 462   Address        _index;
 463 
 464   public:
 465 
 466   ArrayAddress() {};
 467   ArrayAddress(AddressLiteral base, Address index): _base(base), _index(index) {};
 468   AddressLiteral base() { return _base; }
 469   Address index() { return _index; }
 470 
 471 };
 472 
 473 class InstructionAttr;
 474 
 475 // 64-bit refect the fxsave size which is 512 bytes and the new xsave area on EVEX which is another 2176 bytes
 476 // See fxsave and xsave(EVEX enabled) documentation for layout
 477 const int FPUStateSizeInWords = NOT_LP64(27) LP64_ONLY(2688 / wordSize);
 478 
 479 // The Intel x86/Amd64 Assembler: Pure assembler doing NO optimizations on the instruction
 480 // level (e.g. mov rax, 0 is not translated into xor rax, rax!); i.e., what you write
 481 // is what you get. The Assembler is generating code into a CodeBuffer.
 482 
 483 class Assembler : public AbstractAssembler  {
 484   friend class AbstractAssembler; // for the non-virtual hack
 485   friend class LIR_Assembler; // as_Address()
 486   friend class StubGenerator;
 487 
 488  public:
 489   enum Condition {                     // The x86 condition codes used for conditional jumps/moves.
 490     zero          = 0x4,
 491     notZero       = 0x5,
 492     equal         = 0x4,
 493     notEqual      = 0x5,
 494     less          = 0xc,
 495     lessEqual     = 0xe,
 496     greater       = 0xf,
 497     greaterEqual  = 0xd,
 498     below         = 0x2,
 499     belowEqual    = 0x6,
 500     above         = 0x7,
 501     aboveEqual    = 0x3,
 502     overflow      = 0x0,
 503     noOverflow    = 0x1,
 504     carrySet      = 0x2,
 505     carryClear    = 0x3,
 506     negative      = 0x8,
 507     positive      = 0x9,
 508     parity        = 0xa,
 509     noParity      = 0xb
 510   };
 511 
 512   enum Prefix {
 513     // segment overrides
 514     CS_segment = 0x2e,
 515     SS_segment = 0x36,
 516     DS_segment = 0x3e,
 517     ES_segment = 0x26,
 518     FS_segment = 0x64,
 519     GS_segment = 0x65,
 520 
 521     REX        = 0x40,
 522 
 523     REX_B      = 0x41,
 524     REX_X      = 0x42,
 525     REX_XB     = 0x43,
 526     REX_R      = 0x44,
 527     REX_RB     = 0x45,
 528     REX_RX     = 0x46,
 529     REX_RXB    = 0x47,
 530 
 531     REX_W      = 0x48,
 532 
 533     REX_WB     = 0x49,
 534     REX_WX     = 0x4A,
 535     REX_WXB    = 0x4B,
 536     REX_WR     = 0x4C,
 537     REX_WRB    = 0x4D,
 538     REX_WRX    = 0x4E,
 539     REX_WRXB   = 0x4F,
 540 
 541     VEX_3bytes = 0xC4,
 542     VEX_2bytes = 0xC5,
 543     EVEX_4bytes = 0x62,
 544     Prefix_EMPTY = 0x0
 545   };
 546 
 547   enum VexPrefix {
 548     VEX_B = 0x20,
 549     VEX_X = 0x40,
 550     VEX_R = 0x80,
 551     VEX_W = 0x80
 552   };
 553 
 554   enum ExexPrefix {
 555     EVEX_F  = 0x04,
 556     EVEX_V  = 0x08,
 557     EVEX_Rb = 0x10,
 558     EVEX_X  = 0x40,
 559     EVEX_Z  = 0x80
 560   };
 561 
 562   enum VexSimdPrefix {
 563     VEX_SIMD_NONE = 0x0,
 564     VEX_SIMD_66   = 0x1,
 565     VEX_SIMD_F3   = 0x2,
 566     VEX_SIMD_F2   = 0x3
 567   };
 568 
 569   enum VexOpcode {
 570     VEX_OPCODE_NONE  = 0x0,
 571     VEX_OPCODE_0F    = 0x1,
 572     VEX_OPCODE_0F_38 = 0x2,
 573     VEX_OPCODE_0F_3A = 0x3,
 574     VEX_OPCODE_MASK  = 0x1F
 575   };
 576 
 577   enum AvxVectorLen {
 578     AVX_128bit = 0x0,
 579     AVX_256bit = 0x1,
 580     AVX_512bit = 0x2,
 581     AVX_NoVec  = 0x4
 582   };
 583 
 584   enum EvexTupleType {
 585     EVEX_FV   = 0,
 586     EVEX_HV   = 4,
 587     EVEX_FVM  = 6,
 588     EVEX_T1S  = 7,
 589     EVEX_T1F  = 11,
 590     EVEX_T2   = 13,
 591     EVEX_T4   = 15,
 592     EVEX_T8   = 17,
 593     EVEX_HVM  = 18,
 594     EVEX_QVM  = 19,
 595     EVEX_OVM  = 20,
 596     EVEX_M128 = 21,
 597     EVEX_DUP  = 22,
 598     EVEX_ETUP = 23
 599   };
 600 
 601   enum EvexInputSizeInBits {
 602     EVEX_8bit  = 0,
 603     EVEX_16bit = 1,
 604     EVEX_32bit = 2,
 605     EVEX_64bit = 3,
 606     EVEX_NObit = 4
 607   };
 608 
 609   enum WhichOperand {
 610     // input to locate_operand, and format code for relocations
 611     imm_operand  = 0,            // embedded 32-bit|64-bit immediate operand
 612     disp32_operand = 1,          // embedded 32-bit displacement or address
 613     call32_operand = 2,          // embedded 32-bit self-relative displacement
 614 #ifndef _LP64
 615     _WhichOperand_limit = 3
 616 #else
 617      narrow_oop_operand = 3,     // embedded 32-bit immediate narrow oop
 618     _WhichOperand_limit = 4
 619 #endif
 620   };
 621 
 622   enum ComparisonPredicate {
 623     eq = 0,
 624     lt = 1,
 625     le = 2,
 626     _false = 3,
 627     neq = 4,
 628     nlt = 5,
 629     nle = 6,
 630     _true = 7
 631   };
 632 
 633 
 634   // NOTE: The general philopsophy of the declarations here is that 64bit versions
 635   // of instructions are freely declared without the need for wrapping them an ifdef.
 636   // (Some dangerous instructions are ifdef&#39;s out of inappropriate jvm&#39;s.)
 637   // In the .cpp file the implementations are wrapped so that they are dropped out
 638   // of the resulting jvm. This is done mostly to keep the footprint of MINIMAL
 639   // to the size it was prior to merging up the 32bit and 64bit assemblers.
 640   //
 641   // This does mean you&#39;ll get a linker/runtime error if you use a 64bit only instruction
 642   // in a 32bit vm. This is somewhat unfortunate but keeps the ifdef noise down.
 643 
 644 private:
 645 
 646   bool _legacy_mode_bw;
 647   bool _legacy_mode_dq;
 648   bool _legacy_mode_vl;
 649   bool _legacy_mode_vlbw;
 650   bool _is_managed;
 651   bool _vector_masking;    // For stub code use only
 652 
 653   class InstructionAttr *_attributes;
 654 
 655   // 64bit prefixes
 656   int prefix_and_encode(int reg_enc, bool byteinst = false);
 657   int prefixq_and_encode(int reg_enc);
 658 
 659   int prefix_and_encode(int dst_enc, int src_enc) {
 660     return prefix_and_encode(dst_enc, false, src_enc, false);
 661   }
 662   int prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte);
 663   int prefixq_and_encode(int dst_enc, int src_enc);
 664 
 665   void prefix(Register reg);
 666   void prefix(Register dst, Register src, Prefix p);
 667   void prefix(Register dst, Address adr, Prefix p);
 668   void prefix(Address adr);
 669   void prefixq(Address adr);
 670 
 671   void prefix(Address adr, Register reg,  bool byteinst = false);
 672   void prefix(Address adr, XMMRegister reg);
 673   void prefixq(Address adr, Register reg);
 674   void prefixq(Address adr, XMMRegister reg);
 675 
 676   void prefetch_prefix(Address src);
 677 
 678   void rex_prefix(Address adr, XMMRegister xreg,
 679                   VexSimdPrefix pre, VexOpcode opc, bool rex_w);
 680   int  rex_prefix_and_encode(int dst_enc, int src_enc,
 681                              VexSimdPrefix pre, VexOpcode opc, bool rex_w);
 682 
 683   void vex_prefix(bool vex_r, bool vex_b, bool vex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc);
 684 
 685   void evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v,
 686                    int nds_enc, VexSimdPrefix pre, VexOpcode opc);
 687 
 688   void vex_prefix(Address adr, int nds_enc, int xreg_enc,
 689                   VexSimdPrefix pre, VexOpcode opc,
 690                   InstructionAttr *attributes);
 691 
 692   int  vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc,
 693                              VexSimdPrefix pre, VexOpcode opc,
 694                              InstructionAttr *attributes);
 695 
 696   void simd_prefix(XMMRegister xreg, XMMRegister nds, Address adr, VexSimdPrefix pre,
 697                    VexOpcode opc, InstructionAttr *attributes);
 698 
 699   int simd_prefix_and_encode(XMMRegister dst, XMMRegister nds, XMMRegister src, VexSimdPrefix pre,
 700                              VexOpcode opc, InstructionAttr *attributes);
 701 
 702   // Helper functions for groups of instructions
 703   void emit_arith_b(int op1, int op2, Register dst, int imm8);
 704 
 705   void emit_arith(int op1, int op2, Register dst, int32_t imm32);
 706   // Force generation of a 4 byte immediate value even if it fits into 8bit
 707   void emit_arith_imm32(int op1, int op2, Register dst, int32_t imm32);
 708   void emit_arith(int op1, int op2, Register dst, Register src);
 709 
 710   bool emit_compressed_disp_byte(int &amp;disp);
 711 
 712   void emit_operand(Register reg,
 713                     Register base, Register index, Address::ScaleFactor scale,
 714                     int disp,
 715                     RelocationHolder const&amp; rspec,
 716                     int rip_relative_correction = 0);
 717 
 718   void emit_operand(XMMRegister reg, Register base, XMMRegister index,
 719                     Address::ScaleFactor scale,
 720                     int disp, RelocationHolder const&amp; rspec);
 721 
 722   void emit_operand(Register reg, Address adr, int rip_relative_correction = 0);
 723 
 724   // operands that only take the original 32bit registers
 725   void emit_operand32(Register reg, Address adr);
 726 
 727   void emit_operand(XMMRegister reg,
 728                     Register base, Register index, Address::ScaleFactor scale,
 729                     int disp,
 730                     RelocationHolder const&amp; rspec);
 731 
 732   void emit_operand(XMMRegister reg, Address adr);
 733 
 734   void emit_operand(MMXRegister reg, Address adr);
 735 
 736   // workaround gcc (3.2.1-7) bug
 737   void emit_operand(Address adr, MMXRegister reg);
 738 
 739 
 740   // Immediate-to-memory forms
 741   void emit_arith_operand(int op1, Register rm, Address adr, int32_t imm32);
 742 
 743   void emit_farith(int b1, int b2, int i);
 744 
 745 
 746  protected:
 747   #ifdef ASSERT
 748   void check_relocation(RelocationHolder const&amp; rspec, int format);
 749   #endif
 750 
 751   void emit_data(jint data, relocInfo::relocType    rtype, int format);
 752   void emit_data(jint data, RelocationHolder const&amp; rspec, int format);
 753   void emit_data64(jlong data, relocInfo::relocType rtype, int format = 0);
 754   void emit_data64(jlong data, RelocationHolder const&amp; rspec, int format = 0);
 755 
 756   bool reachable(AddressLiteral adr) NOT_LP64({ return true;});
 757 
 758   // These are all easily abused and hence protected
 759 
 760   // 32BIT ONLY SECTION
 761 #ifndef _LP64
 762   // Make these disappear in 64bit mode since they would never be correct
 763   void cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec);   // 32BIT ONLY
 764   void cmp_literal32(Address src1, int32_t imm32, RelocationHolder const&amp; rspec);    // 32BIT ONLY
 765 
 766   void mov_literal32(Register dst, int32_t imm32, RelocationHolder const&amp; rspec);    // 32BIT ONLY
 767   void mov_literal32(Address dst, int32_t imm32, RelocationHolder const&amp; rspec);     // 32BIT ONLY
 768 
 769   void push_literal32(int32_t imm32, RelocationHolder const&amp; rspec);                 // 32BIT ONLY
 770 #else
 771   // 64BIT ONLY SECTION
 772   void mov_literal64(Register dst, intptr_t imm64, RelocationHolder const&amp; rspec);   // 64BIT ONLY
 773 
 774   void cmp_narrow_oop(Register src1, int32_t imm32, RelocationHolder const&amp; rspec);
 775   void cmp_narrow_oop(Address src1, int32_t imm32, RelocationHolder const&amp; rspec);
 776 
 777   void mov_narrow_oop(Register dst, int32_t imm32, RelocationHolder const&amp; rspec);
 778   void mov_narrow_oop(Address dst, int32_t imm32, RelocationHolder const&amp; rspec);
 779 #endif // _LP64
 780 
 781   // These are unique in that we are ensured by the caller that the 32bit
 782   // relative in these instructions will always be able to reach the potentially
 783   // 64bit address described by entry. Since they can take a 64bit address they
 784   // don&#39;t have the 32 suffix like the other instructions in this class.
 785 
 786   void call_literal(address entry, RelocationHolder const&amp; rspec);
 787   void jmp_literal(address entry, RelocationHolder const&amp; rspec);
 788 
 789   // Avoid using directly section
 790   // Instructions in this section are actually usable by anyone without danger
 791   // of failure but have performance issues that are addressed my enhanced
 792   // instructions which will do the proper thing base on the particular cpu.
 793   // We protect them because we don&#39;t trust you...
 794 
 795   // Don&#39;t use next inc() and dec() methods directly. INC &amp; DEC instructions
 796   // could cause a partial flag stall since they don&#39;t set CF flag.
 797   // Use MacroAssembler::decrement() &amp; MacroAssembler::increment() methods
 798   // which call inc() &amp; dec() or add() &amp; sub() in accordance with
 799   // the product flag UseIncDec value.
 800 
 801   void decl(Register dst);
 802   void decl(Address dst);
 803   void decq(Register dst);
 804   void decq(Address dst);
 805 
 806   void incl(Register dst);
 807   void incl(Address dst);
 808   void incq(Register dst);
 809   void incq(Address dst);
 810 
 811   // New cpus require use of movsd and movss to avoid partial register stall
 812   // when loading from memory. But for old Opteron use movlpd instead of movsd.
 813   // The selection is done in MacroAssembler::movdbl() and movflt().
 814 
 815   // Move Scalar Single-Precision Floating-Point Values
 816   void movss(XMMRegister dst, Address src);
 817   void movss(XMMRegister dst, XMMRegister src);
 818   void movss(Address dst, XMMRegister src);
 819 
 820   // Move Scalar Double-Precision Floating-Point Values
 821   void movsd(XMMRegister dst, Address src);
 822   void movsd(XMMRegister dst, XMMRegister src);
 823   void movsd(Address dst, XMMRegister src);
 824   void movlpd(XMMRegister dst, Address src);
 825 
 826   // New cpus require use of movaps and movapd to avoid partial register stall
 827   // when moving between registers.
 828   void movaps(XMMRegister dst, XMMRegister src);
 829   void movapd(XMMRegister dst, XMMRegister src);
 830 
 831   // End avoid using directly
 832 
 833 
 834   // Instruction prefixes
 835   void prefix(Prefix p);
 836 
 837   public:
 838 
 839   // Creation
 840   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
 841     init_attributes();
 842   }
 843 
 844   // Decoding
 845   static address locate_operand(address inst, WhichOperand which);
 846   static address locate_next_instruction(address inst);
 847 
 848   // Utilities
 849   static bool is_polling_page_far() NOT_LP64({ return false;});
 850   static bool query_compressed_disp_byte(int disp, bool is_evex_inst, int vector_len,
 851                                          int cur_tuple_type, int in_size_in_bits, int cur_encoding);
 852 
 853   // Generic instructions
 854   // Does 32bit or 64bit as needed for the platform. In some sense these
 855   // belong in macro assembler but there is no need for both varieties to exist
 856 
 857   void init_attributes(void) {
 858     _legacy_mode_bw = (VM_Version::supports_avx512bw() == false);
 859     _legacy_mode_dq = (VM_Version::supports_avx512dq() == false);
 860     _legacy_mode_vl = (VM_Version::supports_avx512vl() == false);
 861     _legacy_mode_vlbw = (VM_Version::supports_avx512vlbw() == false);
 862     _is_managed = false;
 863     _vector_masking = false;
 864     _attributes = NULL;
 865   }
 866 
 867   void set_attributes(InstructionAttr *attributes) { _attributes = attributes; }
 868   void clear_attributes(void) { _attributes = NULL; }
 869 
 870   void set_managed(void) { _is_managed = true; }
 871   void clear_managed(void) { _is_managed = false; }
 872   bool is_managed(void) { return _is_managed; }
 873 
 874   void lea(Register dst, Address src);
 875 
 876   void mov(Register dst, Register src);
 877 
 878   void pusha();
 879   void popa();
 880 
 881   void pushf();
 882   void popf();
 883 
 884   void push(int32_t imm32);
 885 
 886   void push(Register src);
 887 
 888   void pop(Register dst);
 889 
 890   // These are dummies to prevent surprise implicit conversions to Register
 891   void push(void* v);
 892   void pop(void* v);
 893 
 894   // These do register sized moves/scans
 895   void rep_mov();
 896   void rep_stos();
 897   void rep_stosb();
 898   void repne_scan();
 899 #ifdef _LP64
 900   void repne_scanl();
 901 #endif
 902 
 903   // Vanilla instructions in lexical order
 904 
 905   void adcl(Address dst, int32_t imm32);
 906   void adcl(Address dst, Register src);
 907   void adcl(Register dst, int32_t imm32);
 908   void adcl(Register dst, Address src);
 909   void adcl(Register dst, Register src);
 910 
 911   void adcq(Register dst, int32_t imm32);
 912   void adcq(Register dst, Address src);
 913   void adcq(Register dst, Register src);
 914 
 915   void addb(Address dst, int imm8);
 916   void addw(Address dst, int imm16);
 917 
 918   void addl(Address dst, int32_t imm32);
 919   void addl(Address dst, Register src);
 920   void addl(Register dst, int32_t imm32);
 921   void addl(Register dst, Address src);
 922   void addl(Register dst, Register src);
 923 
 924   void addq(Address dst, int32_t imm32);
 925   void addq(Address dst, Register src);
 926   void addq(Register dst, int32_t imm32);
 927   void addq(Register dst, Address src);
 928   void addq(Register dst, Register src);
 929 
 930 #ifdef _LP64
 931  //Add Unsigned Integers with Carry Flag
 932   void adcxq(Register dst, Register src);
 933 
 934  //Add Unsigned Integers with Overflow Flag
 935   void adoxq(Register dst, Register src);
 936 #endif
 937 
 938   void addr_nop_4();
 939   void addr_nop_5();
 940   void addr_nop_7();
 941   void addr_nop_8();
 942 
 943   // Add Scalar Double-Precision Floating-Point Values
 944   void addsd(XMMRegister dst, Address src);
 945   void addsd(XMMRegister dst, XMMRegister src);
 946 
 947   // Add Scalar Single-Precision Floating-Point Values
 948   void addss(XMMRegister dst, Address src);
 949   void addss(XMMRegister dst, XMMRegister src);
 950 
 951   // AES instructions
 952   void aesdec(XMMRegister dst, Address src);
 953   void aesdec(XMMRegister dst, XMMRegister src);
 954   void aesdeclast(XMMRegister dst, Address src);
 955   void aesdeclast(XMMRegister dst, XMMRegister src);
 956   void aesenc(XMMRegister dst, Address src);
 957   void aesenc(XMMRegister dst, XMMRegister src);
 958   void aesenclast(XMMRegister dst, Address src);
 959   void aesenclast(XMMRegister dst, XMMRegister src);
 960   void vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
 961   void vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
 962 
 963   void andl(Address  dst, int32_t imm32);
 964   void andl(Register dst, int32_t imm32);
 965   void andl(Register dst, Address src);
 966   void andl(Register dst, Register src);
 967 
 968   void andq(Address  dst, int32_t imm32);
 969   void andq(Register dst, int32_t imm32);
 970   void andq(Register dst, Address src);
 971   void andq(Register dst, Register src);
 972 
 973   // BMI instructions
 974   void andnl(Register dst, Register src1, Register src2);
 975   void andnl(Register dst, Register src1, Address src2);
 976   void andnq(Register dst, Register src1, Register src2);
 977   void andnq(Register dst, Register src1, Address src2);
 978 
 979   void blsil(Register dst, Register src);
 980   void blsil(Register dst, Address src);
 981   void blsiq(Register dst, Register src);
 982   void blsiq(Register dst, Address src);
 983 
 984   void blsmskl(Register dst, Register src);
 985   void blsmskl(Register dst, Address src);
 986   void blsmskq(Register dst, Register src);
 987   void blsmskq(Register dst, Address src);
 988 
 989   void blsrl(Register dst, Register src);
 990   void blsrl(Register dst, Address src);
 991   void blsrq(Register dst, Register src);
 992   void blsrq(Register dst, Address src);
 993 
 994   void bsfl(Register dst, Register src);
 995   void bsrl(Register dst, Register src);
 996 
 997 #ifdef _LP64
 998   void bsfq(Register dst, Register src);
 999   void bsrq(Register dst, Register src);
1000 #endif
1001 
1002   void bswapl(Register reg);
1003 
1004   void bswapq(Register reg);
1005 
1006   void call(Label&amp; L, relocInfo::relocType rtype);
1007   void call(Register reg);  // push pc; pc &lt;- reg
1008   void call(Address adr);   // push pc; pc &lt;- adr
1009 
1010   void cdql();
1011 
1012   void cdqq();
1013 
1014   void cld();
1015 
1016   void clflush(Address adr);
1017 
1018   void cmovl(Condition cc, Register dst, Register src);
1019   void cmovl(Condition cc, Register dst, Address src);
1020 
1021   void cmovq(Condition cc, Register dst, Register src);
1022   void cmovq(Condition cc, Register dst, Address src);
1023 
1024 
1025   void cmpb(Address dst, int imm8);
1026 
1027   void cmpl(Address dst, int32_t imm32);
1028 
1029   void cmpl(Register dst, int32_t imm32);
1030   void cmpl(Register dst, Register src);
1031   void cmpl(Register dst, Address src);
1032 
1033   void cmpq(Address dst, int32_t imm32);
1034   void cmpq(Address dst, Register src);
1035 
1036   void cmpq(Register dst, int32_t imm32);
1037   void cmpq(Register dst, Register src);
1038   void cmpq(Register dst, Address src);
1039 
1040   // these are dummies used to catch attempting to convert NULL to Register
1041   void cmpl(Register dst, void* junk); // dummy
1042   void cmpq(Register dst, void* junk); // dummy
1043 
1044   void cmpw(Address dst, int imm16);
1045 
1046   void cmpxchg8 (Address adr);
1047 
1048   void cmpxchgb(Register reg, Address adr);
1049   void cmpxchgl(Register reg, Address adr);
1050 
1051   void cmpxchgq(Register reg, Address adr);
1052 
1053   // Ordered Compare Scalar Double-Precision Floating-Point Values and set EFLAGS
1054   void comisd(XMMRegister dst, Address src);
1055   void comisd(XMMRegister dst, XMMRegister src);
1056 
1057   // Ordered Compare Scalar Single-Precision Floating-Point Values and set EFLAGS
1058   void comiss(XMMRegister dst, Address src);
1059   void comiss(XMMRegister dst, XMMRegister src);
1060 
1061   // Identify processor type and features
1062   void cpuid();
1063 
1064   // CRC32C
1065   void crc32(Register crc, Register v, int8_t sizeInBytes);
1066   void crc32(Register crc, Address adr, int8_t sizeInBytes);
1067 
1068   // Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value
1069   void cvtsd2ss(XMMRegister dst, XMMRegister src);
1070   void cvtsd2ss(XMMRegister dst, Address src);
1071 
1072   // Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value
1073   void cvtsi2sdl(XMMRegister dst, Register src);
1074   void cvtsi2sdl(XMMRegister dst, Address src);
1075   void cvtsi2sdq(XMMRegister dst, Register src);
1076   void cvtsi2sdq(XMMRegister dst, Address src);
1077 
1078   // Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value
1079   void cvtsi2ssl(XMMRegister dst, Register src);
1080   void cvtsi2ssl(XMMRegister dst, Address src);
1081   void cvtsi2ssq(XMMRegister dst, Register src);
1082   void cvtsi2ssq(XMMRegister dst, Address src);
1083 
1084   // Convert Packed Signed Doubleword Integers to Packed Double-Precision Floating-Point Value
1085   void cvtdq2pd(XMMRegister dst, XMMRegister src);
1086 
1087   // Convert Packed Signed Doubleword Integers to Packed Single-Precision Floating-Point Value
1088   void cvtdq2ps(XMMRegister dst, XMMRegister src);
1089 
1090   // Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value
1091   void cvtss2sd(XMMRegister dst, XMMRegister src);
1092   void cvtss2sd(XMMRegister dst, Address src);
1093 
1094   // Convert with Truncation Scalar Double-Precision Floating-Point Value to Doubleword Integer
1095   void cvttsd2sil(Register dst, Address src);
1096   void cvttsd2sil(Register dst, XMMRegister src);
1097   void cvttsd2siq(Register dst, XMMRegister src);
1098 
1099   // Convert with Truncation Scalar Single-Precision Floating-Point Value to Doubleword Integer
1100   void cvttss2sil(Register dst, XMMRegister src);
1101   void cvttss2siq(Register dst, XMMRegister src);
1102 
1103   void cvttpd2dq(XMMRegister dst, XMMRegister src);
1104 
1105   // Divide Scalar Double-Precision Floating-Point Values
1106   void divsd(XMMRegister dst, Address src);
1107   void divsd(XMMRegister dst, XMMRegister src);
1108 
1109   // Divide Scalar Single-Precision Floating-Point Values
1110   void divss(XMMRegister dst, Address src);
1111   void divss(XMMRegister dst, XMMRegister src);
1112 
1113   void emms();
1114 
1115   void fabs();
1116 
1117   void fadd(int i);
1118 
1119   void fadd_d(Address src);
1120   void fadd_s(Address src);
1121 
1122   // &quot;Alternate&quot; versions of x87 instructions place result down in FPU
1123   // stack instead of on TOS
1124 
1125   void fadda(int i); // &quot;alternate&quot; fadd
1126   void faddp(int i = 1);
1127 
1128   void fchs();
1129 
1130   void fcom(int i);
1131 
1132   void fcomp(int i = 1);
1133   void fcomp_d(Address src);
1134   void fcomp_s(Address src);
1135 
1136   void fcompp();
1137 
1138   void fcos();
1139 
1140   void fdecstp();
1141 
1142   void fdiv(int i);
1143   void fdiv_d(Address src);
1144   void fdivr_s(Address src);
1145   void fdiva(int i);  // &quot;alternate&quot; fdiv
1146   void fdivp(int i = 1);
1147 
1148   void fdivr(int i);
1149   void fdivr_d(Address src);
1150   void fdiv_s(Address src);
1151 
1152   void fdivra(int i); // &quot;alternate&quot; reversed fdiv
1153 
1154   void fdivrp(int i = 1);
1155 
1156   void ffree(int i = 0);
1157 
1158   void fild_d(Address adr);
1159   void fild_s(Address adr);
1160 
1161   void fincstp();
1162 
1163   void finit();
1164 
1165   void fist_s (Address adr);
1166   void fistp_d(Address adr);
1167   void fistp_s(Address adr);
1168 
1169   void fld1();
1170 
1171   void fld_d(Address adr);
1172   void fld_s(Address adr);
1173   void fld_s(int index);
1174   void fld_x(Address adr);  // extended-precision (80-bit) format
1175 
1176   void fldcw(Address src);
1177 
1178   void fldenv(Address src);
1179 
1180   void fldlg2();
1181 
1182   void fldln2();
1183 
1184   void fldz();
1185 
1186   void flog();
1187   void flog10();
1188 
1189   void fmul(int i);
1190 
1191   void fmul_d(Address src);
1192   void fmul_s(Address src);
1193 
1194   void fmula(int i);  // &quot;alternate&quot; fmul
1195 
1196   void fmulp(int i = 1);
1197 
1198   void fnsave(Address dst);
1199 
1200   void fnstcw(Address src);
1201 
1202   void fnstsw_ax();
1203 
1204   void fprem();
1205   void fprem1();
1206 
1207   void frstor(Address src);
1208 
1209   void fsin();
1210 
1211   void fsqrt();
1212 
1213   void fst_d(Address adr);
1214   void fst_s(Address adr);
1215 
1216   void fstp_d(Address adr);
1217   void fstp_d(int index);
1218   void fstp_s(Address adr);
1219   void fstp_x(Address adr); // extended-precision (80-bit) format
1220 
1221   void fsub(int i);
1222   void fsub_d(Address src);
1223   void fsub_s(Address src);
1224 
1225   void fsuba(int i);  // &quot;alternate&quot; fsub
1226 
1227   void fsubp(int i = 1);
1228 
1229   void fsubr(int i);
1230   void fsubr_d(Address src);
1231   void fsubr_s(Address src);
1232 
1233   void fsubra(int i); // &quot;alternate&quot; reversed fsub
1234 
1235   void fsubrp(int i = 1);
1236 
1237   void ftan();
1238 
1239   void ftst();
1240 
1241   void fucomi(int i = 1);
1242   void fucomip(int i = 1);
1243 
1244   void fwait();
1245 
1246   void fxch(int i = 1);
1247 
1248   void fxrstor(Address src);
1249   void xrstor(Address src);
1250 
1251   void fxsave(Address dst);
1252   void xsave(Address dst);
1253 
1254   void fyl2x();
1255   void frndint();
1256   void f2xm1();
1257   void fldl2e();
1258 
1259   void hlt();
1260 
1261   void idivl(Register src);
1262   void divl(Register src); // Unsigned division
1263 
1264 #ifdef _LP64
1265   void idivq(Register src);
1266 #endif
1267 
1268   void imull(Register src);
1269   void imull(Register dst, Register src);
1270   void imull(Register dst, Register src, int value);
1271   void imull(Register dst, Address src);
1272 
1273 #ifdef _LP64
1274   void imulq(Register dst, Register src);
1275   void imulq(Register dst, Register src, int value);
1276   void imulq(Register dst, Address src);
1277 #endif
1278 
1279   // jcc is the generic conditional branch generator to run-
1280   // time routines, jcc is used for branches to labels. jcc
1281   // takes a branch opcode (cc) and a label (L) and generates
1282   // either a backward branch or a forward branch and links it
1283   // to the label fixup chain. Usage:
1284   //
1285   // Label L;      // unbound label
1286   // jcc(cc, L);   // forward branch to unbound label
1287   // bind(L);      // bind label to the current pc
1288   // jcc(cc, L);   // backward branch to bound label
1289   // bind(L);      // illegal: a label may be bound only once
1290   //
1291   // Note: The same Label can be used for forward and backward branches
1292   // but it may be bound only once.
1293 
1294   void jcc(Condition cc, Label&amp; L, bool maybe_short = true);
1295 
1296   // Conditional jump to a 8-bit offset to L.
1297   // WARNING: be very careful using this for forward jumps.  If the label is
1298   // not bound within an 8-bit offset of this instruction, a run-time error
1299   // will occur.
1300 
1301   // Use macro to record file and line number.
1302   #define jccb(cc, L) jccb_0(cc, L, __FILE__, __LINE__)
1303 
1304   void jccb_0(Condition cc, Label&amp; L, const char* file, int line);
1305 
1306   void jmp(Address entry);    // pc &lt;- entry
1307 
1308   // Label operations &amp; relative jumps (PPUM Appendix D)
1309   void jmp(Label&amp; L, bool maybe_short = true);   // unconditional jump to L
1310 
1311   void jmp(Register entry); // pc &lt;- entry
1312 
1313   // Unconditional 8-bit offset jump to L.
1314   // WARNING: be very careful using this for forward jumps.  If the label is
1315   // not bound within an 8-bit offset of this instruction, a run-time error
1316   // will occur.
1317 
1318   // Use macro to record file and line number.
1319   #define jmpb(L) jmpb_0(L, __FILE__, __LINE__)
1320 
1321   void jmpb_0(Label&amp; L, const char* file, int line);
1322 
1323   void ldmxcsr( Address src );
1324 
1325   void leal(Register dst, Address src);
1326 
1327   void leaq(Register dst, Address src);
1328 
1329   void lfence();
1330 
1331   void lock();
1332 
1333   void lzcntl(Register dst, Register src);
1334 
1335 #ifdef _LP64
1336   void lzcntq(Register dst, Register src);
1337 #endif
1338 
1339   enum Membar_mask_bits {
1340     StoreStore = 1 &lt;&lt; 3,
1341     LoadStore  = 1 &lt;&lt; 2,
1342     StoreLoad  = 1 &lt;&lt; 1,
1343     LoadLoad   = 1 &lt;&lt; 0
1344   };
1345 
1346   // Serializes memory and blows flags
1347   void membar(Membar_mask_bits order_constraint) {
1348     // We only have to handle StoreLoad
1349     if (order_constraint &amp; StoreLoad) {
1350       // All usable chips support &quot;locked&quot; instructions which suffice
1351       // as barriers, and are much faster than the alternative of
1352       // using cpuid instruction. We use here a locked add [esp-C],0.
1353       // This is conveniently otherwise a no-op except for blowing
1354       // flags, and introducing a false dependency on target memory
1355       // location. We can&#39;t do anything with flags, but we can avoid
1356       // memory dependencies in the current method by locked-adding
1357       // somewhere else on the stack. Doing [esp+C] will collide with
1358       // something on stack in current method, hence we go for [esp-C].
1359       // It is convenient since it is almost always in data cache, for
1360       // any small C.  We need to step back from SP to avoid data
1361       // dependencies with other things on below SP (callee-saves, for
1362       // example). Without a clear way to figure out the minimal safe
1363       // distance from SP, it makes sense to step back the complete
1364       // cache line, as this will also avoid possible second-order effects
1365       // with locked ops against the cache line. Our choice of offset
1366       // is bounded by x86 operand encoding, which should stay within
1367       // [-128; +127] to have the 8-byte displacement encoding.
1368       //
1369       // Any change to this code may need to revisit other places in
1370       // the code where this idiom is used, in particular the
1371       // orderAccess code.
1372 
1373       int offset = -VM_Version::L1_line_size();
1374       if (offset &lt; -128) {
1375         offset = -128;
1376       }
1377 
1378       lock();
1379       addl(Address(rsp, offset), 0);// Assert the lock# signal here
1380     }
1381   }
1382 
1383   void mfence();
1384 
1385   // Moves
1386 
1387   void mov64(Register dst, int64_t imm64);
1388 
1389   void movb(Address dst, Register src);
1390   void movb(Address dst, int imm8);
1391   void movb(Register dst, Address src);
1392 
1393   void movddup(XMMRegister dst, XMMRegister src);
1394 
1395   void kmovbl(KRegister dst, Register src);
1396   void kmovbl(Register dst, KRegister src);
1397   void kmovwl(KRegister dst, Register src);
1398   void kmovwl(KRegister dst, Address src);
1399   void kmovwl(Register dst, KRegister src);
1400   void kmovdl(KRegister dst, Register src);
1401   void kmovdl(Register dst, KRegister src);
1402   void kmovql(KRegister dst, KRegister src);
1403   void kmovql(Address dst, KRegister src);
1404   void kmovql(KRegister dst, Address src);
1405   void kmovql(KRegister dst, Register src);
1406   void kmovql(Register dst, KRegister src);
1407 
1408   void knotwl(KRegister dst, KRegister src);
1409 
1410   void kortestbl(KRegister dst, KRegister src);
1411   void kortestwl(KRegister dst, KRegister src);
1412   void kortestdl(KRegister dst, KRegister src);
1413   void kortestql(KRegister dst, KRegister src);
1414 
1415   void ktestq(KRegister src1, KRegister src2);
1416   void ktestd(KRegister src1, KRegister src2);
1417 
1418   void ktestql(KRegister dst, KRegister src);
1419 
1420   void movdl(XMMRegister dst, Register src);
1421   void movdl(Register dst, XMMRegister src);
1422   void movdl(XMMRegister dst, Address src);
1423   void movdl(Address dst, XMMRegister src);
1424 
1425   // Move Double Quadword
1426   void movdq(XMMRegister dst, Register src);
1427   void movdq(Register dst, XMMRegister src);
1428 
1429   // Move Aligned Double Quadword
1430   void movdqa(XMMRegister dst, XMMRegister src);
1431   void movdqa(XMMRegister dst, Address src);
1432 
1433   // Move Unaligned Double Quadword
1434   void movdqu(Address     dst, XMMRegister src);
1435   void movdqu(XMMRegister dst, Address src);
1436   void movdqu(XMMRegister dst, XMMRegister src);
1437 
1438   // Move Unaligned 256bit Vector
1439   void vmovdqu(Address dst, XMMRegister src);
1440   void vmovdqu(XMMRegister dst, Address src);
1441   void vmovdqu(XMMRegister dst, XMMRegister src);
1442 
1443    // Move Unaligned 512bit Vector
1444   void evmovdqub(Address dst, XMMRegister src, int vector_len);
1445   void evmovdqub(XMMRegister dst, Address src, int vector_len);
1446   void evmovdqub(XMMRegister dst, XMMRegister src, int vector_len);
1447   void evmovdqub(XMMRegister dst, KRegister mask, Address src, int vector_len);
1448   void evmovdquw(Address dst, XMMRegister src, int vector_len);
1449   void evmovdquw(Address dst, KRegister mask, XMMRegister src, int vector_len);
1450   void evmovdquw(XMMRegister dst, Address src, int vector_len);
1451   void evmovdquw(XMMRegister dst, KRegister mask, Address src, int vector_len);
1452   void evmovdqul(Address dst, XMMRegister src, int vector_len);
1453   void evmovdqul(XMMRegister dst, Address src, int vector_len);
1454   void evmovdqul(XMMRegister dst, XMMRegister src, int vector_len);
1455   void evmovdquq(Address dst, XMMRegister src, int vector_len);
1456   void evmovdquq(XMMRegister dst, Address src, int vector_len);
1457   void evmovdquq(XMMRegister dst, XMMRegister src, int vector_len);
1458 
1459   // Move lower 64bit to high 64bit in 128bit register
1460   void movlhps(XMMRegister dst, XMMRegister src);
1461 
1462   void movl(Register dst, int32_t imm32);
1463   void movl(Address dst, int32_t imm32);
1464   void movl(Register dst, Register src);
1465   void movl(Register dst, Address src);
1466   void movl(Address dst, Register src);
1467 
1468   // These dummies prevent using movl from converting a zero (like NULL) into Register
1469   // by giving the compiler two choices it can&#39;t resolve
1470 
1471   void movl(Address  dst, void* junk);
1472   void movl(Register dst, void* junk);
1473 
1474 #ifdef _LP64
1475   void movq(Register dst, Register src);
1476   void movq(Register dst, Address src);
1477   void movq(Address  dst, Register src);
1478 #endif
1479 
1480   void movq(Address     dst, MMXRegister src );
1481   void movq(MMXRegister dst, Address src );
1482 
1483 #ifdef _LP64
1484   // These dummies prevent using movq from converting a zero (like NULL) into Register
1485   // by giving the compiler two choices it can&#39;t resolve
1486 
1487   void movq(Address  dst, void* dummy);
1488   void movq(Register dst, void* dummy);
1489 #endif
1490 
1491   // Move Quadword
1492   void movq(Address     dst, XMMRegister src);
1493   void movq(XMMRegister dst, Address src);
1494 
1495   void movsbl(Register dst, Address src);
1496   void movsbl(Register dst, Register src);
1497 
1498 #ifdef _LP64
1499   void movsbq(Register dst, Address src);
1500   void movsbq(Register dst, Register src);
1501 
1502   // Move signed 32bit immediate to 64bit extending sign
1503   void movslq(Address  dst, int32_t imm64);
1504   void movslq(Register dst, int32_t imm64);
1505 
1506   void movslq(Register dst, Address src);
1507   void movslq(Register dst, Register src);
1508   void movslq(Register dst, void* src); // Dummy declaration to cause NULL to be ambiguous
1509 #endif
1510 
1511   void movswl(Register dst, Address src);
1512   void movswl(Register dst, Register src);
1513 
1514 #ifdef _LP64
1515   void movswq(Register dst, Address src);
1516   void movswq(Register dst, Register src);
1517 #endif
1518 
1519   void movw(Address dst, int imm16);
1520   void movw(Register dst, Address src);
1521   void movw(Address dst, Register src);
1522 
1523   void movzbl(Register dst, Address src);
1524   void movzbl(Register dst, Register src);
1525 
1526 #ifdef _LP64
1527   void movzbq(Register dst, Address src);
1528   void movzbq(Register dst, Register src);
1529 #endif
1530 
1531   void movzwl(Register dst, Address src);
1532   void movzwl(Register dst, Register src);
1533 
1534 #ifdef _LP64
1535   void movzwq(Register dst, Address src);
1536   void movzwq(Register dst, Register src);
1537 #endif
1538 
1539   // Unsigned multiply with RAX destination register
1540   void mull(Address src);
1541   void mull(Register src);
1542 
1543 #ifdef _LP64
1544   void mulq(Address src);
1545   void mulq(Register src);
1546   void mulxq(Register dst1, Register dst2, Register src);
1547 #endif
1548 
1549   // Multiply Scalar Double-Precision Floating-Point Values
1550   void mulsd(XMMRegister dst, Address src);
1551   void mulsd(XMMRegister dst, XMMRegister src);
1552 
1553   // Multiply Scalar Single-Precision Floating-Point Values
1554   void mulss(XMMRegister dst, Address src);
1555   void mulss(XMMRegister dst, XMMRegister src);
1556 
1557   void negl(Register dst);
1558 
1559 #ifdef _LP64
1560   void negq(Register dst);
1561 #endif
1562 
1563   void nop(int i = 1);
1564 
1565   void notl(Register dst);
1566 
1567 #ifdef _LP64
1568   void notq(Register dst);
1569 #endif
1570 
1571   void orl(Address dst, int32_t imm32);
1572   void orl(Register dst, int32_t imm32);
1573   void orl(Register dst, Address src);
1574   void orl(Register dst, Register src);
1575   void orl(Address dst, Register src);
1576 
1577   void orb(Address dst, int imm8);
1578 
1579   void orq(Address dst, int32_t imm32);
1580   void orq(Register dst, int32_t imm32);
1581   void orq(Register dst, Address src);
1582   void orq(Register dst, Register src);
1583 
1584   // Pack with unsigned saturation
1585   void packuswb(XMMRegister dst, XMMRegister src);
1586   void packuswb(XMMRegister dst, Address src);
1587   void vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1588 
1589   // Pemutation of 64bit words
1590   void vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len);
1591   void vpermq(XMMRegister dst, XMMRegister src, int imm8);
1592   void vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8);
1593   void vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8);
1594   void evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1595 
1596   void pause();
1597 
1598   // Undefined Instruction
1599   void ud2();
1600 
1601   // SSE4.2 string instructions
1602   void pcmpestri(XMMRegister xmm1, XMMRegister xmm2, int imm8);
1603   void pcmpestri(XMMRegister xmm1, Address src, int imm8);
1604 
1605   void pcmpeqb(XMMRegister dst, XMMRegister src);
1606   void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1607   void evpcmpeqb(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1608   void evpcmpeqb(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1609   void evpcmpeqb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len);
1610 
1611   void evpcmpgtb(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1612   void evpcmpgtb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len);
1613 
1614   void evpcmpuw(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len);
1615   void evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate of, int vector_len);
1616   void evpcmpuw(KRegister kdst, XMMRegister nds, Address src, ComparisonPredicate vcc, int vector_len);
1617 
1618   void pcmpeqw(XMMRegister dst, XMMRegister src);
1619   void vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1620   void evpcmpeqw(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1621   void evpcmpeqw(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1622 
1623   void pcmpeqd(XMMRegister dst, XMMRegister src);
1624   void vpcmpeqd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1625   void evpcmpeqd(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1626   void evpcmpeqd(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1627 
1628   void pcmpeqq(XMMRegister dst, XMMRegister src);
1629   void vpcmpeqq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1630   void evpcmpeqq(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1631   void evpcmpeqq(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1632 
1633   void pmovmskb(Register dst, XMMRegister src);
1634   void vpmovmskb(Register dst, XMMRegister src);
1635 
1636   // SSE 4.1 extract
1637   void pextrd(Register dst, XMMRegister src, int imm8);
1638   void pextrq(Register dst, XMMRegister src, int imm8);
1639   void pextrd(Address dst, XMMRegister src, int imm8);
1640   void pextrq(Address dst, XMMRegister src, int imm8);
1641   void pextrb(Address dst, XMMRegister src, int imm8);
1642   // SSE 2 extract
1643   void pextrw(Register dst, XMMRegister src, int imm8);
1644   void pextrw(Address dst, XMMRegister src, int imm8);
1645 
1646   // SSE 4.1 insert
1647   void pinsrd(XMMRegister dst, Register src, int imm8);
1648   void pinsrq(XMMRegister dst, Register src, int imm8);
1649   void pinsrd(XMMRegister dst, Address src, int imm8);
1650   void pinsrq(XMMRegister dst, Address src, int imm8);
1651   void pinsrb(XMMRegister dst, Address src, int imm8);
1652   // SSE 2 insert
1653   void pinsrw(XMMRegister dst, Register src, int imm8);
1654   void pinsrw(XMMRegister dst, Address src, int imm8);
1655 
1656   // SSE4.1 packed move
1657   void pmovzxbw(XMMRegister dst, XMMRegister src);
1658   void pmovzxbw(XMMRegister dst, Address src);
1659 
1660   void vpmovzxbw( XMMRegister dst, Address src, int vector_len);
1661   void vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len);
1662   void evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len);
1663 
1664   void evpmovwb(Address dst, XMMRegister src, int vector_len);
1665   void evpmovwb(Address dst, KRegister mask, XMMRegister src, int vector_len);
1666 
1667   void vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len);
1668 
1669   void evpmovdb(Address dst, XMMRegister src, int vector_len);
1670 
1671   // Multiply add
1672   void pmaddwd(XMMRegister dst, XMMRegister src);
1673   void vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1674   // Multiply add accumulate
1675   void evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1676 
1677 #ifndef _LP64 // no 32bit push/pop on amd64
1678   void popl(Address dst);
1679 #endif
1680 
1681 #ifdef _LP64
1682   void popq(Address dst);
1683 #endif
1684 
1685   void popcntl(Register dst, Address src);
1686   void popcntl(Register dst, Register src);
1687 
1688   void vpopcntd(XMMRegister dst, XMMRegister src, int vector_len);
1689 
1690 #ifdef _LP64
1691   void popcntq(Register dst, Address src);
1692   void popcntq(Register dst, Register src);
1693 #endif
1694 
1695   // Prefetches (SSE, SSE2, 3DNOW only)
1696 
1697   void prefetchnta(Address src);
1698   void prefetchr(Address src);
1699   void prefetcht0(Address src);
1700   void prefetcht1(Address src);
1701   void prefetcht2(Address src);
1702   void prefetchw(Address src);
1703 
1704   // Shuffle Bytes
1705   void pshufb(XMMRegister dst, XMMRegister src);
1706   void pshufb(XMMRegister dst, Address src);
1707   void vpshufb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1708 
1709   // Shuffle Packed Doublewords
1710   void pshufd(XMMRegister dst, XMMRegister src, int mode);
1711   void pshufd(XMMRegister dst, Address src,     int mode);
1712   void vpshufd(XMMRegister dst, XMMRegister src, int mode, int vector_len);
1713 
1714   // Shuffle Packed Low Words
1715   void pshuflw(XMMRegister dst, XMMRegister src, int mode);
1716   void pshuflw(XMMRegister dst, Address src,     int mode);
1717 
1718   // Shuffle packed values at 128 bit granularity
1719   void evshufi64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len);
1720 
1721   // Shift Right by bytes Logical DoubleQuadword Immediate
1722   void psrldq(XMMRegister dst, int shift);
1723   // Shift Left by bytes Logical DoubleQuadword Immediate
1724   void pslldq(XMMRegister dst, int shift);
1725 
1726   // Logical Compare 128bit
1727   void ptest(XMMRegister dst, XMMRegister src);
1728   void ptest(XMMRegister dst, Address src);
1729   // Logical Compare 256bit
1730   void vptest(XMMRegister dst, XMMRegister src);
1731   void vptest(XMMRegister dst, Address src);
1732 
1733   // Interleave Low Bytes
1734   void punpcklbw(XMMRegister dst, XMMRegister src);
1735   void punpcklbw(XMMRegister dst, Address src);
1736 
1737   // Interleave Low Doublewords
1738   void punpckldq(XMMRegister dst, XMMRegister src);
1739   void punpckldq(XMMRegister dst, Address src);
1740 
1741   // Interleave Low Quadwords
1742   void punpcklqdq(XMMRegister dst, XMMRegister src);
1743 
1744 #ifndef _LP64 // no 32bit push/pop on amd64
1745   void pushl(Address src);
1746 #endif
1747 
1748   void pushq(Address src);
1749 
1750   void rcll(Register dst, int imm8);
1751 
1752   void rclq(Register dst, int imm8);
1753 
1754   void rcrq(Register dst, int imm8);
1755 
1756   void rcpps(XMMRegister dst, XMMRegister src);
1757 
1758   void rcpss(XMMRegister dst, XMMRegister src);
1759 
1760   void rdtsc();
1761 
1762   void ret(int imm16);
1763 
1764 #ifdef _LP64
1765   void rorq(Register dst, int imm8);
1766   void rorxq(Register dst, Register src, int imm8);
1767   void rorxd(Register dst, Register src, int imm8);
1768 #endif
1769 
1770   void sahf();
1771 
1772   void sarl(Register dst, int imm8);
1773   void sarl(Register dst);
1774 
1775   void sarq(Register dst, int imm8);
1776   void sarq(Register dst);
1777 
1778   void sbbl(Address dst, int32_t imm32);
1779   void sbbl(Register dst, int32_t imm32);
1780   void sbbl(Register dst, Address src);
1781   void sbbl(Register dst, Register src);
1782 
1783   void sbbq(Address dst, int32_t imm32);
1784   void sbbq(Register dst, int32_t imm32);
1785   void sbbq(Register dst, Address src);
1786   void sbbq(Register dst, Register src);
1787 
1788   void setb(Condition cc, Register dst);
1789 
1790   void palignr(XMMRegister dst, XMMRegister src, int imm8);
1791   void vpalignr(XMMRegister dst, XMMRegister src1, XMMRegister src2, int imm8, int vector_len);
1792   void evalignq(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
1793 
1794   void pblendw(XMMRegister dst, XMMRegister src, int imm8);
1795 
1796   void sha1rnds4(XMMRegister dst, XMMRegister src, int imm8);
1797   void sha1nexte(XMMRegister dst, XMMRegister src);
1798   void sha1msg1(XMMRegister dst, XMMRegister src);
1799   void sha1msg2(XMMRegister dst, XMMRegister src);
1800   // xmm0 is implicit additional source to the following instruction.
1801   void sha256rnds2(XMMRegister dst, XMMRegister src);
1802   void sha256msg1(XMMRegister dst, XMMRegister src);
1803   void sha256msg2(XMMRegister dst, XMMRegister src);
1804 
1805   void shldl(Register dst, Register src);
1806   void shldl(Register dst, Register src, int8_t imm8);
1807 
1808   void shll(Register dst, int imm8);
1809   void shll(Register dst);
1810 
1811   void shlq(Register dst, int imm8);
1812   void shlq(Register dst);
1813 
1814   void shrdl(Register dst, Register src);
1815 
1816   void shrl(Register dst, int imm8);
1817   void shrl(Register dst);
1818 
1819   void shrq(Register dst, int imm8);
1820   void shrq(Register dst);
1821 
1822   void smovl(); // QQQ generic?
1823 
1824   // Compute Square Root of Scalar Double-Precision Floating-Point Value
1825   void sqrtsd(XMMRegister dst, Address src);
1826   void sqrtsd(XMMRegister dst, XMMRegister src);
1827 
1828   // Compute Square Root of Scalar Single-Precision Floating-Point Value
1829   void sqrtss(XMMRegister dst, Address src);
1830   void sqrtss(XMMRegister dst, XMMRegister src);
1831 
1832   void std();
1833 
1834   void stmxcsr( Address dst );
1835 
1836   void subl(Address dst, int32_t imm32);
1837   void subl(Address dst, Register src);
1838   void subl(Register dst, int32_t imm32);
1839   void subl(Register dst, Address src);
1840   void subl(Register dst, Register src);
1841 
1842   void subq(Address dst, int32_t imm32);
1843   void subq(Address dst, Register src);
1844   void subq(Register dst, int32_t imm32);
1845   void subq(Register dst, Address src);
1846   void subq(Register dst, Register src);
1847 
1848   // Force generation of a 4 byte immediate value even if it fits into 8bit
1849   void subl_imm32(Register dst, int32_t imm32);
1850   void subq_imm32(Register dst, int32_t imm32);
1851 
1852   // Subtract Scalar Double-Precision Floating-Point Values
1853   void subsd(XMMRegister dst, Address src);
1854   void subsd(XMMRegister dst, XMMRegister src);
1855 
1856   // Subtract Scalar Single-Precision Floating-Point Values
1857   void subss(XMMRegister dst, Address src);
1858   void subss(XMMRegister dst, XMMRegister src);
1859 
1860   void testb(Register dst, int imm8);
1861   void testb(Address dst, int imm8);
1862 
1863   void testl(Register dst, int32_t imm32);
1864   void testl(Register dst, Register src);
1865   void testl(Register dst, Address src);
1866 
1867   void testq(Register dst, int32_t imm32);
1868   void testq(Register dst, Register src);
1869   void testq(Register dst, Address src);
1870 
1871   // BMI - count trailing zeros
1872   void tzcntl(Register dst, Register src);
1873   void tzcntq(Register dst, Register src);
1874 
1875   // Unordered Compare Scalar Double-Precision Floating-Point Values and set EFLAGS
1876   void ucomisd(XMMRegister dst, Address src);
1877   void ucomisd(XMMRegister dst, XMMRegister src);
1878 
1879   // Unordered Compare Scalar Single-Precision Floating-Point Values and set EFLAGS
1880   void ucomiss(XMMRegister dst, Address src);
1881   void ucomiss(XMMRegister dst, XMMRegister src);
1882 
1883   void xabort(int8_t imm8);
1884 
1885   void xaddb(Address dst, Register src);
1886   void xaddw(Address dst, Register src);
1887   void xaddl(Address dst, Register src);
1888   void xaddq(Address dst, Register src);
1889 
1890   void xbegin(Label&amp; abort, relocInfo::relocType rtype = relocInfo::none);
1891 
1892   void xchgb(Register reg, Address adr);
1893   void xchgw(Register reg, Address adr);
1894   void xchgl(Register reg, Address adr);
1895   void xchgl(Register dst, Register src);
1896 
1897   void xchgq(Register reg, Address adr);
1898   void xchgq(Register dst, Register src);
1899 
1900   void xend();
1901 
1902   // Get Value of Extended Control Register
1903   void xgetbv();
1904 
1905   void xorl(Register dst, int32_t imm32);
1906   void xorl(Register dst, Address src);
1907   void xorl(Register dst, Register src);
1908 
1909   void xorb(Register dst, Address src);
1910 
1911   void xorq(Register dst, Address src);
1912   void xorq(Register dst, Register src);
1913 
1914   void set_byte_if_not_zero(Register dst); // sets reg to 1 if not zero, otherwise 0
1915 
1916   // AVX 3-operands scalar instructions (encoded with VEX prefix)
1917 
1918   void vaddsd(XMMRegister dst, XMMRegister nds, Address src);
1919   void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1920   void vaddss(XMMRegister dst, XMMRegister nds, Address src);
1921   void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1922   void vdivsd(XMMRegister dst, XMMRegister nds, Address src);
1923   void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1924   void vdivss(XMMRegister dst, XMMRegister nds, Address src);
1925   void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1926   void vfmadd231sd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1927   void vfmadd231ss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1928   void vmulsd(XMMRegister dst, XMMRegister nds, Address src);
1929   void vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1930   void vmulss(XMMRegister dst, XMMRegister nds, Address src);
1931   void vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1932   void vsubsd(XMMRegister dst, XMMRegister nds, Address src);
1933   void vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1934   void vsubss(XMMRegister dst, XMMRegister nds, Address src);
1935   void vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1936 
1937   void vmaxss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1938   void vmaxsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1939   void vminss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1940   void vminsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1941 
1942   void shlxl(Register dst, Register src1, Register src2);
1943   void shlxq(Register dst, Register src1, Register src2);
1944 
1945   //====================VECTOR ARITHMETIC=====================================
1946 
1947   // Add Packed Floating-Point Values
1948   void addpd(XMMRegister dst, XMMRegister src);
1949   void addpd(XMMRegister dst, Address src);
1950   void addps(XMMRegister dst, XMMRegister src);
1951   void vaddpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1952   void vaddps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1953   void vaddpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1954   void vaddps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1955 
1956   // Subtract Packed Floating-Point Values
1957   void subpd(XMMRegister dst, XMMRegister src);
1958   void subps(XMMRegister dst, XMMRegister src);
1959   void vsubpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1960   void vsubps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1961   void vsubpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1962   void vsubps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1963 
1964   // Multiply Packed Floating-Point Values
1965   void mulpd(XMMRegister dst, XMMRegister src);
1966   void mulpd(XMMRegister dst, Address src);
1967   void mulps(XMMRegister dst, XMMRegister src);
1968   void vmulpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1969   void vmulps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1970   void vmulpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1971   void vmulps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1972 
1973   void vfmadd231pd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1974   void vfmadd231ps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1975   void vfmadd231pd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1976   void vfmadd231ps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1977 
1978   // Divide Packed Floating-Point Values
1979   void divpd(XMMRegister dst, XMMRegister src);
1980   void divps(XMMRegister dst, XMMRegister src);
1981   void vdivpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1982   void vdivps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1983   void vdivpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1984   void vdivps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1985 
1986   // Sqrt Packed Floating-Point Values
1987   void vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len);
1988   void vsqrtpd(XMMRegister dst, Address src, int vector_len);
1989   void vsqrtps(XMMRegister dst, XMMRegister src, int vector_len);
1990   void vsqrtps(XMMRegister dst, Address src, int vector_len);
1991 
1992   // Bitwise Logical AND of Packed Floating-Point Values
1993   void andpd(XMMRegister dst, XMMRegister src);
1994   void andps(XMMRegister dst, XMMRegister src);
1995   void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1996   void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1997   void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1998   void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1999 
2000   void unpckhpd(XMMRegister dst, XMMRegister src);
2001   void unpcklpd(XMMRegister dst, XMMRegister src);
2002 
2003   // Bitwise Logical XOR of Packed Floating-Point Values
2004   void xorpd(XMMRegister dst, XMMRegister src);
2005   void xorps(XMMRegister dst, XMMRegister src);
2006   void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2007   void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2008   void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2009   void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2010 
2011   // Add horizontal packed integers
2012   void vphaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2013   void vphaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2014   void phaddw(XMMRegister dst, XMMRegister src);
2015   void phaddd(XMMRegister dst, XMMRegister src);
2016 
2017   // Add packed integers
2018   void paddb(XMMRegister dst, XMMRegister src);
2019   void paddw(XMMRegister dst, XMMRegister src);
2020   void paddd(XMMRegister dst, XMMRegister src);
2021   void paddd(XMMRegister dst, Address src);
2022   void paddq(XMMRegister dst, XMMRegister src);
2023   void vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2024   void vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2025   void vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2026   void vpaddq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2027   void vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2028   void vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2029   void vpaddd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2030   void vpaddq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2031 
2032   // Sub packed integers
2033   void psubb(XMMRegister dst, XMMRegister src);
2034   void psubw(XMMRegister dst, XMMRegister src);
2035   void psubd(XMMRegister dst, XMMRegister src);
2036   void psubq(XMMRegister dst, XMMRegister src);
2037   void vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2038   void vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2039   void vpsubd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2040   void vpsubq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2041   void vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2042   void vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2043   void vpsubd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2044   void vpsubq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2045 
2046   // Multiply packed integers (only shorts and ints)
2047   void pmullw(XMMRegister dst, XMMRegister src);
2048   void pmulld(XMMRegister dst, XMMRegister src);
2049   void vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2050   void vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2051   void vpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2052   void vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2053   void vpmulld(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2054   void vpmullq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2055 
2056   // Shift left packed integers
2057   void psllw(XMMRegister dst, int shift);
2058   void pslld(XMMRegister dst, int shift);
2059   void psllq(XMMRegister dst, int shift);
2060   void psllw(XMMRegister dst, XMMRegister shift);
2061   void pslld(XMMRegister dst, XMMRegister shift);
2062   void psllq(XMMRegister dst, XMMRegister shift);
2063   void vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2064   void vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2065   void vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2066   void vpsllw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2067   void vpslld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2068   void vpsllq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2069   void vpslldq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2070 
2071   // Logical shift right packed integers
2072   void psrlw(XMMRegister dst, int shift);
2073   void psrld(XMMRegister dst, int shift);
2074   void psrlq(XMMRegister dst, int shift);
2075   void psrlw(XMMRegister dst, XMMRegister shift);
2076   void psrld(XMMRegister dst, XMMRegister shift);
2077   void psrlq(XMMRegister dst, XMMRegister shift);
2078   void vpsrlw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2079   void vpsrld(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2080   void vpsrlq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2081   void vpsrlw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2082   void vpsrld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2083   void vpsrlq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2084   void vpsrldq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2085   void evpsrlvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2086   void evpsllvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2087 
2088   // Arithmetic shift right packed integers (only shorts and ints, no instructions for longs)
2089   void psraw(XMMRegister dst, int shift);
2090   void psrad(XMMRegister dst, int shift);
2091   void psraw(XMMRegister dst, XMMRegister shift);
2092   void psrad(XMMRegister dst, XMMRegister shift);
2093   void vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2094   void vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2095   void vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2096   void vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2097 
2098   // And packed integers
2099   void pand(XMMRegister dst, XMMRegister src);
2100   void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2101   void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2102   void vpandq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2103 
2104   // Andn packed integers
2105   void pandn(XMMRegister dst, XMMRegister src);
2106   void vpandn(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2107 
2108   // Or packed integers
2109   void por(XMMRegister dst, XMMRegister src);
2110   void vpor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2111   void vpor(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2112   void vporq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2113 
2114   // Xor packed integers
2115   void pxor(XMMRegister dst, XMMRegister src);
2116   void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2117   void vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2118   void evpxorq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2119   void evpxorq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2120 
2121 
2122   // vinserti forms
2123   void vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2124   void vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2125   void vinserti32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2126   void vinserti32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2127   void vinserti64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2128 
2129   // vinsertf forms
2130   void vinsertf128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2131   void vinsertf128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2132   void vinsertf32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2133   void vinsertf32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2134   void vinsertf64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2135   void vinsertf64x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2136 
2137   // vextracti forms
2138   void vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8);
2139   void vextracti128(Address dst, XMMRegister src, uint8_t imm8);
2140   void vextracti32x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2141   void vextracti32x4(Address dst, XMMRegister src, uint8_t imm8);
2142   void vextracti64x2(XMMRegister dst, XMMRegister src, uint8_t imm8);
2143   void vextracti64x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2144   void vextracti64x4(Address dst, XMMRegister src, uint8_t imm8);
2145 
2146   // vextractf forms
2147   void vextractf128(XMMRegister dst, XMMRegister src, uint8_t imm8);
2148   void vextractf128(Address dst, XMMRegister src, uint8_t imm8);
2149   void vextractf32x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2150   void vextractf32x4(Address dst, XMMRegister src, uint8_t imm8);
2151   void vextractf64x2(XMMRegister dst, XMMRegister src, uint8_t imm8);
2152   void vextractf64x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2153   void vextractf64x4(Address dst, XMMRegister src, uint8_t imm8);
2154 
2155   // xmm/mem sourced byte/word/dword/qword replicate
2156   void vpbroadcastb(XMMRegister dst, XMMRegister src, int vector_len);
2157   void vpbroadcastb(XMMRegister dst, Address src, int vector_len);
2158   void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
2159   void vpbroadcastw(XMMRegister dst, Address src, int vector_len);
2160   void vpbroadcastd(XMMRegister dst, XMMRegister src, int vector_len);
2161   void vpbroadcastd(XMMRegister dst, Address src, int vector_len);
2162   void vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len);
2163   void vpbroadcastq(XMMRegister dst, Address src, int vector_len);
2164 
2165   void evbroadcasti64x2(XMMRegister dst, XMMRegister src, int vector_len);
2166   void evbroadcasti64x2(XMMRegister dst, Address src, int vector_len);
2167 
2168   // scalar single/double precision replicate
2169   void vpbroadcastss(XMMRegister dst, XMMRegister src, int vector_len);
2170   void vpbroadcastss(XMMRegister dst, Address src, int vector_len);
2171   void vpbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len);
2172   void vpbroadcastsd(XMMRegister dst, Address src, int vector_len);
2173 
2174   // gpr sourced byte/word/dword/qword replicate
2175   void evpbroadcastb(XMMRegister dst, Register src, int vector_len);
2176   void evpbroadcastw(XMMRegister dst, Register src, int vector_len);
2177   void evpbroadcastd(XMMRegister dst, Register src, int vector_len);
2178   void evpbroadcastq(XMMRegister dst, Register src, int vector_len);
2179 
2180   void evpgatherdd(XMMRegister dst, KRegister k1, Address src, int vector_len);
2181 
2182   // Carry-Less Multiplication Quadword
2183   void pclmulqdq(XMMRegister dst, XMMRegister src, int mask);
2184   void vpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask);
2185   void evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len);
2186   // AVX instruction which is used to clear upper 128 bits of YMM registers and
2187   // to avoid transaction penalty between AVX and SSE states. There is no
2188   // penalty if legacy SSE instructions are encoded using VEX prefix because
2189   // they always clear upper 128 bits. It should be used before calling
2190   // runtime code and native libraries.
2191   void vzeroupper();
2192 
2193   // AVX support for vectorized conditional move (float/double). The following two instructions used only coupled.
2194   void cmppd(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len);
2195   void blendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len);
2196   void cmpps(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len);
2197   void blendvps(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len);
2198   void vpblendd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len);
2199 
2200  protected:
2201   // Next instructions require address alignment 16 bytes SSE mode.
2202   // They should be called only from corresponding MacroAssembler instructions.
2203   void andpd(XMMRegister dst, Address src);
2204   void andps(XMMRegister dst, Address src);
2205   void xorpd(XMMRegister dst, Address src);
2206   void xorps(XMMRegister dst, Address src);
2207 
2208 };
2209 
2210 // The Intel x86/Amd64 Assembler attributes: All fields enclosed here are to guide encoding level decisions.
2211 // Specific set functions are for specialized use, else defaults or whatever was supplied to object construction
2212 // are applied.
2213 class InstructionAttr {
2214 public:
2215   InstructionAttr(
2216     int vector_len,     // The length of vector to be applied in encoding - for both AVX and EVEX
2217     bool rex_vex_w,     // Width of data: if 32-bits or less, false, else if 64-bit or specially defined, true
2218     bool legacy_mode,   // Details if either this instruction is conditionally encoded to AVX or earlier if true else possibly EVEX
2219     bool no_reg_mask,   // when true, k0 is used when EVEX encoding is chosen, else embedded_opmask_register_specifier is used
2220     bool uses_vl)       // This instruction may have legacy constraints based on vector length for EVEX
2221     :
2222       _avx_vector_len(vector_len),
2223       _rex_vex_w(rex_vex_w),
2224       _rex_vex_w_reverted(false),
2225       _legacy_mode(legacy_mode),
2226       _no_reg_mask(no_reg_mask),
2227       _uses_vl(uses_vl),
2228       _tuple_type(Assembler::EVEX_ETUP),
2229       _input_size_in_bits(Assembler::EVEX_NObit),
2230       _is_evex_instruction(false),
2231       _evex_encoding(0),
2232       _is_clear_context(true),
2233       _is_extended_context(false),
2234       _embedded_opmask_register_specifier(0), // hard code k0
2235       _current_assembler(NULL) {
2236     if (UseAVX &lt; 3) _legacy_mode = true;
2237   }
2238 
2239   ~InstructionAttr() {
2240     if (_current_assembler != NULL) {
2241       _current_assembler-&gt;clear_attributes();
2242     }
2243     _current_assembler = NULL;
2244   }
2245 
2246 private:
2247   int  _avx_vector_len;
2248   bool _rex_vex_w;
2249   bool _rex_vex_w_reverted;
2250   bool _legacy_mode;
2251   bool _no_reg_mask;
2252   bool _uses_vl;
2253   int  _tuple_type;
2254   int  _input_size_in_bits;
2255   bool _is_evex_instruction;
2256   int  _evex_encoding;
2257   bool _is_clear_context;
2258   bool _is_extended_context;
2259   int _embedded_opmask_register_specifier;
2260 
2261   Assembler *_current_assembler;
2262 
2263 public:
2264   // query functions for field accessors
2265   int  get_vector_len(void) const { return _avx_vector_len; }
2266   bool is_rex_vex_w(void) const { return _rex_vex_w; }
2267   bool is_rex_vex_w_reverted(void) { return _rex_vex_w_reverted; }
2268   bool is_legacy_mode(void) const { return _legacy_mode; }
2269   bool is_no_reg_mask(void) const { return _no_reg_mask; }
2270   bool uses_vl(void) const { return _uses_vl; }
2271   int  get_tuple_type(void) const { return _tuple_type; }
2272   int  get_input_size(void) const { return _input_size_in_bits; }
2273   int  is_evex_instruction(void) const { return _is_evex_instruction; }
2274   int  get_evex_encoding(void) const { return _evex_encoding; }
2275   bool is_clear_context(void) const { return _is_clear_context; }
2276   bool is_extended_context(void) const { return _is_extended_context; }
2277   int get_embedded_opmask_register_specifier(void) const { return _embedded_opmask_register_specifier; }
2278 
2279   // Set the vector len manually
2280   void set_vector_len(int vector_len) { _avx_vector_len = vector_len; }
2281 
2282   // Set revert rex_vex_w for avx encoding
2283   void set_rex_vex_w_reverted(void) { _rex_vex_w_reverted = true; }
2284 
2285   // Set rex_vex_w based on state
2286   void set_rex_vex_w(bool state) { _rex_vex_w = state; }
2287 
2288   // Set the instruction to be encoded in AVX mode
2289   void set_is_legacy_mode(void) { _legacy_mode = true; }
2290 
2291   // Set the current instuction to be encoded as an EVEX instuction
2292   void set_is_evex_instruction(void) { _is_evex_instruction = true; }
2293 
2294   // Internal encoding data used in compressed immediate offset programming
2295   void set_evex_encoding(int value) { _evex_encoding = value; }
2296 
2297   // Set the Evex.Z field to be used to clear all non directed XMM/YMM/ZMM components
2298   void reset_is_clear_context(void) { _is_clear_context = false; }
2299 
2300   // Map back to current asembler so that we can manage object level assocation
2301   void set_current_assembler(Assembler *current_assembler) { _current_assembler = current_assembler; }
2302 
2303   // Address modifiers used for compressed displacement calculation
2304   void set_address_attributes(int tuple_type, int input_size_in_bits) {
2305     if (VM_Version::supports_evex()) {
2306       _tuple_type = tuple_type;
2307       _input_size_in_bits = input_size_in_bits;
2308     }
2309   }
2310 
2311   // Set embedded opmask register specifier.
2312   void set_embedded_opmask_register_specifier(KRegister mask) {
2313     _embedded_opmask_register_specifier = (*mask).encoding() &amp; 0x7;
2314   }
2315 
2316 };
2317 
2318 #endif // CPU_X86_ASSEMBLER_X86_HPP
    </pre>
  </body>
</html>
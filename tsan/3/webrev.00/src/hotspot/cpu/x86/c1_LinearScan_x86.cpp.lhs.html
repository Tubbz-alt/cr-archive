<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/c1_LinearScan_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Instruction.hpp&quot;
  27 #include &quot;c1/c1_LinearScan.hpp&quot;
  28 #include &quot;utilities/bitMap.inline.hpp&quot;
  29 
  30 
<a name="1" id="anc1"></a>




  31 //----------------------------------------------------------------------
  32 // Allocation of FPU stack slots (Intel x86 only)
  33 //----------------------------------------------------------------------
  34 
  35 void LinearScan::allocate_fpu_stack() {
  36   // First compute which FPU registers are live at the start of each basic block
  37   // (To minimize the amount of work we have to do if we have to merge FPU stacks)
  38   if (ComputeExactFPURegisterUsage) {
  39     Interval* intervals_in_register, *intervals_in_memory;
  40     create_unhandled_lists(&amp;intervals_in_register, &amp;intervals_in_memory, is_in_fpu_register, NULL);
  41 
  42     // ignore memory intervals by overwriting intervals_in_memory
  43     // the dummy interval is needed to enforce the walker to walk until the given id:
  44     // without it, the walker stops when the unhandled-list is empty -&gt; live information
  45     // beyond this point would be incorrect.
  46     Interval* dummy_interval = new Interval(any_reg);
  47     dummy_interval-&gt;add_range(max_jint - 2, max_jint - 1);
  48     dummy_interval-&gt;set_next(Interval::end());
  49     intervals_in_memory = dummy_interval;
  50 
  51     IntervalWalker iw(this, intervals_in_register, intervals_in_memory);
  52 
  53     const int num_blocks = block_count();
  54     for (int i = 0; i &lt; num_blocks; i++) {
  55       BlockBegin* b = block_at(i);
  56 
  57       // register usage is only needed for merging stacks -&gt; compute only
  58       // when more than one predecessor.
  59       // the block must not have any spill moves at the beginning (checked by assertions)
  60       // spill moves would use intervals that are marked as handled and so the usage bit
  61       // would been set incorrectly
  62 
  63       // NOTE: the check for number_of_preds &gt; 1 is necessary. A block with only one
  64       //       predecessor may have spill moves at the begin of the block.
  65       //       If an interval ends at the current instruction id, it is not possible
  66       //       to decide if the register is live or not at the block begin -&gt; the
  67       //       register information would be incorrect.
  68       if (b-&gt;number_of_preds() &gt; 1) {
  69         int id = b-&gt;first_lir_instruction_id();
  70         ResourceBitMap regs(FrameMap::nof_fpu_regs);
  71 
  72         iw.walk_to(id);   // walk after the first instruction (always a label) of the block
  73         assert(iw.current_position() == id, &quot;did not walk completely to id&quot;);
  74 
  75         // Only consider FPU values in registers
  76         Interval* interval = iw.active_first(fixedKind);
  77         while (interval != Interval::end()) {
  78           int reg = interval-&gt;assigned_reg();
  79           assert(reg &gt;= pd_first_fpu_reg &amp;&amp; reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
  80           assert(interval-&gt;assigned_regHi() == -1, &quot;must not have hi register (doubles stored in one register)&quot;);
  81           assert(interval-&gt;from() &lt;= id &amp;&amp; id &lt; interval-&gt;to(), &quot;interval out of range&quot;);
  82 
  83 #ifndef PRODUCT
  84           if (TraceFPURegisterUsage) {
  85             tty-&gt;print(&quot;fpu reg %d is live because of &quot;, reg - pd_first_fpu_reg); interval-&gt;print();
  86           }
  87 #endif
  88 
  89           regs.set_bit(reg - pd_first_fpu_reg);
  90           interval = interval-&gt;next();
  91         }
  92 
  93         b-&gt;set_fpu_register_usage(regs);
  94 
  95 #ifndef PRODUCT
  96         if (TraceFPURegisterUsage) {
  97           tty-&gt;print(&quot;FPU regs for block %d, LIR instr %d): &quot;, b-&gt;block_id(), id); regs.print_on(tty); tty-&gt;cr();
  98         }
  99 #endif
 100       }
 101     }
 102   }
 103 
 104   FpuStackAllocator alloc(ir()-&gt;compilation(), this);
 105   _fpu_stack_allocator = &amp;alloc;
 106   alloc.allocate();
 107   _fpu_stack_allocator = NULL;
 108 }
 109 
 110 
 111 FpuStackAllocator::FpuStackAllocator(Compilation* compilation, LinearScan* allocator)
 112   : _compilation(compilation)
 113   , _allocator(allocator)
 114   , _lir(NULL)
 115   , _pos(-1)
 116   , _sim(compilation)
 117   , _temp_sim(compilation)
 118 {}
 119 
 120 void FpuStackAllocator::allocate() {
 121   int num_blocks = allocator()-&gt;block_count();
 122   for (int i = 0; i &lt; num_blocks; i++) {
 123     // Set up to process block
 124     BlockBegin* block = allocator()-&gt;block_at(i);
 125     intArray* fpu_stack_state = block-&gt;fpu_stack_state();
 126 
 127 #ifndef PRODUCT
 128     if (TraceFPUStack) {
 129       tty-&gt;cr();
 130       tty-&gt;print_cr(&quot;------- Begin of new Block %d -------&quot;, block-&gt;block_id());
 131     }
 132 #endif
 133 
 134     assert(fpu_stack_state != NULL ||
 135            block-&gt;end()-&gt;as_Base() != NULL ||
 136            block-&gt;is_set(BlockBegin::exception_entry_flag),
 137            &quot;FPU stack state must be present due to linear-scan order for FPU stack allocation&quot;);
 138     // note: exception handler entries always start with an empty fpu stack
 139     //       because stack merging would be too complicated
 140 
 141     if (fpu_stack_state != NULL) {
 142       sim()-&gt;read_state(fpu_stack_state);
 143     } else {
 144       sim()-&gt;clear();
 145     }
 146 
 147 #ifndef PRODUCT
 148     if (TraceFPUStack) {
 149       tty-&gt;print(&quot;Reading FPU state for block %d:&quot;, block-&gt;block_id());
 150       sim()-&gt;print();
 151       tty-&gt;cr();
 152     }
 153 #endif
 154 
 155     allocate_block(block);
 156     CHECK_BAILOUT();
 157   }
 158 }
 159 
 160 void FpuStackAllocator::allocate_block(BlockBegin* block) {
 161   bool processed_merge = false;
 162   LIR_OpList* insts = block-&gt;lir()-&gt;instructions_list();
 163   set_lir(block-&gt;lir());
 164   set_pos(0);
 165 
 166 
 167   // Note: insts-&gt;length() may change during loop
 168   while (pos() &lt; insts-&gt;length()) {
 169     LIR_Op* op = insts-&gt;at(pos());
 170     _debug_information_computed = false;
 171 
 172 #ifndef PRODUCT
 173     if (TraceFPUStack) {
 174       op-&gt;print();
 175     }
 176     check_invalid_lir_op(op);
 177 #endif
 178 
 179     LIR_OpBranch* branch = op-&gt;as_OpBranch();
 180     LIR_Op1* op1 = op-&gt;as_Op1();
 181     LIR_Op2* op2 = op-&gt;as_Op2();
 182     LIR_OpCall* opCall = op-&gt;as_OpCall();
 183 
 184     if (branch != NULL &amp;&amp; branch-&gt;block() != NULL) {
 185       if (!processed_merge) {
 186         // propagate stack at first branch to a successor
 187         processed_merge = true;
 188         bool required_merge = merge_fpu_stack_with_successors(block);
 189 
 190         assert(!required_merge || branch-&gt;cond() == lir_cond_always, &quot;splitting of critical edges should prevent FPU stack mismatches at cond branches&quot;);
 191       }
 192 
 193     } else if (op1 != NULL) {
 194       handle_op1(op1);
 195     } else if (op2 != NULL) {
 196       handle_op2(op2);
 197     } else if (opCall != NULL) {
 198       handle_opCall(opCall);
 199     }
 200 
 201     compute_debug_information(op);
 202 
 203     set_pos(1 + pos());
 204   }
 205 
 206   // Propagate stack when block does not end with branch
 207   if (!processed_merge) {
 208     merge_fpu_stack_with_successors(block);
 209   }
 210 }
 211 
 212 
 213 void FpuStackAllocator::compute_debug_information(LIR_Op* op) {
 214   if (!_debug_information_computed &amp;&amp; op-&gt;id() != -1 &amp;&amp; allocator()-&gt;has_info(op-&gt;id())) {
 215     visitor.visit(op);
 216 
 217     // exception handling
 218     if (allocator()-&gt;compilation()-&gt;has_exception_handlers()) {
 219       XHandlers* xhandlers = visitor.all_xhandler();
 220       int n = xhandlers-&gt;length();
 221       for (int k = 0; k &lt; n; k++) {
 222         allocate_exception_handler(xhandlers-&gt;handler_at(k));
 223       }
 224     } else {
 225       assert(visitor.all_xhandler()-&gt;length() == 0, &quot;missed exception handler&quot;);
 226     }
 227 
 228     // compute debug information
 229     int n = visitor.info_count();
 230     assert(n &gt; 0, &quot;should not visit operation otherwise&quot;);
 231 
 232     for (int j = 0; j &lt; n; j++) {
 233       CodeEmitInfo* info = visitor.info_at(j);
 234       // Compute debug information
 235       allocator()-&gt;compute_debug_info(info, op-&gt;id());
 236     }
 237   }
 238   _debug_information_computed = true;
 239 }
 240 
 241 void FpuStackAllocator::allocate_exception_handler(XHandler* xhandler) {
 242   if (!sim()-&gt;is_empty()) {
 243     LIR_List* old_lir = lir();
 244     int old_pos = pos();
 245     intArray* old_state = sim()-&gt;write_state();
 246 
 247 #ifndef PRODUCT
 248     if (TraceFPUStack) {
 249       tty-&gt;cr();
 250       tty-&gt;print_cr(&quot;------- begin of exception handler -------&quot;);
 251     }
 252 #endif
 253 
 254     if (xhandler-&gt;entry_code() == NULL) {
 255       // need entry code to clear FPU stack
 256       LIR_List* entry_code = new LIR_List(_compilation);
 257       entry_code-&gt;jump(xhandler-&gt;entry_block());
 258       xhandler-&gt;set_entry_code(entry_code);
 259     }
 260 
 261     LIR_OpList* insts = xhandler-&gt;entry_code()-&gt;instructions_list();
 262     set_lir(xhandler-&gt;entry_code());
 263     set_pos(0);
 264 
 265     // Note: insts-&gt;length() may change during loop
 266     while (pos() &lt; insts-&gt;length()) {
 267       LIR_Op* op = insts-&gt;at(pos());
 268 
 269 #ifndef PRODUCT
 270       if (TraceFPUStack) {
 271         op-&gt;print();
 272       }
 273       check_invalid_lir_op(op);
 274 #endif
 275 
 276       switch (op-&gt;code()) {
 277         case lir_move:
 278           assert(op-&gt;as_Op1() != NULL, &quot;must be LIR_Op1&quot;);
 279           assert(pos() != insts-&gt;length() - 1, &quot;must not be last operation&quot;);
 280 
 281           handle_op1((LIR_Op1*)op);
 282           break;
 283 
 284         case lir_branch:
 285           assert(op-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;must be unconditional branch&quot;);
 286           assert(pos() == insts-&gt;length() - 1, &quot;must be last operation&quot;);
 287 
 288           // remove all remaining dead registers from FPU stack
 289           clear_fpu_stack(LIR_OprFact::illegalOpr);
 290           break;
 291 
 292         default:
 293           // other operations not allowed in exception entry code
 294           ShouldNotReachHere();
 295       }
 296 
 297       set_pos(pos() + 1);
 298     }
 299 
 300 #ifndef PRODUCT
 301     if (TraceFPUStack) {
 302       tty-&gt;cr();
 303       tty-&gt;print_cr(&quot;------- end of exception handler -------&quot;);
 304     }
 305 #endif
 306 
 307     set_lir(old_lir);
 308     set_pos(old_pos);
 309     sim()-&gt;read_state(old_state);
 310   }
 311 }
 312 
 313 
 314 int FpuStackAllocator::fpu_num(LIR_Opr opr) {
 315   assert(opr-&gt;is_fpu_register() &amp;&amp; !opr-&gt;is_xmm_register(), &quot;shouldn&#39;t call this otherwise&quot;);
 316   return opr-&gt;is_single_fpu() ? opr-&gt;fpu_regnr() : opr-&gt;fpu_regnrLo();
 317 }
 318 
 319 int FpuStackAllocator::tos_offset(LIR_Opr opr) {
 320   return sim()-&gt;offset_from_tos(fpu_num(opr));
 321 }
 322 
 323 
 324 LIR_Opr FpuStackAllocator::to_fpu_stack(LIR_Opr opr) {
 325   assert(opr-&gt;is_fpu_register() &amp;&amp; !opr-&gt;is_xmm_register(), &quot;shouldn&#39;t call this otherwise&quot;);
 326 
 327   int stack_offset = tos_offset(opr);
 328   if (opr-&gt;is_single_fpu()) {
 329     return LIR_OprFact::single_fpu(stack_offset)-&gt;make_fpu_stack_offset();
 330   } else {
 331     assert(opr-&gt;is_double_fpu(), &quot;shouldn&#39;t call this otherwise&quot;);
 332     return LIR_OprFact::double_fpu(stack_offset)-&gt;make_fpu_stack_offset();
 333   }
 334 }
 335 
 336 LIR_Opr FpuStackAllocator::to_fpu_stack_top(LIR_Opr opr, bool dont_check_offset) {
 337   assert(opr-&gt;is_fpu_register() &amp;&amp; !opr-&gt;is_xmm_register(), &quot;shouldn&#39;t call this otherwise&quot;);
 338   assert(dont_check_offset || tos_offset(opr) == 0, &quot;operand is not on stack top&quot;);
 339 
 340   int stack_offset = 0;
 341   if (opr-&gt;is_single_fpu()) {
 342     return LIR_OprFact::single_fpu(stack_offset)-&gt;make_fpu_stack_offset();
 343   } else {
 344     assert(opr-&gt;is_double_fpu(), &quot;shouldn&#39;t call this otherwise&quot;);
 345     return LIR_OprFact::double_fpu(stack_offset)-&gt;make_fpu_stack_offset();
 346   }
 347 }
 348 
 349 
 350 
 351 void FpuStackAllocator::insert_op(LIR_Op* op) {
 352   lir()-&gt;insert_before(pos(), op);
 353   set_pos(1 + pos());
 354 }
 355 
 356 
 357 void FpuStackAllocator::insert_exchange(int offset) {
 358   if (offset &gt; 0) {
 359     LIR_Op1* fxch_op = new LIR_Op1(lir_fxch, LIR_OprFact::intConst(offset), LIR_OprFact::illegalOpr);
 360     insert_op(fxch_op);
 361     sim()-&gt;swap(offset);
 362 
 363 #ifndef PRODUCT
 364     if (TraceFPUStack) {
 365       tty-&gt;print(&quot;Exchanged register: %d         New state: &quot;, sim()-&gt;get_slot(0)); sim()-&gt;print(); tty-&gt;cr();
 366     }
 367 #endif
 368 
 369   }
 370 }
 371 
 372 void FpuStackAllocator::insert_exchange(LIR_Opr opr) {
 373   insert_exchange(tos_offset(opr));
 374 }
 375 
 376 
 377 void FpuStackAllocator::insert_free(int offset) {
 378   // move stack slot to the top of stack and then pop it
 379   insert_exchange(offset);
 380 
 381   LIR_Op* fpop = new LIR_Op0(lir_fpop_raw);
 382   insert_op(fpop);
 383   sim()-&gt;pop();
 384 
 385 #ifndef PRODUCT
 386     if (TraceFPUStack) {
 387       tty-&gt;print(&quot;Inserted pop                   New state: &quot;); sim()-&gt;print(); tty-&gt;cr();
 388     }
 389 #endif
 390 }
 391 
 392 
 393 void FpuStackAllocator::insert_free_if_dead(LIR_Opr opr) {
 394   if (sim()-&gt;contains(fpu_num(opr))) {
 395     int res_slot = tos_offset(opr);
 396     insert_free(res_slot);
 397   }
 398 }
 399 
 400 void FpuStackAllocator::insert_free_if_dead(LIR_Opr opr, LIR_Opr ignore) {
 401   if (fpu_num(opr) != fpu_num(ignore) &amp;&amp; sim()-&gt;contains(fpu_num(opr))) {
 402     int res_slot = tos_offset(opr);
 403     insert_free(res_slot);
 404   }
 405 }
 406 
 407 void FpuStackAllocator::insert_copy(LIR_Opr from, LIR_Opr to) {
 408   int offset = tos_offset(from);
 409   LIR_Op1* fld = new LIR_Op1(lir_fld, LIR_OprFact::intConst(offset), LIR_OprFact::illegalOpr);
 410   insert_op(fld);
 411 
 412   sim()-&gt;push(fpu_num(to));
 413 
 414 #ifndef PRODUCT
 415   if (TraceFPUStack) {
 416     tty-&gt;print(&quot;Inserted copy (%d -&gt; %d)         New state: &quot;, fpu_num(from), fpu_num(to)); sim()-&gt;print(); tty-&gt;cr();
 417   }
 418 #endif
 419 }
 420 
 421 void FpuStackAllocator::do_rename(LIR_Opr from, LIR_Opr to) {
 422   sim()-&gt;rename(fpu_num(from), fpu_num(to));
 423 }
 424 
 425 void FpuStackAllocator::do_push(LIR_Opr opr) {
 426   sim()-&gt;push(fpu_num(opr));
 427 }
 428 
 429 void FpuStackAllocator::pop_if_last_use(LIR_Op* op, LIR_Opr opr) {
 430   assert(op-&gt;fpu_pop_count() == 0, &quot;fpu_pop_count alredy set&quot;);
 431   assert(tos_offset(opr) == 0, &quot;can only pop stack top&quot;);
 432 
 433   if (opr-&gt;is_last_use()) {
 434     op-&gt;set_fpu_pop_count(1);
 435     sim()-&gt;pop();
 436   }
 437 }
 438 
 439 void FpuStackAllocator::pop_always(LIR_Op* op, LIR_Opr opr) {
 440   assert(op-&gt;fpu_pop_count() == 0, &quot;fpu_pop_count alredy set&quot;);
 441   assert(tos_offset(opr) == 0, &quot;can only pop stack top&quot;);
 442 
 443   op-&gt;set_fpu_pop_count(1);
 444   sim()-&gt;pop();
 445 }
 446 
 447 void FpuStackAllocator::clear_fpu_stack(LIR_Opr preserve) {
 448   int result_stack_size = (preserve-&gt;is_fpu_register() &amp;&amp; !preserve-&gt;is_xmm_register() ? 1 : 0);
 449   while (sim()-&gt;stack_size() &gt; result_stack_size) {
 450     assert(!sim()-&gt;slot_is_empty(0), &quot;not allowed&quot;);
 451 
 452     if (result_stack_size == 0 || sim()-&gt;get_slot(0) != fpu_num(preserve)) {
 453       insert_free(0);
 454     } else {
 455       // move &quot;preserve&quot; to bottom of stack so that all other stack slots can be popped
 456       insert_exchange(sim()-&gt;stack_size() - 1);
 457     }
 458   }
 459 }
 460 
 461 
 462 void FpuStackAllocator::handle_op1(LIR_Op1* op1) {
 463   LIR_Opr in  = op1-&gt;in_opr();
 464   LIR_Opr res = op1-&gt;result_opr();
 465 
 466   LIR_Opr new_in  = in;  // new operands relative to the actual fpu stack top
 467   LIR_Opr new_res = res;
 468 
 469   // Note: this switch is processed for all LIR_Op1, regardless if they have FPU-arguments,
 470   //       so checks for is_float_kind() are necessary inside the cases
 471   switch (op1-&gt;code()) {
 472 
 473     case lir_return: {
 474       // FPU-Stack must only contain the (optional) fpu return value.
 475       // All remaining dead values are popped from the stack
 476       // If the input operand is a fpu-register, it is exchanged to the bottom of the stack
 477 
 478       clear_fpu_stack(in);
 479       if (in-&gt;is_fpu_register() &amp;&amp; !in-&gt;is_xmm_register()) {
 480         new_in = to_fpu_stack_top(in);
 481       }
 482 
 483       break;
 484     }
 485 
 486     case lir_move: {
 487       if (in-&gt;is_fpu_register() &amp;&amp; !in-&gt;is_xmm_register()) {
 488         if (res-&gt;is_xmm_register()) {
 489           // move from fpu register to xmm register (necessary for operations that
 490           // are not available in the SSE instruction set)
 491           insert_exchange(in);
 492           new_in = to_fpu_stack_top(in);
 493           pop_always(op1, in);
 494 
 495         } else if (res-&gt;is_fpu_register() &amp;&amp; !res-&gt;is_xmm_register()) {
 496           // move from fpu-register to fpu-register:
 497           // * input and result register equal:
 498           //   nothing to do
 499           // * input register is last use:
 500           //   rename the input register to result register -&gt; input register
 501           //   not present on fpu-stack afterwards
 502           // * input register not last use:
 503           //   duplicate input register to result register to preserve input
 504           //
 505           // Note: The LIR-Assembler does not produce any code for fpu register moves,
 506           //       so input and result stack index must be equal
 507 
 508           if (fpu_num(in) == fpu_num(res)) {
 509             // nothing to do
 510           } else if (in-&gt;is_last_use()) {
 511             insert_free_if_dead(res);//, in);
 512             do_rename(in, res);
 513           } else {
 514             insert_free_if_dead(res);
 515             insert_copy(in, res);
 516           }
 517           new_in = to_fpu_stack(res);
 518           new_res = new_in;
 519 
 520         } else {
 521           // move from fpu-register to memory
 522           // input operand must be on top of stack
 523 
 524           insert_exchange(in);
 525 
 526           // create debug information here because afterwards the register may have been popped
 527           compute_debug_information(op1);
 528 
 529           new_in = to_fpu_stack_top(in);
 530           pop_if_last_use(op1, in);
 531         }
 532 
 533       } else if (res-&gt;is_fpu_register() &amp;&amp; !res-&gt;is_xmm_register()) {
 534         // move from memory/constant to fpu register
 535         // result is pushed on the stack
 536 
 537         insert_free_if_dead(res);
 538 
 539         // create debug information before register is pushed
 540         compute_debug_information(op1);
 541 
 542         do_push(res);
 543         new_res = to_fpu_stack_top(res);
 544       }
 545       break;
 546     }
 547 
 548     case lir_neg: {
 549       if (in-&gt;is_fpu_register() &amp;&amp; !in-&gt;is_xmm_register()) {
 550         assert(res-&gt;is_fpu_register() &amp;&amp; !res-&gt;is_xmm_register(), &quot;must be&quot;);
 551         assert(in-&gt;is_last_use(), &quot;old value gets destroyed&quot;);
 552 
 553         insert_free_if_dead(res, in);
 554         insert_exchange(in);
 555         new_in = to_fpu_stack_top(in);
 556 
 557         do_rename(in, res);
 558         new_res = to_fpu_stack_top(res);
 559       }
 560       break;
 561     }
 562 
 563     case lir_convert: {
 564       Bytecodes::Code bc = op1-&gt;as_OpConvert()-&gt;bytecode();
 565       switch (bc) {
 566         case Bytecodes::_d2f:
 567         case Bytecodes::_f2d:
 568           assert(res-&gt;is_fpu_register(), &quot;must be&quot;);
 569           assert(in-&gt;is_fpu_register(), &quot;must be&quot;);
 570 
 571           if (!in-&gt;is_xmm_register() &amp;&amp; !res-&gt;is_xmm_register()) {
 572             // this is quite the same as a move from fpu-register to fpu-register
 573             // Note: input and result operands must have different types
 574             if (fpu_num(in) == fpu_num(res)) {
 575               // nothing to do
 576               new_in = to_fpu_stack(in);
 577             } else if (in-&gt;is_last_use()) {
 578               insert_free_if_dead(res);//, in);
 579               new_in = to_fpu_stack(in);
 580               do_rename(in, res);
 581             } else {
 582               insert_free_if_dead(res);
 583               insert_copy(in, res);
 584               new_in = to_fpu_stack_top(in, true);
 585             }
 586             new_res = to_fpu_stack(res);
 587           }
 588 
 589           break;
 590 
 591         case Bytecodes::_i2f:
 592         case Bytecodes::_l2f:
 593         case Bytecodes::_i2d:
 594         case Bytecodes::_l2d:
 595           assert(res-&gt;is_fpu_register(), &quot;must be&quot;);
 596           if (!res-&gt;is_xmm_register()) {
 597             insert_free_if_dead(res);
 598             do_push(res);
 599             new_res = to_fpu_stack_top(res);
 600           }
 601           break;
 602 
 603         case Bytecodes::_f2i:
 604         case Bytecodes::_d2i:
 605           assert(in-&gt;is_fpu_register(), &quot;must be&quot;);
 606           if (!in-&gt;is_xmm_register()) {
 607             insert_exchange(in);
 608             new_in = to_fpu_stack_top(in);
 609 
 610             // TODO: update registes of stub
 611           }
 612           break;
 613 
 614         case Bytecodes::_f2l:
 615         case Bytecodes::_d2l:
 616           assert(in-&gt;is_fpu_register(), &quot;must be&quot;);
 617           if (!in-&gt;is_xmm_register()) {
 618             insert_exchange(in);
 619             new_in = to_fpu_stack_top(in);
 620             pop_always(op1, in);
 621           }
 622           break;
 623 
 624         case Bytecodes::_i2l:
 625         case Bytecodes::_l2i:
 626         case Bytecodes::_i2b:
 627         case Bytecodes::_i2c:
 628         case Bytecodes::_i2s:
 629           // no fpu operands
 630           break;
 631 
 632         default:
 633           ShouldNotReachHere();
 634       }
 635       break;
 636     }
 637 
 638     case lir_roundfp: {
 639       assert(in-&gt;is_fpu_register() &amp;&amp; !in-&gt;is_xmm_register(), &quot;input must be in register&quot;);
 640       assert(res-&gt;is_stack(), &quot;result must be on stack&quot;);
 641 
 642       insert_exchange(in);
 643       new_in = to_fpu_stack_top(in);
 644       pop_if_last_use(op1, in);
 645       break;
 646     }
 647 
 648     default: {
 649       assert(!in-&gt;is_float_kind() &amp;&amp; !res-&gt;is_float_kind(), &quot;missed a fpu-operation&quot;);
 650     }
 651   }
 652 
 653   op1-&gt;set_in_opr(new_in);
 654   op1-&gt;set_result_opr(new_res);
 655 }
 656 
 657 void FpuStackAllocator::handle_op2(LIR_Op2* op2) {
 658   LIR_Opr left  = op2-&gt;in_opr1();
 659   if (!left-&gt;is_float_kind()) {
 660     return;
 661   }
 662   if (left-&gt;is_xmm_register()) {
 663     return;
 664   }
 665 
 666   LIR_Opr right = op2-&gt;in_opr2();
 667   LIR_Opr res   = op2-&gt;result_opr();
 668   LIR_Opr new_left  = left;  // new operands relative to the actual fpu stack top
 669   LIR_Opr new_right = right;
 670   LIR_Opr new_res   = res;
 671 
 672   assert(!left-&gt;is_xmm_register() &amp;&amp; !right-&gt;is_xmm_register() &amp;&amp; !res-&gt;is_xmm_register(), &quot;not for xmm registers&quot;);
 673 
 674   switch (op2-&gt;code()) {
 675     case lir_cmp:
 676     case lir_cmp_fd2i:
 677     case lir_ucmp_fd2i:
 678     case lir_assert: {
 679       assert(left-&gt;is_fpu_register(), &quot;invalid LIR&quot;);
 680       assert(right-&gt;is_fpu_register(), &quot;invalid LIR&quot;);
 681 
 682       // the left-hand side must be on top of stack.
 683       // the right-hand side is never popped, even if is_last_use is set
 684       insert_exchange(left);
 685       new_left = to_fpu_stack_top(left);
 686       new_right = to_fpu_stack(right);
 687       pop_if_last_use(op2, left);
 688       break;
 689     }
 690 
 691     case lir_mul_strictfp:
 692     case lir_div_strictfp: {
 693       assert(op2-&gt;tmp1_opr()-&gt;is_fpu_register(), &quot;strict operations need temporary fpu stack slot&quot;);
 694       insert_free_if_dead(op2-&gt;tmp1_opr());
 695       assert(sim()-&gt;stack_size() &lt;= 7, &quot;at least one stack slot must be free&quot;);
 696       // fall-through: continue with the normal handling of lir_mul and lir_div
 697     }
 698     case lir_add:
 699     case lir_sub:
 700     case lir_mul:
 701     case lir_div: {
 702       assert(left-&gt;is_fpu_register(), &quot;must be&quot;);
 703       assert(res-&gt;is_fpu_register(), &quot;must be&quot;);
 704       assert(left-&gt;is_equal(res), &quot;must be&quot;);
 705 
 706       // either the left-hand or the right-hand side must be on top of stack
 707       // (if right is not a register, left must be on top)
 708       if (!right-&gt;is_fpu_register()) {
 709         insert_exchange(left);
 710         new_left = to_fpu_stack_top(left);
 711       } else {
 712         // no exchange necessary if right is alredy on top of stack
 713         if (tos_offset(right) == 0) {
 714           new_left = to_fpu_stack(left);
 715           new_right = to_fpu_stack_top(right);
 716         } else {
 717           insert_exchange(left);
 718           new_left = to_fpu_stack_top(left);
 719           new_right = to_fpu_stack(right);
 720         }
 721 
 722         if (right-&gt;is_last_use()) {
 723           op2-&gt;set_fpu_pop_count(1);
 724 
 725           if (tos_offset(right) == 0) {
 726             sim()-&gt;pop();
 727           } else {
 728             // if left is on top of stack, the result is placed in the stack
 729             // slot of right, so a renaming from right to res is necessary
 730             assert(tos_offset(left) == 0, &quot;must be&quot;);
 731             sim()-&gt;pop();
 732             do_rename(right, res);
 733           }
 734         }
 735       }
 736       new_res = to_fpu_stack(res);
 737 
 738       break;
 739     }
 740 
 741     case lir_rem: {
 742       assert(left-&gt;is_fpu_register(), &quot;must be&quot;);
 743       assert(right-&gt;is_fpu_register(), &quot;must be&quot;);
 744       assert(res-&gt;is_fpu_register(), &quot;must be&quot;);
 745       assert(left-&gt;is_equal(res), &quot;must be&quot;);
 746 
 747       // Must bring both operands to top of stack with following operand ordering:
 748       // * fpu stack before rem: ... right left
 749       // * fpu stack after rem:  ... left
 750       if (tos_offset(right) != 1) {
 751         insert_exchange(right);
 752         insert_exchange(1);
 753       }
 754       insert_exchange(left);
 755       assert(tos_offset(right) == 1, &quot;check&quot;);
 756       assert(tos_offset(left) == 0, &quot;check&quot;);
 757 
 758       new_left = to_fpu_stack_top(left);
 759       new_right = to_fpu_stack(right);
 760 
 761       op2-&gt;set_fpu_pop_count(1);
 762       sim()-&gt;pop();
 763       do_rename(right, res);
 764 
 765       new_res = to_fpu_stack_top(res);
 766       break;
 767     }
 768 
 769     case lir_abs:
 770     case lir_sqrt: {
 771       // Right argument appears to be unused
 772       assert(right-&gt;is_illegal(), &quot;must be&quot;);
 773       assert(left-&gt;is_fpu_register(), &quot;must be&quot;);
 774       assert(res-&gt;is_fpu_register(), &quot;must be&quot;);
 775       assert(left-&gt;is_last_use(), &quot;old value gets destroyed&quot;);
 776 
 777       insert_free_if_dead(res, left);
 778       insert_exchange(left);
 779       do_rename(left, res);
 780 
 781       new_left = to_fpu_stack_top(res);
 782       new_res = new_left;
 783 
 784       op2-&gt;set_fpu_stack_size(sim()-&gt;stack_size());
 785       break;
 786     }
 787 
 788     default: {
 789       assert(false, &quot;missed a fpu-operation&quot;);
 790     }
 791   }
 792 
 793   op2-&gt;set_in_opr1(new_left);
 794   op2-&gt;set_in_opr2(new_right);
 795   op2-&gt;set_result_opr(new_res);
 796 }
 797 
 798 void FpuStackAllocator::handle_opCall(LIR_OpCall* opCall) {
 799   LIR_Opr res = opCall-&gt;result_opr();
 800 
 801   // clear fpu-stack before call
 802   // it may contain dead values that could not have been remved by previous operations
 803   clear_fpu_stack(LIR_OprFact::illegalOpr);
 804   assert(sim()-&gt;is_empty(), &quot;fpu stack must be empty now&quot;);
 805 
 806   // compute debug information before (possible) fpu result is pushed
 807   compute_debug_information(opCall);
 808 
 809   if (res-&gt;is_fpu_register() &amp;&amp; !res-&gt;is_xmm_register()) {
 810     do_push(res);
 811     opCall-&gt;set_result_opr(to_fpu_stack_top(res));
 812   }
 813 }
 814 
 815 #ifndef PRODUCT
 816 void FpuStackAllocator::check_invalid_lir_op(LIR_Op* op) {
 817   switch (op-&gt;code()) {
<a name="2" id="anc2"></a><span class="line-removed"> 818     case lir_24bit_FPU:</span>
<span class="line-removed"> 819     case lir_reset_FPU:</span>
<span class="line-removed"> 820     case lir_ffree:</span>
<span class="line-removed"> 821       assert(false, &quot;operations not allowed in lir. If one of these operations is needed, check if they have fpu operands&quot;);</span>
<span class="line-removed"> 822       break;</span>
<span class="line-removed"> 823 </span>
 824     case lir_fpop_raw:
 825     case lir_fxch:
 826     case lir_fld:
 827       assert(false, &quot;operations only inserted by FpuStackAllocator&quot;);
 828       break;
 829 
 830     default:
 831       break;
 832   }
 833 }
 834 #endif
 835 
 836 
 837 void FpuStackAllocator::merge_insert_add(LIR_List* instrs, FpuStackSim* cur_sim, int reg) {
 838   LIR_Op1* move = new LIR_Op1(lir_move, LIR_OprFact::doubleConst(0), LIR_OprFact::double_fpu(reg)-&gt;make_fpu_stack_offset());
 839 
 840   instrs-&gt;instructions_list()-&gt;push(move);
 841 
 842   cur_sim-&gt;push(reg);
 843   move-&gt;set_result_opr(to_fpu_stack(move-&gt;result_opr()));
 844 
 845   #ifndef PRODUCT
 846     if (TraceFPUStack) {
 847       tty-&gt;print(&quot;Added new register: %d         New state: &quot;, reg); cur_sim-&gt;print(); tty-&gt;cr();
 848     }
 849   #endif
 850 }
 851 
 852 void FpuStackAllocator::merge_insert_xchg(LIR_List* instrs, FpuStackSim* cur_sim, int slot) {
 853   assert(slot &gt; 0, &quot;no exchange necessary&quot;);
 854 
 855   LIR_Op1* fxch = new LIR_Op1(lir_fxch, LIR_OprFact::intConst(slot));
 856   instrs-&gt;instructions_list()-&gt;push(fxch);
 857   cur_sim-&gt;swap(slot);
 858 
 859   #ifndef PRODUCT
 860     if (TraceFPUStack) {
 861       tty-&gt;print(&quot;Exchanged register: %d         New state: &quot;, cur_sim-&gt;get_slot(slot)); cur_sim-&gt;print(); tty-&gt;cr();
 862     }
 863   #endif
 864 }
 865 
 866 void FpuStackAllocator::merge_insert_pop(LIR_List* instrs, FpuStackSim* cur_sim) {
 867   int reg = cur_sim-&gt;get_slot(0);
 868 
 869   LIR_Op* fpop = new LIR_Op0(lir_fpop_raw);
 870   instrs-&gt;instructions_list()-&gt;push(fpop);
 871   cur_sim-&gt;pop(reg);
 872 
 873   #ifndef PRODUCT
 874     if (TraceFPUStack) {
 875       tty-&gt;print(&quot;Removed register: %d           New state: &quot;, reg); cur_sim-&gt;print(); tty-&gt;cr();
 876     }
 877   #endif
 878 }
 879 
 880 bool FpuStackAllocator::merge_rename(FpuStackSim* cur_sim, FpuStackSim* sux_sim, int start_slot, int change_slot) {
 881   int reg = cur_sim-&gt;get_slot(change_slot);
 882 
 883   for (int slot = start_slot; slot &gt;= 0; slot--) {
 884     int new_reg = sux_sim-&gt;get_slot(slot);
 885 
 886     if (!cur_sim-&gt;contains(new_reg)) {
 887       cur_sim-&gt;set_slot(change_slot, new_reg);
 888 
 889       #ifndef PRODUCT
 890         if (TraceFPUStack) {
 891           tty-&gt;print(&quot;Renamed register %d to %d       New state: &quot;, reg, new_reg); cur_sim-&gt;print(); tty-&gt;cr();
 892         }
 893       #endif
 894 
 895       return true;
 896     }
 897   }
 898   return false;
 899 }
 900 
 901 
 902 void FpuStackAllocator::merge_fpu_stack(LIR_List* instrs, FpuStackSim* cur_sim, FpuStackSim* sux_sim) {
 903 #ifndef PRODUCT
 904   if (TraceFPUStack) {
 905     tty-&gt;cr();
 906     tty-&gt;print(&quot;before merging: pred: &quot;); cur_sim-&gt;print(); tty-&gt;cr();
 907     tty-&gt;print(&quot;                 sux: &quot;); sux_sim-&gt;print(); tty-&gt;cr();
 908   }
 909 
 910   int slot;
 911   for (slot = 0; slot &lt; cur_sim-&gt;stack_size(); slot++) {
 912     assert(!cur_sim-&gt;slot_is_empty(slot), &quot;not handled by algorithm&quot;);
 913   }
 914   for (slot = 0; slot &lt; sux_sim-&gt;stack_size(); slot++) {
 915     assert(!sux_sim-&gt;slot_is_empty(slot), &quot;not handled by algorithm&quot;);
 916   }
 917 #endif
 918 
 919   // size difference between cur and sux that must be resolved by adding or removing values form the stack
 920   int size_diff = cur_sim-&gt;stack_size() - sux_sim-&gt;stack_size();
 921 
 922   if (!ComputeExactFPURegisterUsage) {
 923     // add slots that are currently free, but used in successor
 924     // When the exact FPU register usage is computed, the stack does
 925     // not contain dead values at merging -&gt; no values must be added
 926 
 927     int sux_slot = sux_sim-&gt;stack_size() - 1;
 928     while (size_diff &lt; 0) {
 929       assert(sux_slot &gt;= 0, &quot;slot out of bounds -&gt; error in algorithm&quot;);
 930 
 931       int reg = sux_sim-&gt;get_slot(sux_slot);
 932       if (!cur_sim-&gt;contains(reg)) {
 933         merge_insert_add(instrs, cur_sim, reg);
 934         size_diff++;
 935 
 936         if (sux_slot + size_diff != 0) {
 937           merge_insert_xchg(instrs, cur_sim, sux_slot + size_diff);
 938         }
 939       }
 940      sux_slot--;
 941     }
 942   }
 943 
 944   assert(cur_sim-&gt;stack_size() &gt;= sux_sim-&gt;stack_size(), &quot;stack size must be equal or greater now&quot;);
 945   assert(size_diff == cur_sim-&gt;stack_size() - sux_sim-&gt;stack_size(), &quot;must be&quot;);
 946 
 947   // stack merge algorithm:
 948   // 1) as long as the current stack top is not in the right location (that meens
 949   //    it should not be on the stack top), exchange it into the right location
 950   // 2) if the stack top is right, but the remaining stack is not ordered correctly,
 951   //    the stack top is exchanged away to get another value on top -&gt;
 952   //    now step 1) can be continued
 953   // the stack can also contain unused items -&gt; these items are removed from stack
 954 
 955   int finished_slot = sux_sim-&gt;stack_size() - 1;
 956   while (finished_slot &gt;= 0 || size_diff &gt; 0) {
 957     while (size_diff &gt; 0 || (cur_sim-&gt;stack_size() &gt; 0 &amp;&amp; cur_sim-&gt;get_slot(0) != sux_sim-&gt;get_slot(0))) {
 958       int reg = cur_sim-&gt;get_slot(0);
 959       if (sux_sim-&gt;contains(reg)) {
 960         int sux_slot = sux_sim-&gt;offset_from_tos(reg);
 961         merge_insert_xchg(instrs, cur_sim, sux_slot + size_diff);
 962 
 963       } else if (!merge_rename(cur_sim, sux_sim, finished_slot, 0)) {
 964         assert(size_diff &gt; 0, &quot;must be&quot;);
 965 
 966         merge_insert_pop(instrs, cur_sim);
 967         size_diff--;
 968       }
 969       assert(cur_sim-&gt;stack_size() == 0 || cur_sim-&gt;get_slot(0) != reg, &quot;register must have been changed&quot;);
 970     }
 971 
 972     while (finished_slot &gt;= 0 &amp;&amp; cur_sim-&gt;get_slot(finished_slot) == sux_sim-&gt;get_slot(finished_slot)) {
 973       finished_slot--;
 974     }
 975 
 976     if (finished_slot &gt;= 0) {
 977       int reg = cur_sim-&gt;get_slot(finished_slot);
 978 
 979       if (sux_sim-&gt;contains(reg) || !merge_rename(cur_sim, sux_sim, finished_slot, finished_slot)) {
 980         assert(sux_sim-&gt;contains(reg) || size_diff &gt; 0, &quot;must be&quot;);
 981         merge_insert_xchg(instrs, cur_sim, finished_slot);
 982       }
 983       assert(cur_sim-&gt;get_slot(finished_slot) != reg, &quot;register must have been changed&quot;);
 984     }
 985   }
 986 
 987 #ifndef PRODUCT
 988   if (TraceFPUStack) {
 989     tty-&gt;print(&quot;after merging:  pred: &quot;); cur_sim-&gt;print(); tty-&gt;cr();
 990     tty-&gt;print(&quot;                 sux: &quot;); sux_sim-&gt;print(); tty-&gt;cr();
 991     tty-&gt;cr();
 992   }
 993 #endif
 994   assert(cur_sim-&gt;stack_size() == sux_sim-&gt;stack_size(), &quot;stack size must be equal now&quot;);
 995 }
 996 
 997 
 998 void FpuStackAllocator::merge_cleanup_fpu_stack(LIR_List* instrs, FpuStackSim* cur_sim, BitMap&amp; live_fpu_regs) {
 999 #ifndef PRODUCT
1000   if (TraceFPUStack) {
1001     tty-&gt;cr();
1002     tty-&gt;print(&quot;before cleanup: state: &quot;); cur_sim-&gt;print(); tty-&gt;cr();
1003     tty-&gt;print(&quot;                live:  &quot;); live_fpu_regs.print_on(tty); tty-&gt;cr();
1004   }
1005 #endif
1006 
1007   int slot = 0;
1008   while (slot &lt; cur_sim-&gt;stack_size()) {
1009     int reg = cur_sim-&gt;get_slot(slot);
1010     if (!live_fpu_regs.at(reg)) {
1011       if (slot != 0) {
1012         merge_insert_xchg(instrs, cur_sim, slot);
1013       }
1014       merge_insert_pop(instrs, cur_sim);
1015     } else {
1016       slot++;
1017     }
1018   }
1019 
1020 #ifndef PRODUCT
1021   if (TraceFPUStack) {
1022     tty-&gt;print(&quot;after cleanup:  state: &quot;); cur_sim-&gt;print(); tty-&gt;cr();
1023     tty-&gt;print(&quot;                live:  &quot;); live_fpu_regs.print_on(tty); tty-&gt;cr();
1024     tty-&gt;cr();
1025   }
1026 
1027   // check if fpu stack only contains live registers
1028   for (unsigned int i = 0; i &lt; live_fpu_regs.size(); i++) {
1029     if (live_fpu_regs.at(i) != cur_sim-&gt;contains(i)) {
1030       tty-&gt;print_cr(&quot;mismatch between required and actual stack content&quot;);
1031       break;
1032     }
1033   }
1034 #endif
1035 }
1036 
1037 
1038 bool FpuStackAllocator::merge_fpu_stack_with_successors(BlockBegin* block) {
1039 #ifndef PRODUCT
1040   if (TraceFPUStack) {
1041     tty-&gt;print_cr(&quot;Propagating FPU stack state for B%d at LIR_Op position %d to successors:&quot;,
1042                   block-&gt;block_id(), pos());
1043     sim()-&gt;print();
1044     tty-&gt;cr();
1045   }
1046 #endif
1047 
1048   bool changed = false;
1049   int number_of_sux = block-&gt;number_of_sux();
1050 
1051   if (number_of_sux == 1 &amp;&amp; block-&gt;sux_at(0)-&gt;number_of_preds() &gt; 1) {
1052     // The successor has at least two incoming edges, so a stack merge will be necessary
1053     // If this block is the first predecessor, cleanup the current stack and propagate it
1054     // If this block is not the first predecessor, a stack merge will be necessary
1055 
1056     BlockBegin* sux = block-&gt;sux_at(0);
1057     intArray* state = sux-&gt;fpu_stack_state();
1058     LIR_List* instrs = new LIR_List(_compilation);
1059 
1060     if (state != NULL) {
1061       // Merge with a successors that already has a FPU stack state
1062       // the block must only have one successor because critical edges must been split
1063       FpuStackSim* cur_sim = sim();
1064       FpuStackSim* sux_sim = temp_sim();
1065       sux_sim-&gt;read_state(state);
1066 
1067       merge_fpu_stack(instrs, cur_sim, sux_sim);
1068 
1069     } else {
1070       // propagate current FPU stack state to successor without state
1071       // clean up stack first so that there are no dead values on the stack
1072       if (ComputeExactFPURegisterUsage) {
1073         FpuStackSim* cur_sim = sim();
1074         ResourceBitMap live_fpu_regs = block-&gt;sux_at(0)-&gt;fpu_register_usage();
1075         assert(live_fpu_regs.size() == FrameMap::nof_fpu_regs, &quot;missing register usage&quot;);
1076 
1077         merge_cleanup_fpu_stack(instrs, cur_sim, live_fpu_regs);
1078       }
1079 
1080       intArray* state = sim()-&gt;write_state();
1081       if (TraceFPUStack) {
1082         tty-&gt;print_cr(&quot;Setting FPU stack state of B%d (merge path)&quot;, sux-&gt;block_id());
1083         sim()-&gt;print(); tty-&gt;cr();
1084       }
1085       sux-&gt;set_fpu_stack_state(state);
1086     }
1087 
1088     if (instrs-&gt;instructions_list()-&gt;length() &gt; 0) {
1089       lir()-&gt;insert_before(pos(), instrs);
1090       set_pos(instrs-&gt;instructions_list()-&gt;length() + pos());
1091       changed = true;
1092     }
1093 
1094   } else {
1095     // Propagate unmodified Stack to successors where a stack merge is not necessary
1096     intArray* state = sim()-&gt;write_state();
1097     for (int i = 0; i &lt; number_of_sux; i++) {
1098       BlockBegin* sux = block-&gt;sux_at(i);
1099 
1100 #ifdef ASSERT
1101       for (int j = 0; j &lt; sux-&gt;number_of_preds(); j++) {
1102         assert(block == sux-&gt;pred_at(j), &quot;all critical edges must be broken&quot;);
1103       }
1104 
1105       // check if new state is same
1106       if (sux-&gt;fpu_stack_state() != NULL) {
1107         intArray* sux_state = sux-&gt;fpu_stack_state();
1108         assert(state-&gt;length() == sux_state-&gt;length(), &quot;overwriting existing stack state&quot;);
1109         for (int j = 0; j &lt; state-&gt;length(); j++) {
1110           assert(state-&gt;at(j) == sux_state-&gt;at(j), &quot;overwriting existing stack state&quot;);
1111         }
1112       }
1113 #endif
1114 #ifndef PRODUCT
1115       if (TraceFPUStack) {
1116         tty-&gt;print_cr(&quot;Setting FPU stack state of B%d&quot;, sux-&gt;block_id());
1117         sim()-&gt;print(); tty-&gt;cr();
1118       }
1119 #endif
1120 
1121       sux-&gt;set_fpu_stack_state(state);
1122     }
1123   }
1124 
1125 #ifndef PRODUCT
1126   // assertions that FPU stack state conforms to all successors&#39; states
1127   intArray* cur_state = sim()-&gt;write_state();
1128   for (int i = 0; i &lt; number_of_sux; i++) {
1129     BlockBegin* sux = block-&gt;sux_at(i);
1130     intArray* sux_state = sux-&gt;fpu_stack_state();
1131 
1132     assert(sux_state != NULL, &quot;no fpu state&quot;);
1133     assert(cur_state-&gt;length() == sux_state-&gt;length(), &quot;incorrect length&quot;);
1134     for (int i = 0; i &lt; cur_state-&gt;length(); i++) {
1135       assert(cur_state-&gt;at(i) == sux_state-&gt;at(i), &quot;element not equal&quot;);
1136     }
1137   }
1138 #endif
1139 
1140   return changed;
1141 }
<a name="3" id="anc3"></a>
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
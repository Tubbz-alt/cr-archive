<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/relocInfo_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;code/relocInfo.hpp&quot;
<a name="1" id="anc1"></a>
 28 #include &quot;nativeInst_x86.hpp&quot;
 29 #include &quot;oops/compressedOops.inline.hpp&quot;
 30 #include &quot;oops/klass.inline.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 #include &quot;runtime/safepointMechanism.hpp&quot;
 34 
 35 
 36 void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {
 37 #ifdef AMD64
 38   x += o;
 39   typedef Assembler::WhichOperand WhichOperand;
 40   WhichOperand which = (WhichOperand) format(); // that is, disp32 or imm, call32, narrow oop
 41   assert(which == Assembler::disp32_operand ||
 42          which == Assembler::narrow_oop_operand ||
 43          which == Assembler::imm_operand, &quot;format unpacks ok&quot;);
 44   if (which == Assembler::imm_operand) {
 45     if (verify_only) {
 46       guarantee(*pd_address_in_code() == x, &quot;instructions must match&quot;);
 47     } else {
 48       *pd_address_in_code() = x;
 49     }
 50   } else if (which == Assembler::narrow_oop_operand) {
 51     address disp = Assembler::locate_operand(addr(), which);
 52     // both compressed oops and compressed classes look the same
<a name="2" id="anc2"></a><span class="line-modified"> 53     if (Universe::heap()-&gt;is_in_reserved((oop)x)) {</span>
 54     if (verify_only) {
 55       guarantee(*(uint32_t*) disp == CompressedOops::encode((oop)x), &quot;instructions must match&quot;);
 56     } else {
 57       *(int32_t*) disp = CompressedOops::encode((oop)x);
 58     }
 59   } else {
 60       if (verify_only) {
<a name="3" id="anc3"></a><span class="line-modified"> 61         guarantee(*(uint32_t*) disp == Klass::encode_klass((Klass*)x), &quot;instructions must match&quot;);</span>
 62       } else {
<a name="4" id="anc4"></a><span class="line-modified"> 63         *(int32_t*) disp = Klass::encode_klass((Klass*)x);</span>
 64       }
 65     }
 66   } else {
 67     // Note:  Use runtime_call_type relocations for call32_operand.
 68     address ip = addr();
 69     address disp = Assembler::locate_operand(ip, which);
 70     address next_ip = Assembler::locate_next_instruction(ip);
 71     if (verify_only) {
 72       guarantee(*(int32_t*) disp == (x - next_ip), &quot;instructions must match&quot;);
 73     } else {
 74       *(int32_t*) disp = x - next_ip;
 75     }
 76   }
 77 #else
 78   if (verify_only) {
 79     guarantee(*pd_address_in_code() == (x + o), &quot;instructions must match&quot;);
 80   } else {
 81     *pd_address_in_code() = x + o;
 82   }
 83 #endif // AMD64
 84 }
 85 
 86 
 87 address Relocation::pd_call_destination(address orig_addr) {
 88   intptr_t adj = 0;
 89   if (orig_addr != NULL) {
 90     // We just moved this call instruction from orig_addr to addr().
 91     // This means its target will appear to have grown by addr() - orig_addr.
 92     adj = -( addr() - orig_addr );
 93   }
 94   NativeInstruction* ni = nativeInstruction_at(addr());
 95   if (ni-&gt;is_call()) {
 96     return nativeCall_at(addr())-&gt;destination() + adj;
 97   } else if (ni-&gt;is_jump()) {
 98     return nativeJump_at(addr())-&gt;jump_destination() + adj;
 99   } else if (ni-&gt;is_cond_jump()) {
100     return nativeGeneralJump_at(addr())-&gt;jump_destination() + adj;
101   } else if (ni-&gt;is_mov_literal64()) {
102     return (address) ((NativeMovConstReg*)ni)-&gt;data();
103   } else {
104     ShouldNotReachHere();
105     return NULL;
106   }
107 }
108 
109 
110 void Relocation::pd_set_call_destination(address x) {
111   NativeInstruction* ni = nativeInstruction_at(addr());
112   if (ni-&gt;is_call()) {
113     nativeCall_at(addr())-&gt;set_destination(x);
114   } else if (ni-&gt;is_jump()) {
115     NativeJump* nj = nativeJump_at(addr());
116 
117     // Unresolved jumps are recognized by a destination of -1
118     // However 64bit can&#39;t actually produce such an address
119     // and encodes a jump to self but jump_destination will
120     // return a -1 as the signal. We must not relocate this
121     // jmp or the ic code will not see it as unresolved.
122 
123     if (nj-&gt;jump_destination() == (address) -1) {
124       x = addr(); // jump to self
125     }
126     nj-&gt;set_jump_destination(x);
127   } else if (ni-&gt;is_cond_jump()) {
128     // %%%% kludge this, for now, until we get a jump_destination method
129     address old_dest = nativeGeneralJump_at(addr())-&gt;jump_destination();
130     address disp = Assembler::locate_operand(addr(), Assembler::call32_operand);
131     *(jint*)disp += (x - old_dest);
132   } else if (ni-&gt;is_mov_literal64()) {
133     ((NativeMovConstReg*)ni)-&gt;set_data((intptr_t)x);
134   } else {
135     ShouldNotReachHere();
136   }
137 }
138 
139 
140 address* Relocation::pd_address_in_code() {
141   // All embedded Intel addresses are stored in 32-bit words.
142   // Since the addr points at the start of the instruction,
143   // we must parse the instruction a bit to find the embedded word.
144   assert(is_data(), &quot;must be a DataRelocation&quot;);
145   typedef Assembler::WhichOperand WhichOperand;
146   WhichOperand which = (WhichOperand) format(); // that is, disp32 or imm/imm32
147 #ifdef AMD64
148   assert(which == Assembler::disp32_operand ||
149          which == Assembler::call32_operand ||
150          which == Assembler::imm_operand, &quot;format unpacks ok&quot;);
151   // The &quot;address&quot; in the code is a displacement can&#39;t return it as
152   // and address* since it is really a jint*
153   guarantee(which == Assembler::imm_operand, &quot;must be immediate operand&quot;);
154 #else
155   assert(which == Assembler::disp32_operand || which == Assembler::imm_operand, &quot;format unpacks ok&quot;);
156 #endif // AMD64
157   return (address*) Assembler::locate_operand(addr(), which);
158 }
159 
160 
161 address Relocation::pd_get_address_from_code() {
162 #ifdef AMD64
163   // All embedded Intel addresses are stored in 32-bit words.
164   // Since the addr points at the start of the instruction,
165   // we must parse the instruction a bit to find the embedded word.
166   assert(is_data(), &quot;must be a DataRelocation&quot;);
167   typedef Assembler::WhichOperand WhichOperand;
168   WhichOperand which = (WhichOperand) format(); // that is, disp32 or imm/imm32
169   assert(which == Assembler::disp32_operand ||
170          which == Assembler::call32_operand ||
171          which == Assembler::imm_operand, &quot;format unpacks ok&quot;);
172   if (which != Assembler::imm_operand) {
173     address ip = addr();
174     address disp = Assembler::locate_operand(ip, which);
175     address next_ip = Assembler::locate_next_instruction(ip);
176     address a = next_ip + *(int32_t*) disp;
177     return a;
178   }
179 #endif // AMD64
180   return *pd_address_in_code();
181 }
182 
183 void poll_Relocation::fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) {
184 #ifdef _LP64
185   typedef Assembler::WhichOperand WhichOperand;
186   WhichOperand which = (WhichOperand) format();
187 #if !INCLUDE_JVMCI
188   if (SafepointMechanism::uses_global_page_poll()) {
189     assert((which == Assembler::disp32_operand) == !Assembler::is_polling_page_far(), &quot;format not set correctly&quot;);
190   }
191 #endif
192   if (which == Assembler::disp32_operand) {
193     assert(SafepointMechanism::uses_global_page_poll(), &quot;should only have generated such a poll if global polling enabled&quot;);
194     address orig_addr = old_addr_for(addr(), src, dest);
195     NativeInstruction* oni = nativeInstruction_at(orig_addr);
196     int32_t* orig_disp = (int32_t*) Assembler::locate_operand(orig_addr, which);
197     // This poll_addr is incorrect by the size of the instruction it is irrelevant
198     intptr_t poll_addr = (intptr_t)oni + *orig_disp;
199     NativeInstruction* ni = nativeInstruction_at(addr());
200     intptr_t new_disp = poll_addr - (intptr_t) ni;
201 
202     int32_t* disp = (int32_t*) Assembler::locate_operand(addr(), which);
203     * disp = (int32_t)new_disp;
204   }
205 #endif // _LP64
206 }
207 
208 void metadata_Relocation::pd_fix_value(address x) {
209 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
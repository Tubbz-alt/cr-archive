<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/barrierSet.hpp&quot;
  36 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  37 #include &quot;gc/shared/collectedHeap.hpp&quot;
  38 #include &quot;nativeInst_x86.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;vmreg_x86.inline.hpp&quot;
  44 
  45 
  46 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  47 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  48 // fast versions of NegF/NegD and AbsF/AbsD.
  49 
  50 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  51 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  52   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  53   // of 128-bits operands for SSE instructions.
  54   jlong *operand = (jlong*)(((intptr_t)adr) &amp; ((intptr_t)(~0xF)));
  55   // Store the value to a 128-bits operand.
  56   operand[0] = lo;
  57   operand[1] = hi;
  58   return operand;
  59 }
  60 
  61 // Buffer for 128-bits masks used by SSE instructions.
  62 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  63 
  64 // Static initialization during VM startup.
  65 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2],         CONST64(0x7FFFFFFF7FFFFFFF),         CONST64(0x7FFFFFFF7FFFFFFF));
  66 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2],         CONST64(0x7FFFFFFFFFFFFFFF),         CONST64(0x7FFFFFFFFFFFFFFF));
  67 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], (jlong)UCONST64(0x8000000080000000), (jlong)UCONST64(0x8000000080000000));
  68 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], (jlong)UCONST64(0x8000000000000000), (jlong)UCONST64(0x8000000000000000));
  69 
  70 
  71 NEEDS_CLEANUP // remove this definitions ?
  72 const Register IC_Klass    = rax;   // where the IC klass is cached
  73 const Register SYNC_header = rax;   // synchronization header
  74 const Register SHIFT_count = rcx;   // where count for shift operations must be
  75 
  76 #define __ _masm-&gt;
  77 
  78 
  79 static void select_different_registers(Register preserve,
  80                                        Register extra,
  81                                        Register &amp;tmp1,
  82                                        Register &amp;tmp2) {
  83   if (tmp1 == preserve) {
  84     assert_different_registers(tmp1, tmp2, extra);
  85     tmp1 = extra;
  86   } else if (tmp2 == preserve) {
  87     assert_different_registers(tmp1, tmp2, extra);
  88     tmp2 = extra;
  89   }
  90   assert_different_registers(preserve, tmp1, tmp2);
  91 }
  92 
  93 
  94 
  95 static void select_different_registers(Register preserve,
  96                                        Register extra,
  97                                        Register &amp;tmp1,
  98                                        Register &amp;tmp2,
  99                                        Register &amp;tmp3) {
 100   if (tmp1 == preserve) {
 101     assert_different_registers(tmp1, tmp2, tmp3, extra);
 102     tmp1 = extra;
 103   } else if (tmp2 == preserve) {
 104     assert_different_registers(tmp1, tmp2, tmp3, extra);
 105     tmp2 = extra;
 106   } else if (tmp3 == preserve) {
 107     assert_different_registers(tmp1, tmp2, tmp3, extra);
 108     tmp3 = extra;
 109   }
 110   assert_different_registers(preserve, tmp1, tmp2, tmp3);
 111 }
 112 
 113 
 114 
 115 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
 116   if (opr-&gt;is_constant()) {
 117     LIR_Const* constant = opr-&gt;as_constant_ptr();
 118     switch (constant-&gt;type()) {
 119       case T_INT: {
 120         return true;
 121       }
 122 
 123       default:
 124         return false;
 125     }
 126   }
 127   return false;
 128 }
 129 
 130 
 131 LIR_Opr LIR_Assembler::receiverOpr() {
 132   return FrameMap::receiver_opr;
 133 }
 134 
 135 LIR_Opr LIR_Assembler::osrBufferPointer() {
 136   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 137 }
 138 
 139 //--------------fpu register translations-----------------------
 140 
 141 
 142 address LIR_Assembler::float_constant(float f) {
 143   address const_addr = __ float_constant(f);
 144   if (const_addr == NULL) {
 145     bailout(&quot;const section overflow&quot;);
 146     return __ code()-&gt;consts()-&gt;start();
 147   } else {
 148     return const_addr;
 149   }
 150 }
 151 
 152 
 153 address LIR_Assembler::double_constant(double d) {
 154   address const_addr = __ double_constant(d);
 155   if (const_addr == NULL) {
 156     bailout(&quot;const section overflow&quot;);
 157     return __ code()-&gt;consts()-&gt;start();
 158   } else {
 159     return const_addr;
 160   }
 161 }
 162 
 163 
 164 void LIR_Assembler::set_24bit_FPU() {
 165   __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
 166 }
 167 
 168 void LIR_Assembler::reset_FPU() {
 169   __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
 170 }
 171 
 172 void LIR_Assembler::fpop() {
 173   __ fpop();
 174 }
 175 
 176 void LIR_Assembler::fxch(int i) {
 177   __ fxch(i);
 178 }
 179 
 180 void LIR_Assembler::fld(int i) {
 181   __ fld_s(i);
 182 }
 183 
 184 void LIR_Assembler::ffree(int i) {
 185   __ ffree(i);
 186 }
 187 
 188 void LIR_Assembler::breakpoint() {
 189   __ int3();
 190 }
 191 
 192 void LIR_Assembler::push(LIR_Opr opr) {
 193   if (opr-&gt;is_single_cpu()) {
 194     __ push_reg(opr-&gt;as_register());
 195   } else if (opr-&gt;is_double_cpu()) {
 196     NOT_LP64(__ push_reg(opr-&gt;as_register_hi()));
 197     __ push_reg(opr-&gt;as_register_lo());
 198   } else if (opr-&gt;is_stack()) {
 199     __ push_addr(frame_map()-&gt;address_for_slot(opr-&gt;single_stack_ix()));
 200   } else if (opr-&gt;is_constant()) {
 201     LIR_Const* const_opr = opr-&gt;as_constant_ptr();
 202     if (const_opr-&gt;type() == T_OBJECT) {
 203       __ push_oop(const_opr-&gt;as_jobject());
 204     } else if (const_opr-&gt;type() == T_INT) {
 205       __ push_jint(const_opr-&gt;as_jint());
 206     } else {
 207       ShouldNotReachHere();
 208     }
 209 
 210   } else {
 211     ShouldNotReachHere();
 212   }
 213 }
 214 
 215 void LIR_Assembler::pop(LIR_Opr opr) {
 216   if (opr-&gt;is_single_cpu()) {
 217     __ pop_reg(opr-&gt;as_register());
 218   } else {
 219     ShouldNotReachHere();
 220   }
 221 }
 222 
 223 bool LIR_Assembler::is_literal_address(LIR_Address* addr) {
 224   return addr-&gt;base()-&gt;is_illegal() &amp;&amp; addr-&gt;index()-&gt;is_illegal();
 225 }
 226 
 227 //-------------------------------------------
 228 
 229 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 230   return as_Address(addr, rscratch1);
 231 }
 232 
 233 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 234   if (addr-&gt;base()-&gt;is_illegal()) {
 235     assert(addr-&gt;index()-&gt;is_illegal(), &quot;must be illegal too&quot;);
 236     AddressLiteral laddr((address)addr-&gt;disp(), relocInfo::none);
 237     if (! __ reachable(laddr)) {
 238       __ movptr(tmp, laddr.addr());
 239       Address res(tmp, 0);
 240       return res;
 241     } else {
 242       return __ as_Address(laddr);
 243     }
 244   }
 245 
 246   Register base = addr-&gt;base()-&gt;as_pointer_register();
 247 
 248   if (addr-&gt;index()-&gt;is_illegal()) {
 249     return Address( base, addr-&gt;disp());
 250   } else if (addr-&gt;index()-&gt;is_cpu_register()) {
 251     Register index = addr-&gt;index()-&gt;as_pointer_register();
 252     return Address(base, index, (Address::ScaleFactor) addr-&gt;scale(), addr-&gt;disp());
 253   } else if (addr-&gt;index()-&gt;is_constant()) {
 254     intptr_t addr_offset = (addr-&gt;index()-&gt;as_constant_ptr()-&gt;as_jint() &lt;&lt; addr-&gt;scale()) + addr-&gt;disp();
 255     assert(Assembler::is_simm32(addr_offset), &quot;must be&quot;);
 256 
 257     return Address(base, addr_offset);
 258   } else {
 259     Unimplemented();
 260     return Address();
 261   }
 262 }
 263 
 264 
 265 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 266   Address base = as_Address(addr);
 267   return Address(base._base, base._index, base._scale, base._disp + BytesPerWord);
 268 }
 269 
 270 
 271 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 272   return as_Address(addr);
 273 }
 274 
 275 
 276 void LIR_Assembler::osr_entry() {
 277   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 278   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 279   ValueStack* entry_state = osr_entry-&gt;state();
 280   int number_of_locks = entry_state-&gt;locks_size();
 281 
 282   // we jump here if osr happens with the interpreter
 283   // state set up to continue at the beginning of the
 284   // loop that triggered osr - in particular, we have
 285   // the following registers setup:
 286   //
 287   // rcx: osr buffer
 288   //
 289 
 290   // build frame
 291   ciMethod* m = compilation()-&gt;method();
 292   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 293 
 294   // OSR buffer is
 295   //
 296   // locals[nlocals-1..0]
 297   // monitors[0..number_of_locks]
 298   //
 299   // locals is a direct copy of the interpreter frame so in the osr buffer
 300   // so first slot in the local array is the last local from the interpreter
 301   // and last slot is local[0] (receiver) from the interpreter
 302   //
 303   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 304   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 305   // in the interpreter frame (the method lock if a sync method)
 306 
 307   // Initialize monitors in the compiled activation.
 308   //   rcx: pointer to osr buffer
 309   //
 310   // All other registers are dead at this point and the locals will be
 311   // copied into place by code emitted in the IR.
 312 
 313   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 314   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 315     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 316       (BasicObjectLock::size() * BytesPerWord) * (number_of_locks - 1);
 317     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 318     // the OSR buffer using 2 word entries: first the lock and then
 319     // the oop.
 320     for (int i = 0; i &lt; number_of_locks; i++) {
 321       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 322 #ifdef ASSERT
 323       // verify the interpreter&#39;s monitor has a non-null object
 324       {
 325         Label L;
 326         __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), (int32_t)NULL_WORD);
 327         __ jcc(Assembler::notZero, L);
 328         __ stop(&quot;locked object is NULL&quot;);
 329         __ bind(L);
 330       }
 331 #endif
 332       __ movptr(rbx, Address(OSR_buf, slot_offset + 0));
 333       __ movptr(frame_map()-&gt;address_for_monitor_lock(i), rbx);
 334       __ movptr(rbx, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 335       __ movptr(frame_map()-&gt;address_for_monitor_object(i), rbx);
 336     }
 337   }
 338 }
 339 
 340 
 341 // inline cache check; done before the frame is built.
 342 int LIR_Assembler::check_icache() {
 343   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 344   Register ic_klass = IC_Klass;
 345   const int ic_cmp_size = LP64_ONLY(10) NOT_LP64(9);
 346   const bool do_post_padding = VerifyOops || UseCompressedClassPointers;
 347   if (!do_post_padding) {
 348     // insert some nops so that the verified entry point is aligned on CodeEntryAlignment
 349     __ align(CodeEntryAlignment, __ offset() + ic_cmp_size);
 350   }
 351   int offset = __ offset();
 352   __ inline_cache_check(receiver, IC_Klass);
 353   assert(__ offset() % CodeEntryAlignment == 0 || do_post_padding, &quot;alignment must be correct&quot;);
 354   if (do_post_padding) {
 355     // force alignment after the cache check.
 356     // It&#39;s been verified to be aligned if !VerifyOops
 357     __ align(CodeEntryAlignment);
 358   }
 359   return offset;
 360 }
 361 
 362 
 363 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
 364   jobject o = NULL;
 365   PatchingStub* patch = new PatchingStub(_masm, patching_id(info));
 366   __ movoop(reg, o);
 367   patching_epilog(patch, lir_patch_normal, reg, info);
 368 }
 369 
 370 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 371   Metadata* o = NULL;
 372   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id);
 373   __ mov_metadata(reg, o);
 374   patching_epilog(patch, lir_patch_normal, reg, info);
 375 }
 376 
 377 // This specifies the rsp decrement needed to build the frame
 378 int LIR_Assembler::initial_frame_size_in_bytes() const {
 379   // if rounding, must let FrameMap know!
 380 
 381   // The frame_map records size in slots (32bit word)
 382 
 383   // subtract two words to account for return address and link
 384   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 385 }
 386 
 387 
 388 int LIR_Assembler::emit_exception_handler() {
 389   // if the last instruction is a call (typically to do a throw which
 390   // is coming at the end after block reordering) the return address
 391   // must still point into the code area in order to avoid assertion
 392   // failures when searching for the corresponding bci =&gt; add a nop
 393   // (was bug 5/14/1999 - gri)
 394   __ nop();
 395 
 396   // generate code for exception handler
 397   address handler_base = __ start_a_stub(exception_handler_size());
 398   if (handler_base == NULL) {
 399     // not enough space left for the handler
 400     bailout(&quot;exception handler overflow&quot;);
 401     return -1;
 402   }
 403 
 404   int offset = code_offset();
 405 
 406   // the exception oop and pc are in rax, and rdx
 407   // no other registers need to be preserved, so invalidate them
 408   __ invalidate_registers(false, true, true, false, true, true);
 409 
 410   // check that there is really an exception
 411   __ verify_not_null_oop(rax);
 412 
 413   // search an exception handler (rax: exception oop, rdx: throwing pc)
 414   __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));
 415   __ should_not_reach_here();
 416   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 417   __ end_a_stub();
 418 
 419   return offset;
 420 }
 421 
 422 
 423 // Emit the code to remove the frame from the stack in the exception
 424 // unwind path.
 425 int LIR_Assembler::emit_unwind_handler() {
 426 #ifndef PRODUCT
 427   if (CommentedAssembly) {
 428     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 429   }
 430 #endif
 431 
 432   int offset = code_offset();
 433 
 434   // Fetch the exception from TLS and clear out exception related thread state
 435   Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
 436   NOT_LP64(__ get_thread(rsi));
 437   __ movptr(rax, Address(thread, JavaThread::exception_oop_offset()));
 438   __ movptr(Address(thread, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);
 439   __ movptr(Address(thread, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);
 440 
 441   __ bind(_unwind_handler_entry);
 442   __ verify_not_null_oop(rax);
 443   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 444     __ mov(rbx, rax);  // Preserve the exception (rbx is always callee-saved)
 445   }
 446 
 447   // Preform needed unlocking
 448   MonitorExitStub* stub = NULL;
 449   if (method()-&gt;is_synchronized()) {
 450     monitor_address(0, FrameMap::rax_opr);
 451     stub = new MonitorExitStub(FrameMap::rax_opr, true, 0);
 452     __ unlock_object(rdi, rsi, rax, *stub-&gt;entry());
 453     __ bind(*stub-&gt;continuation());
 454   }
 455 
 456   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 457 #ifdef _LP64
 458     __ mov(rdi, r15_thread);
 459     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 460 #else
 461     __ get_thread(rax);
 462     __ movptr(Address(rsp, 0), rax);
 463     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 464 #endif
 465     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 466   }
 467 
 468   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 469     __ mov(rax, rbx);  // Restore the exception
 470   }
 471 
 472   // remove the activation and dispatch to the unwind handler
 473   __ remove_frame(initial_frame_size_in_bytes());
 474   __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 475 
 476   // Emit the slow path assembly
 477   if (stub != NULL) {
 478     stub-&gt;emit_code(this);
 479   }
 480 
 481   return offset;
 482 }
 483 
 484 
 485 int LIR_Assembler::emit_deopt_handler() {
 486   // if the last instruction is a call (typically to do a throw which
 487   // is coming at the end after block reordering) the return address
 488   // must still point into the code area in order to avoid assertion
 489   // failures when searching for the corresponding bci =&gt; add a nop
 490   // (was bug 5/14/1999 - gri)
 491   __ nop();
 492 
 493   // generate code for exception handler
 494   address handler_base = __ start_a_stub(deopt_handler_size());
 495   if (handler_base == NULL) {
 496     // not enough space left for the handler
 497     bailout(&quot;deopt handler overflow&quot;);
 498     return -1;
 499   }
 500 
 501   int offset = code_offset();
 502   InternalAddress here(__ pc());
 503 
 504   __ pushptr(here.addr());
 505   __ jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 506   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 507   __ end_a_stub();
 508 
 509   return offset;
 510 }
 511 
 512 
 513 void LIR_Assembler::return_op(LIR_Opr result) {
 514   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
 515   if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
 516     assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
 517   }
 518 
 519   // Pop the stack before the safepoint code
 520   __ remove_frame(initial_frame_size_in_bytes());
 521 
 522   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 523     __ reserved_stack_check();
 524   }
 525 
 526   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 527 
 528   // Note: we do not need to round double result; float result has the right precision
 529   // the poll sets the condition code, but no data registers
 530 
 531   if (SafepointMechanism::uses_thread_local_poll()) {
 532 #ifdef _LP64
 533     const Register poll_addr = rscratch1;
 534     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 535 #else
 536     const Register poll_addr = rbx;
 537     assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);
 538     __ get_thread(poll_addr);
 539     __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));
 540 #endif
 541     __ relocate(relocInfo::poll_return_type);
 542     __ testl(rax, Address(poll_addr, 0));
 543   } else {
 544     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
 545 
 546     if (Assembler::is_polling_page_far()) {
 547       __ lea(rscratch1, polling_page);
 548       __ relocate(relocInfo::poll_return_type);
 549       __ testl(rax, Address(rscratch1, 0));
 550     } else {
 551       __ testl(rax, polling_page);
 552     }
 553   }
 554   __ ret(0);
 555 }
 556 
 557 
 558 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 559   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 560   int offset = __ offset();
 561   if (SafepointMechanism::uses_thread_local_poll()) {
 562 #ifdef _LP64
 563     const Register poll_addr = rscratch1;
 564     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 565 #else
 566     assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);
 567     const Register poll_addr = tmp-&gt;as_register();
 568     __ get_thread(poll_addr);
 569     __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));
 570 #endif
 571     add_debug_info_for_branch(info);
 572     __ relocate(relocInfo::poll_type);
 573     address pre_pc = __ pc();
 574     __ testl(rax, Address(poll_addr, 0));
 575     address post_pc = __ pc();
 576     guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);
 577   } else {
 578     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_type);
 579     if (Assembler::is_polling_page_far()) {
 580       __ lea(rscratch1, polling_page);
 581       offset = __ offset();
 582       add_debug_info_for_branch(info);
 583       __ relocate(relocInfo::poll_type);
 584       __ testl(rax, Address(rscratch1, 0));
 585     } else {
 586       add_debug_info_for_branch(info);
 587       __ testl(rax, polling_page);
 588     }
 589   }
 590   return offset;
 591 }
 592 
 593 
 594 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 595   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 596 }
 597 
 598 void LIR_Assembler::swap_reg(Register a, Register b) {
 599   __ xchgptr(a, b);
 600 }
 601 
 602 
 603 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 604   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 605   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 606   LIR_Const* c = src-&gt;as_constant_ptr();
 607 
 608   switch (c-&gt;type()) {
 609     case T_INT: {
 610       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 611       __ movl(dest-&gt;as_register(), c-&gt;as_jint());
 612       break;
 613     }
 614 
 615     case T_ADDRESS: {
 616       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 617       __ movptr(dest-&gt;as_register(), c-&gt;as_jint());
 618       break;
 619     }
 620 
 621     case T_LONG: {
 622       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 623 #ifdef _LP64
 624       __ movptr(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 625 #else
 626       __ movptr(dest-&gt;as_register_lo(), c-&gt;as_jint_lo());
 627       __ movptr(dest-&gt;as_register_hi(), c-&gt;as_jint_hi());
 628 #endif // _LP64
 629       break;
 630     }
 631 
 632     case T_OBJECT: {
 633       if (patch_code != lir_patch_none) {
 634         jobject2reg_with_patching(dest-&gt;as_register(), info);
 635       } else {
 636         __ movoop(dest-&gt;as_register(), c-&gt;as_jobject());
 637       }
 638       break;
 639     }
 640 
 641     case T_METADATA: {
 642       if (patch_code != lir_patch_none) {
 643         klass2reg_with_patching(dest-&gt;as_register(), info);
 644       } else {
 645         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 646       }
 647       break;
 648     }
 649 
 650     case T_FLOAT: {
 651       if (dest-&gt;is_single_xmm()) {
 652         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_float()) {
 653           __ xorps(dest-&gt;as_xmm_float_reg(), dest-&gt;as_xmm_float_reg());
 654         } else {
 655           __ movflt(dest-&gt;as_xmm_float_reg(),
 656                    InternalAddress(float_constant(c-&gt;as_jfloat())));
 657         }
 658       } else {
 659         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
 660         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
 661         if (c-&gt;is_zero_float()) {
 662           __ fldz();
 663         } else if (c-&gt;is_one_float()) {
 664           __ fld1();
 665         } else {
 666           __ fld_s (InternalAddress(float_constant(c-&gt;as_jfloat())));
 667         }
 668       }
 669       break;
 670     }
 671 
 672     case T_DOUBLE: {
 673       if (dest-&gt;is_double_xmm()) {
 674         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_double()) {
 675           __ xorpd(dest-&gt;as_xmm_double_reg(), dest-&gt;as_xmm_double_reg());
 676         } else {
 677           __ movdbl(dest-&gt;as_xmm_double_reg(),
 678                     InternalAddress(double_constant(c-&gt;as_jdouble())));
 679         }
 680       } else {
 681         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
 682         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
 683         if (c-&gt;is_zero_double()) {
 684           __ fldz();
 685         } else if (c-&gt;is_one_double()) {
 686           __ fld1();
 687         } else {
 688           __ fld_d (InternalAddress(double_constant(c-&gt;as_jdouble())));
 689         }
 690       }
 691       break;
 692     }
 693 
 694     default:
 695       ShouldNotReachHere();
 696   }
 697 }
 698 
 699 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 700   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 701   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 702   LIR_Const* c = src-&gt;as_constant_ptr();
 703 
 704   switch (c-&gt;type()) {
 705     case T_INT:  // fall through
 706     case T_FLOAT:
 707       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 708       break;
 709 
 710     case T_ADDRESS:
 711       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 712       break;
 713 
 714     case T_OBJECT:
 715       __ movoop(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jobject());
 716       break;
 717 
 718     case T_LONG:  // fall through
 719     case T_DOUBLE:
 720 #ifdef _LP64
 721       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 722                                             lo_word_offset_in_bytes), (intptr_t)c-&gt;as_jlong_bits());
 723 #else
 724       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 725                                               lo_word_offset_in_bytes), c-&gt;as_jint_lo_bits());
 726       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 727                                               hi_word_offset_in_bytes), c-&gt;as_jint_hi_bits());
 728 #endif // _LP64
 729       break;
 730 
 731     default:
 732       ShouldNotReachHere();
 733   }
 734 }
 735 
 736 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 737   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 738   assert(dest-&gt;is_address(), &quot;should not call otherwise&quot;);
 739   LIR_Const* c = src-&gt;as_constant_ptr();
 740   LIR_Address* addr = dest-&gt;as_address_ptr();
 741 
 742   int null_check_here = code_offset();
 743   switch (type) {
 744     case T_INT:    // fall through
 745     case T_FLOAT:
 746       __ movl(as_Address(addr), c-&gt;as_jint_bits());
 747       break;
 748 
 749     case T_ADDRESS:
 750       __ movptr(as_Address(addr), c-&gt;as_jint_bits());
 751       break;
 752 
 753     case T_OBJECT:  // fall through
 754     case T_ARRAY:
 755       if (c-&gt;as_jobject() == NULL) {
 756         if (UseCompressedOops &amp;&amp; !wide) {
 757           __ movl(as_Address(addr), (int32_t)NULL_WORD);
 758         } else {
 759 #ifdef _LP64
 760           __ xorptr(rscratch1, rscratch1);
 761           null_check_here = code_offset();
 762           __ movptr(as_Address(addr), rscratch1);
 763 #else
 764           __ movptr(as_Address(addr), NULL_WORD);
 765 #endif
 766         }
 767       } else {
 768         if (is_literal_address(addr)) {
 769           ShouldNotReachHere();
 770           __ movoop(as_Address(addr, noreg), c-&gt;as_jobject());
 771         } else {
 772 #ifdef _LP64
 773           __ movoop(rscratch1, c-&gt;as_jobject());
 774           if (UseCompressedOops &amp;&amp; !wide) {
 775             __ encode_heap_oop(rscratch1);
 776             null_check_here = code_offset();
 777             __ movl(as_Address_lo(addr), rscratch1);
 778           } else {
 779             null_check_here = code_offset();
 780             __ movptr(as_Address_lo(addr), rscratch1);
 781           }
 782 #else
 783           __ movoop(as_Address(addr), c-&gt;as_jobject());
 784 #endif
 785         }
 786       }
 787       break;
 788 
 789     case T_LONG:    // fall through
 790     case T_DOUBLE:
 791 #ifdef _LP64
 792       if (is_literal_address(addr)) {
 793         ShouldNotReachHere();
 794         __ movptr(as_Address(addr, r15_thread), (intptr_t)c-&gt;as_jlong_bits());
 795       } else {
 796         __ movptr(r10, (intptr_t)c-&gt;as_jlong_bits());
 797         null_check_here = code_offset();
 798         __ movptr(as_Address_lo(addr), r10);
 799       }
 800 #else
 801       // Always reachable in 32bit so this doesn&#39;t produce useless move literal
 802       __ movptr(as_Address_hi(addr), c-&gt;as_jint_hi_bits());
 803       __ movptr(as_Address_lo(addr), c-&gt;as_jint_lo_bits());
 804 #endif // _LP64
 805       break;
 806 
 807     case T_BOOLEAN: // fall through
 808     case T_BYTE:
 809       __ movb(as_Address(addr), c-&gt;as_jint() &amp; 0xFF);
 810       break;
 811 
 812     case T_CHAR:    // fall through
 813     case T_SHORT:
 814       __ movw(as_Address(addr), c-&gt;as_jint() &amp; 0xFFFF);
 815       break;
 816 
 817     default:
 818       ShouldNotReachHere();
 819   };
 820 
 821   if (info != NULL) {
 822     add_debug_info_for_null_check(null_check_here, info);
 823   }
 824 }
 825 
 826 
 827 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 828   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 829   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 830 
 831   // move between cpu-registers
 832   if (dest-&gt;is_single_cpu()) {
 833 #ifdef _LP64
 834     if (src-&gt;type() == T_LONG) {
 835       // Can do LONG -&gt; OBJECT
 836       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 837       return;
 838     }
 839 #endif
 840     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 841     if (src-&gt;type() == T_OBJECT) {
 842       __ verify_oop(src-&gt;as_register());
 843     }
 844     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 845 
 846   } else if (dest-&gt;is_double_cpu()) {
 847 #ifdef _LP64
 848     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_ARRAY) {
 849       // Surprising to me but we can see move of a long to t_object
 850       __ verify_oop(src-&gt;as_register());
 851       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 852       return;
 853     }
 854 #endif
 855     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 856     Register f_lo = src-&gt;as_register_lo();
 857     Register f_hi = src-&gt;as_register_hi();
 858     Register t_lo = dest-&gt;as_register_lo();
 859     Register t_hi = dest-&gt;as_register_hi();
 860 #ifdef _LP64
 861     assert(f_hi == f_lo, &quot;must be same&quot;);
 862     assert(t_hi == t_lo, &quot;must be same&quot;);
 863     move_regs(f_lo, t_lo);
 864 #else
 865     assert(f_lo != f_hi &amp;&amp; t_lo != t_hi, &quot;invalid register allocation&quot;);
 866 
 867 
 868     if (f_lo == t_hi &amp;&amp; f_hi == t_lo) {
 869       swap_reg(f_lo, f_hi);
 870     } else if (f_hi == t_lo) {
 871       assert(f_lo != t_hi, &quot;overwriting register&quot;);
 872       move_regs(f_hi, t_hi);
 873       move_regs(f_lo, t_lo);
 874     } else {
 875       assert(f_hi != t_lo, &quot;overwriting register&quot;);
 876       move_regs(f_lo, t_lo);
 877       move_regs(f_hi, t_hi);
 878     }
 879 #endif // LP64
 880 
 881     // special moves from fpu-register to xmm-register
 882     // necessary for method results
 883   } else if (src-&gt;is_single_xmm() &amp;&amp; !dest-&gt;is_single_xmm()) {
 884     __ movflt(Address(rsp, 0), src-&gt;as_xmm_float_reg());
 885     __ fld_s(Address(rsp, 0));
 886   } else if (src-&gt;is_double_xmm() &amp;&amp; !dest-&gt;is_double_xmm()) {
 887     __ movdbl(Address(rsp, 0), src-&gt;as_xmm_double_reg());
 888     __ fld_d(Address(rsp, 0));
 889   } else if (dest-&gt;is_single_xmm() &amp;&amp; !src-&gt;is_single_xmm()) {
 890     __ fstp_s(Address(rsp, 0));
 891     __ movflt(dest-&gt;as_xmm_float_reg(), Address(rsp, 0));
 892   } else if (dest-&gt;is_double_xmm() &amp;&amp; !src-&gt;is_double_xmm()) {
 893     __ fstp_d(Address(rsp, 0));
 894     __ movdbl(dest-&gt;as_xmm_double_reg(), Address(rsp, 0));
 895 
 896     // move between xmm-registers
 897   } else if (dest-&gt;is_single_xmm()) {
 898     assert(src-&gt;is_single_xmm(), &quot;must match&quot;);
 899     __ movflt(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_float_reg());
 900   } else if (dest-&gt;is_double_xmm()) {
 901     assert(src-&gt;is_double_xmm(), &quot;must match&quot;);
 902     __ movdbl(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_double_reg());
 903 
 904     // move between fpu-registers (no instruction necessary because of fpu-stack)
 905   } else if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
 906     assert(src-&gt;is_single_fpu() || src-&gt;is_double_fpu(), &quot;must match&quot;);
 907     assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;currently should be nothing to do&quot;);
 908   } else {
 909     ShouldNotReachHere();
 910   }
 911 }
 912 
 913 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 914   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 915   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 916 
 917   if (src-&gt;is_single_cpu()) {
 918     Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 919     if (type == T_OBJECT || type == T_ARRAY) {
 920       __ verify_oop(src-&gt;as_register());
 921       __ movptr (dst, src-&gt;as_register());
 922     } else if (type == T_METADATA) {
 923       __ movptr (dst, src-&gt;as_register());
 924     } else {
 925       __ movl (dst, src-&gt;as_register());
 926     }
 927 
 928   } else if (src-&gt;is_double_cpu()) {
 929     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 930     Address dstHI = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), hi_word_offset_in_bytes);
 931     __ movptr (dstLO, src-&gt;as_register_lo());
 932     NOT_LP64(__ movptr (dstHI, src-&gt;as_register_hi()));
 933 
 934   } else if (src-&gt;is_single_xmm()) {
 935     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 936     __ movflt(dst_addr, src-&gt;as_xmm_float_reg());
 937 
 938   } else if (src-&gt;is_double_xmm()) {
 939     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 940     __ movdbl(dst_addr, src-&gt;as_xmm_double_reg());
 941 
 942   } else if (src-&gt;is_single_fpu()) {
 943     assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 944     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 945     if (pop_fpu_stack)     __ fstp_s (dst_addr);
 946     else                   __ fst_s  (dst_addr);
 947 
 948   } else if (src-&gt;is_double_fpu()) {
 949     assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
 950     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 951     if (pop_fpu_stack)     __ fstp_d (dst_addr);
 952     else                   __ fst_d  (dst_addr);
 953 
 954   } else {
 955     ShouldNotReachHere();
 956   }
 957 }
 958 
 959 
 960 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 961   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 962   PatchingStub* patch = NULL;
 963   Register compressed_src = rscratch1;
 964 
 965   if (type == T_ARRAY || type == T_OBJECT) {
 966     __ verify_oop(src-&gt;as_register());
 967 #ifdef _LP64
 968     if (UseCompressedOops &amp;&amp; !wide) {
 969       __ movptr(compressed_src, src-&gt;as_register());
 970       __ encode_heap_oop(compressed_src);
 971       if (patch_code != lir_patch_none) {
 972         info-&gt;oop_map()-&gt;set_narrowoop(compressed_src-&gt;as_VMReg());
 973       }
 974     }
 975 #endif
 976   }
 977 
 978   if (patch_code != lir_patch_none) {
 979     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 980     Address toa = as_Address(to_addr);
 981     assert(toa.disp() != 0, &quot;must have&quot;);
 982   }
 983 
 984   int null_check_here = code_offset();
 985   switch (type) {
 986     case T_FLOAT: {
 987       if (src-&gt;is_single_xmm()) {
 988         __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
 989       } else {
 990         assert(src-&gt;is_single_fpu(), &quot;must be&quot;);
 991         assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 992         if (pop_fpu_stack)      __ fstp_s(as_Address(to_addr));
 993         else                    __ fst_s (as_Address(to_addr));
 994       }
 995       break;
 996     }
 997 
 998     case T_DOUBLE: {
 999       if (src-&gt;is_double_xmm()) {
1000         __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1001       } else {
1002         assert(src-&gt;is_double_fpu(), &quot;must be&quot;);
1003         assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
1004         if (pop_fpu_stack)      __ fstp_d(as_Address(to_addr));
1005         else                    __ fst_d (as_Address(to_addr));
1006       }
1007       break;
1008     }
1009 
1010     case T_ARRAY:   // fall through
1011     case T_OBJECT:  // fall through
1012       if (UseCompressedOops &amp;&amp; !wide) {
1013         __ movl(as_Address(to_addr), compressed_src);
1014       } else {
1015         __ movptr(as_Address(to_addr), src-&gt;as_register());
1016       }
1017       break;
1018     case T_METADATA:
1019       // We get here to store a method pointer to the stack to pass to
1020       // a dtrace runtime call. This can&#39;t work on 64 bit with
1021       // compressed klass ptrs: T_METADATA can be a compressed klass
1022       // ptr or a 64 bit method pointer.
1023       LP64_ONLY(ShouldNotReachHere());
1024       __ movptr(as_Address(to_addr), src-&gt;as_register());
1025       break;
1026     case T_ADDRESS:
1027       __ movptr(as_Address(to_addr), src-&gt;as_register());
1028       break;
1029     case T_INT:
1030       __ movl(as_Address(to_addr), src-&gt;as_register());
1031       break;
1032 
1033     case T_LONG: {
1034       Register from_lo = src-&gt;as_register_lo();
1035       Register from_hi = src-&gt;as_register_hi();
1036 #ifdef _LP64
1037       __ movptr(as_Address_lo(to_addr), from_lo);
1038 #else
1039       Register base = to_addr-&gt;base()-&gt;as_register();
1040       Register index = noreg;
1041       if (to_addr-&gt;index()-&gt;is_register()) {
1042         index = to_addr-&gt;index()-&gt;as_register();
1043       }
1044       if (base == from_lo || index == from_lo) {
1045         assert(base != from_hi, &quot;can&#39;t be&quot;);
1046         assert(index == noreg || (index != base &amp;&amp; index != from_hi), &quot;can&#39;t handle this&quot;);
1047         __ movl(as_Address_hi(to_addr), from_hi);
1048         if (patch != NULL) {
1049           patching_epilog(patch, lir_patch_high, base, info);
1050           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1051           patch_code = lir_patch_low;
1052         }
1053         __ movl(as_Address_lo(to_addr), from_lo);
1054       } else {
1055         assert(index == noreg || (index != base &amp;&amp; index != from_lo), &quot;can&#39;t handle this&quot;);
1056         __ movl(as_Address_lo(to_addr), from_lo);
1057         if (patch != NULL) {
1058           patching_epilog(patch, lir_patch_low, base, info);
1059           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1060           patch_code = lir_patch_high;
1061         }
1062         __ movl(as_Address_hi(to_addr), from_hi);
1063       }
1064 #endif // _LP64
1065       break;
1066     }
1067 
1068     case T_BYTE:    // fall through
1069     case T_BOOLEAN: {
1070       Register src_reg = src-&gt;as_register();
1071       Address dst_addr = as_Address(to_addr);
1072       assert(VM_Version::is_P6() || src_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1073       __ movb(dst_addr, src_reg);
1074       break;
1075     }
1076 
1077     case T_CHAR:    // fall through
1078     case T_SHORT:
1079       __ movw(as_Address(to_addr), src-&gt;as_register());
1080       break;
1081 
1082     default:
1083       ShouldNotReachHere();
1084   }
1085   if (info != NULL) {
1086     add_debug_info_for_null_check(null_check_here, info);
1087   }
1088 
1089   if (patch_code != lir_patch_none) {
1090     patching_epilog(patch, patch_code, to_addr-&gt;base()-&gt;as_register(), info);
1091   }
1092 }
1093 
1094 
1095 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1096   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1097   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1098 
1099   if (dest-&gt;is_single_cpu()) {
1100     if (type == T_ARRAY || type == T_OBJECT) {
1101       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1102       __ verify_oop(dest-&gt;as_register());
1103     } else if (type == T_METADATA) {
1104       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1105     } else {
1106       __ movl(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1107     }
1108 
1109   } else if (dest-&gt;is_double_cpu()) {
1110     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
1111     Address src_addr_HI = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), hi_word_offset_in_bytes);
1112     __ movptr(dest-&gt;as_register_lo(), src_addr_LO);
1113     NOT_LP64(__ movptr(dest-&gt;as_register_hi(), src_addr_HI));
1114 
1115   } else if (dest-&gt;is_single_xmm()) {
1116     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1117     __ movflt(dest-&gt;as_xmm_float_reg(), src_addr);
1118 
1119   } else if (dest-&gt;is_double_xmm()) {
1120     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1121     __ movdbl(dest-&gt;as_xmm_double_reg(), src_addr);
1122 
1123   } else if (dest-&gt;is_single_fpu()) {
1124     assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1125     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1126     __ fld_s(src_addr);
1127 
1128   } else if (dest-&gt;is_double_fpu()) {
1129     assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1130     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1131     __ fld_d(src_addr);
1132 
1133   } else {
1134     ShouldNotReachHere();
1135   }
1136 }
1137 
1138 
1139 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1140   if (src-&gt;is_single_stack()) {
1141     if (type == T_OBJECT || type == T_ARRAY) {
1142       __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1143       __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1144     } else {
1145 #ifndef _LP64
1146       __ pushl(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1147       __ popl (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1148 #else
1149       //no pushl on 64bits
1150       __ movl(rscratch1, frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1151       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), rscratch1);
1152 #endif
1153     }
1154 
1155   } else if (src-&gt;is_double_stack()) {
1156 #ifdef _LP64
1157     __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix()));
1158     __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
1159 #else
1160     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 0));
1161     // push and pop the part at src + wordSize, adding wordSize for the previous push
1162     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 2 * wordSize));
1163     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 2 * wordSize));
1164     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 0));
1165 #endif // _LP64
1166 
1167   } else {
1168     ShouldNotReachHere();
1169   }
1170 }
1171 
1172 
1173 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
1174   assert(src-&gt;is_address(), &quot;should not call otherwise&quot;);
1175   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1176 
1177   LIR_Address* addr = src-&gt;as_address_ptr();
1178   Address from_addr = as_Address(addr);
1179 
1180   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
1181     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
1182   }
1183 
1184   switch (type) {
1185     case T_BOOLEAN: // fall through
1186     case T_BYTE:    // fall through
1187     case T_CHAR:    // fall through
1188     case T_SHORT:
1189       if (!VM_Version::is_P6() &amp;&amp; !from_addr.uses(dest-&gt;as_register())) {
1190         // on pre P6 processors we may get partial register stalls
1191         // so blow away the value of to_rinfo before loading a
1192         // partial word into it.  Do it here so that it precedes
1193         // the potential patch point below.
1194         __ xorptr(dest-&gt;as_register(), dest-&gt;as_register());
1195       }
1196       break;
1197    default:
1198      break;
1199   }
1200 
1201   PatchingStub* patch = NULL;
1202   if (patch_code != lir_patch_none) {
1203     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1204     assert(from_addr.disp() != 0, &quot;must have&quot;);
1205   }
1206   if (info != NULL) {
1207     add_debug_info_for_null_check_here(info);
1208   }
1209 
1210   switch (type) {
1211     case T_FLOAT: {
1212       if (dest-&gt;is_single_xmm()) {
1213         __ movflt(dest-&gt;as_xmm_float_reg(), from_addr);
1214       } else {
1215         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
1216         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1217         __ fld_s(from_addr);
1218       }
1219       break;
1220     }
1221 
1222     case T_DOUBLE: {
1223       if (dest-&gt;is_double_xmm()) {
1224         __ movdbl(dest-&gt;as_xmm_double_reg(), from_addr);
1225       } else {
1226         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
1227         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1228         __ fld_d(from_addr);
1229       }
1230       break;
1231     }
1232 
1233     case T_OBJECT:  // fall through
1234     case T_ARRAY:   // fall through
1235       if (UseCompressedOops &amp;&amp; !wide) {
1236         __ movl(dest-&gt;as_register(), from_addr);
1237       } else {
1238         __ movptr(dest-&gt;as_register(), from_addr);
1239       }
1240       break;
1241 
1242     case T_ADDRESS:
1243       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1244         __ movl(dest-&gt;as_register(), from_addr);
1245       } else {
1246         __ movptr(dest-&gt;as_register(), from_addr);
1247       }
1248       break;
1249     case T_INT:
1250       __ movl(dest-&gt;as_register(), from_addr);
1251       break;
1252 
1253     case T_LONG: {
1254       Register to_lo = dest-&gt;as_register_lo();
1255       Register to_hi = dest-&gt;as_register_hi();
1256 #ifdef _LP64
1257       __ movptr(to_lo, as_Address_lo(addr));
1258 #else
1259       Register base = addr-&gt;base()-&gt;as_register();
1260       Register index = noreg;
1261       if (addr-&gt;index()-&gt;is_register()) {
1262         index = addr-&gt;index()-&gt;as_register();
1263       }
1264       if ((base == to_lo &amp;&amp; index == to_hi) ||
1265           (base == to_hi &amp;&amp; index == to_lo)) {
1266         // addresses with 2 registers are only formed as a result of
1267         // array access so this code will never have to deal with
1268         // patches or null checks.
1269         assert(info == NULL &amp;&amp; patch == NULL, &quot;must be&quot;);
1270         __ lea(to_hi, as_Address(addr));
1271         __ movl(to_lo, Address(to_hi, 0));
1272         __ movl(to_hi, Address(to_hi, BytesPerWord));
1273       } else if (base == to_lo || index == to_lo) {
1274         assert(base != to_hi, &quot;can&#39;t be&quot;);
1275         assert(index == noreg || (index != base &amp;&amp; index != to_hi), &quot;can&#39;t handle this&quot;);
1276         __ movl(to_hi, as_Address_hi(addr));
1277         if (patch != NULL) {
1278           patching_epilog(patch, lir_patch_high, base, info);
1279           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1280           patch_code = lir_patch_low;
1281         }
1282         __ movl(to_lo, as_Address_lo(addr));
1283       } else {
1284         assert(index == noreg || (index != base &amp;&amp; index != to_lo), &quot;can&#39;t handle this&quot;);
1285         __ movl(to_lo, as_Address_lo(addr));
1286         if (patch != NULL) {
1287           patching_epilog(patch, lir_patch_low, base, info);
1288           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1289           patch_code = lir_patch_high;
1290         }
1291         __ movl(to_hi, as_Address_hi(addr));
1292       }
1293 #endif // _LP64
1294       break;
1295     }
1296 
1297     case T_BOOLEAN: // fall through
1298     case T_BYTE: {
1299       Register dest_reg = dest-&gt;as_register();
1300       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1301       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1302         __ movsbl(dest_reg, from_addr);
1303       } else {
1304         __ movb(dest_reg, from_addr);
1305         __ shll(dest_reg, 24);
1306         __ sarl(dest_reg, 24);
1307       }
1308       break;
1309     }
1310 
1311     case T_CHAR: {
1312       Register dest_reg = dest-&gt;as_register();
1313       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1314       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1315         __ movzwl(dest_reg, from_addr);
1316       } else {
1317         __ movw(dest_reg, from_addr);
1318       }
1319       break;
1320     }
1321 
1322     case T_SHORT: {
1323       Register dest_reg = dest-&gt;as_register();
1324       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1325         __ movswl(dest_reg, from_addr);
1326       } else {
1327         __ movw(dest_reg, from_addr);
1328         __ shll(dest_reg, 16);
1329         __ sarl(dest_reg, 16);
1330       }
1331       break;
1332     }
1333 
1334     default:
1335       ShouldNotReachHere();
1336   }
1337 
1338   if (patch != NULL) {
1339     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
1340   }
1341 
1342   if (type == T_ARRAY || type == T_OBJECT) {
1343 #ifdef _LP64
1344     if (UseCompressedOops &amp;&amp; !wide) {
1345       __ decode_heap_oop(dest-&gt;as_register());
1346     }
1347 #endif
1348 
1349     // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1350     if (!UseZGC) {
1351       __ verify_oop(dest-&gt;as_register());
1352     }
1353   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1354 #ifdef _LP64
1355     if (UseCompressedClassPointers) {
1356       __ decode_klass_not_null(dest-&gt;as_register());
1357     }
1358 #endif
1359   }
1360 }
1361 
1362 
1363 NEEDS_CLEANUP; // This could be static?
1364 Address::ScaleFactor LIR_Assembler::array_element_size(BasicType type) const {
1365   int elem_size = type2aelembytes(type);
1366   switch (elem_size) {
1367     case 1: return Address::times_1;
1368     case 2: return Address::times_2;
1369     case 4: return Address::times_4;
1370     case 8: return Address::times_8;
1371   }
1372   ShouldNotReachHere();
1373   return Address::no_scale;
1374 }
1375 
1376 
1377 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1378   switch (op-&gt;code()) {
1379     case lir_idiv:
1380     case lir_irem:
1381       arithmetic_idiv(op-&gt;code(),
1382                       op-&gt;in_opr1(),
1383                       op-&gt;in_opr2(),
1384                       op-&gt;in_opr3(),
1385                       op-&gt;result_opr(),
1386                       op-&gt;info());
1387       break;
1388     case lir_fmad:
1389       __ fmad(op-&gt;result_opr()-&gt;as_xmm_double_reg(),
1390               op-&gt;in_opr1()-&gt;as_xmm_double_reg(),
1391               op-&gt;in_opr2()-&gt;as_xmm_double_reg(),
1392               op-&gt;in_opr3()-&gt;as_xmm_double_reg());
1393       break;
1394     case lir_fmaf:
1395       __ fmaf(op-&gt;result_opr()-&gt;as_xmm_float_reg(),
1396               op-&gt;in_opr1()-&gt;as_xmm_float_reg(),
1397               op-&gt;in_opr2()-&gt;as_xmm_float_reg(),
1398               op-&gt;in_opr3()-&gt;as_xmm_float_reg());
1399       break;
1400     default:      ShouldNotReachHere(); break;
1401   }
1402 }
1403 
1404 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1405 #ifdef ASSERT
1406   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1407   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1408   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1409 #endif
1410 
1411   if (op-&gt;cond() == lir_cond_always) {
1412     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1413     __ jmp (*(op-&gt;label()));
1414   } else {
1415     Assembler::Condition acond = Assembler::zero;
1416     if (op-&gt;code() == lir_cond_float_branch) {
1417       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
1418       __ jcc(Assembler::parity, *(op-&gt;ublock()-&gt;label()));
1419       switch(op-&gt;cond()) {
1420         case lir_cond_equal:        acond = Assembler::equal;      break;
1421         case lir_cond_notEqual:     acond = Assembler::notEqual;   break;
1422         case lir_cond_less:         acond = Assembler::below;      break;
1423         case lir_cond_lessEqual:    acond = Assembler::belowEqual; break;
1424         case lir_cond_greaterEqual: acond = Assembler::aboveEqual; break;
1425         case lir_cond_greater:      acond = Assembler::above;      break;
1426         default:                         ShouldNotReachHere();
1427       }
1428     } else {
1429       switch (op-&gt;cond()) {
1430         case lir_cond_equal:        acond = Assembler::equal;       break;
1431         case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
1432         case lir_cond_less:         acond = Assembler::less;        break;
1433         case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
1434         case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
1435         case lir_cond_greater:      acond = Assembler::greater;     break;
1436         case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
1437         case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
1438         default:                         ShouldNotReachHere();
1439       }
1440     }
1441     __ jcc(acond,*(op-&gt;label()));
1442   }
1443 }
1444 
1445 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1446   LIR_Opr src  = op-&gt;in_opr();
1447   LIR_Opr dest = op-&gt;result_opr();
1448 
1449   switch (op-&gt;bytecode()) {
1450     case Bytecodes::_i2l:
1451 #ifdef _LP64
1452       __ movl2ptr(dest-&gt;as_register_lo(), src-&gt;as_register());
1453 #else
1454       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
1455       move_regs(src-&gt;as_register(), dest-&gt;as_register_hi());
1456       __ sarl(dest-&gt;as_register_hi(), 31);
1457 #endif // LP64
1458       break;
1459 
1460     case Bytecodes::_l2i:
1461 #ifdef _LP64
1462       __ movl(dest-&gt;as_register(), src-&gt;as_register_lo());
1463 #else
1464       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
1465 #endif
1466       break;
1467 
1468     case Bytecodes::_i2b:
1469       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1470       __ sign_extend_byte(dest-&gt;as_register());
1471       break;
1472 
1473     case Bytecodes::_i2c:
1474       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1475       __ andl(dest-&gt;as_register(), 0xFFFF);
1476       break;
1477 
1478     case Bytecodes::_i2s:
1479       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1480       __ sign_extend_short(dest-&gt;as_register());
1481       break;
1482 
1483 
1484     case Bytecodes::_f2d:
1485     case Bytecodes::_d2f:
1486       if (dest-&gt;is_single_xmm()) {
1487         __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1488       } else if (dest-&gt;is_double_xmm()) {
1489         __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1490       } else {
1491         assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;register must be equal&quot;);
1492         // do nothing (float result is rounded later through spilling)
1493       }
1494       break;
1495 
1496     case Bytecodes::_i2f:
1497     case Bytecodes::_i2d:
1498       if (dest-&gt;is_single_xmm()) {
1499         __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1500       } else if (dest-&gt;is_double_xmm()) {
1501         __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1502       } else {
1503         assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1504         __ movl(Address(rsp, 0), src-&gt;as_register());
1505         __ fild_s(Address(rsp, 0));
1506       }
1507       break;
1508 
1509     case Bytecodes::_f2i:
1510     case Bytecodes::_d2i:
1511       if (src-&gt;is_single_xmm()) {
1512         __ cvttss2sil(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1513       } else if (src-&gt;is_double_xmm()) {
1514         __ cvttsd2sil(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1515       } else {
1516         assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1517         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
1518         __ fist_s(Address(rsp, 0));
1519         __ movl(dest-&gt;as_register(), Address(rsp, 0));
1520         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
1521       }
1522 
1523       // IA32 conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
1524       assert(op-&gt;stub() != NULL, &quot;stub required&quot;);
1525       __ cmpl(dest-&gt;as_register(), 0x80000000);
1526       __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry());
1527       __ bind(*op-&gt;stub()-&gt;continuation());
1528       break;
1529 
1530     case Bytecodes::_l2f:
1531     case Bytecodes::_l2d:
1532       assert(!dest-&gt;is_xmm_register(), &quot;result in xmm register not supported (no SSE instruction present)&quot;);
1533       assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1534 
1535       __ movptr(Address(rsp, 0),            src-&gt;as_register_lo());
1536       NOT_LP64(__ movl(Address(rsp, BytesPerWord), src-&gt;as_register_hi()));
1537       __ fild_d(Address(rsp, 0));
1538       // float result is rounded later through spilling
1539       break;
1540 
1541     case Bytecodes::_f2l:
1542     case Bytecodes::_d2l:
1543       assert(!src-&gt;is_xmm_register(), &quot;input in xmm register not supported (no SSE instruction present)&quot;);
1544       assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1545       assert(dest == FrameMap::long0_opr, &quot;runtime stub places result in these registers&quot;);
1546 
1547       // instruction sequence too long to inline it here
1548       {
1549         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::fpu2long_stub_id)));
1550       }
1551       break;
1552 
1553     default: ShouldNotReachHere();
1554   }
1555 }
1556 
1557 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1558   if (op-&gt;init_check()) {
1559     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1560     __ cmpb(Address(op-&gt;klass()-&gt;as_register(),
1561                     InstanceKlass::init_state_offset()),
1562                     InstanceKlass::fully_initialized);
1563     __ jcc(Assembler::notEqual, *op-&gt;stub()-&gt;entry());
1564   }
1565   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1566                      op-&gt;tmp1()-&gt;as_register(),
1567                      op-&gt;tmp2()-&gt;as_register(),
1568                      op-&gt;header_size(),
1569                      op-&gt;object_size(),
1570                      op-&gt;klass()-&gt;as_register(),
1571                      *op-&gt;stub()-&gt;entry());
1572   __ bind(*op-&gt;stub()-&gt;continuation());
1573 }
1574 
1575 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1576   Register len =  op-&gt;len()-&gt;as_register();
1577   LP64_ONLY( __ movslq(len, len); )
1578 
1579   if (UseSlowPath ||
1580       (!UseFastNewObjectArray &amp;&amp; (op-&gt;type() == T_OBJECT || op-&gt;type() == T_ARRAY)) ||
1581       (!UseFastNewTypeArray   &amp;&amp; (op-&gt;type() != T_OBJECT &amp;&amp; op-&gt;type() != T_ARRAY))) {
1582     __ jmp(*op-&gt;stub()-&gt;entry());
1583   } else {
1584     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1585     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1586     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1587     if (len == tmp1) {
1588       tmp1 = tmp3;
1589     } else if (len == tmp2) {
1590       tmp2 = tmp3;
1591     } else if (len == tmp3) {
1592       // everything is ok
1593     } else {
1594       __ mov(tmp3, len);
1595     }
1596     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1597                       len,
1598                       tmp1,
1599                       tmp2,
1600                       arrayOopDesc::header_size(op-&gt;type()),
1601                       array_element_size(op-&gt;type()),
1602                       op-&gt;klass()-&gt;as_register(),
1603                       *op-&gt;stub()-&gt;entry());
1604   }
1605   __ bind(*op-&gt;stub()-&gt;continuation());
1606 }
1607 
1608 void LIR_Assembler::type_profile_helper(Register mdo,
1609                                         ciMethodData *md, ciProfileData *data,
1610                                         Register recv, Label* update_done) {
1611   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1612     Label next_test;
1613     // See if the receiver is receiver[n].
1614     __ cmpptr(recv, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1615     __ jccb(Assembler::notEqual, next_test);
1616     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1617     __ addptr(data_addr, DataLayout::counter_increment);
1618     __ jmp(*update_done);
1619     __ bind(next_test);
1620   }
1621 
1622   // Didn&#39;t find receiver; find next empty slot and fill it in
1623   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1624     Label next_test;
1625     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
1626     __ cmpptr(recv_addr, (intptr_t)NULL_WORD);
1627     __ jccb(Assembler::notEqual, next_test);
1628     __ movptr(recv_addr, recv);
1629     __ movptr(Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))), DataLayout::counter_increment);
1630     __ jmp(*update_done);
1631     __ bind(next_test);
1632   }
1633 }
1634 
1635 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1636   // we always need a stub for the failure case.
1637   CodeStub* stub = op-&gt;stub();
1638   Register obj = op-&gt;object()-&gt;as_register();
1639   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1640   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1641   Register dst = op-&gt;result_opr()-&gt;as_register();
1642   ciKlass* k = op-&gt;klass();
1643   Register Rtmp1 = noreg;
1644 
1645   // check if it needs to be profiled
1646   ciMethodData* md = NULL;
1647   ciProfileData* data = NULL;
1648 
1649   if (op-&gt;should_profile()) {
1650     ciMethod* method = op-&gt;profiled_method();
1651     assert(method != NULL, &quot;Should have method&quot;);
1652     int bci = op-&gt;profiled_bci();
1653     md = method-&gt;method_data_or_null();
1654     assert(md != NULL, &quot;Sanity&quot;);
1655     data = md-&gt;bci_to_data(bci);
1656     assert(data != NULL,                &quot;need data for type check&quot;);
1657     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1658   }
1659   Label profile_cast_success, profile_cast_failure;
1660   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
1661   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
1662 
1663   if (obj == k_RInfo) {
1664     k_RInfo = dst;
1665   } else if (obj == klass_RInfo) {
1666     klass_RInfo = dst;
1667   }
1668   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1669     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1670   } else {
1671     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1672     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1673   }
1674 
1675   assert_different_registers(obj, k_RInfo, klass_RInfo);
1676 
1677   __ cmpptr(obj, (int32_t)NULL_WORD);
1678   if (op-&gt;should_profile()) {
1679     Label not_null;
1680     __ jccb(Assembler::notEqual, not_null);
1681     // Object is null; update MDO and exit
1682     Register mdo  = klass_RInfo;
1683     __ mov_metadata(mdo, md-&gt;constant_encoding());
1684     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1685     int header_bits = BitData::null_seen_byte_constant();
1686     __ orb(data_addr, header_bits);
1687     __ jmp(*obj_is_null);
1688     __ bind(not_null);
1689   } else {
1690     __ jcc(Assembler::equal, *obj_is_null);
1691   }
1692 
1693   if (!k-&gt;is_loaded()) {
1694     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1695   } else {
1696 #ifdef _LP64
1697     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1698 #endif // _LP64
1699   }
1700   __ verify_oop(obj);
1701 
1702   if (op-&gt;fast_check()) {
1703     // get object class
1704     // not a safepoint as obj null check happens earlier
1705 #ifdef _LP64
1706     if (UseCompressedClassPointers) {
1707       __ load_klass(Rtmp1, obj);
1708       __ cmpptr(k_RInfo, Rtmp1);
1709     } else {
1710       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1711     }
1712 #else
1713     if (k-&gt;is_loaded()) {
1714       __ cmpklass(Address(obj, oopDesc::klass_offset_in_bytes()), k-&gt;constant_encoding());
1715     } else {
1716       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1717     }
1718 #endif
1719     __ jcc(Assembler::notEqual, *failure_target);
1720     // successful cast, fall through to profile or jump
1721   } else {
1722     // get object class
1723     // not a safepoint as obj null check happens earlier
1724     __ load_klass(klass_RInfo, obj);
1725     if (k-&gt;is_loaded()) {
1726       // See if we get an immediate positive hit
1727 #ifdef _LP64
1728       __ cmpptr(k_RInfo, Address(klass_RInfo, k-&gt;super_check_offset()));
1729 #else
1730       __ cmpklass(Address(klass_RInfo, k-&gt;super_check_offset()), k-&gt;constant_encoding());
1731 #endif // _LP64
1732       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1733         __ jcc(Assembler::notEqual, *failure_target);
1734         // successful cast, fall through to profile or jump
1735       } else {
1736         // See if we get an immediate positive hit
1737         __ jcc(Assembler::equal, *success_target);
1738         // check for self
1739 #ifdef _LP64
1740         __ cmpptr(klass_RInfo, k_RInfo);
1741 #else
1742         __ cmpklass(klass_RInfo, k-&gt;constant_encoding());
1743 #endif // _LP64
1744         __ jcc(Assembler::equal, *success_target);
1745 
1746         __ push(klass_RInfo);
1747 #ifdef _LP64
1748         __ push(k_RInfo);
1749 #else
1750         __ pushklass(k-&gt;constant_encoding());
1751 #endif // _LP64
1752         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1753         __ pop(klass_RInfo);
1754         __ pop(klass_RInfo);
1755         // result is a boolean
1756         __ cmpl(klass_RInfo, 0);
1757         __ jcc(Assembler::equal, *failure_target);
1758         // successful cast, fall through to profile or jump
1759       }
1760     } else {
1761       // perform the fast part of the checking logic
1762       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1763       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1764       __ push(klass_RInfo);
1765       __ push(k_RInfo);
1766       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1767       __ pop(klass_RInfo);
1768       __ pop(k_RInfo);
1769       // result is a boolean
1770       __ cmpl(k_RInfo, 0);
1771       __ jcc(Assembler::equal, *failure_target);
1772       // successful cast, fall through to profile or jump
1773     }
1774   }
1775   if (op-&gt;should_profile()) {
1776     Register mdo  = klass_RInfo, recv = k_RInfo;
1777     __ bind(profile_cast_success);
1778     __ mov_metadata(mdo, md-&gt;constant_encoding());
1779     __ load_klass(recv, obj);
1780     type_profile_helper(mdo, md, data, recv, success);
1781     __ jmp(*success);
1782 
1783     __ bind(profile_cast_failure);
1784     __ mov_metadata(mdo, md-&gt;constant_encoding());
1785     Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1786     __ subptr(counter_addr, DataLayout::counter_increment);
1787     __ jmp(*failure);
1788   }
1789   __ jmp(*success);
1790 }
1791 
1792 
1793 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1794   LIR_Code code = op-&gt;code();
1795   if (code == lir_store_check) {
1796     Register value = op-&gt;object()-&gt;as_register();
1797     Register array = op-&gt;array()-&gt;as_register();
1798     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1799     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1800     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1801 
1802     CodeStub* stub = op-&gt;stub();
1803 
1804     // check if it needs to be profiled
1805     ciMethodData* md = NULL;
1806     ciProfileData* data = NULL;
1807 
1808     if (op-&gt;should_profile()) {
1809       ciMethod* method = op-&gt;profiled_method();
1810       assert(method != NULL, &quot;Should have method&quot;);
1811       int bci = op-&gt;profiled_bci();
1812       md = method-&gt;method_data_or_null();
1813       assert(md != NULL, &quot;Sanity&quot;);
1814       data = md-&gt;bci_to_data(bci);
1815       assert(data != NULL,                &quot;need data for type check&quot;);
1816       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1817     }
1818     Label profile_cast_success, profile_cast_failure, done;
1819     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
1820     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
1821 
1822     __ cmpptr(value, (int32_t)NULL_WORD);
1823     if (op-&gt;should_profile()) {
1824       Label not_null;
1825       __ jccb(Assembler::notEqual, not_null);
1826       // Object is null; update MDO and exit
1827       Register mdo  = klass_RInfo;
1828       __ mov_metadata(mdo, md-&gt;constant_encoding());
1829       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1830       int header_bits = BitData::null_seen_byte_constant();
1831       __ orb(data_addr, header_bits);
1832       __ jmp(done);
1833       __ bind(not_null);
1834     } else {
1835       __ jcc(Assembler::equal, done);
1836     }
1837 
1838     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1839     __ load_klass(k_RInfo, array);
1840     __ load_klass(klass_RInfo, value);
1841 
1842     // get instance klass (it&#39;s already uncompressed)
1843     __ movptr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1844     // perform the fast part of the checking logic
1845     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1846     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1847     __ push(klass_RInfo);
1848     __ push(k_RInfo);
1849     __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1850     __ pop(klass_RInfo);
1851     __ pop(k_RInfo);
1852     // result is a boolean
1853     __ cmpl(k_RInfo, 0);
1854     __ jcc(Assembler::equal, *failure_target);
1855     // fall through to the success case
1856 
1857     if (op-&gt;should_profile()) {
1858       Register mdo  = klass_RInfo, recv = k_RInfo;
1859       __ bind(profile_cast_success);
1860       __ mov_metadata(mdo, md-&gt;constant_encoding());
1861       __ load_klass(recv, value);
1862       type_profile_helper(mdo, md, data, recv, &amp;done);
1863       __ jmpb(done);
1864 
1865       __ bind(profile_cast_failure);
1866       __ mov_metadata(mdo, md-&gt;constant_encoding());
1867       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1868       __ subptr(counter_addr, DataLayout::counter_increment);
1869       __ jmp(*stub-&gt;entry());
1870     }
1871 
1872     __ bind(done);
1873   } else
1874     if (code == lir_checkcast) {
1875       Register obj = op-&gt;object()-&gt;as_register();
1876       Register dst = op-&gt;result_opr()-&gt;as_register();
1877       Label success;
1878       emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1879       __ bind(success);
1880       if (dst != obj) {
1881         __ mov(dst, obj);
1882       }
1883     } else
1884       if (code == lir_instanceof) {
1885         Register obj = op-&gt;object()-&gt;as_register();
1886         Register dst = op-&gt;result_opr()-&gt;as_register();
1887         Label success, failure, done;
1888         emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1889         __ bind(failure);
1890         __ xorptr(dst, dst);
1891         __ jmpb(done);
1892         __ bind(success);
1893         __ movptr(dst, 1);
1894         __ bind(done);
1895       } else {
1896         ShouldNotReachHere();
1897       }
1898 
1899 }
1900 
1901 
1902 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
1903   if (LP64_ONLY(false &amp;&amp;) op-&gt;code() == lir_cas_long &amp;&amp; VM_Version::supports_cx8()) {
1904     assert(op-&gt;cmp_value()-&gt;as_register_lo() == rax, &quot;wrong register&quot;);
1905     assert(op-&gt;cmp_value()-&gt;as_register_hi() == rdx, &quot;wrong register&quot;);
1906     assert(op-&gt;new_value()-&gt;as_register_lo() == rbx, &quot;wrong register&quot;);
1907     assert(op-&gt;new_value()-&gt;as_register_hi() == rcx, &quot;wrong register&quot;);
1908     Register addr = op-&gt;addr()-&gt;as_register();
1909     __ lock();
1910     NOT_LP64(__ cmpxchg8(Address(addr, 0)));
1911 
1912   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj ) {
1913     NOT_LP64(assert(op-&gt;addr()-&gt;is_single_cpu(), &quot;must be single&quot;);)
1914     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
1915     Register newval = op-&gt;new_value()-&gt;as_register();
1916     Register cmpval = op-&gt;cmp_value()-&gt;as_register();
1917     assert(cmpval == rax, &quot;wrong register&quot;);
1918     assert(newval != NULL, &quot;new val must be register&quot;);
1919     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
1920     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
1921     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
1922 
1923     if ( op-&gt;code() == lir_cas_obj) {
1924 #ifdef _LP64
1925       if (UseCompressedOops) {
1926         __ encode_heap_oop(cmpval);
1927         __ mov(rscratch1, newval);
1928         __ encode_heap_oop(rscratch1);
1929         __ lock();
1930         // cmpval (rax) is implicitly used by this instruction
1931         __ cmpxchgl(rscratch1, Address(addr, 0));
1932       } else
1933 #endif
1934       {
1935         __ lock();
1936         __ cmpxchgptr(newval, Address(addr, 0));
1937       }
1938     } else {
1939       assert(op-&gt;code() == lir_cas_int, &quot;lir_cas_int expected&quot;);
1940       __ lock();
1941       __ cmpxchgl(newval, Address(addr, 0));
1942     }
1943 #ifdef _LP64
1944   } else if (op-&gt;code() == lir_cas_long) {
1945     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
1946     Register newval = op-&gt;new_value()-&gt;as_register_lo();
1947     Register cmpval = op-&gt;cmp_value()-&gt;as_register_lo();
1948     assert(cmpval == rax, &quot;wrong register&quot;);
1949     assert(newval != NULL, &quot;new val must be register&quot;);
1950     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
1951     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
1952     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
1953     __ lock();
1954     __ cmpxchgq(newval, Address(addr, 0));
1955 #endif // _LP64
1956   } else {
1957     Unimplemented();
1958   }
1959 }
1960 
1961 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1962   Assembler::Condition acond, ncond;
1963   switch (condition) {
1964     case lir_cond_equal:        acond = Assembler::equal;        ncond = Assembler::notEqual;     break;
1965     case lir_cond_notEqual:     acond = Assembler::notEqual;     ncond = Assembler::equal;        break;
1966     case lir_cond_less:         acond = Assembler::less;         ncond = Assembler::greaterEqual; break;
1967     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    ncond = Assembler::greater;      break;
1968     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; ncond = Assembler::less;         break;
1969     case lir_cond_greater:      acond = Assembler::greater;      ncond = Assembler::lessEqual;    break;
1970     case lir_cond_belowEqual:   acond = Assembler::belowEqual;   ncond = Assembler::above;        break;
1971     case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;   ncond = Assembler::below;        break;
1972     default:                    acond = Assembler::equal;        ncond = Assembler::notEqual;
1973                                 ShouldNotReachHere();
1974   }
1975 
1976   if (opr1-&gt;is_cpu_register()) {
1977     reg2reg(opr1, result);
1978   } else if (opr1-&gt;is_stack()) {
1979     stack2reg(opr1, result, result-&gt;type());
1980   } else if (opr1-&gt;is_constant()) {
1981     const2reg(opr1, result, lir_patch_none, NULL);
1982   } else {
1983     ShouldNotReachHere();
1984   }
1985 
1986   if (VM_Version::supports_cmov() &amp;&amp; !opr2-&gt;is_constant()) {
1987     // optimized version that does not require a branch
1988     if (opr2-&gt;is_single_cpu()) {
1989       assert(opr2-&gt;cpu_regnr() != result-&gt;cpu_regnr(), &quot;opr2 already overwritten by previous move&quot;);
1990       __ cmov(ncond, result-&gt;as_register(), opr2-&gt;as_register());
1991     } else if (opr2-&gt;is_double_cpu()) {
1992       assert(opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
1993       assert(opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
1994       __ cmovptr(ncond, result-&gt;as_register_lo(), opr2-&gt;as_register_lo());
1995       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), opr2-&gt;as_register_hi());)
1996     } else if (opr2-&gt;is_single_stack()) {
1997       __ cmovl(ncond, result-&gt;as_register(), frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1998     } else if (opr2-&gt;is_double_stack()) {
1999       __ cmovptr(ncond, result-&gt;as_register_lo(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), lo_word_offset_in_bytes));
2000       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), hi_word_offset_in_bytes));)
2001     } else {
2002       ShouldNotReachHere();
2003     }
2004 
2005   } else {
2006     Label skip;
2007     __ jcc (acond, skip);
2008     if (opr2-&gt;is_cpu_register()) {
2009       reg2reg(opr2, result);
2010     } else if (opr2-&gt;is_stack()) {
2011       stack2reg(opr2, result, result-&gt;type());
2012     } else if (opr2-&gt;is_constant()) {
2013       const2reg(opr2, result, lir_patch_none, NULL);
2014     } else {
2015       ShouldNotReachHere();
2016     }
2017     __ bind(skip);
2018   }
2019 }
2020 
2021 
2022 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
2023   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
2024 
2025   if (left-&gt;is_single_cpu()) {
2026     assert(left == dest, &quot;left and dest must be equal&quot;);
2027     Register lreg = left-&gt;as_register();
2028 
2029     if (right-&gt;is_single_cpu()) {
2030       // cpu register - cpu register
2031       Register rreg = right-&gt;as_register();
2032       switch (code) {
2033         case lir_add: __ addl (lreg, rreg); break;
2034         case lir_sub: __ subl (lreg, rreg); break;
2035         case lir_mul: __ imull(lreg, rreg); break;
2036         default:      ShouldNotReachHere();
2037       }
2038 
2039     } else if (right-&gt;is_stack()) {
2040       // cpu register - stack
2041       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2042       switch (code) {
2043         case lir_add: __ addl(lreg, raddr); break;
2044         case lir_sub: __ subl(lreg, raddr); break;
2045         default:      ShouldNotReachHere();
2046       }
2047 
2048     } else if (right-&gt;is_constant()) {
2049       // cpu register - constant
2050       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2051       switch (code) {
2052         case lir_add: {
2053           __ incrementl(lreg, c);
2054           break;
2055         }
2056         case lir_sub: {
2057           __ decrementl(lreg, c);
2058           break;
2059         }
2060         default: ShouldNotReachHere();
2061       }
2062 
2063     } else {
2064       ShouldNotReachHere();
2065     }
2066 
2067   } else if (left-&gt;is_double_cpu()) {
2068     assert(left == dest, &quot;left and dest must be equal&quot;);
2069     Register lreg_lo = left-&gt;as_register_lo();
2070     Register lreg_hi = left-&gt;as_register_hi();
2071 
2072     if (right-&gt;is_double_cpu()) {
2073       // cpu register - cpu register
2074       Register rreg_lo = right-&gt;as_register_lo();
2075       Register rreg_hi = right-&gt;as_register_hi();
2076       NOT_LP64(assert_different_registers(lreg_lo, lreg_hi, rreg_lo, rreg_hi));
2077       LP64_ONLY(assert_different_registers(lreg_lo, rreg_lo));
2078       switch (code) {
2079         case lir_add:
2080           __ addptr(lreg_lo, rreg_lo);
2081           NOT_LP64(__ adcl(lreg_hi, rreg_hi));
2082           break;
2083         case lir_sub:
2084           __ subptr(lreg_lo, rreg_lo);
2085           NOT_LP64(__ sbbl(lreg_hi, rreg_hi));
2086           break;
2087         case lir_mul:
2088 #ifdef _LP64
2089           __ imulq(lreg_lo, rreg_lo);
2090 #else
2091           assert(lreg_lo == rax &amp;&amp; lreg_hi == rdx, &quot;must be&quot;);
2092           __ imull(lreg_hi, rreg_lo);
2093           __ imull(rreg_hi, lreg_lo);
2094           __ addl (rreg_hi, lreg_hi);
2095           __ mull (rreg_lo);
2096           __ addl (lreg_hi, rreg_hi);
2097 #endif // _LP64
2098           break;
2099         default:
2100           ShouldNotReachHere();
2101       }
2102 
2103     } else if (right-&gt;is_constant()) {
2104       // cpu register - constant
2105 #ifdef _LP64
2106       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong_bits();
2107       __ movptr(r10, (intptr_t) c);
2108       switch (code) {
2109         case lir_add:
2110           __ addptr(lreg_lo, r10);
2111           break;
2112         case lir_sub:
2113           __ subptr(lreg_lo, r10);
2114           break;
2115         default:
2116           ShouldNotReachHere();
2117       }
2118 #else
2119       jint c_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2120       jint c_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2121       switch (code) {
2122         case lir_add:
2123           __ addptr(lreg_lo, c_lo);
2124           __ adcl(lreg_hi, c_hi);
2125           break;
2126         case lir_sub:
2127           __ subptr(lreg_lo, c_lo);
2128           __ sbbl(lreg_hi, c_hi);
2129           break;
2130         default:
2131           ShouldNotReachHere();
2132       }
2133 #endif // _LP64
2134 
2135     } else {
2136       ShouldNotReachHere();
2137     }
2138 
2139   } else if (left-&gt;is_single_xmm()) {
2140     assert(left == dest, &quot;left and dest must be equal&quot;);
2141     XMMRegister lreg = left-&gt;as_xmm_float_reg();
2142 
2143     if (right-&gt;is_single_xmm()) {
2144       XMMRegister rreg = right-&gt;as_xmm_float_reg();
2145       switch (code) {
2146         case lir_add: __ addss(lreg, rreg);  break;
2147         case lir_sub: __ subss(lreg, rreg);  break;
2148         case lir_mul_strictfp: // fall through
2149         case lir_mul: __ mulss(lreg, rreg);  break;
2150         case lir_div_strictfp: // fall through
2151         case lir_div: __ divss(lreg, rreg);  break;
2152         default: ShouldNotReachHere();
2153       }
2154     } else {
2155       Address raddr;
2156       if (right-&gt;is_single_stack()) {
2157         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2158       } else if (right-&gt;is_constant()) {
2159         // hack for now
2160         raddr = __ as_Address(InternalAddress(float_constant(right-&gt;as_jfloat())));
2161       } else {
2162         ShouldNotReachHere();
2163       }
2164       switch (code) {
2165         case lir_add: __ addss(lreg, raddr);  break;
2166         case lir_sub: __ subss(lreg, raddr);  break;
2167         case lir_mul_strictfp: // fall through
2168         case lir_mul: __ mulss(lreg, raddr);  break;
2169         case lir_div_strictfp: // fall through
2170         case lir_div: __ divss(lreg, raddr);  break;
2171         default: ShouldNotReachHere();
2172       }
2173     }
2174 
2175   } else if (left-&gt;is_double_xmm()) {
2176     assert(left == dest, &quot;left and dest must be equal&quot;);
2177 
2178     XMMRegister lreg = left-&gt;as_xmm_double_reg();
2179     if (right-&gt;is_double_xmm()) {
2180       XMMRegister rreg = right-&gt;as_xmm_double_reg();
2181       switch (code) {
2182         case lir_add: __ addsd(lreg, rreg);  break;
2183         case lir_sub: __ subsd(lreg, rreg);  break;
2184         case lir_mul_strictfp: // fall through
2185         case lir_mul: __ mulsd(lreg, rreg);  break;
2186         case lir_div_strictfp: // fall through
2187         case lir_div: __ divsd(lreg, rreg);  break;
2188         default: ShouldNotReachHere();
2189       }
2190     } else {
2191       Address raddr;
2192       if (right-&gt;is_double_stack()) {
2193         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2194       } else if (right-&gt;is_constant()) {
2195         // hack for now
2196         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2197       } else {
2198         ShouldNotReachHere();
2199       }
2200       switch (code) {
2201         case lir_add: __ addsd(lreg, raddr);  break;
2202         case lir_sub: __ subsd(lreg, raddr);  break;
2203         case lir_mul_strictfp: // fall through
2204         case lir_mul: __ mulsd(lreg, raddr);  break;
2205         case lir_div_strictfp: // fall through
2206         case lir_div: __ divsd(lreg, raddr);  break;
2207         default: ShouldNotReachHere();
2208       }
2209     }
2210 
2211   } else if (left-&gt;is_single_fpu()) {
2212     assert(dest-&gt;is_single_fpu(),  &quot;fpu stack allocation required&quot;);
2213 
2214     if (right-&gt;is_single_fpu()) {
2215       arith_fpu_implementation(code, left-&gt;fpu_regnr(), right-&gt;fpu_regnr(), dest-&gt;fpu_regnr(), pop_fpu_stack);
2216 
2217     } else {
2218       assert(left-&gt;fpu_regnr() == 0, &quot;left must be on TOS&quot;);
2219       assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be on TOS&quot;);
2220 
2221       Address raddr;
2222       if (right-&gt;is_single_stack()) {
2223         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2224       } else if (right-&gt;is_constant()) {
2225         address const_addr = float_constant(right-&gt;as_jfloat());
2226         assert(const_addr != NULL, &quot;incorrect float/double constant maintainance&quot;);
2227         // hack for now
2228         raddr = __ as_Address(InternalAddress(const_addr));
2229       } else {
2230         ShouldNotReachHere();
2231       }
2232 
2233       switch (code) {
2234         case lir_add: __ fadd_s(raddr); break;
2235         case lir_sub: __ fsub_s(raddr); break;
2236         case lir_mul_strictfp: // fall through
2237         case lir_mul: __ fmul_s(raddr); break;
2238         case lir_div_strictfp: // fall through
2239         case lir_div: __ fdiv_s(raddr); break;
2240         default:      ShouldNotReachHere();
2241       }
2242     }
2243 
2244   } else if (left-&gt;is_double_fpu()) {
2245     assert(dest-&gt;is_double_fpu(),  &quot;fpu stack allocation required&quot;);
2246 
2247     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2248       // Double values require special handling for strictfp mul/div on x86
2249       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
2250       __ fmulp(left-&gt;fpu_regnrLo() + 1);
2251     }
2252 
2253     if (right-&gt;is_double_fpu()) {
2254       arith_fpu_implementation(code, left-&gt;fpu_regnrLo(), right-&gt;fpu_regnrLo(), dest-&gt;fpu_regnrLo(), pop_fpu_stack);
2255 
2256     } else {
2257       assert(left-&gt;fpu_regnrLo() == 0, &quot;left must be on TOS&quot;);
2258       assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be on TOS&quot;);
2259 
2260       Address raddr;
2261       if (right-&gt;is_double_stack()) {
2262         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2263       } else if (right-&gt;is_constant()) {
2264         // hack for now
2265         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2266       } else {
2267         ShouldNotReachHere();
2268       }
2269 
2270       switch (code) {
2271         case lir_add: __ fadd_d(raddr); break;
2272         case lir_sub: __ fsub_d(raddr); break;
2273         case lir_mul_strictfp: // fall through
2274         case lir_mul: __ fmul_d(raddr); break;
2275         case lir_div_strictfp: // fall through
2276         case lir_div: __ fdiv_d(raddr); break;
2277         default: ShouldNotReachHere();
2278       }
2279     }
2280 
2281     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2282       // Double values require special handling for strictfp mul/div on x86
2283       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
2284       __ fmulp(dest-&gt;fpu_regnrLo() + 1);
2285     }
2286 
2287   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
2288     assert(left == dest, &quot;left and dest must be equal&quot;);
2289 
2290     Address laddr;
2291     if (left-&gt;is_single_stack()) {
2292       laddr = frame_map()-&gt;address_for_slot(left-&gt;single_stack_ix());
2293     } else if (left-&gt;is_address()) {
2294       laddr = as_Address(left-&gt;as_address_ptr());
2295     } else {
2296       ShouldNotReachHere();
2297     }
2298 
2299     if (right-&gt;is_single_cpu()) {
2300       Register rreg = right-&gt;as_register();
2301       switch (code) {
2302         case lir_add: __ addl(laddr, rreg); break;
2303         case lir_sub: __ subl(laddr, rreg); break;
2304         default:      ShouldNotReachHere();
2305       }
2306     } else if (right-&gt;is_constant()) {
2307       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2308       switch (code) {
2309         case lir_add: {
2310           __ incrementl(laddr, c);
2311           break;
2312         }
2313         case lir_sub: {
2314           __ decrementl(laddr, c);
2315           break;
2316         }
2317         default: ShouldNotReachHere();
2318       }
2319     } else {
2320       ShouldNotReachHere();
2321     }
2322 
2323   } else {
2324     ShouldNotReachHere();
2325   }
2326 }
2327 
2328 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) {
2329   assert(pop_fpu_stack  || (left_index     == dest_index || right_index     == dest_index), &quot;invalid LIR&quot;);
2330   assert(!pop_fpu_stack || (left_index - 1 == dest_index || right_index - 1 == dest_index), &quot;invalid LIR&quot;);
2331   assert(left_index == 0 || right_index == 0, &quot;either must be on top of stack&quot;);
2332 
2333   bool left_is_tos = (left_index == 0);
2334   bool dest_is_tos = (dest_index == 0);
2335   int non_tos_index = (left_is_tos ? right_index : left_index);
2336 
2337   switch (code) {
2338     case lir_add:
2339       if (pop_fpu_stack)       __ faddp(non_tos_index);
2340       else if (dest_is_tos)    __ fadd (non_tos_index);
2341       else                     __ fadda(non_tos_index);
2342       break;
2343 
2344     case lir_sub:
2345       if (left_is_tos) {
2346         if (pop_fpu_stack)     __ fsubrp(non_tos_index);
2347         else if (dest_is_tos)  __ fsub  (non_tos_index);
2348         else                   __ fsubra(non_tos_index);
2349       } else {
2350         if (pop_fpu_stack)     __ fsubp (non_tos_index);
2351         else if (dest_is_tos)  __ fsubr (non_tos_index);
2352         else                   __ fsuba (non_tos_index);
2353       }
2354       break;
2355 
2356     case lir_mul_strictfp: // fall through
2357     case lir_mul:
2358       if (pop_fpu_stack)       __ fmulp(non_tos_index);
2359       else if (dest_is_tos)    __ fmul (non_tos_index);
2360       else                     __ fmula(non_tos_index);
2361       break;
2362 
2363     case lir_div_strictfp: // fall through
2364     case lir_div:
2365       if (left_is_tos) {
2366         if (pop_fpu_stack)     __ fdivrp(non_tos_index);
2367         else if (dest_is_tos)  __ fdiv  (non_tos_index);
2368         else                   __ fdivra(non_tos_index);
2369       } else {
2370         if (pop_fpu_stack)     __ fdivp (non_tos_index);
2371         else if (dest_is_tos)  __ fdivr (non_tos_index);
2372         else                   __ fdiva (non_tos_index);
2373       }
2374       break;
2375 
2376     case lir_rem:
2377       assert(left_is_tos &amp;&amp; dest_is_tos &amp;&amp; right_index == 1, &quot;must be guaranteed by FPU stack allocation&quot;);
2378       __ fremr(noreg);
2379       break;
2380 
2381     default:
2382       ShouldNotReachHere();
2383   }
2384 }
2385 
2386 
2387 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {
2388   if (value-&gt;is_double_xmm()) {
2389     switch(code) {
2390       case lir_abs :
2391         {
2392 #ifdef _LP64
2393           if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
2394             assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
2395             __ vpandn(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg(), 2);
2396           } else
2397 #endif
2398           {
2399             if (dest-&gt;as_xmm_double_reg() != value-&gt;as_xmm_double_reg()) {
2400               __ movdbl(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg());
2401             }
2402             assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
2403             __ andpd(dest-&gt;as_xmm_double_reg(),
2404                      ExternalAddress((address)double_signmask_pool));
2405           }
2406         }
2407         break;
2408 
2409       case lir_sqrt: __ sqrtsd(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg()); break;
2410       // all other intrinsics are not available in the SSE instruction set, so FPU is used
2411       default      : ShouldNotReachHere();
2412     }
2413 
2414   } else if (value-&gt;is_double_fpu()) {
2415     assert(value-&gt;fpu_regnrLo() == 0 &amp;&amp; dest-&gt;fpu_regnrLo() == 0, &quot;both must be on TOS&quot;);
2416     switch(code) {
2417       case lir_abs   : __ fabs() ; break;
2418       case lir_sqrt  : __ fsqrt(); break;
2419       default      : ShouldNotReachHere();
2420     }
2421   } else {
2422     Unimplemented();
2423   }
2424 }
2425 
2426 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
2427   // assert(left-&gt;destroys_register(), &quot;check&quot;);
2428   if (left-&gt;is_single_cpu()) {
2429     Register reg = left-&gt;as_register();
2430     if (right-&gt;is_constant()) {
2431       int val = right-&gt;as_constant_ptr()-&gt;as_jint();
2432       switch (code) {
2433         case lir_logic_and: __ andl (reg, val); break;
2434         case lir_logic_or:  __ orl  (reg, val); break;
2435         case lir_logic_xor: __ xorl (reg, val); break;
2436         default: ShouldNotReachHere();
2437       }
2438     } else if (right-&gt;is_stack()) {
2439       // added support for stack operands
2440       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2441       switch (code) {
2442         case lir_logic_and: __ andl (reg, raddr); break;
2443         case lir_logic_or:  __ orl  (reg, raddr); break;
2444         case lir_logic_xor: __ xorl (reg, raddr); break;
2445         default: ShouldNotReachHere();
2446       }
2447     } else {
2448       Register rright = right-&gt;as_register();
2449       switch (code) {
2450         case lir_logic_and: __ andptr (reg, rright); break;
2451         case lir_logic_or : __ orptr  (reg, rright); break;
2452         case lir_logic_xor: __ xorptr (reg, rright); break;
2453         default: ShouldNotReachHere();
2454       }
2455     }
2456     move_regs(reg, dst-&gt;as_register());
2457   } else {
2458     Register l_lo = left-&gt;as_register_lo();
2459     Register l_hi = left-&gt;as_register_hi();
2460     if (right-&gt;is_constant()) {
2461 #ifdef _LP64
2462       __ mov64(rscratch1, right-&gt;as_constant_ptr()-&gt;as_jlong());
2463       switch (code) {
2464         case lir_logic_and:
2465           __ andq(l_lo, rscratch1);
2466           break;
2467         case lir_logic_or:
2468           __ orq(l_lo, rscratch1);
2469           break;
2470         case lir_logic_xor:
2471           __ xorq(l_lo, rscratch1);
2472           break;
2473         default: ShouldNotReachHere();
2474       }
2475 #else
2476       int r_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2477       int r_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2478       switch (code) {
2479         case lir_logic_and:
2480           __ andl(l_lo, r_lo);
2481           __ andl(l_hi, r_hi);
2482           break;
2483         case lir_logic_or:
2484           __ orl(l_lo, r_lo);
2485           __ orl(l_hi, r_hi);
2486           break;
2487         case lir_logic_xor:
2488           __ xorl(l_lo, r_lo);
2489           __ xorl(l_hi, r_hi);
2490           break;
2491         default: ShouldNotReachHere();
2492       }
2493 #endif // _LP64
2494     } else {
2495 #ifdef _LP64
2496       Register r_lo;
2497       if (right-&gt;type() == T_OBJECT || right-&gt;type() == T_ARRAY) {
2498         r_lo = right-&gt;as_register();
2499       } else {
2500         r_lo = right-&gt;as_register_lo();
2501       }
2502 #else
2503       Register r_lo = right-&gt;as_register_lo();
2504       Register r_hi = right-&gt;as_register_hi();
2505       assert(l_lo != r_hi, &quot;overwriting registers&quot;);
2506 #endif
2507       switch (code) {
2508         case lir_logic_and:
2509           __ andptr(l_lo, r_lo);
2510           NOT_LP64(__ andptr(l_hi, r_hi);)
2511           break;
2512         case lir_logic_or:
2513           __ orptr(l_lo, r_lo);
2514           NOT_LP64(__ orptr(l_hi, r_hi);)
2515           break;
2516         case lir_logic_xor:
2517           __ xorptr(l_lo, r_lo);
2518           NOT_LP64(__ xorptr(l_hi, r_hi);)
2519           break;
2520         default: ShouldNotReachHere();
2521       }
2522     }
2523 
2524     Register dst_lo = dst-&gt;as_register_lo();
2525     Register dst_hi = dst-&gt;as_register_hi();
2526 
2527 #ifdef _LP64
2528     move_regs(l_lo, dst_lo);
2529 #else
2530     if (dst_lo == l_hi) {
2531       assert(dst_hi != l_lo, &quot;overwriting registers&quot;);
2532       move_regs(l_hi, dst_hi);
2533       move_regs(l_lo, dst_lo);
2534     } else {
2535       assert(dst_lo != l_hi, &quot;overwriting registers&quot;);
2536       move_regs(l_lo, dst_lo);
2537       move_regs(l_hi, dst_hi);
2538     }
2539 #endif // _LP64
2540   }
2541 }
2542 
2543 
2544 // we assume that rax, and rdx can be overwritten
2545 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
2546 
2547   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
2548   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
2549   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
2550 
2551   //  assert(left-&gt;destroys_register(), &quot;check&quot;);
2552   //  assert(right-&gt;destroys_register(), &quot;check&quot;);
2553 
2554   Register lreg = left-&gt;as_register();
2555   Register dreg = result-&gt;as_register();
2556 
2557   if (right-&gt;is_constant()) {
2558     jint divisor = right-&gt;as_constant_ptr()-&gt;as_jint();
2559     assert(divisor &gt; 0 &amp;&amp; is_power_of_2(divisor), &quot;must be&quot;);
2560     if (code == lir_idiv) {
2561       assert(lreg == rax, &quot;must be rax,&quot;);
2562       assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2563       __ cdql(); // sign extend into rdx:rax
2564       if (divisor == 2) {
2565         __ subl(lreg, rdx);
2566       } else {
2567         __ andl(rdx, divisor - 1);
2568         __ addl(lreg, rdx);
2569       }
2570       __ sarl(lreg, log2_jint(divisor));
2571       move_regs(lreg, dreg);
2572     } else if (code == lir_irem) {
2573       Label done;
2574       __ mov(dreg, lreg);
2575       __ andl(dreg, 0x80000000 | (divisor - 1));
2576       __ jcc(Assembler::positive, done);
2577       __ decrement(dreg);
2578       __ orl(dreg, ~(divisor - 1));
2579       __ increment(dreg);
2580       __ bind(done);
2581     } else {
2582       ShouldNotReachHere();
2583     }
2584   } else {
2585     Register rreg = right-&gt;as_register();
2586     assert(lreg == rax, &quot;left register must be rax,&quot;);
2587     assert(rreg != rdx, &quot;right register must not be rdx&quot;);
2588     assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2589 
2590     move_regs(lreg, rax);
2591 
2592     int idivl_offset = __ corrected_idivl(rreg);
2593     if (ImplicitDiv0Checks) {
2594       add_debug_info_for_div0(idivl_offset, info);
2595     }
2596     if (code == lir_irem) {
2597       move_regs(rdx, dreg); // result is in rdx
2598     } else {
2599       move_regs(rax, dreg);
2600     }
2601   }
2602 }
2603 
2604 
2605 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
2606   if (opr1-&gt;is_single_cpu()) {
2607     Register reg1 = opr1-&gt;as_register();
2608     if (opr2-&gt;is_single_cpu()) {
2609       // cpu register - cpu register
2610       if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {
2611         __ cmpoop(reg1, opr2-&gt;as_register());
2612       } else {
2613         assert(opr2-&gt;type() != T_OBJECT &amp;&amp; opr2-&gt;type() != T_ARRAY, &quot;cmp int, oop?&quot;);
2614         __ cmpl(reg1, opr2-&gt;as_register());
2615       }
2616     } else if (opr2-&gt;is_stack()) {
2617       // cpu register - stack
2618       if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {
2619         __ cmpoop(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2620       } else {
2621         __ cmpl(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2622       }
2623     } else if (opr2-&gt;is_constant()) {
2624       // cpu register - constant
2625       LIR_Const* c = opr2-&gt;as_constant_ptr();
2626       if (c-&gt;type() == T_INT) {
2627         __ cmpl(reg1, c-&gt;as_jint());
2628       } else if (c-&gt;type() == T_OBJECT || c-&gt;type() == T_ARRAY) {
2629         // In 64bit oops are single register
2630         jobject o = c-&gt;as_jobject();
2631         if (o == NULL) {
2632           __ cmpptr(reg1, (int32_t)NULL_WORD);
2633         } else {
2634           __ cmpoop(reg1, o);
2635         }
2636       } else {
2637         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
2638       }
2639       // cpu register - address
2640     } else if (opr2-&gt;is_address()) {
2641       if (op-&gt;info() != NULL) {
2642         add_debug_info_for_null_check_here(op-&gt;info());
2643       }
2644       __ cmpl(reg1, as_Address(opr2-&gt;as_address_ptr()));
2645     } else {
2646       ShouldNotReachHere();
2647     }
2648 
2649   } else if(opr1-&gt;is_double_cpu()) {
2650     Register xlo = opr1-&gt;as_register_lo();
2651     Register xhi = opr1-&gt;as_register_hi();
2652     if (opr2-&gt;is_double_cpu()) {
2653 #ifdef _LP64
2654       __ cmpptr(xlo, opr2-&gt;as_register_lo());
2655 #else
2656       // cpu register - cpu register
2657       Register ylo = opr2-&gt;as_register_lo();
2658       Register yhi = opr2-&gt;as_register_hi();
2659       __ subl(xlo, ylo);
2660       __ sbbl(xhi, yhi);
2661       if (condition == lir_cond_equal || condition == lir_cond_notEqual) {
2662         __ orl(xhi, xlo);
2663       }
2664 #endif // _LP64
2665     } else if (opr2-&gt;is_constant()) {
2666       // cpu register - constant 0
2667       assert(opr2-&gt;as_jlong() == (jlong)0, &quot;only handles zero&quot;);
2668 #ifdef _LP64
2669       __ cmpptr(xlo, (int32_t)opr2-&gt;as_jlong());
2670 #else
2671       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles equals case&quot;);
2672       __ orl(xhi, xlo);
2673 #endif // _LP64
2674     } else {
2675       ShouldNotReachHere();
2676     }
2677 
2678   } else if (opr1-&gt;is_single_xmm()) {
2679     XMMRegister reg1 = opr1-&gt;as_xmm_float_reg();
2680     if (opr2-&gt;is_single_xmm()) {
2681       // xmm register - xmm register
2682       __ ucomiss(reg1, opr2-&gt;as_xmm_float_reg());
2683     } else if (opr2-&gt;is_stack()) {
2684       // xmm register - stack
2685       __ ucomiss(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2686     } else if (opr2-&gt;is_constant()) {
2687       // xmm register - constant
2688       __ ucomiss(reg1, InternalAddress(float_constant(opr2-&gt;as_jfloat())));
2689     } else if (opr2-&gt;is_address()) {
2690       // xmm register - address
2691       if (op-&gt;info() != NULL) {
2692         add_debug_info_for_null_check_here(op-&gt;info());
2693       }
2694       __ ucomiss(reg1, as_Address(opr2-&gt;as_address_ptr()));
2695     } else {
2696       ShouldNotReachHere();
2697     }
2698 
2699   } else if (opr1-&gt;is_double_xmm()) {
2700     XMMRegister reg1 = opr1-&gt;as_xmm_double_reg();
2701     if (opr2-&gt;is_double_xmm()) {
2702       // xmm register - xmm register
2703       __ ucomisd(reg1, opr2-&gt;as_xmm_double_reg());
2704     } else if (opr2-&gt;is_stack()) {
2705       // xmm register - stack
2706       __ ucomisd(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix()));
2707     } else if (opr2-&gt;is_constant()) {
2708       // xmm register - constant
2709       __ ucomisd(reg1, InternalAddress(double_constant(opr2-&gt;as_jdouble())));
2710     } else if (opr2-&gt;is_address()) {
2711       // xmm register - address
2712       if (op-&gt;info() != NULL) {
2713         add_debug_info_for_null_check_here(op-&gt;info());
2714       }
2715       __ ucomisd(reg1, as_Address(opr2-&gt;pointer()-&gt;as_address()));
2716     } else {
2717       ShouldNotReachHere();
2718     }
2719 
2720   } else if(opr1-&gt;is_single_fpu() || opr1-&gt;is_double_fpu()) {
2721     assert(opr1-&gt;is_fpu_register() &amp;&amp; opr1-&gt;fpu() == 0, &quot;currently left-hand side must be on TOS (relax this restriction)&quot;);
2722     assert(opr2-&gt;is_fpu_register(), &quot;both must be registers&quot;);
2723     __ fcmp(noreg, opr2-&gt;fpu(), op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2724 
2725   } else if (opr1-&gt;is_address() &amp;&amp; opr2-&gt;is_constant()) {
2726     LIR_Const* c = opr2-&gt;as_constant_ptr();
2727 #ifdef _LP64
2728     if (c-&gt;type() == T_OBJECT || c-&gt;type() == T_ARRAY) {
2729       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;need to reverse&quot;);
2730       __ movoop(rscratch1, c-&gt;as_jobject());
2731     }
2732 #endif // LP64
2733     if (op-&gt;info() != NULL) {
2734       add_debug_info_for_null_check_here(op-&gt;info());
2735     }
2736     // special case: address - constant
2737     LIR_Address* addr = opr1-&gt;as_address_ptr();
2738     if (c-&gt;type() == T_INT) {
2739       __ cmpl(as_Address(addr), c-&gt;as_jint());
2740     } else if (c-&gt;type() == T_OBJECT || c-&gt;type() == T_ARRAY) {
2741 #ifdef _LP64
2742       // %%% Make this explode if addr isn&#39;t reachable until we figure out a
2743       // better strategy by giving noreg as the temp for as_Address
2744       __ cmpoop(rscratch1, as_Address(addr, noreg));
2745 #else
2746       __ cmpoop(as_Address(addr), c-&gt;as_jobject());
2747 #endif // _LP64
2748     } else {
2749       ShouldNotReachHere();
2750     }
2751 
2752   } else {
2753     ShouldNotReachHere();
2754   }
2755 }
2756 
2757 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op) {
2758   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2759     if (left-&gt;is_single_xmm()) {
2760       assert(right-&gt;is_single_xmm(), &quot;must match&quot;);
2761       __ cmpss2int(left-&gt;as_xmm_float_reg(), right-&gt;as_xmm_float_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2762     } else if (left-&gt;is_double_xmm()) {
2763       assert(right-&gt;is_double_xmm(), &quot;must match&quot;);
2764       __ cmpsd2int(left-&gt;as_xmm_double_reg(), right-&gt;as_xmm_double_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2765 
2766     } else {
2767       assert(left-&gt;is_single_fpu() || left-&gt;is_double_fpu(), &quot;must be&quot;);
2768       assert(right-&gt;is_single_fpu() || right-&gt;is_double_fpu(), &quot;must match&quot;);
2769 
2770       assert(left-&gt;fpu() == 0, &quot;left must be on TOS&quot;);
2771       __ fcmp2int(dst-&gt;as_register(), code == lir_ucmp_fd2i, right-&gt;fpu(),
2772                   op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2773     }
2774   } else {
2775     assert(code == lir_cmp_l2i, &quot;check&quot;);
2776 #ifdef _LP64
2777     Label done;
2778     Register dest = dst-&gt;as_register();
2779     __ cmpptr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
2780     __ movl(dest, -1);
2781     __ jccb(Assembler::less, done);
2782     __ set_byte_if_not_zero(dest);
2783     __ movzbl(dest, dest);
2784     __ bind(done);
2785 #else
2786     __ lcmp2int(left-&gt;as_register_hi(),
2787                 left-&gt;as_register_lo(),
2788                 right-&gt;as_register_hi(),
2789                 right-&gt;as_register_lo());
2790     move_regs(left-&gt;as_register_hi(), dst-&gt;as_register());
2791 #endif // _LP64
2792   }
2793 }
2794 
2795 
2796 void LIR_Assembler::align_call(LIR_Code code) {
2797   // make sure that the displacement word of the call ends up word aligned
2798   int offset = __ offset();
2799   switch (code) {
2800   case lir_static_call:
2801   case lir_optvirtual_call:
2802   case lir_dynamic_call:
2803     offset += NativeCall::displacement_offset;
2804     break;
2805   case lir_icvirtual_call:
2806     offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size;
2807     break;
2808   case lir_virtual_call:  // currently, sparc-specific for niagara
2809   default: ShouldNotReachHere();
2810   }
2811   __ align(BytesPerWord, offset);
2812 }
2813 
2814 
2815 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
2816   assert((__ offset() + NativeCall::displacement_offset) % BytesPerWord == 0,
2817          &quot;must be aligned&quot;);
2818   __ call(AddressLiteral(op-&gt;addr(), rtype));
2819   add_call_info(code_offset(), op-&gt;info());
2820 }
2821 
2822 
2823 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
2824   __ ic_call(op-&gt;addr());
2825   add_call_info(code_offset(), op-&gt;info());
2826   assert((__ offset() - NativeCall::instruction_size + NativeCall::displacement_offset) % BytesPerWord == 0,
2827          &quot;must be aligned&quot;);
2828 }
2829 
2830 
2831 /* Currently, vtable-dispatch is only enabled for sparc platforms */
2832 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
2833   ShouldNotReachHere();
2834 }
2835 
2836 
2837 void LIR_Assembler::emit_static_call_stub() {
2838   address call_pc = __ pc();
2839   address stub = __ start_a_stub(call_stub_size());
2840   if (stub == NULL) {
2841     bailout(&quot;static call stub overflow&quot;);
2842     return;
2843   }
2844 
2845   int start = __ offset();
2846 
2847   // make sure that the displacement word of the call ends up word aligned
2848   __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size + NativeCall::displacement_offset);
2849   __ relocate(static_stub_Relocation::spec(call_pc, false /* is_aot */));
2850   __ mov_metadata(rbx, (Metadata*)NULL);
2851   // must be set to -1 at code generation time
2852   assert(((__ offset() + 1) % BytesPerWord) == 0, &quot;must be aligned&quot;);
2853   // On 64bit this will die since it will take a movq &amp; jmp, must be only a jmp
2854   __ jump(RuntimeAddress(__ pc()));
2855 
2856   if (UseAOT) {
2857     // Trampoline to aot code
2858     __ relocate(static_stub_Relocation::spec(call_pc, true /* is_aot */));
2859 #ifdef _LP64
2860     __ mov64(rax, CONST64(0));  // address is zapped till fixup time.
2861 #else
2862     __ movl(rax, 0xdeadffff);  // address is zapped till fixup time.
2863 #endif
2864     __ jmp(rax);
2865   }
2866   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
2867   __ end_a_stub();
2868 }
2869 
2870 
2871 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2872   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
2873   assert(exceptionPC-&gt;as_register() == rdx, &quot;must match&quot;);
2874 
2875   // exception object is not added to oop map by LinearScan
2876   // (LinearScan assumes that no oops are in fixed registers)
2877   info-&gt;add_register_oop(exceptionOop);
2878   Runtime1::StubID unwind_id;
2879 
2880   // get current pc information
2881   // pc is only needed if the method has an exception handler, the unwind code does not need it.
2882   int pc_for_athrow_offset = __ offset();
2883   InternalAddress pc_for_athrow(__ pc());
2884   __ lea(exceptionPC-&gt;as_register(), pc_for_athrow);
2885   add_call_info(pc_for_athrow_offset, info); // for exception handler
2886 
2887   __ verify_not_null_oop(rax);
2888   // search an exception handler (rax: exception oop, rdx: throwing pc)
2889   if (compilation()-&gt;has_fpu_code()) {
2890     unwind_id = Runtime1::handle_exception_id;
2891   } else {
2892     unwind_id = Runtime1::handle_exception_nofpu_id;
2893   }
2894   __ call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
2895 
2896   // enough room for two byte trap
2897   __ nop();
2898 }
2899 
2900 
2901 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
2902   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
2903 
2904   __ jmp(_unwind_handler_entry);
2905 }
2906 
2907 
2908 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2909 
2910   // optimized version for linear scan:
2911   // * count must be already in ECX (guaranteed by LinearScan)
2912   // * left and dest must be equal
2913   // * tmp must be unused
2914   assert(count-&gt;as_register() == SHIFT_count, &quot;count must be in ECX&quot;);
2915   assert(left == dest, &quot;left and dest must be equal&quot;);
2916   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2917 
2918   if (left-&gt;is_single_cpu()) {
2919     Register value = left-&gt;as_register();
2920     assert(value != SHIFT_count, &quot;left cannot be ECX&quot;);
2921 
2922     switch (code) {
2923       case lir_shl:  __ shll(value); break;
2924       case lir_shr:  __ sarl(value); break;
2925       case lir_ushr: __ shrl(value); break;
2926       default: ShouldNotReachHere();
2927     }
2928   } else if (left-&gt;is_double_cpu()) {
2929     Register lo = left-&gt;as_register_lo();
2930     Register hi = left-&gt;as_register_hi();
2931     assert(lo != SHIFT_count &amp;&amp; hi != SHIFT_count, &quot;left cannot be ECX&quot;);
2932 #ifdef _LP64
2933     switch (code) {
2934       case lir_shl:  __ shlptr(lo);        break;
2935       case lir_shr:  __ sarptr(lo);        break;
2936       case lir_ushr: __ shrptr(lo);        break;
2937       default: ShouldNotReachHere();
2938     }
2939 #else
2940 
2941     switch (code) {
2942       case lir_shl:  __ lshl(hi, lo);        break;
2943       case lir_shr:  __ lshr(hi, lo, true);  break;
2944       case lir_ushr: __ lshr(hi, lo, false); break;
2945       default: ShouldNotReachHere();
2946     }
2947 #endif // LP64
2948   } else {
2949     ShouldNotReachHere();
2950   }
2951 }
2952 
2953 
2954 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2955   if (dest-&gt;is_single_cpu()) {
2956     // first move left into dest so that left is not destroyed by the shift
2957     Register value = dest-&gt;as_register();
2958     count = count &amp; 0x1F; // Java spec
2959 
2960     move_regs(left-&gt;as_register(), value);
2961     switch (code) {
2962       case lir_shl:  __ shll(value, count); break;
2963       case lir_shr:  __ sarl(value, count); break;
2964       case lir_ushr: __ shrl(value, count); break;
2965       default: ShouldNotReachHere();
2966     }
2967   } else if (dest-&gt;is_double_cpu()) {
2968 #ifndef _LP64
2969     Unimplemented();
2970 #else
2971     // first move left into dest so that left is not destroyed by the shift
2972     Register value = dest-&gt;as_register_lo();
2973     count = count &amp; 0x1F; // Java spec
2974 
2975     move_regs(left-&gt;as_register_lo(), value);
2976     switch (code) {
2977       case lir_shl:  __ shlptr(value, count); break;
2978       case lir_shr:  __ sarptr(value, count); break;
2979       case lir_ushr: __ shrptr(value, count); break;
2980       default: ShouldNotReachHere();
2981     }
2982 #endif // _LP64
2983   } else {
2984     ShouldNotReachHere();
2985   }
2986 }
2987 
2988 
2989 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
2990   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2991   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2992   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2993   __ movptr (Address(rsp, offset_from_rsp_in_bytes), r);
2994 }
2995 
2996 
2997 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
2998   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2999   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3000   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3001   __ movptr (Address(rsp, offset_from_rsp_in_bytes), c);
3002 }
3003 
3004 
3005 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
3006   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3007   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3008   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3009   __ movoop (Address(rsp, offset_from_rsp_in_bytes), o);
3010 }
3011 
3012 
3013 void LIR_Assembler::store_parameter(Metadata* m,  int offset_from_rsp_in_words) {
3014   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3015   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3016   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3017   __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m);
3018 }
3019 
3020 
3021 // This code replaces a call to arraycopy; no exception may
3022 // be thrown in this code, they must be thrown in the System.arraycopy
3023 // activation frame; we could save some checks if this would not be the case
3024 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
3025   ciArrayKlass* default_type = op-&gt;expected_type();
3026   Register src = op-&gt;src()-&gt;as_register();
3027   Register dst = op-&gt;dst()-&gt;as_register();
3028   Register src_pos = op-&gt;src_pos()-&gt;as_register();
3029   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
3030   Register length  = op-&gt;length()-&gt;as_register();
3031   Register tmp = op-&gt;tmp()-&gt;as_register();
3032 
3033   __ resolve(ACCESS_READ, src);
3034   __ resolve(ACCESS_WRITE, dst);
3035 
3036   CodeStub* stub = op-&gt;stub();
3037   int flags = op-&gt;flags();
3038   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
3039   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
3040 
3041   // if we don&#39;t know anything, just go through the generic arraycopy
3042   if (default_type == NULL) {
3043     // save outgoing arguments on stack in case call to System.arraycopy is needed
3044     // HACK ALERT. This code used to push the parameters in a hardwired fashion
3045     // for interpreter calling conventions. Now we have to do it in new style conventions.
3046     // For the moment until C1 gets the new register allocator I just force all the
3047     // args to the right place (except the register args) and then on the back side
3048     // reload the register args properly if we go slow path. Yuck
3049 
3050     // These are proper for the calling convention
3051     store_parameter(length, 2);
3052     store_parameter(dst_pos, 1);
3053     store_parameter(dst, 0);
3054 
3055     // these are just temporary placements until we need to reload
3056     store_parameter(src_pos, 3);
3057     store_parameter(src, 4);
3058     NOT_LP64(assert(src == rcx &amp;&amp; src_pos == rdx, &quot;mismatch in calling convention&quot;);)
3059 
3060     address copyfunc_addr = StubRoutines::generic_arraycopy();
3061     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
3062 
3063     // pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint
3064 #ifdef _LP64
3065     // The arguments are in java calling convention so we can trivially shift them to C
3066     // convention
3067     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
3068     __ mov(c_rarg0, j_rarg0);
3069     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
3070     __ mov(c_rarg1, j_rarg1);
3071     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
3072     __ mov(c_rarg2, j_rarg2);
3073     assert_different_registers(c_rarg3, j_rarg4);
3074     __ mov(c_rarg3, j_rarg3);
3075 #ifdef _WIN64
3076     // Allocate abi space for args but be sure to keep stack aligned
3077     __ subptr(rsp, 6*wordSize);
3078     store_parameter(j_rarg4, 4);
3079 #ifndef PRODUCT
3080     if (PrintC1Statistics) {
3081       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3082     }
3083 #endif
3084     __ call(RuntimeAddress(copyfunc_addr));
3085     __ addptr(rsp, 6*wordSize);
3086 #else
3087     __ mov(c_rarg4, j_rarg4);
3088 #ifndef PRODUCT
3089     if (PrintC1Statistics) {
3090       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3091     }
3092 #endif
3093     __ call(RuntimeAddress(copyfunc_addr));
3094 #endif // _WIN64
3095 #else
3096     __ push(length);
3097     __ push(dst_pos);
3098     __ push(dst);
3099     __ push(src_pos);
3100     __ push(src);
3101 
3102 #ifndef PRODUCT
3103     if (PrintC1Statistics) {
3104       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3105     }
3106 #endif
3107     __ call_VM_leaf(copyfunc_addr, 5); // removes pushed parameter from the stack
3108 
3109 #endif // _LP64
3110 
3111     __ cmpl(rax, 0);
3112     __ jcc(Assembler::equal, *stub-&gt;continuation());
3113 
3114     __ mov(tmp, rax);
3115     __ xorl(tmp, -1);
3116 
3117     // Reload values from the stack so they are where the stub
3118     // expects them.
3119     __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3120     __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3121     __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3122     __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3123     __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3124 
3125     __ subl(length, tmp);
3126     __ addl(src_pos, tmp);
3127     __ addl(dst_pos, tmp);
3128     __ jmp(*stub-&gt;entry());
3129 
3130     __ bind(*stub-&gt;continuation());
3131     return;
3132   }
3133 
3134   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
3135 
3136   int elem_size = type2aelembytes(basic_type);
3137   Address::ScaleFactor scale;
3138 
3139   switch (elem_size) {
3140     case 1 :
3141       scale = Address::times_1;
3142       break;
3143     case 2 :
3144       scale = Address::times_2;
3145       break;
3146     case 4 :
3147       scale = Address::times_4;
3148       break;
3149     case 8 :
3150       scale = Address::times_8;
3151       break;
3152     default:
3153       scale = Address::no_scale;
3154       ShouldNotReachHere();
3155   }
3156 
3157   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
3158   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
3159   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
3160   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
3161 
3162   // length and pos&#39;s are all sign extended at this point on 64bit
3163 
3164   // test for NULL
3165   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
3166     __ testptr(src, src);
3167     __ jcc(Assembler::zero, *stub-&gt;entry());
3168   }
3169   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
3170     __ testptr(dst, dst);
3171     __ jcc(Assembler::zero, *stub-&gt;entry());
3172   }
3173 
3174   // If the compiler was not able to prove that exact type of the source or the destination
3175   // of the arraycopy is an array type, check at runtime if the source or the destination is
3176   // an instance type.
3177   if (flags &amp; LIR_OpArrayCopy::type_check) {
3178     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3179       __ load_klass(tmp, dst);
3180       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3181       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3182     }
3183 
3184     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3185       __ load_klass(tmp, src);
3186       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3187       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3188     }
3189   }
3190 
3191   // check if negative
3192   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
3193     __ testl(src_pos, src_pos);
3194     __ jcc(Assembler::less, *stub-&gt;entry());
3195   }
3196   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
3197     __ testl(dst_pos, dst_pos);
3198     __ jcc(Assembler::less, *stub-&gt;entry());
3199   }
3200 
3201   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
3202     __ lea(tmp, Address(src_pos, length, Address::times_1, 0));
3203     __ cmpl(tmp, src_length_addr);
3204     __ jcc(Assembler::above, *stub-&gt;entry());
3205   }
3206   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
3207     __ lea(tmp, Address(dst_pos, length, Address::times_1, 0));
3208     __ cmpl(tmp, dst_length_addr);
3209     __ jcc(Assembler::above, *stub-&gt;entry());
3210   }
3211 
3212   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
3213     __ testl(length, length);
3214     __ jcc(Assembler::less, *stub-&gt;entry());
3215   }
3216 
3217 #ifdef _LP64
3218   __ movl2ptr(src_pos, src_pos); //higher 32bits must be null
3219   __ movl2ptr(dst_pos, dst_pos); //higher 32bits must be null
3220 #endif
3221 
3222   if (flags &amp; LIR_OpArrayCopy::type_check) {
3223     // We don&#39;t know the array types are compatible
3224     if (basic_type != T_OBJECT) {
3225       // Simple test for basic type arrays
3226       if (UseCompressedClassPointers) {
3227         __ movl(tmp, src_klass_addr);
3228         __ cmpl(tmp, dst_klass_addr);
3229       } else {
3230         __ movptr(tmp, src_klass_addr);
3231         __ cmpptr(tmp, dst_klass_addr);
3232       }
3233       __ jcc(Assembler::notEqual, *stub-&gt;entry());
3234     } else {
3235       // For object arrays, if src is a sub class of dst then we can
3236       // safely do the copy.
3237       Label cont, slow;
3238 
3239       __ push(src);
3240       __ push(dst);
3241 
3242       __ load_klass(src, src);
3243       __ load_klass(dst, dst);
3244 
3245       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
3246 
3247       __ push(src);
3248       __ push(dst);
3249       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
3250       __ pop(dst);
3251       __ pop(src);
3252 
3253       __ cmpl(src, 0);
3254       __ jcc(Assembler::notEqual, cont);
3255 
3256       __ bind(slow);
3257       __ pop(dst);
3258       __ pop(src);
3259 
3260       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
3261       if (copyfunc_addr != NULL) { // use stub if available
3262         // src is not a sub class of dst so we have to do a
3263         // per-element check.
3264 
3265         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
3266         if ((flags &amp; mask) != mask) {
3267           // Check that at least both of them object arrays.
3268           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
3269 
3270           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3271             __ load_klass(tmp, src);
3272           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3273             __ load_klass(tmp, dst);
3274           }
3275           int lh_offset = in_bytes(Klass::layout_helper_offset());
3276           Address klass_lh_addr(tmp, lh_offset);
3277           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
3278           __ cmpl(klass_lh_addr, objArray_lh);
3279           __ jcc(Assembler::notEqual, *stub-&gt;entry());
3280         }
3281 
3282        // Spill because stubs can use any register they like and it&#39;s
3283        // easier to restore just those that we care about.
3284        store_parameter(dst, 0);
3285        store_parameter(dst_pos, 1);
3286        store_parameter(length, 2);
3287        store_parameter(src_pos, 3);
3288        store_parameter(src, 4);
3289 
3290 #ifndef _LP64
3291         __ movptr(tmp, dst_klass_addr);
3292         __ movptr(tmp, Address(tmp, ObjArrayKlass::element_klass_offset()));
3293         __ push(tmp);
3294         __ movl(tmp, Address(tmp, Klass::super_check_offset_offset()));
3295         __ push(tmp);
3296         __ push(length);
3297         __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3298         __ push(tmp);
3299         __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3300         __ push(tmp);
3301 
3302         __ call_VM_leaf(copyfunc_addr, 5);
3303 #else
3304         __ movl2ptr(length, length); //higher 32bits must be null
3305 
3306         __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3307         assert_different_registers(c_rarg0, dst, dst_pos, length);
3308         __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3309         assert_different_registers(c_rarg1, dst, length);
3310 
3311         __ mov(c_rarg2, length);
3312         assert_different_registers(c_rarg2, dst);
3313 
3314 #ifdef _WIN64
3315         // Allocate abi space for args but be sure to keep stack aligned
3316         __ subptr(rsp, 6*wordSize);
3317         __ load_klass(c_rarg3, dst);
3318         __ movptr(c_rarg3, Address(c_rarg3, ObjArrayKlass::element_klass_offset()));
3319         store_parameter(c_rarg3, 4);
3320         __ movl(c_rarg3, Address(c_rarg3, Klass::super_check_offset_offset()));
3321         __ call(RuntimeAddress(copyfunc_addr));
3322         __ addptr(rsp, 6*wordSize);
3323 #else
3324         __ load_klass(c_rarg4, dst);
3325         __ movptr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
3326         __ movl(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
3327         __ call(RuntimeAddress(copyfunc_addr));
3328 #endif
3329 
3330 #endif
3331 
3332 #ifndef PRODUCT
3333         if (PrintC1Statistics) {
3334           Label failed;
3335           __ testl(rax, rax);
3336           __ jcc(Assembler::notZero, failed);
3337           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
3338           __ bind(failed);
3339         }
3340 #endif
3341 
3342         __ testl(rax, rax);
3343         __ jcc(Assembler::zero, *stub-&gt;continuation());
3344 
3345 #ifndef PRODUCT
3346         if (PrintC1Statistics) {
3347           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
3348         }
3349 #endif
3350 
3351         __ mov(tmp, rax);
3352 
3353         __ xorl(tmp, -1);
3354 
3355         // Restore previously spilled arguments
3356         __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3357         __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3358         __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3359         __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3360         __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3361 
3362 
3363         __ subl(length, tmp);
3364         __ addl(src_pos, tmp);
3365         __ addl(dst_pos, tmp);
3366       }
3367 
3368       __ jmp(*stub-&gt;entry());
3369 
3370       __ bind(cont);
3371       __ pop(dst);
3372       __ pop(src);
3373     }
3374   }
3375 
3376 #ifdef ASSERT
3377   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
3378     // Sanity check the known type with the incoming class.  For the
3379     // primitive case the types must match exactly with src.klass and
3380     // dst.klass each exactly matching the default type.  For the
3381     // object array case, if no type check is needed then either the
3382     // dst type is exactly the expected type and the src type is a
3383     // subtype which we can&#39;t check or src is the same array as dst
3384     // but not necessarily exactly of type default_type.
3385     Label known_ok, halt;
3386     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
3387 #ifdef _LP64
3388     if (UseCompressedClassPointers) {
3389       __ encode_klass_not_null(tmp);
3390     }
3391 #endif
3392 
3393     if (basic_type != T_OBJECT) {
3394 
3395       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3396       else                   __ cmpptr(tmp, dst_klass_addr);
3397       __ jcc(Assembler::notEqual, halt);
3398       if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);
3399       else                   __ cmpptr(tmp, src_klass_addr);
3400       __ jcc(Assembler::equal, known_ok);
3401     } else {
3402       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3403       else                   __ cmpptr(tmp, dst_klass_addr);
3404       __ jcc(Assembler::equal, known_ok);
3405       __ cmpptr(src, dst);
3406       __ jcc(Assembler::equal, known_ok);
3407     }
3408     __ bind(halt);
3409     __ stop(&quot;incorrect type information in arraycopy&quot;);
3410     __ bind(known_ok);
3411   }
3412 #endif
3413 
3414 #ifndef PRODUCT
3415   if (PrintC1Statistics) {
3416     __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
3417   }
3418 #endif
3419 
3420 #ifdef _LP64
3421   assert_different_registers(c_rarg0, dst, dst_pos, length);
3422   __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3423   assert_different_registers(c_rarg1, length);
3424   __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3425   __ mov(c_rarg2, length);
3426 
3427 #else
3428   __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3429   store_parameter(tmp, 0);
3430   __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3431   store_parameter(tmp, 1);
3432   store_parameter(length, 2);
3433 #endif // _LP64
3434 
3435   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
3436   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
3437   const char *name;
3438   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
3439   __ call_VM_leaf(entry, 0);
3440 
3441   __ bind(*stub-&gt;continuation());
3442 }
3443 
3444 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3445   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
3446   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
3447   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3448   Register crc = op-&gt;crc()-&gt;as_register();
3449   Register val = op-&gt;val()-&gt;as_register();
3450   Register res = op-&gt;result_opr()-&gt;as_register();
3451 
3452   assert_different_registers(val, crc, res);
3453 
3454   __ lea(res, ExternalAddress(StubRoutines::crc_table_addr()));
3455   __ notl(crc); // ~crc
3456   __ update_byte_crc32(crc, val, res);
3457   __ notl(crc); // ~crc
3458   __ mov(res, crc);
3459 }
3460 
3461 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
3462   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
3463   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
3464   Register lock = op-&gt;lock_opr()-&gt;as_register();
3465   if (!UseFastLocking) {
3466     __ jmp(*op-&gt;stub()-&gt;entry());
3467   } else if (op-&gt;code() == lir_lock) {
3468     Register scratch = noreg;
3469     if (UseBiasedLocking) {
3470       scratch = op-&gt;scratch_opr()-&gt;as_register();
3471     }
3472     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3473     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
3474     // add debug info for NullPointerException only if one is possible
3475     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
3476     if (op-&gt;info() != NULL) {
3477       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
3478     }
3479     // done
3480   } else if (op-&gt;code() == lir_unlock) {
3481     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3482     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
3483   } else {
3484     Unimplemented();
3485   }
3486   __ bind(*op-&gt;stub()-&gt;continuation());
3487 }
3488 
3489 
3490 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
3491   ciMethod* method = op-&gt;profiled_method();
3492   int bci          = op-&gt;profiled_bci();
3493   ciMethod* callee = op-&gt;profiled_callee();
3494 
3495   // Update counter for all call types
3496   ciMethodData* md = method-&gt;method_data_or_null();
3497   assert(md != NULL, &quot;Sanity&quot;);
3498   ciProfileData* data = md-&gt;bci_to_data(bci);
3499   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
3500   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
3501   Register mdo  = op-&gt;mdo()-&gt;as_register();
3502   __ mov_metadata(mdo, md-&gt;constant_encoding());
3503   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
3504   // Perform additional virtual call profiling for invokevirtual and
3505   // invokeinterface bytecodes
3506   if (op-&gt;should_profile_receiver_type()) {
3507     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
3508     Register recv = op-&gt;recv()-&gt;as_register();
3509     assert_different_registers(mdo, recv);
3510     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
3511     ciKlass* known_klass = op-&gt;known_holder();
3512     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
3513       // We know the type that will be seen at this call site; we can
3514       // statically update the MethodData* rather than needing to do
3515       // dynamic tests on the receiver type
3516 
3517       // NOTE: we should probably put a lock around this search to
3518       // avoid collisions by concurrent compilations
3519       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
3520       uint i;
3521       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3522         ciKlass* receiver = vc_data-&gt;receiver(i);
3523         if (known_klass-&gt;equals(receiver)) {
3524           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3525           __ addptr(data_addr, DataLayout::counter_increment);
3526           return;
3527         }
3528       }
3529 
3530       // Receiver type not found in profile data; select an empty slot
3531 
3532       // Note that this is less efficient than it should be because it
3533       // always does a write to the receiver part of the
3534       // VirtualCallData rather than just the first time
3535       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3536         ciKlass* receiver = vc_data-&gt;receiver(i);
3537         if (receiver == NULL) {
3538           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
3539           __ mov_metadata(recv_addr, known_klass-&gt;constant_encoding());
3540           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3541           __ addptr(data_addr, DataLayout::counter_increment);
3542           return;
3543         }
3544       }
3545     } else {
3546       __ load_klass(recv, recv);
3547       Label update_done;
3548       type_profile_helper(mdo, md, data, recv, &amp;update_done);
3549       // Receiver did not match any saved receiver and there is no empty row for it.
3550       // Increment total counter to indicate polymorphic case.
3551       __ addptr(counter_addr, DataLayout::counter_increment);
3552 
3553       __ bind(update_done);
3554     }
3555   } else {
3556     // Static call
3557     __ addptr(counter_addr, DataLayout::counter_increment);
3558   }
3559 }
3560 
3561 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3562   Register obj = op-&gt;obj()-&gt;as_register();
3563   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3564   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
3565   ciKlass* exact_klass = op-&gt;exact_klass();
3566   intptr_t current_klass = op-&gt;current_klass();
3567   bool not_null = op-&gt;not_null();
3568   bool no_conflict = op-&gt;no_conflict();
3569 
3570   Label update, next, none;
3571 
3572   bool do_null = !not_null;
3573   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3574   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3575 
3576   assert(do_null || do_update, &quot;why are we here?&quot;);
3577   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3578 
3579   __ verify_oop(obj);
3580 
3581   if (tmp != obj) {
3582     __ mov(tmp, obj);
3583   }
3584   if (do_null) {
3585     __ testptr(tmp, tmp);
3586     __ jccb(Assembler::notZero, update);
3587     if (!TypeEntries::was_null_seen(current_klass)) {
3588       __ orptr(mdo_addr, TypeEntries::null_seen);
3589     }
3590     if (do_update) {
3591 #ifndef ASSERT
3592       __ jmpb(next);
3593     }
3594 #else
3595       __ jmp(next);
3596     }
3597   } else {
3598     __ testptr(tmp, tmp);
3599     __ jcc(Assembler::notZero, update);
3600     __ stop(&quot;unexpect null obj&quot;);
3601 #endif
3602   }
3603 
3604   __ bind(update);
3605 
3606   if (do_update) {
3607 #ifdef ASSERT
3608     if (exact_klass != NULL) {
3609       Label ok;
3610       __ load_klass(tmp, tmp);
3611       __ push(tmp);
3612       __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3613       __ cmpptr(tmp, Address(rsp, 0));
3614       __ jcc(Assembler::equal, ok);
3615       __ stop(&quot;exact klass and actual klass differ&quot;);
3616       __ bind(ok);
3617       __ pop(tmp);
3618     }
3619 #endif
3620     if (!no_conflict) {
3621       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3622         if (exact_klass != NULL) {
3623           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3624         } else {
3625           __ load_klass(tmp, tmp);
3626         }
3627 
3628         __ xorptr(tmp, mdo_addr);
3629         __ testptr(tmp, TypeEntries::type_klass_mask);
3630         // klass seen before, nothing to do. The unknown bit may have been
3631         // set already but no need to check.
3632         __ jccb(Assembler::zero, next);
3633 
3634         __ testptr(tmp, TypeEntries::type_unknown);
3635         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3636 
3637         if (TypeEntries::is_type_none(current_klass)) {
3638           __ cmpptr(mdo_addr, 0);
3639           __ jccb(Assembler::equal, none);
3640           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3641           __ jccb(Assembler::equal, none);
3642           // There is a chance that the checks above (re-reading profiling
3643           // data from memory) fail if another thread has just set the
3644           // profiling to this obj&#39;s klass
3645           __ xorptr(tmp, mdo_addr);
3646           __ testptr(tmp, TypeEntries::type_klass_mask);
3647           __ jccb(Assembler::zero, next);
3648         }
3649       } else {
3650         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3651                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3652 
3653         __ movptr(tmp, mdo_addr);
3654         __ testptr(tmp, TypeEntries::type_unknown);
3655         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3656       }
3657 
3658       // different than before. Cannot keep accurate profile.
3659       __ orptr(mdo_addr, TypeEntries::type_unknown);
3660 
3661       if (TypeEntries::is_type_none(current_klass)) {
3662         __ jmpb(next);
3663 
3664         __ bind(none);
3665         // first time here. Set profile type.
3666         __ movptr(mdo_addr, tmp);
3667       }
3668     } else {
3669       // There&#39;s a single possible klass at this profile point
3670       assert(exact_klass != NULL, &quot;should be&quot;);
3671       if (TypeEntries::is_type_none(current_klass)) {
3672         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3673         __ xorptr(tmp, mdo_addr);
3674         __ testptr(tmp, TypeEntries::type_klass_mask);
3675 #ifdef ASSERT
3676         __ jcc(Assembler::zero, next);
3677 
3678         {
3679           Label ok;
3680           __ push(tmp);
3681           __ cmpptr(mdo_addr, 0);
3682           __ jcc(Assembler::equal, ok);
3683           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3684           __ jcc(Assembler::equal, ok);
3685           // may have been set by another thread
3686           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3687           __ xorptr(tmp, mdo_addr);
3688           __ testptr(tmp, TypeEntries::type_mask);
3689           __ jcc(Assembler::zero, ok);
3690 
3691           __ stop(&quot;unexpected profiling mismatch&quot;);
3692           __ bind(ok);
3693           __ pop(tmp);
3694         }
3695 #else
3696         __ jccb(Assembler::zero, next);
3697 #endif
3698         // first time here. Set profile type.
3699         __ movptr(mdo_addr, tmp);
3700       } else {
3701         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3702                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3703 
3704         __ movptr(tmp, mdo_addr);
3705         __ testptr(tmp, TypeEntries::type_unknown);
3706         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3707 
3708         __ orptr(mdo_addr, TypeEntries::type_unknown);
3709       }
3710     }
3711 
3712     __ bind(next);
3713   }
3714 }
3715 
3716 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
3717   Unimplemented();
3718 }
3719 
3720 
3721 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
3722   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
3723 }
3724 
3725 
3726 void LIR_Assembler::align_backward_branch_target() {
3727   __ align(BytesPerWord);
3728 }
3729 
3730 
3731 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
3732   if (left-&gt;is_single_cpu()) {
3733     __ negl(left-&gt;as_register());
3734     move_regs(left-&gt;as_register(), dest-&gt;as_register());
3735 
3736   } else if (left-&gt;is_double_cpu()) {
3737     Register lo = left-&gt;as_register_lo();
3738 #ifdef _LP64
3739     Register dst = dest-&gt;as_register_lo();
3740     __ movptr(dst, lo);
3741     __ negptr(dst);
3742 #else
3743     Register hi = left-&gt;as_register_hi();
3744     __ lneg(hi, lo);
3745     if (dest-&gt;as_register_lo() == hi) {
3746       assert(dest-&gt;as_register_hi() != lo, &quot;destroying register&quot;);
3747       move_regs(hi, dest-&gt;as_register_hi());
3748       move_regs(lo, dest-&gt;as_register_lo());
3749     } else {
3750       move_regs(lo, dest-&gt;as_register_lo());
3751       move_regs(hi, dest-&gt;as_register_hi());
3752     }
3753 #endif // _LP64
3754 
3755   } else if (dest-&gt;is_single_xmm()) {
3756 #ifdef _LP64
3757     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
3758       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
3759       assert_different_registers(left-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg());
3760       __ vpxor(dest-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg(), 2);
3761     }
3762     else
3763 #endif
3764     {
3765       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
3766       if (left-&gt;as_xmm_float_reg() != dest-&gt;as_xmm_float_reg()) {
3767         __ movflt(dest-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg());
3768       }
3769       __ xorps(dest-&gt;as_xmm_float_reg(),
3770                ExternalAddress((address)float_signflip_pool));
3771     }
3772   } else if (dest-&gt;is_double_xmm()) {
3773 #ifdef _LP64
3774     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
3775       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
3776       assert_different_registers(left-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg());
3777       __ vpxor(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg(), 2);
3778     }
3779     else
3780 #endif
3781     {
3782       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
3783       if (left-&gt;as_xmm_double_reg() != dest-&gt;as_xmm_double_reg()) {
3784         __ movdbl(dest-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg());
3785       }
3786       __ xorpd(dest-&gt;as_xmm_double_reg(),
3787                ExternalAddress((address)double_signflip_pool));
3788     }
3789   } else if (left-&gt;is_single_fpu() || left-&gt;is_double_fpu()) {
3790     assert(left-&gt;fpu() == 0, &quot;arg must be on TOS&quot;);
3791     assert(dest-&gt;fpu() == 0, &quot;dest must be TOS&quot;);
3792     __ fchs();
3793 
3794   } else {
3795     ShouldNotReachHere();
3796   }
3797 }
3798 
3799 
3800 void LIR_Assembler::leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
3801   assert(src-&gt;is_address(), &quot;must be an address&quot;);
3802   assert(dest-&gt;is_register(), &quot;must be a register&quot;);
3803 
3804   PatchingStub* patch = NULL;
3805   if (patch_code != lir_patch_none) {
3806     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
3807   }
3808 
3809   Register reg = dest-&gt;as_pointer_register();
3810   LIR_Address* addr = src-&gt;as_address_ptr();
3811   __ lea(reg, as_Address(addr));
3812 
3813   if (patch != NULL) {
3814     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
3815   }
3816 }
3817 
3818 
3819 
3820 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
3821   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
3822   __ call(RuntimeAddress(dest));
3823   if (info != NULL) {
3824     add_call_info_here(info);
3825   }
3826 }
3827 
3828 
3829 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
3830   assert(type == T_LONG, &quot;only for volatile long fields&quot;);
3831 
3832   if (info != NULL) {
3833     add_debug_info_for_null_check_here(info);
3834   }
3835 
3836   if (src-&gt;is_double_xmm()) {
3837     if (dest-&gt;is_double_cpu()) {
3838 #ifdef _LP64
3839       __ movdq(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
3840 #else
3841       __ movdl(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
3842       __ psrlq(src-&gt;as_xmm_double_reg(), 32);
3843       __ movdl(dest-&gt;as_register_hi(), src-&gt;as_xmm_double_reg());
3844 #endif // _LP64
3845     } else if (dest-&gt;is_double_stack()) {
3846       __ movdbl(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()), src-&gt;as_xmm_double_reg());
3847     } else if (dest-&gt;is_address()) {
3848       __ movdbl(as_Address(dest-&gt;as_address_ptr()), src-&gt;as_xmm_double_reg());
3849     } else {
3850       ShouldNotReachHere();
3851     }
3852 
3853   } else if (dest-&gt;is_double_xmm()) {
3854     if (src-&gt;is_double_stack()) {
3855       __ movdbl(dest-&gt;as_xmm_double_reg(), frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
3856     } else if (src-&gt;is_address()) {
3857       __ movdbl(dest-&gt;as_xmm_double_reg(), as_Address(src-&gt;as_address_ptr()));
3858     } else {
3859       ShouldNotReachHere();
3860     }
3861 
3862   } else if (src-&gt;is_double_fpu()) {
3863     assert(src-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
3864     if (dest-&gt;is_double_stack()) {
3865       __ fistp_d(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
3866     } else if (dest-&gt;is_address()) {
3867       __ fistp_d(as_Address(dest-&gt;as_address_ptr()));
3868     } else {
3869       ShouldNotReachHere();
3870     }
3871 
3872   } else if (dest-&gt;is_double_fpu()) {
3873     assert(dest-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
3874     if (src-&gt;is_double_stack()) {
3875       __ fild_d(frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
3876     } else if (src-&gt;is_address()) {
3877       __ fild_d(as_Address(src-&gt;as_address_ptr()));
3878     } else {
3879       ShouldNotReachHere();
3880     }
3881   } else {
3882     ShouldNotReachHere();
3883   }
3884 }
3885 
3886 #ifdef ASSERT
3887 // emit run-time assertion
3888 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
3889   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
3890 
3891   if (op-&gt;in_opr1()-&gt;is_valid()) {
3892     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
3893     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
3894   } else {
3895     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
3896     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
3897   }
3898 
3899   Label ok;
3900   if (op-&gt;condition() != lir_cond_always) {
3901     Assembler::Condition acond = Assembler::zero;
3902     switch (op-&gt;condition()) {
3903       case lir_cond_equal:        acond = Assembler::equal;       break;
3904       case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
3905       case lir_cond_less:         acond = Assembler::less;        break;
3906       case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
3907       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
3908       case lir_cond_greater:      acond = Assembler::greater;     break;
3909       case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
3910       case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
3911       default:                    ShouldNotReachHere();
3912     }
3913     __ jcc(acond, ok);
3914   }
3915   if (op-&gt;halt()) {
3916     const char* str = __ code_string(op-&gt;msg());
3917     __ stop(str);
3918   } else {
3919     breakpoint();
3920   }
3921   __ bind(ok);
3922 }
3923 #endif
3924 
3925 void LIR_Assembler::membar() {
3926   // QQQ sparc TSO uses this,
3927   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad));
3928 }
3929 
3930 void LIR_Assembler::membar_acquire() {
3931   // No x86 machines currently require load fences
3932 }
3933 
3934 void LIR_Assembler::membar_release() {
3935   // No x86 machines currently require store fences
3936 }
3937 
3938 void LIR_Assembler::membar_loadload() {
3939   // no-op
3940   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
3941 }
3942 
3943 void LIR_Assembler::membar_storestore() {
3944   // no-op
3945   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
3946 }
3947 
3948 void LIR_Assembler::membar_loadstore() {
3949   // no-op
3950   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
3951 }
3952 
3953 void LIR_Assembler::membar_storeload() {
3954   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
3955 }
3956 
3957 void LIR_Assembler::on_spin_wait() {
3958   __ pause ();
3959 }
3960 
3961 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
3962   assert(result_reg-&gt;is_register(), &quot;check&quot;);
3963 #ifdef _LP64
3964   // __ get_thread(result_reg-&gt;as_register_lo());
3965   __ mov(result_reg-&gt;as_register(), r15_thread);
3966 #else
3967   __ get_thread(result_reg-&gt;as_register());
3968 #endif // _LP64
3969 }
3970 
3971 
3972 void LIR_Assembler::peephole(LIR_List*) {
3973   // do nothing for now
3974 }
3975 
3976 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
3977   assert(data == dest, &quot;xchg/xadd uses only 2 operands&quot;);
3978 
3979   if (data-&gt;type() == T_INT) {
3980     if (code == lir_xadd) {
3981       __ lock();
3982       __ xaddl(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register());
3983     } else {
3984       __ xchgl(data-&gt;as_register(), as_Address(src-&gt;as_address_ptr()));
3985     }
3986   } else if (data-&gt;is_oop()) {
3987     assert (code == lir_xchg, &quot;xadd for oops&quot;);
3988     Register obj = data-&gt;as_register();
3989 #ifdef _LP64
3990     if (UseCompressedOops) {
3991       __ encode_heap_oop(obj);
3992       __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
3993       __ decode_heap_oop(obj);
3994     } else {
3995       __ xchgptr(obj, as_Address(src-&gt;as_address_ptr()));
3996     }
3997 #else
3998     __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
3999 #endif
4000   } else if (data-&gt;type() == T_LONG) {
4001 #ifdef _LP64
4002     assert(data-&gt;as_register_lo() == data-&gt;as_register_hi(), &quot;should be a single register&quot;);
4003     if (code == lir_xadd) {
4004       __ lock();
4005       __ xaddq(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register_lo());
4006     } else {
4007       __ xchgq(data-&gt;as_register_lo(), as_Address(src-&gt;as_address_ptr()));
4008     }
4009 #else
4010     ShouldNotReachHere();
4011 #endif
4012   } else {
4013     ShouldNotReachHere();
4014   }
4015 }
4016 
4017 #undef __
    </pre>
  </body>
</html>
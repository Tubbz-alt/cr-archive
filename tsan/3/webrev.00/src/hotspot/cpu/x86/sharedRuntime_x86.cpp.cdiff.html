<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/sharedRuntime_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="relocInfo_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86_32.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/sharedRuntime_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 57,34 ***</span>
    }
  
    __ movptr(result, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
  
    // check if locked
<span class="line-modified">!   __ testptr(result, markOopDesc::unlocked_value);</span>
    __ jcc(Assembler::zero, slowCase);
  
    if (UseBiasedLocking) {
      // Check if biased and fall through to runtime if so
<span class="line-modified">!     __ testptr(result, markOopDesc::biased_lock_bit_in_place);</span>
      __ jcc(Assembler::notZero, slowCase);
    }
  
    // get hash
  #ifdef _LP64
    // Read the header and build a mask to get its hash field.
    // Depend on hash_mask being at most 32 bits and avoid the use of hash_mask_in_place
<span class="line-modified">!   // because it could be larger than 32 bits in a 64-bit vm. See markOop.hpp.</span>
<span class="line-modified">!   __ shrptr(result, markOopDesc::hash_shift);</span>
<span class="line-modified">!   __ andptr(result, markOopDesc::hash_mask);</span>
  #else
<span class="line-modified">!   __ andptr(result, markOopDesc::hash_mask_in_place);</span>
  #endif //_LP64
  
    // test if hashCode exists
    __ jcc(Assembler::zero, slowCase);
  #ifndef _LP64
<span class="line-modified">!   __ shrptr(result, markOopDesc::hash_shift);</span>
  #endif
    __ ret(0);
    __ bind(slowCase);
  }
  #endif //COMPILER1
<span class="line-new-header">--- 57,34 ---</span>
    }
  
    __ movptr(result, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
  
    // check if locked
<span class="line-modified">!   __ testptr(result, markWord::unlocked_value);</span>
    __ jcc(Assembler::zero, slowCase);
  
    if (UseBiasedLocking) {
      // Check if biased and fall through to runtime if so
<span class="line-modified">!     __ testptr(result, markWord::biased_lock_bit_in_place);</span>
      __ jcc(Assembler::notZero, slowCase);
    }
  
    // get hash
  #ifdef _LP64
    // Read the header and build a mask to get its hash field.
    // Depend on hash_mask being at most 32 bits and avoid the use of hash_mask_in_place
<span class="line-modified">!   // because it could be larger than 32 bits in a 64-bit vm. See markWord.hpp.</span>
<span class="line-modified">!   __ shrptr(result, markWord::hash_shift);</span>
<span class="line-modified">!   __ andptr(result, markWord::hash_mask);</span>
  #else
<span class="line-modified">!   __ andptr(result, markWord::hash_mask_in_place);</span>
  #endif //_LP64
  
    // test if hashCode exists
    __ jcc(Assembler::zero, slowCase);
  #ifndef _LP64
<span class="line-modified">!   __ shrptr(result, markWord::hash_shift);</span>
  #endif
    __ ret(0);
    __ bind(slowCase);
  }
  #endif //COMPILER1
</pre>
<center><a href="relocInfo_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86_32.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
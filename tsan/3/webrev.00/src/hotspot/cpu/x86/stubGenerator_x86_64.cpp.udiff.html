<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/stubGenerator_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubGenerator_x86_32.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubRoutines_x86.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/stubGenerator_x86_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -28,10 +28,11 @@</span>
  #include &quot;ci/ciUtilities.hpp&quot;
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  #include &quot;gc/shared/barrierSetNMethod.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;nativeInst_x86.hpp&quot;
  #include &quot;oops/instanceOop.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -549,11 +550,12 @@</span>
      __ jmp(rbx);
  
      return start;
    }
  
<span class="udiff-line-modified-removed">-   // Support for jint atomic::xchg(jint exchange_value, volatile jint* dest)</span>
<span class="udiff-line-modified-added">+   // Implementation of jint atomic_xchg(jint add_value, volatile jint* dest)</span>
<span class="udiff-line-added">+   // used by Atomic::xchg(volatile jint* dest, jint exchange_value)</span>
    //
    // Arguments :
    //    c_rarg0: exchange_value
    //    c_rarg0: dest
    //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -568,11 +570,12 @@</span>
      __ ret(0);
  
      return start;
    }
  
<span class="udiff-line-modified-removed">-   // Support for intptr_t atomic::xchg_long(jlong exchange_value, volatile jlong* dest)</span>
<span class="udiff-line-modified-added">+   // Implementation of intptr_t atomic_xchg(jlong add_value, volatile jlong* dest)</span>
<span class="udiff-line-added">+   // used by Atomic::xchg(volatile jlong* dest, jlong exchange_value)</span>
    //
    // Arguments :
    //    c_rarg0: exchange_value
    //    c_rarg1: dest
    //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -665,11 +668,12 @@</span>
      __ ret(0);
  
      return start;
    }
  
<span class="udiff-line-modified-removed">-   // Support for jint atomic::add(jint add_value, volatile jint* dest)</span>
<span class="udiff-line-modified-added">+   // Implementation of jint atomic_add(jint add_value, volatile jint* dest)</span>
<span class="udiff-line-added">+   // used by Atomic::add(volatile jint* dest, jint add_value)</span>
    //
    // Arguments :
    //    c_rarg0: add_value
    //    c_rarg1: dest
    //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -687,11 +691,12 @@</span>
      __ ret(0);
  
      return start;
    }
  
<span class="udiff-line-modified-removed">-   // Support for intptr_t atomic::add_ptr(intptr_t add_value, volatile intptr_t* dest)</span>
<span class="udiff-line-modified-added">+   // Implementation of intptr_t atomic_add(intptr_t add_value, volatile intptr_t* dest)</span>
<span class="udiff-line-added">+   // used by Atomic::add(volatile intptr_t* dest, intptr_t add_value)</span>
    //
    // Arguments :
    //    c_rarg0: add_value
    //    c_rarg1: dest
    //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -977,10 +982,44 @@</span>
      __ emit_data64( mask, relocInfo::none );
  
      return start;
    }
  
<span class="udiff-line-added">+   address generate_vector_mask(const char *stub_name, int64_t mask) {</span>
<span class="udiff-line-added">+     __ align(CodeEntryAlignment);</span>
<span class="udiff-line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, stub_name);</span>
<span class="udiff-line-added">+     address start = __ pc();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ emit_data64(mask, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(mask, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(mask, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(mask, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(mask, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(mask, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(mask, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(mask, relocInfo::none);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return start;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   address generate_vector_byte_perm_mask(const char *stub_name) {</span>
<span class="udiff-line-added">+     __ align(CodeEntryAlignment);</span>
<span class="udiff-line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, stub_name);</span>
<span class="udiff-line-added">+     address start = __ pc();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000001, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000003, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000005, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000007, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000002, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000004, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000006, relocInfo::none);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return start;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // Non-destructive plausibility checks for oops
    //
    // Arguments:
    //    all args on stack!
    //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1092,14 +1131,11 @@</span>
      __ mov(r12, rsp);                               // remember rsp
      __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
      __ andptr(rsp, -16);                            // align stack as required by ABI
      BLOCK_COMMENT(&quot;call MacroAssembler::debug&quot;);
      __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug64)));
<span class="udiff-line-modified-removed">-     __ mov(rsp, r12);                               // restore rsp</span>
<span class="udiff-line-removed">-     __ popa();                                      // pop registers (includes r12)</span>
<span class="udiff-line-removed">-     __ ret(4 * wordSize);                           // pop caller saved stuff</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+     __ hlt();</span>
      return start;
    }
  
    //
    // Verify that a register contains clean 32-bits positive value
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1254,34 +1290,62 @@</span>
      Label L_loop;
      __ align(OptoLoopAlignment);
      if (UseUnalignedLoadStores) {
        Label L_end;
        // Copy 64-bytes per iteration
<span class="udiff-line-removed">-       __ BIND(L_loop);</span>
        if (UseAVX &gt; 2) {
<span class="udiff-line-added">+         Label L_loop_avx512, L_loop_avx2, L_32_byte_head, L_above_threshold, L_below_threshold;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         __ BIND(L_copy_bytes);</span>
<span class="udiff-line-added">+         __ cmpptr(qword_count, (-1 * AVX3Threshold / 8));</span>
<span class="udiff-line-added">+         __ jccb(Assembler::less, L_above_threshold);</span>
<span class="udiff-line-added">+         __ jmpb(L_below_threshold);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         __ bind(L_loop_avx512);</span>
          __ evmovdqul(xmm0, Address(end_from, qword_count, Address::times_8, -56), Assembler::AVX_512bit);
          __ evmovdqul(Address(end_to, qword_count, Address::times_8, -56), xmm0, Assembler::AVX_512bit);
<span class="udiff-line-modified-removed">-       } else if (UseAVX == 2) {</span>
<span class="udiff-line-modified-added">+         __ bind(L_above_threshold);</span>
<span class="udiff-line-added">+         __ addptr(qword_count, 8);</span>
<span class="udiff-line-added">+         __ jcc(Assembler::lessEqual, L_loop_avx512);</span>
<span class="udiff-line-added">+         __ jmpb(L_32_byte_head);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         __ bind(L_loop_avx2);</span>
          __ vmovdqu(xmm0, Address(end_from, qword_count, Address::times_8, -56));
          __ vmovdqu(Address(end_to, qword_count, Address::times_8, -56), xmm0);
          __ vmovdqu(xmm1, Address(end_from, qword_count, Address::times_8, -24));
          __ vmovdqu(Address(end_to, qword_count, Address::times_8, -24), xmm1);
<span class="udiff-line-added">+         __ bind(L_below_threshold);</span>
<span class="udiff-line-added">+         __ addptr(qword_count, 8);</span>
<span class="udiff-line-added">+         __ jcc(Assembler::lessEqual, L_loop_avx2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         __ bind(L_32_byte_head);</span>
<span class="udiff-line-added">+         __ subptr(qword_count, 4);  // sub(8) and add(4)</span>
<span class="udiff-line-added">+         __ jccb(Assembler::greater, L_end);</span>
        } else {
<span class="udiff-line-modified-removed">-         __ movdqu(xmm0, Address(end_from, qword_count, Address::times_8, -56));</span>
<span class="udiff-line-modified-removed">-         __ movdqu(Address(end_to, qword_count, Address::times_8, -56), xmm0);</span>
<span class="udiff-line-modified-removed">-         __ movdqu(xmm1, Address(end_from, qword_count, Address::times_8, -40));</span>
<span class="udiff-line-modified-removed">-         __ movdqu(Address(end_to, qword_count, Address::times_8, -40), xmm1);</span>
<span class="udiff-line-modified-removed">-         __ movdqu(xmm2, Address(end_from, qword_count, Address::times_8, -24));</span>
<span class="udiff-line-modified-removed">-         __ movdqu(Address(end_to, qword_count, Address::times_8, -24), xmm2);</span>
<span class="udiff-line-modified-removed">-         __ movdqu(xmm3, Address(end_from, qword_count, Address::times_8, - 8));</span>
<span class="udiff-line-modified-removed">-         __ movdqu(Address(end_to, qword_count, Address::times_8, - 8), xmm3);</span>
<span class="udiff-line-modified-added">+         __ BIND(L_loop);</span>
<span class="udiff-line-modified-added">+         if (UseAVX == 2) {</span>
<span class="udiff-line-modified-added">+           __ vmovdqu(xmm0, Address(end_from, qword_count, Address::times_8, -56));</span>
<span class="udiff-line-modified-added">+           __ vmovdqu(Address(end_to, qword_count, Address::times_8, -56), xmm0);</span>
<span class="udiff-line-modified-added">+           __ vmovdqu(xmm1, Address(end_from, qword_count, Address::times_8, -24));</span>
<span class="udiff-line-modified-added">+           __ vmovdqu(Address(end_to, qword_count, Address::times_8, -24), xmm1);</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+           __ movdqu(xmm0, Address(end_from, qword_count, Address::times_8, -56));</span>
<span class="udiff-line-added">+           __ movdqu(Address(end_to, qword_count, Address::times_8, -56), xmm0);</span>
<span class="udiff-line-added">+           __ movdqu(xmm1, Address(end_from, qword_count, Address::times_8, -40));</span>
<span class="udiff-line-added">+           __ movdqu(Address(end_to, qword_count, Address::times_8, -40), xmm1);</span>
<span class="udiff-line-added">+           __ movdqu(xmm2, Address(end_from, qword_count, Address::times_8, -24));</span>
<span class="udiff-line-added">+           __ movdqu(Address(end_to, qword_count, Address::times_8, -24), xmm2);</span>
<span class="udiff-line-added">+           __ movdqu(xmm3, Address(end_from, qword_count, Address::times_8, - 8));</span>
<span class="udiff-line-added">+           __ movdqu(Address(end_to, qword_count, Address::times_8, - 8), xmm3);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         __ BIND(L_copy_bytes);</span>
<span class="udiff-line-added">+         __ addptr(qword_count, 8);</span>
<span class="udiff-line-added">+         __ jcc(Assembler::lessEqual, L_loop);</span>
<span class="udiff-line-added">+         __ subptr(qword_count, 4);  // sub(8) and add(4)</span>
<span class="udiff-line-added">+         __ jccb(Assembler::greater, L_end);</span>
        }
<span class="udiff-line-removed">-       __ BIND(L_copy_bytes);</span>
<span class="udiff-line-removed">-       __ addptr(qword_count, 8);</span>
<span class="udiff-line-removed">-       __ jcc(Assembler::lessEqual, L_loop);</span>
<span class="udiff-line-removed">-       __ subptr(qword_count, 4);  // sub(8) and add(4)</span>
<span class="udiff-line-removed">-       __ jccb(Assembler::greater, L_end);</span>
        // Copy trailing 32 bytes
        if (UseAVX &gt;= 2) {
          __ vmovdqu(xmm0, Address(end_from, qword_count, Address::times_8, -24));
          __ vmovdqu(Address(end_to, qword_count, Address::times_8, -24), xmm0);
        } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1334,35 +1398,63 @@</span>
      Label L_loop;
      __ align(OptoLoopAlignment);
      if (UseUnalignedLoadStores) {
        Label L_end;
        // Copy 64-bytes per iteration
<span class="udiff-line-removed">-       __ BIND(L_loop);</span>
        if (UseAVX &gt; 2) {
<span class="udiff-line-added">+         Label L_loop_avx512, L_loop_avx2, L_32_byte_head, L_above_threshold, L_below_threshold;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         __ BIND(L_copy_bytes);</span>
<span class="udiff-line-added">+         __ cmpptr(qword_count, (AVX3Threshold / 8));</span>
<span class="udiff-line-added">+         __ jccb(Assembler::greater, L_above_threshold);</span>
<span class="udiff-line-added">+         __ jmpb(L_below_threshold);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         __ BIND(L_loop_avx512);</span>
          __ evmovdqul(xmm0, Address(from, qword_count, Address::times_8, 0), Assembler::AVX_512bit);
          __ evmovdqul(Address(dest, qword_count, Address::times_8, 0), xmm0, Assembler::AVX_512bit);
<span class="udiff-line-modified-removed">-       } else if (UseAVX == 2) {</span>
<span class="udiff-line-modified-added">+         __ bind(L_above_threshold);</span>
<span class="udiff-line-added">+         __ subptr(qword_count, 8);</span>
<span class="udiff-line-added">+         __ jcc(Assembler::greaterEqual, L_loop_avx512);</span>
<span class="udiff-line-added">+         __ jmpb(L_32_byte_head);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         __ bind(L_loop_avx2);</span>
          __ vmovdqu(xmm0, Address(from, qword_count, Address::times_8, 32));
          __ vmovdqu(Address(dest, qword_count, Address::times_8, 32), xmm0);
<span class="udiff-line-modified-removed">-         __ vmovdqu(xmm1, Address(from, qword_count, Address::times_8,  0));</span>
<span class="udiff-line-modified-removed">-         __ vmovdqu(Address(dest, qword_count, Address::times_8,  0), xmm1);</span>
<span class="udiff-line-modified-added">+         __ vmovdqu(xmm1, Address(from, qword_count, Address::times_8, 0));</span>
<span class="udiff-line-modified-added">+         __ vmovdqu(Address(dest, qword_count, Address::times_8, 0), xmm1);</span>
<span class="udiff-line-added">+         __ bind(L_below_threshold);</span>
<span class="udiff-line-added">+         __ subptr(qword_count, 8);</span>
<span class="udiff-line-added">+         __ jcc(Assembler::greaterEqual, L_loop_avx2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         __ bind(L_32_byte_head);</span>
<span class="udiff-line-added">+         __ addptr(qword_count, 4);  // add(8) and sub(4)</span>
<span class="udiff-line-added">+         __ jccb(Assembler::less, L_end);</span>
        } else {
<span class="udiff-line-modified-removed">-         __ movdqu(xmm0, Address(from, qword_count, Address::times_8, 48));</span>
<span class="udiff-line-modified-removed">-         __ movdqu(Address(dest, qword_count, Address::times_8, 48), xmm0);</span>
<span class="udiff-line-modified-removed">-         __ movdqu(xmm1, Address(from, qword_count, Address::times_8, 32));</span>
<span class="udiff-line-modified-removed">-         __ movdqu(Address(dest, qword_count, Address::times_8, 32), xmm1);</span>
<span class="udiff-line-modified-removed">-         __ movdqu(xmm2, Address(from, qword_count, Address::times_8, 16));</span>
<span class="udiff-line-modified-removed">-         __ movdqu(Address(dest, qword_count, Address::times_8, 16), xmm2);</span>
<span class="udiff-line-modified-removed">-         __ movdqu(xmm3, Address(from, qword_count, Address::times_8,  0));</span>
<span class="udiff-line-modified-removed">-         __ movdqu(Address(dest, qword_count, Address::times_8,  0), xmm3);</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-removed">-       __ BIND(L_copy_bytes);</span>
<span class="udiff-line-modified-removed">-       __ subptr(qword_count, 8);</span>
<span class="udiff-line-modified-removed">-       __ jcc(Assembler::greaterEqual, L_loop);</span>
<span class="udiff-line-modified-added">+         __ BIND(L_loop);</span>
<span class="udiff-line-modified-added">+         if (UseAVX == 2) {</span>
<span class="udiff-line-modified-added">+           __ vmovdqu(xmm0, Address(from, qword_count, Address::times_8, 32));</span>
<span class="udiff-line-modified-added">+           __ vmovdqu(Address(dest, qword_count, Address::times_8, 32), xmm0);</span>
<span class="udiff-line-modified-added">+           __ vmovdqu(xmm1, Address(from, qword_count, Address::times_8,  0));</span>
<span class="udiff-line-modified-added">+           __ vmovdqu(Address(dest, qword_count, Address::times_8,  0), xmm1);</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+           __ movdqu(xmm0, Address(from, qword_count, Address::times_8, 48));</span>
<span class="udiff-line-modified-added">+           __ movdqu(Address(dest, qword_count, Address::times_8, 48), xmm0);</span>
<span class="udiff-line-modified-added">+           __ movdqu(xmm1, Address(from, qword_count, Address::times_8, 32));</span>
<span class="udiff-line-modified-added">+           __ movdqu(Address(dest, qword_count, Address::times_8, 32), xmm1);</span>
<span class="udiff-line-modified-added">+           __ movdqu(xmm2, Address(from, qword_count, Address::times_8, 16));</span>
<span class="udiff-line-added">+           __ movdqu(Address(dest, qword_count, Address::times_8, 16), xmm2);</span>
<span class="udiff-line-added">+           __ movdqu(xmm3, Address(from, qword_count, Address::times_8,  0));</span>
<span class="udiff-line-added">+           __ movdqu(Address(dest, qword_count, Address::times_8,  0), xmm3);</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-       __ addptr(qword_count, 4);  // add(8) and sub(4)</span>
<span class="udiff-line-modified-removed">-       __ jccb(Assembler::less, L_end);</span>
<span class="udiff-line-modified-added">+         __ BIND(L_copy_bytes);</span>
<span class="udiff-line-modified-added">+         __ subptr(qword_count, 8);</span>
<span class="udiff-line-added">+         __ jcc(Assembler::greaterEqual, L_loop);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         __ addptr(qword_count, 4);  // add(8) and sub(4)</span>
<span class="udiff-line-added">+         __ jccb(Assembler::less, L_end);</span>
<span class="udiff-line-added">+       }</span>
        // Copy trailing 32 bytes
        if (UseAVX &gt;= 2) {
          __ vmovdqu(xmm0, Address(from, qword_count, Address::times_8, 0));
          __ vmovdqu(Address(dest, qword_count, Address::times_8, 0), xmm0);
        } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1396,11 +1488,10 @@</span>
      }
      __ addptr(qword_count, 4);
      __ jcc(Assembler::greater, L_copy_8_bytes); // Copy trailing qwords
    }
  
<span class="udiff-line-removed">- </span>
    // Arguments:
    //   aligned - true =&gt; Input and output aligned on a HeapWord == 8-byte boundary
    //             ignored
    //   name    - stub name string
    //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1445,66 +1536,72 @@</span>
      }
  
      setup_arg_regs(); // from =&gt; rdi, to =&gt; rsi, count =&gt; rdx
                        // r9 and r10 may be used to save non-volatile registers
  
<span class="udiff-line-modified-removed">-     // &#39;from&#39;, &#39;to&#39; and &#39;count&#39; are now valid</span>
<span class="udiff-line-modified-removed">-     __ movptr(byte_count, count);</span>
<span class="udiff-line-modified-removed">-     __ shrptr(count, 3); // count =&gt; qword_count</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy from low to high addresses.  Use &#39;to&#39; as scratch.</span>
<span class="udiff-line-modified-removed">-     __ lea(end_from, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-removed">-     __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-removed">-     __ negptr(qword_count); // make the count negative</span>
<span class="udiff-line-modified-removed">-     __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy trailing qwords</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));</span>
<span class="udiff-line-modified-removed">-     __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);</span>
<span class="udiff-line-modified-removed">-     __ increment(qword_count);</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Check for and copy trailing dword</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_4_bytes);</span>
<span class="udiff-line-modified-removed">-     __ testl(byte_count, 4);</span>
<span class="udiff-line-modified-removed">-     __ jccb(Assembler::zero, L_copy_2_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movl(rax, Address(end_from, 8));</span>
<span class="udiff-line-modified-removed">-     __ movl(Address(end_to, 8), rax);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     __ addptr(end_from, 4);</span>
<span class="udiff-line-modified-removed">-     __ addptr(end_to, 4);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Check for and copy trailing word</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_2_bytes);</span>
<span class="udiff-line-modified-removed">-     __ testl(byte_count, 2);</span>
<span class="udiff-line-modified-removed">-     __ jccb(Assembler::zero, L_copy_byte);</span>
<span class="udiff-line-modified-removed">-     __ movw(rax, Address(end_from, 8));</span>
<span class="udiff-line-modified-removed">-     __ movw(Address(end_to, 8), rax);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     __ addptr(end_from, 2);</span>
<span class="udiff-line-modified-removed">-     __ addptr(end_to, 2);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Check for and copy trailing byte</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_byte);</span>
<span class="udiff-line-modified-removed">-     __ testl(byte_count, 1);</span>
<span class="udiff-line-modified-removed">-     __ jccb(Assembler::zero, L_exit);</span>
<span class="udiff-line-modified-removed">-     __ movb(rax, Address(end_from, 8));</span>
<span class="udiff-line-modified-removed">-     __ movb(Address(end_to, 8), rax);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-modified-added">+       UnsafeCopyMemoryMark ucmm(this, !aligned, true);</span>
<span class="udiff-line-modified-added">+       // &#39;from&#39;, &#39;to&#39; and &#39;count&#39; are now valid</span>
<span class="udiff-line-modified-added">+       __ movptr(byte_count, count);</span>
<span class="udiff-line-modified-added">+       __ shrptr(count, 3); // count =&gt; qword_count</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy from low to high addresses.  Use &#39;to&#39; as scratch.</span>
<span class="udiff-line-modified-added">+       __ lea(end_from, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-added">+       __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-added">+       __ negptr(qword_count); // make the count negative</span>
<span class="udiff-line-modified-added">+       __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy trailing qwords</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+       __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));</span>
<span class="udiff-line-modified-added">+       __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);</span>
<span class="udiff-line-modified-added">+       __ increment(qword_count);</span>
<span class="udiff-line-modified-added">+       __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Check for and copy trailing dword</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_4_bytes);</span>
<span class="udiff-line-modified-added">+       __ testl(byte_count, 4);</span>
<span class="udiff-line-modified-added">+       __ jccb(Assembler::zero, L_copy_2_bytes);</span>
<span class="udiff-line-modified-added">+       __ movl(rax, Address(end_from, 8));</span>
<span class="udiff-line-modified-added">+       __ movl(Address(end_to, 8), rax);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       __ addptr(end_from, 4);</span>
<span class="udiff-line-modified-added">+       __ addptr(end_to, 4);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Check for and copy trailing word</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_2_bytes);</span>
<span class="udiff-line-modified-added">+       __ testl(byte_count, 2);</span>
<span class="udiff-line-modified-added">+       __ jccb(Assembler::zero, L_copy_byte);</span>
<span class="udiff-line-modified-added">+       __ movw(rax, Address(end_from, 8));</span>
<span class="udiff-line-modified-added">+       __ movw(Address(end_to, 8), rax);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       __ addptr(end_from, 2);</span>
<span class="udiff-line-modified-added">+       __ addptr(end_to, 2);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Check for and copy trailing byte</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_byte);</span>
<span class="udiff-line-modified-added">+       __ testl(byte_count, 1);</span>
<span class="udiff-line-modified-added">+       __ jccb(Assembler::zero, L_exit);</span>
<span class="udiff-line-added">+       __ movb(rax, Address(end_from, 8));</span>
<span class="udiff-line-added">+       __ movb(Address(end_to, 8), rax);</span>
<span class="udiff-line-added">+     }</span>
    __ BIND(L_exit);
<span class="udiff-line-added">+     address ucme_exit_pc = __ pc();</span>
      restore_arg_regs();
      inc_counter_np(SharedRuntime::_jbyte_array_copy_ctr); // Update counter after rscratch1 is free
      __ xorptr(rax, rax); // return 0
      __ vzeroupper();
      __ leave(); // required for proper stackwalking of RuntimeStub frame
      __ ret(0);
  
<span class="udiff-line-modified-removed">-     // Copy in multi-bytes chunks</span>
<span class="udiff-line-modified-removed">-     copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">-     __ jmp(L_copy_4_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       UnsafeCopyMemoryMark ucmm(this, !aligned, false, ucme_exit_pc);</span>
<span class="udiff-line-modified-added">+       // Copy in multi-bytes chunks</span>
<span class="udiff-line-modified-added">+       copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-added">+       __ jmp(L_copy_4_bytes);</span>
<span class="udiff-line-added">+     }</span>
      return start;
    }
  
    // Arguments:
    //   aligned - true =&gt; Input and output aligned on a HeapWord == 8-byte boundary
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1545,55 +1642,61 @@</span>
  
      array_overlap_test(nooverlap_target, Address::times_1);
      setup_arg_regs(); // from =&gt; rdi, to =&gt; rsi, count =&gt; rdx
                        // r9 and r10 may be used to save non-volatile registers
  
<span class="udiff-line-modified-removed">-     // &#39;from&#39;, &#39;to&#39; and &#39;count&#39; are now valid</span>
<span class="udiff-line-modified-removed">-     __ movptr(byte_count, count);</span>
<span class="udiff-line-modified-removed">-     __ shrptr(count, 3);   // count =&gt; qword_count</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy from high to low addresses.</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Check for and copy trailing byte</span>
<span class="udiff-line-modified-removed">-     __ testl(byte_count, 1);</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::zero, L_copy_2_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movb(rax, Address(from, byte_count, Address::times_1, -1));</span>
<span class="udiff-line-modified-removed">-     __ movb(Address(to, byte_count, Address::times_1, -1), rax);</span>
<span class="udiff-line-modified-removed">-     __ decrement(byte_count); // Adjust for possible trailing word</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Check for and copy trailing word</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_2_bytes);</span>
<span class="udiff-line-modified-removed">-     __ testl(byte_count, 2);</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::zero, L_copy_4_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movw(rax, Address(from, byte_count, Address::times_1, -2));</span>
<span class="udiff-line-modified-removed">-     __ movw(Address(to, byte_count, Address::times_1, -2), rax);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Check for and copy trailing dword</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_4_bytes);</span>
<span class="udiff-line-modified-removed">-     __ testl(byte_count, 4);</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::zero, L_copy_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movl(rax, Address(from, qword_count, Address::times_8));</span>
<span class="udiff-line-modified-removed">-     __ movl(Address(to, qword_count, Address::times_8), rax);</span>
<span class="udiff-line-modified-removed">-     __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy trailing qwords</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movq(rax, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-removed">-     __ movq(Address(to, qword_count, Address::times_8, -8), rax);</span>
<span class="udiff-line-modified-removed">-     __ decrement(qword_count);</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-modified-added">+       UnsafeCopyMemoryMark ucmm(this, !aligned, true);</span>
<span class="udiff-line-modified-added">+       // &#39;from&#39;, &#39;to&#39; and &#39;count&#39; are now valid</span>
<span class="udiff-line-modified-added">+       __ movptr(byte_count, count);</span>
<span class="udiff-line-modified-added">+       __ shrptr(count, 3);   // count =&gt; qword_count</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy from high to low addresses.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Check for and copy trailing byte</span>
<span class="udiff-line-modified-added">+       __ testl(byte_count, 1);</span>
<span class="udiff-line-modified-added">+       __ jcc(Assembler::zero, L_copy_2_bytes);</span>
<span class="udiff-line-modified-added">+       __ movb(rax, Address(from, byte_count, Address::times_1, -1));</span>
<span class="udiff-line-modified-added">+       __ movb(Address(to, byte_count, Address::times_1, -1), rax);</span>
<span class="udiff-line-modified-added">+       __ decrement(byte_count); // Adjust for possible trailing word</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Check for and copy trailing word</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_2_bytes);</span>
<span class="udiff-line-modified-added">+       __ testl(byte_count, 2);</span>
<span class="udiff-line-modified-added">+       __ jcc(Assembler::zero, L_copy_4_bytes);</span>
<span class="udiff-line-modified-added">+       __ movw(rax, Address(from, byte_count, Address::times_1, -2));</span>
<span class="udiff-line-modified-added">+       __ movw(Address(to, byte_count, Address::times_1, -2), rax);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Check for and copy trailing dword</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_4_bytes);</span>
<span class="udiff-line-modified-added">+       __ testl(byte_count, 4);</span>
<span class="udiff-line-modified-added">+       __ jcc(Assembler::zero, L_copy_bytes);</span>
<span class="udiff-line-modified-added">+       __ movl(rax, Address(from, qword_count, Address::times_8));</span>
<span class="udiff-line-modified-added">+       __ movl(Address(to, qword_count, Address::times_8), rax);</span>
<span class="udiff-line-modified-added">+       __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy trailing qwords</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+       __ movq(rax, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-added">+       __ movq(Address(to, qword_count, Address::times_8, -8), rax);</span>
<span class="udiff-line-added">+       __ decrement(qword_count);</span>
<span class="udiff-line-added">+       __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-added">+     }</span>
      restore_arg_regs();
      inc_counter_np(SharedRuntime::_jbyte_array_copy_ctr); // Update counter after rscratch1 is free
      __ xorptr(rax, rax); // return 0
      __ vzeroupper();
      __ leave(); // required for proper stackwalking of RuntimeStub frame
      __ ret(0);
  
<span class="udiff-line-modified-removed">-     // Copy in multi-bytes chunks</span>
<span class="udiff-line-modified-removed">-     copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-modified-added">+       UnsafeCopyMemoryMark ucmm(this, !aligned, true);</span>
<span class="udiff-line-added">+       // Copy in multi-bytes chunks</span>
<span class="udiff-line-added">+       copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-added">+     }</span>
      restore_arg_regs();
      inc_counter_np(SharedRuntime::_jbyte_array_copy_ctr); // Update counter after rscratch1 is free
      __ xorptr(rax, rax); // return 0
      __ vzeroupper();
      __ leave(); // required for proper stackwalking of RuntimeStub frame
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1647,58 +1750,65 @@</span>
      }
  
      setup_arg_regs(); // from =&gt; rdi, to =&gt; rsi, count =&gt; rdx
                        // r9 and r10 may be used to save non-volatile registers
  
<span class="udiff-line-modified-removed">-     // &#39;from&#39;, &#39;to&#39; and &#39;count&#39; are now valid</span>
<span class="udiff-line-modified-removed">-     __ movptr(word_count, count);</span>
<span class="udiff-line-modified-removed">-     __ shrptr(count, 2); // count =&gt; qword_count</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy from low to high addresses.  Use &#39;to&#39; as scratch.</span>
<span class="udiff-line-modified-removed">-     __ lea(end_from, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-removed">-     __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-removed">-     __ negptr(qword_count);</span>
<span class="udiff-line-modified-removed">-     __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy trailing qwords</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));</span>
<span class="udiff-line-modified-removed">-     __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);</span>
<span class="udiff-line-modified-removed">-     __ increment(qword_count);</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Original &#39;dest&#39; is trashed, so we can&#39;t use it as a</span>
<span class="udiff-line-modified-removed">-     // base register for a possible trailing word copy</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Check for and copy trailing dword</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_4_bytes);</span>
<span class="udiff-line-modified-removed">-     __ testl(word_count, 2);</span>
<span class="udiff-line-modified-removed">-     __ jccb(Assembler::zero, L_copy_2_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movl(rax, Address(end_from, 8));</span>
<span class="udiff-line-modified-removed">-     __ movl(Address(end_to, 8), rax);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     __ addptr(end_from, 4);</span>
<span class="udiff-line-modified-removed">-     __ addptr(end_to, 4);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Check for and copy trailing word</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_2_bytes);</span>
<span class="udiff-line-modified-removed">-     __ testl(word_count, 1);</span>
<span class="udiff-line-modified-removed">-     __ jccb(Assembler::zero, L_exit);</span>
<span class="udiff-line-modified-removed">-     __ movw(rax, Address(end_from, 8));</span>
<span class="udiff-line-modified-removed">-     __ movw(Address(end_to, 8), rax);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-modified-added">+       UnsafeCopyMemoryMark ucmm(this, !aligned, true);</span>
<span class="udiff-line-modified-added">+       // &#39;from&#39;, &#39;to&#39; and &#39;count&#39; are now valid</span>
<span class="udiff-line-modified-added">+       __ movptr(word_count, count);</span>
<span class="udiff-line-modified-added">+       __ shrptr(count, 2); // count =&gt; qword_count</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy from low to high addresses.  Use &#39;to&#39; as scratch.</span>
<span class="udiff-line-modified-added">+       __ lea(end_from, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-added">+       __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-added">+       __ negptr(qword_count);</span>
<span class="udiff-line-modified-added">+       __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy trailing qwords</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+       __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));</span>
<span class="udiff-line-modified-added">+       __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);</span>
<span class="udiff-line-modified-added">+       __ increment(qword_count);</span>
<span class="udiff-line-modified-added">+       __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Original &#39;dest&#39; is trashed, so we can&#39;t use it as a</span>
<span class="udiff-line-modified-added">+       // base register for a possible trailing word copy</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Check for and copy trailing dword</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_4_bytes);</span>
<span class="udiff-line-modified-added">+       __ testl(word_count, 2);</span>
<span class="udiff-line-modified-added">+       __ jccb(Assembler::zero, L_copy_2_bytes);</span>
<span class="udiff-line-modified-added">+       __ movl(rax, Address(end_from, 8));</span>
<span class="udiff-line-modified-added">+       __ movl(Address(end_to, 8), rax);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       __ addptr(end_from, 4);</span>
<span class="udiff-line-modified-added">+       __ addptr(end_to, 4);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Check for and copy trailing word</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_2_bytes);</span>
<span class="udiff-line-modified-added">+       __ testl(word_count, 1);</span>
<span class="udiff-line-modified-added">+       __ jccb(Assembler::zero, L_exit);</span>
<span class="udiff-line-added">+       __ movw(rax, Address(end_from, 8));</span>
<span class="udiff-line-added">+       __ movw(Address(end_to, 8), rax);</span>
<span class="udiff-line-added">+     }</span>
    __ BIND(L_exit);
<span class="udiff-line-added">+     address ucme_exit_pc = __ pc();</span>
      restore_arg_regs();
      inc_counter_np(SharedRuntime::_jshort_array_copy_ctr); // Update counter after rscratch1 is free
      __ xorptr(rax, rax); // return 0
      __ vzeroupper();
      __ leave(); // required for proper stackwalking of RuntimeStub frame
      __ ret(0);
  
<span class="udiff-line-modified-removed">-     // Copy in multi-bytes chunks</span>
<span class="udiff-line-modified-removed">-     copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">-     __ jmp(L_copy_4_bytes);</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       UnsafeCopyMemoryMark ucmm(this, !aligned, false, ucme_exit_pc);</span>
<span class="udiff-line-modified-added">+       // Copy in multi-bytes chunks</span>
<span class="udiff-line-added">+       copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-added">+       __ jmp(L_copy_4_bytes);</span>
<span class="udiff-line-added">+     }</span>
  
      return start;
    }
  
    address generate_fill(BasicType t, bool aligned, const char *name) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1761,47 +1871,53 @@</span>
  
      array_overlap_test(nooverlap_target, Address::times_2);
      setup_arg_regs(); // from =&gt; rdi, to =&gt; rsi, count =&gt; rdx
                        // r9 and r10 may be used to save non-volatile registers
  
<span class="udiff-line-modified-removed">-     // &#39;from&#39;, &#39;to&#39; and &#39;count&#39; are now valid</span>
<span class="udiff-line-modified-removed">-     __ movptr(word_count, count);</span>
<span class="udiff-line-modified-removed">-     __ shrptr(count, 2); // count =&gt; qword_count</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy from high to low addresses.  Use &#39;to&#39; as scratch.</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Check for and copy trailing word</span>
<span class="udiff-line-modified-removed">-     __ testl(word_count, 1);</span>
<span class="udiff-line-modified-removed">-     __ jccb(Assembler::zero, L_copy_4_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movw(rax, Address(from, word_count, Address::times_2, -2));</span>
<span class="udiff-line-modified-removed">-     __ movw(Address(to, word_count, Address::times_2, -2), rax);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Check for and copy trailing dword</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_4_bytes);</span>
<span class="udiff-line-modified-removed">-     __ testl(word_count, 2);</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::zero, L_copy_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movl(rax, Address(from, qword_count, Address::times_8));</span>
<span class="udiff-line-modified-removed">-     __ movl(Address(to, qword_count, Address::times_8), rax);</span>
<span class="udiff-line-modified-removed">-     __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy trailing qwords</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movq(rax, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-removed">-     __ movq(Address(to, qword_count, Address::times_8, -8), rax);</span>
<span class="udiff-line-modified-removed">-     __ decrement(qword_count);</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-modified-added">+       UnsafeCopyMemoryMark ucmm(this, !aligned, true);</span>
<span class="udiff-line-modified-added">+       // &#39;from&#39;, &#39;to&#39; and &#39;count&#39; are now valid</span>
<span class="udiff-line-modified-added">+       __ movptr(word_count, count);</span>
<span class="udiff-line-modified-added">+       __ shrptr(count, 2); // count =&gt; qword_count</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy from high to low addresses.  Use &#39;to&#39; as scratch.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Check for and copy trailing word</span>
<span class="udiff-line-modified-added">+       __ testl(word_count, 1);</span>
<span class="udiff-line-modified-added">+       __ jccb(Assembler::zero, L_copy_4_bytes);</span>
<span class="udiff-line-modified-added">+       __ movw(rax, Address(from, word_count, Address::times_2, -2));</span>
<span class="udiff-line-modified-added">+       __ movw(Address(to, word_count, Address::times_2, -2), rax);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+      // Check for and copy trailing dword</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_4_bytes);</span>
<span class="udiff-line-modified-added">+       __ testl(word_count, 2);</span>
<span class="udiff-line-modified-added">+       __ jcc(Assembler::zero, L_copy_bytes);</span>
<span class="udiff-line-modified-added">+       __ movl(rax, Address(from, qword_count, Address::times_8));</span>
<span class="udiff-line-modified-added">+       __ movl(Address(to, qword_count, Address::times_8), rax);</span>
<span class="udiff-line-modified-added">+       __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy trailing qwords</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+       __ movq(rax, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-added">+       __ movq(Address(to, qword_count, Address::times_8, -8), rax);</span>
<span class="udiff-line-added">+       __ decrement(qword_count);</span>
<span class="udiff-line-added">+       __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-added">+     }</span>
      restore_arg_regs();
      inc_counter_np(SharedRuntime::_jshort_array_copy_ctr); // Update counter after rscratch1 is free
      __ xorptr(rax, rax); // return 0
      __ vzeroupper();
      __ leave(); // required for proper stackwalking of RuntimeStub frame
      __ ret(0);
  
<span class="udiff-line-modified-removed">-     // Copy in multi-bytes chunks</span>
<span class="udiff-line-modified-removed">-     copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-modified-added">+       UnsafeCopyMemoryMark ucmm(this, !aligned, true);</span>
<span class="udiff-line-added">+       // Copy in multi-bytes chunks</span>
<span class="udiff-line-added">+       copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-added">+     }</span>
      restore_arg_regs();
      inc_counter_np(SharedRuntime::_jshort_array_copy_ctr); // Update counter after rscratch1 is free
      __ xorptr(rax, rax); // return 0
      __ vzeroupper();
      __ leave(); // required for proper stackwalking of RuntimeStub frame
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1868,46 +1984,53 @@</span>
  
      BasicType type = is_oop ? T_OBJECT : T_INT;
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
      bs-&gt;arraycopy_prologue(_masm, decorators, type, from, to, count);
  
<span class="udiff-line-modified-removed">-     // &#39;from&#39;, &#39;to&#39; and &#39;count&#39; are now valid</span>
<span class="udiff-line-modified-removed">-     __ movptr(dword_count, count);</span>
<span class="udiff-line-modified-removed">-     __ shrptr(count, 1); // count =&gt; qword_count</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy from low to high addresses.  Use &#39;to&#39; as scratch.</span>
<span class="udiff-line-modified-removed">-     __ lea(end_from, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-removed">-     __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-removed">-     __ negptr(qword_count);</span>
<span class="udiff-line-modified-removed">-     __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy trailing qwords</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));</span>
<span class="udiff-line-modified-removed">-     __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);</span>
<span class="udiff-line-modified-removed">-     __ increment(qword_count);</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Check for and copy trailing dword</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_4_bytes);</span>
<span class="udiff-line-modified-removed">-     __ testl(dword_count, 1); // Only byte test since the value is 0 or 1</span>
<span class="udiff-line-modified-removed">-     __ jccb(Assembler::zero, L_exit);</span>
<span class="udiff-line-modified-removed">-     __ movl(rax, Address(end_from, 8));</span>
<span class="udiff-line-modified-removed">-     __ movl(Address(end_to, 8), rax);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-modified-added">+       UnsafeCopyMemoryMark ucmm(this, !is_oop &amp;&amp; !aligned, true);</span>
<span class="udiff-line-modified-added">+       // &#39;from&#39;, &#39;to&#39; and &#39;count&#39; are now valid</span>
<span class="udiff-line-modified-added">+       __ movptr(dword_count, count);</span>
<span class="udiff-line-modified-added">+       __ shrptr(count, 1); // count =&gt; qword_count</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy from low to high addresses.  Use &#39;to&#39; as scratch.</span>
<span class="udiff-line-modified-added">+       __ lea(end_from, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-added">+       __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-added">+       __ negptr(qword_count);</span>
<span class="udiff-line-modified-added">+       __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy trailing qwords</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+       __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));</span>
<span class="udiff-line-modified-added">+       __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);</span>
<span class="udiff-line-modified-added">+       __ increment(qword_count);</span>
<span class="udiff-line-modified-added">+       __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Check for and copy trailing dword</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_4_bytes);</span>
<span class="udiff-line-modified-added">+       __ testl(dword_count, 1); // Only byte test since the value is 0 or 1</span>
<span class="udiff-line-modified-added">+       __ jccb(Assembler::zero, L_exit);</span>
<span class="udiff-line-added">+       __ movl(rax, Address(end_from, 8));</span>
<span class="udiff-line-added">+       __ movl(Address(end_to, 8), rax);</span>
<span class="udiff-line-added">+     }</span>
    __ BIND(L_exit);
<span class="udiff-line-added">+     address ucme_exit_pc = __ pc();</span>
      bs-&gt;arraycopy_epilogue(_masm, decorators, type, from, to, dword_count);
      restore_arg_regs_using_thread();
      inc_counter_np(SharedRuntime::_jint_array_copy_ctr); // Update counter after rscratch1 is free
      __ vzeroupper();
      __ xorptr(rax, rax); // return 0
      __ leave(); // required for proper stackwalking of RuntimeStub frame
      __ ret(0);
  
<span class="udiff-line-modified-removed">-     // Copy in multi-bytes chunks</span>
<span class="udiff-line-modified-removed">-     copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">-     __ jmp(L_copy_4_bytes);</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       UnsafeCopyMemoryMark ucmm(this, !is_oop &amp;&amp; !aligned, false, ucme_exit_pc);</span>
<span class="udiff-line-modified-added">+       // Copy in multi-bytes chunks</span>
<span class="udiff-line-added">+       copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-added">+       __ jmp(L_copy_4_bytes);</span>
<span class="udiff-line-added">+     }</span>
  
      return start;
    }
  
    // Arguments:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1964,42 +2087,49 @@</span>
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
      // no registers are destroyed by this call
      bs-&gt;arraycopy_prologue(_masm, decorators, type, from, to, count);
  
      assert_clean_int(count, rax); // Make sure &#39;count&#39; is clean int.
<span class="udiff-line-modified-removed">-     // &#39;from&#39;, &#39;to&#39; and &#39;count&#39; are now valid</span>
<span class="udiff-line-modified-removed">-     __ movptr(dword_count, count);</span>
<span class="udiff-line-modified-removed">-     __ shrptr(count, 1); // count =&gt; qword_count</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy from high to low addresses.  Use &#39;to&#39; as scratch.</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Check for and copy trailing dword</span>
<span class="udiff-line-modified-removed">-     __ testl(dword_count, 1);</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::zero, L_copy_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movl(rax, Address(from, dword_count, Address::times_4, -4));</span>
<span class="udiff-line-modified-removed">-     __ movl(Address(to, dword_count, Address::times_4, -4), rax);</span>
<span class="udiff-line-modified-removed">-     __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy trailing qwords</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movq(rax, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-removed">-     __ movq(Address(to, qword_count, Address::times_8, -8), rax);</span>
<span class="udiff-line-modified-removed">-     __ decrement(qword_count);</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-modified-added">+       UnsafeCopyMemoryMark ucmm(this, !is_oop &amp;&amp; !aligned, true);</span>
<span class="udiff-line-modified-added">+       // &#39;from&#39;, &#39;to&#39; and &#39;count&#39; are now valid</span>
<span class="udiff-line-modified-added">+       __ movptr(dword_count, count);</span>
<span class="udiff-line-modified-added">+       __ shrptr(count, 1); // count =&gt; qword_count</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy from high to low addresses.  Use &#39;to&#39; as scratch.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Check for and copy trailing dword</span>
<span class="udiff-line-modified-added">+       __ testl(dword_count, 1);</span>
<span class="udiff-line-modified-added">+       __ jcc(Assembler::zero, L_copy_bytes);</span>
<span class="udiff-line-modified-added">+       __ movl(rax, Address(from, dword_count, Address::times_4, -4));</span>
<span class="udiff-line-modified-added">+       __ movl(Address(to, dword_count, Address::times_4, -4), rax);</span>
<span class="udiff-line-modified-added">+       __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy trailing qwords</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+       __ movq(rax, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-added">+       __ movq(Address(to, qword_count, Address::times_8, -8), rax);</span>
<span class="udiff-line-added">+       __ decrement(qword_count);</span>
<span class="udiff-line-added">+       __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-added">+     }</span>
      if (is_oop) {
        __ jmp(L_exit);
      }
      restore_arg_regs_using_thread();
      inc_counter_np(SharedRuntime::_jint_array_copy_ctr); // Update counter after rscratch1 is free
      __ xorptr(rax, rax); // return 0
      __ vzeroupper();
      __ leave(); // required for proper stackwalking of RuntimeStub frame
      __ ret(0);
  
<span class="udiff-line-modified-removed">-     // Copy in multi-bytes chunks</span>
<span class="udiff-line-modified-removed">-     copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-added">+       UnsafeCopyMemoryMark ucmm(this, !is_oop &amp;&amp; !aligned, true);</span>
<span class="udiff-line-added">+       // Copy in multi-bytes chunks</span>
<span class="udiff-line-added">+       copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-added">+     }</span>
  
    __ BIND(L_exit);
      bs-&gt;arraycopy_epilogue(_masm, decorators, type, from, to, dword_count);
      restore_arg_regs_using_thread();
      inc_counter_np(SharedRuntime::_jint_array_copy_ctr); // Update counter after rscratch1 is free
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2065,24 +2195,27 @@</span>
      }
  
      BasicType type = is_oop ? T_OBJECT : T_LONG;
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
      bs-&gt;arraycopy_prologue(_masm, decorators, type, from, to, qword_count);
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy from low to high addresses.  Use &#39;to&#39; as scratch.</span>
<span class="udiff-line-modified-removed">-     __ lea(end_from, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-removed">-     __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-removed">-     __ negptr(qword_count);</span>
<span class="udiff-line-modified-removed">-     __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Copy trailing qwords</span>
<span class="udiff-line-modified-removed">-   __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">-     __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));</span>
<span class="udiff-line-modified-removed">-     __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);</span>
<span class="udiff-line-modified-removed">-     __ increment(qword_count);</span>
<span class="udiff-line-modified-removed">-     __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-modified-added">+       UnsafeCopyMemoryMark ucmm(this, !is_oop &amp;&amp; !aligned, true);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy from low to high addresses.  Use &#39;to&#39; as scratch.</span>
<span class="udiff-line-modified-added">+       __ lea(end_from, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-added">+       __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));</span>
<span class="udiff-line-modified-added">+       __ negptr(qword_count);</span>
<span class="udiff-line-modified-added">+       __ jmp(L_copy_bytes);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       // Copy trailing qwords</span>
<span class="udiff-line-modified-added">+     __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+       __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));</span>
<span class="udiff-line-modified-added">+       __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);</span>
<span class="udiff-line-added">+       __ increment(qword_count);</span>
<span class="udiff-line-added">+       __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-added">+     }</span>
      if (is_oop) {
        __ jmp(L_exit);
      } else {
        restore_arg_regs_using_thread();
        inc_counter_np(SharedRuntime::_jlong_array_copy_ctr); // Update counter after rscratch1 is free
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2090,12 +2223,16 @@</span>
        __ vzeroupper();
        __ leave(); // required for proper stackwalking of RuntimeStub frame
        __ ret(0);
      }
  
<span class="udiff-line-modified-removed">-     // Copy in multi-bytes chunks</span>
<span class="udiff-line-modified-removed">-     copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-added">+       UnsafeCopyMemoryMark ucmm(this, !is_oop &amp;&amp; !aligned, true);</span>
<span class="udiff-line-added">+       // Copy in multi-bytes chunks</span>
<span class="udiff-line-added">+       copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-added">+     }</span>
  
      __ BIND(L_exit);
      bs-&gt;arraycopy_epilogue(_masm, decorators, type, from, to, qword_count);
      restore_arg_regs_using_thread();
      if (is_oop) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2147,45 +2284,51 @@</span>
      array_overlap_test(nooverlap_target, Address::times_8);
      setup_arg_regs_using_thread(); // from =&gt; rdi, to =&gt; rsi, count =&gt; rdx
                                     // r9 is used to save r15_thread
      // &#39;from&#39;, &#39;to&#39; and &#39;qword_count&#39; are now valid
  
<span class="udiff-line-modified-removed">-     DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_DISJOINT;</span>
<span class="udiff-line-modified-added">+     DecoratorSet decorators = IN_HEAP | IS_ARRAY;</span>
      if (dest_uninitialized) {
        decorators |= IS_DEST_UNINITIALIZED;
      }
      if (aligned) {
        decorators |= ARRAYCOPY_ALIGNED;
      }
  
      BasicType type = is_oop ? T_OBJECT : T_LONG;
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
      bs-&gt;arraycopy_prologue(_masm, decorators, type, from, to, qword_count);
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-added">+       UnsafeCopyMemoryMark ucmm(this, !is_oop &amp;&amp; !aligned, true);</span>
  
<span class="udiff-line-modified-removed">-     __ jmp(L_copy_bytes);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Copy trailing qwords</span>
<span class="udiff-line-removed">-   __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-removed">-     __ movq(rax, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-removed">-     __ movq(Address(to, qword_count, Address::times_8, -8), rax);</span>
<span class="udiff-line-removed">-     __ decrement(qword_count);</span>
<span class="udiff-line-removed">-     __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+       __ jmp(L_copy_bytes);</span>
  
<span class="udiff-line-added">+       // Copy trailing qwords</span>
<span class="udiff-line-added">+     __ BIND(L_copy_8_bytes);</span>
<span class="udiff-line-added">+       __ movq(rax, Address(from, qword_count, Address::times_8, -8));</span>
<span class="udiff-line-added">+       __ movq(Address(to, qword_count, Address::times_8, -8), rax);</span>
<span class="udiff-line-added">+       __ decrement(qword_count);</span>
<span class="udiff-line-added">+       __ jcc(Assembler::notZero, L_copy_8_bytes);</span>
<span class="udiff-line-added">+     }</span>
      if (is_oop) {
        __ jmp(L_exit);
      } else {
        restore_arg_regs_using_thread();
        inc_counter_np(SharedRuntime::_jlong_array_copy_ctr); // Update counter after rscratch1 is free
        __ xorptr(rax, rax); // return 0
        __ vzeroupper();
        __ leave(); // required for proper stackwalking of RuntimeStub frame
        __ ret(0);
      }
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="udiff-line-added">+       UnsafeCopyMemoryMark ucmm(this, !is_oop &amp;&amp; !aligned, true);</span>
  
<span class="udiff-line-modified-removed">-     // Copy in multi-bytes chunks</span>
<span class="udiff-line-modified-removed">-     copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+       // Copy in multi-bytes chunks</span>
<span class="udiff-line-modified-added">+       copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);</span>
<span class="udiff-line-modified-added">+     }</span>
      __ BIND(L_exit);
      bs-&gt;arraycopy_epilogue(_masm, decorators, type, from, to, qword_count);
      restore_arg_regs_using_thread();
      if (is_oop) {
        inc_counter_np(SharedRuntime::_oop_array_copy_ctr); // Update counter after rscratch1 is free
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2341,11 +2484,11 @@</span>
      Address   end_to_addr(to,   length, TIMES_OOP, 0);
      // Loop-variant addresses.  They assume post-incremented count &lt; 0.
      Address from_element_addr(end_from, count, TIMES_OOP, 0);
      Address   to_element_addr(end_to,   count, TIMES_OOP, 0);
  
<span class="udiff-line-modified-removed">-     DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_CHECKCAST;</span>
<span class="udiff-line-modified-added">+     DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_CHECKCAST | ARRAYCOPY_DISJOINT;</span>
      if (dest_uninitialized) {
        decorators |= IS_DEST_UNINITIALIZED;
      }
  
      BasicType type = T_OBJECT;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2821,10 +2964,49 @@</span>
      __ ret(0);
  
      return start;
    }
  
<span class="udiff-line-added">+   address generate_data_cache_writeback() {</span>
<span class="udiff-line-added">+     const Register src        = c_rarg0;  // source address</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ align(CodeEntryAlignment);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;_data_cache_writeback&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     address start = __ pc();</span>
<span class="udiff-line-added">+     __ enter();</span>
<span class="udiff-line-added">+     __ cache_wb(Address(src, 0));</span>
<span class="udiff-line-added">+     __ leave();</span>
<span class="udiff-line-added">+     __ ret(0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return start;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   address generate_data_cache_writeback_sync() {</span>
<span class="udiff-line-added">+     const Register is_pre    = c_rarg0;  // pre or post sync</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ align(CodeEntryAlignment);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;_data_cache_writeback_sync&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // pre wbsync is a no-op</span>
<span class="udiff-line-added">+     // post wbsync translates to an sfence</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Label skip;</span>
<span class="udiff-line-added">+     address start = __ pc();</span>
<span class="udiff-line-added">+     __ enter();</span>
<span class="udiff-line-added">+     __ cmpl(is_pre, 0);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::notEqual, skip);</span>
<span class="udiff-line-added">+     __ cache_wbsync(false);</span>
<span class="udiff-line-added">+     __ bind(skip);</span>
<span class="udiff-line-added">+     __ leave();</span>
<span class="udiff-line-added">+     __ ret(0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return start;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    void generate_arraycopy_stubs() {
      address entry;
      address entry_jbyte_arraycopy;
      address entry_jshort_arraycopy;
      address entry_jint_arraycopy;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3597,10 +3779,40 @@</span>
      __ leave(); // required for proper stackwalking of RuntimeStub frame
      __ ret(0);
      return start;
  }
  
<span class="udiff-line-added">+   address generate_electronicCodeBook_encryptAESCrypt() {</span>
<span class="udiff-line-added">+     __ align(CodeEntryAlignment);</span>
<span class="udiff-line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;electronicCodeBook_encryptAESCrypt&quot;);</span>
<span class="udiff-line-added">+     address start = __ pc();</span>
<span class="udiff-line-added">+     const Register from = c_rarg0;  // source array address</span>
<span class="udiff-line-added">+     const Register to = c_rarg1;  // destination array address</span>
<span class="udiff-line-added">+     const Register key = c_rarg2;  // key array address</span>
<span class="udiff-line-added">+     const Register len = c_rarg3;  // src len (must be multiple of blocksize 16)</span>
<span class="udiff-line-added">+     __ enter(); // required for proper stackwalking of RuntimeStub frame</span>
<span class="udiff-line-added">+     __ aesecb_encrypt(from, to, key, len);</span>
<span class="udiff-line-added">+     __ leave(); // required for proper stackwalking of RuntimeStub frame</span>
<span class="udiff-line-added">+     __ ret(0);</span>
<span class="udiff-line-added">+     return start;</span>
<span class="udiff-line-added">+  }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   address generate_electronicCodeBook_decryptAESCrypt() {</span>
<span class="udiff-line-added">+     __ align(CodeEntryAlignment);</span>
<span class="udiff-line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;electronicCodeBook_decryptAESCrypt&quot;);</span>
<span class="udiff-line-added">+     address start = __ pc();</span>
<span class="udiff-line-added">+     const Register from = c_rarg0;  // source array address</span>
<span class="udiff-line-added">+     const Register to = c_rarg1;  // destination array address</span>
<span class="udiff-line-added">+     const Register key = c_rarg2;  // key array address</span>
<span class="udiff-line-added">+     const Register len = c_rarg3;  // src len (must be multiple of blocksize 16)</span>
<span class="udiff-line-added">+     __ enter(); // required for proper stackwalking of RuntimeStub frame</span>
<span class="udiff-line-added">+     __ aesecb_decrypt(from, to, key, len);</span>
<span class="udiff-line-added">+     __ leave(); // required for proper stackwalking of RuntimeStub frame</span>
<span class="udiff-line-added">+     __ ret(0);</span>
<span class="udiff-line-added">+     return start;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    address generate_upper_word_mask() {
      __ align(64);
      StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;upper_word_mask&quot;);
      address start = __ pc();
      __ emit_data64(0x0000000000000000, relocInfo::none);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3772,10 +3984,127 @@</span>
      __ leave();
      __ ret(0);
      return start;
    }
  
<span class="udiff-line-added">+   // This mask is used for incrementing counter value(linc0, linc4, etc.)</span>
<span class="udiff-line-added">+   address counter_mask_addr() {</span>
<span class="udiff-line-added">+     __ align(64);</span>
<span class="udiff-line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;counter_mask_addr&quot;);</span>
<span class="udiff-line-added">+     address start = __ pc();</span>
<span class="udiff-line-added">+     __ emit_data64(0x08090a0b0c0d0e0f, relocInfo::none);//lbswapmask</span>
<span class="udiff-line-added">+     __ emit_data64(0x0001020304050607, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x08090a0b0c0d0e0f, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0001020304050607, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x08090a0b0c0d0e0f, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0001020304050607, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x08090a0b0c0d0e0f, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0001020304050607, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);//linc0 = counter_mask_addr+64</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000001, relocInfo::none);//counter_mask_addr() + 80</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000002, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000003, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000004, relocInfo::none);//linc4 = counter_mask_addr() + 128</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000004, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000004, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000004, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000008, relocInfo::none);//linc8 = counter_mask_addr() + 192</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000008, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000008, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000008, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000020, relocInfo::none);//linc32 = counter_mask_addr() + 256</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000020, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000020, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000020, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000010, relocInfo::none);//linc16 = counter_mask_addr() + 320</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000010, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000010, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000010, relocInfo::none);</span>
<span class="udiff-line-added">+     __ emit_data64(0x0000000000000000, relocInfo::none);</span>
<span class="udiff-line-added">+     return start;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+  // Vector AES Counter implementation</span>
<span class="udiff-line-added">+   address generate_counterMode_VectorAESCrypt()  {</span>
<span class="udiff-line-added">+     __ align(CodeEntryAlignment);</span>
<span class="udiff-line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;counterMode_AESCrypt&quot;);</span>
<span class="udiff-line-added">+     address start = __ pc();</span>
<span class="udiff-line-added">+     const Register from = c_rarg0; // source array address</span>
<span class="udiff-line-added">+     const Register to = c_rarg1; // destination array address</span>
<span class="udiff-line-added">+     const Register key = c_rarg2; // key array address r8</span>
<span class="udiff-line-added">+     const Register counter = c_rarg3; // counter byte array initialized from counter array address</span>
<span class="udiff-line-added">+     // and updated with the incremented counter in the end</span>
<span class="udiff-line-added">+ #ifndef _WIN64</span>
<span class="udiff-line-added">+     const Register len_reg = c_rarg4;</span>
<span class="udiff-line-added">+     const Register saved_encCounter_start = c_rarg5;</span>
<span class="udiff-line-added">+     const Register used_addr = r10;</span>
<span class="udiff-line-added">+     const Address  used_mem(rbp, 2 * wordSize);</span>
<span class="udiff-line-added">+     const Register used = r11;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     const Address len_mem(rbp, 6 * wordSize); // length is on stack on Win64</span>
<span class="udiff-line-added">+     const Address saved_encCounter_mem(rbp, 7 * wordSize); // saved encrypted counter is on stack on Win64</span>
<span class="udiff-line-added">+     const Address used_mem(rbp, 8 * wordSize); // used length is on stack on Win64</span>
<span class="udiff-line-added">+     const Register len_reg = r10; // pick the first volatile windows register</span>
<span class="udiff-line-added">+     const Register saved_encCounter_start = r11;</span>
<span class="udiff-line-added">+     const Register used_addr = r13;</span>
<span class="udiff-line-added">+     const Register used = r14;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     __ enter();</span>
<span class="udiff-line-added">+    // Save state before entering routine</span>
<span class="udiff-line-added">+     __ push(r12);</span>
<span class="udiff-line-added">+     __ push(r13);</span>
<span class="udiff-line-added">+     __ push(r14);</span>
<span class="udiff-line-added">+     __ push(r15);</span>
<span class="udiff-line-added">+ #ifdef _WIN64</span>
<span class="udiff-line-added">+     // on win64, fill len_reg from stack position</span>
<span class="udiff-line-added">+     __ movl(len_reg, len_mem);</span>
<span class="udiff-line-added">+     __ movptr(saved_encCounter_start, saved_encCounter_mem);</span>
<span class="udiff-line-added">+     __ movptr(used_addr, used_mem);</span>
<span class="udiff-line-added">+     __ movl(used, Address(used_addr, 0));</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     __ push(len_reg); // Save</span>
<span class="udiff-line-added">+     __ movptr(used_addr, used_mem);</span>
<span class="udiff-line-added">+     __ movl(used, Address(used_addr, 0));</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     __ push(rbx);</span>
<span class="udiff-line-added">+     __ aesctr_encrypt(from, to, key, counter, len_reg, used, used_addr, saved_encCounter_start);</span>
<span class="udiff-line-added">+     // Restore state before leaving routine</span>
<span class="udiff-line-added">+     __ pop(rbx);</span>
<span class="udiff-line-added">+ #ifdef _WIN64</span>
<span class="udiff-line-added">+     __ movl(rax, len_mem); // return length</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     __ pop(rax); // return length</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     __ pop(r15);</span>
<span class="udiff-line-added">+     __ pop(r14);</span>
<span class="udiff-line-added">+     __ pop(r13);</span>
<span class="udiff-line-added">+     __ pop(r12);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ leave(); // required for proper stackwalking of RuntimeStub frame</span>
<span class="udiff-line-added">+     __ ret(0);</span>
<span class="udiff-line-added">+     return start;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // This is a version of CTR/AES crypt which does 6 blocks in a loop at a time
    // to hide instruction latency
    //
    // Arguments:
    //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5363,10 +5692,251 @@</span>
      __ ret(0);
  
      return start;
    }
  
<span class="udiff-line-added">+   address generate_bigIntegerRightShift() {</span>
<span class="udiff-line-added">+     __ align(CodeEntryAlignment);</span>
<span class="udiff-line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;bigIntegerRightShiftWorker&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     address start = __ pc();</span>
<span class="udiff-line-added">+     Label Shift512Loop, ShiftTwo, ShiftTwoLoop, ShiftOne, Exit;</span>
<span class="udiff-line-added">+     // For Unix, the arguments are as follows: rdi, rsi, rdx, rcx, r8.</span>
<span class="udiff-line-added">+     const Register newArr = rdi;</span>
<span class="udiff-line-added">+     const Register oldArr = rsi;</span>
<span class="udiff-line-added">+     const Register newIdx = rdx;</span>
<span class="udiff-line-added">+     const Register shiftCount = rcx;  // It was intentional to have shiftCount in rcx since it is used implicitly for shift.</span>
<span class="udiff-line-added">+     const Register totalNumIter = r8;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // For windows, we use r9 and r10 as temps to save rdi and rsi. Thus we cannot allocate them for our temps.</span>
<span class="udiff-line-added">+     // For everything else, we prefer using r9 and r10 since we do not have to save them before use.</span>
<span class="udiff-line-added">+     const Register tmp1 = r11;                    // Caller save.</span>
<span class="udiff-line-added">+     const Register tmp2 = rax;                    // Caller save.</span>
<span class="udiff-line-added">+     const Register tmp3 = WINDOWS_ONLY(r12) NOT_WINDOWS(r9);   // Windows: Callee save. Linux: Caller save.</span>
<span class="udiff-line-added">+     const Register tmp4 = WINDOWS_ONLY(r13) NOT_WINDOWS(r10);  // Windows: Callee save. Linux: Caller save.</span>
<span class="udiff-line-added">+     const Register tmp5 = r14;                    // Callee save.</span>
<span class="udiff-line-added">+     const Register tmp6 = r15;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const XMMRegister x0 = xmm0;</span>
<span class="udiff-line-added">+     const XMMRegister x1 = xmm1;</span>
<span class="udiff-line-added">+     const XMMRegister x2 = xmm2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     BLOCK_COMMENT(&quot;Entry:&quot;);</span>
<span class="udiff-line-added">+     __ enter(); // required for proper stackwalking of RuntimeStub frame</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef _WINDOWS</span>
<span class="udiff-line-added">+     setup_arg_regs(4);</span>
<span class="udiff-line-added">+     // For windows, since last argument is on stack, we need to move it to the appropriate register.</span>
<span class="udiff-line-added">+     __ movl(totalNumIter, Address(rsp, 6 * wordSize));</span>
<span class="udiff-line-added">+     // Save callee save registers.</span>
<span class="udiff-line-added">+     __ push(tmp3);</span>
<span class="udiff-line-added">+     __ push(tmp4);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     __ push(tmp5);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Rename temps used throughout the code.</span>
<span class="udiff-line-added">+     const Register idx = tmp1;</span>
<span class="udiff-line-added">+     const Register nIdx = tmp2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ xorl(idx, idx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Start right shift from end of the array.</span>
<span class="udiff-line-added">+     // For example, if #iteration = 4 and newIdx = 1</span>
<span class="udiff-line-added">+     // then dest[4] = src[4] &gt;&gt; shiftCount  | src[3] &lt;&lt;&lt; (shiftCount - 32)</span>
<span class="udiff-line-added">+     // if #iteration = 4 and newIdx = 0</span>
<span class="udiff-line-added">+     // then dest[3] = src[4] &gt;&gt; shiftCount  | src[3] &lt;&lt;&lt; (shiftCount - 32)</span>
<span class="udiff-line-added">+     __ movl(idx, totalNumIter);</span>
<span class="udiff-line-added">+     __ movl(nIdx, idx);</span>
<span class="udiff-line-added">+     __ addl(nIdx, newIdx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // If vectorization is enabled, check if the number of iterations is at least 64</span>
<span class="udiff-line-added">+     // If not, then go to ShifTwo processing 2 iterations</span>
<span class="udiff-line-added">+     if (VM_Version::supports_vbmi2()) {</span>
<span class="udiff-line-added">+       __ cmpptr(totalNumIter, (AVX3Threshold/64));</span>
<span class="udiff-line-added">+       __ jcc(Assembler::less, ShiftTwo);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (AVX3Threshold &lt; 16 * 64) {</span>
<span class="udiff-line-added">+         __ cmpl(totalNumIter, 16);</span>
<span class="udiff-line-added">+         __ jcc(Assembler::less, ShiftTwo);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       __ evpbroadcastd(x0, shiftCount, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+       __ subl(idx, 16);</span>
<span class="udiff-line-added">+       __ subl(nIdx, 16);</span>
<span class="udiff-line-added">+       __ BIND(Shift512Loop);</span>
<span class="udiff-line-added">+       __ evmovdqul(x2, Address(oldArr, idx, Address::times_4, 4), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+       __ evmovdqul(x1, Address(oldArr, idx, Address::times_4), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+       __ vpshrdvd(x2, x1, x0, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+       __ evmovdqul(Address(newArr, nIdx, Address::times_4), x2, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+       __ subl(nIdx, 16);</span>
<span class="udiff-line-added">+       __ subl(idx, 16);</span>
<span class="udiff-line-added">+       __ jcc(Assembler::greaterEqual, Shift512Loop);</span>
<span class="udiff-line-added">+       __ addl(idx, 16);</span>
<span class="udiff-line-added">+       __ addl(nIdx, 16);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     __ BIND(ShiftTwo);</span>
<span class="udiff-line-added">+     __ cmpl(idx, 2);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::less, ShiftOne);</span>
<span class="udiff-line-added">+     __ subl(idx, 2);</span>
<span class="udiff-line-added">+     __ subl(nIdx, 2);</span>
<span class="udiff-line-added">+     __ BIND(ShiftTwoLoop);</span>
<span class="udiff-line-added">+     __ movl(tmp5, Address(oldArr, idx, Address::times_4, 8));</span>
<span class="udiff-line-added">+     __ movl(tmp4, Address(oldArr, idx, Address::times_4, 4));</span>
<span class="udiff-line-added">+     __ movl(tmp3, Address(oldArr, idx, Address::times_4));</span>
<span class="udiff-line-added">+     __ shrdl(tmp5, tmp4);</span>
<span class="udiff-line-added">+     __ shrdl(tmp4, tmp3);</span>
<span class="udiff-line-added">+     __ movl(Address(newArr, nIdx, Address::times_4, 4), tmp5);</span>
<span class="udiff-line-added">+     __ movl(Address(newArr, nIdx, Address::times_4), tmp4);</span>
<span class="udiff-line-added">+     __ subl(nIdx, 2);</span>
<span class="udiff-line-added">+     __ subl(idx, 2);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::greaterEqual, ShiftTwoLoop);</span>
<span class="udiff-line-added">+     __ addl(idx, 2);</span>
<span class="udiff-line-added">+     __ addl(nIdx, 2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Do the last iteration</span>
<span class="udiff-line-added">+     __ BIND(ShiftOne);</span>
<span class="udiff-line-added">+     __ cmpl(idx, 1);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::less, Exit);</span>
<span class="udiff-line-added">+     __ subl(idx, 1);</span>
<span class="udiff-line-added">+     __ subl(nIdx, 1);</span>
<span class="udiff-line-added">+     __ movl(tmp4, Address(oldArr, idx, Address::times_4, 4));</span>
<span class="udiff-line-added">+     __ movl(tmp3, Address(oldArr, idx, Address::times_4));</span>
<span class="udiff-line-added">+     __ shrdl(tmp4, tmp3);</span>
<span class="udiff-line-added">+     __ movl(Address(newArr, nIdx, Address::times_4), tmp4);</span>
<span class="udiff-line-added">+     __ BIND(Exit);</span>
<span class="udiff-line-added">+     // Restore callee save registers.</span>
<span class="udiff-line-added">+     __ pop(tmp5);</span>
<span class="udiff-line-added">+ #ifdef _WINDOWS</span>
<span class="udiff-line-added">+     __ pop(tmp4);</span>
<span class="udiff-line-added">+     __ pop(tmp3);</span>
<span class="udiff-line-added">+     restore_arg_regs();</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     __ leave(); // required for proper stackwalking of RuntimeStub frame</span>
<span class="udiff-line-added">+     __ ret(0);</span>
<span class="udiff-line-added">+     return start;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+    /**</span>
<span class="udiff-line-added">+    *  Arguments:</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    *  Input:</span>
<span class="udiff-line-added">+    *    c_rarg0   - newArr address</span>
<span class="udiff-line-added">+    *    c_rarg1   - oldArr address</span>
<span class="udiff-line-added">+    *    c_rarg2   - newIdx</span>
<span class="udiff-line-added">+    *    c_rarg3   - shiftCount</span>
<span class="udiff-line-added">+    * not Win64</span>
<span class="udiff-line-added">+    *    c_rarg4   - numIter</span>
<span class="udiff-line-added">+    * Win64</span>
<span class="udiff-line-added">+    *    rsp40    - numIter</span>
<span class="udiff-line-added">+    */</span>
<span class="udiff-line-added">+   address generate_bigIntegerLeftShift() {</span>
<span class="udiff-line-added">+     __ align(CodeEntryAlignment);</span>
<span class="udiff-line-added">+     StubCodeMark mark(this,  &quot;StubRoutines&quot;, &quot;bigIntegerLeftShiftWorker&quot;);</span>
<span class="udiff-line-added">+     address start = __ pc();</span>
<span class="udiff-line-added">+     Label Shift512Loop, ShiftTwo, ShiftTwoLoop, ShiftOne, Exit;</span>
<span class="udiff-line-added">+     // For Unix, the arguments are as follows: rdi, rsi, rdx, rcx, r8.</span>
<span class="udiff-line-added">+     const Register newArr = rdi;</span>
<span class="udiff-line-added">+     const Register oldArr = rsi;</span>
<span class="udiff-line-added">+     const Register newIdx = rdx;</span>
<span class="udiff-line-added">+     const Register shiftCount = rcx;  // It was intentional to have shiftCount in rcx since it is used implicitly for shift.</span>
<span class="udiff-line-added">+     const Register totalNumIter = r8;</span>
<span class="udiff-line-added">+     // For windows, we use r9 and r10 as temps to save rdi and rsi. Thus we cannot allocate them for our temps.</span>
<span class="udiff-line-added">+     // For everything else, we prefer using r9 and r10 since we do not have to save them before use.</span>
<span class="udiff-line-added">+     const Register tmp1 = r11;                    // Caller save.</span>
<span class="udiff-line-added">+     const Register tmp2 = rax;                    // Caller save.</span>
<span class="udiff-line-added">+     const Register tmp3 = WINDOWS_ONLY(r12) NOT_WINDOWS(r9);   // Windows: Callee save. Linux: Caller save.</span>
<span class="udiff-line-added">+     const Register tmp4 = WINDOWS_ONLY(r13) NOT_WINDOWS(r10);  // Windows: Callee save. Linux: Caller save.</span>
<span class="udiff-line-added">+     const Register tmp5 = r14;                    // Callee save.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const XMMRegister x0 = xmm0;</span>
<span class="udiff-line-added">+     const XMMRegister x1 = xmm1;</span>
<span class="udiff-line-added">+     const XMMRegister x2 = xmm2;</span>
<span class="udiff-line-added">+     BLOCK_COMMENT(&quot;Entry:&quot;);</span>
<span class="udiff-line-added">+     __ enter(); // required for proper stackwalking of RuntimeStub frame</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef _WINDOWS</span>
<span class="udiff-line-added">+     setup_arg_regs(4);</span>
<span class="udiff-line-added">+     // For windows, since last argument is on stack, we need to move it to the appropriate register.</span>
<span class="udiff-line-added">+     __ movl(totalNumIter, Address(rsp, 6 * wordSize));</span>
<span class="udiff-line-added">+     // Save callee save registers.</span>
<span class="udiff-line-added">+     __ push(tmp3);</span>
<span class="udiff-line-added">+     __ push(tmp4);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     __ push(tmp5);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Rename temps used throughout the code</span>
<span class="udiff-line-added">+     const Register idx = tmp1;</span>
<span class="udiff-line-added">+     const Register numIterTmp = tmp2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Start idx from zero.</span>
<span class="udiff-line-added">+     __ xorl(idx, idx);</span>
<span class="udiff-line-added">+     // Compute interior pointer for new array. We do this so that we can use same index for both old and new arrays.</span>
<span class="udiff-line-added">+     __ lea(newArr, Address(newArr, newIdx, Address::times_4));</span>
<span class="udiff-line-added">+     __ movl(numIterTmp, totalNumIter);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // If vectorization is enabled, check if the number of iterations is at least 64</span>
<span class="udiff-line-added">+     // If not, then go to ShiftTwo shifting two numbers at a time</span>
<span class="udiff-line-added">+     if (VM_Version::supports_vbmi2()) {</span>
<span class="udiff-line-added">+       __ cmpl(totalNumIter, (AVX3Threshold/64));</span>
<span class="udiff-line-added">+       __ jcc(Assembler::less, ShiftTwo);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (AVX3Threshold &lt; 16 * 64) {</span>
<span class="udiff-line-added">+         __ cmpl(totalNumIter, 16);</span>
<span class="udiff-line-added">+         __ jcc(Assembler::less, ShiftTwo);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       __ evpbroadcastd(x0, shiftCount, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+       __ subl(numIterTmp, 16);</span>
<span class="udiff-line-added">+       __ BIND(Shift512Loop);</span>
<span class="udiff-line-added">+       __ evmovdqul(x1, Address(oldArr, idx, Address::times_4), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+       __ evmovdqul(x2, Address(oldArr, idx, Address::times_4, 0x4), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+       __ vpshldvd(x1, x2, x0, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+       __ evmovdqul(Address(newArr, idx, Address::times_4), x1, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+       __ addl(idx, 16);</span>
<span class="udiff-line-added">+       __ subl(numIterTmp, 16);</span>
<span class="udiff-line-added">+       __ jcc(Assembler::greaterEqual, Shift512Loop);</span>
<span class="udiff-line-added">+       __ addl(numIterTmp, 16);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     __ BIND(ShiftTwo);</span>
<span class="udiff-line-added">+     __ cmpl(totalNumIter, 1);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::less, Exit);</span>
<span class="udiff-line-added">+     __ movl(tmp3, Address(oldArr, idx, Address::times_4));</span>
<span class="udiff-line-added">+     __ subl(numIterTmp, 2);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::less, ShiftOne);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ BIND(ShiftTwoLoop);</span>
<span class="udiff-line-added">+     __ movl(tmp4, Address(oldArr, idx, Address::times_4, 0x4));</span>
<span class="udiff-line-added">+     __ movl(tmp5, Address(oldArr, idx, Address::times_4, 0x8));</span>
<span class="udiff-line-added">+     __ shldl(tmp3, tmp4);</span>
<span class="udiff-line-added">+     __ shldl(tmp4, tmp5);</span>
<span class="udiff-line-added">+     __ movl(Address(newArr, idx, Address::times_4), tmp3);</span>
<span class="udiff-line-added">+     __ movl(Address(newArr, idx, Address::times_4, 0x4), tmp4);</span>
<span class="udiff-line-added">+     __ movl(tmp3, tmp5);</span>
<span class="udiff-line-added">+     __ addl(idx, 2);</span>
<span class="udiff-line-added">+     __ subl(numIterTmp, 2);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::greaterEqual, ShiftTwoLoop);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Do the last iteration</span>
<span class="udiff-line-added">+     __ BIND(ShiftOne);</span>
<span class="udiff-line-added">+     __ addl(numIterTmp, 2);</span>
<span class="udiff-line-added">+     __ cmpl(numIterTmp, 1);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::less, Exit);</span>
<span class="udiff-line-added">+     __ movl(tmp4, Address(oldArr, idx, Address::times_4, 0x4));</span>
<span class="udiff-line-added">+     __ shldl(tmp3, tmp4);</span>
<span class="udiff-line-added">+     __ movl(Address(newArr, idx, Address::times_4), tmp3);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ BIND(Exit);</span>
<span class="udiff-line-added">+     // Restore callee save registers.</span>
<span class="udiff-line-added">+     __ pop(tmp5);</span>
<span class="udiff-line-added">+ #ifdef _WINDOWS</span>
<span class="udiff-line-added">+     __ pop(tmp4);</span>
<span class="udiff-line-added">+     __ pop(tmp3);</span>
<span class="udiff-line-added">+     restore_arg_regs();</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     __ leave(); // required for proper stackwalking of RuntimeStub frame</span>
<span class="udiff-line-added">+     __ ret(0);</span>
<span class="udiff-line-added">+     return start;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    address generate_libmExp() {
      StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;libmExp&quot;);
  
      address start = __ pc();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5769,10 +6339,20 @@</span>
      StubRoutines::x86::_get_previous_fp_entry = generate_get_previous_fp();
      StubRoutines::x86::_get_previous_sp_entry = generate_get_previous_sp();
  
      StubRoutines::x86::_verify_mxcsr_entry    = generate_verify_mxcsr();
  
<span class="udiff-line-added">+     StubRoutines::x86::_f2i_fixup             = generate_f2i_fixup();</span>
<span class="udiff-line-added">+     StubRoutines::x86::_f2l_fixup             = generate_f2l_fixup();</span>
<span class="udiff-line-added">+     StubRoutines::x86::_d2i_fixup             = generate_d2i_fixup();</span>
<span class="udiff-line-added">+     StubRoutines::x86::_d2l_fixup             = generate_d2l_fixup();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     StubRoutines::x86::_float_sign_mask       = generate_fp_mask(&quot;float_sign_mask&quot;,  0x7FFFFFFF7FFFFFFF);</span>
<span class="udiff-line-added">+     StubRoutines::x86::_float_sign_flip       = generate_fp_mask(&quot;float_sign_flip&quot;,  0x8000000080000000);</span>
<span class="udiff-line-added">+     StubRoutines::x86::_double_sign_mask      = generate_fp_mask(&quot;double_sign_mask&quot;, 0x7FFFFFFFFFFFFFFF);</span>
<span class="udiff-line-added">+     StubRoutines::x86::_double_sign_flip      = generate_fp_mask(&quot;double_sign_flip&quot;, 0x8000000000000000);</span>
<span class="udiff-line-added">+ </span>
      // Build this early so it&#39;s available for the interpreter.
      StubRoutines::_throw_StackOverflowError_entry =
        generate_throw_exception(&quot;StackOverflowError throw_exception&quot;,
                                 CAST_FROM_FN_PTR(address,
                                                  SharedRuntime::
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5792,11 +6372,11 @@</span>
        bool supports_clmul = VM_Version::supports_clmul();
        StubRoutines::x86::generate_CRC32C_table(supports_clmul);
        StubRoutines::_crc32c_table_addr = (address)StubRoutines::x86::_crc32c_table;
        StubRoutines::_updateBytesCRC32C = generate_updateBytesCRC32C(supports_clmul);
      }
<span class="udiff-line-modified-removed">-     if (VM_Version::supports_sse2() &amp;&amp; UseLibmIntrinsic &amp;&amp; InlineIntrinsics) {</span>
<span class="udiff-line-modified-added">+     if (UseLibmIntrinsic &amp;&amp; InlineIntrinsics) {</span>
        if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin) ||
            vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos) ||
            vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtan)) {
          StubRoutines::x86::_ONEHALF_adr = (address)StubRoutines::x86::_ONEHALF;
          StubRoutines::x86::_P_2_adr = (address)StubRoutines::x86::_P_2;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5860,23 +6440,25 @@</span>
                                 CAST_FROM_FN_PTR(address,
                                                  SharedRuntime::
                                                  throw_NullPointerException_at_call));
  
      // entry points that are platform specific
<span class="udiff-line-modified-removed">-     StubRoutines::x86::_f2i_fixup = generate_f2i_fixup();</span>
<span class="udiff-line-modified-removed">-     StubRoutines::x86::_f2l_fixup = generate_f2l_fixup();</span>
<span class="udiff-line-modified-removed">-     StubRoutines::x86::_d2i_fixup = generate_d2i_fixup();</span>
<span class="udiff-line-modified-removed">-     StubRoutines::x86::_d2l_fixup = generate_d2l_fixup();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     StubRoutines::x86::_float_sign_mask  = generate_fp_mask(&quot;float_sign_mask&quot;,  0x7FFFFFFF7FFFFFFF);</span>
<span class="udiff-line-modified-removed">-     StubRoutines::x86::_float_sign_flip  = generate_fp_mask(&quot;float_sign_flip&quot;,  0x8000000080000000);</span>
<span class="udiff-line-removed">-     StubRoutines::x86::_double_sign_mask = generate_fp_mask(&quot;double_sign_mask&quot;, 0x7FFFFFFFFFFFFFFF);</span>
<span class="udiff-line-removed">-     StubRoutines::x86::_double_sign_flip = generate_fp_mask(&quot;double_sign_flip&quot;, 0x8000000000000000);</span>
<span class="udiff-line-modified-added">+     StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(&quot;vector_float_sign_mask&quot;, 0x7FFFFFFF7FFFFFFF);</span>
<span class="udiff-line-modified-added">+     StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(&quot;vector_float_sign_flip&quot;, 0x8000000080000000);</span>
<span class="udiff-line-modified-added">+     StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask(&quot;vector_double_sign_mask&quot;, 0x7FFFFFFFFFFFFFFF);</span>
<span class="udiff-line-modified-added">+     StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask(&quot;vector_double_sign_flip&quot;, 0x8000000000000000);</span>
<span class="udiff-line-modified-added">+     StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(&quot;vector_short_to_byte_mask&quot;, 0x00ff00ff00ff00ff);</span>
<span class="udiff-line-modified-added">+     StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask(&quot;vector_byte_perm_mask&quot;);</span>
<span class="udiff-line-modified-added">+     StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask(&quot;vector_long_sign_mask&quot;, 0x8000000000000000);</span>
  
      // support for verify_oop (must happen after universe_init)
      StubRoutines::_verify_oop_subroutine_entry = generate_verify_oop();
  
<span class="udiff-line-added">+     // data cache line writeback</span>
<span class="udiff-line-added">+     StubRoutines::_data_cache_writeback = generate_data_cache_writeback();</span>
<span class="udiff-line-added">+     StubRoutines::_data_cache_writeback_sync = generate_data_cache_writeback_sync();</span>
<span class="udiff-line-added">+ </span>
      // arraycopy stubs used by compilers
      generate_arraycopy_stubs();
  
      // don&#39;t bother generating these AES intrinsic stubs unless global flag is set
      if (UseAESIntrinsics) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5884,17 +6466,24 @@</span>
        StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
        StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
        StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_encryptAESCrypt();
        if (VM_Version::supports_vaes() &amp;&amp;  VM_Version::supports_avx512vl() &amp;&amp; VM_Version::supports_avx512dq() ) {
          StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptVectorAESCrypt();
<span class="udiff-line-added">+         StubRoutines::_electronicCodeBook_encryptAESCrypt = generate_electronicCodeBook_encryptAESCrypt();</span>
<span class="udiff-line-added">+         StubRoutines::_electronicCodeBook_decryptAESCrypt = generate_electronicCodeBook_decryptAESCrypt();</span>
        } else {
          StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt_Parallel();
        }
      }
<span class="udiff-line-modified-removed">-     if (UseAESCTRIntrinsics){</span>
<span class="udiff-line-modified-removed">-       StubRoutines::x86::_counter_shuffle_mask_addr = generate_counter_shuffle_mask();</span>
<span class="udiff-line-modified-removed">-       StubRoutines::_counterMode_AESCrypt = generate_counterMode_AESCrypt_Parallel();</span>
<span class="udiff-line-modified-added">+     if (UseAESCTRIntrinsics) {</span>
<span class="udiff-line-modified-added">+       if (VM_Version::supports_vaes() &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; VM_Version::supports_avx512vl()) {</span>
<span class="udiff-line-modified-added">+         StubRoutines::x86::_counter_mask_addr = counter_mask_addr();</span>
<span class="udiff-line-added">+         StubRoutines::_counterMode_AESCrypt = generate_counterMode_VectorAESCrypt();</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         StubRoutines::x86::_counter_shuffle_mask_addr = generate_counter_shuffle_mask();</span>
<span class="udiff-line-added">+         StubRoutines::_counterMode_AESCrypt = generate_counterMode_AESCrypt_Parallel();</span>
<span class="udiff-line-added">+       }</span>
      }
  
      if (UseSHA1Intrinsics) {
        StubRoutines::x86::_upper_word_mask_addr = generate_upper_word_mask();
        StubRoutines::x86::_shuffle_byte_flip_mask_addr = generate_shuffle_byte_flip_mask();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5965,10 +6554,14 @@</span>
        StubRoutines::_squareToLen = generate_squareToLen();
      }
      if (UseMulAddIntrinsic) {
        StubRoutines::_mulAdd = generate_mulAdd();
      }
<span class="udiff-line-added">+     if (VM_Version::supports_vbmi2()) {</span>
<span class="udiff-line-added">+       StubRoutines::_bigIntegerRightShiftWorker = generate_bigIntegerRightShift();</span>
<span class="udiff-line-added">+       StubRoutines::_bigIntegerLeftShiftWorker = generate_bigIntegerLeftShift();</span>
<span class="udiff-line-added">+     }</span>
  #ifndef _WINDOWS
      if (UseMontgomeryMultiplyIntrinsic) {
        StubRoutines::_montgomeryMultiply
          = CAST_FROM_FN_PTR(address, SharedRuntime::montgomery_multiply);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5992,8 +6585,12 @@</span>
        generate_initial();
      }
    }
  }; // end class declaration
  
<span class="udiff-line-added">+ #define UCM_TABLE_MAX_ENTRIES 16</span>
  void StubGenerator_generate(CodeBuffer* code, bool all) {
<span class="udiff-line-added">+   if (UnsafeCopyMemory::_table == NULL) {</span>
<span class="udiff-line-added">+     UnsafeCopyMemory::create_table(UCM_TABLE_MAX_ENTRIES);</span>
<span class="udiff-line-added">+   }</span>
    StubGenerator g(code, all);
  }
</pre>
<center><a href="stubGenerator_x86_32.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubRoutines_x86.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
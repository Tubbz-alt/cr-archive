<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/vm_version_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vm_version_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86.ad.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/vm_version_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_VM_VERSION_X86_HPP
  26 #define CPU_X86_VM_VERSION_X86_HPP
  27 


  28 #include &quot;runtime/globals_extension.hpp&quot;
<span class="line-removed">  29 #include &quot;runtime/vm_version.hpp&quot;</span>
  30 
  31 class VM_Version : public Abstract_VM_Version {
  32   friend class VMStructs;
  33   friend class JVMCIVMStructs;
  34 
  35  public:
  36   // cpuid result register layouts.  These are all unions of a uint32_t
  37   // (in case anyone wants access to the register as a whole) and a bitfield.
  38 
  39   union StdCpuid1Eax {
  40     uint32_t value;
  41     struct {
  42       uint32_t stepping   : 4,
  43                model      : 4,
  44                family     : 4,
  45                proc_type  : 2,
  46                           : 2,
  47                ext_model  : 4,
  48                ext_family : 8,
  49                           : 4;
</pre>
<hr />
<pre>
 201   };
 202 
 203   union SefCpuid7Ebx {
 204     uint32_t value;
 205     struct {
 206       uint32_t fsgsbase : 1,
 207                         : 2,
 208                    bmi1 : 1,
 209                         : 1,
 210                    avx2 : 1,
 211                         : 2,
 212                    bmi2 : 1,
 213                    erms : 1,
 214                         : 1,
 215                     rtm : 1,
 216                         : 4,
 217                 avx512f : 1,
 218                avx512dq : 1,
 219                         : 1,
 220                     adx : 1,
<span class="line-modified"> 221                         : 6,</span>



 222                avx512pf : 1,
 223                avx512er : 1,
 224                avx512cd : 1,
 225                     sha : 1,
 226                avx512bw : 1,
 227                avx512vl : 1;
 228     } bits;
 229   };
 230 
 231   union SefCpuid7Ecx {
 232     uint32_t value;
 233     struct {
 234       uint32_t prefetchwt1 : 1,
 235                avx512_vbmi : 1,
 236                       umip : 1,
 237                        pku : 1,
 238                      ospke : 1,
 239                            : 1,
 240               avx512_vbmi2 : 1,
 241                            : 1,
 242                       gfni : 1,
 243                       vaes : 1,
<span class="line-modified"> 244                 vpclmulqdq : 1,</span>
 245                avx512_vnni : 1,
 246              avx512_bitalg : 1,
 247                            : 1,
 248           avx512_vpopcntdq : 1,
 249                            : 17;
 250     } bits;
 251   };
 252 
 253   union SefCpuid7Edx {
 254     uint32_t value;
 255     struct {
 256       uint32_t             : 2,
 257              avx512_4vnniw : 1,
 258              avx512_4fmaps : 1,
 259                            : 28;
 260     } bits;
 261   };
 262 
 263   union ExtCpuid1EEbx {
 264     uint32_t value;
</pre>
<hr />
<pre>
 317     CPU_ERMS     = (1 &lt;&lt; 20), // enhanced &#39;rep movsb/stosb&#39; instructions
 318     CPU_CLMUL    = (1 &lt;&lt; 21), // carryless multiply for CRC
 319     CPU_BMI1     = (1 &lt;&lt; 22),
 320     CPU_BMI2     = (1 &lt;&lt; 23),
 321     CPU_RTM      = (1 &lt;&lt; 24), // Restricted Transactional Memory instructions
 322     CPU_ADX      = (1 &lt;&lt; 25),
 323     CPU_AVX512F  = (1 &lt;&lt; 26), // AVX 512bit foundation instructions
 324     CPU_AVX512DQ = (1 &lt;&lt; 27),
 325     CPU_AVX512PF = (1 &lt;&lt; 28),
 326     CPU_AVX512ER = (1 &lt;&lt; 29),
 327     CPU_AVX512CD = (1 &lt;&lt; 30)
 328     // Keeping sign bit 31 unassigned.
 329   };
 330 
 331 #define CPU_AVX512BW ((uint64_t)UCONST64(0x100000000)) // enums are limited to 31 bit
 332 #define CPU_AVX512VL ((uint64_t)UCONST64(0x200000000)) // EVEX instructions with smaller vector length
 333 #define CPU_SHA ((uint64_t)UCONST64(0x400000000))      // SHA instructions
 334 #define CPU_FMA ((uint64_t)UCONST64(0x800000000))      // FMA instructions
 335 #define CPU_VZEROUPPER ((uint64_t)UCONST64(0x1000000000))       // Vzeroupper instruction
 336 #define CPU_AVX512_VPOPCNTDQ ((uint64_t)UCONST64(0x2000000000)) // Vector popcount
<span class="line-modified"> 337 #define CPU_VPCLMULQDQ ((uint64_t)UCONST64(0x4000000000)) //Vector carryless multiplication</span>
 338 #define CPU_VAES ((uint64_t)UCONST64(0x8000000000))    // Vector AES instructions
 339 #define CPU_VNNI ((uint64_t)UCONST64(0x10000000000))   // Vector Neural Network Instructions
 340 
<span class="line-modified"> 341   enum Extended_Family {</span>






 342     // AMD
 343     CPU_FAMILY_AMD_11H       = 0x11,
 344     // ZX
 345     CPU_FAMILY_ZX_CORE_F6    = 6,
 346     CPU_FAMILY_ZX_CORE_F7    = 7,
 347     // Intel
 348     CPU_FAMILY_INTEL_CORE    = 6,
 349     CPU_MODEL_NEHALEM        = 0x1e,
 350     CPU_MODEL_NEHALEM_EP     = 0x1a,
 351     CPU_MODEL_NEHALEM_EX     = 0x2e,
 352     CPU_MODEL_WESTMERE       = 0x25,
 353     CPU_MODEL_WESTMERE_EP    = 0x2c,
 354     CPU_MODEL_WESTMERE_EX    = 0x2f,
 355     CPU_MODEL_SANDYBRIDGE    = 0x2a,
 356     CPU_MODEL_SANDYBRIDGE_EP = 0x2d,
 357     CPU_MODEL_IVYBRIDGE_EP   = 0x3a,
 358     CPU_MODEL_HASWELL_E3     = 0x3c,
 359     CPU_MODEL_HASWELL_E7     = 0x3f,
 360     CPU_MODEL_BROADWELL      = 0x3d,
<span class="line-modified"> 361     CPU_MODEL_SKYLAKE        = CPU_MODEL_HASWELL_E3</span>
 362   };
 363 
 364   // cpuid information block.  All info derived from executing cpuid with
 365   // various function numbers is stored here.  Intel and AMD info is
 366   // merged in this block: accessor methods disentangle it.
 367   //
 368   // The info block is laid out in subblocks of 4 dwords corresponding to
 369   // eax, ebx, ecx and edx, whether or not they contain anything useful.
 370   struct CpuidInfo {
 371     // cpuid function 0
 372     uint32_t std_max_function;
 373     uint32_t std_vendor_name_0;
 374     uint32_t std_vendor_name_1;
 375     uint32_t std_vendor_name_2;
 376 
 377     // cpuid function 1
 378     StdCpuid1Eax std_cpuid1_eax;
 379     StdCpuid1Ebx std_cpuid1_ebx;
 380     StdCpuid1Ecx std_cpuid1_ecx;
 381     StdCpuid1Edx std_cpuid1_edx;
</pre>
<hr />
<pre>
 478     result |= _cpuid_info.std_cpuid1_eax.bits.ext_model &lt;&lt; 4;
 479     return result;
 480   }
 481 
 482   static uint32_t cpu_stepping() {
 483     uint32_t result = _cpuid_info.std_cpuid1_eax.bits.stepping;
 484     return result;
 485   }
 486 
 487   static uint logical_processor_count() {
 488     uint result = threads_per_core();
 489     return result;
 490   }
 491 
 492   static uint64_t feature_flags() {
 493     uint64_t result = 0;
 494     if (_cpuid_info.std_cpuid1_edx.bits.cmpxchg8 != 0)
 495       result |= CPU_CX8;
 496     if (_cpuid_info.std_cpuid1_edx.bits.cmov != 0)
 497       result |= CPU_CMOV;
<span class="line-modified"> 498     if (_cpuid_info.std_cpuid1_edx.bits.fxsr != 0 || (is_amd() &amp;&amp;</span>








 499         _cpuid_info.ext_cpuid1_edx.bits.fxsr != 0))
 500       result |= CPU_FXSR;
 501     // HT flag is set for multi-core processors also.
 502     if (threads_per_core() &gt; 1)
 503       result |= CPU_HT;
<span class="line-modified"> 504     if (_cpuid_info.std_cpuid1_edx.bits.mmx != 0 || (is_amd() &amp;&amp;</span>
 505         _cpuid_info.ext_cpuid1_edx.bits.mmx != 0))
 506       result |= CPU_MMX;
 507     if (_cpuid_info.std_cpuid1_edx.bits.sse != 0)
 508       result |= CPU_SSE;
 509     if (_cpuid_info.std_cpuid1_edx.bits.sse2 != 0)
 510       result |= CPU_SSE2;
 511     if (_cpuid_info.std_cpuid1_ecx.bits.sse3 != 0)
 512       result |= CPU_SSE3;
 513     if (_cpuid_info.std_cpuid1_ecx.bits.ssse3 != 0)
 514       result |= CPU_SSSE3;
 515     if (_cpuid_info.std_cpuid1_ecx.bits.sse4_1 != 0)
 516       result |= CPU_SSE4_1;
 517     if (_cpuid_info.std_cpuid1_ecx.bits.sse4_2 != 0)
 518       result |= CPU_SSE4_2;
 519     if (_cpuid_info.std_cpuid1_ecx.bits.popcnt != 0)
 520       result |= CPU_POPCNT;
 521     if (_cpuid_info.std_cpuid1_ecx.bits.avx != 0 &amp;&amp;
 522         _cpuid_info.std_cpuid1_ecx.bits.osxsave != 0 &amp;&amp;
 523         _cpuid_info.xem_xcr0_eax.bits.sse != 0 &amp;&amp;
 524         _cpuid_info.xem_xcr0_eax.bits.ymm != 0) {
</pre>
<hr />
<pre>
 528         result |= CPU_AVX2;
 529       if (_cpuid_info.sef_cpuid7_ebx.bits.avx512f != 0 &amp;&amp;
 530           _cpuid_info.xem_xcr0_eax.bits.opmask != 0 &amp;&amp;
 531           _cpuid_info.xem_xcr0_eax.bits.zmm512 != 0 &amp;&amp;
 532           _cpuid_info.xem_xcr0_eax.bits.zmm32 != 0) {
 533         result |= CPU_AVX512F;
 534         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512cd != 0)
 535           result |= CPU_AVX512CD;
 536         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512dq != 0)
 537           result |= CPU_AVX512DQ;
 538         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512pf != 0)
 539           result |= CPU_AVX512PF;
 540         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512er != 0)
 541           result |= CPU_AVX512ER;
 542         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512bw != 0)
 543           result |= CPU_AVX512BW;
 544         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512vl != 0)
 545           result |= CPU_AVX512VL;
 546         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpopcntdq != 0)
 547           result |= CPU_AVX512_VPOPCNTDQ;
<span class="line-modified"> 548         if (_cpuid_info.sef_cpuid7_ecx.bits.vpclmulqdq != 0)</span>
<span class="line-modified"> 549           result |= CPU_VPCLMULQDQ;</span>
 550         if (_cpuid_info.sef_cpuid7_ecx.bits.vaes != 0)
 551           result |= CPU_VAES;
 552         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vnni != 0)
 553           result |= CPU_VNNI;


 554       }
 555     }
<span class="line-modified"> 556     if(_cpuid_info.sef_cpuid7_ebx.bits.bmi1 != 0)</span>
 557       result |= CPU_BMI1;
 558     if (_cpuid_info.std_cpuid1_edx.bits.tsc != 0)
 559       result |= CPU_TSC;
 560     if (_cpuid_info.ext_cpuid7_edx.bits.tsc_invariance != 0)
 561       result |= CPU_TSCINV;
 562     if (_cpuid_info.std_cpuid1_ecx.bits.aes != 0)
 563       result |= CPU_AES;
 564     if (_cpuid_info.sef_cpuid7_ebx.bits.erms != 0)
 565       result |= CPU_ERMS;
 566     if (_cpuid_info.std_cpuid1_ecx.bits.clmul != 0)
 567       result |= CPU_CLMUL;
 568     if (_cpuid_info.sef_cpuid7_ebx.bits.rtm != 0)
 569       result |= CPU_RTM;
<span class="line-modified"> 570     if(_cpuid_info.sef_cpuid7_ebx.bits.adx != 0)</span>
 571        result |= CPU_ADX;
<span class="line-modified"> 572     if(_cpuid_info.sef_cpuid7_ebx.bits.bmi2 != 0)</span>
 573       result |= CPU_BMI2;
 574     if (_cpuid_info.sef_cpuid7_ebx.bits.sha != 0)
 575       result |= CPU_SHA;
 576     if (_cpuid_info.std_cpuid1_ecx.bits.fma != 0)
 577       result |= CPU_FMA;


 578 
<span class="line-modified"> 579     // AMD features.</span>
<span class="line-modified"> 580     if (is_amd()) {</span>
 581       if ((_cpuid_info.ext_cpuid1_edx.bits.tdnow != 0) ||
 582           (_cpuid_info.ext_cpuid1_ecx.bits.prefetchw != 0))
 583         result |= CPU_3DNOW_PREFETCH;
 584       if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt != 0)
 585         result |= CPU_LZCNT;
 586       if (_cpuid_info.ext_cpuid1_ecx.bits.sse4a != 0)
 587         result |= CPU_SSE4A;
 588     }
 589     // Intel features.
<span class="line-modified"> 590     if(is_intel()) {</span>
<span class="line-modified"> 591       if(_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)</span>
 592         result |= CPU_LZCNT;
 593       // for Intel, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw
 594       if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {
 595         result |= CPU_3DNOW_PREFETCH;
 596       }



 597     }
 598 
 599     // ZX features.
 600     if (is_zx()) {
 601       if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)
 602         result |= CPU_LZCNT;
 603       // for ZX, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw
 604       if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {
 605         result |= CPU_3DNOW_PREFETCH;
 606       }
 607     }
 608 
 609     return result;
 610   }
 611 
 612   static bool os_supports_avx_vectors() {
 613     bool retVal = false;
 614     int nreg = 2 LP64_ONLY(+2);
 615     if (supports_evex()) {
 616       // Verify that OS save/restore all bits of EVEX registers
</pre>
<hr />
<pre>
 668   static ByteSize ymm_save_offset() { return byte_offset_of(CpuidInfo, ymm_save); }
 669   static ByteSize zmm_save_offset() { return byte_offset_of(CpuidInfo, zmm_save); }
 670 
 671   // The value used to check ymm register after signal handle
 672   static int ymm_test_value()    { return 0xCAFEBABE; }
 673 
 674   static void get_cpu_info_wrapper();
 675   static void set_cpuinfo_segv_addr(address pc) { _cpuinfo_segv_addr = pc; }
 676   static bool  is_cpuinfo_segv_addr(address pc) { return _cpuinfo_segv_addr == pc; }
 677   static void set_cpuinfo_cont_addr(address pc) { _cpuinfo_cont_addr = pc; }
 678   static address  cpuinfo_cont_addr()           { return _cpuinfo_cont_addr; }
 679 
 680   static void clean_cpuFeatures()   { _features = 0; }
 681   static void set_avx_cpuFeatures() { _features = (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }
 682   static void set_evex_cpuFeatures() { _features = (CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }
 683 
 684 
 685   // Initialization
 686   static void initialize();
 687 



 688   // Override Abstract_VM_Version implementation
 689   static bool use_biased_locking();
 690 
 691   // Asserts
 692   static void assert_is_initialized() {
 693     assert(_cpuid_info.std_cpuid1_eax.bits.family != 0, &quot;VM_Version not initialized&quot;);
 694   }
 695 
 696   //
 697   // Processor family:
 698   //       3   -  386
 699   //       4   -  486
 700   //       5   -  Pentium
 701   //       6   -  PentiumPro, Pentium II, Celeron, Xeon, Pentium III, Athlon,
 702   //              Pentium M, Core Solo, Core Duo, Core2 Duo
 703   //    family 6 model:   9,        13,       14,        15
 704   //    0x0f   -  Pentium 4, Opteron
 705   //
 706   // Note: The cpu family should be used to select between
 707   //       instruction sequences which are valid on all Intel
 708   //       processors.  Use the feature test functions below to
 709   //       determine whether a particular instruction is supported.
 710   //
 711   static int  cpu_family()        { return _cpu;}
 712   static bool is_P6()             { return cpu_family() &gt;= 6; }
 713   static bool is_amd()            { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x68747541; } // &#39;htuA&#39;


 714   static bool is_intel()          { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x756e6547; } // &#39;uneG&#39;
 715   static bool is_zx()             { assert_is_initialized(); return (_cpuid_info.std_vendor_name_0 == 0x746e6543) || (_cpuid_info.std_vendor_name_0 == 0x68532020); } // &#39;tneC&#39;||&#39;hS  &#39;
 716   static bool is_atom_family()    { return ((cpu_family() == 0x06) &amp;&amp; ((extended_cpu_model() == 0x36) || (extended_cpu_model() == 0x37) || (extended_cpu_model() == 0x4D))); } //Silvermont and Centerton
 717   static bool is_knights_family() { return ((cpu_family() == 0x06) &amp;&amp; ((extended_cpu_model() == 0x57) || (extended_cpu_model() == 0x85))); } // Xeon Phi 3200/5200/7200 and Future Xeon Phi
 718 
 719   static bool supports_processor_topology() {
 720     return (_cpuid_info.std_max_function &gt;= 0xB) &amp;&amp;
 721            // eax[4:0] | ebx[0:15] == 0 indicates invalid topology level.
 722            // Some cpus have max cpuid &gt;= 0xB but do not support processor topology.
 723            (((_cpuid_info.tpl_cpuidB0_eax &amp; 0x1f) | _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus) != 0);
 724   }
 725 
 726   static uint cores_per_cpu()  {
 727     uint result = 1;
 728     if (is_intel()) {
 729       bool supports_topology = supports_processor_topology();
 730       if (supports_topology) {
 731         result = _cpuid_info.tpl_cpuidB1_ebx.bits.logical_cpus /
 732                  _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 733       }
 734       if (!supports_topology || result == 0) {
 735         result = (_cpuid_info.dcp_cpuid4_eax.bits.cores_per_cpu + 1);
 736       }
<span class="line-modified"> 737     } else if (is_amd()) {</span>
 738       result = (_cpuid_info.ext_cpuid8_ecx.bits.cores_per_cpu + 1);
 739     } else if (is_zx()) {
 740       bool supports_topology = supports_processor_topology();
 741       if (supports_topology) {
 742         result = _cpuid_info.tpl_cpuidB1_ebx.bits.logical_cpus /
 743                  _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 744       }
 745       if (!supports_topology || result == 0) {
 746         result = (_cpuid_info.dcp_cpuid4_eax.bits.cores_per_cpu + 1);
 747       }
 748     }
 749     return result;
 750   }
 751 
 752   static uint threads_per_core()  {
 753     uint result = 1;
 754     if (is_intel() &amp;&amp; supports_processor_topology()) {
 755       result = _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 756     } else if (is_zx() &amp;&amp; supports_processor_topology()) {
 757       result = _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 758     } else if (_cpuid_info.std_cpuid1_edx.bits.ht != 0) {
 759       if (cpu_family() &gt;= 0x17) {
 760         result = _cpuid_info.ext_cpuid1E_ebx.bits.threads_per_core + 1;
 761       } else {
 762         result = _cpuid_info.std_cpuid1_ebx.bits.threads_per_cpu /
 763                  cores_per_cpu();
 764       }
 765     }
 766     return (result == 0 ? 1 : result);
 767   }
 768 
 769   static intx L1_line_size()  {
 770     intx result = 0;
 771     if (is_intel()) {
 772       result = (_cpuid_info.dcp_cpuid4_ebx.bits.L1_line_size + 1);
<span class="line-modified"> 773     } else if (is_amd()) {</span>
 774       result = _cpuid_info.ext_cpuid5_ecx.bits.L1_line_size;
 775     } else if (is_zx()) {
 776       result = (_cpuid_info.dcp_cpuid4_ebx.bits.L1_line_size + 1);
 777     }
 778     if (result &lt; 32) // not defined ?
 779       result = 32;   // 32 bytes by default on x86 and other x64
 780     return result;
 781   }
 782 
 783   static intx prefetch_data_size()  {
 784     return L1_line_size();
 785   }
 786 
 787   //
 788   // Feature identification
 789   //
 790   static bool supports_cpuid()    { return _features  != 0; }
 791   static bool supports_cmpxchg8() { return (_features &amp; CPU_CX8) != 0; }
 792   static bool supports_cmov()     { return (_features &amp; CPU_CMOV) != 0; }
 793   static bool supports_fxsr()     { return (_features &amp; CPU_FXSR) != 0; }
</pre>
<hr />
<pre>
 812   static bool supports_adx()      { return (_features &amp; CPU_ADX) != 0; }
 813   static bool supports_evex()     { return (_features &amp; CPU_AVX512F) != 0; }
 814   static bool supports_avx512dq() { return (_features &amp; CPU_AVX512DQ) != 0; }
 815   static bool supports_avx512pf() { return (_features &amp; CPU_AVX512PF) != 0; }
 816   static bool supports_avx512er() { return (_features &amp; CPU_AVX512ER) != 0; }
 817   static bool supports_avx512cd() { return (_features &amp; CPU_AVX512CD) != 0; }
 818   static bool supports_avx512bw() { return (_features &amp; CPU_AVX512BW) != 0; }
 819   static bool supports_avx512vl() { return (_features &amp; CPU_AVX512VL) != 0; }
 820   static bool supports_avx512vlbw() { return (supports_evex() &amp;&amp; supports_avx512bw() &amp;&amp; supports_avx512vl()); }
 821   static bool supports_avx512vldq() { return (supports_evex() &amp;&amp; supports_avx512dq() &amp;&amp; supports_avx512vl()); }
 822   static bool supports_avx512vlbwdq() { return (supports_evex() &amp;&amp; supports_avx512vl() &amp;&amp;
 823                                                 supports_avx512bw() &amp;&amp; supports_avx512dq()); }
 824   static bool supports_avx512novl() { return (supports_evex() &amp;&amp; !supports_avx512vl()); }
 825   static bool supports_avx512nobw() { return (supports_evex() &amp;&amp; !supports_avx512bw()); }
 826   static bool supports_avx256only() { return (supports_avx2() &amp;&amp; !supports_evex()); }
 827   static bool supports_avxonly()    { return ((supports_avx2() || supports_avx()) &amp;&amp; !supports_evex()); }
 828   static bool supports_sha()        { return (_features &amp; CPU_SHA) != 0; }
 829   static bool supports_fma()        { return (_features &amp; CPU_FMA) != 0 &amp;&amp; supports_avx(); }
 830   static bool supports_vzeroupper() { return (_features &amp; CPU_VZEROUPPER) != 0; }
 831   static bool supports_vpopcntdq()  { return (_features &amp; CPU_AVX512_VPOPCNTDQ) != 0; }
<span class="line-modified"> 832   static bool supports_vpclmulqdq() { return (_features &amp; CPU_VPCLMULQDQ) != 0; }</span>
 833   static bool supports_vaes()       { return (_features &amp; CPU_VAES) != 0; }
 834   static bool supports_vnni()       { return (_features &amp; CPU_VNNI) != 0; }

 835 
 836   // Intel features
 837   static bool is_intel_family_core() { return is_intel() &amp;&amp;
 838                                        extended_cpu_family() == CPU_FAMILY_INTEL_CORE; }
 839 



 840   static bool is_intel_tsc_synched_at_init()  {
 841     if (is_intel_family_core()) {
 842       uint32_t ext_model = extended_cpu_model();
 843       if (ext_model == CPU_MODEL_NEHALEM_EP     ||
 844           ext_model == CPU_MODEL_WESTMERE_EP    ||
 845           ext_model == CPU_MODEL_SANDYBRIDGE_EP ||
 846           ext_model == CPU_MODEL_IVYBRIDGE_EP) {
 847         // &lt;= 2-socket invariant tsc support. EX versions are usually used
 848         // in &gt; 2-socket systems and likely don&#39;t synchronize tscs at
 849         // initialization.
 850         // Code that uses tsc values must be prepared for them to arbitrarily
 851         // jump forward or backward.
 852         return true;
 853       }
 854     }
 855     return false;
 856   }
 857 
 858   // AMD features
 859   static bool supports_3dnow_prefetch()    { return (_features &amp; CPU_3DNOW_PREFETCH) != 0; }
<span class="line-modified"> 860   static bool supports_mmx_ext()  { return is_amd() &amp;&amp; _cpuid_info.ext_cpuid1_edx.bits.mmx_amd != 0; }</span>
 861   static bool supports_lzcnt()    { return (_features &amp; CPU_LZCNT) != 0; }
 862   static bool supports_sse4a()    { return (_features &amp; CPU_SSE4A) != 0; }
 863 
 864   static bool is_amd_Barcelona()  { return is_amd() &amp;&amp;
 865                                            extended_cpu_family() == CPU_FAMILY_AMD_11H; }
 866 
 867   // Intel and AMD newer cores support fast timestamps well
 868   static bool supports_tscinv_bit() {
 869     return (_features &amp; CPU_TSCINV) != 0;
 870   }
 871   static bool supports_tscinv() {
 872     return supports_tscinv_bit() &amp;&amp;
<span class="line-modified"> 873            ( (is_amd() &amp;&amp; !is_amd_Barcelona()) ||</span>
<span class="line-modified"> 874              is_intel_tsc_synched_at_init() );</span>
 875   }
 876 
 877   // Intel Core and newer cpus have fast IDIV instruction (excluding Atom).
 878   static bool has_fast_idiv()     { return is_intel() &amp;&amp; cpu_family() == 6 &amp;&amp;
 879                                            supports_sse3() &amp;&amp; _model != 0x1C; }
 880 
 881   static bool supports_compare_and_exchange() { return true; }
 882 
 883   static intx allocate_prefetch_distance(bool use_watermark_prefetch) {
 884     // Hardware prefetching (distance/size in bytes):
 885     // Pentium 3 -  64 /  32
 886     // Pentium 4 - 256 / 128
 887     // Athlon    -  64 /  32 ????
 888     // Opteron   - 128 /  64 only when 2 sequential cache lines accessed
 889     // Core      - 128 /  64
 890     //
 891     // Software prefetching (distance in bytes / instruction with best score):
 892     // Pentium 3 - 128 / prefetchnta
 893     // Pentium 4 - 512 / prefetchnta
 894     // Athlon    - 128 / prefetchnta
 895     // Opteron   - 256 / prefetchnta
 896     // Core      - 256 / prefetchnta
 897     // It will be used only when AllocatePrefetchStyle &gt; 0
 898 
<span class="line-modified"> 899     if (is_amd()) { // AMD</span>
 900       if (supports_sse2()) {
 901         return 256; // Opteron
 902       } else {
 903         return 128; // Athlon
 904       }
 905     } else { // Intel
 906       if (supports_sse3() &amp;&amp; cpu_family() == 6) {
 907         if (supports_sse4_2() &amp;&amp; supports_ht()) { // Nehalem based cpus
 908           return 192;
 909         } else if (use_watermark_prefetch) { // watermark prefetching on Core
 910 #ifdef _LP64
 911           return 384;
 912 #else
 913           return 320;
 914 #endif
 915         }
 916       }
 917       if (supports_sse2()) {
 918         if (cpu_family() == 6) {
 919           return 256; // Pentium M, Core, Core2
 920         } else {
 921           return 512; // Pentium 4
 922         }
 923       } else {
 924         return 128; // Pentium 3 (and all other old CPUs)
 925       }
 926     }
 927   }
 928 
 929   // SSE2 and later processors implement a &#39;pause&#39; instruction
 930   // that can be used for efficient implementation of
 931   // the intrinsic for java.lang.Thread.onSpinWait()
 932   static bool supports_on_spin_wait() { return supports_sse2(); }
















































 933 };
 934 
 935 #endif // CPU_X86_VM_VERSION_X86_HPP
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_VM_VERSION_X86_HPP
  26 #define CPU_X86_VM_VERSION_X86_HPP
  27 
<span class="line-added">  28 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">  29 #include &quot;runtime/abstract_vm_version.hpp&quot;</span>
  30 #include &quot;runtime/globals_extension.hpp&quot;

  31 
  32 class VM_Version : public Abstract_VM_Version {
  33   friend class VMStructs;
  34   friend class JVMCIVMStructs;
  35 
  36  public:
  37   // cpuid result register layouts.  These are all unions of a uint32_t
  38   // (in case anyone wants access to the register as a whole) and a bitfield.
  39 
  40   union StdCpuid1Eax {
  41     uint32_t value;
  42     struct {
  43       uint32_t stepping   : 4,
  44                model      : 4,
  45                family     : 4,
  46                proc_type  : 2,
  47                           : 2,
  48                ext_model  : 4,
  49                ext_family : 8,
  50                           : 4;
</pre>
<hr />
<pre>
 202   };
 203 
 204   union SefCpuid7Ebx {
 205     uint32_t value;
 206     struct {
 207       uint32_t fsgsbase : 1,
 208                         : 2,
 209                    bmi1 : 1,
 210                         : 1,
 211                    avx2 : 1,
 212                         : 2,
 213                    bmi2 : 1,
 214                    erms : 1,
 215                         : 1,
 216                     rtm : 1,
 217                         : 4,
 218                 avx512f : 1,
 219                avx512dq : 1,
 220                         : 1,
 221                     adx : 1,
<span class="line-modified"> 222                         : 3,</span>
<span class="line-added"> 223              clflushopt : 1,</span>
<span class="line-added"> 224                    clwb : 1,</span>
<span class="line-added"> 225                         : 1,</span>
 226                avx512pf : 1,
 227                avx512er : 1,
 228                avx512cd : 1,
 229                     sha : 1,
 230                avx512bw : 1,
 231                avx512vl : 1;
 232     } bits;
 233   };
 234 
 235   union SefCpuid7Ecx {
 236     uint32_t value;
 237     struct {
 238       uint32_t prefetchwt1 : 1,
 239                avx512_vbmi : 1,
 240                       umip : 1,
 241                        pku : 1,
 242                      ospke : 1,
 243                            : 1,
 244               avx512_vbmi2 : 1,
 245                            : 1,
 246                       gfni : 1,
 247                       vaes : 1,
<span class="line-modified"> 248          avx512_vpclmulqdq : 1,</span>
 249                avx512_vnni : 1,
 250              avx512_bitalg : 1,
 251                            : 1,
 252           avx512_vpopcntdq : 1,
 253                            : 17;
 254     } bits;
 255   };
 256 
 257   union SefCpuid7Edx {
 258     uint32_t value;
 259     struct {
 260       uint32_t             : 2,
 261              avx512_4vnniw : 1,
 262              avx512_4fmaps : 1,
 263                            : 28;
 264     } bits;
 265   };
 266 
 267   union ExtCpuid1EEbx {
 268     uint32_t value;
</pre>
<hr />
<pre>
 321     CPU_ERMS     = (1 &lt;&lt; 20), // enhanced &#39;rep movsb/stosb&#39; instructions
 322     CPU_CLMUL    = (1 &lt;&lt; 21), // carryless multiply for CRC
 323     CPU_BMI1     = (1 &lt;&lt; 22),
 324     CPU_BMI2     = (1 &lt;&lt; 23),
 325     CPU_RTM      = (1 &lt;&lt; 24), // Restricted Transactional Memory instructions
 326     CPU_ADX      = (1 &lt;&lt; 25),
 327     CPU_AVX512F  = (1 &lt;&lt; 26), // AVX 512bit foundation instructions
 328     CPU_AVX512DQ = (1 &lt;&lt; 27),
 329     CPU_AVX512PF = (1 &lt;&lt; 28),
 330     CPU_AVX512ER = (1 &lt;&lt; 29),
 331     CPU_AVX512CD = (1 &lt;&lt; 30)
 332     // Keeping sign bit 31 unassigned.
 333   };
 334 
 335 #define CPU_AVX512BW ((uint64_t)UCONST64(0x100000000)) // enums are limited to 31 bit
 336 #define CPU_AVX512VL ((uint64_t)UCONST64(0x200000000)) // EVEX instructions with smaller vector length
 337 #define CPU_SHA ((uint64_t)UCONST64(0x400000000))      // SHA instructions
 338 #define CPU_FMA ((uint64_t)UCONST64(0x800000000))      // FMA instructions
 339 #define CPU_VZEROUPPER ((uint64_t)UCONST64(0x1000000000))       // Vzeroupper instruction
 340 #define CPU_AVX512_VPOPCNTDQ ((uint64_t)UCONST64(0x2000000000)) // Vector popcount
<span class="line-modified"> 341 #define CPU_AVX512_VPCLMULQDQ ((uint64_t)UCONST64(0x4000000000)) //Vector carryless multiplication</span>
 342 #define CPU_VAES ((uint64_t)UCONST64(0x8000000000))    // Vector AES instructions
 343 #define CPU_VNNI ((uint64_t)UCONST64(0x10000000000))   // Vector Neural Network Instructions
 344 
<span class="line-modified"> 345 #define CPU_FLUSH ((uint64_t)UCONST64(0x20000000000))  // flush instruction</span>
<span class="line-added"> 346 #define CPU_FLUSHOPT ((uint64_t)UCONST64(0x40000000000)) // flushopt instruction</span>
<span class="line-added"> 347 #define CPU_CLWB ((uint64_t)UCONST64(0x80000000000))   // clwb instruction</span>
<span class="line-added"> 348 #define CPU_VBMI2 ((uint64_t)UCONST64(0x100000000000))   // VBMI2 shift left double instructions</span>
<span class="line-added"> 349 </span>
<span class="line-added"> 350 </span>
<span class="line-added"> 351 enum Extended_Family {</span>
 352     // AMD
 353     CPU_FAMILY_AMD_11H       = 0x11,
 354     // ZX
 355     CPU_FAMILY_ZX_CORE_F6    = 6,
 356     CPU_FAMILY_ZX_CORE_F7    = 7,
 357     // Intel
 358     CPU_FAMILY_INTEL_CORE    = 6,
 359     CPU_MODEL_NEHALEM        = 0x1e,
 360     CPU_MODEL_NEHALEM_EP     = 0x1a,
 361     CPU_MODEL_NEHALEM_EX     = 0x2e,
 362     CPU_MODEL_WESTMERE       = 0x25,
 363     CPU_MODEL_WESTMERE_EP    = 0x2c,
 364     CPU_MODEL_WESTMERE_EX    = 0x2f,
 365     CPU_MODEL_SANDYBRIDGE    = 0x2a,
 366     CPU_MODEL_SANDYBRIDGE_EP = 0x2d,
 367     CPU_MODEL_IVYBRIDGE_EP   = 0x3a,
 368     CPU_MODEL_HASWELL_E3     = 0x3c,
 369     CPU_MODEL_HASWELL_E7     = 0x3f,
 370     CPU_MODEL_BROADWELL      = 0x3d,
<span class="line-modified"> 371     CPU_MODEL_SKYLAKE        = 0x55</span>
 372   };
 373 
 374   // cpuid information block.  All info derived from executing cpuid with
 375   // various function numbers is stored here.  Intel and AMD info is
 376   // merged in this block: accessor methods disentangle it.
 377   //
 378   // The info block is laid out in subblocks of 4 dwords corresponding to
 379   // eax, ebx, ecx and edx, whether or not they contain anything useful.
 380   struct CpuidInfo {
 381     // cpuid function 0
 382     uint32_t std_max_function;
 383     uint32_t std_vendor_name_0;
 384     uint32_t std_vendor_name_1;
 385     uint32_t std_vendor_name_2;
 386 
 387     // cpuid function 1
 388     StdCpuid1Eax std_cpuid1_eax;
 389     StdCpuid1Ebx std_cpuid1_ebx;
 390     StdCpuid1Ecx std_cpuid1_ecx;
 391     StdCpuid1Edx std_cpuid1_edx;
</pre>
<hr />
<pre>
 488     result |= _cpuid_info.std_cpuid1_eax.bits.ext_model &lt;&lt; 4;
 489     return result;
 490   }
 491 
 492   static uint32_t cpu_stepping() {
 493     uint32_t result = _cpuid_info.std_cpuid1_eax.bits.stepping;
 494     return result;
 495   }
 496 
 497   static uint logical_processor_count() {
 498     uint result = threads_per_core();
 499     return result;
 500   }
 501 
 502   static uint64_t feature_flags() {
 503     uint64_t result = 0;
 504     if (_cpuid_info.std_cpuid1_edx.bits.cmpxchg8 != 0)
 505       result |= CPU_CX8;
 506     if (_cpuid_info.std_cpuid1_edx.bits.cmov != 0)
 507       result |= CPU_CMOV;
<span class="line-modified"> 508     if (_cpuid_info.std_cpuid1_edx.bits.clflush != 0)</span>
<span class="line-added"> 509       result |= CPU_FLUSH;</span>
<span class="line-added"> 510 #ifdef _LP64</span>
<span class="line-added"> 511     // clflush should always be available on x86_64</span>
<span class="line-added"> 512     // if not we are in real trouble because we rely on it</span>
<span class="line-added"> 513     // to flush the code cache.</span>
<span class="line-added"> 514     assert ((result &amp; CPU_FLUSH) != 0, &quot;clflush should be available&quot;);</span>
<span class="line-added"> 515 #endif</span>
<span class="line-added"> 516     if (_cpuid_info.std_cpuid1_edx.bits.fxsr != 0 || (is_amd_family() &amp;&amp;</span>
 517         _cpuid_info.ext_cpuid1_edx.bits.fxsr != 0))
 518       result |= CPU_FXSR;
 519     // HT flag is set for multi-core processors also.
 520     if (threads_per_core() &gt; 1)
 521       result |= CPU_HT;
<span class="line-modified"> 522     if (_cpuid_info.std_cpuid1_edx.bits.mmx != 0 || (is_amd_family() &amp;&amp;</span>
 523         _cpuid_info.ext_cpuid1_edx.bits.mmx != 0))
 524       result |= CPU_MMX;
 525     if (_cpuid_info.std_cpuid1_edx.bits.sse != 0)
 526       result |= CPU_SSE;
 527     if (_cpuid_info.std_cpuid1_edx.bits.sse2 != 0)
 528       result |= CPU_SSE2;
 529     if (_cpuid_info.std_cpuid1_ecx.bits.sse3 != 0)
 530       result |= CPU_SSE3;
 531     if (_cpuid_info.std_cpuid1_ecx.bits.ssse3 != 0)
 532       result |= CPU_SSSE3;
 533     if (_cpuid_info.std_cpuid1_ecx.bits.sse4_1 != 0)
 534       result |= CPU_SSE4_1;
 535     if (_cpuid_info.std_cpuid1_ecx.bits.sse4_2 != 0)
 536       result |= CPU_SSE4_2;
 537     if (_cpuid_info.std_cpuid1_ecx.bits.popcnt != 0)
 538       result |= CPU_POPCNT;
 539     if (_cpuid_info.std_cpuid1_ecx.bits.avx != 0 &amp;&amp;
 540         _cpuid_info.std_cpuid1_ecx.bits.osxsave != 0 &amp;&amp;
 541         _cpuid_info.xem_xcr0_eax.bits.sse != 0 &amp;&amp;
 542         _cpuid_info.xem_xcr0_eax.bits.ymm != 0) {
</pre>
<hr />
<pre>
 546         result |= CPU_AVX2;
 547       if (_cpuid_info.sef_cpuid7_ebx.bits.avx512f != 0 &amp;&amp;
 548           _cpuid_info.xem_xcr0_eax.bits.opmask != 0 &amp;&amp;
 549           _cpuid_info.xem_xcr0_eax.bits.zmm512 != 0 &amp;&amp;
 550           _cpuid_info.xem_xcr0_eax.bits.zmm32 != 0) {
 551         result |= CPU_AVX512F;
 552         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512cd != 0)
 553           result |= CPU_AVX512CD;
 554         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512dq != 0)
 555           result |= CPU_AVX512DQ;
 556         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512pf != 0)
 557           result |= CPU_AVX512PF;
 558         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512er != 0)
 559           result |= CPU_AVX512ER;
 560         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512bw != 0)
 561           result |= CPU_AVX512BW;
 562         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512vl != 0)
 563           result |= CPU_AVX512VL;
 564         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpopcntdq != 0)
 565           result |= CPU_AVX512_VPOPCNTDQ;
<span class="line-modified"> 566         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpclmulqdq != 0)</span>
<span class="line-modified"> 567           result |= CPU_AVX512_VPCLMULQDQ;</span>
 568         if (_cpuid_info.sef_cpuid7_ecx.bits.vaes != 0)
 569           result |= CPU_VAES;
 570         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vnni != 0)
 571           result |= CPU_VNNI;
<span class="line-added"> 572         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vbmi2 != 0)</span>
<span class="line-added"> 573           result |= CPU_VBMI2;</span>
 574       }
 575     }
<span class="line-modified"> 576     if (_cpuid_info.sef_cpuid7_ebx.bits.bmi1 != 0)</span>
 577       result |= CPU_BMI1;
 578     if (_cpuid_info.std_cpuid1_edx.bits.tsc != 0)
 579       result |= CPU_TSC;
 580     if (_cpuid_info.ext_cpuid7_edx.bits.tsc_invariance != 0)
 581       result |= CPU_TSCINV;
 582     if (_cpuid_info.std_cpuid1_ecx.bits.aes != 0)
 583       result |= CPU_AES;
 584     if (_cpuid_info.sef_cpuid7_ebx.bits.erms != 0)
 585       result |= CPU_ERMS;
 586     if (_cpuid_info.std_cpuid1_ecx.bits.clmul != 0)
 587       result |= CPU_CLMUL;
 588     if (_cpuid_info.sef_cpuid7_ebx.bits.rtm != 0)
 589       result |= CPU_RTM;
<span class="line-modified"> 590     if (_cpuid_info.sef_cpuid7_ebx.bits.adx != 0)</span>
 591        result |= CPU_ADX;
<span class="line-modified"> 592     if (_cpuid_info.sef_cpuid7_ebx.bits.bmi2 != 0)</span>
 593       result |= CPU_BMI2;
 594     if (_cpuid_info.sef_cpuid7_ebx.bits.sha != 0)
 595       result |= CPU_SHA;
 596     if (_cpuid_info.std_cpuid1_ecx.bits.fma != 0)
 597       result |= CPU_FMA;
<span class="line-added"> 598     if (_cpuid_info.sef_cpuid7_ebx.bits.clflushopt != 0)</span>
<span class="line-added"> 599       result |= CPU_FLUSHOPT;</span>
 600 
<span class="line-modified"> 601     // AMD|Hygon features.</span>
<span class="line-modified"> 602     if (is_amd_family()) {</span>
 603       if ((_cpuid_info.ext_cpuid1_edx.bits.tdnow != 0) ||
 604           (_cpuid_info.ext_cpuid1_ecx.bits.prefetchw != 0))
 605         result |= CPU_3DNOW_PREFETCH;
 606       if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt != 0)
 607         result |= CPU_LZCNT;
 608       if (_cpuid_info.ext_cpuid1_ecx.bits.sse4a != 0)
 609         result |= CPU_SSE4A;
 610     }
 611     // Intel features.
<span class="line-modified"> 612     if (is_intel()) {</span>
<span class="line-modified"> 613       if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)</span>
 614         result |= CPU_LZCNT;
 615       // for Intel, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw
 616       if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {
 617         result |= CPU_3DNOW_PREFETCH;
 618       }
<span class="line-added"> 619       if (_cpuid_info.sef_cpuid7_ebx.bits.clwb != 0) {</span>
<span class="line-added"> 620         result |= CPU_CLWB;</span>
<span class="line-added"> 621       }</span>
 622     }
 623 
 624     // ZX features.
 625     if (is_zx()) {
 626       if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)
 627         result |= CPU_LZCNT;
 628       // for ZX, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw
 629       if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {
 630         result |= CPU_3DNOW_PREFETCH;
 631       }
 632     }
 633 
 634     return result;
 635   }
 636 
 637   static bool os_supports_avx_vectors() {
 638     bool retVal = false;
 639     int nreg = 2 LP64_ONLY(+2);
 640     if (supports_evex()) {
 641       // Verify that OS save/restore all bits of EVEX registers
</pre>
<hr />
<pre>
 693   static ByteSize ymm_save_offset() { return byte_offset_of(CpuidInfo, ymm_save); }
 694   static ByteSize zmm_save_offset() { return byte_offset_of(CpuidInfo, zmm_save); }
 695 
 696   // The value used to check ymm register after signal handle
 697   static int ymm_test_value()    { return 0xCAFEBABE; }
 698 
 699   static void get_cpu_info_wrapper();
 700   static void set_cpuinfo_segv_addr(address pc) { _cpuinfo_segv_addr = pc; }
 701   static bool  is_cpuinfo_segv_addr(address pc) { return _cpuinfo_segv_addr == pc; }
 702   static void set_cpuinfo_cont_addr(address pc) { _cpuinfo_cont_addr = pc; }
 703   static address  cpuinfo_cont_addr()           { return _cpuinfo_cont_addr; }
 704 
 705   static void clean_cpuFeatures()   { _features = 0; }
 706   static void set_avx_cpuFeatures() { _features = (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }
 707   static void set_evex_cpuFeatures() { _features = (CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }
 708 
 709 
 710   // Initialization
 711   static void initialize();
 712 
<span class="line-added"> 713   // Override Abstract_VM_Version implementation</span>
<span class="line-added"> 714   static void print_platform_virtualization_info(outputStream*);</span>
<span class="line-added"> 715 </span>
 716   // Override Abstract_VM_Version implementation
 717   static bool use_biased_locking();
 718 
 719   // Asserts
 720   static void assert_is_initialized() {
 721     assert(_cpuid_info.std_cpuid1_eax.bits.family != 0, &quot;VM_Version not initialized&quot;);
 722   }
 723 
 724   //
 725   // Processor family:
 726   //       3   -  386
 727   //       4   -  486
 728   //       5   -  Pentium
 729   //       6   -  PentiumPro, Pentium II, Celeron, Xeon, Pentium III, Athlon,
 730   //              Pentium M, Core Solo, Core Duo, Core2 Duo
 731   //    family 6 model:   9,        13,       14,        15
 732   //    0x0f   -  Pentium 4, Opteron
 733   //
 734   // Note: The cpu family should be used to select between
 735   //       instruction sequences which are valid on all Intel
 736   //       processors.  Use the feature test functions below to
 737   //       determine whether a particular instruction is supported.
 738   //
 739   static int  cpu_family()        { return _cpu;}
 740   static bool is_P6()             { return cpu_family() &gt;= 6; }
 741   static bool is_amd()            { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x68747541; } // &#39;htuA&#39;
<span class="line-added"> 742   static bool is_hygon()          { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x6F677948; } // &#39;ogyH&#39;</span>
<span class="line-added"> 743   static bool is_amd_family()     { return is_amd() || is_hygon(); }</span>
 744   static bool is_intel()          { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x756e6547; } // &#39;uneG&#39;
 745   static bool is_zx()             { assert_is_initialized(); return (_cpuid_info.std_vendor_name_0 == 0x746e6543) || (_cpuid_info.std_vendor_name_0 == 0x68532020); } // &#39;tneC&#39;||&#39;hS  &#39;
 746   static bool is_atom_family()    { return ((cpu_family() == 0x06) &amp;&amp; ((extended_cpu_model() == 0x36) || (extended_cpu_model() == 0x37) || (extended_cpu_model() == 0x4D))); } //Silvermont and Centerton
 747   static bool is_knights_family() { return ((cpu_family() == 0x06) &amp;&amp; ((extended_cpu_model() == 0x57) || (extended_cpu_model() == 0x85))); } // Xeon Phi 3200/5200/7200 and Future Xeon Phi
 748 
 749   static bool supports_processor_topology() {
 750     return (_cpuid_info.std_max_function &gt;= 0xB) &amp;&amp;
 751            // eax[4:0] | ebx[0:15] == 0 indicates invalid topology level.
 752            // Some cpus have max cpuid &gt;= 0xB but do not support processor topology.
 753            (((_cpuid_info.tpl_cpuidB0_eax &amp; 0x1f) | _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus) != 0);
 754   }
 755 
 756   static uint cores_per_cpu()  {
 757     uint result = 1;
 758     if (is_intel()) {
 759       bool supports_topology = supports_processor_topology();
 760       if (supports_topology) {
 761         result = _cpuid_info.tpl_cpuidB1_ebx.bits.logical_cpus /
 762                  _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 763       }
 764       if (!supports_topology || result == 0) {
 765         result = (_cpuid_info.dcp_cpuid4_eax.bits.cores_per_cpu + 1);
 766       }
<span class="line-modified"> 767     } else if (is_amd_family()) {</span>
 768       result = (_cpuid_info.ext_cpuid8_ecx.bits.cores_per_cpu + 1);
 769     } else if (is_zx()) {
 770       bool supports_topology = supports_processor_topology();
 771       if (supports_topology) {
 772         result = _cpuid_info.tpl_cpuidB1_ebx.bits.logical_cpus /
 773                  _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 774       }
 775       if (!supports_topology || result == 0) {
 776         result = (_cpuid_info.dcp_cpuid4_eax.bits.cores_per_cpu + 1);
 777       }
 778     }
 779     return result;
 780   }
 781 
 782   static uint threads_per_core()  {
 783     uint result = 1;
 784     if (is_intel() &amp;&amp; supports_processor_topology()) {
 785       result = _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 786     } else if (is_zx() &amp;&amp; supports_processor_topology()) {
 787       result = _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
 788     } else if (_cpuid_info.std_cpuid1_edx.bits.ht != 0) {
 789       if (cpu_family() &gt;= 0x17) {
 790         result = _cpuid_info.ext_cpuid1E_ebx.bits.threads_per_core + 1;
 791       } else {
 792         result = _cpuid_info.std_cpuid1_ebx.bits.threads_per_cpu /
 793                  cores_per_cpu();
 794       }
 795     }
 796     return (result == 0 ? 1 : result);
 797   }
 798 
 799   static intx L1_line_size()  {
 800     intx result = 0;
 801     if (is_intel()) {
 802       result = (_cpuid_info.dcp_cpuid4_ebx.bits.L1_line_size + 1);
<span class="line-modified"> 803     } else if (is_amd_family()) {</span>
 804       result = _cpuid_info.ext_cpuid5_ecx.bits.L1_line_size;
 805     } else if (is_zx()) {
 806       result = (_cpuid_info.dcp_cpuid4_ebx.bits.L1_line_size + 1);
 807     }
 808     if (result &lt; 32) // not defined ?
 809       result = 32;   // 32 bytes by default on x86 and other x64
 810     return result;
 811   }
 812 
 813   static intx prefetch_data_size()  {
 814     return L1_line_size();
 815   }
 816 
 817   //
 818   // Feature identification
 819   //
 820   static bool supports_cpuid()    { return _features  != 0; }
 821   static bool supports_cmpxchg8() { return (_features &amp; CPU_CX8) != 0; }
 822   static bool supports_cmov()     { return (_features &amp; CPU_CMOV) != 0; }
 823   static bool supports_fxsr()     { return (_features &amp; CPU_FXSR) != 0; }
</pre>
<hr />
<pre>
 842   static bool supports_adx()      { return (_features &amp; CPU_ADX) != 0; }
 843   static bool supports_evex()     { return (_features &amp; CPU_AVX512F) != 0; }
 844   static bool supports_avx512dq() { return (_features &amp; CPU_AVX512DQ) != 0; }
 845   static bool supports_avx512pf() { return (_features &amp; CPU_AVX512PF) != 0; }
 846   static bool supports_avx512er() { return (_features &amp; CPU_AVX512ER) != 0; }
 847   static bool supports_avx512cd() { return (_features &amp; CPU_AVX512CD) != 0; }
 848   static bool supports_avx512bw() { return (_features &amp; CPU_AVX512BW) != 0; }
 849   static bool supports_avx512vl() { return (_features &amp; CPU_AVX512VL) != 0; }
 850   static bool supports_avx512vlbw() { return (supports_evex() &amp;&amp; supports_avx512bw() &amp;&amp; supports_avx512vl()); }
 851   static bool supports_avx512vldq() { return (supports_evex() &amp;&amp; supports_avx512dq() &amp;&amp; supports_avx512vl()); }
 852   static bool supports_avx512vlbwdq() { return (supports_evex() &amp;&amp; supports_avx512vl() &amp;&amp;
 853                                                 supports_avx512bw() &amp;&amp; supports_avx512dq()); }
 854   static bool supports_avx512novl() { return (supports_evex() &amp;&amp; !supports_avx512vl()); }
 855   static bool supports_avx512nobw() { return (supports_evex() &amp;&amp; !supports_avx512bw()); }
 856   static bool supports_avx256only() { return (supports_avx2() &amp;&amp; !supports_evex()); }
 857   static bool supports_avxonly()    { return ((supports_avx2() || supports_avx()) &amp;&amp; !supports_evex()); }
 858   static bool supports_sha()        { return (_features &amp; CPU_SHA) != 0; }
 859   static bool supports_fma()        { return (_features &amp; CPU_FMA) != 0 &amp;&amp; supports_avx(); }
 860   static bool supports_vzeroupper() { return (_features &amp; CPU_VZEROUPPER) != 0; }
 861   static bool supports_vpopcntdq()  { return (_features &amp; CPU_AVX512_VPOPCNTDQ) != 0; }
<span class="line-modified"> 862   static bool supports_avx512_vpclmulqdq() { return (_features &amp; CPU_AVX512_VPCLMULQDQ) != 0; }</span>
 863   static bool supports_vaes()       { return (_features &amp; CPU_VAES) != 0; }
 864   static bool supports_vnni()       { return (_features &amp; CPU_VNNI) != 0; }
<span class="line-added"> 865   static bool supports_vbmi2()      { return (_features &amp; CPU_VBMI2) != 0; }</span>
 866 
 867   // Intel features
 868   static bool is_intel_family_core() { return is_intel() &amp;&amp;
 869                                        extended_cpu_family() == CPU_FAMILY_INTEL_CORE; }
 870 
<span class="line-added"> 871   static bool is_intel_skylake() { return is_intel_family_core() &amp;&amp;</span>
<span class="line-added"> 872                                           extended_cpu_model() == CPU_MODEL_SKYLAKE; }</span>
<span class="line-added"> 873 </span>
 874   static bool is_intel_tsc_synched_at_init()  {
 875     if (is_intel_family_core()) {
 876       uint32_t ext_model = extended_cpu_model();
 877       if (ext_model == CPU_MODEL_NEHALEM_EP     ||
 878           ext_model == CPU_MODEL_WESTMERE_EP    ||
 879           ext_model == CPU_MODEL_SANDYBRIDGE_EP ||
 880           ext_model == CPU_MODEL_IVYBRIDGE_EP) {
 881         // &lt;= 2-socket invariant tsc support. EX versions are usually used
 882         // in &gt; 2-socket systems and likely don&#39;t synchronize tscs at
 883         // initialization.
 884         // Code that uses tsc values must be prepared for them to arbitrarily
 885         // jump forward or backward.
 886         return true;
 887       }
 888     }
 889     return false;
 890   }
 891 
 892   // AMD features
 893   static bool supports_3dnow_prefetch()    { return (_features &amp; CPU_3DNOW_PREFETCH) != 0; }
<span class="line-modified"> 894   static bool supports_mmx_ext()  { return is_amd_family() &amp;&amp; _cpuid_info.ext_cpuid1_edx.bits.mmx_amd != 0; }</span>
 895   static bool supports_lzcnt()    { return (_features &amp; CPU_LZCNT) != 0; }
 896   static bool supports_sse4a()    { return (_features &amp; CPU_SSE4A) != 0; }
 897 
 898   static bool is_amd_Barcelona()  { return is_amd() &amp;&amp;
 899                                            extended_cpu_family() == CPU_FAMILY_AMD_11H; }
 900 
 901   // Intel and AMD newer cores support fast timestamps well
 902   static bool supports_tscinv_bit() {
 903     return (_features &amp; CPU_TSCINV) != 0;
 904   }
 905   static bool supports_tscinv() {
 906     return supports_tscinv_bit() &amp;&amp;
<span class="line-modified"> 907       ((is_amd_family() &amp;&amp; !is_amd_Barcelona()) ||</span>
<span class="line-modified"> 908         is_intel_tsc_synched_at_init());</span>
 909   }
 910 
 911   // Intel Core and newer cpus have fast IDIV instruction (excluding Atom).
 912   static bool has_fast_idiv()     { return is_intel() &amp;&amp; cpu_family() == 6 &amp;&amp;
 913                                            supports_sse3() &amp;&amp; _model != 0x1C; }
 914 
 915   static bool supports_compare_and_exchange() { return true; }
 916 
 917   static intx allocate_prefetch_distance(bool use_watermark_prefetch) {
 918     // Hardware prefetching (distance/size in bytes):
 919     // Pentium 3 -  64 /  32
 920     // Pentium 4 - 256 / 128
 921     // Athlon    -  64 /  32 ????
 922     // Opteron   - 128 /  64 only when 2 sequential cache lines accessed
 923     // Core      - 128 /  64
 924     //
 925     // Software prefetching (distance in bytes / instruction with best score):
 926     // Pentium 3 - 128 / prefetchnta
 927     // Pentium 4 - 512 / prefetchnta
 928     // Athlon    - 128 / prefetchnta
 929     // Opteron   - 256 / prefetchnta
 930     // Core      - 256 / prefetchnta
 931     // It will be used only when AllocatePrefetchStyle &gt; 0
 932 
<span class="line-modified"> 933     if (is_amd_family()) { // AMD | Hygon</span>
 934       if (supports_sse2()) {
 935         return 256; // Opteron
 936       } else {
 937         return 128; // Athlon
 938       }
 939     } else { // Intel
 940       if (supports_sse3() &amp;&amp; cpu_family() == 6) {
 941         if (supports_sse4_2() &amp;&amp; supports_ht()) { // Nehalem based cpus
 942           return 192;
 943         } else if (use_watermark_prefetch) { // watermark prefetching on Core
 944 #ifdef _LP64
 945           return 384;
 946 #else
 947           return 320;
 948 #endif
 949         }
 950       }
 951       if (supports_sse2()) {
 952         if (cpu_family() == 6) {
 953           return 256; // Pentium M, Core, Core2
 954         } else {
 955           return 512; // Pentium 4
 956         }
 957       } else {
 958         return 128; // Pentium 3 (and all other old CPUs)
 959       }
 960     }
 961   }
 962 
 963   // SSE2 and later processors implement a &#39;pause&#39; instruction
 964   // that can be used for efficient implementation of
 965   // the intrinsic for java.lang.Thread.onSpinWait()
 966   static bool supports_on_spin_wait() { return supports_sse2(); }
<span class="line-added"> 967 </span>
<span class="line-added"> 968   // x86_64 supports fast class initialization checks for static methods.</span>
<span class="line-added"> 969   static bool supports_fast_class_init_checks() {</span>
<span class="line-added"> 970     return LP64_ONLY(true) NOT_LP64(false); // not implemented on x86_32</span>
<span class="line-added"> 971   }</span>
<span class="line-added"> 972 </span>
<span class="line-added"> 973   // there are several insns to force cache line sync to memory which</span>
<span class="line-added"> 974   // we can use to ensure mapped non-volatile memory is up to date with</span>
<span class="line-added"> 975   // pending in-cache changes.</span>
<span class="line-added"> 976   //</span>
<span class="line-added"> 977   // 64 bit cpus always support clflush which writes back and evicts</span>
<span class="line-added"> 978   // on 32 bit cpus support is recorded via a feature flag</span>
<span class="line-added"> 979   //</span>
<span class="line-added"> 980   // clflushopt is optional and acts like clflush except it does</span>
<span class="line-added"> 981   // not synchronize with other memory ops. it needs a preceding</span>
<span class="line-added"> 982   // and trailing StoreStore fence</span>
<span class="line-added"> 983   //</span>
<span class="line-added"> 984   // clwb is an optional, intel-specific instruction optional which</span>
<span class="line-added"> 985   // writes back without evicting the line. it also does not</span>
<span class="line-added"> 986   // synchronize with other memory ops. so, it also needs a preceding</span>
<span class="line-added"> 987   // and trailing StoreStore fence.</span>
<span class="line-added"> 988 </span>
<span class="line-added"> 989 #ifdef _LP64</span>
<span class="line-added"> 990   static bool supports_clflush() {</span>
<span class="line-added"> 991     // clflush should always be available on x86_64</span>
<span class="line-added"> 992     // if not we are in real trouble because we rely on it</span>
<span class="line-added"> 993     // to flush the code cache.</span>
<span class="line-added"> 994     // Unfortunately, Assembler::clflush is currently called as part</span>
<span class="line-added"> 995     // of generation of the code cache flush routine. This happens</span>
<span class="line-added"> 996     // under Universe::init before the processor features are set</span>
<span class="line-added"> 997     // up. Assembler::flush calls this routine to check that clflush</span>
<span class="line-added"> 998     // is allowed. So, we give the caller a free pass if Universe init</span>
<span class="line-added"> 999     // is still in progress.</span>
<span class="line-added">1000     assert ((!Universe::is_fully_initialized() || (_features &amp; CPU_FLUSH) != 0), &quot;clflush should be available&quot;);</span>
<span class="line-added">1001     return true;</span>
<span class="line-added">1002   }</span>
<span class="line-added">1003   static bool supports_clflushopt() { return ((_features &amp; CPU_FLUSHOPT) != 0); }</span>
<span class="line-added">1004   static bool supports_clwb() { return ((_features &amp; CPU_CLWB) != 0); }</span>
<span class="line-added">1005 #else</span>
<span class="line-added">1006   static bool supports_clflush() { return  ((_features &amp; CPU_FLUSH) != 0); }</span>
<span class="line-added">1007   static bool supports_clflushopt() { return false; }</span>
<span class="line-added">1008   static bool supports_clwb() { return false; }</span>
<span class="line-added">1009 #endif // _LP64</span>
<span class="line-added">1010 </span>
<span class="line-added">1011   // support functions for virtualization detection</span>
<span class="line-added">1012  private:</span>
<span class="line-added">1013   static void check_virt_cpuid(uint32_t idx, uint32_t *regs);</span>
<span class="line-added">1014   static void check_virtualizations();</span>
1015 };
1016 
1017 #endif // CPU_X86_VM_VERSION_X86_HPP
</pre>
</td>
</tr>
</table>
<center><a href="vm_version_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86.ad.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
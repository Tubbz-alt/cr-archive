<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/jniFastGetField_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jniFastGetField_x86_32.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCodeInstaller_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/jniFastGetField_x86_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;gc/shared/barrierSet.hpp&quot;
 28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;prims/jniFastGetField.hpp&quot;
 31 #include &quot;prims/jvm_misc.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 
 34 #define __ masm-&gt;
 35 
 36 #define BUFFER_SIZE 30*wordSize
 37 
 38 // Common register usage:
 39 // rax/xmm0: result
 40 // c_rarg0:    jni env
 41 // c_rarg1:    obj
 42 // c_rarg2:    jfield id
 43 
<span class="line-modified"> 44 static const Register rtmp          = r8;</span>
<span class="line-modified"> 45 static const Register robj          = r9;</span>
<span class="line-modified"> 46 static const Register rcounter      = r10;</span>
<span class="line-modified"> 47 static const Register roffset       = r11;</span>
<span class="line-removed"> 48 static const Register rcounter_addr = r11;</span>
 49 
 50 // Warning: do not use rip relative addressing after the first counter load
 51 // since that may scratch r10!
 52 
 53 address JNI_FastGetField::generate_fast_get_int_field0(BasicType type) {
 54   const char *name = NULL;
 55   switch (type) {
 56     case T_BOOLEAN: name = &quot;jni_fast_GetBooleanField&quot;; break;
 57     case T_BYTE:    name = &quot;jni_fast_GetByteField&quot;;    break;
 58     case T_CHAR:    name = &quot;jni_fast_GetCharField&quot;;    break;
 59     case T_SHORT:   name = &quot;jni_fast_GetShortField&quot;;   break;
 60     case T_INT:     name = &quot;jni_fast_GetIntField&quot;;     break;
 61     case T_LONG:    name = &quot;jni_fast_GetLongField&quot;;    break;
 62     default:        ShouldNotReachHere();
 63   }
 64   ResourceMark rm;
 65   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE);
 66   CodeBuffer cbuf(blob);
 67   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
 68   address fast_entry = __ pc();
 69 
 70   Label slow;
 71 
 72   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
 73   __ mov32 (rcounter, counter);
 74   __ mov   (robj, c_rarg1);
 75   __ testb (rcounter, 1);
 76   __ jcc (Assembler::notZero, slow);









 77   __ mov   (roffset, c_rarg2);
 78   __ shrptr(roffset, 2);                         // offset
 79 
 80   // Both robj and rtmp are clobbered by try_resolve_jobject_in_native.
 81   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 82   bs-&gt;try_resolve_jobject_in_native(masm, /* jni_env */ c_rarg0, robj, rtmp, slow);
 83   DEBUG_ONLY(__ movl(rtmp, 0xDEADC0DE);)
 84 
 85   assert(count &lt; LIST_CAPACITY, &quot;LIST_CAPACITY too small&quot;);
 86   speculative_load_pclist[count] = __ pc();
 87   switch (type) {
 88     case T_BOOLEAN: __ movzbl (rax, Address(robj, roffset, Address::times_1)); break;
 89     case T_BYTE:    __ movsbl (rax, Address(robj, roffset, Address::times_1)); break;
 90     case T_CHAR:    __ movzwl (rax, Address(robj, roffset, Address::times_1)); break;
 91     case T_SHORT:   __ movswl (rax, Address(robj, roffset, Address::times_1)); break;
 92     case T_INT:     __ movl   (rax, Address(robj, roffset, Address::times_1)); break;
 93     case T_LONG:    __ movq   (rax, Address(robj, roffset, Address::times_1)); break;
 94     default:        ShouldNotReachHere();
 95   }
 96 
</pre>
<hr />
<pre>
147   const char *name = NULL;
148   switch (type) {
149     case T_FLOAT:     name = &quot;jni_fast_GetFloatField&quot;;     break;
150     case T_DOUBLE:    name = &quot;jni_fast_GetDoubleField&quot;;    break;
151     default:          ShouldNotReachHere();
152   }
153   ResourceMark rm;
154   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE);
155   CodeBuffer cbuf(blob);
156   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
157   address fast_entry = __ pc();
158 
159   Label slow;
160 
161   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
162   __ mov32 (rcounter, counter);
163   __ mov   (robj, c_rarg1);
164   __ testb (rcounter, 1);
165   __ jcc (Assembler::notZero, slow);
166 







167   // Both robj and rtmp are clobbered by try_resolve_jobject_in_native.
168   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
169   bs-&gt;try_resolve_jobject_in_native(masm, /* jni_env */ c_rarg0, robj, rtmp, slow);
170   DEBUG_ONLY(__ movl(rtmp, 0xDEADC0DE);)
171 
172   __ mov   (roffset, c_rarg2);
173   __ shrptr(roffset, 2);                         // offset
174 
175   assert(count &lt; LIST_CAPACITY, &quot;LIST_CAPACITY too small&quot;);
176   speculative_load_pclist[count] = __ pc();
177   switch (type) {
178     case T_FLOAT:  __ movflt (xmm0, Address(robj, roffset, Address::times_1)); break;
179     case T_DOUBLE: __ movdbl (xmm0, Address(robj, roffset, Address::times_1)); break;
180     default:        ShouldNotReachHere();
181   }
182   __ cmp32 (rcounter, counter);
183   __ jcc (Assembler::notEqual, slow);
184 
185   __ ret (0);
186 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;gc/shared/barrierSet.hpp&quot;
 28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;prims/jniFastGetField.hpp&quot;
 31 #include &quot;prims/jvm_misc.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 
 34 #define __ masm-&gt;
 35 
 36 #define BUFFER_SIZE 30*wordSize
 37 
 38 // Common register usage:
 39 // rax/xmm0: result
 40 // c_rarg0:    jni env
 41 // c_rarg1:    obj
 42 // c_rarg2:    jfield id
 43 
<span class="line-modified"> 44 static const Register rtmp     = rax; // r8 == c_rarg2 on Windows</span>
<span class="line-modified"> 45 static const Register robj     = r9;</span>
<span class="line-modified"> 46 static const Register roffset  = r10;</span>
<span class="line-modified"> 47 static const Register rcounter = r11;</span>

 48 
 49 // Warning: do not use rip relative addressing after the first counter load
 50 // since that may scratch r10!
 51 
 52 address JNI_FastGetField::generate_fast_get_int_field0(BasicType type) {
 53   const char *name = NULL;
 54   switch (type) {
 55     case T_BOOLEAN: name = &quot;jni_fast_GetBooleanField&quot;; break;
 56     case T_BYTE:    name = &quot;jni_fast_GetByteField&quot;;    break;
 57     case T_CHAR:    name = &quot;jni_fast_GetCharField&quot;;    break;
 58     case T_SHORT:   name = &quot;jni_fast_GetShortField&quot;;   break;
 59     case T_INT:     name = &quot;jni_fast_GetIntField&quot;;     break;
 60     case T_LONG:    name = &quot;jni_fast_GetLongField&quot;;    break;
 61     default:        ShouldNotReachHere();
 62   }
 63   ResourceMark rm;
 64   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE);
 65   CodeBuffer cbuf(blob);
 66   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
 67   address fast_entry = __ pc();
 68 
 69   Label slow;
 70 
 71   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
 72   __ mov32 (rcounter, counter);
 73   __ mov   (robj, c_rarg1);
 74   __ testb (rcounter, 1);
 75   __ jcc (Assembler::notZero, slow);
<span class="line-added"> 76 </span>
<span class="line-added"> 77   if (JvmtiExport::can_post_field_access()) {</span>
<span class="line-added"> 78     // Check to see if a field access watch has been set before we</span>
<span class="line-added"> 79     // take the fast path.</span>
<span class="line-added"> 80     assert_different_registers(rscratch1, robj, rcounter); // cmp32 clobbers rscratch1!</span>
<span class="line-added"> 81     __ cmp32(ExternalAddress((address) JvmtiExport::get_field_access_count_addr()), 0);</span>
<span class="line-added"> 82     __ jcc(Assembler::notZero, slow);</span>
<span class="line-added"> 83   }</span>
<span class="line-added"> 84 </span>
 85   __ mov   (roffset, c_rarg2);
 86   __ shrptr(roffset, 2);                         // offset
 87 
 88   // Both robj and rtmp are clobbered by try_resolve_jobject_in_native.
 89   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 90   bs-&gt;try_resolve_jobject_in_native(masm, /* jni_env */ c_rarg0, robj, rtmp, slow);
 91   DEBUG_ONLY(__ movl(rtmp, 0xDEADC0DE);)
 92 
 93   assert(count &lt; LIST_CAPACITY, &quot;LIST_CAPACITY too small&quot;);
 94   speculative_load_pclist[count] = __ pc();
 95   switch (type) {
 96     case T_BOOLEAN: __ movzbl (rax, Address(robj, roffset, Address::times_1)); break;
 97     case T_BYTE:    __ movsbl (rax, Address(robj, roffset, Address::times_1)); break;
 98     case T_CHAR:    __ movzwl (rax, Address(robj, roffset, Address::times_1)); break;
 99     case T_SHORT:   __ movswl (rax, Address(robj, roffset, Address::times_1)); break;
100     case T_INT:     __ movl   (rax, Address(robj, roffset, Address::times_1)); break;
101     case T_LONG:    __ movq   (rax, Address(robj, roffset, Address::times_1)); break;
102     default:        ShouldNotReachHere();
103   }
104 
</pre>
<hr />
<pre>
155   const char *name = NULL;
156   switch (type) {
157     case T_FLOAT:     name = &quot;jni_fast_GetFloatField&quot;;     break;
158     case T_DOUBLE:    name = &quot;jni_fast_GetDoubleField&quot;;    break;
159     default:          ShouldNotReachHere();
160   }
161   ResourceMark rm;
162   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE);
163   CodeBuffer cbuf(blob);
164   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
165   address fast_entry = __ pc();
166 
167   Label slow;
168 
169   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
170   __ mov32 (rcounter, counter);
171   __ mov   (robj, c_rarg1);
172   __ testb (rcounter, 1);
173   __ jcc (Assembler::notZero, slow);
174 
<span class="line-added">175   if (JvmtiExport::can_post_field_access()) {</span>
<span class="line-added">176     // Check to see if a field access watch has been set before we</span>
<span class="line-added">177     // take the fast path.</span>
<span class="line-added">178     __ cmp32(ExternalAddress((address) JvmtiExport::get_field_access_count_addr()), 0);</span>
<span class="line-added">179     __ jcc(Assembler::notZero, slow);</span>
<span class="line-added">180   }</span>
<span class="line-added">181 </span>
182   // Both robj and rtmp are clobbered by try_resolve_jobject_in_native.
183   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
184   bs-&gt;try_resolve_jobject_in_native(masm, /* jni_env */ c_rarg0, robj, rtmp, slow);
185   DEBUG_ONLY(__ movl(rtmp, 0xDEADC0DE);)
186 
187   __ mov   (roffset, c_rarg2);
188   __ shrptr(roffset, 2);                         // offset
189 
190   assert(count &lt; LIST_CAPACITY, &quot;LIST_CAPACITY too small&quot;);
191   speculative_load_pclist[count] = __ pc();
192   switch (type) {
193     case T_FLOAT:  __ movflt (xmm0, Address(robj, roffset, Address::times_1)); break;
194     case T_DOUBLE: __ movdbl (xmm0, Address(robj, roffset, Address::times_1)); break;
195     default:        ShouldNotReachHere();
196   }
197   __ cmp32 (rcounter, counter);
198   __ jcc (Assembler::notEqual, slow);
199 
200   __ ret (0);
201 
</pre>
</td>
</tr>
</table>
<center><a href="jniFastGetField_x86_32.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCodeInstaller_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
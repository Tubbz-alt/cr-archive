<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_32.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="x86.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_64.ad.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_32.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 1292   // Check for second word integer load
 1293   if( dst_second_rc == rc_int &amp;&amp; src_second_rc == rc_stack )
 1294     return impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),dst_second,0x8B,&quot;MOV &quot;,size, st);
 1295 
 1296 
 1297   Unimplemented();
 1298   return 0; // Mute compiler
 1299 }
 1300 
 1301 #ifndef PRODUCT
 1302 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1303   implementation( NULL, ra_, false, st );
 1304 }
 1305 #endif
 1306 
 1307 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1308   implementation( &amp;cbuf, ra_, false, NULL );
 1309 }
 1310 
 1311 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1312   return implementation( NULL, ra_, true, NULL );</span>
 1313 }
 1314 
 1315 
 1316 //=============================================================================
 1317 #ifndef PRODUCT
 1318 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1319   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1320   int reg = ra_-&gt;get_reg_first(this);
 1321   st-&gt;print(&quot;LEA    %s,[ESP + #%d]&quot;,Matcher::regName[reg],offset);
 1322 }
 1323 #endif
 1324 
 1325 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1326   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1327   int reg = ra_-&gt;get_encode(this);
 1328   if( offset &gt;= 128 ) {
 1329     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1330     emit_rm(cbuf, 0x2, reg, 0x04);
 1331     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1332     emit_d32(cbuf, offset);
</pre>
<hr />
<pre>
 1499   case INDINDEXOFFSET:
 1500     new_memory = new indIndexOffset_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1501     break;
 1502   case INDINDEXSCALE:
 1503     new_memory = new indIndexScale_win95_safeOper(memory-&gt;scale());
 1504     break;
 1505   case INDINDEXSCALEOFFSET:
 1506     new_memory = new indIndexScaleOffset_win95_safeOper(memory-&gt;scale(), memory-&gt;disp(NULL, NULL, 0));
 1507     break;
 1508   case LOAD_LONG_INDIRECT:
 1509   case LOAD_LONG_INDOFFSET32:
 1510     // Does not use EBP as address register, use { EDX, EBX, EDI, ESI}
 1511     return;
 1512   default:
 1513     assert(false, &quot;unexpected memory operand in pd_implicit_null_fixup()&quot;);
 1514     return;
 1515   }
 1516   node-&gt;_opnds[opcnt] = new_memory;
 1517 }
 1518 
<span class="line-modified"> 1519 // Advertise here if the CPU requires explicit rounding operations</span>
<span class="line-removed"> 1520 // to implement the UseStrictFP mode.</span>
 1521 const bool Matcher::strict_fp_requires_explicit_rounding = true;
 1522 
 1523 // Are floats conerted to double when stored to stack during deoptimization?
 1524 // On x32 it is stored with convertion only when FPU is used for floats.
 1525 bool Matcher::float_in_double() { return (UseSSE == 0); }
 1526 
 1527 // Do ints take an entire long register or just half?
 1528 const bool Matcher::int_in_long = false;
 1529 
 1530 // Return whether or not this register is ever used as an argument.  This
 1531 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1532 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1533 // arguments in those registers not be available to the callee.
 1534 bool Matcher::can_be_java_arg( int reg ) {
 1535   if(  reg == ECX_num   || reg == EDX_num   ) return true;
 1536   if( (reg == XMM0_num  || reg == XMM1_num ) &amp;&amp; UseSSE&gt;=1 ) return true;
 1537   if( (reg == XMM0b_num || reg == XMM1b_num) &amp;&amp; UseSSE&gt;=2 ) return true;
 1538   return false;
 1539 }
 1540 
</pre>
<hr />
<pre>
 3900   format %{ &quot;EAX&quot; %}
 3901   interface(REG_INTER);
 3902 %}
 3903 
 3904 // Used in AtomicAdd
 3905 operand eBXRegP(eRegP reg) %{
 3906   constraint(ALLOC_IN_RC(ebx_reg));
 3907   match(reg);
 3908   format %{ &quot;EBX&quot; %}
 3909   interface(REG_INTER);
 3910 %}
 3911 
 3912 // Tail-call (interprocedural jump) to interpreter
 3913 operand eCXRegP(eRegP reg) %{
 3914   constraint(ALLOC_IN_RC(ecx_reg));
 3915   match(reg);
 3916   format %{ &quot;ECX&quot; %}
 3917   interface(REG_INTER);
 3918 %}
 3919 







 3920 operand eSIRegP(eRegP reg) %{
 3921   constraint(ALLOC_IN_RC(esi_reg));
 3922   match(reg);
 3923   format %{ &quot;ESI&quot; %}
 3924   interface(REG_INTER);
 3925 %}
 3926 
 3927 // Used in rep stosw
 3928 operand eDIRegP(eRegP reg) %{
 3929   constraint(ALLOC_IN_RC(edi_reg));
 3930   match(reg);
 3931   format %{ &quot;EDI&quot; %}
 3932   interface(REG_INTER);
 3933 %}
 3934 
 3935 operand eRegL() %{
 3936   constraint(ALLOC_IN_RC(long_reg));
 3937   match(RegL);
 3938   match(eADXRegL);
 3939 
</pre>
<hr />
<pre>
 4106 %}
 4107 
 4108 // XMM Double register operands
 4109 operand regD() %{
 4110   predicate( UseSSE&gt;=2 );
 4111   constraint(ALLOC_IN_RC(double_reg_legacy));
 4112   match(RegD);
 4113   format %{ %}
 4114   interface(REG_INTER);
 4115 %}
 4116 
 4117 // Double register operands
 4118 operand vlRegD() %{
 4119    constraint(ALLOC_IN_RC(double_reg_vl));
 4120    match(RegD);
 4121 
 4122    format %{ %}
 4123    interface(REG_INTER);
 4124 %}
 4125 
<span class="line-removed"> 4126 // Vectors : note, we use legacy registers to avoid extra (unneeded in 32-bit VM)</span>
<span class="line-removed"> 4127 // runtime code generation via reg_class_dynamic.</span>
<span class="line-removed"> 4128 operand vecS() %{</span>
<span class="line-removed"> 4129   constraint(ALLOC_IN_RC(vectors_reg_legacy));</span>
<span class="line-removed"> 4130   match(VecS);</span>
<span class="line-removed"> 4131 </span>
<span class="line-removed"> 4132   format %{ %}</span>
<span class="line-removed"> 4133   interface(REG_INTER);</span>
<span class="line-removed"> 4134 %}</span>
<span class="line-removed"> 4135 </span>
<span class="line-removed"> 4136 operand legVecS() %{</span>
<span class="line-removed"> 4137   constraint(ALLOC_IN_RC(vectors_reg_legacy));</span>
<span class="line-removed"> 4138   match(VecS);</span>
<span class="line-removed"> 4139 </span>
<span class="line-removed"> 4140   format %{ %}</span>
<span class="line-removed"> 4141   interface(REG_INTER);</span>
<span class="line-removed"> 4142 %}</span>
<span class="line-removed"> 4143 </span>
<span class="line-removed"> 4144 operand vecD() %{</span>
<span class="line-removed"> 4145   constraint(ALLOC_IN_RC(vectord_reg_legacy));</span>
<span class="line-removed"> 4146   match(VecD);</span>
<span class="line-removed"> 4147 </span>
<span class="line-removed"> 4148   format %{ %}</span>
<span class="line-removed"> 4149   interface(REG_INTER);</span>
<span class="line-removed"> 4150 %}</span>
<span class="line-removed"> 4151 </span>
<span class="line-removed"> 4152 operand legVecD() %{</span>
<span class="line-removed"> 4153   constraint(ALLOC_IN_RC(vectord_reg_legacy));</span>
<span class="line-removed"> 4154   match(VecD);</span>
<span class="line-removed"> 4155 </span>
<span class="line-removed"> 4156   format %{ %}</span>
<span class="line-removed"> 4157   interface(REG_INTER);</span>
<span class="line-removed"> 4158 %}</span>
<span class="line-removed"> 4159 </span>
<span class="line-removed"> 4160 operand vecX() %{</span>
<span class="line-removed"> 4161   constraint(ALLOC_IN_RC(vectorx_reg_legacy));</span>
<span class="line-removed"> 4162   match(VecX);</span>
<span class="line-removed"> 4163 </span>
<span class="line-removed"> 4164   format %{ %}</span>
<span class="line-removed"> 4165   interface(REG_INTER);</span>
<span class="line-removed"> 4166 %}</span>
<span class="line-removed"> 4167 </span>
<span class="line-removed"> 4168 operand legVecX() %{</span>
<span class="line-removed"> 4169   constraint(ALLOC_IN_RC(vectorx_reg_legacy));</span>
<span class="line-removed"> 4170   match(VecX);</span>
<span class="line-removed"> 4171 </span>
<span class="line-removed"> 4172   format %{ %}</span>
<span class="line-removed"> 4173   interface(REG_INTER);</span>
<span class="line-removed"> 4174 %}</span>
<span class="line-removed"> 4175 </span>
<span class="line-removed"> 4176 operand vecY() %{</span>
<span class="line-removed"> 4177   constraint(ALLOC_IN_RC(vectory_reg_legacy));</span>
<span class="line-removed"> 4178   match(VecY);</span>
<span class="line-removed"> 4179 </span>
<span class="line-removed"> 4180   format %{ %}</span>
<span class="line-removed"> 4181   interface(REG_INTER);</span>
<span class="line-removed"> 4182 %}</span>
<span class="line-removed"> 4183 </span>
<span class="line-removed"> 4184 operand legVecY() %{</span>
<span class="line-removed"> 4185   constraint(ALLOC_IN_RC(vectory_reg_legacy));</span>
<span class="line-removed"> 4186   match(VecY);</span>
<span class="line-removed"> 4187 </span>
<span class="line-removed"> 4188   format %{ %}</span>
<span class="line-removed"> 4189   interface(REG_INTER);</span>
<span class="line-removed"> 4190 %}</span>
<span class="line-removed"> 4191 </span>
 4192 //----------Memory Operands----------------------------------------------------
 4193 // Direct Memory Operand
 4194 operand direct(immP addr) %{
 4195   match(addr);
 4196 
 4197   format %{ &quot;[$addr]&quot; %}
 4198   interface(MEMORY_INTER) %{
 4199     base(0xFFFFFFFF);
 4200     index(0x4);
 4201     scale(0x0);
 4202     disp($addr);
 4203   %}
 4204 %}
 4205 
 4206 // Indirect Memory Operand
 4207 operand indirect(eRegP reg) %{
 4208   constraint(ALLOC_IN_RC(int_reg));
 4209   match(reg);
 4210 
 4211   format %{ &quot;[$reg]&quot; %}
</pre>
<hr />
<pre>
 7298   format %{ &quot;#checkcastPP of $dst&quot; %}
 7299   ins_encode( /*empty encoding*/ );
 7300   ins_pipe( empty );
 7301 %}
 7302 
 7303 instruct castPP( eRegP dst ) %{
 7304   match(Set dst (CastPP dst));
 7305   format %{ &quot;#castPP of $dst&quot; %}
 7306   ins_encode( /*empty encoding*/ );
 7307   ins_pipe( empty );
 7308 %}
 7309 
 7310 instruct castII( rRegI dst ) %{
 7311   match(Set dst (CastII dst));
 7312   format %{ &quot;#castII of $dst&quot; %}
 7313   ins_encode( /*empty encoding*/ );
 7314   ins_cost(0);
 7315   ins_pipe( empty );
 7316 %}
 7317 








 7318 
 7319 // Load-locked - same as a regular pointer load when used with compare-swap
 7320 instruct loadPLocked(eRegP dst, memory mem) %{
 7321   match(Set dst (LoadPLocked mem));
 7322 
 7323   ins_cost(125);
 7324   format %{ &quot;MOV    $dst,$mem\t# Load ptr. locked&quot; %}
 7325   opcode(0x8B);
 7326   ins_encode( OpcP, RegMem(dst,mem));
 7327   ins_pipe( ialu_reg_mem );
 7328 %}
 7329 
 7330 // Conditional-store of the updated heap-top.
 7331 // Used during allocation of the shared heap.
 7332 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7333 instruct storePConditional( memory heap_top_ptr, eAXRegP oldval, eRegP newval, eFlagsReg cr ) %{
 7334   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7335   // EAX is killed if there is contention, but then it&#39;s also unused.
 7336   // In the common case of no contention, EAX holds the new oop address.
 7337   format %{ &quot;CMPXCHG $heap_top_ptr,$newval\t# If EAX==$heap_top_ptr Then store $newval into $heap_top_ptr&quot; %}
</pre>
<hr />
<pre>
 8932 
 8933   format %{ &quot;IMUL    $op1, $op2\t# overflow check int&quot; %}
 8934   ins_encode %{
 8935     __ imull($op1$$Register, $op2$$Register);
 8936   %}
 8937   ins_pipe(ialu_reg_reg_alu0);
 8938 %}
 8939 
 8940 instruct overflowMulI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
 8941 %{
 8942   match(Set cr (OverflowMulI op1 op2));
 8943   effect(DEF cr, TEMP tmp, USE op1, USE op2);
 8944 
 8945   format %{ &quot;IMUL    $tmp, $op1, $op2\t# overflow check int&quot; %}
 8946   ins_encode %{
 8947     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
 8948   %}
 8949   ins_pipe(ialu_reg_reg_alu0);
 8950 %}
 8951 






















 8952 //----------Long Instructions------------------------------------------------
 8953 // Add Long Register with Register
 8954 instruct addL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8955   match(Set dst (AddL dst src));
 8956   effect(KILL cr);
 8957   ins_cost(200);
 8958   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8959             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8960   opcode(0x03, 0x13);
 8961   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8962   ins_pipe( ialu_reg_reg_long );
 8963 %}
 8964 
 8965 // Add Long Register with Immediate
 8966 instruct addL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8967   match(Set dst (AddL dst src));
 8968   effect(KILL cr);
 8969   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8970             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8971   opcode(0x81,0x00,0x02);  /* Opcode 81 /0, 81 /2 */
</pre>
<hr />
<pre>
11741 %}
11742 
11743 // fast string equals
11744 instruct string_equals(eDIRegP str1, eSIRegP str2, eCXRegI cnt, eAXRegI result,
11745                        regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr) %{
11746   match(Set result (StrEquals (Binary str1 str2) cnt));
11747   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11748 
11749   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11750   ins_encode %{
11751     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11752                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11753                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11754   %}
11755 
11756   ins_pipe( pipe_slow );
11757 %}
11758 
11759 // fast search of substring with known size.
11760 instruct string_indexof_conL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
<span class="line-modified">11761                              eBXRegI result, regD vec, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{</span>
11762   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11763   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">11764   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11765 
<span class="line-modified">11766   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
11767   ins_encode %{
11768     int icnt2 = (int)$int_cnt2$$constant;
11769     if (icnt2 &gt;= 16) {
11770       // IndexOf for constant substrings with size &gt;= 16 elements
11771       // which don&#39;t need to be loaded through stack.
11772       __ string_indexofC8($str1$$Register, $str2$$Register,
11773                           $cnt1$$Register, $cnt2$$Register,
11774                           icnt2, $result$$Register,
<span class="line-modified">11775                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11776     } else {
11777       // Small strings are loaded through stack if they cross page boundary.
11778       __ string_indexof($str1$$Register, $str2$$Register,
11779                         $cnt1$$Register, $cnt2$$Register,
11780                         icnt2, $result$$Register,
<span class="line-modified">11781                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11782     }
11783   %}
11784   ins_pipe( pipe_slow );
11785 %}
11786 
11787 // fast search of substring with known size.
11788 instruct string_indexof_conU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
<span class="line-modified">11789                              eBXRegI result, regD vec, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{</span>
11790   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11791   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">11792   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11793 
<span class="line-modified">11794   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
11795   ins_encode %{
11796     int icnt2 = (int)$int_cnt2$$constant;
11797     if (icnt2 &gt;= 8) {
11798       // IndexOf for constant substrings with size &gt;= 8 elements
11799       // which don&#39;t need to be loaded through stack.
11800       __ string_indexofC8($str1$$Register, $str2$$Register,
11801                           $cnt1$$Register, $cnt2$$Register,
11802                           icnt2, $result$$Register,
<span class="line-modified">11803                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11804     } else {
11805       // Small strings are loaded through stack if they cross page boundary.
11806       __ string_indexof($str1$$Register, $str2$$Register,
11807                         $cnt1$$Register, $cnt2$$Register,
11808                         icnt2, $result$$Register,
<span class="line-modified">11809                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11810     }
11811   %}
11812   ins_pipe( pipe_slow );
11813 %}
11814 
11815 // fast search of substring with known size.
11816 instruct string_indexof_conUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
<span class="line-modified">11817                              eBXRegI result, regD vec, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{</span>
11818   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11819   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">11820   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11821 
<span class="line-modified">11822   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
11823   ins_encode %{
11824     int icnt2 = (int)$int_cnt2$$constant;
11825     if (icnt2 &gt;= 8) {
11826       // IndexOf for constant substrings with size &gt;= 8 elements
11827       // which don&#39;t need to be loaded through stack.
11828       __ string_indexofC8($str1$$Register, $str2$$Register,
11829                           $cnt1$$Register, $cnt2$$Register,
11830                           icnt2, $result$$Register,
<span class="line-modified">11831                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11832     } else {
11833       // Small strings are loaded through stack if they cross page boundary.
11834       __ string_indexof($str1$$Register, $str2$$Register,
11835                         $cnt1$$Register, $cnt2$$Register,
11836                         icnt2, $result$$Register,
<span class="line-modified">11837                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11838     }
11839   %}
11840   ins_pipe( pipe_slow );
11841 %}
11842 
11843 instruct string_indexofL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
<span class="line-modified">11844                          eBXRegI result, regD vec, eCXRegI tmp, eFlagsReg cr) %{</span>
11845   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11846   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">11847   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11848 
11849   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11850   ins_encode %{
11851     __ string_indexof($str1$$Register, $str2$$Register,
11852                       $cnt1$$Register, $cnt2$$Register,
11853                       (-1), $result$$Register,
<span class="line-modified">11854                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11855   %}
11856   ins_pipe( pipe_slow );
11857 %}
11858 
11859 instruct string_indexofU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
<span class="line-modified">11860                          eBXRegI result, regD vec, eCXRegI tmp, eFlagsReg cr) %{</span>
11861   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11862   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">11863   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11864 
11865   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11866   ins_encode %{
11867     __ string_indexof($str1$$Register, $str2$$Register,
11868                       $cnt1$$Register, $cnt2$$Register,
11869                       (-1), $result$$Register,
<span class="line-modified">11870                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11871   %}
11872   ins_pipe( pipe_slow );
11873 %}
11874 
11875 instruct string_indexofUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
<span class="line-modified">11876                          eBXRegI result, regD vec, eCXRegI tmp, eFlagsReg cr) %{</span>
11877   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11878   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">11879   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11880 
11881   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11882   ins_encode %{
11883     __ string_indexof($str1$$Register, $str2$$Register,
11884                       $cnt1$$Register, $cnt2$$Register,
11885                       (-1), $result$$Register,
<span class="line-modified">11886                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11887   %}
11888   ins_pipe( pipe_slow );
11889 %}
11890 
11891 instruct string_indexofU_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,
11892                               eBXRegI result, regD vec1, regD vec2, regD vec3, eCXRegI tmp, eFlagsReg cr) %{
11893   predicate(UseSSE42Intrinsics);
11894   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11895   effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11896   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11897   ins_encode %{
11898     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11899                            $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);
11900   %}
11901   ins_pipe( pipe_slow );
11902 %}
11903 
11904 // fast array equals
11905 instruct array_equalsB(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11906                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
</pre>
</td>
<td>
<hr />
<pre>
 1292   // Check for second word integer load
 1293   if( dst_second_rc == rc_int &amp;&amp; src_second_rc == rc_stack )
 1294     return impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),dst_second,0x8B,&quot;MOV &quot;,size, st);
 1295 
 1296 
 1297   Unimplemented();
 1298   return 0; // Mute compiler
 1299 }
 1300 
 1301 #ifndef PRODUCT
 1302 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1303   implementation( NULL, ra_, false, st );
 1304 }
 1305 #endif
 1306 
 1307 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1308   implementation( &amp;cbuf, ra_, false, NULL );
 1309 }
 1310 
 1311 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1312   return MachNode::size(ra_);</span>
 1313 }
 1314 
 1315 
 1316 //=============================================================================
 1317 #ifndef PRODUCT
 1318 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1319   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1320   int reg = ra_-&gt;get_reg_first(this);
 1321   st-&gt;print(&quot;LEA    %s,[ESP + #%d]&quot;,Matcher::regName[reg],offset);
 1322 }
 1323 #endif
 1324 
 1325 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1326   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1327   int reg = ra_-&gt;get_encode(this);
 1328   if( offset &gt;= 128 ) {
 1329     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1330     emit_rm(cbuf, 0x2, reg, 0x04);
 1331     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1332     emit_d32(cbuf, offset);
</pre>
<hr />
<pre>
 1499   case INDINDEXOFFSET:
 1500     new_memory = new indIndexOffset_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1501     break;
 1502   case INDINDEXSCALE:
 1503     new_memory = new indIndexScale_win95_safeOper(memory-&gt;scale());
 1504     break;
 1505   case INDINDEXSCALEOFFSET:
 1506     new_memory = new indIndexScaleOffset_win95_safeOper(memory-&gt;scale(), memory-&gt;disp(NULL, NULL, 0));
 1507     break;
 1508   case LOAD_LONG_INDIRECT:
 1509   case LOAD_LONG_INDOFFSET32:
 1510     // Does not use EBP as address register, use { EDX, EBX, EDI, ESI}
 1511     return;
 1512   default:
 1513     assert(false, &quot;unexpected memory operand in pd_implicit_null_fixup()&quot;);
 1514     return;
 1515   }
 1516   node-&gt;_opnds[opcnt] = new_memory;
 1517 }
 1518 
<span class="line-modified"> 1519 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>

 1520 const bool Matcher::strict_fp_requires_explicit_rounding = true;
 1521 
 1522 // Are floats conerted to double when stored to stack during deoptimization?
 1523 // On x32 it is stored with convertion only when FPU is used for floats.
 1524 bool Matcher::float_in_double() { return (UseSSE == 0); }
 1525 
 1526 // Do ints take an entire long register or just half?
 1527 const bool Matcher::int_in_long = false;
 1528 
 1529 // Return whether or not this register is ever used as an argument.  This
 1530 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1531 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1532 // arguments in those registers not be available to the callee.
 1533 bool Matcher::can_be_java_arg( int reg ) {
 1534   if(  reg == ECX_num   || reg == EDX_num   ) return true;
 1535   if( (reg == XMM0_num  || reg == XMM1_num ) &amp;&amp; UseSSE&gt;=1 ) return true;
 1536   if( (reg == XMM0b_num || reg == XMM1b_num) &amp;&amp; UseSSE&gt;=2 ) return true;
 1537   return false;
 1538 }
 1539 
</pre>
<hr />
<pre>
 3899   format %{ &quot;EAX&quot; %}
 3900   interface(REG_INTER);
 3901 %}
 3902 
 3903 // Used in AtomicAdd
 3904 operand eBXRegP(eRegP reg) %{
 3905   constraint(ALLOC_IN_RC(ebx_reg));
 3906   match(reg);
 3907   format %{ &quot;EBX&quot; %}
 3908   interface(REG_INTER);
 3909 %}
 3910 
 3911 // Tail-call (interprocedural jump) to interpreter
 3912 operand eCXRegP(eRegP reg) %{
 3913   constraint(ALLOC_IN_RC(ecx_reg));
 3914   match(reg);
 3915   format %{ &quot;ECX&quot; %}
 3916   interface(REG_INTER);
 3917 %}
 3918 
<span class="line-added"> 3919 operand eDXRegP(eRegP reg) %{</span>
<span class="line-added"> 3920   constraint(ALLOC_IN_RC(edx_reg));</span>
<span class="line-added"> 3921   match(reg);</span>
<span class="line-added"> 3922   format %{ &quot;EDX&quot; %}</span>
<span class="line-added"> 3923   interface(REG_INTER);</span>
<span class="line-added"> 3924 %}</span>
<span class="line-added"> 3925 </span>
 3926 operand eSIRegP(eRegP reg) %{
 3927   constraint(ALLOC_IN_RC(esi_reg));
 3928   match(reg);
 3929   format %{ &quot;ESI&quot; %}
 3930   interface(REG_INTER);
 3931 %}
 3932 
 3933 // Used in rep stosw
 3934 operand eDIRegP(eRegP reg) %{
 3935   constraint(ALLOC_IN_RC(edi_reg));
 3936   match(reg);
 3937   format %{ &quot;EDI&quot; %}
 3938   interface(REG_INTER);
 3939 %}
 3940 
 3941 operand eRegL() %{
 3942   constraint(ALLOC_IN_RC(long_reg));
 3943   match(RegL);
 3944   match(eADXRegL);
 3945 
</pre>
<hr />
<pre>
 4112 %}
 4113 
 4114 // XMM Double register operands
 4115 operand regD() %{
 4116   predicate( UseSSE&gt;=2 );
 4117   constraint(ALLOC_IN_RC(double_reg_legacy));
 4118   match(RegD);
 4119   format %{ %}
 4120   interface(REG_INTER);
 4121 %}
 4122 
 4123 // Double register operands
 4124 operand vlRegD() %{
 4125    constraint(ALLOC_IN_RC(double_reg_vl));
 4126    match(RegD);
 4127 
 4128    format %{ %}
 4129    interface(REG_INTER);
 4130 %}
 4131 


































































 4132 //----------Memory Operands----------------------------------------------------
 4133 // Direct Memory Operand
 4134 operand direct(immP addr) %{
 4135   match(addr);
 4136 
 4137   format %{ &quot;[$addr]&quot; %}
 4138   interface(MEMORY_INTER) %{
 4139     base(0xFFFFFFFF);
 4140     index(0x4);
 4141     scale(0x0);
 4142     disp($addr);
 4143   %}
 4144 %}
 4145 
 4146 // Indirect Memory Operand
 4147 operand indirect(eRegP reg) %{
 4148   constraint(ALLOC_IN_RC(int_reg));
 4149   match(reg);
 4150 
 4151   format %{ &quot;[$reg]&quot; %}
</pre>
<hr />
<pre>
 7238   format %{ &quot;#checkcastPP of $dst&quot; %}
 7239   ins_encode( /*empty encoding*/ );
 7240   ins_pipe( empty );
 7241 %}
 7242 
 7243 instruct castPP( eRegP dst ) %{
 7244   match(Set dst (CastPP dst));
 7245   format %{ &quot;#castPP of $dst&quot; %}
 7246   ins_encode( /*empty encoding*/ );
 7247   ins_pipe( empty );
 7248 %}
 7249 
 7250 instruct castII( rRegI dst ) %{
 7251   match(Set dst (CastII dst));
 7252   format %{ &quot;#castII of $dst&quot; %}
 7253   ins_encode( /*empty encoding*/ );
 7254   ins_cost(0);
 7255   ins_pipe( empty );
 7256 %}
 7257 
<span class="line-added"> 7258 instruct castLL( eRegL dst ) %{</span>
<span class="line-added"> 7259   match(Set dst (CastLL dst));</span>
<span class="line-added"> 7260   format %{ &quot;#castLL of $dst&quot; %}</span>
<span class="line-added"> 7261   ins_encode( /*empty encoding*/ );</span>
<span class="line-added"> 7262   ins_cost(0);</span>
<span class="line-added"> 7263   ins_pipe( empty );</span>
<span class="line-added"> 7264 %}</span>
<span class="line-added"> 7265 </span>
 7266 
 7267 // Load-locked - same as a regular pointer load when used with compare-swap
 7268 instruct loadPLocked(eRegP dst, memory mem) %{
 7269   match(Set dst (LoadPLocked mem));
 7270 
 7271   ins_cost(125);
 7272   format %{ &quot;MOV    $dst,$mem\t# Load ptr. locked&quot; %}
 7273   opcode(0x8B);
 7274   ins_encode( OpcP, RegMem(dst,mem));
 7275   ins_pipe( ialu_reg_mem );
 7276 %}
 7277 
 7278 // Conditional-store of the updated heap-top.
 7279 // Used during allocation of the shared heap.
 7280 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7281 instruct storePConditional( memory heap_top_ptr, eAXRegP oldval, eRegP newval, eFlagsReg cr ) %{
 7282   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7283   // EAX is killed if there is contention, but then it&#39;s also unused.
 7284   // In the common case of no contention, EAX holds the new oop address.
 7285   format %{ &quot;CMPXCHG $heap_top_ptr,$newval\t# If EAX==$heap_top_ptr Then store $newval into $heap_top_ptr&quot; %}
</pre>
<hr />
<pre>
 8880 
 8881   format %{ &quot;IMUL    $op1, $op2\t# overflow check int&quot; %}
 8882   ins_encode %{
 8883     __ imull($op1$$Register, $op2$$Register);
 8884   %}
 8885   ins_pipe(ialu_reg_reg_alu0);
 8886 %}
 8887 
 8888 instruct overflowMulI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
 8889 %{
 8890   match(Set cr (OverflowMulI op1 op2));
 8891   effect(DEF cr, TEMP tmp, USE op1, USE op2);
 8892 
 8893   format %{ &quot;IMUL    $tmp, $op1, $op2\t# overflow check int&quot; %}
 8894   ins_encode %{
 8895     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
 8896   %}
 8897   ins_pipe(ialu_reg_reg_alu0);
 8898 %}
 8899 
<span class="line-added"> 8900 // Integer Absolute Instructions</span>
<span class="line-added"> 8901 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, eFlagsReg cr)</span>
<span class="line-added"> 8902 %{</span>
<span class="line-added"> 8903   match(Set dst (AbsI src));</span>
<span class="line-added"> 8904   effect(TEMP dst, TEMP tmp, KILL cr);</span>
<span class="line-added"> 8905   format %{ &quot;movl $tmp, $src\n\t&quot;</span>
<span class="line-added"> 8906             &quot;sarl $tmp, 31\n\t&quot;</span>
<span class="line-added"> 8907             &quot;movl $dst, $src\n\t&quot;</span>
<span class="line-added"> 8908             &quot;xorl $dst, $tmp\n\t&quot;</span>
<span class="line-added"> 8909             &quot;subl $dst, $tmp\n&quot;</span>
<span class="line-added"> 8910           %}</span>
<span class="line-added"> 8911   ins_encode %{</span>
<span class="line-added"> 8912     __ movl($tmp$$Register, $src$$Register);</span>
<span class="line-added"> 8913     __ sarl($tmp$$Register, 31);</span>
<span class="line-added"> 8914     __ movl($dst$$Register, $src$$Register);</span>
<span class="line-added"> 8915     __ xorl($dst$$Register, $tmp$$Register);</span>
<span class="line-added"> 8916     __ subl($dst$$Register, $tmp$$Register);</span>
<span class="line-added"> 8917   %}</span>
<span class="line-added"> 8918 </span>
<span class="line-added"> 8919   ins_pipe(ialu_reg_reg);</span>
<span class="line-added"> 8920 %}</span>
<span class="line-added"> 8921 </span>
 8922 //----------Long Instructions------------------------------------------------
 8923 // Add Long Register with Register
 8924 instruct addL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8925   match(Set dst (AddL dst src));
 8926   effect(KILL cr);
 8927   ins_cost(200);
 8928   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8929             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8930   opcode(0x03, 0x13);
 8931   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8932   ins_pipe( ialu_reg_reg_long );
 8933 %}
 8934 
 8935 // Add Long Register with Immediate
 8936 instruct addL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8937   match(Set dst (AddL dst src));
 8938   effect(KILL cr);
 8939   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8940             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8941   opcode(0x81,0x00,0x02);  /* Opcode 81 /0, 81 /2 */
</pre>
<hr />
<pre>
11711 %}
11712 
11713 // fast string equals
11714 instruct string_equals(eDIRegP str1, eSIRegP str2, eCXRegI cnt, eAXRegI result,
11715                        regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr) %{
11716   match(Set result (StrEquals (Binary str1 str2) cnt));
11717   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11718 
11719   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11720   ins_encode %{
11721     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11722                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11723                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11724   %}
11725 
11726   ins_pipe( pipe_slow );
11727 %}
11728 
11729 // fast search of substring with known size.
11730 instruct string_indexof_conL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
<span class="line-modified">11731                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{</span>
11732   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11733   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">11734   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11735 
<span class="line-modified">11736   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}</span>
11737   ins_encode %{
11738     int icnt2 = (int)$int_cnt2$$constant;
11739     if (icnt2 &gt;= 16) {
11740       // IndexOf for constant substrings with size &gt;= 16 elements
11741       // which don&#39;t need to be loaded through stack.
11742       __ string_indexofC8($str1$$Register, $str2$$Register,
11743                           $cnt1$$Register, $cnt2$$Register,
11744                           icnt2, $result$$Register,
<span class="line-modified">11745                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11746     } else {
11747       // Small strings are loaded through stack if they cross page boundary.
11748       __ string_indexof($str1$$Register, $str2$$Register,
11749                         $cnt1$$Register, $cnt2$$Register,
11750                         icnt2, $result$$Register,
<span class="line-modified">11751                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11752     }
11753   %}
11754   ins_pipe( pipe_slow );
11755 %}
11756 
11757 // fast search of substring with known size.
11758 instruct string_indexof_conU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
<span class="line-modified">11759                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{</span>
11760   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11761   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">11762   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11763 
<span class="line-modified">11764   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}</span>
11765   ins_encode %{
11766     int icnt2 = (int)$int_cnt2$$constant;
11767     if (icnt2 &gt;= 8) {
11768       // IndexOf for constant substrings with size &gt;= 8 elements
11769       // which don&#39;t need to be loaded through stack.
11770       __ string_indexofC8($str1$$Register, $str2$$Register,
11771                           $cnt1$$Register, $cnt2$$Register,
11772                           icnt2, $result$$Register,
<span class="line-modified">11773                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11774     } else {
11775       // Small strings are loaded through stack if they cross page boundary.
11776       __ string_indexof($str1$$Register, $str2$$Register,
11777                         $cnt1$$Register, $cnt2$$Register,
11778                         icnt2, $result$$Register,
<span class="line-modified">11779                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11780     }
11781   %}
11782   ins_pipe( pipe_slow );
11783 %}
11784 
11785 // fast search of substring with known size.
11786 instruct string_indexof_conUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
<span class="line-modified">11787                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{</span>
11788   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11789   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">11790   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11791 
<span class="line-modified">11792   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}</span>
11793   ins_encode %{
11794     int icnt2 = (int)$int_cnt2$$constant;
11795     if (icnt2 &gt;= 8) {
11796       // IndexOf for constant substrings with size &gt;= 8 elements
11797       // which don&#39;t need to be loaded through stack.
11798       __ string_indexofC8($str1$$Register, $str2$$Register,
11799                           $cnt1$$Register, $cnt2$$Register,
11800                           icnt2, $result$$Register,
<span class="line-modified">11801                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11802     } else {
11803       // Small strings are loaded through stack if they cross page boundary.
11804       __ string_indexof($str1$$Register, $str2$$Register,
11805                         $cnt1$$Register, $cnt2$$Register,
11806                         icnt2, $result$$Register,
<span class="line-modified">11807                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11808     }
11809   %}
11810   ins_pipe( pipe_slow );
11811 %}
11812 
11813 instruct string_indexofL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
<span class="line-modified">11814                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{</span>
11815   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11816   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">11817   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11818 
11819   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11820   ins_encode %{
11821     __ string_indexof($str1$$Register, $str2$$Register,
11822                       $cnt1$$Register, $cnt2$$Register,
11823                       (-1), $result$$Register,
<span class="line-modified">11824                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11825   %}
11826   ins_pipe( pipe_slow );
11827 %}
11828 
11829 instruct string_indexofU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
<span class="line-modified">11830                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{</span>
11831   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11832   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">11833   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11834 
11835   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11836   ins_encode %{
11837     __ string_indexof($str1$$Register, $str2$$Register,
11838                       $cnt1$$Register, $cnt2$$Register,
11839                       (-1), $result$$Register,
<span class="line-modified">11840                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11841   %}
11842   ins_pipe( pipe_slow );
11843 %}
11844 
11845 instruct string_indexofUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
<span class="line-modified">11846                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{</span>
11847   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11848   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">11849   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11850 
11851   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11852   ins_encode %{
11853     __ string_indexof($str1$$Register, $str2$$Register,
11854                       $cnt1$$Register, $cnt2$$Register,
11855                       (-1), $result$$Register,
<span class="line-modified">11856                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11857   %}
11858   ins_pipe( pipe_slow );
11859 %}
11860 
11861 instruct string_indexofU_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,
11862                               eBXRegI result, regD vec1, regD vec2, regD vec3, eCXRegI tmp, eFlagsReg cr) %{
11863   predicate(UseSSE42Intrinsics);
11864   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11865   effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11866   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11867   ins_encode %{
11868     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11869                            $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);
11870   %}
11871   ins_pipe( pipe_slow );
11872 %}
11873 
11874 // fast array equals
11875 instruct array_equalsB(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11876                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
</pre>
</td>
</tr>
</table>
<center><a href="x86.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_64.ad.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
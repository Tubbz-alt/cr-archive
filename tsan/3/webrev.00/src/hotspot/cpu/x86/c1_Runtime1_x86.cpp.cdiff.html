<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/c1_Runtime1_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_MacroAssembler_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_globals_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_Runtime1_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,10 ***</span>
<span class="line-new-header">--- 29,11 ---</span>
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;ci/ciUtilities.hpp&quot;
  #include &quot;gc/shared/cardTable.hpp&quot;
  #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;nativeInst_x86.hpp&quot;
  #include &quot;oops/compiledICHolder.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;register_x86.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,10 ***</span>
<span class="line-new-header">--- 425,11 ---</span>
  #ifdef ASSERT
    __ movptr(Address(rsp, marker * VMRegImpl::stack_slot_size), (int32_t)0xfeedbeef);
  #endif
  
    if (save_fpu_registers) {
<span class="line-added">+ #ifndef _LP64</span>
      if (UseSSE &lt; 2) {
        // save FPU stack
        __ fnsave(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size));
        __ fwait();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 451,10 ***</span>
<span class="line-new-header">--- 453,11 ---</span>
        for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
          __ fstp_d(Address(rsp, float_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));
          offset += 8;
        }
      }
<span class="line-added">+ #endif // !_LP64</span>
  
      if (UseSSE &gt;= 2) {
        // save XMM registers
        // XMM registers can contain float or double values, but this is not known here,
        // so always save them as doubles.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 470,38 ***</span>
        for (int n = 0; n &lt; xmm_bypass_limit; n++) {
          XMMRegister xmm_name = as_XMMRegister(n);
          __ movdbl(Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset), xmm_name);
          offset += 8;
        }
      } else if (UseSSE == 1) {
        // save XMM registers as float because double not supported without SSE2(num MMX == num fpu)
        int offset = 0;
        for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
          XMMRegister xmm_name = as_XMMRegister(n);
          __ movflt(Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset), xmm_name);
          offset += 8;
        }
      }
    }
  
    // FPU stack must be empty now
<span class="line-modified">!   __ verify_FPU(0, &quot;save_live_registers&quot;);</span>
  }
  
  #undef __
  #define __ sasm-&gt;
  
  static void restore_fpu(C1_MacroAssembler* sasm, bool restore_fpu_registers) {
    if (restore_fpu_registers) {
      if (UseSSE &gt;= 2) {
        // restore XMM registers
        int xmm_bypass_limit = FrameMap::nof_xmm_regs;
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">-       if (UseAVX &lt; 3) {</span>
<span class="line-removed">-         xmm_bypass_limit = xmm_bypass_limit / 2;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- #endif</span>
        int offset = 0;
        for (int n = 0; n &lt; xmm_bypass_limit; n++) {
          XMMRegister xmm_name = as_XMMRegister(n);
          __ movdbl(xmm_name, Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));
          offset += 8;
<span class="line-new-header">--- 473,50 ---</span>
        for (int n = 0; n &lt; xmm_bypass_limit; n++) {
          XMMRegister xmm_name = as_XMMRegister(n);
          __ movdbl(Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset), xmm_name);
          offset += 8;
        }
<span class="line-added">+ #ifndef _LP64</span>
      } else if (UseSSE == 1) {
        // save XMM registers as float because double not supported without SSE2(num MMX == num fpu)
        int offset = 0;
        for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
          XMMRegister xmm_name = as_XMMRegister(n);
          __ movflt(Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset), xmm_name);
          offset += 8;
        }
<span class="line-added">+ #endif // !_LP64</span>
      }
    }
  
    // FPU stack must be empty now
<span class="line-modified">!   NOT_LP64( __ verify_FPU(0, &quot;save_live_registers&quot;); )</span>
  }
  
  #undef __
  #define __ sasm-&gt;
  
  static void restore_fpu(C1_MacroAssembler* sasm, bool restore_fpu_registers) {
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+   if (restore_fpu_registers) {</span>
<span class="line-added">+     // restore XMM registers</span>
<span class="line-added">+     int xmm_bypass_limit = FrameMap::nof_xmm_regs;</span>
<span class="line-added">+     if (UseAVX &lt; 3) {</span>
<span class="line-added">+       xmm_bypass_limit = xmm_bypass_limit / 2;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     int offset = 0;</span>
<span class="line-added">+     for (int n = 0; n &lt; xmm_bypass_limit; n++) {</span>
<span class="line-added">+       XMMRegister xmm_name = as_XMMRegister(n);</span>
<span class="line-added">+       __ movdbl(xmm_name, Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));</span>
<span class="line-added">+       offset += 8;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #else</span>
    if (restore_fpu_registers) {
      if (UseSSE &gt;= 2) {
        // restore XMM registers
        int xmm_bypass_limit = FrameMap::nof_xmm_regs;
        int offset = 0;
        for (int n = 0; n &lt; xmm_bypass_limit; n++) {
          XMMRegister xmm_name = as_XMMRegister(n);
          __ movdbl(xmm_name, Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));
          offset += 8;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 520,15 ***</span>
        __ frstor(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size));
      } else {
        // check that FPU stack is really empty
        __ verify_FPU(0, &quot;restore_live_registers&quot;);
      }
<span class="line-removed">- </span>
    } else {
      // check that FPU stack is really empty
      __ verify_FPU(0, &quot;restore_live_registers&quot;);
    }
  
  #ifdef ASSERT
    {
      Label ok;
      __ cmpptr(Address(rsp, marker * VMRegImpl::stack_slot_size), (int32_t)0xfeedbeef);
<span class="line-new-header">--- 535,15 ---</span>
        __ frstor(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size));
      } else {
        // check that FPU stack is really empty
        __ verify_FPU(0, &quot;restore_live_registers&quot;);
      }
    } else {
      // check that FPU stack is really empty
      __ verify_FPU(0, &quot;restore_live_registers&quot;);
    }
<span class="line-added">+ #endif // _LP64</span>
  
  #ifdef ASSERT
    {
      Label ok;
      __ cmpptr(Address(rsp, marker * VMRegImpl::stack_slot_size), (int32_t)0xfeedbeef);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,16 ***</span>
      break;
    }
    default:  ShouldNotReachHere();
    }
  
<span class="line-modified">! #ifdef TIERED</span>
<span class="line-removed">-   // C2 can leave the fpu stack dirty</span>
    if (UseSSE &lt; 2) {
      __ empty_FPU_stack();
    }
<span class="line-modified">! #endif // TIERED</span>
  
    // verify that only rax, and rdx is valid at this time
    __ invalidate_registers(false, true, true, false, true, true);
    // verify that rax, contains a valid exception
    __ verify_not_null_oop(exception_oop);
<span class="line-new-header">--- 711,16 ---</span>
      break;
    }
    default:  ShouldNotReachHere();
    }
  
<span class="line-modified">! #if !defined(_LP64) &amp;&amp; defined(TIERED)</span>
    if (UseSSE &lt; 2) {
<span class="line-added">+     // C2 can leave the fpu stack dirty</span>
      __ empty_FPU_stack();
    }
<span class="line-modified">! #endif // !_LP64 &amp;&amp; TIERED</span>
  
    // verify that only rax, and rdx is valid at this time
    __ invalidate_registers(false, true, true, false, true, true);
    // verify that rax, contains a valid exception
    __ verify_not_null_oop(exception_oop);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 803,11 ***</span>
    __ stop(&quot;exception pc must be empty&quot;);
    __ bind(pc_empty);
  #endif
  
    // clear the FPU stack in case any FPU results are left behind
<span class="line-modified">!   __ empty_FPU_stack();</span>
  
    // save exception_oop in callee-saved register to preserve it during runtime calls
    __ verify_not_null_oop(exception_oop);
    __ movptr(exception_oop_callee_saved, exception_oop);
  
<span class="line-new-header">--- 818,11 ---</span>
    __ stop(&quot;exception pc must be empty&quot;);
    __ bind(pc_empty);
  #endif
  
    // clear the FPU stack in case any FPU results are left behind
<span class="line-modified">!   NOT_LP64( __ empty_FPU_stack(); )</span>
  
    // save exception_oop in callee-saved register to preserve it during runtime calls
    __ verify_not_null_oop(exception_oop);
    __ movptr(exception_oop_callee_saved, exception_oop);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1474,15 ***</span>
        }
        break;
  
      case fpu2long_stub_id:
        {
          // rax, and rdx are destroyed, but should be free since the result is returned there
          // preserve rsi,ecx
          __ push(rsi);
          __ push(rcx);
<span class="line-removed">-         LP64_ONLY(__ push(rdx);)</span>
  
          // check for NaN
          Label return0, do_return, return_min_jlong, do_convert;
  
          Address value_high_word(rsp, wordSize + 4);
<span class="line-new-header">--- 1489,27 ---</span>
        }
        break;
  
      case fpu2long_stub_id:
        {
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+         Label done;</span>
<span class="line-added">+         __ cvttsd2siq(rax, Address(rsp, wordSize));</span>
<span class="line-added">+         __ cmp64(rax, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));</span>
<span class="line-added">+         __ jccb(Assembler::notEqual, done);</span>
<span class="line-added">+         __ movq(rax, Address(rsp, wordSize));</span>
<span class="line-added">+         __ subptr(rsp, 8);</span>
<span class="line-added">+         __ movq(Address(rsp, 0), rax);</span>
<span class="line-added">+         __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));</span>
<span class="line-added">+         __ pop(rax);</span>
<span class="line-added">+         __ bind(done);</span>
<span class="line-added">+         __ ret(0);</span>
<span class="line-added">+ #else</span>
          // rax, and rdx are destroyed, but should be free since the result is returned there
          // preserve rsi,ecx
          __ push(rsi);
          __ push(rcx);
  
          // check for NaN
          Label return0, do_return, return_min_jlong, do_convert;
  
          Address value_high_word(rsp, wordSize + 4);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1523,50 ***</span>
          __ orl(rcx, rsi);
          __ jcc(Assembler::notEqual, do_return);
          __ fldz();
          __ fcomp_d(value_low_word);
          __ fnstsw_ax();
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">-         __ testl(rax, 0x4100);  // ZF &amp; CF == 0</span>
<span class="line-removed">-         __ jcc(Assembler::equal, return_min_jlong);</span>
<span class="line-removed">- #else</span>
          __ sahf();
          __ jcc(Assembler::above, return_min_jlong);
<span class="line-removed">- #endif // _LP64</span>
          // return max_jlong
<span class="line-removed">- #ifndef _LP64</span>
          __ movl(rdx, 0x7fffffff);
          __ movl(rax, 0xffffffff);
<span class="line-removed">- #else</span>
<span class="line-removed">-         __ mov64(rax, CONST64(0x7fffffffffffffff));</span>
<span class="line-removed">- #endif // _LP64</span>
          __ jmp(do_return);
  
          __ bind(return_min_jlong);
<span class="line-removed">- #ifndef _LP64</span>
          __ movl(rdx, 0x80000000);
          __ xorl(rax, rax);
<span class="line-removed">- #else</span>
<span class="line-removed">-         __ mov64(rax, UCONST64(0x8000000000000000));</span>
<span class="line-removed">- #endif // _LP64</span>
          __ jmp(do_return);
  
          __ bind(return0);
          __ fpop();
<span class="line-removed">- #ifndef _LP64</span>
          __ xorptr(rdx,rdx);
          __ xorptr(rax,rax);
<span class="line-removed">- #else</span>
<span class="line-removed">-         __ xorptr(rax, rax);</span>
<span class="line-removed">- #endif // _LP64</span>
  
          __ bind(do_return);
          __ addptr(rsp, 32);
<span class="line-removed">-         LP64_ONLY(__ pop(rdx);)</span>
          __ pop(rcx);
          __ pop(rsi);
          __ ret(0);
        }
        break;
  
      case predicate_failed_trap_id:
        {
<span class="line-new-header">--- 1550,33 ---</span>
          __ orl(rcx, rsi);
          __ jcc(Assembler::notEqual, do_return);
          __ fldz();
          __ fcomp_d(value_low_word);
          __ fnstsw_ax();
          __ sahf();
          __ jcc(Assembler::above, return_min_jlong);
          // return max_jlong
          __ movl(rdx, 0x7fffffff);
          __ movl(rax, 0xffffffff);
          __ jmp(do_return);
  
          __ bind(return_min_jlong);
          __ movl(rdx, 0x80000000);
          __ xorl(rax, rax);
          __ jmp(do_return);
  
          __ bind(return0);
          __ fpop();
          __ xorptr(rdx,rdx);
          __ xorptr(rax,rax);
  
          __ bind(do_return);
          __ addptr(rsp, 32);
          __ pop(rcx);
          __ pop(rsi);
          __ ret(0);
<span class="line-added">+ #endif // _LP64</span>
        }
        break;
  
      case predicate_failed_trap_id:
        {
</pre>
<center><a href="c1_MacroAssembler_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_globals_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
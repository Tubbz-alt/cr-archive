<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/c1_LinearScan_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Instruction.hpp&quot;
  27 #include &quot;c1/c1_LinearScan.hpp&quot;
  28 #include &quot;utilities/bitMap.inline.hpp&quot;
  29 
  30 
<a name="1" id="anc1"></a><span class="line-added">  31 #ifdef _LP64</span>
<span class="line-added">  32 void LinearScan::allocate_fpu_stack() {</span>
<span class="line-added">  33   // No FPU stack used on x86-64</span>
<span class="line-added">  34 }</span>
<span class="line-added">  35 #else</span>
  36 //----------------------------------------------------------------------
  37 // Allocation of FPU stack slots (Intel x86 only)
  38 //----------------------------------------------------------------------
  39 
  40 void LinearScan::allocate_fpu_stack() {
  41   // First compute which FPU registers are live at the start of each basic block
  42   // (To minimize the amount of work we have to do if we have to merge FPU stacks)
  43   if (ComputeExactFPURegisterUsage) {
  44     Interval* intervals_in_register, *intervals_in_memory;
  45     create_unhandled_lists(&amp;intervals_in_register, &amp;intervals_in_memory, is_in_fpu_register, NULL);
  46 
  47     // ignore memory intervals by overwriting intervals_in_memory
  48     // the dummy interval is needed to enforce the walker to walk until the given id:
  49     // without it, the walker stops when the unhandled-list is empty -&gt; live information
  50     // beyond this point would be incorrect.
  51     Interval* dummy_interval = new Interval(any_reg);
  52     dummy_interval-&gt;add_range(max_jint - 2, max_jint - 1);
  53     dummy_interval-&gt;set_next(Interval::end());
  54     intervals_in_memory = dummy_interval;
  55 
  56     IntervalWalker iw(this, intervals_in_register, intervals_in_memory);
  57 
  58     const int num_blocks = block_count();
  59     for (int i = 0; i &lt; num_blocks; i++) {
  60       BlockBegin* b = block_at(i);
  61 
  62       // register usage is only needed for merging stacks -&gt; compute only
  63       // when more than one predecessor.
  64       // the block must not have any spill moves at the beginning (checked by assertions)
  65       // spill moves would use intervals that are marked as handled and so the usage bit
  66       // would been set incorrectly
  67 
  68       // NOTE: the check for number_of_preds &gt; 1 is necessary. A block with only one
  69       //       predecessor may have spill moves at the begin of the block.
  70       //       If an interval ends at the current instruction id, it is not possible
  71       //       to decide if the register is live or not at the block begin -&gt; the
  72       //       register information would be incorrect.
  73       if (b-&gt;number_of_preds() &gt; 1) {
  74         int id = b-&gt;first_lir_instruction_id();
  75         ResourceBitMap regs(FrameMap::nof_fpu_regs);
  76 
  77         iw.walk_to(id);   // walk after the first instruction (always a label) of the block
  78         assert(iw.current_position() == id, &quot;did not walk completely to id&quot;);
  79 
  80         // Only consider FPU values in registers
  81         Interval* interval = iw.active_first(fixedKind);
  82         while (interval != Interval::end()) {
  83           int reg = interval-&gt;assigned_reg();
  84           assert(reg &gt;= pd_first_fpu_reg &amp;&amp; reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
  85           assert(interval-&gt;assigned_regHi() == -1, &quot;must not have hi register (doubles stored in one register)&quot;);
  86           assert(interval-&gt;from() &lt;= id &amp;&amp; id &lt; interval-&gt;to(), &quot;interval out of range&quot;);
  87 
  88 #ifndef PRODUCT
  89           if (TraceFPURegisterUsage) {
  90             tty-&gt;print(&quot;fpu reg %d is live because of &quot;, reg - pd_first_fpu_reg); interval-&gt;print();
  91           }
  92 #endif
  93 
  94           regs.set_bit(reg - pd_first_fpu_reg);
  95           interval = interval-&gt;next();
  96         }
  97 
  98         b-&gt;set_fpu_register_usage(regs);
  99 
 100 #ifndef PRODUCT
 101         if (TraceFPURegisterUsage) {
 102           tty-&gt;print(&quot;FPU regs for block %d, LIR instr %d): &quot;, b-&gt;block_id(), id); regs.print_on(tty); tty-&gt;cr();
 103         }
 104 #endif
 105       }
 106     }
 107   }
 108 
 109   FpuStackAllocator alloc(ir()-&gt;compilation(), this);
 110   _fpu_stack_allocator = &amp;alloc;
 111   alloc.allocate();
 112   _fpu_stack_allocator = NULL;
 113 }
 114 
 115 
 116 FpuStackAllocator::FpuStackAllocator(Compilation* compilation, LinearScan* allocator)
 117   : _compilation(compilation)
 118   , _allocator(allocator)
 119   , _lir(NULL)
 120   , _pos(-1)
 121   , _sim(compilation)
 122   , _temp_sim(compilation)
 123 {}
 124 
 125 void FpuStackAllocator::allocate() {
 126   int num_blocks = allocator()-&gt;block_count();
 127   for (int i = 0; i &lt; num_blocks; i++) {
 128     // Set up to process block
 129     BlockBegin* block = allocator()-&gt;block_at(i);
 130     intArray* fpu_stack_state = block-&gt;fpu_stack_state();
 131 
 132 #ifndef PRODUCT
 133     if (TraceFPUStack) {
 134       tty-&gt;cr();
 135       tty-&gt;print_cr(&quot;------- Begin of new Block %d -------&quot;, block-&gt;block_id());
 136     }
 137 #endif
 138 
 139     assert(fpu_stack_state != NULL ||
 140            block-&gt;end()-&gt;as_Base() != NULL ||
 141            block-&gt;is_set(BlockBegin::exception_entry_flag),
 142            &quot;FPU stack state must be present due to linear-scan order for FPU stack allocation&quot;);
 143     // note: exception handler entries always start with an empty fpu stack
 144     //       because stack merging would be too complicated
 145 
 146     if (fpu_stack_state != NULL) {
 147       sim()-&gt;read_state(fpu_stack_state);
 148     } else {
 149       sim()-&gt;clear();
 150     }
 151 
 152 #ifndef PRODUCT
 153     if (TraceFPUStack) {
 154       tty-&gt;print(&quot;Reading FPU state for block %d:&quot;, block-&gt;block_id());
 155       sim()-&gt;print();
 156       tty-&gt;cr();
 157     }
 158 #endif
 159 
 160     allocate_block(block);
 161     CHECK_BAILOUT();
 162   }
 163 }
 164 
 165 void FpuStackAllocator::allocate_block(BlockBegin* block) {
 166   bool processed_merge = false;
 167   LIR_OpList* insts = block-&gt;lir()-&gt;instructions_list();
 168   set_lir(block-&gt;lir());
 169   set_pos(0);
 170 
 171 
 172   // Note: insts-&gt;length() may change during loop
 173   while (pos() &lt; insts-&gt;length()) {
 174     LIR_Op* op = insts-&gt;at(pos());
 175     _debug_information_computed = false;
 176 
 177 #ifndef PRODUCT
 178     if (TraceFPUStack) {
 179       op-&gt;print();
 180     }
 181     check_invalid_lir_op(op);
 182 #endif
 183 
 184     LIR_OpBranch* branch = op-&gt;as_OpBranch();
 185     LIR_Op1* op1 = op-&gt;as_Op1();
 186     LIR_Op2* op2 = op-&gt;as_Op2();
 187     LIR_OpCall* opCall = op-&gt;as_OpCall();
 188 
 189     if (branch != NULL &amp;&amp; branch-&gt;block() != NULL) {
 190       if (!processed_merge) {
 191         // propagate stack at first branch to a successor
 192         processed_merge = true;
 193         bool required_merge = merge_fpu_stack_with_successors(block);
 194 
 195         assert(!required_merge || branch-&gt;cond() == lir_cond_always, &quot;splitting of critical edges should prevent FPU stack mismatches at cond branches&quot;);
 196       }
 197 
 198     } else if (op1 != NULL) {
 199       handle_op1(op1);
 200     } else if (op2 != NULL) {
 201       handle_op2(op2);
 202     } else if (opCall != NULL) {
 203       handle_opCall(opCall);
 204     }
 205 
 206     compute_debug_information(op);
 207 
 208     set_pos(1 + pos());
 209   }
 210 
 211   // Propagate stack when block does not end with branch
 212   if (!processed_merge) {
 213     merge_fpu_stack_with_successors(block);
 214   }
 215 }
 216 
 217 
 218 void FpuStackAllocator::compute_debug_information(LIR_Op* op) {
 219   if (!_debug_information_computed &amp;&amp; op-&gt;id() != -1 &amp;&amp; allocator()-&gt;has_info(op-&gt;id())) {
 220     visitor.visit(op);
 221 
 222     // exception handling
 223     if (allocator()-&gt;compilation()-&gt;has_exception_handlers()) {
 224       XHandlers* xhandlers = visitor.all_xhandler();
 225       int n = xhandlers-&gt;length();
 226       for (int k = 0; k &lt; n; k++) {
 227         allocate_exception_handler(xhandlers-&gt;handler_at(k));
 228       }
 229     } else {
 230       assert(visitor.all_xhandler()-&gt;length() == 0, &quot;missed exception handler&quot;);
 231     }
 232 
 233     // compute debug information
 234     int n = visitor.info_count();
 235     assert(n &gt; 0, &quot;should not visit operation otherwise&quot;);
 236 
 237     for (int j = 0; j &lt; n; j++) {
 238       CodeEmitInfo* info = visitor.info_at(j);
 239       // Compute debug information
 240       allocator()-&gt;compute_debug_info(info, op-&gt;id());
 241     }
 242   }
 243   _debug_information_computed = true;
 244 }
 245 
 246 void FpuStackAllocator::allocate_exception_handler(XHandler* xhandler) {
 247   if (!sim()-&gt;is_empty()) {
 248     LIR_List* old_lir = lir();
 249     int old_pos = pos();
 250     intArray* old_state = sim()-&gt;write_state();
 251 
 252 #ifndef PRODUCT
 253     if (TraceFPUStack) {
 254       tty-&gt;cr();
 255       tty-&gt;print_cr(&quot;------- begin of exception handler -------&quot;);
 256     }
 257 #endif
 258 
 259     if (xhandler-&gt;entry_code() == NULL) {
 260       // need entry code to clear FPU stack
 261       LIR_List* entry_code = new LIR_List(_compilation);
 262       entry_code-&gt;jump(xhandler-&gt;entry_block());
 263       xhandler-&gt;set_entry_code(entry_code);
 264     }
 265 
 266     LIR_OpList* insts = xhandler-&gt;entry_code()-&gt;instructions_list();
 267     set_lir(xhandler-&gt;entry_code());
 268     set_pos(0);
 269 
 270     // Note: insts-&gt;length() may change during loop
 271     while (pos() &lt; insts-&gt;length()) {
 272       LIR_Op* op = insts-&gt;at(pos());
 273 
 274 #ifndef PRODUCT
 275       if (TraceFPUStack) {
 276         op-&gt;print();
 277       }
 278       check_invalid_lir_op(op);
 279 #endif
 280 
 281       switch (op-&gt;code()) {
 282         case lir_move:
 283           assert(op-&gt;as_Op1() != NULL, &quot;must be LIR_Op1&quot;);
 284           assert(pos() != insts-&gt;length() - 1, &quot;must not be last operation&quot;);
 285 
 286           handle_op1((LIR_Op1*)op);
 287           break;
 288 
 289         case lir_branch:
 290           assert(op-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;must be unconditional branch&quot;);
 291           assert(pos() == insts-&gt;length() - 1, &quot;must be last operation&quot;);
 292 
 293           // remove all remaining dead registers from FPU stack
 294           clear_fpu_stack(LIR_OprFact::illegalOpr);
 295           break;
 296 
 297         default:
 298           // other operations not allowed in exception entry code
 299           ShouldNotReachHere();
 300       }
 301 
 302       set_pos(pos() + 1);
 303     }
 304 
 305 #ifndef PRODUCT
 306     if (TraceFPUStack) {
 307       tty-&gt;cr();
 308       tty-&gt;print_cr(&quot;------- end of exception handler -------&quot;);
 309     }
 310 #endif
 311 
 312     set_lir(old_lir);
 313     set_pos(old_pos);
 314     sim()-&gt;read_state(old_state);
 315   }
 316 }
 317 
 318 
 319 int FpuStackAllocator::fpu_num(LIR_Opr opr) {
 320   assert(opr-&gt;is_fpu_register() &amp;&amp; !opr-&gt;is_xmm_register(), &quot;shouldn&#39;t call this otherwise&quot;);
 321   return opr-&gt;is_single_fpu() ? opr-&gt;fpu_regnr() : opr-&gt;fpu_regnrLo();
 322 }
 323 
 324 int FpuStackAllocator::tos_offset(LIR_Opr opr) {
 325   return sim()-&gt;offset_from_tos(fpu_num(opr));
 326 }
 327 
 328 
 329 LIR_Opr FpuStackAllocator::to_fpu_stack(LIR_Opr opr) {
 330   assert(opr-&gt;is_fpu_register() &amp;&amp; !opr-&gt;is_xmm_register(), &quot;shouldn&#39;t call this otherwise&quot;);
 331 
 332   int stack_offset = tos_offset(opr);
 333   if (opr-&gt;is_single_fpu()) {
 334     return LIR_OprFact::single_fpu(stack_offset)-&gt;make_fpu_stack_offset();
 335   } else {
 336     assert(opr-&gt;is_double_fpu(), &quot;shouldn&#39;t call this otherwise&quot;);
 337     return LIR_OprFact::double_fpu(stack_offset)-&gt;make_fpu_stack_offset();
 338   }
 339 }
 340 
 341 LIR_Opr FpuStackAllocator::to_fpu_stack_top(LIR_Opr opr, bool dont_check_offset) {
 342   assert(opr-&gt;is_fpu_register() &amp;&amp; !opr-&gt;is_xmm_register(), &quot;shouldn&#39;t call this otherwise&quot;);
 343   assert(dont_check_offset || tos_offset(opr) == 0, &quot;operand is not on stack top&quot;);
 344 
 345   int stack_offset = 0;
 346   if (opr-&gt;is_single_fpu()) {
 347     return LIR_OprFact::single_fpu(stack_offset)-&gt;make_fpu_stack_offset();
 348   } else {
 349     assert(opr-&gt;is_double_fpu(), &quot;shouldn&#39;t call this otherwise&quot;);
 350     return LIR_OprFact::double_fpu(stack_offset)-&gt;make_fpu_stack_offset();
 351   }
 352 }
 353 
 354 
 355 
 356 void FpuStackAllocator::insert_op(LIR_Op* op) {
 357   lir()-&gt;insert_before(pos(), op);
 358   set_pos(1 + pos());
 359 }
 360 
 361 
 362 void FpuStackAllocator::insert_exchange(int offset) {
 363   if (offset &gt; 0) {
 364     LIR_Op1* fxch_op = new LIR_Op1(lir_fxch, LIR_OprFact::intConst(offset), LIR_OprFact::illegalOpr);
 365     insert_op(fxch_op);
 366     sim()-&gt;swap(offset);
 367 
 368 #ifndef PRODUCT
 369     if (TraceFPUStack) {
 370       tty-&gt;print(&quot;Exchanged register: %d         New state: &quot;, sim()-&gt;get_slot(0)); sim()-&gt;print(); tty-&gt;cr();
 371     }
 372 #endif
 373 
 374   }
 375 }
 376 
 377 void FpuStackAllocator::insert_exchange(LIR_Opr opr) {
 378   insert_exchange(tos_offset(opr));
 379 }
 380 
 381 
 382 void FpuStackAllocator::insert_free(int offset) {
 383   // move stack slot to the top of stack and then pop it
 384   insert_exchange(offset);
 385 
 386   LIR_Op* fpop = new LIR_Op0(lir_fpop_raw);
 387   insert_op(fpop);
 388   sim()-&gt;pop();
 389 
 390 #ifndef PRODUCT
 391     if (TraceFPUStack) {
 392       tty-&gt;print(&quot;Inserted pop                   New state: &quot;); sim()-&gt;print(); tty-&gt;cr();
 393     }
 394 #endif
 395 }
 396 
 397 
 398 void FpuStackAllocator::insert_free_if_dead(LIR_Opr opr) {
 399   if (sim()-&gt;contains(fpu_num(opr))) {
 400     int res_slot = tos_offset(opr);
 401     insert_free(res_slot);
 402   }
 403 }
 404 
 405 void FpuStackAllocator::insert_free_if_dead(LIR_Opr opr, LIR_Opr ignore) {
 406   if (fpu_num(opr) != fpu_num(ignore) &amp;&amp; sim()-&gt;contains(fpu_num(opr))) {
 407     int res_slot = tos_offset(opr);
 408     insert_free(res_slot);
 409   }
 410 }
 411 
 412 void FpuStackAllocator::insert_copy(LIR_Opr from, LIR_Opr to) {
 413   int offset = tos_offset(from);
 414   LIR_Op1* fld = new LIR_Op1(lir_fld, LIR_OprFact::intConst(offset), LIR_OprFact::illegalOpr);
 415   insert_op(fld);
 416 
 417   sim()-&gt;push(fpu_num(to));
 418 
 419 #ifndef PRODUCT
 420   if (TraceFPUStack) {
 421     tty-&gt;print(&quot;Inserted copy (%d -&gt; %d)         New state: &quot;, fpu_num(from), fpu_num(to)); sim()-&gt;print(); tty-&gt;cr();
 422   }
 423 #endif
 424 }
 425 
 426 void FpuStackAllocator::do_rename(LIR_Opr from, LIR_Opr to) {
 427   sim()-&gt;rename(fpu_num(from), fpu_num(to));
 428 }
 429 
 430 void FpuStackAllocator::do_push(LIR_Opr opr) {
 431   sim()-&gt;push(fpu_num(opr));
 432 }
 433 
 434 void FpuStackAllocator::pop_if_last_use(LIR_Op* op, LIR_Opr opr) {
 435   assert(op-&gt;fpu_pop_count() == 0, &quot;fpu_pop_count alredy set&quot;);
 436   assert(tos_offset(opr) == 0, &quot;can only pop stack top&quot;);
 437 
 438   if (opr-&gt;is_last_use()) {
 439     op-&gt;set_fpu_pop_count(1);
 440     sim()-&gt;pop();
 441   }
 442 }
 443 
 444 void FpuStackAllocator::pop_always(LIR_Op* op, LIR_Opr opr) {
 445   assert(op-&gt;fpu_pop_count() == 0, &quot;fpu_pop_count alredy set&quot;);
 446   assert(tos_offset(opr) == 0, &quot;can only pop stack top&quot;);
 447 
 448   op-&gt;set_fpu_pop_count(1);
 449   sim()-&gt;pop();
 450 }
 451 
 452 void FpuStackAllocator::clear_fpu_stack(LIR_Opr preserve) {
 453   int result_stack_size = (preserve-&gt;is_fpu_register() &amp;&amp; !preserve-&gt;is_xmm_register() ? 1 : 0);
 454   while (sim()-&gt;stack_size() &gt; result_stack_size) {
 455     assert(!sim()-&gt;slot_is_empty(0), &quot;not allowed&quot;);
 456 
 457     if (result_stack_size == 0 || sim()-&gt;get_slot(0) != fpu_num(preserve)) {
 458       insert_free(0);
 459     } else {
 460       // move &quot;preserve&quot; to bottom of stack so that all other stack slots can be popped
 461       insert_exchange(sim()-&gt;stack_size() - 1);
 462     }
 463   }
 464 }
 465 
 466 
 467 void FpuStackAllocator::handle_op1(LIR_Op1* op1) {
 468   LIR_Opr in  = op1-&gt;in_opr();
 469   LIR_Opr res = op1-&gt;result_opr();
 470 
 471   LIR_Opr new_in  = in;  // new operands relative to the actual fpu stack top
 472   LIR_Opr new_res = res;
 473 
 474   // Note: this switch is processed for all LIR_Op1, regardless if they have FPU-arguments,
 475   //       so checks for is_float_kind() are necessary inside the cases
 476   switch (op1-&gt;code()) {
 477 
 478     case lir_return: {
 479       // FPU-Stack must only contain the (optional) fpu return value.
 480       // All remaining dead values are popped from the stack
 481       // If the input operand is a fpu-register, it is exchanged to the bottom of the stack
 482 
 483       clear_fpu_stack(in);
 484       if (in-&gt;is_fpu_register() &amp;&amp; !in-&gt;is_xmm_register()) {
 485         new_in = to_fpu_stack_top(in);
 486       }
 487 
 488       break;
 489     }
 490 
 491     case lir_move: {
 492       if (in-&gt;is_fpu_register() &amp;&amp; !in-&gt;is_xmm_register()) {
 493         if (res-&gt;is_xmm_register()) {
 494           // move from fpu register to xmm register (necessary for operations that
 495           // are not available in the SSE instruction set)
 496           insert_exchange(in);
 497           new_in = to_fpu_stack_top(in);
 498           pop_always(op1, in);
 499 
 500         } else if (res-&gt;is_fpu_register() &amp;&amp; !res-&gt;is_xmm_register()) {
 501           // move from fpu-register to fpu-register:
 502           // * input and result register equal:
 503           //   nothing to do
 504           // * input register is last use:
 505           //   rename the input register to result register -&gt; input register
 506           //   not present on fpu-stack afterwards
 507           // * input register not last use:
 508           //   duplicate input register to result register to preserve input
 509           //
 510           // Note: The LIR-Assembler does not produce any code for fpu register moves,
 511           //       so input and result stack index must be equal
 512 
 513           if (fpu_num(in) == fpu_num(res)) {
 514             // nothing to do
 515           } else if (in-&gt;is_last_use()) {
 516             insert_free_if_dead(res);//, in);
 517             do_rename(in, res);
 518           } else {
 519             insert_free_if_dead(res);
 520             insert_copy(in, res);
 521           }
 522           new_in = to_fpu_stack(res);
 523           new_res = new_in;
 524 
 525         } else {
 526           // move from fpu-register to memory
 527           // input operand must be on top of stack
 528 
 529           insert_exchange(in);
 530 
 531           // create debug information here because afterwards the register may have been popped
 532           compute_debug_information(op1);
 533 
 534           new_in = to_fpu_stack_top(in);
 535           pop_if_last_use(op1, in);
 536         }
 537 
 538       } else if (res-&gt;is_fpu_register() &amp;&amp; !res-&gt;is_xmm_register()) {
 539         // move from memory/constant to fpu register
 540         // result is pushed on the stack
 541 
 542         insert_free_if_dead(res);
 543 
 544         // create debug information before register is pushed
 545         compute_debug_information(op1);
 546 
 547         do_push(res);
 548         new_res = to_fpu_stack_top(res);
 549       }
 550       break;
 551     }
 552 
 553     case lir_neg: {
 554       if (in-&gt;is_fpu_register() &amp;&amp; !in-&gt;is_xmm_register()) {
 555         assert(res-&gt;is_fpu_register() &amp;&amp; !res-&gt;is_xmm_register(), &quot;must be&quot;);
 556         assert(in-&gt;is_last_use(), &quot;old value gets destroyed&quot;);
 557 
 558         insert_free_if_dead(res, in);
 559         insert_exchange(in);
 560         new_in = to_fpu_stack_top(in);
 561 
 562         do_rename(in, res);
 563         new_res = to_fpu_stack_top(res);
 564       }
 565       break;
 566     }
 567 
 568     case lir_convert: {
 569       Bytecodes::Code bc = op1-&gt;as_OpConvert()-&gt;bytecode();
 570       switch (bc) {
 571         case Bytecodes::_d2f:
 572         case Bytecodes::_f2d:
 573           assert(res-&gt;is_fpu_register(), &quot;must be&quot;);
 574           assert(in-&gt;is_fpu_register(), &quot;must be&quot;);
 575 
 576           if (!in-&gt;is_xmm_register() &amp;&amp; !res-&gt;is_xmm_register()) {
 577             // this is quite the same as a move from fpu-register to fpu-register
 578             // Note: input and result operands must have different types
 579             if (fpu_num(in) == fpu_num(res)) {
 580               // nothing to do
 581               new_in = to_fpu_stack(in);
 582             } else if (in-&gt;is_last_use()) {
 583               insert_free_if_dead(res);//, in);
 584               new_in = to_fpu_stack(in);
 585               do_rename(in, res);
 586             } else {
 587               insert_free_if_dead(res);
 588               insert_copy(in, res);
 589               new_in = to_fpu_stack_top(in, true);
 590             }
 591             new_res = to_fpu_stack(res);
 592           }
 593 
 594           break;
 595 
 596         case Bytecodes::_i2f:
 597         case Bytecodes::_l2f:
 598         case Bytecodes::_i2d:
 599         case Bytecodes::_l2d:
 600           assert(res-&gt;is_fpu_register(), &quot;must be&quot;);
 601           if (!res-&gt;is_xmm_register()) {
 602             insert_free_if_dead(res);
 603             do_push(res);
 604             new_res = to_fpu_stack_top(res);
 605           }
 606           break;
 607 
 608         case Bytecodes::_f2i:
 609         case Bytecodes::_d2i:
 610           assert(in-&gt;is_fpu_register(), &quot;must be&quot;);
 611           if (!in-&gt;is_xmm_register()) {
 612             insert_exchange(in);
 613             new_in = to_fpu_stack_top(in);
 614 
 615             // TODO: update registes of stub
 616           }
 617           break;
 618 
 619         case Bytecodes::_f2l:
 620         case Bytecodes::_d2l:
 621           assert(in-&gt;is_fpu_register(), &quot;must be&quot;);
 622           if (!in-&gt;is_xmm_register()) {
 623             insert_exchange(in);
 624             new_in = to_fpu_stack_top(in);
 625             pop_always(op1, in);
 626           }
 627           break;
 628 
 629         case Bytecodes::_i2l:
 630         case Bytecodes::_l2i:
 631         case Bytecodes::_i2b:
 632         case Bytecodes::_i2c:
 633         case Bytecodes::_i2s:
 634           // no fpu operands
 635           break;
 636 
 637         default:
 638           ShouldNotReachHere();
 639       }
 640       break;
 641     }
 642 
 643     case lir_roundfp: {
 644       assert(in-&gt;is_fpu_register() &amp;&amp; !in-&gt;is_xmm_register(), &quot;input must be in register&quot;);
 645       assert(res-&gt;is_stack(), &quot;result must be on stack&quot;);
 646 
 647       insert_exchange(in);
 648       new_in = to_fpu_stack_top(in);
 649       pop_if_last_use(op1, in);
 650       break;
 651     }
 652 
 653     default: {
 654       assert(!in-&gt;is_float_kind() &amp;&amp; !res-&gt;is_float_kind(), &quot;missed a fpu-operation&quot;);
 655     }
 656   }
 657 
 658   op1-&gt;set_in_opr(new_in);
 659   op1-&gt;set_result_opr(new_res);
 660 }
 661 
 662 void FpuStackAllocator::handle_op2(LIR_Op2* op2) {
 663   LIR_Opr left  = op2-&gt;in_opr1();
 664   if (!left-&gt;is_float_kind()) {
 665     return;
 666   }
 667   if (left-&gt;is_xmm_register()) {
 668     return;
 669   }
 670 
 671   LIR_Opr right = op2-&gt;in_opr2();
 672   LIR_Opr res   = op2-&gt;result_opr();
 673   LIR_Opr new_left  = left;  // new operands relative to the actual fpu stack top
 674   LIR_Opr new_right = right;
 675   LIR_Opr new_res   = res;
 676 
 677   assert(!left-&gt;is_xmm_register() &amp;&amp; !right-&gt;is_xmm_register() &amp;&amp; !res-&gt;is_xmm_register(), &quot;not for xmm registers&quot;);
 678 
 679   switch (op2-&gt;code()) {
 680     case lir_cmp:
 681     case lir_cmp_fd2i:
 682     case lir_ucmp_fd2i:
 683     case lir_assert: {
 684       assert(left-&gt;is_fpu_register(), &quot;invalid LIR&quot;);
 685       assert(right-&gt;is_fpu_register(), &quot;invalid LIR&quot;);
 686 
 687       // the left-hand side must be on top of stack.
 688       // the right-hand side is never popped, even if is_last_use is set
 689       insert_exchange(left);
 690       new_left = to_fpu_stack_top(left);
 691       new_right = to_fpu_stack(right);
 692       pop_if_last_use(op2, left);
 693       break;
 694     }
 695 
 696     case lir_mul_strictfp:
 697     case lir_div_strictfp: {
 698       assert(op2-&gt;tmp1_opr()-&gt;is_fpu_register(), &quot;strict operations need temporary fpu stack slot&quot;);
 699       insert_free_if_dead(op2-&gt;tmp1_opr());
 700       assert(sim()-&gt;stack_size() &lt;= 7, &quot;at least one stack slot must be free&quot;);
 701       // fall-through: continue with the normal handling of lir_mul and lir_div
 702     }
 703     case lir_add:
 704     case lir_sub:
 705     case lir_mul:
 706     case lir_div: {
 707       assert(left-&gt;is_fpu_register(), &quot;must be&quot;);
 708       assert(res-&gt;is_fpu_register(), &quot;must be&quot;);
 709       assert(left-&gt;is_equal(res), &quot;must be&quot;);
 710 
 711       // either the left-hand or the right-hand side must be on top of stack
 712       // (if right is not a register, left must be on top)
 713       if (!right-&gt;is_fpu_register()) {
 714         insert_exchange(left);
 715         new_left = to_fpu_stack_top(left);
 716       } else {
 717         // no exchange necessary if right is alredy on top of stack
 718         if (tos_offset(right) == 0) {
 719           new_left = to_fpu_stack(left);
 720           new_right = to_fpu_stack_top(right);
 721         } else {
 722           insert_exchange(left);
 723           new_left = to_fpu_stack_top(left);
 724           new_right = to_fpu_stack(right);
 725         }
 726 
 727         if (right-&gt;is_last_use()) {
 728           op2-&gt;set_fpu_pop_count(1);
 729 
 730           if (tos_offset(right) == 0) {
 731             sim()-&gt;pop();
 732           } else {
 733             // if left is on top of stack, the result is placed in the stack
 734             // slot of right, so a renaming from right to res is necessary
 735             assert(tos_offset(left) == 0, &quot;must be&quot;);
 736             sim()-&gt;pop();
 737             do_rename(right, res);
 738           }
 739         }
 740       }
 741       new_res = to_fpu_stack(res);
 742 
 743       break;
 744     }
 745 
 746     case lir_rem: {
 747       assert(left-&gt;is_fpu_register(), &quot;must be&quot;);
 748       assert(right-&gt;is_fpu_register(), &quot;must be&quot;);
 749       assert(res-&gt;is_fpu_register(), &quot;must be&quot;);
 750       assert(left-&gt;is_equal(res), &quot;must be&quot;);
 751 
 752       // Must bring both operands to top of stack with following operand ordering:
 753       // * fpu stack before rem: ... right left
 754       // * fpu stack after rem:  ... left
 755       if (tos_offset(right) != 1) {
 756         insert_exchange(right);
 757         insert_exchange(1);
 758       }
 759       insert_exchange(left);
 760       assert(tos_offset(right) == 1, &quot;check&quot;);
 761       assert(tos_offset(left) == 0, &quot;check&quot;);
 762 
 763       new_left = to_fpu_stack_top(left);
 764       new_right = to_fpu_stack(right);
 765 
 766       op2-&gt;set_fpu_pop_count(1);
 767       sim()-&gt;pop();
 768       do_rename(right, res);
 769 
 770       new_res = to_fpu_stack_top(res);
 771       break;
 772     }
 773 
 774     case lir_abs:
 775     case lir_sqrt: {
 776       // Right argument appears to be unused
 777       assert(right-&gt;is_illegal(), &quot;must be&quot;);
 778       assert(left-&gt;is_fpu_register(), &quot;must be&quot;);
 779       assert(res-&gt;is_fpu_register(), &quot;must be&quot;);
 780       assert(left-&gt;is_last_use(), &quot;old value gets destroyed&quot;);
 781 
 782       insert_free_if_dead(res, left);
 783       insert_exchange(left);
 784       do_rename(left, res);
 785 
 786       new_left = to_fpu_stack_top(res);
 787       new_res = new_left;
 788 
 789       op2-&gt;set_fpu_stack_size(sim()-&gt;stack_size());
 790       break;
 791     }
 792 
 793     default: {
 794       assert(false, &quot;missed a fpu-operation&quot;);
 795     }
 796   }
 797 
 798   op2-&gt;set_in_opr1(new_left);
 799   op2-&gt;set_in_opr2(new_right);
 800   op2-&gt;set_result_opr(new_res);
 801 }
 802 
 803 void FpuStackAllocator::handle_opCall(LIR_OpCall* opCall) {
 804   LIR_Opr res = opCall-&gt;result_opr();
 805 
 806   // clear fpu-stack before call
 807   // it may contain dead values that could not have been remved by previous operations
 808   clear_fpu_stack(LIR_OprFact::illegalOpr);
 809   assert(sim()-&gt;is_empty(), &quot;fpu stack must be empty now&quot;);
 810 
 811   // compute debug information before (possible) fpu result is pushed
 812   compute_debug_information(opCall);
 813 
 814   if (res-&gt;is_fpu_register() &amp;&amp; !res-&gt;is_xmm_register()) {
 815     do_push(res);
 816     opCall-&gt;set_result_opr(to_fpu_stack_top(res));
 817   }
 818 }
 819 
 820 #ifndef PRODUCT
 821 void FpuStackAllocator::check_invalid_lir_op(LIR_Op* op) {
 822   switch (op-&gt;code()) {
<a name="2" id="anc2"></a>





 823     case lir_fpop_raw:
 824     case lir_fxch:
 825     case lir_fld:
 826       assert(false, &quot;operations only inserted by FpuStackAllocator&quot;);
 827       break;
 828 
 829     default:
 830       break;
 831   }
 832 }
 833 #endif
 834 
 835 
 836 void FpuStackAllocator::merge_insert_add(LIR_List* instrs, FpuStackSim* cur_sim, int reg) {
 837   LIR_Op1* move = new LIR_Op1(lir_move, LIR_OprFact::doubleConst(0), LIR_OprFact::double_fpu(reg)-&gt;make_fpu_stack_offset());
 838 
 839   instrs-&gt;instructions_list()-&gt;push(move);
 840 
 841   cur_sim-&gt;push(reg);
 842   move-&gt;set_result_opr(to_fpu_stack(move-&gt;result_opr()));
 843 
 844   #ifndef PRODUCT
 845     if (TraceFPUStack) {
 846       tty-&gt;print(&quot;Added new register: %d         New state: &quot;, reg); cur_sim-&gt;print(); tty-&gt;cr();
 847     }
 848   #endif
 849 }
 850 
 851 void FpuStackAllocator::merge_insert_xchg(LIR_List* instrs, FpuStackSim* cur_sim, int slot) {
 852   assert(slot &gt; 0, &quot;no exchange necessary&quot;);
 853 
 854   LIR_Op1* fxch = new LIR_Op1(lir_fxch, LIR_OprFact::intConst(slot));
 855   instrs-&gt;instructions_list()-&gt;push(fxch);
 856   cur_sim-&gt;swap(slot);
 857 
 858   #ifndef PRODUCT
 859     if (TraceFPUStack) {
 860       tty-&gt;print(&quot;Exchanged register: %d         New state: &quot;, cur_sim-&gt;get_slot(slot)); cur_sim-&gt;print(); tty-&gt;cr();
 861     }
 862   #endif
 863 }
 864 
 865 void FpuStackAllocator::merge_insert_pop(LIR_List* instrs, FpuStackSim* cur_sim) {
 866   int reg = cur_sim-&gt;get_slot(0);
 867 
 868   LIR_Op* fpop = new LIR_Op0(lir_fpop_raw);
 869   instrs-&gt;instructions_list()-&gt;push(fpop);
 870   cur_sim-&gt;pop(reg);
 871 
 872   #ifndef PRODUCT
 873     if (TraceFPUStack) {
 874       tty-&gt;print(&quot;Removed register: %d           New state: &quot;, reg); cur_sim-&gt;print(); tty-&gt;cr();
 875     }
 876   #endif
 877 }
 878 
 879 bool FpuStackAllocator::merge_rename(FpuStackSim* cur_sim, FpuStackSim* sux_sim, int start_slot, int change_slot) {
 880   int reg = cur_sim-&gt;get_slot(change_slot);
 881 
 882   for (int slot = start_slot; slot &gt;= 0; slot--) {
 883     int new_reg = sux_sim-&gt;get_slot(slot);
 884 
 885     if (!cur_sim-&gt;contains(new_reg)) {
 886       cur_sim-&gt;set_slot(change_slot, new_reg);
 887 
 888       #ifndef PRODUCT
 889         if (TraceFPUStack) {
 890           tty-&gt;print(&quot;Renamed register %d to %d       New state: &quot;, reg, new_reg); cur_sim-&gt;print(); tty-&gt;cr();
 891         }
 892       #endif
 893 
 894       return true;
 895     }
 896   }
 897   return false;
 898 }
 899 
 900 
 901 void FpuStackAllocator::merge_fpu_stack(LIR_List* instrs, FpuStackSim* cur_sim, FpuStackSim* sux_sim) {
 902 #ifndef PRODUCT
 903   if (TraceFPUStack) {
 904     tty-&gt;cr();
 905     tty-&gt;print(&quot;before merging: pred: &quot;); cur_sim-&gt;print(); tty-&gt;cr();
 906     tty-&gt;print(&quot;                 sux: &quot;); sux_sim-&gt;print(); tty-&gt;cr();
 907   }
 908 
 909   int slot;
 910   for (slot = 0; slot &lt; cur_sim-&gt;stack_size(); slot++) {
 911     assert(!cur_sim-&gt;slot_is_empty(slot), &quot;not handled by algorithm&quot;);
 912   }
 913   for (slot = 0; slot &lt; sux_sim-&gt;stack_size(); slot++) {
 914     assert(!sux_sim-&gt;slot_is_empty(slot), &quot;not handled by algorithm&quot;);
 915   }
 916 #endif
 917 
 918   // size difference between cur and sux that must be resolved by adding or removing values form the stack
 919   int size_diff = cur_sim-&gt;stack_size() - sux_sim-&gt;stack_size();
 920 
 921   if (!ComputeExactFPURegisterUsage) {
 922     // add slots that are currently free, but used in successor
 923     // When the exact FPU register usage is computed, the stack does
 924     // not contain dead values at merging -&gt; no values must be added
 925 
 926     int sux_slot = sux_sim-&gt;stack_size() - 1;
 927     while (size_diff &lt; 0) {
 928       assert(sux_slot &gt;= 0, &quot;slot out of bounds -&gt; error in algorithm&quot;);
 929 
 930       int reg = sux_sim-&gt;get_slot(sux_slot);
 931       if (!cur_sim-&gt;contains(reg)) {
 932         merge_insert_add(instrs, cur_sim, reg);
 933         size_diff++;
 934 
 935         if (sux_slot + size_diff != 0) {
 936           merge_insert_xchg(instrs, cur_sim, sux_slot + size_diff);
 937         }
 938       }
 939      sux_slot--;
 940     }
 941   }
 942 
 943   assert(cur_sim-&gt;stack_size() &gt;= sux_sim-&gt;stack_size(), &quot;stack size must be equal or greater now&quot;);
 944   assert(size_diff == cur_sim-&gt;stack_size() - sux_sim-&gt;stack_size(), &quot;must be&quot;);
 945 
 946   // stack merge algorithm:
 947   // 1) as long as the current stack top is not in the right location (that meens
 948   //    it should not be on the stack top), exchange it into the right location
 949   // 2) if the stack top is right, but the remaining stack is not ordered correctly,
 950   //    the stack top is exchanged away to get another value on top -&gt;
 951   //    now step 1) can be continued
 952   // the stack can also contain unused items -&gt; these items are removed from stack
 953 
 954   int finished_slot = sux_sim-&gt;stack_size() - 1;
 955   while (finished_slot &gt;= 0 || size_diff &gt; 0) {
 956     while (size_diff &gt; 0 || (cur_sim-&gt;stack_size() &gt; 0 &amp;&amp; cur_sim-&gt;get_slot(0) != sux_sim-&gt;get_slot(0))) {
 957       int reg = cur_sim-&gt;get_slot(0);
 958       if (sux_sim-&gt;contains(reg)) {
 959         int sux_slot = sux_sim-&gt;offset_from_tos(reg);
 960         merge_insert_xchg(instrs, cur_sim, sux_slot + size_diff);
 961 
 962       } else if (!merge_rename(cur_sim, sux_sim, finished_slot, 0)) {
 963         assert(size_diff &gt; 0, &quot;must be&quot;);
 964 
 965         merge_insert_pop(instrs, cur_sim);
 966         size_diff--;
 967       }
 968       assert(cur_sim-&gt;stack_size() == 0 || cur_sim-&gt;get_slot(0) != reg, &quot;register must have been changed&quot;);
 969     }
 970 
 971     while (finished_slot &gt;= 0 &amp;&amp; cur_sim-&gt;get_slot(finished_slot) == sux_sim-&gt;get_slot(finished_slot)) {
 972       finished_slot--;
 973     }
 974 
 975     if (finished_slot &gt;= 0) {
 976       int reg = cur_sim-&gt;get_slot(finished_slot);
 977 
 978       if (sux_sim-&gt;contains(reg) || !merge_rename(cur_sim, sux_sim, finished_slot, finished_slot)) {
 979         assert(sux_sim-&gt;contains(reg) || size_diff &gt; 0, &quot;must be&quot;);
 980         merge_insert_xchg(instrs, cur_sim, finished_slot);
 981       }
 982       assert(cur_sim-&gt;get_slot(finished_slot) != reg, &quot;register must have been changed&quot;);
 983     }
 984   }
 985 
 986 #ifndef PRODUCT
 987   if (TraceFPUStack) {
 988     tty-&gt;print(&quot;after merging:  pred: &quot;); cur_sim-&gt;print(); tty-&gt;cr();
 989     tty-&gt;print(&quot;                 sux: &quot;); sux_sim-&gt;print(); tty-&gt;cr();
 990     tty-&gt;cr();
 991   }
 992 #endif
 993   assert(cur_sim-&gt;stack_size() == sux_sim-&gt;stack_size(), &quot;stack size must be equal now&quot;);
 994 }
 995 
 996 
 997 void FpuStackAllocator::merge_cleanup_fpu_stack(LIR_List* instrs, FpuStackSim* cur_sim, BitMap&amp; live_fpu_regs) {
 998 #ifndef PRODUCT
 999   if (TraceFPUStack) {
1000     tty-&gt;cr();
1001     tty-&gt;print(&quot;before cleanup: state: &quot;); cur_sim-&gt;print(); tty-&gt;cr();
1002     tty-&gt;print(&quot;                live:  &quot;); live_fpu_regs.print_on(tty); tty-&gt;cr();
1003   }
1004 #endif
1005 
1006   int slot = 0;
1007   while (slot &lt; cur_sim-&gt;stack_size()) {
1008     int reg = cur_sim-&gt;get_slot(slot);
1009     if (!live_fpu_regs.at(reg)) {
1010       if (slot != 0) {
1011         merge_insert_xchg(instrs, cur_sim, slot);
1012       }
1013       merge_insert_pop(instrs, cur_sim);
1014     } else {
1015       slot++;
1016     }
1017   }
1018 
1019 #ifndef PRODUCT
1020   if (TraceFPUStack) {
1021     tty-&gt;print(&quot;after cleanup:  state: &quot;); cur_sim-&gt;print(); tty-&gt;cr();
1022     tty-&gt;print(&quot;                live:  &quot;); live_fpu_regs.print_on(tty); tty-&gt;cr();
1023     tty-&gt;cr();
1024   }
1025 
1026   // check if fpu stack only contains live registers
1027   for (unsigned int i = 0; i &lt; live_fpu_regs.size(); i++) {
1028     if (live_fpu_regs.at(i) != cur_sim-&gt;contains(i)) {
1029       tty-&gt;print_cr(&quot;mismatch between required and actual stack content&quot;);
1030       break;
1031     }
1032   }
1033 #endif
1034 }
1035 
1036 
1037 bool FpuStackAllocator::merge_fpu_stack_with_successors(BlockBegin* block) {
1038 #ifndef PRODUCT
1039   if (TraceFPUStack) {
1040     tty-&gt;print_cr(&quot;Propagating FPU stack state for B%d at LIR_Op position %d to successors:&quot;,
1041                   block-&gt;block_id(), pos());
1042     sim()-&gt;print();
1043     tty-&gt;cr();
1044   }
1045 #endif
1046 
1047   bool changed = false;
1048   int number_of_sux = block-&gt;number_of_sux();
1049 
1050   if (number_of_sux == 1 &amp;&amp; block-&gt;sux_at(0)-&gt;number_of_preds() &gt; 1) {
1051     // The successor has at least two incoming edges, so a stack merge will be necessary
1052     // If this block is the first predecessor, cleanup the current stack and propagate it
1053     // If this block is not the first predecessor, a stack merge will be necessary
1054 
1055     BlockBegin* sux = block-&gt;sux_at(0);
1056     intArray* state = sux-&gt;fpu_stack_state();
1057     LIR_List* instrs = new LIR_List(_compilation);
1058 
1059     if (state != NULL) {
1060       // Merge with a successors that already has a FPU stack state
1061       // the block must only have one successor because critical edges must been split
1062       FpuStackSim* cur_sim = sim();
1063       FpuStackSim* sux_sim = temp_sim();
1064       sux_sim-&gt;read_state(state);
1065 
1066       merge_fpu_stack(instrs, cur_sim, sux_sim);
1067 
1068     } else {
1069       // propagate current FPU stack state to successor without state
1070       // clean up stack first so that there are no dead values on the stack
1071       if (ComputeExactFPURegisterUsage) {
1072         FpuStackSim* cur_sim = sim();
1073         ResourceBitMap live_fpu_regs = block-&gt;sux_at(0)-&gt;fpu_register_usage();
1074         assert(live_fpu_regs.size() == FrameMap::nof_fpu_regs, &quot;missing register usage&quot;);
1075 
1076         merge_cleanup_fpu_stack(instrs, cur_sim, live_fpu_regs);
1077       }
1078 
1079       intArray* state = sim()-&gt;write_state();
1080       if (TraceFPUStack) {
1081         tty-&gt;print_cr(&quot;Setting FPU stack state of B%d (merge path)&quot;, sux-&gt;block_id());
1082         sim()-&gt;print(); tty-&gt;cr();
1083       }
1084       sux-&gt;set_fpu_stack_state(state);
1085     }
1086 
1087     if (instrs-&gt;instructions_list()-&gt;length() &gt; 0) {
1088       lir()-&gt;insert_before(pos(), instrs);
1089       set_pos(instrs-&gt;instructions_list()-&gt;length() + pos());
1090       changed = true;
1091     }
1092 
1093   } else {
1094     // Propagate unmodified Stack to successors where a stack merge is not necessary
1095     intArray* state = sim()-&gt;write_state();
1096     for (int i = 0; i &lt; number_of_sux; i++) {
1097       BlockBegin* sux = block-&gt;sux_at(i);
1098 
1099 #ifdef ASSERT
1100       for (int j = 0; j &lt; sux-&gt;number_of_preds(); j++) {
1101         assert(block == sux-&gt;pred_at(j), &quot;all critical edges must be broken&quot;);
1102       }
1103 
1104       // check if new state is same
1105       if (sux-&gt;fpu_stack_state() != NULL) {
1106         intArray* sux_state = sux-&gt;fpu_stack_state();
1107         assert(state-&gt;length() == sux_state-&gt;length(), &quot;overwriting existing stack state&quot;);
1108         for (int j = 0; j &lt; state-&gt;length(); j++) {
1109           assert(state-&gt;at(j) == sux_state-&gt;at(j), &quot;overwriting existing stack state&quot;);
1110         }
1111       }
1112 #endif
1113 #ifndef PRODUCT
1114       if (TraceFPUStack) {
1115         tty-&gt;print_cr(&quot;Setting FPU stack state of B%d&quot;, sux-&gt;block_id());
1116         sim()-&gt;print(); tty-&gt;cr();
1117       }
1118 #endif
1119 
1120       sux-&gt;set_fpu_stack_state(state);
1121     }
1122   }
1123 
1124 #ifndef PRODUCT
1125   // assertions that FPU stack state conforms to all successors&#39; states
1126   intArray* cur_state = sim()-&gt;write_state();
1127   for (int i = 0; i &lt; number_of_sux; i++) {
1128     BlockBegin* sux = block-&gt;sux_at(i);
1129     intArray* sux_state = sux-&gt;fpu_stack_state();
1130 
1131     assert(sux_state != NULL, &quot;no fpu state&quot;);
1132     assert(cur_state-&gt;length() == sux_state-&gt;length(), &quot;incorrect length&quot;);
1133     for (int i = 0; i &lt; cur_state-&gt;length(); i++) {
1134       assert(cur_state-&gt;at(i) == sux_state-&gt;at(i), &quot;element not equal&quot;);
1135     }
1136   }
1137 #endif
1138 
1139   return changed;
1140 }
<a name="3" id="anc3"></a><span class="line-added">1141 #endif // _LP64</span>
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
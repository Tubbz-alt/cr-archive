<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/nativeInst_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodHandles_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/nativeInst_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
338   if ( instr_0 == instruction_code_xmm_ss_prefix || // 0xf3
339        instr_0 == instruction_code_xmm_sd_prefix) { // 0xf2
340     off++;
341     instr_0 = ubyte_at(off);
342   }
343 
344   if ( instr_0 &gt;= instruction_prefix_wide_lo &amp;&amp; // 0x40
345        instr_0 &lt;= instruction_prefix_wide_hi) { // 0x4f
346     off++;
347     instr_0 = ubyte_at(off);
348   }
349 
350 
351   if (instr_0 == instruction_extended_prefix ) {  // 0x0f
352     off++;
353   }
354 
355   return off;
356 }
357 
<span class="line-modified">358 address NativeMovRegMem::instruction_address() const {</span>
<span class="line-removed">359   return addr_at(instruction_start());</span>
<span class="line-removed">360 }</span>
<span class="line-removed">361 </span>
<span class="line-removed">362 address NativeMovRegMem::next_instruction_address() const {</span>
<span class="line-removed">363   address ret = instruction_address() + instruction_size;</span>
<span class="line-removed">364   u_char instr_0 =  *(u_char*) instruction_address();</span>
<span class="line-removed">365   switch (instr_0) {</span>
<span class="line-removed">366   case instruction_operandsize_prefix:</span>
<span class="line-removed">367 </span>
<span class="line-removed">368     fatal(&quot;should have skipped instruction_operandsize_prefix&quot;);</span>
<span class="line-removed">369     break;</span>
<span class="line-removed">370 </span>
<span class="line-removed">371   case instruction_extended_prefix:</span>
<span class="line-removed">372     fatal(&quot;should have skipped instruction_extended_prefix&quot;);</span>
<span class="line-removed">373     break;</span>
<span class="line-removed">374 </span>
<span class="line-removed">375   case instruction_code_mem2reg_movslq: // 0x63</span>
<span class="line-removed">376   case instruction_code_mem2reg_movzxb: // 0xB6</span>
<span class="line-removed">377   case instruction_code_mem2reg_movsxb: // 0xBE</span>
<span class="line-removed">378   case instruction_code_mem2reg_movzxw: // 0xB7</span>
<span class="line-removed">379   case instruction_code_mem2reg_movsxw: // 0xBF</span>
<span class="line-removed">380   case instruction_code_reg2mem:        // 0x89 (q/l)</span>
<span class="line-removed">381   case instruction_code_mem2reg:        // 0x8B (q/l)</span>
<span class="line-removed">382   case instruction_code_reg2memb:       // 0x88</span>
<span class="line-removed">383   case instruction_code_mem2regb:       // 0x8a</span>
<span class="line-removed">384 </span>
<span class="line-removed">385   case instruction_code_lea:            // 0x8d</span>
<span class="line-removed">386 </span>
<span class="line-removed">387   case instruction_code_float_s:        // 0xd9 fld_s a</span>
<span class="line-removed">388   case instruction_code_float_d:        // 0xdd fld_d a</span>
<span class="line-removed">389 </span>
<span class="line-removed">390   case instruction_code_xmm_load:       // 0x10</span>
<span class="line-removed">391   case instruction_code_xmm_store:      // 0x11</span>
<span class="line-removed">392   case instruction_code_xmm_lpd:        // 0x12</span>
<span class="line-removed">393     {</span>
<span class="line-removed">394       // If there is an SIB then instruction is longer than expected</span>
<span class="line-removed">395       u_char mod_rm = *(u_char*)(instruction_address() + 1);</span>
<span class="line-removed">396       if ((mod_rm &amp; 7) == 0x4) {</span>
<span class="line-removed">397         ret++;</span>
<span class="line-removed">398       }</span>
<span class="line-removed">399     }</span>
<span class="line-removed">400   case instruction_code_xor:</span>
<span class="line-removed">401     fatal(&quot;should have skipped xor lead in&quot;);</span>
<span class="line-removed">402     break;</span>
<span class="line-removed">403 </span>
<span class="line-removed">404   default:</span>
<span class="line-removed">405     fatal(&quot;not a NativeMovRegMem&quot;);</span>
<span class="line-removed">406   }</span>
<span class="line-removed">407   return ret;</span>
<span class="line-removed">408 </span>
<span class="line-removed">409 }</span>
<span class="line-removed">410 </span>
<span class="line-removed">411 int NativeMovRegMem::offset() const{</span>
412   int off = data_offset + instruction_start();
413   u_char mod_rm = *(u_char*)(instruction_address() + 1);
414   // nnnn(r12|rsp) isn&#39;t coded as simple mod/rm since that is
415   // the encoding to use an SIB byte. Which will have the nnnn
416   // field off by one byte
417   if ((mod_rm &amp; 7) == 0x4) {
418     off++;
419   }
<span class="line-modified">420   return int_at(off);</span>
<span class="line-removed">421 }</span>
<span class="line-removed">422 </span>
<span class="line-removed">423 void NativeMovRegMem::set_offset(int x) {</span>
<span class="line-removed">424   int off = data_offset + instruction_start();</span>
<span class="line-removed">425   u_char mod_rm = *(u_char*)(instruction_address() + 1);</span>
<span class="line-removed">426   // nnnn(r12|rsp) isn&#39;t coded as simple mod/rm since that is</span>
<span class="line-removed">427   // the encoding to use an SIB byte. Which will have the nnnn</span>
<span class="line-removed">428   // field off by one byte</span>
<span class="line-removed">429   if ((mod_rm &amp; 7) == 0x4) {</span>
<span class="line-removed">430     off++;</span>
<span class="line-removed">431   }</span>
<span class="line-removed">432   set_int_at(off, x);</span>
433 }
434 
435 void NativeMovRegMem::verify() {
436   // make sure code pattern is actually a mov [reg+offset], reg instruction
437   u_char test_byte = *(u_char*)instruction_address();
438   switch (test_byte) {
439     case instruction_code_reg2memb:  // 0x88 movb a, r
440     case instruction_code_reg2mem:   // 0x89 movl a, r (can be movq in 64bit)
441     case instruction_code_mem2regb:  // 0x8a movb r, a
442     case instruction_code_mem2reg:   // 0x8b movl r, a (can be movq in 64bit)
443       break;
444 
445     case instruction_code_mem2reg_movslq: // 0x63 movsql r, a
446     case instruction_code_mem2reg_movzxb: // 0xb6 movzbl r, a (movzxb)
447     case instruction_code_mem2reg_movzxw: // 0xb7 movzwl r, a (movzxw)
448     case instruction_code_mem2reg_movsxb: // 0xbe movsbl r, a (movsxb)
449     case instruction_code_mem2reg_movsxw: // 0xbf  movswl r, a (movsxw)
450       break;
451 
452     case instruction_code_float_s:   // 0xd9 fld_s a
</pre>
</td>
<td>
<hr />
<pre>
338   if ( instr_0 == instruction_code_xmm_ss_prefix || // 0xf3
339        instr_0 == instruction_code_xmm_sd_prefix) { // 0xf2
340     off++;
341     instr_0 = ubyte_at(off);
342   }
343 
344   if ( instr_0 &gt;= instruction_prefix_wide_lo &amp;&amp; // 0x40
345        instr_0 &lt;= instruction_prefix_wide_hi) { // 0x4f
346     off++;
347     instr_0 = ubyte_at(off);
348   }
349 
350 
351   if (instr_0 == instruction_extended_prefix ) {  // 0x0f
352     off++;
353   }
354 
355   return off;
356 }
357 
<span class="line-modified">358 int NativeMovRegMem::patch_offset() const {</span>





















































359   int off = data_offset + instruction_start();
360   u_char mod_rm = *(u_char*)(instruction_address() + 1);
361   // nnnn(r12|rsp) isn&#39;t coded as simple mod/rm since that is
362   // the encoding to use an SIB byte. Which will have the nnnn
363   // field off by one byte
364   if ((mod_rm &amp; 7) == 0x4) {
365     off++;
366   }
<span class="line-modified">367   return off;</span>












368 }
369 
370 void NativeMovRegMem::verify() {
371   // make sure code pattern is actually a mov [reg+offset], reg instruction
372   u_char test_byte = *(u_char*)instruction_address();
373   switch (test_byte) {
374     case instruction_code_reg2memb:  // 0x88 movb a, r
375     case instruction_code_reg2mem:   // 0x89 movl a, r (can be movq in 64bit)
376     case instruction_code_mem2regb:  // 0x8a movb r, a
377     case instruction_code_mem2reg:   // 0x8b movl r, a (can be movq in 64bit)
378       break;
379 
380     case instruction_code_mem2reg_movslq: // 0x63 movsql r, a
381     case instruction_code_mem2reg_movzxb: // 0xb6 movzbl r, a (movzxb)
382     case instruction_code_mem2reg_movzxw: // 0xb7 movzwl r, a (movzxw)
383     case instruction_code_mem2reg_movsxb: // 0xbe movsbl r, a (movsxb)
384     case instruction_code_mem2reg_movsxw: // 0xbf  movswl r, a (movsxw)
385       break;
386 
387     case instruction_code_float_s:   // 0xd9 fld_s a
</pre>
</td>
</tr>
</table>
<center><a href="methodHandles_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
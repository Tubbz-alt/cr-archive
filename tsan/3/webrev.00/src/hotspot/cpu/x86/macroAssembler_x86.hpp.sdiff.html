<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86_aes.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  97   void null_check(Register reg, int offset = -1);
  98   static bool needs_explicit_null_check(intptr_t offset);
  99   static bool uses_implicit_null_check(void* address);
 100 
 101   // Required platform-specific helpers for Label::patch_instructions.
 102   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 103   void pd_patch_instruction(address branch, address target, const char* file, int line) {
 104     unsigned char op = branch[0];
 105     assert(op == 0xE8 /* call */ ||
 106         op == 0xE9 /* jmp */ ||
 107         op == 0xEB /* short jmp */ ||
 108         (op &amp; 0xF0) == 0x70 /* short jcc */ ||
 109         op == 0x0F &amp;&amp; (branch[1] &amp; 0xF0) == 0x80 /* jcc */ ||
 110         op == 0xC7 &amp;&amp; branch[1] == 0xF8 /* xbegin */,
 111         &quot;Invalid opcode at patch point&quot;);
 112 
 113     if (op == 0xEB || (op &amp; 0xF0) == 0x70) {
 114       // short offset operators (jmp and jcc)
 115       char* disp = (char*) &amp;branch[1];
 116       int imm8 = target - (address) &amp;disp[1];
<span class="line-modified"> 117       guarantee(this-&gt;is8bit(imm8), &quot;Short forward jump exceeds 8-bit offset at %s:%d&quot;, file, line);</span>

 118       *disp = imm8;
 119     } else {
 120       int* disp = (int*) &amp;branch[(op == 0x0F || op == 0xC7)? 2: 1];
 121       int imm32 = target - (address) &amp;disp[1];
 122       *disp = imm32;
 123     }
 124   }
 125 
 126   // The following 4 methods return the offset of the appropriate move instruction
 127 
 128   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 129   int load_unsigned_byte(Register dst, Address src);
 130   int load_unsigned_short(Register dst, Address src);
 131 
 132   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 133   int load_signed_byte(Register dst, Address src);
 134   int load_signed_short(Register dst, Address src);
 135 
 136   // Support for sign-extension (hi:lo = extend_sign(lo))
 137   void extend_sign(Register hi, Register lo);
</pre>
<hr />
<pre>
 296   void reset_last_Java_frame(Register thread, bool clear_fp);
 297 
 298   // thread in the default location (r15_thread on 64bit)
 299   void reset_last_Java_frame(bool clear_fp);
 300 
 301   // jobjects
 302   void clear_jweak_tag(Register possibly_jweak);
 303   void resolve_jobject(Register value, Register thread, Register tmp);
 304 
 305   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 306   void c2bool(Register x);
 307 
 308   // C++ bool manipulation
 309 
 310   void movbool(Register dst, Address src);
 311   void movbool(Address dst, bool boolconst);
 312   void movbool(Address dst, Register src);
 313   void testbool(Register dst);
 314 
 315   void resolve_oop_handle(Register result, Register tmp = rscratch2);

 316   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);



 317 
 318   // oop manipulations
 319   void load_klass(Register dst, Register src);
 320   void store_klass(Register dst, Register src);
 321 
 322   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 323                       Register tmp1, Register thread_tmp);
 324   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 325                        Register tmp1, Register tmp2);
 326 
 327   // Resolves obj access. Result is placed in the same register.
 328   // All other registers are preserved.
 329   void resolve(DecoratorSet decorators, Register obj);
 330 
 331   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 332                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 333   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 334                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 335   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 336                       Register tmp2 = noreg, DecoratorSet decorators = 0);
</pre>
<hr />
<pre>
 404 
 405   // Long shifts for Java
 406   // (semantics as described in JVM spec.)
 407   void lshl(Register hi, Register lo);                               // hi:lo &lt;&lt; (rcx &amp; 0x3f)
 408   void lshr(Register hi, Register lo, bool sign_extension = false);  // hi:lo &gt;&gt; (rcx &amp; 0x3f)
 409 
 410   // Long compare for Java
 411   // (semantics as described in JVM spec.)
 412   void lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo); // x_hi = lcmp(x, y)
 413 
 414 
 415   // misc
 416 
 417   // Sign extension
 418   void sign_extend_short(Register reg);
 419   void sign_extend_byte(Register reg);
 420 
 421   // Division by power of 2, rounding towards 0
 422   void division_with_shift(Register reg, int shift_value);
 423 

 424   // Compares the top-most stack entries on the FPU stack and sets the eflags as follows:
 425   //
 426   // CF (corresponds to C0) if x &lt; y
 427   // PF (corresponds to C2) if unordered
 428   // ZF (corresponds to C3) if x = y
 429   //
 430   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 431   // tmp is a temporary register, if none is available use noreg (only matters for non-P6 code)
 432   void fcmp(Register tmp);
 433   // Variant of the above which allows y to be further down the stack
 434   // and which only pops x and y if specified. If pop_right is
 435   // specified then pop_left must also be specified.
 436   void fcmp(Register tmp, int index, bool pop_left, bool pop_right);
 437 
 438   // Floating-point comparison for Java
 439   // Compares the top-most stack entries on the FPU stack and stores the result in dst.
 440   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 441   // (semantics as described in JVM spec.)
 442   void fcmp2int(Register dst, bool unordered_is_less);
 443   // Variant of the above which allows y to be further down the stack
 444   // and which only pops x and y if specified. If pop_right is
 445   // specified then pop_left must also be specified.
 446   void fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right);
 447 
 448   // Floating-point remainder for Java (ST0 = ST0 fremr ST1, ST1 is empty afterwards)
 449   // tmp is a temporary register, if none is available use noreg
 450   void fremr(Register tmp);
 451 




 452   // dst = c = a * b + c
 453   void fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 454   void fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 455 
 456   void vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 457   void vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 458   void vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 459   void vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 460 
 461 
 462   // same as fcmp2int, but using SSE2
 463   void cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 464   void cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 465 
 466   // branch to L if FPU flag C2 is set/not set
 467   // tmp is a temporary register, if none is available use noreg
 468   void jC2 (Register tmp, Label&amp; L);
 469   void jnC2(Register tmp, Label&amp; L);
 470 
<span class="line-removed"> 471   // Pop ST (ffree &amp; fincstp combined)</span>
<span class="line-removed"> 472   void fpop();</span>
<span class="line-removed"> 473 </span>
 474   // Load float value from &#39;address&#39;. If UseSSE &gt;= 1, the value is loaded into
 475   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 476   void load_float(Address src);
 477 
 478   // Store float value to &#39;address&#39;. If UseSSE &gt;= 1, the value is stored
 479   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 480   void store_float(Address dst);
 481 
 482   // Load double value from &#39;address&#39;. If UseSSE &gt;= 2, the value is loaded into
 483   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 484   void load_double(Address src);
 485 
 486   // Store double value to &#39;address&#39;. If UseSSE &gt;= 2, the value is stored
 487   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 488   void store_double(Address dst);
 489 
<span class="line-modified"> 490   // pushes double TOS element of FPU stack on CPU stack; pops from FPU stack</span>
<span class="line-modified"> 491   void push_fTOS();</span>
<span class="line-modified"> 492 </span>
<span class="line-removed"> 493   // pops double TOS element from CPU stack and pushes on FPU stack</span>
<span class="line-removed"> 494   void pop_fTOS();</span>
 495 
 496   void empty_FPU_stack();

 497 
 498   void push_IU_state();
 499   void pop_IU_state();
 500 
 501   void push_FPU_state();
 502   void pop_FPU_state();
 503 
 504   void push_CPU_state();
 505   void pop_CPU_state();
 506 
 507   // Round up to a power of two
 508   void round_to(Register reg, int modulus);
 509 
 510   // Callee saved registers handling
 511   void push_callee_saved_registers();
 512   void pop_callee_saved_registers();
 513 
 514   // allocation
 515   void eden_allocate(
 516     Register thread,                   // Current thread
</pre>
<hr />
<pre>
 562   // The rest of the type check; must be wired to a corresponding fast path.
 563   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 564   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 565   // Updates the sub&#39;s secondary super cache as necessary.
 566   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 567   void check_klass_subtype_slow_path(Register sub_klass,
 568                                      Register super_klass,
 569                                      Register temp_reg,
 570                                      Register temp2_reg,
 571                                      Label* L_success,
 572                                      Label* L_failure,
 573                                      bool set_cond_codes = false);
 574 
 575   // Simplified, combined version, good for typical uses.
 576   // Falls through on failure.
 577   void check_klass_subtype(Register sub_klass,
 578                            Register super_klass,
 579                            Register temp_reg,
 580                            Label&amp; L_success);
 581 





 582   // method handles (JSR 292)
 583   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 584 
 585   //----
 586   void set_word_if_not_zero(Register reg); // sets reg to 1 if not zero, otherwise 0
 587 
 588   // Debugging
 589 
 590   // only if +VerifyOops
 591   // TODO: Make these macros with file and line like sparc version!
 592   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
 593   void verify_oop_addr(Address addr, const char * s = &quot;broken oop addr&quot;);
 594 
 595   // TODO: verify method and klass metadata (compare against vptr?)
 596   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 597   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 598 
 599 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 600 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 601 
<span class="line-removed"> 602   // only if +VerifyFPU</span>
<span class="line-removed"> 603   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);</span>
<span class="line-removed"> 604 </span>
 605   // Verify or restore cpu control state after JNI call
 606   void restore_cpu_control_state_after_jni();
 607 
 608   // prints msg, dumps registers and stops execution
 609   void stop(const char* msg);
 610 
 611   // prints msg and continues
 612   void warn(const char* msg);
 613 
 614   // dumps registers and other state
 615   void print_state();
 616 
 617   static void debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg);
 618   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 619   static void print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip);
 620   static void print_state64(int64_t pc, int64_t regs[]);
 621 
 622   void os_breakpoint();
 623 
 624   void untested()                                { stop(&quot;untested&quot;); }
</pre>
<hr />
<pre>
 860 
 861   // Emit the CompiledIC call idiom
 862   void ic_call(address entry, jint method_index = 0);
 863 
 864   // Jumps
 865 
 866   // NOTE: these jumps tranfer to the effective address of dst NOT
 867   // the address contained by dst. This is because this is more natural
 868   // for jumps/calls.
 869   void jump(AddressLiteral dst);
 870   void jump_cc(Condition cc, AddressLiteral dst);
 871 
 872   // 32bit can do a case table jump in one instruction but we no longer allow the base
 873   // to be installed in the Address class. This jump will tranfers to the address
 874   // contained in the location described by entry (not the address of entry)
 875   void jump(ArrayAddress entry);
 876 
 877   // Floating
 878 
 879   void andpd(XMMRegister dst, Address src) { Assembler::andpd(dst, src); }
<span class="line-modified"> 880   void andpd(XMMRegister dst, AddressLiteral src);</span>
 881   void andpd(XMMRegister dst, XMMRegister src) { Assembler::andpd(dst, src); }
 882 
 883   void andps(XMMRegister dst, XMMRegister src) { Assembler::andps(dst, src); }
 884   void andps(XMMRegister dst, Address src) { Assembler::andps(dst, src); }
<span class="line-modified"> 885   void andps(XMMRegister dst, AddressLiteral src);</span>
 886 
 887   void comiss(XMMRegister dst, XMMRegister src) { Assembler::comiss(dst, src); }
 888   void comiss(XMMRegister dst, Address src) { Assembler::comiss(dst, src); }
 889   void comiss(XMMRegister dst, AddressLiteral src);
 890 
 891   void comisd(XMMRegister dst, XMMRegister src) { Assembler::comisd(dst, src); }
 892   void comisd(XMMRegister dst, Address src) { Assembler::comisd(dst, src); }
 893   void comisd(XMMRegister dst, AddressLiteral src);
 894 

 895   void fadd_s(Address src)        { Assembler::fadd_s(src); }
 896   void fadd_s(AddressLiteral src) { Assembler::fadd_s(as_Address(src)); }
 897 
 898   void fldcw(Address src) { Assembler::fldcw(src); }
 899   void fldcw(AddressLiteral src);
 900 
 901   void fld_s(int index)   { Assembler::fld_s(index); }
 902   void fld_s(Address src) { Assembler::fld_s(src); }
 903   void fld_s(AddressLiteral src);
 904 
 905   void fld_d(Address src) { Assembler::fld_d(src); }
 906   void fld_d(AddressLiteral src);
 907 
 908   void fld_x(Address src) { Assembler::fld_x(src); }
 909   void fld_x(AddressLiteral src);
 910 
 911   void fmul_s(Address src)        { Assembler::fmul_s(src); }
 912   void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }

 913 
 914   void ldmxcsr(Address src) { Assembler::ldmxcsr(src); }
 915   void ldmxcsr(AddressLiteral src);
 916 
 917 #ifdef _LP64
 918  private:
 919   void sha256_AVX2_one_round_compute(
 920     Register  reg_old_h,
 921     Register  reg_a,
 922     Register  reg_b,
 923     Register  reg_c,
 924     Register  reg_d,
 925     Register  reg_e,
 926     Register  reg_f,
 927     Register  reg_g,
 928     Register  reg_h,
 929     int iter);
 930   void sha256_AVX2_four_rounds_compute_first(int start);
 931   void sha256_AVX2_four_rounds_compute_last(int start);
 932   void sha256_AVX2_one_round_and_sched(
</pre>
<hr />
<pre>
 956                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 957                    bool multi_block, XMMRegister shuf_mask);
 958   void avx_ghash(Register state, Register htbl, Register data, Register blocks);
 959 #endif
 960 
 961 #ifdef _LP64
 962  private:
 963   void sha512_AVX2_one_round_compute(Register old_h, Register a, Register b, Register c, Register d,
 964                                      Register e, Register f, Register g, Register h, int iteration);
 965 
 966   void sha512_AVX2_one_round_and_schedule(XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
 967                                           Register a, Register b, Register c, Register d, Register e, Register f,
 968                                           Register g, Register h, int iteration);
 969 
 970   void addmq(int disp, Register r1, Register r2);
 971  public:
 972   void sha512_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 973                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 974                    Register buf, Register state, Register ofs, Register limit, Register rsp, bool multi_block,
 975                    XMMRegister shuf_mask);













 976 #endif
 977 
 978   void fast_sha1(XMMRegister abcd, XMMRegister e0, XMMRegister e1, XMMRegister msg0,
 979                  XMMRegister msg1, XMMRegister msg2, XMMRegister msg3, XMMRegister shuf_mask,
 980                  Register buf, Register state, Register ofs, Register limit, Register rsp,
 981                  bool multi_block);
 982 
 983 #ifdef _LP64
 984   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 985                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 986                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 987                    bool multi_block, XMMRegister shuf_mask);
 988 #else
 989   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 990                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 991                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 992                    bool multi_block);
 993 #endif
 994 
 995   void fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
</pre>
<hr />
<pre>
1042   void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1043                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1044                 Register rax, Register rcx, Register rdx, Register tmp);
1045 
1046   void libm_sincos_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1047                         Register edx, Register ebx, Register esi, Register edi,
1048                         Register ebp, Register esp);
1049 
1050   void libm_reduce_pi04l(Register eax, Register ecx, Register edx, Register ebx,
1051                          Register esi, Register edi, Register ebp, Register esp);
1052 
1053   void libm_tancot_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1054                         Register edx, Register ebx, Register esi, Register edi,
1055                         Register ebp, Register esp);
1056 
1057   void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1058                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1059                 Register rax, Register rcx, Register rdx, Register tmp);
1060 #endif
1061 
<span class="line-removed">1062   void increase_precision();</span>
<span class="line-removed">1063   void restore_precision();</span>
<span class="line-removed">1064 </span>
1065 private:
1066 
1067   // these are private because users should be doing movflt/movdbl
1068 
<span class="line-removed">1069   void movss(Address dst, XMMRegister src)     { Assembler::movss(dst, src); }</span>
1070   void movss(XMMRegister dst, XMMRegister src) { Assembler::movss(dst, src); }

1071   void movss(XMMRegister dst, Address src)     { Assembler::movss(dst, src); }
1072   void movss(XMMRegister dst, AddressLiteral src);
1073 
1074   void movlpd(XMMRegister dst, Address src)    {Assembler::movlpd(dst, src); }
1075   void movlpd(XMMRegister dst, AddressLiteral src);
1076 
1077 public:
1078 
1079   void addsd(XMMRegister dst, XMMRegister src)    { Assembler::addsd(dst, src); }
1080   void addsd(XMMRegister dst, Address src)        { Assembler::addsd(dst, src); }
1081   void addsd(XMMRegister dst, AddressLiteral src);
1082 
1083   void addss(XMMRegister dst, XMMRegister src)    { Assembler::addss(dst, src); }
1084   void addss(XMMRegister dst, Address src)        { Assembler::addss(dst, src); }
1085   void addss(XMMRegister dst, AddressLiteral src);
1086 
1087   void addpd(XMMRegister dst, XMMRegister src)    { Assembler::addpd(dst, src); }
1088   void addpd(XMMRegister dst, Address src)        { Assembler::addpd(dst, src); }
1089   void addpd(XMMRegister dst, AddressLiteral src);
1090 
1091   void divsd(XMMRegister dst, XMMRegister src)    { Assembler::divsd(dst, src); }
1092   void divsd(XMMRegister dst, Address src)        { Assembler::divsd(dst, src); }
1093   void divsd(XMMRegister dst, AddressLiteral src);
1094 
1095   void divss(XMMRegister dst, XMMRegister src)    { Assembler::divss(dst, src); }
1096   void divss(XMMRegister dst, Address src)        { Assembler::divss(dst, src); }
1097   void divss(XMMRegister dst, AddressLiteral src);
1098 
1099   // Move Unaligned Double Quadword
1100   void movdqu(Address     dst, XMMRegister src);
1101   void movdqu(XMMRegister dst, Address src);
1102   void movdqu(XMMRegister dst, XMMRegister src);
1103   void movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg = rscratch1);
1104   // AVX Unaligned forms
1105   void vmovdqu(Address     dst, XMMRegister src);
1106   void vmovdqu(XMMRegister dst, Address src);
1107   void vmovdqu(XMMRegister dst, XMMRegister src);
<span class="line-modified">1108   void vmovdqu(XMMRegister dst, AddressLiteral src);</span>
1109   void evmovdquq(XMMRegister dst, Address src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1110   void evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1111   void evmovdquq(Address dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1112   void evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch);
1113 
1114   // Move Aligned Double Quadword
1115   void movdqa(XMMRegister dst, Address src)       { Assembler::movdqa(dst, src); }
1116   void movdqa(XMMRegister dst, XMMRegister src)   { Assembler::movdqa(dst, src); }
1117   void movdqa(XMMRegister dst, AddressLiteral src);
1118 
1119   void movsd(XMMRegister dst, XMMRegister src) { Assembler::movsd(dst, src); }
1120   void movsd(Address dst, XMMRegister src)     { Assembler::movsd(dst, src); }
1121   void movsd(XMMRegister dst, Address src)     { Assembler::movsd(dst, src); }
1122   void movsd(XMMRegister dst, AddressLiteral src);
1123 
1124   void mulpd(XMMRegister dst, XMMRegister src)    { Assembler::mulpd(dst, src); }
1125   void mulpd(XMMRegister dst, Address src)        { Assembler::mulpd(dst, src); }
1126   void mulpd(XMMRegister dst, AddressLiteral src);
1127 
1128   void mulsd(XMMRegister dst, XMMRegister src)    { Assembler::mulsd(dst, src); }
</pre>
<hr />
<pre>
1143     Assembler::pclmulqdq(dst, src, 0x11);
1144   }
1145 
1146   void pcmpeqb(XMMRegister dst, XMMRegister src);
1147   void pcmpeqw(XMMRegister dst, XMMRegister src);
1148 
1149   void pcmpestri(XMMRegister dst, Address src, int imm8);
1150   void pcmpestri(XMMRegister dst, XMMRegister src, int imm8);
1151 
1152   void pmovzxbw(XMMRegister dst, XMMRegister src);
1153   void pmovzxbw(XMMRegister dst, Address src);
1154 
1155   void pmovmskb(Register dst, XMMRegister src);
1156 
1157   void ptest(XMMRegister dst, XMMRegister src);
1158 
1159   void sqrtsd(XMMRegister dst, XMMRegister src)    { Assembler::sqrtsd(dst, src); }
1160   void sqrtsd(XMMRegister dst, Address src)        { Assembler::sqrtsd(dst, src); }
1161   void sqrtsd(XMMRegister dst, AddressLiteral src);
1162 




1163   void sqrtss(XMMRegister dst, XMMRegister src)    { Assembler::sqrtss(dst, src); }
1164   void sqrtss(XMMRegister dst, Address src)        { Assembler::sqrtss(dst, src); }
1165   void sqrtss(XMMRegister dst, AddressLiteral src);
1166 
1167   void subsd(XMMRegister dst, XMMRegister src)    { Assembler::subsd(dst, src); }
1168   void subsd(XMMRegister dst, Address src)        { Assembler::subsd(dst, src); }
1169   void subsd(XMMRegister dst, AddressLiteral src);
1170 
1171   void subss(XMMRegister dst, XMMRegister src)    { Assembler::subss(dst, src); }
1172   void subss(XMMRegister dst, Address src)        { Assembler::subss(dst, src); }
1173   void subss(XMMRegister dst, AddressLiteral src);
1174 
1175   void ucomiss(XMMRegister dst, XMMRegister src) { Assembler::ucomiss(dst, src); }
1176   void ucomiss(XMMRegister dst, Address src)     { Assembler::ucomiss(dst, src); }
1177   void ucomiss(XMMRegister dst, AddressLiteral src);
1178 
1179   void ucomisd(XMMRegister dst, XMMRegister src) { Assembler::ucomisd(dst, src); }
1180   void ucomisd(XMMRegister dst, Address src)     { Assembler::ucomisd(dst, src); }
1181   void ucomisd(XMMRegister dst, AddressLiteral src);
1182 
1183   // Bitwise Logical XOR of Packed Double-Precision Floating-Point Values
1184   void xorpd(XMMRegister dst, XMMRegister src);
1185   void xorpd(XMMRegister dst, Address src)     { Assembler::xorpd(dst, src); }
<span class="line-modified">1186   void xorpd(XMMRegister dst, AddressLiteral src);</span>
1187 
1188   // Bitwise Logical XOR of Packed Single-Precision Floating-Point Values
1189   void xorps(XMMRegister dst, XMMRegister src);
1190   void xorps(XMMRegister dst, Address src)     { Assembler::xorps(dst, src); }
<span class="line-modified">1191   void xorps(XMMRegister dst, AddressLiteral src);</span>
1192 
1193   // Shuffle Bytes
1194   void pshufb(XMMRegister dst, XMMRegister src) { Assembler::pshufb(dst, src); }
1195   void pshufb(XMMRegister dst, Address src)     { Assembler::pshufb(dst, src); }
1196   void pshufb(XMMRegister dst, AddressLiteral src);
1197   // AVX 3-operands instructions
1198 
1199   void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddsd(dst, nds, src); }
1200   void vaddsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddsd(dst, nds, src); }
1201   void vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1202 
1203   void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddss(dst, nds, src); }
1204   void vaddss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddss(dst, nds, src); }
1205   void vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1206 
1207   void vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1208   void vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1209 
1210   void vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1211   void vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1212 
1213   void vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1214   void vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1215 




1216   void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
1217   void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
<span class="line-modified">1218   void vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);</span>
1219 
1220   void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
1221   void vpbroadcastw(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastw(dst, src, vector_len); }
1222 
1223   void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1224 
1225   void vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1226 
1227   void vpmovzxbw(XMMRegister dst, Address src, int vector_len);
1228   void vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::vpmovzxbw(dst, src, vector_len); }
1229 
1230   void vpmovmskb(Register dst, XMMRegister src);
1231 
1232   void vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1233   void vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1234 
1235   void vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1236   void vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1237 
1238   void vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1239   void vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1240 
1241   void vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1242   void vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1243 



1244   void vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1245   void vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1246 
1247   void vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1248   void vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1249 
1250   void vptest(XMMRegister dst, XMMRegister src);
1251 
1252   void punpcklbw(XMMRegister dst, XMMRegister src);
1253   void punpcklbw(XMMRegister dst, Address src) { Assembler::punpcklbw(dst, src); }
1254 
1255   void pshufd(XMMRegister dst, Address src, int mode);
1256   void pshufd(XMMRegister dst, XMMRegister src, int mode) { Assembler::pshufd(dst, src, mode); }
1257 
1258   void pshuflw(XMMRegister dst, XMMRegister src, int mode);
1259   void pshuflw(XMMRegister dst, Address src, int mode) { Assembler::pshuflw(dst, src, mode); }
1260 
1261   void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandpd(dst, nds, src, vector_len); }
1262   void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandpd(dst, nds, src, vector_len); }
<span class="line-modified">1263   void vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);</span>
1264 
1265   void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandps(dst, nds, src, vector_len); }
1266   void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandps(dst, nds, src, vector_len); }
<span class="line-modified">1267   void vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);</span>
1268 
1269   void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivsd(dst, nds, src); }
1270   void vdivsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivsd(dst, nds, src); }
1271   void vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1272 
1273   void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivss(dst, nds, src); }
1274   void vdivss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivss(dst, nds, src); }
1275   void vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1276 
1277   void vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulsd(dst, nds, src); }
1278   void vmulsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulsd(dst, nds, src); }
1279   void vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1280 
1281   void vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulss(dst, nds, src); }
1282   void vmulss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulss(dst, nds, src); }
1283   void vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1284 
1285   void vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubsd(dst, nds, src); }
1286   void vsubsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubsd(dst, nds, src); }
1287   void vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1288 
1289   void vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubss(dst, nds, src); }
1290   void vsubss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubss(dst, nds, src); }
1291   void vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1292 
1293   void vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1294   void vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1295 
1296   // AVX Vector instructions
1297 
1298   void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
1299   void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
<span class="line-modified">1300   void vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);</span>
1301 
1302   void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
1303   void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
<span class="line-modified">1304   void vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);</span>
1305 
1306   void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1307     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1308       Assembler::vpxor(dst, nds, src, vector_len);
1309     else
1310       Assembler::vxorpd(dst, nds, src, vector_len);
1311   }
1312   void vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
1313     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1314       Assembler::vpxor(dst, nds, src, vector_len);
1315     else
1316       Assembler::vxorpd(dst, nds, src, vector_len);
1317   }

1318 
1319   // Simple version for AVX2 256bit vectors
1320   void vpxor(XMMRegister dst, XMMRegister src) { Assembler::vpxor(dst, dst, src, true); }
1321   void vpxor(XMMRegister dst, Address src) { Assembler::vpxor(dst, dst, src, true); }
1322 
1323   void vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
<span class="line-modified">1324     if (UseAVX &gt; 2) {</span>
1325       Assembler::vinserti32x4(dst, dst, src, imm8);
1326     } else if (UseAVX &gt; 1) {
1327       // vinserti128 is available only in AVX2
1328       Assembler::vinserti128(dst, nds, src, imm8);
1329     } else {
1330       Assembler::vinsertf128(dst, nds, src, imm8);
1331     }
1332   }
1333 
1334   void vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
<span class="line-modified">1335     if (UseAVX &gt; 2) {</span>
1336       Assembler::vinserti32x4(dst, dst, src, imm8);
1337     } else if (UseAVX &gt; 1) {
1338       // vinserti128 is available only in AVX2
1339       Assembler::vinserti128(dst, nds, src, imm8);
1340     } else {
1341       Assembler::vinsertf128(dst, nds, src, imm8);
1342     }
1343   }
1344 
1345   void vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
<span class="line-modified">1346     if (UseAVX &gt; 2) {</span>
1347       Assembler::vextracti32x4(dst, src, imm8);
1348     } else if (UseAVX &gt; 1) {
1349       // vextracti128 is available only in AVX2
1350       Assembler::vextracti128(dst, src, imm8);
1351     } else {
1352       Assembler::vextractf128(dst, src, imm8);
1353     }
1354   }
1355 
1356   void vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
<span class="line-modified">1357     if (UseAVX &gt; 2) {</span>
1358       Assembler::vextracti32x4(dst, src, imm8);
1359     } else if (UseAVX &gt; 1) {
1360       // vextracti128 is available only in AVX2
1361       Assembler::vextracti128(dst, src, imm8);
1362     } else {
1363       Assembler::vextractf128(dst, src, imm8);
1364     }
1365   }
1366 
1367   // 128bit copy to/from high 128 bits of 256bit (YMM) vector registers
1368   void vinserti128_high(XMMRegister dst, XMMRegister src) {
1369     vinserti128(dst, dst, src, 1);
1370   }
1371   void vinserti128_high(XMMRegister dst, Address src) {
1372     vinserti128(dst, dst, src, 1);
1373   }
1374   void vextracti128_high(XMMRegister dst, XMMRegister src) {
1375     vextracti128(dst, src, 1);
1376   }
1377   void vextracti128_high(Address dst, XMMRegister src) {
1378     vextracti128(dst, src, 1);
1379   }
1380 
1381   void vinsertf128_high(XMMRegister dst, XMMRegister src) {
<span class="line-modified">1382     if (UseAVX &gt; 2) {</span>
1383       Assembler::vinsertf32x4(dst, dst, src, 1);
1384     } else {
1385       Assembler::vinsertf128(dst, dst, src, 1);
1386     }
1387   }
1388 
1389   void vinsertf128_high(XMMRegister dst, Address src) {
<span class="line-modified">1390     if (UseAVX &gt; 2) {</span>
1391       Assembler::vinsertf32x4(dst, dst, src, 1);
1392     } else {
1393       Assembler::vinsertf128(dst, dst, src, 1);
1394     }
1395   }
1396 
1397   void vextractf128_high(XMMRegister dst, XMMRegister src) {
<span class="line-modified">1398     if (UseAVX &gt; 2) {</span>
1399       Assembler::vextractf32x4(dst, src, 1);
1400     } else {
1401       Assembler::vextractf128(dst, src, 1);
1402     }
1403   }
1404 
1405   void vextractf128_high(Address dst, XMMRegister src) {
<span class="line-modified">1406     if (UseAVX &gt; 2) {</span>
1407       Assembler::vextractf32x4(dst, src, 1);
1408     } else {
1409       Assembler::vextractf128(dst, src, 1);
1410     }
1411   }
1412 
1413   // 256bit copy to/from high 256 bits of 512bit (ZMM) vector registers
1414   void vinserti64x4_high(XMMRegister dst, XMMRegister src) {
1415     Assembler::vinserti64x4(dst, dst, src, 1);
1416   }
1417   void vinsertf64x4_high(XMMRegister dst, XMMRegister src) {
1418     Assembler::vinsertf64x4(dst, dst, src, 1);
1419   }
1420   void vextracti64x4_high(XMMRegister dst, XMMRegister src) {
1421     Assembler::vextracti64x4(dst, src, 1);
1422   }
1423   void vextractf64x4_high(XMMRegister dst, XMMRegister src) {
1424     Assembler::vextractf64x4(dst, src, 1);
1425   }
1426   void vextractf64x4_high(Address dst, XMMRegister src) {
</pre>
<hr />
<pre>
1428   }
1429   void vinsertf64x4_high(XMMRegister dst, Address src) {
1430     Assembler::vinsertf64x4(dst, dst, src, 1);
1431   }
1432 
1433   // 128bit copy to/from low 128 bits of 256bit (YMM) vector registers
1434   void vinserti128_low(XMMRegister dst, XMMRegister src) {
1435     vinserti128(dst, dst, src, 0);
1436   }
1437   void vinserti128_low(XMMRegister dst, Address src) {
1438     vinserti128(dst, dst, src, 0);
1439   }
1440   void vextracti128_low(XMMRegister dst, XMMRegister src) {
1441     vextracti128(dst, src, 0);
1442   }
1443   void vextracti128_low(Address dst, XMMRegister src) {
1444     vextracti128(dst, src, 0);
1445   }
1446 
1447   void vinsertf128_low(XMMRegister dst, XMMRegister src) {
<span class="line-modified">1448     if (UseAVX &gt; 2) {</span>
1449       Assembler::vinsertf32x4(dst, dst, src, 0);
1450     } else {
1451       Assembler::vinsertf128(dst, dst, src, 0);
1452     }
1453   }
1454 
1455   void vinsertf128_low(XMMRegister dst, Address src) {
<span class="line-modified">1456     if (UseAVX &gt; 2) {</span>
1457       Assembler::vinsertf32x4(dst, dst, src, 0);
1458     } else {
1459       Assembler::vinsertf128(dst, dst, src, 0);
1460     }
1461   }
1462 
1463   void vextractf128_low(XMMRegister dst, XMMRegister src) {
<span class="line-modified">1464     if (UseAVX &gt; 2) {</span>
1465       Assembler::vextractf32x4(dst, src, 0);
1466     } else {
1467       Assembler::vextractf128(dst, src, 0);
1468     }
1469   }
1470 
1471   void vextractf128_low(Address dst, XMMRegister src) {
<span class="line-modified">1472     if (UseAVX &gt; 2) {</span>
1473       Assembler::vextractf32x4(dst, src, 0);
1474     } else {
1475       Assembler::vextractf128(dst, src, 0);
1476     }
1477   }
1478 
1479   // 256bit copy to/from low 256 bits of 512bit (ZMM) vector registers
1480   void vinserti64x4_low(XMMRegister dst, XMMRegister src) {
1481     Assembler::vinserti64x4(dst, dst, src, 0);
1482   }
1483   void vinsertf64x4_low(XMMRegister dst, XMMRegister src) {
1484     Assembler::vinsertf64x4(dst, dst, src, 0);
1485   }
1486   void vextracti64x4_low(XMMRegister dst, XMMRegister src) {
1487     Assembler::vextracti64x4(dst, src, 0);
1488   }
1489   void vextractf64x4_low(XMMRegister dst, XMMRegister src) {
1490     Assembler::vextractf64x4(dst, src, 0);
1491   }
1492   void vextractf64x4_low(Address dst, XMMRegister src) {
</pre>
<hr />
<pre>
1584   // Import other mov() methods from the parent class or else
1585   // they will be hidden by the following overriding declaration.
1586   using Assembler::movdl;
1587   using Assembler::movq;
1588   void movdl(XMMRegister dst, AddressLiteral src);
1589   void movq(XMMRegister dst, AddressLiteral src);
1590 
1591   // Can push value or effective address
1592   void pushptr(AddressLiteral src);
1593 
1594   void pushptr(Address src) { LP64_ONLY(pushq(src)) NOT_LP64(pushl(src)); }
1595   void popptr(Address src) { LP64_ONLY(popq(src)) NOT_LP64(popl(src)); }
1596 
1597   void pushoop(jobject obj);
1598   void pushklass(Metadata* obj);
1599 
1600   // sign extend as need a l to ptr sized element
1601   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1602   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1603 
















1604   // C2 compiled method&#39;s prolog code.
1605   void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub);
1606 
1607   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39;;
1608   // if &#39;is_large&#39; is set, do not try to produce short loop
1609   void clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp, bool is_large);
1610 
1611   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
1612   void xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp);
1613 
1614 #ifdef COMPILER2
1615   void string_indexof_char(Register str1, Register cnt1, Register ch, Register result,
1616                            XMMRegister vec1, XMMRegister vec2, XMMRegister vec3, Register tmp);
1617 
1618   // IndexOf strings.
1619   // Small strings are loaded through stack if they cross page boundary.
1620   void string_indexof(Register str1, Register str2,
1621                       Register cnt1, Register cnt2,
1622                       int int_cnt2,  Register result,
1623                       XMMRegister vec, Register tmp,
</pre>
<hr />
<pre>
1744                             Register tmp4, Register tmp5, Register tmp6,
1745                             XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1746                             bool is_pclmulqdq_supported);
1747   // Fold 128-bit data chunk
1748   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1749   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf);
1750   // Fold 8-bit data
1751   void fold_8bit_crc32(Register crc, Register table, Register tmp);
1752   void fold_8bit_crc32(XMMRegister crc, Register table, XMMRegister xtmp, Register tmp);
1753   void fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1754 
1755   // Compress char[] array to byte[].
1756   void char_array_compress(Register src, Register dst, Register len,
1757                            XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1758                            XMMRegister tmp4, Register tmp5, Register result);
1759 
1760   // Inflate byte[] array to char[].
1761   void byte_array_inflate(Register src, Register dst, Register len,
1762                           XMMRegister tmp1, Register tmp2);
1763 









1764 };
1765 
1766 /**
1767  * class SkipIfEqual:
1768  *
1769  * Instantiating this class will result in assembly code being output that will
1770  * jump around any code emitted between the creation of the instance and it&#39;s
1771  * automatic destruction at the end of a scope block, depending on the value of
1772  * the flag passed to the constructor, which will be checked at run-time.
1773  */
1774 class SkipIfEqual {
1775  private:
1776   MacroAssembler* _masm;
1777   Label _label;
1778 
1779  public:
1780    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1781    ~SkipIfEqual();
1782 };
1783 
</pre>
</td>
<td>
<hr />
<pre>
  97   void null_check(Register reg, int offset = -1);
  98   static bool needs_explicit_null_check(intptr_t offset);
  99   static bool uses_implicit_null_check(void* address);
 100 
 101   // Required platform-specific helpers for Label::patch_instructions.
 102   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 103   void pd_patch_instruction(address branch, address target, const char* file, int line) {
 104     unsigned char op = branch[0];
 105     assert(op == 0xE8 /* call */ ||
 106         op == 0xE9 /* jmp */ ||
 107         op == 0xEB /* short jmp */ ||
 108         (op &amp; 0xF0) == 0x70 /* short jcc */ ||
 109         op == 0x0F &amp;&amp; (branch[1] &amp; 0xF0) == 0x80 /* jcc */ ||
 110         op == 0xC7 &amp;&amp; branch[1] == 0xF8 /* xbegin */,
 111         &quot;Invalid opcode at patch point&quot;);
 112 
 113     if (op == 0xEB || (op &amp; 0xF0) == 0x70) {
 114       // short offset operators (jmp and jcc)
 115       char* disp = (char*) &amp;branch[1];
 116       int imm8 = target - (address) &amp;disp[1];
<span class="line-modified"> 117       guarantee(this-&gt;is8bit(imm8), &quot;Short forward jump exceeds 8-bit offset at %s:%d&quot;,</span>
<span class="line-added"> 118                 file == NULL ? &quot;&lt;NULL&gt;&quot; : file, line);</span>
 119       *disp = imm8;
 120     } else {
 121       int* disp = (int*) &amp;branch[(op == 0x0F || op == 0xC7)? 2: 1];
 122       int imm32 = target - (address) &amp;disp[1];
 123       *disp = imm32;
 124     }
 125   }
 126 
 127   // The following 4 methods return the offset of the appropriate move instruction
 128 
 129   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 130   int load_unsigned_byte(Register dst, Address src);
 131   int load_unsigned_short(Register dst, Address src);
 132 
 133   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 134   int load_signed_byte(Register dst, Address src);
 135   int load_signed_short(Register dst, Address src);
 136 
 137   // Support for sign-extension (hi:lo = extend_sign(lo))
 138   void extend_sign(Register hi, Register lo);
</pre>
<hr />
<pre>
 297   void reset_last_Java_frame(Register thread, bool clear_fp);
 298 
 299   // thread in the default location (r15_thread on 64bit)
 300   void reset_last_Java_frame(bool clear_fp);
 301 
 302   // jobjects
 303   void clear_jweak_tag(Register possibly_jweak);
 304   void resolve_jobject(Register value, Register thread, Register tmp);
 305 
 306   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 307   void c2bool(Register x);
 308 
 309   // C++ bool manipulation
 310 
 311   void movbool(Register dst, Address src);
 312   void movbool(Address dst, bool boolconst);
 313   void movbool(Address dst, Register src);
 314   void testbool(Register dst);
 315 
 316   void resolve_oop_handle(Register result, Register tmp = rscratch2);
<span class="line-added"> 317   void resolve_weak_handle(Register result, Register tmp);</span>
 318   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
<span class="line-added"> 319   void load_method_holder_cld(Register rresult, Register rmethod);</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321   void load_method_holder(Register holder, Register method);</span>
 322 
 323   // oop manipulations
 324   void load_klass(Register dst, Register src);
 325   void store_klass(Register dst, Register src);
 326 
 327   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 328                       Register tmp1, Register thread_tmp);
 329   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 330                        Register tmp1, Register tmp2);
 331 
 332   // Resolves obj access. Result is placed in the same register.
 333   // All other registers are preserved.
 334   void resolve(DecoratorSet decorators, Register obj);
 335 
 336   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 337                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 338   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 339                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 340   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 341                       Register tmp2 = noreg, DecoratorSet decorators = 0);
</pre>
<hr />
<pre>
 409 
 410   // Long shifts for Java
 411   // (semantics as described in JVM spec.)
 412   void lshl(Register hi, Register lo);                               // hi:lo &lt;&lt; (rcx &amp; 0x3f)
 413   void lshr(Register hi, Register lo, bool sign_extension = false);  // hi:lo &gt;&gt; (rcx &amp; 0x3f)
 414 
 415   // Long compare for Java
 416   // (semantics as described in JVM spec.)
 417   void lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo); // x_hi = lcmp(x, y)
 418 
 419 
 420   // misc
 421 
 422   // Sign extension
 423   void sign_extend_short(Register reg);
 424   void sign_extend_byte(Register reg);
 425 
 426   // Division by power of 2, rounding towards 0
 427   void division_with_shift(Register reg, int shift_value);
 428 
<span class="line-added"> 429 #ifndef _LP64</span>
 430   // Compares the top-most stack entries on the FPU stack and sets the eflags as follows:
 431   //
 432   // CF (corresponds to C0) if x &lt; y
 433   // PF (corresponds to C2) if unordered
 434   // ZF (corresponds to C3) if x = y
 435   //
 436   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 437   // tmp is a temporary register, if none is available use noreg (only matters for non-P6 code)
 438   void fcmp(Register tmp);
 439   // Variant of the above which allows y to be further down the stack
 440   // and which only pops x and y if specified. If pop_right is
 441   // specified then pop_left must also be specified.
 442   void fcmp(Register tmp, int index, bool pop_left, bool pop_right);
 443 
 444   // Floating-point comparison for Java
 445   // Compares the top-most stack entries on the FPU stack and stores the result in dst.
 446   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 447   // (semantics as described in JVM spec.)
 448   void fcmp2int(Register dst, bool unordered_is_less);
 449   // Variant of the above which allows y to be further down the stack
 450   // and which only pops x and y if specified. If pop_right is
 451   // specified then pop_left must also be specified.
 452   void fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right);
 453 
 454   // Floating-point remainder for Java (ST0 = ST0 fremr ST1, ST1 is empty afterwards)
 455   // tmp is a temporary register, if none is available use noreg
 456   void fremr(Register tmp);
 457 
<span class="line-added"> 458   // only if +VerifyFPU</span>
<span class="line-added"> 459   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);</span>
<span class="line-added"> 460 #endif // !LP64</span>
<span class="line-added"> 461 </span>
 462   // dst = c = a * b + c
 463   void fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 464   void fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 465 
 466   void vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 467   void vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 468   void vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 469   void vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 470 
 471 
 472   // same as fcmp2int, but using SSE2
 473   void cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 474   void cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 475 
 476   // branch to L if FPU flag C2 is set/not set
 477   // tmp is a temporary register, if none is available use noreg
 478   void jC2 (Register tmp, Label&amp; L);
 479   void jnC2(Register tmp, Label&amp; L);
 480 



 481   // Load float value from &#39;address&#39;. If UseSSE &gt;= 1, the value is loaded into
 482   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 483   void load_float(Address src);
 484 
 485   // Store float value to &#39;address&#39;. If UseSSE &gt;= 1, the value is stored
 486   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 487   void store_float(Address dst);
 488 
 489   // Load double value from &#39;address&#39;. If UseSSE &gt;= 2, the value is loaded into
 490   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 491   void load_double(Address src);
 492 
 493   // Store double value to &#39;address&#39;. If UseSSE &gt;= 2, the value is stored
 494   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 495   void store_double(Address dst);
 496 
<span class="line-modified"> 497 #ifndef _LP64</span>
<span class="line-modified"> 498   // Pop ST (ffree &amp; fincstp combined)</span>
<span class="line-modified"> 499   void fpop();</span>


 500 
 501   void empty_FPU_stack();
<span class="line-added"> 502 #endif // !_LP64</span>
 503 
 504   void push_IU_state();
 505   void pop_IU_state();
 506 
 507   void push_FPU_state();
 508   void pop_FPU_state();
 509 
 510   void push_CPU_state();
 511   void pop_CPU_state();
 512 
 513   // Round up to a power of two
 514   void round_to(Register reg, int modulus);
 515 
 516   // Callee saved registers handling
 517   void push_callee_saved_registers();
 518   void pop_callee_saved_registers();
 519 
 520   // allocation
 521   void eden_allocate(
 522     Register thread,                   // Current thread
</pre>
<hr />
<pre>
 568   // The rest of the type check; must be wired to a corresponding fast path.
 569   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 570   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 571   // Updates the sub&#39;s secondary super cache as necessary.
 572   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 573   void check_klass_subtype_slow_path(Register sub_klass,
 574                                      Register super_klass,
 575                                      Register temp_reg,
 576                                      Register temp2_reg,
 577                                      Label* L_success,
 578                                      Label* L_failure,
 579                                      bool set_cond_codes = false);
 580 
 581   // Simplified, combined version, good for typical uses.
 582   // Falls through on failure.
 583   void check_klass_subtype(Register sub_klass,
 584                            Register super_klass,
 585                            Register temp_reg,
 586                            Label&amp; L_success);
 587 
<span class="line-added"> 588   void clinit_barrier(Register klass,</span>
<span class="line-added"> 589                       Register thread,</span>
<span class="line-added"> 590                       Label* L_fast_path = NULL,</span>
<span class="line-added"> 591                       Label* L_slow_path = NULL);</span>
<span class="line-added"> 592 </span>
 593   // method handles (JSR 292)
 594   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 595 
 596   //----
 597   void set_word_if_not_zero(Register reg); // sets reg to 1 if not zero, otherwise 0
 598 
 599   // Debugging
 600 
 601   // only if +VerifyOops
 602   // TODO: Make these macros with file and line like sparc version!
 603   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
 604   void verify_oop_addr(Address addr, const char * s = &quot;broken oop addr&quot;);
 605 
 606   // TODO: verify method and klass metadata (compare against vptr?)
 607   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 608   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 609 
 610 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 611 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 612 



 613   // Verify or restore cpu control state after JNI call
 614   void restore_cpu_control_state_after_jni();
 615 
 616   // prints msg, dumps registers and stops execution
 617   void stop(const char* msg);
 618 
 619   // prints msg and continues
 620   void warn(const char* msg);
 621 
 622   // dumps registers and other state
 623   void print_state();
 624 
 625   static void debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg);
 626   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 627   static void print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip);
 628   static void print_state64(int64_t pc, int64_t regs[]);
 629 
 630   void os_breakpoint();
 631 
 632   void untested()                                { stop(&quot;untested&quot;); }
</pre>
<hr />
<pre>
 868 
 869   // Emit the CompiledIC call idiom
 870   void ic_call(address entry, jint method_index = 0);
 871 
 872   // Jumps
 873 
 874   // NOTE: these jumps tranfer to the effective address of dst NOT
 875   // the address contained by dst. This is because this is more natural
 876   // for jumps/calls.
 877   void jump(AddressLiteral dst);
 878   void jump_cc(Condition cc, AddressLiteral dst);
 879 
 880   // 32bit can do a case table jump in one instruction but we no longer allow the base
 881   // to be installed in the Address class. This jump will tranfers to the address
 882   // contained in the location described by entry (not the address of entry)
 883   void jump(ArrayAddress entry);
 884 
 885   // Floating
 886 
 887   void andpd(XMMRegister dst, Address src) { Assembler::andpd(dst, src); }
<span class="line-modified"> 888   void andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);</span>
 889   void andpd(XMMRegister dst, XMMRegister src) { Assembler::andpd(dst, src); }
 890 
 891   void andps(XMMRegister dst, XMMRegister src) { Assembler::andps(dst, src); }
 892   void andps(XMMRegister dst, Address src) { Assembler::andps(dst, src); }
<span class="line-modified"> 893   void andps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);</span>
 894 
 895   void comiss(XMMRegister dst, XMMRegister src) { Assembler::comiss(dst, src); }
 896   void comiss(XMMRegister dst, Address src) { Assembler::comiss(dst, src); }
 897   void comiss(XMMRegister dst, AddressLiteral src);
 898 
 899   void comisd(XMMRegister dst, XMMRegister src) { Assembler::comisd(dst, src); }
 900   void comisd(XMMRegister dst, Address src) { Assembler::comisd(dst, src); }
 901   void comisd(XMMRegister dst, AddressLiteral src);
 902 
<span class="line-added"> 903 #ifndef _LP64</span>
 904   void fadd_s(Address src)        { Assembler::fadd_s(src); }
 905   void fadd_s(AddressLiteral src) { Assembler::fadd_s(as_Address(src)); }
 906 
 907   void fldcw(Address src) { Assembler::fldcw(src); }
 908   void fldcw(AddressLiteral src);
 909 
 910   void fld_s(int index)   { Assembler::fld_s(index); }
 911   void fld_s(Address src) { Assembler::fld_s(src); }
 912   void fld_s(AddressLiteral src);
 913 
 914   void fld_d(Address src) { Assembler::fld_d(src); }
 915   void fld_d(AddressLiteral src);
 916 
 917   void fld_x(Address src) { Assembler::fld_x(src); }
 918   void fld_x(AddressLiteral src);
 919 
 920   void fmul_s(Address src)        { Assembler::fmul_s(src); }
 921   void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }
<span class="line-added"> 922 #endif // _LP64</span>
 923 
 924   void ldmxcsr(Address src) { Assembler::ldmxcsr(src); }
 925   void ldmxcsr(AddressLiteral src);
 926 
 927 #ifdef _LP64
 928  private:
 929   void sha256_AVX2_one_round_compute(
 930     Register  reg_old_h,
 931     Register  reg_a,
 932     Register  reg_b,
 933     Register  reg_c,
 934     Register  reg_d,
 935     Register  reg_e,
 936     Register  reg_f,
 937     Register  reg_g,
 938     Register  reg_h,
 939     int iter);
 940   void sha256_AVX2_four_rounds_compute_first(int start);
 941   void sha256_AVX2_four_rounds_compute_last(int start);
 942   void sha256_AVX2_one_round_and_sched(
</pre>
<hr />
<pre>
 966                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 967                    bool multi_block, XMMRegister shuf_mask);
 968   void avx_ghash(Register state, Register htbl, Register data, Register blocks);
 969 #endif
 970 
 971 #ifdef _LP64
 972  private:
 973   void sha512_AVX2_one_round_compute(Register old_h, Register a, Register b, Register c, Register d,
 974                                      Register e, Register f, Register g, Register h, int iteration);
 975 
 976   void sha512_AVX2_one_round_and_schedule(XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
 977                                           Register a, Register b, Register c, Register d, Register e, Register f,
 978                                           Register g, Register h, int iteration);
 979 
 980   void addmq(int disp, Register r1, Register r2);
 981  public:
 982   void sha512_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 983                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 984                    Register buf, Register state, Register ofs, Register limit, Register rsp, bool multi_block,
 985                    XMMRegister shuf_mask);
<span class="line-added"> 986 private:</span>
<span class="line-added"> 987   void roundEnc(XMMRegister key, int rnum);</span>
<span class="line-added"> 988   void lastroundEnc(XMMRegister key, int rnum);</span>
<span class="line-added"> 989   void roundDec(XMMRegister key, int rnum);</span>
<span class="line-added"> 990   void lastroundDec(XMMRegister key, int rnum);</span>
<span class="line-added"> 991   void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask);</span>
<span class="line-added"> 992 </span>
<span class="line-added"> 993 public:</span>
<span class="line-added"> 994   void aesecb_encrypt(Register source_addr, Register dest_addr, Register key, Register len);</span>
<span class="line-added"> 995   void aesecb_decrypt(Register source_addr, Register dest_addr, Register key, Register len);</span>
<span class="line-added"> 996   void aesctr_encrypt(Register src_addr, Register dest_addr, Register key, Register counter,</span>
<span class="line-added"> 997                       Register len_reg, Register used, Register used_addr, Register saved_encCounter_start);</span>
<span class="line-added"> 998 </span>
 999 #endif
1000 
1001   void fast_sha1(XMMRegister abcd, XMMRegister e0, XMMRegister e1, XMMRegister msg0,
1002                  XMMRegister msg1, XMMRegister msg2, XMMRegister msg3, XMMRegister shuf_mask,
1003                  Register buf, Register state, Register ofs, Register limit, Register rsp,
1004                  bool multi_block);
1005 
1006 #ifdef _LP64
1007   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
1008                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
1009                    Register buf, Register state, Register ofs, Register limit, Register rsp,
1010                    bool multi_block, XMMRegister shuf_mask);
1011 #else
1012   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
1013                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
1014                    Register buf, Register state, Register ofs, Register limit, Register rsp,
1015                    bool multi_block);
1016 #endif
1017 
1018   void fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
</pre>
<hr />
<pre>
1065   void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1066                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1067                 Register rax, Register rcx, Register rdx, Register tmp);
1068 
1069   void libm_sincos_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1070                         Register edx, Register ebx, Register esi, Register edi,
1071                         Register ebp, Register esp);
1072 
1073   void libm_reduce_pi04l(Register eax, Register ecx, Register edx, Register ebx,
1074                          Register esi, Register edi, Register ebp, Register esp);
1075 
1076   void libm_tancot_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1077                         Register edx, Register ebx, Register esi, Register edi,
1078                         Register ebp, Register esp);
1079 
1080   void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1081                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1082                 Register rax, Register rcx, Register rdx, Register tmp);
1083 #endif
1084 



1085 private:
1086 
1087   // these are private because users should be doing movflt/movdbl
1088 

1089   void movss(XMMRegister dst, XMMRegister src) { Assembler::movss(dst, src); }
<span class="line-added">1090   void movss(Address dst, XMMRegister src)     { Assembler::movss(dst, src); }</span>
1091   void movss(XMMRegister dst, Address src)     { Assembler::movss(dst, src); }
1092   void movss(XMMRegister dst, AddressLiteral src);
1093 
1094   void movlpd(XMMRegister dst, Address src)    {Assembler::movlpd(dst, src); }
1095   void movlpd(XMMRegister dst, AddressLiteral src);
1096 
1097 public:
1098 
1099   void addsd(XMMRegister dst, XMMRegister src)    { Assembler::addsd(dst, src); }
1100   void addsd(XMMRegister dst, Address src)        { Assembler::addsd(dst, src); }
1101   void addsd(XMMRegister dst, AddressLiteral src);
1102 
1103   void addss(XMMRegister dst, XMMRegister src)    { Assembler::addss(dst, src); }
1104   void addss(XMMRegister dst, Address src)        { Assembler::addss(dst, src); }
1105   void addss(XMMRegister dst, AddressLiteral src);
1106 
1107   void addpd(XMMRegister dst, XMMRegister src)    { Assembler::addpd(dst, src); }
1108   void addpd(XMMRegister dst, Address src)        { Assembler::addpd(dst, src); }
1109   void addpd(XMMRegister dst, AddressLiteral src);
1110 
1111   void divsd(XMMRegister dst, XMMRegister src)    { Assembler::divsd(dst, src); }
1112   void divsd(XMMRegister dst, Address src)        { Assembler::divsd(dst, src); }
1113   void divsd(XMMRegister dst, AddressLiteral src);
1114 
1115   void divss(XMMRegister dst, XMMRegister src)    { Assembler::divss(dst, src); }
1116   void divss(XMMRegister dst, Address src)        { Assembler::divss(dst, src); }
1117   void divss(XMMRegister dst, AddressLiteral src);
1118 
1119   // Move Unaligned Double Quadword
1120   void movdqu(Address     dst, XMMRegister src);
1121   void movdqu(XMMRegister dst, Address src);
1122   void movdqu(XMMRegister dst, XMMRegister src);
1123   void movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg = rscratch1);
1124   // AVX Unaligned forms
1125   void vmovdqu(Address     dst, XMMRegister src);
1126   void vmovdqu(XMMRegister dst, Address src);
1127   void vmovdqu(XMMRegister dst, XMMRegister src);
<span class="line-modified">1128   void vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);</span>
1129   void evmovdquq(XMMRegister dst, Address src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1130   void evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1131   void evmovdquq(Address dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1132   void evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch);
1133 
1134   // Move Aligned Double Quadword
1135   void movdqa(XMMRegister dst, Address src)       { Assembler::movdqa(dst, src); }
1136   void movdqa(XMMRegister dst, XMMRegister src)   { Assembler::movdqa(dst, src); }
1137   void movdqa(XMMRegister dst, AddressLiteral src);
1138 
1139   void movsd(XMMRegister dst, XMMRegister src) { Assembler::movsd(dst, src); }
1140   void movsd(Address dst, XMMRegister src)     { Assembler::movsd(dst, src); }
1141   void movsd(XMMRegister dst, Address src)     { Assembler::movsd(dst, src); }
1142   void movsd(XMMRegister dst, AddressLiteral src);
1143 
1144   void mulpd(XMMRegister dst, XMMRegister src)    { Assembler::mulpd(dst, src); }
1145   void mulpd(XMMRegister dst, Address src)        { Assembler::mulpd(dst, src); }
1146   void mulpd(XMMRegister dst, AddressLiteral src);
1147 
1148   void mulsd(XMMRegister dst, XMMRegister src)    { Assembler::mulsd(dst, src); }
</pre>
<hr />
<pre>
1163     Assembler::pclmulqdq(dst, src, 0x11);
1164   }
1165 
1166   void pcmpeqb(XMMRegister dst, XMMRegister src);
1167   void pcmpeqw(XMMRegister dst, XMMRegister src);
1168 
1169   void pcmpestri(XMMRegister dst, Address src, int imm8);
1170   void pcmpestri(XMMRegister dst, XMMRegister src, int imm8);
1171 
1172   void pmovzxbw(XMMRegister dst, XMMRegister src);
1173   void pmovzxbw(XMMRegister dst, Address src);
1174 
1175   void pmovmskb(Register dst, XMMRegister src);
1176 
1177   void ptest(XMMRegister dst, XMMRegister src);
1178 
1179   void sqrtsd(XMMRegister dst, XMMRegister src)    { Assembler::sqrtsd(dst, src); }
1180   void sqrtsd(XMMRegister dst, Address src)        { Assembler::sqrtsd(dst, src); }
1181   void sqrtsd(XMMRegister dst, AddressLiteral src);
1182 
<span class="line-added">1183   void roundsd(XMMRegister dst, XMMRegister src, int32_t rmode)    { Assembler::roundsd(dst, src, rmode); }</span>
<span class="line-added">1184   void roundsd(XMMRegister dst, Address src, int32_t rmode)        { Assembler::roundsd(dst, src, rmode); }</span>
<span class="line-added">1185   void roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg);</span>
<span class="line-added">1186 </span>
1187   void sqrtss(XMMRegister dst, XMMRegister src)    { Assembler::sqrtss(dst, src); }
1188   void sqrtss(XMMRegister dst, Address src)        { Assembler::sqrtss(dst, src); }
1189   void sqrtss(XMMRegister dst, AddressLiteral src);
1190 
1191   void subsd(XMMRegister dst, XMMRegister src)    { Assembler::subsd(dst, src); }
1192   void subsd(XMMRegister dst, Address src)        { Assembler::subsd(dst, src); }
1193   void subsd(XMMRegister dst, AddressLiteral src);
1194 
1195   void subss(XMMRegister dst, XMMRegister src)    { Assembler::subss(dst, src); }
1196   void subss(XMMRegister dst, Address src)        { Assembler::subss(dst, src); }
1197   void subss(XMMRegister dst, AddressLiteral src);
1198 
1199   void ucomiss(XMMRegister dst, XMMRegister src) { Assembler::ucomiss(dst, src); }
1200   void ucomiss(XMMRegister dst, Address src)     { Assembler::ucomiss(dst, src); }
1201   void ucomiss(XMMRegister dst, AddressLiteral src);
1202 
1203   void ucomisd(XMMRegister dst, XMMRegister src) { Assembler::ucomisd(dst, src); }
1204   void ucomisd(XMMRegister dst, Address src)     { Assembler::ucomisd(dst, src); }
1205   void ucomisd(XMMRegister dst, AddressLiteral src);
1206 
1207   // Bitwise Logical XOR of Packed Double-Precision Floating-Point Values
1208   void xorpd(XMMRegister dst, XMMRegister src);
1209   void xorpd(XMMRegister dst, Address src)     { Assembler::xorpd(dst, src); }
<span class="line-modified">1210   void xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);</span>
1211 
1212   // Bitwise Logical XOR of Packed Single-Precision Floating-Point Values
1213   void xorps(XMMRegister dst, XMMRegister src);
1214   void xorps(XMMRegister dst, Address src)     { Assembler::xorps(dst, src); }
<span class="line-modified">1215   void xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);</span>
1216 
1217   // Shuffle Bytes
1218   void pshufb(XMMRegister dst, XMMRegister src) { Assembler::pshufb(dst, src); }
1219   void pshufb(XMMRegister dst, Address src)     { Assembler::pshufb(dst, src); }
1220   void pshufb(XMMRegister dst, AddressLiteral src);
1221   // AVX 3-operands instructions
1222 
1223   void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddsd(dst, nds, src); }
1224   void vaddsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddsd(dst, nds, src); }
1225   void vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1226 
1227   void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddss(dst, nds, src); }
1228   void vaddss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddss(dst, nds, src); }
1229   void vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1230 
1231   void vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1232   void vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1233 
1234   void vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1235   void vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1236 
1237   void vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1238   void vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1239 
<span class="line-added">1240   void vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }</span>
<span class="line-added">1241   void vpaddd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }</span>
<span class="line-added">1242   void vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch);</span>
<span class="line-added">1243 </span>
1244   void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
1245   void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
<span class="line-modified">1246   void vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);</span>
1247 
1248   void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
1249   void vpbroadcastw(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastw(dst, src, vector_len); }
1250 
1251   void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1252 
1253   void vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1254 
1255   void vpmovzxbw(XMMRegister dst, Address src, int vector_len);
1256   void vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::vpmovzxbw(dst, src, vector_len); }
1257 
1258   void vpmovmskb(Register dst, XMMRegister src);
1259 
1260   void vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1261   void vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1262 
1263   void vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1264   void vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1265 
1266   void vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1267   void vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1268 
1269   void vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1270   void vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1271 
<span class="line-added">1272   void evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);</span>
<span class="line-added">1273   void evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len);</span>
<span class="line-added">1274 </span>
1275   void vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1276   void vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1277 
1278   void vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1279   void vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1280 
1281   void vptest(XMMRegister dst, XMMRegister src);
1282 
1283   void punpcklbw(XMMRegister dst, XMMRegister src);
1284   void punpcklbw(XMMRegister dst, Address src) { Assembler::punpcklbw(dst, src); }
1285 
1286   void pshufd(XMMRegister dst, Address src, int mode);
1287   void pshufd(XMMRegister dst, XMMRegister src, int mode) { Assembler::pshufd(dst, src, mode); }
1288 
1289   void pshuflw(XMMRegister dst, XMMRegister src, int mode);
1290   void pshuflw(XMMRegister dst, Address src, int mode) { Assembler::pshuflw(dst, src, mode); }
1291 
1292   void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandpd(dst, nds, src, vector_len); }
1293   void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandpd(dst, nds, src, vector_len); }
<span class="line-modified">1294   void vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);</span>
1295 
1296   void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandps(dst, nds, src, vector_len); }
1297   void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandps(dst, nds, src, vector_len); }
<span class="line-modified">1298   void vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);</span>
1299 
1300   void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivsd(dst, nds, src); }
1301   void vdivsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivsd(dst, nds, src); }
1302   void vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1303 
1304   void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivss(dst, nds, src); }
1305   void vdivss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivss(dst, nds, src); }
1306   void vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1307 
1308   void vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulsd(dst, nds, src); }
1309   void vmulsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulsd(dst, nds, src); }
1310   void vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1311 
1312   void vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulss(dst, nds, src); }
1313   void vmulss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulss(dst, nds, src); }
1314   void vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1315 
1316   void vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubsd(dst, nds, src); }
1317   void vsubsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubsd(dst, nds, src); }
1318   void vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1319 
1320   void vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubss(dst, nds, src); }
1321   void vsubss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubss(dst, nds, src); }
1322   void vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1323 
1324   void vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1325   void vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1326 
1327   // AVX Vector instructions
1328 
1329   void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
1330   void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
<span class="line-modified">1331   void vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);</span>
1332 
1333   void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
1334   void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
<span class="line-modified">1335   void vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);</span>
1336 
1337   void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1338     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1339       Assembler::vpxor(dst, nds, src, vector_len);
1340     else
1341       Assembler::vxorpd(dst, nds, src, vector_len);
1342   }
1343   void vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
1344     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1345       Assembler::vpxor(dst, nds, src, vector_len);
1346     else
1347       Assembler::vxorpd(dst, nds, src, vector_len);
1348   }
<span class="line-added">1349   void vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);</span>
1350 
1351   // Simple version for AVX2 256bit vectors
1352   void vpxor(XMMRegister dst, XMMRegister src) { Assembler::vpxor(dst, dst, src, true); }
1353   void vpxor(XMMRegister dst, Address src) { Assembler::vpxor(dst, dst, src, true); }
1354 
1355   void vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
<span class="line-modified">1356     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
1357       Assembler::vinserti32x4(dst, dst, src, imm8);
1358     } else if (UseAVX &gt; 1) {
1359       // vinserti128 is available only in AVX2
1360       Assembler::vinserti128(dst, nds, src, imm8);
1361     } else {
1362       Assembler::vinsertf128(dst, nds, src, imm8);
1363     }
1364   }
1365 
1366   void vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
<span class="line-modified">1367     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
1368       Assembler::vinserti32x4(dst, dst, src, imm8);
1369     } else if (UseAVX &gt; 1) {
1370       // vinserti128 is available only in AVX2
1371       Assembler::vinserti128(dst, nds, src, imm8);
1372     } else {
1373       Assembler::vinsertf128(dst, nds, src, imm8);
1374     }
1375   }
1376 
1377   void vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
<span class="line-modified">1378     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
1379       Assembler::vextracti32x4(dst, src, imm8);
1380     } else if (UseAVX &gt; 1) {
1381       // vextracti128 is available only in AVX2
1382       Assembler::vextracti128(dst, src, imm8);
1383     } else {
1384       Assembler::vextractf128(dst, src, imm8);
1385     }
1386   }
1387 
1388   void vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
<span class="line-modified">1389     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
1390       Assembler::vextracti32x4(dst, src, imm8);
1391     } else if (UseAVX &gt; 1) {
1392       // vextracti128 is available only in AVX2
1393       Assembler::vextracti128(dst, src, imm8);
1394     } else {
1395       Assembler::vextractf128(dst, src, imm8);
1396     }
1397   }
1398 
1399   // 128bit copy to/from high 128 bits of 256bit (YMM) vector registers
1400   void vinserti128_high(XMMRegister dst, XMMRegister src) {
1401     vinserti128(dst, dst, src, 1);
1402   }
1403   void vinserti128_high(XMMRegister dst, Address src) {
1404     vinserti128(dst, dst, src, 1);
1405   }
1406   void vextracti128_high(XMMRegister dst, XMMRegister src) {
1407     vextracti128(dst, src, 1);
1408   }
1409   void vextracti128_high(Address dst, XMMRegister src) {
1410     vextracti128(dst, src, 1);
1411   }
1412 
1413   void vinsertf128_high(XMMRegister dst, XMMRegister src) {
<span class="line-modified">1414     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
1415       Assembler::vinsertf32x4(dst, dst, src, 1);
1416     } else {
1417       Assembler::vinsertf128(dst, dst, src, 1);
1418     }
1419   }
1420 
1421   void vinsertf128_high(XMMRegister dst, Address src) {
<span class="line-modified">1422     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
1423       Assembler::vinsertf32x4(dst, dst, src, 1);
1424     } else {
1425       Assembler::vinsertf128(dst, dst, src, 1);
1426     }
1427   }
1428 
1429   void vextractf128_high(XMMRegister dst, XMMRegister src) {
<span class="line-modified">1430     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
1431       Assembler::vextractf32x4(dst, src, 1);
1432     } else {
1433       Assembler::vextractf128(dst, src, 1);
1434     }
1435   }
1436 
1437   void vextractf128_high(Address dst, XMMRegister src) {
<span class="line-modified">1438     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
1439       Assembler::vextractf32x4(dst, src, 1);
1440     } else {
1441       Assembler::vextractf128(dst, src, 1);
1442     }
1443   }
1444 
1445   // 256bit copy to/from high 256 bits of 512bit (ZMM) vector registers
1446   void vinserti64x4_high(XMMRegister dst, XMMRegister src) {
1447     Assembler::vinserti64x4(dst, dst, src, 1);
1448   }
1449   void vinsertf64x4_high(XMMRegister dst, XMMRegister src) {
1450     Assembler::vinsertf64x4(dst, dst, src, 1);
1451   }
1452   void vextracti64x4_high(XMMRegister dst, XMMRegister src) {
1453     Assembler::vextracti64x4(dst, src, 1);
1454   }
1455   void vextractf64x4_high(XMMRegister dst, XMMRegister src) {
1456     Assembler::vextractf64x4(dst, src, 1);
1457   }
1458   void vextractf64x4_high(Address dst, XMMRegister src) {
</pre>
<hr />
<pre>
1460   }
1461   void vinsertf64x4_high(XMMRegister dst, Address src) {
1462     Assembler::vinsertf64x4(dst, dst, src, 1);
1463   }
1464 
1465   // 128bit copy to/from low 128 bits of 256bit (YMM) vector registers
1466   void vinserti128_low(XMMRegister dst, XMMRegister src) {
1467     vinserti128(dst, dst, src, 0);
1468   }
1469   void vinserti128_low(XMMRegister dst, Address src) {
1470     vinserti128(dst, dst, src, 0);
1471   }
1472   void vextracti128_low(XMMRegister dst, XMMRegister src) {
1473     vextracti128(dst, src, 0);
1474   }
1475   void vextracti128_low(Address dst, XMMRegister src) {
1476     vextracti128(dst, src, 0);
1477   }
1478 
1479   void vinsertf128_low(XMMRegister dst, XMMRegister src) {
<span class="line-modified">1480     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
1481       Assembler::vinsertf32x4(dst, dst, src, 0);
1482     } else {
1483       Assembler::vinsertf128(dst, dst, src, 0);
1484     }
1485   }
1486 
1487   void vinsertf128_low(XMMRegister dst, Address src) {
<span class="line-modified">1488     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
1489       Assembler::vinsertf32x4(dst, dst, src, 0);
1490     } else {
1491       Assembler::vinsertf128(dst, dst, src, 0);
1492     }
1493   }
1494 
1495   void vextractf128_low(XMMRegister dst, XMMRegister src) {
<span class="line-modified">1496     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
1497       Assembler::vextractf32x4(dst, src, 0);
1498     } else {
1499       Assembler::vextractf128(dst, src, 0);
1500     }
1501   }
1502 
1503   void vextractf128_low(Address dst, XMMRegister src) {
<span class="line-modified">1504     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
1505       Assembler::vextractf32x4(dst, src, 0);
1506     } else {
1507       Assembler::vextractf128(dst, src, 0);
1508     }
1509   }
1510 
1511   // 256bit copy to/from low 256 bits of 512bit (ZMM) vector registers
1512   void vinserti64x4_low(XMMRegister dst, XMMRegister src) {
1513     Assembler::vinserti64x4(dst, dst, src, 0);
1514   }
1515   void vinsertf64x4_low(XMMRegister dst, XMMRegister src) {
1516     Assembler::vinsertf64x4(dst, dst, src, 0);
1517   }
1518   void vextracti64x4_low(XMMRegister dst, XMMRegister src) {
1519     Assembler::vextracti64x4(dst, src, 0);
1520   }
1521   void vextractf64x4_low(XMMRegister dst, XMMRegister src) {
1522     Assembler::vextractf64x4(dst, src, 0);
1523   }
1524   void vextractf64x4_low(Address dst, XMMRegister src) {
</pre>
<hr />
<pre>
1616   // Import other mov() methods from the parent class or else
1617   // they will be hidden by the following overriding declaration.
1618   using Assembler::movdl;
1619   using Assembler::movq;
1620   void movdl(XMMRegister dst, AddressLiteral src);
1621   void movq(XMMRegister dst, AddressLiteral src);
1622 
1623   // Can push value or effective address
1624   void pushptr(AddressLiteral src);
1625 
1626   void pushptr(Address src) { LP64_ONLY(pushq(src)) NOT_LP64(pushl(src)); }
1627   void popptr(Address src) { LP64_ONLY(popq(src)) NOT_LP64(popl(src)); }
1628 
1629   void pushoop(jobject obj);
1630   void pushklass(Metadata* obj);
1631 
1632   // sign extend as need a l to ptr sized element
1633   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1634   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1635 
<span class="line-added">1636 #ifdef COMPILER2</span>
<span class="line-added">1637   // Generic instructions support for use in .ad files C2 code generation</span>
<span class="line-added">1638   void vabsnegd(int opcode, XMMRegister dst, XMMRegister src, Register scr);</span>
<span class="line-added">1639   void vabsnegd(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr);</span>
<span class="line-added">1640   void vabsnegf(int opcode, XMMRegister dst, XMMRegister src, Register scr);</span>
<span class="line-added">1641   void vabsnegf(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr);</span>
<span class="line-added">1642   void vextendbw(bool sign, XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="line-added">1643   void vextendbw(bool sign, XMMRegister dst, XMMRegister src);</span>
<span class="line-added">1644   void vshiftd(int opcode, XMMRegister dst, XMMRegister src);</span>
<span class="line-added">1645   void vshiftd(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);</span>
<span class="line-added">1646   void vshiftw(int opcode, XMMRegister dst, XMMRegister src);</span>
<span class="line-added">1647   void vshiftw(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);</span>
<span class="line-added">1648   void vshiftq(int opcode, XMMRegister dst, XMMRegister src);</span>
<span class="line-added">1649   void vshiftq(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);</span>
<span class="line-added">1650 #endif</span>
<span class="line-added">1651 </span>
1652   // C2 compiled method&#39;s prolog code.
1653   void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub);
1654 
1655   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39;;
1656   // if &#39;is_large&#39; is set, do not try to produce short loop
1657   void clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp, bool is_large);
1658 
1659   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
1660   void xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp);
1661 
1662 #ifdef COMPILER2
1663   void string_indexof_char(Register str1, Register cnt1, Register ch, Register result,
1664                            XMMRegister vec1, XMMRegister vec2, XMMRegister vec3, Register tmp);
1665 
1666   // IndexOf strings.
1667   // Small strings are loaded through stack if they cross page boundary.
1668   void string_indexof(Register str1, Register str2,
1669                       Register cnt1, Register cnt2,
1670                       int int_cnt2,  Register result,
1671                       XMMRegister vec, Register tmp,
</pre>
<hr />
<pre>
1792                             Register tmp4, Register tmp5, Register tmp6,
1793                             XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1794                             bool is_pclmulqdq_supported);
1795   // Fold 128-bit data chunk
1796   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1797   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf);
1798   // Fold 8-bit data
1799   void fold_8bit_crc32(Register crc, Register table, Register tmp);
1800   void fold_8bit_crc32(XMMRegister crc, Register table, XMMRegister xtmp, Register tmp);
1801   void fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1802 
1803   // Compress char[] array to byte[].
1804   void char_array_compress(Register src, Register dst, Register len,
1805                            XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1806                            XMMRegister tmp4, Register tmp5, Register result);
1807 
1808   // Inflate byte[] array to char[].
1809   void byte_array_inflate(Register src, Register dst, Register len,
1810                           XMMRegister tmp1, Register tmp2);
1811 
<span class="line-added">1812 #ifdef _LP64</span>
<span class="line-added">1813   void convert_f2i(Register dst, XMMRegister src);</span>
<span class="line-added">1814   void convert_d2i(Register dst, XMMRegister src);</span>
<span class="line-added">1815   void convert_f2l(Register dst, XMMRegister src);</span>
<span class="line-added">1816   void convert_d2l(Register dst, XMMRegister src);</span>
<span class="line-added">1817 </span>
<span class="line-added">1818   void cache_wb(Address line);</span>
<span class="line-added">1819   void cache_wbsync(bool is_pre);</span>
<span class="line-added">1820 #endif // _LP64</span>
1821 };
1822 
1823 /**
1824  * class SkipIfEqual:
1825  *
1826  * Instantiating this class will result in assembly code being output that will
1827  * jump around any code emitted between the creation of the instance and it&#39;s
1828  * automatic destruction at the end of a scope block, depending on the value of
1829  * the flag passed to the constructor, which will be checked at run-time.
1830  */
1831 class SkipIfEqual {
1832  private:
1833   MacroAssembler* _masm;
1834   Label _label;
1835 
1836  public:
1837    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1838    ~SkipIfEqual();
1839 };
1840 
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86_aes.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
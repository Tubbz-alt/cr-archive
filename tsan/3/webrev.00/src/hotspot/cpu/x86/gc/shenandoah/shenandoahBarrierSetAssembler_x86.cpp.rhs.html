<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  26 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;</span>
  27 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified">  28 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;</span>
<span class="line-added">  29 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;</span>
  30 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  33 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;interpreter/interp_masm.hpp&quot;
  36 #include &quot;runtime/sharedRuntime.hpp&quot;
  37 #include &quot;runtime/thread.hpp&quot;
  38 #include &quot;utilities/macros.hpp&quot;
  39 #ifdef COMPILER1
  40 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  41 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  42 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
  43 #endif
  44 
  45 #define __ masm-&gt;
  46 
<a name="4" id="anc4"></a><span class="line-modified">  47 address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;</span>
  48 
  49 void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
  50                                                        Register src, Register dst, Register count) {
  51 
<a name="5" id="anc5"></a>


  52   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
  53 
<a name="6" id="anc6"></a><span class="line-modified">  54   if (is_reference_type(type)) {</span>
<span class="line-added">  55 </span>
<span class="line-added">  56     if ((ShenandoahSATBBarrier &amp;&amp; !dest_uninitialized) || ShenandoahLoadRefBarrier) {</span>
  57 #ifdef _LP64
<a name="7" id="anc7"></a><span class="line-modified">  58       Register thread = r15_thread;</span>






  59 #else
<a name="8" id="anc8"></a><span class="line-modified">  60       Register thread = rax;</span>
<span class="line-modified">  61       if (thread == src || thread == dst || thread == count) {</span>
<span class="line-modified">  62         thread = rbx;</span>
<span class="line-modified">  63       }</span>
<span class="line-modified">  64       if (thread == src || thread == dst || thread == count) {</span>
<span class="line-modified">  65         thread = rcx;</span>
<span class="line-modified">  66       }</span>
<span class="line-modified">  67       if (thread == src || thread == dst || thread == count) {</span>
<span class="line-added">  68         thread = rdx;</span>
<span class="line-added">  69       }</span>
  70       __ push(thread);
  71       __ get_thread(thread);
  72 #endif
<a name="9" id="anc9"></a><span class="line-added">  73       assert_different_registers(src, dst, count, thread);</span>
  74 
<a name="10" id="anc10"></a><span class="line-modified">  75       Label done;</span>
<span class="line-modified">  76       // Short-circuit if count == 0.</span>
<span class="line-modified">  77       __ testptr(count, count);</span>
<span class="line-modified">  78       __ jcc(Assembler::zero, done);</span>







  79 
<a name="11" id="anc11"></a><span class="line-modified">  80       // Avoid runtime call when not marking.</span>
<span class="line-added">  81       Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-added">  82       int flags = ShenandoahHeap::HAS_FORWARDED;</span>
<span class="line-added">  83       if (!dest_uninitialized) {</span>
<span class="line-added">  84         flags |= ShenandoahHeap::MARKING;</span>
<span class="line-added">  85       }</span>
<span class="line-added">  86       __ testb(gc_state, flags);</span>
<span class="line-added">  87       __ jcc(Assembler::zero, done);</span>
  88 
  89       __ pusha();                      // push registers
  90 #ifdef _LP64
<a name="12" id="anc12"></a><span class="line-modified">  91       assert(src == rdi, &quot;expected&quot;);</span>
<span class="line-modified">  92       assert(dst == rsi, &quot;expected&quot;);</span>
<span class="line-modified">  93       assert(count == rdx, &quot;expected&quot;);</span>
<span class="line-modified">  94       if (UseCompressedOops) {</span>
<span class="line-added">  95         if (dest_uninitialized) {</span>
<span class="line-added">  96           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_duinit_narrow_oop_entry), src, dst, count);</span>
  97         } else {
<a name="13" id="anc13"></a><span class="line-modified">  98           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_narrow_oop_entry), src, dst, count);</span>

  99         }
<a name="14" id="anc14"></a><span class="line-modified"> 100       } else</span>











 101 #endif
<a name="15" id="anc15"></a><span class="line-added"> 102       {</span>
<span class="line-added"> 103         if (dest_uninitialized) {</span>
<span class="line-added"> 104           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_duinit_oop_entry), src, dst, count);</span>
<span class="line-added"> 105         } else {</span>
<span class="line-added"> 106           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry), src, dst, count);</span>
<span class="line-added"> 107         }</span>
<span class="line-added"> 108       }</span>
 109       __ popa();
<a name="16" id="anc16"></a><span class="line-modified"> 110       __ bind(done);</span>
<span class="line-added"> 111       NOT_LP64(__ pop(thread);)</span>
 112     }
 113   }
 114 
 115 }
 116 
<a name="17" id="anc17"></a>











































 117 void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
 118                                                                  Register obj,
 119                                                                  Register pre_val,
 120                                                                  Register thread,
 121                                                                  Register tmp,
 122                                                                  bool tosca_live,
 123                                                                  bool expand_call) {
 124 
 125   if (ShenandoahSATBBarrier) {
 126     satb_write_barrier_pre(masm, obj, pre_val, thread, tmp, tosca_live, expand_call);
 127   }
 128 }
 129 
 130 void ShenandoahBarrierSetAssembler::satb_write_barrier_pre(MacroAssembler* masm,
 131                                                            Register obj,
 132                                                            Register pre_val,
 133                                                            Register thread,
 134                                                            Register tmp,
 135                                                            bool tosca_live,
 136                                                            bool expand_call) {
 137   // If expand_call is true then we expand the call_VM_leaf macro
 138   // directly to skip generating the check by
 139   // InterpreterMacroAssembler::call_VM_leaf_base that checks _last_sp.
 140 
 141 #ifdef _LP64
 142   assert(thread == r15_thread, &quot;must be&quot;);
 143 #endif // _LP64
 144 
 145   Label done;
 146   Label runtime;
 147 
 148   assert(pre_val != noreg, &quot;check this code&quot;);
 149 
 150   if (obj != noreg) {
 151     assert_different_registers(obj, pre_val, tmp);
 152     assert(pre_val != rax, &quot;check this code&quot;);
 153   }
 154 
 155   Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));
 156   Address index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
 157   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
 158 
 159   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 160   __ testb(gc_state, ShenandoahHeap::MARKING | ShenandoahHeap::TRAVERSAL);
 161   __ jcc(Assembler::zero, done);
 162 
 163   // Do we need to load the previous value?
 164   if (obj != noreg) {
 165     __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);
 166   }
 167 
 168   // Is the previous value null?
 169   __ cmpptr(pre_val, (int32_t) NULL_WORD);
 170   __ jcc(Assembler::equal, done);
 171 
 172   // Can we store original value in the thread&#39;s buffer?
 173   // Is index == 0?
 174   // (The index field is typed as size_t.)
 175 
 176   __ movptr(tmp, index);                   // tmp := *index_adr
 177   __ cmpptr(tmp, 0);                       // tmp == 0?
 178   __ jcc(Assembler::equal, runtime);       // If yes, goto runtime
 179 
 180   __ subptr(tmp, wordSize);                // tmp := tmp - wordSize
 181   __ movptr(index, tmp);                   // *index_adr := tmp
 182   __ addptr(tmp, buffer);                  // tmp := tmp + *buffer_adr
 183 
 184   // Record the previous value
 185   __ movptr(Address(tmp, 0), pre_val);
 186   __ jmp(done);
 187 
 188   __ bind(runtime);
 189   // save the live input values
 190   if(tosca_live) __ push(rax);
 191 
 192   if (obj != noreg &amp;&amp; obj != rax)
 193     __ push(obj);
 194 
 195   if (pre_val != rax)
 196     __ push(pre_val);
 197 
 198   // Calling the runtime using the regular call_VM_leaf mechanism generates
 199   // code (generated by InterpreterMacroAssember::call_VM_leaf_base)
 200   // that checks that the *(ebp+frame::interpreter_frame_last_sp) == NULL.
 201   //
 202   // If we care generating the pre-barrier without a frame (e.g. in the
 203   // intrinsified Reference.get() routine) then ebp might be pointing to
 204   // the caller frame and so this check will most likely fail at runtime.
 205   //
 206   // Expanding the call directly bypasses the generation of the check.
 207   // So when we do not have have a full interpreter frame on the stack
 208   // expand_call should be passed true.
 209 
 210   NOT_LP64( __ push(thread); )
 211 
 212 #ifdef _LP64
 213   // We move pre_val into c_rarg0 early, in order to avoid smashing it, should
 214   // pre_val be c_rarg1 (where the call prologue would copy thread argument).
 215   // Note: this should not accidentally smash thread, because thread is always r15.
 216   assert(thread != c_rarg0, &quot;smashed arg&quot;);
 217   if (c_rarg0 != pre_val) {
 218     __ mov(c_rarg0, pre_val);
 219   }
 220 #endif
 221 
 222   if (expand_call) {
 223     LP64_ONLY( assert(pre_val != c_rarg1, &quot;smashed arg&quot;); )
 224 #ifdef _LP64
 225     if (c_rarg1 != thread) {
 226       __ mov(c_rarg1, thread);
 227     }
 228     // Already moved pre_val into c_rarg0 above
 229 #else
 230     __ push(thread);
 231     __ push(pre_val);
 232 #endif
 233     __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), 2);
 234   } else {
 235     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), LP64_ONLY(c_rarg0) NOT_LP64(pre_val), thread);
 236   }
 237 
 238   NOT_LP64( __ pop(thread); )
 239 
 240   // save the live input values
 241   if (pre_val != rax)
 242     __ pop(pre_val);
 243 
 244   if (obj != noreg &amp;&amp; obj != rax)
 245     __ pop(obj);
 246 
 247   if(tosca_live) __ pop(rax);
 248 
 249   __ bind(done);
 250 }
 251 
<a name="18" id="anc18"></a><span class="line-modified"> 252 void ShenandoahBarrierSetAssembler::load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address src) {</span>
<span class="line-modified"> 253   assert(ShenandoahLoadRefBarrier, &quot;Should be enabled&quot;);</span>



 254 
<a name="19" id="anc19"></a><span class="line-modified"> 255   Label done;</span>







 256 
<a name="20" id="anc20"></a><span class="line-modified"> 257 #ifdef _LP64</span>
<span class="line-modified"> 258   Register thread = r15_thread;</span>
<span class="line-modified"> 259 #else</span>
<span class="line-added"> 260   Register thread = rcx;</span>
<span class="line-added"> 261   if (thread == dst) {</span>
<span class="line-added"> 262     thread = rbx;</span>
 263   }
<a name="21" id="anc21"></a><span class="line-modified"> 264   __ push(thread);</span>
<span class="line-added"> 265   __ get_thread(thread);</span>
<span class="line-added"> 266 #endif</span>
 267 
<a name="22" id="anc22"></a><span class="line-modified"> 268   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-modified"> 269   __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED);</span>
<span class="line-modified"> 270   __ jccb(Assembler::zero, done);</span>
<span class="line-modified"> 271 </span>
<span class="line-added"> 272   // Use rsi for src address</span>
<span class="line-added"> 273   const Register src_addr = rsi;</span>
<span class="line-added"> 274   // Setup address parameter first, if it does not clobber oop in dst</span>
<span class="line-added"> 275   bool need_addr_setup = (src_addr != dst);</span>
<span class="line-added"> 276 </span>
<span class="line-added"> 277   if (need_addr_setup) {</span>
<span class="line-added"> 278     __ push(src_addr);</span>
<span class="line-added"> 279     __ lea(src_addr, src);</span>
 280 
<a name="23" id="anc23"></a><span class="line-added"> 281     if (dst != rax) {</span>
<span class="line-added"> 282       // Move obj into rax and save rax</span>
<span class="line-added"> 283       __ push(rax);</span>
<span class="line-added"> 284       __ movptr(rax, dst);</span>
<span class="line-added"> 285     }</span>
<span class="line-added"> 286   } else {</span>
<span class="line-added"> 287     // dst == rsi</span>
<span class="line-added"> 288     __ push(rax);</span>
<span class="line-added"> 289     __ movptr(rax, dst);</span>
 290 
<a name="24" id="anc24"></a><span class="line-modified"> 291     // we can clobber it, since it is outgoing register</span>
<span class="line-modified"> 292     __ lea(src_addr, src);</span>

 293   }
<a name="25" id="anc25"></a><span class="line-added"> 294 </span>
<span class="line-added"> 295   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_lrb())));</span>
<span class="line-added"> 296 </span>
<span class="line-added"> 297   if (need_addr_setup) {</span>
<span class="line-added"> 298     if (dst != rax) {</span>
<span class="line-added"> 299       __ movptr(dst, rax);</span>
<span class="line-added"> 300       __ pop(rax);</span>
<span class="line-added"> 301     }</span>
<span class="line-added"> 302     __ pop(src_addr);</span>
<span class="line-added"> 303   } else {</span>
<span class="line-added"> 304     __ movptr(dst, rax);</span>
<span class="line-added"> 305     __ pop(rax);</span>
<span class="line-added"> 306   }</span>
<span class="line-added"> 307 </span>
<span class="line-added"> 308   __ bind(done);</span>
<span class="line-added"> 309 </span>
<span class="line-added"> 310 #ifndef _LP64</span>
<span class="line-added"> 311     __ pop(thread);</span>
<span class="line-added"> 312 #endif</span>
 313 }
 314 
<a name="26" id="anc26"></a><span class="line-modified"> 315 void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address src) {</span>
<span class="line-modified"> 316   if (!ShenandoahLoadRefBarrier) {</span>
<span class="line-modified"> 317     return;</span>
<span class="line-added"> 318   }</span>
<span class="line-added"> 319 </span>
 320   Label done;
<a name="27" id="anc27"></a><span class="line-added"> 321   Label not_null;</span>
<span class="line-added"> 322   Label slow_path;</span>
<span class="line-added"> 323   __ block_comment(&quot;load_reference_barrier_native { &quot;);</span>
 324 
<a name="28" id="anc28"></a><span class="line-modified"> 325   // null check</span>
<span class="line-modified"> 326   __ testptr(dst, dst);</span>
<span class="line-modified"> 327   __ jcc(Assembler::notZero, not_null);</span>
<span class="line-added"> 328   __ jmp(done);</span>
<span class="line-added"> 329   __ bind(not_null);</span>
 330 
<a name="29" id="anc29"></a>

 331 
<a name="30" id="anc30"></a><span class="line-modified"> 332 #ifdef _LP64</span>
<span class="line-modified"> 333   Register thread = r15_thread;</span>
<span class="line-added"> 334 #else</span>
<span class="line-added"> 335   Register thread = rcx;</span>
<span class="line-added"> 336   if (thread == dst) {</span>
<span class="line-added"> 337     thread = rbx;</span>
<span class="line-added"> 338   }</span>
<span class="line-added"> 339   __ push(thread);</span>
<span class="line-added"> 340   __ get_thread(thread);</span>
<span class="line-added"> 341 #endif</span>
<span class="line-added"> 342   assert_different_registers(dst, thread);</span>
<span class="line-added"> 343 </span>
<span class="line-added"> 344   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-added"> 345   __ testb(gc_state, ShenandoahHeap::EVACUATION);</span>
<span class="line-added"> 346 #ifndef _LP64</span>
<span class="line-added"> 347   __ pop(thread);</span>
<span class="line-added"> 348 #endif</span>
<span class="line-added"> 349   __ jccb(Assembler::notZero, slow_path);</span>
<span class="line-added"> 350   __ jmp(done);</span>
<span class="line-added"> 351   __ bind(slow_path);</span>
<span class="line-added"> 352 </span>
<span class="line-added"> 353   if (dst != rax) {</span>
<span class="line-added"> 354     __ push(rax);</span>
<span class="line-added"> 355   }</span>
<span class="line-added"> 356   __ push(rcx);</span>
<span class="line-added"> 357   __ push(rdx);</span>
<span class="line-added"> 358   __ push(rdi);</span>
<span class="line-added"> 359   __ push(rsi);</span>
<span class="line-added"> 360 #ifdef _LP64</span>
<span class="line-added"> 361   __ push(r8);</span>
<span class="line-added"> 362   __ push(r9);</span>
<span class="line-added"> 363   __ push(r10);</span>
<span class="line-added"> 364   __ push(r11);</span>
<span class="line-added"> 365   __ push(r12);</span>
<span class="line-added"> 366   __ push(r13);</span>
<span class="line-added"> 367   __ push(r14);</span>
<span class="line-added"> 368   __ push(r15);</span>
<span class="line-added"> 369 #endif</span>
 370 
<a name="31" id="anc31"></a><span class="line-modified"> 371   assert_different_registers(dst, rsi);</span>
<span class="line-modified"> 372   __ lea(rsi, src);</span>
<span class="line-modified"> 373   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), dst, rsi);</span>
 374 
<a name="32" id="anc32"></a><span class="line-modified"> 375 #ifdef _LP64</span>
<span class="line-added"> 376   __ pop(r15);</span>
<span class="line-added"> 377   __ pop(r14);</span>
<span class="line-added"> 378   __ pop(r13);</span>
<span class="line-added"> 379   __ pop(r12);</span>
<span class="line-added"> 380   __ pop(r11);</span>
<span class="line-added"> 381   __ pop(r10);</span>
<span class="line-added"> 382   __ pop(r9);</span>
<span class="line-added"> 383   __ pop(r8);</span>
<span class="line-added"> 384 #endif</span>
<span class="line-added"> 385   __ pop(rsi);</span>
<span class="line-added"> 386   __ pop(rdi);</span>
<span class="line-added"> 387   __ pop(rdx);</span>
<span class="line-added"> 388   __ pop(rcx);</span>
 389 
<a name="33" id="anc33"></a><span class="line-modified"> 390   if (dst != rax) {</span>
<span class="line-modified"> 391     __ movptr(dst, rax);</span>
<span class="line-modified"> 392     __ pop(rax);</span>
<span class="line-added"> 393   }</span>
 394 
 395   __ bind(done);
<a name="34" id="anc34"></a><span class="line-modified"> 396   __ block_comment(&quot;load_reference_barrier_native { &quot;);</span>


 397 }
 398 
 399 void ShenandoahBarrierSetAssembler::storeval_barrier(MacroAssembler* masm, Register dst, Register tmp) {
<a name="35" id="anc35"></a><span class="line-modified"> 400   if (ShenandoahStoreValEnqueueBarrier) {</span>
 401     storeval_barrier_impl(masm, dst, tmp);
 402   }
 403 }
 404 
 405 void ShenandoahBarrierSetAssembler::storeval_barrier_impl(MacroAssembler* masm, Register dst, Register tmp) {
<a name="36" id="anc36"></a><span class="line-modified"> 406   assert(ShenandoahStoreValEnqueueBarrier, &quot;should be enabled&quot;);</span>
 407 
 408   if (dst == noreg) return;
 409 
<a name="37" id="anc37"></a>
 410   if (ShenandoahStoreValEnqueueBarrier) {
<a name="38" id="anc38"></a>





 411     // The set of registers to be saved+restored is the same as in the write-barrier above.
 412     // Those are the commonly used registers in the interpreter.
 413     __ pusha();
 414     // __ push_callee_saved_registers();
 415     __ subptr(rsp, 2 * Interpreter::stackElementSize);
 416     __ movdbl(Address(rsp, 0), xmm0);
 417 
<a name="39" id="anc39"></a><span class="line-modified"> 418 #ifdef _LP64</span>
<span class="line-added"> 419     Register thread = r15_thread;</span>
<span class="line-added"> 420 #else</span>
<span class="line-added"> 421     Register thread = rcx;</span>
<span class="line-added"> 422     if (thread == dst || thread == tmp) {</span>
<span class="line-added"> 423       thread = rdi;</span>
<span class="line-added"> 424     }</span>
<span class="line-added"> 425     if (thread == dst || thread == tmp) {</span>
<span class="line-added"> 426       thread = rbx;</span>
<span class="line-added"> 427     }</span>
<span class="line-added"> 428     __ get_thread(thread);</span>
<span class="line-added"> 429 #endif</span>
<span class="line-added"> 430     assert_different_registers(dst, tmp, thread);</span>
<span class="line-added"> 431 </span>
<span class="line-added"> 432     satb_write_barrier_pre(masm, noreg, dst, thread, tmp, true, false);</span>
 433     __ movdbl(xmm0, Address(rsp, 0));
 434     __ addptr(rsp, 2 * Interpreter::stackElementSize);
 435     //__ pop_callee_saved_registers();
 436     __ popa();
 437   }
<a name="40" id="anc40"></a><span class="line-modified"> 438 }</span>
<span class="line-modified"> 439 </span>
<span class="line-added"> 440 void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address src) {</span>
<span class="line-added"> 441   if (ShenandoahLoadRefBarrier) {</span>
<span class="line-added"> 442     Label done;</span>
<span class="line-added"> 443     __ testptr(dst, dst);</span>
<span class="line-added"> 444     __ jcc(Assembler::zero, done);</span>
<span class="line-added"> 445     load_reference_barrier_not_null(masm, dst, src);</span>
<span class="line-added"> 446     __ bind(done);</span>
 447   }
<a name="41" id="anc41"></a>


 448 }
 449 
<a name="42" id="anc42"></a><span class="line-added"> 450 //</span>
<span class="line-added"> 451 // Arguments:</span>
<span class="line-added"> 452 //</span>
<span class="line-added"> 453 // Inputs:</span>
<span class="line-added"> 454 //   src:        oop location, might be clobbered</span>
<span class="line-added"> 455 //   tmp1:       scratch register, might not be valid.</span>
<span class="line-added"> 456 //</span>
<span class="line-added"> 457 // Output:</span>
<span class="line-added"> 458 //   dst:        oop loaded from src location</span>
<span class="line-added"> 459 //</span>
<span class="line-added"> 460 // Kill:</span>
<span class="line-added"> 461 //   tmp1 (if it is valid)</span>
<span class="line-added"> 462 //</span>
 463 void ShenandoahBarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
 464              Register dst, Address src, Register tmp1, Register tmp_thread) {
<a name="43" id="anc43"></a><span class="line-modified"> 465   // 1: non-reference load, no additional barrier is needed</span>
<span class="line-modified"> 466   if (!is_reference_type(type)) {</span>
<span class="line-modified"> 467     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-modified"> 468     return;</span>
<span class="line-modified"> 469   }</span>
<span class="line-modified"> 470 </span>
<span class="line-modified"> 471   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Not expected&quot;);</span>





 472 
<a name="44" id="anc44"></a><span class="line-added"> 473   // 2: load a reference from src location and apply LRB if needed</span>
<span class="line-added"> 474   if (ShenandoahBarrierSet::need_load_reference_barrier(decorators, type)) {</span>
<span class="line-added"> 475     Register result_dst = dst;</span>
<span class="line-added"> 476     bool use_tmp1_for_dst = false;</span>
<span class="line-added"> 477 </span>
<span class="line-added"> 478     // Preserve src location for LRB</span>
<span class="line-added"> 479     if (dst == src.base() || dst == src.index()) {</span>
<span class="line-added"> 480       // Use tmp1 for dst if possible, as it is not used in BarrierAssembler::load_at()</span>
<span class="line-added"> 481       if (tmp1-&gt;is_valid() &amp;&amp; tmp1 != src.base() &amp;&amp; tmp1 != src.index()) {</span>
<span class="line-added"> 482         dst = tmp1;</span>
<span class="line-added"> 483         use_tmp1_for_dst = true;</span>
<span class="line-added"> 484       } else {</span>
<span class="line-added"> 485         dst = rdi;</span>
<span class="line-added"> 486         __ push(dst);</span>
<span class="line-added"> 487       }</span>
<span class="line-added"> 488       assert_different_registers(dst, src.base(), src.index());</span>
<span class="line-added"> 489     }</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-added"> 492 </span>
<span class="line-added"> 493     if (ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type)) {</span>
<span class="line-added"> 494       load_reference_barrier_native(masm, dst, src);</span>
<span class="line-added"> 495     } else {</span>
<span class="line-added"> 496       load_reference_barrier(masm, dst, src);</span>
<span class="line-added"> 497     }</span>
<span class="line-added"> 498 </span>
<span class="line-added"> 499     // Move loaded oop to final destination</span>
<span class="line-added"> 500     if (dst != result_dst) {</span>
<span class="line-added"> 501       __ movptr(result_dst, dst);</span>
<span class="line-added"> 502 </span>
<span class="line-added"> 503       if (!use_tmp1_for_dst) {</span>
<span class="line-added"> 504         __ pop(dst);</span>
<span class="line-added"> 505       }</span>
<span class="line-added"> 506 </span>
<span class="line-added"> 507       dst = result_dst;</span>
<span class="line-added"> 508     }</span>
<span class="line-added"> 509   } else {</span>
<span class="line-added"> 510     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-added"> 511   }</span>
<span class="line-added"> 512 </span>
<span class="line-added"> 513   // 3: apply keep-alive barrier if needed</span>
<span class="line-added"> 514   if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {</span>
<span class="line-added"> 515     __ push_IU_state();</span>
<span class="line-added"> 516     // That path can be reached from the c2i adapter with live fp</span>
<span class="line-added"> 517     // arguments in registers.</span>
<span class="line-added"> 518     LP64_ONLY(assert(Argument::n_float_register_parameters_j == 8, &quot;8 fp registers to save at java call&quot;));</span>
<span class="line-added"> 519     __ subptr(rsp, 64);</span>
<span class="line-added"> 520     __ movdbl(Address(rsp, 0), xmm0);</span>
<span class="line-added"> 521     __ movdbl(Address(rsp, 8), xmm1);</span>
<span class="line-added"> 522     __ movdbl(Address(rsp, 16), xmm2);</span>
<span class="line-added"> 523     __ movdbl(Address(rsp, 24), xmm3);</span>
<span class="line-added"> 524     __ movdbl(Address(rsp, 32), xmm4);</span>
<span class="line-added"> 525     __ movdbl(Address(rsp, 40), xmm5);</span>
<span class="line-added"> 526     __ movdbl(Address(rsp, 48), xmm6);</span>
<span class="line-added"> 527     __ movdbl(Address(rsp, 56), xmm7);</span>
<span class="line-added"> 528 </span>
<span class="line-added"> 529     Register thread = NOT_LP64(tmp_thread) LP64_ONLY(r15_thread);</span>
<span class="line-added"> 530     assert_different_registers(dst, tmp1, tmp_thread);</span>
<span class="line-added"> 531     if (!thread-&gt;is_valid()) {</span>
<span class="line-added"> 532       thread = rdx;</span>
<span class="line-added"> 533     }</span>
<span class="line-added"> 534     NOT_LP64(__ get_thread(thread));</span>
 535     // Generate the SATB pre-barrier code to log the value of
 536     // the referent field in an SATB buffer.
 537     shenandoah_write_barrier_pre(masm /* masm */,
 538                                  noreg /* obj */,
 539                                  dst /* pre_val */,
 540                                  thread /* thread */,
 541                                  tmp1 /* tmp */,
 542                                  true /* tosca_live */,
 543                                  true /* expand_call */);
<a name="45" id="anc45"></a><span class="line-added"> 544     __ movdbl(xmm0, Address(rsp, 0));</span>
<span class="line-added"> 545     __ movdbl(xmm1, Address(rsp, 8));</span>
<span class="line-added"> 546     __ movdbl(xmm2, Address(rsp, 16));</span>
<span class="line-added"> 547     __ movdbl(xmm3, Address(rsp, 24));</span>
<span class="line-added"> 548     __ movdbl(xmm4, Address(rsp, 32));</span>
<span class="line-added"> 549     __ movdbl(xmm5, Address(rsp, 40));</span>
<span class="line-added"> 550     __ movdbl(xmm6, Address(rsp, 48));</span>
<span class="line-added"> 551     __ movdbl(xmm7, Address(rsp, 56));</span>
<span class="line-added"> 552     __ addptr(rsp, 64);</span>
<span class="line-added"> 553     __ pop_IU_state();</span>
 554   }
 555 }
 556 
 557 void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
 558               Address dst, Register val, Register tmp1, Register tmp2) {
 559 
<a name="46" id="anc46"></a><span class="line-added"> 560   bool on_oop = is_reference_type(type);</span>
 561   bool in_heap = (decorators &amp; IN_HEAP) != 0;
 562   bool as_normal = (decorators &amp; AS_NORMAL) != 0;
<a name="47" id="anc47"></a><span class="line-modified"> 563   if (on_oop &amp;&amp; in_heap) {</span>



 564     bool needs_pre_barrier = as_normal;
 565 
 566     Register tmp3 = LP64_ONLY(r8) NOT_LP64(rsi);
 567     Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
 568     // flatten object address if needed
 569     // We do it regardless of precise because we need the registers
 570     if (dst.index() == noreg &amp;&amp; dst.disp() == 0) {
 571       if (dst.base() != tmp1) {
 572         __ movptr(tmp1, dst.base());
 573       }
 574     } else {
 575       __ lea(tmp1, dst);
 576     }
 577 
<a name="48" id="anc48"></a><span class="line-added"> 578     assert_different_registers(val, tmp1, tmp2, tmp3, rthread);</span>
<span class="line-added"> 579 </span>
 580 #ifndef _LP64
<a name="49" id="anc49"></a><span class="line-added"> 581     __ get_thread(rthread);</span>
 582     InterpreterMacroAssembler *imasm = static_cast&lt;InterpreterMacroAssembler*&gt;(masm);
<a name="50" id="anc50"></a><span class="line-added"> 583     imasm-&gt;save_bcp();</span>
 584 #endif
 585 
<a name="51" id="anc51"></a>


 586     if (needs_pre_barrier) {
 587       shenandoah_write_barrier_pre(masm /*masm*/,
 588                                    tmp1 /* obj */,
 589                                    tmp2 /* pre_val */,
 590                                    rthread /* thread */,
 591                                    tmp3  /* tmp */,
 592                                    val != noreg /* tosca_live */,
 593                                    false /* expand_call */);
 594     }
 595     if (val == noreg) {
 596       BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg);
 597     } else {
 598       storeval_barrier(masm, val, tmp3);
 599       BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg);
 600     }
 601     NOT_LP64(imasm-&gt;restore_bcp());
 602   } else {
 603     BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);
 604   }
 605 }
 606 
<a name="52" id="anc52"></a><span class="line-modified"> 607 void ShenandoahBarrierSetAssembler::try_resolve_jobject_in_native(MacroAssembler* masm, Register jni_env,</span>
<span class="line-modified"> 608                                                                   Register obj, Register tmp, Label&amp; slowpath) {</span>
<span class="line-modified"> 609   Label done;</span>
<span class="line-modified"> 610   // Resolve jobject</span>
<span class="line-modified"> 611   BarrierSetAssembler::try_resolve_jobject_in_native(masm, jni_env, obj, tmp, slowpath);</span>










































































 612 
<a name="53" id="anc53"></a><span class="line-modified"> 613   // Check for null.</span>
<span class="line-modified"> 614   __ testptr(obj, obj);</span>
<span class="line-modified"> 615   __ jcc(Assembler::zero, done);</span>



 616 
<a name="54" id="anc54"></a><span class="line-modified"> 617   Address gc_state(jni_env, ShenandoahThreadLocalData::gc_state_offset() - JavaThread::jni_environment_offset());</span>
<span class="line-modified"> 618   __ testb(gc_state, ShenandoahHeap::EVACUATION);</span>
<span class="line-modified"> 619   __ jccb(Assembler::notZero, slowpath);</span>
<span class="line-modified"> 620   __ bind(done);</span>
















 621 }
 622 
 623 // Special Shenandoah CAS implementation that handles false negatives
 624 // due to concurrent evacuation.
<a name="55" id="anc55"></a>







 625 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm,
 626                                                 Register res, Address addr, Register oldval, Register newval,
 627                                                 bool exchange, Register tmp1, Register tmp2) {
 628   assert(ShenandoahCASBarrier, &quot;Should only be used when CAS barrier is enabled&quot;);
 629   assert(oldval == rax, &quot;must be in rax for implicit use in cmpxchg&quot;);
<a name="56" id="anc56"></a><span class="line-added"> 630   assert_different_registers(oldval, newval, tmp1, tmp2);</span>
 631 
<a name="57" id="anc57"></a><span class="line-modified"> 632   Label L_success, L_failure;</span>
 633 
 634   // Remember oldval for retry logic below
<a name="58" id="anc58"></a><span class="line-added"> 635 #ifdef _LP64</span>
 636   if (UseCompressedOops) {
 637     __ movl(tmp1, oldval);
<a name="59" id="anc59"></a><span class="line-modified"> 638   } else</span>
<span class="line-added"> 639 #endif</span>
<span class="line-added"> 640   {</span>
 641     __ movptr(tmp1, oldval);
 642   }
 643 
<a name="60" id="anc60"></a><span class="line-modified"> 644   // Step 1. Fast-path.</span>
<span class="line-modified"> 645   //</span>
<span class="line-added"> 646   // Try to CAS with given arguments. If successful, then we are done.</span>
<span class="line-added"> 647 </span>
 648   if (os::is_MP()) __ lock();
<a name="61" id="anc61"></a><span class="line-added"> 649 #ifdef _LP64</span>
 650   if (UseCompressedOops) {
 651     __ cmpxchgl(newval, addr);
<a name="62" id="anc62"></a><span class="line-modified"> 652   } else</span>
<span class="line-added"> 653 #endif</span>
<span class="line-added"> 654   {</span>
 655     __ cmpxchgptr(newval, addr);
 656   }
<a name="63" id="anc63"></a><span class="line-modified"> 657   __ jcc(Assembler::equal, L_success);</span>
 658 
 659   // Step 2. CAS had failed. This may be a false negative.
 660   //
 661   // The trouble comes when we compare the to-space pointer with the from-space
<a name="64" id="anc64"></a><span class="line-modified"> 662   // pointer to the same object. To resolve this, it will suffice to resolve</span>
<span class="line-modified"> 663   // the value from memory -- this will give both to-space pointers.</span>
<span class="line-modified"> 664   // If they mismatch, then it was a legitimate failure.</span>
 665   //
<a name="65" id="anc65"></a><span class="line-modified"> 666   // Before reaching to resolve sequence, see if we can avoid the whole shebang</span>
<span class="line-modified"> 667   // with filters.</span>
<span class="line-modified"> 668 </span>
<span class="line-modified"> 669   // Filter: when offending in-memory value is NULL, the failure is definitely legitimate</span>
<span class="line-added"> 670   __ testptr(oldval, oldval);</span>
<span class="line-added"> 671   __ jcc(Assembler::zero, L_failure);</span>
<span class="line-added"> 672 </span>
<span class="line-added"> 673   // Filter: when heap is stable, the failure is definitely legitimate</span>
<span class="line-added"> 674 #ifdef _LP64</span>
<span class="line-added"> 675   const Register thread = r15_thread;</span>
<span class="line-added"> 676 #else</span>
<span class="line-added"> 677   const Register thread = tmp2;</span>
<span class="line-added"> 678   __ get_thread(thread);</span>
<span class="line-added"> 679 #endif</span>
<span class="line-added"> 680   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-added"> 681   __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED);</span>
<span class="line-added"> 682   __ jcc(Assembler::zero, L_failure);</span>
 683 
<a name="66" id="anc66"></a><span class="line-added"> 684 #ifdef _LP64</span>
 685   if (UseCompressedOops) {
 686     __ movl(tmp2, oldval);
 687     __ decode_heap_oop(tmp2);
<a name="67" id="anc67"></a><span class="line-modified"> 688   } else</span>
<span class="line-added"> 689 #endif</span>
<span class="line-added"> 690   {</span>
 691     __ movptr(tmp2, oldval);
 692   }
<a name="68" id="anc68"></a>
 693 
<a name="69" id="anc69"></a><span class="line-modified"> 694   // Decode offending in-memory value.</span>
<span class="line-modified"> 695   // Test if-forwarded</span>
<span class="line-added"> 696   __ testb(Address(tmp2, oopDesc::mark_offset_in_bytes()), markWord::marked_value);</span>
<span class="line-added"> 697   __ jcc(Assembler::noParity, L_failure);  // When odd number of bits, then not forwarded</span>
<span class="line-added"> 698   __ jcc(Assembler::zero, L_failure);      // When it is 00, then also not forwarded</span>
 699 
<a name="70" id="anc70"></a><span class="line-modified"> 700   // Load and mask forwarding pointer</span>
<span class="line-modified"> 701   __ movptr(tmp2, Address(tmp2, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-modified"> 702   __ shrptr(tmp2, 2);</span>
<span class="line-modified"> 703   __ shlptr(tmp2, 2);</span>










 704 
<a name="71" id="anc71"></a><span class="line-added"> 705 #ifdef _LP64</span>
 706   if (UseCompressedOops) {
<a name="72" id="anc72"></a><span class="line-modified"> 707     __ decode_heap_oop(tmp1); // decode for comparison</span>



 708   }
<a name="73" id="anc73"></a><span class="line-modified"> 709 #endif</span>
 710 
<a name="74" id="anc74"></a><span class="line-added"> 711   // Now we have the forwarded offender in tmp2.</span>
<span class="line-added"> 712   // Compare and if they don&#39;t match, we have legitimate failure</span>
 713   __ cmpptr(tmp1, tmp2);
<a name="75" id="anc75"></a><span class="line-modified"> 714   __ jcc(Assembler::notEqual, L_failure);</span>
 715 
<a name="76" id="anc76"></a><span class="line-modified"> 716   // Step 3. Need to fix the memory ptr before continuing.</span>
<span class="line-modified"> 717   //</span>
<span class="line-modified"> 718   // At this point, we have from-space oldval in the register, and its to-space</span>
<span class="line-modified"> 719   // address is in tmp2. Let&#39;s try to update it into memory. We don&#39;t care if it</span>
<span class="line-modified"> 720   // succeeds or not. If it does, then the retrying CAS would see it and succeed.</span>
<span class="line-modified"> 721   // If this fixup fails, this means somebody else beat us to it, and necessarily</span>
<span class="line-modified"> 722   // with to-space ptr store. We still have to do the retry, because the GC might</span>
<span class="line-modified"> 723   // have updated the reference for us.</span>



 724 
<a name="77" id="anc77"></a><span class="line-modified"> 725 #ifdef _LP64</span>
<span class="line-modified"> 726   if (UseCompressedOops) {</span>
<span class="line-modified"> 727     __ encode_heap_oop(tmp2); // previously decoded at step 2.</span>

 728   }
<a name="78" id="anc78"></a>




























 729 #endif
<a name="79" id="anc79"></a><span class="line-modified"> 730 </span>
<span class="line-modified"> 731   if (os::is_MP()) __ lock();</span>
 732 #ifdef _LP64
<a name="80" id="anc80"></a><span class="line-modified"> 733   if (UseCompressedOops) {</span>
<span class="line-modified"> 734     __ cmpxchgl(tmp2, addr);</span>
<span class="line-modified"> 735   } else</span>










 736 #endif
<a name="81" id="anc81"></a><span class="line-added"> 737   {</span>
<span class="line-added"> 738     __ cmpxchgptr(tmp2, addr);</span>
 739   }
<a name="82" id="anc82"></a>
 740 
<a name="83" id="anc83"></a><span class="line-modified"> 741   // Step 4. Try to CAS again.</span>
<span class="line-modified"> 742   //</span>
<span class="line-modified"> 743   // This is guaranteed not to have false negatives, because oldval is definitely</span>
<span class="line-modified"> 744   // to-space, and memory pointer is to-space as well. Nothing is able to store</span>
<span class="line-modified"> 745   // from-space ptr into memory anymore. Make sure oldval is restored, after being</span>
<span class="line-modified"> 746   // garbled during retries.</span>
<span class="line-modified"> 747   //</span>





 748 #ifdef _LP64
<a name="84" id="anc84"></a><span class="line-modified"> 749   if (UseCompressedOops) {</span>
<span class="line-modified"> 750     __ movl(oldval, tmp2);</span>
<span class="line-modified"> 751   } else</span>










 752 #endif
<a name="85" id="anc85"></a><span class="line-modified"> 753   {</span>
<span class="line-added"> 754     __ movptr(oldval, tmp2);</span>
<span class="line-added"> 755   }</span>
 756 
<a name="86" id="anc86"></a><span class="line-modified"> 757   if (os::is_MP()) __ lock();</span>
<span class="line-modified"> 758 #ifdef _LP64</span>
<span class="line-modified"> 759   if (UseCompressedOops) {</span>
<span class="line-modified"> 760     __ cmpxchgl(newval, addr);</span>
<span class="line-modified"> 761   } else</span>









 762 #endif
<a name="87" id="anc87"></a><span class="line-added"> 763   {</span>
<span class="line-added"> 764     __ cmpxchgptr(newval, addr);</span>
<span class="line-added"> 765   }</span>
<span class="line-added"> 766   if (!exchange) {</span>
<span class="line-added"> 767     __ jccb(Assembler::equal, L_success); // fastpath, peeking into Step 5, no need to jump</span>
<span class="line-added"> 768   }</span>
<span class="line-added"> 769 </span>
<span class="line-added"> 770   // Step 5. If we need a boolean result out of CAS, set the flag appropriately.</span>
<span class="line-added"> 771   // and promote the result. Note that we handle the flag from both the 1st and 2nd CAS.</span>
<span class="line-added"> 772   // Otherwise, failure witness for CAE is in oldval on all paths, and we can return.</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774   if (exchange) {</span>
<span class="line-added"> 775     __ bind(L_failure);</span>
<span class="line-added"> 776     __ bind(L_success);</span>
<span class="line-added"> 777   } else {</span>
<span class="line-added"> 778     assert(res != NULL, &quot;need result register&quot;);</span>
<span class="line-added"> 779 </span>
<span class="line-added"> 780     Label exit;</span>
<span class="line-added"> 781     __ bind(L_failure);</span>
<span class="line-added"> 782     __ xorptr(res, res);</span>
<span class="line-added"> 783     __ jmpb(exit);</span>
<span class="line-added"> 784 </span>
<span class="line-added"> 785     __ bind(L_success);</span>
<span class="line-added"> 786     __ movptr(res, 1);</span>
<span class="line-added"> 787     __ bind(exit);</span>
 788   }
 789 }
 790 
<a name="88" id="anc88"></a><span class="line-added"> 791 #undef __</span>
<span class="line-added"> 792 </span>
 793 #ifdef COMPILER1
 794 
<a name="89" id="anc89"></a>
 795 #define __ ce-&gt;masm()-&gt;
 796 
 797 void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
 798   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
 799   // At this point we know that marking is in progress.
 800   // If do_load() is true then we have to emit the
 801   // load of the previous value; otherwise it has already
 802   // been loaded into _pre_val.
 803 
 804   __ bind(*stub-&gt;entry());
 805   assert(stub-&gt;pre_val()-&gt;is_register(), &quot;Precondition.&quot;);
 806 
 807   Register pre_val_reg = stub-&gt;pre_val()-&gt;as_register();
 808 
 809   if (stub-&gt;do_load()) {
 810     ce-&gt;mem2reg(stub-&gt;addr(), stub-&gt;pre_val(), T_OBJECT, stub-&gt;patch_code(), stub-&gt;info(), false /*wide*/, false /*unaligned*/);
 811   }
 812 
 813   __ cmpptr(pre_val_reg, (int32_t)NULL_WORD);
 814   __ jcc(Assembler::equal, *stub-&gt;continuation());
 815   ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
 816   __ call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
 817   __ jmp(*stub-&gt;continuation());
 818 
 819 }
 820 
<a name="90" id="anc90"></a><span class="line-modified"> 821 void ShenandoahBarrierSetAssembler::gen_load_reference_barrier_stub(LIR_Assembler* ce, ShenandoahLoadReferenceBarrierStub* stub) {</span>
<span class="line-added"> 822   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();</span>
 823   __ bind(*stub-&gt;entry());
 824 
<a name="91" id="anc91"></a>
 825   Register obj = stub-&gt;obj()-&gt;as_register();
 826   Register res = stub-&gt;result()-&gt;as_register();
<a name="92" id="anc92"></a><span class="line-added"> 827   Register addr = stub-&gt;addr()-&gt;as_pointer_register();</span>
<span class="line-added"> 828   Register tmp1 = stub-&gt;tmp1()-&gt;as_register();</span>
<span class="line-added"> 829   Register tmp2 = stub-&gt;tmp2()-&gt;as_register();</span>
<span class="line-added"> 830   assert_different_registers(obj, res, addr, tmp1, tmp2);</span>
<span class="line-added"> 831 </span>
<span class="line-added"> 832   Label slow_path;</span>
<span class="line-added"> 833 </span>
<span class="line-added"> 834   assert(res == rax, &quot;result must arrive in rax&quot;);</span>
 835 
 836   if (res != obj) {
 837     __ mov(res, obj);
 838   }
 839 
 840   // Check for null.
<a name="93" id="anc93"></a><span class="line-modified"> 841   __ testptr(res, res);</span>
<span class="line-modified"> 842   __ jcc(Assembler::zero, *stub-&gt;continuation());</span>


 843 
<a name="94" id="anc94"></a><span class="line-modified"> 844   // Check for object being in the collection set.</span>
<span class="line-added"> 845   __ mov(tmp1, res);</span>
<span class="line-added"> 846   __ shrptr(tmp1, ShenandoahHeapRegion::region_size_bytes_shift_jint());</span>
<span class="line-added"> 847   __ movptr(tmp2, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());</span>
<span class="line-added"> 848 #ifdef _LP64</span>
<span class="line-added"> 849   __ movbool(tmp2, Address(tmp2, tmp1, Address::times_1));</span>
<span class="line-added"> 850   __ testbool(tmp2);</span>
<span class="line-added"> 851 #else</span>
<span class="line-added"> 852   // On x86_32, C1 register allocator can give us the register without 8-bit support.</span>
<span class="line-added"> 853   // Do the full-register access and test to avoid compilation failures.</span>
<span class="line-added"> 854   __ movptr(tmp2, Address(tmp2, tmp1, Address::times_1));</span>
<span class="line-added"> 855   __ testptr(tmp2, 0xFF);</span>
<span class="line-added"> 856 #endif</span>
<span class="line-added"> 857   __ jcc(Assembler::zero, *stub-&gt;continuation());</span>
 858 
<a name="95" id="anc95"></a><span class="line-modified"> 859   __ bind(slow_path);</span>
<span class="line-added"> 860   ce-&gt;store_parameter(res, 0);</span>
<span class="line-added"> 861   ce-&gt;store_parameter(addr, 1);</span>
<span class="line-added"> 862   if (stub-&gt;is_native()) {</span>
<span class="line-added"> 863     __ call(RuntimeAddress(bs-&gt;load_reference_barrier_native_rt_code_blob()-&gt;code_begin()));</span>
<span class="line-added"> 864   } else {</span>
<span class="line-added"> 865     __ call(RuntimeAddress(bs-&gt;load_reference_barrier_rt_code_blob()-&gt;code_begin()));</span>
<span class="line-added"> 866   }</span>
 867   __ jmp(*stub-&gt;continuation());
 868 }
 869 
 870 #undef __
 871 
 872 #define __ sasm-&gt;
 873 
 874 void ShenandoahBarrierSetAssembler::generate_c1_pre_barrier_runtime_stub(StubAssembler* sasm) {
 875   __ prologue(&quot;shenandoah_pre_barrier&quot;, false);
 876   // arg0 : previous value of memory
 877 
 878   __ push(rax);
 879   __ push(rdx);
 880 
 881   const Register pre_val = rax;
 882   const Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);
 883   const Register tmp = rdx;
 884 
 885   NOT_LP64(__ get_thread(thread);)
 886 
 887   Address queue_index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
 888   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
 889 
 890   Label done;
 891   Label runtime;
 892 
 893   // Is SATB still active?
 894   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 895   __ testb(gc_state, ShenandoahHeap::MARKING | ShenandoahHeap::TRAVERSAL);
 896   __ jcc(Assembler::zero, done);
 897 
 898   // Can we store original value in the thread&#39;s buffer?
 899 
 900   __ movptr(tmp, queue_index);
 901   __ testptr(tmp, tmp);
 902   __ jcc(Assembler::zero, runtime);
 903   __ subptr(tmp, wordSize);
 904   __ movptr(queue_index, tmp);
 905   __ addptr(tmp, buffer);
 906 
 907   // prev_val (rax)
 908   __ load_parameter(0, pre_val);
 909   __ movptr(Address(tmp, 0), pre_val);
 910   __ jmp(done);
 911 
 912   __ bind(runtime);
 913 
 914   __ save_live_registers_no_oop_map(true);
 915 
 916   // load the pre-value
 917   __ load_parameter(0, rcx);
 918   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), rcx, thread);
 919 
 920   __ restore_live_registers(true);
 921 
 922   __ bind(done);
 923 
 924   __ pop(rdx);
 925   __ pop(rax);
 926 
 927   __ epilogue();
 928 }
 929 
<a name="96" id="anc96"></a><span class="line-added"> 930 void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native) {</span>
<span class="line-added"> 931   __ prologue(&quot;shenandoah_load_reference_barrier&quot;, false);</span>
<span class="line-added"> 932   // arg0 : object to be resolved</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934   __ save_live_registers_no_oop_map(true);</span>
<span class="line-added"> 935 </span>
<span class="line-added"> 936 #ifdef _LP64</span>
<span class="line-added"> 937   __ load_parameter(0, c_rarg0);</span>
<span class="line-added"> 938   __ load_parameter(1, c_rarg1);</span>
<span class="line-added"> 939   if (is_native) {</span>
<span class="line-added"> 940     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), c_rarg0, c_rarg1);</span>
<span class="line-added"> 941   } else if (UseCompressedOops) {</span>
<span class="line-added"> 942     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), c_rarg0, c_rarg1);</span>
<span class="line-added"> 943   } else {</span>
<span class="line-added"> 944     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), c_rarg0, c_rarg1);</span>
<span class="line-added"> 945   }</span>
<span class="line-added"> 946 #else</span>
<span class="line-added"> 947   __ load_parameter(0, rax);</span>
<span class="line-added"> 948   __ load_parameter(1, rbx);</span>
<span class="line-added"> 949   if (is_native) {</span>
<span class="line-added"> 950     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), rax, rbx);</span>
<span class="line-added"> 951   } else {</span>
<span class="line-added"> 952     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), rax, rbx);</span>
<span class="line-added"> 953   }</span>
<span class="line-added"> 954 #endif</span>
<span class="line-added"> 955 </span>
<span class="line-added"> 956   __ restore_live_registers_except_rax(true);</span>
<span class="line-added"> 957 </span>
<span class="line-added"> 958   __ epilogue();</span>
<span class="line-added"> 959 }</span>
<span class="line-added"> 960 </span>
 961 #undef __
 962 
 963 #endif // COMPILER1
 964 
<a name="97" id="anc97"></a><span class="line-modified"> 965 address ShenandoahBarrierSetAssembler::shenandoah_lrb() {</span>
<span class="line-modified"> 966   assert(_shenandoah_lrb != NULL, &quot;need load reference barrier stub&quot;);</span>
<span class="line-modified"> 967   return _shenandoah_lrb;</span>
 968 }
 969 
 970 #define __ cgen-&gt;assembler()-&gt;
 971 
<a name="98" id="anc98"></a><span class="line-modified"> 972 /*</span>
<span class="line-added"> 973  *  Incoming parameters:</span>
<span class="line-added"> 974  *  rax: oop</span>
<span class="line-added"> 975  *  rsi: load address</span>
<span class="line-added"> 976  */</span>
<span class="line-added"> 977 address ShenandoahBarrierSetAssembler::generate_shenandoah_lrb(StubCodeGenerator* cgen) {</span>
 978   __ align(CodeEntryAlignment);
<a name="99" id="anc99"></a><span class="line-modified"> 979   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_lrb&quot;);</span>
 980   address start = __ pc();
 981 
<a name="100" id="anc100"></a><span class="line-modified"> 982   Label resolve_oop, slow_path;</span>

 983 
 984   // We use RDI, which also serves as argument register for slow call.
<a name="101" id="anc101"></a><span class="line-modified"> 985   // RAX always holds the src object ptr, except after the slow call,</span>
<span class="line-modified"> 986   // then it holds the result. R8/RBX is used as temporary register.</span>
<span class="line-modified"> 987 </span>
<span class="line-modified"> 988   Register tmp1 = rdi;</span>
<span class="line-modified"> 989   Register tmp2 = LP64_ONLY(r8) NOT_LP64(rbx);</span>
<span class="line-modified"> 990 </span>
<span class="line-modified"> 991   __ push(tmp1);</span>
<span class="line-modified"> 992   __ push(tmp2);</span>
<span class="line-modified"> 993 </span>
<span class="line-modified"> 994   // Check for object being in the collection set.</span>
<span class="line-modified"> 995   __ mov(tmp1, rax);</span>
<span class="line-modified"> 996   __ shrptr(tmp1, ShenandoahHeapRegion::region_size_bytes_shift_jint());</span>
<span class="line-modified"> 997   __ movptr(tmp2, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());</span>
<span class="line-modified"> 998   __ movbool(tmp2, Address(tmp2, tmp1, Address::times_1));</span>
<span class="line-modified"> 999   __ testbool(tmp2);</span>
<span class="line-modified">1000   __ jccb(Assembler::notZero, resolve_oop);</span>
<span class="line-modified">1001   __ pop(tmp2);</span>
<span class="line-modified">1002   __ pop(tmp1);</span>
<span class="line-modified">1003   __ ret(0);</span>

1004 
<a name="102" id="anc102"></a><span class="line-modified">1005   // Test if object is already resolved.</span>
<span class="line-modified">1006   __ bind(resolve_oop);</span>
<span class="line-added">1007   __ movptr(tmp2, Address(rax, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">1008   // Test if both lowest bits are set. We trick it by negating the bits</span>
<span class="line-added">1009   // then test for both bits clear.</span>
<span class="line-added">1010   __ notptr(tmp2);</span>
<span class="line-added">1011   __ testb(tmp2, markWord::marked_value);</span>
<span class="line-added">1012   __ jccb(Assembler::notZero, slow_path);</span>
<span class="line-added">1013   // Clear both lower bits. It&#39;s still inverted, so set them, and then invert back.</span>
<span class="line-added">1014   __ orptr(tmp2, markWord::marked_value);</span>
<span class="line-added">1015   __ notptr(tmp2);</span>
<span class="line-added">1016   // At this point, tmp2 contains the decoded forwarding pointer.</span>
<span class="line-added">1017   __ mov(rax, tmp2);</span>
<span class="line-added">1018 </span>
<span class="line-added">1019   __ pop(tmp2);</span>
<span class="line-added">1020   __ pop(tmp1);</span>
1021   __ ret(0);
1022 
<a name="103" id="anc103"></a><span class="line-modified">1023   __ bind(slow_path);</span>
1024 
1025   __ push(rcx);
1026   __ push(rdx);
1027   __ push(rdi);
<a name="104" id="anc104"></a><span class="line-modified">1028 #ifdef _LP64</span>
1029   __ push(r8);
1030   __ push(r9);
1031   __ push(r10);
1032   __ push(r11);
1033   __ push(r12);
1034   __ push(r13);
1035   __ push(r14);
1036   __ push(r15);
<a name="105" id="anc105"></a><span class="line-modified">1037 #endif</span>
<span class="line-modified">1038   __ push(rbp);</span>
<span class="line-modified">1039   __ movptr(rbp, rsp);</span>
<span class="line-modified">1040   __ andptr(rsp, -StackAlignmentInBytes);</span>
<span class="line-added">1041   __ push_FPU_state();</span>
<span class="line-added">1042   if (UseCompressedOops) {</span>
<span class="line-added">1043     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), rax, rsi);</span>
<span class="line-added">1044   } else {</span>
<span class="line-added">1045     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), rax, rsi);</span>
<span class="line-added">1046   }</span>
<span class="line-added">1047   __ pop_FPU_state();</span>
<span class="line-added">1048   __ movptr(rsp, rbp);</span>
<span class="line-added">1049   __ pop(rbp);</span>
<span class="line-added">1050 #ifdef _LP64</span>
1051   __ pop(r15);
1052   __ pop(r14);
1053   __ pop(r13);
1054   __ pop(r12);
1055   __ pop(r11);
1056   __ pop(r10);
1057   __ pop(r9);
1058   __ pop(r8);
<a name="106" id="anc106"></a><span class="line-modified">1059 #endif</span>
1060   __ pop(rdi);
1061   __ pop(rdx);
1062   __ pop(rcx);
1063 
<a name="107" id="anc107"></a><span class="line-modified">1064   __ pop(tmp2);</span>
<span class="line-modified">1065   __ pop(tmp1);</span>
1066   __ ret(0);
<a name="108" id="anc108"></a><span class="line-modified">1067 </span>


1068   return start;
1069 }
1070 
1071 #undef __
1072 
1073 void ShenandoahBarrierSetAssembler::barrier_stubs_init() {
<a name="109" id="anc109"></a><span class="line-modified">1074   if (ShenandoahLoadRefBarrier) {</span>
1075     int stub_code_size = 4096;
1076     ResourceMark rm;
1077     BufferBlob* bb = BufferBlob::create(&quot;shenandoah_barrier_stubs&quot;, stub_code_size);
1078     CodeBuffer buf(bb);
1079     StubCodeGenerator cgen(&amp;buf);
<a name="110" id="anc110"></a><span class="line-modified">1080     _shenandoah_lrb = generate_shenandoah_lrb(&amp;cgen);</span>
1081   }
1082 }
<a name="111" id="anc111"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="111" type="hidden" />
</body>
</html>
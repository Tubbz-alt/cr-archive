<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../shared/modRefBarrierSetAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.</span>

   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  *
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;

  25 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<span class="line-modified">  26 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;</span>

  27 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  28 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  29 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  30 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;interpreter/interp_masm.hpp&quot;
  33 #include &quot;runtime/sharedRuntime.hpp&quot;
  34 #include &quot;runtime/thread.hpp&quot;
  35 #include &quot;utilities/macros.hpp&quot;
  36 #ifdef COMPILER1
  37 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  38 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  39 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
  40 #endif
  41 
  42 #define __ masm-&gt;
  43 
<span class="line-modified">  44 address ShenandoahBarrierSetAssembler::_shenandoah_wb = NULL;</span>
  45 
  46 void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
  47                                                        Register src, Register dst, Register count) {
  48 
<span class="line-removed">  49   bool checkcast = (decorators &amp; ARRAYCOPY_CHECKCAST) != 0;</span>
<span class="line-removed">  50   bool disjoint = (decorators &amp; ARRAYCOPY_DISJOINT) != 0;</span>
<span class="line-removed">  51   bool obj_int = type == T_OBJECT LP64_ONLY(&amp;&amp; UseCompressedOops);</span>
  52   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
  53 
<span class="line-modified">  54   if (type == T_OBJECT || type == T_ARRAY) {</span>


  55 #ifdef _LP64
<span class="line-modified">  56     if (!checkcast &amp;&amp; !obj_int) {</span>
<span class="line-removed">  57       // Save count for barrier</span>
<span class="line-removed">  58       __ movptr(r11, count);</span>
<span class="line-removed">  59     } else if (disjoint &amp;&amp; obj_int) {</span>
<span class="line-removed">  60       // Save dst in r11 in the disjoint case</span>
<span class="line-removed">  61       __ movq(r11, dst);</span>
<span class="line-removed">  62     }</span>
  63 #else
<span class="line-modified">  64     if (disjoint) {</span>
<span class="line-modified">  65       __ mov(rdx, dst);          // save &#39;to&#39;</span>
<span class="line-modified">  66     }</span>
<span class="line-modified">  67 #endif</span>
<span class="line-modified">  68 </span>
<span class="line-modified">  69     if (!dest_uninitialized &amp;&amp; !ShenandoahHeap::heap()-&gt;heuristics()-&gt;can_do_traversal_gc()) {</span>
<span class="line-modified">  70       Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);</span>
<span class="line-modified">  71 #ifndef _LP64</span>


  72       __ push(thread);
  73       __ get_thread(thread);
  74 #endif

  75 
<span class="line-modified">  76       Label filtered;</span>
<span class="line-modified">  77       Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));</span>
<span class="line-modified">  78       // Is marking active?</span>
<span class="line-modified">  79       if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {</span>
<span class="line-removed">  80         __ cmpl(in_progress, 0);</span>
<span class="line-removed">  81       } else {</span>
<span class="line-removed">  82         assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, &quot;Assumption&quot;);</span>
<span class="line-removed">  83         __ cmpb(in_progress, 0);</span>
<span class="line-removed">  84       }</span>
<span class="line-removed">  85 </span>
<span class="line-removed">  86       NOT_LP64(__ pop(thread);)</span>
  87 
<span class="line-modified">  88         __ jcc(Assembler::equal, filtered);</span>







  89 
  90       __ pusha();                      // push registers
  91 #ifdef _LP64
<span class="line-modified">  92       if (count == c_rarg0) {</span>
<span class="line-modified">  93         if (dst == c_rarg1) {</span>
<span class="line-modified">  94           // exactly backwards!!</span>
<span class="line-modified">  95           __ xchgptr(c_rarg1, c_rarg0);</span>


  96         } else {
<span class="line-modified">  97           __ movptr(c_rarg1, count);</span>
<span class="line-removed">  98           __ movptr(c_rarg0, dst);</span>
  99         }
<span class="line-modified"> 100       } else {</span>
<span class="line-removed"> 101         __ movptr(c_rarg0, dst);</span>
<span class="line-removed"> 102         __ movptr(c_rarg1, count);</span>
<span class="line-removed"> 103       }</span>
<span class="line-removed"> 104       if (UseCompressedOops) {</span>
<span class="line-removed"> 105         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_narrow_oop_entry), 2);</span>
<span class="line-removed"> 106       } else {</span>
<span class="line-removed"> 107         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry), 2);</span>
<span class="line-removed"> 108       }</span>
<span class="line-removed"> 109 #else</span>
<span class="line-removed"> 110       __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry),</span>
<span class="line-removed"> 111                       dst, count);</span>
 112 #endif







 113       __ popa();
<span class="line-modified"> 114       __ bind(filtered);</span>

 115     }
 116   }
 117 
 118 }
 119 
<span class="line-removed"> 120 void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,</span>
<span class="line-removed"> 121                                                        Register src, Register dst, Register count) {</span>
<span class="line-removed"> 122   bool checkcast = (decorators &amp; ARRAYCOPY_CHECKCAST) != 0;</span>
<span class="line-removed"> 123   bool disjoint = (decorators &amp; ARRAYCOPY_DISJOINT) != 0;</span>
<span class="line-removed"> 124   bool obj_int = type == T_OBJECT LP64_ONLY(&amp;&amp; UseCompressedOops);</span>
<span class="line-removed"> 125   Register tmp = rax;</span>
<span class="line-removed"> 126 </span>
<span class="line-removed"> 127   if (type == T_OBJECT || type == T_ARRAY) {</span>
<span class="line-removed"> 128 #ifdef _LP64</span>
<span class="line-removed"> 129     if (!checkcast &amp;&amp; !obj_int) {</span>
<span class="line-removed"> 130       // Save count for barrier</span>
<span class="line-removed"> 131       count = r11;</span>
<span class="line-removed"> 132     } else if (disjoint &amp;&amp; obj_int) {</span>
<span class="line-removed"> 133       // Use the saved dst in the disjoint case</span>
<span class="line-removed"> 134       dst = r11;</span>
<span class="line-removed"> 135     } else if (checkcast) {</span>
<span class="line-removed"> 136       tmp = rscratch1;</span>
<span class="line-removed"> 137     }</span>
<span class="line-removed"> 138 #else</span>
<span class="line-removed"> 139     if (disjoint) {</span>
<span class="line-removed"> 140       __ mov(dst, rdx); // restore &#39;to&#39;</span>
<span class="line-removed"> 141     }</span>
<span class="line-removed"> 142 #endif</span>
<span class="line-removed"> 143 </span>
<span class="line-removed"> 144     __ pusha();             // push registers (overkill)</span>
<span class="line-removed"> 145 #ifdef _LP64</span>
<span class="line-removed"> 146     if (c_rarg0 == count) { // On win64 c_rarg0 == rcx</span>
<span class="line-removed"> 147       assert_different_registers(c_rarg1, dst);</span>
<span class="line-removed"> 148       __ mov(c_rarg1, count);</span>
<span class="line-removed"> 149       __ mov(c_rarg0, dst);</span>
<span class="line-removed"> 150     } else {</span>
<span class="line-removed"> 151       assert_different_registers(c_rarg0, count);</span>
<span class="line-removed"> 152       __ mov(c_rarg0, dst);</span>
<span class="line-removed"> 153       __ mov(c_rarg1, count);</span>
<span class="line-removed"> 154     }</span>
<span class="line-removed"> 155     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_post_entry), 2);</span>
<span class="line-removed"> 156 #else</span>
<span class="line-removed"> 157     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_post_entry),</span>
<span class="line-removed"> 158                     dst, count);</span>
<span class="line-removed"> 159 #endif</span>
<span class="line-removed"> 160     __ popa();</span>
<span class="line-removed"> 161   }</span>
<span class="line-removed"> 162 }</span>
<span class="line-removed"> 163 </span>
 164 void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
 165                                                                  Register obj,
 166                                                                  Register pre_val,
 167                                                                  Register thread,
 168                                                                  Register tmp,
 169                                                                  bool tosca_live,
 170                                                                  bool expand_call) {
 171 
 172   if (ShenandoahSATBBarrier) {
 173     satb_write_barrier_pre(masm, obj, pre_val, thread, tmp, tosca_live, expand_call);
 174   }
 175 }
 176 
 177 void ShenandoahBarrierSetAssembler::satb_write_barrier_pre(MacroAssembler* masm,
 178                                                            Register obj,
 179                                                            Register pre_val,
 180                                                            Register thread,
 181                                                            Register tmp,
 182                                                            bool tosca_live,
 183                                                            bool expand_call) {
</pre>
<hr />
<pre>
 279 #endif
 280     __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), 2);
 281   } else {
 282     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), LP64_ONLY(c_rarg0) NOT_LP64(pre_val), thread);
 283   }
 284 
 285   NOT_LP64( __ pop(thread); )
 286 
 287   // save the live input values
 288   if (pre_val != rax)
 289     __ pop(pre_val);
 290 
 291   if (obj != noreg &amp;&amp; obj != rax)
 292     __ pop(obj);
 293 
 294   if(tosca_live) __ pop(rax);
 295 
 296   __ bind(done);
 297 }
 298 
<span class="line-modified"> 299 void ShenandoahBarrierSetAssembler::read_barrier(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified"> 300   if (ShenandoahReadBarrier) {</span>
<span class="line-removed"> 301     read_barrier_impl(masm, dst);</span>
<span class="line-removed"> 302   }</span>
<span class="line-removed"> 303 }</span>
 304 
<span class="line-modified"> 305 void ShenandoahBarrierSetAssembler::read_barrier_impl(MacroAssembler* masm, Register dst) {</span>
<span class="line-removed"> 306   assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier || ShenandoahCASBarrier), &quot;should be enabled&quot;);</span>
<span class="line-removed"> 307   Label is_null;</span>
<span class="line-removed"> 308   __ testptr(dst, dst);</span>
<span class="line-removed"> 309   __ jcc(Assembler::zero, is_null);</span>
<span class="line-removed"> 310   read_barrier_not_null_impl(masm, dst);</span>
<span class="line-removed"> 311   __ bind(is_null);</span>
<span class="line-removed"> 312 }</span>
 313 
<span class="line-modified"> 314 void ShenandoahBarrierSetAssembler::read_barrier_not_null(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified"> 315   if (ShenandoahReadBarrier) {</span>
<span class="line-modified"> 316     read_barrier_not_null_impl(masm, dst);</span>



 317   }
<span class="line-modified"> 318 }</span>


 319 
<span class="line-modified"> 320 void ShenandoahBarrierSetAssembler::read_barrier_not_null_impl(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified"> 321   assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier || ShenandoahCASBarrier), &quot;should be enabled&quot;);</span>
<span class="line-modified"> 322   __ movptr(dst, Address(dst, ShenandoahBrooksPointer::byte_offset()));</span>
<span class="line-modified"> 323 }</span>








 324 









 325 
<span class="line-modified"> 326 void ShenandoahBarrierSetAssembler::write_barrier(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified"> 327   if (ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 328     write_barrier_impl(masm, dst);</span>
 329   }



















 330 }
 331 
<span class="line-modified"> 332 void ShenandoahBarrierSetAssembler::write_barrier_impl(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified"> 333   assert(UseShenandoahGC &amp;&amp; (ShenandoahWriteBarrier || ShenandoahStoreValEnqueueBarrier), &quot;Should be enabled&quot;);</span>
<span class="line-modified"> 334 #ifdef _LP64</span>


 335   Label done;



 336 
<span class="line-modified"> 337   Address gc_state(r15_thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-modified"> 338   __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);</span>
<span class="line-modified"> 339   __ jccb(Assembler::zero, done);</span>


 340 
<span class="line-removed"> 341   // Heap is unstable, need to perform the read-barrier even if WB is inactive</span>
<span class="line-removed"> 342   read_barrier_not_null(masm, dst);</span>
 343 
<span class="line-modified"> 344   __ testb(gc_state, ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);</span>
<span class="line-modified"> 345   __ jccb(Assembler::zero, done);</span>




































 346 
<span class="line-modified"> 347    if (dst != rax) {</span>
<span class="line-modified"> 348      __ xchgptr(dst, rax); // Move obj into rax and save rax into obj.</span>
<span class="line-modified"> 349    }</span>
 350 
<span class="line-modified"> 351    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_wb())));</span>













 352 
<span class="line-modified"> 353    if (dst != rax) {</span>
<span class="line-modified"> 354      __ xchgptr(rax, dst); // Swap back obj with rax.</span>
<span class="line-modified"> 355    }</span>

 356 
 357   __ bind(done);
<span class="line-modified"> 358 #else</span>
<span class="line-removed"> 359   Unimplemented();</span>
<span class="line-removed"> 360 #endif</span>
 361 }
 362 
 363 void ShenandoahBarrierSetAssembler::storeval_barrier(MacroAssembler* masm, Register dst, Register tmp) {
<span class="line-modified"> 364   if (ShenandoahStoreValReadBarrier || ShenandoahStoreValEnqueueBarrier) {</span>
 365     storeval_barrier_impl(masm, dst, tmp);
 366   }
 367 }
 368 
 369 void ShenandoahBarrierSetAssembler::storeval_barrier_impl(MacroAssembler* masm, Register dst, Register tmp) {
<span class="line-modified"> 370   assert(UseShenandoahGC &amp;&amp; (ShenandoahStoreValReadBarrier || ShenandoahStoreValEnqueueBarrier), &quot;should be enabled&quot;);</span>
 371 
 372   if (dst == noreg) return;
 373 
<span class="line-removed"> 374 #ifdef _LP64</span>
 375   if (ShenandoahStoreValEnqueueBarrier) {
<span class="line-removed"> 376     Label is_null;</span>
<span class="line-removed"> 377     __ testptr(dst, dst);</span>
<span class="line-removed"> 378     __ jcc(Assembler::zero, is_null);</span>
<span class="line-removed"> 379     write_barrier_impl(masm, dst);</span>
<span class="line-removed"> 380     __ bind(is_null);</span>
<span class="line-removed"> 381 </span>
 382     // The set of registers to be saved+restored is the same as in the write-barrier above.
 383     // Those are the commonly used registers in the interpreter.
 384     __ pusha();
 385     // __ push_callee_saved_registers();
 386     __ subptr(rsp, 2 * Interpreter::stackElementSize);
 387     __ movdbl(Address(rsp, 0), xmm0);
 388 
<span class="line-modified"> 389     satb_write_barrier_pre(masm, noreg, dst, r15_thread, tmp, true, false);</span>














 390     __ movdbl(xmm0, Address(rsp, 0));
 391     __ addptr(rsp, 2 * Interpreter::stackElementSize);
 392     //__ pop_callee_saved_registers();
 393     __ popa();
 394   }
<span class="line-modified"> 395   if (ShenandoahStoreValReadBarrier) {</span>
<span class="line-modified"> 396     read_barrier_impl(masm, dst);</span>







 397   }
<span class="line-removed"> 398 #else</span>
<span class="line-removed"> 399   Unimplemented();</span>
<span class="line-removed"> 400 #endif</span>
 401 }
 402 













 403 void ShenandoahBarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
 404              Register dst, Address src, Register tmp1, Register tmp_thread) {
<span class="line-modified"> 405   bool on_oop = type == T_OBJECT || type == T_ARRAY;</span>
<span class="line-modified"> 406   bool in_heap = (decorators &amp; IN_HEAP) != 0;</span>
<span class="line-modified"> 407   bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;</span>
<span class="line-modified"> 408   bool on_phantom = (decorators &amp; ON_PHANTOM_OOP_REF) != 0;</span>
<span class="line-modified"> 409   bool on_reference = on_weak || on_phantom;</span>
<span class="line-modified"> 410   if (in_heap) {</span>
<span class="line-modified"> 411     read_barrier_not_null(masm, src.base());</span>
<span class="line-removed"> 412   }</span>
<span class="line-removed"> 413   BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-removed"> 414   if (ShenandoahKeepAliveBarrier &amp;&amp; on_oop &amp;&amp; on_reference) {</span>
<span class="line-removed"> 415     const Register thread = NOT_LP64(tmp_thread) LP64_ONLY(r15_thread);</span>
<span class="line-removed"> 416     NOT_LP64(__ get_thread(thread));</span>
 417 






























































 418     // Generate the SATB pre-barrier code to log the value of
 419     // the referent field in an SATB buffer.
 420     shenandoah_write_barrier_pre(masm /* masm */,
 421                                  noreg /* obj */,
 422                                  dst /* pre_val */,
 423                                  thread /* thread */,
 424                                  tmp1 /* tmp */,
 425                                  true /* tosca_live */,
 426                                  true /* expand_call */);










 427   }
 428 }
 429 
 430 void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
 431               Address dst, Register val, Register tmp1, Register tmp2) {
 432 

 433   bool in_heap = (decorators &amp; IN_HEAP) != 0;
 434   bool as_normal = (decorators &amp; AS_NORMAL) != 0;
<span class="line-modified"> 435   if (in_heap) {</span>
<span class="line-removed"> 436     write_barrier(masm, dst.base());</span>
<span class="line-removed"> 437   }</span>
<span class="line-removed"> 438   if (type == T_OBJECT || type == T_ARRAY) {</span>
 439     bool needs_pre_barrier = as_normal;
 440 
 441     Register tmp3 = LP64_ONLY(r8) NOT_LP64(rsi);
 442     Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
 443     // flatten object address if needed
 444     // We do it regardless of precise because we need the registers
 445     if (dst.index() == noreg &amp;&amp; dst.disp() == 0) {
 446       if (dst.base() != tmp1) {
 447         __ movptr(tmp1, dst.base());
 448       }
 449     } else {
 450       __ lea(tmp1, dst);
 451     }
 452 


 453 #ifndef _LP64

 454     InterpreterMacroAssembler *imasm = static_cast&lt;InterpreterMacroAssembler*&gt;(masm);

 455 #endif
 456 
<span class="line-removed"> 457     NOT_LP64(__ get_thread(rcx));</span>
<span class="line-removed"> 458     NOT_LP64(imasm-&gt;save_bcp());</span>
<span class="line-removed"> 459 </span>
 460     if (needs_pre_barrier) {
 461       shenandoah_write_barrier_pre(masm /*masm*/,
 462                                    tmp1 /* obj */,
 463                                    tmp2 /* pre_val */,
 464                                    rthread /* thread */,
 465                                    tmp3  /* tmp */,
 466                                    val != noreg /* tosca_live */,
 467                                    false /* expand_call */);
 468     }
 469     if (val == noreg) {
 470       BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg);
 471     } else {
 472       storeval_barrier(masm, val, tmp3);
 473       BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg);
 474     }
 475     NOT_LP64(imasm-&gt;restore_bcp());
 476   } else {
 477     BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);
 478   }
 479 }
 480 
<span class="line-modified"> 481 #ifndef _LP64</span>
<span class="line-modified"> 482 void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm,</span>
<span class="line-modified"> 483                                                Address obj1, jobject obj2) {</span>
<span class="line-modified"> 484   Unimplemented();</span>
<span class="line-modified"> 485 }</span>
<span class="line-removed"> 486 </span>
<span class="line-removed"> 487 void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm,</span>
<span class="line-removed"> 488                                                Register obj1, jobject obj2) {</span>
<span class="line-removed"> 489   Unimplemented();</span>
<span class="line-removed"> 490 }</span>
<span class="line-removed"> 491 #endif</span>
<span class="line-removed"> 492 </span>
<span class="line-removed"> 493 </span>
<span class="line-removed"> 494 void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm, Register op1, Register op2) {</span>
<span class="line-removed"> 495   __ cmpptr(op1, op2);</span>
<span class="line-removed"> 496   if (ShenandoahAcmpBarrier) {</span>
<span class="line-removed"> 497     Label done;</span>
<span class="line-removed"> 498     __ jccb(Assembler::equal, done);</span>
<span class="line-removed"> 499     read_barrier(masm, op1);</span>
<span class="line-removed"> 500     read_barrier(masm, op2);</span>
<span class="line-removed"> 501     __ cmpptr(op1, op2);</span>
<span class="line-removed"> 502     __ bind(done);</span>
<span class="line-removed"> 503   }</span>
<span class="line-removed"> 504 }</span>
<span class="line-removed"> 505 </span>
<span class="line-removed"> 506 void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm, Register src1, Address src2) {</span>
<span class="line-removed"> 507   __ cmpptr(src1, src2);</span>
<span class="line-removed"> 508   if (ShenandoahAcmpBarrier) {</span>
<span class="line-removed"> 509     Label done;</span>
<span class="line-removed"> 510     __ jccb(Assembler::equal, done);</span>
<span class="line-removed"> 511     __ movptr(rscratch2, src2);</span>
<span class="line-removed"> 512     read_barrier(masm, src1);</span>
<span class="line-removed"> 513     read_barrier(masm, rscratch2);</span>
<span class="line-removed"> 514     __ cmpptr(src1, rscratch2);</span>
<span class="line-removed"> 515     __ bind(done);</span>
<span class="line-removed"> 516   }</span>
<span class="line-removed"> 517 }</span>
<span class="line-removed"> 518 </span>
<span class="line-removed"> 519 void ShenandoahBarrierSetAssembler::tlab_allocate(MacroAssembler* masm,</span>
<span class="line-removed"> 520                                                   Register thread, Register obj,</span>
<span class="line-removed"> 521                                                   Register var_size_in_bytes,</span>
<span class="line-removed"> 522                                                   int con_size_in_bytes,</span>
<span class="line-removed"> 523                                                   Register t1, Register t2,</span>
<span class="line-removed"> 524                                                   Label&amp; slow_case) {</span>
<span class="line-removed"> 525   assert_different_registers(obj, t1, t2);</span>
<span class="line-removed"> 526   assert_different_registers(obj, var_size_in_bytes, t1);</span>
<span class="line-removed"> 527   Register end = t2;</span>
<span class="line-removed"> 528   if (!thread-&gt;is_valid()) {</span>
<span class="line-removed"> 529 #ifdef _LP64</span>
<span class="line-removed"> 530     thread = r15_thread;</span>
<span class="line-removed"> 531 #else</span>
<span class="line-removed"> 532     assert(t1-&gt;is_valid(), &quot;need temp reg&quot;);</span>
<span class="line-removed"> 533     thread = t1;</span>
<span class="line-removed"> 534     __ get_thread(thread);</span>
<span class="line-removed"> 535 #endif</span>
<span class="line-removed"> 536   }</span>
<span class="line-removed"> 537 </span>
<span class="line-removed"> 538   __ verify_tlab();</span>
<span class="line-removed"> 539 </span>
<span class="line-removed"> 540   __ movptr(obj, Address(thread, JavaThread::tlab_top_offset()));</span>
<span class="line-removed"> 541   if (var_size_in_bytes == noreg) {</span>
<span class="line-removed"> 542     __ lea(end, Address(obj, con_size_in_bytes + ShenandoahBrooksPointer::byte_size()));</span>
<span class="line-removed"> 543   } else {</span>
<span class="line-removed"> 544     __ addptr(var_size_in_bytes, ShenandoahBrooksPointer::byte_size());</span>
<span class="line-removed"> 545     __ lea(end, Address(obj, var_size_in_bytes, Address::times_1));</span>
<span class="line-removed"> 546   }</span>
<span class="line-removed"> 547   __ cmpptr(end, Address(thread, JavaThread::tlab_end_offset()));</span>
<span class="line-removed"> 548   __ jcc(Assembler::above, slow_case);</span>
<span class="line-removed"> 549 </span>
<span class="line-removed"> 550   // update the tlab top pointer</span>
<span class="line-removed"> 551   __ movptr(Address(thread, JavaThread::tlab_top_offset()), end);</span>
<span class="line-removed"> 552 </span>
<span class="line-removed"> 553   // Initialize brooks pointer</span>
<span class="line-removed"> 554 #ifdef _LP64</span>
<span class="line-removed"> 555   __ incrementq(obj, ShenandoahBrooksPointer::byte_size());</span>
<span class="line-removed"> 556 #else</span>
<span class="line-removed"> 557   __ incrementl(obj, ShenandoahBrooksPointer::byte_size());</span>
<span class="line-removed"> 558 #endif</span>
<span class="line-removed"> 559   __ movptr(Address(obj, ShenandoahBrooksPointer::byte_offset()), obj);</span>
 560 
<span class="line-modified"> 561   // recover var_size_in_bytes if necessary</span>
<span class="line-modified"> 562   if (var_size_in_bytes == end) {</span>
<span class="line-modified"> 563     __ subptr(var_size_in_bytes, obj);</span>
<span class="line-removed"> 564   }</span>
<span class="line-removed"> 565   __ verify_tlab();</span>
<span class="line-removed"> 566 }</span>
 567 
<span class="line-modified"> 568 void ShenandoahBarrierSetAssembler::resolve(MacroAssembler* masm, DecoratorSet decorators, Register obj) {</span>
<span class="line-modified"> 569   bool oop_not_null = (decorators &amp; IS_NOT_NULL) != 0;</span>
<span class="line-modified"> 570   bool is_write = (decorators &amp; ACCESS_WRITE) != 0;</span>
<span class="line-modified"> 571   if (is_write) {</span>
<span class="line-removed"> 572     if (oop_not_null) {</span>
<span class="line-removed"> 573       write_barrier(masm, obj);</span>
<span class="line-removed"> 574     } else {</span>
<span class="line-removed"> 575       Label done;</span>
<span class="line-removed"> 576       __ testptr(obj, obj);</span>
<span class="line-removed"> 577       __ jcc(Assembler::zero, done);</span>
<span class="line-removed"> 578       write_barrier(masm, obj);</span>
<span class="line-removed"> 579       __ bind(done);</span>
<span class="line-removed"> 580     }</span>
<span class="line-removed"> 581   } else {</span>
<span class="line-removed"> 582     if (oop_not_null) {</span>
<span class="line-removed"> 583       read_barrier_not_null(masm, obj);</span>
<span class="line-removed"> 584     } else {</span>
<span class="line-removed"> 585       read_barrier(masm, obj);</span>
<span class="line-removed"> 586     }</span>
<span class="line-removed"> 587   }</span>
 588 }
 589 
 590 // Special Shenandoah CAS implementation that handles false negatives
 591 // due to concurrent evacuation.
<span class="line-removed"> 592 #ifndef _LP64</span>
<span class="line-removed"> 593 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm,</span>
<span class="line-removed"> 594                                                 Register res, Address addr, Register oldval, Register newval,</span>
<span class="line-removed"> 595                                                 bool exchange, Register tmp1, Register tmp2) {</span>
<span class="line-removed"> 596   // Shenandoah has no 32-bit version for this.</span>
<span class="line-removed"> 597   Unimplemented();</span>
<span class="line-removed"> 598 }</span>
<span class="line-removed"> 599 #else</span>
 600 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm,
 601                                                 Register res, Address addr, Register oldval, Register newval,
 602                                                 bool exchange, Register tmp1, Register tmp2) {
 603   assert(ShenandoahCASBarrier, &quot;Should only be used when CAS barrier is enabled&quot;);
 604   assert(oldval == rax, &quot;must be in rax for implicit use in cmpxchg&quot;);

 605 
<span class="line-modified"> 606   Label retry, done;</span>
 607 
 608   // Remember oldval for retry logic below

 609   if (UseCompressedOops) {
 610     __ movl(tmp1, oldval);
<span class="line-modified"> 611   } else {</span>


 612     __ movptr(tmp1, oldval);
 613   }
 614 
<span class="line-modified"> 615   // Step 1. Try to CAS with given arguments. If successful, then we are done,</span>
<span class="line-modified"> 616   // and can safely return.</span>


 617   if (os::is_MP()) __ lock();

 618   if (UseCompressedOops) {
 619     __ cmpxchgl(newval, addr);
<span class="line-modified"> 620   } else {</span>


 621     __ cmpxchgptr(newval, addr);
 622   }
<span class="line-modified"> 623   __ jcc(Assembler::equal, done, true);</span>
 624 
 625   // Step 2. CAS had failed. This may be a false negative.
 626   //
 627   // The trouble comes when we compare the to-space pointer with the from-space
<span class="line-modified"> 628   // pointer to the same object. To resolve this, it will suffice to read both</span>
<span class="line-modified"> 629   // oldval and the value from memory through the read barriers -- this will give</span>
<span class="line-modified"> 630   // both to-space pointers. If they mismatch, then it was a legitimate failure.</span>
 631   //
<span class="line-modified"> 632   if (UseCompressedOops) {</span>
<span class="line-modified"> 633     __ decode_heap_oop(tmp1);</span>
<span class="line-modified"> 634   }</span>
<span class="line-modified"> 635   read_barrier_impl(masm, tmp1);</span>













 636 

 637   if (UseCompressedOops) {
 638     __ movl(tmp2, oldval);
 639     __ decode_heap_oop(tmp2);
<span class="line-modified"> 640   } else {</span>


 641     __ movptr(tmp2, oldval);
 642   }
<span class="line-removed"> 643   read_barrier_impl(masm, tmp2);</span>
 644 
<span class="line-modified"> 645   __ cmpptr(tmp1, tmp2);</span>
<span class="line-modified"> 646   __ jcc(Assembler::notEqual, done, true);</span>



 647 
<span class="line-modified"> 648   // Step 3. Try to CAS again with resolved to-space pointers.</span>
<span class="line-modified"> 649   //</span>
<span class="line-modified"> 650   // Corner case: it may happen that somebody stored the from-space pointer</span>
<span class="line-modified"> 651   // to memory while we were preparing for retry. Therefore, we can fail again</span>
<span class="line-removed"> 652   // on retry, and so need to do this in loop, always re-reading the failure</span>
<span class="line-removed"> 653   // witness through the read barrier.</span>
<span class="line-removed"> 654   __ bind(retry);</span>
<span class="line-removed"> 655   if (os::is_MP()) __ lock();</span>
<span class="line-removed"> 656   if (UseCompressedOops) {</span>
<span class="line-removed"> 657     __ cmpxchgl(newval, addr);</span>
<span class="line-removed"> 658   } else {</span>
<span class="line-removed"> 659     __ cmpxchgptr(newval, addr);</span>
<span class="line-removed"> 660   }</span>
<span class="line-removed"> 661   __ jcc(Assembler::equal, done, true);</span>
 662 

 663   if (UseCompressedOops) {
<span class="line-modified"> 664     __ movl(tmp2, oldval);</span>
<span class="line-removed"> 665     __ decode_heap_oop(tmp2);</span>
<span class="line-removed"> 666   } else {</span>
<span class="line-removed"> 667     __ movptr(tmp2, oldval);</span>
 668   }
<span class="line-modified"> 669   read_barrier_impl(masm, tmp2);</span>
 670 


 671   __ cmpptr(tmp1, tmp2);
<span class="line-modified"> 672   __ jcc(Assembler::equal, retry, true);</span>
 673 
<span class="line-modified"> 674   // Step 4. If we need a boolean result out of CAS, check the flag again,</span>
<span class="line-modified"> 675   // and promote the result. Note that we handle the flag from both the CAS</span>
<span class="line-modified"> 676   // itself and from the retry loop.</span>
<span class="line-modified"> 677   __ bind(done);</span>
<span class="line-modified"> 678   if (!exchange) {</span>
<span class="line-modified"> 679     assert(res != NULL, &quot;need result register&quot;);</span>
<span class="line-modified"> 680     __ setb(Assembler::equal, res);</span>
<span class="line-modified"> 681     __ movzbl(res, res);</span>
<span class="line-removed"> 682   }</span>
<span class="line-removed"> 683 }</span>
<span class="line-removed"> 684 #endif // LP64</span>
 685 
<span class="line-modified"> 686 void ShenandoahBarrierSetAssembler::save_vector_registers(MacroAssembler* masm) {</span>
<span class="line-modified"> 687   int num_xmm_regs = LP64_ONLY(16) NOT_LP64(8);</span>
<span class="line-modified"> 688   if (UseAVX &gt; 2) {</span>
<span class="line-removed"> 689     num_xmm_regs = LP64_ONLY(32) NOT_LP64(8);</span>
 690   }
<span class="line-removed"> 691 </span>
<span class="line-removed"> 692   if (UseSSE == 1)  {</span>
<span class="line-removed"> 693     __ subptr(rsp, sizeof(jdouble)*8);</span>
<span class="line-removed"> 694     for (int n = 0; n &lt; 8; n++) {</span>
<span class="line-removed"> 695       __ movflt(Address(rsp, n*sizeof(jdouble)), as_XMMRegister(n));</span>
<span class="line-removed"> 696     }</span>
<span class="line-removed"> 697   } else if (UseSSE &gt;= 2)  {</span>
<span class="line-removed"> 698     if (UseAVX &gt; 2) {</span>
<span class="line-removed"> 699       __ push(rbx);</span>
<span class="line-removed"> 700       __ movl(rbx, 0xffff);</span>
<span class="line-removed"> 701       __ kmovwl(k1, rbx);</span>
<span class="line-removed"> 702       __ pop(rbx);</span>
<span class="line-removed"> 703     }</span>
<span class="line-removed"> 704 #ifdef COMPILER2</span>
<span class="line-removed"> 705     if (MaxVectorSize &gt; 16) {</span>
<span class="line-removed"> 706       if(UseAVX &gt; 2) {</span>
<span class="line-removed"> 707         // Save upper half of ZMM registers</span>
<span class="line-removed"> 708         __ subptr(rsp, 32*num_xmm_regs);</span>
<span class="line-removed"> 709         for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed"> 710           __ vextractf64x4_high(Address(rsp, n*32), as_XMMRegister(n));</span>
<span class="line-removed"> 711         }</span>
<span class="line-removed"> 712       }</span>
<span class="line-removed"> 713       assert(UseAVX &gt; 0, &quot;256 bit vectors are supported only with AVX&quot;);</span>
<span class="line-removed"> 714       // Save upper half of YMM registers</span>
<span class="line-removed"> 715       __ subptr(rsp, 16*num_xmm_regs);</span>
<span class="line-removed"> 716       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed"> 717         __ vextractf128_high(Address(rsp, n*16), as_XMMRegister(n));</span>
<span class="line-removed"> 718       }</span>
<span class="line-removed"> 719     }</span>
 720 #endif
<span class="line-modified"> 721     // Save whole 128bit (16 bytes) XMM registers</span>
<span class="line-modified"> 722     __ subptr(rsp, 16*num_xmm_regs);</span>
 723 #ifdef _LP64
<span class="line-modified"> 724     if (VM_Version::supports_evex()) {</span>
<span class="line-modified"> 725       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-modified"> 726         __ vextractf32x4(Address(rsp, n*16), as_XMMRegister(n), 0);</span>
<span class="line-removed"> 727       }</span>
<span class="line-removed"> 728     } else {</span>
<span class="line-removed"> 729       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed"> 730         __ movdqu(Address(rsp, n*16), as_XMMRegister(n));</span>
<span class="line-removed"> 731       }</span>
<span class="line-removed"> 732     }</span>
<span class="line-removed"> 733 #else</span>
<span class="line-removed"> 734     for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed"> 735       __ movdqu(Address(rsp, n*16), as_XMMRegister(n));</span>
<span class="line-removed"> 736     }</span>
 737 #endif


 738   }
<span class="line-removed"> 739 }</span>
 740 
<span class="line-modified"> 741 void ShenandoahBarrierSetAssembler::restore_vector_registers(MacroAssembler* masm) {</span>
<span class="line-modified"> 742   int num_xmm_regs = LP64_ONLY(16) NOT_LP64(8);</span>
<span class="line-modified"> 743   if (UseAVX &gt; 2) {</span>
<span class="line-modified"> 744     num_xmm_regs = LP64_ONLY(32) NOT_LP64(8);</span>
<span class="line-modified"> 745   }</span>
<span class="line-modified"> 746   if (UseSSE == 1)  {</span>
<span class="line-modified"> 747     for (int n = 0; n &lt; 8; n++) {</span>
<span class="line-removed"> 748       __ movflt(as_XMMRegister(n), Address(rsp, n*sizeof(jdouble)));</span>
<span class="line-removed"> 749     }</span>
<span class="line-removed"> 750     __ addptr(rsp, sizeof(jdouble)*8);</span>
<span class="line-removed"> 751   } else if (UseSSE &gt;= 2)  {</span>
<span class="line-removed"> 752     // Restore whole 128bit (16 bytes) XMM registers</span>
 753 #ifdef _LP64
<span class="line-modified"> 754     if (VM_Version::supports_evex()) {</span>
<span class="line-modified"> 755       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-modified"> 756         __ vinsertf32x4(as_XMMRegister(n), as_XMMRegister(n), Address(rsp, n*16), 0);</span>
<span class="line-removed"> 757       }</span>
<span class="line-removed"> 758     } else {</span>
<span class="line-removed"> 759       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed"> 760         __ movdqu(as_XMMRegister(n), Address(rsp, n*16));</span>
<span class="line-removed"> 761       }</span>
<span class="line-removed"> 762     }</span>
<span class="line-removed"> 763 #else</span>
<span class="line-removed"> 764     for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed"> 765       __ movdqu(as_XMMRegister(n), Address(rsp, n*16));</span>
<span class="line-removed"> 766     }</span>
 767 #endif
<span class="line-modified"> 768     __ addptr(rsp, 16*num_xmm_regs);</span>


 769 
<span class="line-modified"> 770 #ifdef COMPILER2</span>
<span class="line-modified"> 771     if (MaxVectorSize &gt; 16) {</span>
<span class="line-modified"> 772       // Restore upper half of YMM registers.</span>
<span class="line-modified"> 773       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-modified"> 774         __ vinsertf128_high(as_XMMRegister(n), Address(rsp, n*16));</span>
<span class="line-removed"> 775       }</span>
<span class="line-removed"> 776       __ addptr(rsp, 16*num_xmm_regs);</span>
<span class="line-removed"> 777       if (UseAVX &gt; 2) {</span>
<span class="line-removed"> 778         for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed"> 779           __ vinsertf64x4_high(as_XMMRegister(n), Address(rsp, n*32));</span>
<span class="line-removed"> 780         }</span>
<span class="line-removed"> 781         __ addptr(rsp, 32*num_xmm_regs);</span>
<span class="line-removed"> 782       }</span>
<span class="line-removed"> 783     }</span>
 784 #endif

























 785   }
 786 }
 787 


 788 #ifdef COMPILER1
 789 
<span class="line-removed"> 790 #undef __</span>
 791 #define __ ce-&gt;masm()-&gt;
 792 
 793 void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
 794   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
 795   // At this point we know that marking is in progress.
 796   // If do_load() is true then we have to emit the
 797   // load of the previous value; otherwise it has already
 798   // been loaded into _pre_val.
 799 
 800   __ bind(*stub-&gt;entry());
 801   assert(stub-&gt;pre_val()-&gt;is_register(), &quot;Precondition.&quot;);
 802 
 803   Register pre_val_reg = stub-&gt;pre_val()-&gt;as_register();
 804 
 805   if (stub-&gt;do_load()) {
 806     ce-&gt;mem2reg(stub-&gt;addr(), stub-&gt;pre_val(), T_OBJECT, stub-&gt;patch_code(), stub-&gt;info(), false /*wide*/, false /*unaligned*/);
 807   }
 808 
 809   __ cmpptr(pre_val_reg, (int32_t)NULL_WORD);
 810   __ jcc(Assembler::equal, *stub-&gt;continuation());
 811   ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
 812   __ call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
 813   __ jmp(*stub-&gt;continuation());
 814 
 815 }
 816 
<span class="line-modified"> 817 void ShenandoahBarrierSetAssembler::gen_write_barrier_stub(LIR_Assembler* ce, ShenandoahWriteBarrierStub* stub) {</span>

 818   __ bind(*stub-&gt;entry());
 819 
<span class="line-removed"> 820   Label done;</span>
 821   Register obj = stub-&gt;obj()-&gt;as_register();
 822   Register res = stub-&gt;result()-&gt;as_register();








 823 
 824   if (res != obj) {
 825     __ mov(res, obj);
 826   }
 827 
 828   // Check for null.
<span class="line-modified"> 829   if (stub-&gt;needs_null_check()) {</span>
<span class="line-modified"> 830     __ testptr(res, res);</span>
<span class="line-removed"> 831     __ jcc(Assembler::zero, done);</span>
<span class="line-removed"> 832   }</span>
 833 
<span class="line-modified"> 834   write_barrier(ce-&gt;masm(), res);</span>













 835 
<span class="line-modified"> 836   __ bind(done);</span>







 837   __ jmp(*stub-&gt;continuation());
 838 }
 839 
 840 #undef __
 841 
 842 #define __ sasm-&gt;
 843 
 844 void ShenandoahBarrierSetAssembler::generate_c1_pre_barrier_runtime_stub(StubAssembler* sasm) {
 845   __ prologue(&quot;shenandoah_pre_barrier&quot;, false);
 846   // arg0 : previous value of memory
 847 
 848   __ push(rax);
 849   __ push(rdx);
 850 
 851   const Register pre_val = rax;
 852   const Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);
 853   const Register tmp = rdx;
 854 
 855   NOT_LP64(__ get_thread(thread);)
 856 
</pre>
<hr />
<pre>
 880   __ jmp(done);
 881 
 882   __ bind(runtime);
 883 
 884   __ save_live_registers_no_oop_map(true);
 885 
 886   // load the pre-value
 887   __ load_parameter(0, rcx);
 888   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), rcx, thread);
 889 
 890   __ restore_live_registers(true);
 891 
 892   __ bind(done);
 893 
 894   __ pop(rdx);
 895   __ pop(rax);
 896 
 897   __ epilogue();
 898 }
 899 































 900 #undef __
 901 
 902 #endif // COMPILER1
 903 
<span class="line-modified"> 904 address ShenandoahBarrierSetAssembler::shenandoah_wb() {</span>
<span class="line-modified"> 905   assert(_shenandoah_wb != NULL, &quot;need write barrier stub&quot;);</span>
<span class="line-modified"> 906   return _shenandoah_wb;</span>
 907 }
 908 
 909 #define __ cgen-&gt;assembler()-&gt;
 910 
<span class="line-modified"> 911 address ShenandoahBarrierSetAssembler::generate_shenandoah_wb(StubCodeGenerator* cgen) {</span>





 912   __ align(CodeEntryAlignment);
<span class="line-modified"> 913   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_wb&quot;);</span>
 914   address start = __ pc();
 915 
<span class="line-modified"> 916 #ifdef _LP64</span>
<span class="line-removed"> 917   Label not_done;</span>
 918 
 919   // We use RDI, which also serves as argument register for slow call.
<span class="line-modified"> 920   // RAX always holds the src object ptr, except after the slow call and</span>
<span class="line-modified"> 921   // the cmpxchg, then it holds the result.</span>
<span class="line-modified"> 922   // R8 and RCX are used as temporary registers.</span>
<span class="line-modified"> 923   __ push(rdi);</span>
<span class="line-modified"> 924   __ push(r8);</span>
<span class="line-modified"> 925 </span>
<span class="line-modified"> 926   // Check for object beeing in the collection set.</span>
<span class="line-modified"> 927   // TODO: Can we use only 1 register here?</span>
<span class="line-modified"> 928   // The source object arrives here in rax.</span>
<span class="line-modified"> 929   // live: rax</span>
<span class="line-modified"> 930   // live: rdi</span>
<span class="line-modified"> 931   __ mov(rdi, rax);</span>
<span class="line-modified"> 932   __ shrptr(rdi, ShenandoahHeapRegion::region_size_bytes_shift_jint());</span>
<span class="line-modified"> 933   // live: r8</span>
<span class="line-modified"> 934   __ movptr(r8, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());</span>
<span class="line-modified"> 935   __ movbool(r8, Address(r8, rdi, Address::times_1));</span>
<span class="line-modified"> 936   // unlive: rdi</span>
<span class="line-modified"> 937   __ testbool(r8);</span>
<span class="line-modified"> 938   // unlive: r8</span>
<span class="line-removed"> 939   __ jccb(Assembler::notZero, not_done);</span>
 940 
<span class="line-modified"> 941   __ pop(r8);</span>
<span class="line-modified"> 942   __ pop(rdi);</span>














 943   __ ret(0);
 944 
<span class="line-modified"> 945   __ bind(not_done);</span>
 946 
 947   __ push(rcx);
 948   __ push(rdx);
 949   __ push(rdi);
<span class="line-modified"> 950   __ push(rsi);</span>
 951   __ push(r8);
 952   __ push(r9);
 953   __ push(r10);
 954   __ push(r11);
 955   __ push(r12);
 956   __ push(r13);
 957   __ push(r14);
 958   __ push(r15);
<span class="line-modified"> 959   save_vector_registers(cgen-&gt;assembler());</span>
<span class="line-modified"> 960   __ movptr(rdi, rax);</span>
<span class="line-modified"> 961   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_JRT), rdi);</span>
<span class="line-modified"> 962   restore_vector_registers(cgen-&gt;assembler());</span>










 963   __ pop(r15);
 964   __ pop(r14);
 965   __ pop(r13);
 966   __ pop(r12);
 967   __ pop(r11);
 968   __ pop(r10);
 969   __ pop(r9);
 970   __ pop(r8);
<span class="line-modified"> 971   __ pop(rsi);</span>
 972   __ pop(rdi);
 973   __ pop(rdx);
 974   __ pop(rcx);
 975 
<span class="line-modified"> 976   __ pop(r8);</span>
<span class="line-modified"> 977   __ pop(rdi);</span>
 978   __ ret(0);
<span class="line-modified"> 979 #else</span>
<span class="line-removed"> 980   ShouldNotReachHere();</span>
<span class="line-removed"> 981 #endif</span>
 982   return start;
 983 }
 984 
 985 #undef __
 986 
 987 void ShenandoahBarrierSetAssembler::barrier_stubs_init() {
<span class="line-modified"> 988   if (ShenandoahWriteBarrier || ShenandoahStoreValEnqueueBarrier) {</span>
 989     int stub_code_size = 4096;
 990     ResourceMark rm;
 991     BufferBlob* bb = BufferBlob::create(&quot;shenandoah_barrier_stubs&quot;, stub_code_size);
 992     CodeBuffer buf(bb);
 993     StubCodeGenerator cgen(&amp;buf);
<span class="line-modified"> 994     _shenandoah_wb = generate_shenandoah_wb(&amp;cgen);</span>
 995   }
 996 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
<span class="line-added">  26 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;</span>
  27 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<span class="line-modified">  28 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;</span>
<span class="line-added">  29 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;</span>
  30 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  33 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;interpreter/interp_masm.hpp&quot;
  36 #include &quot;runtime/sharedRuntime.hpp&quot;
  37 #include &quot;runtime/thread.hpp&quot;
  38 #include &quot;utilities/macros.hpp&quot;
  39 #ifdef COMPILER1
  40 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  41 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  42 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
  43 #endif
  44 
  45 #define __ masm-&gt;
  46 
<span class="line-modified">  47 address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;</span>
  48 
  49 void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
  50                                                        Register src, Register dst, Register count) {
  51 



  52   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
  53 
<span class="line-modified">  54   if (is_reference_type(type)) {</span>
<span class="line-added">  55 </span>
<span class="line-added">  56     if ((ShenandoahSATBBarrier &amp;&amp; !dest_uninitialized) || ShenandoahLoadRefBarrier) {</span>
  57 #ifdef _LP64
<span class="line-modified">  58       Register thread = r15_thread;</span>






  59 #else
<span class="line-modified">  60       Register thread = rax;</span>
<span class="line-modified">  61       if (thread == src || thread == dst || thread == count) {</span>
<span class="line-modified">  62         thread = rbx;</span>
<span class="line-modified">  63       }</span>
<span class="line-modified">  64       if (thread == src || thread == dst || thread == count) {</span>
<span class="line-modified">  65         thread = rcx;</span>
<span class="line-modified">  66       }</span>
<span class="line-modified">  67       if (thread == src || thread == dst || thread == count) {</span>
<span class="line-added">  68         thread = rdx;</span>
<span class="line-added">  69       }</span>
  70       __ push(thread);
  71       __ get_thread(thread);
  72 #endif
<span class="line-added">  73       assert_different_registers(src, dst, count, thread);</span>
  74 
<span class="line-modified">  75       Label done;</span>
<span class="line-modified">  76       // Short-circuit if count == 0.</span>
<span class="line-modified">  77       __ testptr(count, count);</span>
<span class="line-modified">  78       __ jcc(Assembler::zero, done);</span>







  79 
<span class="line-modified">  80       // Avoid runtime call when not marking.</span>
<span class="line-added">  81       Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-added">  82       int flags = ShenandoahHeap::HAS_FORWARDED;</span>
<span class="line-added">  83       if (!dest_uninitialized) {</span>
<span class="line-added">  84         flags |= ShenandoahHeap::MARKING;</span>
<span class="line-added">  85       }</span>
<span class="line-added">  86       __ testb(gc_state, flags);</span>
<span class="line-added">  87       __ jcc(Assembler::zero, done);</span>
  88 
  89       __ pusha();                      // push registers
  90 #ifdef _LP64
<span class="line-modified">  91       assert(src == rdi, &quot;expected&quot;);</span>
<span class="line-modified">  92       assert(dst == rsi, &quot;expected&quot;);</span>
<span class="line-modified">  93       assert(count == rdx, &quot;expected&quot;);</span>
<span class="line-modified">  94       if (UseCompressedOops) {</span>
<span class="line-added">  95         if (dest_uninitialized) {</span>
<span class="line-added">  96           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_duinit_narrow_oop_entry), src, dst, count);</span>
  97         } else {
<span class="line-modified">  98           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_narrow_oop_entry), src, dst, count);</span>

  99         }
<span class="line-modified"> 100       } else</span>











 101 #endif
<span class="line-added"> 102       {</span>
<span class="line-added"> 103         if (dest_uninitialized) {</span>
<span class="line-added"> 104           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_duinit_oop_entry), src, dst, count);</span>
<span class="line-added"> 105         } else {</span>
<span class="line-added"> 106           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry), src, dst, count);</span>
<span class="line-added"> 107         }</span>
<span class="line-added"> 108       }</span>
 109       __ popa();
<span class="line-modified"> 110       __ bind(done);</span>
<span class="line-added"> 111       NOT_LP64(__ pop(thread);)</span>
 112     }
 113   }
 114 
 115 }
 116 












































 117 void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
 118                                                                  Register obj,
 119                                                                  Register pre_val,
 120                                                                  Register thread,
 121                                                                  Register tmp,
 122                                                                  bool tosca_live,
 123                                                                  bool expand_call) {
 124 
 125   if (ShenandoahSATBBarrier) {
 126     satb_write_barrier_pre(masm, obj, pre_val, thread, tmp, tosca_live, expand_call);
 127   }
 128 }
 129 
 130 void ShenandoahBarrierSetAssembler::satb_write_barrier_pre(MacroAssembler* masm,
 131                                                            Register obj,
 132                                                            Register pre_val,
 133                                                            Register thread,
 134                                                            Register tmp,
 135                                                            bool tosca_live,
 136                                                            bool expand_call) {
</pre>
<hr />
<pre>
 232 #endif
 233     __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), 2);
 234   } else {
 235     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), LP64_ONLY(c_rarg0) NOT_LP64(pre_val), thread);
 236   }
 237 
 238   NOT_LP64( __ pop(thread); )
 239 
 240   // save the live input values
 241   if (pre_val != rax)
 242     __ pop(pre_val);
 243 
 244   if (obj != noreg &amp;&amp; obj != rax)
 245     __ pop(obj);
 246 
 247   if(tosca_live) __ pop(rax);
 248 
 249   __ bind(done);
 250 }
 251 
<span class="line-modified"> 252 void ShenandoahBarrierSetAssembler::load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address src) {</span>
<span class="line-modified"> 253   assert(ShenandoahLoadRefBarrier, &quot;Should be enabled&quot;);</span>



 254 
<span class="line-modified"> 255   Label done;</span>







 256 
<span class="line-modified"> 257 #ifdef _LP64</span>
<span class="line-modified"> 258   Register thread = r15_thread;</span>
<span class="line-modified"> 259 #else</span>
<span class="line-added"> 260   Register thread = rcx;</span>
<span class="line-added"> 261   if (thread == dst) {</span>
<span class="line-added"> 262     thread = rbx;</span>
 263   }
<span class="line-modified"> 264   __ push(thread);</span>
<span class="line-added"> 265   __ get_thread(thread);</span>
<span class="line-added"> 266 #endif</span>
 267 
<span class="line-modified"> 268   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-modified"> 269   __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED);</span>
<span class="line-modified"> 270   __ jccb(Assembler::zero, done);</span>
<span class="line-modified"> 271 </span>
<span class="line-added"> 272   // Use rsi for src address</span>
<span class="line-added"> 273   const Register src_addr = rsi;</span>
<span class="line-added"> 274   // Setup address parameter first, if it does not clobber oop in dst</span>
<span class="line-added"> 275   bool need_addr_setup = (src_addr != dst);</span>
<span class="line-added"> 276 </span>
<span class="line-added"> 277   if (need_addr_setup) {</span>
<span class="line-added"> 278     __ push(src_addr);</span>
<span class="line-added"> 279     __ lea(src_addr, src);</span>
 280 
<span class="line-added"> 281     if (dst != rax) {</span>
<span class="line-added"> 282       // Move obj into rax and save rax</span>
<span class="line-added"> 283       __ push(rax);</span>
<span class="line-added"> 284       __ movptr(rax, dst);</span>
<span class="line-added"> 285     }</span>
<span class="line-added"> 286   } else {</span>
<span class="line-added"> 287     // dst == rsi</span>
<span class="line-added"> 288     __ push(rax);</span>
<span class="line-added"> 289     __ movptr(rax, dst);</span>
 290 
<span class="line-modified"> 291     // we can clobber it, since it is outgoing register</span>
<span class="line-modified"> 292     __ lea(src_addr, src);</span>

 293   }
<span class="line-added"> 294 </span>
<span class="line-added"> 295   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_lrb())));</span>
<span class="line-added"> 296 </span>
<span class="line-added"> 297   if (need_addr_setup) {</span>
<span class="line-added"> 298     if (dst != rax) {</span>
<span class="line-added"> 299       __ movptr(dst, rax);</span>
<span class="line-added"> 300       __ pop(rax);</span>
<span class="line-added"> 301     }</span>
<span class="line-added"> 302     __ pop(src_addr);</span>
<span class="line-added"> 303   } else {</span>
<span class="line-added"> 304     __ movptr(dst, rax);</span>
<span class="line-added"> 305     __ pop(rax);</span>
<span class="line-added"> 306   }</span>
<span class="line-added"> 307 </span>
<span class="line-added"> 308   __ bind(done);</span>
<span class="line-added"> 309 </span>
<span class="line-added"> 310 #ifndef _LP64</span>
<span class="line-added"> 311     __ pop(thread);</span>
<span class="line-added"> 312 #endif</span>
 313 }
 314 
<span class="line-modified"> 315 void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address src) {</span>
<span class="line-modified"> 316   if (!ShenandoahLoadRefBarrier) {</span>
<span class="line-modified"> 317     return;</span>
<span class="line-added"> 318   }</span>
<span class="line-added"> 319 </span>
 320   Label done;
<span class="line-added"> 321   Label not_null;</span>
<span class="line-added"> 322   Label slow_path;</span>
<span class="line-added"> 323   __ block_comment(&quot;load_reference_barrier_native { &quot;);</span>
 324 
<span class="line-modified"> 325   // null check</span>
<span class="line-modified"> 326   __ testptr(dst, dst);</span>
<span class="line-modified"> 327   __ jcc(Assembler::notZero, not_null);</span>
<span class="line-added"> 328   __ jmp(done);</span>
<span class="line-added"> 329   __ bind(not_null);</span>
 330 


 331 
<span class="line-modified"> 332 #ifdef _LP64</span>
<span class="line-modified"> 333   Register thread = r15_thread;</span>
<span class="line-added"> 334 #else</span>
<span class="line-added"> 335   Register thread = rcx;</span>
<span class="line-added"> 336   if (thread == dst) {</span>
<span class="line-added"> 337     thread = rbx;</span>
<span class="line-added"> 338   }</span>
<span class="line-added"> 339   __ push(thread);</span>
<span class="line-added"> 340   __ get_thread(thread);</span>
<span class="line-added"> 341 #endif</span>
<span class="line-added"> 342   assert_different_registers(dst, thread);</span>
<span class="line-added"> 343 </span>
<span class="line-added"> 344   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-added"> 345   __ testb(gc_state, ShenandoahHeap::EVACUATION);</span>
<span class="line-added"> 346 #ifndef _LP64</span>
<span class="line-added"> 347   __ pop(thread);</span>
<span class="line-added"> 348 #endif</span>
<span class="line-added"> 349   __ jccb(Assembler::notZero, slow_path);</span>
<span class="line-added"> 350   __ jmp(done);</span>
<span class="line-added"> 351   __ bind(slow_path);</span>
<span class="line-added"> 352 </span>
<span class="line-added"> 353   if (dst != rax) {</span>
<span class="line-added"> 354     __ push(rax);</span>
<span class="line-added"> 355   }</span>
<span class="line-added"> 356   __ push(rcx);</span>
<span class="line-added"> 357   __ push(rdx);</span>
<span class="line-added"> 358   __ push(rdi);</span>
<span class="line-added"> 359   __ push(rsi);</span>
<span class="line-added"> 360 #ifdef _LP64</span>
<span class="line-added"> 361   __ push(r8);</span>
<span class="line-added"> 362   __ push(r9);</span>
<span class="line-added"> 363   __ push(r10);</span>
<span class="line-added"> 364   __ push(r11);</span>
<span class="line-added"> 365   __ push(r12);</span>
<span class="line-added"> 366   __ push(r13);</span>
<span class="line-added"> 367   __ push(r14);</span>
<span class="line-added"> 368   __ push(r15);</span>
<span class="line-added"> 369 #endif</span>
 370 
<span class="line-modified"> 371   assert_different_registers(dst, rsi);</span>
<span class="line-modified"> 372   __ lea(rsi, src);</span>
<span class="line-modified"> 373   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), dst, rsi);</span>
 374 
<span class="line-modified"> 375 #ifdef _LP64</span>
<span class="line-added"> 376   __ pop(r15);</span>
<span class="line-added"> 377   __ pop(r14);</span>
<span class="line-added"> 378   __ pop(r13);</span>
<span class="line-added"> 379   __ pop(r12);</span>
<span class="line-added"> 380   __ pop(r11);</span>
<span class="line-added"> 381   __ pop(r10);</span>
<span class="line-added"> 382   __ pop(r9);</span>
<span class="line-added"> 383   __ pop(r8);</span>
<span class="line-added"> 384 #endif</span>
<span class="line-added"> 385   __ pop(rsi);</span>
<span class="line-added"> 386   __ pop(rdi);</span>
<span class="line-added"> 387   __ pop(rdx);</span>
<span class="line-added"> 388   __ pop(rcx);</span>
 389 
<span class="line-modified"> 390   if (dst != rax) {</span>
<span class="line-modified"> 391     __ movptr(dst, rax);</span>
<span class="line-modified"> 392     __ pop(rax);</span>
<span class="line-added"> 393   }</span>
 394 
 395   __ bind(done);
<span class="line-modified"> 396   __ block_comment(&quot;load_reference_barrier_native { &quot;);</span>


 397 }
 398 
 399 void ShenandoahBarrierSetAssembler::storeval_barrier(MacroAssembler* masm, Register dst, Register tmp) {
<span class="line-modified"> 400   if (ShenandoahStoreValEnqueueBarrier) {</span>
 401     storeval_barrier_impl(masm, dst, tmp);
 402   }
 403 }
 404 
 405 void ShenandoahBarrierSetAssembler::storeval_barrier_impl(MacroAssembler* masm, Register dst, Register tmp) {
<span class="line-modified"> 406   assert(ShenandoahStoreValEnqueueBarrier, &quot;should be enabled&quot;);</span>
 407 
 408   if (dst == noreg) return;
 409 

 410   if (ShenandoahStoreValEnqueueBarrier) {






 411     // The set of registers to be saved+restored is the same as in the write-barrier above.
 412     // Those are the commonly used registers in the interpreter.
 413     __ pusha();
 414     // __ push_callee_saved_registers();
 415     __ subptr(rsp, 2 * Interpreter::stackElementSize);
 416     __ movdbl(Address(rsp, 0), xmm0);
 417 
<span class="line-modified"> 418 #ifdef _LP64</span>
<span class="line-added"> 419     Register thread = r15_thread;</span>
<span class="line-added"> 420 #else</span>
<span class="line-added"> 421     Register thread = rcx;</span>
<span class="line-added"> 422     if (thread == dst || thread == tmp) {</span>
<span class="line-added"> 423       thread = rdi;</span>
<span class="line-added"> 424     }</span>
<span class="line-added"> 425     if (thread == dst || thread == tmp) {</span>
<span class="line-added"> 426       thread = rbx;</span>
<span class="line-added"> 427     }</span>
<span class="line-added"> 428     __ get_thread(thread);</span>
<span class="line-added"> 429 #endif</span>
<span class="line-added"> 430     assert_different_registers(dst, tmp, thread);</span>
<span class="line-added"> 431 </span>
<span class="line-added"> 432     satb_write_barrier_pre(masm, noreg, dst, thread, tmp, true, false);</span>
 433     __ movdbl(xmm0, Address(rsp, 0));
 434     __ addptr(rsp, 2 * Interpreter::stackElementSize);
 435     //__ pop_callee_saved_registers();
 436     __ popa();
 437   }
<span class="line-modified"> 438 }</span>
<span class="line-modified"> 439 </span>
<span class="line-added"> 440 void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address src) {</span>
<span class="line-added"> 441   if (ShenandoahLoadRefBarrier) {</span>
<span class="line-added"> 442     Label done;</span>
<span class="line-added"> 443     __ testptr(dst, dst);</span>
<span class="line-added"> 444     __ jcc(Assembler::zero, done);</span>
<span class="line-added"> 445     load_reference_barrier_not_null(masm, dst, src);</span>
<span class="line-added"> 446     __ bind(done);</span>
 447   }



 448 }
 449 
<span class="line-added"> 450 //</span>
<span class="line-added"> 451 // Arguments:</span>
<span class="line-added"> 452 //</span>
<span class="line-added"> 453 // Inputs:</span>
<span class="line-added"> 454 //   src:        oop location, might be clobbered</span>
<span class="line-added"> 455 //   tmp1:       scratch register, might not be valid.</span>
<span class="line-added"> 456 //</span>
<span class="line-added"> 457 // Output:</span>
<span class="line-added"> 458 //   dst:        oop loaded from src location</span>
<span class="line-added"> 459 //</span>
<span class="line-added"> 460 // Kill:</span>
<span class="line-added"> 461 //   tmp1 (if it is valid)</span>
<span class="line-added"> 462 //</span>
 463 void ShenandoahBarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
 464              Register dst, Address src, Register tmp1, Register tmp_thread) {
<span class="line-modified"> 465   // 1: non-reference load, no additional barrier is needed</span>
<span class="line-modified"> 466   if (!is_reference_type(type)) {</span>
<span class="line-modified"> 467     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-modified"> 468     return;</span>
<span class="line-modified"> 469   }</span>
<span class="line-modified"> 470 </span>
<span class="line-modified"> 471   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Not expected&quot;);</span>





 472 
<span class="line-added"> 473   // 2: load a reference from src location and apply LRB if needed</span>
<span class="line-added"> 474   if (ShenandoahBarrierSet::need_load_reference_barrier(decorators, type)) {</span>
<span class="line-added"> 475     Register result_dst = dst;</span>
<span class="line-added"> 476     bool use_tmp1_for_dst = false;</span>
<span class="line-added"> 477 </span>
<span class="line-added"> 478     // Preserve src location for LRB</span>
<span class="line-added"> 479     if (dst == src.base() || dst == src.index()) {</span>
<span class="line-added"> 480       // Use tmp1 for dst if possible, as it is not used in BarrierAssembler::load_at()</span>
<span class="line-added"> 481       if (tmp1-&gt;is_valid() &amp;&amp; tmp1 != src.base() &amp;&amp; tmp1 != src.index()) {</span>
<span class="line-added"> 482         dst = tmp1;</span>
<span class="line-added"> 483         use_tmp1_for_dst = true;</span>
<span class="line-added"> 484       } else {</span>
<span class="line-added"> 485         dst = rdi;</span>
<span class="line-added"> 486         __ push(dst);</span>
<span class="line-added"> 487       }</span>
<span class="line-added"> 488       assert_different_registers(dst, src.base(), src.index());</span>
<span class="line-added"> 489     }</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-added"> 492 </span>
<span class="line-added"> 493     if (ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type)) {</span>
<span class="line-added"> 494       load_reference_barrier_native(masm, dst, src);</span>
<span class="line-added"> 495     } else {</span>
<span class="line-added"> 496       load_reference_barrier(masm, dst, src);</span>
<span class="line-added"> 497     }</span>
<span class="line-added"> 498 </span>
<span class="line-added"> 499     // Move loaded oop to final destination</span>
<span class="line-added"> 500     if (dst != result_dst) {</span>
<span class="line-added"> 501       __ movptr(result_dst, dst);</span>
<span class="line-added"> 502 </span>
<span class="line-added"> 503       if (!use_tmp1_for_dst) {</span>
<span class="line-added"> 504         __ pop(dst);</span>
<span class="line-added"> 505       }</span>
<span class="line-added"> 506 </span>
<span class="line-added"> 507       dst = result_dst;</span>
<span class="line-added"> 508     }</span>
<span class="line-added"> 509   } else {</span>
<span class="line-added"> 510     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-added"> 511   }</span>
<span class="line-added"> 512 </span>
<span class="line-added"> 513   // 3: apply keep-alive barrier if needed</span>
<span class="line-added"> 514   if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {</span>
<span class="line-added"> 515     __ push_IU_state();</span>
<span class="line-added"> 516     // That path can be reached from the c2i adapter with live fp</span>
<span class="line-added"> 517     // arguments in registers.</span>
<span class="line-added"> 518     LP64_ONLY(assert(Argument::n_float_register_parameters_j == 8, &quot;8 fp registers to save at java call&quot;));</span>
<span class="line-added"> 519     __ subptr(rsp, 64);</span>
<span class="line-added"> 520     __ movdbl(Address(rsp, 0), xmm0);</span>
<span class="line-added"> 521     __ movdbl(Address(rsp, 8), xmm1);</span>
<span class="line-added"> 522     __ movdbl(Address(rsp, 16), xmm2);</span>
<span class="line-added"> 523     __ movdbl(Address(rsp, 24), xmm3);</span>
<span class="line-added"> 524     __ movdbl(Address(rsp, 32), xmm4);</span>
<span class="line-added"> 525     __ movdbl(Address(rsp, 40), xmm5);</span>
<span class="line-added"> 526     __ movdbl(Address(rsp, 48), xmm6);</span>
<span class="line-added"> 527     __ movdbl(Address(rsp, 56), xmm7);</span>
<span class="line-added"> 528 </span>
<span class="line-added"> 529     Register thread = NOT_LP64(tmp_thread) LP64_ONLY(r15_thread);</span>
<span class="line-added"> 530     assert_different_registers(dst, tmp1, tmp_thread);</span>
<span class="line-added"> 531     if (!thread-&gt;is_valid()) {</span>
<span class="line-added"> 532       thread = rdx;</span>
<span class="line-added"> 533     }</span>
<span class="line-added"> 534     NOT_LP64(__ get_thread(thread));</span>
 535     // Generate the SATB pre-barrier code to log the value of
 536     // the referent field in an SATB buffer.
 537     shenandoah_write_barrier_pre(masm /* masm */,
 538                                  noreg /* obj */,
 539                                  dst /* pre_val */,
 540                                  thread /* thread */,
 541                                  tmp1 /* tmp */,
 542                                  true /* tosca_live */,
 543                                  true /* expand_call */);
<span class="line-added"> 544     __ movdbl(xmm0, Address(rsp, 0));</span>
<span class="line-added"> 545     __ movdbl(xmm1, Address(rsp, 8));</span>
<span class="line-added"> 546     __ movdbl(xmm2, Address(rsp, 16));</span>
<span class="line-added"> 547     __ movdbl(xmm3, Address(rsp, 24));</span>
<span class="line-added"> 548     __ movdbl(xmm4, Address(rsp, 32));</span>
<span class="line-added"> 549     __ movdbl(xmm5, Address(rsp, 40));</span>
<span class="line-added"> 550     __ movdbl(xmm6, Address(rsp, 48));</span>
<span class="line-added"> 551     __ movdbl(xmm7, Address(rsp, 56));</span>
<span class="line-added"> 552     __ addptr(rsp, 64);</span>
<span class="line-added"> 553     __ pop_IU_state();</span>
 554   }
 555 }
 556 
 557 void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
 558               Address dst, Register val, Register tmp1, Register tmp2) {
 559 
<span class="line-added"> 560   bool on_oop = is_reference_type(type);</span>
 561   bool in_heap = (decorators &amp; IN_HEAP) != 0;
 562   bool as_normal = (decorators &amp; AS_NORMAL) != 0;
<span class="line-modified"> 563   if (on_oop &amp;&amp; in_heap) {</span>



 564     bool needs_pre_barrier = as_normal;
 565 
 566     Register tmp3 = LP64_ONLY(r8) NOT_LP64(rsi);
 567     Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
 568     // flatten object address if needed
 569     // We do it regardless of precise because we need the registers
 570     if (dst.index() == noreg &amp;&amp; dst.disp() == 0) {
 571       if (dst.base() != tmp1) {
 572         __ movptr(tmp1, dst.base());
 573       }
 574     } else {
 575       __ lea(tmp1, dst);
 576     }
 577 
<span class="line-added"> 578     assert_different_registers(val, tmp1, tmp2, tmp3, rthread);</span>
<span class="line-added"> 579 </span>
 580 #ifndef _LP64
<span class="line-added"> 581     __ get_thread(rthread);</span>
 582     InterpreterMacroAssembler *imasm = static_cast&lt;InterpreterMacroAssembler*&gt;(masm);
<span class="line-added"> 583     imasm-&gt;save_bcp();</span>
 584 #endif
 585 



 586     if (needs_pre_barrier) {
 587       shenandoah_write_barrier_pre(masm /*masm*/,
 588                                    tmp1 /* obj */,
 589                                    tmp2 /* pre_val */,
 590                                    rthread /* thread */,
 591                                    tmp3  /* tmp */,
 592                                    val != noreg /* tosca_live */,
 593                                    false /* expand_call */);
 594     }
 595     if (val == noreg) {
 596       BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg);
 597     } else {
 598       storeval_barrier(masm, val, tmp3);
 599       BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg);
 600     }
 601     NOT_LP64(imasm-&gt;restore_bcp());
 602   } else {
 603     BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);
 604   }
 605 }
 606 
<span class="line-modified"> 607 void ShenandoahBarrierSetAssembler::try_resolve_jobject_in_native(MacroAssembler* masm, Register jni_env,</span>
<span class="line-modified"> 608                                                                   Register obj, Register tmp, Label&amp; slowpath) {</span>
<span class="line-modified"> 609   Label done;</span>
<span class="line-modified"> 610   // Resolve jobject</span>
<span class="line-modified"> 611   BarrierSetAssembler::try_resolve_jobject_in_native(masm, jni_env, obj, tmp, slowpath);</span>










































































 612 
<span class="line-modified"> 613   // Check for null.</span>
<span class="line-modified"> 614   __ testptr(obj, obj);</span>
<span class="line-modified"> 615   __ jcc(Assembler::zero, done);</span>



 616 
<span class="line-modified"> 617   Address gc_state(jni_env, ShenandoahThreadLocalData::gc_state_offset() - JavaThread::jni_environment_offset());</span>
<span class="line-modified"> 618   __ testb(gc_state, ShenandoahHeap::EVACUATION);</span>
<span class="line-modified"> 619   __ jccb(Assembler::notZero, slowpath);</span>
<span class="line-modified"> 620   __ bind(done);</span>
















 621 }
 622 
 623 // Special Shenandoah CAS implementation that handles false negatives
 624 // due to concurrent evacuation.








 625 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm,
 626                                                 Register res, Address addr, Register oldval, Register newval,
 627                                                 bool exchange, Register tmp1, Register tmp2) {
 628   assert(ShenandoahCASBarrier, &quot;Should only be used when CAS barrier is enabled&quot;);
 629   assert(oldval == rax, &quot;must be in rax for implicit use in cmpxchg&quot;);
<span class="line-added"> 630   assert_different_registers(oldval, newval, tmp1, tmp2);</span>
 631 
<span class="line-modified"> 632   Label L_success, L_failure;</span>
 633 
 634   // Remember oldval for retry logic below
<span class="line-added"> 635 #ifdef _LP64</span>
 636   if (UseCompressedOops) {
 637     __ movl(tmp1, oldval);
<span class="line-modified"> 638   } else</span>
<span class="line-added"> 639 #endif</span>
<span class="line-added"> 640   {</span>
 641     __ movptr(tmp1, oldval);
 642   }
 643 
<span class="line-modified"> 644   // Step 1. Fast-path.</span>
<span class="line-modified"> 645   //</span>
<span class="line-added"> 646   // Try to CAS with given arguments. If successful, then we are done.</span>
<span class="line-added"> 647 </span>
 648   if (os::is_MP()) __ lock();
<span class="line-added"> 649 #ifdef _LP64</span>
 650   if (UseCompressedOops) {
 651     __ cmpxchgl(newval, addr);
<span class="line-modified"> 652   } else</span>
<span class="line-added"> 653 #endif</span>
<span class="line-added"> 654   {</span>
 655     __ cmpxchgptr(newval, addr);
 656   }
<span class="line-modified"> 657   __ jcc(Assembler::equal, L_success);</span>
 658 
 659   // Step 2. CAS had failed. This may be a false negative.
 660   //
 661   // The trouble comes when we compare the to-space pointer with the from-space
<span class="line-modified"> 662   // pointer to the same object. To resolve this, it will suffice to resolve</span>
<span class="line-modified"> 663   // the value from memory -- this will give both to-space pointers.</span>
<span class="line-modified"> 664   // If they mismatch, then it was a legitimate failure.</span>
 665   //
<span class="line-modified"> 666   // Before reaching to resolve sequence, see if we can avoid the whole shebang</span>
<span class="line-modified"> 667   // with filters.</span>
<span class="line-modified"> 668 </span>
<span class="line-modified"> 669   // Filter: when offending in-memory value is NULL, the failure is definitely legitimate</span>
<span class="line-added"> 670   __ testptr(oldval, oldval);</span>
<span class="line-added"> 671   __ jcc(Assembler::zero, L_failure);</span>
<span class="line-added"> 672 </span>
<span class="line-added"> 673   // Filter: when heap is stable, the failure is definitely legitimate</span>
<span class="line-added"> 674 #ifdef _LP64</span>
<span class="line-added"> 675   const Register thread = r15_thread;</span>
<span class="line-added"> 676 #else</span>
<span class="line-added"> 677   const Register thread = tmp2;</span>
<span class="line-added"> 678   __ get_thread(thread);</span>
<span class="line-added"> 679 #endif</span>
<span class="line-added"> 680   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-added"> 681   __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED);</span>
<span class="line-added"> 682   __ jcc(Assembler::zero, L_failure);</span>
 683 
<span class="line-added"> 684 #ifdef _LP64</span>
 685   if (UseCompressedOops) {
 686     __ movl(tmp2, oldval);
 687     __ decode_heap_oop(tmp2);
<span class="line-modified"> 688   } else</span>
<span class="line-added"> 689 #endif</span>
<span class="line-added"> 690   {</span>
 691     __ movptr(tmp2, oldval);
 692   }

 693 
<span class="line-modified"> 694   // Decode offending in-memory value.</span>
<span class="line-modified"> 695   // Test if-forwarded</span>
<span class="line-added"> 696   __ testb(Address(tmp2, oopDesc::mark_offset_in_bytes()), markWord::marked_value);</span>
<span class="line-added"> 697   __ jcc(Assembler::noParity, L_failure);  // When odd number of bits, then not forwarded</span>
<span class="line-added"> 698   __ jcc(Assembler::zero, L_failure);      // When it is 00, then also not forwarded</span>
 699 
<span class="line-modified"> 700   // Load and mask forwarding pointer</span>
<span class="line-modified"> 701   __ movptr(tmp2, Address(tmp2, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-modified"> 702   __ shrptr(tmp2, 2);</span>
<span class="line-modified"> 703   __ shlptr(tmp2, 2);</span>










 704 
<span class="line-added"> 705 #ifdef _LP64</span>
 706   if (UseCompressedOops) {
<span class="line-modified"> 707     __ decode_heap_oop(tmp1); // decode for comparison</span>



 708   }
<span class="line-modified"> 709 #endif</span>
 710 
<span class="line-added"> 711   // Now we have the forwarded offender in tmp2.</span>
<span class="line-added"> 712   // Compare and if they don&#39;t match, we have legitimate failure</span>
 713   __ cmpptr(tmp1, tmp2);
<span class="line-modified"> 714   __ jcc(Assembler::notEqual, L_failure);</span>
 715 
<span class="line-modified"> 716   // Step 3. Need to fix the memory ptr before continuing.</span>
<span class="line-modified"> 717   //</span>
<span class="line-modified"> 718   // At this point, we have from-space oldval in the register, and its to-space</span>
<span class="line-modified"> 719   // address is in tmp2. Let&#39;s try to update it into memory. We don&#39;t care if it</span>
<span class="line-modified"> 720   // succeeds or not. If it does, then the retrying CAS would see it and succeed.</span>
<span class="line-modified"> 721   // If this fixup fails, this means somebody else beat us to it, and necessarily</span>
<span class="line-modified"> 722   // with to-space ptr store. We still have to do the retry, because the GC might</span>
<span class="line-modified"> 723   // have updated the reference for us.</span>



 724 
<span class="line-modified"> 725 #ifdef _LP64</span>
<span class="line-modified"> 726   if (UseCompressedOops) {</span>
<span class="line-modified"> 727     __ encode_heap_oop(tmp2); // previously decoded at step 2.</span>

 728   }





























 729 #endif
<span class="line-modified"> 730 </span>
<span class="line-modified"> 731   if (os::is_MP()) __ lock();</span>
 732 #ifdef _LP64
<span class="line-modified"> 733   if (UseCompressedOops) {</span>
<span class="line-modified"> 734     __ cmpxchgl(tmp2, addr);</span>
<span class="line-modified"> 735   } else</span>










 736 #endif
<span class="line-added"> 737   {</span>
<span class="line-added"> 738     __ cmpxchgptr(tmp2, addr);</span>
 739   }

 740 
<span class="line-modified"> 741   // Step 4. Try to CAS again.</span>
<span class="line-modified"> 742   //</span>
<span class="line-modified"> 743   // This is guaranteed not to have false negatives, because oldval is definitely</span>
<span class="line-modified"> 744   // to-space, and memory pointer is to-space as well. Nothing is able to store</span>
<span class="line-modified"> 745   // from-space ptr into memory anymore. Make sure oldval is restored, after being</span>
<span class="line-modified"> 746   // garbled during retries.</span>
<span class="line-modified"> 747   //</span>





 748 #ifdef _LP64
<span class="line-modified"> 749   if (UseCompressedOops) {</span>
<span class="line-modified"> 750     __ movl(oldval, tmp2);</span>
<span class="line-modified"> 751   } else</span>










 752 #endif
<span class="line-modified"> 753   {</span>
<span class="line-added"> 754     __ movptr(oldval, tmp2);</span>
<span class="line-added"> 755   }</span>
 756 
<span class="line-modified"> 757   if (os::is_MP()) __ lock();</span>
<span class="line-modified"> 758 #ifdef _LP64</span>
<span class="line-modified"> 759   if (UseCompressedOops) {</span>
<span class="line-modified"> 760     __ cmpxchgl(newval, addr);</span>
<span class="line-modified"> 761   } else</span>









 762 #endif
<span class="line-added"> 763   {</span>
<span class="line-added"> 764     __ cmpxchgptr(newval, addr);</span>
<span class="line-added"> 765   }</span>
<span class="line-added"> 766   if (!exchange) {</span>
<span class="line-added"> 767     __ jccb(Assembler::equal, L_success); // fastpath, peeking into Step 5, no need to jump</span>
<span class="line-added"> 768   }</span>
<span class="line-added"> 769 </span>
<span class="line-added"> 770   // Step 5. If we need a boolean result out of CAS, set the flag appropriately.</span>
<span class="line-added"> 771   // and promote the result. Note that we handle the flag from both the 1st and 2nd CAS.</span>
<span class="line-added"> 772   // Otherwise, failure witness for CAE is in oldval on all paths, and we can return.</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774   if (exchange) {</span>
<span class="line-added"> 775     __ bind(L_failure);</span>
<span class="line-added"> 776     __ bind(L_success);</span>
<span class="line-added"> 777   } else {</span>
<span class="line-added"> 778     assert(res != NULL, &quot;need result register&quot;);</span>
<span class="line-added"> 779 </span>
<span class="line-added"> 780     Label exit;</span>
<span class="line-added"> 781     __ bind(L_failure);</span>
<span class="line-added"> 782     __ xorptr(res, res);</span>
<span class="line-added"> 783     __ jmpb(exit);</span>
<span class="line-added"> 784 </span>
<span class="line-added"> 785     __ bind(L_success);</span>
<span class="line-added"> 786     __ movptr(res, 1);</span>
<span class="line-added"> 787     __ bind(exit);</span>
 788   }
 789 }
 790 
<span class="line-added"> 791 #undef __</span>
<span class="line-added"> 792 </span>
 793 #ifdef COMPILER1
 794 

 795 #define __ ce-&gt;masm()-&gt;
 796 
 797 void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
 798   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
 799   // At this point we know that marking is in progress.
 800   // If do_load() is true then we have to emit the
 801   // load of the previous value; otherwise it has already
 802   // been loaded into _pre_val.
 803 
 804   __ bind(*stub-&gt;entry());
 805   assert(stub-&gt;pre_val()-&gt;is_register(), &quot;Precondition.&quot;);
 806 
 807   Register pre_val_reg = stub-&gt;pre_val()-&gt;as_register();
 808 
 809   if (stub-&gt;do_load()) {
 810     ce-&gt;mem2reg(stub-&gt;addr(), stub-&gt;pre_val(), T_OBJECT, stub-&gt;patch_code(), stub-&gt;info(), false /*wide*/, false /*unaligned*/);
 811   }
 812 
 813   __ cmpptr(pre_val_reg, (int32_t)NULL_WORD);
 814   __ jcc(Assembler::equal, *stub-&gt;continuation());
 815   ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
 816   __ call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
 817   __ jmp(*stub-&gt;continuation());
 818 
 819 }
 820 
<span class="line-modified"> 821 void ShenandoahBarrierSetAssembler::gen_load_reference_barrier_stub(LIR_Assembler* ce, ShenandoahLoadReferenceBarrierStub* stub) {</span>
<span class="line-added"> 822   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();</span>
 823   __ bind(*stub-&gt;entry());
 824 

 825   Register obj = stub-&gt;obj()-&gt;as_register();
 826   Register res = stub-&gt;result()-&gt;as_register();
<span class="line-added"> 827   Register addr = stub-&gt;addr()-&gt;as_pointer_register();</span>
<span class="line-added"> 828   Register tmp1 = stub-&gt;tmp1()-&gt;as_register();</span>
<span class="line-added"> 829   Register tmp2 = stub-&gt;tmp2()-&gt;as_register();</span>
<span class="line-added"> 830   assert_different_registers(obj, res, addr, tmp1, tmp2);</span>
<span class="line-added"> 831 </span>
<span class="line-added"> 832   Label slow_path;</span>
<span class="line-added"> 833 </span>
<span class="line-added"> 834   assert(res == rax, &quot;result must arrive in rax&quot;);</span>
 835 
 836   if (res != obj) {
 837     __ mov(res, obj);
 838   }
 839 
 840   // Check for null.
<span class="line-modified"> 841   __ testptr(res, res);</span>
<span class="line-modified"> 842   __ jcc(Assembler::zero, *stub-&gt;continuation());</span>


 843 
<span class="line-modified"> 844   // Check for object being in the collection set.</span>
<span class="line-added"> 845   __ mov(tmp1, res);</span>
<span class="line-added"> 846   __ shrptr(tmp1, ShenandoahHeapRegion::region_size_bytes_shift_jint());</span>
<span class="line-added"> 847   __ movptr(tmp2, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());</span>
<span class="line-added"> 848 #ifdef _LP64</span>
<span class="line-added"> 849   __ movbool(tmp2, Address(tmp2, tmp1, Address::times_1));</span>
<span class="line-added"> 850   __ testbool(tmp2);</span>
<span class="line-added"> 851 #else</span>
<span class="line-added"> 852   // On x86_32, C1 register allocator can give us the register without 8-bit support.</span>
<span class="line-added"> 853   // Do the full-register access and test to avoid compilation failures.</span>
<span class="line-added"> 854   __ movptr(tmp2, Address(tmp2, tmp1, Address::times_1));</span>
<span class="line-added"> 855   __ testptr(tmp2, 0xFF);</span>
<span class="line-added"> 856 #endif</span>
<span class="line-added"> 857   __ jcc(Assembler::zero, *stub-&gt;continuation());</span>
 858 
<span class="line-modified"> 859   __ bind(slow_path);</span>
<span class="line-added"> 860   ce-&gt;store_parameter(res, 0);</span>
<span class="line-added"> 861   ce-&gt;store_parameter(addr, 1);</span>
<span class="line-added"> 862   if (stub-&gt;is_native()) {</span>
<span class="line-added"> 863     __ call(RuntimeAddress(bs-&gt;load_reference_barrier_native_rt_code_blob()-&gt;code_begin()));</span>
<span class="line-added"> 864   } else {</span>
<span class="line-added"> 865     __ call(RuntimeAddress(bs-&gt;load_reference_barrier_rt_code_blob()-&gt;code_begin()));</span>
<span class="line-added"> 866   }</span>
 867   __ jmp(*stub-&gt;continuation());
 868 }
 869 
 870 #undef __
 871 
 872 #define __ sasm-&gt;
 873 
 874 void ShenandoahBarrierSetAssembler::generate_c1_pre_barrier_runtime_stub(StubAssembler* sasm) {
 875   __ prologue(&quot;shenandoah_pre_barrier&quot;, false);
 876   // arg0 : previous value of memory
 877 
 878   __ push(rax);
 879   __ push(rdx);
 880 
 881   const Register pre_val = rax;
 882   const Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);
 883   const Register tmp = rdx;
 884 
 885   NOT_LP64(__ get_thread(thread);)
 886 
</pre>
<hr />
<pre>
 910   __ jmp(done);
 911 
 912   __ bind(runtime);
 913 
 914   __ save_live_registers_no_oop_map(true);
 915 
 916   // load the pre-value
 917   __ load_parameter(0, rcx);
 918   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), rcx, thread);
 919 
 920   __ restore_live_registers(true);
 921 
 922   __ bind(done);
 923 
 924   __ pop(rdx);
 925   __ pop(rax);
 926 
 927   __ epilogue();
 928 }
 929 
<span class="line-added"> 930 void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native) {</span>
<span class="line-added"> 931   __ prologue(&quot;shenandoah_load_reference_barrier&quot;, false);</span>
<span class="line-added"> 932   // arg0 : object to be resolved</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934   __ save_live_registers_no_oop_map(true);</span>
<span class="line-added"> 935 </span>
<span class="line-added"> 936 #ifdef _LP64</span>
<span class="line-added"> 937   __ load_parameter(0, c_rarg0);</span>
<span class="line-added"> 938   __ load_parameter(1, c_rarg1);</span>
<span class="line-added"> 939   if (is_native) {</span>
<span class="line-added"> 940     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), c_rarg0, c_rarg1);</span>
<span class="line-added"> 941   } else if (UseCompressedOops) {</span>
<span class="line-added"> 942     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), c_rarg0, c_rarg1);</span>
<span class="line-added"> 943   } else {</span>
<span class="line-added"> 944     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), c_rarg0, c_rarg1);</span>
<span class="line-added"> 945   }</span>
<span class="line-added"> 946 #else</span>
<span class="line-added"> 947   __ load_parameter(0, rax);</span>
<span class="line-added"> 948   __ load_parameter(1, rbx);</span>
<span class="line-added"> 949   if (is_native) {</span>
<span class="line-added"> 950     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), rax, rbx);</span>
<span class="line-added"> 951   } else {</span>
<span class="line-added"> 952     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), rax, rbx);</span>
<span class="line-added"> 953   }</span>
<span class="line-added"> 954 #endif</span>
<span class="line-added"> 955 </span>
<span class="line-added"> 956   __ restore_live_registers_except_rax(true);</span>
<span class="line-added"> 957 </span>
<span class="line-added"> 958   __ epilogue();</span>
<span class="line-added"> 959 }</span>
<span class="line-added"> 960 </span>
 961 #undef __
 962 
 963 #endif // COMPILER1
 964 
<span class="line-modified"> 965 address ShenandoahBarrierSetAssembler::shenandoah_lrb() {</span>
<span class="line-modified"> 966   assert(_shenandoah_lrb != NULL, &quot;need load reference barrier stub&quot;);</span>
<span class="line-modified"> 967   return _shenandoah_lrb;</span>
 968 }
 969 
 970 #define __ cgen-&gt;assembler()-&gt;
 971 
<span class="line-modified"> 972 /*</span>
<span class="line-added"> 973  *  Incoming parameters:</span>
<span class="line-added"> 974  *  rax: oop</span>
<span class="line-added"> 975  *  rsi: load address</span>
<span class="line-added"> 976  */</span>
<span class="line-added"> 977 address ShenandoahBarrierSetAssembler::generate_shenandoah_lrb(StubCodeGenerator* cgen) {</span>
 978   __ align(CodeEntryAlignment);
<span class="line-modified"> 979   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_lrb&quot;);</span>
 980   address start = __ pc();
 981 
<span class="line-modified"> 982   Label resolve_oop, slow_path;</span>

 983 
 984   // We use RDI, which also serves as argument register for slow call.
<span class="line-modified"> 985   // RAX always holds the src object ptr, except after the slow call,</span>
<span class="line-modified"> 986   // then it holds the result. R8/RBX is used as temporary register.</span>
<span class="line-modified"> 987 </span>
<span class="line-modified"> 988   Register tmp1 = rdi;</span>
<span class="line-modified"> 989   Register tmp2 = LP64_ONLY(r8) NOT_LP64(rbx);</span>
<span class="line-modified"> 990 </span>
<span class="line-modified"> 991   __ push(tmp1);</span>
<span class="line-modified"> 992   __ push(tmp2);</span>
<span class="line-modified"> 993 </span>
<span class="line-modified"> 994   // Check for object being in the collection set.</span>
<span class="line-modified"> 995   __ mov(tmp1, rax);</span>
<span class="line-modified"> 996   __ shrptr(tmp1, ShenandoahHeapRegion::region_size_bytes_shift_jint());</span>
<span class="line-modified"> 997   __ movptr(tmp2, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());</span>
<span class="line-modified"> 998   __ movbool(tmp2, Address(tmp2, tmp1, Address::times_1));</span>
<span class="line-modified"> 999   __ testbool(tmp2);</span>
<span class="line-modified">1000   __ jccb(Assembler::notZero, resolve_oop);</span>
<span class="line-modified">1001   __ pop(tmp2);</span>
<span class="line-modified">1002   __ pop(tmp1);</span>
<span class="line-modified">1003   __ ret(0);</span>

1004 
<span class="line-modified">1005   // Test if object is already resolved.</span>
<span class="line-modified">1006   __ bind(resolve_oop);</span>
<span class="line-added">1007   __ movptr(tmp2, Address(rax, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">1008   // Test if both lowest bits are set. We trick it by negating the bits</span>
<span class="line-added">1009   // then test for both bits clear.</span>
<span class="line-added">1010   __ notptr(tmp2);</span>
<span class="line-added">1011   __ testb(tmp2, markWord::marked_value);</span>
<span class="line-added">1012   __ jccb(Assembler::notZero, slow_path);</span>
<span class="line-added">1013   // Clear both lower bits. It&#39;s still inverted, so set them, and then invert back.</span>
<span class="line-added">1014   __ orptr(tmp2, markWord::marked_value);</span>
<span class="line-added">1015   __ notptr(tmp2);</span>
<span class="line-added">1016   // At this point, tmp2 contains the decoded forwarding pointer.</span>
<span class="line-added">1017   __ mov(rax, tmp2);</span>
<span class="line-added">1018 </span>
<span class="line-added">1019   __ pop(tmp2);</span>
<span class="line-added">1020   __ pop(tmp1);</span>
1021   __ ret(0);
1022 
<span class="line-modified">1023   __ bind(slow_path);</span>
1024 
1025   __ push(rcx);
1026   __ push(rdx);
1027   __ push(rdi);
<span class="line-modified">1028 #ifdef _LP64</span>
1029   __ push(r8);
1030   __ push(r9);
1031   __ push(r10);
1032   __ push(r11);
1033   __ push(r12);
1034   __ push(r13);
1035   __ push(r14);
1036   __ push(r15);
<span class="line-modified">1037 #endif</span>
<span class="line-modified">1038   __ push(rbp);</span>
<span class="line-modified">1039   __ movptr(rbp, rsp);</span>
<span class="line-modified">1040   __ andptr(rsp, -StackAlignmentInBytes);</span>
<span class="line-added">1041   __ push_FPU_state();</span>
<span class="line-added">1042   if (UseCompressedOops) {</span>
<span class="line-added">1043     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), rax, rsi);</span>
<span class="line-added">1044   } else {</span>
<span class="line-added">1045     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), rax, rsi);</span>
<span class="line-added">1046   }</span>
<span class="line-added">1047   __ pop_FPU_state();</span>
<span class="line-added">1048   __ movptr(rsp, rbp);</span>
<span class="line-added">1049   __ pop(rbp);</span>
<span class="line-added">1050 #ifdef _LP64</span>
1051   __ pop(r15);
1052   __ pop(r14);
1053   __ pop(r13);
1054   __ pop(r12);
1055   __ pop(r11);
1056   __ pop(r10);
1057   __ pop(r9);
1058   __ pop(r8);
<span class="line-modified">1059 #endif</span>
1060   __ pop(rdi);
1061   __ pop(rdx);
1062   __ pop(rcx);
1063 
<span class="line-modified">1064   __ pop(tmp2);</span>
<span class="line-modified">1065   __ pop(tmp1);</span>
1066   __ ret(0);
<span class="line-modified">1067 </span>


1068   return start;
1069 }
1070 
1071 #undef __
1072 
1073 void ShenandoahBarrierSetAssembler::barrier_stubs_init() {
<span class="line-modified">1074   if (ShenandoahLoadRefBarrier) {</span>
1075     int stub_code_size = 4096;
1076     ResourceMark rm;
1077     BufferBlob* bb = BufferBlob::create(&quot;shenandoah_barrier_stubs&quot;, stub_code_size);
1078     CodeBuffer buf(bb);
1079     StubCodeGenerator cgen(&amp;buf);
<span class="line-modified">1080     _shenandoah_lrb = generate_shenandoah_lrb(&amp;cgen);</span>
1081   }
1082 }
</pre>
</td>
</tr>
</table>
<center><a href="../shared/modRefBarrierSetAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/gc/shared/barrierSetNMethod_x86.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="barrierSetAssembler_x86.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="modRefBarrierSetAssembler_x86.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/gc/shared/barrierSetNMethod_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -33,26 +33,36 @@</span>
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  
  class NativeNMethodCmpBarrier: public NativeInstruction {
  public:
<span class="udiff-line-added">+ #ifdef _LP64</span>
    enum Intel_specific_constants {
      instruction_code        = 0x81,
      instruction_size        = 8,
      imm_offset              = 4,
      instruction_rex_prefix  = Assembler::REX | Assembler::REX_B,
      instruction_modrm       = 0x7f  // [r15 + offset]
    };
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   enum Intel_specific_constants {</span>
<span class="udiff-line-added">+     instruction_code        = 0x81,</span>
<span class="udiff-line-added">+     instruction_size        = 7,</span>
<span class="udiff-line-added">+     imm_offset              = 2,</span>
<span class="udiff-line-added">+     instruction_modrm       = 0x3f  // [rdi]</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ #endif</span>
  
    address instruction_address() const { return addr_at(0); }
    address immediate_address() const { return addr_at(imm_offset); }
  
    jint get_immedate() const { return int_at(imm_offset); }
    void set_immediate(jint imm) { set_int_at(imm_offset, imm); }
    void verify() const;
  };
  
<span class="udiff-line-added">+ #ifdef _LP64</span>
  void NativeNMethodCmpBarrier::verify() const {
    if (((uintptr_t) instruction_address()) &amp; 0x7) {
      fatal(&quot;Not properly aligned&quot;);
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -75,10 +85,31 @@</span>
      tty-&gt;print_cr(&quot;Addr: &quot; INTPTR_FORMAT &quot; mod/rm: 0x%x&quot;, p2i(instruction_address()),
          modrm);
      fatal(&quot;not a cmp barrier&quot;);
    }
  }
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ void NativeNMethodCmpBarrier::verify() const {</span>
<span class="udiff-line-added">+   if (((uintptr_t) instruction_address()) &amp; 0x3) {</span>
<span class="udiff-line-added">+     fatal(&quot;Not properly aligned&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int inst = ubyte_at(0);</span>
<span class="udiff-line-added">+   if (inst != instruction_code) {</span>
<span class="udiff-line-added">+     tty-&gt;print_cr(&quot;Addr: &quot; INTPTR_FORMAT &quot; Code: 0x%x&quot;, p2i(instruction_address()),</span>
<span class="udiff-line-added">+         inst);</span>
<span class="udiff-line-added">+     fatal(&quot;not a cmp barrier&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int modrm = ubyte_at(1);</span>
<span class="udiff-line-added">+   if (modrm != instruction_modrm) {</span>
<span class="udiff-line-added">+     tty-&gt;print_cr(&quot;Addr: &quot; INTPTR_FORMAT &quot; mod/rm: 0x%x&quot;, p2i(instruction_address()),</span>
<span class="udiff-line-added">+         modrm);</span>
<span class="udiff-line-added">+     fatal(&quot;not a cmp barrier&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif // _LP64</span>
  
  void BarrierSetNMethod::deoptimize(nmethod* nm, address* return_address_ptr) {
    /*
     * [ callers frame          ]
     * [ callers return address ] &lt;- callers rsp
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -125,11 +156,11 @@</span>
  // If any code changes between the end of the verified entry where the entry
  // barrier resides, and the completion of the frame, then
  // NativeNMethodCmpBarrier::verify() will immediately complain when it does
  // not find the expected native instruction at this offset, which needs updating.
  // Note that this offset is invariant of PreserveFramePointer.
<span class="udiff-line-modified-removed">- static const int entry_barrier_offset = -19;</span>
<span class="udiff-line-modified-added">+ static const int entry_barrier_offset = LP64_ONLY(-19) NOT_LP64(-18);</span>
  
  static NativeNMethodCmpBarrier* native_nmethod_barrier(nmethod* nm) {
    address barrier_address = nm-&gt;code_begin() + nm-&gt;frame_complete_offset() + entry_barrier_offset;
    NativeNMethodCmpBarrier* barrier = reinterpret_cast&lt;NativeNMethodCmpBarrier*&gt;(barrier_address);
    debug_only(barrier-&gt;verify());
</pre>
<center><a href="barrierSetAssembler_x86.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="modRefBarrierSetAssembler_x86.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
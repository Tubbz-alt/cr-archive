<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/gc/z/zBarrierSetAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../shenandoah/shenandoah_x86_64.ad.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="zBarrierSetAssembler_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/gc/z/zBarrierSetAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 22,26 ***</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;asm/macroAssembler.inline.hpp&quot;
  #include &quot;code/codeBlob.hpp&quot;
  #include &quot;gc/z/zBarrier.inline.hpp&quot;
  #include &quot;gc/z/zBarrierSet.hpp&quot;
  #include &quot;gc/z/zBarrierSetAssembler.hpp&quot;
  #include &quot;gc/z/zBarrierSetRuntime.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">! #include &quot;runtime/stubCodeGenerator.hpp&quot;</span>
  #include &quot;utilities/macros.hpp&quot;
  #ifdef COMPILER1
  #include &quot;c1/c1_LIRAssembler.hpp&quot;
  #include &quot;c1/c1_MacroAssembler.hpp&quot;
  #include &quot;gc/z/c1/zBarrierSetC1.hpp&quot;
  #endif // COMPILER1
<span class="line-modified">! </span>
<span class="line-modified">! ZBarrierSetAssembler::ZBarrierSetAssembler() :</span>
<span class="line-modified">!     _load_barrier_slow_stub(),</span>
<span class="line-removed">-     _load_barrier_weak_slow_stub() {}</span>
  
  #ifdef PRODUCT
  #define BLOCK_COMMENT(str) /* nothing */
  #else
  #define BLOCK_COMMENT(str) __ block_comment(str)
<span class="line-new-header">--- 22,26 ---</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;asm/macroAssembler.inline.hpp&quot;
  #include &quot;code/codeBlob.hpp&quot;
<span class="line-added">+ #include &quot;code/vmreg.inline.hpp&quot;</span>
  #include &quot;gc/z/zBarrier.inline.hpp&quot;
  #include &quot;gc/z/zBarrierSet.hpp&quot;
  #include &quot;gc/z/zBarrierSetAssembler.hpp&quot;
  #include &quot;gc/z/zBarrierSetRuntime.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">! #include &quot;runtime/sharedRuntime.hpp&quot;</span>
  #include &quot;utilities/macros.hpp&quot;
  #ifdef COMPILER1
  #include &quot;c1/c1_LIRAssembler.hpp&quot;
  #include &quot;c1/c1_MacroAssembler.hpp&quot;
  #include &quot;gc/z/c1/zBarrierSetC1.hpp&quot;
  #endif // COMPILER1
<span class="line-modified">! #ifdef COMPILER2</span>
<span class="line-modified">! #include &quot;gc/z/c2/zBarrierSetC2.hpp&quot;</span>
<span class="line-modified">! #endif // COMPILER2</span>
  
  #ifdef PRODUCT
  #define BLOCK_COMMENT(str) /* nothing */
  #else
  #define BLOCK_COMMENT(str) __ block_comment(str)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 196,11 ***</span>
                                      Register tmp1,
                                      Register tmp2) {
    BLOCK_COMMENT(&quot;ZBarrierSetAssembler::store_at {&quot;);
  
    // Verify oop store
<span class="line-modified">!   if (type == T_OBJECT || type == T_ARRAY) {</span>
      // Note that src could be noreg, which means we
      // are storing null and can skip verification.
      if (src != noreg) {
        Label done;
        __ testptr(src, address_bad_mask_from_thread(r15_thread));
<span class="line-new-header">--- 196,11 ---</span>
                                      Register tmp1,
                                      Register tmp2) {
    BLOCK_COMMENT(&quot;ZBarrierSetAssembler::store_at {&quot;);
  
    // Verify oop store
<span class="line-modified">!   if (is_reference_type(type)) {</span>
      // Note that src could be noreg, which means we
      // are storing null and can skip verification.
      if (src != noreg) {
        Label done;
        __ testptr(src, address_bad_mask_from_thread(r15_thread));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 342,139 ***</span>
    __ ret(0);
  }
  
  #endif // COMPILER1
  
<span class="line-modified">! #undef __</span>
<span class="line-modified">! #define __ cgen-&gt;assembler()-&gt;</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Generates a register specific stub for calling</span>
<span class="line-modified">! // ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded() or</span>
<span class="line-modified">! // ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded().</span>
<span class="line-modified">! //</span>
<span class="line-modified">! // The raddr register serves as both input and output for this stub. When the stub is</span>
<span class="line-modified">! // called the raddr register contains the object field address (oop*) where the bad oop</span>
<span class="line-modified">! // was loaded from, which caused the slow path to be taken. On return from the stub the</span>
<span class="line-modified">! // raddr register contains the good/healed oop returned from</span>
<span class="line-modified">! // ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded() or</span>
<span class="line-modified">! // ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded().</span>
<span class="line-modified">! static address generate_load_barrier_stub(StubCodeGenerator* cgen, Register raddr, DecoratorSet decorators) {</span>
<span class="line-modified">!   // Don&#39;t generate stub for invalid registers</span>
<span class="line-modified">!   if (raddr == rsp || raddr == r15) {</span>
<span class="line-modified">!     return NULL;</span>
    }
  
<span class="line-modified">!   // Create stub name</span>
<span class="line-modified">!   char name[64];</span>
<span class="line-removed">-   const bool weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;</span>
<span class="line-removed">-   os::snprintf(name, sizeof(name), &quot;zgc_load_barrier%s_stub_%s&quot;, weak ? &quot;_weak&quot; : &quot;&quot;, raddr-&gt;name());</span>
  
<span class="line-modified">!   __ align(CodeEntryAlignment);</span>
<span class="line-modified">!   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, os::strdup(name, mtCode));</span>
<span class="line-modified">!   address start = __ pc();</span>
  
<span class="line-modified">!   // Save live registers</span>
<span class="line-modified">!   if (raddr != rax) {</span>
<span class="line-modified">!     __ push(rax);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (raddr != rcx) {</span>
<span class="line-modified">!     __ push(rcx);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (raddr != rdx) {</span>
<span class="line-modified">!     __ push(rdx);</span>
    }
<span class="line-modified">!   if (raddr != rsi) {</span>
<span class="line-modified">!     __ push(rsi);</span>
    }
<span class="line-modified">!   if (raddr != rdi) {</span>
<span class="line-modified">!     __ push(rdi);</span>
    }
<span class="line-modified">!   if (raddr != r8) {</span>
<span class="line-modified">!     __ push(r8);</span>
    }
<span class="line-modified">!   if (raddr != r9) {</span>
<span class="line-modified">!     __ push(r9);</span>
    }
<span class="line-modified">!   if (raddr != r10) {</span>
<span class="line-modified">!     __ push(r10);</span>
    }
<span class="line-modified">!   if (raddr != r11) {</span>
<span class="line-modified">!     __ push(r11);</span>
    }
  
<span class="line-modified">!   // Setup arguments</span>
<span class="line-modified">!   if (raddr != c_rarg1) {</span>
<span class="line-modified">!     __ movq(c_rarg1, raddr);</span>
    }
<span class="line-removed">-   __ movq(c_rarg0, Address(raddr, 0));</span>
  
<span class="line-modified">!   // Call barrier function</span>
<span class="line-modified">!   __ call_VM_leaf(ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr(decorators), c_rarg0, c_rarg1);</span>
  
<span class="line-modified">!   // Move result returned in rax to raddr, if needed</span>
<span class="line-modified">!   if (raddr != rax) {</span>
<span class="line-modified">!     __ movq(raddr, rax);</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   // Restore saved registers</span>
<span class="line-modified">!   if (raddr != r11) {</span>
<span class="line-modified">!     __ pop(r11);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (raddr != r10) {</span>
<span class="line-modified">!     __ pop(r10);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (raddr != r9) {</span>
<span class="line-modified">!     __ pop(r9);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (raddr != r8) {</span>
<span class="line-modified">!     __ pop(r8);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (raddr != rdi) {</span>
<span class="line-modified">!     __ pop(rdi);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (raddr != rsi) {</span>
<span class="line-modified">!     __ pop(rsi);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (raddr != rdx) {</span>
<span class="line-modified">!     __ pop(rdx);</span>
    }
<span class="line-modified">!   if (raddr != rcx) {</span>
<span class="line-modified">!     __ pop(rcx);</span>
    }
<span class="line-modified">!   if (raddr != rax) {</span>
<span class="line-modified">!     __ pop(rax);</span>
    }
  
<span class="line-modified">!   __ ret(0);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   return start;</span>
<span class="line-modified">! }</span>
  
  #undef __
  
<span class="line-modified">! static void barrier_stubs_init_inner(const char* label, const DecoratorSet decorators, address* stub) {</span>
<span class="line-modified">!   const int nregs = RegisterImpl::number_of_registers;</span>
<span class="line-removed">-   const int code_size = nregs * 128; // Rough estimate of code size</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ResourceMark rm;</span>
  
<span class="line-modified">!   CodeBuffer buf(BufferBlob::create(label, code_size));</span>
<span class="line-modified">!   StubCodeGenerator cgen(&amp;buf);</span>
  
<span class="line-modified">!   for (int i = 0; i &lt; nregs; i++) {</span>
<span class="line-modified">!     const Register reg = as_Register(i);</span>
<span class="line-modified">!     stub[i] = generate_load_barrier_stub(&amp;cgen, reg, decorators);</span>
    }
<span class="line-removed">- }</span>
  
<span class="line-modified">! void ZBarrierSetAssembler::barrier_stubs_init() {</span>
<span class="line-modified">!   barrier_stubs_init_inner(&quot;zgc_load_barrier_stubs&quot;, ON_STRONG_OOP_REF, _load_barrier_slow_stub);</span>
<span class="line-removed">-   barrier_stubs_init_inner(&quot;zgc_load_barrier_weak_stubs&quot;, ON_WEAK_OOP_REF, _load_barrier_weak_slow_stub);</span>
  }
  
<span class="line-modified">! address ZBarrierSetAssembler::load_barrier_slow_stub(Register reg) {</span>
<span class="line-removed">-   return _load_barrier_slow_stub[reg-&gt;encoding()];</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! address ZBarrierSetAssembler::load_barrier_weak_slow_stub(Register reg) {</span>
<span class="line-removed">-   return _load_barrier_weak_slow_stub[reg-&gt;encoding()];</span>
<span class="line-removed">- }</span>
<span class="line-new-header">--- 342,332 ---</span>
    __ ret(0);
  }
  
  #endif // COMPILER1
  
<span class="line-modified">! #ifdef COMPILER2</span>
<span class="line-modified">! </span>
<span class="line-modified">! OptoReg::Name ZBarrierSetAssembler::refine_register(const Node* node, OptoReg::Name opto_reg) {</span>
<span class="line-modified">!   if (!OptoReg::is_reg(opto_reg)) {</span>
<span class="line-modified">!     return OptoReg::Bad;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   const VMReg vm_reg = OptoReg::as_VMReg(opto_reg);</span>
<span class="line-modified">!   if (vm_reg-&gt;is_XMMRegister()) {</span>
<span class="line-modified">!     opto_reg &amp;= ~15;</span>
<span class="line-modified">!     switch (node-&gt;ideal_reg()) {</span>
<span class="line-modified">!       case Op_VecX:</span>
<span class="line-modified">!         opto_reg |= 2;</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       case Op_VecY:</span>
<span class="line-modified">!         opto_reg |= 4;</span>
<span class="line-modified">!         break;</span>
<span class="line-added">+       case Op_VecZ:</span>
<span class="line-added">+         opto_reg |= 8;</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       default:</span>
<span class="line-added">+         opto_reg |= 1;</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
    }
  
<span class="line-modified">!   return opto_reg;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! // We use the vec_spill_helper from the x86.ad file to avoid reinventing this wheel</span>
<span class="line-modified">! extern int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,</span>
<span class="line-modified">!                             int stack_offset, int reg, uint ireg, outputStream* st);</span>
  
<span class="line-modified">! #undef __</span>
<span class="line-modified">! #define __ _masm-&gt;</span>
<span class="line-modified">! </span>
<span class="line-modified">! class ZSaveLiveRegisters {</span>
<span class="line-modified">! private:</span>
<span class="line-modified">!   struct XMMRegisterData {</span>
<span class="line-modified">!     XMMRegister _reg;</span>
<span class="line-modified">!     int         _size;</span>
<span class="line-modified">! </span>
<span class="line-added">+     // Used by GrowableArray::find()</span>
<span class="line-added">+     bool operator == (const XMMRegisterData&amp; other) {</span>
<span class="line-added">+       return _reg == other._reg;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
<span class="line-added">+   MacroAssembler* const          _masm;</span>
<span class="line-added">+   GrowableArray&lt;Register&gt;        _gp_registers;</span>
<span class="line-added">+   GrowableArray&lt;XMMRegisterData&gt; _xmm_registers;</span>
<span class="line-added">+   int                            _spill_size;</span>
<span class="line-added">+   int                            _spill_offset;</span>
<span class="line-added">+ </span>
<span class="line-added">+   static int xmm_compare_register_size(XMMRegisterData* left, XMMRegisterData* right) {</span>
<span class="line-added">+     if (left-&gt;_size == right-&gt;_size) {</span>
<span class="line-added">+       return 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return (left-&gt;_size &lt; right-&gt;_size) ? -1 : 1;</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   static int xmm_slot_size(OptoReg::Name opto_reg) {</span>
<span class="line-added">+     // The low order 4 bytes denote what size of the XMM register is live</span>
<span class="line-added">+     return (opto_reg &amp; 15) &lt;&lt; 3;</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   static uint xmm_ideal_reg_for_size(int reg_size) {</span>
<span class="line-added">+     switch (reg_size) {</span>
<span class="line-added">+     case 8:</span>
<span class="line-added">+       return Op_VecD;</span>
<span class="line-added">+     case 16:</span>
<span class="line-added">+       return Op_VecX;</span>
<span class="line-added">+     case 32:</span>
<span class="line-added">+       return Op_VecY;</span>
<span class="line-added">+     case 64:</span>
<span class="line-added">+       return Op_VecZ;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       fatal(&quot;Invalid register size %d&quot;, reg_size);</span>
<span class="line-added">+       return 0;</span>
<span class="line-added">+     }</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   bool xmm_needs_vzeroupper() const {</span>
<span class="line-added">+     return _xmm_registers.is_nonempty() &amp;&amp; _xmm_registers.at(0)._size &gt; 16;</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   void xmm_register_save(const XMMRegisterData&amp; reg_data) {</span>
<span class="line-added">+     const OptoReg::Name opto_reg = OptoReg::as_OptoReg(reg_data._reg-&gt;as_VMReg());</span>
<span class="line-added">+     const uint ideal_reg = xmm_ideal_reg_for_size(reg_data._size);</span>
<span class="line-added">+     _spill_offset -= reg_data._size;</span>
<span class="line-added">+     vec_spill_helper(__ code(), false /* do_size */, false /* is_load */, _spill_offset, opto_reg, ideal_reg, tty);</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   void xmm_register_restore(const XMMRegisterData&amp; reg_data) {</span>
<span class="line-added">+     const OptoReg::Name opto_reg = OptoReg::as_OptoReg(reg_data._reg-&gt;as_VMReg());</span>
<span class="line-added">+     const uint ideal_reg = xmm_ideal_reg_for_size(reg_data._size);</span>
<span class="line-added">+     vec_spill_helper(__ code(), false /* do_size */, true /* is_load */, _spill_offset, opto_reg, ideal_reg, tty);</span>
<span class="line-added">+     _spill_offset += reg_data._size;</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   void gp_register_save(Register reg) {</span>
<span class="line-added">+     _spill_offset -= 8;</span>
<span class="line-added">+     __ movq(Address(rsp, _spill_offset), reg);</span>
    }
  
<span class="line-modified">!   void gp_register_restore(Register reg) {</span>
<span class="line-modified">!     __ movq(reg, Address(rsp, _spill_offset));</span>
<span class="line-modified">!     _spill_offset += 8;</span>
    }
  
<span class="line-modified">!   void initialize(ZLoadBarrierStubC2* stub) {</span>
<span class="line-modified">!     // Create mask of caller saved registers that need to</span>
<span class="line-added">+     // be saved/restored if live</span>
<span class="line-added">+     RegMask caller_saved;</span>
<span class="line-added">+     caller_saved.Insert(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));</span>
<span class="line-added">+     caller_saved.Insert(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));</span>
<span class="line-added">+     caller_saved.Insert(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));</span>
<span class="line-added">+     caller_saved.Insert(OptoReg::as_OptoReg(rsi-&gt;as_VMReg()));</span>
<span class="line-added">+     caller_saved.Insert(OptoReg::as_OptoReg(rdi-&gt;as_VMReg()));</span>
<span class="line-added">+     caller_saved.Insert(OptoReg::as_OptoReg(r8-&gt;as_VMReg()));</span>
<span class="line-added">+     caller_saved.Insert(OptoReg::as_OptoReg(r9-&gt;as_VMReg()));</span>
<span class="line-added">+     caller_saved.Insert(OptoReg::as_OptoReg(r10-&gt;as_VMReg()));</span>
<span class="line-added">+     caller_saved.Insert(OptoReg::as_OptoReg(r11-&gt;as_VMReg()));</span>
<span class="line-added">+     caller_saved.Remove(OptoReg::as_OptoReg(stub-&gt;ref()-&gt;as_VMReg()));</span>
  
<span class="line-modified">!     // Create mask of live registers</span>
<span class="line-modified">!     RegMask live = stub-&gt;live();</span>
<span class="line-modified">!     if (stub-&gt;tmp() != noreg) {</span>
<span class="line-modified">!       live.Insert(OptoReg::as_OptoReg(stub-&gt;tmp()-&gt;as_VMReg()));</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     int gp_spill_size = 0;</span>
<span class="line-modified">!     int xmm_spill_size = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Record registers that needs to be saved/restored</span>
<span class="line-modified">!     while (live.is_NotEmpty()) {</span>
<span class="line-modified">!       const OptoReg::Name opto_reg = live.find_first_elem();</span>
<span class="line-modified">!       const VMReg vm_reg = OptoReg::as_VMReg(opto_reg);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       live.Remove(opto_reg);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       if (vm_reg-&gt;is_Register()) {</span>
<span class="line-modified">!         if (caller_saved.Member(opto_reg)) {</span>
<span class="line-modified">!           _gp_registers.append(vm_reg-&gt;as_Register());</span>
<span class="line-modified">!           gp_spill_size += 8;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       } else if (vm_reg-&gt;is_XMMRegister()) {</span>
<span class="line-modified">!         // We encode in the low order 4 bits of the opto_reg, how large part of the register is live</span>
<span class="line-modified">!         const VMReg vm_reg_base = OptoReg::as_VMReg(opto_reg &amp; ~15);</span>
<span class="line-modified">!         const int reg_size = xmm_slot_size(opto_reg);</span>
<span class="line-modified">!         const XMMRegisterData reg_data = { vm_reg_base-&gt;as_XMMRegister(), reg_size };</span>
<span class="line-modified">!         const int reg_index = _xmm_registers.find(reg_data);</span>
<span class="line-added">+         if (reg_index == -1) {</span>
<span class="line-added">+           // Not previously appended</span>
<span class="line-added">+           _xmm_registers.append(reg_data);</span>
<span class="line-added">+           xmm_spill_size += reg_size;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           // Previously appended, update size</span>
<span class="line-added">+           const int reg_size_prev = _xmm_registers.at(reg_index)._size;</span>
<span class="line-added">+           if (reg_size &gt; reg_size_prev) {</span>
<span class="line-added">+             _xmm_registers.at_put(reg_index, reg_data);</span>
<span class="line-added">+             xmm_spill_size += reg_size - reg_size_prev;</span>
<span class="line-added">+           }</span>
<span class="line-added">+         }</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         fatal(&quot;Unexpected register type&quot;);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Sort by size, largest first</span>
<span class="line-added">+     _xmm_registers.sort(xmm_compare_register_size);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // On Windows, the caller reserves stack space for spilling register arguments</span>
<span class="line-added">+     const int arg_spill_size = frame::arg_reg_save_area_bytes;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Stack pointer must be 16 bytes aligned for the call</span>
<span class="line-added">+     _spill_offset = _spill_size = align_up(xmm_spill_size + gp_spill_size + arg_spill_size, 16);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ZSaveLiveRegisters(MacroAssembler* masm, ZLoadBarrierStubC2* stub) :</span>
<span class="line-added">+       _masm(masm),</span>
<span class="line-added">+       _gp_registers(),</span>
<span class="line-added">+       _xmm_registers(),</span>
<span class="line-added">+       _spill_size(0),</span>
<span class="line-added">+       _spill_offset(0) {</span>
<span class="line-added">+ </span>
<span class="line-added">+     //</span>
<span class="line-added">+     // Stack layout after registers have been spilled:</span>
<span class="line-added">+     //</span>
<span class="line-added">+     // | ...            | original rsp, 16 bytes aligned</span>
<span class="line-added">+     // ------------------</span>
<span class="line-added">+     // | zmm0 high      |</span>
<span class="line-added">+     // | ...            |</span>
<span class="line-added">+     // | zmm0 low       | 16 bytes aligned</span>
<span class="line-added">+     // | ...            |</span>
<span class="line-added">+     // | ymm1 high      |</span>
<span class="line-added">+     // | ...            |</span>
<span class="line-added">+     // | ymm1 low       | 16 bytes aligned</span>
<span class="line-added">+     // | ...            |</span>
<span class="line-added">+     // | xmmN high      |</span>
<span class="line-added">+     // | ...            |</span>
<span class="line-added">+     // | xmmN low       | 8 bytes aligned</span>
<span class="line-added">+     // | reg0           | 8 bytes aligned</span>
<span class="line-added">+     // | reg1           |</span>
<span class="line-added">+     // | ...            |</span>
<span class="line-added">+     // | regN           | new rsp, if 16 bytes aligned</span>
<span class="line-added">+     // | &lt;padding&gt;      | else new rsp, 16 bytes aligned</span>
<span class="line-added">+     // ------------------</span>
<span class="line-added">+     //</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Figure out what registers to save/restore</span>
<span class="line-added">+     initialize(stub);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Allocate stack space</span>
<span class="line-added">+     if (_spill_size &gt; 0) {</span>
<span class="line-added">+       __ subptr(rsp, _spill_size);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Save XMM/YMM/ZMM registers</span>
<span class="line-added">+     for (int i = 0; i &lt; _xmm_registers.length(); i++) {</span>
<span class="line-added">+       xmm_register_save(_xmm_registers.at(i));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (xmm_needs_vzeroupper()) {</span>
<span class="line-added">+       __ vzeroupper();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Save general purpose registers</span>
<span class="line-added">+     for (int i = 0; i &lt; _gp_registers.length(); i++) {</span>
<span class="line-added">+       gp_register_save(_gp_registers.at(i));</span>
<span class="line-added">+     }</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   ~ZSaveLiveRegisters() {</span>
<span class="line-added">+     // Restore general purpose registers</span>
<span class="line-added">+     for (int i = _gp_registers.length() - 1; i &gt;= 0; i--) {</span>
<span class="line-added">+       gp_register_restore(_gp_registers.at(i));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ vzeroupper();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Restore XMM/YMM/ZMM registers</span>
<span class="line-added">+     for (int i = _xmm_registers.length() - 1; i &gt;= 0; i--) {</span>
<span class="line-added">+       xmm_register_restore(_xmm_registers.at(i));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Free stack space</span>
<span class="line-added">+     if (_spill_size &gt; 0) {</span>
<span class="line-added">+       __ addptr(rsp, _spill_size);</span>
<span class="line-added">+     }</span>
    }
<span class="line-modified">! };</span>
<span class="line-modified">! </span>
<span class="line-added">+ class ZSetupArguments {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   MacroAssembler* const _masm;</span>
<span class="line-added">+   const Register        _ref;</span>
<span class="line-added">+   const Address         _ref_addr;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ZSetupArguments(MacroAssembler* masm, ZLoadBarrierStubC2* stub) :</span>
<span class="line-added">+       _masm(masm),</span>
<span class="line-added">+       _ref(stub-&gt;ref()),</span>
<span class="line-added">+       _ref_addr(stub-&gt;ref_addr()) {</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Setup arguments</span>
<span class="line-added">+     if (_ref_addr.base() == noreg) {</span>
<span class="line-added">+       // No self healing</span>
<span class="line-added">+       if (_ref != c_rarg0) {</span>
<span class="line-added">+         __ movq(c_rarg0, _ref);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       __ xorq(c_rarg1, c_rarg1);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // Self healing</span>
<span class="line-added">+       if (_ref == c_rarg0) {</span>
<span class="line-added">+         __ lea(c_rarg1, _ref_addr);</span>
<span class="line-added">+       } else if (_ref != c_rarg1) {</span>
<span class="line-added">+         __ lea(c_rarg1, _ref_addr);</span>
<span class="line-added">+         __ movq(c_rarg0, _ref);</span>
<span class="line-added">+       } else if (_ref_addr.base() != c_rarg0 &amp;&amp; _ref_addr.index() != c_rarg0) {</span>
<span class="line-added">+         __ movq(c_rarg0, _ref);</span>
<span class="line-added">+         __ lea(c_rarg1, _ref_addr);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         __ xchgq(c_rarg0, c_rarg1);</span>
<span class="line-added">+         if (_ref_addr.base() == c_rarg0) {</span>
<span class="line-added">+           __ lea(c_rarg1, Address(c_rarg1, _ref_addr.index(), _ref_addr.scale(), _ref_addr.disp()));</span>
<span class="line-added">+         } else if (_ref_addr.index() == c_rarg0) {</span>
<span class="line-added">+           __ lea(c_rarg1, Address(_ref_addr.base(), c_rarg1, _ref_addr.scale(), _ref_addr.disp()));</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           ShouldNotReachHere();</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
    }
  
<span class="line-modified">!   ~ZSetupArguments() {</span>
<span class="line-modified">!     // Transfer result</span>
<span class="line-modified">!     if (_ref != rax) {</span>
<span class="line-modified">!       __ movq(_ref, rax);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
  
  #undef __
<span class="line-added">+ #define __ masm-&gt;</span>
  
<span class="line-modified">! void ZBarrierSetAssembler::generate_c2_load_barrier_stub(MacroAssembler* masm, ZLoadBarrierStubC2* stub) const {</span>
<span class="line-modified">!   BLOCK_COMMENT(&quot;ZLoadBarrierStubC2&quot;);</span>
  
<span class="line-modified">!   // Stub entry</span>
<span class="line-modified">!   __ bind(*stub-&gt;entry());</span>
  
<span class="line-modified">!   {</span>
<span class="line-modified">!     ZSaveLiveRegisters save_live_registers(masm, stub);</span>
<span class="line-modified">!     ZSetupArguments setup_arguments(masm, stub);</span>
<span class="line-added">+     __ call(RuntimeAddress(stub-&gt;slow_path()));</span>
    }
  
<span class="line-modified">!   // Stub exit</span>
<span class="line-modified">!   __ jmp(*stub-&gt;continuation());</span>
  }
  
<span class="line-modified">! #undef __</span>
  
<span class="line-modified">! #endif // COMPILER2</span>
</pre>
<center><a href="../shenandoah/shenandoah_x86_64.ad.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="zBarrierSetAssembler_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
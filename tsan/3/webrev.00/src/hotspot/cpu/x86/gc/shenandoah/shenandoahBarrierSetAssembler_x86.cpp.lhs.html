<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
<a name="2" id="anc2"></a>
 25 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 26 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;</span>

 27 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
 31 #include &quot;interpreter/interpreter.hpp&quot;
 32 #include &quot;interpreter/interp_masm.hpp&quot;
 33 #include &quot;runtime/sharedRuntime.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 #include &quot;utilities/macros.hpp&quot;
 36 #ifdef COMPILER1
 37 #include &quot;c1/c1_LIRAssembler.hpp&quot;
 38 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 39 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
 40 #endif
 41 
 42 #define __ masm-&gt;
 43 
<a name="4" id="anc4"></a><span class="line-modified"> 44 address ShenandoahBarrierSetAssembler::_shenandoah_wb = NULL;</span>
 45 
 46 void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
 47                                                        Register src, Register dst, Register count) {
 48 
<a name="5" id="anc5"></a><span class="line-removed"> 49   bool checkcast = (decorators &amp; ARRAYCOPY_CHECKCAST) != 0;</span>
<span class="line-removed"> 50   bool disjoint = (decorators &amp; ARRAYCOPY_DISJOINT) != 0;</span>
<span class="line-removed"> 51   bool obj_int = type == T_OBJECT LP64_ONLY(&amp;&amp; UseCompressedOops);</span>
 52   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
 53 
<a name="6" id="anc6"></a><span class="line-modified"> 54   if (type == T_OBJECT || type == T_ARRAY) {</span>


 55 #ifdef _LP64
<a name="7" id="anc7"></a><span class="line-modified"> 56     if (!checkcast &amp;&amp; !obj_int) {</span>
<span class="line-removed"> 57       // Save count for barrier</span>
<span class="line-removed"> 58       __ movptr(r11, count);</span>
<span class="line-removed"> 59     } else if (disjoint &amp;&amp; obj_int) {</span>
<span class="line-removed"> 60       // Save dst in r11 in the disjoint case</span>
<span class="line-removed"> 61       __ movq(r11, dst);</span>
<span class="line-removed"> 62     }</span>
 63 #else
<a name="8" id="anc8"></a><span class="line-modified"> 64     if (disjoint) {</span>
<span class="line-modified"> 65       __ mov(rdx, dst);          // save &#39;to&#39;</span>
<span class="line-modified"> 66     }</span>
<span class="line-modified"> 67 #endif</span>
<span class="line-modified"> 68 </span>
<span class="line-modified"> 69     if (!dest_uninitialized &amp;&amp; !ShenandoahHeap::heap()-&gt;heuristics()-&gt;can_do_traversal_gc()) {</span>
<span class="line-modified"> 70       Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);</span>
<span class="line-modified"> 71 #ifndef _LP64</span>


 72       __ push(thread);
 73       __ get_thread(thread);
 74 #endif
<a name="9" id="anc9"></a>
 75 
<a name="10" id="anc10"></a><span class="line-modified"> 76       Label filtered;</span>
<span class="line-modified"> 77       Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));</span>
<span class="line-modified"> 78       // Is marking active?</span>
<span class="line-modified"> 79       if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {</span>
<span class="line-removed"> 80         __ cmpl(in_progress, 0);</span>
<span class="line-removed"> 81       } else {</span>
<span class="line-removed"> 82         assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, &quot;Assumption&quot;);</span>
<span class="line-removed"> 83         __ cmpb(in_progress, 0);</span>
<span class="line-removed"> 84       }</span>
<span class="line-removed"> 85 </span>
<span class="line-removed"> 86       NOT_LP64(__ pop(thread);)</span>
 87 
<a name="11" id="anc11"></a><span class="line-modified"> 88         __ jcc(Assembler::equal, filtered);</span>







 89 
 90       __ pusha();                      // push registers
 91 #ifdef _LP64
<a name="12" id="anc12"></a><span class="line-modified"> 92       if (count == c_rarg0) {</span>
<span class="line-modified"> 93         if (dst == c_rarg1) {</span>
<span class="line-modified"> 94           // exactly backwards!!</span>
<span class="line-modified"> 95           __ xchgptr(c_rarg1, c_rarg0);</span>


 96         } else {
<a name="13" id="anc13"></a><span class="line-modified"> 97           __ movptr(c_rarg1, count);</span>
<span class="line-removed"> 98           __ movptr(c_rarg0, dst);</span>
 99         }
<a name="14" id="anc14"></a><span class="line-modified">100       } else {</span>
<span class="line-removed">101         __ movptr(c_rarg0, dst);</span>
<span class="line-removed">102         __ movptr(c_rarg1, count);</span>
<span class="line-removed">103       }</span>
<span class="line-removed">104       if (UseCompressedOops) {</span>
<span class="line-removed">105         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_narrow_oop_entry), 2);</span>
<span class="line-removed">106       } else {</span>
<span class="line-removed">107         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry), 2);</span>
<span class="line-removed">108       }</span>
<span class="line-removed">109 #else</span>
<span class="line-removed">110       __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry),</span>
<span class="line-removed">111                       dst, count);</span>
112 #endif
<a name="15" id="anc15"></a>






113       __ popa();
<a name="16" id="anc16"></a><span class="line-modified">114       __ bind(filtered);</span>

115     }
116   }
117 
118 }
119 
<a name="17" id="anc17"></a><span class="line-removed">120 void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,</span>
<span class="line-removed">121                                                        Register src, Register dst, Register count) {</span>
<span class="line-removed">122   bool checkcast = (decorators &amp; ARRAYCOPY_CHECKCAST) != 0;</span>
<span class="line-removed">123   bool disjoint = (decorators &amp; ARRAYCOPY_DISJOINT) != 0;</span>
<span class="line-removed">124   bool obj_int = type == T_OBJECT LP64_ONLY(&amp;&amp; UseCompressedOops);</span>
<span class="line-removed">125   Register tmp = rax;</span>
<span class="line-removed">126 </span>
<span class="line-removed">127   if (type == T_OBJECT || type == T_ARRAY) {</span>
<span class="line-removed">128 #ifdef _LP64</span>
<span class="line-removed">129     if (!checkcast &amp;&amp; !obj_int) {</span>
<span class="line-removed">130       // Save count for barrier</span>
<span class="line-removed">131       count = r11;</span>
<span class="line-removed">132     } else if (disjoint &amp;&amp; obj_int) {</span>
<span class="line-removed">133       // Use the saved dst in the disjoint case</span>
<span class="line-removed">134       dst = r11;</span>
<span class="line-removed">135     } else if (checkcast) {</span>
<span class="line-removed">136       tmp = rscratch1;</span>
<span class="line-removed">137     }</span>
<span class="line-removed">138 #else</span>
<span class="line-removed">139     if (disjoint) {</span>
<span class="line-removed">140       __ mov(dst, rdx); // restore &#39;to&#39;</span>
<span class="line-removed">141     }</span>
<span class="line-removed">142 #endif</span>
<span class="line-removed">143 </span>
<span class="line-removed">144     __ pusha();             // push registers (overkill)</span>
<span class="line-removed">145 #ifdef _LP64</span>
<span class="line-removed">146     if (c_rarg0 == count) { // On win64 c_rarg0 == rcx</span>
<span class="line-removed">147       assert_different_registers(c_rarg1, dst);</span>
<span class="line-removed">148       __ mov(c_rarg1, count);</span>
<span class="line-removed">149       __ mov(c_rarg0, dst);</span>
<span class="line-removed">150     } else {</span>
<span class="line-removed">151       assert_different_registers(c_rarg0, count);</span>
<span class="line-removed">152       __ mov(c_rarg0, dst);</span>
<span class="line-removed">153       __ mov(c_rarg1, count);</span>
<span class="line-removed">154     }</span>
<span class="line-removed">155     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_post_entry), 2);</span>
<span class="line-removed">156 #else</span>
<span class="line-removed">157     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_post_entry),</span>
<span class="line-removed">158                     dst, count);</span>
<span class="line-removed">159 #endif</span>
<span class="line-removed">160     __ popa();</span>
<span class="line-removed">161   }</span>
<span class="line-removed">162 }</span>
<span class="line-removed">163 </span>
164 void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
165                                                                  Register obj,
166                                                                  Register pre_val,
167                                                                  Register thread,
168                                                                  Register tmp,
169                                                                  bool tosca_live,
170                                                                  bool expand_call) {
171 
172   if (ShenandoahSATBBarrier) {
173     satb_write_barrier_pre(masm, obj, pre_val, thread, tmp, tosca_live, expand_call);
174   }
175 }
176 
177 void ShenandoahBarrierSetAssembler::satb_write_barrier_pre(MacroAssembler* masm,
178                                                            Register obj,
179                                                            Register pre_val,
180                                                            Register thread,
181                                                            Register tmp,
182                                                            bool tosca_live,
183                                                            bool expand_call) {
184   // If expand_call is true then we expand the call_VM_leaf macro
185   // directly to skip generating the check by
186   // InterpreterMacroAssembler::call_VM_leaf_base that checks _last_sp.
187 
188 #ifdef _LP64
189   assert(thread == r15_thread, &quot;must be&quot;);
190 #endif // _LP64
191 
192   Label done;
193   Label runtime;
194 
195   assert(pre_val != noreg, &quot;check this code&quot;);
196 
197   if (obj != noreg) {
198     assert_different_registers(obj, pre_val, tmp);
199     assert(pre_val != rax, &quot;check this code&quot;);
200   }
201 
202   Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));
203   Address index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
204   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
205 
206   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
207   __ testb(gc_state, ShenandoahHeap::MARKING | ShenandoahHeap::TRAVERSAL);
208   __ jcc(Assembler::zero, done);
209 
210   // Do we need to load the previous value?
211   if (obj != noreg) {
212     __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);
213   }
214 
215   // Is the previous value null?
216   __ cmpptr(pre_val, (int32_t) NULL_WORD);
217   __ jcc(Assembler::equal, done);
218 
219   // Can we store original value in the thread&#39;s buffer?
220   // Is index == 0?
221   // (The index field is typed as size_t.)
222 
223   __ movptr(tmp, index);                   // tmp := *index_adr
224   __ cmpptr(tmp, 0);                       // tmp == 0?
225   __ jcc(Assembler::equal, runtime);       // If yes, goto runtime
226 
227   __ subptr(tmp, wordSize);                // tmp := tmp - wordSize
228   __ movptr(index, tmp);                   // *index_adr := tmp
229   __ addptr(tmp, buffer);                  // tmp := tmp + *buffer_adr
230 
231   // Record the previous value
232   __ movptr(Address(tmp, 0), pre_val);
233   __ jmp(done);
234 
235   __ bind(runtime);
236   // save the live input values
237   if(tosca_live) __ push(rax);
238 
239   if (obj != noreg &amp;&amp; obj != rax)
240     __ push(obj);
241 
242   if (pre_val != rax)
243     __ push(pre_val);
244 
245   // Calling the runtime using the regular call_VM_leaf mechanism generates
246   // code (generated by InterpreterMacroAssember::call_VM_leaf_base)
247   // that checks that the *(ebp+frame::interpreter_frame_last_sp) == NULL.
248   //
249   // If we care generating the pre-barrier without a frame (e.g. in the
250   // intrinsified Reference.get() routine) then ebp might be pointing to
251   // the caller frame and so this check will most likely fail at runtime.
252   //
253   // Expanding the call directly bypasses the generation of the check.
254   // So when we do not have have a full interpreter frame on the stack
255   // expand_call should be passed true.
256 
257   NOT_LP64( __ push(thread); )
258 
259 #ifdef _LP64
260   // We move pre_val into c_rarg0 early, in order to avoid smashing it, should
261   // pre_val be c_rarg1 (where the call prologue would copy thread argument).
262   // Note: this should not accidentally smash thread, because thread is always r15.
263   assert(thread != c_rarg0, &quot;smashed arg&quot;);
264   if (c_rarg0 != pre_val) {
265     __ mov(c_rarg0, pre_val);
266   }
267 #endif
268 
269   if (expand_call) {
270     LP64_ONLY( assert(pre_val != c_rarg1, &quot;smashed arg&quot;); )
271 #ifdef _LP64
272     if (c_rarg1 != thread) {
273       __ mov(c_rarg1, thread);
274     }
275     // Already moved pre_val into c_rarg0 above
276 #else
277     __ push(thread);
278     __ push(pre_val);
279 #endif
280     __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), 2);
281   } else {
282     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), LP64_ONLY(c_rarg0) NOT_LP64(pre_val), thread);
283   }
284 
285   NOT_LP64( __ pop(thread); )
286 
287   // save the live input values
288   if (pre_val != rax)
289     __ pop(pre_val);
290 
291   if (obj != noreg &amp;&amp; obj != rax)
292     __ pop(obj);
293 
294   if(tosca_live) __ pop(rax);
295 
296   __ bind(done);
297 }
298 
<a name="18" id="anc18"></a><span class="line-modified">299 void ShenandoahBarrierSetAssembler::read_barrier(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">300   if (ShenandoahReadBarrier) {</span>
<span class="line-removed">301     read_barrier_impl(masm, dst);</span>
<span class="line-removed">302   }</span>
<span class="line-removed">303 }</span>
304 
<a name="19" id="anc19"></a><span class="line-modified">305 void ShenandoahBarrierSetAssembler::read_barrier_impl(MacroAssembler* masm, Register dst) {</span>
<span class="line-removed">306   assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier || ShenandoahCASBarrier), &quot;should be enabled&quot;);</span>
<span class="line-removed">307   Label is_null;</span>
<span class="line-removed">308   __ testptr(dst, dst);</span>
<span class="line-removed">309   __ jcc(Assembler::zero, is_null);</span>
<span class="line-removed">310   read_barrier_not_null_impl(masm, dst);</span>
<span class="line-removed">311   __ bind(is_null);</span>
<span class="line-removed">312 }</span>
313 
<a name="20" id="anc20"></a><span class="line-modified">314 void ShenandoahBarrierSetAssembler::read_barrier_not_null(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">315   if (ShenandoahReadBarrier) {</span>
<span class="line-modified">316     read_barrier_not_null_impl(masm, dst);</span>



317   }
<a name="21" id="anc21"></a><span class="line-modified">318 }</span>


319 
<a name="22" id="anc22"></a><span class="line-modified">320 void ShenandoahBarrierSetAssembler::read_barrier_not_null_impl(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">321   assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier || ShenandoahCASBarrier), &quot;should be enabled&quot;);</span>
<span class="line-modified">322   __ movptr(dst, Address(dst, ShenandoahBrooksPointer::byte_offset()));</span>
<span class="line-modified">323 }</span>








324 
<a name="23" id="anc23"></a>








325 
<a name="24" id="anc24"></a><span class="line-modified">326 void ShenandoahBarrierSetAssembler::write_barrier(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">327   if (ShenandoahWriteBarrier) {</span>
<span class="line-removed">328     write_barrier_impl(masm, dst);</span>
329   }
<a name="25" id="anc25"></a>


















330 }
331 
<a name="26" id="anc26"></a><span class="line-modified">332 void ShenandoahBarrierSetAssembler::write_barrier_impl(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">333   assert(UseShenandoahGC &amp;&amp; (ShenandoahWriteBarrier || ShenandoahStoreValEnqueueBarrier), &quot;Should be enabled&quot;);</span>
<span class="line-modified">334 #ifdef _LP64</span>


335   Label done;
<a name="27" id="anc27"></a>


336 
<a name="28" id="anc28"></a><span class="line-modified">337   Address gc_state(r15_thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-modified">338   __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);</span>
<span class="line-modified">339   __ jccb(Assembler::zero, done);</span>


340 
<a name="29" id="anc29"></a><span class="line-removed">341   // Heap is unstable, need to perform the read-barrier even if WB is inactive</span>
<span class="line-removed">342   read_barrier_not_null(masm, dst);</span>
343 
<a name="30" id="anc30"></a><span class="line-modified">344   __ testb(gc_state, ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);</span>
<span class="line-modified">345   __ jccb(Assembler::zero, done);</span>




































346 
<a name="31" id="anc31"></a><span class="line-modified">347    if (dst != rax) {</span>
<span class="line-modified">348      __ xchgptr(dst, rax); // Move obj into rax and save rax into obj.</span>
<span class="line-modified">349    }</span>
350 
<a name="32" id="anc32"></a><span class="line-modified">351    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_wb())));</span>













352 
<a name="33" id="anc33"></a><span class="line-modified">353    if (dst != rax) {</span>
<span class="line-modified">354      __ xchgptr(rax, dst); // Swap back obj with rax.</span>
<span class="line-modified">355    }</span>

356 
357   __ bind(done);
<a name="34" id="anc34"></a><span class="line-modified">358 #else</span>
<span class="line-removed">359   Unimplemented();</span>
<span class="line-removed">360 #endif</span>
361 }
362 
363 void ShenandoahBarrierSetAssembler::storeval_barrier(MacroAssembler* masm, Register dst, Register tmp) {
<a name="35" id="anc35"></a><span class="line-modified">364   if (ShenandoahStoreValReadBarrier || ShenandoahStoreValEnqueueBarrier) {</span>
365     storeval_barrier_impl(masm, dst, tmp);
366   }
367 }
368 
369 void ShenandoahBarrierSetAssembler::storeval_barrier_impl(MacroAssembler* masm, Register dst, Register tmp) {
<a name="36" id="anc36"></a><span class="line-modified">370   assert(UseShenandoahGC &amp;&amp; (ShenandoahStoreValReadBarrier || ShenandoahStoreValEnqueueBarrier), &quot;should be enabled&quot;);</span>
371 
372   if (dst == noreg) return;
373 
<a name="37" id="anc37"></a><span class="line-removed">374 #ifdef _LP64</span>
375   if (ShenandoahStoreValEnqueueBarrier) {
<a name="38" id="anc38"></a><span class="line-removed">376     Label is_null;</span>
<span class="line-removed">377     __ testptr(dst, dst);</span>
<span class="line-removed">378     __ jcc(Assembler::zero, is_null);</span>
<span class="line-removed">379     write_barrier_impl(masm, dst);</span>
<span class="line-removed">380     __ bind(is_null);</span>
<span class="line-removed">381 </span>
382     // The set of registers to be saved+restored is the same as in the write-barrier above.
383     // Those are the commonly used registers in the interpreter.
384     __ pusha();
385     // __ push_callee_saved_registers();
386     __ subptr(rsp, 2 * Interpreter::stackElementSize);
387     __ movdbl(Address(rsp, 0), xmm0);
388 
<a name="39" id="anc39"></a><span class="line-modified">389     satb_write_barrier_pre(masm, noreg, dst, r15_thread, tmp, true, false);</span>














390     __ movdbl(xmm0, Address(rsp, 0));
391     __ addptr(rsp, 2 * Interpreter::stackElementSize);
392     //__ pop_callee_saved_registers();
393     __ popa();
394   }
<a name="40" id="anc40"></a><span class="line-modified">395   if (ShenandoahStoreValReadBarrier) {</span>
<span class="line-modified">396     read_barrier_impl(masm, dst);</span>







397   }
<a name="41" id="anc41"></a><span class="line-removed">398 #else</span>
<span class="line-removed">399   Unimplemented();</span>
<span class="line-removed">400 #endif</span>
401 }
402 
<a name="42" id="anc42"></a>












403 void ShenandoahBarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
404              Register dst, Address src, Register tmp1, Register tmp_thread) {
<a name="43" id="anc43"></a><span class="line-modified">405   bool on_oop = type == T_OBJECT || type == T_ARRAY;</span>
<span class="line-modified">406   bool in_heap = (decorators &amp; IN_HEAP) != 0;</span>
<span class="line-modified">407   bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;</span>
<span class="line-modified">408   bool on_phantom = (decorators &amp; ON_PHANTOM_OOP_REF) != 0;</span>
<span class="line-modified">409   bool on_reference = on_weak || on_phantom;</span>
<span class="line-modified">410   if (in_heap) {</span>
<span class="line-modified">411     read_barrier_not_null(masm, src.base());</span>
<span class="line-removed">412   }</span>
<span class="line-removed">413   BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-removed">414   if (ShenandoahKeepAliveBarrier &amp;&amp; on_oop &amp;&amp; on_reference) {</span>
<span class="line-removed">415     const Register thread = NOT_LP64(tmp_thread) LP64_ONLY(r15_thread);</span>
<span class="line-removed">416     NOT_LP64(__ get_thread(thread));</span>
417 
<a name="44" id="anc44"></a>





























































418     // Generate the SATB pre-barrier code to log the value of
419     // the referent field in an SATB buffer.
420     shenandoah_write_barrier_pre(masm /* masm */,
421                                  noreg /* obj */,
422                                  dst /* pre_val */,
423                                  thread /* thread */,
424                                  tmp1 /* tmp */,
425                                  true /* tosca_live */,
426                                  true /* expand_call */);
<a name="45" id="anc45"></a>









427   }
428 }
429 
430 void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
431               Address dst, Register val, Register tmp1, Register tmp2) {
432 
<a name="46" id="anc46"></a>
433   bool in_heap = (decorators &amp; IN_HEAP) != 0;
434   bool as_normal = (decorators &amp; AS_NORMAL) != 0;
<a name="47" id="anc47"></a><span class="line-modified">435   if (in_heap) {</span>
<span class="line-removed">436     write_barrier(masm, dst.base());</span>
<span class="line-removed">437   }</span>
<span class="line-removed">438   if (type == T_OBJECT || type == T_ARRAY) {</span>
439     bool needs_pre_barrier = as_normal;
440 
441     Register tmp3 = LP64_ONLY(r8) NOT_LP64(rsi);
442     Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
443     // flatten object address if needed
444     // We do it regardless of precise because we need the registers
445     if (dst.index() == noreg &amp;&amp; dst.disp() == 0) {
446       if (dst.base() != tmp1) {
447         __ movptr(tmp1, dst.base());
448       }
449     } else {
450       __ lea(tmp1, dst);
451     }
452 
<a name="48" id="anc48"></a>

453 #ifndef _LP64
<a name="49" id="anc49"></a>
454     InterpreterMacroAssembler *imasm = static_cast&lt;InterpreterMacroAssembler*&gt;(masm);
<a name="50" id="anc50"></a>
455 #endif
456 
<a name="51" id="anc51"></a><span class="line-removed">457     NOT_LP64(__ get_thread(rcx));</span>
<span class="line-removed">458     NOT_LP64(imasm-&gt;save_bcp());</span>
<span class="line-removed">459 </span>
460     if (needs_pre_barrier) {
461       shenandoah_write_barrier_pre(masm /*masm*/,
462                                    tmp1 /* obj */,
463                                    tmp2 /* pre_val */,
464                                    rthread /* thread */,
465                                    tmp3  /* tmp */,
466                                    val != noreg /* tosca_live */,
467                                    false /* expand_call */);
468     }
469     if (val == noreg) {
470       BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg);
471     } else {
472       storeval_barrier(masm, val, tmp3);
473       BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg);
474     }
475     NOT_LP64(imasm-&gt;restore_bcp());
476   } else {
477     BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);
478   }
479 }
480 
<a name="52" id="anc52"></a><span class="line-modified">481 #ifndef _LP64</span>
<span class="line-modified">482 void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm,</span>
<span class="line-modified">483                                                Address obj1, jobject obj2) {</span>
<span class="line-modified">484   Unimplemented();</span>
<span class="line-modified">485 }</span>
<span class="line-removed">486 </span>
<span class="line-removed">487 void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm,</span>
<span class="line-removed">488                                                Register obj1, jobject obj2) {</span>
<span class="line-removed">489   Unimplemented();</span>
<span class="line-removed">490 }</span>
<span class="line-removed">491 #endif</span>
<span class="line-removed">492 </span>
<span class="line-removed">493 </span>
<span class="line-removed">494 void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm, Register op1, Register op2) {</span>
<span class="line-removed">495   __ cmpptr(op1, op2);</span>
<span class="line-removed">496   if (ShenandoahAcmpBarrier) {</span>
<span class="line-removed">497     Label done;</span>
<span class="line-removed">498     __ jccb(Assembler::equal, done);</span>
<span class="line-removed">499     read_barrier(masm, op1);</span>
<span class="line-removed">500     read_barrier(masm, op2);</span>
<span class="line-removed">501     __ cmpptr(op1, op2);</span>
<span class="line-removed">502     __ bind(done);</span>
<span class="line-removed">503   }</span>
<span class="line-removed">504 }</span>
<span class="line-removed">505 </span>
<span class="line-removed">506 void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm, Register src1, Address src2) {</span>
<span class="line-removed">507   __ cmpptr(src1, src2);</span>
<span class="line-removed">508   if (ShenandoahAcmpBarrier) {</span>
<span class="line-removed">509     Label done;</span>
<span class="line-removed">510     __ jccb(Assembler::equal, done);</span>
<span class="line-removed">511     __ movptr(rscratch2, src2);</span>
<span class="line-removed">512     read_barrier(masm, src1);</span>
<span class="line-removed">513     read_barrier(masm, rscratch2);</span>
<span class="line-removed">514     __ cmpptr(src1, rscratch2);</span>
<span class="line-removed">515     __ bind(done);</span>
<span class="line-removed">516   }</span>
<span class="line-removed">517 }</span>
<span class="line-removed">518 </span>
<span class="line-removed">519 void ShenandoahBarrierSetAssembler::tlab_allocate(MacroAssembler* masm,</span>
<span class="line-removed">520                                                   Register thread, Register obj,</span>
<span class="line-removed">521                                                   Register var_size_in_bytes,</span>
<span class="line-removed">522                                                   int con_size_in_bytes,</span>
<span class="line-removed">523                                                   Register t1, Register t2,</span>
<span class="line-removed">524                                                   Label&amp; slow_case) {</span>
<span class="line-removed">525   assert_different_registers(obj, t1, t2);</span>
<span class="line-removed">526   assert_different_registers(obj, var_size_in_bytes, t1);</span>
<span class="line-removed">527   Register end = t2;</span>
<span class="line-removed">528   if (!thread-&gt;is_valid()) {</span>
<span class="line-removed">529 #ifdef _LP64</span>
<span class="line-removed">530     thread = r15_thread;</span>
<span class="line-removed">531 #else</span>
<span class="line-removed">532     assert(t1-&gt;is_valid(), &quot;need temp reg&quot;);</span>
<span class="line-removed">533     thread = t1;</span>
<span class="line-removed">534     __ get_thread(thread);</span>
<span class="line-removed">535 #endif</span>
<span class="line-removed">536   }</span>
<span class="line-removed">537 </span>
<span class="line-removed">538   __ verify_tlab();</span>
<span class="line-removed">539 </span>
<span class="line-removed">540   __ movptr(obj, Address(thread, JavaThread::tlab_top_offset()));</span>
<span class="line-removed">541   if (var_size_in_bytes == noreg) {</span>
<span class="line-removed">542     __ lea(end, Address(obj, con_size_in_bytes + ShenandoahBrooksPointer::byte_size()));</span>
<span class="line-removed">543   } else {</span>
<span class="line-removed">544     __ addptr(var_size_in_bytes, ShenandoahBrooksPointer::byte_size());</span>
<span class="line-removed">545     __ lea(end, Address(obj, var_size_in_bytes, Address::times_1));</span>
<span class="line-removed">546   }</span>
<span class="line-removed">547   __ cmpptr(end, Address(thread, JavaThread::tlab_end_offset()));</span>
<span class="line-removed">548   __ jcc(Assembler::above, slow_case);</span>
<span class="line-removed">549 </span>
<span class="line-removed">550   // update the tlab top pointer</span>
<span class="line-removed">551   __ movptr(Address(thread, JavaThread::tlab_top_offset()), end);</span>
<span class="line-removed">552 </span>
<span class="line-removed">553   // Initialize brooks pointer</span>
<span class="line-removed">554 #ifdef _LP64</span>
<span class="line-removed">555   __ incrementq(obj, ShenandoahBrooksPointer::byte_size());</span>
<span class="line-removed">556 #else</span>
<span class="line-removed">557   __ incrementl(obj, ShenandoahBrooksPointer::byte_size());</span>
<span class="line-removed">558 #endif</span>
<span class="line-removed">559   __ movptr(Address(obj, ShenandoahBrooksPointer::byte_offset()), obj);</span>
560 
<a name="53" id="anc53"></a><span class="line-modified">561   // recover var_size_in_bytes if necessary</span>
<span class="line-modified">562   if (var_size_in_bytes == end) {</span>
<span class="line-modified">563     __ subptr(var_size_in_bytes, obj);</span>
<span class="line-removed">564   }</span>
<span class="line-removed">565   __ verify_tlab();</span>
<span class="line-removed">566 }</span>
567 
<a name="54" id="anc54"></a><span class="line-modified">568 void ShenandoahBarrierSetAssembler::resolve(MacroAssembler* masm, DecoratorSet decorators, Register obj) {</span>
<span class="line-modified">569   bool oop_not_null = (decorators &amp; IS_NOT_NULL) != 0;</span>
<span class="line-modified">570   bool is_write = (decorators &amp; ACCESS_WRITE) != 0;</span>
<span class="line-modified">571   if (is_write) {</span>
<span class="line-removed">572     if (oop_not_null) {</span>
<span class="line-removed">573       write_barrier(masm, obj);</span>
<span class="line-removed">574     } else {</span>
<span class="line-removed">575       Label done;</span>
<span class="line-removed">576       __ testptr(obj, obj);</span>
<span class="line-removed">577       __ jcc(Assembler::zero, done);</span>
<span class="line-removed">578       write_barrier(masm, obj);</span>
<span class="line-removed">579       __ bind(done);</span>
<span class="line-removed">580     }</span>
<span class="line-removed">581   } else {</span>
<span class="line-removed">582     if (oop_not_null) {</span>
<span class="line-removed">583       read_barrier_not_null(masm, obj);</span>
<span class="line-removed">584     } else {</span>
<span class="line-removed">585       read_barrier(masm, obj);</span>
<span class="line-removed">586     }</span>
<span class="line-removed">587   }</span>
588 }
589 
590 // Special Shenandoah CAS implementation that handles false negatives
591 // due to concurrent evacuation.
<a name="55" id="anc55"></a><span class="line-removed">592 #ifndef _LP64</span>
<span class="line-removed">593 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm,</span>
<span class="line-removed">594                                                 Register res, Address addr, Register oldval, Register newval,</span>
<span class="line-removed">595                                                 bool exchange, Register tmp1, Register tmp2) {</span>
<span class="line-removed">596   // Shenandoah has no 32-bit version for this.</span>
<span class="line-removed">597   Unimplemented();</span>
<span class="line-removed">598 }</span>
<span class="line-removed">599 #else</span>
600 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm,
601                                                 Register res, Address addr, Register oldval, Register newval,
602                                                 bool exchange, Register tmp1, Register tmp2) {
603   assert(ShenandoahCASBarrier, &quot;Should only be used when CAS barrier is enabled&quot;);
604   assert(oldval == rax, &quot;must be in rax for implicit use in cmpxchg&quot;);
<a name="56" id="anc56"></a>
605 
<a name="57" id="anc57"></a><span class="line-modified">606   Label retry, done;</span>
607 
608   // Remember oldval for retry logic below
<a name="58" id="anc58"></a>
609   if (UseCompressedOops) {
610     __ movl(tmp1, oldval);
<a name="59" id="anc59"></a><span class="line-modified">611   } else {</span>


612     __ movptr(tmp1, oldval);
613   }
614 
<a name="60" id="anc60"></a><span class="line-modified">615   // Step 1. Try to CAS with given arguments. If successful, then we are done,</span>
<span class="line-modified">616   // and can safely return.</span>


617   if (os::is_MP()) __ lock();
<a name="61" id="anc61"></a>
618   if (UseCompressedOops) {
619     __ cmpxchgl(newval, addr);
<a name="62" id="anc62"></a><span class="line-modified">620   } else {</span>


621     __ cmpxchgptr(newval, addr);
622   }
<a name="63" id="anc63"></a><span class="line-modified">623   __ jcc(Assembler::equal, done, true);</span>
624 
625   // Step 2. CAS had failed. This may be a false negative.
626   //
627   // The trouble comes when we compare the to-space pointer with the from-space
<a name="64" id="anc64"></a><span class="line-modified">628   // pointer to the same object. To resolve this, it will suffice to read both</span>
<span class="line-modified">629   // oldval and the value from memory through the read barriers -- this will give</span>
<span class="line-modified">630   // both to-space pointers. If they mismatch, then it was a legitimate failure.</span>
631   //
<a name="65" id="anc65"></a><span class="line-modified">632   if (UseCompressedOops) {</span>
<span class="line-modified">633     __ decode_heap_oop(tmp1);</span>
<span class="line-modified">634   }</span>
<span class="line-modified">635   read_barrier_impl(masm, tmp1);</span>













636 
<a name="66" id="anc66"></a>
637   if (UseCompressedOops) {
638     __ movl(tmp2, oldval);
639     __ decode_heap_oop(tmp2);
<a name="67" id="anc67"></a><span class="line-modified">640   } else {</span>


641     __ movptr(tmp2, oldval);
642   }
<a name="68" id="anc68"></a><span class="line-removed">643   read_barrier_impl(masm, tmp2);</span>
644 
<a name="69" id="anc69"></a><span class="line-modified">645   __ cmpptr(tmp1, tmp2);</span>
<span class="line-modified">646   __ jcc(Assembler::notEqual, done, true);</span>



647 
<a name="70" id="anc70"></a><span class="line-modified">648   // Step 3. Try to CAS again with resolved to-space pointers.</span>
<span class="line-modified">649   //</span>
<span class="line-modified">650   // Corner case: it may happen that somebody stored the from-space pointer</span>
<span class="line-modified">651   // to memory while we were preparing for retry. Therefore, we can fail again</span>
<span class="line-removed">652   // on retry, and so need to do this in loop, always re-reading the failure</span>
<span class="line-removed">653   // witness through the read barrier.</span>
<span class="line-removed">654   __ bind(retry);</span>
<span class="line-removed">655   if (os::is_MP()) __ lock();</span>
<span class="line-removed">656   if (UseCompressedOops) {</span>
<span class="line-removed">657     __ cmpxchgl(newval, addr);</span>
<span class="line-removed">658   } else {</span>
<span class="line-removed">659     __ cmpxchgptr(newval, addr);</span>
<span class="line-removed">660   }</span>
<span class="line-removed">661   __ jcc(Assembler::equal, done, true);</span>
662 
<a name="71" id="anc71"></a>
663   if (UseCompressedOops) {
<a name="72" id="anc72"></a><span class="line-modified">664     __ movl(tmp2, oldval);</span>
<span class="line-removed">665     __ decode_heap_oop(tmp2);</span>
<span class="line-removed">666   } else {</span>
<span class="line-removed">667     __ movptr(tmp2, oldval);</span>
668   }
<a name="73" id="anc73"></a><span class="line-modified">669   read_barrier_impl(masm, tmp2);</span>
670 
<a name="74" id="anc74"></a>

671   __ cmpptr(tmp1, tmp2);
<a name="75" id="anc75"></a><span class="line-modified">672   __ jcc(Assembler::equal, retry, true);</span>
673 
<a name="76" id="anc76"></a><span class="line-modified">674   // Step 4. If we need a boolean result out of CAS, check the flag again,</span>
<span class="line-modified">675   // and promote the result. Note that we handle the flag from both the CAS</span>
<span class="line-modified">676   // itself and from the retry loop.</span>
<span class="line-modified">677   __ bind(done);</span>
<span class="line-modified">678   if (!exchange) {</span>
<span class="line-modified">679     assert(res != NULL, &quot;need result register&quot;);</span>
<span class="line-modified">680     __ setb(Assembler::equal, res);</span>
<span class="line-modified">681     __ movzbl(res, res);</span>
<span class="line-removed">682   }</span>
<span class="line-removed">683 }</span>
<span class="line-removed">684 #endif // LP64</span>
685 
<a name="77" id="anc77"></a><span class="line-modified">686 void ShenandoahBarrierSetAssembler::save_vector_registers(MacroAssembler* masm) {</span>
<span class="line-modified">687   int num_xmm_regs = LP64_ONLY(16) NOT_LP64(8);</span>
<span class="line-modified">688   if (UseAVX &gt; 2) {</span>
<span class="line-removed">689     num_xmm_regs = LP64_ONLY(32) NOT_LP64(8);</span>
690   }
<a name="78" id="anc78"></a><span class="line-removed">691 </span>
<span class="line-removed">692   if (UseSSE == 1)  {</span>
<span class="line-removed">693     __ subptr(rsp, sizeof(jdouble)*8);</span>
<span class="line-removed">694     for (int n = 0; n &lt; 8; n++) {</span>
<span class="line-removed">695       __ movflt(Address(rsp, n*sizeof(jdouble)), as_XMMRegister(n));</span>
<span class="line-removed">696     }</span>
<span class="line-removed">697   } else if (UseSSE &gt;= 2)  {</span>
<span class="line-removed">698     if (UseAVX &gt; 2) {</span>
<span class="line-removed">699       __ push(rbx);</span>
<span class="line-removed">700       __ movl(rbx, 0xffff);</span>
<span class="line-removed">701       __ kmovwl(k1, rbx);</span>
<span class="line-removed">702       __ pop(rbx);</span>
<span class="line-removed">703     }</span>
<span class="line-removed">704 #ifdef COMPILER2</span>
<span class="line-removed">705     if (MaxVectorSize &gt; 16) {</span>
<span class="line-removed">706       if(UseAVX &gt; 2) {</span>
<span class="line-removed">707         // Save upper half of ZMM registers</span>
<span class="line-removed">708         __ subptr(rsp, 32*num_xmm_regs);</span>
<span class="line-removed">709         for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed">710           __ vextractf64x4_high(Address(rsp, n*32), as_XMMRegister(n));</span>
<span class="line-removed">711         }</span>
<span class="line-removed">712       }</span>
<span class="line-removed">713       assert(UseAVX &gt; 0, &quot;256 bit vectors are supported only with AVX&quot;);</span>
<span class="line-removed">714       // Save upper half of YMM registers</span>
<span class="line-removed">715       __ subptr(rsp, 16*num_xmm_regs);</span>
<span class="line-removed">716       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed">717         __ vextractf128_high(Address(rsp, n*16), as_XMMRegister(n));</span>
<span class="line-removed">718       }</span>
<span class="line-removed">719     }</span>
720 #endif
<a name="79" id="anc79"></a><span class="line-modified">721     // Save whole 128bit (16 bytes) XMM registers</span>
<span class="line-modified">722     __ subptr(rsp, 16*num_xmm_regs);</span>
723 #ifdef _LP64
<a name="80" id="anc80"></a><span class="line-modified">724     if (VM_Version::supports_evex()) {</span>
<span class="line-modified">725       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-modified">726         __ vextractf32x4(Address(rsp, n*16), as_XMMRegister(n), 0);</span>
<span class="line-removed">727       }</span>
<span class="line-removed">728     } else {</span>
<span class="line-removed">729       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed">730         __ movdqu(Address(rsp, n*16), as_XMMRegister(n));</span>
<span class="line-removed">731       }</span>
<span class="line-removed">732     }</span>
<span class="line-removed">733 #else</span>
<span class="line-removed">734     for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed">735       __ movdqu(Address(rsp, n*16), as_XMMRegister(n));</span>
<span class="line-removed">736     }</span>
737 #endif
<a name="81" id="anc81"></a>

738   }
<a name="82" id="anc82"></a><span class="line-removed">739 }</span>
740 
<a name="83" id="anc83"></a><span class="line-modified">741 void ShenandoahBarrierSetAssembler::restore_vector_registers(MacroAssembler* masm) {</span>
<span class="line-modified">742   int num_xmm_regs = LP64_ONLY(16) NOT_LP64(8);</span>
<span class="line-modified">743   if (UseAVX &gt; 2) {</span>
<span class="line-modified">744     num_xmm_regs = LP64_ONLY(32) NOT_LP64(8);</span>
<span class="line-modified">745   }</span>
<span class="line-modified">746   if (UseSSE == 1)  {</span>
<span class="line-modified">747     for (int n = 0; n &lt; 8; n++) {</span>
<span class="line-removed">748       __ movflt(as_XMMRegister(n), Address(rsp, n*sizeof(jdouble)));</span>
<span class="line-removed">749     }</span>
<span class="line-removed">750     __ addptr(rsp, sizeof(jdouble)*8);</span>
<span class="line-removed">751   } else if (UseSSE &gt;= 2)  {</span>
<span class="line-removed">752     // Restore whole 128bit (16 bytes) XMM registers</span>
753 #ifdef _LP64
<a name="84" id="anc84"></a><span class="line-modified">754     if (VM_Version::supports_evex()) {</span>
<span class="line-modified">755       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-modified">756         __ vinsertf32x4(as_XMMRegister(n), as_XMMRegister(n), Address(rsp, n*16), 0);</span>
<span class="line-removed">757       }</span>
<span class="line-removed">758     } else {</span>
<span class="line-removed">759       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed">760         __ movdqu(as_XMMRegister(n), Address(rsp, n*16));</span>
<span class="line-removed">761       }</span>
<span class="line-removed">762     }</span>
<span class="line-removed">763 #else</span>
<span class="line-removed">764     for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed">765       __ movdqu(as_XMMRegister(n), Address(rsp, n*16));</span>
<span class="line-removed">766     }</span>
767 #endif
<a name="85" id="anc85"></a><span class="line-modified">768     __ addptr(rsp, 16*num_xmm_regs);</span>


769 
<a name="86" id="anc86"></a><span class="line-modified">770 #ifdef COMPILER2</span>
<span class="line-modified">771     if (MaxVectorSize &gt; 16) {</span>
<span class="line-modified">772       // Restore upper half of YMM registers.</span>
<span class="line-modified">773       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-modified">774         __ vinsertf128_high(as_XMMRegister(n), Address(rsp, n*16));</span>
<span class="line-removed">775       }</span>
<span class="line-removed">776       __ addptr(rsp, 16*num_xmm_regs);</span>
<span class="line-removed">777       if (UseAVX &gt; 2) {</span>
<span class="line-removed">778         for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="line-removed">779           __ vinsertf64x4_high(as_XMMRegister(n), Address(rsp, n*32));</span>
<span class="line-removed">780         }</span>
<span class="line-removed">781         __ addptr(rsp, 32*num_xmm_regs);</span>
<span class="line-removed">782       }</span>
<span class="line-removed">783     }</span>
784 #endif
<a name="87" id="anc87"></a>
























785   }
786 }
787 
<a name="88" id="anc88"></a>

788 #ifdef COMPILER1
789 
<a name="89" id="anc89"></a><span class="line-removed">790 #undef __</span>
791 #define __ ce-&gt;masm()-&gt;
792 
793 void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
794   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
795   // At this point we know that marking is in progress.
796   // If do_load() is true then we have to emit the
797   // load of the previous value; otherwise it has already
798   // been loaded into _pre_val.
799 
800   __ bind(*stub-&gt;entry());
801   assert(stub-&gt;pre_val()-&gt;is_register(), &quot;Precondition.&quot;);
802 
803   Register pre_val_reg = stub-&gt;pre_val()-&gt;as_register();
804 
805   if (stub-&gt;do_load()) {
806     ce-&gt;mem2reg(stub-&gt;addr(), stub-&gt;pre_val(), T_OBJECT, stub-&gt;patch_code(), stub-&gt;info(), false /*wide*/, false /*unaligned*/);
807   }
808 
809   __ cmpptr(pre_val_reg, (int32_t)NULL_WORD);
810   __ jcc(Assembler::equal, *stub-&gt;continuation());
811   ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
812   __ call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
813   __ jmp(*stub-&gt;continuation());
814 
815 }
816 
<a name="90" id="anc90"></a><span class="line-modified">817 void ShenandoahBarrierSetAssembler::gen_write_barrier_stub(LIR_Assembler* ce, ShenandoahWriteBarrierStub* stub) {</span>

818   __ bind(*stub-&gt;entry());
819 
<a name="91" id="anc91"></a><span class="line-removed">820   Label done;</span>
821   Register obj = stub-&gt;obj()-&gt;as_register();
822   Register res = stub-&gt;result()-&gt;as_register();
<a name="92" id="anc92"></a>







823 
824   if (res != obj) {
825     __ mov(res, obj);
826   }
827 
828   // Check for null.
<a name="93" id="anc93"></a><span class="line-modified">829   if (stub-&gt;needs_null_check()) {</span>
<span class="line-modified">830     __ testptr(res, res);</span>
<span class="line-removed">831     __ jcc(Assembler::zero, done);</span>
<span class="line-removed">832   }</span>
833 
<a name="94" id="anc94"></a><span class="line-modified">834   write_barrier(ce-&gt;masm(), res);</span>













835 
<a name="95" id="anc95"></a><span class="line-modified">836   __ bind(done);</span>







837   __ jmp(*stub-&gt;continuation());
838 }
839 
840 #undef __
841 
842 #define __ sasm-&gt;
843 
844 void ShenandoahBarrierSetAssembler::generate_c1_pre_barrier_runtime_stub(StubAssembler* sasm) {
845   __ prologue(&quot;shenandoah_pre_barrier&quot;, false);
846   // arg0 : previous value of memory
847 
848   __ push(rax);
849   __ push(rdx);
850 
851   const Register pre_val = rax;
852   const Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);
853   const Register tmp = rdx;
854 
855   NOT_LP64(__ get_thread(thread);)
856 
857   Address queue_index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
858   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
859 
860   Label done;
861   Label runtime;
862 
863   // Is SATB still active?
864   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
865   __ testb(gc_state, ShenandoahHeap::MARKING | ShenandoahHeap::TRAVERSAL);
866   __ jcc(Assembler::zero, done);
867 
868   // Can we store original value in the thread&#39;s buffer?
869 
870   __ movptr(tmp, queue_index);
871   __ testptr(tmp, tmp);
872   __ jcc(Assembler::zero, runtime);
873   __ subptr(tmp, wordSize);
874   __ movptr(queue_index, tmp);
875   __ addptr(tmp, buffer);
876 
877   // prev_val (rax)
878   __ load_parameter(0, pre_val);
879   __ movptr(Address(tmp, 0), pre_val);
880   __ jmp(done);
881 
882   __ bind(runtime);
883 
884   __ save_live_registers_no_oop_map(true);
885 
886   // load the pre-value
887   __ load_parameter(0, rcx);
888   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), rcx, thread);
889 
890   __ restore_live_registers(true);
891 
892   __ bind(done);
893 
894   __ pop(rdx);
895   __ pop(rax);
896 
897   __ epilogue();
898 }
899 
<a name="96" id="anc96"></a>






























900 #undef __
901 
902 #endif // COMPILER1
903 
<a name="97" id="anc97"></a><span class="line-modified">904 address ShenandoahBarrierSetAssembler::shenandoah_wb() {</span>
<span class="line-modified">905   assert(_shenandoah_wb != NULL, &quot;need write barrier stub&quot;);</span>
<span class="line-modified">906   return _shenandoah_wb;</span>
907 }
908 
909 #define __ cgen-&gt;assembler()-&gt;
910 
<a name="98" id="anc98"></a><span class="line-modified">911 address ShenandoahBarrierSetAssembler::generate_shenandoah_wb(StubCodeGenerator* cgen) {</span>





912   __ align(CodeEntryAlignment);
<a name="99" id="anc99"></a><span class="line-modified">913   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_wb&quot;);</span>
914   address start = __ pc();
915 
<a name="100" id="anc100"></a><span class="line-modified">916 #ifdef _LP64</span>
<span class="line-removed">917   Label not_done;</span>
918 
919   // We use RDI, which also serves as argument register for slow call.
<a name="101" id="anc101"></a><span class="line-modified">920   // RAX always holds the src object ptr, except after the slow call and</span>
<span class="line-modified">921   // the cmpxchg, then it holds the result.</span>
<span class="line-modified">922   // R8 and RCX are used as temporary registers.</span>
<span class="line-modified">923   __ push(rdi);</span>
<span class="line-modified">924   __ push(r8);</span>
<span class="line-modified">925 </span>
<span class="line-modified">926   // Check for object beeing in the collection set.</span>
<span class="line-modified">927   // TODO: Can we use only 1 register here?</span>
<span class="line-modified">928   // The source object arrives here in rax.</span>
<span class="line-modified">929   // live: rax</span>
<span class="line-modified">930   // live: rdi</span>
<span class="line-modified">931   __ mov(rdi, rax);</span>
<span class="line-modified">932   __ shrptr(rdi, ShenandoahHeapRegion::region_size_bytes_shift_jint());</span>
<span class="line-modified">933   // live: r8</span>
<span class="line-modified">934   __ movptr(r8, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());</span>
<span class="line-modified">935   __ movbool(r8, Address(r8, rdi, Address::times_1));</span>
<span class="line-modified">936   // unlive: rdi</span>
<span class="line-modified">937   __ testbool(r8);</span>
<span class="line-modified">938   // unlive: r8</span>
<span class="line-removed">939   __ jccb(Assembler::notZero, not_done);</span>
940 
<a name="102" id="anc102"></a><span class="line-modified">941   __ pop(r8);</span>
<span class="line-modified">942   __ pop(rdi);</span>














943   __ ret(0);
944 
<a name="103" id="anc103"></a><span class="line-modified">945   __ bind(not_done);</span>
946 
947   __ push(rcx);
948   __ push(rdx);
949   __ push(rdi);
<a name="104" id="anc104"></a><span class="line-modified">950   __ push(rsi);</span>
951   __ push(r8);
952   __ push(r9);
953   __ push(r10);
954   __ push(r11);
955   __ push(r12);
956   __ push(r13);
957   __ push(r14);
958   __ push(r15);
<a name="105" id="anc105"></a><span class="line-modified">959   save_vector_registers(cgen-&gt;assembler());</span>
<span class="line-modified">960   __ movptr(rdi, rax);</span>
<span class="line-modified">961   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_JRT), rdi);</span>
<span class="line-modified">962   restore_vector_registers(cgen-&gt;assembler());</span>










963   __ pop(r15);
964   __ pop(r14);
965   __ pop(r13);
966   __ pop(r12);
967   __ pop(r11);
968   __ pop(r10);
969   __ pop(r9);
970   __ pop(r8);
<a name="106" id="anc106"></a><span class="line-modified">971   __ pop(rsi);</span>
972   __ pop(rdi);
973   __ pop(rdx);
974   __ pop(rcx);
975 
<a name="107" id="anc107"></a><span class="line-modified">976   __ pop(r8);</span>
<span class="line-modified">977   __ pop(rdi);</span>
978   __ ret(0);
<a name="108" id="anc108"></a><span class="line-modified">979 #else</span>
<span class="line-removed">980   ShouldNotReachHere();</span>
<span class="line-removed">981 #endif</span>
982   return start;
983 }
984 
985 #undef __
986 
987 void ShenandoahBarrierSetAssembler::barrier_stubs_init() {
<a name="109" id="anc109"></a><span class="line-modified">988   if (ShenandoahWriteBarrier || ShenandoahStoreValEnqueueBarrier) {</span>
989     int stub_code_size = 4096;
990     ResourceMark rm;
991     BufferBlob* bb = BufferBlob::create(&quot;shenandoah_barrier_stubs&quot;, stub_code_size);
992     CodeBuffer buf(bb);
993     StubCodeGenerator cgen(&amp;buf);
<a name="110" id="anc110"></a><span class="line-modified">994     _shenandoah_wb = generate_shenandoah_wb(&amp;cgen);</span>
995   }
996 }
<a name="111" id="anc111"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="111" type="hidden" />
</body>
</html>
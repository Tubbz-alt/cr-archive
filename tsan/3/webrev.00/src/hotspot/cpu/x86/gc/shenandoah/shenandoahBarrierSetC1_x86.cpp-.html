<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetC1_x86.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;c1/c1_LIRAssembler.hpp&quot;
 26 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
 29 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
 30 
 31 #define __ masm-&gt;masm()-&gt;
 32 
 33 void LIR_OpShenandoahCompareAndSwap::emit_code(LIR_Assembler* masm) {
 34   Register addr = _addr-&gt;as_register_lo();
 35   Register newval = _new_value-&gt;as_register();
 36   Register cmpval = _cmp_value-&gt;as_register();
 37   Register tmp1 = _tmp1-&gt;as_register();
 38   Register tmp2 = _tmp2-&gt;as_register();
 39   Register result = result_opr()-&gt;as_register();
 40   assert(cmpval == rax, &quot;wrong register&quot;);
 41   assert(newval != NULL, &quot;new val must be register&quot;);
 42   assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
 43   assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
 44   assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
 45 
 46   // Apply storeval barrier to newval.
 47   ShenandoahBarrierSet::assembler()-&gt;storeval_barrier(masm-&gt;masm(), newval, tmp1);
 48 
 49   if (UseCompressedOops) {
 50     __ encode_heap_oop(cmpval);
 51     __ mov(rscratch1, newval);
 52     __ encode_heap_oop(rscratch1);
 53     newval = rscratch1;
 54   }
 55 
 56   ShenandoahBarrierSet::assembler()-&gt;cmpxchg_oop(masm-&gt;masm(), result, Address(addr, 0), cmpval, newval, false, tmp1, tmp2);
 57 }
 58 
 59 #undef __
 60 
 61 #ifdef ASSERT
 62 #define __ gen-&gt;lir(__FILE__, __LINE__)-&gt;
 63 #else
 64 #define __ gen-&gt;lir()-&gt;
 65 #endif
 66 
 67 LIR_Opr ShenandoahBarrierSetC1::atomic_cmpxchg_at_resolved(LIRAccess&amp; access, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 68 
 69   if (access.is_oop()) {
 70     LIRGenerator* gen = access.gen();
 71     if (ShenandoahSATBBarrier) {
 72       pre_barrier(gen, access.access_emit_info(), access.decorators(), access.resolved_addr(),
 73                   LIR_OprFact::illegalOpr /* pre_val */);
 74     }
 75     if (ShenandoahCASBarrier) {
 76       cmp_value.load_item_force(FrameMap::rax_oop_opr);
 77       new_value.load_item();
 78 
 79       LIR_Opr t1 = gen-&gt;new_register(T_OBJECT);
 80       LIR_Opr t2 = gen-&gt;new_register(T_OBJECT);
 81       LIR_Opr addr = access.resolved_addr()-&gt;as_address_ptr()-&gt;base();
 82       LIR_Opr result = gen-&gt;new_register(T_INT);
 83 
 84       __ append(new LIR_OpShenandoahCompareAndSwap(addr, cmp_value.result(), new_value.result(), t1, t2, result));
 85       return result;
 86     }
 87   }
 88   return BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);
 89 }
 90 
 91 LIR_Opr ShenandoahBarrierSetC1::atomic_xchg_at_resolved(LIRAccess&amp; access, LIRItem&amp; value) {
 92   LIRGenerator* gen = access.gen();
 93   BasicType type = access.type();
 94 
 95   LIR_Opr result = gen-&gt;new_register(type);
 96   value.load_item();
 97   LIR_Opr value_opr = value.result();
 98 
 99   if (access.is_oop()) {
100     value_opr = storeval_barrier(access.gen(), value_opr, access.access_emit_info(), access.decorators());
101   }
102 
103   // Because we want a 2-arg form of xchg and xadd
104   __ move(value_opr, result);
105 
106   assert(type == T_INT || type == T_OBJECT || type == T_ARRAY LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
107   __ xchg(access.resolved_addr(), result, result, LIR_OprFact::illegalOpr);
108 
109   if (access.is_oop()) {
110     if (ShenandoahSATBBarrier) {
111       pre_barrier(access.gen(), access.access_emit_info(), access.decorators(), LIR_OprFact::illegalOpr,
112                   result /* pre_val */);
113     }
114   }
115 
116   return result;
117 }
    </pre>
  </body>
</html>
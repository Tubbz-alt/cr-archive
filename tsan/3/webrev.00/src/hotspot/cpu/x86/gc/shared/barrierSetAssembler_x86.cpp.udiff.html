<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/gc/shared/barrierSetAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../g1/g1BarrierSetAssembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="barrierSetAssembler_x86.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/gc/shared/barrierSetAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,11 +26,13 @@</span>
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  #include &quot;gc/shared/barrierSetNMethod.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;interpreter/interp_masm.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;runtime/jniHandles.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/sharedRuntime.hpp&quot;</span>
  #include &quot;runtime/thread.hpp&quot;
  
  #define __ masm-&gt;
  
  void BarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -323,23 +325,90 @@</span>
    }
    __ adcl(Address(thread, in_bytes(JavaThread::allocated_bytes_offset())+4), 0);
  #endif
  }
  
<span class="udiff-line-added">+ #ifdef _LP64</span>
  void BarrierSetAssembler::nmethod_entry_barrier(MacroAssembler* masm) {
    BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()-&gt;barrier_set_nmethod();
    if (bs_nm == NULL) {
      return;
    }
<span class="udiff-line-removed">- #ifndef _LP64</span>
<span class="udiff-line-removed">-   ShouldNotReachHere();</span>
<span class="udiff-line-removed">- #else</span>
    Label continuation;
<span class="udiff-line-modified-removed">-   Register thread = LP64_ONLY(r15_thread);</span>
<span class="udiff-line-modified-added">+   Register thread = r15_thread;</span>
    Address disarmed_addr(thread, in_bytes(bs_nm-&gt;thread_disarmed_offset()));
    __ align(8);
    __ cmpl(disarmed_addr, 0);
    __ jcc(Assembler::equal, continuation);
    __ call(RuntimeAddress(StubRoutines::x86::method_entry_barrier()));
    __ bind(continuation);
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ void BarrierSetAssembler::nmethod_entry_barrier(MacroAssembler* masm) {</span>
<span class="udiff-line-added">+   BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()-&gt;barrier_set_nmethod();</span>
<span class="udiff-line-added">+   if (bs_nm == NULL) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Label continuation;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Register tmp = rdi;</span>
<span class="udiff-line-added">+   __ push(tmp);</span>
<span class="udiff-line-added">+   __ movptr(tmp, (intptr_t)bs_nm-&gt;disarmed_value_address());</span>
<span class="udiff-line-added">+   Address disarmed_addr(tmp, 0);</span>
<span class="udiff-line-added">+   __ align(4);</span>
<span class="udiff-line-added">+   __ cmpl(disarmed_addr, 0);</span>
<span class="udiff-line-added">+   __ pop(tmp);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::equal, continuation);</span>
<span class="udiff-line-added">+   __ call(RuntimeAddress(StubRoutines::x86::method_entry_barrier()));</span>
<span class="udiff-line-added">+   __ bind(continuation);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void BarrierSetAssembler::c2i_entry_barrier(MacroAssembler* masm) {</span>
<span class="udiff-line-added">+   BarrierSetNMethod* bs = BarrierSet::barrier_set()-&gt;barrier_set_nmethod();</span>
<span class="udiff-line-added">+   if (bs == NULL) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Label bad_call;</span>
<span class="udiff-line-added">+   __ cmpptr(rbx, 0); // rbx contains the incoming method for c2i adapters.</span>
<span class="udiff-line-added">+   __ jcc(Assembler::equal, bad_call);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+   Register tmp1 = rscratch1;</span>
<span class="udiff-line-added">+   Register tmp2 = rscratch2;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   Register tmp1 = rax;</span>
<span class="udiff-line-added">+   Register tmp2 = rcx;</span>
<span class="udiff-line-added">+   __ push(tmp1);</span>
<span class="udiff-line-added">+   __ push(tmp2);</span>
<span class="udiff-line-added">+ #endif // _LP64</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Pointer chase to the method holder to find out if the method is concurrently unloading.</span>
<span class="udiff-line-added">+   Label method_live;</span>
<span class="udiff-line-added">+   __ load_method_holder_cld(tmp1, rbx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+    // Is it a strong CLD?</span>
<span class="udiff-line-added">+   __ cmpl(Address(tmp1, ClassLoaderData::keep_alive_offset()), 0);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::greater, method_live);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+    // Is it a weak but alive CLD?</span>
<span class="udiff-line-added">+   __ movptr(tmp1, Address(tmp1, ClassLoaderData::holder_offset()));</span>
<span class="udiff-line-added">+   __ resolve_weak_handle(tmp1, tmp2);</span>
<span class="udiff-line-added">+   __ cmpptr(tmp1, 0);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::notEqual, method_live);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef _LP64</span>
<span class="udiff-line-added">+   __ pop(tmp2);</span>
<span class="udiff-line-added">+   __ pop(tmp1);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ bind(bad_call);</span>
<span class="udiff-line-added">+   __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>
<span class="udiff-line-added">+   __ bind(method_live);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef _LP64</span>
<span class="udiff-line-added">+   __ pop(tmp2);</span>
<span class="udiff-line-added">+   __ pop(tmp1);</span>
  #endif
  }
</pre>
<center><a href="../g1/g1BarrierSetAssembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="barrierSetAssembler_x86.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
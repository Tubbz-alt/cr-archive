<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../shared/modRefBarrierSetAssembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler_x86.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,8 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="udiff-line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -20,12 +21,14 @@</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -39,130 +42,80 @@</span>
  #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
  #endif
  
  #define __ masm-&gt;
  
<span class="udiff-line-modified-removed">- address ShenandoahBarrierSetAssembler::_shenandoah_wb = NULL;</span>
<span class="udiff-line-modified-added">+ address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;</span>
  
  void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
                                                         Register src, Register dst, Register count) {
  
<span class="udiff-line-removed">-   bool checkcast = (decorators &amp; ARRAYCOPY_CHECKCAST) != 0;</span>
<span class="udiff-line-removed">-   bool disjoint = (decorators &amp; ARRAYCOPY_DISJOINT) != 0;</span>
<span class="udiff-line-removed">-   bool obj_int = type == T_OBJECT LP64_ONLY(&amp;&amp; UseCompressedOops);</span>
    bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
  
<span class="udiff-line-modified-removed">-   if (type == T_OBJECT || type == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(type)) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if ((ShenandoahSATBBarrier &amp;&amp; !dest_uninitialized) || ShenandoahLoadRefBarrier) {</span>
  #ifdef _LP64
<span class="udiff-line-modified-removed">-     if (!checkcast &amp;&amp; !obj_int) {</span>
<span class="udiff-line-removed">-       // Save count for barrier</span>
<span class="udiff-line-removed">-       __ movptr(r11, count);</span>
<span class="udiff-line-removed">-     } else if (disjoint &amp;&amp; obj_int) {</span>
<span class="udiff-line-removed">-       // Save dst in r11 in the disjoint case</span>
<span class="udiff-line-removed">-       __ movq(r11, dst);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+       Register thread = r15_thread;</span>
  #else
<span class="udiff-line-modified-removed">-     if (disjoint) {</span>
<span class="udiff-line-modified-removed">-       __ mov(rdx, dst);          // save &#39;to&#39;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     if (!dest_uninitialized &amp;&amp; !ShenandoahHeap::heap()-&gt;heuristics()-&gt;can_do_traversal_gc()) {</span>
<span class="udiff-line-modified-removed">-       Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);</span>
<span class="udiff-line-modified-removed">- #ifndef _LP64</span>
<span class="udiff-line-modified-added">+       Register thread = rax;</span>
<span class="udiff-line-modified-added">+       if (thread == src || thread == dst || thread == count) {</span>
<span class="udiff-line-modified-added">+         thread = rbx;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+       if (thread == src || thread == dst || thread == count) {</span>
<span class="udiff-line-modified-added">+         thread = rcx;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+       if (thread == src || thread == dst || thread == count) {</span>
<span class="udiff-line-added">+         thread = rdx;</span>
<span class="udiff-line-added">+       }</span>
        __ push(thread);
        __ get_thread(thread);
  #endif
<span class="udiff-line-added">+       assert_different_registers(src, dst, count, thread);</span>
  
<span class="udiff-line-modified-removed">-       Label filtered;</span>
<span class="udiff-line-modified-removed">-       Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));</span>
<span class="udiff-line-modified-removed">-       // Is marking active?</span>
<span class="udiff-line-modified-removed">-       if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {</span>
<span class="udiff-line-removed">-         __ cmpl(in_progress, 0);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, &quot;Assumption&quot;);</span>
<span class="udiff-line-removed">-         __ cmpb(in_progress, 0);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       NOT_LP64(__ pop(thread);)</span>
<span class="udiff-line-modified-added">+       Label done;</span>
<span class="udiff-line-modified-added">+       // Short-circuit if count == 0.</span>
<span class="udiff-line-modified-added">+       __ testptr(count, count);</span>
<span class="udiff-line-modified-added">+       __ jcc(Assembler::zero, done);</span>
  
<span class="udiff-line-modified-removed">-         __ jcc(Assembler::equal, filtered);</span>
<span class="udiff-line-modified-added">+       // Avoid runtime call when not marking.</span>
<span class="udiff-line-added">+       Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="udiff-line-added">+       int flags = ShenandoahHeap::HAS_FORWARDED;</span>
<span class="udiff-line-added">+       if (!dest_uninitialized) {</span>
<span class="udiff-line-added">+         flags |= ShenandoahHeap::MARKING;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       __ testb(gc_state, flags);</span>
<span class="udiff-line-added">+       __ jcc(Assembler::zero, done);</span>
  
        __ pusha();                      // push registers
  #ifdef _LP64
<span class="udiff-line-modified-removed">-       if (count == c_rarg0) {</span>
<span class="udiff-line-modified-removed">-         if (dst == c_rarg1) {</span>
<span class="udiff-line-modified-removed">-           // exactly backwards!!</span>
<span class="udiff-line-modified-removed">-           __ xchgptr(c_rarg1, c_rarg0);</span>
<span class="udiff-line-modified-added">+       assert(src == rdi, &quot;expected&quot;);</span>
<span class="udiff-line-modified-added">+       assert(dst == rsi, &quot;expected&quot;);</span>
<span class="udiff-line-modified-added">+       assert(count == rdx, &quot;expected&quot;);</span>
<span class="udiff-line-modified-added">+       if (UseCompressedOops) {</span>
<span class="udiff-line-added">+         if (dest_uninitialized) {</span>
<span class="udiff-line-added">+           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_duinit_narrow_oop_entry), src, dst, count);</span>
          } else {
<span class="udiff-line-modified-removed">-           __ movptr(c_rarg1, count);</span>
<span class="udiff-line-removed">-           __ movptr(c_rarg0, dst);</span>
<span class="udiff-line-modified-added">+           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_narrow_oop_entry), src, dst, count);</span>
          }
<span class="udiff-line-modified-removed">-       } else {</span>
<span class="udiff-line-removed">-         __ movptr(c_rarg0, dst);</span>
<span class="udiff-line-removed">-         __ movptr(c_rarg1, count);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (UseCompressedOops) {</span>
<span class="udiff-line-removed">-         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_narrow_oop_entry), 2);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry), 2);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-       __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry),</span>
<span class="udiff-line-removed">-                       dst, count);</span>
<span class="udiff-line-modified-added">+       } else</span>
  #endif
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         if (dest_uninitialized) {</span>
<span class="udiff-line-added">+           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_duinit_oop_entry), src, dst, count);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry), src, dst, count);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
        __ popa();
<span class="udiff-line-modified-removed">-       __ bind(filtered);</span>
<span class="udiff-line-modified-added">+       __ bind(done);</span>
<span class="udiff-line-added">+       NOT_LP64(__ pop(thread);)</span>
      }
    }
  
  }
  
<span class="udiff-line-removed">- void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,</span>
<span class="udiff-line-removed">-                                                        Register src, Register dst, Register count) {</span>
<span class="udiff-line-removed">-   bool checkcast = (decorators &amp; ARRAYCOPY_CHECKCAST) != 0;</span>
<span class="udiff-line-removed">-   bool disjoint = (decorators &amp; ARRAYCOPY_DISJOINT) != 0;</span>
<span class="udiff-line-removed">-   bool obj_int = type == T_OBJECT LP64_ONLY(&amp;&amp; UseCompressedOops);</span>
<span class="udiff-line-removed">-   Register tmp = rax;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (type == T_OBJECT || type == T_ARRAY) {</span>
<span class="udiff-line-removed">- #ifdef _LP64</span>
<span class="udiff-line-removed">-     if (!checkcast &amp;&amp; !obj_int) {</span>
<span class="udiff-line-removed">-       // Save count for barrier</span>
<span class="udiff-line-removed">-       count = r11;</span>
<span class="udiff-line-removed">-     } else if (disjoint &amp;&amp; obj_int) {</span>
<span class="udiff-line-removed">-       // Use the saved dst in the disjoint case</span>
<span class="udiff-line-removed">-       dst = r11;</span>
<span class="udiff-line-removed">-     } else if (checkcast) {</span>
<span class="udiff-line-removed">-       tmp = rscratch1;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-     if (disjoint) {</span>
<span class="udiff-line-removed">-       __ mov(dst, rdx); // restore &#39;to&#39;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     __ pusha();             // push registers (overkill)</span>
<span class="udiff-line-removed">- #ifdef _LP64</span>
<span class="udiff-line-removed">-     if (c_rarg0 == count) { // On win64 c_rarg0 == rcx</span>
<span class="udiff-line-removed">-       assert_different_registers(c_rarg1, dst);</span>
<span class="udiff-line-removed">-       __ mov(c_rarg1, count);</span>
<span class="udiff-line-removed">-       __ mov(c_rarg0, dst);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       assert_different_registers(c_rarg0, count);</span>
<span class="udiff-line-removed">-       __ mov(c_rarg0, dst);</span>
<span class="udiff-line-removed">-       __ mov(c_rarg1, count);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_post_entry), 2);</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_post_entry),</span>
<span class="udiff-line-removed">-                     dst, count);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     __ popa();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
                                                                   Register obj,
                                                                   Register pre_val,
                                                                   Register thread,
                                                                   Register tmp,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -294,150 +247,322 @@</span>
    if(tosca_live) __ pop(rax);
  
    __ bind(done);
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetAssembler::read_barrier(MacroAssembler* masm, Register dst) {</span>
<span class="udiff-line-modified-removed">-   if (ShenandoahReadBarrier) {</span>
<span class="udiff-line-removed">-     read_barrier_impl(masm, dst);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierSetAssembler::load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address src) {</span>
<span class="udiff-line-modified-added">+   assert(ShenandoahLoadRefBarrier, &quot;Should be enabled&quot;);</span>
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetAssembler::read_barrier_impl(MacroAssembler* masm, Register dst) {</span>
<span class="udiff-line-removed">-   assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier || ShenandoahCASBarrier), &quot;should be enabled&quot;);</span>
<span class="udiff-line-removed">-   Label is_null;</span>
<span class="udiff-line-removed">-   __ testptr(dst, dst);</span>
<span class="udiff-line-removed">-   __ jcc(Assembler::zero, is_null);</span>
<span class="udiff-line-removed">-   read_barrier_not_null_impl(masm, dst);</span>
<span class="udiff-line-removed">-   __ bind(is_null);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+   Label done;</span>
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetAssembler::read_barrier_not_null(MacroAssembler* masm, Register dst) {</span>
<span class="udiff-line-modified-removed">-   if (ShenandoahReadBarrier) {</span>
<span class="udiff-line-modified-removed">-     read_barrier_not_null_impl(masm, dst);</span>
<span class="udiff-line-modified-added">+ #ifdef _LP64</span>
<span class="udiff-line-modified-added">+   Register thread = r15_thread;</span>
<span class="udiff-line-modified-added">+ #else</span>
<span class="udiff-line-added">+   Register thread = rcx;</span>
<span class="udiff-line-added">+   if (thread == dst) {</span>
<span class="udiff-line-added">+     thread = rbx;</span>
    }
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-added">+   __ push(thread);</span>
<span class="udiff-line-added">+   __ get_thread(thread);</span>
<span class="udiff-line-added">+ #endif</span>
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetAssembler::read_barrier_not_null_impl(MacroAssembler* masm, Register dst) {</span>
<span class="udiff-line-modified-removed">-   assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier || ShenandoahCASBarrier), &quot;should be enabled&quot;);</span>
<span class="udiff-line-modified-removed">-   __ movptr(dst, Address(dst, ShenandoahBrooksPointer::byte_offset()));</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-added">+   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="udiff-line-modified-added">+   __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED);</span>
<span class="udiff-line-modified-added">+   __ jccb(Assembler::zero, done);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   // Use rsi for src address</span>
<span class="udiff-line-added">+   const Register src_addr = rsi;</span>
<span class="udiff-line-added">+   // Setup address parameter first, if it does not clobber oop in dst</span>
<span class="udiff-line-added">+   bool need_addr_setup = (src_addr != dst);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (need_addr_setup) {</span>
<span class="udiff-line-added">+     __ push(src_addr);</span>
<span class="udiff-line-added">+     __ lea(src_addr, src);</span>
  
<span class="udiff-line-added">+     if (dst != rax) {</span>
<span class="udiff-line-added">+       // Move obj into rax and save rax</span>
<span class="udiff-line-added">+       __ push(rax);</span>
<span class="udiff-line-added">+       __ movptr(rax, dst);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // dst == rsi</span>
<span class="udiff-line-added">+     __ push(rax);</span>
<span class="udiff-line-added">+     __ movptr(rax, dst);</span>
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetAssembler::write_barrier(MacroAssembler* masm, Register dst) {</span>
<span class="udiff-line-modified-removed">-   if (ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-     write_barrier_impl(masm, dst);</span>
<span class="udiff-line-modified-added">+     // we can clobber it, since it is outgoing register</span>
<span class="udiff-line-modified-added">+     __ lea(src_addr, src);</span>
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_lrb())));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (need_addr_setup) {</span>
<span class="udiff-line-added">+     if (dst != rax) {</span>
<span class="udiff-line-added">+       __ movptr(dst, rax);</span>
<span class="udiff-line-added">+       __ pop(rax);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     __ pop(src_addr);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     __ movptr(dst, rax);</span>
<span class="udiff-line-added">+     __ pop(rax);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ bind(done);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef _LP64</span>
<span class="udiff-line-added">+     __ pop(thread);</span>
<span class="udiff-line-added">+ #endif</span>
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetAssembler::write_barrier_impl(MacroAssembler* masm, Register dst) {</span>
<span class="udiff-line-modified-removed">-   assert(UseShenandoahGC &amp;&amp; (ShenandoahWriteBarrier || ShenandoahStoreValEnqueueBarrier), &quot;Should be enabled&quot;);</span>
<span class="udiff-line-modified-removed">- #ifdef _LP64</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address src) {</span>
<span class="udiff-line-modified-added">+   if (!ShenandoahLoadRefBarrier) {</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    Label done;
<span class="udiff-line-added">+   Label not_null;</span>
<span class="udiff-line-added">+   Label slow_path;</span>
<span class="udiff-line-added">+   __ block_comment(&quot;load_reference_barrier_native { &quot;);</span>
  
<span class="udiff-line-modified-removed">-   Address gc_state(r15_thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="udiff-line-modified-removed">-   __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);</span>
<span class="udiff-line-modified-removed">-   __ jccb(Assembler::zero, done);</span>
<span class="udiff-line-modified-added">+   // null check</span>
<span class="udiff-line-modified-added">+   __ testptr(dst, dst);</span>
<span class="udiff-line-modified-added">+   __ jcc(Assembler::notZero, not_null);</span>
<span class="udiff-line-added">+   __ jmp(done);</span>
<span class="udiff-line-added">+   __ bind(not_null);</span>
  
<span class="udiff-line-removed">-   // Heap is unstable, need to perform the read-barrier even if WB is inactive</span>
<span class="udiff-line-removed">-   read_barrier_not_null(masm, dst);</span>
  
<span class="udiff-line-modified-removed">-   __ testb(gc_state, ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);</span>
<span class="udiff-line-modified-removed">-   __ jccb(Assembler::zero, done);</span>
<span class="udiff-line-modified-added">+ #ifdef _LP64</span>
<span class="udiff-line-modified-added">+   Register thread = r15_thread;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   Register thread = rcx;</span>
<span class="udiff-line-added">+   if (thread == dst) {</span>
<span class="udiff-line-added">+     thread = rbx;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   __ push(thread);</span>
<span class="udiff-line-added">+   __ get_thread(thread);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   assert_different_registers(dst, thread);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="udiff-line-added">+   __ testb(gc_state, ShenandoahHeap::EVACUATION);</span>
<span class="udiff-line-added">+ #ifndef _LP64</span>
<span class="udiff-line-added">+   __ pop(thread);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   __ jccb(Assembler::notZero, slow_path);</span>
<span class="udiff-line-added">+   __ jmp(done);</span>
<span class="udiff-line-added">+   __ bind(slow_path);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (dst != rax) {</span>
<span class="udiff-line-added">+     __ push(rax);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   __ push(rcx);</span>
<span class="udiff-line-added">+   __ push(rdx);</span>
<span class="udiff-line-added">+   __ push(rdi);</span>
<span class="udiff-line-added">+   __ push(rsi);</span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+   __ push(r8);</span>
<span class="udiff-line-added">+   __ push(r9);</span>
<span class="udiff-line-added">+   __ push(r10);</span>
<span class="udiff-line-added">+   __ push(r11);</span>
<span class="udiff-line-added">+   __ push(r12);</span>
<span class="udiff-line-added">+   __ push(r13);</span>
<span class="udiff-line-added">+   __ push(r14);</span>
<span class="udiff-line-added">+   __ push(r15);</span>
<span class="udiff-line-added">+ #endif</span>
  
<span class="udiff-line-modified-removed">-    if (dst != rax) {</span>
<span class="udiff-line-modified-removed">-      __ xchgptr(dst, rax); // Move obj into rax and save rax into obj.</span>
<span class="udiff-line-modified-removed">-    }</span>
<span class="udiff-line-modified-added">+   assert_different_registers(dst, rsi);</span>
<span class="udiff-line-modified-added">+   __ lea(rsi, src);</span>
<span class="udiff-line-modified-added">+   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), dst, rsi);</span>
  
<span class="udiff-line-modified-removed">-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_wb())));</span>
<span class="udiff-line-modified-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+   __ pop(r15);</span>
<span class="udiff-line-added">+   __ pop(r14);</span>
<span class="udiff-line-added">+   __ pop(r13);</span>
<span class="udiff-line-added">+   __ pop(r12);</span>
<span class="udiff-line-added">+   __ pop(r11);</span>
<span class="udiff-line-added">+   __ pop(r10);</span>
<span class="udiff-line-added">+   __ pop(r9);</span>
<span class="udiff-line-added">+   __ pop(r8);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   __ pop(rsi);</span>
<span class="udiff-line-added">+   __ pop(rdi);</span>
<span class="udiff-line-added">+   __ pop(rdx);</span>
<span class="udiff-line-added">+   __ pop(rcx);</span>
  
<span class="udiff-line-modified-removed">-    if (dst != rax) {</span>
<span class="udiff-line-modified-removed">-      __ xchgptr(rax, dst); // Swap back obj with rax.</span>
<span class="udiff-line-modified-removed">-    }</span>
<span class="udiff-line-modified-added">+   if (dst != rax) {</span>
<span class="udiff-line-modified-added">+     __ movptr(dst, rax);</span>
<span class="udiff-line-modified-added">+     __ pop(rax);</span>
<span class="udiff-line-added">+   }</span>
  
    __ bind(done);
<span class="udiff-line-modified-removed">- #else</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+   __ block_comment(&quot;load_reference_barrier_native { &quot;);</span>
  }
  
  void ShenandoahBarrierSetAssembler::storeval_barrier(MacroAssembler* masm, Register dst, Register tmp) {
<span class="udiff-line-modified-removed">-   if (ShenandoahStoreValReadBarrier || ShenandoahStoreValEnqueueBarrier) {</span>
<span class="udiff-line-modified-added">+   if (ShenandoahStoreValEnqueueBarrier) {</span>
      storeval_barrier_impl(masm, dst, tmp);
    }
  }
  
  void ShenandoahBarrierSetAssembler::storeval_barrier_impl(MacroAssembler* masm, Register dst, Register tmp) {
<span class="udiff-line-modified-removed">-   assert(UseShenandoahGC &amp;&amp; (ShenandoahStoreValReadBarrier || ShenandoahStoreValEnqueueBarrier), &quot;should be enabled&quot;);</span>
<span class="udiff-line-modified-added">+   assert(ShenandoahStoreValEnqueueBarrier, &quot;should be enabled&quot;);</span>
  
    if (dst == noreg) return;
  
<span class="udiff-line-removed">- #ifdef _LP64</span>
    if (ShenandoahStoreValEnqueueBarrier) {
<span class="udiff-line-removed">-     Label is_null;</span>
<span class="udiff-line-removed">-     __ testptr(dst, dst);</span>
<span class="udiff-line-removed">-     __ jcc(Assembler::zero, is_null);</span>
<span class="udiff-line-removed">-     write_barrier_impl(masm, dst);</span>
<span class="udiff-line-removed">-     __ bind(is_null);</span>
<span class="udiff-line-removed">- </span>
      // The set of registers to be saved+restored is the same as in the write-barrier above.
      // Those are the commonly used registers in the interpreter.
      __ pusha();
      // __ push_callee_saved_registers();
      __ subptr(rsp, 2 * Interpreter::stackElementSize);
      __ movdbl(Address(rsp, 0), xmm0);
  
<span class="udiff-line-modified-removed">-     satb_write_barrier_pre(masm, noreg, dst, r15_thread, tmp, true, false);</span>
<span class="udiff-line-modified-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+     Register thread = r15_thread;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     Register thread = rcx;</span>
<span class="udiff-line-added">+     if (thread == dst || thread == tmp) {</span>
<span class="udiff-line-added">+       thread = rdi;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (thread == dst || thread == tmp) {</span>
<span class="udiff-line-added">+       thread = rbx;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     __ get_thread(thread);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     assert_different_registers(dst, tmp, thread);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     satb_write_barrier_pre(masm, noreg, dst, thread, tmp, true, false);</span>
      __ movdbl(xmm0, Address(rsp, 0));
      __ addptr(rsp, 2 * Interpreter::stackElementSize);
      //__ pop_callee_saved_registers();
      __ popa();
    }
<span class="udiff-line-modified-removed">-   if (ShenandoahStoreValReadBarrier) {</span>
<span class="udiff-line-modified-removed">-     read_barrier_impl(masm, dst);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+ void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address src) {</span>
<span class="udiff-line-added">+   if (ShenandoahLoadRefBarrier) {</span>
<span class="udiff-line-added">+     Label done;</span>
<span class="udiff-line-added">+     __ testptr(dst, dst);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::zero, done);</span>
<span class="udiff-line-added">+     load_reference_barrier_not_null(masm, dst, src);</span>
<span class="udiff-line-added">+     __ bind(done);</span>
    }
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- #endif</span>
  }
  
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Arguments:</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Inputs:</span>
<span class="udiff-line-added">+ //   src:        oop location, might be clobbered</span>
<span class="udiff-line-added">+ //   tmp1:       scratch register, might not be valid.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Output:</span>
<span class="udiff-line-added">+ //   dst:        oop loaded from src location</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Kill:</span>
<span class="udiff-line-added">+ //   tmp1 (if it is valid)</span>
<span class="udiff-line-added">+ //</span>
  void ShenandoahBarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
               Register dst, Address src, Register tmp1, Register tmp_thread) {
<span class="udiff-line-modified-removed">-   bool on_oop = type == T_OBJECT || type == T_ARRAY;</span>
<span class="udiff-line-modified-removed">-   bool in_heap = (decorators &amp; IN_HEAP) != 0;</span>
<span class="udiff-line-modified-removed">-   bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;</span>
<span class="udiff-line-modified-removed">-   bool on_phantom = (decorators &amp; ON_PHANTOM_OOP_REF) != 0;</span>
<span class="udiff-line-modified-removed">-   bool on_reference = on_weak || on_phantom;</span>
<span class="udiff-line-modified-removed">-   if (in_heap) {</span>
<span class="udiff-line-modified-removed">-     read_barrier_not_null(masm, src.base());</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="udiff-line-removed">-   if (ShenandoahKeepAliveBarrier &amp;&amp; on_oop &amp;&amp; on_reference) {</span>
<span class="udiff-line-removed">-     const Register thread = NOT_LP64(tmp_thread) LP64_ONLY(r15_thread);</span>
<span class="udiff-line-removed">-     NOT_LP64(__ get_thread(thread));</span>
<span class="udiff-line-modified-added">+   // 1: non-reference load, no additional barrier is needed</span>
<span class="udiff-line-modified-added">+   if (!is_reference_type(type)) {</span>
<span class="udiff-line-modified-added">+     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Not expected&quot;);</span>
  
<span class="udiff-line-added">+   // 2: load a reference from src location and apply LRB if needed</span>
<span class="udiff-line-added">+   if (ShenandoahBarrierSet::need_load_reference_barrier(decorators, type)) {</span>
<span class="udiff-line-added">+     Register result_dst = dst;</span>
<span class="udiff-line-added">+     bool use_tmp1_for_dst = false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Preserve src location for LRB</span>
<span class="udiff-line-added">+     if (dst == src.base() || dst == src.index()) {</span>
<span class="udiff-line-added">+       // Use tmp1 for dst if possible, as it is not used in BarrierAssembler::load_at()</span>
<span class="udiff-line-added">+       if (tmp1-&gt;is_valid() &amp;&amp; tmp1 != src.base() &amp;&amp; tmp1 != src.index()) {</span>
<span class="udiff-line-added">+         dst = tmp1;</span>
<span class="udiff-line-added">+         use_tmp1_for_dst = true;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         dst = rdi;</span>
<span class="udiff-line-added">+         __ push(dst);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       assert_different_registers(dst, src.base(), src.index());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type)) {</span>
<span class="udiff-line-added">+       load_reference_barrier_native(masm, dst, src);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       load_reference_barrier(masm, dst, src);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Move loaded oop to final destination</span>
<span class="udiff-line-added">+     if (dst != result_dst) {</span>
<span class="udiff-line-added">+       __ movptr(result_dst, dst);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (!use_tmp1_for_dst) {</span>
<span class="udiff-line-added">+         __ pop(dst);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       dst = result_dst;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // 3: apply keep-alive barrier if needed</span>
<span class="udiff-line-added">+   if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {</span>
<span class="udiff-line-added">+     __ push_IU_state();</span>
<span class="udiff-line-added">+     // That path can be reached from the c2i adapter with live fp</span>
<span class="udiff-line-added">+     // arguments in registers.</span>
<span class="udiff-line-added">+     LP64_ONLY(assert(Argument::n_float_register_parameters_j == 8, &quot;8 fp registers to save at java call&quot;));</span>
<span class="udiff-line-added">+     __ subptr(rsp, 64);</span>
<span class="udiff-line-added">+     __ movdbl(Address(rsp, 0), xmm0);</span>
<span class="udiff-line-added">+     __ movdbl(Address(rsp, 8), xmm1);</span>
<span class="udiff-line-added">+     __ movdbl(Address(rsp, 16), xmm2);</span>
<span class="udiff-line-added">+     __ movdbl(Address(rsp, 24), xmm3);</span>
<span class="udiff-line-added">+     __ movdbl(Address(rsp, 32), xmm4);</span>
<span class="udiff-line-added">+     __ movdbl(Address(rsp, 40), xmm5);</span>
<span class="udiff-line-added">+     __ movdbl(Address(rsp, 48), xmm6);</span>
<span class="udiff-line-added">+     __ movdbl(Address(rsp, 56), xmm7);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Register thread = NOT_LP64(tmp_thread) LP64_ONLY(r15_thread);</span>
<span class="udiff-line-added">+     assert_different_registers(dst, tmp1, tmp_thread);</span>
<span class="udiff-line-added">+     if (!thread-&gt;is_valid()) {</span>
<span class="udiff-line-added">+       thread = rdx;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     NOT_LP64(__ get_thread(thread));</span>
      // Generate the SATB pre-barrier code to log the value of
      // the referent field in an SATB buffer.
      shenandoah_write_barrier_pre(masm /* masm */,
                                   noreg /* obj */,
                                   dst /* pre_val */,
                                   thread /* thread */,
                                   tmp1 /* tmp */,
                                   true /* tosca_live */,
                                   true /* expand_call */);
<span class="udiff-line-added">+     __ movdbl(xmm0, Address(rsp, 0));</span>
<span class="udiff-line-added">+     __ movdbl(xmm1, Address(rsp, 8));</span>
<span class="udiff-line-added">+     __ movdbl(xmm2, Address(rsp, 16));</span>
<span class="udiff-line-added">+     __ movdbl(xmm3, Address(rsp, 24));</span>
<span class="udiff-line-added">+     __ movdbl(xmm4, Address(rsp, 32));</span>
<span class="udiff-line-added">+     __ movdbl(xmm5, Address(rsp, 40));</span>
<span class="udiff-line-added">+     __ movdbl(xmm6, Address(rsp, 48));</span>
<span class="udiff-line-added">+     __ movdbl(xmm7, Address(rsp, 56));</span>
<span class="udiff-line-added">+     __ addptr(rsp, 64);</span>
<span class="udiff-line-added">+     __ pop_IU_state();</span>
    }
  }
  
  void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
                Address dst, Register val, Register tmp1, Register tmp2) {
  
<span class="udiff-line-added">+   bool on_oop = is_reference_type(type);</span>
    bool in_heap = (decorators &amp; IN_HEAP) != 0;
    bool as_normal = (decorators &amp; AS_NORMAL) != 0;
<span class="udiff-line-modified-removed">-   if (in_heap) {</span>
<span class="udiff-line-removed">-     write_barrier(masm, dst.base());</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (type == T_OBJECT || type == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+   if (on_oop &amp;&amp; in_heap) {</span>
      bool needs_pre_barrier = as_normal;
  
      Register tmp3 = LP64_ONLY(r8) NOT_LP64(rsi);
      Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
      // flatten object address if needed
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -448,17 +573,18 @@</span>
        }
      } else {
        __ lea(tmp1, dst);
      }
  
<span class="udiff-line-added">+     assert_different_registers(val, tmp1, tmp2, tmp3, rthread);</span>
<span class="udiff-line-added">+ </span>
  #ifndef _LP64
<span class="udiff-line-added">+     __ get_thread(rthread);</span>
      InterpreterMacroAssembler *imasm = static_cast&lt;InterpreterMacroAssembler*&gt;(masm);
<span class="udiff-line-added">+     imasm-&gt;save_bcp();</span>
  #endif
  
<span class="udiff-line-removed">-     NOT_LP64(__ get_thread(rcx));</span>
<span class="udiff-line-removed">-     NOT_LP64(imasm-&gt;save_bcp());</span>
<span class="udiff-line-removed">- </span>
      if (needs_pre_barrier) {
        shenandoah_write_barrier_pre(masm /*masm*/,
                                     tmp1 /* obj */,
                                     tmp2 /* pre_val */,
                                     rthread /* thread */,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -476,320 +602,198 @@</span>
    } else {
      BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);
    }
  }
  
<span class="udiff-line-modified-removed">- #ifndef _LP64</span>
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm,</span>
<span class="udiff-line-modified-removed">-                                                Address obj1, jobject obj2) {</span>
<span class="udiff-line-modified-removed">-   Unimplemented();</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm,</span>
<span class="udiff-line-removed">-                                                Register obj1, jobject obj2) {</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm, Register op1, Register op2) {</span>
<span class="udiff-line-removed">-   __ cmpptr(op1, op2);</span>
<span class="udiff-line-removed">-   if (ShenandoahAcmpBarrier) {</span>
<span class="udiff-line-removed">-     Label done;</span>
<span class="udiff-line-removed">-     __ jccb(Assembler::equal, done);</span>
<span class="udiff-line-removed">-     read_barrier(masm, op1);</span>
<span class="udiff-line-removed">-     read_barrier(masm, op2);</span>
<span class="udiff-line-removed">-     __ cmpptr(op1, op2);</span>
<span class="udiff-line-removed">-     __ bind(done);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm, Register src1, Address src2) {</span>
<span class="udiff-line-removed">-   __ cmpptr(src1, src2);</span>
<span class="udiff-line-removed">-   if (ShenandoahAcmpBarrier) {</span>
<span class="udiff-line-removed">-     Label done;</span>
<span class="udiff-line-removed">-     __ jccb(Assembler::equal, done);</span>
<span class="udiff-line-removed">-     __ movptr(rscratch2, src2);</span>
<span class="udiff-line-removed">-     read_barrier(masm, src1);</span>
<span class="udiff-line-removed">-     read_barrier(masm, rscratch2);</span>
<span class="udiff-line-removed">-     __ cmpptr(src1, rscratch2);</span>
<span class="udiff-line-removed">-     __ bind(done);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahBarrierSetAssembler::tlab_allocate(MacroAssembler* masm,</span>
<span class="udiff-line-removed">-                                                   Register thread, Register obj,</span>
<span class="udiff-line-removed">-                                                   Register var_size_in_bytes,</span>
<span class="udiff-line-removed">-                                                   int con_size_in_bytes,</span>
<span class="udiff-line-removed">-                                                   Register t1, Register t2,</span>
<span class="udiff-line-removed">-                                                   Label&amp; slow_case) {</span>
<span class="udiff-line-removed">-   assert_different_registers(obj, t1, t2);</span>
<span class="udiff-line-removed">-   assert_different_registers(obj, var_size_in_bytes, t1);</span>
<span class="udiff-line-removed">-   Register end = t2;</span>
<span class="udiff-line-removed">-   if (!thread-&gt;is_valid()) {</span>
<span class="udiff-line-removed">- #ifdef _LP64</span>
<span class="udiff-line-removed">-     thread = r15_thread;</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-     assert(t1-&gt;is_valid(), &quot;need temp reg&quot;);</span>
<span class="udiff-line-removed">-     thread = t1;</span>
<span class="udiff-line-removed">-     __ get_thread(thread);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   __ verify_tlab();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   __ movptr(obj, Address(thread, JavaThread::tlab_top_offset()));</span>
<span class="udiff-line-removed">-   if (var_size_in_bytes == noreg) {</span>
<span class="udiff-line-removed">-     __ lea(end, Address(obj, con_size_in_bytes + ShenandoahBrooksPointer::byte_size()));</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     __ addptr(var_size_in_bytes, ShenandoahBrooksPointer::byte_size());</span>
<span class="udiff-line-removed">-     __ lea(end, Address(obj, var_size_in_bytes, Address::times_1));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   __ cmpptr(end, Address(thread, JavaThread::tlab_end_offset()));</span>
<span class="udiff-line-removed">-   __ jcc(Assembler::above, slow_case);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // update the tlab top pointer</span>
<span class="udiff-line-removed">-   __ movptr(Address(thread, JavaThread::tlab_top_offset()), end);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Initialize brooks pointer</span>
<span class="udiff-line-removed">- #ifdef _LP64</span>
<span class="udiff-line-removed">-   __ incrementq(obj, ShenandoahBrooksPointer::byte_size());</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-   __ incrementl(obj, ShenandoahBrooksPointer::byte_size());</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   __ movptr(Address(obj, ShenandoahBrooksPointer::byte_offset()), obj);</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierSetAssembler::try_resolve_jobject_in_native(MacroAssembler* masm, Register jni_env,</span>
<span class="udiff-line-modified-added">+                                                                   Register obj, Register tmp, Label&amp; slowpath) {</span>
<span class="udiff-line-modified-added">+   Label done;</span>
<span class="udiff-line-modified-added">+   // Resolve jobject</span>
<span class="udiff-line-modified-added">+   BarrierSetAssembler::try_resolve_jobject_in_native(masm, jni_env, obj, tmp, slowpath);</span>
  
<span class="udiff-line-modified-removed">-   // recover var_size_in_bytes if necessary</span>
<span class="udiff-line-modified-removed">-   if (var_size_in_bytes == end) {</span>
<span class="udiff-line-modified-removed">-     __ subptr(var_size_in_bytes, obj);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   __ verify_tlab();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+   // Check for null.</span>
<span class="udiff-line-modified-added">+   __ testptr(obj, obj);</span>
<span class="udiff-line-modified-added">+   __ jcc(Assembler::zero, done);</span>
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetAssembler::resolve(MacroAssembler* masm, DecoratorSet decorators, Register obj) {</span>
<span class="udiff-line-modified-removed">-   bool oop_not_null = (decorators &amp; IS_NOT_NULL) != 0;</span>
<span class="udiff-line-modified-removed">-   bool is_write = (decorators &amp; ACCESS_WRITE) != 0;</span>
<span class="udiff-line-modified-removed">-   if (is_write) {</span>
<span class="udiff-line-removed">-     if (oop_not_null) {</span>
<span class="udiff-line-removed">-       write_barrier(masm, obj);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       Label done;</span>
<span class="udiff-line-removed">-       __ testptr(obj, obj);</span>
<span class="udiff-line-removed">-       __ jcc(Assembler::zero, done);</span>
<span class="udiff-line-removed">-       write_barrier(masm, obj);</span>
<span class="udiff-line-removed">-       __ bind(done);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     if (oop_not_null) {</span>
<span class="udiff-line-removed">-       read_barrier_not_null(masm, obj);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       read_barrier(masm, obj);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   Address gc_state(jni_env, ShenandoahThreadLocalData::gc_state_offset() - JavaThread::jni_environment_offset());</span>
<span class="udiff-line-modified-added">+   __ testb(gc_state, ShenandoahHeap::EVACUATION);</span>
<span class="udiff-line-modified-added">+   __ jccb(Assembler::notZero, slowpath);</span>
<span class="udiff-line-modified-added">+   __ bind(done);</span>
  }
  
  // Special Shenandoah CAS implementation that handles false negatives
  // due to concurrent evacuation.
<span class="udiff-line-removed">- #ifndef _LP64</span>
<span class="udiff-line-removed">- void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm,</span>
<span class="udiff-line-removed">-                                                 Register res, Address addr, Register oldval, Register newval,</span>
<span class="udiff-line-removed">-                                                 bool exchange, Register tmp1, Register tmp2) {</span>
<span class="udiff-line-removed">-   // Shenandoah has no 32-bit version for this.</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #else</span>
  void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm,
                                                  Register res, Address addr, Register oldval, Register newval,
                                                  bool exchange, Register tmp1, Register tmp2) {
    assert(ShenandoahCASBarrier, &quot;Should only be used when CAS barrier is enabled&quot;);
    assert(oldval == rax, &quot;must be in rax for implicit use in cmpxchg&quot;);
<span class="udiff-line-added">+   assert_different_registers(oldval, newval, tmp1, tmp2);</span>
  
<span class="udiff-line-modified-removed">-   Label retry, done;</span>
<span class="udiff-line-modified-added">+   Label L_success, L_failure;</span>
  
    // Remember oldval for retry logic below
<span class="udiff-line-added">+ #ifdef _LP64</span>
    if (UseCompressedOops) {
      __ movl(tmp1, oldval);
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-added">+   } else</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   {</span>
      __ movptr(tmp1, oldval);
    }
  
<span class="udiff-line-modified-removed">-   // Step 1. Try to CAS with given arguments. If successful, then we are done,</span>
<span class="udiff-line-modified-removed">-   // and can safely return.</span>
<span class="udiff-line-modified-added">+   // Step 1. Fast-path.</span>
<span class="udiff-line-modified-added">+   //</span>
<span class="udiff-line-added">+   // Try to CAS with given arguments. If successful, then we are done.</span>
<span class="udiff-line-added">+ </span>
    if (os::is_MP()) __ lock();
<span class="udiff-line-added">+ #ifdef _LP64</span>
    if (UseCompressedOops) {
      __ cmpxchgl(newval, addr);
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-added">+   } else</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   {</span>
      __ cmpxchgptr(newval, addr);
    }
<span class="udiff-line-modified-removed">-   __ jcc(Assembler::equal, done, true);</span>
<span class="udiff-line-modified-added">+   __ jcc(Assembler::equal, L_success);</span>
  
    // Step 2. CAS had failed. This may be a false negative.
    //
    // The trouble comes when we compare the to-space pointer with the from-space
<span class="udiff-line-modified-removed">-   // pointer to the same object. To resolve this, it will suffice to read both</span>
<span class="udiff-line-modified-removed">-   // oldval and the value from memory through the read barriers -- this will give</span>
<span class="udiff-line-modified-removed">-   // both to-space pointers. If they mismatch, then it was a legitimate failure.</span>
<span class="udiff-line-modified-added">+   // pointer to the same object. To resolve this, it will suffice to resolve</span>
<span class="udiff-line-modified-added">+   // the value from memory -- this will give both to-space pointers.</span>
<span class="udiff-line-modified-added">+   // If they mismatch, then it was a legitimate failure.</span>
    //
<span class="udiff-line-modified-removed">-   if (UseCompressedOops) {</span>
<span class="udiff-line-modified-removed">-     __ decode_heap_oop(tmp1);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   read_barrier_impl(masm, tmp1);</span>
<span class="udiff-line-modified-added">+   // Before reaching to resolve sequence, see if we can avoid the whole shebang</span>
<span class="udiff-line-modified-added">+   // with filters.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Filter: when offending in-memory value is NULL, the failure is definitely legitimate</span>
<span class="udiff-line-added">+   __ testptr(oldval, oldval);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::zero, L_failure);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Filter: when heap is stable, the failure is definitely legitimate</span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+   const Register thread = r15_thread;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   const Register thread = tmp2;</span>
<span class="udiff-line-added">+   __ get_thread(thread);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="udiff-line-added">+   __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::zero, L_failure);</span>
  
<span class="udiff-line-added">+ #ifdef _LP64</span>
    if (UseCompressedOops) {
      __ movl(tmp2, oldval);
      __ decode_heap_oop(tmp2);
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-added">+   } else</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   {</span>
      __ movptr(tmp2, oldval);
    }
<span class="udiff-line-removed">-   read_barrier_impl(masm, tmp2);</span>
  
<span class="udiff-line-modified-removed">-   __ cmpptr(tmp1, tmp2);</span>
<span class="udiff-line-modified-removed">-   __ jcc(Assembler::notEqual, done, true);</span>
<span class="udiff-line-modified-added">+   // Decode offending in-memory value.</span>
<span class="udiff-line-modified-added">+   // Test if-forwarded</span>
<span class="udiff-line-added">+   __ testb(Address(tmp2, oopDesc::mark_offset_in_bytes()), markWord::marked_value);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::noParity, L_failure);  // When odd number of bits, then not forwarded</span>
<span class="udiff-line-added">+   __ jcc(Assembler::zero, L_failure);      // When it is 00, then also not forwarded</span>
  
<span class="udiff-line-modified-removed">-   // Step 3. Try to CAS again with resolved to-space pointers.</span>
<span class="udiff-line-modified-removed">-   //</span>
<span class="udiff-line-modified-removed">-   // Corner case: it may happen that somebody stored the from-space pointer</span>
<span class="udiff-line-modified-removed">-   // to memory while we were preparing for retry. Therefore, we can fail again</span>
<span class="udiff-line-removed">-   // on retry, and so need to do this in loop, always re-reading the failure</span>
<span class="udiff-line-removed">-   // witness through the read barrier.</span>
<span class="udiff-line-removed">-   __ bind(retry);</span>
<span class="udiff-line-removed">-   if (os::is_MP()) __ lock();</span>
<span class="udiff-line-removed">-   if (UseCompressedOops) {</span>
<span class="udiff-line-removed">-     __ cmpxchgl(newval, addr);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     __ cmpxchgptr(newval, addr);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   __ jcc(Assembler::equal, done, true);</span>
<span class="udiff-line-modified-added">+   // Load and mask forwarding pointer</span>
<span class="udiff-line-modified-added">+   __ movptr(tmp2, Address(tmp2, oopDesc::mark_offset_in_bytes()));</span>
<span class="udiff-line-modified-added">+   __ shrptr(tmp2, 2);</span>
<span class="udiff-line-modified-added">+   __ shlptr(tmp2, 2);</span>
  
<span class="udiff-line-added">+ #ifdef _LP64</span>
    if (UseCompressedOops) {
<span class="udiff-line-modified-removed">-     __ movl(tmp2, oldval);</span>
<span class="udiff-line-removed">-     __ decode_heap_oop(tmp2);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     __ movptr(tmp2, oldval);</span>
<span class="udiff-line-modified-added">+     __ decode_heap_oop(tmp1); // decode for comparison</span>
    }
<span class="udiff-line-modified-removed">-   read_barrier_impl(masm, tmp2);</span>
<span class="udiff-line-modified-added">+ #endif</span>
  
<span class="udiff-line-added">+   // Now we have the forwarded offender in tmp2.</span>
<span class="udiff-line-added">+   // Compare and if they don&#39;t match, we have legitimate failure</span>
    __ cmpptr(tmp1, tmp2);
<span class="udiff-line-modified-removed">-   __ jcc(Assembler::equal, retry, true);</span>
<span class="udiff-line-modified-added">+   __ jcc(Assembler::notEqual, L_failure);</span>
  
<span class="udiff-line-modified-removed">-   // Step 4. If we need a boolean result out of CAS, check the flag again,</span>
<span class="udiff-line-modified-removed">-   // and promote the result. Note that we handle the flag from both the CAS</span>
<span class="udiff-line-modified-removed">-   // itself and from the retry loop.</span>
<span class="udiff-line-modified-removed">-   __ bind(done);</span>
<span class="udiff-line-modified-removed">-   if (!exchange) {</span>
<span class="udiff-line-modified-removed">-     assert(res != NULL, &quot;need result register&quot;);</span>
<span class="udiff-line-modified-removed">-     __ setb(Assembler::equal, res);</span>
<span class="udiff-line-modified-removed">-     __ movzbl(res, res);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif // LP64</span>
<span class="udiff-line-modified-added">+   // Step 3. Need to fix the memory ptr before continuing.</span>
<span class="udiff-line-modified-added">+   //</span>
<span class="udiff-line-modified-added">+   // At this point, we have from-space oldval in the register, and its to-space</span>
<span class="udiff-line-modified-added">+   // address is in tmp2. Let&#39;s try to update it into memory. We don&#39;t care if it</span>
<span class="udiff-line-modified-added">+   // succeeds or not. If it does, then the retrying CAS would see it and succeed.</span>
<span class="udiff-line-modified-added">+   // If this fixup fails, this means somebody else beat us to it, and necessarily</span>
<span class="udiff-line-modified-added">+   // with to-space ptr store. We still have to do the retry, because the GC might</span>
<span class="udiff-line-modified-added">+   // have updated the reference for us.</span>
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetAssembler::save_vector_registers(MacroAssembler* masm) {</span>
<span class="udiff-line-modified-removed">-   int num_xmm_regs = LP64_ONLY(16) NOT_LP64(8);</span>
<span class="udiff-line-modified-removed">-   if (UseAVX &gt; 2) {</span>
<span class="udiff-line-removed">-     num_xmm_regs = LP64_ONLY(32) NOT_LP64(8);</span>
<span class="udiff-line-modified-added">+ #ifdef _LP64</span>
<span class="udiff-line-modified-added">+   if (UseCompressedOops) {</span>
<span class="udiff-line-modified-added">+     __ encode_heap_oop(tmp2); // previously decoded at step 2.</span>
    }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (UseSSE == 1)  {</span>
<span class="udiff-line-removed">-     __ subptr(rsp, sizeof(jdouble)*8);</span>
<span class="udiff-line-removed">-     for (int n = 0; n &lt; 8; n++) {</span>
<span class="udiff-line-removed">-       __ movflt(Address(rsp, n*sizeof(jdouble)), as_XMMRegister(n));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else if (UseSSE &gt;= 2)  {</span>
<span class="udiff-line-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-removed">-       __ push(rbx);</span>
<span class="udiff-line-removed">-       __ movl(rbx, 0xffff);</span>
<span class="udiff-line-removed">-       __ kmovwl(k1, rbx);</span>
<span class="udiff-line-removed">-       __ pop(rbx);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #ifdef COMPILER2</span>
<span class="udiff-line-removed">-     if (MaxVectorSize &gt; 16) {</span>
<span class="udiff-line-removed">-       if(UseAVX &gt; 2) {</span>
<span class="udiff-line-removed">-         // Save upper half of ZMM registers</span>
<span class="udiff-line-removed">-         __ subptr(rsp, 32*num_xmm_regs);</span>
<span class="udiff-line-removed">-         for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="udiff-line-removed">-           __ vextractf64x4_high(Address(rsp, n*32), as_XMMRegister(n));</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       assert(UseAVX &gt; 0, &quot;256 bit vectors are supported only with AVX&quot;);</span>
<span class="udiff-line-removed">-       // Save upper half of YMM registers</span>
<span class="udiff-line-removed">-       __ subptr(rsp, 16*num_xmm_regs);</span>
<span class="udiff-line-removed">-       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="udiff-line-removed">-         __ vextractf128_high(Address(rsp, n*16), as_XMMRegister(n));</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
  #endif
<span class="udiff-line-modified-removed">-     // Save whole 128bit (16 bytes) XMM registers</span>
<span class="udiff-line-modified-removed">-     __ subptr(rsp, 16*num_xmm_regs);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (os::is_MP()) __ lock();</span>
  #ifdef _LP64
<span class="udiff-line-modified-removed">-     if (VM_Version::supports_evex()) {</span>
<span class="udiff-line-modified-removed">-       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="udiff-line-modified-removed">-         __ vextractf32x4(Address(rsp, n*16), as_XMMRegister(n), 0);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="udiff-line-removed">-         __ movdqu(Address(rsp, n*16), as_XMMRegister(n));</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-     for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="udiff-line-removed">-       __ movdqu(Address(rsp, n*16), as_XMMRegister(n));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   if (UseCompressedOops) {</span>
<span class="udiff-line-modified-added">+     __ cmpxchgl(tmp2, addr);</span>
<span class="udiff-line-modified-added">+   } else</span>
  #endif
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     __ cmpxchgptr(tmp2, addr);</span>
    }
<span class="udiff-line-removed">- }</span>
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetAssembler::restore_vector_registers(MacroAssembler* masm) {</span>
<span class="udiff-line-modified-removed">-   int num_xmm_regs = LP64_ONLY(16) NOT_LP64(8);</span>
<span class="udiff-line-modified-removed">-   if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-removed">-     num_xmm_regs = LP64_ONLY(32) NOT_LP64(8);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   if (UseSSE == 1)  {</span>
<span class="udiff-line-modified-removed">-     for (int n = 0; n &lt; 8; n++) {</span>
<span class="udiff-line-removed">-       __ movflt(as_XMMRegister(n), Address(rsp, n*sizeof(jdouble)));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     __ addptr(rsp, sizeof(jdouble)*8);</span>
<span class="udiff-line-removed">-   } else if (UseSSE &gt;= 2)  {</span>
<span class="udiff-line-removed">-     // Restore whole 128bit (16 bytes) XMM registers</span>
<span class="udiff-line-modified-added">+   // Step 4. Try to CAS again.</span>
<span class="udiff-line-modified-added">+   //</span>
<span class="udiff-line-modified-added">+   // This is guaranteed not to have false negatives, because oldval is definitely</span>
<span class="udiff-line-modified-added">+   // to-space, and memory pointer is to-space as well. Nothing is able to store</span>
<span class="udiff-line-modified-added">+   // from-space ptr into memory anymore. Make sure oldval is restored, after being</span>
<span class="udiff-line-modified-added">+   // garbled during retries.</span>
<span class="udiff-line-modified-added">+   //</span>
  #ifdef _LP64
<span class="udiff-line-modified-removed">-     if (VM_Version::supports_evex()) {</span>
<span class="udiff-line-modified-removed">-       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="udiff-line-modified-removed">-         __ vinsertf32x4(as_XMMRegister(n), as_XMMRegister(n), Address(rsp, n*16), 0);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="udiff-line-removed">-         __ movdqu(as_XMMRegister(n), Address(rsp, n*16));</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-     for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="udiff-line-removed">-       __ movdqu(as_XMMRegister(n), Address(rsp, n*16));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   if (UseCompressedOops) {</span>
<span class="udiff-line-modified-added">+     __ movl(oldval, tmp2);</span>
<span class="udiff-line-modified-added">+   } else</span>
  #endif
<span class="udiff-line-modified-removed">-     __ addptr(rsp, 16*num_xmm_regs);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-added">+     __ movptr(oldval, tmp2);</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">- #ifdef COMPILER2</span>
<span class="udiff-line-modified-removed">-     if (MaxVectorSize &gt; 16) {</span>
<span class="udiff-line-modified-removed">-       // Restore upper half of YMM registers.</span>
<span class="udiff-line-modified-removed">-       for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="udiff-line-modified-removed">-         __ vinsertf128_high(as_XMMRegister(n), Address(rsp, n*16));</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       __ addptr(rsp, 16*num_xmm_regs);</span>
<span class="udiff-line-removed">-       if (UseAVX &gt; 2) {</span>
<span class="udiff-line-removed">-         for (int n = 0; n &lt; num_xmm_regs; n++) {</span>
<span class="udiff-line-removed">-           __ vinsertf64x4_high(as_XMMRegister(n), Address(rsp, n*32));</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         __ addptr(rsp, 32*num_xmm_regs);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   if (os::is_MP()) __ lock();</span>
<span class="udiff-line-modified-added">+ #ifdef _LP64</span>
<span class="udiff-line-modified-added">+   if (UseCompressedOops) {</span>
<span class="udiff-line-modified-added">+     __ cmpxchgl(newval, addr);</span>
<span class="udiff-line-modified-added">+   } else</span>
  #endif
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     __ cmpxchgptr(newval, addr);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!exchange) {</span>
<span class="udiff-line-added">+     __ jccb(Assembler::equal, L_success); // fastpath, peeking into Step 5, no need to jump</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Step 5. If we need a boolean result out of CAS, set the flag appropriately.</span>
<span class="udiff-line-added">+   // and promote the result. Note that we handle the flag from both the 1st and 2nd CAS.</span>
<span class="udiff-line-added">+   // Otherwise, failure witness for CAE is in oldval on all paths, and we can return.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (exchange) {</span>
<span class="udiff-line-added">+     __ bind(L_failure);</span>
<span class="udiff-line-added">+     __ bind(L_success);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     assert(res != NULL, &quot;need result register&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Label exit;</span>
<span class="udiff-line-added">+     __ bind(L_failure);</span>
<span class="udiff-line-added">+     __ xorptr(res, res);</span>
<span class="udiff-line-added">+     __ jmpb(exit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ bind(L_success);</span>
<span class="udiff-line-added">+     __ movptr(res, 1);</span>
<span class="udiff-line-added">+     __ bind(exit);</span>
    }
  }
  
<span class="udiff-line-added">+ #undef __</span>
<span class="udiff-line-added">+ </span>
  #ifdef COMPILER1
  
<span class="udiff-line-removed">- #undef __</span>
  #define __ ce-&gt;masm()-&gt;
  
  void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
    ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
    // At this point we know that marking is in progress.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -812,30 +816,56 @@</span>
    __ call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
    __ jmp(*stub-&gt;continuation());
  
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetAssembler::gen_write_barrier_stub(LIR_Assembler* ce, ShenandoahWriteBarrierStub* stub) {</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierSetAssembler::gen_load_reference_barrier_stub(LIR_Assembler* ce, ShenandoahLoadReferenceBarrierStub* stub) {</span>
<span class="udiff-line-added">+   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();</span>
    __ bind(*stub-&gt;entry());
  
<span class="udiff-line-removed">-   Label done;</span>
    Register obj = stub-&gt;obj()-&gt;as_register();
    Register res = stub-&gt;result()-&gt;as_register();
<span class="udiff-line-added">+   Register addr = stub-&gt;addr()-&gt;as_pointer_register();</span>
<span class="udiff-line-added">+   Register tmp1 = stub-&gt;tmp1()-&gt;as_register();</span>
<span class="udiff-line-added">+   Register tmp2 = stub-&gt;tmp2()-&gt;as_register();</span>
<span class="udiff-line-added">+   assert_different_registers(obj, res, addr, tmp1, tmp2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Label slow_path;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(res == rax, &quot;result must arrive in rax&quot;);</span>
  
    if (res != obj) {
      __ mov(res, obj);
    }
  
    // Check for null.
<span class="udiff-line-modified-removed">-   if (stub-&gt;needs_null_check()) {</span>
<span class="udiff-line-modified-removed">-     __ testptr(res, res);</span>
<span class="udiff-line-removed">-     __ jcc(Assembler::zero, done);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   __ testptr(res, res);</span>
<span class="udiff-line-modified-added">+   __ jcc(Assembler::zero, *stub-&gt;continuation());</span>
  
<span class="udiff-line-modified-removed">-   write_barrier(ce-&gt;masm(), res);</span>
<span class="udiff-line-modified-added">+   // Check for object being in the collection set.</span>
<span class="udiff-line-added">+   __ mov(tmp1, res);</span>
<span class="udiff-line-added">+   __ shrptr(tmp1, ShenandoahHeapRegion::region_size_bytes_shift_jint());</span>
<span class="udiff-line-added">+   __ movptr(tmp2, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());</span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+   __ movbool(tmp2, Address(tmp2, tmp1, Address::times_1));</span>
<span class="udiff-line-added">+   __ testbool(tmp2);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   // On x86_32, C1 register allocator can give us the register without 8-bit support.</span>
<span class="udiff-line-added">+   // Do the full-register access and test to avoid compilation failures.</span>
<span class="udiff-line-added">+   __ movptr(tmp2, Address(tmp2, tmp1, Address::times_1));</span>
<span class="udiff-line-added">+   __ testptr(tmp2, 0xFF);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   __ jcc(Assembler::zero, *stub-&gt;continuation());</span>
  
<span class="udiff-line-modified-removed">-   __ bind(done);</span>
<span class="udiff-line-modified-added">+   __ bind(slow_path);</span>
<span class="udiff-line-added">+   ce-&gt;store_parameter(res, 0);</span>
<span class="udiff-line-added">+   ce-&gt;store_parameter(addr, 1);</span>
<span class="udiff-line-added">+   if (stub-&gt;is_native()) {</span>
<span class="udiff-line-added">+     __ call(RuntimeAddress(bs-&gt;load_reference_barrier_native_rt_code_blob()-&gt;code_begin()));</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     __ call(RuntimeAddress(bs-&gt;load_reference_barrier_rt_code_blob()-&gt;code_begin()));</span>
<span class="udiff-line-added">+   }</span>
    __ jmp(*stub-&gt;continuation());
  }
  
  #undef __
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -895,102 +925,158 @@</span>
    __ pop(rax);
  
    __ epilogue();
  }
  
<span class="udiff-line-added">+ void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native) {</span>
<span class="udiff-line-added">+   __ prologue(&quot;shenandoah_load_reference_barrier&quot;, false);</span>
<span class="udiff-line-added">+   // arg0 : object to be resolved</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ save_live_registers_no_oop_map(true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+   __ load_parameter(0, c_rarg0);</span>
<span class="udiff-line-added">+   __ load_parameter(1, c_rarg1);</span>
<span class="udiff-line-added">+   if (is_native) {</span>
<span class="udiff-line-added">+     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), c_rarg0, c_rarg1);</span>
<span class="udiff-line-added">+   } else if (UseCompressedOops) {</span>
<span class="udiff-line-added">+     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), c_rarg0, c_rarg1);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), c_rarg0, c_rarg1);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   __ load_parameter(0, rax);</span>
<span class="udiff-line-added">+   __ load_parameter(1, rbx);</span>
<span class="udiff-line-added">+   if (is_native) {</span>
<span class="udiff-line-added">+     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), rax, rbx);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), rax, rbx);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ restore_live_registers_except_rax(true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ epilogue();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  #undef __
  
  #endif // COMPILER1
  
<span class="udiff-line-modified-removed">- address ShenandoahBarrierSetAssembler::shenandoah_wb() {</span>
<span class="udiff-line-modified-removed">-   assert(_shenandoah_wb != NULL, &quot;need write barrier stub&quot;);</span>
<span class="udiff-line-modified-removed">-   return _shenandoah_wb;</span>
<span class="udiff-line-modified-added">+ address ShenandoahBarrierSetAssembler::shenandoah_lrb() {</span>
<span class="udiff-line-modified-added">+   assert(_shenandoah_lrb != NULL, &quot;need load reference barrier stub&quot;);</span>
<span class="udiff-line-modified-added">+   return _shenandoah_lrb;</span>
  }
  
  #define __ cgen-&gt;assembler()-&gt;
  
<span class="udiff-line-modified-removed">- address ShenandoahBarrierSetAssembler::generate_shenandoah_wb(StubCodeGenerator* cgen) {</span>
<span class="udiff-line-modified-added">+ /*</span>
<span class="udiff-line-added">+  *  Incoming parameters:</span>
<span class="udiff-line-added">+  *  rax: oop</span>
<span class="udiff-line-added">+  *  rsi: load address</span>
<span class="udiff-line-added">+  */</span>
<span class="udiff-line-added">+ address ShenandoahBarrierSetAssembler::generate_shenandoah_lrb(StubCodeGenerator* cgen) {</span>
    __ align(CodeEntryAlignment);
<span class="udiff-line-modified-removed">-   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_wb&quot;);</span>
<span class="udiff-line-modified-added">+   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_lrb&quot;);</span>
    address start = __ pc();
  
<span class="udiff-line-modified-removed">- #ifdef _LP64</span>
<span class="udiff-line-removed">-   Label not_done;</span>
<span class="udiff-line-modified-added">+   Label resolve_oop, slow_path;</span>
  
    // We use RDI, which also serves as argument register for slow call.
<span class="udiff-line-modified-removed">-   // RAX always holds the src object ptr, except after the slow call and</span>
<span class="udiff-line-modified-removed">-   // the cmpxchg, then it holds the result.</span>
<span class="udiff-line-modified-removed">-   // R8 and RCX are used as temporary registers.</span>
<span class="udiff-line-modified-removed">-   __ push(rdi);</span>
<span class="udiff-line-modified-removed">-   __ push(r8);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   // Check for object beeing in the collection set.</span>
<span class="udiff-line-modified-removed">-   // TODO: Can we use only 1 register here?</span>
<span class="udiff-line-modified-removed">-   // The source object arrives here in rax.</span>
<span class="udiff-line-modified-removed">-   // live: rax</span>
<span class="udiff-line-modified-removed">-   // live: rdi</span>
<span class="udiff-line-modified-removed">-   __ mov(rdi, rax);</span>
<span class="udiff-line-modified-removed">-   __ shrptr(rdi, ShenandoahHeapRegion::region_size_bytes_shift_jint());</span>
<span class="udiff-line-modified-removed">-   // live: r8</span>
<span class="udiff-line-modified-removed">-   __ movptr(r8, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());</span>
<span class="udiff-line-modified-removed">-   __ movbool(r8, Address(r8, rdi, Address::times_1));</span>
<span class="udiff-line-modified-removed">-   // unlive: rdi</span>
<span class="udiff-line-modified-removed">-   __ testbool(r8);</span>
<span class="udiff-line-modified-removed">-   // unlive: r8</span>
<span class="udiff-line-removed">-   __ jccb(Assembler::notZero, not_done);</span>
<span class="udiff-line-modified-added">+   // RAX always holds the src object ptr, except after the slow call,</span>
<span class="udiff-line-modified-added">+   // then it holds the result. R8/RBX is used as temporary register.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   Register tmp1 = rdi;</span>
<span class="udiff-line-modified-added">+   Register tmp2 = LP64_ONLY(r8) NOT_LP64(rbx);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   __ push(tmp1);</span>
<span class="udiff-line-modified-added">+   __ push(tmp2);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Check for object being in the collection set.</span>
<span class="udiff-line-modified-added">+   __ mov(tmp1, rax);</span>
<span class="udiff-line-modified-added">+   __ shrptr(tmp1, ShenandoahHeapRegion::region_size_bytes_shift_jint());</span>
<span class="udiff-line-modified-added">+   __ movptr(tmp2, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());</span>
<span class="udiff-line-modified-added">+   __ movbool(tmp2, Address(tmp2, tmp1, Address::times_1));</span>
<span class="udiff-line-modified-added">+   __ testbool(tmp2);</span>
<span class="udiff-line-modified-added">+   __ jccb(Assembler::notZero, resolve_oop);</span>
<span class="udiff-line-modified-added">+   __ pop(tmp2);</span>
<span class="udiff-line-modified-added">+   __ pop(tmp1);</span>
<span class="udiff-line-modified-added">+   __ ret(0);</span>
  
<span class="udiff-line-modified-removed">-   __ pop(r8);</span>
<span class="udiff-line-modified-removed">-   __ pop(rdi);</span>
<span class="udiff-line-modified-added">+   // Test if object is already resolved.</span>
<span class="udiff-line-modified-added">+   __ bind(resolve_oop);</span>
<span class="udiff-line-added">+   __ movptr(tmp2, Address(rax, oopDesc::mark_offset_in_bytes()));</span>
<span class="udiff-line-added">+   // Test if both lowest bits are set. We trick it by negating the bits</span>
<span class="udiff-line-added">+   // then test for both bits clear.</span>
<span class="udiff-line-added">+   __ notptr(tmp2);</span>
<span class="udiff-line-added">+   __ testb(tmp2, markWord::marked_value);</span>
<span class="udiff-line-added">+   __ jccb(Assembler::notZero, slow_path);</span>
<span class="udiff-line-added">+   // Clear both lower bits. It&#39;s still inverted, so set them, and then invert back.</span>
<span class="udiff-line-added">+   __ orptr(tmp2, markWord::marked_value);</span>
<span class="udiff-line-added">+   __ notptr(tmp2);</span>
<span class="udiff-line-added">+   // At this point, tmp2 contains the decoded forwarding pointer.</span>
<span class="udiff-line-added">+   __ mov(rax, tmp2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ pop(tmp2);</span>
<span class="udiff-line-added">+   __ pop(tmp1);</span>
    __ ret(0);
  
<span class="udiff-line-modified-removed">-   __ bind(not_done);</span>
<span class="udiff-line-modified-added">+   __ bind(slow_path);</span>
  
    __ push(rcx);
    __ push(rdx);
    __ push(rdi);
<span class="udiff-line-modified-removed">-   __ push(rsi);</span>
<span class="udiff-line-modified-added">+ #ifdef _LP64</span>
    __ push(r8);
    __ push(r9);
    __ push(r10);
    __ push(r11);
    __ push(r12);
    __ push(r13);
    __ push(r14);
    __ push(r15);
<span class="udiff-line-modified-removed">-   save_vector_registers(cgen-&gt;assembler());</span>
<span class="udiff-line-modified-removed">-   __ movptr(rdi, rax);</span>
<span class="udiff-line-modified-removed">-   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_JRT), rdi);</span>
<span class="udiff-line-modified-removed">-   restore_vector_registers(cgen-&gt;assembler());</span>
<span class="udiff-line-modified-added">+ #endif</span>
<span class="udiff-line-modified-added">+   __ push(rbp);</span>
<span class="udiff-line-modified-added">+   __ movptr(rbp, rsp);</span>
<span class="udiff-line-modified-added">+   __ andptr(rsp, -StackAlignmentInBytes);</span>
<span class="udiff-line-added">+   __ push_FPU_state();</span>
<span class="udiff-line-added">+   if (UseCompressedOops) {</span>
<span class="udiff-line-added">+     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), rax, rsi);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), rax, rsi);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   __ pop_FPU_state();</span>
<span class="udiff-line-added">+   __ movptr(rsp, rbp);</span>
<span class="udiff-line-added">+   __ pop(rbp);</span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
    __ pop(r15);
    __ pop(r14);
    __ pop(r13);
    __ pop(r12);
    __ pop(r11);
    __ pop(r10);
    __ pop(r9);
    __ pop(r8);
<span class="udiff-line-modified-removed">-   __ pop(rsi);</span>
<span class="udiff-line-modified-added">+ #endif</span>
    __ pop(rdi);
    __ pop(rdx);
    __ pop(rcx);
  
<span class="udiff-line-modified-removed">-   __ pop(r8);</span>
<span class="udiff-line-modified-removed">-   __ pop(rdi);</span>
<span class="udiff-line-modified-added">+   __ pop(tmp2);</span>
<span class="udiff-line-modified-added">+   __ pop(tmp1);</span>
    __ ret(0);
<span class="udiff-line-modified-removed">- #else</span>
<span class="udiff-line-removed">-   ShouldNotReachHere();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+ </span>
    return start;
  }
  
  #undef __
  
  void ShenandoahBarrierSetAssembler::barrier_stubs_init() {
<span class="udiff-line-modified-removed">-   if (ShenandoahWriteBarrier || ShenandoahStoreValEnqueueBarrier) {</span>
<span class="udiff-line-modified-added">+   if (ShenandoahLoadRefBarrier) {</span>
      int stub_code_size = 4096;
      ResourceMark rm;
      BufferBlob* bb = BufferBlob::create(&quot;shenandoah_barrier_stubs&quot;, stub_code_size);
      CodeBuffer buf(bb);
      StubCodeGenerator cgen(&amp;buf);
<span class="udiff-line-modified-removed">-     _shenandoah_wb = generate_shenandoah_wb(&amp;cgen);</span>
<span class="udiff-line-modified-added">+     _shenandoah_lrb = generate_shenandoah_lrb(&amp;cgen);</span>
    }
  }
</pre>
<center><a href="../shared/modRefBarrierSetAssembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler_x86.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
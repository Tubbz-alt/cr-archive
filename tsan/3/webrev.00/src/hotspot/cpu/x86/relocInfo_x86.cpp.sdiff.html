<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/relocInfo_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="rdtsc_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/relocInfo_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;code/relocInfo.hpp&quot;

 28 #include &quot;nativeInst_x86.hpp&quot;
 29 #include &quot;oops/compressedOops.inline.hpp&quot;
 30 #include &quot;oops/klass.inline.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 #include &quot;runtime/safepointMechanism.hpp&quot;
 34 
 35 
 36 void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {
 37 #ifdef AMD64
 38   x += o;
 39   typedef Assembler::WhichOperand WhichOperand;
 40   WhichOperand which = (WhichOperand) format(); // that is, disp32 or imm, call32, narrow oop
 41   assert(which == Assembler::disp32_operand ||
 42          which == Assembler::narrow_oop_operand ||
 43          which == Assembler::imm_operand, &quot;format unpacks ok&quot;);
 44   if (which == Assembler::imm_operand) {
 45     if (verify_only) {
 46       guarantee(*pd_address_in_code() == x, &quot;instructions must match&quot;);
 47     } else {
 48       *pd_address_in_code() = x;
 49     }
 50   } else if (which == Assembler::narrow_oop_operand) {
 51     address disp = Assembler::locate_operand(addr(), which);
 52     // both compressed oops and compressed classes look the same
<span class="line-modified"> 53     if (Universe::heap()-&gt;is_in_reserved((oop)x)) {</span>
 54     if (verify_only) {
 55       guarantee(*(uint32_t*) disp == CompressedOops::encode((oop)x), &quot;instructions must match&quot;);
 56     } else {
 57       *(int32_t*) disp = CompressedOops::encode((oop)x);
 58     }
 59   } else {
 60       if (verify_only) {
<span class="line-modified"> 61         guarantee(*(uint32_t*) disp == Klass::encode_klass((Klass*)x), &quot;instructions must match&quot;);</span>
 62       } else {
<span class="line-modified"> 63         *(int32_t*) disp = Klass::encode_klass((Klass*)x);</span>
 64       }
 65     }
 66   } else {
 67     // Note:  Use runtime_call_type relocations for call32_operand.
 68     address ip = addr();
 69     address disp = Assembler::locate_operand(ip, which);
 70     address next_ip = Assembler::locate_next_instruction(ip);
 71     if (verify_only) {
 72       guarantee(*(int32_t*) disp == (x - next_ip), &quot;instructions must match&quot;);
 73     } else {
 74       *(int32_t*) disp = x - next_ip;
 75     }
 76   }
 77 #else
 78   if (verify_only) {
 79     guarantee(*pd_address_in_code() == (x + o), &quot;instructions must match&quot;);
 80   } else {
 81     *pd_address_in_code() = x + o;
 82   }
 83 #endif // AMD64
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;code/relocInfo.hpp&quot;
<span class="line-added"> 28 #include &quot;memory/universe.hpp&quot;</span>
 29 #include &quot;nativeInst_x86.hpp&quot;
 30 #include &quot;oops/compressedOops.inline.hpp&quot;
 31 #include &quot;oops/klass.inline.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;runtime/safepoint.hpp&quot;
 34 #include &quot;runtime/safepointMechanism.hpp&quot;
 35 
 36 
 37 void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {
 38 #ifdef AMD64
 39   x += o;
 40   typedef Assembler::WhichOperand WhichOperand;
 41   WhichOperand which = (WhichOperand) format(); // that is, disp32 or imm, call32, narrow oop
 42   assert(which == Assembler::disp32_operand ||
 43          which == Assembler::narrow_oop_operand ||
 44          which == Assembler::imm_operand, &quot;format unpacks ok&quot;);
 45   if (which == Assembler::imm_operand) {
 46     if (verify_only) {
 47       guarantee(*pd_address_in_code() == x, &quot;instructions must match&quot;);
 48     } else {
 49       *pd_address_in_code() = x;
 50     }
 51   } else if (which == Assembler::narrow_oop_operand) {
 52     address disp = Assembler::locate_operand(addr(), which);
 53     // both compressed oops and compressed classes look the same
<span class="line-modified"> 54     if (CompressedOops::is_in((void*)x)) {</span>
 55     if (verify_only) {
 56       guarantee(*(uint32_t*) disp == CompressedOops::encode((oop)x), &quot;instructions must match&quot;);
 57     } else {
 58       *(int32_t*) disp = CompressedOops::encode((oop)x);
 59     }
 60   } else {
 61       if (verify_only) {
<span class="line-modified"> 62         guarantee(*(uint32_t*) disp == CompressedKlassPointers::encode((Klass*)x), &quot;instructions must match&quot;);</span>
 63       } else {
<span class="line-modified"> 64         *(int32_t*) disp = CompressedKlassPointers::encode((Klass*)x);</span>
 65       }
 66     }
 67   } else {
 68     // Note:  Use runtime_call_type relocations for call32_operand.
 69     address ip = addr();
 70     address disp = Assembler::locate_operand(ip, which);
 71     address next_ip = Assembler::locate_next_instruction(ip);
 72     if (verify_only) {
 73       guarantee(*(int32_t*) disp == (x - next_ip), &quot;instructions must match&quot;);
 74     } else {
 75       *(int32_t*) disp = x - next_ip;
 76     }
 77   }
 78 #else
 79   if (verify_only) {
 80     guarantee(*pd_address_in_code() == (x + o), &quot;instructions must match&quot;);
 81   } else {
 82     *pd_address_in_code() = x + o;
 83   }
 84 #endif // AMD64
</pre>
</td>
</tr>
</table>
<center><a href="rdtsc_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86_aes.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -112,11 +112,12 @@</span>
  
      if (op == 0xEB || (op &amp; 0xF0) == 0x70) {
        // short offset operators (jmp and jcc)
        char* disp = (char*) &amp;branch[1];
        int imm8 = target - (address) &amp;disp[1];
<span class="udiff-line-modified-removed">-       guarantee(this-&gt;is8bit(imm8), &quot;Short forward jump exceeds 8-bit offset at %s:%d&quot;, file, line);</span>
<span class="udiff-line-modified-added">+       guarantee(this-&gt;is8bit(imm8), &quot;Short forward jump exceeds 8-bit offset at %s:%d&quot;,</span>
<span class="udiff-line-added">+                 file == NULL ? &quot;&lt;NULL&gt;&quot; : file, line);</span>
        *disp = imm8;
      } else {
        int* disp = (int*) &amp;branch[(op == 0x0F || op == 0xC7)? 2: 1];
        int imm32 = target - (address) &amp;disp[1];
        *disp = imm32;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -311,11 +312,15 @@</span>
    void movbool(Address dst, bool boolconst);
    void movbool(Address dst, Register src);
    void testbool(Register dst);
  
    void resolve_oop_handle(Register result, Register tmp = rscratch2);
<span class="udiff-line-added">+   void resolve_weak_handle(Register result, Register tmp);</span>
    void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
<span class="udiff-line-added">+   void load_method_holder_cld(Register rresult, Register rmethod);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void load_method_holder(Register holder, Register method);</span>
  
    // oop manipulations
    void load_klass(Register dst, Register src);
    void store_klass(Register dst, Register src);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -419,10 +424,11 @@</span>
    void sign_extend_byte(Register reg);
  
    // Division by power of 2, rounding towards 0
    void division_with_shift(Register reg, int shift_value);
  
<span class="udiff-line-added">+ #ifndef _LP64</span>
    // Compares the top-most stack entries on the FPU stack and sets the eflags as follows:
    //
    // CF (corresponds to C0) if x &lt; y
    // PF (corresponds to C2) if unordered
    // ZF (corresponds to C3) if x = y
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -447,10 +453,14 @@</span>
  
    // Floating-point remainder for Java (ST0 = ST0 fremr ST1, ST1 is empty afterwards)
    // tmp is a temporary register, if none is available use noreg
    void fremr(Register tmp);
  
<span class="udiff-line-added">+   // only if +VerifyFPU</span>
<span class="udiff-line-added">+   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);</span>
<span class="udiff-line-added">+ #endif // !LP64</span>
<span class="udiff-line-added">+ </span>
    // dst = c = a * b + c
    void fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
    void fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
  
    void vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -466,13 +476,10 @@</span>
    // branch to L if FPU flag C2 is set/not set
    // tmp is a temporary register, if none is available use noreg
    void jC2 (Register tmp, Label&amp; L);
    void jnC2(Register tmp, Label&amp; L);
  
<span class="udiff-line-removed">-   // Pop ST (ffree &amp; fincstp combined)</span>
<span class="udiff-line-removed">-   void fpop();</span>
<span class="udiff-line-removed">- </span>
    // Load float value from &#39;address&#39;. If UseSSE &gt;= 1, the value is loaded into
    // register xmm0. Otherwise, the value is loaded onto the FPU stack.
    void load_float(Address src);
  
    // Store float value to &#39;address&#39;. If UseSSE &gt;= 1, the value is stored
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -485,17 +492,16 @@</span>
  
    // Store double value to &#39;address&#39;. If UseSSE &gt;= 2, the value is stored
    // from register xmm0. Otherwise, the value is stored from the FPU stack.
    void store_double(Address dst);
  
<span class="udiff-line-modified-removed">-   // pushes double TOS element of FPU stack on CPU stack; pops from FPU stack</span>
<span class="udiff-line-modified-removed">-   void push_fTOS();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   // pops double TOS element from CPU stack and pushes on FPU stack</span>
<span class="udiff-line-removed">-   void pop_fTOS();</span>
<span class="udiff-line-modified-added">+ #ifndef _LP64</span>
<span class="udiff-line-modified-added">+   // Pop ST (ffree &amp; fincstp combined)</span>
<span class="udiff-line-modified-added">+   void fpop();</span>
  
    void empty_FPU_stack();
<span class="udiff-line-added">+ #endif // !_LP64</span>
  
    void push_IU_state();
    void pop_IU_state();
  
    void push_FPU_state();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -577,10 +583,15 @@</span>
    void check_klass_subtype(Register sub_klass,
                             Register super_klass,
                             Register temp_reg,
                             Label&amp; L_success);
  
<span class="udiff-line-added">+   void clinit_barrier(Register klass,</span>
<span class="udiff-line-added">+                       Register thread,</span>
<span class="udiff-line-added">+                       Label* L_fast_path = NULL,</span>
<span class="udiff-line-added">+                       Label* L_slow_path = NULL);</span>
<span class="udiff-line-added">+ </span>
    // method handles (JSR 292)
    Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
  
    //----
    void set_word_if_not_zero(Register reg); // sets reg to 1 if not zero, otherwise 0
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -597,13 +608,10 @@</span>
    void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
  
  #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
  #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
  
<span class="udiff-line-removed">-   // only if +VerifyFPU</span>
<span class="udiff-line-removed">-   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);</span>
<span class="udiff-line-removed">- </span>
    // Verify or restore cpu control state after JNI call
    void restore_cpu_control_state_after_jni();
  
    // prints msg, dumps registers and stops execution
    void stop(const char* msg);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -875,25 +883,26 @@</span>
    void jump(ArrayAddress entry);
  
    // Floating
  
    void andpd(XMMRegister dst, Address src) { Assembler::andpd(dst, src); }
<span class="udiff-line-modified-removed">-   void andpd(XMMRegister dst, AddressLiteral src);</span>
<span class="udiff-line-modified-added">+   void andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);</span>
    void andpd(XMMRegister dst, XMMRegister src) { Assembler::andpd(dst, src); }
  
    void andps(XMMRegister dst, XMMRegister src) { Assembler::andps(dst, src); }
    void andps(XMMRegister dst, Address src) { Assembler::andps(dst, src); }
<span class="udiff-line-modified-removed">-   void andps(XMMRegister dst, AddressLiteral src);</span>
<span class="udiff-line-modified-added">+   void andps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);</span>
  
    void comiss(XMMRegister dst, XMMRegister src) { Assembler::comiss(dst, src); }
    void comiss(XMMRegister dst, Address src) { Assembler::comiss(dst, src); }
    void comiss(XMMRegister dst, AddressLiteral src);
  
    void comisd(XMMRegister dst, XMMRegister src) { Assembler::comisd(dst, src); }
    void comisd(XMMRegister dst, Address src) { Assembler::comisd(dst, src); }
    void comisd(XMMRegister dst, AddressLiteral src);
  
<span class="udiff-line-added">+ #ifndef _LP64</span>
    void fadd_s(Address src)        { Assembler::fadd_s(src); }
    void fadd_s(AddressLiteral src) { Assembler::fadd_s(as_Address(src)); }
  
    void fldcw(Address src) { Assembler::fldcw(src); }
    void fldcw(AddressLiteral src);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -908,10 +917,11 @@</span>
    void fld_x(Address src) { Assembler::fld_x(src); }
    void fld_x(AddressLiteral src);
  
    void fmul_s(Address src)        { Assembler::fmul_s(src); }
    void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }
<span class="udiff-line-added">+ #endif // _LP64</span>
  
    void ldmxcsr(Address src) { Assembler::ldmxcsr(src); }
    void ldmxcsr(AddressLiteral src);
  
  #ifdef _LP64
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -971,10 +981,23 @@</span>
   public:
    void sha512_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
                     XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
                     Register buf, Register state, Register ofs, Register limit, Register rsp, bool multi_block,
                     XMMRegister shuf_mask);
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+   void roundEnc(XMMRegister key, int rnum);</span>
<span class="udiff-line-added">+   void lastroundEnc(XMMRegister key, int rnum);</span>
<span class="udiff-line-added">+   void roundDec(XMMRegister key, int rnum);</span>
<span class="udiff-line-added">+   void lastroundDec(XMMRegister key, int rnum);</span>
<span class="udiff-line-added">+   void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   void aesecb_encrypt(Register source_addr, Register dest_addr, Register key, Register len);</span>
<span class="udiff-line-added">+   void aesecb_decrypt(Register source_addr, Register dest_addr, Register key, Register len);</span>
<span class="udiff-line-added">+   void aesctr_encrypt(Register src_addr, Register dest_addr, Register key, Register counter,</span>
<span class="udiff-line-added">+                       Register len_reg, Register used, Register used_addr, Register saved_encCounter_start);</span>
<span class="udiff-line-added">+ </span>
  #endif
  
    void fast_sha1(XMMRegister abcd, XMMRegister e0, XMMRegister e1, XMMRegister msg0,
                   XMMRegister msg1, XMMRegister msg2, XMMRegister msg3, XMMRegister shuf_mask,
                   Register buf, Register state, Register ofs, Register limit, Register rsp,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1057,19 +1080,16 @@</span>
    void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
                  XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
                  Register rax, Register rcx, Register rdx, Register tmp);
  #endif
  
<span class="udiff-line-removed">-   void increase_precision();</span>
<span class="udiff-line-removed">-   void restore_precision();</span>
<span class="udiff-line-removed">- </span>
  private:
  
    // these are private because users should be doing movflt/movdbl
  
<span class="udiff-line-removed">-   void movss(Address dst, XMMRegister src)     { Assembler::movss(dst, src); }</span>
    void movss(XMMRegister dst, XMMRegister src) { Assembler::movss(dst, src); }
<span class="udiff-line-added">+   void movss(Address dst, XMMRegister src)     { Assembler::movss(dst, src); }</span>
    void movss(XMMRegister dst, Address src)     { Assembler::movss(dst, src); }
    void movss(XMMRegister dst, AddressLiteral src);
  
    void movlpd(XMMRegister dst, Address src)    {Assembler::movlpd(dst, src); }
    void movlpd(XMMRegister dst, AddressLiteral src);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1103,11 +1123,11 @@</span>
    void movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg = rscratch1);
    // AVX Unaligned forms
    void vmovdqu(Address     dst, XMMRegister src);
    void vmovdqu(XMMRegister dst, Address src);
    void vmovdqu(XMMRegister dst, XMMRegister src);
<span class="udiff-line-modified-removed">-   void vmovdqu(XMMRegister dst, AddressLiteral src);</span>
<span class="udiff-line-modified-added">+   void vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);</span>
    void evmovdquq(XMMRegister dst, Address src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
    void evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
    void evmovdquq(Address dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
    void evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1158,10 +1178,14 @@</span>
  
    void sqrtsd(XMMRegister dst, XMMRegister src)    { Assembler::sqrtsd(dst, src); }
    void sqrtsd(XMMRegister dst, Address src)        { Assembler::sqrtsd(dst, src); }
    void sqrtsd(XMMRegister dst, AddressLiteral src);
  
<span class="udiff-line-added">+   void roundsd(XMMRegister dst, XMMRegister src, int32_t rmode)    { Assembler::roundsd(dst, src, rmode); }</span>
<span class="udiff-line-added">+   void roundsd(XMMRegister dst, Address src, int32_t rmode)        { Assembler::roundsd(dst, src, rmode); }</span>
<span class="udiff-line-added">+   void roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg);</span>
<span class="udiff-line-added">+ </span>
    void sqrtss(XMMRegister dst, XMMRegister src)    { Assembler::sqrtss(dst, src); }
    void sqrtss(XMMRegister dst, Address src)        { Assembler::sqrtss(dst, src); }
    void sqrtss(XMMRegister dst, AddressLiteral src);
  
    void subsd(XMMRegister dst, XMMRegister src)    { Assembler::subsd(dst, src); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1181,16 +1205,16 @@</span>
    void ucomisd(XMMRegister dst, AddressLiteral src);
  
    // Bitwise Logical XOR of Packed Double-Precision Floating-Point Values
    void xorpd(XMMRegister dst, XMMRegister src);
    void xorpd(XMMRegister dst, Address src)     { Assembler::xorpd(dst, src); }
<span class="udiff-line-modified-removed">-   void xorpd(XMMRegister dst, AddressLiteral src);</span>
<span class="udiff-line-modified-added">+   void xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);</span>
  
    // Bitwise Logical XOR of Packed Single-Precision Floating-Point Values
    void xorps(XMMRegister dst, XMMRegister src);
    void xorps(XMMRegister dst, Address src)     { Assembler::xorps(dst, src); }
<span class="udiff-line-modified-removed">-   void xorps(XMMRegister dst, AddressLiteral src);</span>
<span class="udiff-line-modified-added">+   void xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);</span>
  
    // Shuffle Bytes
    void pshufb(XMMRegister dst, XMMRegister src) { Assembler::pshufb(dst, src); }
    void pshufb(XMMRegister dst, Address src)     { Assembler::pshufb(dst, src); }
    void pshufb(XMMRegister dst, AddressLiteral src);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1211,13 +1235,17 @@</span>
    void vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
  
    void vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
    void vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
  
<span class="udiff-line-added">+   void vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }</span>
<span class="udiff-line-added">+   void vpaddd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }</span>
<span class="udiff-line-added">+   void vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch);</span>
<span class="udiff-line-added">+ </span>
    void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
    void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
<span class="udiff-line-modified-removed">-   void vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);</span>
<span class="udiff-line-modified-added">+   void vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);</span>
  
    void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
    void vpbroadcastw(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastw(dst, src, vector_len); }
  
    void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1239,10 +1267,13 @@</span>
    void vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
  
    void vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
    void vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
  
<span class="udiff-line-added">+   void evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);</span>
<span class="udiff-line-added">+   void evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len);</span>
<span class="udiff-line-added">+ </span>
    void vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
    void vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
  
    void vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
    void vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1258,15 +1289,15 @@</span>
    void pshuflw(XMMRegister dst, XMMRegister src, int mode);
    void pshuflw(XMMRegister dst, Address src, int mode) { Assembler::pshuflw(dst, src, mode); }
  
    void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandpd(dst, nds, src, vector_len); }
    void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandpd(dst, nds, src, vector_len); }
<span class="udiff-line-modified-removed">-   void vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);</span>
<span class="udiff-line-modified-added">+   void vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);</span>
  
    void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandps(dst, nds, src, vector_len); }
    void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandps(dst, nds, src, vector_len); }
<span class="udiff-line-modified-removed">-   void vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);</span>
<span class="udiff-line-modified-added">+   void vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);</span>
  
    void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivsd(dst, nds, src); }
    void vdivsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivsd(dst, nds, src); }
    void vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1295,15 +1326,15 @@</span>
  
    // AVX Vector instructions
  
    void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
    void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
<span class="udiff-line-modified-removed">-   void vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);</span>
<span class="udiff-line-modified-added">+   void vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);</span>
  
    void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
    void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
<span class="udiff-line-modified-removed">-   void vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);</span>
<span class="udiff-line-modified-added">+   void vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);</span>
  
    void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
      if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
        Assembler::vpxor(dst, nds, src, vector_len);
      else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1313,50 +1344,51 @@</span>
      if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
        Assembler::vpxor(dst, nds, src, vector_len);
      else
        Assembler::vxorpd(dst, nds, src, vector_len);
    }
<span class="udiff-line-added">+   void vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);</span>
  
    // Simple version for AVX2 256bit vectors
    void vpxor(XMMRegister dst, XMMRegister src) { Assembler::vpxor(dst, dst, src, true); }
    void vpxor(XMMRegister dst, Address src) { Assembler::vpxor(dst, dst, src, true); }
  
    void vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
        Assembler::vinserti32x4(dst, dst, src, imm8);
      } else if (UseAVX &gt; 1) {
        // vinserti128 is available only in AVX2
        Assembler::vinserti128(dst, nds, src, imm8);
      } else {
        Assembler::vinsertf128(dst, nds, src, imm8);
      }
    }
  
    void vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
        Assembler::vinserti32x4(dst, dst, src, imm8);
      } else if (UseAVX &gt; 1) {
        // vinserti128 is available only in AVX2
        Assembler::vinserti128(dst, nds, src, imm8);
      } else {
        Assembler::vinsertf128(dst, nds, src, imm8);
      }
    }
  
    void vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
        Assembler::vextracti32x4(dst, src, imm8);
      } else if (UseAVX &gt; 1) {
        // vextracti128 is available only in AVX2
        Assembler::vextracti128(dst, src, imm8);
      } else {
        Assembler::vextractf128(dst, src, imm8);
      }
    }
  
    void vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
        Assembler::vextracti32x4(dst, src, imm8);
      } else if (UseAVX &gt; 1) {
        // vextracti128 is available only in AVX2
        Assembler::vextracti128(dst, src, imm8);
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1377,35 +1409,35 @@</span>
    void vextracti128_high(Address dst, XMMRegister src) {
      vextracti128(dst, src, 1);
    }
  
    void vinsertf128_high(XMMRegister dst, XMMRegister src) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
        Assembler::vinsertf32x4(dst, dst, src, 1);
      } else {
        Assembler::vinsertf128(dst, dst, src, 1);
      }
    }
  
    void vinsertf128_high(XMMRegister dst, Address src) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
        Assembler::vinsertf32x4(dst, dst, src, 1);
      } else {
        Assembler::vinsertf128(dst, dst, src, 1);
      }
    }
  
    void vextractf128_high(XMMRegister dst, XMMRegister src) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
        Assembler::vextractf32x4(dst, src, 1);
      } else {
        Assembler::vextractf128(dst, src, 1);
      }
    }
  
    void vextractf128_high(Address dst, XMMRegister src) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
        Assembler::vextractf32x4(dst, src, 1);
      } else {
        Assembler::vextractf128(dst, src, 1);
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1443,35 +1475,35 @@</span>
    void vextracti128_low(Address dst, XMMRegister src) {
      vextracti128(dst, src, 0);
    }
  
    void vinsertf128_low(XMMRegister dst, XMMRegister src) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
        Assembler::vinsertf32x4(dst, dst, src, 0);
      } else {
        Assembler::vinsertf128(dst, dst, src, 0);
      }
    }
  
    void vinsertf128_low(XMMRegister dst, Address src) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
        Assembler::vinsertf32x4(dst, dst, src, 0);
      } else {
        Assembler::vinsertf128(dst, dst, src, 0);
      }
    }
  
    void vextractf128_low(XMMRegister dst, XMMRegister src) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
        Assembler::vextractf32x4(dst, src, 0);
      } else {
        Assembler::vextractf128(dst, src, 0);
      }
    }
  
    void vextractf128_low(Address dst, XMMRegister src) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {</span>
        Assembler::vextractf32x4(dst, src, 0);
      } else {
        Assembler::vextractf128(dst, src, 0);
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1599,10 +1631,26 @@</span>
  
    // sign extend as need a l to ptr sized element
    void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
    void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
  
<span class="udiff-line-added">+ #ifdef COMPILER2</span>
<span class="udiff-line-added">+   // Generic instructions support for use in .ad files C2 code generation</span>
<span class="udiff-line-added">+   void vabsnegd(int opcode, XMMRegister dst, XMMRegister src, Register scr);</span>
<span class="udiff-line-added">+   void vabsnegd(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr);</span>
<span class="udiff-line-added">+   void vabsnegf(int opcode, XMMRegister dst, XMMRegister src, Register scr);</span>
<span class="udiff-line-added">+   void vabsnegf(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr);</span>
<span class="udiff-line-added">+   void vextendbw(bool sign, XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="udiff-line-added">+   void vextendbw(bool sign, XMMRegister dst, XMMRegister src);</span>
<span class="udiff-line-added">+   void vshiftd(int opcode, XMMRegister dst, XMMRegister src);</span>
<span class="udiff-line-added">+   void vshiftd(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);</span>
<span class="udiff-line-added">+   void vshiftw(int opcode, XMMRegister dst, XMMRegister src);</span>
<span class="udiff-line-added">+   void vshiftw(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);</span>
<span class="udiff-line-added">+   void vshiftq(int opcode, XMMRegister dst, XMMRegister src);</span>
<span class="udiff-line-added">+   void vshiftq(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
    // C2 compiled method&#39;s prolog code.
    void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub);
  
    // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39;;
    // if &#39;is_large&#39; is set, do not try to produce short loop
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1759,10 +1807,19 @@</span>
  
    // Inflate byte[] array to char[].
    void byte_array_inflate(Register src, Register dst, Register len,
                            XMMRegister tmp1, Register tmp2);
  
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+   void convert_f2i(Register dst, XMMRegister src);</span>
<span class="udiff-line-added">+   void convert_d2i(Register dst, XMMRegister src);</span>
<span class="udiff-line-added">+   void convert_f2l(Register dst, XMMRegister src);</span>
<span class="udiff-line-added">+   void convert_d2l(Register dst, XMMRegister src);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void cache_wb(Address line);</span>
<span class="udiff-line-added">+   void cache_wbsync(bool is_pre);</span>
<span class="udiff-line-added">+ #endif // _LP64</span>
  };
  
  /**
   * class SkipIfEqual:
   *
</pre>
<center><a href="macroAssembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86_aes.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/globals_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef CPU_X86_GLOBALS_X86_HPP
 26 #define CPU_X86_GLOBALS_X86_HPP
 27 
 28 #include &quot;utilities/globalDefinitions.hpp&quot;
 29 #include &quot;utilities/macros.hpp&quot;
 30 
 31 // Sets the default values for platform dependent flags used by the runtime system.
 32 // (see globals.hpp)
 33 
<a name="2" id="anc2"></a><span class="line-removed"> 34 define_pd_global(bool, ShareVtableStubs,         true);</span>
<span class="line-removed"> 35 define_pd_global(bool, NeedsDeoptSuspend,        false); // only register window machines need this</span>
<span class="line-removed"> 36 </span>
 37 define_pd_global(bool, ImplicitNullChecks,       true);  // Generate code for implicit null checks
 38 define_pd_global(bool, TrapBasedNullChecks,      false); // Not needed on x86.
 39 define_pd_global(bool, UncommonNullCast,         true);  // Uncommon-trap NULLs passed to check cast
 40 
 41 define_pd_global(uintx, CodeCacheSegmentSize,    64 TIERED_ONLY(+64)); // Tiered compilation has large code-entry alignment.
 42 // See 4827828 for this change. There is no globals_core_i486.hpp. I can&#39;t
 43 // assign a different value for C2 without touching a number of files. Use
 44 // #ifdef to minimize the change as it&#39;s late in Mantis. -- FIXME.
 45 // c1 doesn&#39;t have this problem because the fix to 4858033 assures us
 46 // the the vep is aligned at CodeEntryAlignment whereas c2 only aligns
 47 // the uep and the vep doesn&#39;t get real alignment but just slops on by
 48 // only assured that the entry instruction meets the 5 byte size requirement.
 49 #if COMPILER2_OR_JVMCI
 50 define_pd_global(intx, CodeEntryAlignment,       32);
 51 #else
 52 define_pd_global(intx, CodeEntryAlignment,       16);
 53 #endif // COMPILER2_OR_JVMCI
 54 define_pd_global(intx, OptoLoopAlignment,        16);
 55 define_pd_global(intx, InlineFrequencyCount,     100);
 56 define_pd_global(intx, InlineSmallCode,          1000);
 57 
 58 #define DEFAULT_STACK_YELLOW_PAGES (NOT_WINDOWS(2) WINDOWS_ONLY(3))
 59 #define DEFAULT_STACK_RED_PAGES (1)
 60 #define DEFAULT_STACK_RESERVED_PAGES (NOT_WINDOWS(1) WINDOWS_ONLY(0))
 61 
 62 #define MIN_STACK_YELLOW_PAGES DEFAULT_STACK_YELLOW_PAGES
 63 #define MIN_STACK_RED_PAGES DEFAULT_STACK_RED_PAGES
 64 #define MIN_STACK_RESERVED_PAGES (0)
 65 
 66 #ifdef _LP64
 67 // Java_java_net_SocketOutputStream_socketWrite0() uses a 64k buffer on the
 68 // stack if compiled for unix and LP64. To pass stack overflow tests we need
 69 // 20 shadow pages.
 70 #define DEFAULT_STACK_SHADOW_PAGES (NOT_WIN64(20) WIN64_ONLY(7) DEBUG_ONLY(+2))
 71 // For those clients that do not use write socket, we allow
 72 // the min range value to be below that of the default
 73 #define MIN_STACK_SHADOW_PAGES (NOT_WIN64(10) WIN64_ONLY(7) DEBUG_ONLY(+2))
 74 #else
 75 #define DEFAULT_STACK_SHADOW_PAGES (4 DEBUG_ONLY(+5))
 76 #define MIN_STACK_SHADOW_PAGES DEFAULT_STACK_SHADOW_PAGES
 77 #endif // _LP64
 78 
 79 define_pd_global(intx, StackYellowPages, DEFAULT_STACK_YELLOW_PAGES);
 80 define_pd_global(intx, StackRedPages, DEFAULT_STACK_RED_PAGES);
 81 define_pd_global(intx, StackShadowPages, DEFAULT_STACK_SHADOW_PAGES);
 82 define_pd_global(intx, StackReservedPages, DEFAULT_STACK_RESERVED_PAGES);
 83 
 84 define_pd_global(bool, RewriteBytecodes,     true);
 85 define_pd_global(bool, RewriteFrequentPairs, true);
 86 
<a name="3" id="anc3"></a><span class="line-removed"> 87 // GC Ergo Flags</span>
<span class="line-removed"> 88 define_pd_global(size_t, CMSYoungGenPerWorker, 64*M);  // default max size of CMS young gen, per GC worker thread</span>
<span class="line-removed"> 89 </span>
 90 define_pd_global(uintx, TypeProfileLevel, 111);
 91 
 92 define_pd_global(bool, CompactStrings, true);
 93 
 94 define_pd_global(bool, PreserveFramePointer, false);
 95 
 96 define_pd_global(intx, InitArrayShortSize, 8*BytesPerLong);
 97 
<a name="4" id="anc4"></a><span class="line-removed"> 98 #if defined(_LP64) || defined(_WINDOWS)</span>
<span class="line-removed"> 99 define_pd_global(bool, ThreadLocalHandshakes, true);</span>
<span class="line-removed">100 #else</span>
<span class="line-removed">101 // get_thread() is slow on linux 32 bit, therefore off by default</span>
<span class="line-removed">102 define_pd_global(bool, ThreadLocalHandshakes, false);</span>
<span class="line-removed">103 #endif</span>
<span class="line-removed">104 </span>
105 #define ARCH_FLAGS(develop, \
106                    product, \
107                    diagnostic, \
108                    experimental, \
109                    notproduct, \
110                    range, \
<a name="5" id="anc5"></a><span class="line-modified">111                    constraint, \</span>
<span class="line-removed">112                    writeable) \</span>
113                                                                             \
114   develop(bool, IEEEPrecision, true,                                        \
115           &quot;Enables IEEE precision (for INTEL only)&quot;)                        \
116                                                                             \
117   product(bool, UseStoreImmI16, true,                                       \
118           &quot;Use store immediate 16-bits value instruction on x86&quot;)           \
119                                                                             \
120   product(intx, UseAVX, 3,                                                  \
121           &quot;Highest supported AVX instructions set on x86/x64&quot;)              \
122           range(0, 99)                                                      \
123                                                                             \
124   product(bool, UseCLMUL, false,                                            \
125           &quot;Control whether CLMUL instructions can be used on x86/x64&quot;)      \
126                                                                             \
127   diagnostic(bool, UseIncDec, true,                                         \
128           &quot;Use INC, DEC instructions on x86&quot;)                               \
129                                                                             \
130   product(bool, UseNewLongLShift, false,                                    \
131           &quot;Use optimized bitwise shift left&quot;)                               \
132                                                                             \
133   product(bool, UseAddressNop, false,                                       \
134           &quot;Use &#39;0F 1F [addr]&#39; NOP instructions on x86 cpus&quot;)                \
135                                                                             \
136   product(bool, UseXmmLoadAndClearUpper, true,                              \
137           &quot;Load low part of XMM register and clear upper part&quot;)             \
138                                                                             \
139   product(bool, UseXmmRegToRegMoveAll, false,                               \
140           &quot;Copy all XMM register bits when moving value between registers&quot;) \
141                                                                             \
142   product(bool, UseXmmI2D, false,                                           \
143           &quot;Use SSE2 CVTDQ2PD instruction to convert Integer to Double&quot;)     \
144                                                                             \
145   product(bool, UseXmmI2F, false,                                           \
146           &quot;Use SSE2 CVTDQ2PS instruction to convert Integer to Float&quot;)      \
147                                                                             \
148   product(bool, UseUnalignedLoadStores, false,                              \
149           &quot;Use SSE2 MOVDQU instruction for Arraycopy&quot;)                      \
150                                                                             \
151   product(bool, UseXMMForObjInit, false,                                    \
152           &quot;Use XMM/YMM MOVDQU instruction for Object Initialization&quot;)       \
153                                                                             \
154   product(bool, UseFastStosb, false,                                        \
155           &quot;Use fast-string operation for zeroing: rep stosb&quot;)               \
156                                                                             \
157   /* Use Restricted Transactional Memory for lock eliding */                \
158   product(bool, UseRTMLocking, false,                                       \
159           &quot;Enable RTM lock eliding for inflated locks in compiled code&quot;)    \
160                                                                             \
161   experimental(bool, UseRTMForStackLocks, false,                            \
162           &quot;Enable RTM lock eliding for stack locks in compiled code&quot;)       \
163                                                                             \
164   product(bool, UseRTMDeopt, false,                                         \
165           &quot;Perform deopt and recompilation based on RTM abort ratio&quot;)       \
166                                                                             \
167   product(int, RTMRetryCount, 5,                                            \
168           &quot;Number of RTM retries on lock abort or busy&quot;)                    \
169           range(0, max_jint)                                                \
170                                                                             \
171   experimental(int, RTMSpinLoopCount, 100,                                  \
172           &quot;Spin count for lock to become free before RTM retry&quot;)            \
173           range(0, max_jint)                                                \
174                                                                             \
175   experimental(int, RTMAbortThreshold, 1000,                                \
176           &quot;Calculate abort ratio after this number of aborts&quot;)              \
177           range(0, max_jint)                                                \
178                                                                             \
179   experimental(int, RTMLockingThreshold, 10000,                             \
180           &quot;Lock count at which to do RTM lock eliding without &quot;             \
181           &quot;abort ratio calculation&quot;)                                        \
182           range(0, max_jint)                                                \
183                                                                             \
184   experimental(int, RTMAbortRatio, 50,                                      \
185           &quot;Lock abort ratio at which to stop use RTM lock eliding&quot;)         \
186           range(0, 100) /* natural range */                                 \
187                                                                             \
188   experimental(int, RTMTotalCountIncrRate, 64,                              \
189           &quot;Increment total RTM attempted lock count once every n times&quot;)    \
190           range(1, max_jint)                                                \
191           constraint(RTMTotalCountIncrRateConstraintFunc,AfterErgo)         \
192                                                                             \
193   experimental(intx, RTMLockingCalculationDelay, 0,                         \
194           &quot;Number of milliseconds to wait before start calculating aborts &quot; \
195           &quot;for RTM locking&quot;)                                                \
196                                                                             \
197   experimental(bool, UseRTMXendForLockBusy, true,                           \
198           &quot;Use RTM Xend instead of Xabort when lock busy&quot;)                  \
199                                                                             \
200   /* assembler */                                                           \
201   product(bool, UseCountLeadingZerosInstruction, false,                     \
202           &quot;Use count leading zeros instruction&quot;)                            \
203                                                                             \
204   product(bool, UseCountTrailingZerosInstruction, false,                    \
205           &quot;Use count trailing zeros instruction&quot;)                           \
206                                                                             \
207   product(bool, UseSSE42Intrinsics, false,                                  \
208           &quot;SSE4.2 versions of intrinsics&quot;)                                  \
209                                                                             \
210   product(bool, UseBMI1Instructions, false,                                 \
211           &quot;Use BMI1 instructions&quot;)                                          \
212                                                                             \
213   product(bool, UseBMI2Instructions, false,                                 \
214           &quot;Use BMI2 instructions&quot;)                                          \
215                                                                             \
216   diagnostic(bool, UseLibmIntrinsic, true,                                  \
<a name="6" id="anc6"></a><span class="line-modified">217           &quot;Use Libm Intrinsics&quot;)</span>










218 #endif // CPU_X86_GLOBALS_X86_HPP
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/x86.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vm_version_x86.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_32.ad.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1092,145 ***</span>
                        XMM14, XMM14b, XMM14c, XMM14d, XMM14e, XMM14f, XMM14g, XMM14h, XMM14i, XMM14j, XMM14k, XMM14l, XMM14m, XMM14n, XMM14o, XMM14p,
                        XMM15, XMM15b, XMM15c, XMM15d, XMM15e, XMM15f, XMM15g, XMM15h, XMM15i, XMM15j, XMM15k, XMM15l, XMM15m, XMM15n, XMM15o, XMM15p
  #endif
                        );
  
<span class="line-modified">! reg_class_dynamic vectorz_reg(vectorz_reg_evex, vectorz_reg_legacy, %{ VM_Version::supports_evex() %} );</span>
  reg_class_dynamic vectorz_reg_vl(vectorz_reg_evex, vectorz_reg_legacy, %{ VM_Version::supports_evex() &amp;&amp; VM_Version::supports_avx512vl() %} );
  
<span class="line-removed">- reg_class xmm0_reg(XMM0, XMM0b, XMM0c, XMM0d);</span>
<span class="line-removed">- reg_class ymm0_reg(XMM0, XMM0b, XMM0c, XMM0d, XMM0e, XMM0f, XMM0g, XMM0h);</span>
<span class="line-removed">- reg_class zmm0_reg(XMM0, XMM0b, XMM0c, XMM0d, XMM0e, XMM0f, XMM0g, XMM0h, XMM0i, XMM0j, XMM0k, XMM0l, XMM0m, XMM0n, XMM0o, XMM0p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm1_reg(XMM1, XMM1b, XMM1c, XMM1d);</span>
<span class="line-removed">- reg_class ymm1_reg(XMM1, XMM1b, XMM1c, XMM1d, XMM1e, XMM1f, XMM1g, XMM1h);</span>
<span class="line-removed">- reg_class zmm1_reg(XMM1, XMM1b, XMM1c, XMM1d, XMM1e, XMM1f, XMM1g, XMM1h, XMM1i, XMM1j, XMM1k, XMM1l, XMM1m, XMM1n, XMM1o, XMM1p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm2_reg(XMM2, XMM2b, XMM2c, XMM2d);</span>
<span class="line-removed">- reg_class ymm2_reg(XMM2, XMM2b, XMM2c, XMM2d, XMM2e, XMM2f, XMM2g, XMM2h);</span>
<span class="line-removed">- reg_class zmm2_reg(XMM2, XMM2b, XMM2c, XMM2d, XMM2e, XMM2f, XMM2g, XMM2h, XMM2i, XMM2j, XMM2k, XMM2l, XMM2m, XMM2n, XMM2o, XMM2p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm3_reg(XMM3, XMM3b, XMM3c, XMM3d);</span>
<span class="line-removed">- reg_class ymm3_reg(XMM3, XMM3b, XMM3c, XMM3d, XMM3e, XMM3f, XMM3g, XMM3h);</span>
<span class="line-removed">- reg_class zmm3_reg(XMM3, XMM3b, XMM3c, XMM3d, XMM3e, XMM3f, XMM3g, XMM3h, XMM3i, XMM3j, XMM3k, XMM3l, XMM3m, XMM3n, XMM3o, XMM3p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm4_reg(XMM4, XMM4b, XMM4c, XMM4d);</span>
<span class="line-removed">- reg_class ymm4_reg(XMM4, XMM4b, XMM4c, XMM4d, XMM4e, XMM4f, XMM4g, XMM4h);</span>
<span class="line-removed">- reg_class zmm4_reg(XMM4, XMM4b, XMM4c, XMM4d, XMM4e, XMM4f, XMM4g, XMM4h, XMM4i, XMM4j, XMM4k, XMM4l, XMM4m, XMM4n, XMM4o, XMM4p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm5_reg(XMM5, XMM5b, XMM5c, XMM5d);</span>
<span class="line-removed">- reg_class ymm5_reg(XMM5, XMM5b, XMM5c, XMM5d, XMM5e, XMM5f, XMM5g, XMM5h);</span>
<span class="line-removed">- reg_class zmm5_reg(XMM5, XMM5b, XMM5c, XMM5d, XMM5e, XMM5f, XMM5g, XMM5h, XMM5i, XMM5j, XMM5k, XMM5l, XMM5m, XMM5n, XMM5o, XMM5p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm6_reg(XMM6, XMM6b, XMM6c, XMM6d);</span>
<span class="line-removed">- reg_class ymm6_reg(XMM6, XMM6b, XMM6c, XMM6d, XMM6e, XMM6f, XMM6g, XMM6h);</span>
<span class="line-removed">- reg_class zmm6_reg(XMM6, XMM6b, XMM6c, XMM6d, XMM6e, XMM6f, XMM6g, XMM6h, XMM6i, XMM6j, XMM6k, XMM6l, XMM6m, XMM6n, XMM6o, XMM6p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm7_reg(XMM7, XMM7b, XMM7c, XMM7d);</span>
<span class="line-removed">- reg_class ymm7_reg(XMM7, XMM7b, XMM7c, XMM7d, XMM7e, XMM7f, XMM7g, XMM7h);</span>
<span class="line-removed">- reg_class zmm7_reg(XMM7, XMM7b, XMM7c, XMM7d, XMM7e, XMM7f, XMM7g, XMM7h, XMM7i, XMM7j, XMM7k, XMM7l, XMM7m, XMM7n, XMM7o, XMM7p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm8_reg(XMM8, XMM8b, XMM8c, XMM8d);</span>
<span class="line-removed">- reg_class ymm8_reg(XMM8, XMM8b, XMM8c, XMM8d, XMM8e, XMM8f, XMM8g, XMM8h);</span>
<span class="line-removed">- reg_class zmm8_reg(XMM8, XMM8b, XMM8c, XMM8d, XMM8e, XMM8f, XMM8g, XMM8h, XMM8i, XMM8j, XMM8k, XMM8l, XMM8m, XMM8n, XMM8o, XMM8p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm9_reg(XMM9, XMM9b, XMM9c, XMM9d);</span>
<span class="line-removed">- reg_class ymm9_reg(XMM9, XMM9b, XMM9c, XMM9d, XMM9e, XMM9f, XMM9g, XMM9h);</span>
<span class="line-removed">- reg_class zmm9_reg(XMM9, XMM9b, XMM9c, XMM9d, XMM9e, XMM9f, XMM9g, XMM9h, XMM9i, XMM9j, XMM9k, XMM9l, XMM9m, XMM9n, XMM9o, XMM9p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm10_reg(XMM10, XMM10b, XMM10c, XMM10d);</span>
<span class="line-removed">- reg_class ymm10_reg(XMM10, XMM10b, XMM10c, XMM10d, XMM10e, XMM10f, XMM10g, XMM10h);</span>
<span class="line-removed">- reg_class zmm10_reg(XMM10, XMM10b, XMM10c, XMM10d, XMM10e, XMM10f, XMM10g, XMM10h, XMM10i, XMM10j, XMM10k, XMM10l, XMM10m, XMM10n, XMM10o, XMM10p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm11_reg(XMM11, XMM11b, XMM11c, XMM11d);</span>
<span class="line-removed">- reg_class ymm11_reg(XMM11, XMM11b, XMM11c, XMM11d, XMM11e, XMM11f, XMM11g, XMM11h);</span>
<span class="line-removed">- reg_class zmm11_reg(XMM11, XMM11b, XMM11c, XMM11d, XMM11e, XMM11f, XMM11g, XMM11h, XMM11i, XMM11j, XMM11k, XMM11l, XMM11m, XMM11n, XMM11o, XMM11p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm12_reg(XMM12, XMM12b, XMM12c, XMM12d);</span>
<span class="line-removed">- reg_class ymm12_reg(XMM12, XMM12b, XMM12c, XMM12d, XMM12e, XMM12f, XMM12g, XMM12h);</span>
<span class="line-removed">- reg_class zmm12_reg(XMM12, XMM12b, XMM12c, XMM12d, XMM12e, XMM12f, XMM12g, XMM12h, XMM12i, XMM12j, XMM12k, XMM12l, XMM12m, XMM12n, XMM12o, XMM12p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm13_reg(XMM13, XMM13b, XMM13c, XMM13d);</span>
<span class="line-removed">- reg_class ymm13_reg(XMM13, XMM13b, XMM13c, XMM13d, XMM13e, XMM13f, XMM13g, XMM13h);</span>
<span class="line-removed">- reg_class zmm13_reg(XMM13, XMM13b, XMM13c, XMM13d, XMM13e, XMM13f, XMM13g, XMM13h, XMM13i, XMM13j, XMM13k, XMM13l, XMM13m, XMM13n, XMM13o, XMM13p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm14_reg(XMM14, XMM14b, XMM14c, XMM14d);</span>
<span class="line-removed">- reg_class ymm14_reg(XMM14, XMM14b, XMM14c, XMM14d, XMM14e, XMM14f, XMM14g, XMM14h);</span>
<span class="line-removed">- reg_class zmm14_reg(XMM14, XMM14b, XMM14c, XMM14d, XMM14e, XMM14f, XMM14g, XMM14h, XMM14i, XMM14j, XMM14k, XMM14l, XMM14m, XMM14n, XMM14o, XMM14p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm15_reg(XMM15, XMM15b, XMM15c, XMM15d);</span>
<span class="line-removed">- reg_class ymm15_reg(XMM15, XMM15b, XMM15c, XMM15d, XMM15e, XMM15f, XMM15g, XMM15h);</span>
<span class="line-removed">- reg_class zmm15_reg(XMM15, XMM15b, XMM15c, XMM15d, XMM15e, XMM15f, XMM15g, XMM15h, XMM15i, XMM15j, XMM15k, XMM15l, XMM15m, XMM15n, XMM15o, XMM15p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm16_reg(XMM16, XMM16b, XMM16c, XMM16d);</span>
<span class="line-removed">- reg_class ymm16_reg(XMM16, XMM16b, XMM16c, XMM16d, XMM16e, XMM16f, XMM16g, XMM16h);</span>
<span class="line-removed">- reg_class zmm16_reg(XMM16, XMM16b, XMM16c, XMM16d, XMM16e, XMM16f, XMM16g, XMM16h, XMM16i, XMM16j, XMM16k, XMM16l, XMM16m, XMM16n, XMM16o, XMM16p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm17_reg(XMM17, XMM17b, XMM17c, XMM17d);</span>
<span class="line-removed">- reg_class ymm17_reg(XMM17, XMM17b, XMM17c, XMM17d, XMM17e, XMM17f, XMM17g, XMM17h);</span>
<span class="line-removed">- reg_class zmm17_reg(XMM17, XMM17b, XMM17c, XMM17d, XMM17e, XMM17f, XMM17g, XMM17h, XMM17i, XMM17j, XMM17k, XMM17l, XMM17m, XMM17n, XMM17o, XMM17p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm18_reg(XMM18, XMM18b, XMM18c, XMM18d);</span>
<span class="line-removed">- reg_class ymm18_reg(XMM18, XMM18b, XMM18c, XMM18d, XMM18e, XMM18f, XMM18g, XMM18h);</span>
<span class="line-removed">- reg_class zmm18_reg(XMM18, XMM18b, XMM18c, XMM18d, XMM18e, XMM18f, XMM18g, XMM18h, XMM18i, XMM18j, XMM18k, XMM18l, XMM18m, XMM18n, XMM18o, XMM18p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm19_reg(XMM19, XMM19b, XMM19c, XMM19d);</span>
<span class="line-removed">- reg_class ymm19_reg(XMM19, XMM19b, XMM19c, XMM19d, XMM19e, XMM19f, XMM19g, XMM19h);</span>
<span class="line-removed">- reg_class zmm19_reg(XMM19, XMM19b, XMM19c, XMM19d, XMM19e, XMM19f, XMM19g, XMM19h, XMM19i, XMM19j, XMM19k, XMM19l, XMM19m, XMM19n, XMM19o, XMM19p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm20_reg(XMM20, XMM20b, XMM20c, XMM20d);</span>
<span class="line-removed">- reg_class ymm20_reg(XMM20, XMM20b, XMM20c, XMM20d, XMM20e, XMM20f, XMM20g, XMM20h);</span>
<span class="line-removed">- reg_class zmm20_reg(XMM20, XMM20b, XMM20c, XMM20d, XMM20e, XMM20f, XMM20g, XMM20h, XMM20i, XMM20j, XMM20k, XMM20l, XMM20m, XMM20n, XMM20o, XMM20p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm21_reg(XMM21, XMM21b, XMM21c, XMM21d);</span>
<span class="line-removed">- reg_class ymm21_reg(XMM21, XMM21b, XMM21c, XMM21d, XMM21e, XMM21f, XMM21g, XMM21h);</span>
<span class="line-removed">- reg_class zmm21_reg(XMM21, XMM21b, XMM21c, XMM21d, XMM21e, XMM21f, XMM21g, XMM21h, XMM21i, XMM21j, XMM21k, XMM21l, XMM21m, XMM21n, XMM21o, XMM21p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm22_reg(XMM22, XMM22b, XMM22c, XMM22d);</span>
<span class="line-removed">- reg_class ymm22_reg(XMM22, XMM22b, XMM22c, XMM22d, XMM22e, XMM22f, XMM22g, XMM22h);</span>
<span class="line-removed">- reg_class zmm22_reg(XMM22, XMM22b, XMM22c, XMM22d, XMM22e, XMM22f, XMM22g, XMM22h, XMM22i, XMM22j, XMM22k, XMM22l, XMM22m, XMM22n, XMM22o, XMM22p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm23_reg(XMM23, XMM23b, XMM23c, XMM23d);</span>
<span class="line-removed">- reg_class ymm23_reg(XMM23, XMM23b, XMM23c, XMM23d, XMM23e, XMM23f, XMM23g, XMM23h);</span>
<span class="line-removed">- reg_class zmm23_reg(XMM23, XMM23b, XMM23c, XMM23d, XMM23e, XMM23f, XMM23g, XMM23h, XMM23i, XMM23j, XMM23k, XMM23l, XMM23m, XMM23n, XMM23o, XMM23p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm24_reg(XMM24, XMM24b, XMM24c, XMM24d);</span>
<span class="line-removed">- reg_class ymm24_reg(XMM24, XMM24b, XMM24c, XMM24d, XMM24e, XMM24f, XMM24g, XMM24h);</span>
<span class="line-removed">- reg_class zmm24_reg(XMM24, XMM24b, XMM24c, XMM24d, XMM24e, XMM24f, XMM24g, XMM24h, XMM24i, XMM24j, XMM24k, XMM24l, XMM24m, XMM24n, XMM24o, XMM24p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm25_reg(XMM25, XMM25b, XMM25c, XMM25d);</span>
<span class="line-removed">- reg_class ymm25_reg(XMM25, XMM25b, XMM25c, XMM25d, XMM25e, XMM25f, XMM25g, XMM25h);</span>
<span class="line-removed">- reg_class zmm25_reg(XMM25, XMM25b, XMM25c, XMM25d, XMM25e, XMM25f, XMM25g, XMM25h, XMM25i, XMM25j, XMM25k, XMM25l, XMM25m, XMM25n, XMM25o, XMM25p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm26_reg(XMM26, XMM26b, XMM26c, XMM26d);</span>
<span class="line-removed">- reg_class ymm26_reg(XMM26, XMM26b, XMM26c, XMM26d, XMM26e, XMM26f, XMM26g, XMM26h);</span>
<span class="line-removed">- reg_class zmm26_reg(XMM26, XMM26b, XMM26c, XMM26d, XMM26e, XMM26f, XMM26g, XMM26h, XMM26i, XMM26j, XMM26k, XMM26l, XMM26m, XMM26n, XMM26o, XMM26p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm27_reg(XMM27, XMM27b, XMM27c, XMM27d);</span>
<span class="line-removed">- reg_class ymm27_reg(XMM27, XMM27b, XMM27c, XMM27d, XMM27e, XMM27f, XMM27g, XMM27h);</span>
<span class="line-removed">- reg_class zmm27_reg(XMM27, XMM27b, XMM27c, XMM27d, XMM27e, XMM27f, XMM27g, XMM27h, XMM27i, XMM27j, XMM27k, XMM27l, XMM27m, XMM27n, XMM27o, XMM27p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm28_reg(XMM28, XMM28b, XMM28c, XMM28d);</span>
<span class="line-removed">- reg_class ymm28_reg(XMM28, XMM28b, XMM28c, XMM28d, XMM28e, XMM28f, XMM28g, XMM28h);</span>
<span class="line-removed">- reg_class zmm28_reg(XMM28, XMM28b, XMM28c, XMM28d, XMM28e, XMM28f, XMM28g, XMM28h, XMM28i, XMM28j, XMM28k, XMM28l, XMM28m, XMM28n, XMM28o, XMM28p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm29_reg(XMM29, XMM29b, XMM29c, XMM29d);</span>
<span class="line-removed">- reg_class ymm29_reg(XMM29, XMM29b, XMM29c, XMM29d, XMM29e, XMM29f, XMM29g, XMM29h);</span>
<span class="line-removed">- reg_class zmm29_reg(XMM29, XMM29b, XMM29c, XMM29d, XMM29e, XMM29f, XMM29g, XMM29h, XMM29i, XMM29j, XMM29k, XMM29l, XMM29m, XMM29n, XMM29o, XMM29p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm30_reg(XMM30, XMM30b, XMM30c, XMM30d);</span>
<span class="line-removed">- reg_class ymm30_reg(XMM30, XMM30b, XMM30c, XMM30d, XMM30e, XMM30f, XMM30g, XMM30h);</span>
<span class="line-removed">- reg_class zmm30_reg(XMM30, XMM30b, XMM30c, XMM30d, XMM30e, XMM30f, XMM30g, XMM30h, XMM30i, XMM30j, XMM30k, XMM30l, XMM30m, XMM30n, XMM30o, XMM30p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- reg_class xmm31_reg(XMM31, XMM31b, XMM31c, XMM31d);</span>
<span class="line-removed">- reg_class ymm31_reg(XMM31, XMM31b, XMM31c, XMM31d, XMM31e, XMM31f, XMM31g, XMM31h);</span>
<span class="line-removed">- reg_class zmm31_reg(XMM31, XMM31b, XMM31c, XMM31d, XMM31e, XMM31f, XMM31g, XMM31h, XMM31i, XMM31j, XMM31k, XMM31l, XMM31m, XMM31n, XMM31o, XMM31p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  %}
  
  
  //----------SOURCE BLOCK-------------------------------------------------------
  // This is a block of C++ code which provides values, functions, and
<span class="line-new-header">--- 1092,13 ---</span>
                        XMM14, XMM14b, XMM14c, XMM14d, XMM14e, XMM14f, XMM14g, XMM14h, XMM14i, XMM14j, XMM14k, XMM14l, XMM14m, XMM14n, XMM14o, XMM14p,
                        XMM15, XMM15b, XMM15c, XMM15d, XMM15e, XMM15f, XMM15g, XMM15h, XMM15i, XMM15j, XMM15k, XMM15l, XMM15m, XMM15n, XMM15o, XMM15p
  #endif
                        );
  
<span class="line-modified">! reg_class_dynamic vectorz_reg   (vectorz_reg_evex, vectorz_reg_legacy, %{ VM_Version::supports_evex() %} );</span>
  reg_class_dynamic vectorz_reg_vl(vectorz_reg_evex, vectorz_reg_legacy, %{ VM_Version::supports_evex() &amp;&amp; VM_Version::supports_avx512vl() %} );
  
  %}
  
  
  //----------SOURCE BLOCK-------------------------------------------------------
  // This is a block of C++ code which provides values, functions, and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1370,136 ***</span>
    static address float_signmask()  { return (address)float_signmask_pool; }
    static address float_signflip()  { return (address)float_signflip_pool; }
    static address double_signmask() { return (address)double_signmask_pool; }
    static address double_signflip() { return (address)double_signflip_pool; }
  #endif
  
<span class="line-modified">! </span>
  const bool Matcher::match_rule_supported(int opcode) {
<span class="line-modified">!   if (!has_match_rule(opcode))</span>
<span class="line-modified">!     return false;</span>
<span class="line-modified">! </span>
<span class="line-removed">-   bool ret_value = true;</span>
    switch (opcode) {
      case Op_PopCountI:
      case Op_PopCountL:
<span class="line-modified">!       if (!UsePopCountInstruction)</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_PopCountVI:
<span class="line-modified">!       if (!UsePopCountInstruction || !VM_Version::supports_vpopcntdq())</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_MulVI:
<span class="line-modified">!       if ((UseSSE &lt; 4) &amp;&amp; (UseAVX &lt; 1)) // only with SSE4_1 or AVX</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_MulVL:
      case Op_MulReductionVL:
<span class="line-modified">!       if (VM_Version::supports_avx512dq() == false)</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_AddReductionVL:
<span class="line-modified">!       if (UseAVX &lt; 3) // only EVEX : vector connectivity becomes an issue here</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_AddReductionVI:
<span class="line-modified">!       if (UseSSE &lt; 3) // requires at least SSE3</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_MulReductionVI:
<span class="line-modified">!       if (UseSSE &lt; 4) // requires at least SSE4</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_AddReductionVF:
      case Op_AddReductionVD:
      case Op_MulReductionVF:
      case Op_MulReductionVD:
<span class="line-modified">!       if (UseSSE &lt; 1) // requires at least SSE</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_SqrtVD:
      case Op_SqrtVF:
<span class="line-modified">!       if (UseAVX &lt; 1) // enabled for AVX only</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_CompareAndSwapL:
  #ifdef _LP64
      case Op_CompareAndSwapP:
  #endif
<span class="line-modified">!       if (!VM_Version::supports_cx8())</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_CMoveVF:
      case Op_CMoveVD:
<span class="line-modified">!       if (UseAVX &lt; 1 || UseAVX &gt; 2)</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_StrIndexOf:
<span class="line-modified">!       if (!UseSSE42Intrinsics)</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_StrIndexOfChar:
<span class="line-modified">!       if (!UseSSE42Intrinsics)</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_OnSpinWait:
<span class="line-modified">!       if (VM_Version::supports_on_spin_wait() == false)</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
      case Op_MulAddVS2VI:
<span class="line-modified">!       if (UseSSE &lt; 2)</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
  #ifdef _LP64
      case Op_MaxD:
      case Op_MaxF:
      case Op_MinD:
      case Op_MinF:
<span class="line-modified">!       if (UseAVX &lt; 1) // enabled for AVX only</span>
<span class="line-modified">!         ret_value = false;</span>
        break;
  #endif
    }
  
<span class="line-modified">!   return ret_value;  // Per default match rules are supported.</span>
  }
  
<span class="line-modified">! const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {</span>
<span class="line-modified">!   // identify extra cases that we might want to provide match rules for</span>
<span class="line-modified">!   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen</span>
<span class="line-modified">!   bool ret_value = match_rule_supported(opcode);</span>
<span class="line-modified">!   if (ret_value) {</span>
<span class="line-modified">!     switch (opcode) {</span>
<span class="line-modified">!       case Op_AddVB:</span>
<span class="line-modified">!       case Op_SubVB:</span>
<span class="line-modified">!         if ((vlen == 64) &amp;&amp; (VM_Version::supports_avx512bw() == false))</span>
<span class="line-modified">!           ret_value = false;</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       case Op_URShiftVS:</span>
<span class="line-modified">!       case Op_RShiftVS:</span>
<span class="line-modified">!       case Op_LShiftVS:</span>
<span class="line-modified">!       case Op_MulVS:</span>
<span class="line-modified">!       case Op_AddVS:</span>
<span class="line-modified">!       case Op_SubVS:</span>
<span class="line-modified">!         if ((vlen == 32) &amp;&amp; (VM_Version::supports_avx512bw() == false))</span>
<span class="line-modified">!           ret_value = false;</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       case Op_CMoveVF:</span>
<span class="line-modified">!         if (vlen != 8)</span>
<span class="line-modified">!           ret_value  = false;</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       case Op_CMoveVD:</span>
<span class="line-modified">!         if (vlen != 4)</span>
<span class="line-removed">-           ret_value  = false;</span>
<span class="line-removed">-         break;</span>
      }
    }
  
<span class="line-modified">!   return ret_value;  // Per default match rules are supported.</span>
  }
  
  const bool Matcher::has_predicated_vectors(void) {
    bool ret_value = false;
    if (UseAVX &gt; 2) {
      ret_value = VM_Version::supports_avx512vl();
    }
<span class="line-new-header">--- 1238,259 ---</span>
    static address float_signmask()  { return (address)float_signmask_pool; }
    static address float_signflip()  { return (address)float_signflip_pool; }
    static address double_signmask() { return (address)double_signmask_pool; }
    static address double_signflip() { return (address)double_signflip_pool; }
  #endif
<span class="line-added">+   static address vector_short_to_byte_mask() { return StubRoutines::x86::vector_short_to_byte_mask(); }</span>
<span class="line-added">+   static address vector_byte_perm_mask() { return StubRoutines::x86::vector_byte_perm_mask(); }</span>
<span class="line-added">+   static address vector_long_sign_mask() { return StubRoutines::x86::vector_long_sign_mask(); }</span>
  
<span class="line-modified">! //=============================================================================</span>
  const bool Matcher::match_rule_supported(int opcode) {
<span class="line-modified">!   if (!has_match_rule(opcode)) {</span>
<span class="line-modified">!     return false; // no match rule present</span>
<span class="line-modified">!   }</span>
    switch (opcode) {
<span class="line-added">+     case Op_AbsVL:</span>
<span class="line-added">+       if (UseAVX &lt; 3) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
      case Op_PopCountI:
      case Op_PopCountL:
<span class="line-modified">!       if (!UsePopCountInstruction) {</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_PopCountVI:
<span class="line-modified">!       if (!UsePopCountInstruction || !VM_Version::supports_vpopcntdq()) {</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_MulVI:
<span class="line-modified">!       if ((UseSSE &lt; 4) &amp;&amp; (UseAVX &lt; 1)) { // only with SSE4_1 or AVX</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_MulVL:
      case Op_MulReductionVL:
<span class="line-modified">!       if (VM_Version::supports_avx512dq() == false) {</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_AddReductionVL:
<span class="line-modified">!       if (UseAVX &lt; 3) { // only EVEX : vector connectivity becomes an issue here</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
<span class="line-added">+     case Op_AbsVB:</span>
<span class="line-added">+     case Op_AbsVS:</span>
<span class="line-added">+     case Op_AbsVI:</span>
      case Op_AddReductionVI:
<span class="line-modified">!       if (UseSSE &lt; 3 || !VM_Version::supports_ssse3()) { // requires at least SSSE3</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_MulReductionVI:
<span class="line-modified">!       if (UseSSE &lt; 4) { // requires at least SSE4</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_AddReductionVF:
      case Op_AddReductionVD:
      case Op_MulReductionVF:
      case Op_MulReductionVD:
<span class="line-modified">!       if (UseSSE &lt; 1) { // requires at least SSE</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_SqrtVD:
      case Op_SqrtVF:
<span class="line-modified">!       if (UseAVX &lt; 1) { // enabled for AVX only</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_CompareAndSwapL:
  #ifdef _LP64
      case Op_CompareAndSwapP:
  #endif
<span class="line-modified">!       if (!VM_Version::supports_cx8()) {</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_CMoveVF:
      case Op_CMoveVD:
<span class="line-modified">!       if (UseAVX &lt; 1 || UseAVX &gt; 2) {</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_StrIndexOf:
<span class="line-modified">!       if (!UseSSE42Intrinsics) {</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_StrIndexOfChar:
<span class="line-modified">!       if (!UseSSE42Intrinsics) {</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_OnSpinWait:
<span class="line-modified">!       if (VM_Version::supports_on_spin_wait() == false) {</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
      case Op_MulAddVS2VI:
<span class="line-modified">!     case Op_RShiftVL:</span>
<span class="line-modified">!     case Op_AbsVD:</span>
<span class="line-added">+     case Op_NegVD:</span>
<span class="line-added">+       if (UseSSE &lt; 2) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case Op_MulVB:</span>
<span class="line-added">+     case Op_LShiftVB:</span>
<span class="line-added">+     case Op_RShiftVB:</span>
<span class="line-added">+     case Op_URShiftVB:</span>
<span class="line-added">+       if (UseSSE &lt; 4) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
        break;
  #ifdef _LP64
      case Op_MaxD:
      case Op_MaxF:
      case Op_MinD:
      case Op_MinF:
<span class="line-modified">!       if (UseAVX &lt; 1) { // enabled for AVX only</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+       }</span>
        break;
  #endif
<span class="line-added">+     case Op_CacheWB:</span>
<span class="line-added">+     case Op_CacheWBPreSync:</span>
<span class="line-added">+     case Op_CacheWBPostSync:</span>
<span class="line-added">+       if (!VM_Version::supports_data_cache_line_flush()) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case Op_RoundDoubleMode:</span>
<span class="line-added">+       if (UseSSE &lt; 4) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case Op_RoundDoubleModeV:</span>
<span class="line-added">+       if (VM_Version::supports_avx() == false) {</span>
<span class="line-added">+         return false; // 128bit vroundpd is not available</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
    }
<span class="line-added">+   return true;  // Match rules are supported by default.</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! //------------------------------------------------------------------------</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Identify extra cases that we might want to provide match rules for vector nodes and</span>
<span class="line-added">+ // other intrinsics guarded with vector length (vlen) and element type (bt).</span>
<span class="line-added">+ const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {</span>
<span class="line-added">+   if (!match_rule_supported(opcode)) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   // Matcher::vector_size_supported() restricts vector sizes in the following way (see Matcher::vector_width_in_bytes):</span>
<span class="line-added">+   //   * SSE2 supports 128bit vectors for all types;</span>
<span class="line-added">+   //   * AVX1 supports 256bit vectors only for FLOAT and DOUBLE types;</span>
<span class="line-added">+   //   * AVX2 supports 256bit vectors for all types;</span>
<span class="line-added">+   //   * AVX512F supports 512bit vectors only for INT, FLOAT, and DOUBLE types;</span>
<span class="line-added">+   //   * AVX512BW supports 512bit vectors for BYTE, SHORT, and CHAR types.</span>
<span class="line-added">+   // There&#39;s also a limit on minimum vector size supported: 2 elements (or 4 bytes for BYTE).</span>
<span class="line-added">+   // And MaxVectorSize is taken into account as well.</span>
<span class="line-added">+   if (!vector_size_supported(bt, vlen)) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   // Special cases which require vector length follow:</span>
<span class="line-added">+   //   * implementation limitations</span>
<span class="line-added">+   //   * some 512bit vector operations on FLOAT and DOUBLE types require AVX512DQ</span>
<span class="line-added">+   //   * 128bit vroundpd instruction is present only in AVX1</span>
<span class="line-added">+   switch (opcode) {</span>
<span class="line-added">+     case Op_AbsVF:</span>
<span class="line-added">+     case Op_NegVF:</span>
<span class="line-added">+       if ((vlen == 16) &amp;&amp; (VM_Version::supports_avx512dq() == false)) {</span>
<span class="line-added">+         return false; // 512bit vandps and vxorps are not available</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case Op_AbsVD:</span>
<span class="line-added">+     case Op_NegVD:</span>
<span class="line-added">+       if ((vlen == 8) &amp;&amp; (VM_Version::supports_avx512dq() == false)) {</span>
<span class="line-added">+         return false; // 512bit vandpd and vxorpd are not available</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case Op_CMoveVF:</span>
<span class="line-added">+       if (vlen != 8) {</span>
<span class="line-added">+         return false; // implementation limitation (only vcmov8F_reg is present)</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case Op_CMoveVD:</span>
<span class="line-added">+       if (vlen != 4) {</span>
<span class="line-added">+         return false; // implementation limitation (only vcmov4D_reg is present)</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return true;  // Per default match rules are supported.</span>
  }
  
<span class="line-modified">! // x86 supports generic vector operands: vec and legVec.</span>
<span class="line-modified">! const bool Matcher::supports_generic_vector_operands = true;</span>
<span class="line-modified">! </span>
<span class="line-modified">! MachOper* Matcher::specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp) {</span>
<span class="line-modified">!   assert(Matcher::is_generic_vector(generic_opnd), &quot;not generic&quot;);</span>
<span class="line-modified">!   bool legacy = (generic_opnd-&gt;opcode() == LEGVEC);</span>
<span class="line-modified">!   if (!VM_Version::supports_avx512vlbwdq() &amp;&amp; // KNL</span>
<span class="line-modified">!       is_temp &amp;&amp; !legacy &amp;&amp; (ideal_reg == Op_VecZ)) {</span>
<span class="line-modified">!     // Conservatively specialize 512bit vec TEMP operands to legVecZ (zmm0-15) on KNL.</span>
<span class="line-modified">!     return new legVecZOper();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (legacy) {</span>
<span class="line-modified">!     switch (ideal_reg) {</span>
<span class="line-modified">!       case Op_VecS: return new legVecSOper();</span>
<span class="line-modified">!       case Op_VecD: return new legVecDOper();</span>
<span class="line-modified">!       case Op_VecX: return new legVecXOper();</span>
<span class="line-modified">!       case Op_VecY: return new legVecYOper();</span>
<span class="line-modified">!       case Op_VecZ: return new legVecZOper();</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     switch (ideal_reg) {</span>
<span class="line-modified">!       case Op_VecS: return new vecSOper();</span>
<span class="line-modified">!       case Op_VecD: return new vecDOper();</span>
<span class="line-modified">!       case Op_VecX: return new vecXOper();</span>
<span class="line-modified">!       case Op_VecY: return new vecYOper();</span>
<span class="line-modified">!       case Op_VecZ: return new vecZOper();</span>
      }
    }
<span class="line-added">+   ShouldNotReachHere();</span>
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Matcher::is_generic_reg2reg_move(MachNode* m) {</span>
<span class="line-added">+   switch (m-&gt;rule()) {</span>
<span class="line-added">+     case MoveVec2Leg_rule:</span>
<span class="line-added">+     case MoveLeg2Vec_rule:</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! bool Matcher::is_generic_vector(MachOper* opnd) {</span>
<span class="line-added">+   switch (opnd-&gt;opcode()) {</span>
<span class="line-added">+     case VEC:</span>
<span class="line-added">+     case LEGVEC:</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-added">+ //------------------------------------------------------------------------</span>
<span class="line-added">+ </span>
  const bool Matcher::has_predicated_vectors(void) {
    bool ret_value = false;
    if (UseAVX &gt; 2) {
      ret_value = VM_Version::supports_avx512vl();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1675,10 ***</span>
<span class="line-new-header">--- 1666,41 ---</span>
  }
  
  void Compile::reshape_address(AddPNode* addp) {
  }
  
<span class="line-added">+ static inline uint vector_length(const MachNode* n) {</span>
<span class="line-added">+   const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();</span>
<span class="line-added">+   return vt-&gt;length();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline uint vector_length_in_bytes(const MachNode* n) {</span>
<span class="line-added">+   const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();</span>
<span class="line-added">+   return vt-&gt;length_in_bytes();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline uint vector_length_in_bytes(const MachNode* use, MachOper* opnd) {</span>
<span class="line-added">+   uint def_idx = use-&gt;operand_index(opnd);</span>
<span class="line-added">+   Node* def = use-&gt;in(def_idx);</span>
<span class="line-added">+   return def-&gt;bottom_type()-&gt;is_vect()-&gt;length_in_bytes();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline Assembler::AvxVectorLen vector_length_encoding(const MachNode* n) {</span>
<span class="line-added">+   switch(vector_length_in_bytes(n)) {</span>
<span class="line-added">+     case  4: // fall-through</span>
<span class="line-added">+     case  8: // fall-through</span>
<span class="line-added">+     case 16: return Assembler::AVX_128bit;</span>
<span class="line-added">+     case 32: return Assembler::AVX_256bit;</span>
<span class="line-added">+     case 64: return Assembler::AVX_512bit;</span>
<span class="line-added">+ </span>
<span class="line-added">+     default: {</span>
<span class="line-added">+       ShouldNotReachHere();</span>
<span class="line-added">+       return Assembler::AVX_NoVec;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Helper methods for MachSpillCopyNode::implementation().
  static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
                            int src_hi, int dst_hi, uint ireg, outputStream* st) {
    // In 64-bit VM size calculation is very complex. Emitting instructions
    // into scratch buffer is used to get size in 64-bit VM.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1746,12 ***</span>
    }
    // VEX_2bytes prefix is used if UseAVX &gt; 0, and it takes the same 2 bytes as SIMD prefix.
    return (UseAVX &gt; 2) ? 6 : 4;
  }
  
<span class="line-modified">! static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,</span>
<span class="line-modified">!                             int stack_offset, int reg, uint ireg, outputStream* st) {</span>
    // In 64-bit VM size calculation is very complex. Emitting instructions
    // into scratch buffer is used to get size in 64-bit VM.
    LP64_ONLY( assert(!do_size, &quot;this method calculates size only for 32-bit VM&quot;); )
    if (cbuf) {
      MacroAssembler _masm(cbuf);
<span class="line-new-header">--- 1768,12 ---</span>
    }
    // VEX_2bytes prefix is used if UseAVX &gt; 0, and it takes the same 2 bytes as SIMD prefix.
    return (UseAVX &gt; 2) ? 6 : 4;
  }
  
<span class="line-modified">! int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,</span>
<span class="line-modified">!                      int stack_offset, int reg, uint ireg, outputStream* st) {</span>
    // In 64-bit VM size calculation is very complex. Emitting instructions
    // into scratch buffer is used to get size in 64-bit VM.
    LP64_ONLY( assert(!do_size, &quot;this method calculates size only for 32-bit VM&quot;); )
    if (cbuf) {
      MacroAssembler _masm(cbuf);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2004,20 ***</span>
  //----------OPERANDS-----------------------------------------------------------
  // Operand definitions must precede instruction definitions for correct parsing
  // in the ADLC because operands constitute user defined types which are used in
  // instruction definitions.
  
  operand vecZ() %{
    constraint(ALLOC_IN_RC(vectorz_reg));
    match(VecZ);
  
    format %{ %}
    interface(REG_INTER);
  %}
  
  operand legVecZ() %{
<span class="line-modified">!   constraint(ALLOC_IN_RC(vectorz_reg_vl));</span>
    match(VecZ);
  
    format %{ %}
    interface(REG_INTER);
  %}
<span class="line-new-header">--- 2026,126 ---</span>
  //----------OPERANDS-----------------------------------------------------------
  // Operand definitions must precede instruction definitions for correct parsing
  // in the ADLC because operands constitute user defined types which are used in
  // instruction definitions.
  
<span class="line-added">+ // Vectors</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Dummy generic vector class. Should be used for all vector operands.</span>
<span class="line-added">+ // Replaced with vec[SDXYZ] during post-selection pass.</span>
<span class="line-added">+ operand vec() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(dynamic));</span>
<span class="line-added">+   match(VecX);</span>
<span class="line-added">+   match(VecY);</span>
<span class="line-added">+   match(VecZ);</span>
<span class="line-added">+   match(VecS);</span>
<span class="line-added">+   match(VecD);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Dummy generic legacy vector class. Should be used for all legacy vector operands.</span>
<span class="line-added">+ // Replaced with legVec[SDXYZ] during post-selection cleanup.</span>
<span class="line-added">+ // Note: legacy register class is used to avoid extra (unneeded in 32-bit VM)</span>
<span class="line-added">+ // runtime code generation via reg_class_dynamic.</span>
<span class="line-added">+ operand legVec() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(dynamic));</span>
<span class="line-added">+   match(VecX);</span>
<span class="line-added">+   match(VecY);</span>
<span class="line-added">+   match(VecZ);</span>
<span class="line-added">+   match(VecS);</span>
<span class="line-added">+   match(VecD);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Replaces vec during post-selection cleanup. See above.</span>
<span class="line-added">+ operand vecS() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(vectors_reg_vlbwdq));</span>
<span class="line-added">+   match(VecS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Replaces legVec during post-selection cleanup. See above.</span>
<span class="line-added">+ operand legVecS() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(vectors_reg_legacy));</span>
<span class="line-added">+   match(VecS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Replaces vec during post-selection cleanup. See above.</span>
<span class="line-added">+ operand vecD() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(vectord_reg_vlbwdq));</span>
<span class="line-added">+   match(VecD);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Replaces legVec during post-selection cleanup. See above.</span>
<span class="line-added">+ operand legVecD() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(vectord_reg_legacy));</span>
<span class="line-added">+   match(VecD);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Replaces vec during post-selection cleanup. See above.</span>
<span class="line-added">+ operand vecX() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(vectorx_reg_vlbwdq));</span>
<span class="line-added">+   match(VecX);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Replaces legVec during post-selection cleanup. See above.</span>
<span class="line-added">+ operand legVecX() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(vectorx_reg_legacy));</span>
<span class="line-added">+   match(VecX);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Replaces vec during post-selection cleanup. See above.</span>
<span class="line-added">+ operand vecY() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(vectory_reg_vlbwdq));</span>
<span class="line-added">+   match(VecY);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Replaces legVec during post-selection cleanup. See above.</span>
<span class="line-added">+ operand legVecY() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(vectory_reg_legacy));</span>
<span class="line-added">+   match(VecY);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Replaces vec during post-selection cleanup. See above.</span>
  operand vecZ() %{
    constraint(ALLOC_IN_RC(vectorz_reg));
    match(VecZ);
  
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="line-added">+ // Replaces legVec during post-selection cleanup. See above.</span>
  operand legVecZ() %{
<span class="line-modified">!   constraint(ALLOC_IN_RC(vectorz_reg_legacy));</span>
    match(VecZ);
  
    format %{ %}
    interface(REG_INTER);
  %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2051,11 ***</span>
  
  instruct ShouldNotReachHere() %{
    match(Halt);
    format %{ &quot;ud2\t# ShouldNotReachHere&quot; %}
    ins_encode %{
<span class="line-modified">!     __ ud2();</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  // =================================EVEX special===============================
<span class="line-new-header">--- 2179,11 ---</span>
  
  instruct ShouldNotReachHere() %{
    match(Halt);
    format %{ &quot;ud2\t# ShouldNotReachHere&quot; %}
    ins_encode %{
<span class="line-modified">!     __ stop(_halt_reason);</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  // =================================EVEX special===============================
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2808,10 ***</span>
<span class="line-new-header">--- 2936,93 ---</span>
      __ sqrtsd($dst$$XMMRegister, $constantaddress($con));
    %}
    ins_pipe(pipe_slow);
  %}
  
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+ instruct roundD_reg(legRegD dst, legRegD src, immU8 rmode) %{</span>
<span class="line-added">+   match(Set dst (RoundDoubleMode src rmode));</span>
<span class="line-added">+   format %{ &quot;roundsd $dst,$src&quot; %}</span>
<span class="line-added">+   ins_cost(150);</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     assert(UseSSE &gt;= 4, &quot;required&quot;);</span>
<span class="line-added">+     __ roundsd($dst$$XMMRegister, $src$$XMMRegister, $rmode$$constant);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_slow);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct roundD_mem(legRegD dst, memory src, immU8 rmode) %{</span>
<span class="line-added">+   match(Set dst (RoundDoubleMode (LoadD src) rmode));</span>
<span class="line-added">+   format %{ &quot;roundsd $dst,$src&quot; %}</span>
<span class="line-added">+   ins_cost(150);</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     assert(UseSSE &gt;= 4, &quot;required&quot;);</span>
<span class="line-added">+     __ roundsd($dst$$XMMRegister, $src$$Address, $rmode$$constant);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_slow);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct roundD_imm(legRegD dst, immD con, immU8 rmode, rRegI scratch_reg) %{</span>
<span class="line-added">+   match(Set dst (RoundDoubleMode con rmode));</span>
<span class="line-added">+   effect(TEMP scratch_reg);</span>
<span class="line-added">+   format %{ &quot;roundsd $dst,[$constantaddress]\t# load from constant table: double=$con&quot; %}</span>
<span class="line-added">+   ins_cost(150);</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     assert(UseSSE &gt;= 4, &quot;required&quot;);</span>
<span class="line-added">+     __ roundsd($dst$$XMMRegister, $constantaddress($con), $rmode$$constant, $scratch_reg$$Register);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_slow);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct vroundD_reg(legVec dst, legVec src, immU8 rmode) %{</span>
<span class="line-added">+   predicate(n-&gt;as_Vector()-&gt;length() &lt; 8);</span>
<span class="line-added">+   match(Set dst (RoundDoubleModeV src rmode));</span>
<span class="line-added">+   format %{ &quot;vroundpd $dst,$src,$rmode\t! round packedD&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vroundpd($dst$$XMMRegister, $src$$XMMRegister, $rmode$$constant, vector_len);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe( pipe_slow );</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct vround8D_reg(vec dst, vec src, immU8 rmode) %{</span>
<span class="line-added">+   predicate(n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-added">+   match(Set dst (RoundDoubleModeV src rmode));</span>
<span class="line-added">+   format %{ &quot;vrndscalepd $dst,$src,$rmode\t! round packed8D&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-added">+     __ vrndscalepd($dst$$XMMRegister, $src$$XMMRegister, $rmode$$constant, Assembler::AVX_512bit);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe( pipe_slow );</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct vroundD_mem(legVec dst, memory mem, immU8 rmode) %{</span>
<span class="line-added">+   predicate(n-&gt;as_Vector()-&gt;length() &lt; 8);</span>
<span class="line-added">+   match(Set dst (RoundDoubleModeV (LoadVector mem) rmode));</span>
<span class="line-added">+   format %{ &quot;vroundpd $dst, $mem, $rmode\t! round packedD&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vroundpd($dst$$XMMRegister, $mem$$Address, $rmode$$constant, vector_len);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe( pipe_slow );</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct vround8D_mem(vec dst, memory mem, immU8 rmode) %{</span>
<span class="line-added">+   predicate(n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-added">+   match(Set dst (RoundDoubleModeV (LoadVector mem) rmode));</span>
<span class="line-added">+   format %{ &quot;vrndscalepd $dst,$mem,$rmode\t! round packed8D&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-added">+     __ vrndscalepd($dst$$XMMRegister, $mem$$Address, $rmode$$constant, Assembler::AVX_512bit);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe( pipe_slow );</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ #endif // _LP64</span>
<span class="line-added">+ </span>
  instruct onspinwait() %{
    match(OnSpinWait);
    ins_cost(200);
  
    format %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2848,7183 ***</span>
    ins_pipe( pipe_slow );
  %}
  
  // ====================VECTOR INSTRUCTIONS=====================================
  
<span class="line-modified">! </span>
<span class="line-modified">! // Load vectors (4 bytes long)</span>
<span class="line-removed">- instruct loadV4(vecS dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 4);</span>
<span class="line-removed">-   match(Set dst (LoadVector mem));</span>
<span class="line-removed">-   ins_cost(125);</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$mem\t! load vector (4 bytes)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Load vectors (4 bytes long)</span>
<span class="line-removed">- instruct MoveVecS2Leg(legVecS dst, vecS src) %{</span>
    match(Set dst src);
<span class="line-modified">!   format %{ &quot;movss $dst,$src\t! load vector (4 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movflt($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
<span class="line-modified">! // Load vectors (4 bytes long)</span>
<span class="line-removed">- instruct MoveLeg2VecS(vecS dst, legVecS src) %{</span>
    match(Set dst src);
<span class="line-modified">!   format %{ &quot;movss $dst,$src\t! load vector (4 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movflt($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
<span class="line-modified">! // Load vectors (8 bytes long)</span>
<span class="line-modified">! instruct loadV8(vecD dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);</span>
    match(Set dst (LoadVector mem));
    ins_cost(125);
<span class="line-modified">!   format %{ &quot;movq    $dst,$mem\t! load vector (8 bytes)&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ movq($dst$$XMMRegister, $mem$$Address);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Load vectors (8 bytes long)</span>
<span class="line-modified">! instruct MoveVecD2Leg(legVecD dst, vecD src) %{</span>
<span class="line-modified">!   match(Set dst src);</span>
<span class="line-modified">!   format %{ &quot;movsd $dst,$src\t! load vector (8 bytes)&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
<span class="line-modified">!   ins_pipe( fpu_reg_reg );</span>
  %}
  
<span class="line-modified">! // Load vectors (8 bytes long)</span>
<span class="line-modified">! instruct MoveLeg2VecD(vecD dst, legVecD src) %{</span>
<span class="line-modified">!   match(Set dst src);</span>
<span class="line-modified">!   format %{ &quot;movsd $dst,$src\t! load vector (8 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
<span class="line-modified">!   ins_pipe( fpu_reg_reg );</span>
  %}
  
<span class="line-modified">! // Load vectors (16 bytes long)</span>
<span class="line-modified">! instruct loadV16(vecX dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 16);</span>
<span class="line-modified">!   match(Set dst (LoadVector mem));</span>
<span class="line-removed">-   ins_cost(125);</span>
<span class="line-removed">-   format %{ &quot;movdqu  $dst,$mem\t! load vector (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movdqu($dst$$XMMRegister, $mem$$Address);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Load vectors (16 bytes long)</span>
<span class="line-modified">! instruct MoveVecX2Leg(legVecX dst, vecX src) %{</span>
<span class="line-modified">!   match(Set dst src);</span>
<span class="line-modified">!   format %{ &quot;movdqu $dst,$src\t! load vector (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {</span>
<span class="line-modified">!       int vector_len = 2;</span>
<span class="line-modified">!       __ evmovdquq($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       __ movdqu($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-     }</span>
    %}
<span class="line-modified">!   ins_pipe( fpu_reg_reg );</span>
  %}
  
<span class="line-modified">! // Load vectors (16 bytes long)</span>
<span class="line-modified">! instruct MoveLeg2VecX(vecX dst, legVecX src) %{</span>
<span class="line-modified">!   match(Set dst src);</span>
<span class="line-modified">!   format %{ &quot;movdqu $dst,$src\t! load vector (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {</span>
<span class="line-modified">!       int vector_len = 2;</span>
<span class="line-modified">!       __ evmovdquq($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
      } else {
<span class="line-modified">!       __ movdqu($dst$$XMMRegister, $src$$XMMRegister);</span>
      }
    %}
<span class="line-modified">!   ins_pipe( fpu_reg_reg );</span>
  %}
  
<span class="line-modified">! // Load vectors (32 bytes long)</span>
<span class="line-modified">! instruct loadV32(vecY dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 32);</span>
<span class="line-modified">!   match(Set dst (LoadVector mem));</span>
<span class="line-removed">-   ins_cost(125);</span>
<span class="line-removed">-   format %{ &quot;vmovdqu $dst,$mem\t! load vector (32 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ vmovdqu($dst$$XMMRegister, $mem$$Address);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Load vectors (32 bytes long)</span>
<span class="line-modified">! instruct MoveVecY2Leg(legVecY dst, vecY src) %{</span>
<span class="line-modified">!   match(Set dst src);</span>
<span class="line-modified">!   format %{ &quot;vmovdqu $dst,$src\t! load vector (32 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {</span>
<span class="line-modified">!       int vector_len = 2;</span>
<span class="line-modified">!       __ evmovdquq($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
      } else {
<span class="line-modified">!       __ vmovdqu($dst$$XMMRegister, $src$$XMMRegister);</span>
      }
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
<span class="line-modified">! // Load vectors (32 bytes long)</span>
<span class="line-modified">! instruct MoveLeg2VecY(vecY dst, legVecY src) %{</span>
<span class="line-modified">!   match(Set dst src);</span>
<span class="line-modified">!   format %{ &quot;vmovdqu $dst,$src\t! load vector (32 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {</span>
<span class="line-modified">!       int vector_len = 2;</span>
<span class="line-modified">!       __ evmovdquq($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
      } else {
<span class="line-modified">!       __ vmovdqu($dst$$XMMRegister, $src$$XMMRegister);</span>
      }
    %}
<span class="line-modified">!   ins_pipe( fpu_reg_reg );</span>
  %}
  
<span class="line-modified">! // Load vectors (64 bytes long)</span>
<span class="line-modified">! instruct loadV64_dword(vecZ dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 64 &amp;&amp; n-&gt;as_LoadVector()-&gt;element_size() &lt;= 4);</span>
<span class="line-modified">!   match(Set dst (LoadVector mem));</span>
<span class="line-removed">-   ins_cost(125);</span>
<span class="line-removed">-   format %{ &quot;vmovdqul $dst k0,$mem\t! load vector (64 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ evmovdqul($dst$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Load vectors (64 bytes long)</span>
<span class="line-modified">! instruct loadV64_qword(vecZ dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 64 &amp;&amp; n-&gt;as_LoadVector()-&gt;element_size() &gt; 4);</span>
<span class="line-modified">!   match(Set dst (LoadVector mem));</span>
<span class="line-modified">!   ins_cost(125);</span>
<span class="line-modified">!   format %{ &quot;vmovdquq $dst k0,$mem\t! load vector (64 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ evmovdquq($dst$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct MoveVecZ2Leg(legVecZ dst, vecZ  src) %{</span>
<span class="line-modified">!   match(Set dst src);</span>
<span class="line-modified">!   format %{ &quot;vmovdquq $dst k0,$src\t! Move vector (64 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ evmovdquq($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
    %}
<span class="line-modified">!   ins_pipe( fpu_reg_reg );</span>
  %}
  
<span class="line-modified">! instruct MoveLeg2VecZ(vecZ dst, legVecZ  src) %{</span>
<span class="line-modified">!   match(Set dst src);</span>
<span class="line-modified">!   format %{ &quot;vmovdquq $dst k0,$src\t! Move vector (64 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ evmovdquq($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
<span class="line-modified">! // Store vectors</span>
<span class="line-modified">! instruct storeV4(memory mem, vecS src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 4);</span>
<span class="line-modified">!   match(Set mem (StoreVector mem src));</span>
<span class="line-removed">-   ins_cost(145);</span>
<span class="line-removed">-   format %{ &quot;movd    $mem,$src\t! store vector (4 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movdl($mem$$Address, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct storeV8(memory mem, vecD src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);</span>
<span class="line-modified">!   match(Set mem (StoreVector mem src));</span>
<span class="line-removed">-   ins_cost(145);</span>
<span class="line-removed">-   format %{ &quot;movq    $mem,$src\t! store vector (8 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movq($mem$$Address, $src$$XMMRegister);</span>
    %}
<span class="line-modified">!   ins_pipe( pipe_slow );</span>
  %}
  
<span class="line-modified">! instruct storeV16(memory mem, vecX src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 16);</span>
<span class="line-modified">!   match(Set mem (StoreVector mem src));</span>
<span class="line-modified">!   ins_cost(145);</span>
<span class="line-modified">!   format %{ &quot;movdqu  $mem,$src\t! store vector (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movdqu($mem$$Address, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct storeV32(memory mem, vecY src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 32);</span>
<span class="line-modified">!   match(Set mem (StoreVector mem src));</span>
<span class="line-modified">!   ins_cost(145);</span>
<span class="line-modified">!   format %{ &quot;vmovdqu $mem,$src\t! store vector (32 bytes)&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ vmovdqu($mem$$Address, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct storeV64_dword(memory mem, vecZ src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 64 &amp;&amp; n-&gt;as_StoreVector()-&gt;element_size() &lt;= 4);</span>
<span class="line-modified">!   match(Set mem (StoreVector mem src));</span>
<span class="line-modified">!   ins_cost(145);</span>
<span class="line-modified">!   format %{ &quot;vmovdqul $mem k0,$src\t! store vector (64 bytes)&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ evmovdqul($mem$$Address, $src$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct storeV64_qword(memory mem, vecZ src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 64 &amp;&amp; n-&gt;as_StoreVector()-&gt;element_size() &gt; 4);</span>
<span class="line-modified">!   match(Set mem (StoreVector mem src));</span>
<span class="line-modified">!   ins_cost(145);</span>
<span class="line-removed">-   format %{ &quot;vmovdquq $mem k0,$src\t! store vector (64 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ evmovdquq($mem$$Address, $src$$XMMRegister, vector_len);</span>
    %}
<span class="line-modified">!   ins_pipe( pipe_slow );</span>
  %}
  
<span class="line-modified">! // ====================LEGACY REPLICATE=======================================</span>
  
<span class="line-modified">! instruct Repl4B_mem(vecS dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateB (LoadB mem)));</span>
<span class="line-modified">!   format %{ &quot;punpcklbw $dst,$mem\n\t&quot;</span>
<span class="line-modified">!             &quot;pshuflw $dst,$dst,0x00\t! replicate4B&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ punpcklbw($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
    %}
    ins_pipe( pipe_slow );
  %}
<span class="line-modified">! </span>
<span class="line-modified">! instruct Repl8B_mem(vecD dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateB (LoadB mem)));</span>
<span class="line-modified">!   format %{ &quot;punpcklbw $dst,$mem\n\t&quot;</span>
<span class="line-modified">!             &quot;pshuflw $dst,$dst,0x00\t! replicate8B&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ punpcklbw($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct Repl16B(vecX dst, rRegI src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateB src));</span>
<span class="line-modified">!   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-modified">!             &quot;punpcklbw $dst,$dst\n\t&quot;</span>
<span class="line-modified">!             &quot;pshuflw $dst,$dst,0x00\n\t&quot;</span>
<span class="line-modified">!             &quot;punpcklqdq $dst,$dst\t! replicate16B&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-modified">!     __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct Repl16B_mem(vecX dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateB (LoadB mem)));</span>
<span class="line-modified">!   format %{ &quot;punpcklbw $dst,$mem\n\t&quot;</span>
<span class="line-modified">!             &quot;pshuflw $dst,$dst,0x00\n\t&quot;</span>
<span class="line-modified">!             &quot;punpcklqdq $dst,$dst\t! replicate16B&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ punpcklbw($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct Repl32B(vecY dst, rRegI src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateB src));</span>
<span class="line-modified">!   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-modified">!             &quot;punpcklbw $dst,$dst\n\t&quot;</span>
<span class="line-modified">!             &quot;pshuflw $dst,$dst,0x00\n\t&quot;</span>
<span class="line-modified">!             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-modified">!             &quot;vinserti128_high $dst,$dst\t! replicate32B&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-modified">!     __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-modified">!     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct Repl32B_mem(vecY dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateB (LoadB mem)));</span>
<span class="line-removed">-   format %{ &quot;punpcklbw $dst,$mem\n\t&quot;</span>
<span class="line-removed">-             &quot;pshuflw $dst,$dst,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t! replicate32B&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ punpcklbw($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-modified">!     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
    %}
<span class="line-modified">!   ins_pipe( pipe_slow );</span>
  %}
  
<span class="line-modified">! instruct Repl64B(legVecZ dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB src));</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklbw $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;pshuflw $dst,$dst,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate64B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
  
<span class="line-modified">! instruct Repl64B_mem(legVecZ dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateB (LoadB mem)));</span>
<span class="line-modified">!   format %{ &quot;punpcklbw $dst,$mem\n\t&quot;</span>
<span class="line-modified">!             &quot;pshuflw $dst,$dst,0x00\n\t&quot;</span>
<span class="line-modified">!             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-modified">!             &quot;vinserti128_high $dst,$dst\t&quot;</span>
<span class="line-modified">!             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate64B&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ punpcklbw($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-modified">!     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-modified">!     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct Repl16B_imm(vecX dst, immI con) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateB con));</span>
<span class="line-modified">!   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-modified">!             &quot;punpcklqdq $dst,$dst\t! replicate16B($con)&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 1)));</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct Repl32B_imm(vecY dst, immI con) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateB con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t! lreplicate32B($con)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 1)));</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-modified">!     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
    %}
<span class="line-modified">!   ins_pipe( pipe_slow );</span>
  %}
  
<span class="line-modified">! instruct Repl64B_imm(legVecZ dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate64B($con)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 1)));</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
  
<span class="line-modified">! instruct Repl4S(vecD dst, rRegI src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateS src));</span>
<span class="line-modified">!   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-modified">!             &quot;pshuflw $dst,$dst,0x00\t! replicate4S&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct Repl4S_mem(vecD dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateS (LoadS mem)));</span>
<span class="line-modified">!   format %{ &quot;pshuflw $dst,$mem,0x00\t! replicate4S&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $mem$$Address, 0x00);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct Repl8S(vecX dst, rRegI src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateS src));</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;pshuflw $dst,$dst,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\t! replicate8S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
    %}
<span class="line-modified">!   ins_pipe( pipe_slow );</span>
  %}
  
<span class="line-modified">! instruct Repl8S_mem(vecX dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateS (LoadS mem)));</span>
<span class="line-modified">!   format %{ &quot;pshuflw $dst,$mem,0x00\n\t&quot;</span>
<span class="line-modified">!             &quot;punpcklqdq $dst,$dst\t! replicate8S&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct Repl8S_imm(vecX dst, immI con) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateS con));</span>
<span class="line-modified">!   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-modified">!             &quot;punpcklqdq $dst,$dst\t! replicate8S($con)&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 2)));</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct Repl16S(vecY dst, rRegI src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateS src));</span>
<span class="line-modified">!   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-modified">!             &quot;pshuflw $dst,$dst,0x00\n\t&quot;</span>
<span class="line-modified">!             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-modified">!             &quot;vinserti128_high $dst,$dst\t! replicate16S&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-modified">!     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct Repl16S_mem(vecY dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-modified">!   match(Set dst (ReplicateS (LoadS mem)));</span>
<span class="line-modified">!   format %{ &quot;pshuflw $dst,$mem,0x00\n\t&quot;</span>
<span class="line-modified">!             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t! replicate16S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshuflw($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16S_imm(vecY dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t! replicate16S($con)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 2)));</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl32S(legVecZ dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS src));</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;pshuflw $dst,$dst,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl32S_mem(legVecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS (LoadS mem)));</span>
<span class="line-removed">-   format %{ &quot;pshuflw $dst,$mem,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshuflw($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl32S_imm(legVecZ dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate32S($con)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 2)));</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4I(vecX dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI src));</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $dst,$dst,0x00\t! replicate4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4I_mem(vecX dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI (LoadI mem)));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$mem,0x00\t! replicate4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8I(vecY dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI src));</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $dst,$dst,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t! replicate8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8I_mem(vecY dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI (LoadI mem)));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$mem,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t! replicate8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16I(legVecZ dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI src));</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $dst,$dst,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16I_mem(legVecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI (LoadI mem)));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$mem,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4I_imm(vecX dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\t! replicate4I($con)\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 4)));</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8I_imm(vecY dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\t! replicate8I($con)\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 4)));</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16I_imm(legVecZ dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate16I($con)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 4)));</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Long could be loaded into xmm register directly from memory.</span>
<span class="line-removed">- instruct Repl2L_mem(vecX dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; !VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateL (LoadL mem)));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,$mem\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\t! replicate2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate long (8 byte) scalar to be vector</span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">- instruct Repl4L(vecY dst, rRegL src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL src));</span>
<span class="line-removed">-   format %{ &quot;movdq   $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t! replicate4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdq($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8L(legVecZ dst, rRegL src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL src));</span>
<span class="line-removed">-   format %{ &quot;movdq   $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdq($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- #else // _LP64</span>
<span class="line-removed">- instruct Repl4L(vecY dst, eRegL src, vecY tmp) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL src));</span>
<span class="line-removed">-   effect(TEMP dst, USE src, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;movdl   $dst,$src.lo\n\t&quot;</span>
<span class="line-removed">-             &quot;movdl   $tmp,$src.hi\n\t&quot;</span>
<span class="line-removed">-             &quot;punpckldq $dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t! replicate4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));</span>
<span class="line-removed">-     __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8L(legVecZ dst, eRegL src, legVecZ tmp) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL src));</span>
<span class="line-removed">-   effect(TEMP dst, USE src, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;movdl   $dst,$src.lo\n\t&quot;</span>
<span class="line-removed">-             &quot;movdl   $tmp,$src.hi\n\t&quot;</span>
<span class="line-removed">-             &quot;punpckldq $dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));</span>
<span class="line-removed">-     __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- #endif // _LP64</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4L_imm(vecY dst, immL con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t! replicate4L($con)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress($con));</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8L_imm(legVecZ dst, immL con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate8L($con)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress($con));</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4L_mem(vecY dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL (LoadL mem)));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,$mem\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t! replicate4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8L_mem(legVecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL (LoadL mem)));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,$mem\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;vinserti128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl2F_mem(vecD dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateF (LoadF mem)));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$mem,0x00\t! replicate2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4F_mem(vecX dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateF (LoadF mem)));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$mem,0x00\t! replicate4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8F(vecY dst, vlRegF src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateF src));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$src,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;vinsertf128_high $dst,$dst\t! replicate8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);</span>
<span class="line-removed">-     __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8F_mem(vecY dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateF (LoadF mem)));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$mem,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;vinsertf128_high $dst,$dst\t! replicate8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-removed">-     __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16F(legVecZ dst, vlRegF src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateF src));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$src,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;vinsertf128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);</span>
<span class="line-removed">-     __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16F_mem(legVecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateF (LoadF mem)));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$mem,0x00\n\t&quot;</span>
<span class="line-removed">-             &quot;vinsertf128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-removed">-     __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl2F_zero(vecD dst, immF0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseAVX &lt; 3);</span>
<span class="line-removed">-   match(Set dst (ReplicateF zero));</span>
<span class="line-removed">-   format %{ &quot;xorps   $dst,$dst\t! replicate2F zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4F_zero(vecX dst, immF0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &lt; 3);</span>
<span class="line-removed">-   match(Set dst (ReplicateF zero));</span>
<span class="line-removed">-   format %{ &quot;xorps   $dst,$dst\t! replicate4F zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8F_zero(vecY dst, immF0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &lt; 3);</span>
<span class="line-removed">-   match(Set dst (ReplicateF zero));</span>
<span class="line-removed">-   format %{ &quot;vxorps  $dst,$dst,$dst\t! replicate8F zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vxorps($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl2D_mem(vecX dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateD (LoadD mem)));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$mem,0x44\t! replicate2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $mem$$Address, 0x44);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4D(vecY dst, vlRegD src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateD src));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$src,0x44\n\t&quot;</span>
<span class="line-removed">-             &quot;vinsertf128_high $dst,$dst\t! replicate4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);</span>
<span class="line-removed">-     __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4D_mem(vecY dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateD (LoadD mem)));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$mem,0x44\n\t&quot;</span>
<span class="line-removed">-             &quot;vinsertf128_high $dst,$dst\t! replicate4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $mem$$Address, 0x44);</span>
<span class="line-removed">-     __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8D(legVecZ dst, vlRegD src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 0 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateD src));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$src,0x44\n\t&quot;</span>
<span class="line-removed">-             &quot;vinsertf128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);</span>
<span class="line-removed">-     __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8D_mem(legVecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; !VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateD (LoadD mem)));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$mem,0x44\n\t&quot;</span>
<span class="line-removed">-             &quot;vinsertf128_high $dst,$dst\t&quot;</span>
<span class="line-removed">-             &quot;vinserti64x4 $dst,$dst,$dst,0x1\t! replicate8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $mem$$Address, 0x44);</span>
<span class="line-removed">-     __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate double (8 byte) scalar zero to be vector</span>
<span class="line-removed">- instruct Repl2D_zero(vecX dst, immD0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseAVX &lt; 3);</span>
<span class="line-removed">-   match(Set dst (ReplicateD zero));</span>
<span class="line-removed">-   format %{ &quot;xorpd   $dst,$dst\t! replicate2D zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ xorpd($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4D_zero(vecY dst, immD0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &lt; 3);</span>
<span class="line-removed">-   match(Set dst (ReplicateD zero));</span>
<span class="line-removed">-   format %{ &quot;vxorpd  $dst,$dst,$dst,vect256\t! replicate4D zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vxorpd($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // ====================GENERIC REPLICATE==========================================</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate byte scalar to be vector</span>
<span class="line-removed">- instruct Repl4B(vecS dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (ReplicateB src));</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklbw $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;pshuflw $dst,$dst,0x00\t! replicate4B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8B(vecD dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (ReplicateB src));</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklbw $dst,$dst\n\t&quot;</span>
<span class="line-removed">-             &quot;pshuflw $dst,$dst,0x00\t! replicate8B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate byte scalar immediate to be vector by loading from const table.</span>
<span class="line-removed">- instruct Repl4B_imm(vecS dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (ReplicateB con));</span>
<span class="line-removed">-   format %{ &quot;movdl   $dst,[$constantaddress]\t! replicate4B($con)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $constantaddress(replicate4_imm($con$$constant, 1)));</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8B_imm(vecD dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (ReplicateB con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\t! replicate8B($con)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 1)));</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate byte scalar zero to be vector</span>
<span class="line-removed">- instruct Repl4B_zero(vecS dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (ReplicateB zero));</span>
<span class="line-removed">-   format %{ &quot;pxor    $dst,$dst\t! replicate4B zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8B_zero(vecD dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (ReplicateB zero));</span>
<span class="line-removed">-   format %{ &quot;pxor    $dst,$dst\t! replicate8B zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16B_zero(vecX dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (ReplicateB zero));</span>
<span class="line-removed">-   format %{ &quot;pxor    $dst,$dst\t! replicate16B zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl32B_zero(vecY dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (ReplicateB zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor   $dst,$dst,$dst\t! replicate32B zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vxorpd since AVX does not have vpxor for 256-bit (AVX2 will have it).</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate char/short (2 byte) scalar to be vector</span>
<span class="line-removed">- instruct Repl2S(vecS dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateS src));</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;pshuflw $dst,$dst,0x00\t! replicate2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate char/short (2 byte) scalar immediate to be vector by loading from const table.</span>
<span class="line-removed">- instruct Repl2S_imm(vecS dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateS con));</span>
<span class="line-removed">-   format %{ &quot;movdl   $dst,[$constantaddress]\t! replicate2S($con)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $constantaddress(replicate4_imm($con$$constant, 2)));</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4S_imm(vecD dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (ReplicateS con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\t! replicate4S($con)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 2)));</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate char/short (2 byte) scalar zero to be vector</span>
<span class="line-removed">- instruct Repl2S_zero(vecS dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateS zero));</span>
<span class="line-removed">-   format %{ &quot;pxor    $dst,$dst\t! replicate2S zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4S_zero(vecD dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (ReplicateS zero));</span>
<span class="line-removed">-   format %{ &quot;pxor    $dst,$dst\t! replicate4S zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8S_zero(vecX dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (ReplicateS zero));</span>
<span class="line-removed">-   format %{ &quot;pxor    $dst,$dst\t! replicate8S zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16S_zero(vecY dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (ReplicateS zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor   $dst,$dst,$dst\t! replicate16S zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vxorpd since AVX does not have vpxor for 256-bit (AVX2 will have it).</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate integer (4 byte) scalar to be vector</span>
<span class="line-removed">- instruct Repl2I(vecD dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateI src));</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $dst,$dst,0x00\t! replicate2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Integer could be loaded into xmm register directly from memory.</span>
<span class="line-removed">- instruct Repl2I_mem(vecD dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateI (LoadI mem)));</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$mem\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $dst,$dst,0x00\t! replicate2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate integer (4 byte) scalar immediate to be vector by loading from const table.</span>
<span class="line-removed">- instruct Repl2I_imm(vecD dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateI con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\t! replicate2I($con)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 4)));</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate integer (4 byte) scalar zero to be vector</span>
<span class="line-removed">- instruct Repl2I_zero(vecD dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateI zero));</span>
<span class="line-removed">-   format %{ &quot;pxor    $dst,$dst\t! replicate2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4I_zero(vecX dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (ReplicateI zero));</span>
<span class="line-removed">-   format %{ &quot;pxor    $dst,$dst\t! replicate4I zero)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8I_zero(vecY dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (ReplicateI zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor   $dst,$dst,$dst\t! replicate8I zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vxorpd since AVX does not have vpxor for 256-bit (AVX2 will have it).</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate long (8 byte) scalar to be vector</span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">- instruct Repl2L(vecX dst, rRegL src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateL src));</span>
<span class="line-removed">-   format %{ &quot;movdq   $dst,$src\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\t! replicate2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdq($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- #else // _LP64</span>
<span class="line-removed">- instruct Repl2L(vecX dst, eRegL src, vecX tmp) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateL src));</span>
<span class="line-removed">-   effect(TEMP dst, USE src, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;movdl   $dst,$src.lo\n\t&quot;</span>
<span class="line-removed">-             &quot;movdl   $tmp,$src.hi\n\t&quot;</span>
<span class="line-removed">-             &quot;punpckldq $dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\t! replicate2L&quot;%}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));</span>
<span class="line-removed">-     __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- #endif // _LP64</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate long (8 byte) scalar immediate to be vector by loading from const table.</span>
<span class="line-removed">- instruct Repl2L_imm(vecX dst, immL con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateL con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;punpcklqdq $dst,$dst\t! replicate2L($con)&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress($con));</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate long (8 byte) scalar zero to be vector</span>
<span class="line-removed">- instruct Repl2L_zero(vecX dst, immL0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateL zero));</span>
<span class="line-removed">-   format %{ &quot;pxor    $dst,$dst\t! replicate2L zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4L_zero(vecY dst, immL0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (ReplicateL zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor   $dst,$dst,$dst\t! replicate4L zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vxorpd since AVX does not have vpxor for 256-bit (AVX2 will have it).</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate float (4 byte) scalar to be vector</span>
<span class="line-removed">- instruct Repl2F(vecD dst, vlRegF src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateF src));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$dst,0x00\t! replicate2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4F(vecX dst, vlRegF src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (ReplicateF src));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$dst,0x00\t! replicate4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate double (8 bytes) scalar to be vector</span>
<span class="line-removed">- instruct Repl2D(vecX dst, vlRegD src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateD src));</span>
<span class="line-removed">-   format %{ &quot;pshufd  $dst,$src,0x44\t! replicate2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // ====================EVEX REPLICATE=============================================</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4B_mem_evex(vecS dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB (LoadB mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastb  $dst,$mem\t! replicate4B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpbroadcastb($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8B_mem_evex(vecD dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB (LoadB mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastb  $dst,$mem\t! replicate8B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpbroadcastb($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16B_evex(vecX dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB src));</span>
<span class="line-removed">-   format %{ &quot;evpbroadcastb $dst,$src\t! replicate16B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 0;</span>
<span class="line-removed">-     __ evpbroadcastb($dst$$XMMRegister, $src$$Register, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16B_mem_evex(vecX dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB (LoadB mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastb  $dst,$mem\t! replicate16B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpbroadcastb($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl32B_evex(vecY dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB src));</span>
<span class="line-removed">-   format %{ &quot;evpbroadcastb $dst,$src\t! replicate32B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 1;</span>
<span class="line-removed">-     __ evpbroadcastb($dst$$XMMRegister, $src$$Register, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl32B_mem_evex(vecY dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB (LoadB mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastb  $dst,$mem\t! replicate32B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpbroadcastb($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl64B_evex(vecZ dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB src));</span>
<span class="line-removed">-   format %{ &quot;evpbroadcastb $dst,$src\t! upper replicate64B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 2;</span>
<span class="line-removed">-     __ evpbroadcastb($dst$$XMMRegister, $src$$Register, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl64B_mem_evex(vecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB (LoadB mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastb  $dst,$mem\t! replicate64B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpbroadcastb($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16B_imm_evex(vecX dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastb $dst,$dst\t! replicate16B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 0;</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 1)));</span>
<span class="line-removed">-     __ vpbroadcastb($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl32B_imm_evex(vecY dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastb $dst,$dst\t! replicate32B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 1;</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 1)));</span>
<span class="line-removed">-     __ vpbroadcastb($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl64B_imm_evex(vecZ dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastb $dst,$dst\t! upper replicate64B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 2;</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 1)));</span>
<span class="line-removed">-     __ vpbroadcastb($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl64B_zero_evex(vecZ dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateB zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor   $dst k0,$dst,$dst\t! replicate64B zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vxorpd since AVX does not have vpxor for 512-bit (EVEX will have it).</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister,$dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4S_evex(vecD dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS src));</span>
<span class="line-removed">-   format %{ &quot;evpbroadcastw $dst,$src\t! replicate4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 0;</span>
<span class="line-removed">-     __ evpbroadcastw($dst$$XMMRegister, $src$$Register, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4S_mem_evex(vecD dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS (LoadS mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastw  $dst,$mem\t! replicate4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpbroadcastw($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8S_evex(vecX dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS src));</span>
<span class="line-removed">-   format %{ &quot;evpbroadcastw $dst,$src\t! replicate8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 0;</span>
<span class="line-removed">-     __ evpbroadcastw($dst$$XMMRegister, $src$$Register, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8S_mem_evex(vecX dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS (LoadS mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastw  $dst,$mem\t! replicate8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpbroadcastw($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16S_evex(vecY dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS src));</span>
<span class="line-removed">-   format %{ &quot;evpbroadcastw $dst,$src\t! replicate16S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 1;</span>
<span class="line-removed">-     __ evpbroadcastw($dst$$XMMRegister, $src$$Register, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16S_mem_evex(vecY dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS (LoadS mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastw  $dst,$mem\t! replicate16S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpbroadcastw($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl32S_evex(vecZ dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS src));</span>
<span class="line-removed">-   format %{ &quot;evpbroadcastw $dst,$src\t! replicate32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 2;</span>
<span class="line-removed">-     __ evpbroadcastw($dst$$XMMRegister, $src$$Register, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl32S_mem_evex(vecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS (LoadS mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastw  $dst,$mem\t! replicate32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpbroadcastw($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8S_imm_evex(vecX dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastw $dst,$dst\t! replicate8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 0;</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 2)));</span>
<span class="line-removed">-     __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16S_imm_evex(vecY dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vlbw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastw $dst,$dst\t! replicate16S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 1;</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 2)));</span>
<span class="line-removed">-     __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl32S_imm_evex(vecZ dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastw $dst,$dst\t! replicate32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-    int vector_len = 2;</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 2)));</span>
<span class="line-removed">-     __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl32S_zero_evex(vecZ dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateS zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor   $dst k0,$dst,$dst\t! replicate32S zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vxorpd since AVX does not have vpxor for 512-bit (EVEX will have it).</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4I_evex(vecX dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI src));</span>
<span class="line-removed">-   format %{ &quot;evpbroadcastd  $dst,$src\t! replicate4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ evpbroadcastd($dst$$XMMRegister, $src$$Register, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4I_mem_evex(vecX dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI (LoadI mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastd  $dst,$mem\t! replicate4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpbroadcastd($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8I_evex(vecY dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI src));</span>
<span class="line-removed">-   format %{ &quot;evpbroadcastd  $dst,$src\t! replicate8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ evpbroadcastd($dst$$XMMRegister, $src$$Register, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8I_mem_evex(vecY dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI (LoadI mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastd  $dst,$mem\t! replicate8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpbroadcastd($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16I_evex(vecZ dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateI src));</span>
<span class="line-removed">-   format %{ &quot;evpbroadcastd  $dst,$src\t! replicate16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ evpbroadcastd($dst$$XMMRegister, $src$$Register, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16I_mem_evex(vecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateI (LoadI mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastd  $dst,$mem\t! replicate16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpbroadcastd($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4I_imm_evex(vecX dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\t! replicate8I($con)\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastd  $dst,$dst\t! replicate4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 4)));</span>
<span class="line-removed">-     __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8I_imm_evex(vecY dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateI con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\t! replicate8I($con)\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastd  $dst,$dst\t! replicate8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 4)));</span>
<span class="line-removed">-     __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16I_imm_evex(vecZ dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateI con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\t! replicate16I($con)\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastd  $dst,$dst\t! replicate16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 4)));</span>
<span class="line-removed">-     __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16I_zero_evex(vecZ dst, immI0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateI zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor   $dst k0,$dst,$dst\t! replicate16I zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vxorpd since AVX does not have vpxor for 512-bit (AVX2 will have it).</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Replicate long (8 byte) scalar to be vector</span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">- instruct Repl4L_evex(vecY dst, rRegL src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL src));</span>
<span class="line-removed">-   format %{ &quot;evpbroadcastq  $dst,$src\t! replicate4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ evpbroadcastq($dst$$XMMRegister, $src$$Register, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8L_evex(vecZ dst, rRegL src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateL src));</span>
<span class="line-removed">-   format %{ &quot;evpbroadcastq  $dst,$src\t! replicate8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ evpbroadcastq($dst$$XMMRegister, $src$$Register, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- #else // _LP64</span>
<span class="line-removed">- instruct Repl4L_evex(vecY dst, eRegL src, regD tmp) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL src));</span>
<span class="line-removed">-   effect(TEMP dst, USE src, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;movdl   $dst,$src.lo\n\t&quot;</span>
<span class="line-removed">-             &quot;movdl   $tmp,$src.hi\n\t&quot;</span>
<span class="line-removed">-             &quot;punpckldq $dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastq  $dst,$dst\t! replicate4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));</span>
<span class="line-removed">-     __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8L_evex(legVecZ dst, eRegL src, legVecZ tmp) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateL src));</span>
<span class="line-removed">-   effect(TEMP dst, USE src, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;movdl   $dst,$src.lo\n\t&quot;</span>
<span class="line-removed">-             &quot;movdl   $tmp,$src.hi\n\t&quot;</span>
<span class="line-removed">-             &quot;punpckldq $dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastq  $dst,$dst\t! replicate8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));</span>
<span class="line-removed">-     __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- #endif // _LP64</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4L_imm_evex(vecY dst, immL con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastq  $dst,$dst\t! replicate4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress($con));</span>
<span class="line-removed">-     __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8L_imm_evex(vecZ dst, immL con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateL con));</span>
<span class="line-removed">-   format %{ &quot;movq    $dst,[$constantaddress]\n\t&quot;</span>
<span class="line-removed">-             &quot;vpbroadcastq  $dst,$dst\t! replicate8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress($con));</span>
<span class="line-removed">-     __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl2L_mem_evex(vecX dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL (LoadL mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastd  $dst,$mem\t! replicate2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpbroadcastq($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4L_mem_evex(vecY dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateL (LoadL mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastd  $dst,$mem\t! replicate4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpbroadcastq($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8L_mem_evex(vecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateL (LoadL mem)));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastd  $dst,$mem\t! replicate8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpbroadcastq($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8L_zero_evex(vecZ dst, immL0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateL zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor   $dst k0,$dst,$dst\t! replicate8L zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vxorpd since AVX does not have vpxor for 512-bit (EVEX will have it).</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister,$dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8F_evex(vecY dst, regF src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateF src));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastss $dst,$src\t! replicate8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpbroadcastss($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8F_mem_evex(vecY dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateF (LoadF mem)));</span>
<span class="line-removed">-   format %{ &quot;vbroadcastss  $dst,$mem\t! replicate8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpbroadcastss($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16F_evex(vecZ dst, regF src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateF src));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastss $dst,$src\t! replicate16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpbroadcastss($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16F_mem_evex(vecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateF (LoadF mem)));</span>
<span class="line-removed">-   format %{ &quot;vbroadcastss  $dst,$mem\t! replicate16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpbroadcastss($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl2F_zero_evex(vecD dst, immF0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateF zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor  $dst k0,$dst,$dst\t! replicate2F zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vpxor in place of vxorps since EVEX has a constriant on dq for vxorps: this is a 512-bit operation</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister,$dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4F_zero_evex(vecX dst, immF0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateF zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor  $dst k0,$dst,$dst\t! replicate4F zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vpxor in place of vxorps since EVEX has a constriant on dq for vxorps: this is a 512-bit operation</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister,$dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8F_zero_evex(vecY dst, immF0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateF zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor  $dst k0,$dst,$dst\t! replicate8F zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vpxor in place of vxorps since EVEX has a constriant on dq for vxorps: this is a 512-bit operation</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister,$dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl16F_zero_evex(vecZ dst, immF0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateF zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor  $dst k0,$dst,$dst\t! replicate16F zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vpxor in place of vxorps since EVEX has a constriant on dq for vxorps: this is a 512-bit operation</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister,$dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4D_evex(vecY dst, regD src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateD src));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastsd $dst,$src\t! replicate4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpbroadcastsd($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4D_mem_evex(vecY dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512vl());</span>
<span class="line-removed">-   match(Set dst (ReplicateD (LoadD mem)));</span>
<span class="line-removed">-   format %{ &quot;vbroadcastsd  $dst,$mem\t! replicate4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpbroadcastsd($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8D_evex(vecZ dst, regD src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateD src));</span>
<span class="line-removed">-   format %{ &quot;vpbroadcastsd $dst,$src\t! replicate8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpbroadcastsd($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8D_mem_evex(vecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateD (LoadD mem)));</span>
<span class="line-removed">-   format %{ &quot;vbroadcastsd  $dst,$mem\t! replicate8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpbroadcastsd($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl2D_zero_evex(vecX dst, immD0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateD zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor  $dst k0,$dst,$dst\t! replicate2D zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vpxor in place of vxorpd since EVEX has a constriant on dq for vxorpd: this is a 512-bit operation</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister,$dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl4D_zero_evex(vecY dst, immD0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateD zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor  $dst k0,$dst,$dst\t! replicate4D zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vpxor in place of vxorpd since EVEX has a constriant on dq for vxorpd: this is a 512-bit operation</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister,$dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct Repl8D_zero_evex(vecZ dst, immD0 zero) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (ReplicateD zero));</span>
<span class="line-removed">-   format %{ &quot;vpxor  $dst k0,$dst,$dst,vect512\t! replicate8D zero&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     // Use vpxor in place of vxorpd since EVEX has a constriant on dq for vxorpd: this is a 512-bit operation</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister,$dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( fpu_reg_reg );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // ====================REDUCTION ARITHMETIC=======================================</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rsadd2I_reduction_reg(rRegI dst, rRegI src1, vecD src2, vecD tmp, vecD tmp2) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt; 2 &amp;&amp; UseAVX == 0);</span>
<span class="line-removed">-   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp2, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;movdqu  $tmp2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;phaddd  $tmp2,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $tmp,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;paddd   $tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $dst,$tmp\t! add reduction2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdqu($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ phaddd($tmp2$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ movdl($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ paddd($tmp$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd2I_reduction_reg(rRegI dst, rRegI src1, vecD src2, vecD tmp, vecD tmp2) %{</span>
<span class="line-removed">-   predicate(VM_Version::supports_avxonly());</span>
<span class="line-removed">-   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vphaddd  $tmp,$src2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd   $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $dst,$tmp2\t! add reduction2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vphaddd($tmp$$XMMRegister, $src2$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddd($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd2I_reduction_reg_evex(rRegI dst, rRegI src1, vecD src2, vecD tmp, vecD tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;pshufd  $tmp2,$src2,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp,$src2,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp2,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $dst,$tmp2\t! add reduction2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddd($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rsadd4I_reduction_reg(rRegI dst, rRegI src1, vecX src2, vecX tmp, vecX tmp2) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt; 2 &amp;&amp; UseAVX == 0);</span>
<span class="line-removed">-   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;movdqu  $tmp,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;phaddd  $tmp,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;phaddd  $tmp,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;paddd   $tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $dst,$tmp2\t! add reduction4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdqu($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ phaddd($tmp$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ phaddd($tmp$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ paddd($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd4I_reduction_reg(rRegI dst, rRegI src1, vecX src2, vecX tmp, vecX tmp2) %{</span>
<span class="line-removed">-   predicate(VM_Version::supports_avxonly());</span>
<span class="line-removed">-   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vphaddd  $tmp,$src2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vphaddd  $tmp,$tmp,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd   $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $dst,$tmp2\t! add reduction4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vphaddd($tmp$$XMMRegister, $src2$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ vphaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddd($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd4I_reduction_reg_evex(rRegI dst, rRegI src1, vecX src2, vecX tmp, vecX tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;pshufd  $tmp2,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp,$src2,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp2,$tmp,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp2,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $dst,$tmp2\t! add reduction4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddd($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd8I_reduction_reg(rRegI dst, rRegI src1, vecY src2, vecY tmp, vecY tmp2) %{</span>
<span class="line-removed">-   predicate(VM_Version::supports_avxonly());</span>
<span class="line-removed">-   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vphaddd  $tmp,$src2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vphaddd  $tmp,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;vextracti128_high  $tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd   $tmp,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd   $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $dst,$tmp2\t! add reduction8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vphaddd($tmp$$XMMRegister, $src2$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ vphaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ vextracti128_high($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddd($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd8I_reduction_reg_evex(rRegI dst, rRegI src1, vecY src2, vecY tmp, vecY tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vextracti128_high  $tmp,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp,$tmp,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp2,$tmp,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp2,$tmp,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp2,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $dst,$tmp2\t! add reduction8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddd($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd16I_reduction_reg_evex(rRegI dst, rRegI src1, legVecZ src2, legVecZ tmp, legVecZ tmp2, legVecZ tmp3) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2, TEMP tmp3);</span>
<span class="line-removed">-   format %{ &quot;vextracti64x4_high  $tmp3,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp3,$tmp3,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vextracti128_high  $tmp,$tmp3\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp,$tmp,$tmp3\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp2,$tmp,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp2,$tmp,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddd  $tmp2,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $dst,$tmp2\t! mul reduction16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vextracti64x4_high($tmp3$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vpaddd($tmp3$$XMMRegister, $tmp3$$XMMRegister, $src2$$XMMRegister, 1);</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $tmp3$$XMMRegister);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp3$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddd($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">- instruct rvadd2L_reduction_reg(rRegL dst, rRegL src1, vecX src2, vecX tmp, vecX tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (AddReductionVL src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;pshufd  $tmp2,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddq  $tmp,$src2,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movdq   $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddq  $tmp2,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movdq   $dst,$tmp2\t! add reduction2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpaddq($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd4L_reduction_reg(rRegL dst, rRegL src1, vecY src2, vecY tmp, vecY tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (AddReductionVL src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vextracti128_high  $tmp,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddq  $tmp2,$tmp,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddq  $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movdq   $tmp,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddq  $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movdq   $dst,$tmp2\t! add reduction4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp$$XMMRegister, $src2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd8L_reduction_reg(rRegL dst, rRegL src1, legVecZ src2, legVecZ tmp, legVecZ tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (AddReductionVL src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vextracti64x4_high  $tmp2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddq  $tmp2,$tmp2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vextracti128_high  $tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddq  $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddq  $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movdq   $tmp,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpaddq  $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movdq   $dst,$tmp2\t! add reduction8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vextracti64x4_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $src2$$XMMRegister, 1);</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rsadd2F_reduction_reg(regF dst, vecD src2, vecD tmp) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt;= 1 &amp;&amp; UseAVX == 0);</span>
<span class="line-removed">-   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP dst, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;addss   $dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;addss   $dst,$tmp\t! add reduction2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ addss($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ addss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd2F_reduction_reg(regF dst, vecD src2, vecD tmp) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0);</span>
<span class="line-removed">-   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP dst, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;vaddss  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\t! add reduction2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rsadd4F_reduction_reg(regF dst, vecX src2, vecX tmp) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt;= 1 &amp;&amp; UseAVX == 0);</span>
<span class="line-removed">-   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP dst, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;addss   $dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;addss   $dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;addss   $dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;addss   $dst,$tmp\t! add reduction4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ addss($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ addss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ addss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ addss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd4F_reduction_reg(regF dst, vecX src2, vecX tmp) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0);</span>
<span class="line-removed">-   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst);</span>
<span class="line-removed">-   format %{ &quot;vaddss  $dst,dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\t! add reduction4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct radd8F_reduction_reg(regF dst, vecY src2, vecY tmp, vecY tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0);</span>
<span class="line-removed">-   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vaddss  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf128_high  $tmp2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\t! add reduction8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf128_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct radd16F_reduction_reg(regF dst, legVecZ src2, legVecZ tmp, legVecZ tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vaddss  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf32x4  $tmp2,$src2,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf32x4  $tmp2,$src2,0x2\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf32x4  $tmp2,$src2,0x3\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddss  $dst,$dst,$tmp\t! add reduction16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x2);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x3);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rsadd2D_reduction_reg(regD dst, vecX src2, vecX tmp) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt;= 1 &amp;&amp; UseAVX == 0);</span>
<span class="line-removed">-   match(Set dst (AddReductionVD dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst);</span>
<span class="line-removed">-   format %{ &quot;addsd   $dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;addsd   $dst,$tmp\t! add reduction2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ addsd($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ addsd($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd2D_reduction_reg(regD dst, vecX src2, vecX tmp) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0);</span>
<span class="line-removed">-   match(Set dst (AddReductionVD dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst);</span>
<span class="line-removed">-   format %{ &quot;vaddsd  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddsd  $dst,$dst,$tmp\t! add reduction2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd4D_reduction_reg(regD dst, vecY src2, vecX tmp, vecX tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0);</span>
<span class="line-removed">-   match(Set dst (AddReductionVD dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vaddsd  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddsd  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf128  $tmp2,$src2,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddsd  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddsd  $dst,$dst,$tmp\t! add reduction4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf128($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvadd8D_reduction_reg(regD dst, legVecZ src2, legVecZ tmp, legVecZ tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (AddReductionVD dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vaddsd  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddsd  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf32x4  $tmp2,$src2,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddsd  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddsd  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf32x4  $tmp2,$src2,0x2\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddsd  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddsd  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf32x4  $tmp2,$src2,0x3\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddsd  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vaddsd  $dst,$dst,$tmp\t! add reduction8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x2);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x3);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rsmul2I_reduction_reg(rRegI dst, rRegI src1, vecD src2, vecD tmp, vecD tmp2) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt; 3 &amp;&amp; UseAVX == 0);</span>
<span class="line-removed">-   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;pshufd  $tmp2,$src2,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;pmulld  $tmp2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $tmp,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;pmulld  $tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $dst,$tmp2\t! mul reduction2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ pmulld($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ movdl($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ pmulld($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul2I_reduction_reg(rRegI dst, rRegI src1, vecD src2, vecD tmp, vecD tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0);</span>
<span class="line-removed">-   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;pshufd   $tmp2,$src2,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp,$src2,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp2,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $dst,$tmp2\t! mul reduction2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpmulld($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rsmul4I_reduction_reg(rRegI dst, rRegI src1, vecX src2, vecX tmp, vecX tmp2) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt; 3 &amp;&amp; UseAVX == 0);</span>
<span class="line-removed">-   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;pshufd  $tmp2,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;pmulld  $tmp2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;pmulld  $tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $tmp,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;pmulld  $tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movd    $dst,$tmp2\t! mul reduction4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ pmulld($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ pmulld($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ movdl($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ pmulld($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul4I_reduction_reg(rRegI dst, rRegI src1, vecX src2, vecX tmp, vecX tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0);</span>
<span class="line-removed">-   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;pshufd   $tmp2,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp,$src2,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd   $tmp2,$tmp,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp2,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $dst,$tmp2\t! mul reduction4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpmulld($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul8I_reduction_reg(rRegI dst, rRegI src1, vecY src2, vecY tmp, vecY tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1);</span>
<span class="line-removed">-   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vextracti128_high  $tmp,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp,$tmp,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd   $tmp2,$tmp,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd   $tmp2,$tmp,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp2,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $dst,$tmp2\t! mul reduction8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpmulld($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul16I_reduction_reg(rRegI dst, rRegI src1, legVecZ src2, legVecZ tmp, legVecZ tmp2, legVecZ tmp3) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2, TEMP tmp3);</span>
<span class="line-removed">-   format %{ &quot;vextracti64x4_high  $tmp3,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp3,$tmp3,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vextracti128_high  $tmp,$tmp3\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp,$tmp,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd   $tmp2,$tmp,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd   $tmp2,$tmp,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmulld  $tmp2,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movd     $dst,$tmp2\t! mul reduction16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vextracti64x4_high($tmp3$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vpmulld($tmp3$$XMMRegister, $tmp3$$XMMRegister, $src2$$XMMRegister, 1);</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $tmp3$$XMMRegister);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp3$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpmulld($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">- instruct rvmul2L_reduction_reg(rRegL dst, rRegL src1, vecX src2, vecX tmp, vecX tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512dq());</span>
<span class="line-removed">-   match(Set dst (MulReductionVL src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;pshufd   $tmp2,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmullq  $tmp,$src2,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movdq    $tmp2,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmullq  $tmp2,$tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;movdq    $dst,$tmp2\t! mul reduction2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpmullq($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul4L_reduction_reg(rRegL dst, rRegL src1, vecY src2, vecY tmp, vecY tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512dq());</span>
<span class="line-removed">-   match(Set dst (MulReductionVL src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vextracti128_high  $tmp,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmullq  $tmp2,$tmp,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd   $tmp,$tmp2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmullq  $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movdq    $tmp,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmullq  $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movdq    $dst,$tmp2\t! mul reduction4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp$$XMMRegister, $src2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul8L_reduction_reg(rRegL dst, rRegL src1, legVecZ src2, legVecZ tmp, legVecZ tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512dq());</span>
<span class="line-removed">-   match(Set dst (MulReductionVL src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vextracti64x4_high  $tmp2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmullq  $tmp2,$tmp2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vextracti128_high  $tmp,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmullq  $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd   $tmp,$tmp2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmullq  $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movdq    $tmp,$src1\n\t&quot;</span>
<span class="line-removed">-             &quot;vpmullq  $tmp2,$tmp2,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;movdq    $dst,$tmp2\t! mul reduction8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vextracti64x4_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $src2$$XMMRegister, 1);</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rsmul2F_reduction(regF dst, vecD src2, vecD tmp) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt;= 1 &amp;&amp; UseAVX == 0);</span>
<span class="line-removed">-   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP dst, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;mulss   $dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;mulss   $dst,$tmp\t! mul reduction2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ mulss($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ mulss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul2F_reduction_reg(regF dst, vecD src2, vecD tmp) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0);</span>
<span class="line-removed">-   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst);</span>
<span class="line-removed">-   format %{ &quot;vmulss  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\t! mul reduction2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rsmul4F_reduction_reg(regF dst, vecX src2, vecX tmp) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt;= 1 &amp;&amp; UseAVX == 0);</span>
<span class="line-removed">-   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP dst, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;mulss   $dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;mulss   $dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;mulss   $dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;mulss   $dst,$tmp\t! mul reduction4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ mulss($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ mulss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ mulss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ mulss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul4F_reduction_reg(regF dst, vecX src2, vecX tmp) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0);</span>
<span class="line-removed">-   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst);</span>
<span class="line-removed">-   format %{ &quot;vmulss  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\t! mul reduction4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul8F_reduction_reg(regF dst, vecY src2, vecY tmp, vecY tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0);</span>
<span class="line-removed">-   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vmulss  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf128_high  $tmp2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\t! mul reduction8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf128_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul16F_reduction_reg(regF dst, legVecZ src2, legVecZ tmp, legVecZ tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vmulss  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf32x4  $tmp2,$src2,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf32x4  $tmp2,$src2,0x2\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf32x4  $tmp2,$src2,0x3\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x01\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x02\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0x03\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulss  $dst,$dst,$tmp\t! mul reduction16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x2);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x3);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rsmul2D_reduction_reg(regD dst, vecX src2, vecX tmp) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt;= 1 &amp;&amp; UseAVX == 0);</span>
<span class="line-removed">-   match(Set dst (MulReductionVD dst src2));</span>
<span class="line-removed">-   effect(TEMP dst, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;mulsd   $dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;mulsd   $dst,$tmp\t! mul reduction2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ mulsd($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ mulsd($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul2D_reduction_reg(regD dst, vecX src2, vecX tmp) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0);</span>
<span class="line-removed">-   match(Set dst (MulReductionVD dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst);</span>
<span class="line-removed">-   format %{ &quot;vmulsd  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulsd  $dst,$dst,$tmp\t! mul reduction2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul4D_reduction_reg(regD dst, vecY src2, vecY tmp, vecY tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0);</span>
<span class="line-removed">-   match(Set dst (MulReductionVD dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vmulsd  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulsd  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf128_high  $tmp2,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulsd  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulsd  $dst,$dst,$tmp\t! mul reduction4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf128_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct rvmul8D_reduction_reg(regD dst, legVecZ src2, legVecZ tmp, legVecZ tmp2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2);</span>
<span class="line-removed">-   match(Set dst (MulReductionVD dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vmulsd  $dst,$dst,$src2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulsd  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf32x4  $tmp2,$src2,0x1\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulsd  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$src2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulsd  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf32x4  $tmp2,$src2,0x2\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulsd  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulsd  $dst,$dst,$tmp\n\t&quot;</span>
<span class="line-removed">-             &quot;vextractf32x4  $tmp2,$src2,0x3\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulsd  $dst,$dst,$tmp2\n\t&quot;</span>
<span class="line-removed">-             &quot;pshufd  $tmp,$tmp2,0xE\n\t&quot;</span>
<span class="line-removed">-             &quot;vmulsd  $dst,$dst,$tmp\t! mul reduction8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x2);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x3);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // ====================VECTOR ARITHMETIC=======================================</span>
<span class="line-removed">- </span>
<span class="line-removed">- // --------------------------------- ADD --------------------------------------</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Bytes vector add</span>
<span class="line-removed">- instruct vadd4B(vecS dst, vecS src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVB dst src));</span>
<span class="line-removed">-   format %{ &quot;paddb   $dst,$src\t! add packed4B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ paddb($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4B_reg(vecS dst, vecS src1, vecS src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVB src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddb  $dst,$src1,$src2\t! add packed4B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddb($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4B_mem(vecS dst, vecS src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVB src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddb  $dst,$src,$mem\t! add packed4B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddb($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8B(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVB dst src));</span>
<span class="line-removed">-   format %{ &quot;paddb   $dst,$src\t! add packed8B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ paddb($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8B_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVB src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddb  $dst,$src1,$src2\t! add packed8B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddb($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8B_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVB src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddb  $dst,$src,$mem\t! add packed8B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddb($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd16B(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (AddVB dst src));</span>
<span class="line-removed">-   format %{ &quot;paddb   $dst,$src\t! add packed16B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ paddb($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd16B_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0  &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (AddVB src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddb  $dst,$src1,$src2\t! add packed16B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddb($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd16B_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (AddVB src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddb  $dst,$src,$mem\t! add packed16B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddb($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd32B_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (AddVB src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddb  $dst,$src1,$src2\t! add packed32B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpaddb($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd32B_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (AddVB src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddb  $dst,$src,$mem\t! add packed32B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpaddb($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd64B_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 64);</span>
<span class="line-removed">-   match(Set dst (AddVB src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddb  $dst,$src1,$src2\t! add packed64B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpaddb($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd64B_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 64);</span>
<span class="line-removed">-   match(Set dst (AddVB src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddb  $dst,$src,$mem\t! add packed64B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpaddb($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Shorts/Chars vector add</span>
<span class="line-removed">- instruct vadd2S(vecS dst, vecS src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVS dst src));</span>
<span class="line-removed">-   format %{ &quot;paddw   $dst,$src\t! add packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ paddw($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd2S_reg(vecS dst, vecS src1, vecS src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0  &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddw  $dst,$src1,$src2\t! add packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd2S_mem(vecS dst, vecS src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddw  $dst,$src,$mem\t! add packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4S(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVS dst src));</span>
<span class="line-removed">-   format %{ &quot;paddw   $dst,$src\t! add packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ paddw($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4S_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddw  $dst,$src1,$src2\t! add packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4S_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddw  $dst,$src,$mem\t! add packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8S(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVS dst src));</span>
<span class="line-removed">-   format %{ &quot;paddw   $dst,$src\t! add packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ paddw($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8S_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddw  $dst,$src1,$src2\t! add packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8S_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddw  $dst,$src,$mem\t! add packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd16S_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (AddVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddw  $dst,$src1,$src2\t! add packed16S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpaddw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd16S_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (AddVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddw  $dst,$src,$mem\t! add packed16S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpaddw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd32S_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (AddVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddw  $dst,$src1,$src2\t! add packed32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpaddw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd32S_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (AddVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddw  $dst,$src,$mem\t! add packed32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpaddw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Integers vector add</span>
<span class="line-removed">- instruct vadd2I(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVI dst src));</span>
<span class="line-removed">-   format %{ &quot;paddd   $dst,$src\t! add packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ paddd($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd2I_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddd  $dst,$src1,$src2\t! add packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd2I_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVI src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddd  $dst,$src,$mem\t! add packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4I(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVI dst src));</span>
<span class="line-removed">-   format %{ &quot;paddd   $dst,$src\t! add packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ paddd($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4I_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddd  $dst,$src1,$src2\t! add packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4I_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVI src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddd  $dst,$src,$mem\t! add packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8I_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddd  $dst,$src1,$src2\t! add packed8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpaddd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8I_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVI src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddd  $dst,$src,$mem\t! add packed8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpaddd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd16I_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (AddVI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddd  $dst,$src1,$src2\t! add packed16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpaddd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd16I_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (AddVI src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddd  $dst,$src,$mem\t! add packed16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpaddd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Longs vector add</span>
<span class="line-removed">- instruct vadd2L(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVL dst src));</span>
<span class="line-removed">-   format %{ &quot;paddq   $dst,$src\t! add packed2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ paddq($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd2L_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVL src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddq  $dst,$src1,$src2\t! add packed2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd2L_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVL src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddq  $dst,$src,$mem\t! add packed2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpaddq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4L_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVL src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddq  $dst,$src1,$src2\t! add packed4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpaddq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4L_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVL src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddq  $dst,$src,$mem\t! add packed4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpaddq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8L_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVL src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpaddq  $dst,$src1,$src2\t! add packed8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpaddq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8L_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVL src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpaddq  $dst,$src,$mem\t! add packed8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpaddq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Floats vector add</span>
<span class="line-removed">- instruct vadd2F(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVF dst src));</span>
<span class="line-removed">-   format %{ &quot;addps   $dst,$src\t! add packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ addps($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd2F_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vaddps  $dst,$src1,$src2\t! add packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vaddps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd2F_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vaddps  $dst,$src,$mem\t! add packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vaddps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4F(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVF dst src));</span>
<span class="line-removed">-   format %{ &quot;addps   $dst,$src\t! add packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ addps($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4F_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vaddps  $dst,$src1,$src2\t! add packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vaddps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4F_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vaddps  $dst,$src,$mem\t! add packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vaddps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8F_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vaddps  $dst,$src1,$src2\t! add packed8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vaddps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8F_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vaddps  $dst,$src,$mem\t! add packed8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vaddps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd16F_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (AddVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vaddps  $dst,$src1,$src2\t! add packed16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vaddps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd16F_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (AddVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vaddps  $dst,$src,$mem\t! add packed16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vaddps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Doubles vector add</span>
<span class="line-removed">- instruct vadd2D(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVD dst src));</span>
<span class="line-removed">-   format %{ &quot;addpd   $dst,$src\t! add packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ addpd($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd2D_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVD src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vaddpd  $dst,$src1,$src2\t! add packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vaddpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd2D_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVD src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vaddpd  $dst,$src,$mem\t! add packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vaddpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4D_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVD src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vaddpd  $dst,$src1,$src2\t! add packed4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vaddpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4D_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVD src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vaddpd  $dst,$src,$mem\t! add packed4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vaddpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8D_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVD src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vaddpd  $dst,$src1,$src2\t! add packed8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vaddpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8D_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (AddVD src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vaddpd  $dst,$src,$mem\t! add packed8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vaddpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // --------------------------------- SUB --------------------------------------</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Bytes vector sub</span>
<span class="line-removed">- instruct vsub4B(vecS dst, vecS src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVB dst src));</span>
<span class="line-removed">-   format %{ &quot;psubb   $dst,$src\t! sub packed4B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psubb($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4B_reg(vecS dst, vecS src1, vecS src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVB src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubb  $dst,$src1,$src2\t! sub packed4B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubb($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4B_mem(vecS dst, vecS src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVB src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubb  $dst,$src,$mem\t! sub packed4B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubb($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8B(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVB dst src));</span>
<span class="line-removed">-   format %{ &quot;psubb   $dst,$src\t! sub packed8B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psubb($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8B_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVB src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubb  $dst,$src1,$src2\t! sub packed8B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubb($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8B_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVB src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubb  $dst,$src,$mem\t! sub packed8B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubb($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub16B(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (SubVB dst src));</span>
<span class="line-removed">-   format %{ &quot;psubb   $dst,$src\t! sub packed16B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psubb($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub16B_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (SubVB src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubb  $dst,$src1,$src2\t! sub packed16B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubb($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub16B_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (SubVB src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubb  $dst,$src,$mem\t! sub packed16B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubb($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub32B_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (SubVB src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubb  $dst,$src1,$src2\t! sub packed32B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsubb($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub32B_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (SubVB src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubb  $dst,$src,$mem\t! sub packed32B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsubb($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub64B_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 64);</span>
<span class="line-removed">-   match(Set dst (SubVB src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubb  $dst,$src1,$src2\t! sub packed64B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpsubb($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub64B_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 64);</span>
<span class="line-removed">-   match(Set dst (SubVB src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubb  $dst,$src,$mem\t! sub packed64B&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpsubb($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Shorts/Chars vector sub</span>
<span class="line-removed">- instruct vsub2S(vecS dst, vecS src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVS dst src));</span>
<span class="line-removed">-   format %{ &quot;psubw   $dst,$src\t! sub packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psubw($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub2S_reg(vecS dst, vecS src1, vecS src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubw  $dst,$src1,$src2\t! sub packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub2S_mem(vecS dst, vecS src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubw  $dst,$src,$mem\t! sub packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4S(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVS dst src));</span>
<span class="line-removed">-   format %{ &quot;psubw   $dst,$src\t! sub packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psubw($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4S_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubw  $dst,$src1,$src2\t! sub packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4S_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubw  $dst,$src,$mem\t! sub packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8S(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVS dst src));</span>
<span class="line-removed">-   format %{ &quot;psubw   $dst,$src\t! sub packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psubw($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8S_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubw  $dst,$src1,$src2\t! sub packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8S_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubw  $dst,$src,$mem\t! sub packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub16S_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (SubVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubw  $dst,$src1,$src2\t! sub packed16S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsubw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub16S_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (SubVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubw  $dst,$src,$mem\t! sub packed16S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsubw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub32S_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (SubVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubw  $dst,$src1,$src2\t! sub packed32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpsubw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub32S_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (SubVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubw  $dst,$src,$mem\t! sub packed32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpsubw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Integers vector sub</span>
<span class="line-removed">- instruct vsub2I(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVI dst src));</span>
<span class="line-removed">-   format %{ &quot;psubd   $dst,$src\t! sub packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psubd($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub2I_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubd  $dst,$src1,$src2\t! sub packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub2I_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVI src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubd  $dst,$src,$mem\t! sub packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4I(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVI dst src));</span>
<span class="line-removed">-   format %{ &quot;psubd   $dst,$src\t! sub packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psubd($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4I_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubd  $dst,$src1,$src2\t! sub packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4I_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVI src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubd  $dst,$src,$mem\t! sub packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8I_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubd  $dst,$src1,$src2\t! sub packed8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsubd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8I_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVI src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubd  $dst,$src,$mem\t! sub packed8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsubd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub16I_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (SubVI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubd  $dst,$src1,$src2\t! sub packed16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpsubd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub16I_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (SubVI src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubd  $dst,$src,$mem\t! sub packed16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpsubd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Longs vector sub</span>
<span class="line-removed">- instruct vsub2L(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVL dst src));</span>
<span class="line-removed">-   format %{ &quot;psubq   $dst,$src\t! sub packed2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psubq($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub2L_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVL src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubq  $dst,$src1,$src2\t! sub packed2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub2L_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVL src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubq  $dst,$src,$mem\t! sub packed2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsubq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4L_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVL src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubq  $dst,$src1,$src2\t! sub packed4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsubq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4L_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVL src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubq  $dst,$src,$mem\t! sub packed4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsubq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8L_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVL src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpsubq  $dst,$src1,$src2\t! sub packed8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpsubq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8L_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVL src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpsubq  $dst,$src,$mem\t! sub packed8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpsubq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Floats vector sub</span>
<span class="line-removed">- instruct vsub2F(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVF dst src));</span>
<span class="line-removed">-   format %{ &quot;subps   $dst,$src\t! sub packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ subps($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub2F_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vsubps  $dst,$src1,$src2\t! sub packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vsubps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub2F_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsubps  $dst,$src,$mem\t! sub packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vsubps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4F(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVF dst src));</span>
<span class="line-removed">-   format %{ &quot;subps   $dst,$src\t! sub packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ subps($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4F_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vsubps  $dst,$src1,$src2\t! sub packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vsubps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4F_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsubps  $dst,$src,$mem\t! sub packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vsubps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8F_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vsubps  $dst,$src1,$src2\t! sub packed8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vsubps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8F_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsubps  $dst,$src,$mem\t! sub packed8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vsubps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub16F_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (SubVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vsubps  $dst,$src1,$src2\t! sub packed16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vsubps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub16F_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (SubVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsubps  $dst,$src,$mem\t! sub packed16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vsubps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Doubles vector sub</span>
<span class="line-removed">- instruct vsub2D(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVD dst src));</span>
<span class="line-removed">-   format %{ &quot;subpd   $dst,$src\t! sub packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ subpd($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub2D_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVD src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vsubpd  $dst,$src1,$src2\t! sub packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vsubpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub2D_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SubVD src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsubpd  $dst,$src,$mem\t! sub packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vsubpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4D_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVD src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vsubpd  $dst,$src1,$src2\t! sub packed4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vsubpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub4D_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SubVD src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsubpd  $dst,$src,$mem\t! sub packed4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vsubpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8D_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVD src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vsubpd  $dst,$src1,$src2\t! sub packed8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vsubpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsub8D_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SubVD src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsubpd  $dst,$src,$mem\t! sub packed8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vsubpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // --------------------------------- MUL --------------------------------------</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Shorts/Chars vector mul</span>
<span class="line-removed">- instruct vmul2S(vecS dst, vecS src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulVS dst src));</span>
<span class="line-removed">-   format %{ &quot;pmullw $dst,$src\t! mul packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pmullw($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul2S_reg(vecS dst, vecS src1, vecS src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmullw $dst,$src1,$src2\t! mul packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmullw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul2S_mem(vecS dst, vecS src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpmullw $dst,$src,$mem\t! mul packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmullw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4S(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (MulVS dst src));</span>
<span class="line-removed">-   format %{ &quot;pmullw  $dst,$src\t! mul packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pmullw($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4S_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (MulVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmullw $dst,$src1,$src2\t! mul packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmullw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4S_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (MulVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpmullw $dst,$src,$mem\t! mul packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmullw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul8S(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (MulVS dst src));</span>
<span class="line-removed">-   format %{ &quot;pmullw  $dst,$src\t! mul packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pmullw($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul8S_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (MulVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmullw $dst,$src1,$src2\t! mul packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmullw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul8S_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (MulVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpmullw $dst,$src,$mem\t! mul packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmullw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul16S_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (MulVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmullw $dst,$src1,$src2\t! mul packed16S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpmullw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul16S_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (MulVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpmullw $dst,$src,$mem\t! mul packed16S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpmullw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul32S_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (MulVS src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmullw $dst,$src1,$src2\t! mul packed32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpmullw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul32S_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (MulVS src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpmullw $dst,$src,$mem\t! mul packed32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpmullw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Integers vector mul (sse4_1)</span>
<span class="line-removed">- instruct vmul2I(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt; 3 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulVI dst src));</span>
<span class="line-removed">-   format %{ &quot;pmulld  $dst,$src\t! mul packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pmulld($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul2I_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulVI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmulld $dst,$src1,$src2\t! mul packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmulld($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul2I_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulVI src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpmulld $dst,$src,$mem\t! mul packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmulld($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4I(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt; 3 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (MulVI dst src));</span>
<span class="line-removed">-   format %{ &quot;pmulld  $dst,$src\t! mul packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pmulld($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4I_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (MulVI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmulld $dst,$src1,$src2\t! mul packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmulld($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4I_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (MulVI src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpmulld $dst,$src,$mem\t! mul packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmulld($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul2L_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; VM_Version::supports_avx512dq());</span>
<span class="line-removed">-   match(Set dst (MulVL src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmullq $dst,$src1,$src2\t! mul packed2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmullq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul2L_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; VM_Version::supports_avx512dq());</span>
<span class="line-removed">-   match(Set dst (MulVL src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpmullq $dst,$src,$mem\t! mul packed2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmullq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4L_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; VM_Version::supports_avx512dq());</span>
<span class="line-removed">-   match(Set dst (MulVL src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmullq $dst,$src1,$src2\t! mul packed4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpmullq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4L_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; VM_Version::supports_avx512dq());</span>
<span class="line-removed">-   match(Set dst (MulVL src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpmullq $dst,$src,$mem\t! mul packed4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpmullq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul8L_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; VM_Version::supports_avx512dq());</span>
<span class="line-removed">-   match(Set dst (MulVL src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmullq $dst,$src1,$src2\t! mul packed8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpmullq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul8L_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; VM_Version::supports_avx512dq());</span>
<span class="line-removed">-   match(Set dst (MulVL src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpmullq $dst,$src,$mem\t! mul packed8L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpmullq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul8I_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (MulVI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmulld $dst,$src1,$src2\t! mul packed8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpmulld($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul8I_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (MulVI src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpmulld $dst,$src,$mem\t! mul packed8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpmulld($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul16I_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (MulVI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmulld $dst,$src1,$src2\t! mul packed16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpmulld($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul16I_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (MulVI src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vpmulld $dst,$src,$mem\t! mul packed16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpmulld($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Floats vector mul</span>
<span class="line-removed">- instruct vmul2F(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulVF dst src));</span>
<span class="line-removed">-   format %{ &quot;mulps   $dst,$src\t! mul packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ mulps($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul2F_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vmulps  $dst,$src1,$src2\t! mul packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vmulps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul2F_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vmulps  $dst,$src,$mem\t! mul packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vmulps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4F(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (MulVF dst src));</span>
<span class="line-removed">-   format %{ &quot;mulps   $dst,$src\t! mul packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ mulps($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4F_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (MulVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vmulps  $dst,$src1,$src2\t! mul packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vmulps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4F_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (MulVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vmulps  $dst,$src,$mem\t! mul packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vmulps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul8F_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (MulVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vmulps  $dst,$src1,$src2\t! mul packed8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vmulps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul8F_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (MulVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vmulps  $dst,$src,$mem\t! mul packed8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vmulps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul16F_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (MulVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vmulps  $dst,$src1,$src2\t! mul packed16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vmulps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul16F_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (MulVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vmulps  $dst,$src,$mem\t! mul packed16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vmulps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Doubles vector mul</span>
<span class="line-removed">- instruct vmul2D(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulVD dst src));</span>
<span class="line-removed">-   format %{ &quot;mulpd   $dst,$src\t! mul packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ mulpd($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul2D_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulVD src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vmulpd  $dst,$src1,$src2\t! mul packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vmulpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul2D_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulVD src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vmulpd  $dst,$src,$mem\t! mul packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vmulpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4D_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (MulVD src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vmulpd  $dst,$src1,$src2\t! mul packed4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vmulpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4D_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (MulVD src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vmulpd  $dst,$src,$mem\t! mul packed4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vmulpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul8D_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (MulVD src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vmulpd  $dst k0,$src1,$src2\t! mul packed8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vmulpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul8D_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (MulVD src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vmulpd  $dst k0,$src,$mem\t! mul packed8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vmulpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vcmov8F_reg(legVecY dst, legVecY src1, legVecY src2, immI8 cop, cmpOp_vcmppd copnd) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (CMoveVF (Binary copnd cop) (Binary src1 src2)));</span>
<span class="line-removed">-   effect(TEMP dst, USE src1, USE src2);</span>
<span class="line-removed">-   format %{ &quot;cmpps.$copnd  $dst, $src1, $src2  ! vcmovevf, cond=$cop\n\t&quot;</span>
<span class="line-removed">-             &quot;blendvps $dst,$src1,$src2,$dst ! vcmovevf\n\t&quot;</span>
<span class="line-removed">-          %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     int cond = (Assembler::Condition)($copnd$$cmpcode);</span>
<span class="line-removed">-     __ cmpps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cond, vector_len);</span>
<span class="line-removed">-     __ blendvps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vcmov4D_reg(legVecY dst, legVecY src1, legVecY src2, immI8 cop, cmpOp_vcmppd copnd) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (CMoveVD (Binary copnd cop) (Binary src1 src2)));</span>
<span class="line-removed">-   effect(TEMP dst, USE src1, USE src2);</span>
<span class="line-removed">-   format %{ &quot;cmppd.$copnd  $dst, $src1, $src2  ! vcmovevd, cond=$cop\n\t&quot;</span>
<span class="line-removed">-             &quot;blendvpd $dst,$src1,$src2,$dst ! vcmovevd\n\t&quot;</span>
<span class="line-removed">-          %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     int cond = (Assembler::Condition)($copnd$$cmpcode);</span>
<span class="line-removed">-     __ cmppd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cond, vector_len);</span>
<span class="line-removed">-     __ blendvpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // --------------------------------- DIV --------------------------------------</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Floats vector div</span>
<span class="line-removed">- instruct vdiv2F(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (DivVF dst src));</span>
<span class="line-removed">-   format %{ &quot;divps   $dst,$src\t! div packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ divps($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv2F_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (DivVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vdivps  $dst,$src1,$src2\t! div packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vdivps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv2F_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (DivVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vdivps  $dst,$src,$mem\t! div packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vdivps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv4F(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (DivVF dst src));</span>
<span class="line-removed">-   format %{ &quot;divps   $dst,$src\t! div packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ divps($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv4F_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (DivVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vdivps  $dst,$src1,$src2\t! div packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vdivps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv4F_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (DivVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vdivps  $dst,$src,$mem\t! div packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vdivps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv8F_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (DivVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vdivps  $dst,$src1,$src2\t! div packed8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vdivps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv8F_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (DivVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vdivps  $dst,$src,$mem\t! div packed8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vdivps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv16F_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (DivVF src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vdivps  $dst,$src1,$src2\t! div packed16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vdivps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv16F_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (DivVF src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vdivps  $dst,$src,$mem\t! div packed16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vdivps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Doubles vector div</span>
<span class="line-removed">- instruct vdiv2D(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (DivVD dst src));</span>
<span class="line-removed">-   format %{ &quot;divpd   $dst,$src\t! div packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ divpd($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv2D_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (DivVD src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vdivpd  $dst,$src1,$src2\t! div packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vdivpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv2D_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (DivVD src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vdivpd  $dst,$src,$mem\t! div packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vdivpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv4D_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (DivVD src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vdivpd  $dst,$src1,$src2\t! div packed4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vdivpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv4D_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (DivVD src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vdivpd  $dst,$src,$mem\t! div packed4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vdivpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv8D_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (DivVD src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vdivpd  $dst,$src1,$src2\t! div packed8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vdivpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vdiv8D_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (DivVD src (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vdivpd  $dst,$src,$mem\t! div packed8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vdivpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // ------------------------------ Shift ---------------------------------------</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Left and right shift count vectors are the same on x86</span>
<span class="line-removed">- // (only lowest bits of xmm reg are used for count).</span>
<span class="line-removed">- instruct vshiftcnt(vecS dst, rRegI cnt) %{</span>
<span class="line-removed">-   match(Set dst (LShiftCntV cnt));</span>
<span class="line-removed">-   match(Set dst (RShiftCntV cnt));</span>
<span class="line-removed">-   format %{ &quot;movd    $dst,$cnt\t! load shift count&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $cnt$$Register);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // --------------------------------- Sqrt --------------------------------------</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Floating point vector sqrt</span>
<span class="line-removed">- instruct vsqrt2D_reg(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SqrtVD src));</span>
<span class="line-removed">-   format %{ &quot;vsqrtpd  $dst,$src\t! sqrt packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vsqrtpd($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt2D_mem(vecX dst, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SqrtVD (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsqrtpd  $dst,$mem\t! sqrt packed2D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vsqrtpd($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt4D_reg(vecY dst, vecY src) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SqrtVD src));</span>
<span class="line-removed">-   format %{ &quot;vsqrtpd  $dst,$src\t! sqrt packed4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vsqrtpd($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt4D_mem(vecY dst, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SqrtVD (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsqrtpd  $dst,$mem\t! sqrt packed4D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vsqrtpd($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt8D_reg(vecZ dst, vecZ src) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SqrtVD src));</span>
<span class="line-removed">-   format %{ &quot;vsqrtpd  $dst,$src\t! sqrt packed8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vsqrtpd($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt8D_mem(vecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SqrtVD (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsqrtpd  $dst,$mem\t! sqrt packed8D&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vsqrtpd($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt2F_reg(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SqrtVF src));</span>
<span class="line-removed">-   format %{ &quot;vsqrtps  $dst,$src\t! sqrt packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vsqrtps($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt2F_mem(vecD dst, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (SqrtVF (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsqrtps  $dst,$mem\t! sqrt packed2F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vsqrtps($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt4F_reg(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SqrtVF src));</span>
<span class="line-removed">-   format %{ &quot;vsqrtps  $dst,$src\t! sqrt packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vsqrtps($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt4F_mem(vecX dst, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (SqrtVF (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsqrtps  $dst,$mem\t! sqrt packed4F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vsqrtps($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt8F_reg(vecY dst, vecY src) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SqrtVF src));</span>
<span class="line-removed">-   format %{ &quot;vsqrtps  $dst,$src\t! sqrt packed8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vsqrtps($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt8F_mem(vecY dst, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (SqrtVF (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsqrtps  $dst,$mem\t! sqrt packed8F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vsqrtps($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt16F_reg(vecZ dst, vecZ src) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (SqrtVF src));</span>
<span class="line-removed">-   format %{ &quot;vsqrtps  $dst,$src\t! sqrt packed16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vsqrtps($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsqrt16F_mem(vecZ dst, memory mem) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (SqrtVF (LoadVector mem)));</span>
<span class="line-removed">-   format %{ &quot;vsqrtps  $dst,$mem\t! sqrt packed16F&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vsqrtps($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // ------------------------------ LeftShift -----------------------------------</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Shorts/Chars vector left shift</span>
<span class="line-removed">- instruct vsll2S(vecS dst, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (LShiftVS dst shift));</span>
<span class="line-removed">-   format %{ &quot;psllw   $dst,$shift\t! left shift packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psllw($dst$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll2S_imm(vecS dst, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (LShiftVS dst shift));</span>
<span class="line-removed">-   format %{ &quot;psllw   $dst,$shift\t! left shift packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psllw($dst$$XMMRegister, (int)$shift$$constant);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll2S_reg(vecS dst, vecS src, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsllw  $dst,$src,$shift\t! left shift packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsllw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll2S_reg_imm(vecS dst, vecS src, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsllw  $dst,$src,$shift\t! left shift packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsllw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll4S(vecD dst, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (LShiftVS dst shift));</span>
<span class="line-removed">-   format %{ &quot;psllw   $dst,$shift\t! left shift packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psllw($dst$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll4S_imm(vecD dst, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (LShiftVS dst shift));</span>
<span class="line-removed">-   format %{ &quot;psllw   $dst,$shift\t! left shift packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psllw($dst$$XMMRegister, (int)$shift$$constant);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll4S_reg(vecD dst, vecD src, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsllw  $dst,$src,$shift\t! left shift packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsllw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll4S_reg_imm(vecD dst, vecD src, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsllw  $dst,$src,$shift\t! left shift packed4S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsllw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll8S(vecX dst, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (LShiftVS dst shift));</span>
<span class="line-removed">-   format %{ &quot;psllw   $dst,$shift\t! left shift packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psllw($dst$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll8S_imm(vecX dst, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (LShiftVS dst shift));</span>
<span class="line-removed">-   format %{ &quot;psllw   $dst,$shift\t! left shift packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ psllw($dst$$XMMRegister, (int)$shift$$constant);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll8S_reg(vecX dst, vecX src, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsllw  $dst,$src,$shift\t! left shift packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsllw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll8S_reg_imm(vecX dst, vecX src, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsllw  $dst,$src,$shift\t! left shift packed8S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsllw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll16S_reg(vecY dst, vecY src, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsllw  $dst,$src,$shift\t! left shift packed16S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsllw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll16S_reg_imm(vecY dst, vecY src, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsllw  $dst,$src,$shift\t! left shift packed16S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsllw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll32S_reg(vecZ dst, vecZ src, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsllw  $dst,$src,$shift\t! left shift packed32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpsllw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll32S_reg_imm(vecZ dst, vecZ src, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsllw  $dst,$src,$shift\t! left shift packed32S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpsllw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Integers vector left shift</span>
<span class="line-removed">- instruct vsll2I(vecD dst, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (LShiftVI dst shift));</span>
<span class="line-removed">-   format %{ &quot;pslld   $dst,$shift\t! left shift packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pslld($dst$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll2I_imm(vecD dst, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (LShiftVI dst shift));</span>
<span class="line-removed">-   format %{ &quot;pslld   $dst,$shift\t! left shift packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pslld($dst$$XMMRegister, (int)$shift$$constant);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll2I_reg(vecD dst, vecD src, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (LShiftVI src shift));</span>
<span class="line-removed">-   format %{ &quot;vpslld  $dst,$src,$shift\t! left shift packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpslld($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll2I_reg_imm(vecD dst, vecD src, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (LShiftVI src shift));</span>
<span class="line-removed">-   format %{ &quot;vpslld  $dst,$src,$shift\t! left shift packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpslld($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll4I(vecX dst, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (LShiftVI dst shift));</span>
<span class="line-removed">-   format %{ &quot;pslld   $dst,$shift\t! left shift packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pslld($dst$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll4I_imm(vecX dst, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (LShiftVI dst shift));</span>
<span class="line-removed">-   format %{ &quot;pslld   $dst,$shift\t! left shift packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pslld($dst$$XMMRegister, (int)$shift$$constant);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll4I_reg(vecX dst, vecX src, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (LShiftVI src shift));</span>
<span class="line-removed">-   format %{ &quot;vpslld  $dst,$src,$shift\t! left shift packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpslld($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll4I_reg_imm(vecX dst, vecX src, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (LShiftVI src shift));</span>
<span class="line-removed">-   format %{ &quot;vpslld  $dst,$src,$shift\t! left shift packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpslld($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll8I_reg(vecY dst, vecY src, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (LShiftVI src shift));</span>
<span class="line-removed">-   format %{ &quot;vpslld  $dst,$src,$shift\t! left shift packed8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpslld($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vsll8I_reg_imm(vecY dst, vecY src, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (LShiftVI src shift));</span>
<span class="line-removed">-   format %{ &quot;vpslld  $dst,$src,$shift\t! left shift packed8I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vpslld($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsll16I_reg(vecZ dst, vecZ src, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (LShiftVI src shift));</span>
<span class="line-removed">-   format %{ &quot;vpslld  $dst,$src,$shift\t! left shift packed16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vpslld($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
  
<span class="line-modified">! instruct vsll16I_reg_imm(vecZ dst, vecZ src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-modified">!   match(Set dst (LShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpslld  $dst,$src,$shift\t! left shift packed16I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpslld($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Longs vector left shift</span>
<span class="line-modified">! instruct vsll2L(vecX dst, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (LShiftVL dst shift));</span>
<span class="line-modified">!   format %{ &quot;psllq   $dst,$shift\t! left shift packed2L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psllq($dst$$XMMRegister, $shift$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsll2L_imm(vecX dst, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (LShiftVL dst shift));</span>
<span class="line-modified">!   format %{ &quot;psllq   $dst,$shift\t! left shift packed2L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psllq($dst$$XMMRegister, (int)$shift$$constant);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsll2L_reg(vecX dst, vecX src, vecS shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (LShiftVL src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsllq  $dst,$src,$shift\t! left shift packed2L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsllq($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
  
<span class="line-modified">! instruct vsll2L_reg_imm(vecX dst, vecX src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (LShiftVL src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsllq  $dst,$src,$shift\t! left shift packed2L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsllq($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsll4L_reg(vecY dst, vecY src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (LShiftVL src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsllq  $dst,$src,$shift\t! left shift packed4L&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vpsllq($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-removed">- instruct vsll4L_reg_imm(vecY dst, vecY src, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (LShiftVL src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsllq  $dst,$src,$shift\t! left shift packed4L&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsllq($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
  
<span class="line-modified">! instruct vsll8L_reg(vecZ dst, vecZ src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (LShiftVL src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsllq  $dst,$src,$shift\t! left shift packed8L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpsllq($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsll8L_reg_imm(vecZ dst, vecZ src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (LShiftVL src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsllq  $dst,$src,$shift\t! left shift packed8L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpsllq($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // ----------------------- LogicalRightShift -----------------------------------</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Shorts vector logical right shift produces incorrect Java result</span>
<span class="line-removed">- // for negative data because java code convert short value into int with</span>
<span class="line-removed">- // sign extension before a shift. But char vectors are fine since chars are</span>
<span class="line-removed">- // unsigned values.</span>
  
<span class="line-modified">! instruct vsrl2S(vecS dst, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (URShiftVS dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrlw   $dst,$shift\t! logical right shift packed2S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrlw($dst$$XMMRegister, $shift$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl2S_imm(vecS dst, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (URShiftVS dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrlw   $dst,$shift\t! logical right shift packed2S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrlw($dst$$XMMRegister, (int)$shift$$constant);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl2S_reg(vecS dst, vecS src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (URShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlw  $dst,$src,$shift\t! logical right shift packed2S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsrlw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl2S_reg_imm(vecS dst, vecS src, immI8 shift) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (URShiftVS src shift));</span>
<span class="line-removed">-   format %{ &quot;vpsrlw  $dst,$src,$shift\t! logical right shift packed2S&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsrlw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
  
<span class="line-modified">! instruct vsrl4S(vecD dst, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (URShiftVS dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrlw   $dst,$shift\t! logical right shift packed4S&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ psrlw($dst$$XMMRegister, $shift$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl4S_imm(vecD dst, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (URShiftVS dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrlw   $dst,$shift\t! logical right shift packed4S&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ psrlw($dst$$XMMRegister, (int)$shift$$constant);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl4S_reg(vecD dst, vecD src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (URShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlw  $dst,$src,$shift\t! logical right shift packed4S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsrlw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl4S_reg_imm(vecD dst, vecD src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (URShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlw  $dst,$src,$shift\t! logical right shift packed4S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsrlw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl8S(vecX dst, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (URShiftVS dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrlw   $dst,$shift\t! logical right shift packed8S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrlw($dst$$XMMRegister, $shift$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl8S_imm(vecX dst, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (URShiftVS dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrlw   $dst,$shift\t! logical right shift packed8S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrlw($dst$$XMMRegister, (int)$shift$$constant);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl8S_reg(vecX dst, vecX src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (URShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlw  $dst,$src,$shift\t! logical right shift packed8S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsrlw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl8S_reg_imm(vecX dst, vecX src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (URShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlw  $dst,$src,$shift\t! logical right shift packed8S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsrlw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl16S_reg(vecY dst, vecY src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-modified">!   match(Set dst (URShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlw  $dst,$src,$shift\t! logical right shift packed16S&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vpsrlw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl16S_reg_imm(vecY dst, vecY src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-modified">!   match(Set dst (URShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlw  $dst,$src,$shift\t! logical right shift packed16S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vpsrlw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl32S_reg(vecZ dst, vecZ src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-modified">!   match(Set dst (URShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlw  $dst,$src,$shift\t! logical right shift packed32S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpsrlw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl32S_reg_imm(vecZ dst, vecZ src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-modified">!   match(Set dst (URShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlw  $dst,$src,$shift\t! logical right shift packed32S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpsrlw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Integers vector logical right shift</span>
<span class="line-modified">! instruct vsrl2I(vecD dst, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (URShiftVI dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrld   $dst,$shift\t! logical right shift packed2I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrld($dst$$XMMRegister, $shift$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl2I_imm(vecD dst, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (URShiftVI dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrld   $dst,$shift\t! logical right shift packed2I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrld($dst$$XMMRegister, (int)$shift$$constant);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl2I_reg(vecD dst, vecD src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (URShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrld  $dst,$src,$shift\t! logical right shift packed2I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsrld($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl2I_reg_imm(vecD dst, vecD src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (URShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrld  $dst,$src,$shift\t! logical right shift packed2I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsrld($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl4I(vecX dst, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (URShiftVI dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrld   $dst,$shift\t! logical right shift packed4I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrld($dst$$XMMRegister, $shift$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl4I_imm(vecX dst, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (URShiftVI dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrld   $dst,$shift\t! logical right shift packed4I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrld($dst$$XMMRegister, (int)$shift$$constant);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl4I_reg(vecX dst, vecX src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (URShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrld  $dst,$src,$shift\t! logical right shift packed4I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsrld($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl4I_reg_imm(vecX dst, vecX src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (URShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrld  $dst,$src,$shift\t! logical right shift packed4I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsrld($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl8I_reg(vecY dst, vecY src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (URShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrld  $dst,$src,$shift\t! logical right shift packed8I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsrld($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl8I_reg_imm(vecY dst, vecY src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (URShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrld  $dst,$src,$shift\t! logical right shift packed8I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vpsrld($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl16I_reg(vecZ dst, vecZ src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-modified">!   match(Set dst (URShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrld  $dst,$src,$shift\t! logical right shift packed16I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpsrld($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl16I_reg_imm(vecZ dst, vecZ src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-modified">!   match(Set dst (URShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrld  $dst,$src,$shift\t! logical right shift packed16I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-removed">-     __ vpsrld($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Longs vector logical right shift</span>
<span class="line-modified">! instruct vsrl2L(vecX dst, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (URShiftVL dst shift));</span>
<span class="line-removed">-   format %{ &quot;psrlq   $dst,$shift\t! logical right shift packed2L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrlq($dst$$XMMRegister, $shift$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl2L_imm(vecX dst, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (URShiftVL dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrlq   $dst,$shift\t! logical right shift packed2L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrlq($dst$$XMMRegister, (int)$shift$$constant);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl2L_reg(vecX dst, vecX src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (URShiftVL src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlq  $dst,$src,$shift\t! logical right shift packed2L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsrlq($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl2L_reg_imm(vecX dst, vecX src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (URShiftVL src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlq  $dst,$src,$shift\t! logical right shift packed2L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsrlq($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl4L_reg(vecY dst, vecY src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (URShiftVL src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlq  $dst,$src,$shift\t! logical right shift packed4L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vpsrlq($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl4L_reg_imm(vecY dst, vecY src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (URShiftVL src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlq  $dst,$src,$shift\t! logical right shift packed4L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsrlq($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl8L_reg(vecZ dst, vecZ src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (URShiftVL src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlq  $dst,$src,$shift\t! logical right shift packed8L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpsrlq($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsrl8L_reg_imm(vecZ dst, vecZ src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (URShiftVL src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrlq  $dst,$src,$shift\t! logical right shift packed8L&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpsrlq($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // ------------------- ArithmeticRightShift -----------------------------------</span>
  
<span class="line-modified">! // Shorts/Chars vector arithmetic right shift</span>
<span class="line-modified">! instruct vsra2S(vecS dst, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (RShiftVS dst shift));</span>
<span class="line-modified">!   format %{ &quot;psraw   $dst,$shift\t! arithmetic right shift packed2S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psraw($dst$$XMMRegister, $shift$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra2S_imm(vecS dst, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (RShiftVS dst shift));</span>
<span class="line-modified">!   format %{ &quot;psraw   $dst,$shift\t! arithmetic right shift packed2S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psraw($dst$$XMMRegister, (int)$shift$$constant);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra2S_reg(vecS dst, vecS src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (RShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsraw  $dst,$src,$shift\t! arithmetic right shift packed2S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsraw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra2S_reg_imm(vecS dst, vecS src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (RShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsraw  $dst,$src,$shift\t! arithmetic right shift packed2S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsraw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra4S(vecD dst, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (RShiftVS dst shift));</span>
<span class="line-modified">!   format %{ &quot;psraw   $dst,$shift\t! arithmetic right shift packed4S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psraw($dst$$XMMRegister, $shift$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra4S_imm(vecD dst, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (RShiftVS dst shift));</span>
<span class="line-modified">!   format %{ &quot;psraw   $dst,$shift\t! arithmetic right shift packed4S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psraw($dst$$XMMRegister, (int)$shift$$constant);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra4S_reg(vecD dst, vecD src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (RShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsraw  $dst,$src,$shift\t! arithmetic right shift packed4S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsraw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra4S_reg_imm(vecD dst, vecD src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (RShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsraw  $dst,$src,$shift\t! arithmetic right shift packed4S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsraw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra8S(vecX dst, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (RShiftVS dst shift));</span>
<span class="line-modified">!   format %{ &quot;psraw   $dst,$shift\t! arithmetic right shift packed8S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psraw($dst$$XMMRegister, $shift$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra8S_imm(vecX dst, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (RShiftVS dst shift));</span>
<span class="line-modified">!   format %{ &quot;psraw   $dst,$shift\t! arithmetic right shift packed8S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psraw($dst$$XMMRegister, (int)$shift$$constant);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra8S_reg(vecX dst, vecX src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (RShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsraw  $dst,$src,$shift\t! arithmetic right shift packed8S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsraw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra8S_reg_imm(vecX dst, vecX src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (RShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsraw  $dst,$src,$shift\t! arithmetic right shift packed8S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsraw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra16S_reg(vecY dst, vecY src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-modified">!   match(Set dst (RShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsraw  $dst,$src,$shift\t! arithmetic right shift packed16S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-removed">-     __ vpsraw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra16S_reg_imm(vecY dst, vecY src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-modified">!   match(Set dst (RShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsraw  $dst,$src,$shift\t! arithmetic right shift packed16S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vpsraw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra32S_reg(vecZ dst, vecZ src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-modified">!   match(Set dst (RShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsraw  $dst,$src,$shift\t! arithmetic right shift packed32S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpsraw($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra32S_reg_imm(vecZ dst, vecZ src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512bw() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-modified">!   match(Set dst (RShiftVS src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsraw  $dst,$src,$shift\t! arithmetic right shift packed32S&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-removed">-     __ vpsraw($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Integers vector arithmetic right shift</span>
<span class="line-modified">! instruct vsra2I(vecD dst, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (RShiftVI dst shift));</span>
<span class="line-removed">-   format %{ &quot;psrad   $dst,$shift\t! arithmetic right shift packed2I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrad($dst$$XMMRegister, $shift$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra2I_imm(vecD dst, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (RShiftVI dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrad   $dst,$shift\t! arithmetic right shift packed2I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrad($dst$$XMMRegister, (int)$shift$$constant);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra2I_reg(vecD dst, vecD src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (RShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrad  $dst,$src,$shift\t! arithmetic right shift packed2I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsrad($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra2I_reg_imm(vecD dst, vecD src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (RShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrad  $dst,$src,$shift\t! arithmetic right shift packed2I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsrad($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra4I(vecX dst, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (RShiftVI dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrad   $dst,$shift\t! arithmetic right shift packed4I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psrad($dst$$XMMRegister, $shift$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra4I_imm(vecX dst, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (RShiftVI dst shift));</span>
<span class="line-modified">!   format %{ &quot;psrad   $dst,$shift\t! arithmetic right shift packed4I&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     __ psrad($dst$$XMMRegister, (int)$shift$$constant);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra4I_reg(vecX dst, vecX src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (RShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrad  $dst,$src,$shift\t! arithmetic right shift packed4I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-removed">-     __ vpsrad($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra4I_reg_imm(vecX dst, vecX src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (RShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrad  $dst,$src,$shift\t! arithmetic right shift packed4I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpsrad($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra8I_reg(vecY dst, vecY src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (RShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrad  $dst,$src,$shift\t! arithmetic right shift packed8I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vpsrad($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra8I_reg_imm(vecY dst, vecY src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (RShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrad  $dst,$src,$shift\t! arithmetic right shift packed8I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vpsrad($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra16I_reg(vecZ dst, vecZ src, vecS shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-modified">!   match(Set dst (RShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrad  $dst,$src,$shift\t! arithmetic right shift packed16I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpsrad($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsra16I_reg_imm(vecZ dst, vecZ src, immI8 shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-modified">!   match(Set dst (RShiftVI src shift));</span>
<span class="line-modified">!   format %{ &quot;vpsrad  $dst,$src,$shift\t! arithmetic right shift packed16I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpsrad($dst$$XMMRegister, $src$$XMMRegister, (int)$shift$$constant, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // There are no longs vector arithmetic right shift instructions.</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">! // --------------------------------- AND --------------------------------------</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vand4B(vecS dst, vecS src) %{</span>
<span class="line-removed">-   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 4);</span>
<span class="line-removed">-   match(Set dst (AndV dst src));</span>
<span class="line-removed">-   format %{ &quot;pand    $dst,$src\t! and vectors (4 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ pand($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand4B_reg(vecS dst, vecS src1, vecS src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 4);</span>
<span class="line-modified">!   match(Set dst (AndV src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpand   $dst,$src1,$src2\t! and vectors (4 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpand($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand4B_mem(vecS dst, vecS src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 4);</span>
<span class="line-modified">!   match(Set dst (AndV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpand   $dst,$src,$mem\t! and vectors (4 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-removed">-     __ vpand($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand8B(vecD dst, vecD src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 8);</span>
<span class="line-modified">!   match(Set dst (AndV dst src));</span>
<span class="line-modified">!   format %{ &quot;pand    $dst,$src\t! and vectors (8 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ pand($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand8B_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 8);</span>
<span class="line-modified">!   match(Set dst (AndV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpand   $dst,$src1,$src2\t! and vectors (8 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpand($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand8B_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 8);</span>
<span class="line-modified">!   match(Set dst (AndV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpand   $dst,$src,$mem\t! and vectors (8 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-removed">-     __ vpand($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand16B(vecX dst, vecX src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 16);</span>
<span class="line-modified">!   match(Set dst (AndV dst src));</span>
<span class="line-modified">!   format %{ &quot;pand    $dst,$src\t! and vectors (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ pand($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand16B_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 16);</span>
<span class="line-modified">!   match(Set dst (AndV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpand   $dst,$src1,$src2\t! and vectors (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpand($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand16B_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 16);</span>
<span class="line-modified">!   match(Set dst (AndV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpand   $dst,$src,$mem\t! and vectors (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpand($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand32B_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 32);</span>
<span class="line-modified">!   match(Set dst (AndV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpand   $dst,$src1,$src2\t! and vectors (32 bytes)&quot; %}</span>
    ins_encode %{
      int vector_len = 1;
<span class="line-modified">!     __ vpand($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand32B_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 32);</span>
<span class="line-modified">!   match(Set dst (AndV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpand   $dst,$src,$mem\t! and vectors (32 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-removed">-     __ vpand($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand64B_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 64);</span>
<span class="line-modified">!   match(Set dst (AndV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpand   $dst,$src1,$src2\t! and vectors (64 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpand($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand64B_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 64);</span>
<span class="line-modified">!   match(Set dst (AndV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpand   $dst,$src,$mem\t! and vectors (64 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpand($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // --------------------------------- OR ---------------------------------------</span>
<span class="line-modified">! </span>
<span class="line-modified">! instruct vor4B(vecS dst, vecS src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 4);</span>
<span class="line-modified">!   match(Set dst (OrV dst src));</span>
<span class="line-removed">-   format %{ &quot;por     $dst,$src\t! or vectors (4 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ por($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor4B_reg(vecS dst, vecS src1, vecS src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 4);</span>
<span class="line-modified">!   match(Set dst (OrV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpor    $dst,$src1,$src2\t! or vectors (4 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpor($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor4B_mem(vecS dst, vecS src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 4);</span>
<span class="line-modified">!   match(Set dst (OrV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpor    $dst,$src,$mem\t! or vectors (4 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpor($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor8B(vecD dst, vecD src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 8);</span>
<span class="line-modified">!   match(Set dst (OrV dst src));</span>
<span class="line-modified">!   format %{ &quot;por     $dst,$src\t! or vectors (8 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ por($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor8B_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 8);</span>
<span class="line-modified">!   match(Set dst (OrV src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpor    $dst,$src1,$src2\t! or vectors (8 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpor($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor8B_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 4);</span>
<span class="line-modified">!   match(Set dst (OrV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpor    $dst,$src,$mem\t! or vectors (8 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpor($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor16B(vecX dst, vecX src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 16);</span>
<span class="line-modified">!   match(Set dst (OrV dst src));</span>
<span class="line-removed">-   format %{ &quot;por     $dst,$src\t! or vectors (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ por($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor16B_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 16);</span>
<span class="line-modified">!   match(Set dst (OrV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpor    $dst,$src1,$src2\t! or vectors (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-removed">-     __ vpor($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor16B_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 16);</span>
<span class="line-modified">!   match(Set dst (OrV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpor    $dst,$src,$mem\t! or vectors (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpor($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor32B_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 32);</span>
<span class="line-modified">!   match(Set dst (OrV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpor    $dst,$src1,$src2\t! or vectors (32 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vpor($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor32B_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 32);</span>
<span class="line-modified">!   match(Set dst (OrV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpor    $dst,$src,$mem\t! or vectors (32 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vpor($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor64B_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 64);</span>
<span class="line-modified">!   match(Set dst (OrV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpor    $dst,$src1,$src2\t! or vectors (64 bytes)&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpor($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor64B_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 64);</span>
<span class="line-modified">!   match(Set dst (OrV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpor    $dst,$src,$mem\t! or vectors (64 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vpor($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // --------------------------------- XOR --------------------------------------</span>
<span class="line-modified">! </span>
<span class="line-modified">! instruct vxor4B(vecS dst, vecS src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 4);</span>
<span class="line-modified">!   match(Set dst (XorV dst src));</span>
<span class="line-modified">!   format %{ &quot;pxor    $dst,$src\t! xor vectors (4 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ pxor($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor4B_reg(vecS dst, vecS src1, vecS src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 4);</span>
<span class="line-modified">!   match(Set dst (XorV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpxor   $dst,$src1,$src2\t! xor vectors (4 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpxor($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor4B_mem(vecS dst, vecS src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 4);</span>
<span class="line-modified">!   match(Set dst (XorV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpxor   $dst,$src,$mem\t! xor vectors (4 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpxor($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor8B(vecD dst, vecD src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 8);</span>
<span class="line-modified">!   match(Set dst (XorV dst src));</span>
<span class="line-modified">!   format %{ &quot;pxor    $dst,$src\t! xor vectors (8 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ pxor($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor8B_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 8);</span>
<span class="line-modified">!   match(Set dst (XorV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpxor   $dst,$src1,$src2\t! xor vectors (8 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor8B_mem(vecD dst, vecD src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 8);</span>
<span class="line-modified">!   match(Set dst (XorV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpxor   $dst,$src,$mem\t! xor vectors (8 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpxor($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor16B(vecX dst, vecX src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 16);</span>
<span class="line-modified">!   match(Set dst (XorV dst src));</span>
<span class="line-modified">!   format %{ &quot;pxor    $dst,$src\t! xor vectors (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ pxor($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor16B_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 16);</span>
<span class="line-modified">!   match(Set dst (XorV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpxor   $dst,$src1,$src2\t! xor vectors (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor16B_mem(vecX dst, vecX src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 16);</span>
<span class="line-modified">!   match(Set dst (XorV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpxor   $dst,$src,$mem\t! xor vectors (16 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vpxor($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor32B_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 32);</span>
<span class="line-modified">!   match(Set dst (XorV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpxor   $dst,$src1,$src2\t! xor vectors (32 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vpxor($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor32B_mem(vecY dst, vecY src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 32);</span>
<span class="line-modified">!   match(Set dst (XorV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpxor   $dst,$src,$mem\t! xor vectors (32 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-removed">-     __ vpxor($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor64B_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 64);</span>
    match(Set dst (XorV src1 src2));
<span class="line-modified">!   format %{ &quot;vpxor   $dst,$src1,$src2\t! xor vectors (64 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
      __ vpxor($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor64B_mem(vecZ dst, vecZ src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length_in_bytes() == 64);</span>
    match(Set dst (XorV src (LoadVector mem)));
<span class="line-modified">!   format %{ &quot;vpxor   $dst,$src,$mem\t! xor vectors (64 bytes)&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
      __ vpxor($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // --------------------------------- FMA --------------------------------------</span>
<span class="line-modified">! </span>
<span class="line-modified">! // a * b + c</span>
<span class="line-modified">! instruct vfma2D_reg(vecX a, vecX b, vecX c) %{</span>
<span class="line-modified">!   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set c (FmaVD  c (Binary a b)));</span>
<span class="line-removed">-   format %{ &quot;fmapd $a,$b,$c\t# $c = $a * $b + $c fma packed2D&quot; %}</span>
<span class="line-removed">-   ins_cost(150);</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vfmad($c$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $c$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // a * b + c</span>
<span class="line-modified">! instruct vfma2D_mem(vecX a, memory b, vecX c) %{</span>
<span class="line-modified">!   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set c (FmaVD  c (Binary a (LoadVector b))));</span>
<span class="line-removed">-   format %{ &quot;fmapd $a,$b,$c\t# $c = $a * $b + $c fma packed2D&quot; %}</span>
<span class="line-removed">-   ins_cost(150);</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vfmad($c$$XMMRegister, $a$$XMMRegister, $b$$Address, $c$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! </span>
<span class="line-modified">! // a * b + c</span>
<span class="line-modified">! instruct vfma4D_reg(vecY a, vecY b, vecY c) %{</span>
<span class="line-removed">-   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set c (FmaVD  c (Binary a b)));</span>
<span class="line-removed">-   format %{ &quot;fmapd $a,$b,$c\t# $c = $a * $b + $c fma packed4D&quot; %}</span>
<span class="line-removed">-   ins_cost(150);</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vfmad($c$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $c$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // a * b + c</span>
<span class="line-modified">! instruct vfma4D_mem(vecY a, memory b, vecY c) %{</span>
<span class="line-modified">!   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set c (FmaVD  c (Binary a (LoadVector b))));</span>
<span class="line-removed">-   format %{ &quot;fmapd $a,$b,$c\t# $c = $a * $b + $c fma packed4D&quot; %}</span>
<span class="line-removed">-   ins_cost(150);</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ vfmad($c$$XMMRegister, $a$$XMMRegister, $b$$Address, $c$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // a * b + c</span>
<span class="line-removed">- instruct vfma8D_reg(vecZ a, vecZ b, vecZ c) %{</span>
<span class="line-removed">-   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set c (FmaVD  c (Binary a b)));</span>
<span class="line-removed">-   format %{ &quot;fmapd $a,$b,$c\t# $c = $a * $b + $c fma packed8D&quot; %}</span>
<span class="line-removed">-   ins_cost(150);</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
<span class="line-removed">-     __ vfmad($c$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $c$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
  
<span class="line-modified">! // a * b + c</span>
<span class="line-modified">! instruct vfma8D_mem(vecZ a, memory b, vecZ c) %{</span>
<span class="line-modified">!   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set c (FmaVD  c (Binary a (LoadVector b))));</span>
<span class="line-modified">!   format %{ &quot;fmapd $a,$b,$c\t# $c = $a * $b + $c fma packed8D&quot; %}</span>
    ins_cost(150);
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vfmad($c$$XMMRegister, $a$$XMMRegister, $b$$Address, $c$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // a * b + c</span>
<span class="line-modified">! instruct vfma4F_reg(vecX a, vecX b, vecX c) %{</span>
<span class="line-modified">!   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set c (FmaVF  c (Binary a b)));</span>
<span class="line-modified">!   format %{ &quot;fmaps $a,$b,$c\t# $c = $a * $b + $c fma packed4F&quot; %}</span>
    ins_cost(150);
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vfmaf($c$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $c$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // a * b + c</span>
<span class="line-modified">! instruct vfma4F_mem(vecX a, memory b, vecX c) %{</span>
<span class="line-modified">!   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set c (FmaVF  c (Binary a (LoadVector b))));</span>
<span class="line-modified">!   format %{ &quot;fmaps $a,$b,$c\t# $c = $a * $b + $c fma packed4F&quot; %}</span>
<span class="line-removed">-   ins_cost(150);</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 0;</span>
<span class="line-modified">!     __ vfmaf($c$$XMMRegister, $a$$XMMRegister, $b$$Address, $c$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  // a * b + c
<span class="line-modified">! instruct vfma8F_reg(vecY a, vecY b, vecY c) %{</span>
<span class="line-modified">!   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
    match(Set c (FmaVF  c (Binary a b)));
<span class="line-modified">!   format %{ &quot;fmaps $a,$b,$c\t# $c = $a * $b + $c fma packed8F&quot; %}</span>
    ins_cost(150);
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
      __ vfmaf($c$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $c$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // a * b + c</span>
<span class="line-removed">- instruct vfma8F_mem(vecY a, memory b, vecY c) %{</span>
<span class="line-removed">-   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
    match(Set c (FmaVF  c (Binary a (LoadVector b))));
<span class="line-modified">!   format %{ &quot;fmaps $a,$b,$c\t# $c = $a * $b + $c fma packed8F&quot; %}</span>
    ins_cost(150);
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
      __ vfmaf($c$$XMMRegister, $a$$XMMRegister, $b$$Address, $c$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // a * b + c</span>
<span class="line-modified">! instruct vfma16F_reg(vecZ a, vecZ b, vecZ c) %{</span>
<span class="line-modified">!   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set c (FmaVF  c (Binary a b)));</span>
<span class="line-removed">-   format %{ &quot;fmaps $a,$b,$c\t# $c = $a * $b + $c fma packed16F&quot; %}</span>
    ins_cost(150);
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vfmaf($c$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $c$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // a * b + c</span>
<span class="line-modified">! instruct vfma16F_mem(vecZ a, memory b, vecZ c) %{</span>
<span class="line-modified">!   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set c (FmaVF  c (Binary a (LoadVector b))));</span>
<span class="line-removed">-   format %{ &quot;fmaps $a,$b,$c\t# $c = $a * $b + $c fma packed16F&quot; %}</span>
    ins_cost(150);
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
<span class="line-modified">!     __ vfmaf($c$$XMMRegister, $a$$XMMRegister, $b$$Address, $c$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  // --------------------------------- Vector Multiply Add --------------------------------------
  
<span class="line-modified">! instruct smuladd4S2I_reg(vecD dst, vecD src1) %{</span>
<span class="line-modified">!   predicate(UseSSE &gt;= 2 &amp;&amp; UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulAddVS2VI dst src1));</span>
<span class="line-removed">-   format %{ &quot;pmaddwd $dst,$dst,$src1\t! muladd packed4Sto2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ pmaddwd($dst$$XMMRegister, $src1$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmuladd4S2I_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (MulAddVS2VI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmaddwd $dst,$src1,$src2\t! muladd packed4Sto2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmaddwd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct smuladd8S4I_reg(vecX dst, vecX src1) %{</span>
<span class="line-removed">-   predicate(UseSSE &gt;= 2 &amp;&amp; UseAVX == 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
    match(Set dst (MulAddVS2VI dst src1));
<span class="line-modified">!   format %{ &quot;pmaddwd $dst,$dst,$src1\t! muladd packed8Sto4I&quot; %}</span>
    ins_encode %{
      __ pmaddwd($dst$$XMMRegister, $src1$$XMMRegister);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmuladd8S4I_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (MulAddVS2VI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmaddwd $dst,$src1,$src2\t! muladd packed8Sto4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpmaddwd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmuladd16S8I_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 1 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-removed">-   match(Set dst (MulAddVS2VI src1 src2));</span>
<span class="line-removed">-   format %{ &quot;vpmaddwd $dst,$src1,$src2\t! muladd packed16Sto8I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 1;</span>
<span class="line-removed">-     __ vpmaddwd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmuladd32S16I_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
    match(Set dst (MulAddVS2VI src1 src2));
<span class="line-modified">!   format %{ &quot;vpmaddwd $dst,$src1,$src2\t! muladd packed32Sto16I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 2;</span>
      __ vpmaddwd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
  // --------------------------------- Vector Multiply Add Add ----------------------------------
  
<span class="line-modified">! instruct vmuladdadd4S2I_reg(vecD dst, vecD src1, vecD src2) %{</span>
<span class="line-modified">!   predicate(VM_Version::supports_vnni() &amp;&amp; UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (AddVI (MulAddVS2VI src1 src2) dst));</span>
<span class="line-removed">-   format %{ &quot;evpdpwssd $dst,$src1,$src2\t! muladdadd packed4Sto2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ evpdpwssd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">-   ins_cost(10);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmuladdadd8S4I_reg(vecX dst, vecX src1, vecX src2) %{</span>
<span class="line-removed">-   predicate(VM_Version::supports_vnni() &amp;&amp; UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (AddVI (MulAddVS2VI src1 src2) dst));</span>
<span class="line-removed">-   format %{ &quot;evpdpwssd $dst,$src1,$src2\t! muladdadd packed8Sto4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ evpdpwssd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">-   ins_cost(10);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmuladdadd16S8I_reg(vecY dst, vecY src1, vecY src2) %{</span>
<span class="line-removed">-   predicate(VM_Version::supports_vnni() &amp;&amp; UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
    match(Set dst (AddVI (MulAddVS2VI src1 src2) dst));
<span class="line-modified">!   format %{ &quot;evpdpwssd $dst,$src1,$src2\t! muladdadd packed16Sto8I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     __ evpdpwssd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">-   ins_cost(10);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmuladdadd32S16I_reg(vecZ dst, vecZ src1, vecZ src2) %{</span>
<span class="line-removed">-   predicate(VM_Version::supports_vnni() &amp;&amp; UseAVX &gt; 2 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (AddVI (MulAddVS2VI src1 src2) dst));</span>
<span class="line-removed">-   format %{ &quot;evpdpwssd $dst,$src1,$src2\t! muladdadd packed32Sto16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
      __ evpdpwssd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
    ins_cost(10);
  %}
  
  // --------------------------------- PopCount --------------------------------------
  
<span class="line-modified">! instruct vpopcount2I(vecD dst, vecD src) %{</span>
<span class="line-removed">-   predicate(VM_Version::supports_vpopcntdq() &amp;&amp; UsePopCountInstruction &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">-   match(Set dst (PopCountVI src));</span>
<span class="line-removed">-   format %{ &quot;vpopcntd  $dst,$src\t! vector popcount packed2I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpopcntd($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vpopcount4I(vecX dst, vecX src) %{</span>
<span class="line-removed">-   predicate(VM_Version::supports_vpopcntdq() &amp;&amp; UsePopCountInstruction &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-removed">-   match(Set dst (PopCountVI src));</span>
<span class="line-removed">-   format %{ &quot;vpopcntd  $dst,$src\t! vector popcount packed4I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 0;</span>
<span class="line-removed">-     __ vpopcntd($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vpopcount8I(vecY dst, vecY src) %{</span>
<span class="line-removed">-   predicate(VM_Version::supports_vpopcntdq() &amp;&amp; UsePopCountInstruction &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
    match(Set dst (PopCountVI src));
<span class="line-modified">!   format %{ &quot;vpopcntd  $dst,$src\t! vector popcount packed8I&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-removed">-     __ vpopcntd($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
  
<span class="line-modified">! instruct vpopcount16I(vecZ dst, vecZ src) %{</span>
<span class="line-removed">-   predicate(VM_Version::supports_vpopcntdq() &amp;&amp; UsePopCountInstruction &amp;&amp; n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-removed">-   match(Set dst (PopCountVI src));</span>
<span class="line-removed">-   format %{ &quot;vpopcntd  $dst,$src\t! vector popcount packed16I&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     int vector_len = 2;</span>
      __ vpopcntd($dst$$XMMRegister, $src$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
<span class="line-new-header">--- 3059,2753 ---</span>
    ins_pipe( pipe_slow );
  %}
  
  // ====================VECTOR INSTRUCTIONS=====================================
  
<span class="line-modified">! // Dummy reg-to-reg vector moves. Removed during post-selection cleanup.</span>
<span class="line-modified">! instruct MoveVec2Leg(legVec dst, vec src) %{</span>
    match(Set dst src);
<span class="line-modified">!   format %{ &quot;&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     ShouldNotReachHere();</span>
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
<span class="line-modified">! instruct MoveLeg2Vec(vec dst, legVec src) %{</span>
    match(Set dst src);
<span class="line-modified">!   format %{ &quot;&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     ShouldNotReachHere();</span>
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
<span class="line-modified">! // ============================================================================</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Load vectors</span>
<span class="line-added">+ instruct loadV(vec dst, memory mem) %{</span>
    match(Set dst (LoadVector mem));
    ins_cost(125);
<span class="line-modified">!   format %{ &quot;load_vector $dst,$mem&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     switch (vector_length_in_bytes(this)) {</span>
<span class="line-added">+       case  4: __ movdl    ($dst$$XMMRegister, $mem$$Address); break;</span>
<span class="line-added">+       case  8: __ movq     ($dst$$XMMRegister, $mem$$Address); break;</span>
<span class="line-added">+       case 16: __ movdqu   ($dst$$XMMRegister, $mem$$Address); break;</span>
<span class="line-added">+       case 32: __ vmovdqu  ($dst$$XMMRegister, $mem$$Address); break;</span>
<span class="line-added">+       case 64: __ evmovdqul($dst$$XMMRegister, $mem$$Address, Assembler::AVX_512bit); break;</span>
<span class="line-added">+       default: ShouldNotReachHere();</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Store vectors generic operand pattern.</span>
<span class="line-modified">! instruct storeV(memory mem, vec src) %{</span>
<span class="line-modified">!   match(Set mem (StoreVector mem src));</span>
<span class="line-modified">!   ins_cost(145);</span>
<span class="line-modified">!   format %{ &quot;store_vector $mem,$src\n\t&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-added">+     switch (vector_length_in_bytes(this, $src)) {</span>
<span class="line-added">+       case  4: __ movdl    ($mem$$Address, $src$$XMMRegister); break;</span>
<span class="line-added">+       case  8: __ movq     ($mem$$Address, $src$$XMMRegister); break;</span>
<span class="line-added">+       case 16: __ movdqu   ($mem$$Address, $src$$XMMRegister); break;</span>
<span class="line-added">+       case 32: __ vmovdqu  ($mem$$Address, $src$$XMMRegister); break;</span>
<span class="line-added">+       case 64: __ evmovdqul($mem$$Address, $src$$XMMRegister, Assembler::AVX_512bit); break;</span>
<span class="line-added">+       default: ShouldNotReachHere();</span>
<span class="line-added">+     }</span>
    %}
<span class="line-modified">!   ins_pipe( pipe_slow );</span>
  %}
  
<span class="line-modified">! // ====================REPLICATE=======================================</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Replicate byte scalar to be vector</span>
<span class="line-modified">! instruct ReplB_reg(vec dst, rRegI src) %{</span>
<span class="line-added">+   predicate((n-&gt;as_Vector()-&gt;length() &lt;= 32) ||</span>
<span class="line-added">+             (n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; VM_Version::supports_avx512bw())); // AVX512BW for 512bit byte instructions</span>
<span class="line-added">+   match(Set dst (ReplicateB src));</span>
<span class="line-added">+   format %{ &quot;replicateB $dst,$src&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-added">+     if (vlen == 64 || VM_Version::supports_avx512vlbw()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-added">+       assert(VM_Version::supports_avx512bw(), &quot;required&quot;);</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ evpbroadcastb($dst$$XMMRegister, $src$$Register, vlen_enc);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-added">+       __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+       __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-added">+       if (vlen &gt;= 16) {</span>
<span class="line-added">+         __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+         if (vlen &gt;= 32) {</span>
<span class="line-added">+           assert(vlen == 32, &quot;sanity&quot;); // vlen == 64 &amp;&amp; !AVX512BW is covered by ReplB_reg_leg</span>
<span class="line-added">+           __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
    %}
<span class="line-modified">!   ins_pipe( pipe_slow );</span>
  %}
  
<span class="line-modified">! instruct ReplB_reg_leg(legVec dst, rRegI src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; !VM_Version::supports_avx512bw()); // AVX512BW for 512bit byte instructions</span>
<span class="line-modified">!   match(Set dst (ReplicateB src));</span>
<span class="line-modified">!   format %{ &quot;replicateB $dst,$src&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-added">+     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-added">+     __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-added">+     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct ReplB_mem(vec dst, memory mem) %{</span>
<span class="line-modified">!   predicate((n-&gt;as_Vector()-&gt;length() &lt;= 32 &amp;&amp; VM_Version::supports_avx512vlbw()) || // AVX512VL for &lt;512bit operands</span>
<span class="line-modified">!             (n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; VM_Version::supports_avx512bw()));    // AVX512BW for 512bit byte instructions</span>
<span class="line-modified">!   match(Set dst (ReplicateB (LoadB mem)));</span>
<span class="line-added">+   format %{ &quot;replicateB $dst,$mem&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpbroadcastb($dst$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
<span class="line-modified">!   ins_pipe( pipe_slow );</span>
  %}
  
<span class="line-modified">! instruct ReplB_imm(vec dst, immI con) %{</span>
<span class="line-modified">!   predicate((n-&gt;as_Vector()-&gt;length() &lt;= 32) ||</span>
<span class="line-modified">!             (n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; VM_Version::supports_avx512bw())); // AVX512BW for 512bit byte instructions</span>
<span class="line-modified">!   match(Set dst (ReplicateB con));</span>
<span class="line-added">+   format %{ &quot;replicateB $dst,$con&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 1));</span>
<span class="line-modified">!     if (vlen == 4) {</span>
<span class="line-added">+       __ movdl($dst$$XMMRegister, const_addr);</span>
      } else {
<span class="line-modified">!       __ movq($dst$$XMMRegister, const_addr);</span>
<span class="line-added">+       if (vlen &gt;= 16) {</span>
<span class="line-added">+         if (vlen == 64 || VM_Version::supports_avx512vlbw()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-added">+           int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+           __ vpbroadcastb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+           if (vlen &gt;= 32) {</span>
<span class="line-added">+              assert(vlen == 32, &quot;sanity&quot;);// vlen == 64 &amp;&amp; !AVX512BW is covered by ReplB_imm_leg</span>
<span class="line-added">+             __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+           }</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
      }
    %}
<span class="line-modified">!   ins_pipe( pipe_slow );</span>
  %}
  
<span class="line-modified">! instruct ReplB_imm_leg(legVec dst, immI con) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; !VM_Version::supports_avx512bw());</span>
<span class="line-modified">!   match(Set dst (ReplicateB con));</span>
<span class="line-modified">!   format %{ &quot;replicateB $dst,$con&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 1)));</span>
<span class="line-added">+     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Replicate byte scalar zero to be vector</span>
<span class="line-modified">! instruct ReplB_zero(vec dst, immI0 zero) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateB zero));</span>
<span class="line-modified">!   format %{ &quot;replicateB $dst,$zero&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen &lt;= 16) {</span>
<span class="line-modified">!       __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
      } else {
<span class="line-modified">!       // Use vpxor since AVX512F does not have 512bit vxorpd (requires AVX512DQ).</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);</span>
      }
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
<span class="line-modified">! // ====================ReplicateS=======================================</span>
<span class="line-modified">! </span>
<span class="line-modified">! instruct ReplS_reg(vec dst, rRegI src) %{</span>
<span class="line-modified">!   predicate((n-&gt;as_Vector()-&gt;length() &lt;= 16) ||</span>
<span class="line-added">+             (n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; VM_Version::supports_avx512bw())); // AVX512BW for 512bit instructions on shorts</span>
<span class="line-added">+   match(Set dst (ReplicateS src));</span>
<span class="line-added">+   format %{ &quot;replicateS $dst,$src&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen == 32 || VM_Version::supports_avx512vlbw()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-modified">!       assert(VM_Version::supports_avx512bw(), &quot;required&quot;);</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ evpbroadcastw($dst$$XMMRegister, $src$$Register, vlen_enc);</span>
      } else {
<span class="line-modified">!       __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-added">+       __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-added">+       if (vlen &gt;= 8) {</span>
<span class="line-added">+         __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+         if (vlen &gt;= 16) {</span>
<span class="line-added">+           assert(vlen == 16, &quot;sanity&quot;); // vlen == 32 &amp;&amp; !AVX512BW is covered by ReplS_reg_leg</span>
<span class="line-added">+           __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
      }
    %}
<span class="line-modified">!   ins_pipe( pipe_slow );</span>
  %}
  
<span class="line-modified">! instruct ReplS_reg_leg(legVec dst, rRegI src) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; !VM_Version::supports_avx512bw());</span>
<span class="line-modified">!   match(Set dst (ReplicateS src));</span>
<span class="line-modified">!   format %{ &quot;replicateS $dst,$src&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-added">+     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct ReplS_mem(vec dst, memory mem) %{</span>
<span class="line-modified">!   predicate((n-&gt;as_Vector()-&gt;length() &gt;= 4  &amp;&amp;</span>
<span class="line-modified">!              n-&gt;as_Vector()-&gt;length() &lt;= 16 &amp;&amp; VM_Version::supports_avx()) ||</span>
<span class="line-modified">!             (n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; VM_Version::supports_avx512bw())); // AVX512BW for 512bit instructions on shorts</span>
<span class="line-modified">!   match(Set dst (ReplicateS (LoadS mem)));</span>
<span class="line-modified">!   format %{ &quot;replicateS $dst,$mem&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen == 32 || VM_Version::supports_avx512vlbw()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-added">+       assert(VM_Version::supports_avx512bw(), &quot;required&quot;);</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vpbroadcastw($dst$$XMMRegister, $mem$$Address, vlen_enc);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       __ pshuflw($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-added">+       if (vlen &gt;= 8) {</span>
<span class="line-added">+         __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+         if (vlen &gt;= 16) {</span>
<span class="line-added">+           assert(vlen == 16, &quot;sanity&quot;); // vlen == 32 &amp;&amp; !AVX512BW is covered by ReplS_mem_leg</span>
<span class="line-added">+           __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct ReplS_mem_leg(legVec dst, memory mem) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; !VM_Version::supports_avx512bw());</span>
<span class="line-modified">!   match(Set dst (ReplicateS (LoadS mem)));</span>
<span class="line-added">+   format %{ &quot;replicateS $dst,$mem&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
    %}
<span class="line-modified">!   ins_pipe( pipe_slow );</span>
  %}
  
<span class="line-modified">! instruct ReplS_imm(vec dst, immI con) %{</span>
<span class="line-modified">!   predicate((n-&gt;as_Vector()-&gt;length() &lt;= 16) ||</span>
<span class="line-modified">!             (n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; VM_Version::supports_avx512bw())); // AVX512BW for 512bit instructions on shorts</span>
<span class="line-added">+   match(Set dst (ReplicateS con));</span>
<span class="line-added">+   format %{ &quot;replicateS $dst,$con&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     InternalAddress constaddr = $constantaddress(replicate8_imm($con$$constant, 2));</span>
<span class="line-added">+     if (vlen == 2) {</span>
<span class="line-added">+       __ movdl($dst$$XMMRegister, constaddr);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       __ movq($dst$$XMMRegister, constaddr);</span>
<span class="line-added">+       if (vlen == 32 || VM_Version::supports_avx512vlbw() ) { // AVX512VL for &lt;512bit operands</span>
<span class="line-added">+         assert(VM_Version::supports_avx512bw(), &quot;required&quot;);</span>
<span class="line-added">+         int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+         __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         __ movq($dst$$XMMRegister, constaddr);</span>
<span class="line-added">+         __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+         if (vlen &gt;= 16) {</span>
<span class="line-added">+           assert(vlen == 16, &quot;sanity&quot;); // vlen == 32 &amp;&amp; !AVX512BW is covered by ReplS_imm_leg</span>
<span class="line-added">+           __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
<span class="line-modified">! instruct ReplS_imm_leg(legVec dst, immI con) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; !VM_Version::supports_avx512bw());</span>
<span class="line-modified">!   match(Set dst (ReplicateS con));</span>
<span class="line-modified">!   format %{ &quot;replicateS $dst,$con&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 2)));</span>
<span class="line-added">+     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct ReplS_zero(vec dst, immI0 zero) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateS zero));</span>
<span class="line-modified">!   format %{ &quot;replicateS $dst,$zero&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-added">+     if (vlen &lt;= 8) {</span>
<span class="line-added">+       __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);</span>
<span class="line-added">+     }</span>
    %}
<span class="line-modified">!   ins_pipe( fpu_reg_reg );</span>
  %}
  
<span class="line-modified">! // ====================ReplicateI=======================================</span>
<span class="line-modified">! </span>
<span class="line-modified">! instruct ReplI_reg(vec dst, rRegI src) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateI src));</span>
<span class="line-modified">!   format %{ &quot;replicateI $dst,$src&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-added">+     if (vlen == 16 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ evpbroadcastd($dst$$XMMRegister, $src$$Register, vlen_enc);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-added">+       __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-added">+       if (vlen &gt;= 8) {</span>
<span class="line-added">+         assert(vlen == 8, &quot;sanity&quot;);</span>
<span class="line-added">+         __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct ReplI_mem(vec dst, memory mem) %{</span>
<span class="line-modified">!   predicate(VM_Version::supports_avx()); // use VEX-encoded pshufd to relax 16-byte alignment restriction on the source</span>
<span class="line-modified">!   match(Set dst (ReplicateI (LoadI mem)));</span>
<span class="line-modified">!   format %{ &quot;replicateI $dst,$mem&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen &lt;= 4) {</span>
<span class="line-added">+       __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-added">+     } else if (vlen == 16 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-added">+       int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+       __ vpbroadcastd($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(vlen == 8, &quot;sanity&quot;);</span>
<span class="line-added">+       __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-added">+       __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct ReplI_imm(vec dst, immI con) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateI con));</span>
<span class="line-modified">!   format %{ &quot;replicateI $dst,$con&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     InternalAddress constaddr = $constantaddress(replicate8_imm($con$$constant, 4));</span>
<span class="line-modified">!     if (vlen == 2) {</span>
<span class="line-modified">!       __ movq($dst$$XMMRegister, constaddr);</span>
<span class="line-added">+     } else if (vlen == 16 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-added">+       int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+       __ movq($dst$$XMMRegister, constaddr);</span>
<span class="line-added">+       __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       __ movq($dst$$XMMRegister, constaddr);</span>
<span class="line-added">+       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+       if (vlen &gt;= 8) {</span>
<span class="line-added">+         assert(vlen == 8, &quot;sanity&quot;);</span>
<span class="line-added">+         __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Replicate integer (4 byte) scalar zero to be vector</span>
<span class="line-modified">! instruct ReplI_zero(vec dst, immI0 zero) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateI zero));</span>
<span class="line-modified">!   format %{ &quot;replicateI $dst,$zero&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen &lt;= 4) {</span>
<span class="line-added">+       __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);</span>
<span class="line-added">+     }</span>
    %}
<span class="line-modified">!   ins_pipe( fpu_reg_reg );</span>
  %}
  
<span class="line-modified">! // ====================ReplicateL=======================================</span>
  
<span class="line-modified">! #ifdef _LP64</span>
<span class="line-modified">! // Replicate long (8 byte) scalar to be vector</span>
<span class="line-modified">! instruct ReplL_reg(vec dst, rRegL src) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateL src));</span>
<span class="line-modified">!   format %{ &quot;replicateL $dst,$src&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen == 2) {</span>
<span class="line-added">+       __ movdq($dst$$XMMRegister, $src$$Register);</span>
<span class="line-added">+       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     } else if (vlen == 8 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ evpbroadcastq($dst$$XMMRegister, $src$$Register, vlen_enc);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(vlen == 4, &quot;sanity&quot;);</span>
<span class="line-added">+       __ movdq($dst$$XMMRegister, $src$$Register);</span>
<span class="line-added">+       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+       __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
<span class="line-modified">! #else // _LP64</span>
<span class="line-modified">! // Replicate long (8 byte) scalar to be vector</span>
<span class="line-modified">! instruct ReplL_reg(vec dst, eRegL src, vec tmp) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() &lt;= 4);</span>
<span class="line-modified">!   match(Set dst (ReplicateL src));</span>
<span class="line-modified">!   effect(TEMP dst, USE src, TEMP tmp);</span>
<span class="line-modified">!   format %{ &quot;replicateL $dst,$src&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-added">+     if (vlen == 2) {</span>
<span class="line-added">+       __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-added">+       __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));</span>
<span class="line-added">+       __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     } else if (VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-added">+       int vector_len = Assembler::AVX_256bit;</span>
<span class="line-added">+       __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-added">+       __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));</span>
<span class="line-added">+       __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-added">+       __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));</span>
<span class="line-added">+       __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+       __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct ReplL_reg_leg(legVec dst, eRegL src, legVec tmp) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (ReplicateL src));</span>
<span class="line-modified">!   effect(TEMP dst, USE src, TEMP tmp);</span>
<span class="line-modified">!   format %{ &quot;replicateL $dst,$src&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     if (VM_Version::supports_avx512vl()) {</span>
<span class="line-modified">!       __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-modified">!       __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));</span>
<span class="line-modified">!       __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-modified">!       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-modified">!       __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+       __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       int vector_len = Assembler::AVX_512bit;</span>
<span class="line-added">+       __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-added">+       __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));</span>
<span class="line-added">+       __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
<span class="line-added">+ #endif // _LP64</span>
  
<span class="line-modified">! instruct ReplL_mem(vec dst, memory mem) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateL (LoadL mem)));</span>
<span class="line-modified">!   format %{ &quot;replicateL $dst,$mem&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen == 2) {</span>
<span class="line-modified">!       __ movq($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-modified">!       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-modified">!     } else if (vlen == 8 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-modified">!       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vpbroadcastq($dst$$XMMRegister, $mem$$Address, vlen_enc);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(vlen == 4, &quot;sanity&quot;);</span>
<span class="line-added">+       __ movq($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-added">+       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+       __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Replicate long (8 byte) scalar immediate to be vector by loading from const table.</span>
<span class="line-modified">! instruct ReplL_imm(vec dst, immL con) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateL con));</span>
<span class="line-modified">!   format %{ &quot;replicateL $dst,$con&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     InternalAddress const_addr = $constantaddress($con);</span>
<span class="line-modified">!     if (vlen == 2) {</span>
<span class="line-modified">!       __ movq($dst$$XMMRegister, const_addr);</span>
<span class="line-modified">!       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-modified">!     } else if (vlen == 8 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-modified">!       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-modified">!       __ movq($dst$$XMMRegister, const_addr);</span>
<span class="line-modified">!       __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(vlen == 4, &quot;sanity&quot;);</span>
<span class="line-added">+       __ movq($dst$$XMMRegister, const_addr);</span>
<span class="line-added">+       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+       __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct ReplL_zero(vec dst, immL0 zero) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateL zero));</span>
<span class="line-modified">!   format %{ &quot;replicateL $dst,$zero&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen == 2) {</span>
<span class="line-modified">!       __ pxor($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-modified">!     } else {</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);</span>
<span class="line-added">+     }</span>
    %}
<span class="line-modified">!   ins_pipe( fpu_reg_reg );</span>
  %}
  
<span class="line-modified">! // ====================ReplicateF=======================================</span>
  
<span class="line-modified">! instruct ReplF_reg(vec dst, vlRegF src) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateF src));</span>
<span class="line-modified">!   format %{ &quot;replicateF $dst,$src&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen &lt;= 4) {</span>
<span class="line-modified">!       __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);</span>
<span class="line-modified">!     } else if (vlen == 16 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-modified">!       int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!       __ vbroadcastss($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       assert(vlen == 8, &quot;sanity&quot;);</span>
<span class="line-modified">!       __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);</span>
<span class="line-modified">!       __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct ReplF_mem(vec dst, memory mem) %{</span>
<span class="line-modified">!   predicate(VM_Version::supports_avx()); // use VEX-encoded pshufd to relax 16-byte alignment restriction on the source</span>
<span class="line-modified">!   match(Set dst (ReplicateF (LoadF mem)));</span>
<span class="line-modified">!   format %{ &quot;replicateF $dst,$mem&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen &lt;= 4) {</span>
<span class="line-modified">!       __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-added">+     } else if (vlen == 16 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-added">+       int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+       __ vbroadcastss($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(vlen == 8, &quot;sanity&quot;);</span>
<span class="line-added">+       __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-added">+       __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct ReplF_zero(vec dst, immF0 zero) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateF zero));</span>
<span class="line-modified">!   format %{ &quot;replicateF $dst,$zero&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen &lt;= 4) {</span>
<span class="line-modified">!       __ xorps($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vpxor($dst$$XMMRegister,$dst$$XMMRegister, $dst$$XMMRegister, vlen_enc); // 512bit vxorps requires AVX512DQ</span>
<span class="line-added">+     }</span>
    %}
<span class="line-modified">!   ins_pipe( fpu_reg_reg );</span>
  %}
  
<span class="line-modified">! // ====================ReplicateD=======================================</span>
  
<span class="line-modified">! // Replicate double (8 bytes) scalar to be vector</span>
<span class="line-modified">! instruct ReplD_reg(vec dst, vlRegD src) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateD src));</span>
<span class="line-modified">!   format %{ &quot;replicateD $dst,$src&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen == 2) {</span>
<span class="line-modified">!       __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);</span>
<span class="line-added">+     } else if (vlen == 8 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-added">+       int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+       __ vbroadcastsd($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(vlen == 4, &quot;sanity&quot;);</span>
<span class="line-added">+       __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);</span>
<span class="line-added">+       __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct ReplD_mem(vec dst, memory mem) %{</span>
<span class="line-modified">!   predicate(VM_Version::supports_avx()); // use VEX-encoded pshufd to relax 16-byte alignment restriction on the source</span>
<span class="line-modified">!   match(Set dst (ReplicateD (LoadD mem)));</span>
<span class="line-modified">!   format %{ &quot;replicateD $dst,$mem&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-added">+     if (vlen == 2) {</span>
<span class="line-added">+       __ pshufd($dst$$XMMRegister, $mem$$Address, 0x44);</span>
<span class="line-added">+     } else if (vlen == 8 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-added">+       int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+       __ vbroadcastsd($dst$$XMMRegister, $mem$$Address, vector_len);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(vlen == 4, &quot;sanity&quot;);</span>
<span class="line-added">+       __ pshufd($dst$$XMMRegister, $mem$$Address, 0x44);</span>
<span class="line-added">+       __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct ReplD_zero(vec dst, immD0 zero) %{</span>
<span class="line-modified">!   match(Set dst (ReplicateD zero));</span>
<span class="line-modified">!   format %{ &quot;replicateD $dst,$zero&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen == 2) {</span>
<span class="line-modified">!       __ xorpd($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc); // 512bit vxorps requires AVX512DQ</span>
<span class="line-added">+     }</span>
    %}
<span class="line-modified">!   ins_pipe( fpu_reg_reg );</span>
  %}
  
<span class="line-modified">! // ====================REDUCTION ARITHMETIC=======================================</span>
<span class="line-modified">! </span>
<span class="line-modified">! // =======================AddReductionVI==========================================</span>
<span class="line-modified">! </span>
<span class="line-modified">! instruct vadd2I_reduction_reg(rRegI dst, rRegI src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-modified">!   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_add2I_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     if (UseAVX &gt; 2) {</span>
<span class="line-added">+       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-added">+       __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-added">+       __ vpaddd($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+       __ vpaddd($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-added">+     } else if (VM_Version::supports_avxonly()) {</span>
<span class="line-added">+       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-added">+       __ vphaddd($tmp$$XMMRegister, $src2$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+       __ vpaddd($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(UseSSE &gt; 2, &quot;required&quot;);</span>
<span class="line-added">+       __ movdqu($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ phaddd($tmp2$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+       __ movdl($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+       __ paddd($tmp$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+       __ movdl($dst$$Register, $tmp$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vadd4I_reduction_reg(rRegI dst, rRegI src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
<span class="line-modified">!   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_add4I_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     if (UseAVX &gt; 2) {</span>
<span class="line-modified">!       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-added">+       __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+       __ vpaddd($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-added">+       __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+       __ vpaddd($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-added">+     } else if (VM_Version::supports_avxonly()) {</span>
<span class="line-added">+       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-added">+       __ vphaddd($tmp$$XMMRegister, $src2$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ vphaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+       __ vpaddd($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(UseSSE &gt; 2, &quot;required&quot;);</span>
<span class="line-added">+       __ movdqu($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ phaddd($tmp$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ phaddd($tmp$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+       __ paddd($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vadd8I_reduction_reg(rRegI dst, rRegI src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-modified">!   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_add8I_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     if (UseAVX &gt; 2) {</span>
<span class="line-modified">!       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-modified">!       __ vextracti128_high($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-modified">!       __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-modified">!       __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0xE);</span>
<span class="line-modified">!       __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-added">+       __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+       __ vpaddd($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(UseAVX &gt; 0, &quot;&quot;);</span>
<span class="line-added">+       int vector_len = Assembler::AVX_256bit;</span>
<span class="line-added">+       __ vphaddd($tmp$$XMMRegister, $src2$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ vphaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ vextracti128_high($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-added">+       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+       __ vpaddd($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-added">+       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vadd16I_reduction_reg(rRegI dst, rRegI src1, legVec src2, legVec tmp, legVec tmp2, legVec tmp3) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 16); // vector_length(src2) == 16</span>
<span class="line-modified">!   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2, TEMP tmp3);</span>
<span class="line-modified">!   format %{ &quot;vector_add16I_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ vextracti64x4_high($tmp3$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-modified">!     __ vpaddd($tmp3$$XMMRegister, $tmp3$$XMMRegister, $src2$$XMMRegister, 1);</span>
<span class="line-added">+     __ vextracti128_high($tmp$$XMMRegister, $tmp3$$XMMRegister);</span>
<span class="line-added">+     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp3$$XMMRegister, 0);</span>
<span class="line-added">+     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-added">+     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-added">+     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+     __ vpaddd($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // =======================AddReductionVL==========================================</span>
  
<span class="line-modified">! #ifdef _LP64</span>
<span class="line-modified">! instruct vadd2L_reduction_reg(rRegL dst, rRegL src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-modified">!   match(Set dst (AddReductionVL src1 src2));</span>
<span class="line-added">+   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_add2L_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-modified">!     __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vpaddq($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdq($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+     __ vpaddq($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vadd4L_reduction_reg(rRegL dst, rRegL src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
<span class="line-modified">!   match(Set dst (AddReductionVL src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_add4L_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-added">+     __ vextracti128_high($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ vpaddq($tmp2$$XMMRegister, $tmp$$XMMRegister, $src2$$XMMRegister, 0);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdq($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vadd8L_reduction_reg(rRegL dst, rRegL src1, legVec src2, legVec tmp, legVec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-modified">!   match(Set dst (AddReductionVL src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_addL_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-added">+     __ vextracti64x4_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $src2$$XMMRegister, 1);</span>
<span class="line-added">+     __ vextracti128_high($tmp$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdq($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
<span class="line-added">+ #endif // _LP64</span>
  
<span class="line-modified">! // =======================AddReductionVF==========================================</span>
  
<span class="line-modified">! instruct vadd2F_reduction_reg(regF dst, vec src2, vec tmp) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-modified">!   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP tmp);</span>
<span class="line-added">+   format %{ &quot;vector_add2F_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     if (UseAVX &gt; 0) {</span>
<span class="line-modified">!       __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-added">+       __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(UseSSE &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+       __ addss($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-added">+       __ addss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vadd4F_reduction_reg(regF dst, vec src2, vec tmp) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
<span class="line-modified">!   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP tmp);</span>
<span class="line-modified">!   format %{ &quot;vector_add4F_reduction $dst,$dst,$src2&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     if (UseAVX &gt; 0) {</span>
<span class="line-added">+       __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-added">+       __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-added">+       __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-added">+       __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(UseSSE &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+       __ addss($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-added">+       __ addss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-added">+       __ addss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-added">+       __ addss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  
<span class="line-modified">! instruct vadd8F_reduction_reg(regF dst, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-modified">!   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_add8F_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-modified">!     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf128_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vadd16F_reduction_reg(regF dst, legVec src2, legVec tmp, legVec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 16); // vector_length(src2) == 16</span>
<span class="line-modified">!   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_add16F_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-modified">!     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x2);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x3);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-added">+     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // =======================AddReductionVD==========================================</span>
  
<span class="line-modified">! instruct vadd2D_reduction_reg(regD dst, vec src2, vec tmp) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-modified">!   match(Set dst (AddReductionVD dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst);</span>
<span class="line-added">+   format %{ &quot;vector_add2D_reduction  $dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     if (UseAVX &gt; 0) {</span>
<span class="line-added">+       __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+       __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(UseSSE &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+       __ addsd($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+       __ addsd($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vadd4D_reduction_reg(regD dst, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
<span class="line-modified">!   match(Set dst (AddReductionVD dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_add4D_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf128($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-added">+     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vadd8D_reduction_reg(regD dst, legVec src2, legVec tmp, legVec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-modified">!   match(Set dst (AddReductionVD dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_add8D_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-modified">!     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-added">+     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x2);</span>
<span class="line-added">+     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x3);</span>
<span class="line-added">+     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // =======================MulReductionVI==========================================</span>
  
<span class="line-modified">! instruct vmul2I_reduction_reg(rRegI dst, rRegI src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-modified">!   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_mul2I_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-added">+     if (UseAVX &gt; 0) {</span>
<span class="line-added">+       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-added">+       __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-added">+       __ vpmulld($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+       __ vpmulld($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(UseSSE &gt; 3, &quot;required&quot;);</span>
<span class="line-added">+       __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-added">+       __ pmulld($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ movdl($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+       __ pmulld($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul4I_reduction_reg(rRegI dst, rRegI src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
<span class="line-modified">!   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_mul4I_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-added">+     if (UseAVX &gt; 0) {</span>
<span class="line-added">+       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-added">+       __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+       __ vpmulld($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-added">+       __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+       __ vpmulld($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(UseSSE &gt; 3, &quot;required&quot;);</span>
<span class="line-added">+       __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+       __ pmulld($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x1);</span>
<span class="line-added">+       __ pmulld($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ movdl($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+       __ pmulld($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul8I_reduction_reg(rRegI dst, rRegI src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-modified">!   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_mul8I_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 1, &quot;required&quot;);</span>
<span class="line-modified">!     int vector_len = Assembler::AVX_128bit;</span>
<span class="line-added">+     __ vextracti128_high($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-added">+     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+     __ vpmulld($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul16I_reduction_reg(rRegI dst, rRegI src1, legVec src2, legVec tmp, legVec tmp2, legVec tmp3) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 16); // vector_length(src2) == 16</span>
<span class="line-modified">!   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2, TEMP tmp3);</span>
<span class="line-added">+   format %{ &quot;vector_mul16I_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-modified">!     __ vextracti64x4_high($tmp3$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ vpmulld($tmp3$$XMMRegister, $tmp3$$XMMRegister, $src2$$XMMRegister, 1);</span>
<span class="line-added">+     __ vextracti128_high($tmp$$XMMRegister, $tmp3$$XMMRegister);</span>
<span class="line-added">+     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp3$$XMMRegister, 0);</span>
<span class="line-added">+     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-added">+     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-added">+     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+     __ vpmulld($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // =======================MulReductionVL==========================================</span>
<span class="line-modified">! </span>
<span class="line-modified">! #ifdef _LP64</span>
<span class="line-modified">! instruct vmul2L_reduction_reg(rRegL dst, rRegL src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-added">+   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-added">+   match(Set dst (MulReductionVL src1 src2));</span>
<span class="line-added">+   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_mul2L_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(VM_Version::supports_avx512dq(), &quot;required&quot;);</span>
<span class="line-added">+     __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vpmullq($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdq($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+     __ vpmullq($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul4L_reduction_reg(rRegL dst, rRegL src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
<span class="line-modified">!   match(Set dst (MulReductionVL src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_mul4L_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(VM_Version::supports_avx512dq(), &quot;required&quot;);</span>
<span class="line-added">+     __ vextracti128_high($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ vpmullq($tmp2$$XMMRegister, $tmp$$XMMRegister, $src2$$XMMRegister, 0);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdq($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul8L_reduction_reg(rRegL dst, rRegL src1, legVec src2, legVec tmp, legVec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-modified">!   match(Set dst (MulReductionVL src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_mul8L_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(VM_Version::supports_avx512dq(), &quot;required&quot;);</span>
<span class="line-modified">!     __ vextracti64x4_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $src2$$XMMRegister, 1);</span>
<span class="line-added">+     __ vextracti128_high($tmp$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdq($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-added">+     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-added">+     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
<span class="line-added">+ #endif</span>
  
<span class="line-modified">! // =======================MulReductionVF==========================================</span>
<span class="line-modified">! </span>
<span class="line-modified">! instruct vmul2F_reduction_reg(regF dst, vec src2, vec tmp) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-added">+   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-added">+   effect(TEMP dst, TEMP tmp);</span>
<span class="line-added">+   format %{ &quot;vector_mul2F_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     if (UseAVX &gt; 0) {</span>
<span class="line-modified">!       __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-added">+       __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(UseSSE &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+       __ mulss($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-added">+       __ mulss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul4F_reduction_reg(regF dst, vec src2, vec tmp) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
<span class="line-modified">!   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP tmp);</span>
<span class="line-modified">!   format %{ &quot;vector_mul4F_reduction $dst,$dst,$src2&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     if (UseAVX &gt; 0) {</span>
<span class="line-added">+       __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-added">+       __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-added">+       __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-added">+       __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(UseSSE &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+       __ mulss($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-added">+       __ mulss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-added">+       __ mulss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-added">+       __ mulss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul8F_reduction_reg(regF dst, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-modified">!   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_mul8F_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-modified">!     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf128_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul16F_reduction_reg(regF dst, legVec src2, legVec tmp, legVec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 16); // vector_length(src2) == 16</span>
<span class="line-modified">!   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_mul16F_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-modified">!     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x2);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x3);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-added">+     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // =======================MulReductionVD==========================================</span>
<span class="line-modified">! </span>
<span class="line-modified">! instruct vmul2D_reduction_reg(regD dst, vec src2, vec tmp) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-added">+   match(Set dst (MulReductionVD dst src2));</span>
<span class="line-added">+   effect(TEMP dst, TEMP tmp);</span>
<span class="line-added">+   format %{ &quot;vector_mul2D_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     if (UseAVX &gt; 0) {</span>
<span class="line-modified">!       __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+       __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(UseSSE &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+       __ mulsd($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+       __ mulsd($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! </span>
<span class="line-modified">! instruct vmul4D_reduction_reg(regD dst, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 2</span>
<span class="line-modified">!   match(Set dst (MulReductionVD dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_mul4D_reduction  $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf128_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul8D_reduction_reg(regD dst, legVec src2, legVec tmp, legVec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 2</span>
<span class="line-modified">!   match(Set dst (MulReductionVD dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-added">+   format %{ &quot;vector_mul8D_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-added">+     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x2);</span>
<span class="line-added">+     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x3);</span>
<span class="line-added">+     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // ====================VECTOR ARITHMETIC=======================================</span>
<span class="line-modified">! </span>
<span class="line-modified">! // --------------------------------- ADD --------------------------------------</span>
<span class="line-modified">! </span>
<span class="line-added">+ // Bytes vector add</span>
<span class="line-added">+ instruct vaddB(vec dst, vec src) %{</span>
<span class="line-added">+   predicate(UseAVX == 0);</span>
<span class="line-added">+   match(Set dst (AddVB dst src));</span>
<span class="line-added">+   format %{ &quot;paddb   $dst,$src\t! add packedB&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ paddb($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vaddB_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AddVB src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpaddb  $dst,$src1,$src2\t! add packedB&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpaddb($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vaddB_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AddVB src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpaddb  $dst,$src,$mem\t! add packedB&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vpaddb($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Shorts/Chars vector add</span>
<span class="line-modified">! instruct vaddS(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (AddVS dst src));</span>
<span class="line-added">+   format %{ &quot;paddw   $dst,$src\t! add packedS&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ paddw($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vaddS_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AddVS src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpaddw  $dst,$src1,$src2\t! add packedS&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpaddw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vaddS_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AddVS src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpaddw  $dst,$src,$mem\t! add packedS&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpaddw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Integers vector add</span>
<span class="line-modified">! instruct vaddI(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (AddVI dst src));</span>
<span class="line-added">+   format %{ &quot;paddd   $dst,$src\t! add packedI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ paddd($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vaddI_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AddVI src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpaddd  $dst,$src1,$src2\t! add packedI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpaddd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! </span>
<span class="line-modified">! instruct vaddI_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AddVI src (LoadVector mem)));</span>
<span class="line-added">+   format %{ &quot;vpaddd  $dst,$src,$mem\t! add packedI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpaddd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Longs vector add</span>
<span class="line-modified">! instruct vaddL(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (AddVL dst src));</span>
<span class="line-added">+   format %{ &quot;paddq   $dst,$src\t! add packedL&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ paddq($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vaddL_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AddVL src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpaddq  $dst,$src1,$src2\t! add packedL&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vpaddq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vaddL_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AddVL src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpaddq  $dst,$src,$mem\t! add packedL&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vpaddq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Floats vector add</span>
<span class="line-modified">! instruct vaddF(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (AddVF dst src));</span>
<span class="line-added">+   format %{ &quot;addps   $dst,$src\t! add packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ addps($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vaddF_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AddVF src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vaddps  $dst,$src1,$src2\t! add packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vaddps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vaddF_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AddVF src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vaddps  $dst,$src,$mem\t! add packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vaddps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Doubles vector add</span>
<span class="line-modified">! instruct vaddD(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (AddVD dst src));</span>
<span class="line-added">+   format %{ &quot;addpd   $dst,$src\t! add packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ addpd($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vaddD_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AddVD src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vaddpd  $dst,$src1,$src2\t! add packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vaddpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vaddD_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AddVD src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vaddpd  $dst,$src,$mem\t! add packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vaddpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // --------------------------------- SUB --------------------------------------</span>
  
<span class="line-modified">! // Bytes vector sub</span>
<span class="line-modified">! instruct vsubB(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (SubVB dst src));</span>
<span class="line-modified">!   format %{ &quot;psubb   $dst,$src\t! sub packedB&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psubb($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsubB_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (SubVB src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpsubb  $dst,$src1,$src2\t! sub packedB&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vpsubb($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsubB_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (SubVB src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpsubb  $dst,$src,$mem\t! sub packedB&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpsubb($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Shorts/Chars vector sub</span>
<span class="line-modified">! instruct vsubS(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (SubVS dst src));</span>
<span class="line-added">+   format %{ &quot;psubw   $dst,$src\t! sub packedS&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psubw($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! </span>
<span class="line-modified">! instruct vsubS_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (SubVS src1 src2));</span>
<span class="line-added">+   format %{ &quot;vpsubw  $dst,$src1,$src2\t! sub packedS&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vpsubw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsubS_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (SubVS src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpsubw  $dst,$src,$mem\t! sub packedS&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vpsubw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Integers vector sub</span>
<span class="line-modified">! instruct vsubI(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (SubVI dst src));</span>
<span class="line-added">+   format %{ &quot;psubd   $dst,$src\t! sub packedI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psubd($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsubI_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (SubVI src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpsubd  $dst,$src1,$src2\t! sub packedI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpsubd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsubI_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (SubVI src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpsubd  $dst,$src,$mem\t! sub packedI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vpsubd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Longs vector sub</span>
<span class="line-modified">! instruct vsubL(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (SubVL dst src));</span>
<span class="line-added">+   format %{ &quot;psubq   $dst,$src\t! sub packedL&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ psubq($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsubL_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (SubVL src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpsubq  $dst,$src1,$src2\t! sub packedL&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpsubq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! </span>
<span class="line-modified">! instruct vsubL_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (SubVL src (LoadVector mem)));</span>
<span class="line-added">+   format %{ &quot;vpsubq  $dst,$src,$mem\t! sub packedL&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpsubq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Floats vector sub</span>
<span class="line-modified">! instruct vsubF(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (SubVF dst src));</span>
<span class="line-added">+   format %{ &quot;subps   $dst,$src\t! sub packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ subps($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsubF_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (SubVF src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vsubps  $dst,$src1,$src2\t! sub packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vsubps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsubF_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (SubVF src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vsubps  $dst,$src,$mem\t! sub packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vsubps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Doubles vector sub</span>
<span class="line-modified">! instruct vsubD(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (SubVD dst src));</span>
<span class="line-added">+   format %{ &quot;subpd   $dst,$src\t! sub packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ subpd($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsubD_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (SubVD src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vsubpd  $dst,$src1,$src2\t! sub packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vsubpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsubD_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (SubVD src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vsubpd  $dst,$src,$mem\t! sub packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vsubpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // --------------------------------- MUL --------------------------------------</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Byte vector mul</span>
<span class="line-modified">! instruct mulB_reg(vec dst, vec src1, vec src2, vec tmp, rRegI scratch) %{</span>
<span class="line-added">+   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||</span>
<span class="line-added">+             n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-added">+   match(Set dst (MulVB src1 src2));</span>
<span class="line-added">+   effect(TEMP dst, TEMP tmp, TEMP scratch);</span>
<span class="line-added">+   format %{&quot;vector_mulB $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseSSE &gt; 3, &quot;required&quot;);</span>
<span class="line-modified">!     __ pmovsxbw($tmp$$XMMRegister, $src1$$XMMRegister);</span>
<span class="line-added">+     __ pmovsxbw($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ pmullw($tmp$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);</span>
<span class="line-added">+     __ pand($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ packuswb($dst$$XMMRegister, $dst$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct mul16B_reg(vec dst, vec src1, vec src2, vec tmp1, vec tmp2, rRegI scratch) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &lt;= 1);</span>
<span class="line-modified">!   match(Set dst (MulVB src1 src2));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP scratch);</span>
<span class="line-added">+   format %{&quot;vector_mulB $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseSSE &gt; 3, &quot;required&quot;);</span>
<span class="line-modified">!     __ pmovsxbw($tmp1$$XMMRegister, $src1$$XMMRegister);</span>
<span class="line-added">+     __ pmovsxbw($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ pmullw($tmp1$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp2$$XMMRegister, $src1$$XMMRegister, 0xEE);</span>
<span class="line-added">+     __ pshufd($dst$$XMMRegister, $src2$$XMMRegister, 0xEE);</span>
<span class="line-added">+     __ pmovsxbw($tmp2$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ pmovsxbw($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ pmullw($tmp2$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);</span>
<span class="line-added">+     __ pand($tmp2$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ pand($dst$$XMMRegister, $tmp1$$XMMRegister);</span>
<span class="line-added">+     __ packuswb($dst$$XMMRegister, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul16B_reg_avx(vec dst, vec src1, vec src2, vec tmp, rRegI scratch) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 1);</span>
<span class="line-modified">!   match(Set dst (MulVB src1 src2));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP tmp, TEMP scratch);</span>
<span class="line-added">+   format %{&quot;vector_mulB $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!   int vector_len = Assembler::AVX_256bit;</span>
<span class="line-added">+     __ vpmovsxbw($tmp$$XMMRegister, $src1$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpmovsxbw($dst$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpmullw($tmp$$XMMRegister, $tmp$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);</span>
<span class="line-added">+     __ vpand($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vextracti128_high($tmp$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ vpackuswb($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister, 0);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul32B_reg_avx(vec dst, vec src1, vec src2, vec tmp1, vec tmp2, rRegI scratch) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-modified">!   match(Set dst (MulVB src1 src2));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP scratch);</span>
<span class="line-modified">!   format %{&quot;vector_mulB $dst,$src1,$src2&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-added">+     assert(UseAVX &gt; 1, &quot;required&quot;);</span>
<span class="line-added">+     int vector_len = Assembler::AVX_256bit;</span>
<span class="line-added">+     __ vextracti128_high($tmp1$$XMMRegister, $src1$$XMMRegister);</span>
<span class="line-added">+     __ vextracti128_high($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ vpmovsxbw($tmp1$$XMMRegister, $tmp1$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpmovsxbw($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpmullw($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpmovsxbw($tmp2$$XMMRegister, $src1$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpmovsxbw($dst$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpmullw($tmp2$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);</span>
<span class="line-added">+     __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpand($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpand($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpackuswb($dst$$XMMRegister, $dst$$XMMRegister, $tmp1$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 0xD8, vector_len);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe( pipe_slow );</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct vmul64B_reg_avx(vec dst, vec src1, vec src2, vec tmp1, vec tmp2, rRegI scratch) %{</span>
<span class="line-added">+   predicate(n-&gt;as_Vector()-&gt;length() == 64);</span>
<span class="line-added">+   match(Set dst (MulVB src1 src2));</span>
<span class="line-added">+   effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP scratch);</span>
<span class="line-added">+   format %{&quot;vector_mulB $dst,$src1,$src2\n\t&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-added">+     int vector_len = Assembler::AVX_512bit;</span>
<span class="line-added">+     __ vextracti64x4_high($tmp1$$XMMRegister, $src1$$XMMRegister);</span>
<span class="line-added">+     __ vextracti64x4_high($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-added">+     __ vpmovsxbw($tmp1$$XMMRegister, $tmp1$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpmovsxbw($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpmullw($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpmovsxbw($tmp2$$XMMRegister, $src1$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpmovsxbw($dst$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpmullw($tmp2$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);</span>
<span class="line-added">+     __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpand($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpand($tmp2$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpackuswb($dst$$XMMRegister, $tmp1$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ evmovdquq($tmp2$$XMMRegister, ExternalAddress(vector_byte_perm_mask()), vector_len, $scratch$$Register);</span>
<span class="line-added">+     __ vpermq($dst$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Shorts/Chars vector mul</span>
<span class="line-modified">! instruct vmulS(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (MulVS dst src));</span>
<span class="line-added">+   format %{ &quot;pmullw $dst,$src\t! mul packedS&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ pmullw($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmulS_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (MulVS src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpmullw $dst,$src1,$src2\t! mul packedS&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpmullw($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmulS_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (MulVS src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpmullw $dst,$src,$mem\t! mul packedS&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpmullw($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Integers vector mul</span>
<span class="line-modified">! instruct vmulI(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (MulVI dst src));</span>
<span class="line-added">+   format %{ &quot;pmulld  $dst,$src\t! mul packedI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseSSE &gt; 3, &quot;required&quot;);</span>
<span class="line-modified">!     __ pmulld($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmulI_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (MulVI src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpmulld $dst,$src1,$src2\t! mul packedI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpmulld($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmulI_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (MulVI src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpmulld $dst,$src,$mem\t! mul packedI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpmulld($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Longs vector mul</span>
<span class="line-modified">! instruct vmulL_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   match(Set dst (MulVL src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpmullq $dst,$src1,$src2\t! mul packedL&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-added">+     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vpmullq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmulL_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   match(Set dst (MulVL src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpmullq $dst,$src,$mem\t! mul packedL&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vpmullq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Floats vector mul</span>
<span class="line-modified">! instruct vmulF(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (MulVF dst src));</span>
<span class="line-added">+   format %{ &quot;mulps   $dst,$src\t! mul packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ mulps($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmulF_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (MulVF src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vmulps  $dst,$src1,$src2\t! mul packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vmulps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmulF_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (MulVF src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vmulps  $dst,$src,$mem\t! mul packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vmulps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Doubles vector mul</span>
<span class="line-modified">! instruct vmulD(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (MulVD dst src));</span>
<span class="line-added">+   format %{ &quot;mulpd   $dst,$src\t! mul packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ mulpd($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmulD_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (MulVD src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vmulpd  $dst,$src1,$src2\t! mul packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vmulpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmulD_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (MulVD src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vmulpd  $dst,$src,$mem\t! mul packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vmulpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vcmov8F_reg(legVec dst, legVec src1, legVec src2, immI8 cop, cmpOp_vcmppd copnd) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (CMoveVF (Binary copnd cop) (Binary src1 src2)));</span>
<span class="line-modified">!   effect(TEMP dst, USE src1, USE src2);</span>
<span class="line-added">+   format %{ &quot;cmpps.$copnd  $dst, $src1, $src2  ! vcmovevf, cond=$cop\n\t&quot;</span>
<span class="line-added">+             &quot;blendvps $dst,$src1,$src2,$dst ! vcmovevf\n\t&quot;</span>
<span class="line-added">+          %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = 1;</span>
<span class="line-modified">!     int cond = (Assembler::Condition)($copnd$$cmpcode);</span>
<span class="line-added">+     __ cmpps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cond, vector_len);</span>
<span class="line-added">+     __ blendvps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vcmov4D_reg(legVec dst, legVec src1, legVec src2, immI8 cop, cmpOp_vcmppd copnd) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (CMoveVD (Binary copnd cop) (Binary src1 src2)));</span>
<span class="line-modified">!   effect(TEMP dst, USE src1, USE src2);</span>
<span class="line-added">+   format %{ &quot;cmppd.$copnd  $dst, $src1, $src2  ! vcmovevd, cond=$cop\n\t&quot;</span>
<span class="line-added">+             &quot;blendvpd $dst,$src1,$src2,$dst ! vcmovevd\n\t&quot;</span>
<span class="line-added">+          %}</span>
    ins_encode %{
      int vector_len = 1;
<span class="line-modified">!     int cond = (Assembler::Condition)($copnd$$cmpcode);</span>
<span class="line-added">+     __ cmppd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cond, vector_len);</span>
<span class="line-added">+     __ blendvpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // --------------------------------- DIV --------------------------------------</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Floats vector div</span>
<span class="line-modified">! instruct vdivF(vec dst, vec src) %{</span>
<span class="line-added">+   predicate(UseAVX == 0);</span>
<span class="line-added">+   match(Set dst (DivVF dst src));</span>
<span class="line-added">+   format %{ &quot;divps   $dst,$src\t! div packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ divps($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vdivF_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (DivVF src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vdivps  $dst,$src1,$src2\t! div packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vdivps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vdivF_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (DivVF src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vdivps  $dst,$src,$mem\t! div packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vdivps($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Doubles vector div</span>
<span class="line-modified">! instruct vdivD(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-modified">!   match(Set dst (DivVD dst src));</span>
<span class="line-modified">!   format %{ &quot;divpd   $dst,$src\t! div packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ divpd($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vdivD_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (DivVD src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vdivpd  $dst,$src1,$src2\t! div packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vdivpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vdivD_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (DivVD src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vdivpd  $dst,$src,$mem\t! div packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vdivpd($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // --------------------------------- Sqrt --------------------------------------</span>
<span class="line-modified">! </span>
<span class="line-modified">! instruct vsqrtF_reg(vec dst, vec src) %{</span>
<span class="line-modified">!   match(Set dst (SqrtVF src));</span>
<span class="line-added">+   format %{ &quot;vsqrtps  $dst,$src\t! sqrt packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vsqrtps($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsqrtF_mem(vec dst, memory mem) %{</span>
<span class="line-modified">!   match(Set dst (SqrtVF (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vsqrtps  $dst,$mem\t! sqrt packedF&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vsqrtps($dst$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Floating point vector sqrt</span>
<span class="line-modified">! instruct vsqrtD_reg(vec dst, vec src) %{</span>
<span class="line-modified">!   match(Set dst (SqrtVD src));</span>
<span class="line-modified">!   format %{ &quot;vsqrtpd  $dst,$src\t! sqrt packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vsqrtpd($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vsqrtD_mem(vec dst, memory mem) %{</span>
<span class="line-modified">!   match(Set dst (SqrtVD (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vsqrtpd  $dst,$mem\t! sqrt packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-added">+     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vsqrtpd($dst$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // ------------------------------ Shift ---------------------------------------</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Left and right shift count vectors are the same on x86</span>
<span class="line-modified">! // (only lowest bits of xmm reg are used for count).</span>
<span class="line-added">+ instruct vshiftcnt(vec dst, rRegI cnt) %{</span>
<span class="line-added">+   match(Set dst (LShiftCntV cnt));</span>
<span class="line-added">+   match(Set dst (RShiftCntV cnt));</span>
<span class="line-added">+   format %{ &quot;movdl    $dst,$cnt\t! load shift count&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ movdl($dst$$XMMRegister, $cnt$$Register);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Byte vector shift</span>
<span class="line-modified">! instruct vshiftB(vec dst, vec src, vec shift, vec tmp, rRegI scratch) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() &lt;= 8);</span>
<span class="line-modified">!   match(Set dst (LShiftVB src shift));</span>
<span class="line-added">+   match(Set dst (RShiftVB src shift));</span>
<span class="line-added">+   match(Set dst (URShiftVB src shift));</span>
<span class="line-added">+   effect(TEMP dst, USE src, USE shift, TEMP tmp, TEMP scratch);</span>
<span class="line-added">+   format %{&quot;vector_byte_shift $dst,$src,$shift&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseSSE &gt; 3, &quot;required&quot;);</span>
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-added">+     __ vextendbw(opcode, $tmp$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+     __ vshiftw(opcode, $tmp$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-added">+     __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);</span>
<span class="line-added">+     __ pand($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ packuswb($dst$$XMMRegister, $dst$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vshift16B(vec dst, vec src, vec shift, vec tmp1, vec tmp2, rRegI scratch) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &lt;= 1);</span>
<span class="line-modified">!   match(Set dst (LShiftVB src shift));</span>
<span class="line-modified">!   match(Set dst (RShiftVB src shift));</span>
<span class="line-added">+   match(Set dst (URShiftVB src shift));</span>
<span class="line-added">+   effect(TEMP dst, USE src, USE shift, TEMP tmp1, TEMP tmp2, TEMP scratch);</span>
<span class="line-added">+   format %{&quot;vector_byte_shift $dst,$src,$shift&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseSSE &gt; 3, &quot;required&quot;);</span>
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ vextendbw(opcode, $tmp1$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+     __ vshiftw(opcode, $tmp1$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-added">+     __ pshufd($tmp2$$XMMRegister, $src$$XMMRegister, 0xE);</span>
<span class="line-added">+     __ vextendbw(opcode, $tmp2$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-added">+     __ vshiftw(opcode, $tmp2$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-added">+     __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);</span>
<span class="line-added">+     __ pand($tmp2$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+     __ pand($dst$$XMMRegister, $tmp1$$XMMRegister);</span>
<span class="line-added">+     __ packuswb($dst$$XMMRegister, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vshift16B_avx(vec dst, vec src, vec shift, vec tmp, rRegI scratch) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 16 &amp;&amp; UseAVX &gt; 1);</span>
<span class="line-modified">!   match(Set dst (LShiftVB src shift));</span>
<span class="line-modified">!   match(Set dst (RShiftVB src shift));</span>
<span class="line-added">+   match(Set dst (URShiftVB src shift));</span>
<span class="line-added">+   effect(TEMP dst, TEMP tmp, TEMP scratch);</span>
<span class="line-added">+   format %{&quot;vector_byte_shift $dst,$src,$shift&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     int vector_len = Assembler::AVX_256bit;</span>
<span class="line-added">+     __ vextendbw(opcode, $tmp$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vshiftw(opcode, $tmp$$XMMRegister, $tmp$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpand($tmp$$XMMRegister, $tmp$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), vector_len, $scratch$$Register);</span>
<span class="line-added">+     __ vextracti128_high($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     __ vpackuswb($dst$$XMMRegister, $tmp$$XMMRegister, $dst$$XMMRegister, 0);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vshift32B_avx(vec dst, vec src, vec shift, vec tmp, rRegI scratch) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 32);</span>
<span class="line-modified">!   match(Set dst (LShiftVB src shift));</span>
<span class="line-modified">!   match(Set dst (RShiftVB src shift));</span>
<span class="line-modified">!   match(Set dst (URShiftVB src shift));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP tmp, TEMP scratch);</span>
<span class="line-modified">!   format %{&quot;vector_byte_shift $dst,$src,$shift&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     assert(UseAVX &gt; 1, &quot;required&quot;);</span>
<span class="line-added">+     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-added">+     int vector_len = Assembler::AVX_256bit;</span>
<span class="line-added">+     __ vextracti128_high($tmp$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+     __ vextendbw(opcode, $tmp$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vextendbw(opcode, $dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vshiftw(opcode, $tmp$$XMMRegister, $tmp$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vshiftw(opcode, $dst$$XMMRegister, $dst$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpand($tmp$$XMMRegister, $tmp$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), vector_len, $scratch$$Register);</span>
<span class="line-added">+     __ vpand($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), vector_len, $scratch$$Register);</span>
<span class="line-added">+     __ vpackuswb($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 0xD8, vector_len);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe( pipe_slow );</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct vshift64B_avx(vec dst, vec src, vec shift, vec tmp1, vec tmp2, rRegI scratch) %{</span>
<span class="line-added">+   predicate(n-&gt;as_Vector()-&gt;length() == 64);</span>
<span class="line-added">+   match(Set dst (LShiftVB src shift));</span>
<span class="line-added">+   match(Set dst (RShiftVB src shift));</span>
<span class="line-added">+   match(Set dst (URShiftVB src shift));</span>
<span class="line-added">+   effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP scratch);</span>
<span class="line-added">+   format %{&quot;vector_byte_shift $dst,$src,$shift&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-added">+     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-added">+     int vector_len = Assembler::AVX_512bit;</span>
<span class="line-added">+     __ vextracti64x4($tmp1$$XMMRegister, $src$$XMMRegister, 1);</span>
<span class="line-added">+     __ vextendbw(opcode, $tmp1$$XMMRegister, $tmp1$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vextendbw(opcode, $tmp2$$XMMRegister, $src$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vshiftw(opcode, $tmp1$$XMMRegister, $tmp1$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vshiftw(opcode, $tmp2$$XMMRegister, $tmp2$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);</span>
<span class="line-added">+     __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpand($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpand($tmp2$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ vpackuswb($dst$$XMMRegister, $tmp1$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-added">+     __ evmovdquq($tmp2$$XMMRegister, ExternalAddress(vector_byte_perm_mask()), vector_len, $scratch$$Register);</span>
<span class="line-added">+     __ vpermq($dst$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Shorts vector logical right shift produces incorrect Java result</span>
<span class="line-modified">! // for negative data because java code convert short value into int with</span>
<span class="line-modified">! // sign extension before a shift. But char vectors are fine since chars are</span>
<span class="line-modified">! // unsigned values.</span>
<span class="line-added">+ // Shorts/Chars vector left shift</span>
<span class="line-added">+ instruct vshiftS(vec dst, vec src, vec shift) %{</span>
<span class="line-added">+   match(Set dst (LShiftVS src shift));</span>
<span class="line-added">+   match(Set dst (RShiftVS src shift));</span>
<span class="line-added">+   match(Set dst (URShiftVS src shift));</span>
<span class="line-added">+   effect(TEMP dst, USE src, USE shift);</span>
<span class="line-added">+   format %{ &quot;vshiftw  $dst,$src,$shift\t! shift packedS&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     if (UseAVX &gt; 0) {</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vshiftw(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vlen_enc);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       int vlen = vector_length(this);</span>
<span class="line-added">+       if (vlen == 2) {</span>
<span class="line-added">+         __ movflt($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+         __ vshiftw(opcode, $dst$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-added">+       } else if (vlen == 4) {</span>
<span class="line-added">+         __ movdbl($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+         __ vshiftw(opcode, $dst$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         assert (vlen == 8, &quot;sanity&quot;);</span>
<span class="line-added">+         __ movdqu($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+         __ vshiftw(opcode, $dst$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Integers vector left shift</span>
<span class="line-modified">! instruct vshiftI(vec dst, vec src, vec shift) %{</span>
<span class="line-modified">!   match(Set dst (LShiftVI src shift));</span>
<span class="line-modified">!   match(Set dst (RShiftVI src shift));</span>
<span class="line-modified">!   match(Set dst (URShiftVI src shift));</span>
<span class="line-modified">!   effect(TEMP dst, USE src, USE shift);</span>
<span class="line-added">+   format %{ &quot;vshiftd  $dst,$src,$shift\t! shift packedI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-added">+     if (UseAVX &gt; 0) {</span>
<span class="line-added">+       int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+       __ vshiftd(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       int vlen = vector_length(this);</span>
<span class="line-added">+       if (vlen == 2) {</span>
<span class="line-added">+         __ movdbl($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+         __ vshiftd(opcode, $dst$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         assert(vlen == 4, &quot;sanity&quot;);</span>
<span class="line-added">+         __ movdqu($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+         __ vshiftd(opcode, $dst$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // Longs vector shift</span>
<span class="line-modified">! instruct vshiftL(vec dst, vec src, vec shift) %{</span>
<span class="line-modified">!   match(Set dst (LShiftVL src shift));</span>
<span class="line-modified">!   match(Set dst (URShiftVL src shift));</span>
<span class="line-added">+   effect(TEMP dst, USE src, USE shift);</span>
<span class="line-added">+   format %{ &quot;vshiftq  $dst,$src,$shift\t! shift packedL&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     if (UseAVX &gt; 0) {</span>
<span class="line-added">+       int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+       __ vshiftq(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(vector_length(this) == 2, &quot;&quot;);</span>
<span class="line-added">+       __ movdqu($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+       __ vshiftq(opcode, $dst$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // -------------------ArithmeticRightShift -----------------------------------</span>
<span class="line-modified">! // Long vector arithmetic right shift</span>
<span class="line-modified">! instruct vshiftL_arith_reg(vec dst, vec src, vec shift, vec tmp, rRegI scratch) %{</span>
<span class="line-modified">!   predicate(UseAVX &lt;= 2);</span>
<span class="line-added">+   match(Set dst (RShiftVL src shift));</span>
<span class="line-added">+   effect(TEMP dst, TEMP tmp, TEMP scratch);</span>
<span class="line-added">+   format %{ &quot;vshiftq $dst,$src,$shift&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen == 2) {</span>
<span class="line-added">+       assert(UseSSE &gt;= 2, &quot;required&quot;);</span>
<span class="line-added">+       __ movdqu($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+       __ psrlq($dst$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-added">+       __ movdqu($tmp$$XMMRegister, ExternalAddress(vector_long_sign_mask()), $scratch$$Register);</span>
<span class="line-added">+       __ psrlq($tmp$$XMMRegister, $shift$$XMMRegister);</span>
<span class="line-added">+       __ pxor($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+       __ psubq($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(vlen == 4, &quot;sanity&quot;);</span>
<span class="line-added">+       assert(UseAVX &gt; 1, &quot;required&quot;);</span>
<span class="line-added">+       int vector_len = Assembler::AVX_256bit;</span>
<span class="line-added">+       __ vpsrlq($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ vmovdqu($tmp$$XMMRegister, ExternalAddress(vector_long_sign_mask()), $scratch$$Register);</span>
<span class="line-added">+       __ vpsrlq($tmp$$XMMRegister, $tmp$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-added">+       __ vpsubq($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vshiftL_arith_reg_evex(vec dst, vec src, vec shift) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 2);</span>
<span class="line-modified">!   match(Set dst (RShiftVL src shift));</span>
<span class="line-modified">!   format %{ &quot;vshiftq $dst,$src,$shift&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ evpsraq($dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // --------------------------------- AND --------------------------------------</span>
<span class="line-modified">! </span>
<span class="line-modified">! instruct vand(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-added">+   match(Set dst (AndV dst src));</span>
<span class="line-added">+   format %{ &quot;pand    $dst,$src\t! and vectors&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ pand($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AndV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpand   $dst,$src1,$src2\t! and vectors&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpand($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vand_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (AndV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpand   $dst,$src,$mem\t! and vectors&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vpand($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // --------------------------------- OR ---------------------------------------</span>
<span class="line-modified">! </span>
<span class="line-modified">! instruct vor(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-added">+   match(Set dst (OrV dst src));</span>
<span class="line-added">+   format %{ &quot;por     $dst,$src\t! or vectors&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ por($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (OrV src1 src2));</span>
<span class="line-modified">!   format %{ &quot;vpor    $dst,$src1,$src2\t! or vectors&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpor($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vor_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
<span class="line-modified">!   match(Set dst (OrV src (LoadVector mem)));</span>
<span class="line-modified">!   format %{ &quot;vpor    $dst,$src,$mem\t! or vectors&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpor($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // --------------------------------- XOR --------------------------------------</span>
<span class="line-modified">! </span>
<span class="line-modified">! instruct vxor(vec dst, vec src) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
<span class="line-added">+   match(Set dst (XorV dst src));</span>
<span class="line-added">+   format %{ &quot;pxor    $dst,$src\t! xor vectors&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ pxor($dst$$XMMRegister, $src$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
    match(Set dst (XorV src1 src2));
<span class="line-modified">!   format %{ &quot;vpxor   $dst,$src1,$src2\t! xor vectors&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
      __ vpxor($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vxor_mem(vec dst, vec src, memory mem) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
    match(Set dst (XorV src (LoadVector mem)));
<span class="line-modified">!   format %{ &quot;vpxor   $dst,$src,$mem\t! xor vectors&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
      __ vpxor($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // --------------------------------- ABS --------------------------------------</span>
<span class="line-modified">! // a = |a|</span>
<span class="line-modified">! instruct vabsB_reg(vec dst, vec src) %{</span>
<span class="line-modified">!   match(Set dst (AbsVB  src));</span>
<span class="line-modified">!   format %{ &quot;vabsb $dst,$src\t# $dst = |$src| abs packedB&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen &lt;= 16) {</span>
<span class="line-added">+       __ pabsb($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vpabsb($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vabsS_reg(vec dst, vec src) %{</span>
<span class="line-modified">!   match(Set dst (AbsVS  src));</span>
<span class="line-modified">!   format %{ &quot;vabsw $dst,$src\t# $dst = |$src| abs packedS&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen &lt;= 8) {</span>
<span class="line-added">+       __ pabsw($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vpabsw($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vabsI_reg(vec dst, vec src) %{</span>
<span class="line-modified">!   match(Set dst (AbsVI  src));</span>
<span class="line-modified">!   format %{ &quot;pabsd $dst,$src\t# $dst = |$src| abs packedI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-modified">!     if (vlen &lt;= 4) {</span>
<span class="line-added">+       __ pabsd($dst$$XMMRegister, $src$$XMMRegister);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vpabsd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vabsL_reg(vec dst, vec src) %{</span>
<span class="line-modified">!   match(Set dst (AbsVL  src));</span>
<span class="line-modified">!   format %{ &quot;evpabsq $dst,$src\t# $dst = |$src| abs packedL&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ evpabsq($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // --------------------------------- ABSNEG --------------------------------------</span>
  
<span class="line-modified">! instruct vabsnegF(vec dst, vec src, rRegI scratch) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() != 4); // handled by 1-operand instruction vabsneg4F</span>
<span class="line-modified">!   match(Set dst (AbsVF src));</span>
<span class="line-modified">!   match(Set dst (NegVF src));</span>
<span class="line-modified">!   effect(TEMP scratch);</span>
<span class="line-added">+   format %{ &quot;vabsnegf $dst,$src,[mask]\t# absneg packedF&quot; %}</span>
    ins_cost(150);
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     int vlen = vector_length(this);</span>
<span class="line-added">+     if (vlen == 2) {</span>
<span class="line-added">+       __ vabsnegf(opcode, $dst$$XMMRegister, $src$$XMMRegister, $scratch$$Register);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(vlen == 8 || vlen == 16, &quot;required&quot;);</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vabsnegf(opcode, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc, $scratch$$Register);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vabsneg4F(vec dst, rRegI scratch) %{</span>
<span class="line-modified">!   predicate(n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (AbsVF dst));</span>
<span class="line-modified">!   match(Set dst (NegVF dst));</span>
<span class="line-modified">!   effect(TEMP scratch);</span>
<span class="line-added">+   format %{ &quot;vabsnegf $dst,[mask]\t# absneg packed4F&quot; %}</span>
    ins_cost(150);
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     __ vabsnegf(opcode, $dst$$XMMRegister, $dst$$XMMRegister, $scratch$$Register);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vabsnegD(vec dst, vec src, rRegI scratch) %{</span>
<span class="line-modified">!   match(Set dst (AbsVD  src));</span>
<span class="line-modified">!   match(Set dst (NegVD  src));</span>
<span class="line-modified">!   effect(TEMP scratch);</span>
<span class="line-modified">!   format %{ &quot;vabsnegd $dst,$src,[mask]\t# absneg packedD&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     uint vlen = vector_length(this);</span>
<span class="line-added">+     if (vlen == 2) {</span>
<span class="line-added">+       assert(UseSSE &gt;= 2, &quot;required&quot;);</span>
<span class="line-added">+       __ vabsnegd(opcode, $dst$$XMMRegister, $src$$XMMRegister, $scratch$$Register);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-added">+       __ vabsnegd(opcode, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc, $scratch$$Register);</span>
<span class="line-added">+     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-added">+ // --------------------------------- FMA --------------------------------------</span>
  // a * b + c
<span class="line-modified">! </span>
<span class="line-modified">! instruct vfmaF_reg(vec a, vec b, vec c) %{</span>
    match(Set c (FmaVF  c (Binary a b)));
<span class="line-modified">!   format %{ &quot;fmaps $a,$b,$c\t# $c = $a * $b + $c fma packedF&quot; %}</span>
    ins_cost(150);
    ins_encode %{
<span class="line-modified">!     assert(UseFMA, &quot;not enabled&quot;);</span>
<span class="line-added">+     int vector_len = vector_length_encoding(this);</span>
      __ vfmaf($c$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $c$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vfmaF_mem(vec a, memory b, vec c) %{</span>
    match(Set c (FmaVF  c (Binary a (LoadVector b))));
<span class="line-modified">!   format %{ &quot;fmaps $a,$b,$c\t# $c = $a * $b + $c fma packedF&quot; %}</span>
    ins_cost(150);
    ins_encode %{
<span class="line-modified">!     assert(UseFMA, &quot;not enabled&quot;);</span>
<span class="line-added">+     int vector_len = vector_length_encoding(this);</span>
      __ vfmaf($c$$XMMRegister, $a$$XMMRegister, $b$$Address, $c$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vfmaD_reg(vec a, vec b, vec c) %{</span>
<span class="line-modified">!   match(Set c (FmaVD  c (Binary a b)));</span>
<span class="line-modified">!   format %{ &quot;fmapd $a,$b,$c\t# $c = $a * $b + $c fma packedD&quot; %}</span>
    ins_cost(150);
    ins_encode %{
<span class="line-modified">!     assert(UseFMA, &quot;not enabled&quot;);</span>
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vfmad($c$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $c$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vfmaD_mem(vec a, memory b, vec c) %{</span>
<span class="line-modified">!   match(Set c (FmaVD  c (Binary a (LoadVector b))));</span>
<span class="line-modified">!   format %{ &quot;fmapd $a,$b,$c\t# $c = $a * $b + $c fma packedD&quot; %}</span>
    ins_cost(150);
    ins_encode %{
<span class="line-modified">!     assert(UseFMA, &quot;not enabled&quot;);</span>
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vfmad($c$$XMMRegister, $a$$XMMRegister, $b$$Address, $c$$XMMRegister, vector_len);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  // --------------------------------- Vector Multiply Add --------------------------------------
  
<span class="line-modified">! instruct vmuladdS2I_reg_sse(vec dst, vec src1) %{</span>
<span class="line-modified">!   predicate(UseAVX == 0);</span>
    match(Set dst (MulAddVS2VI dst src1));
<span class="line-modified">!   format %{ &quot;pmaddwd $dst,$dst,$src1\t! muladd packedStoI&quot; %}</span>
    ins_encode %{
      __ pmaddwd($dst$$XMMRegister, $src1$$XMMRegister);
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmuladdS2I_reg_avx(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(UseAVX &gt; 0);</span>
    match(Set dst (MulAddVS2VI src1 src2));
<span class="line-modified">!   format %{ &quot;vpmaddwd $dst,$src1,$src2\t! muladd packedStoI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
      __ vpmaddwd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
  // --------------------------------- Vector Multiply Add Add ----------------------------------
  
<span class="line-modified">! instruct vmuladdaddS2I_reg(vec dst, vec src1, vec src2) %{</span>
<span class="line-modified">!   predicate(VM_Version::supports_vnni());</span>
    match(Set dst (AddVI (MulAddVS2VI src1 src2) dst));
<span class="line-modified">!   format %{ &quot;evpdpwssd $dst,$src1,$src2\t! muladdadd packedStoI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
      __ evpdpwssd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
    ins_cost(10);
  %}
  
  // --------------------------------- PopCount --------------------------------------
  
<span class="line-modified">! instruct vpopcountI(vec dst, vec src) %{</span>
    match(Set dst (PopCountVI src));
<span class="line-modified">!   format %{ &quot;vpopcntd  $dst,$src\t! vector popcount packedI&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UsePopCountInstruction, &quot;not enabled&quot;);</span>
  
<span class="line-modified">!     int vector_len = vector_length_encoding(this);</span>
      __ vpopcntd($dst$$XMMRegister, $src$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
</pre>
<center><a href="vm_version_x86.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_32.ad.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
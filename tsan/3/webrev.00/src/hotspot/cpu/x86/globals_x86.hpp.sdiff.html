<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/globals_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globalDefinitions_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/globals_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef CPU_X86_GLOBALS_X86_HPP
 26 #define CPU_X86_GLOBALS_X86_HPP
 27 
 28 #include &quot;utilities/globalDefinitions.hpp&quot;
 29 #include &quot;utilities/macros.hpp&quot;
 30 
 31 // Sets the default values for platform dependent flags used by the runtime system.
 32 // (see globals.hpp)
 33 
<span class="line-removed"> 34 define_pd_global(bool, ShareVtableStubs,         true);</span>
<span class="line-removed"> 35 define_pd_global(bool, NeedsDeoptSuspend,        false); // only register window machines need this</span>
<span class="line-removed"> 36 </span>
 37 define_pd_global(bool, ImplicitNullChecks,       true);  // Generate code for implicit null checks
 38 define_pd_global(bool, TrapBasedNullChecks,      false); // Not needed on x86.
 39 define_pd_global(bool, UncommonNullCast,         true);  // Uncommon-trap NULLs passed to check cast
 40 
 41 define_pd_global(uintx, CodeCacheSegmentSize,    64 TIERED_ONLY(+64)); // Tiered compilation has large code-entry alignment.
 42 // See 4827828 for this change. There is no globals_core_i486.hpp. I can&#39;t
 43 // assign a different value for C2 without touching a number of files. Use
 44 // #ifdef to minimize the change as it&#39;s late in Mantis. -- FIXME.
 45 // c1 doesn&#39;t have this problem because the fix to 4858033 assures us
 46 // the the vep is aligned at CodeEntryAlignment whereas c2 only aligns
 47 // the uep and the vep doesn&#39;t get real alignment but just slops on by
 48 // only assured that the entry instruction meets the 5 byte size requirement.
 49 #if COMPILER2_OR_JVMCI
 50 define_pd_global(intx, CodeEntryAlignment,       32);
 51 #else
 52 define_pd_global(intx, CodeEntryAlignment,       16);
 53 #endif // COMPILER2_OR_JVMCI
 54 define_pd_global(intx, OptoLoopAlignment,        16);
 55 define_pd_global(intx, InlineFrequencyCount,     100);
 56 define_pd_global(intx, InlineSmallCode,          1000);
</pre>
<hr />
<pre>
 67 // Java_java_net_SocketOutputStream_socketWrite0() uses a 64k buffer on the
 68 // stack if compiled for unix and LP64. To pass stack overflow tests we need
 69 // 20 shadow pages.
 70 #define DEFAULT_STACK_SHADOW_PAGES (NOT_WIN64(20) WIN64_ONLY(7) DEBUG_ONLY(+2))
 71 // For those clients that do not use write socket, we allow
 72 // the min range value to be below that of the default
 73 #define MIN_STACK_SHADOW_PAGES (NOT_WIN64(10) WIN64_ONLY(7) DEBUG_ONLY(+2))
 74 #else
 75 #define DEFAULT_STACK_SHADOW_PAGES (4 DEBUG_ONLY(+5))
 76 #define MIN_STACK_SHADOW_PAGES DEFAULT_STACK_SHADOW_PAGES
 77 #endif // _LP64
 78 
 79 define_pd_global(intx, StackYellowPages, DEFAULT_STACK_YELLOW_PAGES);
 80 define_pd_global(intx, StackRedPages, DEFAULT_STACK_RED_PAGES);
 81 define_pd_global(intx, StackShadowPages, DEFAULT_STACK_SHADOW_PAGES);
 82 define_pd_global(intx, StackReservedPages, DEFAULT_STACK_RESERVED_PAGES);
 83 
 84 define_pd_global(bool, RewriteBytecodes,     true);
 85 define_pd_global(bool, RewriteFrequentPairs, true);
 86 
<span class="line-removed"> 87 // GC Ergo Flags</span>
<span class="line-removed"> 88 define_pd_global(size_t, CMSYoungGenPerWorker, 64*M);  // default max size of CMS young gen, per GC worker thread</span>
<span class="line-removed"> 89 </span>
 90 define_pd_global(uintx, TypeProfileLevel, 111);
 91 
 92 define_pd_global(bool, CompactStrings, true);
 93 
 94 define_pd_global(bool, PreserveFramePointer, false);
 95 
 96 define_pd_global(intx, InitArrayShortSize, 8*BytesPerLong);
 97 
<span class="line-removed"> 98 #if defined(_LP64) || defined(_WINDOWS)</span>
<span class="line-removed"> 99 define_pd_global(bool, ThreadLocalHandshakes, true);</span>
<span class="line-removed">100 #else</span>
<span class="line-removed">101 // get_thread() is slow on linux 32 bit, therefore off by default</span>
<span class="line-removed">102 define_pd_global(bool, ThreadLocalHandshakes, false);</span>
<span class="line-removed">103 #endif</span>
<span class="line-removed">104 </span>
105 #define ARCH_FLAGS(develop, \
106                    product, \
107                    diagnostic, \
108                    experimental, \
109                    notproduct, \
110                    range, \
<span class="line-modified">111                    constraint, \</span>
<span class="line-removed">112                    writeable) \</span>
113                                                                             \
114   develop(bool, IEEEPrecision, true,                                        \
115           &quot;Enables IEEE precision (for INTEL only)&quot;)                        \
116                                                                             \
117   product(bool, UseStoreImmI16, true,                                       \
118           &quot;Use store immediate 16-bits value instruction on x86&quot;)           \
119                                                                             \
120   product(intx, UseAVX, 3,                                                  \
121           &quot;Highest supported AVX instructions set on x86/x64&quot;)              \
122           range(0, 99)                                                      \
123                                                                             \
124   product(bool, UseCLMUL, false,                                            \
125           &quot;Control whether CLMUL instructions can be used on x86/x64&quot;)      \
126                                                                             \
127   diagnostic(bool, UseIncDec, true,                                         \
128           &quot;Use INC, DEC instructions on x86&quot;)                               \
129                                                                             \
130   product(bool, UseNewLongLShift, false,                                    \
131           &quot;Use optimized bitwise shift left&quot;)                               \
132                                                                             \
</pre>
<hr />
<pre>
197   experimental(bool, UseRTMXendForLockBusy, true,                           \
198           &quot;Use RTM Xend instead of Xabort when lock busy&quot;)                  \
199                                                                             \
200   /* assembler */                                                           \
201   product(bool, UseCountLeadingZerosInstruction, false,                     \
202           &quot;Use count leading zeros instruction&quot;)                            \
203                                                                             \
204   product(bool, UseCountTrailingZerosInstruction, false,                    \
205           &quot;Use count trailing zeros instruction&quot;)                           \
206                                                                             \
207   product(bool, UseSSE42Intrinsics, false,                                  \
208           &quot;SSE4.2 versions of intrinsics&quot;)                                  \
209                                                                             \
210   product(bool, UseBMI1Instructions, false,                                 \
211           &quot;Use BMI1 instructions&quot;)                                          \
212                                                                             \
213   product(bool, UseBMI2Instructions, false,                                 \
214           &quot;Use BMI2 instructions&quot;)                                          \
215                                                                             \
216   diagnostic(bool, UseLibmIntrinsic, true,                                  \
<span class="line-modified">217           &quot;Use Libm Intrinsics&quot;)</span>










218 #endif // CPU_X86_GLOBALS_X86_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef CPU_X86_GLOBALS_X86_HPP
 26 #define CPU_X86_GLOBALS_X86_HPP
 27 
 28 #include &quot;utilities/globalDefinitions.hpp&quot;
 29 #include &quot;utilities/macros.hpp&quot;
 30 
 31 // Sets the default values for platform dependent flags used by the runtime system.
 32 // (see globals.hpp)
 33 



 34 define_pd_global(bool, ImplicitNullChecks,       true);  // Generate code for implicit null checks
 35 define_pd_global(bool, TrapBasedNullChecks,      false); // Not needed on x86.
 36 define_pd_global(bool, UncommonNullCast,         true);  // Uncommon-trap NULLs passed to check cast
 37 
 38 define_pd_global(uintx, CodeCacheSegmentSize,    64 TIERED_ONLY(+64)); // Tiered compilation has large code-entry alignment.
 39 // See 4827828 for this change. There is no globals_core_i486.hpp. I can&#39;t
 40 // assign a different value for C2 without touching a number of files. Use
 41 // #ifdef to minimize the change as it&#39;s late in Mantis. -- FIXME.
 42 // c1 doesn&#39;t have this problem because the fix to 4858033 assures us
 43 // the the vep is aligned at CodeEntryAlignment whereas c2 only aligns
 44 // the uep and the vep doesn&#39;t get real alignment but just slops on by
 45 // only assured that the entry instruction meets the 5 byte size requirement.
 46 #if COMPILER2_OR_JVMCI
 47 define_pd_global(intx, CodeEntryAlignment,       32);
 48 #else
 49 define_pd_global(intx, CodeEntryAlignment,       16);
 50 #endif // COMPILER2_OR_JVMCI
 51 define_pd_global(intx, OptoLoopAlignment,        16);
 52 define_pd_global(intx, InlineFrequencyCount,     100);
 53 define_pd_global(intx, InlineSmallCode,          1000);
</pre>
<hr />
<pre>
 64 // Java_java_net_SocketOutputStream_socketWrite0() uses a 64k buffer on the
 65 // stack if compiled for unix and LP64. To pass stack overflow tests we need
 66 // 20 shadow pages.
 67 #define DEFAULT_STACK_SHADOW_PAGES (NOT_WIN64(20) WIN64_ONLY(7) DEBUG_ONLY(+2))
 68 // For those clients that do not use write socket, we allow
 69 // the min range value to be below that of the default
 70 #define MIN_STACK_SHADOW_PAGES (NOT_WIN64(10) WIN64_ONLY(7) DEBUG_ONLY(+2))
 71 #else
 72 #define DEFAULT_STACK_SHADOW_PAGES (4 DEBUG_ONLY(+5))
 73 #define MIN_STACK_SHADOW_PAGES DEFAULT_STACK_SHADOW_PAGES
 74 #endif // _LP64
 75 
 76 define_pd_global(intx, StackYellowPages, DEFAULT_STACK_YELLOW_PAGES);
 77 define_pd_global(intx, StackRedPages, DEFAULT_STACK_RED_PAGES);
 78 define_pd_global(intx, StackShadowPages, DEFAULT_STACK_SHADOW_PAGES);
 79 define_pd_global(intx, StackReservedPages, DEFAULT_STACK_RESERVED_PAGES);
 80 
 81 define_pd_global(bool, RewriteBytecodes,     true);
 82 define_pd_global(bool, RewriteFrequentPairs, true);
 83 



 84 define_pd_global(uintx, TypeProfileLevel, 111);
 85 
 86 define_pd_global(bool, CompactStrings, true);
 87 
 88 define_pd_global(bool, PreserveFramePointer, false);
 89 
 90 define_pd_global(intx, InitArrayShortSize, 8*BytesPerLong);
 91 







 92 #define ARCH_FLAGS(develop, \
 93                    product, \
 94                    diagnostic, \
 95                    experimental, \
 96                    notproduct, \
 97                    range, \
<span class="line-modified"> 98                    constraint) \</span>

 99                                                                             \
100   develop(bool, IEEEPrecision, true,                                        \
101           &quot;Enables IEEE precision (for INTEL only)&quot;)                        \
102                                                                             \
103   product(bool, UseStoreImmI16, true,                                       \
104           &quot;Use store immediate 16-bits value instruction on x86&quot;)           \
105                                                                             \
106   product(intx, UseAVX, 3,                                                  \
107           &quot;Highest supported AVX instructions set on x86/x64&quot;)              \
108           range(0, 99)                                                      \
109                                                                             \
110   product(bool, UseCLMUL, false,                                            \
111           &quot;Control whether CLMUL instructions can be used on x86/x64&quot;)      \
112                                                                             \
113   diagnostic(bool, UseIncDec, true,                                         \
114           &quot;Use INC, DEC instructions on x86&quot;)                               \
115                                                                             \
116   product(bool, UseNewLongLShift, false,                                    \
117           &quot;Use optimized bitwise shift left&quot;)                               \
118                                                                             \
</pre>
<hr />
<pre>
183   experimental(bool, UseRTMXendForLockBusy, true,                           \
184           &quot;Use RTM Xend instead of Xabort when lock busy&quot;)                  \
185                                                                             \
186   /* assembler */                                                           \
187   product(bool, UseCountLeadingZerosInstruction, false,                     \
188           &quot;Use count leading zeros instruction&quot;)                            \
189                                                                             \
190   product(bool, UseCountTrailingZerosInstruction, false,                    \
191           &quot;Use count trailing zeros instruction&quot;)                           \
192                                                                             \
193   product(bool, UseSSE42Intrinsics, false,                                  \
194           &quot;SSE4.2 versions of intrinsics&quot;)                                  \
195                                                                             \
196   product(bool, UseBMI1Instructions, false,                                 \
197           &quot;Use BMI1 instructions&quot;)                                          \
198                                                                             \
199   product(bool, UseBMI2Instructions, false,                                 \
200           &quot;Use BMI2 instructions&quot;)                                          \
201                                                                             \
202   diagnostic(bool, UseLibmIntrinsic, true,                                  \
<span class="line-modified">203           &quot;Use Libm Intrinsics&quot;)                                            \</span>
<span class="line-added">204                                                                             \</span>
<span class="line-added">205   /* Minimum array size in bytes to use AVX512 intrinsics */                \</span>
<span class="line-added">206   /* for copy, inflate and fill which don&#39;t bail out early based on any */  \</span>
<span class="line-added">207   /* condition. When this value is set to zero compare operations like */   \</span>
<span class="line-added">208   /* compare, vectorizedMismatch, compress can also use AVX512 intrinsics.*/\</span>
<span class="line-added">209   diagnostic(int, AVX3Threshold, 4096,                                      \</span>
<span class="line-added">210              &quot;Minimum array size in bytes to use AVX512 intrinsics&quot;         \</span>
<span class="line-added">211              &quot;for copy, inflate and fill. When this value is set as zero&quot;   \</span>
<span class="line-added">212              &quot;compare operations can also use AVX512 intrinsics.&quot;)          \</span>
<span class="line-added">213           range(0, max_jint)</span>
214 #endif // CPU_X86_GLOBALS_X86_HPP
</pre>
</td>
</tr>
</table>
<center><a href="globalDefinitions_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
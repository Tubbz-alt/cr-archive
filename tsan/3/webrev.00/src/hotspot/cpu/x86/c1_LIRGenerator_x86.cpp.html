<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Compilation.hpp&quot;
  27 #include &quot;c1/c1_FrameMap.hpp&quot;
  28 #include &quot;c1/c1_Instruction.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArray.hpp&quot;
  34 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  35 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  36 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  37 #include &quot;runtime/sharedRuntime.hpp&quot;
  38 #include &quot;runtime/stubRoutines.hpp&quot;
  39 #include &quot;utilities/powerOfTwo.hpp&quot;
  40 #include &quot;vmreg_x86.inline.hpp&quot;
  41 
  42 #ifdef ASSERT
  43 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  44 #else
  45 #define __ gen()-&gt;lir()-&gt;
  46 #endif
  47 
  48 // Item will be loaded into a byte register; Intel only
  49 void LIRItem::load_byte_item() {
  50   load_item();
  51   LIR_Opr res = result();
  52 
  53   if (!res-&gt;is_virtual() || !_gen-&gt;is_vreg_flag_set(res, LIRGenerator::byte_reg)) {
  54     // make sure that it is a byte register
  55     assert(!value()-&gt;type()-&gt;is_float() &amp;&amp; !value()-&gt;type()-&gt;is_double(),
  56            &quot;can&#39;t load floats in byte register&quot;);
  57     LIR_Opr reg = _gen-&gt;rlock_byte(T_BYTE);
  58     __ move(res, reg);
  59 
  60     _result = reg;
  61   }
  62 }
  63 
  64 
  65 void LIRItem::load_nonconstant() {
  66   LIR_Opr r = value()-&gt;operand();
  67   if (r-&gt;is_constant()) {
  68     _result = r;
  69   } else {
  70     load_item();
  71   }
  72 }
  73 
  74 //--------------------------------------------------------------
  75 //               LIRGenerator
  76 //--------------------------------------------------------------
  77 
  78 
  79 LIR_Opr LIRGenerator::exceptionOopOpr() { return FrameMap::rax_oop_opr; }
  80 LIR_Opr LIRGenerator::exceptionPcOpr()  { return FrameMap::rdx_opr; }
  81 LIR_Opr LIRGenerator::divInOpr()        { return FrameMap::rax_opr; }
  82 LIR_Opr LIRGenerator::divOutOpr()       { return FrameMap::rax_opr; }
  83 LIR_Opr LIRGenerator::remOutOpr()       { return FrameMap::rdx_opr; }
  84 LIR_Opr LIRGenerator::shiftCountOpr()   { return FrameMap::rcx_opr; }
  85 LIR_Opr LIRGenerator::syncLockOpr()     { return new_register(T_INT); }
  86 LIR_Opr LIRGenerator::syncTempOpr()     { return FrameMap::rax_opr; }
  87 LIR_Opr LIRGenerator::getThreadTemp()   { return LIR_OprFact::illegalOpr; }
  88 
  89 
  90 LIR_Opr LIRGenerator::result_register_for(ValueType* type, bool callee) {
  91   LIR_Opr opr;
  92   switch (type-&gt;tag()) {
  93     case intTag:     opr = FrameMap::rax_opr;          break;
  94     case objectTag:  opr = FrameMap::rax_oop_opr;      break;
  95     case longTag:    opr = FrameMap::long0_opr;        break;
  96     case floatTag:   opr = UseSSE &gt;= 1 ? FrameMap::xmm0_float_opr  : FrameMap::fpu0_float_opr;  break;
  97     case doubleTag:  opr = UseSSE &gt;= 2 ? FrameMap::xmm0_double_opr : FrameMap::fpu0_double_opr;  break;
  98 
  99     case addressTag:
 100     default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
 101   }
 102 
 103   assert(opr-&gt;type_field() == as_OprType(as_BasicType(type)), &quot;type mismatch&quot;);
 104   return opr;
 105 }
 106 
 107 
 108 LIR_Opr LIRGenerator::rlock_byte(BasicType type) {
 109   LIR_Opr reg = new_register(T_INT);
 110   set_vreg_flag(reg, LIRGenerator::byte_reg);
 111   return reg;
 112 }
 113 
 114 
 115 //--------- loading items into registers --------------------------------
 116 
 117 
 118 // i486 instructions can inline constants
 119 bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {
 120   if (type == T_SHORT || type == T_CHAR) {
 121     // there is no immediate move of word values in asembler_i486.?pp
 122     return false;
 123   }
 124   Constant* c = v-&gt;as_Constant();
 125   if (c &amp;&amp; c-&gt;state_before() == NULL) {
 126     // constants of any type can be stored directly, except for
 127     // unloaded object constants.
 128     return true;
 129   }
 130   return false;
 131 }
 132 
 133 
 134 bool LIRGenerator::can_inline_as_constant(Value v) const {
 135   if (v-&gt;type()-&gt;tag() == longTag) return false;
 136   return v-&gt;type()-&gt;tag() != objectTag ||
 137     (v-&gt;type()-&gt;is_constant() &amp;&amp; v-&gt;type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object());
 138 }
 139 
 140 
 141 bool LIRGenerator::can_inline_as_constant(LIR_Const* c) const {
 142   if (c-&gt;type() == T_LONG) return false;
 143   return c-&gt;type() != T_OBJECT || c-&gt;as_jobject() == NULL;
 144 }
 145 
 146 
 147 LIR_Opr LIRGenerator::safepoint_poll_register() {
 148   NOT_LP64( if (SafepointMechanism::uses_thread_local_poll()) { return new_register(T_ADDRESS); } )
 149   return LIR_OprFact::illegalOpr;
 150 }
 151 
 152 
 153 LIR_Address* LIRGenerator::generate_address(LIR_Opr base, LIR_Opr index,
 154                                             int shift, int disp, BasicType type) {
 155   assert(base-&gt;is_register(), &quot;must be&quot;);
 156   if (index-&gt;is_constant()) {
 157     LIR_Const *constant = index-&gt;as_constant_ptr();
 158 #ifdef _LP64
 159     jlong c;
 160     if (constant-&gt;type() == T_INT) {
 161       c = (jlong(index-&gt;as_jint()) &lt;&lt; shift) + disp;
 162     } else {
 163       assert(constant-&gt;type() == T_LONG, &quot;should be&quot;);
 164       c = (index-&gt;as_jlong() &lt;&lt; shift) + disp;
 165     }
 166     if ((jlong)((jint)c) == c) {
 167       return new LIR_Address(base, (jint)c, type);
 168     } else {
 169       LIR_Opr tmp = new_register(T_LONG);
 170       __ move(index, tmp);
 171       return new LIR_Address(base, tmp, type);
 172     }
 173 #else
 174     return new LIR_Address(base,
 175                            ((intx)(constant-&gt;as_jint()) &lt;&lt; shift) + disp,
 176                            type);
 177 #endif
 178   } else {
 179     return new LIR_Address(base, index, (LIR_Address::Scale)shift, disp, type);
 180   }
 181 }
 182 
 183 
 184 LIR_Address* LIRGenerator::emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr,
 185                                               BasicType type) {
 186   int offset_in_bytes = arrayOopDesc::base_offset_in_bytes(type);
 187 
 188   LIR_Address* addr;
 189   if (index_opr-&gt;is_constant()) {
 190     int elem_size = type2aelembytes(type);
 191     addr = new LIR_Address(array_opr,
 192                            offset_in_bytes + (intx)(index_opr-&gt;as_jint()) * elem_size, type);
 193   } else {
 194 #ifdef _LP64
 195     if (index_opr-&gt;type() == T_INT) {
 196       LIR_Opr tmp = new_register(T_LONG);
 197       __ convert(Bytecodes::_i2l, index_opr, tmp);
 198       index_opr = tmp;
 199     }
 200 #endif // _LP64
 201     addr =  new LIR_Address(array_opr,
 202                             index_opr,
 203                             LIR_Address::scale(type),
 204                             offset_in_bytes, type);
 205   }
 206   return addr;
 207 }
 208 
 209 
 210 LIR_Opr LIRGenerator::load_immediate(int x, BasicType type) {
 211   LIR_Opr r = NULL;
 212   if (type == T_LONG) {
 213     r = LIR_OprFact::longConst(x);
 214   } else if (type == T_INT) {
 215     r = LIR_OprFact::intConst(x);
 216   } else {
 217     ShouldNotReachHere();
 218   }
 219   return r;
 220 }
 221 
 222 void LIRGenerator::increment_counter(address counter, BasicType type, int step) {
 223   LIR_Opr pointer = new_pointer_register();
 224   __ move(LIR_OprFact::intptrConst(counter), pointer);
 225   LIR_Address* addr = new LIR_Address(pointer, type);
 226   increment_counter(addr, step);
 227 }
 228 
 229 
 230 void LIRGenerator::increment_counter(LIR_Address* addr, int step) {
 231   __ add((LIR_Opr)addr, LIR_OprFact::intConst(step), (LIR_Opr)addr);
 232 }
 233 
 234 void LIRGenerator::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
 235   __ cmp_mem_int(condition, base, disp, c, info);
 236 }
 237 
 238 
 239 void LIRGenerator::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Opr base, int disp, BasicType type, CodeEmitInfo* info) {
 240   __ cmp_reg_mem(condition, reg, new LIR_Address(base, disp, type), info);
 241 }
 242 
 243 
 244 bool LIRGenerator::strength_reduce_multiply(LIR_Opr left, jint c, LIR_Opr result, LIR_Opr tmp) {
 245   if (tmp-&gt;is_valid() &amp;&amp; c &gt; 0 &amp;&amp; c &lt; max_jint) {
 246     if (is_power_of_2(c + 1)) {
 247       __ move(left, tmp);
 248       __ shift_left(left, log2_jint(c + 1), left);
 249       __ sub(left, tmp, result);
 250       return true;
 251     } else if (is_power_of_2(c - 1)) {
 252       __ move(left, tmp);
 253       __ shift_left(left, log2_jint(c - 1), left);
 254       __ add(left, tmp, result);
 255       return true;
 256     }
 257   }
 258   return false;
 259 }
 260 
 261 
 262 void LIRGenerator::store_stack_parameter (LIR_Opr item, ByteSize offset_from_sp) {
 263   BasicType type = item-&gt;type();
 264   __ store(item, new LIR_Address(FrameMap::rsp_opr, in_bytes(offset_from_sp), type));
 265 }
 266 
 267 void LIRGenerator::array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci) {
 268   LIR_Opr tmp1 = new_register(objectType);
 269   LIR_Opr tmp2 = new_register(objectType);
 270   LIR_Opr tmp3 = new_register(objectType);
 271   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 272 }
 273 
 274 //----------------------------------------------------------------------
 275 //             visitor functions
 276 //----------------------------------------------------------------------
 277 
 278 void LIRGenerator::do_MonitorEnter(MonitorEnter* x) {
 279   assert(x-&gt;is_pinned(),&quot;&quot;);
 280   LIRItem obj(x-&gt;obj(), this);
 281   obj.load_item();
 282 
 283   set_no_result(x);
 284 
 285   // &quot;lock&quot; stores the address of the monitor stack slot, so this is not an oop
 286   LIR_Opr lock = new_register(T_INT);
 287   // Need a scratch register for biased locking on x86
 288   LIR_Opr scratch = LIR_OprFact::illegalOpr;
 289   if (UseBiasedLocking) {
 290     scratch = new_register(T_INT);
 291   }
 292 
 293   CodeEmitInfo* info_for_exception = NULL;
 294   if (x-&gt;needs_null_check()) {
 295     info_for_exception = state_for(x);
 296   }
 297   // this CodeEmitInfo must not have the xhandlers because here the
 298   // object is already locked (xhandlers expect object to be unlocked)
 299   CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
 300   monitor_enter(obj.result(), lock, syncTempOpr(), scratch,
 301                         x-&gt;monitor_no(), info_for_exception, info);
 302 }
 303 
 304 
 305 void LIRGenerator::do_MonitorExit(MonitorExit* x) {
 306   assert(x-&gt;is_pinned(),&quot;&quot;);
 307 
 308   LIRItem obj(x-&gt;obj(), this);
 309   obj.dont_load_item();
 310 
 311   LIR_Opr lock = new_register(T_INT);
 312   LIR_Opr obj_temp = new_register(T_INT);
 313   set_no_result(x);
 314   monitor_exit(obj_temp, lock, syncTempOpr(), LIR_OprFact::illegalOpr, x-&gt;monitor_no());
 315 }
 316 
 317 
 318 // _ineg, _lneg, _fneg, _dneg
 319 void LIRGenerator::do_NegateOp(NegateOp* x) {
 320   LIRItem value(x-&gt;x(), this);
 321   value.set_destroys_register();
 322   value.load_item();
 323   LIR_Opr reg = rlock(x);
 324 
 325   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 326 #ifdef _LP64
 327   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
 328     if (x-&gt;type()-&gt;tag() == doubleTag) {
 329       tmp = new_register(T_DOUBLE);
 330       __ move(LIR_OprFact::doubleConst(-0.0), tmp);
 331     }
 332     else if (x-&gt;type()-&gt;tag() == floatTag) {
 333       tmp = new_register(T_FLOAT);
 334       __ move(LIR_OprFact::floatConst(-0.0), tmp);
 335     }
 336   }
 337 #endif
 338   __ negate(value.result(), reg, tmp);
 339 
 340   set_result(x, round_item(reg));
 341 }
 342 
 343 
 344 // for  _fadd, _fmul, _fsub, _fdiv, _frem
 345 //      _dadd, _dmul, _dsub, _ddiv, _drem
 346 void LIRGenerator::do_ArithmeticOp_FPU(ArithmeticOp* x) {
 347   LIRItem left(x-&gt;x(),  this);
 348   LIRItem right(x-&gt;y(), this);
 349   LIRItem* left_arg  = &amp;left;
 350   LIRItem* right_arg = &amp;right;
 351   assert(!left.is_stack() || !right.is_stack(), &quot;can&#39;t both be memory operands&quot;);
 352   bool must_load_both = (x-&gt;op() == Bytecodes::_frem || x-&gt;op() == Bytecodes::_drem);
 353   if (left.is_register() || x-&gt;x()-&gt;type()-&gt;is_constant() || must_load_both) {
 354     left.load_item();
 355   } else {
 356     left.dont_load_item();
 357   }
 358 
 359   // do not load right operand if it is a constant.  only 0 and 1 are
 360   // loaded because there are special instructions for loading them
 361   // without memory access (not needed for SSE2 instructions)
 362   bool must_load_right = false;
 363   if (right.is_constant()) {
 364     LIR_Const* c = right.result()-&gt;as_constant_ptr();
 365     assert(c != NULL, &quot;invalid constant&quot;);
 366     assert(c-&gt;type() == T_FLOAT || c-&gt;type() == T_DOUBLE, &quot;invalid type&quot;);
 367 
 368     if (c-&gt;type() == T_FLOAT) {
 369       must_load_right = UseSSE &lt; 1 &amp;&amp; (c-&gt;is_one_float() || c-&gt;is_zero_float());
 370     } else {
 371       must_load_right = UseSSE &lt; 2 &amp;&amp; (c-&gt;is_one_double() || c-&gt;is_zero_double());
 372     }
 373   }
 374 
 375   if (must_load_both) {
 376     // frem and drem destroy also right operand, so move it to a new register
 377     right.set_destroys_register();
 378     right.load_item();
 379   } else if (right.is_register() || must_load_right) {
 380     right.load_item();
 381   } else {
 382     right.dont_load_item();
 383   }
 384   LIR_Opr reg = rlock(x);
 385   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 386   if (x-&gt;is_strictfp() &amp;&amp; (x-&gt;op() == Bytecodes::_dmul || x-&gt;op() == Bytecodes::_ddiv)) {
 387     tmp = new_register(T_DOUBLE);
 388   }
 389 
 390 #ifdef _LP64
 391   if (x-&gt;op() == Bytecodes::_frem || x-&gt;op() == Bytecodes::_drem) {
 392     // frem and drem are implemented as a direct call into the runtime.
 393     LIRItem left(x-&gt;x(), this);
 394     LIRItem right(x-&gt;y(), this);
 395 
 396     BasicType bt = as_BasicType(x-&gt;type());
 397     BasicTypeList signature(2);
 398     signature.append(bt);
 399     signature.append(bt);
 400     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 401 
 402     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 403     left.load_item_force(cc-&gt;at(0));
 404     right.load_item_force(cc-&gt;at(1));
 405 
 406     address entry = NULL;
 407     switch (x-&gt;op()) {
 408       case Bytecodes::_frem:
 409         entry = CAST_FROM_FN_PTR(address, SharedRuntime::frem);
 410         break;
 411       case Bytecodes::_drem:
 412         entry = CAST_FROM_FN_PTR(address, SharedRuntime::drem);
 413         break;
 414       default:
 415         ShouldNotReachHere();
 416     }
 417 
 418     LIR_Opr result = rlock_result(x);
 419     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 420     __ move(result_reg, result);
 421   } else {
 422     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
 423     set_result(x, round_item(reg));
 424   }
 425 #else
 426   if ((UseSSE &gt;= 1 &amp;&amp; x-&gt;op() == Bytecodes::_frem) || (UseSSE &gt;= 2 &amp;&amp; x-&gt;op() == Bytecodes::_drem)) {
 427     // special handling for frem and drem: no SSE instruction, so must use FPU with temporary fpu stack slots
 428     LIR_Opr fpu0, fpu1;
 429     if (x-&gt;op() == Bytecodes::_frem) {
 430       fpu0 = LIR_OprFact::single_fpu(0);
 431       fpu1 = LIR_OprFact::single_fpu(1);
 432     } else {
 433       fpu0 = LIR_OprFact::double_fpu(0);
 434       fpu1 = LIR_OprFact::double_fpu(1);
 435     }
 436     __ move(right.result(), fpu1); // order of left and right operand is important!
 437     __ move(left.result(), fpu0);
 438     __ rem (fpu0, fpu1, fpu0);
 439     __ move(fpu0, reg);
 440 
 441   } else {
 442     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
 443   }
 444   set_result(x, round_item(reg));
 445 #endif // _LP64
 446 }
 447 
 448 
 449 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 450 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 451   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem ) {
 452     // long division is implemented as a direct call into the runtime
 453     LIRItem left(x-&gt;x(), this);
 454     LIRItem right(x-&gt;y(), this);
 455 
 456     // the check for division by zero destroys the right operand
 457     right.set_destroys_register();
 458 
 459     BasicTypeList signature(2);
 460     signature.append(T_LONG);
 461     signature.append(T_LONG);
 462     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 463 
 464     // check for division by zero (destroys registers of right operand!)
 465     CodeEmitInfo* info = state_for(x);
 466 
 467     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 468     left.load_item_force(cc-&gt;at(1));
 469     right.load_item();
 470 
 471     __ move(right.result(), cc-&gt;at(0));
 472 
 473     __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
 474     __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));
 475 
 476     address entry = NULL;
 477     switch (x-&gt;op()) {
 478     case Bytecodes::_lrem:
 479       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
 480       break; // check if dividend is 0 is done elsewhere
 481     case Bytecodes::_ldiv:
 482       entry = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
 483       break; // check if dividend is 0 is done elsewhere
 484     default:
 485       ShouldNotReachHere();
 486     }
 487 
 488     LIR_Opr result = rlock_result(x);
 489     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 490     __ move(result_reg, result);
 491   } else if (x-&gt;op() == Bytecodes::_lmul) {
 492     // missing test if instr is commutative and if we should swap
 493     LIRItem left(x-&gt;x(), this);
 494     LIRItem right(x-&gt;y(), this);
 495 
 496     // right register is destroyed by the long mul, so it must be
 497     // copied to a new register.
 498     right.set_destroys_register();
 499 
 500     left.load_item();
 501     right.load_item();
 502 
 503     LIR_Opr reg = FrameMap::long0_opr;
 504     arithmetic_op_long(x-&gt;op(), reg, left.result(), right.result(), NULL);
 505     LIR_Opr result = rlock_result(x);
 506     __ move(reg, result);
 507   } else {
 508     // missing test if instr is commutative and if we should swap
 509     LIRItem left(x-&gt;x(), this);
 510     LIRItem right(x-&gt;y(), this);
 511 
 512     left.load_item();
 513     // don&#39;t load constants to save register
 514     right.load_nonconstant();
 515     rlock_result(x);
 516     arithmetic_op_long(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), NULL);
 517   }
 518 }
 519 
 520 
 521 
 522 // for: _iadd, _imul, _isub, _idiv, _irem
 523 void LIRGenerator::do_ArithmeticOp_Int(ArithmeticOp* x) {
 524   if (x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem) {
 525     // The requirements for division and modulo
 526     // input : rax,: dividend                         min_int
 527     //         reg: divisor   (may not be rax,/rdx)   -1
 528     //
 529     // output: rax,: quotient  (= rax, idiv reg)       min_int
 530     //         rdx: remainder (= rax, irem reg)       0
 531 
 532     // rax, and rdx will be destroyed
 533 
 534     // Note: does this invalidate the spec ???
 535     LIRItem right(x-&gt;y(), this);
 536     LIRItem left(x-&gt;x() , this);   // visit left second, so that the is_register test is valid
 537 
 538     // call state_for before load_item_force because state_for may
 539     // force the evaluation of other instructions that are needed for
 540     // correct debug info.  Otherwise the live range of the fix
 541     // register might be too long.
 542     CodeEmitInfo* info = state_for(x);
 543 
 544     left.load_item_force(divInOpr());
 545 
 546     right.load_item();
 547 
 548     LIR_Opr result = rlock_result(x);
 549     LIR_Opr result_reg;
 550     if (x-&gt;op() == Bytecodes::_idiv) {
 551       result_reg = divOutOpr();
 552     } else {
 553       result_reg = remOutOpr();
 554     }
 555 
 556     if (!ImplicitDiv0Checks) {
 557       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::intConst(0));
 558       __ branch(lir_cond_equal, T_INT, new DivByZeroStub(info));
 559       // Idiv/irem cannot trap (passing info would generate an assertion).
 560       info = NULL;
 561     }
 562     LIR_Opr tmp = FrameMap::rdx_opr; // idiv and irem use rdx in their implementation
 563     if (x-&gt;op() == Bytecodes::_irem) {
 564       __ irem(left.result(), right.result(), result_reg, tmp, info);
 565     } else if (x-&gt;op() == Bytecodes::_idiv) {
 566       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 567     } else {
 568       ShouldNotReachHere();
 569     }
 570 
 571     __ move(result_reg, result);
 572   } else {
 573     // missing test if instr is commutative and if we should swap
 574     LIRItem left(x-&gt;x(),  this);
 575     LIRItem right(x-&gt;y(), this);
 576     LIRItem* left_arg = &amp;left;
 577     LIRItem* right_arg = &amp;right;
 578     if (x-&gt;is_commutative() &amp;&amp; left.is_stack() &amp;&amp; right.is_register()) {
 579       // swap them if left is real stack (or cached) and right is real register(not cached)
 580       left_arg = &amp;right;
 581       right_arg = &amp;left;
 582     }
 583 
 584     left_arg-&gt;load_item();
 585 
 586     // do not need to load right, as we can handle stack and constants
 587     if (x-&gt;op() == Bytecodes::_imul ) {
 588       // check if we can use shift instead
 589       bool use_constant = false;
 590       bool use_tmp = false;
 591       if (right_arg-&gt;is_constant()) {
 592         jint iconst = right_arg-&gt;get_jint_constant();
 593         if (iconst &gt; 0 &amp;&amp; iconst &lt; max_jint) {
 594           if (is_power_of_2(iconst)) {
 595             use_constant = true;
 596           } else if (is_power_of_2(iconst - 1) || is_power_of_2(iconst + 1)) {
 597             use_constant = true;
 598             use_tmp = true;
 599           }
 600         }
 601       }
 602       if (use_constant) {
 603         right_arg-&gt;dont_load_item();
 604       } else {
 605         right_arg-&gt;load_item();
 606       }
 607       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 608       if (use_tmp) {
 609         tmp = new_register(T_INT);
 610       }
 611       rlock_result(x);
 612 
 613       arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), tmp);
 614     } else {
 615       right_arg-&gt;dont_load_item();
 616       rlock_result(x);
 617       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 618       arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), tmp);
 619     }
 620   }
 621 }
 622 
 623 
 624 void LIRGenerator::do_ArithmeticOp(ArithmeticOp* x) {
 625   // when an operand with use count 1 is the left operand, then it is
 626   // likely that no move for 2-operand-LIR-form is necessary
 627   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 628     x-&gt;swap_operands();
 629   }
 630 
 631   ValueTag tag = x-&gt;type()-&gt;tag();
 632   assert(x-&gt;x()-&gt;type()-&gt;tag() == tag &amp;&amp; x-&gt;y()-&gt;type()-&gt;tag() == tag, &quot;wrong parameters&quot;);
 633   switch (tag) {
 634     case floatTag:
 635     case doubleTag:  do_ArithmeticOp_FPU(x);  return;
 636     case longTag:    do_ArithmeticOp_Long(x); return;
 637     case intTag:     do_ArithmeticOp_Int(x);  return;
 638     default:         ShouldNotReachHere();    return;
 639   }
 640 }
 641 
 642 
 643 // _ishl, _lshl, _ishr, _lshr, _iushr, _lushr
 644 void LIRGenerator::do_ShiftOp(ShiftOp* x) {
 645   // count must always be in rcx
 646   LIRItem value(x-&gt;x(), this);
 647   LIRItem count(x-&gt;y(), this);
 648 
 649   ValueTag elemType = x-&gt;type()-&gt;tag();
 650   bool must_load_count = !count.is_constant() || elemType == longTag;
 651   if (must_load_count) {
 652     // count for long must be in register
 653     count.load_item_force(shiftCountOpr());
 654   } else {
 655     count.dont_load_item();
 656   }
 657   value.load_item();
 658   LIR_Opr reg = rlock_result(x);
 659 
 660   shift_op(x-&gt;op(), reg, value.result(), count.result(), LIR_OprFact::illegalOpr);
 661 }
 662 
 663 
 664 // _iand, _land, _ior, _lor, _ixor, _lxor
 665 void LIRGenerator::do_LogicOp(LogicOp* x) {
 666   // when an operand with use count 1 is the left operand, then it is
 667   // likely that no move for 2-operand-LIR-form is necessary
 668   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 669     x-&gt;swap_operands();
 670   }
 671 
 672   LIRItem left(x-&gt;x(), this);
 673   LIRItem right(x-&gt;y(), this);
 674 
 675   left.load_item();
 676   right.load_nonconstant();
 677   LIR_Opr reg = rlock_result(x);
 678 
 679   logic_op(x-&gt;op(), reg, left.result(), right.result());
 680 }
 681 
 682 
 683 
 684 // _lcmp, _fcmpl, _fcmpg, _dcmpl, _dcmpg
 685 void LIRGenerator::do_CompareOp(CompareOp* x) {
 686   LIRItem left(x-&gt;x(), this);
 687   LIRItem right(x-&gt;y(), this);
 688   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
 689   if (tag == longTag) {
 690     left.set_destroys_register();
 691   }
 692   left.load_item();
 693   right.load_item();
 694   LIR_Opr reg = rlock_result(x);
 695 
 696   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 697     Bytecodes::Code code = x-&gt;op();
 698     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 699   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 700     __ lcmp2int(left.result(), right.result(), reg);
 701   } else {
 702     Unimplemented();
 703   }
 704 }
 705 
 706 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 707   LIR_Opr ill = LIR_OprFact::illegalOpr;  // for convenience
 708   if (is_reference_type(type)) {
 709     cmp_value.load_item_force(FrameMap::rax_oop_opr);
 710     new_value.load_item();
 711     __ cas_obj(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 712   } else if (type == T_INT) {
 713     cmp_value.load_item_force(FrameMap::rax_opr);
 714     new_value.load_item();
 715     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 716   } else if (type == T_LONG) {
 717     cmp_value.load_item_force(FrameMap::long0_opr);
 718     new_value.load_item_force(FrameMap::long1_opr);
 719     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 720   } else {
 721     Unimplemented();
 722   }
 723   LIR_Opr result = new_register(T_INT);
 724   __ cmove(lir_cond_equal, LIR_OprFact::intConst(1), LIR_OprFact::intConst(0),
 725            result, T_INT);
 726   return result;
 727 }
 728 
 729 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 730   bool is_oop = is_reference_type(type);
 731   LIR_Opr result = new_register(type);
 732   value.load_item();
 733   // Because we want a 2-arg form of xchg and xadd
 734   __ move(value.result(), result);
 735   assert(type == T_INT || is_oop LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 736   __ xchg(addr, result, result, LIR_OprFact::illegalOpr);
 737   return result;
 738 }
 739 
 740 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 741   LIR_Opr result = new_register(type);
 742   value.load_item();
 743   // Because we want a 2-arg form of xchg and xadd
 744   __ move(value.result(), result);
 745   assert(type == T_INT LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 746   __ xadd(addr, result, result, LIR_OprFact::illegalOpr);
 747   return result;
 748 }
 749 
 750 void LIRGenerator::do_FmaIntrinsic(Intrinsic* x) {
 751   assert(x-&gt;number_of_arguments() == 3, &quot;wrong type&quot;);
 752   assert(UseFMA, &quot;Needs FMA instructions support.&quot;);
 753   LIRItem value(x-&gt;argument_at(0), this);
 754   LIRItem value1(x-&gt;argument_at(1), this);
 755   LIRItem value2(x-&gt;argument_at(2), this);
 756 
 757   value2.set_destroys_register();
 758 
 759   value.load_item();
 760   value1.load_item();
 761   value2.load_item();
 762 
 763   LIR_Opr calc_input = value.result();
 764   LIR_Opr calc_input1 = value1.result();
 765   LIR_Opr calc_input2 = value2.result();
 766   LIR_Opr calc_result = rlock_result(x);
 767 
 768   switch (x-&gt;id()) {
 769   case vmIntrinsics::_fmaD:   __ fmad(calc_input, calc_input1, calc_input2, calc_result); break;
 770   case vmIntrinsics::_fmaF:   __ fmaf(calc_input, calc_input1, calc_input2, calc_result); break;
 771   default:                    ShouldNotReachHere();
 772   }
 773 
 774 }
 775 
 776 
 777 void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {
 778   assert(x-&gt;number_of_arguments() == 1 || (x-&gt;number_of_arguments() == 2 &amp;&amp; x-&gt;id() == vmIntrinsics::_dpow), &quot;wrong type&quot;);
 779 
 780   if (x-&gt;id() == vmIntrinsics::_dexp || x-&gt;id() == vmIntrinsics::_dlog ||
 781       x-&gt;id() == vmIntrinsics::_dpow || x-&gt;id() == vmIntrinsics::_dcos ||
 782       x-&gt;id() == vmIntrinsics::_dsin || x-&gt;id() == vmIntrinsics::_dtan ||
 783       x-&gt;id() == vmIntrinsics::_dlog10) {
 784     do_LibmIntrinsic(x);
 785     return;
 786   }
 787 
 788   LIRItem value(x-&gt;argument_at(0), this);
 789 
 790   bool use_fpu = false;
 791   if (UseSSE &lt; 2) {
 792     value.set_destroys_register();
 793   }
 794   value.load_item();
 795 
 796   LIR_Opr calc_input = value.result();
 797   LIR_Opr calc_result = rlock_result(x);
 798 
 799   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 800 #ifdef _LP64
 801   if (UseAVX &gt; 2 &amp;&amp; (!VM_Version::supports_avx512vl()) &amp;&amp;
 802       (x-&gt;id() == vmIntrinsics::_dabs)) {
 803     tmp = new_register(T_DOUBLE);
 804     __ move(LIR_OprFact::doubleConst(-0.0), tmp);
 805   }
 806 #endif
 807 
 808   switch(x-&gt;id()) {
 809     case vmIntrinsics::_dabs:   __ abs  (calc_input, calc_result, tmp); break;
 810     case vmIntrinsics::_dsqrt:  __ sqrt (calc_input, calc_result, LIR_OprFact::illegalOpr); break;
 811     default:                    ShouldNotReachHere();
 812   }
 813 
 814   if (use_fpu) {
 815     __ move(calc_result, x-&gt;operand());
 816   }
 817 }
 818 
 819 void LIRGenerator::do_LibmIntrinsic(Intrinsic* x) {
 820   LIRItem value(x-&gt;argument_at(0), this);
 821   value.set_destroys_register();
 822 
 823   LIR_Opr calc_result = rlock_result(x);
 824   LIR_Opr result_reg = result_register_for(x-&gt;type());
 825 
 826   CallingConvention* cc = NULL;
 827 
 828   if (x-&gt;id() == vmIntrinsics::_dpow) {
 829     LIRItem value1(x-&gt;argument_at(1), this);
 830 
 831     value1.set_destroys_register();
 832 
 833     BasicTypeList signature(2);
 834     signature.append(T_DOUBLE);
 835     signature.append(T_DOUBLE);
 836     cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 837     value.load_item_force(cc-&gt;at(0));
 838     value1.load_item_force(cc-&gt;at(1));
 839   } else {
 840     BasicTypeList signature(1);
 841     signature.append(T_DOUBLE);
 842     cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 843     value.load_item_force(cc-&gt;at(0));
 844   }
 845 
 846 #ifndef _LP64
 847   LIR_Opr tmp = FrameMap::fpu0_double_opr;
 848   result_reg = tmp;
 849   switch(x-&gt;id()) {
 850     case vmIntrinsics::_dexp:
 851       if (StubRoutines::dexp() != NULL) {
 852         __ call_runtime_leaf(StubRoutines::dexp(), getThreadTemp(), result_reg, cc-&gt;args());
 853       } else {
 854         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dexp), getThreadTemp(), result_reg, cc-&gt;args());
 855       }
 856       break;
 857     case vmIntrinsics::_dlog:
 858       if (StubRoutines::dlog() != NULL) {
 859         __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc-&gt;args());
 860       } else {
 861         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc-&gt;args());
 862       }
 863       break;
 864     case vmIntrinsics::_dlog10:
 865       if (StubRoutines::dlog10() != NULL) {
 866        __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc-&gt;args());
 867       } else {
 868         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc-&gt;args());
 869       }
 870       break;
 871     case vmIntrinsics::_dpow:
 872       if (StubRoutines::dpow() != NULL) {
 873         __ call_runtime_leaf(StubRoutines::dpow(), getThreadTemp(), result_reg, cc-&gt;args());
 874       } else {
 875         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dpow), getThreadTemp(), result_reg, cc-&gt;args());
 876       }
 877       break;
 878     case vmIntrinsics::_dsin:
 879       if (VM_Version::supports_sse2() &amp;&amp; StubRoutines::dsin() != NULL) {
 880         __ call_runtime_leaf(StubRoutines::dsin(), getThreadTemp(), result_reg, cc-&gt;args());
 881       } else {
 882         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dsin), getThreadTemp(), result_reg, cc-&gt;args());
 883       }
 884       break;
 885     case vmIntrinsics::_dcos:
 886       if (VM_Version::supports_sse2() &amp;&amp; StubRoutines::dcos() != NULL) {
 887         __ call_runtime_leaf(StubRoutines::dcos(), getThreadTemp(), result_reg, cc-&gt;args());
 888       } else {
 889         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dcos), getThreadTemp(), result_reg, cc-&gt;args());
 890       }
 891       break;
 892     case vmIntrinsics::_dtan:
 893       if (StubRoutines::dtan() != NULL) {
 894         __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc-&gt;args());
 895       } else {
 896         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc-&gt;args());
 897       }
 898       break;
 899     default:  ShouldNotReachHere();
 900   }
 901 #else
 902   switch (x-&gt;id()) {
 903     case vmIntrinsics::_dexp:
 904       if (StubRoutines::dexp() != NULL) {
 905         __ call_runtime_leaf(StubRoutines::dexp(), getThreadTemp(), result_reg, cc-&gt;args());
 906       } else {
 907         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dexp), getThreadTemp(), result_reg, cc-&gt;args());
 908       }
 909       break;
 910     case vmIntrinsics::_dlog:
 911       if (StubRoutines::dlog() != NULL) {
 912       __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc-&gt;args());
 913       } else {
 914         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc-&gt;args());
 915       }
 916       break;
 917     case vmIntrinsics::_dlog10:
 918       if (StubRoutines::dlog10() != NULL) {
 919       __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc-&gt;args());
 920       } else {
 921         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc-&gt;args());
 922       }
 923       break;
 924     case vmIntrinsics::_dpow:
 925        if (StubRoutines::dpow() != NULL) {
 926       __ call_runtime_leaf(StubRoutines::dpow(), getThreadTemp(), result_reg, cc-&gt;args());
 927       } else {
 928         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dpow), getThreadTemp(), result_reg, cc-&gt;args());
 929       }
 930       break;
 931     case vmIntrinsics::_dsin:
 932       if (StubRoutines::dsin() != NULL) {
 933         __ call_runtime_leaf(StubRoutines::dsin(), getThreadTemp(), result_reg, cc-&gt;args());
 934       } else {
 935         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dsin), getThreadTemp(), result_reg, cc-&gt;args());
 936       }
 937       break;
 938     case vmIntrinsics::_dcos:
 939       if (StubRoutines::dcos() != NULL) {
 940         __ call_runtime_leaf(StubRoutines::dcos(), getThreadTemp(), result_reg, cc-&gt;args());
 941       } else {
 942         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dcos), getThreadTemp(), result_reg, cc-&gt;args());
 943       }
 944       break;
 945     case vmIntrinsics::_dtan:
 946        if (StubRoutines::dtan() != NULL) {
 947       __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc-&gt;args());
 948       } else {
 949         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc-&gt;args());
 950       }
 951       break;
 952     default:  ShouldNotReachHere();
 953   }
 954 #endif // _LP64
 955   __ move(result_reg, calc_result);
 956 }
 957 
 958 void LIRGenerator::do_ArrayCopy(Intrinsic* x) {
 959   assert(x-&gt;number_of_arguments() == 5, &quot;wrong type&quot;);
 960 
 961   // Make all state_for calls early since they can emit code
 962   CodeEmitInfo* info = state_for(x, x-&gt;state());
 963 
 964   LIRItem src(x-&gt;argument_at(0), this);
 965   LIRItem src_pos(x-&gt;argument_at(1), this);
 966   LIRItem dst(x-&gt;argument_at(2), this);
 967   LIRItem dst_pos(x-&gt;argument_at(3), this);
 968   LIRItem length(x-&gt;argument_at(4), this);
 969 
 970   // operands for arraycopy must use fixed registers, otherwise
 971   // LinearScan will fail allocation (because arraycopy always needs a
 972   // call)
 973 
 974 #ifndef _LP64
 975   src.load_item_force     (FrameMap::rcx_oop_opr);
 976   src_pos.load_item_force (FrameMap::rdx_opr);
 977   dst.load_item_force     (FrameMap::rax_oop_opr);
 978   dst_pos.load_item_force (FrameMap::rbx_opr);
 979   length.load_item_force  (FrameMap::rdi_opr);
 980   LIR_Opr tmp =           (FrameMap::rsi_opr);
 981 #else
 982 
 983   // The java calling convention will give us enough registers
 984   // so that on the stub side the args will be perfect already.
 985   // On the other slow/special case side we call C and the arg
 986   // positions are not similar enough to pick one as the best.
 987   // Also because the java calling convention is a &quot;shifted&quot; version
 988   // of the C convention we can process the java args trivially into C
 989   // args without worry of overwriting during the xfer
 990 
 991   src.load_item_force     (FrameMap::as_oop_opr(j_rarg0));
 992   src_pos.load_item_force (FrameMap::as_opr(j_rarg1));
 993   dst.load_item_force     (FrameMap::as_oop_opr(j_rarg2));
 994   dst_pos.load_item_force (FrameMap::as_opr(j_rarg3));
 995   length.load_item_force  (FrameMap::as_opr(j_rarg4));
 996 
 997   LIR_Opr tmp =           FrameMap::as_opr(j_rarg5);
 998 #endif // LP64
 999 
1000   set_no_result(x);
1001 
1002   int flags;
1003   ciArrayKlass* expected_type;
1004   arraycopy_helper(x, &amp;flags, &amp;expected_type);
1005 
1006   __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(), length.result(), tmp, expected_type, flags, info); // does add_safepoint
1007 }
1008 
1009 void LIRGenerator::do_update_CRC32(Intrinsic* x) {
1010   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
1011   // Make all state_for calls early since they can emit code
1012   LIR_Opr result = rlock_result(x);
1013   int flags = 0;
1014   switch (x-&gt;id()) {
1015     case vmIntrinsics::_updateCRC32: {
1016       LIRItem crc(x-&gt;argument_at(0), this);
1017       LIRItem val(x-&gt;argument_at(1), this);
1018       // val is destroyed by update_crc32
1019       val.set_destroys_register();
1020       crc.load_item();
1021       val.load_item();
1022       __ update_crc32(crc.result(), val.result(), result);
1023       break;
1024     }
1025     case vmIntrinsics::_updateBytesCRC32:
1026     case vmIntrinsics::_updateByteBufferCRC32: {
1027       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32);
1028 
1029       LIRItem crc(x-&gt;argument_at(0), this);
1030       LIRItem buf(x-&gt;argument_at(1), this);
1031       LIRItem off(x-&gt;argument_at(2), this);
1032       LIRItem len(x-&gt;argument_at(3), this);
1033       buf.load_item();
1034       off.load_nonconstant();
1035 
1036       LIR_Opr index = off.result();
1037       int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
1038       if(off.result()-&gt;is_constant()) {
1039         index = LIR_OprFact::illegalOpr;
1040        offset += off.result()-&gt;as_jint();
1041       }
1042       LIR_Opr base_op = buf.result();
1043 
1044 #ifndef _LP64
1045       if (!is_updateBytes) { // long b raw address
1046          base_op = new_register(T_INT);
1047          __ convert(Bytecodes::_l2i, buf.result(), base_op);
1048       }
1049 #else
1050       if (index-&gt;is_valid()) {
1051         LIR_Opr tmp = new_register(T_LONG);
1052         __ convert(Bytecodes::_i2l, index, tmp);
1053         index = tmp;
1054       }
1055 #endif
1056 
1057       if (is_updateBytes) {
1058         base_op = access_resolve(IS_NOT_NULL | ACCESS_READ, base_op);
1059       }
1060 
1061       LIR_Address* a = new LIR_Address(base_op,
1062                                        index,
1063                                        offset,
1064                                        T_BYTE);
1065       BasicTypeList signature(3);
1066       signature.append(T_INT);
1067       signature.append(T_ADDRESS);
1068       signature.append(T_INT);
1069       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1070       const LIR_Opr result_reg = result_register_for(x-&gt;type());
1071 
1072       LIR_Opr addr = new_pointer_register();
1073       __ leal(LIR_OprFact::address(a), addr);
1074 
1075       crc.load_item_force(cc-&gt;at(0));
1076       __ move(addr, cc-&gt;at(1));
1077       len.load_item_force(cc-&gt;at(2));
1078 
1079       __ call_runtime_leaf(StubRoutines::updateBytesCRC32(), getThreadTemp(), result_reg, cc-&gt;args());
1080       __ move(result_reg, result);
1081 
1082       break;
1083     }
1084     default: {
1085       ShouldNotReachHere();
1086     }
1087   }
1088 }
1089 
1090 void LIRGenerator::do_update_CRC32C(Intrinsic* x) {
1091   Unimplemented();
1092 }
1093 
1094 void LIRGenerator::do_vectorizedMismatch(Intrinsic* x) {
1095   assert(UseVectorizedMismatchIntrinsic, &quot;need AVX instruction support&quot;);
1096 
1097   // Make all state_for calls early since they can emit code
1098   LIR_Opr result = rlock_result(x);
1099 
1100   LIRItem a(x-&gt;argument_at(0), this); // Object
1101   LIRItem aOffset(x-&gt;argument_at(1), this); // long
1102   LIRItem b(x-&gt;argument_at(2), this); // Object
1103   LIRItem bOffset(x-&gt;argument_at(3), this); // long
1104   LIRItem length(x-&gt;argument_at(4), this); // int
1105   LIRItem log2ArrayIndexScale(x-&gt;argument_at(5), this); // int
1106 
1107   a.load_item();
1108   aOffset.load_nonconstant();
1109   b.load_item();
1110   bOffset.load_nonconstant();
1111 
1112   long constant_aOffset = 0;
1113   LIR_Opr result_aOffset = aOffset.result();
1114   if (result_aOffset-&gt;is_constant()) {
1115     constant_aOffset = result_aOffset-&gt;as_jlong();
1116     result_aOffset = LIR_OprFact::illegalOpr;
1117   }
1118   LIR_Opr result_a = access_resolve(ACCESS_READ, a.result());
1119 
1120   long constant_bOffset = 0;
1121   LIR_Opr result_bOffset = bOffset.result();
1122   if (result_bOffset-&gt;is_constant()) {
1123     constant_bOffset = result_bOffset-&gt;as_jlong();
1124     result_bOffset = LIR_OprFact::illegalOpr;
1125   }
1126   LIR_Opr result_b = access_resolve(ACCESS_READ, b.result());
1127 
1128 #ifndef _LP64
1129   result_a = new_register(T_INT);
1130   __ convert(Bytecodes::_l2i, a.result(), result_a);
1131   result_b = new_register(T_INT);
1132   __ convert(Bytecodes::_l2i, b.result(), result_b);
1133 #endif
1134 
1135 
1136   LIR_Address* addr_a = new LIR_Address(result_a,
1137                                         result_aOffset,
1138                                         constant_aOffset,
1139                                         T_BYTE);
1140 
1141   LIR_Address* addr_b = new LIR_Address(result_b,
1142                                         result_bOffset,
1143                                         constant_bOffset,
1144                                         T_BYTE);
1145 
1146   BasicTypeList signature(4);
1147   signature.append(T_ADDRESS);
1148   signature.append(T_ADDRESS);
1149   signature.append(T_INT);
1150   signature.append(T_INT);
1151   CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1152   const LIR_Opr result_reg = result_register_for(x-&gt;type());
1153 
1154   LIR_Opr ptr_addr_a = new_pointer_register();
1155   __ leal(LIR_OprFact::address(addr_a), ptr_addr_a);
1156 
1157   LIR_Opr ptr_addr_b = new_pointer_register();
1158   __ leal(LIR_OprFact::address(addr_b), ptr_addr_b);
1159 
1160   __ move(ptr_addr_a, cc-&gt;at(0));
1161   __ move(ptr_addr_b, cc-&gt;at(1));
1162   length.load_item_force(cc-&gt;at(2));
1163   log2ArrayIndexScale.load_item_force(cc-&gt;at(3));
1164 
1165   __ call_runtime_leaf(StubRoutines::vectorizedMismatch(), getThreadTemp(), result_reg, cc-&gt;args());
1166   __ move(result_reg, result);
1167 }
1168 
1169 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
1170 // _i2b, _i2c, _i2s
1171 LIR_Opr fixed_register_for(BasicType type) {
1172   switch (type) {
1173     case T_FLOAT:  return FrameMap::fpu0_float_opr;
1174     case T_DOUBLE: return FrameMap::fpu0_double_opr;
1175     case T_INT:    return FrameMap::rax_opr;
1176     case T_LONG:   return FrameMap::long0_opr;
1177     default:       ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
1178   }
1179 }
1180 
1181 void LIRGenerator::do_Convert(Convert* x) {
1182 #ifdef _LP64
1183   LIRItem value(x-&gt;value(), this);
1184   value.load_item();
1185   LIR_Opr input = value.result();
1186   LIR_Opr result = rlock(x);
1187   __ convert(x-&gt;op(), input, result);
1188   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1189   set_result(x, result);
1190 #else
1191   // flags that vary for the different operations and different SSE-settings
1192   bool fixed_input = false, fixed_result = false, round_result = false, needs_stub = false;
1193 
1194   switch (x-&gt;op()) {
1195     case Bytecodes::_i2l: // fall through
1196     case Bytecodes::_l2i: // fall through
1197     case Bytecodes::_i2b: // fall through
1198     case Bytecodes::_i2c: // fall through
1199     case Bytecodes::_i2s: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;
1200 
1201     case Bytecodes::_f2d: fixed_input = UseSSE == 1; fixed_result = false;       round_result = false;      needs_stub = false; break;
1202     case Bytecodes::_d2f: fixed_input = false;       fixed_result = UseSSE == 1; round_result = UseSSE &lt; 1; needs_stub = false; break;
1203     case Bytecodes::_i2f: fixed_input = false;       fixed_result = false;       round_result = UseSSE &lt; 1; needs_stub = false; break;
1204     case Bytecodes::_i2d: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;
1205     case Bytecodes::_f2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;
1206     case Bytecodes::_d2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;
1207     case Bytecodes::_l2f: fixed_input = false;       fixed_result = UseSSE &gt;= 1; round_result = UseSSE &lt; 1; needs_stub = false; break;
1208     case Bytecodes::_l2d: fixed_input = false;       fixed_result = UseSSE &gt;= 2; round_result = UseSSE &lt; 2; needs_stub = false; break;
1209     case Bytecodes::_f2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;
1210     case Bytecodes::_d2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;
1211     default: ShouldNotReachHere();
1212   }
1213 
1214   LIRItem value(x-&gt;value(), this);
1215   value.load_item();
1216   LIR_Opr input = value.result();
1217   LIR_Opr result = rlock(x);
1218 
1219   // arguments of lir_convert
1220   LIR_Opr conv_input = input;
1221   LIR_Opr conv_result = result;
1222   ConversionStub* stub = NULL;
1223 
1224   if (fixed_input) {
1225     conv_input = fixed_register_for(input-&gt;type());
1226     __ move(input, conv_input);
1227   }
1228 
1229   assert(fixed_result == false || round_result == false, &quot;cannot set both&quot;);
1230   if (fixed_result) {
1231     conv_result = fixed_register_for(result-&gt;type());
1232   } else if (round_result) {
1233     result = new_register(result-&gt;type());
1234     set_vreg_flag(result, must_start_in_memory);
1235   }
1236 
1237   if (needs_stub) {
1238     stub = new ConversionStub(x-&gt;op(), conv_input, conv_result);
1239   }
1240 
1241   __ convert(x-&gt;op(), conv_input, conv_result, stub);
1242 
1243   if (result != conv_result) {
1244     __ move(conv_result, result);
1245   }
1246 
1247   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1248   set_result(x, result);
1249 #endif // _LP64
1250 }
1251 
1252 
1253 void LIRGenerator::do_NewInstance(NewInstance* x) {
1254   print_if_not_loaded(x);
1255 
1256   CodeEmitInfo* info = state_for(x, x-&gt;state());
1257   LIR_Opr reg = result_register_for(x-&gt;type());
1258   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1259                        FrameMap::rcx_oop_opr,
1260                        FrameMap::rdi_oop_opr,
1261                        FrameMap::rsi_oop_opr,
1262                        LIR_OprFact::illegalOpr,
1263                        FrameMap::rdx_metadata_opr, info);
1264   LIR_Opr result = rlock_result(x);
1265   __ move(reg, result);
1266 }
1267 
1268 
1269 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
1270   CodeEmitInfo* info = state_for(x, x-&gt;state());
1271 
1272   LIRItem length(x-&gt;length(), this);
1273   length.load_item_force(FrameMap::rbx_opr);
1274 
1275   LIR_Opr reg = result_register_for(x-&gt;type());
1276   LIR_Opr tmp1 = FrameMap::rcx_oop_opr;
1277   LIR_Opr tmp2 = FrameMap::rsi_oop_opr;
1278   LIR_Opr tmp3 = FrameMap::rdi_oop_opr;
1279   LIR_Opr tmp4 = reg;
1280   LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;
1281   LIR_Opr len = length.result();
1282   BasicType elem_type = x-&gt;elt_type();
1283 
1284   __ metadata2reg(ciTypeArrayKlass::make(elem_type)-&gt;constant_encoding(), klass_reg);
1285 
1286   CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len, reg, info);
1287   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);
1288 
1289   LIR_Opr result = rlock_result(x);
1290   __ move(reg, result);
1291 }
1292 
1293 
1294 void LIRGenerator::do_NewObjectArray(NewObjectArray* x) {
1295   LIRItem length(x-&gt;length(), this);
1296   // in case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
1297   // and therefore provide the state before the parameters have been consumed
1298   CodeEmitInfo* patching_info = NULL;
1299   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1300     patching_info =  state_for(x, x-&gt;state_before());
1301   }
1302 
1303   CodeEmitInfo* info = state_for(x, x-&gt;state());
1304 
1305   const LIR_Opr reg = result_register_for(x-&gt;type());
1306   LIR_Opr tmp1 = FrameMap::rcx_oop_opr;
1307   LIR_Opr tmp2 = FrameMap::rsi_oop_opr;
1308   LIR_Opr tmp3 = FrameMap::rdi_oop_opr;
1309   LIR_Opr tmp4 = reg;
1310   LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;
1311 
1312   length.load_item_force(FrameMap::rbx_opr);
1313   LIR_Opr len = length.result();
1314 
1315   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info);
1316   ciKlass* obj = (ciKlass*) ciObjArrayKlass::make(x-&gt;klass());
1317   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
1318     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
1319   }
1320   klass2reg_with_patching(klass_reg, obj, patching_info);
1321   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);
1322 
1323   LIR_Opr result = rlock_result(x);
1324   __ move(reg, result);
1325 }
1326 
1327 
1328 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
1329   Values* dims = x-&gt;dims();
1330   int i = dims-&gt;length();
1331   LIRItemList* items = new LIRItemList(i, i, NULL);
1332   while (i-- &gt; 0) {
1333     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
1334     items-&gt;at_put(i, size);
1335   }
1336 
1337   // Evaluate state_for early since it may emit code.
1338   CodeEmitInfo* patching_info = NULL;
1339   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1340     patching_info = state_for(x, x-&gt;state_before());
1341 
1342     // Cannot re-use same xhandlers for multiple CodeEmitInfos, so
1343     // clone all handlers (NOTE: Usually this is handled transparently
1344     // by the CodeEmitInfo cloning logic in CodeStub constructors but
1345     // is done explicitly here because a stub isn&#39;t being used).
1346     x-&gt;set_exception_handlers(new XHandlers(x-&gt;exception_handlers()));
1347   }
1348   CodeEmitInfo* info = state_for(x, x-&gt;state());
1349 
1350   i = dims-&gt;length();
1351   while (i-- &gt; 0) {
1352     LIRItem* size = items-&gt;at(i);
1353     size-&gt;load_nonconstant();
1354 
1355     store_stack_parameter(size-&gt;result(), in_ByteSize(i*4));
1356   }
1357 
1358   LIR_Opr klass_reg = FrameMap::rax_metadata_opr;
1359   klass2reg_with_patching(klass_reg, x-&gt;klass(), patching_info);
1360 
1361   LIR_Opr rank = FrameMap::rbx_opr;
1362   __ move(LIR_OprFact::intConst(x-&gt;rank()), rank);
1363   LIR_Opr varargs = FrameMap::rcx_opr;
1364   __ move(FrameMap::rsp_opr, varargs);
1365   LIR_OprList* args = new LIR_OprList(3);
1366   args-&gt;append(klass_reg);
1367   args-&gt;append(rank);
1368   args-&gt;append(varargs);
1369   LIR_Opr reg = result_register_for(x-&gt;type());
1370   __ call_runtime(Runtime1::entry_for(Runtime1::new_multi_array_id),
1371                   LIR_OprFact::illegalOpr,
1372                   reg, args, info);
1373 
1374   LIR_Opr result = rlock_result(x);
1375   __ move(reg, result);
1376 }
1377 
1378 
1379 void LIRGenerator::do_BlockBegin(BlockBegin* x) {
1380   // nothing to do for now
1381 }
1382 
1383 
1384 void LIRGenerator::do_CheckCast(CheckCast* x) {
1385   LIRItem obj(x-&gt;obj(), this);
1386 
1387   CodeEmitInfo* patching_info = NULL;
1388   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
1389     // must do this before locking the destination register as an oop register,
1390     // and before the obj is loaded (the latter is for deoptimization)
1391     patching_info = state_for(x, x-&gt;state_before());
1392   }
1393   obj.load_item();
1394 
1395   // info for exceptions
1396   CodeEmitInfo* info_for_exception =
1397       (x-&gt;needs_exception_state() ? state_for(x) :
1398                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
1399 
1400   CodeStub* stub;
1401   if (x-&gt;is_incompatible_class_change_check()) {
1402     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1403     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
1404   } else if (x-&gt;is_invokespecial_receiver_check()) {
1405     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1406     stub = new DeoptimizeStub(info_for_exception, Deoptimization::Reason_class_check, Deoptimization::Action_none);
1407   } else {
1408     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
1409   }
1410   LIR_Opr reg = rlock_result(x);
1411   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1412   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1413     tmp3 = new_register(objectType);
1414   }
1415   __ checkcast(reg, obj.result(), x-&gt;klass(),
1416                new_register(objectType), new_register(objectType), tmp3,
1417                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
1418                x-&gt;profiled_method(), x-&gt;profiled_bci());
1419 }
1420 
1421 
1422 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
1423   LIRItem obj(x-&gt;obj(), this);
1424 
1425   // result and test object may not be in same register
1426   LIR_Opr reg = rlock_result(x);
1427   CodeEmitInfo* patching_info = NULL;
1428   if ((!x-&gt;klass()-&gt;is_loaded() || PatchALot)) {
1429     // must do this before locking the destination register as an oop register
1430     patching_info = state_for(x, x-&gt;state_before());
1431   }
1432   obj.load_item();
1433   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1434   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1435     tmp3 = new_register(objectType);
1436   }
1437   __ instanceof(reg, obj.result(), x-&gt;klass(),
1438                 new_register(objectType), new_register(objectType), tmp3,
1439                 x-&gt;direct_compare(), patching_info, x-&gt;profiled_method(), x-&gt;profiled_bci());
1440 }
1441 
1442 
1443 void LIRGenerator::do_If(If* x) {
1444   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
1445   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
1446   bool is_safepoint = x-&gt;is_safepoint();
1447 
1448   If::Condition cond = x-&gt;cond();
1449 
1450   LIRItem xitem(x-&gt;x(), this);
1451   LIRItem yitem(x-&gt;y(), this);
1452   LIRItem* xin = &amp;xitem;
1453   LIRItem* yin = &amp;yitem;
1454 
1455   if (tag == longTag) {
1456     // for longs, only conditions &quot;eql&quot;, &quot;neq&quot;, &quot;lss&quot;, &quot;geq&quot; are valid;
1457     // mirror for other conditions
1458     if (cond == If::gtr || cond == If::leq) {
1459       cond = Instruction::mirror(cond);
1460       xin = &amp;yitem;
1461       yin = &amp;xitem;
1462     }
1463     xin-&gt;set_destroys_register();
1464   }
1465   xin-&gt;load_item();
1466   if (tag == longTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; yin-&gt;get_jlong_constant() == 0 &amp;&amp; (cond == If::eql || cond == If::neq)) {
1467     // inline long zero
1468     yin-&gt;dont_load_item();
1469   } else if (tag == longTag || tag == floatTag || tag == doubleTag) {
1470     // longs cannot handle constants at right side
1471     yin-&gt;load_item();
1472   } else {
1473     yin-&gt;dont_load_item();
1474   }
1475 
1476   LIR_Opr left = xin-&gt;result();
1477   LIR_Opr right = yin-&gt;result();
1478 
1479   set_no_result(x);
1480 
1481   // add safepoint before generating condition code so it can be recomputed
1482   if (x-&gt;is_safepoint()) {
1483     // increment backedge counter if needed
1484     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1485         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1486     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
1487   }
1488 
1489   __ cmp(lir_cond(cond), left, right);
1490   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1491   profile_branch(x, cond);
1492   move_to_phi(x-&gt;state());
1493   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
1494     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());
1495   } else {
1496     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());
1497   }
1498   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1499   __ jump(x-&gt;default_sux());
1500 }
1501 
1502 
1503 LIR_Opr LIRGenerator::getThreadPointer() {
1504 #ifdef _LP64
1505   return FrameMap::as_pointer_opr(r15_thread);
1506 #else
1507   LIR_Opr result = new_register(T_INT);
1508   __ get_thread(result);
1509   return result;
1510 #endif //
1511 }
1512 
1513 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1514   store_stack_parameter(LIR_OprFact::intConst(block-&gt;block_id()), in_ByteSize(0));
1515   LIR_OprList* args = new LIR_OprList();
1516   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1517   __ call_runtime_leaf(func, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, args);
1518 }
1519 
1520 
1521 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1522                                         CodeEmitInfo* info) {
1523   if (address-&gt;type() == T_LONG) {
1524     address = new LIR_Address(address-&gt;base(),
1525                               address-&gt;index(), address-&gt;scale(),
1526                               address-&gt;disp(), T_DOUBLE);
1527     // Transfer the value atomically by using FP moves.  This means
1528     // the value has to be moved between CPU and FPU registers.  It
1529     // always has to be moved through spill slot since there&#39;s no
1530     // quick way to pack the value into an SSE register.
1531     LIR_Opr temp_double = new_register(T_DOUBLE);
1532     LIR_Opr spill = new_register(T_LONG);
1533     set_vreg_flag(spill, must_start_in_memory);
1534     __ move(value, spill);
1535     __ volatile_move(spill, temp_double, T_LONG);
1536     __ volatile_move(temp_double, LIR_OprFact::address(address), T_LONG, info);
1537   } else {
1538     __ store(value, address, info);
1539   }
1540 }
1541 
1542 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1543                                        CodeEmitInfo* info) {
1544   if (address-&gt;type() == T_LONG) {
1545     address = new LIR_Address(address-&gt;base(),
1546                               address-&gt;index(), address-&gt;scale(),
1547                               address-&gt;disp(), T_DOUBLE);
1548     // Transfer the value atomically by using FP moves.  This means
1549     // the value has to be moved between CPU and FPU registers.  In
1550     // SSE0 and SSE1 mode it has to be moved through spill slot but in
1551     // SSE2+ mode it can be moved directly.
1552     LIR_Opr temp_double = new_register(T_DOUBLE);
1553     __ volatile_move(LIR_OprFact::address(address), temp_double, T_LONG, info);
1554     __ volatile_move(temp_double, result, T_LONG);
1555     if (UseSSE &lt; 2) {
1556       // no spill slot needed in SSE2 mode because xmm-&gt;cpu register move is possible
1557       set_vreg_flag(result, must_start_in_memory);
1558     }
1559   } else {
1560     __ load(address, result, info);
1561   }
1562 }
    </pre>
  </body>
</html>
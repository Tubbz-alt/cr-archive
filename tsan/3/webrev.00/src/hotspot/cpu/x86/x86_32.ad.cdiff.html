<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/x86_32.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="x86.ad.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_64.ad.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_32.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1307,11 ***</span>
  void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    implementation( &amp;cbuf, ra_, false, NULL );
  }
  
  uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
<span class="line-modified">!   return implementation( NULL, ra_, true, NULL );</span>
  }
  
  
  //=============================================================================
  #ifndef PRODUCT
<span class="line-new-header">--- 1307,11 ---</span>
  void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    implementation( &amp;cbuf, ra_, false, NULL );
  }
  
  uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
<span class="line-modified">!   return MachNode::size(ra_);</span>
  }
  
  
  //=============================================================================
  #ifndef PRODUCT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1514,12 ***</span>
      return;
    }
    node-&gt;_opnds[opcnt] = new_memory;
  }
  
<span class="line-modified">! // Advertise here if the CPU requires explicit rounding operations</span>
<span class="line-removed">- // to implement the UseStrictFP mode.</span>
  const bool Matcher::strict_fp_requires_explicit_rounding = true;
  
  // Are floats conerted to double when stored to stack during deoptimization?
  // On x32 it is stored with convertion only when FPU is used for floats.
  bool Matcher::float_in_double() { return (UseSSE == 0); }
<span class="line-new-header">--- 1514,11 ---</span>
      return;
    }
    node-&gt;_opnds[opcnt] = new_memory;
  }
  
<span class="line-modified">! // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>
  const bool Matcher::strict_fp_requires_explicit_rounding = true;
  
  // Are floats conerted to double when stored to stack during deoptimization?
  // On x32 it is stored with convertion only when FPU is used for floats.
  bool Matcher::float_in_double() { return (UseSSE == 0); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3915,10 ***</span>
<span class="line-new-header">--- 3914,17 ---</span>
    match(reg);
    format %{ &quot;ECX&quot; %}
    interface(REG_INTER);
  %}
  
<span class="line-added">+ operand eDXRegP(eRegP reg) %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(edx_reg));</span>
<span class="line-added">+   match(reg);</span>
<span class="line-added">+   format %{ &quot;EDX&quot; %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  operand eSIRegP(eRegP reg) %{
    constraint(ALLOC_IN_RC(esi_reg));
    match(reg);
    format %{ &quot;ESI&quot; %}
    interface(REG_INTER);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4121,76 ***</span>
  
     format %{ %}
     interface(REG_INTER);
  %}
  
<span class="line-removed">- // Vectors : note, we use legacy registers to avoid extra (unneeded in 32-bit VM)</span>
<span class="line-removed">- // runtime code generation via reg_class_dynamic.</span>
<span class="line-removed">- operand vecS() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectors_reg_legacy));</span>
<span class="line-removed">-   match(VecS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand legVecS() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectors_reg_legacy));</span>
<span class="line-removed">-   match(VecS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand vecD() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectord_reg_legacy));</span>
<span class="line-removed">-   match(VecD);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand legVecD() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectord_reg_legacy));</span>
<span class="line-removed">-   match(VecD);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand vecX() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectorx_reg_legacy));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand legVecX() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectorx_reg_legacy));</span>
<span class="line-removed">-   match(VecX);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand vecY() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectory_reg_legacy));</span>
<span class="line-removed">-   match(VecY);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- operand legVecY() %{</span>
<span class="line-removed">-   constraint(ALLOC_IN_RC(vectory_reg_legacy));</span>
<span class="line-removed">-   match(VecY);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(REG_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  //----------Memory Operands----------------------------------------------------
  // Direct Memory Operand
  operand direct(immP addr) %{
    match(addr);
  
<span class="line-new-header">--- 4127,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7313,10 ***</span>
<span class="line-new-header">--- 7253,18 ---</span>
    ins_encode( /*empty encoding*/ );
    ins_cost(0);
    ins_pipe( empty );
  %}
  
<span class="line-added">+ instruct castLL( eRegL dst ) %{</span>
<span class="line-added">+   match(Set dst (CastLL dst));</span>
<span class="line-added">+   format %{ &quot;#castLL of $dst&quot; %}</span>
<span class="line-added">+   ins_encode( /*empty encoding*/ );</span>
<span class="line-added">+   ins_cost(0);</span>
<span class="line-added">+   ins_pipe( empty );</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  
  // Load-locked - same as a regular pointer load when used with compare-swap
  instruct loadPLocked(eRegP dst, memory mem) %{
    match(Set dst (LoadPLocked mem));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8947,10 ***</span>
<span class="line-new-header">--- 8895,32 ---</span>
      __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
    %}
    ins_pipe(ialu_reg_reg_alu0);
  %}
  
<span class="line-added">+ // Integer Absolute Instructions</span>
<span class="line-added">+ instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, eFlagsReg cr)</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   match(Set dst (AbsI src));</span>
<span class="line-added">+   effect(TEMP dst, TEMP tmp, KILL cr);</span>
<span class="line-added">+   format %{ &quot;movl $tmp, $src\n\t&quot;</span>
<span class="line-added">+             &quot;sarl $tmp, 31\n\t&quot;</span>
<span class="line-added">+             &quot;movl $dst, $src\n\t&quot;</span>
<span class="line-added">+             &quot;xorl $dst, $tmp\n\t&quot;</span>
<span class="line-added">+             &quot;subl $dst, $tmp\n&quot;</span>
<span class="line-added">+           %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     __ movl($tmp$$Register, $src$$Register);</span>
<span class="line-added">+     __ sarl($tmp$$Register, 31);</span>
<span class="line-added">+     __ movl($dst$$Register, $src$$Register);</span>
<span class="line-added">+     __ xorl($dst$$Register, $tmp$$Register);</span>
<span class="line-added">+     __ subl($dst$$Register, $tmp$$Register);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_pipe(ialu_reg_reg);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  //----------Long Instructions------------------------------------------------
  // Add Long Register with Register
  instruct addL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
    match(Set dst (AddL dst src));
    effect(KILL cr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11756,136 ***</span>
    ins_pipe( pipe_slow );
  %}
  
  // fast search of substring with known size.
  instruct string_indexof_conL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
<span class="line-modified">!                              eBXRegI result, regD vec, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{</span>
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">!   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
  
<span class="line-modified">!   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
    ins_encode %{
      int icnt2 = (int)$int_cnt2$$constant;
      if (icnt2 &gt;= 16) {
        // IndexOf for constant substrings with size &gt;= 16 elements
        // which don&#39;t need to be loaded through stack.
        __ string_indexofC8($str1$$Register, $str2$$Register,
                            $cnt1$$Register, $cnt2$$Register,
                            icnt2, $result$$Register,
<span class="line-modified">!                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
      } else {
        // Small strings are loaded through stack if they cross page boundary.
        __ string_indexof($str1$$Register, $str2$$Register,
                          $cnt1$$Register, $cnt2$$Register,
                          icnt2, $result$$Register,
<span class="line-modified">!                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  // fast search of substring with known size.
  instruct string_indexof_conU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
<span class="line-modified">!                              eBXRegI result, regD vec, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{</span>
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">!   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
  
<span class="line-modified">!   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
    ins_encode %{
      int icnt2 = (int)$int_cnt2$$constant;
      if (icnt2 &gt;= 8) {
        // IndexOf for constant substrings with size &gt;= 8 elements
        // which don&#39;t need to be loaded through stack.
        __ string_indexofC8($str1$$Register, $str2$$Register,
                            $cnt1$$Register, $cnt2$$Register,
                            icnt2, $result$$Register,
<span class="line-modified">!                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
      } else {
        // Small strings are loaded through stack if they cross page boundary.
        __ string_indexof($str1$$Register, $str2$$Register,
                          $cnt1$$Register, $cnt2$$Register,
                          icnt2, $result$$Register,
<span class="line-modified">!                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  // fast search of substring with known size.
  instruct string_indexof_conUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
<span class="line-modified">!                              eBXRegI result, regD vec, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{</span>
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">!   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
  
<span class="line-modified">!   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
    ins_encode %{
      int icnt2 = (int)$int_cnt2$$constant;
      if (icnt2 &gt;= 8) {
        // IndexOf for constant substrings with size &gt;= 8 elements
        // which don&#39;t need to be loaded through stack.
        __ string_indexofC8($str1$$Register, $str2$$Register,
                            $cnt1$$Register, $cnt2$$Register,
                            icnt2, $result$$Register,
<span class="line-modified">!                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
      } else {
        // Small strings are loaded through stack if they cross page boundary.
        __ string_indexof($str1$$Register, $str2$$Register,
                          $cnt1$$Register, $cnt2$$Register,
                          icnt2, $result$$Register,
<span class="line-modified">!                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
<span class="line-modified">!                          eBXRegI result, regD vec, eCXRegI tmp, eFlagsReg cr) %{</span>
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">!   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
  
    format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof($str1$$Register, $str2$$Register,
                        $cnt1$$Register, $cnt2$$Register,
                        (-1), $result$$Register,
<span class="line-modified">!                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
<span class="line-modified">!                          eBXRegI result, regD vec, eCXRegI tmp, eFlagsReg cr) %{</span>
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">!   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
  
    format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof($str1$$Register, $str2$$Register,
                        $cnt1$$Register, $cnt2$$Register,
                        (-1), $result$$Register,
<span class="line-modified">!                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
<span class="line-modified">!                          eBXRegI result, regD vec, eCXRegI tmp, eFlagsReg cr) %{</span>
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">!   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
  
    format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof($str1$$Register, $str2$$Register,
                        $cnt1$$Register, $cnt2$$Register,
                        (-1), $result$$Register,
<span class="line-modified">!                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofU_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,
<span class="line-new-header">--- 11726,136 ---</span>
    ins_pipe( pipe_slow );
  %}
  
  // fast search of substring with known size.
  instruct string_indexof_conL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
<span class="line-modified">!                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{</span>
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">!   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
  
<span class="line-modified">!   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}</span>
    ins_encode %{
      int icnt2 = (int)$int_cnt2$$constant;
      if (icnt2 &gt;= 16) {
        // IndexOf for constant substrings with size &gt;= 16 elements
        // which don&#39;t need to be loaded through stack.
        __ string_indexofC8($str1$$Register, $str2$$Register,
                            $cnt1$$Register, $cnt2$$Register,
                            icnt2, $result$$Register,
<span class="line-modified">!                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
      } else {
        // Small strings are loaded through stack if they cross page boundary.
        __ string_indexof($str1$$Register, $str2$$Register,
                          $cnt1$$Register, $cnt2$$Register,
                          icnt2, $result$$Register,
<span class="line-modified">!                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  // fast search of substring with known size.
  instruct string_indexof_conU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
<span class="line-modified">!                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{</span>
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">!   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
  
<span class="line-modified">!   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}</span>
    ins_encode %{
      int icnt2 = (int)$int_cnt2$$constant;
      if (icnt2 &gt;= 8) {
        // IndexOf for constant substrings with size &gt;= 8 elements
        // which don&#39;t need to be loaded through stack.
        __ string_indexofC8($str1$$Register, $str2$$Register,
                            $cnt1$$Register, $cnt2$$Register,
                            icnt2, $result$$Register,
<span class="line-modified">!                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
      } else {
        // Small strings are loaded through stack if they cross page boundary.
        __ string_indexof($str1$$Register, $str2$$Register,
                          $cnt1$$Register, $cnt2$$Register,
                          icnt2, $result$$Register,
<span class="line-modified">!                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  // fast search of substring with known size.
  instruct string_indexof_conUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
<span class="line-modified">!                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{</span>
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">!   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
  
<span class="line-modified">!   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}</span>
    ins_encode %{
      int icnt2 = (int)$int_cnt2$$constant;
      if (icnt2 &gt;= 8) {
        // IndexOf for constant substrings with size &gt;= 8 elements
        // which don&#39;t need to be loaded through stack.
        __ string_indexofC8($str1$$Register, $str2$$Register,
                            $cnt1$$Register, $cnt2$$Register,
                            icnt2, $result$$Register,
<span class="line-modified">!                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
      } else {
        // Small strings are loaded through stack if they cross page boundary.
        __ string_indexof($str1$$Register, $str2$$Register,
                          $cnt1$$Register, $cnt2$$Register,
                          icnt2, $result$$Register,
<span class="line-modified">!                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
<span class="line-modified">!                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{</span>
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">!   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
  
    format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof($str1$$Register, $str2$$Register,
                        $cnt1$$Register, $cnt2$$Register,
                        (-1), $result$$Register,
<span class="line-modified">!                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
<span class="line-modified">!                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{</span>
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">!   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
  
    format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof($str1$$Register, $str2$$Register,
                        $cnt1$$Register, $cnt2$$Register,
                        (-1), $result$$Register,
<span class="line-modified">!                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
<span class="line-modified">!                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{</span>
    predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
    match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">!   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
  
    format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
    ins_encode %{
      __ string_indexof($str1$$Register, $str2$$Register,
                        $cnt1$$Register, $cnt2$$Register,
                        (-1), $result$$Register,
<span class="line-modified">!                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct string_indexofU_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,
</pre>
<center><a href="x86.ad.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_64.ad.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
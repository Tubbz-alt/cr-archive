<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/vm_version_ext_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="templateTable_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_ext_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/vm_version_ext_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 26 #include &quot;jvm.h&quot;
 27 #include &quot;utilities/macros.hpp&quot;
 28 #include &quot;asm/macroAssembler.hpp&quot;
 29 #include &quot;asm/macroAssembler.inline.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 34 #include &quot;vm_version_ext_x86.hpp&quot;
 35 
 36 typedef enum {
 37    CPU_FAMILY_8086_8088  = 0,
 38    CPU_FAMILY_INTEL_286  = 2,
 39    CPU_FAMILY_INTEL_386  = 3,
 40    CPU_FAMILY_INTEL_486  = 4,
 41    CPU_FAMILY_PENTIUM    = 5,
 42    CPU_FAMILY_PENTIUMPRO = 6,    // Same family several models
 43    CPU_FAMILY_PENTIUM_4  = 0xF
 44 } FamilyFlag;
 45 
<span class="line-modified"> 46  typedef enum {</span>
<span class="line-modified"> 47     RDTSCP_FLAG  = 0x08000000, // bit 27</span>
<span class="line-modified"> 48     INTEL64_FLAG = 0x20000000  // bit 29</span>
<span class="line-modified"> 49   } _featureExtendedEdxFlag;</span>
 50 
 51 #define CPUID_STANDARD_FN   0x0
 52 #define CPUID_STANDARD_FN_1 0x1
 53 #define CPUID_STANDARD_FN_4 0x4
 54 #define CPUID_STANDARD_FN_B 0xb
 55 
 56 #define CPUID_EXTENDED_FN   0x80000000
 57 #define CPUID_EXTENDED_FN_1 0x80000001
 58 #define CPUID_EXTENDED_FN_2 0x80000002
 59 #define CPUID_EXTENDED_FN_3 0x80000003
 60 #define CPUID_EXTENDED_FN_4 0x80000004
 61 #define CPUID_EXTENDED_FN_7 0x80000007
 62 #define CPUID_EXTENDED_FN_8 0x80000008
 63 
 64 typedef enum {
 65    FPU_FLAG     = 0x00000001,
 66    VME_FLAG     = 0x00000002,
 67    DE_FLAG      = 0x00000004,
 68    PSE_FLAG     = 0x00000008,
 69    TSC_FLAG     = 0x00000010,
</pre>
<hr />
<pre>
323   return ((_cpuid_info.ext_cpuid1_edx.value &amp; INTEL64_FLAG) == INTEL64_FLAG);
324 }
325 
326 bool VM_Version_Ext::is_netburst(void) {
327   return (is_intel() &amp;&amp; (extended_cpu_family() == CPU_FAMILY_PENTIUM_4));
328 }
329 
330 bool VM_Version_Ext::supports_tscinv_ext(void) {
331   if (!supports_tscinv_bit()) {
332     return false;
333   }
334 
335   if (is_intel()) {
336     return true;
337   }
338 
339   if (is_amd()) {
340     return !is_amd_Barcelona();
341   }
342 




343   return false;
344 }
345 
346 void VM_Version_Ext::resolve_cpu_information_details(void) {
347 
348   // in future we want to base this information on proper cpu
349   // and cache topology enumeration such as:
350   // Intel 64 Architecture Processor Topology Enumeration
351   // which supports system cpu and cache topology enumeration
352   // either using 2xAPICIDs or initial APICIDs
353 
354   // currently only rough cpu information estimates
355   // which will not necessarily reflect the exact configuration of the system
356 
357   // this is the number of logical hardware threads
358   // visible to the operating system
359   _no_of_threads = os::processor_count();
360 
361   // find out number of threads per cpu package
362   int threads_per_package = threads_per_core() * cores_per_cpu();
</pre>
<hr />
<pre>
382   return _no_of_threads;
383 }
384 
385 int VM_Version_Ext::number_of_cores(void) {
386   if (_no_of_cores == 0) {
387     resolve_cpu_information_details();
388   }
389   return _no_of_cores;
390 }
391 
392 int VM_Version_Ext::number_of_sockets(void) {
393   if (_no_of_packages == 0) {
394     resolve_cpu_information_details();
395   }
396   return _no_of_packages;
397 }
398 
399 const char* VM_Version_Ext::cpu_family_description(void) {
400   int cpu_family_id = extended_cpu_family();
401   if (is_amd()) {
<span class="line-modified">402     return _family_id_amd[cpu_family_id];</span>


403   }
404   if (is_intel()) {
405     if (cpu_family_id == CPU_FAMILY_PENTIUMPRO) {
406       return cpu_model_description();
407     }
<span class="line-modified">408     return _family_id_intel[cpu_family_id];</span>





409   }
410   return &quot;Unknown x86&quot;;
411 }
412 
413 int VM_Version_Ext::cpu_type_description(char* const buf, size_t buf_len) {
414   assert(buf != NULL, &quot;buffer is NULL!&quot;);
415   assert(buf_len &gt;= CPU_TYPE_DESC_BUF_SIZE, &quot;buffer len should at least be == CPU_TYPE_DESC_BUF_SIZE!&quot;);
416 
417   const char* cpu_type = NULL;
418   const char* x64 = NULL;
419 
420   if (is_intel()) {
421     cpu_type = &quot;Intel&quot;;
422     x64 = cpu_is_em64t() ? &quot; Intel64&quot; : &quot;&quot;;
423   } else if (is_amd()) {
424     cpu_type = &quot;AMD&quot;;
425     x64 = cpu_is_em64t() ? &quot; AMD64&quot; : &quot;&quot;;



426   } else {
427     cpu_type = &quot;Unknown x86&quot;;
428     x64 = cpu_is_em64t() ? &quot; x86_64&quot; : &quot;&quot;;
429   }
430 
431   jio_snprintf(buf, buf_len, &quot;%s %s%s SSE SSE2%s%s%s%s%s%s%s%s&quot;,
432     cpu_type,
433     cpu_family_description(),
434     supports_ht() ? &quot; (HT)&quot; : &quot;&quot;,
435     supports_sse3() ? &quot; SSE3&quot; : &quot;&quot;,
436     supports_ssse3() ? &quot; SSSE3&quot; : &quot;&quot;,
437     supports_sse4_1() ? &quot; SSE4.1&quot; : &quot;&quot;,
438     supports_sse4_2() ? &quot; SSE4.2&quot; : &quot;&quot;,
439     supports_sse4a() ? &quot; SSE4A&quot; : &quot;&quot;,
440     is_netburst() ? &quot; Netburst&quot; : &quot;&quot;,
441     is_intel_family_core() ? &quot; Core&quot; : &quot;&quot;,
442     x64);
443 
444   return OS_OK;
445 }
</pre>
<hr />
<pre>
677       frequency += (jlong)(*(Hz_location - 2) - &#39;0&#39;) * (multiplier / 100);
678     } else { // format is &quot;xxxx&quot;
679       frequency =  (jlong)(*(Hz_location - 5) - &#39;0&#39;) * 1000;
680       frequency += (jlong)(*(Hz_location - 4) - &#39;0&#39;) * 100;
681       frequency += (jlong)(*(Hz_location - 3) - &#39;0&#39;) * 10;
682       frequency += (jlong)(*(Hz_location - 2) - &#39;0&#39;);
683       frequency *= multiplier;
684     }
685   }
686   return frequency;
687 }
688 
689 
690 jlong VM_Version_Ext::maximum_qualified_cpu_frequency(void) {
691   if (_max_qualified_cpu_frequency == 0) {
692     _max_qualified_cpu_frequency = max_qualified_cpu_freq_from_brand_string();
693   }
694   return _max_qualified_cpu_frequency;
695 }
696 
<span class="line-modified">697 const char* const VM_Version_Ext::_family_id_intel[] = {</span>
698   &quot;8086/8088&quot;,
699   &quot;&quot;,
700   &quot;286&quot;,
701   &quot;386&quot;,
702   &quot;486&quot;,
703   &quot;Pentium&quot;,
704   &quot;Pentium Pro&quot;,   //or Pentium-M/Woodcrest depeding on model
705   &quot;&quot;,
706   &quot;&quot;,
707   &quot;&quot;,
708   &quot;&quot;,
709   &quot;&quot;,
710   &quot;&quot;,
711   &quot;&quot;,
712   &quot;&quot;,
713   &quot;Pentium 4&quot;
714 };
715 
<span class="line-modified">716 const char* const VM_Version_Ext::_family_id_amd[] = {</span>
717   &quot;&quot;,
718   &quot;&quot;,
719   &quot;&quot;,
720   &quot;&quot;,
721   &quot;5x86&quot;,
722   &quot;K5/K6&quot;,
723   &quot;Athlon/AthlonXP&quot;,
724   &quot;&quot;,
725   &quot;&quot;,
726   &quot;&quot;,
727   &quot;&quot;,
728   &quot;&quot;,
729   &quot;&quot;,
730   &quot;&quot;,
731   &quot;&quot;,
732   &quot;Opteron/Athlon64&quot;,
733   &quot;Opteron QC/Phenom&quot;  // Barcelona et.al.







734 };
735 // Partially from Intel 64 and IA-32 Architecture Software Developer&#39;s Manual,
736 // September 2013, Vol 3C Table 35-1
737 const char* const VM_Version_Ext::_model_id_pentium_pro[] = {
738   &quot;&quot;,
739   &quot;Pentium Pro&quot;,
740   &quot;&quot;,
741   &quot;Pentium II model 3&quot;,
742   &quot;&quot;,
743   &quot;Pentium II model 5/Xeon/Celeron&quot;,
744   &quot;Celeron&quot;,
745   &quot;Pentium III/Pentium III Xeon&quot;,
746   &quot;Pentium III/Pentium III Xeon&quot;,
747   &quot;Pentium M model 9&quot;,    // Yonah
748   &quot;Pentium III, model A&quot;,
749   &quot;Pentium III, model B&quot;,
750   &quot;&quot;,
751   &quot;Pentium M model D&quot;,    // Dothan
752   &quot;&quot;,
753   &quot;Core 2&quot;,               // 0xf Woodcrest/Conroe/Merom/Kentsfield/Clovertown
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 26 #include &quot;jvm.h&quot;
 27 #include &quot;utilities/macros.hpp&quot;
 28 #include &quot;asm/macroAssembler.hpp&quot;
 29 #include &quot;asm/macroAssembler.inline.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 34 #include &quot;vm_version_ext_x86.hpp&quot;
 35 
 36 typedef enum {
 37    CPU_FAMILY_8086_8088  = 0,
 38    CPU_FAMILY_INTEL_286  = 2,
 39    CPU_FAMILY_INTEL_386  = 3,
 40    CPU_FAMILY_INTEL_486  = 4,
 41    CPU_FAMILY_PENTIUM    = 5,
 42    CPU_FAMILY_PENTIUMPRO = 6,    // Same family several models
 43    CPU_FAMILY_PENTIUM_4  = 0xF
 44 } FamilyFlag;
 45 
<span class="line-modified"> 46 typedef enum {</span>
<span class="line-modified"> 47   RDTSCP_FLAG  = 0x08000000, // bit 27</span>
<span class="line-modified"> 48   INTEL64_FLAG = 0x20000000  // bit 29</span>
<span class="line-modified"> 49 } _featureExtendedEdxFlag;</span>
 50 
 51 #define CPUID_STANDARD_FN   0x0
 52 #define CPUID_STANDARD_FN_1 0x1
 53 #define CPUID_STANDARD_FN_4 0x4
 54 #define CPUID_STANDARD_FN_B 0xb
 55 
 56 #define CPUID_EXTENDED_FN   0x80000000
 57 #define CPUID_EXTENDED_FN_1 0x80000001
 58 #define CPUID_EXTENDED_FN_2 0x80000002
 59 #define CPUID_EXTENDED_FN_3 0x80000003
 60 #define CPUID_EXTENDED_FN_4 0x80000004
 61 #define CPUID_EXTENDED_FN_7 0x80000007
 62 #define CPUID_EXTENDED_FN_8 0x80000008
 63 
 64 typedef enum {
 65    FPU_FLAG     = 0x00000001,
 66    VME_FLAG     = 0x00000002,
 67    DE_FLAG      = 0x00000004,
 68    PSE_FLAG     = 0x00000008,
 69    TSC_FLAG     = 0x00000010,
</pre>
<hr />
<pre>
323   return ((_cpuid_info.ext_cpuid1_edx.value &amp; INTEL64_FLAG) == INTEL64_FLAG);
324 }
325 
326 bool VM_Version_Ext::is_netburst(void) {
327   return (is_intel() &amp;&amp; (extended_cpu_family() == CPU_FAMILY_PENTIUM_4));
328 }
329 
330 bool VM_Version_Ext::supports_tscinv_ext(void) {
331   if (!supports_tscinv_bit()) {
332     return false;
333   }
334 
335   if (is_intel()) {
336     return true;
337   }
338 
339   if (is_amd()) {
340     return !is_amd_Barcelona();
341   }
342 
<span class="line-added">343   if (is_hygon()) {</span>
<span class="line-added">344     return true;</span>
<span class="line-added">345   }</span>
<span class="line-added">346 </span>
347   return false;
348 }
349 
350 void VM_Version_Ext::resolve_cpu_information_details(void) {
351 
352   // in future we want to base this information on proper cpu
353   // and cache topology enumeration such as:
354   // Intel 64 Architecture Processor Topology Enumeration
355   // which supports system cpu and cache topology enumeration
356   // either using 2xAPICIDs or initial APICIDs
357 
358   // currently only rough cpu information estimates
359   // which will not necessarily reflect the exact configuration of the system
360 
361   // this is the number of logical hardware threads
362   // visible to the operating system
363   _no_of_threads = os::processor_count();
364 
365   // find out number of threads per cpu package
366   int threads_per_package = threads_per_core() * cores_per_cpu();
</pre>
<hr />
<pre>
386   return _no_of_threads;
387 }
388 
389 int VM_Version_Ext::number_of_cores(void) {
390   if (_no_of_cores == 0) {
391     resolve_cpu_information_details();
392   }
393   return _no_of_cores;
394 }
395 
396 int VM_Version_Ext::number_of_sockets(void) {
397   if (_no_of_packages == 0) {
398     resolve_cpu_information_details();
399   }
400   return _no_of_packages;
401 }
402 
403 const char* VM_Version_Ext::cpu_family_description(void) {
404   int cpu_family_id = extended_cpu_family();
405   if (is_amd()) {
<span class="line-modified">406     if (cpu_family_id &lt; ExtendedFamilyIdLength_AMD) {</span>
<span class="line-added">407       return _family_id_amd[cpu_family_id];</span>
<span class="line-added">408     }</span>
409   }
410   if (is_intel()) {
411     if (cpu_family_id == CPU_FAMILY_PENTIUMPRO) {
412       return cpu_model_description();
413     }
<span class="line-modified">414     if (cpu_family_id &lt; ExtendedFamilyIdLength_INTEL) {</span>
<span class="line-added">415       return _family_id_intel[cpu_family_id];</span>
<span class="line-added">416     }</span>
<span class="line-added">417   }</span>
<span class="line-added">418   if (is_hygon()) {</span>
<span class="line-added">419     return &quot;Dhyana&quot;;</span>
420   }
421   return &quot;Unknown x86&quot;;
422 }
423 
424 int VM_Version_Ext::cpu_type_description(char* const buf, size_t buf_len) {
425   assert(buf != NULL, &quot;buffer is NULL!&quot;);
426   assert(buf_len &gt;= CPU_TYPE_DESC_BUF_SIZE, &quot;buffer len should at least be == CPU_TYPE_DESC_BUF_SIZE!&quot;);
427 
428   const char* cpu_type = NULL;
429   const char* x64 = NULL;
430 
431   if (is_intel()) {
432     cpu_type = &quot;Intel&quot;;
433     x64 = cpu_is_em64t() ? &quot; Intel64&quot; : &quot;&quot;;
434   } else if (is_amd()) {
435     cpu_type = &quot;AMD&quot;;
436     x64 = cpu_is_em64t() ? &quot; AMD64&quot; : &quot;&quot;;
<span class="line-added">437   } else if (is_hygon()) {</span>
<span class="line-added">438     cpu_type = &quot;Hygon&quot;;</span>
<span class="line-added">439     x64 = cpu_is_em64t() ? &quot; AMD64&quot; : &quot;&quot;;</span>
440   } else {
441     cpu_type = &quot;Unknown x86&quot;;
442     x64 = cpu_is_em64t() ? &quot; x86_64&quot; : &quot;&quot;;
443   }
444 
445   jio_snprintf(buf, buf_len, &quot;%s %s%s SSE SSE2%s%s%s%s%s%s%s%s&quot;,
446     cpu_type,
447     cpu_family_description(),
448     supports_ht() ? &quot; (HT)&quot; : &quot;&quot;,
449     supports_sse3() ? &quot; SSE3&quot; : &quot;&quot;,
450     supports_ssse3() ? &quot; SSSE3&quot; : &quot;&quot;,
451     supports_sse4_1() ? &quot; SSE4.1&quot; : &quot;&quot;,
452     supports_sse4_2() ? &quot; SSE4.2&quot; : &quot;&quot;,
453     supports_sse4a() ? &quot; SSE4A&quot; : &quot;&quot;,
454     is_netburst() ? &quot; Netburst&quot; : &quot;&quot;,
455     is_intel_family_core() ? &quot; Core&quot; : &quot;&quot;,
456     x64);
457 
458   return OS_OK;
459 }
</pre>
<hr />
<pre>
691       frequency += (jlong)(*(Hz_location - 2) - &#39;0&#39;) * (multiplier / 100);
692     } else { // format is &quot;xxxx&quot;
693       frequency =  (jlong)(*(Hz_location - 5) - &#39;0&#39;) * 1000;
694       frequency += (jlong)(*(Hz_location - 4) - &#39;0&#39;) * 100;
695       frequency += (jlong)(*(Hz_location - 3) - &#39;0&#39;) * 10;
696       frequency += (jlong)(*(Hz_location - 2) - &#39;0&#39;);
697       frequency *= multiplier;
698     }
699   }
700   return frequency;
701 }
702 
703 
704 jlong VM_Version_Ext::maximum_qualified_cpu_frequency(void) {
705   if (_max_qualified_cpu_frequency == 0) {
706     _max_qualified_cpu_frequency = max_qualified_cpu_freq_from_brand_string();
707   }
708   return _max_qualified_cpu_frequency;
709 }
710 
<span class="line-modified">711 const char* const VM_Version_Ext::_family_id_intel[ExtendedFamilyIdLength_INTEL] = {</span>
712   &quot;8086/8088&quot;,
713   &quot;&quot;,
714   &quot;286&quot;,
715   &quot;386&quot;,
716   &quot;486&quot;,
717   &quot;Pentium&quot;,
718   &quot;Pentium Pro&quot;,   //or Pentium-M/Woodcrest depeding on model
719   &quot;&quot;,
720   &quot;&quot;,
721   &quot;&quot;,
722   &quot;&quot;,
723   &quot;&quot;,
724   &quot;&quot;,
725   &quot;&quot;,
726   &quot;&quot;,
727   &quot;Pentium 4&quot;
728 };
729 
<span class="line-modified">730 const char* const VM_Version_Ext::_family_id_amd[ExtendedFamilyIdLength_AMD] = {</span>
731   &quot;&quot;,
732   &quot;&quot;,
733   &quot;&quot;,
734   &quot;&quot;,
735   &quot;5x86&quot;,
736   &quot;K5/K6&quot;,
737   &quot;Athlon/AthlonXP&quot;,
738   &quot;&quot;,
739   &quot;&quot;,
740   &quot;&quot;,
741   &quot;&quot;,
742   &quot;&quot;,
743   &quot;&quot;,
744   &quot;&quot;,
745   &quot;&quot;,
746   &quot;Opteron/Athlon64&quot;,
747   &quot;Opteron QC/Phenom&quot;  // Barcelona et.al.
<span class="line-added">748   &quot;&quot;,</span>
<span class="line-added">749   &quot;&quot;,</span>
<span class="line-added">750   &quot;&quot;,</span>
<span class="line-added">751   &quot;&quot;,</span>
<span class="line-added">752   &quot;&quot;,</span>
<span class="line-added">753   &quot;&quot;,</span>
<span class="line-added">754   &quot;Zen&quot;</span>
755 };
756 // Partially from Intel 64 and IA-32 Architecture Software Developer&#39;s Manual,
757 // September 2013, Vol 3C Table 35-1
758 const char* const VM_Version_Ext::_model_id_pentium_pro[] = {
759   &quot;&quot;,
760   &quot;Pentium Pro&quot;,
761   &quot;&quot;,
762   &quot;Pentium II model 3&quot;,
763   &quot;&quot;,
764   &quot;Pentium II model 5/Xeon/Celeron&quot;,
765   &quot;Celeron&quot;,
766   &quot;Pentium III/Pentium III Xeon&quot;,
767   &quot;Pentium III/Pentium III Xeon&quot;,
768   &quot;Pentium M model 9&quot;,    // Yonah
769   &quot;Pentium III, model A&quot;,
770   &quot;Pentium III, model B&quot;,
771   &quot;&quot;,
772   &quot;Pentium M model D&quot;,    // Dothan
773   &quot;&quot;,
774   &quot;Core 2&quot;,               // 0xf Woodcrest/Conroe/Merom/Kentsfield/Clovertown
</pre>
</td>
</tr>
</table>
<center><a href="templateTable_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_ext_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/c1_CodeStubs_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Defs_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_CodeStubs_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;c1/c1_CodeStubs.hpp&quot;
 27 #include &quot;c1/c1_FrameMap.hpp&quot;
 28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
 29 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 30 #include &quot;c1/c1_Runtime1.hpp&quot;
 31 #include &quot;nativeInst_x86.hpp&quot;
 32 #include &quot;runtime/sharedRuntime.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 #include &quot;vmreg_x86.inline.hpp&quot;
 36 
 37 
 38 #define __ ce-&gt;masm()-&gt;
 39 

 40 float ConversionStub::float_zero = 0.0;
 41 double ConversionStub::double_zero = 0.0;
 42 
 43 void ConversionStub::emit_code(LIR_Assembler* ce) {
 44   __ bind(_entry);
 45   assert(bytecode() == Bytecodes::_f2i || bytecode() == Bytecodes::_d2i, &quot;other conversions do not require stub&quot;);
 46 
 47 
 48   if (input()-&gt;is_single_xmm()) {
 49     __ comiss(input()-&gt;as_xmm_float_reg(),
 50               ExternalAddress((address)&amp;float_zero));
 51   } else if (input()-&gt;is_double_xmm()) {
 52     __ comisd(input()-&gt;as_xmm_double_reg(),
 53               ExternalAddress((address)&amp;double_zero));
 54   } else {
<span class="line-removed"> 55     LP64_ONLY(ShouldNotReachHere());</span>
 56     __ push(rax);
 57     __ ftst();
 58     __ fnstsw_ax();
 59     __ sahf();
 60     __ pop(rax);
 61   }
 62 
 63   Label NaN, do_return;
 64   __ jccb(Assembler::parity, NaN);
 65   __ jccb(Assembler::below, do_return);
 66 
 67   // input is &gt; 0 -&gt; return maxInt
 68   // result register already contains 0x80000000, so subtracting 1 gives 0x7fffffff
 69   __ decrement(result()-&gt;as_register());
 70   __ jmpb(do_return);
 71 
 72   // input is NaN -&gt; return 0
 73   __ bind(NaN);
 74   __ xorptr(result()-&gt;as_register(), result()-&gt;as_register());
 75 
 76   __ bind(do_return);
 77   __ jmp(_continuation);
 78 }

 79 
 80 void CounterOverflowStub::emit_code(LIR_Assembler* ce) {
 81   __ bind(_entry);
 82   Metadata *m = _method-&gt;as_constant_ptr()-&gt;as_metadata();
 83   ce-&gt;store_parameter(m, 1);
 84   ce-&gt;store_parameter(_bci, 0);
 85   __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::counter_overflow_id)));
 86   ce-&gt;add_call_info_here(_info);
 87   ce-&gt;verify_oop_map(_info);
 88   __ jmp(_continuation);
 89 }
 90 
 91 RangeCheckStub::RangeCheckStub(CodeEmitInfo* info, LIR_Opr index, LIR_Opr array)
 92   : _index(index), _array(array), _throw_index_out_of_bounds_exception(false) {
 93   assert(info != NULL, &quot;must have info&quot;);
 94   _info = new CodeEmitInfo(info);
 95 }
 96 
 97 RangeCheckStub::RangeCheckStub(CodeEmitInfo* info, LIR_Opr index)
 98   : _index(index), _array(NULL), _throw_index_out_of_bounds_exception(true) {
</pre>
</td>
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;c1/c1_CodeStubs.hpp&quot;
 27 #include &quot;c1/c1_FrameMap.hpp&quot;
 28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
 29 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 30 #include &quot;c1/c1_Runtime1.hpp&quot;
 31 #include &quot;nativeInst_x86.hpp&quot;
 32 #include &quot;runtime/sharedRuntime.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 #include &quot;vmreg_x86.inline.hpp&quot;
 36 
 37 
 38 #define __ ce-&gt;masm()-&gt;
 39 
<span class="line-added"> 40 #ifndef _LP64</span>
 41 float ConversionStub::float_zero = 0.0;
 42 double ConversionStub::double_zero = 0.0;
 43 
 44 void ConversionStub::emit_code(LIR_Assembler* ce) {
 45   __ bind(_entry);
 46   assert(bytecode() == Bytecodes::_f2i || bytecode() == Bytecodes::_d2i, &quot;other conversions do not require stub&quot;);
 47 
 48 
 49   if (input()-&gt;is_single_xmm()) {
 50     __ comiss(input()-&gt;as_xmm_float_reg(),
 51               ExternalAddress((address)&amp;float_zero));
 52   } else if (input()-&gt;is_double_xmm()) {
 53     __ comisd(input()-&gt;as_xmm_double_reg(),
 54               ExternalAddress((address)&amp;double_zero));
 55   } else {

 56     __ push(rax);
 57     __ ftst();
 58     __ fnstsw_ax();
 59     __ sahf();
 60     __ pop(rax);
 61   }
 62 
 63   Label NaN, do_return;
 64   __ jccb(Assembler::parity, NaN);
 65   __ jccb(Assembler::below, do_return);
 66 
 67   // input is &gt; 0 -&gt; return maxInt
 68   // result register already contains 0x80000000, so subtracting 1 gives 0x7fffffff
 69   __ decrement(result()-&gt;as_register());
 70   __ jmpb(do_return);
 71 
 72   // input is NaN -&gt; return 0
 73   __ bind(NaN);
 74   __ xorptr(result()-&gt;as_register(), result()-&gt;as_register());
 75 
 76   __ bind(do_return);
 77   __ jmp(_continuation);
 78 }
<span class="line-added"> 79 #endif // !_LP64</span>
 80 
 81 void CounterOverflowStub::emit_code(LIR_Assembler* ce) {
 82   __ bind(_entry);
 83   Metadata *m = _method-&gt;as_constant_ptr()-&gt;as_metadata();
 84   ce-&gt;store_parameter(m, 1);
 85   ce-&gt;store_parameter(_bci, 0);
 86   __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::counter_overflow_id)));
 87   ce-&gt;add_call_info_here(_info);
 88   ce-&gt;verify_oop_map(_info);
 89   __ jmp(_continuation);
 90 }
 91 
 92 RangeCheckStub::RangeCheckStub(CodeEmitInfo* info, LIR_Opr index, LIR_Opr array)
 93   : _index(index), _array(array), _throw_index_out_of_bounds_exception(false) {
 94   assert(info != NULL, &quot;must have info&quot;);
 95   _info = new CodeEmitInfo(info);
 96 }
 97 
 98 RangeCheckStub::RangeCheckStub(CodeEmitInfo* info, LIR_Opr index)
 99   : _index(index), _array(NULL), _throw_index_out_of_bounds_exception(true) {
</pre>
</td>
</tr>
</table>
<center><a href="assembler_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Defs_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/vm_version_ext_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;utilities/macros.hpp&quot;
 28 #include &quot;asm/macroAssembler.hpp&quot;
 29 #include &quot;asm/macroAssembler.inline.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 34 #include &quot;vm_version_ext_x86.hpp&quot;
 35 
 36 typedef enum {
 37    CPU_FAMILY_8086_8088  = 0,
 38    CPU_FAMILY_INTEL_286  = 2,
 39    CPU_FAMILY_INTEL_386  = 3,
 40    CPU_FAMILY_INTEL_486  = 4,
 41    CPU_FAMILY_PENTIUM    = 5,
 42    CPU_FAMILY_PENTIUMPRO = 6,    // Same family several models
 43    CPU_FAMILY_PENTIUM_4  = 0xF
 44 } FamilyFlag;
 45 
<a name="2" id="anc2"></a><span class="line-modified"> 46  typedef enum {</span>
<span class="line-modified"> 47     RDTSCP_FLAG  = 0x08000000, // bit 27</span>
<span class="line-modified"> 48     INTEL64_FLAG = 0x20000000  // bit 29</span>
<span class="line-modified"> 49   } _featureExtendedEdxFlag;</span>
 50 
 51 #define CPUID_STANDARD_FN   0x0
 52 #define CPUID_STANDARD_FN_1 0x1
 53 #define CPUID_STANDARD_FN_4 0x4
 54 #define CPUID_STANDARD_FN_B 0xb
 55 
 56 #define CPUID_EXTENDED_FN   0x80000000
 57 #define CPUID_EXTENDED_FN_1 0x80000001
 58 #define CPUID_EXTENDED_FN_2 0x80000002
 59 #define CPUID_EXTENDED_FN_3 0x80000003
 60 #define CPUID_EXTENDED_FN_4 0x80000004
 61 #define CPUID_EXTENDED_FN_7 0x80000007
 62 #define CPUID_EXTENDED_FN_8 0x80000008
 63 
 64 typedef enum {
 65    FPU_FLAG     = 0x00000001,
 66    VME_FLAG     = 0x00000002,
 67    DE_FLAG      = 0x00000004,
 68    PSE_FLAG     = 0x00000008,
 69    TSC_FLAG     = 0x00000010,
 70    MSR_FLAG     = 0x00000020,
 71    PAE_FLAG     = 0x00000040,
 72    MCE_FLAG     = 0x00000080,
 73    CX8_FLAG     = 0x00000100,
 74    APIC_FLAG    = 0x00000200,
 75    SEP_FLAG     = 0x00000800,
 76    MTRR_FLAG    = 0x00001000,
 77    PGE_FLAG     = 0x00002000,
 78    MCA_FLAG     = 0x00004000,
 79    CMOV_FLAG    = 0x00008000,
 80    PAT_FLAG     = 0x00010000,
 81    PSE36_FLAG   = 0x00020000,
 82    PSNUM_FLAG   = 0x00040000,
 83    CLFLUSH_FLAG = 0x00080000,
 84    DTS_FLAG     = 0x00200000,
 85    ACPI_FLAG    = 0x00400000,
 86    MMX_FLAG     = 0x00800000,
 87    FXSR_FLAG    = 0x01000000,
 88    SSE_FLAG     = 0x02000000,
 89    SSE2_FLAG    = 0x04000000,
 90    SS_FLAG      = 0x08000000,
 91    HTT_FLAG     = 0x10000000,
 92    TM_FLAG      = 0x20000000
 93 } FeatureEdxFlag;
 94 
 95 static BufferBlob* cpuid_brand_string_stub_blob;
 96 static const int   cpuid_brand_string_stub_size = 550;
 97 
 98 extern &quot;C&quot; {
 99   typedef void (*getCPUIDBrandString_stub_t)(void*);
100 }
101 
102 static getCPUIDBrandString_stub_t getCPUIDBrandString_stub = NULL;
103 
104 class VM_Version_Ext_StubGenerator: public StubCodeGenerator {
105  public:
106 
107   VM_Version_Ext_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}
108 
109   address generate_getCPUIDBrandString(void) {
110     // Flags to test CPU type.
111     const uint32_t HS_EFL_AC           = 0x40000;
112     const uint32_t HS_EFL_ID           = 0x200000;
113     // Values for when we don&#39;t have a CPUID instruction.
114     const int      CPU_FAMILY_SHIFT = 8;
115     const uint32_t CPU_FAMILY_386   = (3 &lt;&lt; CPU_FAMILY_SHIFT);
116     const uint32_t CPU_FAMILY_486   = (4 &lt;&lt; CPU_FAMILY_SHIFT);
117 
118     Label detect_486, cpu486, detect_586, done, ext_cpuid;
119 
120     StubCodeMark mark(this, &quot;VM_Version_Ext&quot;, &quot;getCPUIDNameInfo_stub&quot;);
121 #   define __ _masm-&gt;
122 
123     address start = __ pc();
124 
125     //
126     // void getCPUIDBrandString(VM_Version::CpuidInfo* cpuid_info);
127     //
128     // LP64: rcx and rdx are first and second argument registers on windows
129 
130     __ push(rbp);
131 #ifdef _LP64
132     __ mov(rbp, c_rarg0); // cpuid_info address
133 #else
134     __ movptr(rbp, Address(rsp, 8)); // cpuid_info address
135 #endif
136     __ push(rbx);
137     __ push(rsi);
138     __ pushf();          // preserve rbx, and flags
139     __ pop(rax);
140     __ push(rax);
141     __ mov(rcx, rax);
142     //
143     // if we are unable to change the AC flag, we have a 386
144     //
145     __ xorl(rax, HS_EFL_AC);
146     __ push(rax);
147     __ popf();
148     __ pushf();
149     __ pop(rax);
150     __ cmpptr(rax, rcx);
151     __ jccb(Assembler::notEqual, detect_486);
152 
153     __ movl(rax, CPU_FAMILY_386);
154     __ jmp(done);
155 
156     //
157     // If we are unable to change the ID flag, we have a 486 which does
158     // not support the &quot;cpuid&quot; instruction.
159     //
160     __ bind(detect_486);
161     __ mov(rax, rcx);
162     __ xorl(rax, HS_EFL_ID);
163     __ push(rax);
164     __ popf();
165     __ pushf();
166     __ pop(rax);
167     __ cmpptr(rcx, rax);
168     __ jccb(Assembler::notEqual, detect_586);
169 
170     __ bind(cpu486);
171     __ movl(rax, CPU_FAMILY_486);
172     __ jmp(done);
173 
174     //
175     // At this point, we have a chip which supports the &quot;cpuid&quot; instruction
176     //
177     __ bind(detect_586);
178     __ xorl(rax, rax);
179     __ cpuid();
180     __ orl(rax, rax);
181     __ jcc(Assembler::equal, cpu486);   // if cpuid doesn&#39;t support an input
182                                         // value of at least 1, we give up and
183                                         // assume a 486
184 
185     //
186     // Extended cpuid(0x80000000) for processor brand string detection
187     //
188     __ bind(ext_cpuid);
189     __ movl(rax, CPUID_EXTENDED_FN);
190     __ cpuid();
191     __ cmpl(rax, CPUID_EXTENDED_FN_4);
192     __ jcc(Assembler::below, done);
193 
194     //
195     // Extended cpuid(0x80000002)  // first 16 bytes in brand string
196     //
197     __ movl(rax, CPUID_EXTENDED_FN_2);
198     __ cpuid();
199     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_0_offset())));
200     __ movl(Address(rsi, 0), rax);
201     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_1_offset())));
202     __ movl(Address(rsi, 0), rbx);
203     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_2_offset())));
204     __ movl(Address(rsi, 0), rcx);
205     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_3_offset())));
206     __ movl(Address(rsi,0), rdx);
207 
208     //
209     // Extended cpuid(0x80000003) // next 16 bytes in brand string
210     //
211     __ movl(rax, CPUID_EXTENDED_FN_3);
212     __ cpuid();
213     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_4_offset())));
214     __ movl(Address(rsi, 0), rax);
215     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_5_offset())));
216     __ movl(Address(rsi, 0), rbx);
217     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_6_offset())));
218     __ movl(Address(rsi, 0), rcx);
219     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_7_offset())));
220     __ movl(Address(rsi,0), rdx);
221 
222     //
223     // Extended cpuid(0x80000004) // last 16 bytes in brand string
224     //
225     __ movl(rax, CPUID_EXTENDED_FN_4);
226     __ cpuid();
227     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_8_offset())));
228     __ movl(Address(rsi, 0), rax);
229     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_9_offset())));
230     __ movl(Address(rsi, 0), rbx);
231     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_10_offset())));
232     __ movl(Address(rsi, 0), rcx);
233     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_11_offset())));
234     __ movl(Address(rsi,0), rdx);
235 
236     //
237     // return
238     //
239     __ bind(done);
240     __ popf();
241     __ pop(rsi);
242     __ pop(rbx);
243     __ pop(rbp);
244     __ ret(0);
245 
246 #   undef __
247 
248     return start;
249   };
250 };
251 
252 
253 // VM_Version_Ext statics
254 const size_t VM_Version_Ext::VENDOR_LENGTH = 13;
255 const size_t VM_Version_Ext::CPU_EBS_MAX_LENGTH = (3 * 4 * 4 + 1);
256 const size_t VM_Version_Ext::CPU_TYPE_DESC_BUF_SIZE = 256;
257 const size_t VM_Version_Ext::CPU_DETAILED_DESC_BUF_SIZE = 4096;
258 char* VM_Version_Ext::_cpu_brand_string = NULL;
259 jlong VM_Version_Ext::_max_qualified_cpu_frequency = 0;
260 
261 int VM_Version_Ext::_no_of_threads = 0;
262 int VM_Version_Ext::_no_of_cores = 0;
263 int VM_Version_Ext::_no_of_packages = 0;
264 
265 void VM_Version_Ext::initialize(void) {
266   ResourceMark rm;
267 
268   cpuid_brand_string_stub_blob = BufferBlob::create(&quot;getCPUIDBrandString_stub&quot;, cpuid_brand_string_stub_size);
269   if (cpuid_brand_string_stub_blob == NULL) {
270     vm_exit_during_initialization(&quot;Unable to allocate getCPUIDBrandString_stub&quot;);
271   }
272   CodeBuffer c(cpuid_brand_string_stub_blob);
273   VM_Version_Ext_StubGenerator g(&amp;c);
274   getCPUIDBrandString_stub = CAST_TO_FN_PTR(getCPUIDBrandString_stub_t,
275                                    g.generate_getCPUIDBrandString());
276 }
277 
278 const char* VM_Version_Ext::cpu_model_description(void) {
279   uint32_t cpu_family = extended_cpu_family();
280   uint32_t cpu_model = extended_cpu_model();
281   const char* model = NULL;
282 
283   if (cpu_family == CPU_FAMILY_PENTIUMPRO) {
284     for (uint32_t i = 0; i &lt;= cpu_model; i++) {
285       model = _model_id_pentium_pro[i];
286       if (model == NULL) {
287         break;
288       }
289     }
290   }
291   return model;
292 }
293 
294 const char* VM_Version_Ext::cpu_brand_string(void) {
295   if (_cpu_brand_string == NULL) {
296     _cpu_brand_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_EBS_MAX_LENGTH, mtInternal);
297     if (NULL == _cpu_brand_string) {
298       return NULL;
299     }
300     int ret_val = cpu_extended_brand_string(_cpu_brand_string, CPU_EBS_MAX_LENGTH);
301     if (ret_val != OS_OK) {
302       FREE_C_HEAP_ARRAY(char, _cpu_brand_string);
303       _cpu_brand_string = NULL;
304     }
305   }
306   return _cpu_brand_string;
307 }
308 
309 const char* VM_Version_Ext::cpu_brand(void) {
310   const char*  brand  = NULL;
311 
312   if ((_cpuid_info.std_cpuid1_ebx.value &amp; 0xFF) &gt; 0) {
313     int brand_num = _cpuid_info.std_cpuid1_ebx.value &amp; 0xFF;
314     brand = _brand_id[0];
315     for (int i = 0; brand != NULL &amp;&amp; i &lt;= brand_num; i += 1) {
316       brand = _brand_id[i];
317     }
318   }
319   return brand;
320 }
321 
322 bool VM_Version_Ext::cpu_is_em64t(void) {
323   return ((_cpuid_info.ext_cpuid1_edx.value &amp; INTEL64_FLAG) == INTEL64_FLAG);
324 }
325 
326 bool VM_Version_Ext::is_netburst(void) {
327   return (is_intel() &amp;&amp; (extended_cpu_family() == CPU_FAMILY_PENTIUM_4));
328 }
329 
330 bool VM_Version_Ext::supports_tscinv_ext(void) {
331   if (!supports_tscinv_bit()) {
332     return false;
333   }
334 
335   if (is_intel()) {
336     return true;
337   }
338 
339   if (is_amd()) {
340     return !is_amd_Barcelona();
341   }
342 
<a name="3" id="anc3"></a>



343   return false;
344 }
345 
346 void VM_Version_Ext::resolve_cpu_information_details(void) {
347 
348   // in future we want to base this information on proper cpu
349   // and cache topology enumeration such as:
350   // Intel 64 Architecture Processor Topology Enumeration
351   // which supports system cpu and cache topology enumeration
352   // either using 2xAPICIDs or initial APICIDs
353 
354   // currently only rough cpu information estimates
355   // which will not necessarily reflect the exact configuration of the system
356 
357   // this is the number of logical hardware threads
358   // visible to the operating system
359   _no_of_threads = os::processor_count();
360 
361   // find out number of threads per cpu package
362   int threads_per_package = threads_per_core() * cores_per_cpu();
363 
364   // use amount of threads visible to the process in order to guess number of sockets
365   _no_of_packages = _no_of_threads / threads_per_package;
366 
367   // process might only see a subset of the total number of threads
368   // from a single processor package. Virtualization/resource management for example.
369   // If so then just write a hard 1 as num of pkgs.
370   if (0 == _no_of_packages) {
371     _no_of_packages = 1;
372   }
373 
374   // estimate the number of cores
375   _no_of_cores = cores_per_cpu() * _no_of_packages;
376 }
377 
378 int VM_Version_Ext::number_of_threads(void) {
379   if (_no_of_threads == 0) {
380    resolve_cpu_information_details();
381   }
382   return _no_of_threads;
383 }
384 
385 int VM_Version_Ext::number_of_cores(void) {
386   if (_no_of_cores == 0) {
387     resolve_cpu_information_details();
388   }
389   return _no_of_cores;
390 }
391 
392 int VM_Version_Ext::number_of_sockets(void) {
393   if (_no_of_packages == 0) {
394     resolve_cpu_information_details();
395   }
396   return _no_of_packages;
397 }
398 
399 const char* VM_Version_Ext::cpu_family_description(void) {
400   int cpu_family_id = extended_cpu_family();
401   if (is_amd()) {
<a name="4" id="anc4"></a><span class="line-modified">402     return _family_id_amd[cpu_family_id];</span>


403   }
404   if (is_intel()) {
405     if (cpu_family_id == CPU_FAMILY_PENTIUMPRO) {
406       return cpu_model_description();
407     }
<a name="5" id="anc5"></a><span class="line-modified">408     return _family_id_intel[cpu_family_id];</span>





409   }
410   return &quot;Unknown x86&quot;;
411 }
412 
413 int VM_Version_Ext::cpu_type_description(char* const buf, size_t buf_len) {
414   assert(buf != NULL, &quot;buffer is NULL!&quot;);
415   assert(buf_len &gt;= CPU_TYPE_DESC_BUF_SIZE, &quot;buffer len should at least be == CPU_TYPE_DESC_BUF_SIZE!&quot;);
416 
417   const char* cpu_type = NULL;
418   const char* x64 = NULL;
419 
420   if (is_intel()) {
421     cpu_type = &quot;Intel&quot;;
422     x64 = cpu_is_em64t() ? &quot; Intel64&quot; : &quot;&quot;;
423   } else if (is_amd()) {
424     cpu_type = &quot;AMD&quot;;
425     x64 = cpu_is_em64t() ? &quot; AMD64&quot; : &quot;&quot;;
<a name="6" id="anc6"></a>


426   } else {
427     cpu_type = &quot;Unknown x86&quot;;
428     x64 = cpu_is_em64t() ? &quot; x86_64&quot; : &quot;&quot;;
429   }
430 
431   jio_snprintf(buf, buf_len, &quot;%s %s%s SSE SSE2%s%s%s%s%s%s%s%s&quot;,
432     cpu_type,
433     cpu_family_description(),
434     supports_ht() ? &quot; (HT)&quot; : &quot;&quot;,
435     supports_sse3() ? &quot; SSE3&quot; : &quot;&quot;,
436     supports_ssse3() ? &quot; SSSE3&quot; : &quot;&quot;,
437     supports_sse4_1() ? &quot; SSE4.1&quot; : &quot;&quot;,
438     supports_sse4_2() ? &quot; SSE4.2&quot; : &quot;&quot;,
439     supports_sse4a() ? &quot; SSE4A&quot; : &quot;&quot;,
440     is_netburst() ? &quot; Netburst&quot; : &quot;&quot;,
441     is_intel_family_core() ? &quot; Core&quot; : &quot;&quot;,
442     x64);
443 
444   return OS_OK;
445 }
446 
447 int VM_Version_Ext::cpu_extended_brand_string(char* const buf, size_t buf_len) {
448   assert(buf != NULL, &quot;buffer is NULL!&quot;);
449   assert(buf_len &gt;= CPU_EBS_MAX_LENGTH, &quot;buffer len should at least be == CPU_EBS_MAX_LENGTH!&quot;);
450   assert(getCPUIDBrandString_stub != NULL, &quot;not initialized&quot;);
451 
452   // invoke newly generated asm code to fetch CPU Brand String
453   getCPUIDBrandString_stub(&amp;_cpuid_info);
454 
455   // fetch results into buffer
456   *((uint32_t*) &amp;buf[0])  = _cpuid_info.proc_name_0;
457   *((uint32_t*) &amp;buf[4])  = _cpuid_info.proc_name_1;
458   *((uint32_t*) &amp;buf[8])  = _cpuid_info.proc_name_2;
459   *((uint32_t*) &amp;buf[12]) = _cpuid_info.proc_name_3;
460   *((uint32_t*) &amp;buf[16]) = _cpuid_info.proc_name_4;
461   *((uint32_t*) &amp;buf[20]) = _cpuid_info.proc_name_5;
462   *((uint32_t*) &amp;buf[24]) = _cpuid_info.proc_name_6;
463   *((uint32_t*) &amp;buf[28]) = _cpuid_info.proc_name_7;
464   *((uint32_t*) &amp;buf[32]) = _cpuid_info.proc_name_8;
465   *((uint32_t*) &amp;buf[36]) = _cpuid_info.proc_name_9;
466   *((uint32_t*) &amp;buf[40]) = _cpuid_info.proc_name_10;
467   *((uint32_t*) &amp;buf[44]) = _cpuid_info.proc_name_11;
468 
469   return OS_OK;
470 }
471 
472 size_t VM_Version_Ext::cpu_write_support_string(char* const buf, size_t buf_len) {
473   guarantee(buf != NULL, &quot;buffer is NULL!&quot;);
474   guarantee(buf_len &gt; 0, &quot;buffer len not enough!&quot;);
475 
476   unsigned int flag = 0;
477   unsigned int fi = 0;
478   size_t       written = 0;
479   const char*  prefix = &quot;&quot;;
480 
481 #define WRITE_TO_BUF(string)                                                          \
482   {                                                                                   \
483     int res = jio_snprintf(&amp;buf[written], buf_len - written, &quot;%s%s&quot;, prefix, string); \
484     if (res &lt; 0) {                                                                    \
485       return buf_len - 1;                                                             \
486     }                                                                                 \
487     written += res;                                                                   \
488     if (prefix[0] == &#39;\0&#39;) {                                                          \
489       prefix = &quot;, &quot;;                                                                  \
490     }                                                                                 \
491   }
492 
493   for (flag = 1, fi = 0; flag &lt;= 0x20000000 ; flag &lt;&lt;= 1, fi++) {
494     if (flag == HTT_FLAG &amp;&amp; (((_cpuid_info.std_cpuid1_ebx.value &gt;&gt; 16) &amp; 0xff) &lt;= 1)) {
495       continue; /* no hyperthreading */
496     } else if (flag == SEP_FLAG &amp;&amp; (cpu_family() == CPU_FAMILY_PENTIUMPRO &amp;&amp; ((_cpuid_info.std_cpuid1_eax.value &amp; 0xff) &lt; 0x33))) {
497       continue; /* no fast system call */
498     }
499     if ((_cpuid_info.std_cpuid1_edx.value &amp; flag) &amp;&amp; strlen(_feature_edx_id[fi]) &gt; 0) {
500       WRITE_TO_BUF(_feature_edx_id[fi]);
501     }
502   }
503 
504   for (flag = 1, fi = 0; flag &lt;= 0x20000000; flag &lt;&lt;= 1, fi++) {
505     if ((_cpuid_info.std_cpuid1_ecx.value &amp; flag) &amp;&amp; strlen(_feature_ecx_id[fi]) &gt; 0) {
506       WRITE_TO_BUF(_feature_ecx_id[fi]);
507     }
508   }
509 
510   for (flag = 1, fi = 0; flag &lt;= 0x20000000 ; flag &lt;&lt;= 1, fi++) {
511     if ((_cpuid_info.ext_cpuid1_ecx.value &amp; flag) &amp;&amp; strlen(_feature_extended_ecx_id[fi]) &gt; 0) {
512       WRITE_TO_BUF(_feature_extended_ecx_id[fi]);
513     }
514   }
515 
516   for (flag = 1, fi = 0; flag &lt;= 0x20000000; flag &lt;&lt;= 1, fi++) {
517     if ((_cpuid_info.ext_cpuid1_edx.value &amp; flag) &amp;&amp; strlen(_feature_extended_edx_id[fi]) &gt; 0) {
518       WRITE_TO_BUF(_feature_extended_edx_id[fi]);
519     }
520   }
521 
522   if (supports_tscinv_bit()) {
523       WRITE_TO_BUF(&quot;Invariant TSC&quot;);
524   }
525 
526   return written;
527 }
528 
529 /**
530  * Write a detailed description of the cpu to a given buffer, including
531  * feature set.
532  */
533 int VM_Version_Ext::cpu_detailed_description(char* const buf, size_t buf_len) {
534   assert(buf != NULL, &quot;buffer is NULL!&quot;);
535   assert(buf_len &gt;= CPU_DETAILED_DESC_BUF_SIZE, &quot;buffer len should at least be == CPU_DETAILED_DESC_BUF_SIZE!&quot;);
536 
537   static const char* unknown = &quot;&lt;unknown&gt;&quot;;
538   char               vendor_id[VENDOR_LENGTH];
539   const char*        family = NULL;
540   const char*        model = NULL;
541   const char*        brand = NULL;
542   int                outputLen = 0;
543 
544   family = cpu_family_description();
545   if (family == NULL) {
546     family = unknown;
547   }
548 
549   model = cpu_model_description();
550   if (model == NULL) {
551     model = unknown;
552   }
553 
554   brand = cpu_brand_string();
555 
556   if (brand == NULL) {
557     brand = cpu_brand();
558     if (brand == NULL) {
559       brand = unknown;
560     }
561   }
562 
563   *((uint32_t*) &amp;vendor_id[0]) = _cpuid_info.std_vendor_name_0;
564   *((uint32_t*) &amp;vendor_id[4]) = _cpuid_info.std_vendor_name_2;
565   *((uint32_t*) &amp;vendor_id[8]) = _cpuid_info.std_vendor_name_1;
566   vendor_id[VENDOR_LENGTH-1] = &#39;\0&#39;;
567 
568   outputLen = jio_snprintf(buf, buf_len, &quot;Brand: %s, Vendor: %s\n&quot;
569     &quot;Family: %s (0x%x), Model: %s (0x%x), Stepping: 0x%x\n&quot;
570     &quot;Ext. family: 0x%x, Ext. model: 0x%x, Type: 0x%x, Signature: 0x%8.8x\n&quot;
571     &quot;Features: ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\n&quot;
572     &quot;Ext. features: eax: 0x%8.8x, ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\n&quot;
573     &quot;Supports: &quot;,
574     brand,
575     vendor_id,
576     family,
577     extended_cpu_family(),
578     model,
579     extended_cpu_model(),
580     cpu_stepping(),
581     _cpuid_info.std_cpuid1_eax.bits.ext_family,
582     _cpuid_info.std_cpuid1_eax.bits.ext_model,
583     _cpuid_info.std_cpuid1_eax.bits.proc_type,
584     _cpuid_info.std_cpuid1_eax.value,
585     _cpuid_info.std_cpuid1_ebx.value,
586     _cpuid_info.std_cpuid1_ecx.value,
587     _cpuid_info.std_cpuid1_edx.value,
588     _cpuid_info.ext_cpuid1_eax,
589     _cpuid_info.ext_cpuid1_ebx,
590     _cpuid_info.ext_cpuid1_ecx,
591     _cpuid_info.ext_cpuid1_edx);
592 
593   if (outputLen &lt; 0 || (size_t) outputLen &gt;= buf_len - 1) {
594     if (buf_len &gt; 0) { buf[buf_len-1] = &#39;\0&#39;; }
595     return OS_ERR;
596   }
597 
598   cpu_write_support_string(&amp;buf[outputLen], buf_len - outputLen);
599 
600   return OS_OK;
601 }
602 
603 const char* VM_Version_Ext::cpu_name(void) {
604   char cpu_type_desc[CPU_TYPE_DESC_BUF_SIZE];
605   size_t cpu_desc_len = sizeof(cpu_type_desc);
606 
607   cpu_type_description(cpu_type_desc, cpu_desc_len);
608   char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, cpu_desc_len, mtTracing);
609   if (NULL == tmp) {
610     return NULL;
611   }
612   strncpy(tmp, cpu_type_desc, cpu_desc_len);
613   return tmp;
614 }
615 
616 const char* VM_Version_Ext::cpu_description(void) {
617   char cpu_detailed_desc_buffer[CPU_DETAILED_DESC_BUF_SIZE];
618   size_t cpu_detailed_desc_len = sizeof(cpu_detailed_desc_buffer);
619 
620   cpu_detailed_description(cpu_detailed_desc_buffer, cpu_detailed_desc_len);
621 
622   char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, cpu_detailed_desc_len, mtTracing);
623 
624   if (NULL == tmp) {
625     return NULL;
626   }
627 
628   strncpy(tmp, cpu_detailed_desc_buffer, cpu_detailed_desc_len);
629   return tmp;
630 }
631 
632 /**
633  *  See Intel Application note 485 (chapter 10) for details
634  *  on frequency extraction from cpu brand string.
635  *  http://www.intel.com/content/dam/www/public/us/en/documents/application-notes/processor-identification-cpuid-instruction-note.pdf
636  *
637  */
638 jlong VM_Version_Ext::max_qualified_cpu_freq_from_brand_string(void) {
639   // get brand string
640   const char* const brand_string = cpu_brand_string();
641   if (brand_string == NULL) {
642     return 0;
643   }
644 
645   const u8 MEGA = 1000000;
646   u8 multiplier = 0;
647   jlong frequency = 0;
648 
649   // the frequency information in the cpu brand string
650   // is given in either of two formats &quot;x.xxyHz&quot; or &quot;xxxxyHz&quot;,
651   // where y=M,G,T and x is digits
652   const char* Hz_location = strchr(brand_string, &#39;H&#39;);
653 
654   if (Hz_location != NULL) {
655     if (*(Hz_location + 1) == &#39;z&#39;) {
656       // switch on y in &quot;yHz&quot;
657       switch(*(Hz_location - 1)) {
658         case &#39;M&#39; :
659           // Set multiplier to frequency is in Hz
660           multiplier = MEGA;
661           break;
662         case &#39;G&#39; :
663           multiplier = MEGA * 1000;
664           break;
665         case &#39;T&#39; :
666           multiplier = MEGA * 1000 * 1000;
667           break;
668       }
669     }
670   }
671 
672   if (multiplier &gt; 0) {
673     // compute frequency (in Hz) from brand string
674     if (*(Hz_location - 4) == &#39;.&#39;) { // if format is &quot;x.xx&quot;
675       frequency =  (jlong)(*(Hz_location - 5) - &#39;0&#39;) * (multiplier);
676       frequency += (jlong)(*(Hz_location - 3) - &#39;0&#39;) * (multiplier / 10);
677       frequency += (jlong)(*(Hz_location - 2) - &#39;0&#39;) * (multiplier / 100);
678     } else { // format is &quot;xxxx&quot;
679       frequency =  (jlong)(*(Hz_location - 5) - &#39;0&#39;) * 1000;
680       frequency += (jlong)(*(Hz_location - 4) - &#39;0&#39;) * 100;
681       frequency += (jlong)(*(Hz_location - 3) - &#39;0&#39;) * 10;
682       frequency += (jlong)(*(Hz_location - 2) - &#39;0&#39;);
683       frequency *= multiplier;
684     }
685   }
686   return frequency;
687 }
688 
689 
690 jlong VM_Version_Ext::maximum_qualified_cpu_frequency(void) {
691   if (_max_qualified_cpu_frequency == 0) {
692     _max_qualified_cpu_frequency = max_qualified_cpu_freq_from_brand_string();
693   }
694   return _max_qualified_cpu_frequency;
695 }
696 
<a name="7" id="anc7"></a><span class="line-modified">697 const char* const VM_Version_Ext::_family_id_intel[] = {</span>
698   &quot;8086/8088&quot;,
699   &quot;&quot;,
700   &quot;286&quot;,
701   &quot;386&quot;,
702   &quot;486&quot;,
703   &quot;Pentium&quot;,
704   &quot;Pentium Pro&quot;,   //or Pentium-M/Woodcrest depeding on model
705   &quot;&quot;,
706   &quot;&quot;,
707   &quot;&quot;,
708   &quot;&quot;,
709   &quot;&quot;,
710   &quot;&quot;,
711   &quot;&quot;,
712   &quot;&quot;,
713   &quot;Pentium 4&quot;
714 };
715 
<a name="8" id="anc8"></a><span class="line-modified">716 const char* const VM_Version_Ext::_family_id_amd[] = {</span>
717   &quot;&quot;,
718   &quot;&quot;,
719   &quot;&quot;,
720   &quot;&quot;,
721   &quot;5x86&quot;,
722   &quot;K5/K6&quot;,
723   &quot;Athlon/AthlonXP&quot;,
724   &quot;&quot;,
725   &quot;&quot;,
726   &quot;&quot;,
727   &quot;&quot;,
728   &quot;&quot;,
729   &quot;&quot;,
730   &quot;&quot;,
731   &quot;&quot;,
732   &quot;Opteron/Athlon64&quot;,
733   &quot;Opteron QC/Phenom&quot;  // Barcelona et.al.
<a name="9" id="anc9"></a>






734 };
735 // Partially from Intel 64 and IA-32 Architecture Software Developer&#39;s Manual,
736 // September 2013, Vol 3C Table 35-1
737 const char* const VM_Version_Ext::_model_id_pentium_pro[] = {
738   &quot;&quot;,
739   &quot;Pentium Pro&quot;,
740   &quot;&quot;,
741   &quot;Pentium II model 3&quot;,
742   &quot;&quot;,
743   &quot;Pentium II model 5/Xeon/Celeron&quot;,
744   &quot;Celeron&quot;,
745   &quot;Pentium III/Pentium III Xeon&quot;,
746   &quot;Pentium III/Pentium III Xeon&quot;,
747   &quot;Pentium M model 9&quot;,    // Yonah
748   &quot;Pentium III, model A&quot;,
749   &quot;Pentium III, model B&quot;,
750   &quot;&quot;,
751   &quot;Pentium M model D&quot;,    // Dothan
752   &quot;&quot;,
753   &quot;Core 2&quot;,               // 0xf Woodcrest/Conroe/Merom/Kentsfield/Clovertown
754   &quot;&quot;,
755   &quot;&quot;,
756   &quot;&quot;,
757   &quot;&quot;,
758   &quot;&quot;,
759   &quot;&quot;,
760   &quot;Celeron&quot;,              // 0x16 Celeron 65nm
761   &quot;Core 2&quot;,               // 0x17 Penryn / Harpertown
762   &quot;&quot;,
763   &quot;&quot;,
764   &quot;Core i7&quot;,              // 0x1A CPU_MODEL_NEHALEM_EP
765   &quot;Atom&quot;,                 // 0x1B Z5xx series Silverthorn
766   &quot;&quot;,
767   &quot;Core 2&quot;,               // 0x1D Dunnington (6-core)
768   &quot;Nehalem&quot;,              // 0x1E CPU_MODEL_NEHALEM
769   &quot;&quot;,
770   &quot;&quot;,
771   &quot;&quot;,
772   &quot;&quot;,
773   &quot;&quot;,
774   &quot;&quot;,
775   &quot;Westmere&quot;,             // 0x25 CPU_MODEL_WESTMERE
776   &quot;&quot;,
777   &quot;&quot;,
778   &quot;&quot;,                     // 0x28
779   &quot;&quot;,
780   &quot;Sandy Bridge&quot;,         // 0x2a &quot;2nd Generation Intel Core i7, i5, i3&quot;
781   &quot;&quot;,
782   &quot;Westmere-EP&quot;,          // 0x2c CPU_MODEL_WESTMERE_EP
783   &quot;Sandy Bridge-EP&quot;,      // 0x2d CPU_MODEL_SANDYBRIDGE_EP
784   &quot;Nehalem-EX&quot;,           // 0x2e CPU_MODEL_NEHALEM_EX
785   &quot;Westmere-EX&quot;,          // 0x2f CPU_MODEL_WESTMERE_EX
786   &quot;&quot;,
787   &quot;&quot;,
788   &quot;&quot;,
789   &quot;&quot;,
790   &quot;&quot;,
791   &quot;&quot;,
792   &quot;&quot;,
793   &quot;&quot;,
794   &quot;&quot;,
795   &quot;&quot;,
796   &quot;Ivy Bridge&quot;,           // 0x3a
797   &quot;&quot;,
798   &quot;Haswell&quot;,              // 0x3c &quot;4th Generation Intel Core Processor&quot;
799   &quot;&quot;,                     // 0x3d &quot;Next Generation Intel Core Processor&quot;
800   &quot;Ivy Bridge-EP&quot;,        // 0x3e &quot;Next Generation Intel Xeon Processor E7 Family&quot;
801   &quot;&quot;,                     // 0x3f &quot;Future Generation Intel Xeon Processor&quot;
802   &quot;&quot;,
803   &quot;&quot;,
804   &quot;&quot;,
805   &quot;&quot;,
806   &quot;&quot;,
807   &quot;Haswell&quot;,              // 0x45 &quot;4th Generation Intel Core Processor&quot;
808   &quot;Haswell&quot;,              // 0x46 &quot;4th Generation Intel Core Processor&quot;
809   NULL
810 };
811 
812 /* Brand ID is for back compability
813  * Newer CPUs uses the extended brand string */
814 const char* const VM_Version_Ext::_brand_id[] = {
815   &quot;&quot;,
816   &quot;Celeron processor&quot;,
817   &quot;Pentium III processor&quot;,
818   &quot;Intel Pentium III Xeon processor&quot;,
819   &quot;&quot;,
820   &quot;&quot;,
821   &quot;&quot;,
822   &quot;&quot;,
823   &quot;Intel Pentium 4 processor&quot;,
824   NULL
825 };
826 
827 
828 const char* const VM_Version_Ext::_feature_edx_id[] = {
829   &quot;On-Chip FPU&quot;,
830   &quot;Virtual Mode Extensions&quot;,
831   &quot;Debugging Extensions&quot;,
832   &quot;Page Size Extensions&quot;,
833   &quot;Time Stamp Counter&quot;,
834   &quot;Model Specific Registers&quot;,
835   &quot;Physical Address Extension&quot;,
836   &quot;Machine Check Exceptions&quot;,
837   &quot;CMPXCHG8B Instruction&quot;,
838   &quot;On-Chip APIC&quot;,
839   &quot;&quot;,
840   &quot;Fast System Call&quot;,
841   &quot;Memory Type Range Registers&quot;,
842   &quot;Page Global Enable&quot;,
843   &quot;Machine Check Architecture&quot;,
844   &quot;Conditional Mov Instruction&quot;,
845   &quot;Page Attribute Table&quot;,
846   &quot;36-bit Page Size Extension&quot;,
847   &quot;Processor Serial Number&quot;,
848   &quot;CLFLUSH Instruction&quot;,
849   &quot;&quot;,
850   &quot;Debug Trace Store feature&quot;,
851   &quot;ACPI registers in MSR space&quot;,
852   &quot;Intel Architecture MMX Technology&quot;,
853   &quot;Fast Float Point Save and Restore&quot;,
854   &quot;Streaming SIMD extensions&quot;,
855   &quot;Streaming SIMD extensions 2&quot;,
856   &quot;Self-Snoop&quot;,
857   &quot;Hyper Threading&quot;,
858   &quot;Thermal Monitor&quot;,
859   &quot;&quot;,
860   &quot;Pending Break Enable&quot;
861 };
862 
863 const char* const VM_Version_Ext::_feature_extended_edx_id[] = {
864   &quot;&quot;,
865   &quot;&quot;,
866   &quot;&quot;,
867   &quot;&quot;,
868   &quot;&quot;,
869   &quot;&quot;,
870   &quot;&quot;,
871   &quot;&quot;,
872   &quot;&quot;,
873   &quot;&quot;,
874   &quot;&quot;,
875   &quot;SYSCALL/SYSRET&quot;,
876   &quot;&quot;,
877   &quot;&quot;,
878   &quot;&quot;,
879   &quot;&quot;,
880   &quot;&quot;,
881   &quot;&quot;,
882   &quot;&quot;,
883   &quot;&quot;,
884   &quot;Execute Disable Bit&quot;,
885   &quot;&quot;,
886   &quot;&quot;,
887   &quot;&quot;,
888   &quot;&quot;,
889   &quot;&quot;,
890   &quot;&quot;,
891   &quot;RDTSCP&quot;,
892   &quot;&quot;,
893   &quot;Intel 64 Architecture&quot;,
894   &quot;&quot;,
895   &quot;&quot;
896 };
897 
898 const char* const VM_Version_Ext::_feature_ecx_id[] = {
899   &quot;Streaming SIMD Extensions 3&quot;,
900   &quot;PCLMULQDQ&quot;,
901   &quot;64-bit DS Area&quot;,
902   &quot;MONITOR/MWAIT instructions&quot;,
903   &quot;CPL Qualified Debug Store&quot;,
904   &quot;Virtual Machine Extensions&quot;,
905   &quot;Safer Mode Extensions&quot;,
906   &quot;Enhanced Intel SpeedStep technology&quot;,
907   &quot;Thermal Monitor 2&quot;,
908   &quot;Supplemental Streaming SIMD Extensions 3&quot;,
909   &quot;L1 Context ID&quot;,
910   &quot;&quot;,
911   &quot;Fused Multiply-Add&quot;,
912   &quot;CMPXCHG16B&quot;,
913   &quot;xTPR Update Control&quot;,
914   &quot;Perfmon and Debug Capability&quot;,
915   &quot;&quot;,
916   &quot;Process-context identifiers&quot;,
917   &quot;Direct Cache Access&quot;,
918   &quot;Streaming SIMD extensions 4.1&quot;,
919   &quot;Streaming SIMD extensions 4.2&quot;,
920   &quot;x2APIC&quot;,
921   &quot;MOVBE&quot;,
922   &quot;Popcount instruction&quot;,
923   &quot;TSC-Deadline&quot;,
924   &quot;AESNI&quot;,
925   &quot;XSAVE&quot;,
926   &quot;OSXSAVE&quot;,
927   &quot;AVX&quot;,
928   &quot;F16C&quot;,
929   &quot;RDRAND&quot;,
930   &quot;&quot;
931 };
932 
933 const char* const VM_Version_Ext::_feature_extended_ecx_id[] = {
934   &quot;LAHF/SAHF instruction support&quot;,
935   &quot;Core multi-processor leagacy mode&quot;,
936   &quot;&quot;,
937   &quot;&quot;,
938   &quot;&quot;,
939   &quot;Advanced Bit Manipulations: LZCNT&quot;,
940   &quot;SSE4A: MOVNTSS, MOVNTSD, EXTRQ, INSERTQ&quot;,
941   &quot;Misaligned SSE mode&quot;,
942   &quot;&quot;,
943   &quot;&quot;,
944   &quot;&quot;,
945   &quot;&quot;,
946   &quot;&quot;,
947   &quot;&quot;,
948   &quot;&quot;,
949   &quot;&quot;,
950   &quot;&quot;,
951   &quot;&quot;,
952   &quot;&quot;,
953   &quot;&quot;,
954   &quot;&quot;,
955   &quot;&quot;,
956   &quot;&quot;,
957   &quot;&quot;,
958   &quot;&quot;,
959   &quot;&quot;,
960   &quot;&quot;,
961   &quot;&quot;,
962   &quot;&quot;,
963   &quot;&quot;,
964   &quot;&quot;,
965   &quot;&quot;
966 };
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
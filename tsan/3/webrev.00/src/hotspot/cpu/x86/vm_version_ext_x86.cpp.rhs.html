<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/vm_version_ext_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;utilities/macros.hpp&quot;
 28 #include &quot;asm/macroAssembler.hpp&quot;
 29 #include &quot;asm/macroAssembler.inline.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 34 #include &quot;vm_version_ext_x86.hpp&quot;
 35 
 36 typedef enum {
 37    CPU_FAMILY_8086_8088  = 0,
 38    CPU_FAMILY_INTEL_286  = 2,
 39    CPU_FAMILY_INTEL_386  = 3,
 40    CPU_FAMILY_INTEL_486  = 4,
 41    CPU_FAMILY_PENTIUM    = 5,
 42    CPU_FAMILY_PENTIUMPRO = 6,    // Same family several models
 43    CPU_FAMILY_PENTIUM_4  = 0xF
 44 } FamilyFlag;
 45 
<a name="2" id="anc2"></a><span class="line-modified"> 46 typedef enum {</span>
<span class="line-modified"> 47   RDTSCP_FLAG  = 0x08000000, // bit 27</span>
<span class="line-modified"> 48   INTEL64_FLAG = 0x20000000  // bit 29</span>
<span class="line-modified"> 49 } _featureExtendedEdxFlag;</span>
 50 
 51 #define CPUID_STANDARD_FN   0x0
 52 #define CPUID_STANDARD_FN_1 0x1
 53 #define CPUID_STANDARD_FN_4 0x4
 54 #define CPUID_STANDARD_FN_B 0xb
 55 
 56 #define CPUID_EXTENDED_FN   0x80000000
 57 #define CPUID_EXTENDED_FN_1 0x80000001
 58 #define CPUID_EXTENDED_FN_2 0x80000002
 59 #define CPUID_EXTENDED_FN_3 0x80000003
 60 #define CPUID_EXTENDED_FN_4 0x80000004
 61 #define CPUID_EXTENDED_FN_7 0x80000007
 62 #define CPUID_EXTENDED_FN_8 0x80000008
 63 
 64 typedef enum {
 65    FPU_FLAG     = 0x00000001,
 66    VME_FLAG     = 0x00000002,
 67    DE_FLAG      = 0x00000004,
 68    PSE_FLAG     = 0x00000008,
 69    TSC_FLAG     = 0x00000010,
 70    MSR_FLAG     = 0x00000020,
 71    PAE_FLAG     = 0x00000040,
 72    MCE_FLAG     = 0x00000080,
 73    CX8_FLAG     = 0x00000100,
 74    APIC_FLAG    = 0x00000200,
 75    SEP_FLAG     = 0x00000800,
 76    MTRR_FLAG    = 0x00001000,
 77    PGE_FLAG     = 0x00002000,
 78    MCA_FLAG     = 0x00004000,
 79    CMOV_FLAG    = 0x00008000,
 80    PAT_FLAG     = 0x00010000,
 81    PSE36_FLAG   = 0x00020000,
 82    PSNUM_FLAG   = 0x00040000,
 83    CLFLUSH_FLAG = 0x00080000,
 84    DTS_FLAG     = 0x00200000,
 85    ACPI_FLAG    = 0x00400000,
 86    MMX_FLAG     = 0x00800000,
 87    FXSR_FLAG    = 0x01000000,
 88    SSE_FLAG     = 0x02000000,
 89    SSE2_FLAG    = 0x04000000,
 90    SS_FLAG      = 0x08000000,
 91    HTT_FLAG     = 0x10000000,
 92    TM_FLAG      = 0x20000000
 93 } FeatureEdxFlag;
 94 
 95 static BufferBlob* cpuid_brand_string_stub_blob;
 96 static const int   cpuid_brand_string_stub_size = 550;
 97 
 98 extern &quot;C&quot; {
 99   typedef void (*getCPUIDBrandString_stub_t)(void*);
100 }
101 
102 static getCPUIDBrandString_stub_t getCPUIDBrandString_stub = NULL;
103 
104 class VM_Version_Ext_StubGenerator: public StubCodeGenerator {
105  public:
106 
107   VM_Version_Ext_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}
108 
109   address generate_getCPUIDBrandString(void) {
110     // Flags to test CPU type.
111     const uint32_t HS_EFL_AC           = 0x40000;
112     const uint32_t HS_EFL_ID           = 0x200000;
113     // Values for when we don&#39;t have a CPUID instruction.
114     const int      CPU_FAMILY_SHIFT = 8;
115     const uint32_t CPU_FAMILY_386   = (3 &lt;&lt; CPU_FAMILY_SHIFT);
116     const uint32_t CPU_FAMILY_486   = (4 &lt;&lt; CPU_FAMILY_SHIFT);
117 
118     Label detect_486, cpu486, detect_586, done, ext_cpuid;
119 
120     StubCodeMark mark(this, &quot;VM_Version_Ext&quot;, &quot;getCPUIDNameInfo_stub&quot;);
121 #   define __ _masm-&gt;
122 
123     address start = __ pc();
124 
125     //
126     // void getCPUIDBrandString(VM_Version::CpuidInfo* cpuid_info);
127     //
128     // LP64: rcx and rdx are first and second argument registers on windows
129 
130     __ push(rbp);
131 #ifdef _LP64
132     __ mov(rbp, c_rarg0); // cpuid_info address
133 #else
134     __ movptr(rbp, Address(rsp, 8)); // cpuid_info address
135 #endif
136     __ push(rbx);
137     __ push(rsi);
138     __ pushf();          // preserve rbx, and flags
139     __ pop(rax);
140     __ push(rax);
141     __ mov(rcx, rax);
142     //
143     // if we are unable to change the AC flag, we have a 386
144     //
145     __ xorl(rax, HS_EFL_AC);
146     __ push(rax);
147     __ popf();
148     __ pushf();
149     __ pop(rax);
150     __ cmpptr(rax, rcx);
151     __ jccb(Assembler::notEqual, detect_486);
152 
153     __ movl(rax, CPU_FAMILY_386);
154     __ jmp(done);
155 
156     //
157     // If we are unable to change the ID flag, we have a 486 which does
158     // not support the &quot;cpuid&quot; instruction.
159     //
160     __ bind(detect_486);
161     __ mov(rax, rcx);
162     __ xorl(rax, HS_EFL_ID);
163     __ push(rax);
164     __ popf();
165     __ pushf();
166     __ pop(rax);
167     __ cmpptr(rcx, rax);
168     __ jccb(Assembler::notEqual, detect_586);
169 
170     __ bind(cpu486);
171     __ movl(rax, CPU_FAMILY_486);
172     __ jmp(done);
173 
174     //
175     // At this point, we have a chip which supports the &quot;cpuid&quot; instruction
176     //
177     __ bind(detect_586);
178     __ xorl(rax, rax);
179     __ cpuid();
180     __ orl(rax, rax);
181     __ jcc(Assembler::equal, cpu486);   // if cpuid doesn&#39;t support an input
182                                         // value of at least 1, we give up and
183                                         // assume a 486
184 
185     //
186     // Extended cpuid(0x80000000) for processor brand string detection
187     //
188     __ bind(ext_cpuid);
189     __ movl(rax, CPUID_EXTENDED_FN);
190     __ cpuid();
191     __ cmpl(rax, CPUID_EXTENDED_FN_4);
192     __ jcc(Assembler::below, done);
193 
194     //
195     // Extended cpuid(0x80000002)  // first 16 bytes in brand string
196     //
197     __ movl(rax, CPUID_EXTENDED_FN_2);
198     __ cpuid();
199     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_0_offset())));
200     __ movl(Address(rsi, 0), rax);
201     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_1_offset())));
202     __ movl(Address(rsi, 0), rbx);
203     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_2_offset())));
204     __ movl(Address(rsi, 0), rcx);
205     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_3_offset())));
206     __ movl(Address(rsi,0), rdx);
207 
208     //
209     // Extended cpuid(0x80000003) // next 16 bytes in brand string
210     //
211     __ movl(rax, CPUID_EXTENDED_FN_3);
212     __ cpuid();
213     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_4_offset())));
214     __ movl(Address(rsi, 0), rax);
215     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_5_offset())));
216     __ movl(Address(rsi, 0), rbx);
217     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_6_offset())));
218     __ movl(Address(rsi, 0), rcx);
219     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_7_offset())));
220     __ movl(Address(rsi,0), rdx);
221 
222     //
223     // Extended cpuid(0x80000004) // last 16 bytes in brand string
224     //
225     __ movl(rax, CPUID_EXTENDED_FN_4);
226     __ cpuid();
227     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_8_offset())));
228     __ movl(Address(rsi, 0), rax);
229     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_9_offset())));
230     __ movl(Address(rsi, 0), rbx);
231     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_10_offset())));
232     __ movl(Address(rsi, 0), rcx);
233     __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_11_offset())));
234     __ movl(Address(rsi,0), rdx);
235 
236     //
237     // return
238     //
239     __ bind(done);
240     __ popf();
241     __ pop(rsi);
242     __ pop(rbx);
243     __ pop(rbp);
244     __ ret(0);
245 
246 #   undef __
247 
248     return start;
249   };
250 };
251 
252 
253 // VM_Version_Ext statics
254 const size_t VM_Version_Ext::VENDOR_LENGTH = 13;
255 const size_t VM_Version_Ext::CPU_EBS_MAX_LENGTH = (3 * 4 * 4 + 1);
256 const size_t VM_Version_Ext::CPU_TYPE_DESC_BUF_SIZE = 256;
257 const size_t VM_Version_Ext::CPU_DETAILED_DESC_BUF_SIZE = 4096;
258 char* VM_Version_Ext::_cpu_brand_string = NULL;
259 jlong VM_Version_Ext::_max_qualified_cpu_frequency = 0;
260 
261 int VM_Version_Ext::_no_of_threads = 0;
262 int VM_Version_Ext::_no_of_cores = 0;
263 int VM_Version_Ext::_no_of_packages = 0;
264 
265 void VM_Version_Ext::initialize(void) {
266   ResourceMark rm;
267 
268   cpuid_brand_string_stub_blob = BufferBlob::create(&quot;getCPUIDBrandString_stub&quot;, cpuid_brand_string_stub_size);
269   if (cpuid_brand_string_stub_blob == NULL) {
270     vm_exit_during_initialization(&quot;Unable to allocate getCPUIDBrandString_stub&quot;);
271   }
272   CodeBuffer c(cpuid_brand_string_stub_blob);
273   VM_Version_Ext_StubGenerator g(&amp;c);
274   getCPUIDBrandString_stub = CAST_TO_FN_PTR(getCPUIDBrandString_stub_t,
275                                    g.generate_getCPUIDBrandString());
276 }
277 
278 const char* VM_Version_Ext::cpu_model_description(void) {
279   uint32_t cpu_family = extended_cpu_family();
280   uint32_t cpu_model = extended_cpu_model();
281   const char* model = NULL;
282 
283   if (cpu_family == CPU_FAMILY_PENTIUMPRO) {
284     for (uint32_t i = 0; i &lt;= cpu_model; i++) {
285       model = _model_id_pentium_pro[i];
286       if (model == NULL) {
287         break;
288       }
289     }
290   }
291   return model;
292 }
293 
294 const char* VM_Version_Ext::cpu_brand_string(void) {
295   if (_cpu_brand_string == NULL) {
296     _cpu_brand_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_EBS_MAX_LENGTH, mtInternal);
297     if (NULL == _cpu_brand_string) {
298       return NULL;
299     }
300     int ret_val = cpu_extended_brand_string(_cpu_brand_string, CPU_EBS_MAX_LENGTH);
301     if (ret_val != OS_OK) {
302       FREE_C_HEAP_ARRAY(char, _cpu_brand_string);
303       _cpu_brand_string = NULL;
304     }
305   }
306   return _cpu_brand_string;
307 }
308 
309 const char* VM_Version_Ext::cpu_brand(void) {
310   const char*  brand  = NULL;
311 
312   if ((_cpuid_info.std_cpuid1_ebx.value &amp; 0xFF) &gt; 0) {
313     int brand_num = _cpuid_info.std_cpuid1_ebx.value &amp; 0xFF;
314     brand = _brand_id[0];
315     for (int i = 0; brand != NULL &amp;&amp; i &lt;= brand_num; i += 1) {
316       brand = _brand_id[i];
317     }
318   }
319   return brand;
320 }
321 
322 bool VM_Version_Ext::cpu_is_em64t(void) {
323   return ((_cpuid_info.ext_cpuid1_edx.value &amp; INTEL64_FLAG) == INTEL64_FLAG);
324 }
325 
326 bool VM_Version_Ext::is_netburst(void) {
327   return (is_intel() &amp;&amp; (extended_cpu_family() == CPU_FAMILY_PENTIUM_4));
328 }
329 
330 bool VM_Version_Ext::supports_tscinv_ext(void) {
331   if (!supports_tscinv_bit()) {
332     return false;
333   }
334 
335   if (is_intel()) {
336     return true;
337   }
338 
339   if (is_amd()) {
340     return !is_amd_Barcelona();
341   }
342 
<a name="3" id="anc3"></a><span class="line-added">343   if (is_hygon()) {</span>
<span class="line-added">344     return true;</span>
<span class="line-added">345   }</span>
<span class="line-added">346 </span>
347   return false;
348 }
349 
350 void VM_Version_Ext::resolve_cpu_information_details(void) {
351 
352   // in future we want to base this information on proper cpu
353   // and cache topology enumeration such as:
354   // Intel 64 Architecture Processor Topology Enumeration
355   // which supports system cpu and cache topology enumeration
356   // either using 2xAPICIDs or initial APICIDs
357 
358   // currently only rough cpu information estimates
359   // which will not necessarily reflect the exact configuration of the system
360 
361   // this is the number of logical hardware threads
362   // visible to the operating system
363   _no_of_threads = os::processor_count();
364 
365   // find out number of threads per cpu package
366   int threads_per_package = threads_per_core() * cores_per_cpu();
367 
368   // use amount of threads visible to the process in order to guess number of sockets
369   _no_of_packages = _no_of_threads / threads_per_package;
370 
371   // process might only see a subset of the total number of threads
372   // from a single processor package. Virtualization/resource management for example.
373   // If so then just write a hard 1 as num of pkgs.
374   if (0 == _no_of_packages) {
375     _no_of_packages = 1;
376   }
377 
378   // estimate the number of cores
379   _no_of_cores = cores_per_cpu() * _no_of_packages;
380 }
381 
382 int VM_Version_Ext::number_of_threads(void) {
383   if (_no_of_threads == 0) {
384    resolve_cpu_information_details();
385   }
386   return _no_of_threads;
387 }
388 
389 int VM_Version_Ext::number_of_cores(void) {
390   if (_no_of_cores == 0) {
391     resolve_cpu_information_details();
392   }
393   return _no_of_cores;
394 }
395 
396 int VM_Version_Ext::number_of_sockets(void) {
397   if (_no_of_packages == 0) {
398     resolve_cpu_information_details();
399   }
400   return _no_of_packages;
401 }
402 
403 const char* VM_Version_Ext::cpu_family_description(void) {
404   int cpu_family_id = extended_cpu_family();
405   if (is_amd()) {
<a name="4" id="anc4"></a><span class="line-modified">406     if (cpu_family_id &lt; ExtendedFamilyIdLength_AMD) {</span>
<span class="line-added">407       return _family_id_amd[cpu_family_id];</span>
<span class="line-added">408     }</span>
409   }
410   if (is_intel()) {
411     if (cpu_family_id == CPU_FAMILY_PENTIUMPRO) {
412       return cpu_model_description();
413     }
<a name="5" id="anc5"></a><span class="line-modified">414     if (cpu_family_id &lt; ExtendedFamilyIdLength_INTEL) {</span>
<span class="line-added">415       return _family_id_intel[cpu_family_id];</span>
<span class="line-added">416     }</span>
<span class="line-added">417   }</span>
<span class="line-added">418   if (is_hygon()) {</span>
<span class="line-added">419     return &quot;Dhyana&quot;;</span>
420   }
421   return &quot;Unknown x86&quot;;
422 }
423 
424 int VM_Version_Ext::cpu_type_description(char* const buf, size_t buf_len) {
425   assert(buf != NULL, &quot;buffer is NULL!&quot;);
426   assert(buf_len &gt;= CPU_TYPE_DESC_BUF_SIZE, &quot;buffer len should at least be == CPU_TYPE_DESC_BUF_SIZE!&quot;);
427 
428   const char* cpu_type = NULL;
429   const char* x64 = NULL;
430 
431   if (is_intel()) {
432     cpu_type = &quot;Intel&quot;;
433     x64 = cpu_is_em64t() ? &quot; Intel64&quot; : &quot;&quot;;
434   } else if (is_amd()) {
435     cpu_type = &quot;AMD&quot;;
436     x64 = cpu_is_em64t() ? &quot; AMD64&quot; : &quot;&quot;;
<a name="6" id="anc6"></a><span class="line-added">437   } else if (is_hygon()) {</span>
<span class="line-added">438     cpu_type = &quot;Hygon&quot;;</span>
<span class="line-added">439     x64 = cpu_is_em64t() ? &quot; AMD64&quot; : &quot;&quot;;</span>
440   } else {
441     cpu_type = &quot;Unknown x86&quot;;
442     x64 = cpu_is_em64t() ? &quot; x86_64&quot; : &quot;&quot;;
443   }
444 
445   jio_snprintf(buf, buf_len, &quot;%s %s%s SSE SSE2%s%s%s%s%s%s%s%s&quot;,
446     cpu_type,
447     cpu_family_description(),
448     supports_ht() ? &quot; (HT)&quot; : &quot;&quot;,
449     supports_sse3() ? &quot; SSE3&quot; : &quot;&quot;,
450     supports_ssse3() ? &quot; SSSE3&quot; : &quot;&quot;,
451     supports_sse4_1() ? &quot; SSE4.1&quot; : &quot;&quot;,
452     supports_sse4_2() ? &quot; SSE4.2&quot; : &quot;&quot;,
453     supports_sse4a() ? &quot; SSE4A&quot; : &quot;&quot;,
454     is_netburst() ? &quot; Netburst&quot; : &quot;&quot;,
455     is_intel_family_core() ? &quot; Core&quot; : &quot;&quot;,
456     x64);
457 
458   return OS_OK;
459 }
460 
461 int VM_Version_Ext::cpu_extended_brand_string(char* const buf, size_t buf_len) {
462   assert(buf != NULL, &quot;buffer is NULL!&quot;);
463   assert(buf_len &gt;= CPU_EBS_MAX_LENGTH, &quot;buffer len should at least be == CPU_EBS_MAX_LENGTH!&quot;);
464   assert(getCPUIDBrandString_stub != NULL, &quot;not initialized&quot;);
465 
466   // invoke newly generated asm code to fetch CPU Brand String
467   getCPUIDBrandString_stub(&amp;_cpuid_info);
468 
469   // fetch results into buffer
470   *((uint32_t*) &amp;buf[0])  = _cpuid_info.proc_name_0;
471   *((uint32_t*) &amp;buf[4])  = _cpuid_info.proc_name_1;
472   *((uint32_t*) &amp;buf[8])  = _cpuid_info.proc_name_2;
473   *((uint32_t*) &amp;buf[12]) = _cpuid_info.proc_name_3;
474   *((uint32_t*) &amp;buf[16]) = _cpuid_info.proc_name_4;
475   *((uint32_t*) &amp;buf[20]) = _cpuid_info.proc_name_5;
476   *((uint32_t*) &amp;buf[24]) = _cpuid_info.proc_name_6;
477   *((uint32_t*) &amp;buf[28]) = _cpuid_info.proc_name_7;
478   *((uint32_t*) &amp;buf[32]) = _cpuid_info.proc_name_8;
479   *((uint32_t*) &amp;buf[36]) = _cpuid_info.proc_name_9;
480   *((uint32_t*) &amp;buf[40]) = _cpuid_info.proc_name_10;
481   *((uint32_t*) &amp;buf[44]) = _cpuid_info.proc_name_11;
482 
483   return OS_OK;
484 }
485 
486 size_t VM_Version_Ext::cpu_write_support_string(char* const buf, size_t buf_len) {
487   guarantee(buf != NULL, &quot;buffer is NULL!&quot;);
488   guarantee(buf_len &gt; 0, &quot;buffer len not enough!&quot;);
489 
490   unsigned int flag = 0;
491   unsigned int fi = 0;
492   size_t       written = 0;
493   const char*  prefix = &quot;&quot;;
494 
495 #define WRITE_TO_BUF(string)                                                          \
496   {                                                                                   \
497     int res = jio_snprintf(&amp;buf[written], buf_len - written, &quot;%s%s&quot;, prefix, string); \
498     if (res &lt; 0) {                                                                    \
499       return buf_len - 1;                                                             \
500     }                                                                                 \
501     written += res;                                                                   \
502     if (prefix[0] == &#39;\0&#39;) {                                                          \
503       prefix = &quot;, &quot;;                                                                  \
504     }                                                                                 \
505   }
506 
507   for (flag = 1, fi = 0; flag &lt;= 0x20000000 ; flag &lt;&lt;= 1, fi++) {
508     if (flag == HTT_FLAG &amp;&amp; (((_cpuid_info.std_cpuid1_ebx.value &gt;&gt; 16) &amp; 0xff) &lt;= 1)) {
509       continue; /* no hyperthreading */
510     } else if (flag == SEP_FLAG &amp;&amp; (cpu_family() == CPU_FAMILY_PENTIUMPRO &amp;&amp; ((_cpuid_info.std_cpuid1_eax.value &amp; 0xff) &lt; 0x33))) {
511       continue; /* no fast system call */
512     }
513     if ((_cpuid_info.std_cpuid1_edx.value &amp; flag) &amp;&amp; strlen(_feature_edx_id[fi]) &gt; 0) {
514       WRITE_TO_BUF(_feature_edx_id[fi]);
515     }
516   }
517 
518   for (flag = 1, fi = 0; flag &lt;= 0x20000000; flag &lt;&lt;= 1, fi++) {
519     if ((_cpuid_info.std_cpuid1_ecx.value &amp; flag) &amp;&amp; strlen(_feature_ecx_id[fi]) &gt; 0) {
520       WRITE_TO_BUF(_feature_ecx_id[fi]);
521     }
522   }
523 
524   for (flag = 1, fi = 0; flag &lt;= 0x20000000 ; flag &lt;&lt;= 1, fi++) {
525     if ((_cpuid_info.ext_cpuid1_ecx.value &amp; flag) &amp;&amp; strlen(_feature_extended_ecx_id[fi]) &gt; 0) {
526       WRITE_TO_BUF(_feature_extended_ecx_id[fi]);
527     }
528   }
529 
530   for (flag = 1, fi = 0; flag &lt;= 0x20000000; flag &lt;&lt;= 1, fi++) {
531     if ((_cpuid_info.ext_cpuid1_edx.value &amp; flag) &amp;&amp; strlen(_feature_extended_edx_id[fi]) &gt; 0) {
532       WRITE_TO_BUF(_feature_extended_edx_id[fi]);
533     }
534   }
535 
536   if (supports_tscinv_bit()) {
537       WRITE_TO_BUF(&quot;Invariant TSC&quot;);
538   }
539 
540   return written;
541 }
542 
543 /**
544  * Write a detailed description of the cpu to a given buffer, including
545  * feature set.
546  */
547 int VM_Version_Ext::cpu_detailed_description(char* const buf, size_t buf_len) {
548   assert(buf != NULL, &quot;buffer is NULL!&quot;);
549   assert(buf_len &gt;= CPU_DETAILED_DESC_BUF_SIZE, &quot;buffer len should at least be == CPU_DETAILED_DESC_BUF_SIZE!&quot;);
550 
551   static const char* unknown = &quot;&lt;unknown&gt;&quot;;
552   char               vendor_id[VENDOR_LENGTH];
553   const char*        family = NULL;
554   const char*        model = NULL;
555   const char*        brand = NULL;
556   int                outputLen = 0;
557 
558   family = cpu_family_description();
559   if (family == NULL) {
560     family = unknown;
561   }
562 
563   model = cpu_model_description();
564   if (model == NULL) {
565     model = unknown;
566   }
567 
568   brand = cpu_brand_string();
569 
570   if (brand == NULL) {
571     brand = cpu_brand();
572     if (brand == NULL) {
573       brand = unknown;
574     }
575   }
576 
577   *((uint32_t*) &amp;vendor_id[0]) = _cpuid_info.std_vendor_name_0;
578   *((uint32_t*) &amp;vendor_id[4]) = _cpuid_info.std_vendor_name_2;
579   *((uint32_t*) &amp;vendor_id[8]) = _cpuid_info.std_vendor_name_1;
580   vendor_id[VENDOR_LENGTH-1] = &#39;\0&#39;;
581 
582   outputLen = jio_snprintf(buf, buf_len, &quot;Brand: %s, Vendor: %s\n&quot;
583     &quot;Family: %s (0x%x), Model: %s (0x%x), Stepping: 0x%x\n&quot;
584     &quot;Ext. family: 0x%x, Ext. model: 0x%x, Type: 0x%x, Signature: 0x%8.8x\n&quot;
585     &quot;Features: ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\n&quot;
586     &quot;Ext. features: eax: 0x%8.8x, ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\n&quot;
587     &quot;Supports: &quot;,
588     brand,
589     vendor_id,
590     family,
591     extended_cpu_family(),
592     model,
593     extended_cpu_model(),
594     cpu_stepping(),
595     _cpuid_info.std_cpuid1_eax.bits.ext_family,
596     _cpuid_info.std_cpuid1_eax.bits.ext_model,
597     _cpuid_info.std_cpuid1_eax.bits.proc_type,
598     _cpuid_info.std_cpuid1_eax.value,
599     _cpuid_info.std_cpuid1_ebx.value,
600     _cpuid_info.std_cpuid1_ecx.value,
601     _cpuid_info.std_cpuid1_edx.value,
602     _cpuid_info.ext_cpuid1_eax,
603     _cpuid_info.ext_cpuid1_ebx,
604     _cpuid_info.ext_cpuid1_ecx,
605     _cpuid_info.ext_cpuid1_edx);
606 
607   if (outputLen &lt; 0 || (size_t) outputLen &gt;= buf_len - 1) {
608     if (buf_len &gt; 0) { buf[buf_len-1] = &#39;\0&#39;; }
609     return OS_ERR;
610   }
611 
612   cpu_write_support_string(&amp;buf[outputLen], buf_len - outputLen);
613 
614   return OS_OK;
615 }
616 
617 const char* VM_Version_Ext::cpu_name(void) {
618   char cpu_type_desc[CPU_TYPE_DESC_BUF_SIZE];
619   size_t cpu_desc_len = sizeof(cpu_type_desc);
620 
621   cpu_type_description(cpu_type_desc, cpu_desc_len);
622   char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, cpu_desc_len, mtTracing);
623   if (NULL == tmp) {
624     return NULL;
625   }
626   strncpy(tmp, cpu_type_desc, cpu_desc_len);
627   return tmp;
628 }
629 
630 const char* VM_Version_Ext::cpu_description(void) {
631   char cpu_detailed_desc_buffer[CPU_DETAILED_DESC_BUF_SIZE];
632   size_t cpu_detailed_desc_len = sizeof(cpu_detailed_desc_buffer);
633 
634   cpu_detailed_description(cpu_detailed_desc_buffer, cpu_detailed_desc_len);
635 
636   char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, cpu_detailed_desc_len, mtTracing);
637 
638   if (NULL == tmp) {
639     return NULL;
640   }
641 
642   strncpy(tmp, cpu_detailed_desc_buffer, cpu_detailed_desc_len);
643   return tmp;
644 }
645 
646 /**
647  *  See Intel Application note 485 (chapter 10) for details
648  *  on frequency extraction from cpu brand string.
649  *  http://www.intel.com/content/dam/www/public/us/en/documents/application-notes/processor-identification-cpuid-instruction-note.pdf
650  *
651  */
652 jlong VM_Version_Ext::max_qualified_cpu_freq_from_brand_string(void) {
653   // get brand string
654   const char* const brand_string = cpu_brand_string();
655   if (brand_string == NULL) {
656     return 0;
657   }
658 
659   const u8 MEGA = 1000000;
660   u8 multiplier = 0;
661   jlong frequency = 0;
662 
663   // the frequency information in the cpu brand string
664   // is given in either of two formats &quot;x.xxyHz&quot; or &quot;xxxxyHz&quot;,
665   // where y=M,G,T and x is digits
666   const char* Hz_location = strchr(brand_string, &#39;H&#39;);
667 
668   if (Hz_location != NULL) {
669     if (*(Hz_location + 1) == &#39;z&#39;) {
670       // switch on y in &quot;yHz&quot;
671       switch(*(Hz_location - 1)) {
672         case &#39;M&#39; :
673           // Set multiplier to frequency is in Hz
674           multiplier = MEGA;
675           break;
676         case &#39;G&#39; :
677           multiplier = MEGA * 1000;
678           break;
679         case &#39;T&#39; :
680           multiplier = MEGA * 1000 * 1000;
681           break;
682       }
683     }
684   }
685 
686   if (multiplier &gt; 0) {
687     // compute frequency (in Hz) from brand string
688     if (*(Hz_location - 4) == &#39;.&#39;) { // if format is &quot;x.xx&quot;
689       frequency =  (jlong)(*(Hz_location - 5) - &#39;0&#39;) * (multiplier);
690       frequency += (jlong)(*(Hz_location - 3) - &#39;0&#39;) * (multiplier / 10);
691       frequency += (jlong)(*(Hz_location - 2) - &#39;0&#39;) * (multiplier / 100);
692     } else { // format is &quot;xxxx&quot;
693       frequency =  (jlong)(*(Hz_location - 5) - &#39;0&#39;) * 1000;
694       frequency += (jlong)(*(Hz_location - 4) - &#39;0&#39;) * 100;
695       frequency += (jlong)(*(Hz_location - 3) - &#39;0&#39;) * 10;
696       frequency += (jlong)(*(Hz_location - 2) - &#39;0&#39;);
697       frequency *= multiplier;
698     }
699   }
700   return frequency;
701 }
702 
703 
704 jlong VM_Version_Ext::maximum_qualified_cpu_frequency(void) {
705   if (_max_qualified_cpu_frequency == 0) {
706     _max_qualified_cpu_frequency = max_qualified_cpu_freq_from_brand_string();
707   }
708   return _max_qualified_cpu_frequency;
709 }
710 
<a name="7" id="anc7"></a><span class="line-modified">711 const char* const VM_Version_Ext::_family_id_intel[ExtendedFamilyIdLength_INTEL] = {</span>
712   &quot;8086/8088&quot;,
713   &quot;&quot;,
714   &quot;286&quot;,
715   &quot;386&quot;,
716   &quot;486&quot;,
717   &quot;Pentium&quot;,
718   &quot;Pentium Pro&quot;,   //or Pentium-M/Woodcrest depeding on model
719   &quot;&quot;,
720   &quot;&quot;,
721   &quot;&quot;,
722   &quot;&quot;,
723   &quot;&quot;,
724   &quot;&quot;,
725   &quot;&quot;,
726   &quot;&quot;,
727   &quot;Pentium 4&quot;
728 };
729 
<a name="8" id="anc8"></a><span class="line-modified">730 const char* const VM_Version_Ext::_family_id_amd[ExtendedFamilyIdLength_AMD] = {</span>
731   &quot;&quot;,
732   &quot;&quot;,
733   &quot;&quot;,
734   &quot;&quot;,
735   &quot;5x86&quot;,
736   &quot;K5/K6&quot;,
737   &quot;Athlon/AthlonXP&quot;,
738   &quot;&quot;,
739   &quot;&quot;,
740   &quot;&quot;,
741   &quot;&quot;,
742   &quot;&quot;,
743   &quot;&quot;,
744   &quot;&quot;,
745   &quot;&quot;,
746   &quot;Opteron/Athlon64&quot;,
747   &quot;Opteron QC/Phenom&quot;  // Barcelona et.al.
<a name="9" id="anc9"></a><span class="line-added">748   &quot;&quot;,</span>
<span class="line-added">749   &quot;&quot;,</span>
<span class="line-added">750   &quot;&quot;,</span>
<span class="line-added">751   &quot;&quot;,</span>
<span class="line-added">752   &quot;&quot;,</span>
<span class="line-added">753   &quot;&quot;,</span>
<span class="line-added">754   &quot;Zen&quot;</span>
755 };
756 // Partially from Intel 64 and IA-32 Architecture Software Developer&#39;s Manual,
757 // September 2013, Vol 3C Table 35-1
758 const char* const VM_Version_Ext::_model_id_pentium_pro[] = {
759   &quot;&quot;,
760   &quot;Pentium Pro&quot;,
761   &quot;&quot;,
762   &quot;Pentium II model 3&quot;,
763   &quot;&quot;,
764   &quot;Pentium II model 5/Xeon/Celeron&quot;,
765   &quot;Celeron&quot;,
766   &quot;Pentium III/Pentium III Xeon&quot;,
767   &quot;Pentium III/Pentium III Xeon&quot;,
768   &quot;Pentium M model 9&quot;,    // Yonah
769   &quot;Pentium III, model A&quot;,
770   &quot;Pentium III, model B&quot;,
771   &quot;&quot;,
772   &quot;Pentium M model D&quot;,    // Dothan
773   &quot;&quot;,
774   &quot;Core 2&quot;,               // 0xf Woodcrest/Conroe/Merom/Kentsfield/Clovertown
775   &quot;&quot;,
776   &quot;&quot;,
777   &quot;&quot;,
778   &quot;&quot;,
779   &quot;&quot;,
780   &quot;&quot;,
781   &quot;Celeron&quot;,              // 0x16 Celeron 65nm
782   &quot;Core 2&quot;,               // 0x17 Penryn / Harpertown
783   &quot;&quot;,
784   &quot;&quot;,
785   &quot;Core i7&quot;,              // 0x1A CPU_MODEL_NEHALEM_EP
786   &quot;Atom&quot;,                 // 0x1B Z5xx series Silverthorn
787   &quot;&quot;,
788   &quot;Core 2&quot;,               // 0x1D Dunnington (6-core)
789   &quot;Nehalem&quot;,              // 0x1E CPU_MODEL_NEHALEM
790   &quot;&quot;,
791   &quot;&quot;,
792   &quot;&quot;,
793   &quot;&quot;,
794   &quot;&quot;,
795   &quot;&quot;,
796   &quot;Westmere&quot;,             // 0x25 CPU_MODEL_WESTMERE
797   &quot;&quot;,
798   &quot;&quot;,
799   &quot;&quot;,                     // 0x28
800   &quot;&quot;,
801   &quot;Sandy Bridge&quot;,         // 0x2a &quot;2nd Generation Intel Core i7, i5, i3&quot;
802   &quot;&quot;,
803   &quot;Westmere-EP&quot;,          // 0x2c CPU_MODEL_WESTMERE_EP
804   &quot;Sandy Bridge-EP&quot;,      // 0x2d CPU_MODEL_SANDYBRIDGE_EP
805   &quot;Nehalem-EX&quot;,           // 0x2e CPU_MODEL_NEHALEM_EX
806   &quot;Westmere-EX&quot;,          // 0x2f CPU_MODEL_WESTMERE_EX
807   &quot;&quot;,
808   &quot;&quot;,
809   &quot;&quot;,
810   &quot;&quot;,
811   &quot;&quot;,
812   &quot;&quot;,
813   &quot;&quot;,
814   &quot;&quot;,
815   &quot;&quot;,
816   &quot;&quot;,
817   &quot;Ivy Bridge&quot;,           // 0x3a
818   &quot;&quot;,
819   &quot;Haswell&quot;,              // 0x3c &quot;4th Generation Intel Core Processor&quot;
820   &quot;&quot;,                     // 0x3d &quot;Next Generation Intel Core Processor&quot;
821   &quot;Ivy Bridge-EP&quot;,        // 0x3e &quot;Next Generation Intel Xeon Processor E7 Family&quot;
822   &quot;&quot;,                     // 0x3f &quot;Future Generation Intel Xeon Processor&quot;
823   &quot;&quot;,
824   &quot;&quot;,
825   &quot;&quot;,
826   &quot;&quot;,
827   &quot;&quot;,
828   &quot;Haswell&quot;,              // 0x45 &quot;4th Generation Intel Core Processor&quot;
829   &quot;Haswell&quot;,              // 0x46 &quot;4th Generation Intel Core Processor&quot;
830   NULL
831 };
832 
833 /* Brand ID is for back compability
834  * Newer CPUs uses the extended brand string */
835 const char* const VM_Version_Ext::_brand_id[] = {
836   &quot;&quot;,
837   &quot;Celeron processor&quot;,
838   &quot;Pentium III processor&quot;,
839   &quot;Intel Pentium III Xeon processor&quot;,
840   &quot;&quot;,
841   &quot;&quot;,
842   &quot;&quot;,
843   &quot;&quot;,
844   &quot;Intel Pentium 4 processor&quot;,
845   NULL
846 };
847 
848 
849 const char* const VM_Version_Ext::_feature_edx_id[] = {
850   &quot;On-Chip FPU&quot;,
851   &quot;Virtual Mode Extensions&quot;,
852   &quot;Debugging Extensions&quot;,
853   &quot;Page Size Extensions&quot;,
854   &quot;Time Stamp Counter&quot;,
855   &quot;Model Specific Registers&quot;,
856   &quot;Physical Address Extension&quot;,
857   &quot;Machine Check Exceptions&quot;,
858   &quot;CMPXCHG8B Instruction&quot;,
859   &quot;On-Chip APIC&quot;,
860   &quot;&quot;,
861   &quot;Fast System Call&quot;,
862   &quot;Memory Type Range Registers&quot;,
863   &quot;Page Global Enable&quot;,
864   &quot;Machine Check Architecture&quot;,
865   &quot;Conditional Mov Instruction&quot;,
866   &quot;Page Attribute Table&quot;,
867   &quot;36-bit Page Size Extension&quot;,
868   &quot;Processor Serial Number&quot;,
869   &quot;CLFLUSH Instruction&quot;,
870   &quot;&quot;,
871   &quot;Debug Trace Store feature&quot;,
872   &quot;ACPI registers in MSR space&quot;,
873   &quot;Intel Architecture MMX Technology&quot;,
874   &quot;Fast Float Point Save and Restore&quot;,
875   &quot;Streaming SIMD extensions&quot;,
876   &quot;Streaming SIMD extensions 2&quot;,
877   &quot;Self-Snoop&quot;,
878   &quot;Hyper Threading&quot;,
879   &quot;Thermal Monitor&quot;,
880   &quot;&quot;,
881   &quot;Pending Break Enable&quot;
882 };
883 
884 const char* const VM_Version_Ext::_feature_extended_edx_id[] = {
885   &quot;&quot;,
886   &quot;&quot;,
887   &quot;&quot;,
888   &quot;&quot;,
889   &quot;&quot;,
890   &quot;&quot;,
891   &quot;&quot;,
892   &quot;&quot;,
893   &quot;&quot;,
894   &quot;&quot;,
895   &quot;&quot;,
896   &quot;SYSCALL/SYSRET&quot;,
897   &quot;&quot;,
898   &quot;&quot;,
899   &quot;&quot;,
900   &quot;&quot;,
901   &quot;&quot;,
902   &quot;&quot;,
903   &quot;&quot;,
904   &quot;&quot;,
905   &quot;Execute Disable Bit&quot;,
906   &quot;&quot;,
907   &quot;&quot;,
908   &quot;&quot;,
909   &quot;&quot;,
910   &quot;&quot;,
911   &quot;&quot;,
912   &quot;RDTSCP&quot;,
913   &quot;&quot;,
914   &quot;Intel 64 Architecture&quot;,
915   &quot;&quot;,
916   &quot;&quot;
917 };
918 
919 const char* const VM_Version_Ext::_feature_ecx_id[] = {
920   &quot;Streaming SIMD Extensions 3&quot;,
921   &quot;PCLMULQDQ&quot;,
922   &quot;64-bit DS Area&quot;,
923   &quot;MONITOR/MWAIT instructions&quot;,
924   &quot;CPL Qualified Debug Store&quot;,
925   &quot;Virtual Machine Extensions&quot;,
926   &quot;Safer Mode Extensions&quot;,
927   &quot;Enhanced Intel SpeedStep technology&quot;,
928   &quot;Thermal Monitor 2&quot;,
929   &quot;Supplemental Streaming SIMD Extensions 3&quot;,
930   &quot;L1 Context ID&quot;,
931   &quot;&quot;,
932   &quot;Fused Multiply-Add&quot;,
933   &quot;CMPXCHG16B&quot;,
934   &quot;xTPR Update Control&quot;,
935   &quot;Perfmon and Debug Capability&quot;,
936   &quot;&quot;,
937   &quot;Process-context identifiers&quot;,
938   &quot;Direct Cache Access&quot;,
939   &quot;Streaming SIMD extensions 4.1&quot;,
940   &quot;Streaming SIMD extensions 4.2&quot;,
941   &quot;x2APIC&quot;,
942   &quot;MOVBE&quot;,
943   &quot;Popcount instruction&quot;,
944   &quot;TSC-Deadline&quot;,
945   &quot;AESNI&quot;,
946   &quot;XSAVE&quot;,
947   &quot;OSXSAVE&quot;,
948   &quot;AVX&quot;,
949   &quot;F16C&quot;,
950   &quot;RDRAND&quot;,
951   &quot;&quot;
952 };
953 
954 const char* const VM_Version_Ext::_feature_extended_ecx_id[] = {
955   &quot;LAHF/SAHF instruction support&quot;,
956   &quot;Core multi-processor leagacy mode&quot;,
957   &quot;&quot;,
958   &quot;&quot;,
959   &quot;&quot;,
960   &quot;Advanced Bit Manipulations: LZCNT&quot;,
961   &quot;SSE4A: MOVNTSS, MOVNTSD, EXTRQ, INSERTQ&quot;,
962   &quot;Misaligned SSE mode&quot;,
963   &quot;&quot;,
964   &quot;&quot;,
965   &quot;&quot;,
966   &quot;&quot;,
967   &quot;&quot;,
968   &quot;&quot;,
969   &quot;&quot;,
970   &quot;&quot;,
971   &quot;&quot;,
972   &quot;&quot;,
973   &quot;&quot;,
974   &quot;&quot;,
975   &quot;&quot;,
976   &quot;&quot;,
977   &quot;&quot;,
978   &quot;&quot;,
979   &quot;&quot;,
980   &quot;&quot;,
981   &quot;&quot;,
982   &quot;&quot;,
983   &quot;&quot;,
984   &quot;&quot;,
985   &quot;&quot;,
986   &quot;&quot;
987 };
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
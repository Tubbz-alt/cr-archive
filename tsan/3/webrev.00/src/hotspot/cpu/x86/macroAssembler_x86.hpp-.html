<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_MACROASSEMBLER_X86_HPP
  26 #define CPU_X86_MACROASSEMBLER_X86_HPP
  27 
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;utilities/macros.hpp&quot;
  30 #include &quot;runtime/rtmLocking.hpp&quot;
  31 
  32 // MacroAssembler extends Assembler by frequently used macros.
  33 //
  34 // Instructions for which a &#39;better&#39; code sequence exists depending
  35 // on arguments should also go in here.
  36 
  37 class MacroAssembler: public Assembler {
  38   friend class LIR_Assembler;
  39   friend class Runtime1;      // as_Address()
  40 
  41  public:
  42   // Support for VM calls
  43   //
  44   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  45   // may customize this version by overriding it for its purposes (e.g., to save/restore
  46   // additional registers when doing a VM call).
  47 
  48   virtual void call_VM_leaf_base(
  49     address entry_point,               // the entry point
  50     int     number_of_arguments        // the number of arguments to pop after the call
  51   );
  52 
  53  protected:
  54   // This is the base routine called by the different versions of call_VM. The interpreter
  55   // may customize this version by overriding it for its purposes (e.g., to save/restore
  56   // additional registers when doing a VM call).
  57   //
  58   // If no java_thread register is specified (noreg) than rdi will be used instead. call_VM_base
  59   // returns the register which contains the thread upon return. If a thread register has been
  60   // specified, the return value will correspond to that register. If no last_java_sp is specified
  61   // (noreg) than rsp will be used instead.
  62   virtual void call_VM_base(           // returns the register containing the thread upon return
  63     Register oop_result,               // where an oop-result ends up if any; use noreg otherwise
  64     Register java_thread,              // the thread if computed before     ; use noreg otherwise
  65     Register last_java_sp,             // to set up last_Java_frame in stubs; use noreg otherwise
  66     address  entry_point,              // the entry point
  67     int      number_of_arguments,      // the number of arguments (w/o thread) to pop after the call
  68     bool     check_exceptions          // whether to check for pending exceptions after return
  69   );
  70 
  71   void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions = true);
  72 
  73   // helpers for FPU flag access
  74   // tmp is a temporary register, if none is available use noreg
  75   void save_rax   (Register tmp);
  76   void restore_rax(Register tmp);
  77 
  78  public:
  79   MacroAssembler(CodeBuffer* code) : Assembler(code) {}
  80 
  81  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
  82  // The implementation is only non-empty for the InterpreterMacroAssembler,
  83  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
  84  virtual void check_and_handle_popframe(Register java_thread);
  85  virtual void check_and_handle_earlyret(Register java_thread);
  86 
  87   Address as_Address(AddressLiteral adr);
  88   Address as_Address(ArrayAddress adr);
  89 
  90   // Support for NULL-checks
  91   //
  92   // Generates code that causes a NULL OS exception if the content of reg is NULL.
  93   // If the accessed location is M[reg + offset] and the offset is known, provide the
  94   // offset. No explicit code generation is needed if the offset is within a certain
  95   // range (0 &lt;= offset &lt;= page_size).
  96 
  97   void null_check(Register reg, int offset = -1);
  98   static bool needs_explicit_null_check(intptr_t offset);
  99   static bool uses_implicit_null_check(void* address);
 100 
 101   // Required platform-specific helpers for Label::patch_instructions.
 102   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 103   void pd_patch_instruction(address branch, address target, const char* file, int line) {
 104     unsigned char op = branch[0];
 105     assert(op == 0xE8 /* call */ ||
 106         op == 0xE9 /* jmp */ ||
 107         op == 0xEB /* short jmp */ ||
 108         (op &amp; 0xF0) == 0x70 /* short jcc */ ||
 109         op == 0x0F &amp;&amp; (branch[1] &amp; 0xF0) == 0x80 /* jcc */ ||
 110         op == 0xC7 &amp;&amp; branch[1] == 0xF8 /* xbegin */,
 111         &quot;Invalid opcode at patch point&quot;);
 112 
 113     if (op == 0xEB || (op &amp; 0xF0) == 0x70) {
 114       // short offset operators (jmp and jcc)
 115       char* disp = (char*) &amp;branch[1];
 116       int imm8 = target - (address) &amp;disp[1];
 117       guarantee(this-&gt;is8bit(imm8), &quot;Short forward jump exceeds 8-bit offset at %s:%d&quot;, file, line);
 118       *disp = imm8;
 119     } else {
 120       int* disp = (int*) &amp;branch[(op == 0x0F || op == 0xC7)? 2: 1];
 121       int imm32 = target - (address) &amp;disp[1];
 122       *disp = imm32;
 123     }
 124   }
 125 
 126   // The following 4 methods return the offset of the appropriate move instruction
 127 
 128   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 129   int load_unsigned_byte(Register dst, Address src);
 130   int load_unsigned_short(Register dst, Address src);
 131 
 132   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 133   int load_signed_byte(Register dst, Address src);
 134   int load_signed_short(Register dst, Address src);
 135 
 136   // Support for sign-extension (hi:lo = extend_sign(lo))
 137   void extend_sign(Register hi, Register lo);
 138 
 139   // Load and store values by size and signed-ness
 140   void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);
 141   void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);
 142 
 143   // Support for inc/dec with optimal instruction selection depending on value
 144 
 145   void increment(Register reg, int value = 1) { LP64_ONLY(incrementq(reg, value)) NOT_LP64(incrementl(reg, value)) ; }
 146   void decrement(Register reg, int value = 1) { LP64_ONLY(decrementq(reg, value)) NOT_LP64(decrementl(reg, value)) ; }
 147 
 148   void decrementl(Address dst, int value = 1);
 149   void decrementl(Register reg, int value = 1);
 150 
 151   void decrementq(Register reg, int value = 1);
 152   void decrementq(Address dst, int value = 1);
 153 
 154   void incrementl(Address dst, int value = 1);
 155   void incrementl(Register reg, int value = 1);
 156 
 157   void incrementq(Register reg, int value = 1);
 158   void incrementq(Address dst, int value = 1);
 159 
 160 #ifdef COMPILER2
 161   // special instructions for EVEX
 162   void setvectmask(Register dst, Register src);
 163   void restorevectmask();
 164 #endif
 165 
 166   // Support optimal SSE move instructions.
 167   void movflt(XMMRegister dst, XMMRegister src) {
 168     if (dst-&gt; encoding() == src-&gt;encoding()) return;
 169     if (UseXmmRegToRegMoveAll) { movaps(dst, src); return; }
 170     else                       { movss (dst, src); return; }
 171   }
 172   void movflt(XMMRegister dst, Address src) { movss(dst, src); }
 173   void movflt(XMMRegister dst, AddressLiteral src);
 174   void movflt(Address dst, XMMRegister src) { movss(dst, src); }
 175 
 176   void movdbl(XMMRegister dst, XMMRegister src) {
 177     if (dst-&gt; encoding() == src-&gt;encoding()) return;
 178     if (UseXmmRegToRegMoveAll) { movapd(dst, src); return; }
 179     else                       { movsd (dst, src); return; }
 180   }
 181 
 182   void movdbl(XMMRegister dst, AddressLiteral src);
 183 
 184   void movdbl(XMMRegister dst, Address src) {
 185     if (UseXmmLoadAndClearUpper) { movsd (dst, src); return; }
 186     else                         { movlpd(dst, src); return; }
 187   }
 188   void movdbl(Address dst, XMMRegister src) { movsd(dst, src); }
 189 
 190   void incrementl(AddressLiteral dst);
 191   void incrementl(ArrayAddress dst);
 192 
 193   void incrementq(AddressLiteral dst);
 194 
 195   // Alignment
 196   void align(int modulus);
 197   void align(int modulus, int target);
 198 
 199   // A 5 byte nop that is safe for patching (see patch_verified_entry)
 200   void fat_nop();
 201 
 202   // Stack frame creation/removal
 203   void enter();
 204   void leave();
 205 
 206   // Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)
 207   // The pointer will be loaded into the thread register.
 208   void get_thread(Register thread);
 209 
 210 
 211   // Support for VM calls
 212   //
 213   // It is imperative that all calls into the VM are handled via the call_VM macros.
 214   // They make sure that the stack linkage is setup correctly. call_VM&#39;s correspond
 215   // to ENTRY/ENTRY_X entry points while call_VM_leaf&#39;s correspond to LEAF entry points.
 216 
 217 
 218   void call_VM(Register oop_result,
 219                address entry_point,
 220                bool check_exceptions = true);
 221   void call_VM(Register oop_result,
 222                address entry_point,
 223                Register arg_1,
 224                bool check_exceptions = true);
 225   void call_VM(Register oop_result,
 226                address entry_point,
 227                Register arg_1, Register arg_2,
 228                bool check_exceptions = true);
 229   void call_VM(Register oop_result,
 230                address entry_point,
 231                Register arg_1, Register arg_2, Register arg_3,
 232                bool check_exceptions = true);
 233 
 234   // Overloadings with last_Java_sp
 235   void call_VM(Register oop_result,
 236                Register last_java_sp,
 237                address entry_point,
 238                int number_of_arguments = 0,
 239                bool check_exceptions = true);
 240   void call_VM(Register oop_result,
 241                Register last_java_sp,
 242                address entry_point,
 243                Register arg_1, bool
 244                check_exceptions = true);
 245   void call_VM(Register oop_result,
 246                Register last_java_sp,
 247                address entry_point,
 248                Register arg_1, Register arg_2,
 249                bool check_exceptions = true);
 250   void call_VM(Register oop_result,
 251                Register last_java_sp,
 252                address entry_point,
 253                Register arg_1, Register arg_2, Register arg_3,
 254                bool check_exceptions = true);
 255 
 256   void get_vm_result  (Register oop_result, Register thread);
 257   void get_vm_result_2(Register metadata_result, Register thread);
 258 
 259   // These always tightly bind to MacroAssembler::call_VM_base
 260   // bypassing the virtual implementation
 261   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments = 0, bool check_exceptions = true);
 262   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true);
 263   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
 264   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
 265   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4, bool check_exceptions = true);
 266 
 267   void call_VM_leaf0(address entry_point);
 268   void call_VM_leaf(address entry_point,
 269                     int number_of_arguments = 0);
 270   void call_VM_leaf(address entry_point,
 271                     Register arg_1);
 272   void call_VM_leaf(address entry_point,
 273                     Register arg_1, Register arg_2);
 274   void call_VM_leaf(address entry_point,
 275                     Register arg_1, Register arg_2, Register arg_3);
 276 
 277   // These always tightly bind to MacroAssembler::call_VM_leaf_base
 278   // bypassing the virtual implementation
 279   void super_call_VM_leaf(address entry_point);
 280   void super_call_VM_leaf(address entry_point, Register arg_1);
 281   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
 282   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3);
 283   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4);
 284 
 285   // last Java Frame (fills frame anchor)
 286   void set_last_Java_frame(Register thread,
 287                            Register last_java_sp,
 288                            Register last_java_fp,
 289                            address last_java_pc);
 290 
 291   // thread in the default location (r15_thread on 64bit)
 292   void set_last_Java_frame(Register last_java_sp,
 293                            Register last_java_fp,
 294                            address last_java_pc);
 295 
 296   void reset_last_Java_frame(Register thread, bool clear_fp);
 297 
 298   // thread in the default location (r15_thread on 64bit)
 299   void reset_last_Java_frame(bool clear_fp);
 300 
 301   // jobjects
 302   void clear_jweak_tag(Register possibly_jweak);
 303   void resolve_jobject(Register value, Register thread, Register tmp);
 304 
 305   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 306   void c2bool(Register x);
 307 
 308   // C++ bool manipulation
 309 
 310   void movbool(Register dst, Address src);
 311   void movbool(Address dst, bool boolconst);
 312   void movbool(Address dst, Register src);
 313   void testbool(Register dst);
 314 
 315   void resolve_oop_handle(Register result, Register tmp = rscratch2);
 316   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
 317 
 318   // oop manipulations
 319   void load_klass(Register dst, Register src);
 320   void store_klass(Register dst, Register src);
 321 
 322   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 323                       Register tmp1, Register thread_tmp);
 324   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 325                        Register tmp1, Register tmp2);
 326 
 327   // Resolves obj access. Result is placed in the same register.
 328   // All other registers are preserved.
 329   void resolve(DecoratorSet decorators, Register obj);
 330 
 331   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 332                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 333   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 334                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 335   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 336                       Register tmp2 = noreg, DecoratorSet decorators = 0);
 337 
 338   // Used for storing NULL. All other oop constants should be
 339   // stored using routines that take a jobject.
 340   void store_heap_oop_null(Address dst);
 341 
 342   void load_prototype_header(Register dst, Register src);
 343 
 344 #ifdef _LP64
 345   void store_klass_gap(Register dst, Register src);
 346 
 347   // This dummy is to prevent a call to store_heap_oop from
 348   // converting a zero (like NULL) into a Register by giving
 349   // the compiler two choices it can&#39;t resolve
 350 
 351   void store_heap_oop(Address dst, void* dummy);
 352 
 353   void encode_heap_oop(Register r);
 354   void decode_heap_oop(Register r);
 355   void encode_heap_oop_not_null(Register r);
 356   void decode_heap_oop_not_null(Register r);
 357   void encode_heap_oop_not_null(Register dst, Register src);
 358   void decode_heap_oop_not_null(Register dst, Register src);
 359 
 360   void set_narrow_oop(Register dst, jobject obj);
 361   void set_narrow_oop(Address dst, jobject obj);
 362   void cmp_narrow_oop(Register dst, jobject obj);
 363   void cmp_narrow_oop(Address dst, jobject obj);
 364 
 365   void encode_klass_not_null(Register r);
 366   void decode_klass_not_null(Register r);
 367   void encode_klass_not_null(Register dst, Register src);
 368   void decode_klass_not_null(Register dst, Register src);
 369   void set_narrow_klass(Register dst, Klass* k);
 370   void set_narrow_klass(Address dst, Klass* k);
 371   void cmp_narrow_klass(Register dst, Klass* k);
 372   void cmp_narrow_klass(Address dst, Klass* k);
 373 
 374   // Returns the byte size of the instructions generated by decode_klass_not_null()
 375   // when compressed klass pointers are being used.
 376   static int instr_size_for_decode_klass_not_null();
 377 
 378   // if heap base register is used - reinit it with the correct value
 379   void reinit_heapbase();
 380 
 381   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 382 
 383 #endif // _LP64
 384 
 385   // Int division/remainder for Java
 386   // (as idivl, but checks for special case as described in JVM spec.)
 387   // returns idivl instruction offset for implicit exception handling
 388   int corrected_idivl(Register reg);
 389 
 390   // Long division/remainder for Java
 391   // (as idivq, but checks for special case as described in JVM spec.)
 392   // returns idivq instruction offset for implicit exception handling
 393   int corrected_idivq(Register reg);
 394 
 395   void int3();
 396 
 397   // Long operation macros for a 32bit cpu
 398   // Long negation for Java
 399   void lneg(Register hi, Register lo);
 400 
 401   // Long multiplication for Java
 402   // (destroys contents of eax, ebx, ecx and edx)
 403   void lmul(int x_rsp_offset, int y_rsp_offset); // rdx:rax = x * y
 404 
 405   // Long shifts for Java
 406   // (semantics as described in JVM spec.)
 407   void lshl(Register hi, Register lo);                               // hi:lo &lt;&lt; (rcx &amp; 0x3f)
 408   void lshr(Register hi, Register lo, bool sign_extension = false);  // hi:lo &gt;&gt; (rcx &amp; 0x3f)
 409 
 410   // Long compare for Java
 411   // (semantics as described in JVM spec.)
 412   void lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo); // x_hi = lcmp(x, y)
 413 
 414 
 415   // misc
 416 
 417   // Sign extension
 418   void sign_extend_short(Register reg);
 419   void sign_extend_byte(Register reg);
 420 
 421   // Division by power of 2, rounding towards 0
 422   void division_with_shift(Register reg, int shift_value);
 423 
 424   // Compares the top-most stack entries on the FPU stack and sets the eflags as follows:
 425   //
 426   // CF (corresponds to C0) if x &lt; y
 427   // PF (corresponds to C2) if unordered
 428   // ZF (corresponds to C3) if x = y
 429   //
 430   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 431   // tmp is a temporary register, if none is available use noreg (only matters for non-P6 code)
 432   void fcmp(Register tmp);
 433   // Variant of the above which allows y to be further down the stack
 434   // and which only pops x and y if specified. If pop_right is
 435   // specified then pop_left must also be specified.
 436   void fcmp(Register tmp, int index, bool pop_left, bool pop_right);
 437 
 438   // Floating-point comparison for Java
 439   // Compares the top-most stack entries on the FPU stack and stores the result in dst.
 440   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 441   // (semantics as described in JVM spec.)
 442   void fcmp2int(Register dst, bool unordered_is_less);
 443   // Variant of the above which allows y to be further down the stack
 444   // and which only pops x and y if specified. If pop_right is
 445   // specified then pop_left must also be specified.
 446   void fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right);
 447 
 448   // Floating-point remainder for Java (ST0 = ST0 fremr ST1, ST1 is empty afterwards)
 449   // tmp is a temporary register, if none is available use noreg
 450   void fremr(Register tmp);
 451 
 452   // dst = c = a * b + c
 453   void fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 454   void fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 455 
 456   void vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 457   void vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 458   void vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 459   void vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 460 
 461 
 462   // same as fcmp2int, but using SSE2
 463   void cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 464   void cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 465 
 466   // branch to L if FPU flag C2 is set/not set
 467   // tmp is a temporary register, if none is available use noreg
 468   void jC2 (Register tmp, Label&amp; L);
 469   void jnC2(Register tmp, Label&amp; L);
 470 
 471   // Pop ST (ffree &amp; fincstp combined)
 472   void fpop();
 473 
 474   // Load float value from &#39;address&#39;. If UseSSE &gt;= 1, the value is loaded into
 475   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 476   void load_float(Address src);
 477 
 478   // Store float value to &#39;address&#39;. If UseSSE &gt;= 1, the value is stored
 479   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 480   void store_float(Address dst);
 481 
 482   // Load double value from &#39;address&#39;. If UseSSE &gt;= 2, the value is loaded into
 483   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 484   void load_double(Address src);
 485 
 486   // Store double value to &#39;address&#39;. If UseSSE &gt;= 2, the value is stored
 487   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 488   void store_double(Address dst);
 489 
 490   // pushes double TOS element of FPU stack on CPU stack; pops from FPU stack
 491   void push_fTOS();
 492 
 493   // pops double TOS element from CPU stack and pushes on FPU stack
 494   void pop_fTOS();
 495 
 496   void empty_FPU_stack();
 497 
 498   void push_IU_state();
 499   void pop_IU_state();
 500 
 501   void push_FPU_state();
 502   void pop_FPU_state();
 503 
 504   void push_CPU_state();
 505   void pop_CPU_state();
 506 
 507   // Round up to a power of two
 508   void round_to(Register reg, int modulus);
 509 
 510   // Callee saved registers handling
 511   void push_callee_saved_registers();
 512   void pop_callee_saved_registers();
 513 
 514   // allocation
 515   void eden_allocate(
 516     Register thread,                   // Current thread
 517     Register obj,                      // result: pointer to object after successful allocation
 518     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 519     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 520     Register t1,                       // temp register
 521     Label&amp;   slow_case                 // continuation point if fast allocation fails
 522   );
 523   void tlab_allocate(
 524     Register thread,                   // Current thread
 525     Register obj,                      // result: pointer to object after successful allocation
 526     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 527     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 528     Register t1,                       // temp register
 529     Register t2,                       // temp register
 530     Label&amp;   slow_case                 // continuation point if fast allocation fails
 531   );
 532   void zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp);
 533 
 534   // interface method calling
 535   void lookup_interface_method(Register recv_klass,
 536                                Register intf_klass,
 537                                RegisterOrConstant itable_index,
 538                                Register method_result,
 539                                Register scan_temp,
 540                                Label&amp; no_such_interface,
 541                                bool return_method = true);
 542 
 543   // virtual method calling
 544   void lookup_virtual_method(Register recv_klass,
 545                              RegisterOrConstant vtable_index,
 546                              Register method_result);
 547 
 548   // Test sub_klass against super_klass, with fast and slow paths.
 549 
 550   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 551   // One of the three labels can be NULL, meaning take the fall-through.
 552   // If super_check_offset is -1, the value is loaded up from super_klass.
 553   // No registers are killed, except temp_reg.
 554   void check_klass_subtype_fast_path(Register sub_klass,
 555                                      Register super_klass,
 556                                      Register temp_reg,
 557                                      Label* L_success,
 558                                      Label* L_failure,
 559                                      Label* L_slow_path,
 560                 RegisterOrConstant super_check_offset = RegisterOrConstant(-1));
 561 
 562   // The rest of the type check; must be wired to a corresponding fast path.
 563   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 564   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 565   // Updates the sub&#39;s secondary super cache as necessary.
 566   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 567   void check_klass_subtype_slow_path(Register sub_klass,
 568                                      Register super_klass,
 569                                      Register temp_reg,
 570                                      Register temp2_reg,
 571                                      Label* L_success,
 572                                      Label* L_failure,
 573                                      bool set_cond_codes = false);
 574 
 575   // Simplified, combined version, good for typical uses.
 576   // Falls through on failure.
 577   void check_klass_subtype(Register sub_klass,
 578                            Register super_klass,
 579                            Register temp_reg,
 580                            Label&amp; L_success);
 581 
 582   // method handles (JSR 292)
 583   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 584 
 585   //----
 586   void set_word_if_not_zero(Register reg); // sets reg to 1 if not zero, otherwise 0
 587 
 588   // Debugging
 589 
 590   // only if +VerifyOops
 591   // TODO: Make these macros with file and line like sparc version!
 592   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
 593   void verify_oop_addr(Address addr, const char * s = &quot;broken oop addr&quot;);
 594 
 595   // TODO: verify method and klass metadata (compare against vptr?)
 596   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 597   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 598 
 599 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 600 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 601 
 602   // only if +VerifyFPU
 603   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 604 
 605   // Verify or restore cpu control state after JNI call
 606   void restore_cpu_control_state_after_jni();
 607 
 608   // prints msg, dumps registers and stops execution
 609   void stop(const char* msg);
 610 
 611   // prints msg and continues
 612   void warn(const char* msg);
 613 
 614   // dumps registers and other state
 615   void print_state();
 616 
 617   static void debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg);
 618   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 619   static void print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip);
 620   static void print_state64(int64_t pc, int64_t regs[]);
 621 
 622   void os_breakpoint();
 623 
 624   void untested()                                { stop(&quot;untested&quot;); }
 625 
 626   void unimplemented(const char* what = &quot;&quot;);
 627 
 628   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
 629 
 630   void print_CPU_state();
 631 
 632   // Stack overflow checking
 633   void bang_stack_with_offset(int offset) {
 634     // stack grows down, caller passes positive offset
 635     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
 636     movl(Address(rsp, (-offset)), rax);
 637   }
 638 
 639   // Writes to stack successive pages until offset reached to check for
 640   // stack overflow + shadow pages.  Also, clobbers tmp
 641   void bang_stack_size(Register size, Register tmp);
 642 
 643   // Check for reserved stack access in method being exited (for JIT)
 644   void reserved_stack_check();
 645 
 646   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
 647                                                 Register tmp,
 648                                                 int offset);
 649 
 650   // If thread_reg is != noreg the code assumes the register passed contains
 651   // the thread (required on 64 bit).
 652   void safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg);
 653 
 654   void verify_tlab();
 655 
 656   // Biased locking support
 657   // lock_reg and obj_reg must be loaded up with the appropriate values.
 658   // swap_reg must be rax, and is killed.
 659   // tmp_reg is optional. If it is supplied (i.e., != noreg) it will
 660   // be killed; if not supplied, push/pop will be used internally to
 661   // allocate a temporary (inefficient, avoid if possible).
 662   // Optional slow case is for implementations (interpreter and C1) which branch to
 663   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 664   // Returns offset of first potentially-faulting instruction for null
 665   // check info (currently consumed only by C1). If
 666   // swap_reg_contains_mark is true then returns -1 as it is assumed
 667   // the calling code has already passed any potential faults.
 668   int biased_locking_enter(Register lock_reg, Register obj_reg,
 669                            Register swap_reg, Register tmp_reg,
 670                            bool swap_reg_contains_mark,
 671                            Label&amp; done, Label* slow_case = NULL,
 672                            BiasedLockingCounters* counters = NULL);
 673   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 674 #ifdef COMPILER2
 675   // Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.
 676   // See full desription in macroAssembler_x86.cpp.
 677   void fast_lock(Register obj, Register box, Register tmp,
 678                  Register scr, Register cx1, Register cx2,
 679                  BiasedLockingCounters* counters,
 680                  RTMLockingCounters* rtm_counters,
 681                  RTMLockingCounters* stack_rtm_counters,
 682                  Metadata* method_data,
 683                  bool use_rtm, bool profile_rtm);
 684   void fast_unlock(Register obj, Register box, Register tmp, bool use_rtm);
 685 #if INCLUDE_RTM_OPT
 686   void rtm_counters_update(Register abort_status, Register rtm_counters);
 687   void branch_on_random_using_rdtsc(Register tmp, Register scr, int count, Label&amp; brLabel);
 688   void rtm_abort_ratio_calculation(Register tmp, Register rtm_counters_reg,
 689                                    RTMLockingCounters* rtm_counters,
 690                                    Metadata* method_data);
 691   void rtm_profiling(Register abort_status_Reg, Register rtm_counters_Reg,
 692                      RTMLockingCounters* rtm_counters, Metadata* method_data, bool profile_rtm);
 693   void rtm_retry_lock_on_abort(Register retry_count, Register abort_status, Label&amp; retryLabel);
 694   void rtm_retry_lock_on_busy(Register retry_count, Register box, Register tmp, Register scr, Label&amp; retryLabel);
 695   void rtm_stack_locking(Register obj, Register tmp, Register scr,
 696                          Register retry_on_abort_count,
 697                          RTMLockingCounters* stack_rtm_counters,
 698                          Metadata* method_data, bool profile_rtm,
 699                          Label&amp; DONE_LABEL, Label&amp; IsInflated);
 700   void rtm_inflated_locking(Register obj, Register box, Register tmp,
 701                             Register scr, Register retry_on_busy_count,
 702                             Register retry_on_abort_count,
 703                             RTMLockingCounters* rtm_counters,
 704                             Metadata* method_data, bool profile_rtm,
 705                             Label&amp; DONE_LABEL);
 706 #endif
 707 #endif
 708 
 709   Condition negate_condition(Condition cond);
 710 
 711   // Instructions that use AddressLiteral operands. These instruction can handle 32bit/64bit
 712   // operands. In general the names are modified to avoid hiding the instruction in Assembler
 713   // so that we don&#39;t need to implement all the varieties in the Assembler with trivial wrappers
 714   // here in MacroAssembler. The major exception to this rule is call
 715 
 716   // Arithmetics
 717 
 718 
 719   void addptr(Address dst, int32_t src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)) ; }
 720   void addptr(Address dst, Register src);
 721 
 722   void addptr(Register dst, Address src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)); }
 723   void addptr(Register dst, int32_t src);
 724   void addptr(Register dst, Register src);
 725   void addptr(Register dst, RegisterOrConstant src) {
 726     if (src.is_constant()) addptr(dst, (int) src.as_constant());
 727     else                   addptr(dst,       src.as_register());
 728   }
 729 
 730   void andptr(Register dst, int32_t src);
 731   void andptr(Register src1, Register src2) { LP64_ONLY(andq(src1, src2)) NOT_LP64(andl(src1, src2)) ; }
 732 
 733   void cmp8(AddressLiteral src1, int imm);
 734 
 735   // renamed to drag out the casting of address to int32_t/intptr_t
 736   void cmp32(Register src1, int32_t imm);
 737 
 738   void cmp32(AddressLiteral src1, int32_t imm);
 739   // compare reg - mem, or reg - &amp;mem
 740   void cmp32(Register src1, AddressLiteral src2);
 741 
 742   void cmp32(Register src1, Address src2);
 743 
 744 #ifndef _LP64
 745   void cmpklass(Address dst, Metadata* obj);
 746   void cmpklass(Register dst, Metadata* obj);
 747   void cmpoop(Address dst, jobject obj);
 748   void cmpoop_raw(Address dst, jobject obj);
 749 #endif // _LP64
 750 
 751   void cmpoop(Register src1, Register src2);
 752   void cmpoop(Register src1, Address src2);
 753   void cmpoop(Register dst, jobject obj);
 754   void cmpoop_raw(Register dst, jobject obj);
 755 
 756   // NOTE src2 must be the lval. This is NOT an mem-mem compare
 757   void cmpptr(Address src1, AddressLiteral src2);
 758 
 759   void cmpptr(Register src1, AddressLiteral src2);
 760 
 761   void cmpptr(Register src1, Register src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 762   void cmpptr(Register src1, Address src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 763   // void cmpptr(Address src1, Register src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 764 
 765   void cmpptr(Register src1, int32_t src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 766   void cmpptr(Address src1, int32_t src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 767 
 768   // cmp64 to avoild hiding cmpq
 769   void cmp64(Register src1, AddressLiteral src);
 770 
 771   void cmpxchgptr(Register reg, Address adr);
 772 
 773   void locked_cmpxchgptr(Register reg, AddressLiteral adr);
 774 
 775 
 776   void imulptr(Register dst, Register src) { LP64_ONLY(imulq(dst, src)) NOT_LP64(imull(dst, src)); }
 777   void imulptr(Register dst, Register src, int imm32) { LP64_ONLY(imulq(dst, src, imm32)) NOT_LP64(imull(dst, src, imm32)); }
 778 
 779 
 780   void negptr(Register dst) { LP64_ONLY(negq(dst)) NOT_LP64(negl(dst)); }
 781 
 782   void notptr(Register dst) { LP64_ONLY(notq(dst)) NOT_LP64(notl(dst)); }
 783 
 784   void shlptr(Register dst, int32_t shift);
 785   void shlptr(Register dst) { LP64_ONLY(shlq(dst)) NOT_LP64(shll(dst)); }
 786 
 787   void shrptr(Register dst, int32_t shift);
 788   void shrptr(Register dst) { LP64_ONLY(shrq(dst)) NOT_LP64(shrl(dst)); }
 789 
 790   void sarptr(Register dst) { LP64_ONLY(sarq(dst)) NOT_LP64(sarl(dst)); }
 791   void sarptr(Register dst, int32_t src) { LP64_ONLY(sarq(dst, src)) NOT_LP64(sarl(dst, src)); }
 792 
 793   void subptr(Address dst, int32_t src) { LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src)); }
 794 
 795   void subptr(Register dst, Address src) { LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src)); }
 796   void subptr(Register dst, int32_t src);
 797   // Force generation of a 4 byte immediate value even if it fits into 8bit
 798   void subptr_imm32(Register dst, int32_t src);
 799   void subptr(Register dst, Register src);
 800   void subptr(Register dst, RegisterOrConstant src) {
 801     if (src.is_constant()) subptr(dst, (int) src.as_constant());
 802     else                   subptr(dst,       src.as_register());
 803   }
 804 
 805   void sbbptr(Address dst, int32_t src) { LP64_ONLY(sbbq(dst, src)) NOT_LP64(sbbl(dst, src)); }
 806   void sbbptr(Register dst, int32_t src) { LP64_ONLY(sbbq(dst, src)) NOT_LP64(sbbl(dst, src)); }
 807 
 808   void xchgptr(Register src1, Register src2) { LP64_ONLY(xchgq(src1, src2)) NOT_LP64(xchgl(src1, src2)) ; }
 809   void xchgptr(Register src1, Address src2) { LP64_ONLY(xchgq(src1, src2)) NOT_LP64(xchgl(src1, src2)) ; }
 810 
 811   void xaddptr(Address src1, Register src2) { LP64_ONLY(xaddq(src1, src2)) NOT_LP64(xaddl(src1, src2)) ; }
 812 
 813 
 814 
 815   // Helper functions for statistics gathering.
 816   // Conditionally (atomically, on MPs) increments passed counter address, preserving condition codes.
 817   void cond_inc32(Condition cond, AddressLiteral counter_addr);
 818   // Unconditional atomic increment.
 819   void atomic_incl(Address counter_addr);
 820   void atomic_incl(AddressLiteral counter_addr, Register scr = rscratch1);
 821 #ifdef _LP64
 822   void atomic_incq(Address counter_addr);
 823   void atomic_incq(AddressLiteral counter_addr, Register scr = rscratch1);
 824 #endif
 825   void atomic_incptr(AddressLiteral counter_addr, Register scr = rscratch1) { LP64_ONLY(atomic_incq(counter_addr, scr)) NOT_LP64(atomic_incl(counter_addr, scr)) ; }
 826   void atomic_incptr(Address counter_addr) { LP64_ONLY(atomic_incq(counter_addr)) NOT_LP64(atomic_incl(counter_addr)) ; }
 827 
 828   void lea(Register dst, AddressLiteral adr);
 829   void lea(Address dst, AddressLiteral adr);
 830   void lea(Register dst, Address adr) { Assembler::lea(dst, adr); }
 831 
 832   void leal32(Register dst, Address src) { leal(dst, src); }
 833 
 834   // Import other testl() methods from the parent class or else
 835   // they will be hidden by the following overriding declaration.
 836   using Assembler::testl;
 837   void testl(Register dst, AddressLiteral src);
 838 
 839   void orptr(Register dst, Address src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 840   void orptr(Register dst, Register src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 841   void orptr(Register dst, int32_t src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 842   void orptr(Address dst, int32_t imm32) { LP64_ONLY(orq(dst, imm32)) NOT_LP64(orl(dst, imm32)); }
 843 
 844   void testptr(Register src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }
 845   void testptr(Register src1, Address src2) { LP64_ONLY(testq(src1, src2)) NOT_LP64(testl(src1, src2)); }
 846   void testptr(Register src1, Register src2);
 847 
 848   void xorptr(Register dst, Register src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 849   void xorptr(Register dst, Address src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 850 
 851   // Calls
 852 
 853   void call(Label&amp; L, relocInfo::relocType rtype);
 854   void call(Register entry);
 855 
 856   // NOTE: this call transfers to the effective address of entry NOT
 857   // the address contained by entry. This is because this is more natural
 858   // for jumps/calls.
 859   void call(AddressLiteral entry);
 860 
 861   // Emit the CompiledIC call idiom
 862   void ic_call(address entry, jint method_index = 0);
 863 
 864   // Jumps
 865 
 866   // NOTE: these jumps tranfer to the effective address of dst NOT
 867   // the address contained by dst. This is because this is more natural
 868   // for jumps/calls.
 869   void jump(AddressLiteral dst);
 870   void jump_cc(Condition cc, AddressLiteral dst);
 871 
 872   // 32bit can do a case table jump in one instruction but we no longer allow the base
 873   // to be installed in the Address class. This jump will tranfers to the address
 874   // contained in the location described by entry (not the address of entry)
 875   void jump(ArrayAddress entry);
 876 
 877   // Floating
 878 
 879   void andpd(XMMRegister dst, Address src) { Assembler::andpd(dst, src); }
 880   void andpd(XMMRegister dst, AddressLiteral src);
 881   void andpd(XMMRegister dst, XMMRegister src) { Assembler::andpd(dst, src); }
 882 
 883   void andps(XMMRegister dst, XMMRegister src) { Assembler::andps(dst, src); }
 884   void andps(XMMRegister dst, Address src) { Assembler::andps(dst, src); }
 885   void andps(XMMRegister dst, AddressLiteral src);
 886 
 887   void comiss(XMMRegister dst, XMMRegister src) { Assembler::comiss(dst, src); }
 888   void comiss(XMMRegister dst, Address src) { Assembler::comiss(dst, src); }
 889   void comiss(XMMRegister dst, AddressLiteral src);
 890 
 891   void comisd(XMMRegister dst, XMMRegister src) { Assembler::comisd(dst, src); }
 892   void comisd(XMMRegister dst, Address src) { Assembler::comisd(dst, src); }
 893   void comisd(XMMRegister dst, AddressLiteral src);
 894 
 895   void fadd_s(Address src)        { Assembler::fadd_s(src); }
 896   void fadd_s(AddressLiteral src) { Assembler::fadd_s(as_Address(src)); }
 897 
 898   void fldcw(Address src) { Assembler::fldcw(src); }
 899   void fldcw(AddressLiteral src);
 900 
 901   void fld_s(int index)   { Assembler::fld_s(index); }
 902   void fld_s(Address src) { Assembler::fld_s(src); }
 903   void fld_s(AddressLiteral src);
 904 
 905   void fld_d(Address src) { Assembler::fld_d(src); }
 906   void fld_d(AddressLiteral src);
 907 
 908   void fld_x(Address src) { Assembler::fld_x(src); }
 909   void fld_x(AddressLiteral src);
 910 
 911   void fmul_s(Address src)        { Assembler::fmul_s(src); }
 912   void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }
 913 
 914   void ldmxcsr(Address src) { Assembler::ldmxcsr(src); }
 915   void ldmxcsr(AddressLiteral src);
 916 
 917 #ifdef _LP64
 918  private:
 919   void sha256_AVX2_one_round_compute(
 920     Register  reg_old_h,
 921     Register  reg_a,
 922     Register  reg_b,
 923     Register  reg_c,
 924     Register  reg_d,
 925     Register  reg_e,
 926     Register  reg_f,
 927     Register  reg_g,
 928     Register  reg_h,
 929     int iter);
 930   void sha256_AVX2_four_rounds_compute_first(int start);
 931   void sha256_AVX2_four_rounds_compute_last(int start);
 932   void sha256_AVX2_one_round_and_sched(
 933         XMMRegister xmm_0,     /* == ymm4 on 0, 1, 2, 3 iterations, then rotate 4 registers left on 4, 8, 12 iterations */
 934         XMMRegister xmm_1,     /* ymm5 */  /* full cycle is 16 iterations */
 935         XMMRegister xmm_2,     /* ymm6 */
 936         XMMRegister xmm_3,     /* ymm7 */
 937         Register    reg_a,      /* == eax on 0 iteration, then rotate 8 register right on each next iteration */
 938         Register    reg_b,      /* ebx */    /* full cycle is 8 iterations */
 939         Register    reg_c,      /* edi */
 940         Register    reg_d,      /* esi */
 941         Register    reg_e,      /* r8d */
 942         Register    reg_f,      /* r9d */
 943         Register    reg_g,      /* r10d */
 944         Register    reg_h,      /* r11d */
 945         int iter);
 946 
 947   void addm(int disp, Register r1, Register r2);
 948   void gfmul(XMMRegister tmp0, XMMRegister t);
 949   void schoolbookAAD(int i, Register subkeyH, XMMRegister data, XMMRegister tmp0,
 950                      XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3);
 951   void generateHtbl_one_block(Register htbl);
 952   void generateHtbl_eight_blocks(Register htbl);
 953  public:
 954   void sha256_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 955                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 956                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 957                    bool multi_block, XMMRegister shuf_mask);
 958   void avx_ghash(Register state, Register htbl, Register data, Register blocks);
 959 #endif
 960 
 961 #ifdef _LP64
 962  private:
 963   void sha512_AVX2_one_round_compute(Register old_h, Register a, Register b, Register c, Register d,
 964                                      Register e, Register f, Register g, Register h, int iteration);
 965 
 966   void sha512_AVX2_one_round_and_schedule(XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
 967                                           Register a, Register b, Register c, Register d, Register e, Register f,
 968                                           Register g, Register h, int iteration);
 969 
 970   void addmq(int disp, Register r1, Register r2);
 971  public:
 972   void sha512_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 973                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 974                    Register buf, Register state, Register ofs, Register limit, Register rsp, bool multi_block,
 975                    XMMRegister shuf_mask);
 976 #endif
 977 
 978   void fast_sha1(XMMRegister abcd, XMMRegister e0, XMMRegister e1, XMMRegister msg0,
 979                  XMMRegister msg1, XMMRegister msg2, XMMRegister msg3, XMMRegister shuf_mask,
 980                  Register buf, Register state, Register ofs, Register limit, Register rsp,
 981                  bool multi_block);
 982 
 983 #ifdef _LP64
 984   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 985                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 986                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 987                    bool multi_block, XMMRegister shuf_mask);
 988 #else
 989   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 990                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 991                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 992                    bool multi_block);
 993 #endif
 994 
 995   void fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
 996                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
 997                 Register rax, Register rcx, Register rdx, Register tmp);
 998 
 999 #ifdef _LP64
1000   void fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1001                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1002                 Register rax, Register rcx, Register rdx, Register tmp1, Register tmp2);
1003 
1004   void fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1005                   XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1006                   Register rax, Register rcx, Register rdx, Register r11);
1007 
1008   void fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,
1009                 XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register rax, Register rcx,
1010                 Register rdx, Register tmp1, Register tmp2, Register tmp3, Register tmp4);
1011 
1012   void fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1013                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1014                 Register rax, Register rbx, Register rcx, Register rdx, Register tmp1, Register tmp2,
1015                 Register tmp3, Register tmp4);
1016 
1017   void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1018                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1019                 Register rax, Register rcx, Register rdx, Register tmp1,
1020                 Register tmp2, Register tmp3, Register tmp4);
1021   void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1022                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1023                 Register rax, Register rcx, Register rdx, Register tmp1,
1024                 Register tmp2, Register tmp3, Register tmp4);
1025 #else
1026   void fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1027                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1028                 Register rax, Register rcx, Register rdx, Register tmp1);
1029 
1030   void fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1031                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1032                 Register rax, Register rcx, Register rdx, Register tmp);
1033 
1034   void fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,
1035                 XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register rax, Register rcx,
1036                 Register rdx, Register tmp);
1037 
1038   void fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1039                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1040                 Register rax, Register rbx, Register rdx);
1041 
1042   void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1043                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1044                 Register rax, Register rcx, Register rdx, Register tmp);
1045 
1046   void libm_sincos_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1047                         Register edx, Register ebx, Register esi, Register edi,
1048                         Register ebp, Register esp);
1049 
1050   void libm_reduce_pi04l(Register eax, Register ecx, Register edx, Register ebx,
1051                          Register esi, Register edi, Register ebp, Register esp);
1052 
1053   void libm_tancot_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1054                         Register edx, Register ebx, Register esi, Register edi,
1055                         Register ebp, Register esp);
1056 
1057   void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1058                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1059                 Register rax, Register rcx, Register rdx, Register tmp);
1060 #endif
1061 
1062   void increase_precision();
1063   void restore_precision();
1064 
1065 private:
1066 
1067   // these are private because users should be doing movflt/movdbl
1068 
1069   void movss(Address dst, XMMRegister src)     { Assembler::movss(dst, src); }
1070   void movss(XMMRegister dst, XMMRegister src) { Assembler::movss(dst, src); }
1071   void movss(XMMRegister dst, Address src)     { Assembler::movss(dst, src); }
1072   void movss(XMMRegister dst, AddressLiteral src);
1073 
1074   void movlpd(XMMRegister dst, Address src)    {Assembler::movlpd(dst, src); }
1075   void movlpd(XMMRegister dst, AddressLiteral src);
1076 
1077 public:
1078 
1079   void addsd(XMMRegister dst, XMMRegister src)    { Assembler::addsd(dst, src); }
1080   void addsd(XMMRegister dst, Address src)        { Assembler::addsd(dst, src); }
1081   void addsd(XMMRegister dst, AddressLiteral src);
1082 
1083   void addss(XMMRegister dst, XMMRegister src)    { Assembler::addss(dst, src); }
1084   void addss(XMMRegister dst, Address src)        { Assembler::addss(dst, src); }
1085   void addss(XMMRegister dst, AddressLiteral src);
1086 
1087   void addpd(XMMRegister dst, XMMRegister src)    { Assembler::addpd(dst, src); }
1088   void addpd(XMMRegister dst, Address src)        { Assembler::addpd(dst, src); }
1089   void addpd(XMMRegister dst, AddressLiteral src);
1090 
1091   void divsd(XMMRegister dst, XMMRegister src)    { Assembler::divsd(dst, src); }
1092   void divsd(XMMRegister dst, Address src)        { Assembler::divsd(dst, src); }
1093   void divsd(XMMRegister dst, AddressLiteral src);
1094 
1095   void divss(XMMRegister dst, XMMRegister src)    { Assembler::divss(dst, src); }
1096   void divss(XMMRegister dst, Address src)        { Assembler::divss(dst, src); }
1097   void divss(XMMRegister dst, AddressLiteral src);
1098 
1099   // Move Unaligned Double Quadword
1100   void movdqu(Address     dst, XMMRegister src);
1101   void movdqu(XMMRegister dst, Address src);
1102   void movdqu(XMMRegister dst, XMMRegister src);
1103   void movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg = rscratch1);
1104   // AVX Unaligned forms
1105   void vmovdqu(Address     dst, XMMRegister src);
1106   void vmovdqu(XMMRegister dst, Address src);
1107   void vmovdqu(XMMRegister dst, XMMRegister src);
1108   void vmovdqu(XMMRegister dst, AddressLiteral src);
1109   void evmovdquq(XMMRegister dst, Address src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1110   void evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1111   void evmovdquq(Address dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1112   void evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch);
1113 
1114   // Move Aligned Double Quadword
1115   void movdqa(XMMRegister dst, Address src)       { Assembler::movdqa(dst, src); }
1116   void movdqa(XMMRegister dst, XMMRegister src)   { Assembler::movdqa(dst, src); }
1117   void movdqa(XMMRegister dst, AddressLiteral src);
1118 
1119   void movsd(XMMRegister dst, XMMRegister src) { Assembler::movsd(dst, src); }
1120   void movsd(Address dst, XMMRegister src)     { Assembler::movsd(dst, src); }
1121   void movsd(XMMRegister dst, Address src)     { Assembler::movsd(dst, src); }
1122   void movsd(XMMRegister dst, AddressLiteral src);
1123 
1124   void mulpd(XMMRegister dst, XMMRegister src)    { Assembler::mulpd(dst, src); }
1125   void mulpd(XMMRegister dst, Address src)        { Assembler::mulpd(dst, src); }
1126   void mulpd(XMMRegister dst, AddressLiteral src);
1127 
1128   void mulsd(XMMRegister dst, XMMRegister src)    { Assembler::mulsd(dst, src); }
1129   void mulsd(XMMRegister dst, Address src)        { Assembler::mulsd(dst, src); }
1130   void mulsd(XMMRegister dst, AddressLiteral src);
1131 
1132   void mulss(XMMRegister dst, XMMRegister src)    { Assembler::mulss(dst, src); }
1133   void mulss(XMMRegister dst, Address src)        { Assembler::mulss(dst, src); }
1134   void mulss(XMMRegister dst, AddressLiteral src);
1135 
1136   // Carry-Less Multiplication Quadword
1137   void pclmulldq(XMMRegister dst, XMMRegister src) {
1138     // 0x00 - multiply lower 64 bits [0:63]
1139     Assembler::pclmulqdq(dst, src, 0x00);
1140   }
1141   void pclmulhdq(XMMRegister dst, XMMRegister src) {
1142     // 0x11 - multiply upper 64 bits [64:127]
1143     Assembler::pclmulqdq(dst, src, 0x11);
1144   }
1145 
1146   void pcmpeqb(XMMRegister dst, XMMRegister src);
1147   void pcmpeqw(XMMRegister dst, XMMRegister src);
1148 
1149   void pcmpestri(XMMRegister dst, Address src, int imm8);
1150   void pcmpestri(XMMRegister dst, XMMRegister src, int imm8);
1151 
1152   void pmovzxbw(XMMRegister dst, XMMRegister src);
1153   void pmovzxbw(XMMRegister dst, Address src);
1154 
1155   void pmovmskb(Register dst, XMMRegister src);
1156 
1157   void ptest(XMMRegister dst, XMMRegister src);
1158 
1159   void sqrtsd(XMMRegister dst, XMMRegister src)    { Assembler::sqrtsd(dst, src); }
1160   void sqrtsd(XMMRegister dst, Address src)        { Assembler::sqrtsd(dst, src); }
1161   void sqrtsd(XMMRegister dst, AddressLiteral src);
1162 
1163   void sqrtss(XMMRegister dst, XMMRegister src)    { Assembler::sqrtss(dst, src); }
1164   void sqrtss(XMMRegister dst, Address src)        { Assembler::sqrtss(dst, src); }
1165   void sqrtss(XMMRegister dst, AddressLiteral src);
1166 
1167   void subsd(XMMRegister dst, XMMRegister src)    { Assembler::subsd(dst, src); }
1168   void subsd(XMMRegister dst, Address src)        { Assembler::subsd(dst, src); }
1169   void subsd(XMMRegister dst, AddressLiteral src);
1170 
1171   void subss(XMMRegister dst, XMMRegister src)    { Assembler::subss(dst, src); }
1172   void subss(XMMRegister dst, Address src)        { Assembler::subss(dst, src); }
1173   void subss(XMMRegister dst, AddressLiteral src);
1174 
1175   void ucomiss(XMMRegister dst, XMMRegister src) { Assembler::ucomiss(dst, src); }
1176   void ucomiss(XMMRegister dst, Address src)     { Assembler::ucomiss(dst, src); }
1177   void ucomiss(XMMRegister dst, AddressLiteral src);
1178 
1179   void ucomisd(XMMRegister dst, XMMRegister src) { Assembler::ucomisd(dst, src); }
1180   void ucomisd(XMMRegister dst, Address src)     { Assembler::ucomisd(dst, src); }
1181   void ucomisd(XMMRegister dst, AddressLiteral src);
1182 
1183   // Bitwise Logical XOR of Packed Double-Precision Floating-Point Values
1184   void xorpd(XMMRegister dst, XMMRegister src);
1185   void xorpd(XMMRegister dst, Address src)     { Assembler::xorpd(dst, src); }
1186   void xorpd(XMMRegister dst, AddressLiteral src);
1187 
1188   // Bitwise Logical XOR of Packed Single-Precision Floating-Point Values
1189   void xorps(XMMRegister dst, XMMRegister src);
1190   void xorps(XMMRegister dst, Address src)     { Assembler::xorps(dst, src); }
1191   void xorps(XMMRegister dst, AddressLiteral src);
1192 
1193   // Shuffle Bytes
1194   void pshufb(XMMRegister dst, XMMRegister src) { Assembler::pshufb(dst, src); }
1195   void pshufb(XMMRegister dst, Address src)     { Assembler::pshufb(dst, src); }
1196   void pshufb(XMMRegister dst, AddressLiteral src);
1197   // AVX 3-operands instructions
1198 
1199   void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddsd(dst, nds, src); }
1200   void vaddsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddsd(dst, nds, src); }
1201   void vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1202 
1203   void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddss(dst, nds, src); }
1204   void vaddss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddss(dst, nds, src); }
1205   void vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1206 
1207   void vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1208   void vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1209 
1210   void vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1211   void vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1212 
1213   void vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1214   void vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1215 
1216   void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
1217   void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
1218   void vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);
1219 
1220   void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
1221   void vpbroadcastw(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastw(dst, src, vector_len); }
1222 
1223   void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1224 
1225   void vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1226 
1227   void vpmovzxbw(XMMRegister dst, Address src, int vector_len);
1228   void vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::vpmovzxbw(dst, src, vector_len); }
1229 
1230   void vpmovmskb(Register dst, XMMRegister src);
1231 
1232   void vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1233   void vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1234 
1235   void vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1236   void vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1237 
1238   void vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1239   void vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1240 
1241   void vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1242   void vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1243 
1244   void vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1245   void vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1246 
1247   void vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1248   void vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1249 
1250   void vptest(XMMRegister dst, XMMRegister src);
1251 
1252   void punpcklbw(XMMRegister dst, XMMRegister src);
1253   void punpcklbw(XMMRegister dst, Address src) { Assembler::punpcklbw(dst, src); }
1254 
1255   void pshufd(XMMRegister dst, Address src, int mode);
1256   void pshufd(XMMRegister dst, XMMRegister src, int mode) { Assembler::pshufd(dst, src, mode); }
1257 
1258   void pshuflw(XMMRegister dst, XMMRegister src, int mode);
1259   void pshuflw(XMMRegister dst, Address src, int mode) { Assembler::pshuflw(dst, src, mode); }
1260 
1261   void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandpd(dst, nds, src, vector_len); }
1262   void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandpd(dst, nds, src, vector_len); }
1263   void vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);
1264 
1265   void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandps(dst, nds, src, vector_len); }
1266   void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandps(dst, nds, src, vector_len); }
1267   void vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);
1268 
1269   void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivsd(dst, nds, src); }
1270   void vdivsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivsd(dst, nds, src); }
1271   void vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1272 
1273   void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivss(dst, nds, src); }
1274   void vdivss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivss(dst, nds, src); }
1275   void vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1276 
1277   void vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulsd(dst, nds, src); }
1278   void vmulsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulsd(dst, nds, src); }
1279   void vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1280 
1281   void vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulss(dst, nds, src); }
1282   void vmulss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulss(dst, nds, src); }
1283   void vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1284 
1285   void vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubsd(dst, nds, src); }
1286   void vsubsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubsd(dst, nds, src); }
1287   void vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1288 
1289   void vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubss(dst, nds, src); }
1290   void vsubss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubss(dst, nds, src); }
1291   void vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1292 
1293   void vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1294   void vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1295 
1296   // AVX Vector instructions
1297 
1298   void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
1299   void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
1300   void vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);
1301 
1302   void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
1303   void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
1304   void vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len);
1305 
1306   void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1307     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1308       Assembler::vpxor(dst, nds, src, vector_len);
1309     else
1310       Assembler::vxorpd(dst, nds, src, vector_len);
1311   }
1312   void vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
1313     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1314       Assembler::vpxor(dst, nds, src, vector_len);
1315     else
1316       Assembler::vxorpd(dst, nds, src, vector_len);
1317   }
1318 
1319   // Simple version for AVX2 256bit vectors
1320   void vpxor(XMMRegister dst, XMMRegister src) { Assembler::vpxor(dst, dst, src, true); }
1321   void vpxor(XMMRegister dst, Address src) { Assembler::vpxor(dst, dst, src, true); }
1322 
1323   void vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
1324     if (UseAVX &gt; 2) {
1325       Assembler::vinserti32x4(dst, dst, src, imm8);
1326     } else if (UseAVX &gt; 1) {
1327       // vinserti128 is available only in AVX2
1328       Assembler::vinserti128(dst, nds, src, imm8);
1329     } else {
1330       Assembler::vinsertf128(dst, nds, src, imm8);
1331     }
1332   }
1333 
1334   void vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
1335     if (UseAVX &gt; 2) {
1336       Assembler::vinserti32x4(dst, dst, src, imm8);
1337     } else if (UseAVX &gt; 1) {
1338       // vinserti128 is available only in AVX2
1339       Assembler::vinserti128(dst, nds, src, imm8);
1340     } else {
1341       Assembler::vinsertf128(dst, nds, src, imm8);
1342     }
1343   }
1344 
1345   void vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
1346     if (UseAVX &gt; 2) {
1347       Assembler::vextracti32x4(dst, src, imm8);
1348     } else if (UseAVX &gt; 1) {
1349       // vextracti128 is available only in AVX2
1350       Assembler::vextracti128(dst, src, imm8);
1351     } else {
1352       Assembler::vextractf128(dst, src, imm8);
1353     }
1354   }
1355 
1356   void vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
1357     if (UseAVX &gt; 2) {
1358       Assembler::vextracti32x4(dst, src, imm8);
1359     } else if (UseAVX &gt; 1) {
1360       // vextracti128 is available only in AVX2
1361       Assembler::vextracti128(dst, src, imm8);
1362     } else {
1363       Assembler::vextractf128(dst, src, imm8);
1364     }
1365   }
1366 
1367   // 128bit copy to/from high 128 bits of 256bit (YMM) vector registers
1368   void vinserti128_high(XMMRegister dst, XMMRegister src) {
1369     vinserti128(dst, dst, src, 1);
1370   }
1371   void vinserti128_high(XMMRegister dst, Address src) {
1372     vinserti128(dst, dst, src, 1);
1373   }
1374   void vextracti128_high(XMMRegister dst, XMMRegister src) {
1375     vextracti128(dst, src, 1);
1376   }
1377   void vextracti128_high(Address dst, XMMRegister src) {
1378     vextracti128(dst, src, 1);
1379   }
1380 
1381   void vinsertf128_high(XMMRegister dst, XMMRegister src) {
1382     if (UseAVX &gt; 2) {
1383       Assembler::vinsertf32x4(dst, dst, src, 1);
1384     } else {
1385       Assembler::vinsertf128(dst, dst, src, 1);
1386     }
1387   }
1388 
1389   void vinsertf128_high(XMMRegister dst, Address src) {
1390     if (UseAVX &gt; 2) {
1391       Assembler::vinsertf32x4(dst, dst, src, 1);
1392     } else {
1393       Assembler::vinsertf128(dst, dst, src, 1);
1394     }
1395   }
1396 
1397   void vextractf128_high(XMMRegister dst, XMMRegister src) {
1398     if (UseAVX &gt; 2) {
1399       Assembler::vextractf32x4(dst, src, 1);
1400     } else {
1401       Assembler::vextractf128(dst, src, 1);
1402     }
1403   }
1404 
1405   void vextractf128_high(Address dst, XMMRegister src) {
1406     if (UseAVX &gt; 2) {
1407       Assembler::vextractf32x4(dst, src, 1);
1408     } else {
1409       Assembler::vextractf128(dst, src, 1);
1410     }
1411   }
1412 
1413   // 256bit copy to/from high 256 bits of 512bit (ZMM) vector registers
1414   void vinserti64x4_high(XMMRegister dst, XMMRegister src) {
1415     Assembler::vinserti64x4(dst, dst, src, 1);
1416   }
1417   void vinsertf64x4_high(XMMRegister dst, XMMRegister src) {
1418     Assembler::vinsertf64x4(dst, dst, src, 1);
1419   }
1420   void vextracti64x4_high(XMMRegister dst, XMMRegister src) {
1421     Assembler::vextracti64x4(dst, src, 1);
1422   }
1423   void vextractf64x4_high(XMMRegister dst, XMMRegister src) {
1424     Assembler::vextractf64x4(dst, src, 1);
1425   }
1426   void vextractf64x4_high(Address dst, XMMRegister src) {
1427     Assembler::vextractf64x4(dst, src, 1);
1428   }
1429   void vinsertf64x4_high(XMMRegister dst, Address src) {
1430     Assembler::vinsertf64x4(dst, dst, src, 1);
1431   }
1432 
1433   // 128bit copy to/from low 128 bits of 256bit (YMM) vector registers
1434   void vinserti128_low(XMMRegister dst, XMMRegister src) {
1435     vinserti128(dst, dst, src, 0);
1436   }
1437   void vinserti128_low(XMMRegister dst, Address src) {
1438     vinserti128(dst, dst, src, 0);
1439   }
1440   void vextracti128_low(XMMRegister dst, XMMRegister src) {
1441     vextracti128(dst, src, 0);
1442   }
1443   void vextracti128_low(Address dst, XMMRegister src) {
1444     vextracti128(dst, src, 0);
1445   }
1446 
1447   void vinsertf128_low(XMMRegister dst, XMMRegister src) {
1448     if (UseAVX &gt; 2) {
1449       Assembler::vinsertf32x4(dst, dst, src, 0);
1450     } else {
1451       Assembler::vinsertf128(dst, dst, src, 0);
1452     }
1453   }
1454 
1455   void vinsertf128_low(XMMRegister dst, Address src) {
1456     if (UseAVX &gt; 2) {
1457       Assembler::vinsertf32x4(dst, dst, src, 0);
1458     } else {
1459       Assembler::vinsertf128(dst, dst, src, 0);
1460     }
1461   }
1462 
1463   void vextractf128_low(XMMRegister dst, XMMRegister src) {
1464     if (UseAVX &gt; 2) {
1465       Assembler::vextractf32x4(dst, src, 0);
1466     } else {
1467       Assembler::vextractf128(dst, src, 0);
1468     }
1469   }
1470 
1471   void vextractf128_low(Address dst, XMMRegister src) {
1472     if (UseAVX &gt; 2) {
1473       Assembler::vextractf32x4(dst, src, 0);
1474     } else {
1475       Assembler::vextractf128(dst, src, 0);
1476     }
1477   }
1478 
1479   // 256bit copy to/from low 256 bits of 512bit (ZMM) vector registers
1480   void vinserti64x4_low(XMMRegister dst, XMMRegister src) {
1481     Assembler::vinserti64x4(dst, dst, src, 0);
1482   }
1483   void vinsertf64x4_low(XMMRegister dst, XMMRegister src) {
1484     Assembler::vinsertf64x4(dst, dst, src, 0);
1485   }
1486   void vextracti64x4_low(XMMRegister dst, XMMRegister src) {
1487     Assembler::vextracti64x4(dst, src, 0);
1488   }
1489   void vextractf64x4_low(XMMRegister dst, XMMRegister src) {
1490     Assembler::vextractf64x4(dst, src, 0);
1491   }
1492   void vextractf64x4_low(Address dst, XMMRegister src) {
1493     Assembler::vextractf64x4(dst, src, 0);
1494   }
1495   void vinsertf64x4_low(XMMRegister dst, Address src) {
1496     Assembler::vinsertf64x4(dst, dst, src, 0);
1497   }
1498 
1499   // Carry-Less Multiplication Quadword
1500   void vpclmulldq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1501     // 0x00 - multiply lower 64 bits [0:63]
1502     Assembler::vpclmulqdq(dst, nds, src, 0x00);
1503   }
1504   void vpclmulhdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1505     // 0x11 - multiply upper 64 bits [64:127]
1506     Assembler::vpclmulqdq(dst, nds, src, 0x11);
1507   }
1508   void vpclmullqhqdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1509     // 0x10 - multiply nds[0:63] and src[64:127]
1510     Assembler::vpclmulqdq(dst, nds, src, 0x10);
1511   }
1512   void vpclmulhqlqdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1513     //0x01 - multiply nds[64:127] and src[0:63]
1514     Assembler::vpclmulqdq(dst, nds, src, 0x01);
1515   }
1516 
1517   void evpclmulldq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1518     // 0x00 - multiply lower 64 bits [0:63]
1519     Assembler::evpclmulqdq(dst, nds, src, 0x00, vector_len);
1520   }
1521   void evpclmulhdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1522     // 0x11 - multiply upper 64 bits [64:127]
1523     Assembler::evpclmulqdq(dst, nds, src, 0x11, vector_len);
1524   }
1525 
1526   // Data
1527 
1528   void cmov32( Condition cc, Register dst, Address  src);
1529   void cmov32( Condition cc, Register dst, Register src);
1530 
1531   void cmov(   Condition cc, Register dst, Register src) { cmovptr(cc, dst, src); }
1532 
1533   void cmovptr(Condition cc, Register dst, Address  src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmov32(cc, dst, src)); }
1534   void cmovptr(Condition cc, Register dst, Register src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmov32(cc, dst, src)); }
1535 
1536   void movoop(Register dst, jobject obj);
1537   void movoop(Address dst, jobject obj);
1538 
1539   void mov_metadata(Register dst, Metadata* obj);
1540   void mov_metadata(Address dst, Metadata* obj);
1541 
1542   void movptr(ArrayAddress dst, Register src);
1543   // can this do an lea?
1544   void movptr(Register dst, ArrayAddress src);
1545 
1546   void movptr(Register dst, Address src);
1547 
1548 #ifdef _LP64
1549   void movptr(Register dst, AddressLiteral src, Register scratch=rscratch1);
1550 #else
1551   void movptr(Register dst, AddressLiteral src, Register scratch=noreg); // Scratch reg is ignored in 32-bit
1552 #endif
1553 
1554   void movptr(Register dst, intptr_t src);
1555   void movptr(Register dst, Register src);
1556   void movptr(Address dst, intptr_t src);
1557 
1558   void movptr(Address dst, Register src);
1559 
1560   void movptr(Register dst, RegisterOrConstant src) {
1561     if (src.is_constant()) movptr(dst, src.as_constant());
1562     else                   movptr(dst, src.as_register());
1563   }
1564 
1565 #ifdef _LP64
1566   // Generally the next two are only used for moving NULL
1567   // Although there are situations in initializing the mark word where
1568   // they could be used. They are dangerous.
1569 
1570   // They only exist on LP64 so that int32_t and intptr_t are not the same
1571   // and we have ambiguous declarations.
1572 
1573   void movptr(Address dst, int32_t imm32);
1574   void movptr(Register dst, int32_t imm32);
1575 #endif // _LP64
1576 
1577   // to avoid hiding movl
1578   void mov32(AddressLiteral dst, Register src);
1579   void mov32(Register dst, AddressLiteral src);
1580 
1581   // to avoid hiding movb
1582   void movbyte(ArrayAddress dst, int src);
1583 
1584   // Import other mov() methods from the parent class or else
1585   // they will be hidden by the following overriding declaration.
1586   using Assembler::movdl;
1587   using Assembler::movq;
1588   void movdl(XMMRegister dst, AddressLiteral src);
1589   void movq(XMMRegister dst, AddressLiteral src);
1590 
1591   // Can push value or effective address
1592   void pushptr(AddressLiteral src);
1593 
1594   void pushptr(Address src) { LP64_ONLY(pushq(src)) NOT_LP64(pushl(src)); }
1595   void popptr(Address src) { LP64_ONLY(popq(src)) NOT_LP64(popl(src)); }
1596 
1597   void pushoop(jobject obj);
1598   void pushklass(Metadata* obj);
1599 
1600   // sign extend as need a l to ptr sized element
1601   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1602   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1603 
1604   // C2 compiled method&#39;s prolog code.
1605   void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub);
1606 
1607   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39;;
1608   // if &#39;is_large&#39; is set, do not try to produce short loop
1609   void clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp, bool is_large);
1610 
1611   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
1612   void xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp);
1613 
1614 #ifdef COMPILER2
1615   void string_indexof_char(Register str1, Register cnt1, Register ch, Register result,
1616                            XMMRegister vec1, XMMRegister vec2, XMMRegister vec3, Register tmp);
1617 
1618   // IndexOf strings.
1619   // Small strings are loaded through stack if they cross page boundary.
1620   void string_indexof(Register str1, Register str2,
1621                       Register cnt1, Register cnt2,
1622                       int int_cnt2,  Register result,
1623                       XMMRegister vec, Register tmp,
1624                       int ae);
1625 
1626   // IndexOf for constant substrings with size &gt;= 8 elements
1627   // which don&#39;t need to be loaded through stack.
1628   void string_indexofC8(Register str1, Register str2,
1629                       Register cnt1, Register cnt2,
1630                       int int_cnt2,  Register result,
1631                       XMMRegister vec, Register tmp,
1632                       int ae);
1633 
1634     // Smallest code: we don&#39;t need to load through stack,
1635     // check string tail.
1636 
1637   // helper function for string_compare
1638   void load_next_elements(Register elem1, Register elem2, Register str1, Register str2,
1639                           Address::ScaleFactor scale, Address::ScaleFactor scale1,
1640                           Address::ScaleFactor scale2, Register index, int ae);
1641   // Compare strings.
1642   void string_compare(Register str1, Register str2,
1643                       Register cnt1, Register cnt2, Register result,
1644                       XMMRegister vec1, int ae);
1645 
1646   // Search for Non-ASCII character (Negative byte value) in a byte array,
1647   // return true if it has any and false otherwise.
1648   void has_negatives(Register ary1, Register len,
1649                      Register result, Register tmp1,
1650                      XMMRegister vec1, XMMRegister vec2);
1651 
1652   // Compare char[] or byte[] arrays.
1653   void arrays_equals(bool is_array_equ, Register ary1, Register ary2,
1654                      Register limit, Register result, Register chr,
1655                      XMMRegister vec1, XMMRegister vec2, bool is_char);
1656 
1657 #endif
1658 
1659   // Fill primitive arrays
1660   void generate_fill(BasicType t, bool aligned,
1661                      Register to, Register value, Register count,
1662                      Register rtmp, XMMRegister xtmp);
1663 
1664   void encode_iso_array(Register src, Register dst, Register len,
1665                         XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1666                         XMMRegister tmp4, Register tmp5, Register result);
1667 
1668 #ifdef _LP64
1669   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2);
1670   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1671                              Register y, Register y_idx, Register z,
1672                              Register carry, Register product,
1673                              Register idx, Register kdx);
1674   void multiply_add_128_x_128(Register x_xstart, Register y, Register z,
1675                               Register yz_idx, Register idx,
1676                               Register carry, Register product, int offset);
1677   void multiply_128_x_128_bmi2_loop(Register y, Register z,
1678                                     Register carry, Register carry2,
1679                                     Register idx, Register jdx,
1680                                     Register yz_idx1, Register yz_idx2,
1681                                     Register tmp, Register tmp3, Register tmp4);
1682   void multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
1683                                Register yz_idx, Register idx, Register jdx,
1684                                Register carry, Register product,
1685                                Register carry2);
1686   void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
1687                        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5);
1688   void square_rshift(Register x, Register len, Register z, Register tmp1, Register tmp3,
1689                      Register tmp4, Register tmp5, Register rdxReg, Register raxReg);
1690   void multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry,
1691                             Register tmp2);
1692   void multiply_add_64(Register sum, Register op1, Register op2, Register carry,
1693                        Register rdxReg, Register raxReg);
1694   void add_one_64(Register z, Register zlen, Register carry, Register tmp1);
1695   void lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2,
1696                        Register tmp3, Register tmp4);
1697   void square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2,
1698                      Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg);
1699 
1700   void mul_add_128_x_32_loop(Register out, Register in, Register offset, Register len, Register tmp1,
1701                Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg,
1702                Register raxReg);
1703   void mul_add(Register out, Register in, Register offset, Register len, Register k, Register tmp1,
1704                Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg,
1705                Register raxReg);
1706   void vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
1707                            Register result, Register tmp1, Register tmp2,
1708                            XMMRegister vec1, XMMRegister vec2, XMMRegister vec3);
1709 #endif
1710 
1711   // CRC32 code for java.util.zip.CRC32::updateBytes() intrinsic.
1712   void update_byte_crc32(Register crc, Register val, Register table);
1713   void kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp);
1714   // CRC32C code for java.util.zip.CRC32C::updateBytes() intrinsic
1715   // Note on a naming convention:
1716   // Prefix w = register only used on a Westmere+ architecture
1717   // Prefix n = register only used on a Nehalem architecture
1718 #ifdef _LP64
1719   void crc32c_ipl_alg4(Register in_out, uint32_t n,
1720                        Register tmp1, Register tmp2, Register tmp3);
1721 #else
1722   void crc32c_ipl_alg4(Register in_out, uint32_t n,
1723                        Register tmp1, Register tmp2, Register tmp3,
1724                        XMMRegister xtmp1, XMMRegister xtmp2);
1725 #endif
1726   void crc32c_pclmulqdq(XMMRegister w_xtmp1,
1727                         Register in_out,
1728                         uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
1729                         XMMRegister w_xtmp2,
1730                         Register tmp1,
1731                         Register n_tmp2, Register n_tmp3);
1732   void crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
1733                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1734                        Register tmp1, Register tmp2,
1735                        Register n_tmp3);
1736   void crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
1737                          Register in_out1, Register in_out2, Register in_out3,
1738                          Register tmp1, Register tmp2, Register tmp3,
1739                          XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1740                          Register tmp4, Register tmp5,
1741                          Register n_tmp6);
1742   void crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
1743                             Register tmp1, Register tmp2, Register tmp3,
1744                             Register tmp4, Register tmp5, Register tmp6,
1745                             XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1746                             bool is_pclmulqdq_supported);
1747   // Fold 128-bit data chunk
1748   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1749   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf);
1750   // Fold 8-bit data
1751   void fold_8bit_crc32(Register crc, Register table, Register tmp);
1752   void fold_8bit_crc32(XMMRegister crc, Register table, XMMRegister xtmp, Register tmp);
1753   void fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1754 
1755   // Compress char[] array to byte[].
1756   void char_array_compress(Register src, Register dst, Register len,
1757                            XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1758                            XMMRegister tmp4, Register tmp5, Register result);
1759 
1760   // Inflate byte[] array to char[].
1761   void byte_array_inflate(Register src, Register dst, Register len,
1762                           XMMRegister tmp1, Register tmp2);
1763 
1764 };
1765 
1766 /**
1767  * class SkipIfEqual:
1768  *
1769  * Instantiating this class will result in assembly code being output that will
1770  * jump around any code emitted between the creation of the instance and it&#39;s
1771  * automatic destruction at the end of a scope block, depending on the value of
1772  * the flag passed to the constructor, which will be checked at run-time.
1773  */
1774 class SkipIfEqual {
1775  private:
1776   MacroAssembler* _masm;
1777   Label _label;
1778 
1779  public:
1780    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1781    ~SkipIfEqual();
1782 };
1783 
1784 #endif // CPU_X86_MACROASSEMBLER_X86_HPP
    </pre>
  </body>
</html>
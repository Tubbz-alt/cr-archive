<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/assembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_CodeStubs_x86.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/assembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -24,11 +24,12 @@</span>
  
  #ifndef CPU_X86_ASSEMBLER_X86_HPP
  #define CPU_X86_ASSEMBLER_X86_HPP
  
  #include &quot;asm/register.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;vm_version_x86.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;runtime/vm_version.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  class BiasedLockingCounters;
  
  // Contains all the definitions needed for x86 assembly code generation.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -628,10 +629,21 @@</span>
      nlt = 5,
      nle = 6,
      _true = 7
    };
  
<span class="udiff-line-added">+   //---&lt;  calculate length of instruction  &gt;---</span>
<span class="udiff-line-added">+   // As instruction size can&#39;t be found out easily on x86/x64,</span>
<span class="udiff-line-added">+   // we just use &#39;4&#39; for len and maxlen.</span>
<span class="udiff-line-added">+   // instruction must start at passed address</span>
<span class="udiff-line-added">+   static unsigned int instr_len(unsigned char *instr) { return 4; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   //---&lt;  longest instructions  &gt;---</span>
<span class="udiff-line-added">+   // Max instruction length is not specified in architecture documentation.</span>
<span class="udiff-line-added">+   // We could use a &quot;safe enough&quot; estimate (15), but just default to</span>
<span class="udiff-line-added">+   // instruction length guess from above.</span>
<span class="udiff-line-added">+   static unsigned int instr_maxlen() { return 4; }</span>
  
    // NOTE: The general philopsophy of the declarations here is that 64bit versions
    // of instructions are freely declared without the need for wrapping them an ifdef.
    // (Some dangerous instructions are ifdef&#39;s out of inappropriate jvm&#39;s.)
    // In the .cpp file the implementations are wrapped so that they are dropped out
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -955,10 +967,13 @@</span>
    void aesdeclast(XMMRegister dst, XMMRegister src);
    void aesenc(XMMRegister dst, Address src);
    void aesenc(XMMRegister dst, XMMRegister src);
    void aesenclast(XMMRegister dst, Address src);
    void aesenclast(XMMRegister dst, XMMRegister src);
<span class="udiff-line-added">+   // Vector AES instructions</span>
<span class="udiff-line-added">+   void vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);</span>
<span class="udiff-line-added">+   void vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);</span>
    void vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
    void vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
  
    void andl(Address  dst, int32_t imm32);
    void andl(Register dst, int32_t imm32);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1012,10 +1027,12 @@</span>
    void cdqq();
  
    void cld();
  
    void clflush(Address adr);
<span class="udiff-line-added">+   void clflushopt(Address adr);</span>
<span class="udiff-line-added">+   void clwb(Address adr);</span>
  
    void cmovl(Condition cc, Register dst, Register src);
    void cmovl(Condition cc, Register dst, Address src);
  
    void cmovq(Condition cc, Register dst, Register src);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1092,28 +1109,39 @@</span>
    void cvtss2sd(XMMRegister dst, Address src);
  
    // Convert with Truncation Scalar Double-Precision Floating-Point Value to Doubleword Integer
    void cvttsd2sil(Register dst, Address src);
    void cvttsd2sil(Register dst, XMMRegister src);
<span class="udiff-line-added">+   void cvttsd2siq(Register dst, Address src);</span>
    void cvttsd2siq(Register dst, XMMRegister src);
  
    // Convert with Truncation Scalar Single-Precision Floating-Point Value to Doubleword Integer
    void cvttss2sil(Register dst, XMMRegister src);
    void cvttss2siq(Register dst, XMMRegister src);
  
    void cvttpd2dq(XMMRegister dst, XMMRegister src);
  
<span class="udiff-line-added">+   //Abs of packed Integer values</span>
<span class="udiff-line-added">+   void pabsb(XMMRegister dst, XMMRegister src);</span>
<span class="udiff-line-added">+   void pabsw(XMMRegister dst, XMMRegister src);</span>
<span class="udiff-line-added">+   void pabsd(XMMRegister dst, XMMRegister src);</span>
<span class="udiff-line-added">+   void vpabsb(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="udiff-line-added">+   void vpabsw(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="udiff-line-added">+   void vpabsd(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="udiff-line-added">+   void evpabsq(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="udiff-line-added">+ </span>
    // Divide Scalar Double-Precision Floating-Point Values
    void divsd(XMMRegister dst, Address src);
    void divsd(XMMRegister dst, XMMRegister src);
  
    // Divide Scalar Single-Precision Floating-Point Values
    void divss(XMMRegister dst, Address src);
    void divss(XMMRegister dst, XMMRegister src);
  
    void emms();
  
<span class="udiff-line-added">+ #ifndef _LP64</span>
    void fabs();
  
    void fadd(int i);
  
    void fadd_d(Address src);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1243,21 +1271,22 @@</span>
  
    void fwait();
  
    void fxch(int i = 1);
  
<span class="udiff-line-added">+   void fyl2x();</span>
<span class="udiff-line-added">+   void frndint();</span>
<span class="udiff-line-added">+   void f2xm1();</span>
<span class="udiff-line-added">+   void fldl2e();</span>
<span class="udiff-line-added">+ #endif // !_LP64</span>
<span class="udiff-line-added">+ </span>
    void fxrstor(Address src);
    void xrstor(Address src);
  
    void fxsave(Address dst);
    void xsave(Address dst);
  
<span class="udiff-line-removed">-   void fyl2x();</span>
<span class="udiff-line-removed">-   void frndint();</span>
<span class="udiff-line-removed">-   void f2xm1();</span>
<span class="udiff-line-removed">-   void fldl2e();</span>
<span class="udiff-line-removed">- </span>
    void hlt();
  
    void idivl(Register src);
    void divl(Register src); // Unsigned division
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1379,10 +1408,11 @@</span>
        addl(Address(rsp, offset), 0);// Assert the lock# signal here
      }
    }
  
    void mfence();
<span class="udiff-line-added">+   void sfence();</span>
  
    // Moves
  
    void mov64(Register dst, int64_t imm64);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1564,10 +1594,13 @@</span>
  
    void notl(Register dst);
  
  #ifdef _LP64
    void notq(Register dst);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void btsq(Address dst, int imm8);</span>
<span class="udiff-line-added">+   void btrq(Address dst, int imm8);</span>
  #endif
  
    void orl(Address dst, int32_t imm32);
    void orl(Register dst, int32_t imm32);
    void orl(Register dst, Address src);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1587,10 +1620,11 @@</span>
    void vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
  
    // Pemutation of 64bit words
    void vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len);
    void vpermq(XMMRegister dst, XMMRegister src, int imm8);
<span class="udiff-line-added">+   void vpermq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);</span>
    void vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8);
    void vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8);
    void evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
  
    void pause();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1666,10 +1700,14 @@</span>
  
    void vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len);
  
    void evpmovdb(Address dst, XMMRegister src, int vector_len);
  
<span class="udiff-line-added">+   // Sign extend moves</span>
<span class="udiff-line-added">+   void pmovsxbw(XMMRegister dst, XMMRegister src);</span>
<span class="udiff-line-added">+   void vpmovsxbw(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="udiff-line-added">+ </span>
    // Multiply add
    void pmaddwd(XMMRegister dst, XMMRegister src);
    void vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
    // Multiply add accumulate
    void evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1802,19 +1840,19 @@</span>
    void sha256msg1(XMMRegister dst, XMMRegister src);
    void sha256msg2(XMMRegister dst, XMMRegister src);
  
    void shldl(Register dst, Register src);
    void shldl(Register dst, Register src, int8_t imm8);
<span class="udiff-line-added">+   void shrdl(Register dst, Register src);</span>
<span class="udiff-line-added">+   void shrdl(Register dst, Register src, int8_t imm8);</span>
  
    void shll(Register dst, int imm8);
    void shll(Register dst);
  
    void shlq(Register dst, int imm8);
    void shlq(Register dst);
  
<span class="udiff-line-removed">-   void shrdl(Register dst, Register src);</span>
<span class="udiff-line-removed">- </span>
    void shrl(Register dst, int imm8);
    void shrl(Register dst);
  
    void shrq(Register dst, int imm8);
    void shrq(Register dst);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1823,10 +1861,13 @@</span>
  
    // Compute Square Root of Scalar Double-Precision Floating-Point Value
    void sqrtsd(XMMRegister dst, Address src);
    void sqrtsd(XMMRegister dst, XMMRegister src);
  
<span class="udiff-line-added">+   void roundsd(XMMRegister dst, Address src, int32_t rmode);</span>
<span class="udiff-line-added">+   void roundsd(XMMRegister dst, XMMRegister src, int32_t rmode);</span>
<span class="udiff-line-added">+ </span>
    // Compute Square Root of Scalar Single-Precision Floating-Point Value
    void sqrtss(XMMRegister dst, Address src);
    void sqrtss(XMMRegister dst, XMMRegister src);
  
    void std();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1987,10 +2028,16 @@</span>
    void vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len);
    void vsqrtpd(XMMRegister dst, Address src, int vector_len);
    void vsqrtps(XMMRegister dst, XMMRegister src, int vector_len);
    void vsqrtps(XMMRegister dst, Address src, int vector_len);
  
<span class="udiff-line-added">+   // Round Packed Double precision value.</span>
<span class="udiff-line-added">+   void vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len);</span>
<span class="udiff-line-added">+   void vroundpd(XMMRegister dst, Address src, int32_t rmode, int vector_len);</span>
<span class="udiff-line-added">+   void vrndscalepd(XMMRegister dst,  XMMRegister src,  int32_t rmode, int vector_len);</span>
<span class="udiff-line-added">+   void vrndscalepd(XMMRegister dst, Address src, int32_t rmode, int vector_len);</span>
<span class="udiff-line-added">+ </span>
    // Bitwise Logical AND of Packed Floating-Point Values
    void andpd(XMMRegister dst, XMMRegister src);
    void andps(XMMRegister dst, XMMRegister src);
    void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
    void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2092,10 +2139,15 @@</span>
    void psrad(XMMRegister dst, XMMRegister shift);
    void vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
    void vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len);
    void vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
    void vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
<span class="udiff-line-added">+   void evpsraq(XMMRegister dst, XMMRegister src, int shift, int vector_len);</span>
<span class="udiff-line-added">+   void evpsraq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);</span>
<span class="udiff-line-added">+   void vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);</span>
  
    // And packed integers
    void pand(XMMRegister dst, XMMRegister src);
    void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
    void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2164,14 +2216,14 @@</span>
  
    void evbroadcasti64x2(XMMRegister dst, XMMRegister src, int vector_len);
    void evbroadcasti64x2(XMMRegister dst, Address src, int vector_len);
  
    // scalar single/double precision replicate
<span class="udiff-line-modified-removed">-   void vpbroadcastss(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="udiff-line-modified-removed">-   void vpbroadcastss(XMMRegister dst, Address src, int vector_len);</span>
<span class="udiff-line-modified-removed">-   void vpbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="udiff-line-modified-removed">-   void vpbroadcastsd(XMMRegister dst, Address src, int vector_len);</span>
<span class="udiff-line-modified-added">+   void vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="udiff-line-modified-added">+   void vbroadcastss(XMMRegister dst, Address src, int vector_len);</span>
<span class="udiff-line-modified-added">+   void vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="udiff-line-modified-added">+   void vbroadcastsd(XMMRegister dst, Address src, int vector_len);</span>
  
    // gpr sourced byte/word/dword/qword replicate
    void evpbroadcastb(XMMRegister dst, Register src, int vector_len);
    void evpbroadcastw(XMMRegister dst, Register src, int vector_len);
    void evpbroadcastd(XMMRegister dst, Register src, int vector_len);
</pre>
<center><a href="assembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_CodeStubs_x86.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/nativeInst_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nativeInst_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="rdtsc_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/nativeInst_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
344     instruction_code_reg2mem            = 0x89,
345     instruction_code_mem2reg            = 0x8b,
346     instruction_code_reg2memb           = 0x88,
347     instruction_code_mem2regb           = 0x8a,
348     instruction_code_float_s            = 0xd9,
349     instruction_code_float_d            = 0xdd,
350     instruction_code_long_volatile      = 0xdf,
351     instruction_code_xmm_ss_prefix      = 0xf3,
352     instruction_code_xmm_sd_prefix      = 0xf2,
353     instruction_code_xmm_code           = 0x0f,
354     instruction_code_xmm_load           = 0x10,
355     instruction_code_xmm_store          = 0x11,
356     instruction_code_xmm_lpd            = 0x12,
357 
358     instruction_code_lea                = 0x8d,
359 
360     instruction_VEX_prefix_2bytes       = Assembler::VEX_2bytes,
361     instruction_VEX_prefix_3bytes       = Assembler::VEX_3bytes,
362     instruction_EVEX_prefix_4bytes      = Assembler::EVEX_4bytes,
363 
<span class="line-removed">364     instruction_size                    = 4,</span>
365     instruction_offset                  = 0,
366     data_offset                         = 2,
367     next_instruction_offset             = 4
368   };
369 
370   // helper
371   int instruction_start() const;
372 
<span class="line-modified">373   address instruction_address() const;</span>


374 
<span class="line-modified">375   address next_instruction_address() const;</span>


376 
<span class="line-modified">377   int   offset() const;</span>


378 
<span class="line-modified">379   void  set_offset(int x);</span>


380 
<span class="line-modified">381   void  add_offset_in_bytes(int add_offset)     { set_offset ( ( offset() + add_offset ) ); }</span>



382 
383   void verify();
384   void print ();
385 
386   // unit test stuff
387   static void test() {}
388 
389  private:

390   inline friend NativeMovRegMem* nativeMovRegMem_at (address address);
391 };
392 
393 inline NativeMovRegMem* nativeMovRegMem_at (address address) {
394   NativeMovRegMem* test = (NativeMovRegMem*)(address - NativeMovRegMem::instruction_offset);
395 #ifdef ASSERT
396   test-&gt;verify();
397 #endif
398   return test;
399 }
400 
401 
402 // An interface for accessing/manipulating native leal instruction of form:
403 //        leal reg, [reg + offset]
404 
405 class NativeLoadAddress: public NativeMovRegMem {
406 #ifdef AMD64
407   static const bool has_rex = true;
408   static const int rex_size = 1;
409 #else
</pre>
</td>
<td>
<hr />
<pre>
344     instruction_code_reg2mem            = 0x89,
345     instruction_code_mem2reg            = 0x8b,
346     instruction_code_reg2memb           = 0x88,
347     instruction_code_mem2regb           = 0x8a,
348     instruction_code_float_s            = 0xd9,
349     instruction_code_float_d            = 0xdd,
350     instruction_code_long_volatile      = 0xdf,
351     instruction_code_xmm_ss_prefix      = 0xf3,
352     instruction_code_xmm_sd_prefix      = 0xf2,
353     instruction_code_xmm_code           = 0x0f,
354     instruction_code_xmm_load           = 0x10,
355     instruction_code_xmm_store          = 0x11,
356     instruction_code_xmm_lpd            = 0x12,
357 
358     instruction_code_lea                = 0x8d,
359 
360     instruction_VEX_prefix_2bytes       = Assembler::VEX_2bytes,
361     instruction_VEX_prefix_3bytes       = Assembler::VEX_3bytes,
362     instruction_EVEX_prefix_4bytes      = Assembler::EVEX_4bytes,
363 

364     instruction_offset                  = 0,
365     data_offset                         = 2,
366     next_instruction_offset             = 4
367   };
368 
369   // helper
370   int instruction_start() const;
371 
<span class="line-modified">372   address instruction_address() const {</span>
<span class="line-added">373     return addr_at(instruction_start());</span>
<span class="line-added">374   }</span>
375 
<span class="line-modified">376   int num_bytes_to_end_of_patch() const {</span>
<span class="line-added">377     return patch_offset() + sizeof(jint);</span>
<span class="line-added">378   }</span>
379 
<span class="line-modified">380   int offset() const {</span>
<span class="line-added">381     return int_at(patch_offset());</span>
<span class="line-added">382   }</span>
383 
<span class="line-modified">384   void set_offset(int x) {</span>
<span class="line-added">385     set_int_at(patch_offset(), x);</span>
<span class="line-added">386   }</span>
387 
<span class="line-modified">388   void add_offset_in_bytes(int add_offset) {</span>
<span class="line-added">389     int patch_off = patch_offset();</span>
<span class="line-added">390     set_int_at(patch_off, int_at(patch_off) + add_offset);</span>
<span class="line-added">391   }</span>
392 
393   void verify();
394   void print ();
395 
396   // unit test stuff
397   static void test() {}
398 
399  private:
<span class="line-added">400   int patch_offset() const;</span>
401   inline friend NativeMovRegMem* nativeMovRegMem_at (address address);
402 };
403 
404 inline NativeMovRegMem* nativeMovRegMem_at (address address) {
405   NativeMovRegMem* test = (NativeMovRegMem*)(address - NativeMovRegMem::instruction_offset);
406 #ifdef ASSERT
407   test-&gt;verify();
408 #endif
409   return test;
410 }
411 
412 
413 // An interface for accessing/manipulating native leal instruction of form:
414 //        leal reg, [reg + offset]
415 
416 class NativeLoadAddress: public NativeMovRegMem {
417 #ifdef AMD64
418   static const bool has_rex = true;
419   static const int rex_size = 1;
420 #else
</pre>
</td>
</tr>
</table>
<center><a href="nativeInst_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="rdtsc_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
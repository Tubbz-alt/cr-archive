<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/jvmciCodeInstaller_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jniFastGetField_x86_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/jvmciCodeInstaller_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -35,11 +35,11 @@</span>
  #include &quot;asm/register.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/vmreg.hpp&quot;
  #include &quot;vmreg_x86.inline.hpp&quot;
  
<span class="udiff-line-modified-removed">- jint CodeInstaller::pd_next_offset(NativeInstruction* inst, jint pc_offset, Handle method, TRAPS) {</span>
<span class="udiff-line-modified-added">+ jint CodeInstaller::pd_next_offset(NativeInstruction* inst, jint pc_offset, JVMCIObject method, JVMCI_TRAPS) {</span>
    if (inst-&gt;is_call() || inst-&gt;is_jump()) {
      assert(NativeCall::instruction_size == (int)NativeJump::instruction_size, &quot;unexpected size&quot;);
      return (pc_offset + NativeCall::instruction_size);
    } else if (inst-&gt;is_mov_literal64()) {
      // mov+call instruction pair
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -52,25 +52,26 @@</span>
      assert(call[0] == 0xFF, &quot;expected call&quot;);
      offset += 2; /* opcode byte + modrm byte */
      return (offset);
    } else if (inst-&gt;is_call_reg()) {
      // the inlined vtable stub contains a &quot;call register&quot; instruction
<span class="udiff-line-modified-removed">-     assert(method.not_null(), &quot;only valid for virtual calls&quot;);</span>
<span class="udiff-line-modified-added">+     assert(method.is_non_null(), &quot;only valid for virtual calls&quot;);</span>
      return (pc_offset + ((NativeCallReg *) inst)-&gt;next_instruction_offset());
    } else if (inst-&gt;is_cond_jump()) {
      address pc = (address) (inst);
      return pc_offset + (jint) (Assembler::locate_next_instruction(pc) - pc);
    } else {
      JVMCI_ERROR_0(&quot;unsupported type of instruction for call site&quot;);
    }
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::pd_patch_OopConstant(int pc_offset, Handle constant, TRAPS) {</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::pd_patch_OopConstant(int pc_offset, JVMCIObject constant, JVMCI_TRAPS) {</span>
    address pc = _instructions-&gt;start() + pc_offset;
<span class="udiff-line-modified-removed">-   Handle obj(THREAD, HotSpotObjectConstantImpl::object(constant));</span>
<span class="udiff-line-modified-added">+   Handle obj = jvmci_env()-&gt;asConstant(constant, JVMCI_CHECK);</span>
<span class="udiff-line-added">+   Thread* THREAD = Thread::current();</span>
    jobject value = JNIHandles::make_local(obj());
<span class="udiff-line-modified-removed">-   if (HotSpotObjectConstantImpl::compressed(constant)) {</span>
<span class="udiff-line-modified-added">+   if (jvmci_env()-&gt;get_HotSpotObjectConstantImpl_compressed(constant)) {</span>
  #ifdef _LP64
      address operand = Assembler::locate_operand(pc, Assembler::narrow_oop_operand);
      int oop_index = _oop_recorder-&gt;find_index(value);
      _instructions-&gt;relocate(pc, oop_Relocation::spec(oop_index), Assembler::narrow_oop_operand);
      TRACE_jvmci_3(&quot;relocating (narrow oop constant) at &quot; PTR_FORMAT &quot;/&quot; PTR_FORMAT, p2i(pc), p2i(operand));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -83,28 +84,28 @@</span>
      _instructions-&gt;relocate(pc, oop_Relocation::spec_for_immediate(), Assembler::imm_operand);
      TRACE_jvmci_3(&quot;relocating (oop constant) at &quot; PTR_FORMAT &quot;/&quot; PTR_FORMAT, p2i(pc), p2i(operand));
    }
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::pd_patch_MetaspaceConstant(int pc_offset, Handle constant, TRAPS) {</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::pd_patch_MetaspaceConstant(int pc_offset, JVMCIObject constant, JVMCI_TRAPS) {</span>
    address pc = _instructions-&gt;start() + pc_offset;
<span class="udiff-line-modified-removed">-   if (HotSpotMetaspaceConstantImpl::compressed(constant)) {</span>
<span class="udiff-line-modified-added">+   if (jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant)) {</span>
  #ifdef _LP64
      address operand = Assembler::locate_operand(pc, Assembler::narrow_oop_operand);
<span class="udiff-line-modified-removed">-     *((narrowKlass*) operand) = record_narrow_metadata_reference(_instructions, operand, constant, CHECK);</span>
<span class="udiff-line-modified-added">+     *((narrowKlass*) operand) = record_narrow_metadata_reference(_instructions, operand, constant, JVMCI_CHECK);</span>
      TRACE_jvmci_3(&quot;relocating (narrow metaspace constant) at &quot; PTR_FORMAT &quot;/&quot; PTR_FORMAT, p2i(pc), p2i(operand));
  #else
      JVMCI_ERROR(&quot;compressed Klass* on 32bit&quot;);
  #endif
    } else {
      address operand = Assembler::locate_operand(pc, Assembler::imm_operand);
<span class="udiff-line-modified-removed">-     *((void**) operand) = record_metadata_reference(_instructions, operand, constant, CHECK);</span>
<span class="udiff-line-modified-added">+     *((void**) operand) = record_metadata_reference(_instructions, operand, constant, JVMCI_CHECK);</span>
      TRACE_jvmci_3(&quot;relocating (metaspace constant) at &quot; PTR_FORMAT &quot;/&quot; PTR_FORMAT, p2i(pc), p2i(operand));
    }
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::pd_patch_DataSectionReference(int pc_offset, int data_offset, TRAPS) {</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::pd_patch_DataSectionReference(int pc_offset, int data_offset, JVMCI_TRAPS) {</span>
    address pc = _instructions-&gt;start() + pc_offset;
  
    address operand = Assembler::locate_operand(pc, Assembler::disp32_operand);
    address next_instruction = Assembler::locate_next_instruction(pc);
    address dest = _constants-&gt;start() + data_offset;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -115,11 +116,11 @@</span>
  
    _instructions-&gt;relocate(pc, section_word_Relocation::spec((address) dest, CodeBuffer::SECT_CONSTS), Assembler::disp32_operand);
    TRACE_jvmci_3(&quot;relocating at &quot; PTR_FORMAT &quot;/&quot; PTR_FORMAT &quot; with destination at &quot; PTR_FORMAT &quot; (%d)&quot;, p2i(pc), p2i(operand), p2i(dest), data_offset);
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::pd_relocate_ForeignCall(NativeInstruction* inst, jlong foreign_call_destination, TRAPS) {</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::pd_relocate_ForeignCall(NativeInstruction* inst, jlong foreign_call_destination, JVMCI_TRAPS) {</span>
    address pc = (address) inst;
    if (inst-&gt;is_call()) {
      // NOTE: for call without a mov, the offset must fit a 32-bit immediate
      //       see also CompilerToVM.getMaxCallTargetOffset()
      NativeCall* call = nativeCall_at(pc);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -143,16 +144,16 @@</span>
    }
  
    TRACE_jvmci_3(&quot;relocating (foreign call)  at &quot; PTR_FORMAT, p2i(inst));
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::pd_relocate_JavaMethod(CodeBuffer &amp;, Handle hotspot_method, jint pc_offset, TRAPS) {</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::pd_relocate_JavaMethod(CodeBuffer &amp;, JVMCIObject hotspot_method, jint pc_offset, JVMCI_TRAPS) {</span>
  #ifdef ASSERT
    Method* method = NULL;
    // we need to check, this might also be an unresolved method
<span class="udiff-line-modified-removed">-   if (hotspot_method-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass())) {</span>
<span class="udiff-line-modified-removed">-     method = getMethodFromHotSpotMethod(hotspot_method());</span>
<span class="udiff-line-modified-added">+   if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(hotspot_method)) {</span>
<span class="udiff-line-modified-added">+     method = JVMCIENV-&gt;asMethod(hotspot_method);</span>
    }
  #endif
    switch (_next_call_type) {
      case INLINE_INVOKE:
        break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -197,11 +198,11 @@</span>
    intptr_t new_disp = (intptr_t) (os::get_polling_page() + offset) - (intptr_t) ni;
    *disp = (int32_t)new_disp;
  }
  
  
<span class="udiff-line-modified-removed">- void CodeInstaller::pd_relocate_poll(address pc, jint mark, TRAPS) {</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS) {</span>
    switch (mark) {
      case POLL_NEAR: {
        relocate_poll_near(pc);
        _instructions-&gt;relocate(pc, relocInfo::poll_type, Assembler::disp32_operand);
        break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -227,11 +228,11 @@</span>
        break;
    }
  }
  
  // convert JVMCI register indices (as used in oop maps) to HotSpot registers
<span class="udiff-line-modified-removed">- VMReg CodeInstaller::get_hotspot_reg(jint jvmci_reg, TRAPS) {</span>
<span class="udiff-line-modified-added">+ VMReg CodeInstaller::get_hotspot_reg(jint jvmci_reg, JVMCI_TRAPS) {</span>
    if (jvmci_reg &lt; RegisterImpl::number_of_registers) {
      return as_Register(jvmci_reg)-&gt;as_VMReg();
    } else {
      jint floatRegisterNumber = jvmci_reg - RegisterImpl::number_of_registers;
      if (floatRegisterNumber &lt; XMMRegisterImpl::number_of_registers) {
</pre>
<center><a href="jniFastGetField_x86_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
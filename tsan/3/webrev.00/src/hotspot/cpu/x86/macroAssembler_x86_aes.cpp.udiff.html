<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/macroAssembler_x86_aes.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_x86.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86_aes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">- * Copyright (c) 2018, Intel Corporation.</span>
<span class="udiff-line-modified-added">+ * Copyright (c) 2019, Intel Corporation.</span>
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -28,10 +28,467 @@</span>
  #include &quot;asm/assembler.inline.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;macroAssembler_x86.hpp&quot;
  
  #ifdef _LP64
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MacroAssembler::roundEnc(XMMRegister key, int rnum) {</span>
<span class="udiff-line-added">+     for (int xmm_reg_no = 0; xmm_reg_no &lt;=rnum; xmm_reg_no++) {</span>
<span class="udiff-line-added">+       vaesenc(as_XMMRegister(xmm_reg_no), as_XMMRegister(xmm_reg_no), key, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MacroAssembler::lastroundEnc(XMMRegister key, int rnum) {</span>
<span class="udiff-line-added">+     for (int xmm_reg_no = 0; xmm_reg_no &lt;=rnum; xmm_reg_no++) {</span>
<span class="udiff-line-added">+       vaesenclast(as_XMMRegister(xmm_reg_no), as_XMMRegister(xmm_reg_no), key, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MacroAssembler::roundDec(XMMRegister key, int rnum) {</span>
<span class="udiff-line-added">+     for (int xmm_reg_no = 0; xmm_reg_no &lt;=rnum; xmm_reg_no++) {</span>
<span class="udiff-line-added">+       vaesdec(as_XMMRegister(xmm_reg_no), as_XMMRegister(xmm_reg_no), key, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MacroAssembler::lastroundDec(XMMRegister key, int rnum) {</span>
<span class="udiff-line-added">+     for (int xmm_reg_no = 0; xmm_reg_no &lt;=rnum; xmm_reg_no++) {</span>
<span class="udiff-line-added">+       vaesdeclast(as_XMMRegister(xmm_reg_no), as_XMMRegister(xmm_reg_no), key, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Load key and shuffle operation</span>
<span class="udiff-line-added">+ void MacroAssembler::ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {</span>
<span class="udiff-line-added">+     movdqu(xmmdst, Address(key, offset));</span>
<span class="udiff-line-added">+     if (xmm_shuf_mask != NULL) {</span>
<span class="udiff-line-added">+         pshufb(xmmdst, xmm_shuf_mask);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+        pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+    evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // AES-ECB Encrypt Operation</span>
<span class="udiff-line-added">+ void MacroAssembler::aesecb_encrypt(Register src_addr, Register dest_addr, Register key, Register len) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const Register pos = rax;</span>
<span class="udiff-line-added">+     const Register rounds = r12;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Label NO_PARTS, LOOP, Loop_start, LOOP2, AES192, END_LOOP, AES256, REMAINDER, LAST2, END, KEY_192, KEY_256, EXIT;</span>
<span class="udiff-line-added">+     push(r13);</span>
<span class="udiff-line-added">+     push(r12);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge</span>
<span class="udiff-line-added">+     // context for the registers used, where all instructions below are using 128-bit mode</span>
<span class="udiff-line-added">+     // On EVEX without VL and BW, these instructions will all be AVX.</span>
<span class="udiff-line-added">+     if (VM_Version::supports_avx512vlbw()) {</span>
<span class="udiff-line-added">+        movl(rax, 0xffff);</span>
<span class="udiff-line-added">+        kmovql(k1, rax);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     push(len); // Save</span>
<span class="udiff-line-added">+     push(rbx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     vzeroupper();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     xorptr(pos, pos);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Calculate number of rounds based on key length(128, 192, 256):44 for 10-rounds, 52 for 12-rounds, 60 for 14-rounds</span>
<span class="udiff-line-added">+     movl(rounds, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Load Key shuf mask</span>
<span class="udiff-line-added">+     const XMMRegister xmm_key_shuf_mask = xmm31;  // used temporarily to swap key bytes up front</span>
<span class="udiff-line-added">+     movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Load and shuffle key based on number of rounds</span>
<span class="udiff-line-added">+     ev_load_key(xmm8, key, 0 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm9, key, 1 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm10, key, 2 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm23, key, 3 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm12, key, 4 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm13, key, 5 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm14, key, 6 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm15, key, 7 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm16, key, 8 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm17, key, 9 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm24, key, 10 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::greaterEqual, KEY_192);</span>
<span class="udiff-line-added">+     jmp(Loop_start);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(KEY_192);</span>
<span class="udiff-line-added">+     ev_load_key(xmm19, key, 11 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm20, key, 12 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     cmpl(rounds, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::equal, KEY_256);</span>
<span class="udiff-line-added">+     jmp(Loop_start);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(KEY_256);</span>
<span class="udiff-line-added">+     ev_load_key(xmm21, key, 13 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm22, key, 14 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(Loop_start);</span>
<span class="udiff-line-added">+     movq(rbx, len);</span>
<span class="udiff-line-added">+     // Divide length by 16 to convert it to number of blocks</span>
<span class="udiff-line-added">+     shrq(len, 4);</span>
<span class="udiff-line-added">+     shlq(rbx, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::equal, NO_PARTS);</span>
<span class="udiff-line-added">+     addq(len, 1);</span>
<span class="udiff-line-added">+     // Check if number of blocks is greater than or equal to 32</span>
<span class="udiff-line-added">+     // If true, 512 bytes are processed at a time (code marked by label LOOP)</span>
<span class="udiff-line-added">+     // If not, 16 bytes are processed (code marked by REMAINDER label)</span>
<span class="udiff-line-added">+     bind(NO_PARTS);</span>
<span class="udiff-line-added">+     movq(rbx, len);</span>
<span class="udiff-line-added">+     shrq(len, 5);</span>
<span class="udiff-line-added">+     jcc(Assembler::equal, REMAINDER);</span>
<span class="udiff-line-added">+     movl(r13, len);</span>
<span class="udiff-line-added">+     // Compute number of blocks that will be processed 512 bytes at a time</span>
<span class="udiff-line-added">+     // Subtract this from the total number of blocks which will then be processed by REMAINDER loop</span>
<span class="udiff-line-added">+     shlq(r13, 5);</span>
<span class="udiff-line-added">+     subq(rbx, r13);</span>
<span class="udiff-line-added">+     //Begin processing 512 bytes</span>
<span class="udiff-line-added">+     bind(LOOP);</span>
<span class="udiff-line-added">+     // Move 64 bytes of PT data into a zmm register, as a result 512 bytes of PT loaded in zmm0-7</span>
<span class="udiff-line-added">+     evmovdquq(xmm0, Address(src_addr, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm1, Address(src_addr, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm2, Address(src_addr, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm3, Address(src_addr, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm4, Address(src_addr, pos, Address::times_1, 4 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm5, Address(src_addr, pos, Address::times_1, 5 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm6, Address(src_addr, pos, Address::times_1, 6 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm7, Address(src_addr, pos, Address::times_1, 7 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     // Xor with the first round key</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, xmm8, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm1, xmm1, xmm8, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm2, xmm2, xmm8, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm3, xmm3, xmm8, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm4, xmm4, xmm8, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm5, xmm5, xmm8, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm6, xmm6, xmm8, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm7, xmm7, xmm8, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     // 9 Aes encode round operations</span>
<span class="udiff-line-added">+     roundEnc(xmm9,  7);</span>
<span class="udiff-line-added">+     roundEnc(xmm10, 7);</span>
<span class="udiff-line-added">+     roundEnc(xmm23, 7);</span>
<span class="udiff-line-added">+     roundEnc(xmm12, 7);</span>
<span class="udiff-line-added">+     roundEnc(xmm13, 7);</span>
<span class="udiff-line-added">+     roundEnc(xmm14, 7);</span>
<span class="udiff-line-added">+     roundEnc(xmm15, 7);</span>
<span class="udiff-line-added">+     roundEnc(xmm16, 7);</span>
<span class="udiff-line-added">+     roundEnc(xmm17, 7);</span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES192);</span>
<span class="udiff-line-added">+     // Aesenclast round operation for keysize = 128</span>
<span class="udiff-line-added">+     lastroundEnc(xmm24, 7);</span>
<span class="udiff-line-added">+     jmp(END_LOOP);</span>
<span class="udiff-line-added">+     //Additional 2 rounds of Aesenc operation for keysize = 192</span>
<span class="udiff-line-added">+     bind(AES192);</span>
<span class="udiff-line-added">+     roundEnc(xmm24, 7);</span>
<span class="udiff-line-added">+     roundEnc(xmm19, 7);</span>
<span class="udiff-line-added">+     cmpl(rounds, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES256);</span>
<span class="udiff-line-added">+     // Aesenclast round for keysize = 192</span>
<span class="udiff-line-added">+     lastroundEnc(xmm20, 7);</span>
<span class="udiff-line-added">+     jmp(END_LOOP);</span>
<span class="udiff-line-added">+     // 2 rounds of Aesenc operation and Aesenclast for keysize = 256</span>
<span class="udiff-line-added">+     bind(AES256);</span>
<span class="udiff-line-added">+     roundEnc(xmm20, 7);</span>
<span class="udiff-line-added">+     roundEnc(xmm21, 7);</span>
<span class="udiff-line-added">+     lastroundEnc(xmm22, 7);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(END_LOOP);</span>
<span class="udiff-line-added">+     // Move 512 bytes of CT to destination</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 0 * 64), xmm0, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 1 * 64), xmm1, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 2 * 64), xmm2, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 3 * 64), xmm3, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 4 * 64), xmm4, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 5 * 64), xmm5, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 6 * 64), xmm6, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 7 * 64), xmm7, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     addq(pos, 512);</span>
<span class="udiff-line-added">+     decq(len);</span>
<span class="udiff-line-added">+     jcc(Assembler::notEqual, LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(REMAINDER);</span>
<span class="udiff-line-added">+     vzeroupper();</span>
<span class="udiff-line-added">+     cmpq(rbx, 0);</span>
<span class="udiff-line-added">+     jcc(Assembler::equal, END);</span>
<span class="udiff-line-added">+     // Process 16 bytes at a time</span>
<span class="udiff-line-added">+     bind(LOOP2);</span>
<span class="udiff-line-added">+     movdqu(xmm1, Address(src_addr, pos, Address::times_1, 0));</span>
<span class="udiff-line-added">+     vpxor(xmm1, xmm1, xmm8, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     // xmm2 contains shuffled key for Aesenclast operation.</span>
<span class="udiff-line-added">+     vmovdqu(xmm2, xmm24);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm9, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm10, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm23, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm12, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm13, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm14, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm15, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm16, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm17, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::below, LAST2);</span>
<span class="udiff-line-added">+     vmovdqu(xmm2, xmm20);</span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm24, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm19, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     cmpl(rounds, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::below, LAST2);</span>
<span class="udiff-line-added">+     vmovdqu(xmm2, xmm22);</span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm20, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm1, xmm1, xmm21, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(LAST2);</span>
<span class="udiff-line-added">+     // Aesenclast round</span>
<span class="udiff-line-added">+     vaesenclast(xmm1, xmm1, xmm2, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     // Write 16 bytes of CT to destination</span>
<span class="udiff-line-added">+     movdqu(Address(dest_addr, pos, Address::times_1, 0), xmm1);</span>
<span class="udiff-line-added">+     addq(pos, 16);</span>
<span class="udiff-line-added">+     decq(rbx);</span>
<span class="udiff-line-added">+     jcc(Assembler::notEqual, LOOP2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(END);</span>
<span class="udiff-line-added">+     // Zero out the round keys</span>
<span class="udiff-line-added">+     evpxorq(xmm8, xmm8, xmm8, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm9, xmm9, xmm9, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm10, xmm10, xmm10, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm23, xmm23, xmm23, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm12, xmm12, xmm12, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm13, xmm13, xmm13, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm14, xmm14, xmm14, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm15, xmm15, xmm15, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm16, xmm16, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm17, xmm17, xmm17, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm24, xmm24, xmm24, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     cmpl(rounds, 44);</span>
<span class="udiff-line-added">+     jcc(Assembler::belowEqual, EXIT);</span>
<span class="udiff-line-added">+     evpxorq(xmm19, xmm19, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm20, xmm20, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::belowEqual, EXIT);</span>
<span class="udiff-line-added">+     evpxorq(xmm21, xmm21, xmm21, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm22, xmm22, xmm22, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     bind(EXIT);</span>
<span class="udiff-line-added">+     pop(rbx);</span>
<span class="udiff-line-added">+     pop(rax); // return length</span>
<span class="udiff-line-added">+     pop(r12);</span>
<span class="udiff-line-added">+     pop(r13);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // AES-ECB Decrypt Operation</span>
<span class="udiff-line-added">+ void MacroAssembler::aesecb_decrypt(Register src_addr, Register dest_addr, Register key, Register len)  {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Label NO_PARTS, LOOP, Loop_start, LOOP2, AES192, END_LOOP, AES256, REMAINDER, LAST2, END, KEY_192, KEY_256, EXIT;</span>
<span class="udiff-line-added">+     const Register pos = rax;</span>
<span class="udiff-line-added">+     const Register rounds = r12;</span>
<span class="udiff-line-added">+     push(r13);</span>
<span class="udiff-line-added">+     push(r12);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge</span>
<span class="udiff-line-added">+     // context for the registers used, where all instructions below are using 128-bit mode</span>
<span class="udiff-line-added">+     // On EVEX without VL and BW, these instructions will all be AVX.</span>
<span class="udiff-line-added">+     if (VM_Version::supports_avx512vlbw()) {</span>
<span class="udiff-line-added">+        movl(rax, 0xffff);</span>
<span class="udiff-line-added">+        kmovql(k1, rax);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     push(len); // Save</span>
<span class="udiff-line-added">+     push(rbx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     vzeroupper();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     xorptr(pos, pos);</span>
<span class="udiff-line-added">+     // Calculate number of rounds i.e. based on key length(128, 192, 256):44 for 10-rounds, 52 for 12-rounds, 60 for 14-rounds</span>
<span class="udiff-line-added">+     movl(rounds, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Load Key shuf mask</span>
<span class="udiff-line-added">+     const XMMRegister xmm_key_shuf_mask = xmm31;  // used temporarily to swap key bytes up front</span>
<span class="udiff-line-added">+     movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Load and shuffle round keys. The java expanded key ordering is rotated one position in decryption.</span>
<span class="udiff-line-added">+     // So the first round key is loaded from 1*16 here and last round key is loaded from 0*16</span>
<span class="udiff-line-added">+     ev_load_key(xmm9,  key, 1 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm10, key, 2 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm11, key, 3 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm12, key, 4 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm13, key, 5 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm14, key, 6 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm15, key, 7 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm16, key, 8 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm17, key, 9 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm18, key, 10 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm27, key, 0 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::greaterEqual, KEY_192);</span>
<span class="udiff-line-added">+     jmp(Loop_start);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(KEY_192);</span>
<span class="udiff-line-added">+     ev_load_key(xmm19, key, 11 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm20, key, 12 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     cmpl(rounds, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::equal, KEY_256);</span>
<span class="udiff-line-added">+     jmp(Loop_start);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(KEY_256);</span>
<span class="udiff-line-added">+     ev_load_key(xmm21, key, 13 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     ev_load_key(xmm22, key, 14 * 16, xmm_key_shuf_mask);</span>
<span class="udiff-line-added">+     bind(Loop_start);</span>
<span class="udiff-line-added">+     movq(rbx, len);</span>
<span class="udiff-line-added">+     // Convert input length to number of blocks</span>
<span class="udiff-line-added">+     shrq(len, 4);</span>
<span class="udiff-line-added">+     shlq(rbx, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::equal, NO_PARTS);</span>
<span class="udiff-line-added">+     addq(len, 1);</span>
<span class="udiff-line-added">+     // Check if number of blocks is greater than/ equal to 32</span>
<span class="udiff-line-added">+     // If true, blocks then 512 bytes are processed at a time (code marked by label LOOP)</span>
<span class="udiff-line-added">+     // If not, 16 bytes are processed (code marked by label REMAINDER)</span>
<span class="udiff-line-added">+     bind(NO_PARTS);</span>
<span class="udiff-line-added">+     movq(rbx, len);</span>
<span class="udiff-line-added">+     shrq(len, 5);</span>
<span class="udiff-line-added">+     jcc(Assembler::equal, REMAINDER);</span>
<span class="udiff-line-added">+     movl(r13, len);</span>
<span class="udiff-line-added">+     // Compute number of blocks that will be processed as 512 bytes at a time</span>
<span class="udiff-line-added">+     // Subtract this from the total number of blocks, which will then be processed by REMAINDER loop.</span>
<span class="udiff-line-added">+     shlq(r13, 5);</span>
<span class="udiff-line-added">+     subq(rbx, r13);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(LOOP);</span>
<span class="udiff-line-added">+     // Move 64 bytes of CT data into a zmm register, as a result 512 bytes of CT loaded in zmm0-7</span>
<span class="udiff-line-added">+     evmovdquq(xmm0, Address(src_addr, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm1, Address(src_addr, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm2, Address(src_addr, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm3, Address(src_addr, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm4, Address(src_addr, pos, Address::times_1, 4 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm5, Address(src_addr, pos, Address::times_1, 5 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm6, Address(src_addr, pos, Address::times_1, 6 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(xmm7, Address(src_addr, pos, Address::times_1, 7 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     // Xor with the first round key</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, xmm9, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm1, xmm1, xmm9, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm2, xmm2, xmm9, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm3, xmm3, xmm9, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm4, xmm4, xmm9, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm5, xmm5, xmm9, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm6, xmm6, xmm9, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm7, xmm7, xmm9, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     // 9 rounds of Aesdec</span>
<span class="udiff-line-added">+     roundDec(xmm10, 7);</span>
<span class="udiff-line-added">+     roundDec(xmm11, 7);</span>
<span class="udiff-line-added">+     roundDec(xmm12, 7);</span>
<span class="udiff-line-added">+     roundDec(xmm13, 7);</span>
<span class="udiff-line-added">+     roundDec(xmm14, 7);</span>
<span class="udiff-line-added">+     roundDec(xmm15, 7);</span>
<span class="udiff-line-added">+     roundDec(xmm16, 7);</span>
<span class="udiff-line-added">+     roundDec(xmm17, 7);</span>
<span class="udiff-line-added">+     roundDec(xmm18, 7);</span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES192);</span>
<span class="udiff-line-added">+     // Aesdeclast round for keysize = 128</span>
<span class="udiff-line-added">+     lastroundDec(xmm27, 7);</span>
<span class="udiff-line-added">+     jmp(END_LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(AES192);</span>
<span class="udiff-line-added">+     // 2 Additional rounds for keysize = 192</span>
<span class="udiff-line-added">+     roundDec(xmm19, 7);</span>
<span class="udiff-line-added">+     roundDec(xmm20, 7);</span>
<span class="udiff-line-added">+     cmpl(rounds, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES256);</span>
<span class="udiff-line-added">+     // Aesdeclast round for keysize = 192</span>
<span class="udiff-line-added">+     lastroundDec(xmm27, 7);</span>
<span class="udiff-line-added">+     jmp(END_LOOP);</span>
<span class="udiff-line-added">+     bind(AES256);</span>
<span class="udiff-line-added">+     // 2 Additional rounds and Aesdeclast for keysize = 256</span>
<span class="udiff-line-added">+     roundDec(xmm21, 7);</span>
<span class="udiff-line-added">+     roundDec(xmm22, 7);</span>
<span class="udiff-line-added">+     lastroundDec(xmm27, 7);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(END_LOOP);</span>
<span class="udiff-line-added">+     // Write 512 bytes of PT to the destination</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 0 * 64), xmm0, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 1 * 64), xmm1, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 2 * 64), xmm2, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 3 * 64), xmm3, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 4 * 64), xmm4, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 5 * 64), xmm5, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 6 * 64), xmm6, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 7 * 64), xmm7, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     addq(pos, 512);</span>
<span class="udiff-line-added">+     decq(len);</span>
<span class="udiff-line-added">+     jcc(Assembler::notEqual, LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(REMAINDER);</span>
<span class="udiff-line-added">+     vzeroupper();</span>
<span class="udiff-line-added">+     cmpq(rbx, 0);</span>
<span class="udiff-line-added">+     jcc(Assembler::equal, END);</span>
<span class="udiff-line-added">+     // Process 16 bytes at a time</span>
<span class="udiff-line-added">+     bind(LOOP2);</span>
<span class="udiff-line-added">+     movdqu(xmm1, Address(src_addr, pos, Address::times_1, 0));</span>
<span class="udiff-line-added">+     vpxor(xmm1, xmm1, xmm9, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     // xmm2 contains shuffled key for Aesdeclast operation.</span>
<span class="udiff-line-added">+     vmovdqu(xmm2, xmm27);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm10, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm11, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm12, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm13, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm14, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm15, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm16, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm17, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm18, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::below, LAST2);</span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm19, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm20, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     cmpl(rounds, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::below, LAST2);</span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm21, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesdec(xmm1, xmm1, xmm22, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(LAST2);</span>
<span class="udiff-line-added">+     // Aesdeclast round</span>
<span class="udiff-line-added">+     vaesdeclast(xmm1, xmm1, xmm2, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     // Write 16 bytes of PT to destination</span>
<span class="udiff-line-added">+     movdqu(Address(dest_addr, pos, Address::times_1, 0), xmm1);</span>
<span class="udiff-line-added">+     addq(pos, 16);</span>
<span class="udiff-line-added">+     decq(rbx);</span>
<span class="udiff-line-added">+     jcc(Assembler::notEqual, LOOP2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(END);</span>
<span class="udiff-line-added">+     // Zero out the round keys</span>
<span class="udiff-line-added">+     evpxorq(xmm8, xmm8, xmm8, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm9, xmm9, xmm9, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm10, xmm10, xmm10, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm11, xmm11, xmm11, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm12, xmm12, xmm12, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm13, xmm13, xmm13, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm14, xmm14, xmm14, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm15, xmm15, xmm15, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm16, xmm16, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm17, xmm17, xmm17, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm18, xmm18, xmm18, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm27, xmm27, xmm27, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     cmpl(rounds, 44);</span>
<span class="udiff-line-added">+     jcc(Assembler::belowEqual, EXIT);</span>
<span class="udiff-line-added">+     evpxorq(xmm19, xmm19, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm20, xmm20, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::belowEqual, EXIT);</span>
<span class="udiff-line-added">+     evpxorq(xmm21, xmm21, xmm21, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm22, xmm22, xmm22, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     bind(EXIT);</span>
<span class="udiff-line-added">+     pop(rbx);</span>
<span class="udiff-line-added">+     pop(rax); // return length</span>
<span class="udiff-line-added">+     pop(r12);</span>
<span class="udiff-line-added">+     pop(r13);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Multiply 128 x 128 bits, using 4 pclmulqdq operations
  void MacroAssembler::schoolbookAAD(int i, Register htbl, XMMRegister data,
      XMMRegister tmp0, XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3) {
      movdqu(xmm15, Address(htbl, i * 16));
      vpclmulhqlqdq(tmp3, data, xmm15); // 0x01
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -319,6 +776,495 @@</span>
      vpxor(xmm0, xmm0, xmm0, Assembler::AVX_128bit);
      vpxor(xmm1, xmm1, xmm1, Assembler::AVX_128bit);
      vpxor(xmm3, xmm3, xmm3, Assembler::AVX_128bit);
      vpxor(xmm15, xmm15, xmm15, Assembler::AVX_128bit);
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // AES Counter Mode using VAES instructions</span>
<span class="udiff-line-added">+ void MacroAssembler::aesctr_encrypt(Register src_addr, Register dest_addr, Register key, Register counter,</span>
<span class="udiff-line-added">+     Register len_reg, Register used, Register used_addr, Register saved_encCounter_start) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const Register rounds = 0;</span>
<span class="udiff-line-added">+     const Register pos = r12;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Label PRELOOP_START, EXIT_PRELOOP, REMAINDER, REMAINDER_16, LOOP, END, EXIT, END_LOOP,</span>
<span class="udiff-line-added">+     AES192, AES256, AES192_REMAINDER16, REMAINDER16_END_LOOP, AES256_REMAINDER16,</span>
<span class="udiff-line-added">+     REMAINDER_8, REMAINDER_4, AES192_REMAINDER8, REMAINDER_LOOP, AES256_REMINDER,</span>
<span class="udiff-line-added">+     AES192_REMAINDER, END_REMAINDER_LOOP, AES256_REMAINDER8, REMAINDER8_END_LOOP,</span>
<span class="udiff-line-added">+     AES192_REMAINDER4, AES256_REMAINDER4, AES256_REMAINDER, END_REMAINDER4, EXTRACT_TAILBYTES,</span>
<span class="udiff-line-added">+     EXTRACT_TAIL_4BYTES, EXTRACT_TAIL_2BYTES, EXTRACT_TAIL_1BYTE, STORE_CTR;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cmpl(len_reg, 0);</span>
<span class="udiff-line-added">+     jcc(Assembler::belowEqual, EXIT);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     movl(pos, 0);</span>
<span class="udiff-line-added">+     // if the number of used encrypted counter bytes &lt; 16,</span>
<span class="udiff-line-added">+     // XOR PT with saved encrypted counter to obtain CT</span>
<span class="udiff-line-added">+     bind(PRELOOP_START);</span>
<span class="udiff-line-added">+     cmpl(used, 16);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, EXIT_PRELOOP);</span>
<span class="udiff-line-added">+     movb(rbx, Address(saved_encCounter_start, used));</span>
<span class="udiff-line-added">+     xorb(rbx, Address(src_addr, pos));</span>
<span class="udiff-line-added">+     movb(Address(dest_addr, pos), rbx);</span>
<span class="udiff-line-added">+     addptr(pos, 1);</span>
<span class="udiff-line-added">+     addptr(used, 1);</span>
<span class="udiff-line-added">+     decrement(len_reg);</span>
<span class="udiff-line-added">+     jmp(PRELOOP_START);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(EXIT_PRELOOP);</span>
<span class="udiff-line-added">+     movl(Address(used_addr, 0), used);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Calculate number of rounds i.e. 10, 12, 14,  based on key length(128, 192, 256).</span>
<span class="udiff-line-added">+     movl(rounds, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     vpxor(xmm0, xmm0, xmm0, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     // Move initial counter value in xmm0</span>
<span class="udiff-line-added">+     movdqu(xmm0, Address(counter, 0));</span>
<span class="udiff-line-added">+     // broadcast counter value to zmm8</span>
<span class="udiff-line-added">+     evshufi64x2(xmm8, xmm0, xmm0, 0, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // load lbswap mask</span>
<span class="udiff-line-added">+     evmovdquq(xmm16, ExternalAddress(StubRoutines::x86::counter_mask_addr()), Assembler::AVX_512bit, r15);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     //shuffle counter using lbswap_mask</span>
<span class="udiff-line-added">+     vpshufb(xmm8, xmm8, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // pre-increment and propagate counter values to zmm9-zmm15 registers.</span>
<span class="udiff-line-added">+     // Linc0 increments the zmm8 by 1 (initial value being 0), Linc4 increments the counters zmm9-zmm15 by 4</span>
<span class="udiff-line-added">+     // The counter is incremented after each block i.e. 16 bytes is processed;</span>
<span class="udiff-line-added">+     // each zmm register has 4 counter values as its MSB</span>
<span class="udiff-line-added">+     // the counters are incremented in parallel</span>
<span class="udiff-line-added">+     vpaddd(xmm8, xmm8, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 64), Assembler::AVX_512bit, r15);//linc0</span>
<span class="udiff-line-added">+     vpaddd(xmm9, xmm8, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//linc4(rip)</span>
<span class="udiff-line-added">+     vpaddd(xmm10, xmm9, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="udiff-line-added">+     vpaddd(xmm11, xmm10, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="udiff-line-added">+     vpaddd(xmm12, xmm11, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="udiff-line-added">+     vpaddd(xmm13, xmm12, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="udiff-line-added">+     vpaddd(xmm14, xmm13, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="udiff-line-added">+     vpaddd(xmm15, xmm14, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // load linc32 mask in zmm register.linc32 increments counter by 32</span>
<span class="udiff-line-added">+     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 256), Assembler::AVX_512bit, r15);//Linc32</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // xmm31 contains the key shuffle mask.</span>
<span class="udiff-line-added">+     movdqu(xmm31, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));</span>
<span class="udiff-line-added">+     // Load key function loads 128 bit key and shuffles it. Then we broadcast the shuffled key to convert it into a 512 bit value.</span>
<span class="udiff-line-added">+     // For broadcasting the values to ZMM, vshufi64 is used instead of evbroadcasti64x2 as the source in this case is ZMM register</span>
<span class="udiff-line-added">+     // that holds shuffled key value.</span>
<span class="udiff-line-added">+     ev_load_key(xmm20, key, 0, xmm31);</span>
<span class="udiff-line-added">+     ev_load_key(xmm21, key, 1 * 16, xmm31);</span>
<span class="udiff-line-added">+     ev_load_key(xmm22, key, 2 * 16, xmm31);</span>
<span class="udiff-line-added">+     ev_load_key(xmm23, key, 3 * 16, xmm31);</span>
<span class="udiff-line-added">+     ev_load_key(xmm24, key, 4 * 16, xmm31);</span>
<span class="udiff-line-added">+     ev_load_key(xmm25, key, 5 * 16, xmm31);</span>
<span class="udiff-line-added">+     ev_load_key(xmm26, key, 6 * 16, xmm31);</span>
<span class="udiff-line-added">+     ev_load_key(xmm27, key, 7 * 16, xmm31);</span>
<span class="udiff-line-added">+     ev_load_key(xmm28, key, 8 * 16, xmm31);</span>
<span class="udiff-line-added">+     ev_load_key(xmm29, key, 9 * 16, xmm31);</span>
<span class="udiff-line-added">+     ev_load_key(xmm30, key, 10 * 16, xmm31);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Process 32 blocks or 512 bytes of data</span>
<span class="udiff-line-added">+     bind(LOOP);</span>
<span class="udiff-line-added">+     cmpl(len_reg, 512);</span>
<span class="udiff-line-added">+     jcc(Assembler::less, REMAINDER);</span>
<span class="udiff-line-added">+     subq(len_reg, 512);</span>
<span class="udiff-line-added">+     //Shuffle counter and Exor it with roundkey1. Result is stored in zmm0-7</span>
<span class="udiff-line-added">+     vpshufb(xmm0, xmm8, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vpshufb(xmm1, xmm9, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm1, xmm1, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vpshufb(xmm2, xmm10, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm2, xmm2, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vpshufb(xmm3, xmm11, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm3, xmm3, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vpshufb(xmm4, xmm12, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm4, xmm4, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vpshufb(xmm5, xmm13, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm5, xmm5, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vpshufb(xmm6, xmm14, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm6, xmm6, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vpshufb(xmm7, xmm15, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm7, xmm7, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     // Perform AES encode operations and put results in zmm0-zmm7.</span>
<span class="udiff-line-added">+     // This is followed by incrementing counter values in zmm8-zmm15.</span>
<span class="udiff-line-added">+     // Since we will be processing 32 blocks at a time, the counter is incremented by 32.</span>
<span class="udiff-line-added">+     roundEnc(xmm21, 7);</span>
<span class="udiff-line-added">+     vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     roundEnc(xmm22, 7);</span>
<span class="udiff-line-added">+     vpaddq(xmm9, xmm9, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     roundEnc(xmm23, 7);</span>
<span class="udiff-line-added">+     vpaddq(xmm10, xmm10, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     roundEnc(xmm24, 7);</span>
<span class="udiff-line-added">+     vpaddq(xmm11, xmm11, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     roundEnc(xmm25, 7);</span>
<span class="udiff-line-added">+     vpaddq(xmm12, xmm12, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     roundEnc(xmm26, 7);</span>
<span class="udiff-line-added">+     vpaddq(xmm13, xmm13, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     roundEnc(xmm27, 7);</span>
<span class="udiff-line-added">+     vpaddq(xmm14, xmm14, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     roundEnc(xmm28, 7);</span>
<span class="udiff-line-added">+     vpaddq(xmm15, xmm15, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     roundEnc(xmm29, 7);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES192);</span>
<span class="udiff-line-added">+     lastroundEnc(xmm30, 7);</span>
<span class="udiff-line-added">+     jmp(END_LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(AES192);</span>
<span class="udiff-line-added">+     roundEnc(xmm30, 7);</span>
<span class="udiff-line-added">+     ev_load_key(xmm18, key, 11 * 16, xmm31);</span>
<span class="udiff-line-added">+     roundEnc(xmm18, 7);</span>
<span class="udiff-line-added">+     cmpl(rounds, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES256);</span>
<span class="udiff-line-added">+     ev_load_key(xmm18, key, 12 * 16, xmm31);</span>
<span class="udiff-line-added">+     lastroundEnc(xmm18, 7);</span>
<span class="udiff-line-added">+     jmp(END_LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(AES256);</span>
<span class="udiff-line-added">+     ev_load_key(xmm18, key, 12 * 16, xmm31);</span>
<span class="udiff-line-added">+     roundEnc(xmm18, 7);</span>
<span class="udiff-line-added">+     ev_load_key(xmm18, key, 13 * 16, xmm31);</span>
<span class="udiff-line-added">+     roundEnc(xmm18, 7);</span>
<span class="udiff-line-added">+     ev_load_key(xmm18, key, 14 * 16, xmm31);</span>
<span class="udiff-line-added">+     lastroundEnc(xmm18, 7);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // After AES encode rounds, the encrypted block cipher lies in zmm0-zmm7</span>
<span class="udiff-line-added">+     // xor encrypted block cipher and input plaintext and store resultant ciphertext</span>
<span class="udiff-line-added">+     bind(END_LOOP);</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 0), xmm0, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm1, xmm1, Address(src_addr, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 64), xmm1, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm2, xmm2, Address(src_addr, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 2 * 64), xmm2, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm3, xmm3, Address(src_addr, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 3 * 64), xmm3, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm4, xmm4, Address(src_addr, pos, Address::times_1, 4 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 4 * 64), xmm4, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm5, xmm5, Address(src_addr, pos, Address::times_1, 5 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 5 * 64), xmm5, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm6, xmm6, Address(src_addr, pos, Address::times_1, 6 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 6 * 64), xmm6, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm7, xmm7, Address(src_addr, pos, Address::times_1, 7 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 7 * 64), xmm7, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     addq(pos, 512);</span>
<span class="udiff-line-added">+     jmp(LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Encode 256, 128, 64 or 16 bytes at a time if length is less than 512 bytes</span>
<span class="udiff-line-added">+     bind(REMAINDER);</span>
<span class="udiff-line-added">+     cmpl(len_reg, 0);</span>
<span class="udiff-line-added">+     jcc(Assembler::equal, END);</span>
<span class="udiff-line-added">+     cmpl(len_reg, 256);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, REMAINDER_16);</span>
<span class="udiff-line-added">+     cmpl(len_reg, 128);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, REMAINDER_8);</span>
<span class="udiff-line-added">+     cmpl(len_reg, 64);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, REMAINDER_4);</span>
<span class="udiff-line-added">+     // At this point, we will process 16 bytes of data at a time.</span>
<span class="udiff-line-added">+     // So load xmm19 with counter increment value as 1</span>
<span class="udiff-line-added">+     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 80), Assembler::AVX_128bit, r15);</span>
<span class="udiff-line-added">+     jmp(REMAINDER_LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Each ZMM register can be used to encode 64 bytes of data, so we have 4 ZMM registers to encode 256 bytes of data</span>
<span class="udiff-line-added">+     bind(REMAINDER_16);</span>
<span class="udiff-line-added">+     subq(len_reg, 256);</span>
<span class="udiff-line-added">+     // As we process 16 blocks at a time, load mask for incrementing the counter value by 16</span>
<span class="udiff-line-added">+     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 320), Assembler::AVX_512bit, r15);//Linc16(rip)</span>
<span class="udiff-line-added">+     // shuffle counter and XOR counter with roundkey1</span>
<span class="udiff-line-added">+     vpshufb(xmm0, xmm8, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vpshufb(xmm1, xmm9, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm1, xmm1, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vpshufb(xmm2, xmm10, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm2, xmm2, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vpshufb(xmm3, xmm11, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm3, xmm3, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     // Increment counter values by 16</span>
<span class="udiff-line-added">+     vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vpaddq(xmm9, xmm9, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     // AES encode rounds</span>
<span class="udiff-line-added">+     roundEnc(xmm21, 3);</span>
<span class="udiff-line-added">+     roundEnc(xmm22, 3);</span>
<span class="udiff-line-added">+     roundEnc(xmm23, 3);</span>
<span class="udiff-line-added">+     roundEnc(xmm24, 3);</span>
<span class="udiff-line-added">+     roundEnc(xmm25, 3);</span>
<span class="udiff-line-added">+     roundEnc(xmm26, 3);</span>
<span class="udiff-line-added">+     roundEnc(xmm27, 3);</span>
<span class="udiff-line-added">+     roundEnc(xmm28, 3);</span>
<span class="udiff-line-added">+     roundEnc(xmm29, 3);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES192_REMAINDER16);</span>
<span class="udiff-line-added">+     lastroundEnc(xmm30, 3);</span>
<span class="udiff-line-added">+     jmp(REMAINDER16_END_LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(AES192_REMAINDER16);</span>
<span class="udiff-line-added">+     roundEnc(xmm30, 3);</span>
<span class="udiff-line-added">+     ev_load_key(xmm18, key, 11 * 16, xmm31);</span>
<span class="udiff-line-added">+     roundEnc(xmm18, 3);</span>
<span class="udiff-line-added">+     ev_load_key(xmm5, key, 12 * 16, xmm31);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cmpl(rounds, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES256_REMAINDER16);</span>
<span class="udiff-line-added">+     lastroundEnc(xmm5, 3);</span>
<span class="udiff-line-added">+     jmp(REMAINDER16_END_LOOP);</span>
<span class="udiff-line-added">+     bind(AES256_REMAINDER16);</span>
<span class="udiff-line-added">+     roundEnc(xmm5, 3);</span>
<span class="udiff-line-added">+     ev_load_key(xmm6, key, 13 * 16, xmm31);</span>
<span class="udiff-line-added">+     roundEnc(xmm6, 3);</span>
<span class="udiff-line-added">+     ev_load_key(xmm7, key, 14 * 16, xmm31);</span>
<span class="udiff-line-added">+     lastroundEnc(xmm7, 3);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // After AES encode rounds, the encrypted block cipher lies in zmm0-zmm3</span>
<span class="udiff-line-added">+     // xor 256 bytes of PT with the encrypted counters to produce CT.</span>
<span class="udiff-line-added">+     bind(REMAINDER16_END_LOOP);</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 0), xmm0, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm1, xmm1, Address(src_addr, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 1 * 64), xmm1, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm2, xmm2, Address(src_addr, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 2 * 64), xmm2, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm3, xmm3, Address(src_addr, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 3 * 64), xmm3, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     addq(pos, 256);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cmpl(len_reg, 128);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, REMAINDER_8);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cmpl(len_reg, 64);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, REMAINDER_4);</span>
<span class="udiff-line-added">+     //load mask for incrementing the counter value by 1</span>
<span class="udiff-line-added">+     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 80), Assembler::AVX_128bit, r15);//Linc0 + 16(rip)</span>
<span class="udiff-line-added">+     jmp(REMAINDER_LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Each ZMM register can be used to encode 64 bytes of data, so we have 2 ZMM registers to encode 128 bytes of data</span>
<span class="udiff-line-added">+     bind(REMAINDER_8);</span>
<span class="udiff-line-added">+     subq(len_reg, 128);</span>
<span class="udiff-line-added">+     // As we process 8 blocks at a time, load mask for incrementing the counter value by 8</span>
<span class="udiff-line-added">+     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 192), Assembler::AVX_512bit, r15);//Linc8(rip)</span>
<span class="udiff-line-added">+     // shuffle counters and xor with roundkey1</span>
<span class="udiff-line-added">+     vpshufb(xmm0, xmm8, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vpshufb(xmm1, xmm9, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm1, xmm1, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     // increment counter by 8</span>
<span class="udiff-line-added">+     vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     // AES encode</span>
<span class="udiff-line-added">+     roundEnc(xmm21, 1);</span>
<span class="udiff-line-added">+     roundEnc(xmm22, 1);</span>
<span class="udiff-line-added">+     roundEnc(xmm23, 1);</span>
<span class="udiff-line-added">+     roundEnc(xmm24, 1);</span>
<span class="udiff-line-added">+     roundEnc(xmm25, 1);</span>
<span class="udiff-line-added">+     roundEnc(xmm26, 1);</span>
<span class="udiff-line-added">+     roundEnc(xmm27, 1);</span>
<span class="udiff-line-added">+     roundEnc(xmm28, 1);</span>
<span class="udiff-line-added">+     roundEnc(xmm29, 1);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES192_REMAINDER8);</span>
<span class="udiff-line-added">+     lastroundEnc(xmm30, 1);</span>
<span class="udiff-line-added">+     jmp(REMAINDER8_END_LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(AES192_REMAINDER8);</span>
<span class="udiff-line-added">+     roundEnc(xmm30, 1);</span>
<span class="udiff-line-added">+     ev_load_key(xmm18, key, 11 * 16, xmm31);</span>
<span class="udiff-line-added">+     roundEnc(xmm18, 1);</span>
<span class="udiff-line-added">+     ev_load_key(xmm5, key, 12 * 16, xmm31);</span>
<span class="udiff-line-added">+     cmpl(rounds, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES256_REMAINDER8);</span>
<span class="udiff-line-added">+     lastroundEnc(xmm5, 1);</span>
<span class="udiff-line-added">+     jmp(REMAINDER8_END_LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(AES256_REMAINDER8);</span>
<span class="udiff-line-added">+     roundEnc(xmm5, 1);</span>
<span class="udiff-line-added">+     ev_load_key(xmm6, key, 13 * 16, xmm31);</span>
<span class="udiff-line-added">+     roundEnc(xmm6, 1);</span>
<span class="udiff-line-added">+     ev_load_key(xmm7, key, 14 * 16, xmm31);</span>
<span class="udiff-line-added">+     lastroundEnc(xmm7, 1);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(REMAINDER8_END_LOOP);</span>
<span class="udiff-line-added">+     // After AES encode rounds, the encrypted block cipher lies in zmm0-zmm1</span>
<span class="udiff-line-added">+     // XOR PT with the encrypted counter and store as CT</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 0 * 64), xmm0, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm1, xmm1, Address(src_addr, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 1 * 64), xmm1, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     addq(pos, 128);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cmpl(len_reg, 64);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, REMAINDER_4);</span>
<span class="udiff-line-added">+     // load mask for incrementing the counter value by 1</span>
<span class="udiff-line-added">+     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 80), Assembler::AVX_128bit, r15);//Linc0 + 16(rip)</span>
<span class="udiff-line-added">+     jmp(REMAINDER_LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Each ZMM register can be used to encode 64 bytes of data, so we have 1 ZMM register used in this block of code</span>
<span class="udiff-line-added">+     bind(REMAINDER_4);</span>
<span class="udiff-line-added">+     subq(len_reg, 64);</span>
<span class="udiff-line-added">+     // As we process 4 blocks at a time, load mask for incrementing the counter value by 4</span>
<span class="udiff-line-added">+     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);//Linc4(rip)</span>
<span class="udiff-line-added">+     // XOR counter with first roundkey</span>
<span class="udiff-line-added">+     vpshufb(xmm0, xmm8, xmm16, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     // Increment counter</span>
<span class="udiff-line-added">+     vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm21, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm22, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm23, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm24, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm25, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm26, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm27, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm28, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm29, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES192_REMAINDER4);</span>
<span class="udiff-line-added">+     vaesenclast(xmm0, xmm0, xmm30, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     jmp(END_REMAINDER4);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(AES192_REMAINDER4);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm30, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     ev_load_key(xmm18, key, 11 * 16, xmm31);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm18, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     ev_load_key(xmm5, key, 12 * 16, xmm31);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cmpl(rounds, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES256_REMAINDER4);</span>
<span class="udiff-line-added">+     vaesenclast(xmm0, xmm0, xmm5, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     jmp(END_REMAINDER4);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(AES256_REMAINDER4);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm5, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     ev_load_key(xmm6, key, 13 * 16, xmm31);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm6, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     ev_load_key(xmm7, key, 14 * 16, xmm31);</span>
<span class="udiff-line-added">+     vaesenclast(xmm0, xmm0, xmm7, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     // After AES encode rounds, the encrypted block cipher lies in zmm0.</span>
<span class="udiff-line-added">+     // XOR encrypted block cipher with PT and store 64 bytes of ciphertext</span>
<span class="udiff-line-added">+     bind(END_REMAINDER4);</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 0), xmm0, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     addq(pos, 64);</span>
<span class="udiff-line-added">+     // load mask for incrementing the counter value by 1</span>
<span class="udiff-line-added">+     evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 80), Assembler::AVX_128bit, r15);//Linc0 + 16(rip)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // For a single block, the AES rounds start here.</span>
<span class="udiff-line-added">+     bind(REMAINDER_LOOP);</span>
<span class="udiff-line-added">+     cmpl(len_reg, 0);</span>
<span class="udiff-line-added">+     jcc(Assembler::belowEqual, END);</span>
<span class="udiff-line-added">+     // XOR counter with first roundkey</span>
<span class="udiff-line-added">+     vpshufb(xmm0, xmm8, xmm16, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, xmm20, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm21, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     // Increment counter by 1</span>
<span class="udiff-line-added">+     vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm22, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm23, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm24, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm25, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm26, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm27, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm28, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm29, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES192_REMAINDER);</span>
<span class="udiff-line-added">+     vaesenclast(xmm0, xmm0, xmm30, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     jmp(END_REMAINDER_LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(AES192_REMAINDER);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm30, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     ev_load_key(xmm18, key, 11 * 16, xmm31);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm18, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     ev_load_key(xmm5, key, 12 * 16, xmm31);</span>
<span class="udiff-line-added">+     cmpl(rounds, 60);</span>
<span class="udiff-line-added">+     jcc(Assembler::aboveEqual, AES256_REMAINDER);</span>
<span class="udiff-line-added">+     vaesenclast(xmm0, xmm0, xmm5, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     jmp(END_REMAINDER_LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(AES256_REMAINDER);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm5, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     ev_load_key(xmm6, key, 13 * 16, xmm31);</span>
<span class="udiff-line-added">+     vaesenc(xmm0, xmm0, xmm6, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     ev_load_key(xmm7, key, 14 * 16, xmm31);</span>
<span class="udiff-line-added">+     vaesenclast(xmm0, xmm0, xmm7, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(END_REMAINDER_LOOP);</span>
<span class="udiff-line-added">+     // If the length register is less than the blockSize i.e. 16</span>
<span class="udiff-line-added">+     // then we store only those bytes of the CT to the destination</span>
<span class="udiff-line-added">+     // corresponding to the length register value</span>
<span class="udiff-line-added">+     // extracting the exact number of bytes is handled by EXTRACT_TAILBYTES</span>
<span class="udiff-line-added">+     cmpl(len_reg, 16);</span>
<span class="udiff-line-added">+     jcc(Assembler::less, EXTRACT_TAILBYTES);</span>
<span class="udiff-line-added">+     subl(len_reg, 16);</span>
<span class="udiff-line-added">+     // After AES encode rounds, the encrypted block cipher lies in xmm0.</span>
<span class="udiff-line-added">+     // If the length register is equal to 16 bytes, store CT in dest after XOR operation.</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0), Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     evmovdquq(Address(dest_addr, pos, Address::times_1, 0), xmm0, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     addl(pos, 16);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     jmp(REMAINDER_LOOP);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(EXTRACT_TAILBYTES);</span>
<span class="udiff-line-added">+     // Save encrypted counter value in xmm0 for next invocation, before XOR operation</span>
<span class="udiff-line-added">+     movdqu(Address(saved_encCounter_start, 0), xmm0);</span>
<span class="udiff-line-added">+     // XOR encryted block cipher in xmm0 with PT to produce CT</span>
<span class="udiff-line-added">+     evpxorq(xmm0, xmm0, Address(src_addr, pos, Address::times_1, 0), Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     // extract upto 15 bytes of CT from xmm0 as specified by length register</span>
<span class="udiff-line-added">+     testptr(len_reg, 8);</span>
<span class="udiff-line-added">+     jcc(Assembler::zero, EXTRACT_TAIL_4BYTES);</span>
<span class="udiff-line-added">+     pextrq(Address(dest_addr, pos), xmm0, 0);</span>
<span class="udiff-line-added">+     psrldq(xmm0, 8);</span>
<span class="udiff-line-added">+     addl(pos, 8);</span>
<span class="udiff-line-added">+     bind(EXTRACT_TAIL_4BYTES);</span>
<span class="udiff-line-added">+     testptr(len_reg, 4);</span>
<span class="udiff-line-added">+     jcc(Assembler::zero, EXTRACT_TAIL_2BYTES);</span>
<span class="udiff-line-added">+     pextrd(Address(dest_addr, pos), xmm0, 0);</span>
<span class="udiff-line-added">+     psrldq(xmm0, 4);</span>
<span class="udiff-line-added">+     addq(pos, 4);</span>
<span class="udiff-line-added">+     bind(EXTRACT_TAIL_2BYTES);</span>
<span class="udiff-line-added">+     testptr(len_reg, 2);</span>
<span class="udiff-line-added">+     jcc(Assembler::zero, EXTRACT_TAIL_1BYTE);</span>
<span class="udiff-line-added">+     pextrw(Address(dest_addr, pos), xmm0, 0);</span>
<span class="udiff-line-added">+     psrldq(xmm0, 2);</span>
<span class="udiff-line-added">+     addl(pos, 2);</span>
<span class="udiff-line-added">+     bind(EXTRACT_TAIL_1BYTE);</span>
<span class="udiff-line-added">+     testptr(len_reg, 1);</span>
<span class="udiff-line-added">+     jcc(Assembler::zero, END);</span>
<span class="udiff-line-added">+     pextrb(Address(dest_addr, pos), xmm0, 0);</span>
<span class="udiff-line-added">+     addl(pos, 1);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(END);</span>
<span class="udiff-line-added">+     // If there are no tail bytes, store counter value and exit</span>
<span class="udiff-line-added">+     cmpl(len_reg, 0);</span>
<span class="udiff-line-added">+     jcc(Assembler::equal, STORE_CTR);</span>
<span class="udiff-line-added">+     movl(Address(used_addr, 0), len_reg);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bind(STORE_CTR);</span>
<span class="udiff-line-added">+     //shuffle updated counter and store it</span>
<span class="udiff-line-added">+     vpshufb(xmm8, xmm8, xmm16, Assembler::AVX_128bit);</span>
<span class="udiff-line-added">+     movdqu(Address(counter, 0), xmm8);</span>
<span class="udiff-line-added">+     // Zero out counter and key registers</span>
<span class="udiff-line-added">+     evpxorq(xmm8, xmm8, xmm8, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm20, xmm20, xmm20, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm21, xmm21, xmm21, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm22, xmm22, xmm22, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm23, xmm23, xmm23, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm24, xmm24, xmm24, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm25, xmm25, xmm25, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm26, xmm26, xmm26, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm27, xmm27, xmm27, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm28, xmm28, xmm28, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm29, xmm29, xmm29, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm30, xmm30, xmm30, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     cmpl(rounds, 44);</span>
<span class="udiff-line-added">+     jcc(Assembler::belowEqual, EXIT);</span>
<span class="udiff-line-added">+     evpxorq(xmm18, xmm18, xmm18, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm5, xmm5, xmm5, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     cmpl(rounds, 52);</span>
<span class="udiff-line-added">+     jcc(Assembler::belowEqual, EXIT);</span>
<span class="udiff-line-added">+     evpxorq(xmm6, xmm6, xmm6, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     evpxorq(xmm7, xmm7, xmm7, Assembler::AVX_512bit);</span>
<span class="udiff-line-added">+     bind(EXIT);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  #endif // _LP64
</pre>
<center><a href="macroAssembler_x86.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_x86.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/x86_32.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // X86 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // architecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // Previously set EBX, ESI, and EDI as save-on-entry for java code
   64 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   65 // Now that allocator is better, turn on ESI and EDI as SOE registers.
   66 
   67 reg_def EBX(SOC, SOE, Op_RegI, 3, rbx-&gt;as_VMReg());
   68 reg_def ECX(SOC, SOC, Op_RegI, 1, rcx-&gt;as_VMReg());
   69 reg_def ESI(SOC, SOE, Op_RegI, 6, rsi-&gt;as_VMReg());
   70 reg_def EDI(SOC, SOE, Op_RegI, 7, rdi-&gt;as_VMReg());
   71 // now that adapter frames are gone EBP is always saved and restored by the prolog/epilog code
   72 reg_def EBP(NS, SOE, Op_RegI, 5, rbp-&gt;as_VMReg());
   73 reg_def EDX(SOC, SOC, Op_RegI, 2, rdx-&gt;as_VMReg());
   74 reg_def EAX(SOC, SOC, Op_RegI, 0, rax-&gt;as_VMReg());
   75 reg_def ESP( NS,  NS, Op_RegI, 4, rsp-&gt;as_VMReg());
   76 
   77 // Float registers.  We treat TOS/FPR0 special.  It is invisible to the
   78 // allocator, and only shows up in the encodings.
   79 reg_def FPR0L( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());
   80 reg_def FPR0H( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());
   81 // Ok so here&#39;s the trick FPR1 is really st(0) except in the midst
   82 // of emission of assembly for a machnode. During the emission the fpu stack
   83 // is pushed making FPR1 == st(1) temporarily. However at any safepoint
   84 // the stack will not have this element so FPR1 == st(0) from the
   85 // oopMap viewpoint. This same weirdness with numbering causes
   86 // instruction encoding to have to play games with the register
   87 // encode to correct for this 0/1 issue. See MachSpillCopyNode::implementation
   88 // where it does flt-&gt;flt moves to see an example
   89 //
   90 reg_def FPR1L( SOC, SOC, Op_RegF, 1, as_FloatRegister(0)-&gt;as_VMReg());
   91 reg_def FPR1H( SOC, SOC, Op_RegF, 1, as_FloatRegister(0)-&gt;as_VMReg()-&gt;next());
   92 reg_def FPR2L( SOC, SOC, Op_RegF, 2, as_FloatRegister(1)-&gt;as_VMReg());
   93 reg_def FPR2H( SOC, SOC, Op_RegF, 2, as_FloatRegister(1)-&gt;as_VMReg()-&gt;next());
   94 reg_def FPR3L( SOC, SOC, Op_RegF, 3, as_FloatRegister(2)-&gt;as_VMReg());
   95 reg_def FPR3H( SOC, SOC, Op_RegF, 3, as_FloatRegister(2)-&gt;as_VMReg()-&gt;next());
   96 reg_def FPR4L( SOC, SOC, Op_RegF, 4, as_FloatRegister(3)-&gt;as_VMReg());
   97 reg_def FPR4H( SOC, SOC, Op_RegF, 4, as_FloatRegister(3)-&gt;as_VMReg()-&gt;next());
   98 reg_def FPR5L( SOC, SOC, Op_RegF, 5, as_FloatRegister(4)-&gt;as_VMReg());
   99 reg_def FPR5H( SOC, SOC, Op_RegF, 5, as_FloatRegister(4)-&gt;as_VMReg()-&gt;next());
  100 reg_def FPR6L( SOC, SOC, Op_RegF, 6, as_FloatRegister(5)-&gt;as_VMReg());
  101 reg_def FPR6H( SOC, SOC, Op_RegF, 6, as_FloatRegister(5)-&gt;as_VMReg()-&gt;next());
  102 reg_def FPR7L( SOC, SOC, Op_RegF, 7, as_FloatRegister(6)-&gt;as_VMReg());
  103 reg_def FPR7H( SOC, SOC, Op_RegF, 7, as_FloatRegister(6)-&gt;as_VMReg()-&gt;next());
  104 //
  105 // Empty fill registers, which are never used, but supply alignment to xmm regs
  106 //
  107 reg_def FILL0( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());
  108 reg_def FILL1( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());
  109 reg_def FILL2( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());
  110 reg_def FILL3( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());
  111 reg_def FILL4( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());
  112 reg_def FILL5( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());
  113 reg_def FILL6( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());
  114 reg_def FILL7( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());
  115 
  116 // Specify priority of register selection within phases of register
  117 // allocation.  Highest priority is first.  A useful heuristic is to
  118 // give registers a low priority when they are required by machine
  119 // instructions, like EAX and EDX.  Registers which are used as
  120 // pairs must fall on an even boundary (witness the FPR#L&#39;s in this list).
  121 // For the Intel integer registers, the equivalent Long pairs are
  122 // EDX:EAX, EBX:ECX, and EDI:EBP.
  123 alloc_class chunk0( ECX,   EBX,   EBP,   EDI,   EAX,   EDX,   ESI, ESP,
  124                     FPR0L, FPR0H, FPR1L, FPR1H, FPR2L, FPR2H,
  125                     FPR3L, FPR3H, FPR4L, FPR4H, FPR5L, FPR5H,
  126                     FPR6L, FPR6H, FPR7L, FPR7H,
  127                     FILL0, FILL1, FILL2, FILL3, FILL4, FILL5, FILL6, FILL7);
  128 
  129 
  130 //----------Architecture Description Register Classes--------------------------
  131 // Several register classes are automatically defined based upon information in
  132 // this architecture description.
  133 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  134 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  135 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  136 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  137 //
  138 // Class for no registers (empty set).
  139 reg_class no_reg();
  140 
  141 // Class for all registers
  142 reg_class any_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, ECX, EBX, ESP);
  143 // Class for all registers (excluding EBP)
  144 reg_class any_reg_no_ebp(EAX, EDX, EDI, ESI, ECX, EBX, ESP);
  145 // Dynamic register class that selects at runtime between register classes
  146 // any_reg and any_no_ebp_reg (depending on the value of the flag PreserveFramePointer).
  147 // Equivalent to: return PreserveFramePointer ? any_no_ebp_reg : any_reg;
  148 reg_class_dynamic any_reg(any_reg_no_ebp, any_reg_with_ebp, %{ PreserveFramePointer %});
  149 
  150 // Class for general registers
  151 reg_class int_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, ECX, EBX);
  152 // Class for general registers (excluding EBP).
  153 // This register class can be used for implicit null checks on win95.
  154 // It is also safe for use by tailjumps (we don&#39;t want to allocate in ebp).
  155 // Used also if the PreserveFramePointer flag is true.
  156 reg_class int_reg_no_ebp(EAX, EDX, EDI, ESI, ECX, EBX);
  157 // Dynamic register class that selects between int_reg and int_reg_no_ebp.
  158 reg_class_dynamic int_reg(int_reg_no_ebp, int_reg_with_ebp, %{ PreserveFramePointer %});
  159 
  160 // Class of &quot;X&quot; registers
  161 reg_class int_x_reg(EBX, ECX, EDX, EAX);
  162 
  163 // Class of registers that can appear in an address with no offset.
  164 // EBP and ESP require an extra instruction byte for zero offset.
  165 // Used in fast-unlock
  166 reg_class p_reg(EDX, EDI, ESI, EBX);
  167 
  168 // Class for general registers excluding ECX
  169 reg_class ncx_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, EBX);
  170 // Class for general registers excluding ECX (and EBP)
  171 reg_class ncx_reg_no_ebp(EAX, EDX, EDI, ESI, EBX);
  172 // Dynamic register class that selects between ncx_reg and ncx_reg_no_ebp.
  173 reg_class_dynamic ncx_reg(ncx_reg_no_ebp, ncx_reg_with_ebp, %{ PreserveFramePointer %});
  174 
  175 // Class for general registers excluding EAX
  176 reg_class nax_reg(EDX, EDI, ESI, ECX, EBX);
  177 
  178 // Class for general registers excluding EAX and EBX.
  179 reg_class nabx_reg_with_ebp(EDX, EDI, ESI, ECX, EBP);
  180 // Class for general registers excluding EAX and EBX (and EBP)
  181 reg_class nabx_reg_no_ebp(EDX, EDI, ESI, ECX);
  182 // Dynamic register class that selects between nabx_reg and nabx_reg_no_ebp.
  183 reg_class_dynamic nabx_reg(nabx_reg_no_ebp, nabx_reg_with_ebp, %{ PreserveFramePointer %});
  184 
  185 // Class of EAX (for multiply and divide operations)
  186 reg_class eax_reg(EAX);
  187 
  188 // Class of EBX (for atomic add)
  189 reg_class ebx_reg(EBX);
  190 
  191 // Class of ECX (for shift and JCXZ operations and cmpLTMask)
  192 reg_class ecx_reg(ECX);
  193 
  194 // Class of EDX (for multiply and divide operations)
  195 reg_class edx_reg(EDX);
  196 
  197 // Class of EDI (for synchronization)
  198 reg_class edi_reg(EDI);
  199 
  200 // Class of ESI (for synchronization)
  201 reg_class esi_reg(ESI);
  202 
  203 // Singleton class for stack pointer
  204 reg_class sp_reg(ESP);
  205 
  206 // Singleton class for instruction pointer
  207 // reg_class ip_reg(EIP);
  208 
  209 // Class of integer register pairs
  210 reg_class long_reg_with_ebp( EAX,EDX, ECX,EBX, EBP,EDI );
  211 // Class of integer register pairs (excluding EBP and EDI);
  212 reg_class long_reg_no_ebp( EAX,EDX, ECX,EBX );
  213 // Dynamic register class that selects between long_reg and long_reg_no_ebp.
  214 reg_class_dynamic long_reg(long_reg_no_ebp, long_reg_with_ebp, %{ PreserveFramePointer %});
  215 
  216 // Class of integer register pairs that aligns with calling convention
  217 reg_class eadx_reg( EAX,EDX );
  218 reg_class ebcx_reg( ECX,EBX );
  219 
  220 // Not AX or DX, used in divides
  221 reg_class nadx_reg_with_ebp(EBX, ECX, ESI, EDI, EBP);
  222 // Not AX or DX (and neither EBP), used in divides
  223 reg_class nadx_reg_no_ebp(EBX, ECX, ESI, EDI);
  224 // Dynamic register class that selects between nadx_reg and nadx_reg_no_ebp.
  225 reg_class_dynamic nadx_reg(nadx_reg_no_ebp, nadx_reg_with_ebp, %{ PreserveFramePointer %});
  226 
  227 // Floating point registers.  Notice FPR0 is not a choice.
  228 // FPR0 is not ever allocated; we use clever encodings to fake
  229 // a 2-address instructions out of Intels FP stack.
  230 reg_class fp_flt_reg( FPR1L,FPR2L,FPR3L,FPR4L,FPR5L,FPR6L,FPR7L );
  231 
  232 reg_class fp_dbl_reg( FPR1L,FPR1H, FPR2L,FPR2H, FPR3L,FPR3H,
  233                       FPR4L,FPR4H, FPR5L,FPR5H, FPR6L,FPR6H,
  234                       FPR7L,FPR7H );
  235 
  236 reg_class fp_flt_reg0( FPR1L );
  237 reg_class fp_dbl_reg0( FPR1L,FPR1H );
  238 reg_class fp_dbl_reg1( FPR2L,FPR2H );
  239 reg_class fp_dbl_notreg0( FPR2L,FPR2H, FPR3L,FPR3H, FPR4L,FPR4H,
  240                           FPR5L,FPR5H, FPR6L,FPR6H, FPR7L,FPR7H );
  241 
  242 %}
  243 
  244 
  245 //----------SOURCE BLOCK-------------------------------------------------------
  246 // This is a block of C++ code which provides values, functions, and
  247 // definitions necessary in the rest of the architecture description
  248 source_hpp %{
  249 // Must be visible to the DFA in dfa_x86_32.cpp
  250 extern bool is_operand_hi32_zero(Node* n);
  251 %}
  252 
  253 source %{
  254 #define   RELOC_IMM32    Assembler::imm_operand
  255 #define   RELOC_DISP32   Assembler::disp32_operand
  256 
  257 #define __ _masm.
  258 
  259 // How to find the high register of a Long pair, given the low register
  260 #define   HIGH_FROM_LOW(x) ((x)+2)
  261 
  262 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  263 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  264 // fast versions of NegF/NegD and AbsF/AbsD.
  265 
  266 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  267 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  268   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  269   // of 128-bits operands for SSE instructions.
  270   jlong *operand = (jlong*)(((uintptr_t)adr)&amp;((uintptr_t)(~0xF)));
  271   // Store the value to a 128-bits operand.
  272   operand[0] = lo;
  273   operand[1] = hi;
  274   return operand;
  275 }
  276 
  277 // Buffer for 128-bits masks used by SSE instructions.
  278 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  279 
  280 // Static initialization during VM startup.
  281 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2], CONST64(0x7FFFFFFF7FFFFFFF), CONST64(0x7FFFFFFF7FFFFFFF));
  282 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2], CONST64(0x7FFFFFFFFFFFFFFF), CONST64(0x7FFFFFFFFFFFFFFF));
  283 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], CONST64(0x8000000080000000), CONST64(0x8000000080000000));
  284 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], CONST64(0x8000000000000000), CONST64(0x8000000000000000));
  285 
  286 // Offset hacking within calls.
  287 static int pre_call_resets_size() {
  288   int size = 0;
  289   Compile* C = Compile::current();
  290   if (C-&gt;in_24_bit_fp_mode()) {
  291     size += 6; // fldcw
  292   }
  293   if (VM_Version::supports_vzeroupper()) {
  294     size += 3; // vzeroupper
  295   }
  296   return size;
  297 }
  298 
  299 // !!!!! Special hack to get all type of calls to specify the byte offset
  300 //       from the start of the call to the point where the return address
  301 //       will point.
  302 int MachCallStaticJavaNode::ret_addr_offset() {
  303   return 5 + pre_call_resets_size();  // 5 bytes from start of call to where return address points
  304 }
  305 
  306 int MachCallDynamicJavaNode::ret_addr_offset() {
  307   return 10 + pre_call_resets_size();  // 10 bytes from start of call to where return address points
  308 }
  309 
  310 static int sizeof_FFree_Float_Stack_All = -1;
  311 
  312 int MachCallRuntimeNode::ret_addr_offset() {
  313   assert(sizeof_FFree_Float_Stack_All != -1, &quot;must have been emitted already&quot;);
  314   return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();
  315 }
  316 
  317 // Indicate if the safepoint node needs the polling page as an input.
  318 // Since x86 does have absolute addressing, it doesn&#39;t.
  319 bool SafePointNode::needs_polling_address_input() {
  320   return SafepointMechanism::uses_thread_local_poll();
  321 }
  322 
  323 //
  324 // Compute padding required for nodes which need alignment
  325 //
  326 
  327 // The address of the call instruction needs to be 4-byte aligned to
  328 // ensure that it does not span a cache line so that it can be patched.
  329 int CallStaticJavaDirectNode::compute_padding(int current_offset) const {
  330   current_offset += pre_call_resets_size();  // skip fldcw, if any
  331   current_offset += 1;      // skip call opcode byte
  332   return align_up(current_offset, alignment_required()) - current_offset;
  333 }
  334 
  335 // The address of the call instruction needs to be 4-byte aligned to
  336 // ensure that it does not span a cache line so that it can be patched.
  337 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const {
  338   current_offset += pre_call_resets_size();  // skip fldcw, if any
  339   current_offset += 5;      // skip MOV instruction
  340   current_offset += 1;      // skip call opcode byte
  341   return align_up(current_offset, alignment_required()) - current_offset;
  342 }
  343 
  344 // EMIT_RM()
  345 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  346   unsigned char c = (unsigned char)((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  347   cbuf.insts()-&gt;emit_int8(c);
  348 }
  349 
  350 // EMIT_CC()
  351 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  352   unsigned char c = (unsigned char)( f1 | f2 );
  353   cbuf.insts()-&gt;emit_int8(c);
  354 }
  355 
  356 // EMIT_OPCODE()
  357 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  358   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  359 }
  360 
  361 // EMIT_OPCODE() w/ relocation information
  362 void emit_opcode(CodeBuffer &amp;cbuf, int code, relocInfo::relocType reloc, int offset = 0) {
  363   cbuf.relocate(cbuf.insts_mark() + offset, reloc);
  364   emit_opcode(cbuf, code);
  365 }
  366 
  367 // EMIT_D8()
  368 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  369   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  370 }
  371 
  372 // EMIT_D16()
  373 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  374   cbuf.insts()-&gt;emit_int16(d16);
  375 }
  376 
  377 // EMIT_D32()
  378 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  379   cbuf.insts()-&gt;emit_int32(d32);
  380 }
  381 
  382 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  383 void emit_d32_reloc(CodeBuffer &amp;cbuf, int d32, relocInfo::relocType reloc,
  384         int format) {
  385   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  386   cbuf.insts()-&gt;emit_int32(d32);
  387 }
  388 
  389 // emit 32 bit value and construct relocation entry from RelocationHolder
  390 void emit_d32_reloc(CodeBuffer &amp;cbuf, int d32, RelocationHolder const&amp; rspec,
  391         int format) {
  392 #ifdef ASSERT
  393   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp; d32 != 0 &amp;&amp; d32 != (int)Universe::non_oop_word()) {
  394     assert(oopDesc::is_oop(cast_to_oop(d32)), &quot;cannot embed broken oops in code&quot;);
  395   }
  396 #endif
  397   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  398   cbuf.insts()-&gt;emit_int32(d32);
  399 }
  400 
  401 // Access stack slot for load or store
  402 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp) {
  403   emit_opcode( cbuf, opcode );               // (e.g., FILD   [ESP+src])
  404   if( -128 &lt;= disp &amp;&amp; disp &lt;= 127 ) {
  405     emit_rm( cbuf, 0x01, rm_field, ESP_enc );  // R/M byte
  406     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    // SIB byte
  407     emit_d8 (cbuf, disp);     // Displacement  // R/M byte
  408   } else {
  409     emit_rm( cbuf, 0x02, rm_field, ESP_enc );  // R/M byte
  410     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    // SIB byte
  411     emit_d32(cbuf, disp);     // Displacement  // R/M byte
  412   }
  413 }
  414 
  415    // rRegI ereg, memory mem) %{    // emit_reg_mem
  416 void encode_RegMem( CodeBuffer &amp;cbuf, int reg_encoding, int base, int index, int scale, int displace, relocInfo::relocType disp_reloc ) {
  417   // There is no index &amp; no scale, use form without SIB byte
  418   if ((index == 0x4) &amp;&amp;
  419       (scale == 0) &amp;&amp; (base != ESP_enc)) {
  420     // If no displacement, mode is 0x0; unless base is [EBP]
  421     if ( (displace == 0) &amp;&amp; (base != EBP_enc) ) {
  422       emit_rm(cbuf, 0x0, reg_encoding, base);
  423     }
  424     else {                    // If 8-bit displacement, mode 0x1
  425       if ((displace &gt;= -128) &amp;&amp; (displace &lt;= 127)
  426           &amp;&amp; (disp_reloc == relocInfo::none) ) {
  427         emit_rm(cbuf, 0x1, reg_encoding, base);
  428         emit_d8(cbuf, displace);
  429       }
  430       else {                  // If 32-bit displacement
  431         if (base == -1) { // Special flag for absolute address
  432           emit_rm(cbuf, 0x0, reg_encoding, 0x5);
  433           // (manual lies; no SIB needed here)
  434           if ( disp_reloc != relocInfo::none ) {
  435             emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  436           } else {
  437             emit_d32      (cbuf, displace);
  438           }
  439         }
  440         else {                // Normal base + offset
  441           emit_rm(cbuf, 0x2, reg_encoding, base);
  442           if ( disp_reloc != relocInfo::none ) {
  443             emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  444           } else {
  445             emit_d32      (cbuf, displace);
  446           }
  447         }
  448       }
  449     }
  450   }
  451   else {                      // Else, encode with the SIB byte
  452     // If no displacement, mode is 0x0; unless base is [EBP]
  453     if (displace == 0 &amp;&amp; (base != EBP_enc)) {  // If no displacement
  454       emit_rm(cbuf, 0x0, reg_encoding, 0x4);
  455       emit_rm(cbuf, scale, index, base);
  456     }
  457     else {                    // If 8-bit displacement, mode 0x1
  458       if ((displace &gt;= -128) &amp;&amp; (displace &lt;= 127)
  459           &amp;&amp; (disp_reloc == relocInfo::none) ) {
  460         emit_rm(cbuf, 0x1, reg_encoding, 0x4);
  461         emit_rm(cbuf, scale, index, base);
  462         emit_d8(cbuf, displace);
  463       }
  464       else {                  // If 32-bit displacement
  465         if (base == 0x04 ) {
  466           emit_rm(cbuf, 0x2, reg_encoding, 0x4);
  467           emit_rm(cbuf, scale, index, 0x04);
  468         } else {
  469           emit_rm(cbuf, 0x2, reg_encoding, 0x4);
  470           emit_rm(cbuf, scale, index, base);
  471         }
  472         if ( disp_reloc != relocInfo::none ) {
  473           emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  474         } else {
  475           emit_d32      (cbuf, displace);
  476         }
  477       }
  478     }
  479   }
  480 }
  481 
  482 
  483 void encode_Copy( CodeBuffer &amp;cbuf, int dst_encoding, int src_encoding ) {
  484   if( dst_encoding == src_encoding ) {
  485     // reg-reg copy, use an empty encoding
  486   } else {
  487     emit_opcode( cbuf, 0x8B );
  488     emit_rm(cbuf, 0x3, dst_encoding, src_encoding );
  489   }
  490 }
  491 
  492 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  493   Label exit;
  494   __ jccb(Assembler::noParity, exit);
  495   __ pushf();
  496   //
  497   // comiss/ucomiss instructions set ZF,PF,CF flags and
  498   // zero OF,AF,SF for NaN values.
  499   // Fixup flags by zeroing ZF,PF so that compare of NaN
  500   // values returns &#39;less than&#39; result (CF is set).
  501   // Leave the rest of flags unchanged.
  502   //
  503   //    7 6 5 4 3 2 1 0
  504   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  505   //    0 0 1 0 1 0 1 1   (0x2B)
  506   //
  507   __ andl(Address(rsp, 0), 0xffffff2b);
  508   __ popf();
  509   __ bind(exit);
  510 }
  511 
  512 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  513   Label done;
  514   __ movl(dst, -1);
  515   __ jcc(Assembler::parity, done);
  516   __ jcc(Assembler::below, done);
  517   __ setb(Assembler::notEqual, dst);
  518   __ movzbl(dst, dst);
  519   __ bind(done);
  520 }
  521 
  522 
  523 //=============================================================================
  524 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  525 
  526 int Compile::ConstantTable::calculate_table_base_offset() const {
  527   return 0;  // absolute addressing, no offset
  528 }
  529 
  530 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  531 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  532   ShouldNotReachHere();
  533 }
  534 
  535 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  536   // Empty encoding
  537 }
  538 
  539 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  540   return 0;
  541 }
  542 
  543 #ifndef PRODUCT
  544 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  545   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  546 }
  547 #endif
  548 
  549 
  550 //=============================================================================
  551 #ifndef PRODUCT
  552 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  553   Compile* C = ra_-&gt;C;
  554 
  555   int framesize = C-&gt;frame_size_in_bytes();
  556   int bangsize = C-&gt;bang_size_in_bytes();
  557   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  558   // Remove wordSize for return addr which is already pushed.
  559   framesize -= wordSize;
  560 
  561   if (C-&gt;need_stack_bang(bangsize)) {
  562     framesize -= wordSize;
  563     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  564     st-&gt;print(&quot;\n\t&quot;);
  565     st-&gt;print(&quot;PUSH   EBP\t# Save EBP&quot;);
  566     if (PreserveFramePointer) {
  567       st-&gt;print(&quot;\n\t&quot;);
  568       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  569     }
  570     if (framesize) {
  571       st-&gt;print(&quot;\n\t&quot;);
  572       st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  573     }
  574   } else {
  575     st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  576     st-&gt;print(&quot;\n\t&quot;);
  577     framesize -= wordSize;
  578     st-&gt;print(&quot;MOV    [ESP + #%d], EBP\t# Save EBP&quot;,framesize);
  579     if (PreserveFramePointer) {
  580       st-&gt;print(&quot;\n\t&quot;);
  581       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  582       if (framesize &gt; 0) {
  583         st-&gt;print(&quot;\n\t&quot;);
  584         st-&gt;print(&quot;ADD    EBP, #%d&quot;, framesize);
  585       }
  586     }
  587   }
  588 
  589   if (VerifyStackAtCalls) {
  590     st-&gt;print(&quot;\n\t&quot;);
  591     framesize -= wordSize;
  592     st-&gt;print(&quot;MOV    [ESP + #%d], 0xBADB100D\t# Majik cookie for stack depth check&quot;,framesize);
  593   }
  594 
  595   if( C-&gt;in_24_bit_fp_mode() ) {
  596     st-&gt;print(&quot;\n\t&quot;);
  597     st-&gt;print(&quot;FLDCW  \t# load 24 bit fpu control word&quot;);
  598   }
  599   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
  600     st-&gt;print(&quot;\n\t&quot;);
  601     st-&gt;print(&quot;# verify FPU stack (must be clean on entry)&quot;);
  602   }
  603 
  604 #ifdef ASSERT
  605   if (VerifyStackAtCalls) {
  606     st-&gt;print(&quot;\n\t&quot;);
  607     st-&gt;print(&quot;# stack alignment check&quot;);
  608   }
  609 #endif
  610   st-&gt;cr();
  611 }
  612 #endif
  613 
  614 
  615 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  616   Compile* C = ra_-&gt;C;
  617   MacroAssembler _masm(&amp;cbuf);
  618 
  619   int framesize = C-&gt;frame_size_in_bytes();
  620   int bangsize = C-&gt;bang_size_in_bytes();
  621 
  622   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, C-&gt;in_24_bit_fp_mode(), C-&gt;stub_function() != NULL);
  623 
  624   C-&gt;set_frame_complete(cbuf.insts_size());
  625 
  626   if (C-&gt;has_mach_constant_base_node()) {
  627     // NOTE: We set the table base offset here because users might be
  628     // emitted before MachConstantBaseNode.
  629     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
  630     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  631   }
  632 }
  633 
  634 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  635   return MachNode::size(ra_); // too many variables; just compute it the hard way
  636 }
  637 
  638 int MachPrologNode::reloc() const {
  639   return 0; // a large enough number
  640 }
  641 
  642 //=============================================================================
  643 #ifndef PRODUCT
  644 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  645   Compile *C = ra_-&gt;C;
  646   int framesize = C-&gt;frame_size_in_bytes();
  647   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  648   // Remove two words for return addr and rbp,
  649   framesize -= 2*wordSize;
  650 
  651   if (C-&gt;max_vector_size() &gt; 16) {
  652     st-&gt;print(&quot;VZEROUPPER&quot;);
  653     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  654   }
  655   if (C-&gt;in_24_bit_fp_mode()) {
  656     st-&gt;print(&quot;FLDCW  standard control word&quot;);
  657     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  658   }
  659   if (framesize) {
  660     st-&gt;print(&quot;ADD    ESP,%d\t# Destroy frame&quot;,framesize);
  661     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  662   }
  663   st-&gt;print_cr(&quot;POPL   EBP&quot;); st-&gt;print(&quot;\t&quot;);
  664   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  665     st-&gt;print(&quot;TEST   PollPage,EAX\t! Poll Safepoint&quot;);
  666     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  667   }
  668 }
  669 #endif
  670 
  671 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  672   Compile *C = ra_-&gt;C;
  673   MacroAssembler _masm(&amp;cbuf);
  674 
  675   if (C-&gt;max_vector_size() &gt; 16) {
  676     // Clear upper bits of YMM registers when current compiled code uses
  677     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  678     _masm.vzeroupper();
  679   }
  680   // If method set FPU control word, restore to standard control word
  681   if (C-&gt;in_24_bit_fp_mode()) {
  682     _masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
  683   }
  684 
  685   int framesize = C-&gt;frame_size_in_bytes();
  686   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  687   // Remove two words for return addr and rbp,
  688   framesize -= 2*wordSize;
  689 
  690   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  691 
  692   if (framesize &gt;= 128) {
  693     emit_opcode(cbuf, 0x81); // add  SP, #framesize
  694     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  695     emit_d32(cbuf, framesize);
  696   } else if (framesize) {
  697     emit_opcode(cbuf, 0x83); // add  SP, #framesize
  698     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  699     emit_d8(cbuf, framesize);
  700   }
  701 
  702   emit_opcode(cbuf, 0x58 | EBP_enc);
  703 
  704   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  705     __ reserved_stack_check();
  706   }
  707 
  708   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  709     if (SafepointMechanism::uses_thread_local_poll()) {
  710       Register pollReg = as_Register(EBX_enc);
  711       MacroAssembler masm(&amp;cbuf);
  712       masm.get_thread(pollReg);
  713       masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));
  714       masm.relocate(relocInfo::poll_return_type);
  715       masm.testl(rax, Address(pollReg, 0));
  716     } else {
  717       cbuf.relocate(cbuf.insts_end(), relocInfo::poll_return_type, 0);
  718       emit_opcode(cbuf,0x85);
  719       emit_rm(cbuf, 0x0, EAX_enc, 0x5); // EAX
  720       emit_d32(cbuf, (intptr_t)os::get_polling_page());
  721     }
  722   }
  723 }
  724 
  725 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  726   return MachNode::size(ra_); // too many variables; just compute it
  727                               // the hard way
  728 }
  729 
  730 int MachEpilogNode::reloc() const {
  731   return 0; // a large enough number
  732 }
  733 
  734 const Pipeline * MachEpilogNode::pipeline() const {
  735   return MachNode::pipeline_class();
  736 }
  737 
  738 int MachEpilogNode::safepoint_offset() const { return 0; }
  739 
  740 //=============================================================================
  741 
  742 enum RC { rc_bad, rc_int, rc_float, rc_xmm, rc_stack };
  743 static enum RC rc_class( OptoReg::Name reg ) {
  744 
  745   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  746   if (OptoReg::is_stack(reg)) return rc_stack;
  747 
  748   VMReg r = OptoReg::as_VMReg(reg);
  749   if (r-&gt;is_Register()) return rc_int;
  750   if (r-&gt;is_FloatRegister()) {
  751     assert(UseSSE &lt; 2, &quot;shouldn&#39;t be used in SSE2+ mode&quot;);
  752     return rc_float;
  753   }
  754   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  755   return rc_xmm;
  756 }
  757 
  758 static int impl_helper( CodeBuffer *cbuf, bool do_size, bool is_load, int offset, int reg,
  759                         int opcode, const char *op_str, int size, outputStream* st ) {
  760   if( cbuf ) {
  761     emit_opcode  (*cbuf, opcode );
  762     encode_RegMem(*cbuf, Matcher::_regEncode[reg], ESP_enc, 0x4, 0, offset, relocInfo::none);
  763 #ifndef PRODUCT
  764   } else if( !do_size ) {
  765     if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  766     if( opcode == 0x8B || opcode == 0x89 ) { // MOV
  767       if( is_load ) st-&gt;print(&quot;%s   %s,[ESP + #%d]&quot;,op_str,Matcher::regName[reg],offset);
  768       else          st-&gt;print(&quot;%s   [ESP + #%d],%s&quot;,op_str,offset,Matcher::regName[reg]);
  769     } else { // FLD, FST, PUSH, POP
  770       st-&gt;print(&quot;%s [ESP + #%d]&quot;,op_str,offset);
  771     }
  772 #endif
  773   }
  774   int offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
  775   return size+3+offset_size;
  776 }
  777 
  778 // Helper for XMM registers.  Extra opcode bits, limited syntax.
  779 static int impl_x_helper( CodeBuffer *cbuf, bool do_size, bool is_load,
  780                          int offset, int reg_lo, int reg_hi, int size, outputStream* st ) {
  781   int in_size_in_bits = Assembler::EVEX_32bit;
  782   int evex_encoding = 0;
  783   if (reg_lo+1 == reg_hi) {
  784     in_size_in_bits = Assembler::EVEX_64bit;
  785     evex_encoding = Assembler::VEX_W;
  786   }
  787   if (cbuf) {
  788     MacroAssembler _masm(cbuf);
  789     // EVEX spills remain EVEX: Compressed displacemement is better than AVX on spill mem operations,
  790     //                          it maps more cases to single byte displacement
  791     _masm.set_managed();
  792     if (reg_lo+1 == reg_hi) { // double move?
  793       if (is_load) {
  794         __ movdbl(as_XMMRegister(Matcher::_regEncode[reg_lo]), Address(rsp, offset));
  795       } else {
  796         __ movdbl(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[reg_lo]));
  797       }
  798     } else {
  799       if (is_load) {
  800         __ movflt(as_XMMRegister(Matcher::_regEncode[reg_lo]), Address(rsp, offset));
  801       } else {
  802         __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[reg_lo]));
  803       }
  804     }
  805 #ifndef PRODUCT
  806   } else if (!do_size) {
  807     if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  808     if (reg_lo+1 == reg_hi) { // double move?
  809       if (is_load) st-&gt;print(&quot;%s %s,[ESP + #%d]&quot;,
  810                               UseXmmLoadAndClearUpper ? &quot;MOVSD &quot; : &quot;MOVLPD&quot;,
  811                               Matcher::regName[reg_lo], offset);
  812       else         st-&gt;print(&quot;MOVSD  [ESP + #%d],%s&quot;,
  813                               offset, Matcher::regName[reg_lo]);
  814     } else {
  815       if (is_load) st-&gt;print(&quot;MOVSS  %s,[ESP + #%d]&quot;,
  816                               Matcher::regName[reg_lo], offset);
  817       else         st-&gt;print(&quot;MOVSS  [ESP + #%d],%s&quot;,
  818                               offset, Matcher::regName[reg_lo]);
  819     }
  820 #endif
  821   }
  822   bool is_single_byte = false;
  823   if ((UseAVX &gt; 2) &amp;&amp; (offset != 0)) {
  824     is_single_byte = Assembler::query_compressed_disp_byte(offset, true, 0, Assembler::EVEX_T1S, in_size_in_bits, evex_encoding);
  825   }
  826   int offset_size = 0;
  827   if (UseAVX &gt; 2 ) {
  828     offset_size = (offset == 0) ? 0 : ((is_single_byte) ? 1 : 4);
  829   } else {
  830     offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
  831   }
  832   size += (UseAVX &gt; 2) ? 2 : 0; // Need an additional two bytes for EVEX
  833   // VEX_2bytes prefix is used if UseAVX &gt; 0, so it takes the same 2 bytes as SIMD prefix.
  834   return size+5+offset_size;
  835 }
  836 
  837 
  838 static int impl_movx_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  839                             int src_hi, int dst_hi, int size, outputStream* st ) {
  840   if (cbuf) {
  841     MacroAssembler _masm(cbuf);
  842     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  843     _masm.set_managed();
  844     if (src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) { // double move?
  845       __ movdbl(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  846                 as_XMMRegister(Matcher::_regEncode[src_lo]));
  847     } else {
  848       __ movflt(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  849                 as_XMMRegister(Matcher::_regEncode[src_lo]));
  850     }
  851 #ifndef PRODUCT
  852   } else if (!do_size) {
  853     if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  854     if (UseXmmRegToRegMoveAll) {//Use movaps,movapd to move between xmm registers
  855       if (src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) { // double move?
  856         st-&gt;print(&quot;MOVAPD %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  857       } else {
  858         st-&gt;print(&quot;MOVAPS %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  859       }
  860     } else {
  861       if( src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi ) { // double move?
  862         st-&gt;print(&quot;MOVSD  %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  863       } else {
  864         st-&gt;print(&quot;MOVSS  %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  865       }
  866     }
  867 #endif
  868   }
  869   // VEX_2bytes prefix is used if UseAVX &gt; 0, and it takes the same 2 bytes as SIMD prefix.
  870   // Only MOVAPS SSE prefix uses 1 byte.  EVEX uses an additional 2 bytes.
  871   int sz = (UseAVX &gt; 2) ? 6 : 4;
  872   if (!(src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) &amp;&amp;
  873       UseXmmRegToRegMoveAll &amp;&amp; (UseAVX == 0)) sz = 3;
  874   return size + sz;
  875 }
  876 
  877 static int impl_movgpr2x_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  878                             int src_hi, int dst_hi, int size, outputStream* st ) {
  879   // 32-bit
  880   if (cbuf) {
  881     MacroAssembler _masm(cbuf);
  882     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  883     _masm.set_managed();
  884     __ movdl(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  885              as_Register(Matcher::_regEncode[src_lo]));
  886 #ifndef PRODUCT
  887   } else if (!do_size) {
  888     st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
  889 #endif
  890   }
  891   return (UseAVX&gt; 2) ? 6 : 4;
  892 }
  893 
  894 
  895 static int impl_movx2gpr_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  896                                  int src_hi, int dst_hi, int size, outputStream* st ) {
  897   // 32-bit
  898   if (cbuf) {
  899     MacroAssembler _masm(cbuf);
  900     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  901     _masm.set_managed();
  902     __ movdl(as_Register(Matcher::_regEncode[dst_lo]),
  903              as_XMMRegister(Matcher::_regEncode[src_lo]));
  904 #ifndef PRODUCT
  905   } else if (!do_size) {
  906     st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
  907 #endif
  908   }
  909   return (UseAVX&gt; 2) ? 6 : 4;
  910 }
  911 
  912 static int impl_mov_helper( CodeBuffer *cbuf, bool do_size, int src, int dst, int size, outputStream* st ) {
  913   if( cbuf ) {
  914     emit_opcode(*cbuf, 0x8B );
  915     emit_rm    (*cbuf, 0x3, Matcher::_regEncode[dst], Matcher::_regEncode[src] );
  916 #ifndef PRODUCT
  917   } else if( !do_size ) {
  918     if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  919     st-&gt;print(&quot;MOV    %s,%s&quot;,Matcher::regName[dst],Matcher::regName[src]);
  920 #endif
  921   }
  922   return size+2;
  923 }
  924 
  925 static int impl_fp_store_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int src_hi, int dst_lo, int dst_hi,
  926                                  int offset, int size, outputStream* st ) {
  927   if( src_lo != FPR1L_num ) {      // Move value to top of FP stack, if not already there
  928     if( cbuf ) {
  929       emit_opcode( *cbuf, 0xD9 );  // FLD (i.e., push it)
  930       emit_d8( *cbuf, 0xC0-1+Matcher::_regEncode[src_lo] );
  931 #ifndef PRODUCT
  932     } else if( !do_size ) {
  933       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  934       st-&gt;print(&quot;FLD    %s&quot;,Matcher::regName[src_lo]);
  935 #endif
  936     }
  937     size += 2;
  938   }
  939 
  940   int st_op = (src_lo != FPR1L_num) ? EBX_num /*store &amp; pop*/ : EDX_num /*store no pop*/;
  941   const char *op_str;
  942   int op;
  943   if( src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi ) { // double store?
  944     op_str = (src_lo != FPR1L_num) ? &quot;FSTP_D&quot; : &quot;FST_D &quot;;
  945     op = 0xDD;
  946   } else {                   // 32-bit store
  947     op_str = (src_lo != FPR1L_num) ? &quot;FSTP_S&quot; : &quot;FST_S &quot;;
  948     op = 0xD9;
  949     assert( !OptoReg::is_valid(src_hi) &amp;&amp; !OptoReg::is_valid(dst_hi), &quot;no non-adjacent float-stores&quot; );
  950   }
  951 
  952   return impl_helper(cbuf,do_size,false,offset,st_op,op,op_str,size, st);
  953 }
  954 
  955 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
  956 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  957                           int src_hi, int dst_hi, uint ireg, outputStream* st);
  958 
  959 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
  960                             int stack_offset, int reg, uint ireg, outputStream* st);
  961 
  962 static int vec_stack_to_stack_helper(CodeBuffer *cbuf, bool do_size, int src_offset,
  963                                      int dst_offset, uint ireg, outputStream* st) {
  964   int calc_size = 0;
  965   int src_offset_size = (src_offset == 0) ? 0 : ((src_offset &lt; 0x80) ? 1 : 4);
  966   int dst_offset_size = (dst_offset == 0) ? 0 : ((dst_offset &lt; 0x80) ? 1 : 4);
  967   switch (ireg) {
  968   case Op_VecS:
  969     calc_size = 3+src_offset_size + 3+dst_offset_size;
  970     break;
  971   case Op_VecD: {
  972     calc_size = 3+src_offset_size + 3+dst_offset_size;
  973     int tmp_src_offset = src_offset + 4;
  974     int tmp_dst_offset = dst_offset + 4;
  975     src_offset_size = (tmp_src_offset == 0) ? 0 : ((tmp_src_offset &lt; 0x80) ? 1 : 4);
  976     dst_offset_size = (tmp_dst_offset == 0) ? 0 : ((tmp_dst_offset &lt; 0x80) ? 1 : 4);
  977     calc_size += 3+src_offset_size + 3+dst_offset_size;
  978     break;
  979   }
  980   case Op_VecX:
  981   case Op_VecY:
  982   case Op_VecZ:
  983     calc_size = 6 + 6 + 5+src_offset_size + 5+dst_offset_size;
  984     break;
  985   default:
  986     ShouldNotReachHere();
  987   }
  988   if (cbuf) {
  989     MacroAssembler _masm(cbuf);
  990     int offset = __ offset();
  991     switch (ireg) {
  992     case Op_VecS:
  993       __ pushl(Address(rsp, src_offset));
  994       __ popl (Address(rsp, dst_offset));
  995       break;
  996     case Op_VecD:
  997       __ pushl(Address(rsp, src_offset));
  998       __ popl (Address(rsp, dst_offset));
  999       __ pushl(Address(rsp, src_offset+4));
 1000       __ popl (Address(rsp, dst_offset+4));
 1001       break;
 1002     case Op_VecX:
 1003       __ movdqu(Address(rsp, -16), xmm0);
 1004       __ movdqu(xmm0, Address(rsp, src_offset));
 1005       __ movdqu(Address(rsp, dst_offset), xmm0);
 1006       __ movdqu(xmm0, Address(rsp, -16));
 1007       break;
 1008     case Op_VecY:
 1009       __ vmovdqu(Address(rsp, -32), xmm0);
 1010       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1011       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1012       __ vmovdqu(xmm0, Address(rsp, -32));
 1013       break;
 1014     case Op_VecZ:
 1015       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1016       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1017       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1018       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1019       break;
 1020     default:
 1021       ShouldNotReachHere();
 1022     }
 1023     int size = __ offset() - offset;
 1024     assert(size == calc_size, &quot;incorrect size calculation&quot;);
 1025     return size;
 1026 #ifndef PRODUCT
 1027   } else if (!do_size) {
 1028     switch (ireg) {
 1029     case Op_VecS:
 1030       st-&gt;print(&quot;pushl   [rsp + #%d]\t# 32-bit mem-mem spill\n\t&quot;
 1031                 &quot;popl    [rsp + #%d]&quot;,
 1032                 src_offset, dst_offset);
 1033       break;
 1034     case Op_VecD:
 1035       st-&gt;print(&quot;pushl   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1036                 &quot;popq    [rsp + #%d]\n\t&quot;
 1037                 &quot;pushl   [rsp + #%d]\n\t&quot;
 1038                 &quot;popq    [rsp + #%d]&quot;,
 1039                 src_offset, dst_offset, src_offset+4, dst_offset+4);
 1040       break;
 1041      case Op_VecX:
 1042       st-&gt;print(&quot;movdqu  [rsp - #16], xmm0\t# 128-bit mem-mem spill\n\t&quot;
 1043                 &quot;movdqu  xmm0, [rsp + #%d]\n\t&quot;
 1044                 &quot;movdqu  [rsp + #%d], xmm0\n\t&quot;
 1045                 &quot;movdqu  xmm0, [rsp - #16]&quot;,
 1046                 src_offset, dst_offset);
 1047       break;
 1048     case Op_VecY:
 1049       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1050                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1051                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1052                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1053                 src_offset, dst_offset);
 1054       break;
 1055     case Op_VecZ:
 1056       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1057                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1058                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1059                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1060                 src_offset, dst_offset);
 1061       break;
 1062     default:
 1063       ShouldNotReachHere();
 1064     }
 1065 #endif
 1066   }
 1067   return calc_size;
 1068 }
 1069 
 1070 uint MachSpillCopyNode::implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const {
 1071   // Get registers to move
 1072   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1073   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1074   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this );
 1075   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this );
 1076 
 1077   enum RC src_second_rc = rc_class(src_second);
 1078   enum RC src_first_rc = rc_class(src_first);
 1079   enum RC dst_second_rc = rc_class(dst_second);
 1080   enum RC dst_first_rc = rc_class(dst_first);
 1081 
 1082   assert( OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot; );
 1083 
 1084   // Generate spill code!
 1085   int size = 0;
 1086 
 1087   if( src_first == dst_first &amp;&amp; src_second == dst_second )
 1088     return size;            // Self copy, no move
 1089 
 1090   if (bottom_type()-&gt;isa_vect() != NULL) {
 1091     uint ireg = ideal_reg();
 1092     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1093     assert((src_first_rc != rc_float &amp;&amp; dst_first_rc != rc_float), &quot;sanity&quot;);
 1094     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1095     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1096       // mem -&gt; mem
 1097       int src_offset = ra_-&gt;reg2offset(src_first);
 1098       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1099       return vec_stack_to_stack_helper(cbuf, do_size, src_offset, dst_offset, ireg, st);
 1100     } else if (src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_xmm ) {
 1101       return vec_mov_helper(cbuf, do_size, src_first, dst_first, src_second, dst_second, ireg, st);
 1102     } else if (src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_stack ) {
 1103       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1104       return vec_spill_helper(cbuf, do_size, false, stack_offset, src_first, ireg, st);
 1105     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_xmm ) {
 1106       int stack_offset = ra_-&gt;reg2offset(src_first);
 1107       return vec_spill_helper(cbuf, do_size, true,  stack_offset, dst_first, ireg, st);
 1108     } else {
 1109       ShouldNotReachHere();
 1110     }
 1111   }
 1112 
 1113   // --------------------------------------
 1114   // Check for mem-mem move.  push/pop to move.
 1115   if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1116     if( src_second == dst_first ) { // overlapping stack copy ranges
 1117       assert( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack, &quot;we only expect a stk-stk copy here&quot; );
 1118       size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1119       size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1120       src_second_rc = dst_second_rc = rc_bad;  // flag as already moved the second bits
 1121     }
 1122     // move low bits
 1123     size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1124     size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1125     if( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack ) { // mov second bits
 1126       size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1127       size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1128     }
 1129     return size;
 1130   }
 1131 
 1132   // --------------------------------------
 1133   // Check for integer reg-reg copy
 1134   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_int )
 1135     size = impl_mov_helper(cbuf,do_size,src_first,dst_first,size, st);
 1136 
 1137   // Check for integer store
 1138   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_stack )
 1139     size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),src_first,0x89,&quot;MOV &quot;,size, st);
 1140 
 1141   // Check for integer load
 1142   if( dst_first_rc == rc_int &amp;&amp; src_first_rc == rc_stack )
 1143     size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),dst_first,0x8B,&quot;MOV &quot;,size, st);
 1144 
 1145   // Check for integer reg-xmm reg copy
 1146   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_xmm ) {
 1147     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad),
 1148             &quot;no 64 bit integer-float reg moves&quot; );
 1149     return impl_movgpr2x_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1150   }
 1151   // --------------------------------------
 1152   // Check for float reg-reg copy
 1153   if( src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1154     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad) ||
 1155             (src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second), &quot;no non-adjacent float-moves&quot; );
 1156     if( cbuf ) {
 1157 
 1158       // Note the mucking with the register encode to compensate for the 0/1
 1159       // indexing issue mentioned in a comment in the reg_def sections
 1160       // for FPR registers many lines above here.
 1161 
 1162       if( src_first != FPR1L_num ) {
 1163         emit_opcode  (*cbuf, 0xD9 );           // FLD    ST(i)
 1164         emit_d8      (*cbuf, 0xC0+Matcher::_regEncode[src_first]-1 );
 1165         emit_opcode  (*cbuf, 0xDD );           // FSTP   ST(i)
 1166         emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );
 1167      } else {
 1168         emit_opcode  (*cbuf, 0xDD );           // FST    ST(i)
 1169         emit_d8      (*cbuf, 0xD0+Matcher::_regEncode[dst_first]-1 );
 1170      }
 1171 #ifndef PRODUCT
 1172     } else if( !do_size ) {
 1173       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1174       if( src_first != FPR1L_num ) st-&gt;print(&quot;FLD    %s\n\tFSTP   %s&quot;,Matcher::regName[src_first],Matcher::regName[dst_first]);
 1175       else                      st-&gt;print(             &quot;FST    %s&quot;,                            Matcher::regName[dst_first]);
 1176 #endif
 1177     }
 1178     return size + ((src_first != FPR1L_num) ? 2+2 : 2);
 1179   }
 1180 
 1181   // Check for float store
 1182   if( src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1183     return impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,ra_-&gt;reg2offset(dst_first),size, st);
 1184   }
 1185 
 1186   // Check for float load
 1187   if( dst_first_rc == rc_float &amp;&amp; src_first_rc == rc_stack ) {
 1188     int offset = ra_-&gt;reg2offset(src_first);
 1189     const char *op_str;
 1190     int op;
 1191     if( src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second ) { // double load?
 1192       op_str = &quot;FLD_D&quot;;
 1193       op = 0xDD;
 1194     } else {                   // 32-bit load
 1195       op_str = &quot;FLD_S&quot;;
 1196       op = 0xD9;
 1197       assert( src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad, &quot;no non-adjacent float-loads&quot; );
 1198     }
 1199     if( cbuf ) {
 1200       emit_opcode  (*cbuf, op );
 1201       encode_RegMem(*cbuf, 0x0, ESP_enc, 0x4, 0, offset, relocInfo::none);
 1202       emit_opcode  (*cbuf, 0xDD );           // FSTP   ST(i)
 1203       emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );
 1204 #ifndef PRODUCT
 1205     } else if( !do_size ) {
 1206       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1207       st-&gt;print(&quot;%s  ST,[ESP + #%d]\n\tFSTP   %s&quot;,op_str, offset,Matcher::regName[dst_first]);
 1208 #endif
 1209     }
 1210     int offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
 1211     return size + 3+offset_size+2;
 1212   }
 1213 
 1214   // Check for xmm reg-reg copy
 1215   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_xmm ) {
 1216     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad) ||
 1217             (src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second),
 1218             &quot;no non-adjacent float-moves&quot; );
 1219     return impl_movx_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1220   }
 1221 
 1222   // Check for xmm reg-integer reg copy
 1223   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_int ) {
 1224     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad),
 1225             &quot;no 64 bit float-integer reg moves&quot; );
 1226     return impl_movx2gpr_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1227   }
 1228 
 1229   // Check for xmm store
 1230   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_stack ) {
 1231     return impl_x_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),src_first, src_second, size, st);
 1232   }
 1233 
 1234   // Check for float xmm load
 1235   if( dst_first_rc == rc_xmm &amp;&amp; src_first_rc == rc_stack ) {
 1236     return impl_x_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),dst_first, dst_second, size, st);
 1237   }
 1238 
 1239   // Copy from float reg to xmm reg
 1240   if( dst_first_rc == rc_xmm &amp;&amp; src_first_rc == rc_float ) {
 1241     // copy to the top of stack from floating point reg
 1242     // and use LEA to preserve flags
 1243     if( cbuf ) {
 1244       emit_opcode(*cbuf,0x8D);  // LEA  ESP,[ESP-8]
 1245       emit_rm(*cbuf, 0x1, ESP_enc, 0x04);
 1246       emit_rm(*cbuf, 0x0, 0x04, ESP_enc);
 1247       emit_d8(*cbuf,0xF8);
 1248 #ifndef PRODUCT
 1249     } else if( !do_size ) {
 1250       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1251       st-&gt;print(&quot;LEA    ESP,[ESP-8]&quot;);
 1252 #endif
 1253     }
 1254     size += 4;
 1255 
 1256     size = impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,0,size, st);
 1257 
 1258     // Copy from the temp memory to the xmm reg.
 1259     size = impl_x_helper(cbuf,do_size,true ,0,dst_first, dst_second, size, st);
 1260 
 1261     if( cbuf ) {
 1262       emit_opcode(*cbuf,0x8D);  // LEA  ESP,[ESP+8]
 1263       emit_rm(*cbuf, 0x1, ESP_enc, 0x04);
 1264       emit_rm(*cbuf, 0x0, 0x04, ESP_enc);
 1265       emit_d8(*cbuf,0x08);
 1266 #ifndef PRODUCT
 1267     } else if( !do_size ) {
 1268       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1269       st-&gt;print(&quot;LEA    ESP,[ESP+8]&quot;);
 1270 #endif
 1271     }
 1272     size += 4;
 1273     return size;
 1274   }
 1275 
 1276   assert( size &gt; 0, &quot;missed a case&quot; );
 1277 
 1278   // --------------------------------------------------------------------
 1279   // Check for second bits still needing moving.
 1280   if( src_second == dst_second )
 1281     return size;               // Self copy; no move
 1282   assert( src_second_rc != rc_bad &amp;&amp; dst_second_rc != rc_bad, &quot;src_second &amp; dst_second cannot be Bad&quot; );
 1283 
 1284   // Check for second word int-int move
 1285   if( src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_int )
 1286     return impl_mov_helper(cbuf,do_size,src_second,dst_second,size, st);
 1287 
 1288   // Check for second word integer store
 1289   if( src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_stack )
 1290     return impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),src_second,0x89,&quot;MOV &quot;,size, st);
 1291 
 1292   // Check for second word integer load
 1293   if( dst_second_rc == rc_int &amp;&amp; src_second_rc == rc_stack )
 1294     return impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),dst_second,0x8B,&quot;MOV &quot;,size, st);
 1295 
 1296 
 1297   Unimplemented();
 1298   return 0; // Mute compiler
 1299 }
 1300 
 1301 #ifndef PRODUCT
 1302 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1303   implementation( NULL, ra_, false, st );
 1304 }
 1305 #endif
 1306 
 1307 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1308   implementation( &amp;cbuf, ra_, false, NULL );
 1309 }
 1310 
 1311 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1312   return MachNode::size(ra_);
 1313 }
 1314 
 1315 
 1316 //=============================================================================
 1317 #ifndef PRODUCT
 1318 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1319   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1320   int reg = ra_-&gt;get_reg_first(this);
 1321   st-&gt;print(&quot;LEA    %s,[ESP + #%d]&quot;,Matcher::regName[reg],offset);
 1322 }
 1323 #endif
 1324 
 1325 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1326   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1327   int reg = ra_-&gt;get_encode(this);
 1328   if( offset &gt;= 128 ) {
 1329     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1330     emit_rm(cbuf, 0x2, reg, 0x04);
 1331     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1332     emit_d32(cbuf, offset);
 1333   }
 1334   else {
 1335     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1336     emit_rm(cbuf, 0x1, reg, 0x04);
 1337     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1338     emit_d8(cbuf, offset);
 1339   }
 1340 }
 1341 
 1342 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1343   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1344   if( offset &gt;= 128 ) {
 1345     return 7;
 1346   }
 1347   else {
 1348     return 4;
 1349   }
 1350 }
 1351 
 1352 //=============================================================================
 1353 #ifndef PRODUCT
 1354 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1355   st-&gt;print_cr(  &quot;CMP    EAX,[ECX+4]\t# Inline cache check&quot;);
 1356   st-&gt;print_cr(&quot;\tJNE    SharedRuntime::handle_ic_miss_stub&quot;);
 1357   st-&gt;print_cr(&quot;\tNOP&quot;);
 1358   st-&gt;print_cr(&quot;\tNOP&quot;);
 1359   if( !OptoBreakpoint )
 1360     st-&gt;print_cr(&quot;\tNOP&quot;);
 1361 }
 1362 #endif
 1363 
 1364 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1365   MacroAssembler masm(&amp;cbuf);
 1366 #ifdef ASSERT
 1367   uint insts_size = cbuf.insts_size();
 1368 #endif
 1369   masm.cmpptr(rax, Address(rcx, oopDesc::klass_offset_in_bytes()));
 1370   masm.jump_cc(Assembler::notEqual,
 1371                RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1372   /* WARNING these NOPs are critical so that verified entry point is properly
 1373      aligned for patching by NativeJump::patch_verified_entry() */
 1374   int nops_cnt = 2;
 1375   if( !OptoBreakpoint ) // Leave space for int3
 1376      nops_cnt += 1;
 1377   masm.nop(nops_cnt);
 1378 
 1379   assert(cbuf.insts_size() - insts_size == size(ra_), &quot;checking code size of inline cache node&quot;);
 1380 }
 1381 
 1382 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1383   return OptoBreakpoint ? 11 : 12;
 1384 }
 1385 
 1386 
 1387 //=============================================================================
 1388 
 1389 int Matcher::regnum_to_fpu_offset(int regnum) {
 1390   return regnum - 32; // The FP registers are in the second chunk
 1391 }
 1392 
 1393 // This is UltraSparc specific, true just means we have fast l2f conversion
 1394 const bool Matcher::convL2FSupported(void) {
 1395   return true;
 1396 }
 1397 
 1398 // Is this branch offset short enough that a short branch can be used?
 1399 //
 1400 // NOTE: If the platform does not provide any short branch variants, then
 1401 //       this method should return false for offset 0.
 1402 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1403   // The passed offset is relative to address of the branch.
 1404   // On 86 a branch displacement is calculated relative to address
 1405   // of a next instruction.
 1406   offset -= br_size;
 1407 
 1408   // the short version of jmpConUCF2 contains multiple branches,
 1409   // making the reach slightly less
 1410   if (rule == jmpConUCF2_rule)
 1411     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1412   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1413 }
 1414 
 1415 const bool Matcher::isSimpleConstant64(jlong value) {
 1416   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1417   return false;
 1418 }
 1419 
 1420 // The ecx parameter to rep stos for the ClearArray node is in dwords.
 1421 const bool Matcher::init_array_count_is_in_bytes = false;
 1422 
 1423 // Needs 2 CMOV&#39;s for longs.
 1424 const int Matcher::long_cmove_cost() { return 1; }
 1425 
 1426 // No CMOVF/CMOVD with SSE/SSE2
 1427 const int Matcher::float_cmove_cost() { return (UseSSE&gt;=1) ? ConditionalMoveLimit : 0; }
 1428 
 1429 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1430 const bool Matcher::require_postalloc_expand = false;
 1431 
 1432 // Do we need to mask the count passed to shift instructions or does
 1433 // the cpu only look at the lower 5/6 bits anyway?
 1434 const bool Matcher::need_masked_shift_count = false;
 1435 
 1436 bool Matcher::narrow_oop_use_complex_address() {
 1437   ShouldNotCallThis();
 1438   return true;
 1439 }
 1440 
 1441 bool Matcher::narrow_klass_use_complex_address() {
 1442   ShouldNotCallThis();
 1443   return true;
 1444 }
 1445 
 1446 bool Matcher::const_oop_prefer_decode() {
 1447   ShouldNotCallThis();
 1448   return true;
 1449 }
 1450 
 1451 bool Matcher::const_klass_prefer_decode() {
 1452   ShouldNotCallThis();
 1453   return true;
 1454 }
 1455 
 1456 // Is it better to copy float constants, or load them directly from memory?
 1457 // Intel can load a float constant from a direct address, requiring no
 1458 // extra registers.  Most RISCs will have to materialize an address into a
 1459 // register first, so they would do better to copy the constant from stack.
 1460 const bool Matcher::rematerialize_float_constants = true;
 1461 
 1462 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1463 // needed.  Else we split the double into 2 integer pieces and move it
 1464 // piece-by-piece.  Only happens when passing doubles into C code as the
 1465 // Java calling convention forces doubles to be aligned.
 1466 const bool Matcher::misaligned_doubles_ok = true;
 1467 
 1468 
 1469 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 1470   // Get the memory operand from the node
 1471   uint numopnds = node-&gt;num_opnds();        // Virtual call for number of operands
 1472   uint skipped  = node-&gt;oper_input_base();  // Sum of leaves skipped so far
 1473   assert( idx &gt;= skipped, &quot;idx too low in pd_implicit_null_fixup&quot; );
 1474   uint opcnt     = 1;                 // First operand
 1475   uint num_edges = node-&gt;_opnds[1]-&gt;num_edges(); // leaves for first operand
 1476   while( idx &gt;= skipped+num_edges ) {
 1477     skipped += num_edges;
 1478     opcnt++;                          // Bump operand count
 1479     assert( opcnt &lt; numopnds, &quot;Accessing non-existent operand&quot; );
 1480     num_edges = node-&gt;_opnds[opcnt]-&gt;num_edges(); // leaves for next operand
 1481   }
 1482 
 1483   MachOper *memory = node-&gt;_opnds[opcnt];
 1484   MachOper *new_memory = NULL;
 1485   switch (memory-&gt;opcode()) {
 1486   case DIRECT:
 1487   case INDOFFSET32X:
 1488     // No transformation necessary.
 1489     return;
 1490   case INDIRECT:
 1491     new_memory = new indirect_win95_safeOper( );
 1492     break;
 1493   case INDOFFSET8:
 1494     new_memory = new indOffset8_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1495     break;
 1496   case INDOFFSET32:
 1497     new_memory = new indOffset32_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1498     break;
 1499   case INDINDEXOFFSET:
 1500     new_memory = new indIndexOffset_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1501     break;
 1502   case INDINDEXSCALE:
 1503     new_memory = new indIndexScale_win95_safeOper(memory-&gt;scale());
 1504     break;
 1505   case INDINDEXSCALEOFFSET:
 1506     new_memory = new indIndexScaleOffset_win95_safeOper(memory-&gt;scale(), memory-&gt;disp(NULL, NULL, 0));
 1507     break;
 1508   case LOAD_LONG_INDIRECT:
 1509   case LOAD_LONG_INDOFFSET32:
 1510     // Does not use EBP as address register, use { EDX, EBX, EDI, ESI}
 1511     return;
 1512   default:
 1513     assert(false, &quot;unexpected memory operand in pd_implicit_null_fixup()&quot;);
 1514     return;
 1515   }
 1516   node-&gt;_opnds[opcnt] = new_memory;
 1517 }
 1518 
 1519 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1520 const bool Matcher::strict_fp_requires_explicit_rounding = true;
 1521 
 1522 // Are floats conerted to double when stored to stack during deoptimization?
 1523 // On x32 it is stored with convertion only when FPU is used for floats.
 1524 bool Matcher::float_in_double() { return (UseSSE == 0); }
 1525 
 1526 // Do ints take an entire long register or just half?
 1527 const bool Matcher::int_in_long = false;
 1528 
 1529 // Return whether or not this register is ever used as an argument.  This
 1530 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1531 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1532 // arguments in those registers not be available to the callee.
 1533 bool Matcher::can_be_java_arg( int reg ) {
 1534   if(  reg == ECX_num   || reg == EDX_num   ) return true;
 1535   if( (reg == XMM0_num  || reg == XMM1_num ) &amp;&amp; UseSSE&gt;=1 ) return true;
 1536   if( (reg == XMM0b_num || reg == XMM1b_num) &amp;&amp; UseSSE&gt;=2 ) return true;
 1537   return false;
 1538 }
 1539 
 1540 bool Matcher::is_spillable_arg( int reg ) {
 1541   return can_be_java_arg(reg);
 1542 }
 1543 
 1544 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1545   // Use hardware integer DIV instruction when
 1546   // it is faster than a code which use multiply.
 1547   // Only when constant divisor fits into 32 bit
 1548   // (min_jint is excluded to get only correct
 1549   // positive 32 bit values from negative).
 1550   return VM_Version::has_fast_idiv() &amp;&amp;
 1551          (divisor == (int)divisor &amp;&amp; divisor != min_jint);
 1552 }
 1553 
 1554 // Register for DIVI projection of divmodI
 1555 RegMask Matcher::divI_proj_mask() {
 1556   return EAX_REG_mask();
 1557 }
 1558 
 1559 // Register for MODI projection of divmodI
 1560 RegMask Matcher::modI_proj_mask() {
 1561   return EDX_REG_mask();
 1562 }
 1563 
 1564 // Register for DIVL projection of divmodL
 1565 RegMask Matcher::divL_proj_mask() {
 1566   ShouldNotReachHere();
 1567   return RegMask();
 1568 }
 1569 
 1570 // Register for MODL projection of divmodL
 1571 RegMask Matcher::modL_proj_mask() {
 1572   ShouldNotReachHere();
 1573   return RegMask();
 1574 }
 1575 
 1576 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1577   return NO_REG_mask();
 1578 }
 1579 
 1580 // Returns true if the high 32 bits of the value is known to be zero.
 1581 bool is_operand_hi32_zero(Node* n) {
 1582   int opc = n-&gt;Opcode();
 1583   if (opc == Op_AndL) {
 1584     Node* o2 = n-&gt;in(2);
 1585     if (o2-&gt;is_Con() &amp;&amp; (o2-&gt;get_long() &amp; 0xFFFFFFFF00000000LL) == 0LL) {
 1586       return true;
 1587     }
 1588   }
 1589   if (opc == Op_ConL &amp;&amp; (n-&gt;get_long() &amp; 0xFFFFFFFF00000000LL) == 0LL) {
 1590     return true;
 1591   }
 1592   return false;
 1593 }
 1594 
 1595 %}
 1596 
 1597 //----------ENCODING BLOCK-----------------------------------------------------
 1598 // This block specifies the encoding classes used by the compiler to output
 1599 // byte streams.  Encoding classes generate functions which are called by
 1600 // Machine Instruction Nodes in order to generate the bit encoding of the
 1601 // instruction.  Operands specify their base encoding interface with the
 1602 // interface keyword.  There are currently supported four interfaces,
 1603 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER.  REG_INTER causes an
 1604 // operand to generate a function which returns its register number when
 1605 // queried.   CONST_INTER causes an operand to generate a function which
 1606 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1607 // operand to generate four functions which return the Base Register, the
 1608 // Index Register, the Scale Value, and the Offset Value of the operand when
 1609 // queried.  COND_INTER causes an operand to generate six functions which
 1610 // return the encoding code (ie - encoding bits for the instruction)
 1611 // associated with each basic boolean condition for a conditional instruction.
 1612 // Instructions specify two basic values for encoding.  They use the
 1613 // ins_encode keyword to specify their encoding class (which must be one of
 1614 // the class names specified in the encoding block), and they use the
 1615 // opcode keyword to specify, in order, their primary, secondary, and
 1616 // tertiary opcode.  Only the opcode sections which a particular instruction
 1617 // needs for encoding need to be specified.
 1618 encode %{
 1619   // Build emit functions for each basic byte or larger field in the intel
 1620   // encoding scheme (opcode, rm, sib, immediate), and call them from C++
 1621   // code in the enc_class source block.  Emit functions will live in the
 1622   // main source block for now.  In future, we can generalize this by
 1623   // adding a syntax that specifies the sizes of fields in an order,
 1624   // so that the adlc can build the emit functions automagically
 1625 
 1626   // Emit primary opcode
 1627   enc_class OpcP %{
 1628     emit_opcode(cbuf, $primary);
 1629   %}
 1630 
 1631   // Emit secondary opcode
 1632   enc_class OpcS %{
 1633     emit_opcode(cbuf, $secondary);
 1634   %}
 1635 
 1636   // Emit opcode directly
 1637   enc_class Opcode(immI d8) %{
 1638     emit_opcode(cbuf, $d8$$constant);
 1639   %}
 1640 
 1641   enc_class SizePrefix %{
 1642     emit_opcode(cbuf,0x66);
 1643   %}
 1644 
 1645   enc_class RegReg (rRegI dst, rRegI src) %{    // RegReg(Many)
 1646     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 1647   %}
 1648 
 1649   enc_class OpcRegReg (immI opcode, rRegI dst, rRegI src) %{    // OpcRegReg(Many)
 1650     emit_opcode(cbuf,$opcode$$constant);
 1651     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 1652   %}
 1653 
 1654   enc_class mov_r32_imm0( rRegI dst ) %{
 1655     emit_opcode( cbuf, 0xB8 + $dst$$reg ); // 0xB8+ rd   -- MOV r32  ,imm32
 1656     emit_d32   ( cbuf, 0x0  );             //                         imm32==0x0
 1657   %}
 1658 
 1659   enc_class cdq_enc %{
 1660     // Full implementation of Java idiv and irem; checks for
 1661     // special case as described in JVM spec., p.243 &amp; p.271.
 1662     //
 1663     //         normal case                           special case
 1664     //
 1665     // input : rax,: dividend                         min_int
 1666     //         reg: divisor                          -1
 1667     //
 1668     // output: rax,: quotient  (= rax, idiv reg)       min_int
 1669     //         rdx: remainder (= rax, irem reg)       0
 1670     //
 1671     //  Code sequnce:
 1672     //
 1673     //  81 F8 00 00 00 80    cmp         rax,80000000h
 1674     //  0F 85 0B 00 00 00    jne         normal_case
 1675     //  33 D2                xor         rdx,edx
 1676     //  83 F9 FF             cmp         rcx,0FFh
 1677     //  0F 84 03 00 00 00    je          done
 1678     //                  normal_case:
 1679     //  99                   cdq
 1680     //  F7 F9                idiv        rax,ecx
 1681     //                  done:
 1682     //
 1683     emit_opcode(cbuf,0x81); emit_d8(cbuf,0xF8);
 1684     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);
 1685     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x80);                     // cmp rax,80000000h
 1686     emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x85);
 1687     emit_opcode(cbuf,0x0B); emit_d8(cbuf,0x00);
 1688     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     // jne normal_case
 1689     emit_opcode(cbuf,0x33); emit_d8(cbuf,0xD2);                     // xor rdx,edx
 1690     emit_opcode(cbuf,0x83); emit_d8(cbuf,0xF9); emit_d8(cbuf,0xFF); // cmp rcx,0FFh
 1691     emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x84);
 1692     emit_opcode(cbuf,0x03); emit_d8(cbuf,0x00);
 1693     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     // je done
 1694     // normal_case:
 1695     emit_opcode(cbuf,0x99);                                         // cdq
 1696     // idiv (note: must be emitted by the user of this rule)
 1697     // normal:
 1698   %}
 1699 
 1700   // Dense encoding for older common ops
 1701   enc_class Opc_plus(immI opcode, rRegI reg) %{
 1702     emit_opcode(cbuf, $opcode$$constant + $reg$$reg);
 1703   %}
 1704 
 1705 
 1706   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1707   enc_class OpcSE (immI imm) %{ // Emit primary opcode and set sign-extend bit
 1708     // Check for 8-bit immediate, and set sign extend bit in opcode
 1709     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1710       emit_opcode(cbuf, $primary | 0x02);
 1711     }
 1712     else {                          // If 32-bit immediate
 1713       emit_opcode(cbuf, $primary);
 1714     }
 1715   %}
 1716 
 1717   enc_class OpcSErm (rRegI dst, immI imm) %{    // OpcSEr/m
 1718     // Emit primary opcode and set sign-extend bit
 1719     // Check for 8-bit immediate, and set sign extend bit in opcode
 1720     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1721       emit_opcode(cbuf, $primary | 0x02);    }
 1722     else {                          // If 32-bit immediate
 1723       emit_opcode(cbuf, $primary);
 1724     }
 1725     // Emit r/m byte with secondary opcode, after primary opcode.
 1726     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1727   %}
 1728 
 1729   enc_class Con8or32 (immI imm) %{    // Con8or32(storeImmI), 8 or 32 bits
 1730     // Check for 8-bit immediate, and set sign extend bit in opcode
 1731     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1732       $$$emit8$imm$$constant;
 1733     }
 1734     else {                          // If 32-bit immediate
 1735       // Output immediate
 1736       $$$emit32$imm$$constant;
 1737     }
 1738   %}
 1739 
 1740   enc_class Long_OpcSErm_Lo(eRegL dst, immL imm) %{
 1741     // Emit primary opcode and set sign-extend bit
 1742     // Check for 8-bit immediate, and set sign extend bit in opcode
 1743     int con = (int)$imm$$constant; // Throw away top bits
 1744     emit_opcode(cbuf, ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) ? ($primary | 0x02) : $primary);
 1745     // Emit r/m byte with secondary opcode, after primary opcode.
 1746     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1747     if ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) emit_d8 (cbuf,con);
 1748     else                               emit_d32(cbuf,con);
 1749   %}
 1750 
 1751   enc_class Long_OpcSErm_Hi(eRegL dst, immL imm) %{
 1752     // Emit primary opcode and set sign-extend bit
 1753     // Check for 8-bit immediate, and set sign extend bit in opcode
 1754     int con = (int)($imm$$constant &gt;&gt; 32); // Throw away bottom bits
 1755     emit_opcode(cbuf, ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) ? ($primary | 0x02) : $primary);
 1756     // Emit r/m byte with tertiary opcode, after primary opcode.
 1757     emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW($dst$$reg));
 1758     if ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) emit_d8 (cbuf,con);
 1759     else                               emit_d32(cbuf,con);
 1760   %}
 1761 
 1762   enc_class OpcSReg (rRegI dst) %{    // BSWAP
 1763     emit_cc(cbuf, $secondary, $dst$$reg );
 1764   %}
 1765 
 1766   enc_class bswap_long_bytes(eRegL dst) %{ // BSWAP
 1767     int destlo = $dst$$reg;
 1768     int desthi = HIGH_FROM_LOW(destlo);
 1769     // bswap lo
 1770     emit_opcode(cbuf, 0x0F);
 1771     emit_cc(cbuf, 0xC8, destlo);
 1772     // bswap hi
 1773     emit_opcode(cbuf, 0x0F);
 1774     emit_cc(cbuf, 0xC8, desthi);
 1775     // xchg lo and hi
 1776     emit_opcode(cbuf, 0x87);
 1777     emit_rm(cbuf, 0x3, destlo, desthi);
 1778   %}
 1779 
 1780   enc_class RegOpc (rRegI div) %{    // IDIV, IMOD, JMP indirect, ...
 1781     emit_rm(cbuf, 0x3, $secondary, $div$$reg );
 1782   %}
 1783 
 1784   enc_class enc_cmov(cmpOp cop ) %{ // CMOV
 1785     $$$emit8$primary;
 1786     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 1787   %}
 1788 
 1789   enc_class enc_cmov_dpr(cmpOp cop, regDPR src ) %{ // CMOV
 1790     int op = 0xDA00 + $cop$$cmpcode + ($src$$reg-1);
 1791     emit_d8(cbuf, op &gt;&gt; 8 );
 1792     emit_d8(cbuf, op &amp; 255);
 1793   %}
 1794 
 1795   // emulate a CMOV with a conditional branch around a MOV
 1796   enc_class enc_cmov_branch( cmpOp cop, immI brOffs ) %{ // CMOV
 1797     // Invert sense of branch from sense of CMOV
 1798     emit_cc( cbuf, 0x70, ($cop$$cmpcode^1) );
 1799     emit_d8( cbuf, $brOffs$$constant );
 1800   %}
 1801 
 1802   enc_class enc_PartialSubtypeCheck( ) %{
 1803     Register Redi = as_Register(EDI_enc); // result register
 1804     Register Reax = as_Register(EAX_enc); // super class
 1805     Register Recx = as_Register(ECX_enc); // killed
 1806     Register Resi = as_Register(ESI_enc); // sub class
 1807     Label miss;
 1808 
 1809     MacroAssembler _masm(&amp;cbuf);
 1810     __ check_klass_subtype_slow_path(Resi, Reax, Recx, Redi,
 1811                                      NULL, &amp;miss,
 1812                                      /*set_cond_codes:*/ true);
 1813     if ($primary) {
 1814       __ xorptr(Redi, Redi);
 1815     }
 1816     __ bind(miss);
 1817   %}
 1818 
 1819   enc_class FFree_Float_Stack_All %{    // Free_Float_Stack_All
 1820     MacroAssembler masm(&amp;cbuf);
 1821     int start = masm.offset();
 1822     if (UseSSE &gt;= 2) {
 1823       if (VerifyFPU) {
 1824         masm.verify_FPU(0, &quot;must be empty in SSE2+ mode&quot;);
 1825       }
 1826     } else {
 1827       // External c_calling_convention expects the FPU stack to be &#39;clean&#39;.
 1828       // Compiled code leaves it dirty.  Do cleanup now.
 1829       masm.empty_FPU_stack();
 1830     }
 1831     if (sizeof_FFree_Float_Stack_All == -1) {
 1832       sizeof_FFree_Float_Stack_All = masm.offset() - start;
 1833     } else {
 1834       assert(masm.offset() - start == sizeof_FFree_Float_Stack_All, &quot;wrong size&quot;);
 1835     }
 1836   %}
 1837 
 1838   enc_class Verify_FPU_For_Leaf %{
 1839     if( VerifyFPU ) {
 1840       MacroAssembler masm(&amp;cbuf);
 1841       masm.verify_FPU( -3, &quot;Returning from Runtime Leaf call&quot;);
 1842     }
 1843   %}
 1844 
 1845   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime, Java_To_Runtime_Leaf
 1846     // This is the instruction starting address for relocation info.
 1847     cbuf.set_insts_mark();
 1848     $$$emit8$primary;
 1849     // CALL directly to the runtime
 1850     emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1851                 runtime_call_Relocation::spec(), RELOC_IMM32 );
 1852 
 1853     if (UseSSE &gt;= 2) {
 1854       MacroAssembler _masm(&amp;cbuf);
 1855       BasicType rt = tf()-&gt;return_type();
 1856 
 1857       if ((rt == T_FLOAT || rt == T_DOUBLE) &amp;&amp; !return_value_is_used()) {
 1858         // A C runtime call where the return value is unused.  In SSE2+
 1859         // mode the result needs to be removed from the FPU stack.  It&#39;s
 1860         // likely that this function call could be removed by the
 1861         // optimizer if the C function is a pure function.
 1862         __ ffree(0);
 1863       } else if (rt == T_FLOAT) {
 1864         __ lea(rsp, Address(rsp, -4));
 1865         __ fstp_s(Address(rsp, 0));
 1866         __ movflt(xmm0, Address(rsp, 0));
 1867         __ lea(rsp, Address(rsp,  4));
 1868       } else if (rt == T_DOUBLE) {
 1869         __ lea(rsp, Address(rsp, -8));
 1870         __ fstp_d(Address(rsp, 0));
 1871         __ movdbl(xmm0, Address(rsp, 0));
 1872         __ lea(rsp, Address(rsp,  8));
 1873       }
 1874     }
 1875   %}
 1876 
 1877   enc_class pre_call_resets %{
 1878     // If method sets FPU control word restore it here
 1879     debug_only(int off0 = cbuf.insts_size());
 1880     if (ra_-&gt;C-&gt;in_24_bit_fp_mode()) {
 1881       MacroAssembler _masm(&amp;cbuf);
 1882       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
 1883     }
 1884     // Clear upper bits of YMM registers when current compiled code uses
 1885     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 1886     MacroAssembler _masm(&amp;cbuf);
 1887     __ vzeroupper();
 1888     debug_only(int off1 = cbuf.insts_size());
 1889     assert(off1 - off0 == pre_call_resets_size(), &quot;correct size prediction&quot;);
 1890   %}
 1891 
 1892   enc_class post_call_FPU %{
 1893     // If method sets FPU control word do it here also
 1894     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
 1895       MacroAssembler masm(&amp;cbuf);
 1896       masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
 1897     }
 1898   %}
 1899 
 1900   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 1901     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 1902     // who we intended to call.
 1903     cbuf.set_insts_mark();
 1904     $$$emit8$primary;
 1905 
 1906     if (!_method) {
 1907       emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1908                      runtime_call_Relocation::spec(),
 1909                      RELOC_IMM32);
 1910     } else {
 1911       int method_index = resolved_method_index(cbuf);
 1912       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 1913                                                   : static_call_Relocation::spec(method_index);
 1914       emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1915                      rspec, RELOC_DISP32);
 1916       // Emit stubs for static call.
 1917       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 1918       if (stub == NULL) {
 1919         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1920         return;
 1921       }
 1922     }
 1923   %}
 1924 
 1925   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
 1926     MacroAssembler _masm(&amp;cbuf);
 1927     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 1928   %}
 1929 
 1930   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
 1931     int disp = in_bytes(Method::from_compiled_offset());
 1932     assert( -128 &lt;= disp &amp;&amp; disp &lt;= 127, &quot;compiled_code_offset isn&#39;t small&quot;);
 1933 
 1934     // CALL *[EAX+in_bytes(Method::from_compiled_code_entry_point_offset())]
 1935     cbuf.set_insts_mark();
 1936     $$$emit8$primary;
 1937     emit_rm(cbuf, 0x01, $secondary, EAX_enc );  // R/M byte
 1938     emit_d8(cbuf, disp);             // Displacement
 1939 
 1940   %}
 1941 
 1942 //   Following encoding is no longer used, but may be restored if calling
 1943 //   convention changes significantly.
 1944 //   Became: Xor_Reg(EBP), Java_To_Runtime( labl )
 1945 //
 1946 //   enc_class Java_Interpreter_Call (label labl) %{    // JAVA INTERPRETER CALL
 1947 //     // int ic_reg     = Matcher::inline_cache_reg();
 1948 //     // int ic_encode  = Matcher::_regEncode[ic_reg];
 1949 //     // int imo_reg    = Matcher::interpreter_method_oop_reg();
 1950 //     // int imo_encode = Matcher::_regEncode[imo_reg];
 1951 //
 1952 //     // // Interpreter expects method_oop in EBX, currently a callee-saved register,
 1953 //     // // so we load it immediately before the call
 1954 //     // emit_opcode(cbuf, 0x8B);                     // MOV    imo_reg,ic_reg  # method_oop
 1955 //     // emit_rm(cbuf, 0x03, imo_encode, ic_encode ); // R/M byte
 1956 //
 1957 //     // xor rbp,ebp
 1958 //     emit_opcode(cbuf, 0x33);
 1959 //     emit_rm(cbuf, 0x3, EBP_enc, EBP_enc);
 1960 //
 1961 //     // CALL to interpreter.
 1962 //     cbuf.set_insts_mark();
 1963 //     $$$emit8$primary;
 1964 //     emit_d32_reloc(cbuf, ($labl$$label - (int)(cbuf.insts_end()) - 4),
 1965 //                 runtime_call_Relocation::spec(), RELOC_IMM32 );
 1966 //   %}
 1967 
 1968   enc_class RegOpcImm (rRegI dst, immI8 shift) %{    // SHL, SAR, SHR
 1969     $$$emit8$primary;
 1970     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1971     $$$emit8$shift$$constant;
 1972   %}
 1973 
 1974   enc_class LdImmI (rRegI dst, immI src) %{    // Load Immediate
 1975     // Load immediate does not have a zero or sign extended version
 1976     // for 8-bit immediates
 1977     emit_opcode(cbuf, 0xB8 + $dst$$reg);
 1978     $$$emit32$src$$constant;
 1979   %}
 1980 
 1981   enc_class LdImmP (rRegI dst, immI src) %{    // Load Immediate
 1982     // Load immediate does not have a zero or sign extended version
 1983     // for 8-bit immediates
 1984     emit_opcode(cbuf, $primary + $dst$$reg);
 1985     $$$emit32$src$$constant;
 1986   %}
 1987 
 1988   enc_class LdImmL_Lo( eRegL dst, immL src) %{    // Load Immediate
 1989     // Load immediate does not have a zero or sign extended version
 1990     // for 8-bit immediates
 1991     int dst_enc = $dst$$reg;
 1992     int src_con = $src$$constant &amp; 0x0FFFFFFFFL;
 1993     if (src_con == 0) {
 1994       // xor dst, dst
 1995       emit_opcode(cbuf, 0x33);
 1996       emit_rm(cbuf, 0x3, dst_enc, dst_enc);
 1997     } else {
 1998       emit_opcode(cbuf, $primary + dst_enc);
 1999       emit_d32(cbuf, src_con);
 2000     }
 2001   %}
 2002 
 2003   enc_class LdImmL_Hi( eRegL dst, immL src) %{    // Load Immediate
 2004     // Load immediate does not have a zero or sign extended version
 2005     // for 8-bit immediates
 2006     int dst_enc = $dst$$reg + 2;
 2007     int src_con = ((julong)($src$$constant)) &gt;&gt; 32;
 2008     if (src_con == 0) {
 2009       // xor dst, dst
 2010       emit_opcode(cbuf, 0x33);
 2011       emit_rm(cbuf, 0x3, dst_enc, dst_enc);
 2012     } else {
 2013       emit_opcode(cbuf, $primary + dst_enc);
 2014       emit_d32(cbuf, src_con);
 2015     }
 2016   %}
 2017 
 2018 
 2019   // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2020   enc_class enc_Copy( rRegI dst, rRegI src ) %{
 2021     encode_Copy( cbuf, $dst$$reg, $src$$reg );
 2022   %}
 2023 
 2024   enc_class enc_CopyL_Lo( rRegI dst, eRegL src ) %{
 2025     encode_Copy( cbuf, $dst$$reg, $src$$reg );
 2026   %}
 2027 
 2028   enc_class RegReg (rRegI dst, rRegI src) %{    // RegReg(Many)
 2029     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2030   %}
 2031 
 2032   enc_class RegReg_Lo(eRegL dst, eRegL src) %{    // RegReg(Many)
 2033     $$$emit8$primary;
 2034     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2035   %}
 2036 
 2037   enc_class RegReg_Hi(eRegL dst, eRegL src) %{    // RegReg(Many)
 2038     $$$emit8$secondary;
 2039     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));
 2040   %}
 2041 
 2042   enc_class RegReg_Lo2(eRegL dst, eRegL src) %{    // RegReg(Many)
 2043     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2044   %}
 2045 
 2046   enc_class RegReg_Hi2(eRegL dst, eRegL src) %{    // RegReg(Many)
 2047     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));
 2048   %}
 2049 
 2050   enc_class RegReg_HiLo( eRegL src, rRegI dst ) %{
 2051     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($src$$reg));
 2052   %}
 2053 
 2054   enc_class Con32 (immI src) %{    // Con32(storeImmI)
 2055     // Output immediate
 2056     $$$emit32$src$$constant;
 2057   %}
 2058 
 2059   enc_class Con32FPR_as_bits(immFPR src) %{        // storeF_imm
 2060     // Output Float immediate bits
 2061     jfloat jf = $src$$constant;
 2062     int    jf_as_bits = jint_cast( jf );
 2063     emit_d32(cbuf, jf_as_bits);
 2064   %}
 2065 
 2066   enc_class Con32F_as_bits(immF src) %{      // storeX_imm
 2067     // Output Float immediate bits
 2068     jfloat jf = $src$$constant;
 2069     int    jf_as_bits = jint_cast( jf );
 2070     emit_d32(cbuf, jf_as_bits);
 2071   %}
 2072 
 2073   enc_class Con16 (immI src) %{    // Con16(storeImmI)
 2074     // Output immediate
 2075     $$$emit16$src$$constant;
 2076   %}
 2077 
 2078   enc_class Con_d32(immI src) %{
 2079     emit_d32(cbuf,$src$$constant);
 2080   %}
 2081 
 2082   enc_class conmemref (eRegP t1) %{    // Con32(storeImmI)
 2083     // Output immediate memory reference
 2084     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2085     emit_d32(cbuf, 0x00);
 2086   %}
 2087 
 2088   enc_class lock_prefix( ) %{
 2089     emit_opcode(cbuf,0xF0);         // [Lock]
 2090   %}
 2091 
 2092   // Cmp-xchg long value.
 2093   // Note: we need to swap rbx, and rcx before and after the
 2094   //       cmpxchg8 instruction because the instruction uses
 2095   //       rcx as the high order word of the new value to store but
 2096   //       our register encoding uses rbx,.
 2097   enc_class enc_cmpxchg8(eSIRegP mem_ptr) %{
 2098 
 2099     // XCHG  rbx,ecx
 2100     emit_opcode(cbuf,0x87);
 2101     emit_opcode(cbuf,0xD9);
 2102     // [Lock]
 2103     emit_opcode(cbuf,0xF0);
 2104     // CMPXCHG8 [Eptr]
 2105     emit_opcode(cbuf,0x0F);
 2106     emit_opcode(cbuf,0xC7);
 2107     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2108     // XCHG  rbx,ecx
 2109     emit_opcode(cbuf,0x87);
 2110     emit_opcode(cbuf,0xD9);
 2111   %}
 2112 
 2113   enc_class enc_cmpxchg(eSIRegP mem_ptr) %{
 2114     // [Lock]
 2115     emit_opcode(cbuf,0xF0);
 2116 
 2117     // CMPXCHG [Eptr]
 2118     emit_opcode(cbuf,0x0F);
 2119     emit_opcode(cbuf,0xB1);
 2120     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2121   %}
 2122 
 2123   enc_class enc_cmpxchgb(eSIRegP mem_ptr) %{
 2124     // [Lock]
 2125     emit_opcode(cbuf,0xF0);
 2126 
 2127     // CMPXCHGB [Eptr]
 2128     emit_opcode(cbuf,0x0F);
 2129     emit_opcode(cbuf,0xB0);
 2130     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2131   %}
 2132 
 2133   enc_class enc_cmpxchgw(eSIRegP mem_ptr) %{
 2134     // [Lock]
 2135     emit_opcode(cbuf,0xF0);
 2136 
 2137     // 16-bit mode
 2138     emit_opcode(cbuf, 0x66);
 2139 
 2140     // CMPXCHGW [Eptr]
 2141     emit_opcode(cbuf,0x0F);
 2142     emit_opcode(cbuf,0xB1);
 2143     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2144   %}
 2145 
 2146   enc_class enc_flags_ne_to_boolean( iRegI res ) %{
 2147     int res_encoding = $res$$reg;
 2148 
 2149     // MOV  res,0
 2150     emit_opcode( cbuf, 0xB8 + res_encoding);
 2151     emit_d32( cbuf, 0 );
 2152     // JNE,s  fail
 2153     emit_opcode(cbuf,0x75);
 2154     emit_d8(cbuf, 5 );
 2155     // MOV  res,1
 2156     emit_opcode( cbuf, 0xB8 + res_encoding);
 2157     emit_d32( cbuf, 1 );
 2158     // fail:
 2159   %}
 2160 
 2161   enc_class set_instruction_start( ) %{
 2162     cbuf.set_insts_mark();            // Mark start of opcode for reloc info in mem operand
 2163   %}
 2164 
 2165   enc_class RegMem (rRegI ereg, memory mem) %{    // emit_reg_mem
 2166     int reg_encoding = $ereg$$reg;
 2167     int base  = $mem$$base;
 2168     int index = $mem$$index;
 2169     int scale = $mem$$scale;
 2170     int displace = $mem$$disp;
 2171     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2172     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2173   %}
 2174 
 2175   enc_class RegMem_Hi(eRegL ereg, memory mem) %{    // emit_reg_mem
 2176     int reg_encoding = HIGH_FROM_LOW($ereg$$reg);  // Hi register of pair, computed from lo
 2177     int base  = $mem$$base;
 2178     int index = $mem$$index;
 2179     int scale = $mem$$scale;
 2180     int displace = $mem$$disp + 4;      // Offset is 4 further in memory
 2181     assert( $mem-&gt;disp_reloc() == relocInfo::none, &quot;Cannot add 4 to oop&quot; );
 2182     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, relocInfo::none);
 2183   %}
 2184 
 2185   enc_class move_long_small_shift( eRegL dst, immI_1_31 cnt ) %{
 2186     int r1, r2;
 2187     if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }
 2188     else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }
 2189     emit_opcode(cbuf,0x0F);
 2190     emit_opcode(cbuf,$tertiary);
 2191     emit_rm(cbuf, 0x3, r1, r2);
 2192     emit_d8(cbuf,$cnt$$constant);
 2193     emit_d8(cbuf,$primary);
 2194     emit_rm(cbuf, 0x3, $secondary, r1);
 2195     emit_d8(cbuf,$cnt$$constant);
 2196   %}
 2197 
 2198   enc_class move_long_big_shift_sign( eRegL dst, immI_32_63 cnt ) %{
 2199     emit_opcode( cbuf, 0x8B ); // Move
 2200     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));
 2201     if( $cnt$$constant &gt; 32 ) { // Shift, if not by zero
 2202       emit_d8(cbuf,$primary);
 2203       emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 2204       emit_d8(cbuf,$cnt$$constant-32);
 2205     }
 2206     emit_d8(cbuf,$primary);
 2207     emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW($dst$$reg));
 2208     emit_d8(cbuf,31);
 2209   %}
 2210 
 2211   enc_class move_long_big_shift_clr( eRegL dst, immI_32_63 cnt ) %{
 2212     int r1, r2;
 2213     if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }
 2214     else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }
 2215 
 2216     emit_opcode( cbuf, 0x8B ); // Move r1,r2
 2217     emit_rm(cbuf, 0x3, r1, r2);
 2218     if( $cnt$$constant &gt; 32 ) { // Shift, if not by zero
 2219       emit_opcode(cbuf,$primary);
 2220       emit_rm(cbuf, 0x3, $secondary, r1);
 2221       emit_d8(cbuf,$cnt$$constant-32);
 2222     }
 2223     emit_opcode(cbuf,0x33);  // XOR r2,r2
 2224     emit_rm(cbuf, 0x3, r2, r2);
 2225   %}
 2226 
 2227   // Clone of RegMem but accepts an extra parameter to access each
 2228   // half of a double in memory; it never needs relocation info.
 2229   enc_class Mov_MemD_half_to_Reg (immI opcode, memory mem, immI disp_for_half, rRegI rm_reg) %{
 2230     emit_opcode(cbuf,$opcode$$constant);
 2231     int reg_encoding = $rm_reg$$reg;
 2232     int base     = $mem$$base;
 2233     int index    = $mem$$index;
 2234     int scale    = $mem$$scale;
 2235     int displace = $mem$$disp + $disp_for_half$$constant;
 2236     relocInfo::relocType disp_reloc = relocInfo::none;
 2237     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2238   %}
 2239 
 2240   // !!!!! Special Custom Code used by MemMove, and stack access instructions !!!!!
 2241   //
 2242   // Clone of RegMem except the RM-byte&#39;s reg/opcode field is an ADLC-time constant
 2243   // and it never needs relocation information.
 2244   // Frequently used to move data between FPU&#39;s Stack Top and memory.
 2245   enc_class RMopc_Mem_no_oop (immI rm_opcode, memory mem) %{
 2246     int rm_byte_opcode = $rm_opcode$$constant;
 2247     int base     = $mem$$base;
 2248     int index    = $mem$$index;
 2249     int scale    = $mem$$scale;
 2250     int displace = $mem$$disp;
 2251     assert( $mem-&gt;disp_reloc() == relocInfo::none, &quot;No oops here because no reloc info allowed&quot; );
 2252     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, relocInfo::none);
 2253   %}
 2254 
 2255   enc_class RMopc_Mem (immI rm_opcode, memory mem) %{
 2256     int rm_byte_opcode = $rm_opcode$$constant;
 2257     int base     = $mem$$base;
 2258     int index    = $mem$$index;
 2259     int scale    = $mem$$scale;
 2260     int displace = $mem$$disp;
 2261     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 2262     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 2263   %}
 2264 
 2265   enc_class RegLea (rRegI dst, rRegI src0, immI src1 ) %{    // emit_reg_lea
 2266     int reg_encoding = $dst$$reg;
 2267     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2268     int index        = 0x04;            // 0x04 indicates no index
 2269     int scale        = 0x00;            // 0x00 indicates no scale
 2270     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2271     relocInfo::relocType disp_reloc = relocInfo::none;
 2272     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2273   %}
 2274 
 2275   enc_class min_enc (rRegI dst, rRegI src) %{    // MIN
 2276     // Compare dst,src
 2277     emit_opcode(cbuf,0x3B);
 2278     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2279     // jmp dst &lt; src around move
 2280     emit_opcode(cbuf,0x7C);
 2281     emit_d8(cbuf,2);
 2282     // move dst,src
 2283     emit_opcode(cbuf,0x8B);
 2284     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2285   %}
 2286 
 2287   enc_class max_enc (rRegI dst, rRegI src) %{    // MAX
 2288     // Compare dst,src
 2289     emit_opcode(cbuf,0x3B);
 2290     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2291     // jmp dst &gt; src around move
 2292     emit_opcode(cbuf,0x7F);
 2293     emit_d8(cbuf,2);
 2294     // move dst,src
 2295     emit_opcode(cbuf,0x8B);
 2296     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2297   %}
 2298 
 2299   enc_class enc_FPR_store(memory mem, regDPR src) %{
 2300     // If src is FPR1, we can just FST to store it.
 2301     // Else we need to FLD it to FPR1, then FSTP to store/pop it.
 2302     int reg_encoding = 0x2; // Just store
 2303     int base  = $mem$$base;
 2304     int index = $mem$$index;
 2305     int scale = $mem$$scale;
 2306     int displace = $mem$$disp;
 2307     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 2308     if( $src$$reg != FPR1L_enc ) {
 2309       reg_encoding = 0x3;  // Store &amp; pop
 2310       emit_opcode( cbuf, 0xD9 ); // FLD (i.e., push it)
 2311       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2312     }
 2313     cbuf.set_insts_mark();       // Mark start of opcode for reloc info in mem operand
 2314     emit_opcode(cbuf,$primary);
 2315     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2316   %}
 2317 
 2318   enc_class neg_reg(rRegI dst) %{
 2319     // NEG $dst
 2320     emit_opcode(cbuf,0xF7);
 2321     emit_rm(cbuf, 0x3, 0x03, $dst$$reg );
 2322   %}
 2323 
 2324   enc_class setLT_reg(eCXRegI dst) %{
 2325     // SETLT $dst
 2326     emit_opcode(cbuf,0x0F);
 2327     emit_opcode(cbuf,0x9C);
 2328     emit_rm( cbuf, 0x3, 0x4, $dst$$reg );
 2329   %}
 2330 
 2331   enc_class enc_cmpLTP(ncxRegI p, ncxRegI q, ncxRegI y, eCXRegI tmp) %{    // cadd_cmpLT
 2332     int tmpReg = $tmp$$reg;
 2333 
 2334     // SUB $p,$q
 2335     emit_opcode(cbuf,0x2B);
 2336     emit_rm(cbuf, 0x3, $p$$reg, $q$$reg);
 2337     // SBB $tmp,$tmp
 2338     emit_opcode(cbuf,0x1B);
 2339     emit_rm(cbuf, 0x3, tmpReg, tmpReg);
 2340     // AND $tmp,$y
 2341     emit_opcode(cbuf,0x23);
 2342     emit_rm(cbuf, 0x3, tmpReg, $y$$reg);
 2343     // ADD $p,$tmp
 2344     emit_opcode(cbuf,0x03);
 2345     emit_rm(cbuf, 0x3, $p$$reg, tmpReg);
 2346   %}
 2347 
 2348   enc_class shift_left_long( eRegL dst, eCXRegI shift ) %{
 2349     // TEST shift,32
 2350     emit_opcode(cbuf,0xF7);
 2351     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2352     emit_d32(cbuf,0x20);
 2353     // JEQ,s small
 2354     emit_opcode(cbuf, 0x74);
 2355     emit_d8(cbuf, 0x04);
 2356     // MOV    $dst.hi,$dst.lo
 2357     emit_opcode( cbuf, 0x8B );
 2358     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );
 2359     // CLR    $dst.lo
 2360     emit_opcode(cbuf, 0x33);
 2361     emit_rm(cbuf, 0x3, $dst$$reg, $dst$$reg);
 2362 // small:
 2363     // SHLD   $dst.hi,$dst.lo,$shift
 2364     emit_opcode(cbuf,0x0F);
 2365     emit_opcode(cbuf,0xA5);
 2366     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));
 2367     // SHL    $dst.lo,$shift&quot;
 2368     emit_opcode(cbuf,0xD3);
 2369     emit_rm(cbuf, 0x3, 0x4, $dst$$reg );
 2370   %}
 2371 
 2372   enc_class shift_right_long( eRegL dst, eCXRegI shift ) %{
 2373     // TEST shift,32
 2374     emit_opcode(cbuf,0xF7);
 2375     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2376     emit_d32(cbuf,0x20);
 2377     // JEQ,s small
 2378     emit_opcode(cbuf, 0x74);
 2379     emit_d8(cbuf, 0x04);
 2380     // MOV    $dst.lo,$dst.hi
 2381     emit_opcode( cbuf, 0x8B );
 2382     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );
 2383     // CLR    $dst.hi
 2384     emit_opcode(cbuf, 0x33);
 2385     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($dst$$reg));
 2386 // small:
 2387     // SHRD   $dst.lo,$dst.hi,$shift
 2388     emit_opcode(cbuf,0x0F);
 2389     emit_opcode(cbuf,0xAD);
 2390     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);
 2391     // SHR    $dst.hi,$shift&quot;
 2392     emit_opcode(cbuf,0xD3);
 2393     emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW($dst$$reg) );
 2394   %}
 2395 
 2396   enc_class shift_right_arith_long( eRegL dst, eCXRegI shift ) %{
 2397     // TEST shift,32
 2398     emit_opcode(cbuf,0xF7);
 2399     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2400     emit_d32(cbuf,0x20);
 2401     // JEQ,s small
 2402     emit_opcode(cbuf, 0x74);
 2403     emit_d8(cbuf, 0x05);
 2404     // MOV    $dst.lo,$dst.hi
 2405     emit_opcode( cbuf, 0x8B );
 2406     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );
 2407     // SAR    $dst.hi,31
 2408     emit_opcode(cbuf, 0xC1);
 2409     emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW($dst$$reg) );
 2410     emit_d8(cbuf, 0x1F );
 2411 // small:
 2412     // SHRD   $dst.lo,$dst.hi,$shift
 2413     emit_opcode(cbuf,0x0F);
 2414     emit_opcode(cbuf,0xAD);
 2415     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);
 2416     // SAR    $dst.hi,$shift&quot;
 2417     emit_opcode(cbuf,0xD3);
 2418     emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW($dst$$reg) );
 2419   %}
 2420 
 2421 
 2422   // ----------------- Encodings for floating point unit -----------------
 2423   // May leave result in FPU-TOS or FPU reg depending on opcodes
 2424   enc_class OpcReg_FPR(regFPR src) %{    // FMUL, FDIV
 2425     $$$emit8$primary;
 2426     emit_rm(cbuf, 0x3, $secondary, $src$$reg );
 2427   %}
 2428 
 2429   // Pop argument in FPR0 with FSTP ST(0)
 2430   enc_class PopFPU() %{
 2431     emit_opcode( cbuf, 0xDD );
 2432     emit_d8( cbuf, 0xD8 );
 2433   %}
 2434 
 2435   // !!!!! equivalent to Pop_Reg_F
 2436   enc_class Pop_Reg_DPR( regDPR dst ) %{
 2437     emit_opcode( cbuf, 0xDD );           // FSTP   ST(i)
 2438     emit_d8( cbuf, 0xD8+$dst$$reg );
 2439   %}
 2440 
 2441   enc_class Push_Reg_DPR( regDPR dst ) %{
 2442     emit_opcode( cbuf, 0xD9 );
 2443     emit_d8( cbuf, 0xC0-1+$dst$$reg );   // FLD ST(i-1)
 2444   %}
 2445 
 2446   enc_class strictfp_bias1( regDPR dst ) %{
 2447     emit_opcode( cbuf, 0xDB );           // FLD m80real
 2448     emit_opcode( cbuf, 0x2D );
 2449     emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias1() );
 2450     emit_opcode( cbuf, 0xDE );           // FMULP ST(dst), ST0
 2451     emit_opcode( cbuf, 0xC8+$dst$$reg );
 2452   %}
 2453 
 2454   enc_class strictfp_bias2( regDPR dst ) %{
 2455     emit_opcode( cbuf, 0xDB );           // FLD m80real
 2456     emit_opcode( cbuf, 0x2D );
 2457     emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias2() );
 2458     emit_opcode( cbuf, 0xDE );           // FMULP ST(dst), ST0
 2459     emit_opcode( cbuf, 0xC8+$dst$$reg );
 2460   %}
 2461 
 2462   // Special case for moving an integer register to a stack slot.
 2463   enc_class OpcPRegSS( stackSlotI dst, rRegI src ) %{ // RegSS
 2464     store_to_stackslot( cbuf, $primary, $src$$reg, $dst$$disp );
 2465   %}
 2466 
 2467   // Special case for moving a register to a stack slot.
 2468   enc_class RegSS( stackSlotI dst, rRegI src ) %{ // RegSS
 2469     // Opcode already emitted
 2470     emit_rm( cbuf, 0x02, $src$$reg, ESP_enc );   // R/M byte
 2471     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);          // SIB byte
 2472     emit_d32(cbuf, $dst$$disp);   // Displacement
 2473   %}
 2474 
 2475   // Push the integer in stackSlot &#39;src&#39; onto FP-stack
 2476   enc_class Push_Mem_I( memory src ) %{    // FILD   [ESP+src]
 2477     store_to_stackslot( cbuf, $primary, $secondary, $src$$disp );
 2478   %}
 2479 
 2480   // Push FPU&#39;s TOS float to a stack-slot, and pop FPU-stack
 2481   enc_class Pop_Mem_FPR( stackSlotF dst ) %{ // FSTP_S [ESP+dst]
 2482     store_to_stackslot( cbuf, 0xD9, 0x03, $dst$$disp );
 2483   %}
 2484 
 2485   // Same as Pop_Mem_F except for opcode
 2486   // Push FPU&#39;s TOS double to a stack-slot, and pop FPU-stack
 2487   enc_class Pop_Mem_DPR( stackSlotD dst ) %{ // FSTP_D [ESP+dst]
 2488     store_to_stackslot( cbuf, 0xDD, 0x03, $dst$$disp );
 2489   %}
 2490 
 2491   enc_class Pop_Reg_FPR( regFPR dst ) %{
 2492     emit_opcode( cbuf, 0xDD );           // FSTP   ST(i)
 2493     emit_d8( cbuf, 0xD8+$dst$$reg );
 2494   %}
 2495 
 2496   enc_class Push_Reg_FPR( regFPR dst ) %{
 2497     emit_opcode( cbuf, 0xD9 );           // FLD    ST(i-1)
 2498     emit_d8( cbuf, 0xC0-1+$dst$$reg );
 2499   %}
 2500 
 2501   // Push FPU&#39;s float to a stack-slot, and pop FPU-stack
 2502   enc_class Pop_Mem_Reg_FPR( stackSlotF dst, regFPR src ) %{
 2503     int pop = 0x02;
 2504     if ($src$$reg != FPR1L_enc) {
 2505       emit_opcode( cbuf, 0xD9 );         // FLD    ST(i-1)
 2506       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2507       pop = 0x03;
 2508     }
 2509     store_to_stackslot( cbuf, 0xD9, pop, $dst$$disp ); // FST&lt;P&gt;_S  [ESP+dst]
 2510   %}
 2511 
 2512   // Push FPU&#39;s double to a stack-slot, and pop FPU-stack
 2513   enc_class Pop_Mem_Reg_DPR( stackSlotD dst, regDPR src ) %{
 2514     int pop = 0x02;
 2515     if ($src$$reg != FPR1L_enc) {
 2516       emit_opcode( cbuf, 0xD9 );         // FLD    ST(i-1)
 2517       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2518       pop = 0x03;
 2519     }
 2520     store_to_stackslot( cbuf, 0xDD, pop, $dst$$disp ); // FST&lt;P&gt;_D  [ESP+dst]
 2521   %}
 2522 
 2523   // Push FPU&#39;s double to a FPU-stack-slot, and pop FPU-stack
 2524   enc_class Pop_Reg_Reg_DPR( regDPR dst, regFPR src ) %{
 2525     int pop = 0xD0 - 1; // -1 since we skip FLD
 2526     if ($src$$reg != FPR1L_enc) {
 2527       emit_opcode( cbuf, 0xD9 );         // FLD    ST(src-1)
 2528       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2529       pop = 0xD8;
 2530     }
 2531     emit_opcode( cbuf, 0xDD );
 2532     emit_d8( cbuf, pop+$dst$$reg );      // FST&lt;P&gt; ST(i)
 2533   %}
 2534 
 2535 
 2536   enc_class Push_Reg_Mod_DPR( regDPR dst, regDPR src) %{
 2537     // load dst in FPR0
 2538     emit_opcode( cbuf, 0xD9 );
 2539     emit_d8( cbuf, 0xC0-1+$dst$$reg );
 2540     if ($src$$reg != FPR1L_enc) {
 2541       // fincstp
 2542       emit_opcode (cbuf, 0xD9);
 2543       emit_opcode (cbuf, 0xF7);
 2544       // swap src with FPR1:
 2545       // FXCH FPR1 with src
 2546       emit_opcode(cbuf, 0xD9);
 2547       emit_d8(cbuf, 0xC8-1+$src$$reg );
 2548       // fdecstp
 2549       emit_opcode (cbuf, 0xD9);
 2550       emit_opcode (cbuf, 0xF6);
 2551     }
 2552   %}
 2553 
 2554   enc_class Push_ModD_encoding(regD src0, regD src1) %{
 2555     MacroAssembler _masm(&amp;cbuf);
 2556     __ subptr(rsp, 8);
 2557     __ movdbl(Address(rsp, 0), $src1$$XMMRegister);
 2558     __ fld_d(Address(rsp, 0));
 2559     __ movdbl(Address(rsp, 0), $src0$$XMMRegister);
 2560     __ fld_d(Address(rsp, 0));
 2561   %}
 2562 
 2563   enc_class Push_ModF_encoding(regF src0, regF src1) %{
 2564     MacroAssembler _masm(&amp;cbuf);
 2565     __ subptr(rsp, 4);
 2566     __ movflt(Address(rsp, 0), $src1$$XMMRegister);
 2567     __ fld_s(Address(rsp, 0));
 2568     __ movflt(Address(rsp, 0), $src0$$XMMRegister);
 2569     __ fld_s(Address(rsp, 0));
 2570   %}
 2571 
 2572   enc_class Push_ResultD(regD dst) %{
 2573     MacroAssembler _masm(&amp;cbuf);
 2574     __ fstp_d(Address(rsp, 0));
 2575     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2576     __ addptr(rsp, 8);
 2577   %}
 2578 
 2579   enc_class Push_ResultF(regF dst, immI d8) %{
 2580     MacroAssembler _masm(&amp;cbuf);
 2581     __ fstp_s(Address(rsp, 0));
 2582     __ movflt($dst$$XMMRegister, Address(rsp, 0));
 2583     __ addptr(rsp, $d8$$constant);
 2584   %}
 2585 
 2586   enc_class Push_SrcD(regD src) %{
 2587     MacroAssembler _masm(&amp;cbuf);
 2588     __ subptr(rsp, 8);
 2589     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2590     __ fld_d(Address(rsp, 0));
 2591   %}
 2592 
 2593   enc_class push_stack_temp_qword() %{
 2594     MacroAssembler _masm(&amp;cbuf);
 2595     __ subptr(rsp, 8);
 2596   %}
 2597 
 2598   enc_class pop_stack_temp_qword() %{
 2599     MacroAssembler _masm(&amp;cbuf);
 2600     __ addptr(rsp, 8);
 2601   %}
 2602 
 2603   enc_class push_xmm_to_fpr1(regD src) %{
 2604     MacroAssembler _masm(&amp;cbuf);
 2605     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2606     __ fld_d(Address(rsp, 0));
 2607   %}
 2608 
 2609   enc_class Push_Result_Mod_DPR( regDPR src) %{
 2610     if ($src$$reg != FPR1L_enc) {
 2611       // fincstp
 2612       emit_opcode (cbuf, 0xD9);
 2613       emit_opcode (cbuf, 0xF7);
 2614       // FXCH FPR1 with src
 2615       emit_opcode(cbuf, 0xD9);
 2616       emit_d8(cbuf, 0xC8-1+$src$$reg );
 2617       // fdecstp
 2618       emit_opcode (cbuf, 0xD9);
 2619       emit_opcode (cbuf, 0xF6);
 2620     }
 2621     // // following asm replaced with Pop_Reg_F or Pop_Mem_F
 2622     // // FSTP   FPR$dst$$reg
 2623     // emit_opcode( cbuf, 0xDD );
 2624     // emit_d8( cbuf, 0xD8+$dst$$reg );
 2625   %}
 2626 
 2627   enc_class fnstsw_sahf_skip_parity() %{
 2628     // fnstsw ax
 2629     emit_opcode( cbuf, 0xDF );
 2630     emit_opcode( cbuf, 0xE0 );
 2631     // sahf
 2632     emit_opcode( cbuf, 0x9E );
 2633     // jnp  ::skip
 2634     emit_opcode( cbuf, 0x7B );
 2635     emit_opcode( cbuf, 0x05 );
 2636   %}
 2637 
 2638   enc_class emitModDPR() %{
 2639     // fprem must be iterative
 2640     // :: loop
 2641     // fprem
 2642     emit_opcode( cbuf, 0xD9 );
 2643     emit_opcode( cbuf, 0xF8 );
 2644     // wait
 2645     emit_opcode( cbuf, 0x9b );
 2646     // fnstsw ax
 2647     emit_opcode( cbuf, 0xDF );
 2648     emit_opcode( cbuf, 0xE0 );
 2649     // sahf
 2650     emit_opcode( cbuf, 0x9E );
 2651     // jp  ::loop
 2652     emit_opcode( cbuf, 0x0F );
 2653     emit_opcode( cbuf, 0x8A );
 2654     emit_opcode( cbuf, 0xF4 );
 2655     emit_opcode( cbuf, 0xFF );
 2656     emit_opcode( cbuf, 0xFF );
 2657     emit_opcode( cbuf, 0xFF );
 2658   %}
 2659 
 2660   enc_class fpu_flags() %{
 2661     // fnstsw_ax
 2662     emit_opcode( cbuf, 0xDF);
 2663     emit_opcode( cbuf, 0xE0);
 2664     // test ax,0x0400
 2665     emit_opcode( cbuf, 0x66 );   // operand-size prefix for 16-bit immediate
 2666     emit_opcode( cbuf, 0xA9 );
 2667     emit_d16   ( cbuf, 0x0400 );
 2668     // // // This sequence works, but stalls for 12-16 cycles on PPro
 2669     // // test rax,0x0400
 2670     // emit_opcode( cbuf, 0xA9 );
 2671     // emit_d32   ( cbuf, 0x00000400 );
 2672     //
 2673     // jz exit (no unordered comparison)
 2674     emit_opcode( cbuf, 0x74 );
 2675     emit_d8    ( cbuf, 0x02 );
 2676     // mov ah,1 - treat as LT case (set carry flag)
 2677     emit_opcode( cbuf, 0xB4 );
 2678     emit_d8    ( cbuf, 0x01 );
 2679     // sahf
 2680     emit_opcode( cbuf, 0x9E);
 2681   %}
 2682 
 2683   enc_class cmpF_P6_fixup() %{
 2684     // Fixup the integer flags in case comparison involved a NaN
 2685     //
 2686     // JNP exit (no unordered comparison, P-flag is set by NaN)
 2687     emit_opcode( cbuf, 0x7B );
 2688     emit_d8    ( cbuf, 0x03 );
 2689     // MOV AH,1 - treat as LT case (set carry flag)
 2690     emit_opcode( cbuf, 0xB4 );
 2691     emit_d8    ( cbuf, 0x01 );
 2692     // SAHF
 2693     emit_opcode( cbuf, 0x9E);
 2694     // NOP     // target for branch to avoid branch to branch
 2695     emit_opcode( cbuf, 0x90);
 2696   %}
 2697 
 2698 //     fnstsw_ax();
 2699 //     sahf();
 2700 //     movl(dst, nan_result);
 2701 //     jcc(Assembler::parity, exit);
 2702 //     movl(dst, less_result);
 2703 //     jcc(Assembler::below, exit);
 2704 //     movl(dst, equal_result);
 2705 //     jcc(Assembler::equal, exit);
 2706 //     movl(dst, greater_result);
 2707 
 2708 // less_result     =  1;
 2709 // greater_result  = -1;
 2710 // equal_result    = 0;
 2711 // nan_result      = -1;
 2712 
 2713   enc_class CmpF_Result(rRegI dst) %{
 2714     // fnstsw_ax();
 2715     emit_opcode( cbuf, 0xDF);
 2716     emit_opcode( cbuf, 0xE0);
 2717     // sahf
 2718     emit_opcode( cbuf, 0x9E);
 2719     // movl(dst, nan_result);
 2720     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2721     emit_d32( cbuf, -1 );
 2722     // jcc(Assembler::parity, exit);
 2723     emit_opcode( cbuf, 0x7A );
 2724     emit_d8    ( cbuf, 0x13 );
 2725     // movl(dst, less_result);
 2726     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2727     emit_d32( cbuf, -1 );
 2728     // jcc(Assembler::below, exit);
 2729     emit_opcode( cbuf, 0x72 );
 2730     emit_d8    ( cbuf, 0x0C );
 2731     // movl(dst, equal_result);
 2732     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2733     emit_d32( cbuf, 0 );
 2734     // jcc(Assembler::equal, exit);
 2735     emit_opcode( cbuf, 0x74 );
 2736     emit_d8    ( cbuf, 0x05 );
 2737     // movl(dst, greater_result);
 2738     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2739     emit_d32( cbuf, 1 );
 2740   %}
 2741 
 2742 
 2743   // Compare the longs and set flags
 2744   // BROKEN!  Do Not use as-is
 2745   enc_class cmpl_test( eRegL src1, eRegL src2 ) %{
 2746     // CMP    $src1.hi,$src2.hi
 2747     emit_opcode( cbuf, 0x3B );
 2748     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );
 2749     // JNE,s  done
 2750     emit_opcode(cbuf,0x75);
 2751     emit_d8(cbuf, 2 );
 2752     // CMP    $src1.lo,$src2.lo
 2753     emit_opcode( cbuf, 0x3B );
 2754     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2755 // done:
 2756   %}
 2757 
 2758   enc_class convert_int_long( regL dst, rRegI src ) %{
 2759     // mov $dst.lo,$src
 2760     int dst_encoding = $dst$$reg;
 2761     int src_encoding = $src$$reg;
 2762     encode_Copy( cbuf, dst_encoding  , src_encoding );
 2763     // mov $dst.hi,$src
 2764     encode_Copy( cbuf, HIGH_FROM_LOW(dst_encoding), src_encoding );
 2765     // sar $dst.hi,31
 2766     emit_opcode( cbuf, 0xC1 );
 2767     emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW(dst_encoding) );
 2768     emit_d8(cbuf, 0x1F );
 2769   %}
 2770 
 2771   enc_class convert_long_double( eRegL src ) %{
 2772     // push $src.hi
 2773     emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));
 2774     // push $src.lo
 2775     emit_opcode(cbuf, 0x50+$src$$reg  );
 2776     // fild 64-bits at [SP]
 2777     emit_opcode(cbuf,0xdf);
 2778     emit_d8(cbuf, 0x6C);
 2779     emit_d8(cbuf, 0x24);
 2780     emit_d8(cbuf, 0x00);
 2781     // pop stack
 2782     emit_opcode(cbuf, 0x83); // add  SP, #8
 2783     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2784     emit_d8(cbuf, 0x8);
 2785   %}
 2786 
 2787   enc_class multiply_con_and_shift_high( eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32_63 cnt, eFlagsReg cr ) %{
 2788     // IMUL   EDX:EAX,$src1
 2789     emit_opcode( cbuf, 0xF7 );
 2790     emit_rm( cbuf, 0x3, 0x5, $src1$$reg );
 2791     // SAR    EDX,$cnt-32
 2792     int shift_count = ((int)$cnt$$constant) - 32;
 2793     if (shift_count &gt; 0) {
 2794       emit_opcode(cbuf, 0xC1);
 2795       emit_rm(cbuf, 0x3, 7, $dst$$reg );
 2796       emit_d8(cbuf, shift_count);
 2797     }
 2798   %}
 2799 
 2800   // this version doesn&#39;t have add sp, 8
 2801   enc_class convert_long_double2( eRegL src ) %{
 2802     // push $src.hi
 2803     emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));
 2804     // push $src.lo
 2805     emit_opcode(cbuf, 0x50+$src$$reg  );
 2806     // fild 64-bits at [SP]
 2807     emit_opcode(cbuf,0xdf);
 2808     emit_d8(cbuf, 0x6C);
 2809     emit_d8(cbuf, 0x24);
 2810     emit_d8(cbuf, 0x00);
 2811   %}
 2812 
 2813   enc_class long_int_multiply( eADXRegL dst, nadxRegI src) %{
 2814     // Basic idea: long = (long)int * (long)int
 2815     // IMUL EDX:EAX, src
 2816     emit_opcode( cbuf, 0xF7 );
 2817     emit_rm( cbuf, 0x3, 0x5, $src$$reg);
 2818   %}
 2819 
 2820   enc_class long_uint_multiply( eADXRegL dst, nadxRegI src) %{
 2821     // Basic Idea:  long = (int &amp; 0xffffffffL) * (int &amp; 0xffffffffL)
 2822     // MUL EDX:EAX, src
 2823     emit_opcode( cbuf, 0xF7 );
 2824     emit_rm( cbuf, 0x3, 0x4, $src$$reg);
 2825   %}
 2826 
 2827   enc_class long_multiply( eADXRegL dst, eRegL src, rRegI tmp ) %{
 2828     // Basic idea: lo(result) = lo(x_lo * y_lo)
 2829     //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 2830     // MOV    $tmp,$src.lo
 2831     encode_Copy( cbuf, $tmp$$reg, $src$$reg );
 2832     // IMUL   $tmp,EDX
 2833     emit_opcode( cbuf, 0x0F );
 2834     emit_opcode( cbuf, 0xAF );
 2835     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2836     // MOV    EDX,$src.hi
 2837     encode_Copy( cbuf, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg) );
 2838     // IMUL   EDX,EAX
 2839     emit_opcode( cbuf, 0x0F );
 2840     emit_opcode( cbuf, 0xAF );
 2841     emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );
 2842     // ADD    $tmp,EDX
 2843     emit_opcode( cbuf, 0x03 );
 2844     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2845     // MUL   EDX:EAX,$src.lo
 2846     emit_opcode( cbuf, 0xF7 );
 2847     emit_rm( cbuf, 0x3, 0x4, $src$$reg );
 2848     // ADD    EDX,ESI
 2849     emit_opcode( cbuf, 0x03 );
 2850     emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $tmp$$reg );
 2851   %}
 2852 
 2853   enc_class long_multiply_con( eADXRegL dst, immL_127 src, rRegI tmp ) %{
 2854     // Basic idea: lo(result) = lo(src * y_lo)
 2855     //             hi(result) = hi(src * y_lo) + lo(src * y_hi)
 2856     // IMUL   $tmp,EDX,$src
 2857     emit_opcode( cbuf, 0x6B );
 2858     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2859     emit_d8( cbuf, (int)$src$$constant );
 2860     // MOV    EDX,$src
 2861     emit_opcode(cbuf, 0xB8 + EDX_enc);
 2862     emit_d32( cbuf, (int)$src$$constant );
 2863     // MUL   EDX:EAX,EDX
 2864     emit_opcode( cbuf, 0xF7 );
 2865     emit_rm( cbuf, 0x3, 0x4, EDX_enc );
 2866     // ADD    EDX,ESI
 2867     emit_opcode( cbuf, 0x03 );
 2868     emit_rm( cbuf, 0x3, EDX_enc, $tmp$$reg );
 2869   %}
 2870 
 2871   enc_class long_div( eRegL src1, eRegL src2 ) %{
 2872     // PUSH src1.hi
 2873     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );
 2874     // PUSH src1.lo
 2875     emit_opcode(cbuf,               0x50+$src1$$reg  );
 2876     // PUSH src2.hi
 2877     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );
 2878     // PUSH src2.lo
 2879     emit_opcode(cbuf,               0x50+$src2$$reg  );
 2880     // CALL directly to the runtime
 2881     cbuf.set_insts_mark();
 2882     emit_opcode(cbuf,0xE8);       // Call into runtime
 2883     emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::ldiv) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 2884     // Restore stack
 2885     emit_opcode(cbuf, 0x83); // add  SP, #framesize
 2886     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2887     emit_d8(cbuf, 4*4);
 2888   %}
 2889 
 2890   enc_class long_mod( eRegL src1, eRegL src2 ) %{
 2891     // PUSH src1.hi
 2892     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );
 2893     // PUSH src1.lo
 2894     emit_opcode(cbuf,               0x50+$src1$$reg  );
 2895     // PUSH src2.hi
 2896     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );
 2897     // PUSH src2.lo
 2898     emit_opcode(cbuf,               0x50+$src2$$reg  );
 2899     // CALL directly to the runtime
 2900     cbuf.set_insts_mark();
 2901     emit_opcode(cbuf,0xE8);       // Call into runtime
 2902     emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::lrem ) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 2903     // Restore stack
 2904     emit_opcode(cbuf, 0x83); // add  SP, #framesize
 2905     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2906     emit_d8(cbuf, 4*4);
 2907   %}
 2908 
 2909   enc_class long_cmp_flags0( eRegL src, rRegI tmp ) %{
 2910     // MOV   $tmp,$src.lo
 2911     emit_opcode(cbuf, 0x8B);
 2912     emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg);
 2913     // OR    $tmp,$src.hi
 2914     emit_opcode(cbuf, 0x0B);
 2915     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg));
 2916   %}
 2917 
 2918   enc_class long_cmp_flags1( eRegL src1, eRegL src2 ) %{
 2919     // CMP    $src1.lo,$src2.lo
 2920     emit_opcode( cbuf, 0x3B );
 2921     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2922     // JNE,s  skip
 2923     emit_cc(cbuf, 0x70, 0x5);
 2924     emit_d8(cbuf,2);
 2925     // CMP    $src1.hi,$src2.hi
 2926     emit_opcode( cbuf, 0x3B );
 2927     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );
 2928   %}
 2929 
 2930   enc_class long_cmp_flags2( eRegL src1, eRegL src2, rRegI tmp ) %{
 2931     // CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits
 2932     emit_opcode( cbuf, 0x3B );
 2933     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2934     // MOV    $tmp,$src1.hi
 2935     emit_opcode( cbuf, 0x8B );
 2936     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src1$$reg) );
 2937     // SBB   $tmp,$src2.hi\t! Compute flags for long compare
 2938     emit_opcode( cbuf, 0x1B );
 2939     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src2$$reg) );
 2940   %}
 2941 
 2942   enc_class long_cmp_flags3( eRegL src, rRegI tmp ) %{
 2943     // XOR    $tmp,$tmp
 2944     emit_opcode(cbuf,0x33);  // XOR
 2945     emit_rm(cbuf,0x3, $tmp$$reg, $tmp$$reg);
 2946     // CMP    $tmp,$src.lo
 2947     emit_opcode( cbuf, 0x3B );
 2948     emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg );
 2949     // SBB    $tmp,$src.hi
 2950     emit_opcode( cbuf, 0x1B );
 2951     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg) );
 2952   %}
 2953 
 2954  // Sniff, sniff... smells like Gnu Superoptimizer
 2955   enc_class neg_long( eRegL dst ) %{
 2956     emit_opcode(cbuf,0xF7);    // NEG hi
 2957     emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));
 2958     emit_opcode(cbuf,0xF7);    // NEG lo
 2959     emit_rm    (cbuf,0x3, 0x3,               $dst$$reg );
 2960     emit_opcode(cbuf,0x83);    // SBB hi,0
 2961     emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));
 2962     emit_d8    (cbuf,0 );
 2963   %}
 2964 
 2965   enc_class enc_pop_rdx() %{
 2966     emit_opcode(cbuf,0x5A);
 2967   %}
 2968 
 2969   enc_class enc_rethrow() %{
 2970     cbuf.set_insts_mark();
 2971     emit_opcode(cbuf, 0xE9);        // jmp    entry
 2972     emit_d32_reloc(cbuf, (int)OptoRuntime::rethrow_stub() - ((int)cbuf.insts_end())-4,
 2973                    runtime_call_Relocation::spec(), RELOC_IMM32 );
 2974   %}
 2975 
 2976 
 2977   // Convert a double to an int.  Java semantics require we do complex
 2978   // manglelations in the corner cases.  So we set the rounding mode to
 2979   // &#39;zero&#39;, store the darned double down as an int, and reset the
 2980   // rounding mode to &#39;nearest&#39;.  The hardware throws an exception which
 2981   // patches up the correct value directly to the stack.
 2982   enc_class DPR2I_encoding( regDPR src ) %{
 2983     // Flip to round-to-zero mode.  We attempted to allow invalid-op
 2984     // exceptions here, so that a NAN or other corner-case value will
 2985     // thrown an exception (but normal values get converted at full speed).
 2986     // However, I2C adapters and other float-stack manglers leave pending
 2987     // invalid-op exceptions hanging.  We would have to clear them before
 2988     // enabling them and that is more expensive than just testing for the
 2989     // invalid value Intel stores down in the corner cases.
 2990     emit_opcode(cbuf,0xD9);            // FLDCW  trunc
 2991     emit_opcode(cbuf,0x2D);
 2992     emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());
 2993     // Allocate a word
 2994     emit_opcode(cbuf,0x83);            // SUB ESP,4
 2995     emit_opcode(cbuf,0xEC);
 2996     emit_d8(cbuf,0x04);
 2997     // Encoding assumes a double has been pushed into FPR0.
 2998     // Store down the double as an int, popping the FPU stack
 2999     emit_opcode(cbuf,0xDB);            // FISTP [ESP]
 3000     emit_opcode(cbuf,0x1C);
 3001     emit_d8(cbuf,0x24);
 3002     // Restore the rounding mode; mask the exception
 3003     emit_opcode(cbuf,0xD9);            // FLDCW   std/24-bit mode
 3004     emit_opcode(cbuf,0x2D);
 3005     emit_d32( cbuf, Compile::current()-&gt;in_24_bit_fp_mode()
 3006         ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()
 3007         : (int)StubRoutines::addr_fpu_cntrl_wrd_std());
 3008 
 3009     // Load the converted int; adjust CPU stack
 3010     emit_opcode(cbuf,0x58);       // POP EAX
 3011     emit_opcode(cbuf,0x3D);       // CMP EAX,imm
 3012     emit_d32   (cbuf,0x80000000); //         0x80000000
 3013     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3014     emit_d8    (cbuf,0x07);       // Size of slow_call
 3015     // Push src onto stack slow-path
 3016     emit_opcode(cbuf,0xD9 );      // FLD     ST(i)
 3017     emit_d8    (cbuf,0xC0-1+$src$$reg );
 3018     // CALL directly to the runtime
 3019     cbuf.set_insts_mark();
 3020     emit_opcode(cbuf,0xE8);       // Call into runtime
 3021     emit_d32_reloc(cbuf, (StubRoutines::d2i_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 3022     // Carry on here...
 3023   %}
 3024 
 3025   enc_class DPR2L_encoding( regDPR src ) %{
 3026     emit_opcode(cbuf,0xD9);            // FLDCW  trunc
 3027     emit_opcode(cbuf,0x2D);
 3028     emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());
 3029     // Allocate a word
 3030     emit_opcode(cbuf,0x83);            // SUB ESP,8
 3031     emit_opcode(cbuf,0xEC);
 3032     emit_d8(cbuf,0x08);
 3033     // Encoding assumes a double has been pushed into FPR0.
 3034     // Store down the double as a long, popping the FPU stack
 3035     emit_opcode(cbuf,0xDF);            // FISTP [ESP]
 3036     emit_opcode(cbuf,0x3C);
 3037     emit_d8(cbuf,0x24);
 3038     // Restore the rounding mode; mask the exception
 3039     emit_opcode(cbuf,0xD9);            // FLDCW   std/24-bit mode
 3040     emit_opcode(cbuf,0x2D);
 3041     emit_d32( cbuf, Compile::current()-&gt;in_24_bit_fp_mode()
 3042         ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()
 3043         : (int)StubRoutines::addr_fpu_cntrl_wrd_std());
 3044 
 3045     // Load the converted int; adjust CPU stack
 3046     emit_opcode(cbuf,0x58);       // POP EAX
 3047     emit_opcode(cbuf,0x5A);       // POP EDX
 3048     emit_opcode(cbuf,0x81);       // CMP EDX,imm
 3049     emit_d8    (cbuf,0xFA);       // rdx
 3050     emit_d32   (cbuf,0x80000000); //         0x80000000
 3051     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3052     emit_d8    (cbuf,0x07+4);     // Size of slow_call
 3053     emit_opcode(cbuf,0x85);       // TEST EAX,EAX
 3054     emit_opcode(cbuf,0xC0);       // 2/rax,/rax,
 3055     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3056     emit_d8    (cbuf,0x07);       // Size of slow_call
 3057     // Push src onto stack slow-path
 3058     emit_opcode(cbuf,0xD9 );      // FLD     ST(i)
 3059     emit_d8    (cbuf,0xC0-1+$src$$reg );
 3060     // CALL directly to the runtime
 3061     cbuf.set_insts_mark();
 3062     emit_opcode(cbuf,0xE8);       // Call into runtime
 3063     emit_d32_reloc(cbuf, (StubRoutines::d2l_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 3064     // Carry on here...
 3065   %}
 3066 
 3067   enc_class FMul_ST_reg( eRegFPR src1 ) %{
 3068     // Operand was loaded from memory into fp ST (stack top)
 3069     // FMUL   ST,$src  /* D8 C8+i */
 3070     emit_opcode(cbuf, 0xD8);
 3071     emit_opcode(cbuf, 0xC8 + $src1$$reg);
 3072   %}
 3073 
 3074   enc_class FAdd_ST_reg( eRegFPR src2 ) %{
 3075     // FADDP  ST,src2  /* D8 C0+i */
 3076     emit_opcode(cbuf, 0xD8);
 3077     emit_opcode(cbuf, 0xC0 + $src2$$reg);
 3078     //could use FADDP  src2,fpST  /* DE C0+i */
 3079   %}
 3080 
 3081   enc_class FAddP_reg_ST( eRegFPR src2 ) %{
 3082     // FADDP  src2,ST  /* DE C0+i */
 3083     emit_opcode(cbuf, 0xDE);
 3084     emit_opcode(cbuf, 0xC0 + $src2$$reg);
 3085   %}
 3086 
 3087   enc_class subFPR_divFPR_encode( eRegFPR src1, eRegFPR src2) %{
 3088     // Operand has been loaded into fp ST (stack top)
 3089       // FSUB   ST,$src1
 3090       emit_opcode(cbuf, 0xD8);
 3091       emit_opcode(cbuf, 0xE0 + $src1$$reg);
 3092 
 3093       // FDIV
 3094       emit_opcode(cbuf, 0xD8);
 3095       emit_opcode(cbuf, 0xF0 + $src2$$reg);
 3096   %}
 3097 
 3098   enc_class MulFAddF (eRegFPR src1, eRegFPR src2) %{
 3099     // Operand was loaded from memory into fp ST (stack top)
 3100     // FADD   ST,$src  /* D8 C0+i */
 3101     emit_opcode(cbuf, 0xD8);
 3102     emit_opcode(cbuf, 0xC0 + $src1$$reg);
 3103 
 3104     // FMUL  ST,src2  /* D8 C*+i */
 3105     emit_opcode(cbuf, 0xD8);
 3106     emit_opcode(cbuf, 0xC8 + $src2$$reg);
 3107   %}
 3108 
 3109 
 3110   enc_class MulFAddFreverse (eRegFPR src1, eRegFPR src2) %{
 3111     // Operand was loaded from memory into fp ST (stack top)
 3112     // FADD   ST,$src  /* D8 C0+i */
 3113     emit_opcode(cbuf, 0xD8);
 3114     emit_opcode(cbuf, 0xC0 + $src1$$reg);
 3115 
 3116     // FMULP  src2,ST  /* DE C8+i */
 3117     emit_opcode(cbuf, 0xDE);
 3118     emit_opcode(cbuf, 0xC8 + $src2$$reg);
 3119   %}
 3120 
 3121   // Atomically load the volatile long
 3122   enc_class enc_loadL_volatile( memory mem, stackSlotL dst ) %{
 3123     emit_opcode(cbuf,0xDF);
 3124     int rm_byte_opcode = 0x05;
 3125     int base     = $mem$$base;
 3126     int index    = $mem$$index;
 3127     int scale    = $mem$$scale;
 3128     int displace = $mem$$disp;
 3129     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3130     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3131     store_to_stackslot( cbuf, 0x0DF, 0x07, $dst$$disp );
 3132   %}
 3133 
 3134   // Volatile Store Long.  Must be atomic, so move it into
 3135   // the FP TOS and then do a 64-bit FIST.  Has to probe the
 3136   // target address before the store (for null-ptr checks)
 3137   // so the memory operand is used twice in the encoding.
 3138   enc_class enc_storeL_volatile( memory mem, stackSlotL src ) %{
 3139     store_to_stackslot( cbuf, 0x0DF, 0x05, $src$$disp );
 3140     cbuf.set_insts_mark();            // Mark start of FIST in case $mem has an oop
 3141     emit_opcode(cbuf,0xDF);
 3142     int rm_byte_opcode = 0x07;
 3143     int base     = $mem$$base;
 3144     int index    = $mem$$index;
 3145     int scale    = $mem$$scale;
 3146     int displace = $mem$$disp;
 3147     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3148     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3149   %}
 3150 
 3151   // Safepoint Poll.  This polls the safepoint page, and causes an
 3152   // exception if it is not readable. Unfortunately, it kills the condition code
 3153   // in the process
 3154   // We current use TESTL [spp],EDI
 3155   // A better choice might be TESTB [spp + pagesize() - CacheLineSize()],0
 3156 
 3157   enc_class Safepoint_Poll() %{
 3158     cbuf.relocate(cbuf.insts_mark(), relocInfo::poll_type, 0);
 3159     emit_opcode(cbuf,0x85);
 3160     emit_rm (cbuf, 0x0, 0x7, 0x5);
 3161     emit_d32(cbuf, (intptr_t)os::get_polling_page());
 3162   %}
 3163 %}
 3164 
 3165 
 3166 //----------FRAME--------------------------------------------------------------
 3167 // Definition of frame structure and management information.
 3168 //
 3169 //  S T A C K   L A Y O U T    Allocators stack-slot number
 3170 //                             |   (to get allocators register number
 3171 //  G  Owned by    |        |  v    add OptoReg::stack0())
 3172 //  r   CALLER     |        |
 3173 //  o     |        +--------+      pad to even-align allocators stack-slot
 3174 //  w     V        |  pad0  |        numbers; owned by CALLER
 3175 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 3176 //  h     ^        |   in   |  5
 3177 //        |        |  args  |  4   Holes in incoming args owned by SELF
 3178 //  |     |        |        |  3
 3179 //  |     |        +--------+
 3180 //  V     |        | old out|      Empty on Intel, window on Sparc
 3181 //        |    old |preserve|      Must be even aligned.
 3182 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 3183 //        |        |   in   |  3   area for Intel ret address
 3184 //     Owned by    |preserve|      Empty on Sparc.
 3185 //       SELF      +--------+
 3186 //        |        |  pad2  |  2   pad to align old SP
 3187 //        |        +--------+  1
 3188 //        |        | locks  |  0
 3189 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 3190 //        |        |  pad1  | 11   pad to align new SP
 3191 //        |        +--------+
 3192 //        |        |        | 10
 3193 //        |        | spills |  9   spills
 3194 //        V        |        |  8   (pad0 slot for callee)
 3195 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 3196 //        ^        |  out   |  7
 3197 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 3198 //     Owned by    +--------+
 3199 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 3200 //        |    new |preserve|      Must be even-aligned.
 3201 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 3202 //        |        |        |
 3203 //
 3204 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 3205 //         known from SELF&#39;s arguments and the Java calling convention.
 3206 //         Region 6-7 is determined per call site.
 3207 // Note 2: If the calling convention leaves holes in the incoming argument
 3208 //         area, those holes are owned by SELF.  Holes in the outgoing area
 3209 //         are owned by the CALLEE.  Holes should not be nessecary in the
 3210 //         incoming area, as the Java calling convention is completely under
 3211 //         the control of the AD file.  Doubles can be sorted and packed to
 3212 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 3213 //         varargs C calling conventions.
 3214 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 3215 //         even aligned with pad0 as needed.
 3216 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 3217 //         region 6-11 is even aligned; it may be padded out more so that
 3218 //         the region from SP to FP meets the minimum stack alignment.
 3219 
 3220 frame %{
 3221   // What direction does stack grow in (assumed to be same for C &amp; Java)
 3222   stack_direction(TOWARDS_LOW);
 3223 
 3224   // These three registers define part of the calling convention
 3225   // between compiled code and the interpreter.
 3226   inline_cache_reg(EAX);                // Inline Cache Register
 3227   interpreter_method_oop_reg(EBX);      // Method Oop Register when calling interpreter
 3228 
 3229   // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
 3230   cisc_spilling_operand_name(indOffset32);
 3231 
 3232   // Number of stack slots consumed by locking an object
 3233   sync_stack_slots(1);
 3234 
 3235   // Compiled code&#39;s Frame Pointer
 3236   frame_pointer(ESP);
 3237   // Interpreter stores its frame pointer in a register which is
 3238   // stored to the stack by I2CAdaptors.
 3239   // I2CAdaptors convert from interpreted java to compiled java.
 3240   interpreter_frame_pointer(EBP);
 3241 
 3242   // Stack alignment requirement
 3243   // Alignment size in bytes (128-bit -&gt; 16 bytes)
 3244   stack_alignment(StackAlignmentInBytes);
 3245 
 3246   // Number of stack slots between incoming argument block and the start of
 3247   // a new frame.  The PROLOG must add this many slots to the stack.  The
 3248   // EPILOG must remove this many slots.  Intel needs one slot for
 3249   // return address and one for rbp, (must save rbp)
 3250   in_preserve_stack_slots(2+VerifyStackAtCalls);
 3251 
 3252   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 3253   // for calls to C.  Supports the var-args backing area for register parms.
 3254   varargs_C_out_slots_killed(0);
 3255 
 3256   // The after-PROLOG location of the return address.  Location of
 3257   // return address specifies a type (REG or STACK) and a number
 3258   // representing the register number (i.e. - use a register name) or
 3259   // stack slot.
 3260   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 3261   // Otherwise, it is above the locks and verification slot and alignment word
 3262   return_addr(STACK - 1 +
 3263               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 3264                         Compile::current()-&gt;fixed_slots()),
 3265                        stack_alignment_in_slots()));
 3266 
 3267   // Body of function which returns an integer array locating
 3268   // arguments either in registers or in stack slots.  Passed an array
 3269   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 3270   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 3271   // arguments for a CALLEE.  Incoming stack arguments are
 3272   // automatically biased by the preserve_stack_slots field above.
 3273   calling_convention %{
 3274     // No difference between ingoing/outgoing just pass false
 3275     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 3276   %}
 3277 
 3278 
 3279   // Body of function which returns an integer array locating
 3280   // arguments either in registers or in stack slots.  Passed an array
 3281   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 3282   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 3283   // arguments for a CALLEE.  Incoming stack arguments are
 3284   // automatically biased by the preserve_stack_slots field above.
 3285   c_calling_convention %{
 3286     // This is obviously always outgoing
 3287     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 3288   %}
 3289 
 3290   // Location of C &amp; interpreter return values
 3291   c_return_value %{
 3292     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3293     static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, EAX_num,      EAX_num,      FPR1L_num,    FPR1L_num, EAX_num };
 3294     static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, FPR1H_num, EDX_num };
 3295 
 3296     // in SSE2+ mode we want to keep the FPU stack clean so pretend
 3297     // that C functions return float and double results in XMM0.
 3298     if( ideal_reg == Op_RegD &amp;&amp; UseSSE&gt;=2 )
 3299       return OptoRegPair(XMM0b_num,XMM0_num);
 3300     if( ideal_reg == Op_RegF &amp;&amp; UseSSE&gt;=2 )
 3301       return OptoRegPair(OptoReg::Bad,XMM0_num);
 3302 
 3303     return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
 3304   %}
 3305 
 3306   // Location of return values
 3307   return_value %{
 3308     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3309     static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, EAX_num,      EAX_num,      FPR1L_num,    FPR1L_num, EAX_num };
 3310     static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, FPR1H_num, EDX_num };
 3311     if( ideal_reg == Op_RegD &amp;&amp; UseSSE&gt;=2 )
 3312       return OptoRegPair(XMM0b_num,XMM0_num);
 3313     if( ideal_reg == Op_RegF &amp;&amp; UseSSE&gt;=1 )
 3314       return OptoRegPair(OptoReg::Bad,XMM0_num);
 3315     return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
 3316   %}
 3317 
 3318 %}
 3319 
 3320 //----------ATTRIBUTES---------------------------------------------------------
 3321 //----------Operand Attributes-------------------------------------------------
 3322 op_attrib op_cost(0);        // Required cost attribute
 3323 
 3324 //----------Instruction Attributes---------------------------------------------
 3325 ins_attrib ins_cost(100);       // Required cost attribute
 3326 ins_attrib ins_size(8);         // Required size attribute (in bits)
 3327 ins_attrib ins_short_branch(0); // Required flag: is this instruction a
 3328                                 // non-matching short branch variant of some
 3329                                                             // long branch?
 3330 ins_attrib ins_alignment(1);    // Required alignment attribute (must be a power of 2)
 3331                                 // specifies the alignment that some part of the instruction (not
 3332                                 // necessarily the start) requires.  If &gt; 1, a compute_padding()
 3333                                 // function must be provided for the instruction
 3334 
 3335 //----------OPERANDS-----------------------------------------------------------
 3336 // Operand definitions must precede instruction definitions for correct parsing
 3337 // in the ADLC because operands constitute user defined types which are used in
 3338 // instruction definitions.
 3339 
 3340 //----------Simple Operands----------------------------------------------------
 3341 // Immediate Operands
 3342 // Integer Immediate
 3343 operand immI() %{
 3344   match(ConI);
 3345 
 3346   op_cost(10);
 3347   format %{ %}
 3348   interface(CONST_INTER);
 3349 %}
 3350 
 3351 // Constant for test vs zero
 3352 operand immI0() %{
 3353   predicate(n-&gt;get_int() == 0);
 3354   match(ConI);
 3355 
 3356   op_cost(0);
 3357   format %{ %}
 3358   interface(CONST_INTER);
 3359 %}
 3360 
 3361 // Constant for increment
 3362 operand immI1() %{
 3363   predicate(n-&gt;get_int() == 1);
 3364   match(ConI);
 3365 
 3366   op_cost(0);
 3367   format %{ %}
 3368   interface(CONST_INTER);
 3369 %}
 3370 
 3371 // Constant for decrement
 3372 operand immI_M1() %{
 3373   predicate(n-&gt;get_int() == -1);
 3374   match(ConI);
 3375 
 3376   op_cost(0);
 3377   format %{ %}
 3378   interface(CONST_INTER);
 3379 %}
 3380 
 3381 // Valid scale values for addressing modes
 3382 operand immI2() %{
 3383   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 3384   match(ConI);
 3385 
 3386   format %{ %}
 3387   interface(CONST_INTER);
 3388 %}
 3389 
 3390 operand immI8() %{
 3391   predicate((-128 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 127));
 3392   match(ConI);
 3393 
 3394   op_cost(5);
 3395   format %{ %}
 3396   interface(CONST_INTER);
 3397 %}
 3398 
 3399 operand immI16() %{
 3400   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 3401   match(ConI);
 3402 
 3403   op_cost(10);
 3404   format %{ %}
 3405   interface(CONST_INTER);
 3406 %}
 3407 
 3408 // Int Immediate non-negative
 3409 operand immU31()
 3410 %{
 3411   predicate(n-&gt;get_int() &gt;= 0);
 3412   match(ConI);
 3413 
 3414   op_cost(0);
 3415   format %{ %}
 3416   interface(CONST_INTER);
 3417 %}
 3418 
 3419 // Constant for long shifts
 3420 operand immI_32() %{
 3421   predicate( n-&gt;get_int() == 32 );
 3422   match(ConI);
 3423 
 3424   op_cost(0);
 3425   format %{ %}
 3426   interface(CONST_INTER);
 3427 %}
 3428 
 3429 operand immI_1_31() %{
 3430   predicate( n-&gt;get_int() &gt;= 1 &amp;&amp; n-&gt;get_int() &lt;= 31 );
 3431   match(ConI);
 3432 
 3433   op_cost(0);
 3434   format %{ %}
 3435   interface(CONST_INTER);
 3436 %}
 3437 
 3438 operand immI_32_63() %{
 3439   predicate( n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63 );
 3440   match(ConI);
 3441   op_cost(0);
 3442 
 3443   format %{ %}
 3444   interface(CONST_INTER);
 3445 %}
 3446 
 3447 operand immI_1() %{
 3448   predicate( n-&gt;get_int() == 1 );
 3449   match(ConI);
 3450 
 3451   op_cost(0);
 3452   format %{ %}
 3453   interface(CONST_INTER);
 3454 %}
 3455 
 3456 operand immI_2() %{
 3457   predicate( n-&gt;get_int() == 2 );
 3458   match(ConI);
 3459 
 3460   op_cost(0);
 3461   format %{ %}
 3462   interface(CONST_INTER);
 3463 %}
 3464 
 3465 operand immI_3() %{
 3466   predicate( n-&gt;get_int() == 3 );
 3467   match(ConI);
 3468 
 3469   op_cost(0);
 3470   format %{ %}
 3471   interface(CONST_INTER);
 3472 %}
 3473 
 3474 // Pointer Immediate
 3475 operand immP() %{
 3476   match(ConP);
 3477 
 3478   op_cost(10);
 3479   format %{ %}
 3480   interface(CONST_INTER);
 3481 %}
 3482 
 3483 // NULL Pointer Immediate
 3484 operand immP0() %{
 3485   predicate( n-&gt;get_ptr() == 0 );
 3486   match(ConP);
 3487   op_cost(0);
 3488 
 3489   format %{ %}
 3490   interface(CONST_INTER);
 3491 %}
 3492 
 3493 // Long Immediate
 3494 operand immL() %{
 3495   match(ConL);
 3496 
 3497   op_cost(20);
 3498   format %{ %}
 3499   interface(CONST_INTER);
 3500 %}
 3501 
 3502 // Long Immediate zero
 3503 operand immL0() %{
 3504   predicate( n-&gt;get_long() == 0L );
 3505   match(ConL);
 3506   op_cost(0);
 3507 
 3508   format %{ %}
 3509   interface(CONST_INTER);
 3510 %}
 3511 
 3512 // Long Immediate zero
 3513 operand immL_M1() %{
 3514   predicate( n-&gt;get_long() == -1L );
 3515   match(ConL);
 3516   op_cost(0);
 3517 
 3518   format %{ %}
 3519   interface(CONST_INTER);
 3520 %}
 3521 
 3522 // Long immediate from 0 to 127.
 3523 // Used for a shorter form of long mul by 10.
 3524 operand immL_127() %{
 3525   predicate((0 &lt;= n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() &lt;= 127));
 3526   match(ConL);
 3527   op_cost(0);
 3528 
 3529   format %{ %}
 3530   interface(CONST_INTER);
 3531 %}
 3532 
 3533 // Long Immediate: low 32-bit mask
 3534 operand immL_32bits() %{
 3535   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3536   match(ConL);
 3537   op_cost(0);
 3538 
 3539   format %{ %}
 3540   interface(CONST_INTER);
 3541 %}
 3542 
 3543 // Long Immediate: low 32-bit mask
 3544 operand immL32() %{
 3545   predicate(n-&gt;get_long() == (int)(n-&gt;get_long()));
 3546   match(ConL);
 3547   op_cost(20);
 3548 
 3549   format %{ %}
 3550   interface(CONST_INTER);
 3551 %}
 3552 
 3553 //Double Immediate zero
 3554 operand immDPR0() %{
 3555   // Do additional (and counter-intuitive) test against NaN to work around VC++
 3556   // bug that generates code such that NaNs compare equal to 0.0
 3557   predicate( UseSSE&lt;=1 &amp;&amp; n-&gt;getd() == 0.0 &amp;&amp; !g_isnan(n-&gt;getd()) );
 3558   match(ConD);
 3559 
 3560   op_cost(5);
 3561   format %{ %}
 3562   interface(CONST_INTER);
 3563 %}
 3564 
 3565 // Double Immediate one
 3566 operand immDPR1() %{
 3567   predicate( UseSSE&lt;=1 &amp;&amp; n-&gt;getd() == 1.0 );
 3568   match(ConD);
 3569 
 3570   op_cost(5);
 3571   format %{ %}
 3572   interface(CONST_INTER);
 3573 %}
 3574 
 3575 // Double Immediate
 3576 operand immDPR() %{
 3577   predicate(UseSSE&lt;=1);
 3578   match(ConD);
 3579 
 3580   op_cost(5);
 3581   format %{ %}
 3582   interface(CONST_INTER);
 3583 %}
 3584 
 3585 operand immD() %{
 3586   predicate(UseSSE&gt;=2);
 3587   match(ConD);
 3588 
 3589   op_cost(5);
 3590   format %{ %}
 3591   interface(CONST_INTER);
 3592 %}
 3593 
 3594 // Double Immediate zero
 3595 operand immD0() %{
 3596   // Do additional (and counter-intuitive) test against NaN to work around VC++
 3597   // bug that generates code such that NaNs compare equal to 0.0 AND do not
 3598   // compare equal to -0.0.
 3599   predicate( UseSSE&gt;=2 &amp;&amp; jlong_cast(n-&gt;getd()) == 0 );
 3600   match(ConD);
 3601 
 3602   format %{ %}
 3603   interface(CONST_INTER);
 3604 %}
 3605 
 3606 // Float Immediate zero
 3607 operand immFPR0() %{
 3608   predicate(UseSSE == 0 &amp;&amp; n-&gt;getf() == 0.0F);
 3609   match(ConF);
 3610 
 3611   op_cost(5);
 3612   format %{ %}
 3613   interface(CONST_INTER);
 3614 %}
 3615 
 3616 // Float Immediate one
 3617 operand immFPR1() %{
 3618   predicate(UseSSE == 0 &amp;&amp; n-&gt;getf() == 1.0F);
 3619   match(ConF);
 3620 
 3621   op_cost(5);
 3622   format %{ %}
 3623   interface(CONST_INTER);
 3624 %}
 3625 
 3626 // Float Immediate
 3627 operand immFPR() %{
 3628   predicate( UseSSE == 0 );
 3629   match(ConF);
 3630 
 3631   op_cost(5);
 3632   format %{ %}
 3633   interface(CONST_INTER);
 3634 %}
 3635 
 3636 // Float Immediate
 3637 operand immF() %{
 3638   predicate(UseSSE &gt;= 1);
 3639   match(ConF);
 3640 
 3641   op_cost(5);
 3642   format %{ %}
 3643   interface(CONST_INTER);
 3644 %}
 3645 
 3646 // Float Immediate zero.  Zero and not -0.0
 3647 operand immF0() %{
 3648   predicate( UseSSE &gt;= 1 &amp;&amp; jint_cast(n-&gt;getf()) == 0 );
 3649   match(ConF);
 3650 
 3651   op_cost(5);
 3652   format %{ %}
 3653   interface(CONST_INTER);
 3654 %}
 3655 
 3656 // Immediates for special shifts (sign extend)
 3657 
 3658 // Constants for increment
 3659 operand immI_16() %{
 3660   predicate( n-&gt;get_int() == 16 );
 3661   match(ConI);
 3662 
 3663   format %{ %}
 3664   interface(CONST_INTER);
 3665 %}
 3666 
 3667 operand immI_24() %{
 3668   predicate( n-&gt;get_int() == 24 );
 3669   match(ConI);
 3670 
 3671   format %{ %}
 3672   interface(CONST_INTER);
 3673 %}
 3674 
 3675 // Constant for byte-wide masking
 3676 operand immI_255() %{
 3677   predicate( n-&gt;get_int() == 255 );
 3678   match(ConI);
 3679 
 3680   format %{ %}
 3681   interface(CONST_INTER);
 3682 %}
 3683 
 3684 // Constant for short-wide masking
 3685 operand immI_65535() %{
 3686   predicate(n-&gt;get_int() == 65535);
 3687   match(ConI);
 3688 
 3689   format %{ %}
 3690   interface(CONST_INTER);
 3691 %}
 3692 
 3693 // Register Operands
 3694 // Integer Register
 3695 operand rRegI() %{
 3696   constraint(ALLOC_IN_RC(int_reg));
 3697   match(RegI);
 3698   match(xRegI);
 3699   match(eAXRegI);
 3700   match(eBXRegI);
 3701   match(eCXRegI);
 3702   match(eDXRegI);
 3703   match(eDIRegI);
 3704   match(eSIRegI);
 3705 
 3706   format %{ %}
 3707   interface(REG_INTER);
 3708 %}
 3709 
 3710 // Subset of Integer Register
 3711 operand xRegI(rRegI reg) %{
 3712   constraint(ALLOC_IN_RC(int_x_reg));
 3713   match(reg);
 3714   match(eAXRegI);
 3715   match(eBXRegI);
 3716   match(eCXRegI);
 3717   match(eDXRegI);
 3718 
 3719   format %{ %}
 3720   interface(REG_INTER);
 3721 %}
 3722 
 3723 // Special Registers
 3724 operand eAXRegI(xRegI reg) %{
 3725   constraint(ALLOC_IN_RC(eax_reg));
 3726   match(reg);
 3727   match(rRegI);
 3728 
 3729   format %{ &quot;EAX&quot; %}
 3730   interface(REG_INTER);
 3731 %}
 3732 
 3733 // Special Registers
 3734 operand eBXRegI(xRegI reg) %{
 3735   constraint(ALLOC_IN_RC(ebx_reg));
 3736   match(reg);
 3737   match(rRegI);
 3738 
 3739   format %{ &quot;EBX&quot; %}
 3740   interface(REG_INTER);
 3741 %}
 3742 
 3743 operand eCXRegI(xRegI reg) %{
 3744   constraint(ALLOC_IN_RC(ecx_reg));
 3745   match(reg);
 3746   match(rRegI);
 3747 
 3748   format %{ &quot;ECX&quot; %}
 3749   interface(REG_INTER);
 3750 %}
 3751 
 3752 operand eDXRegI(xRegI reg) %{
 3753   constraint(ALLOC_IN_RC(edx_reg));
 3754   match(reg);
 3755   match(rRegI);
 3756 
 3757   format %{ &quot;EDX&quot; %}
 3758   interface(REG_INTER);
 3759 %}
 3760 
 3761 operand eDIRegI(xRegI reg) %{
 3762   constraint(ALLOC_IN_RC(edi_reg));
 3763   match(reg);
 3764   match(rRegI);
 3765 
 3766   format %{ &quot;EDI&quot; %}
 3767   interface(REG_INTER);
 3768 %}
 3769 
 3770 operand naxRegI() %{
 3771   constraint(ALLOC_IN_RC(nax_reg));
 3772   match(RegI);
 3773   match(eCXRegI);
 3774   match(eDXRegI);
 3775   match(eSIRegI);
 3776   match(eDIRegI);
 3777 
 3778   format %{ %}
 3779   interface(REG_INTER);
 3780 %}
 3781 
 3782 operand nadxRegI() %{
 3783   constraint(ALLOC_IN_RC(nadx_reg));
 3784   match(RegI);
 3785   match(eBXRegI);
 3786   match(eCXRegI);
 3787   match(eSIRegI);
 3788   match(eDIRegI);
 3789 
 3790   format %{ %}
 3791   interface(REG_INTER);
 3792 %}
 3793 
 3794 operand ncxRegI() %{
 3795   constraint(ALLOC_IN_RC(ncx_reg));
 3796   match(RegI);
 3797   match(eAXRegI);
 3798   match(eDXRegI);
 3799   match(eSIRegI);
 3800   match(eDIRegI);
 3801 
 3802   format %{ %}
 3803   interface(REG_INTER);
 3804 %}
 3805 
 3806 // // This operand was used by cmpFastUnlock, but conflicted with &#39;object&#39; reg
 3807 // //
 3808 operand eSIRegI(xRegI reg) %{
 3809    constraint(ALLOC_IN_RC(esi_reg));
 3810    match(reg);
 3811    match(rRegI);
 3812 
 3813    format %{ &quot;ESI&quot; %}
 3814    interface(REG_INTER);
 3815 %}
 3816 
 3817 // Pointer Register
 3818 operand anyRegP() %{
 3819   constraint(ALLOC_IN_RC(any_reg));
 3820   match(RegP);
 3821   match(eAXRegP);
 3822   match(eBXRegP);
 3823   match(eCXRegP);
 3824   match(eDIRegP);
 3825   match(eRegP);
 3826 
 3827   format %{ %}
 3828   interface(REG_INTER);
 3829 %}
 3830 
 3831 operand eRegP() %{
 3832   constraint(ALLOC_IN_RC(int_reg));
 3833   match(RegP);
 3834   match(eAXRegP);
 3835   match(eBXRegP);
 3836   match(eCXRegP);
 3837   match(eDIRegP);
 3838 
 3839   format %{ %}
 3840   interface(REG_INTER);
 3841 %}
 3842 
 3843 // On windows95, EBP is not safe to use for implicit null tests.
 3844 operand eRegP_no_EBP() %{
 3845   constraint(ALLOC_IN_RC(int_reg_no_ebp));
 3846   match(RegP);
 3847   match(eAXRegP);
 3848   match(eBXRegP);
 3849   match(eCXRegP);
 3850   match(eDIRegP);
 3851 
 3852   op_cost(100);
 3853   format %{ %}
 3854   interface(REG_INTER);
 3855 %}
 3856 
 3857 operand naxRegP() %{
 3858   constraint(ALLOC_IN_RC(nax_reg));
 3859   match(RegP);
 3860   match(eBXRegP);
 3861   match(eDXRegP);
 3862   match(eCXRegP);
 3863   match(eSIRegP);
 3864   match(eDIRegP);
 3865 
 3866   format %{ %}
 3867   interface(REG_INTER);
 3868 %}
 3869 
 3870 operand nabxRegP() %{
 3871   constraint(ALLOC_IN_RC(nabx_reg));
 3872   match(RegP);
 3873   match(eCXRegP);
 3874   match(eDXRegP);
 3875   match(eSIRegP);
 3876   match(eDIRegP);
 3877 
 3878   format %{ %}
 3879   interface(REG_INTER);
 3880 %}
 3881 
 3882 operand pRegP() %{
 3883   constraint(ALLOC_IN_RC(p_reg));
 3884   match(RegP);
 3885   match(eBXRegP);
 3886   match(eDXRegP);
 3887   match(eSIRegP);
 3888   match(eDIRegP);
 3889 
 3890   format %{ %}
 3891   interface(REG_INTER);
 3892 %}
 3893 
 3894 // Special Registers
 3895 // Return a pointer value
 3896 operand eAXRegP(eRegP reg) %{
 3897   constraint(ALLOC_IN_RC(eax_reg));
 3898   match(reg);
 3899   format %{ &quot;EAX&quot; %}
 3900   interface(REG_INTER);
 3901 %}
 3902 
 3903 // Used in AtomicAdd
 3904 operand eBXRegP(eRegP reg) %{
 3905   constraint(ALLOC_IN_RC(ebx_reg));
 3906   match(reg);
 3907   format %{ &quot;EBX&quot; %}
 3908   interface(REG_INTER);
 3909 %}
 3910 
 3911 // Tail-call (interprocedural jump) to interpreter
 3912 operand eCXRegP(eRegP reg) %{
 3913   constraint(ALLOC_IN_RC(ecx_reg));
 3914   match(reg);
 3915   format %{ &quot;ECX&quot; %}
 3916   interface(REG_INTER);
 3917 %}
 3918 
 3919 operand eDXRegP(eRegP reg) %{
 3920   constraint(ALLOC_IN_RC(edx_reg));
 3921   match(reg);
 3922   format %{ &quot;EDX&quot; %}
 3923   interface(REG_INTER);
 3924 %}
 3925 
 3926 operand eSIRegP(eRegP reg) %{
 3927   constraint(ALLOC_IN_RC(esi_reg));
 3928   match(reg);
 3929   format %{ &quot;ESI&quot; %}
 3930   interface(REG_INTER);
 3931 %}
 3932 
 3933 // Used in rep stosw
 3934 operand eDIRegP(eRegP reg) %{
 3935   constraint(ALLOC_IN_RC(edi_reg));
 3936   match(reg);
 3937   format %{ &quot;EDI&quot; %}
 3938   interface(REG_INTER);
 3939 %}
 3940 
 3941 operand eRegL() %{
 3942   constraint(ALLOC_IN_RC(long_reg));
 3943   match(RegL);
 3944   match(eADXRegL);
 3945 
 3946   format %{ %}
 3947   interface(REG_INTER);
 3948 %}
 3949 
 3950 operand eADXRegL( eRegL reg ) %{
 3951   constraint(ALLOC_IN_RC(eadx_reg));
 3952   match(reg);
 3953 
 3954   format %{ &quot;EDX:EAX&quot; %}
 3955   interface(REG_INTER);
 3956 %}
 3957 
 3958 operand eBCXRegL( eRegL reg ) %{
 3959   constraint(ALLOC_IN_RC(ebcx_reg));
 3960   match(reg);
 3961 
 3962   format %{ &quot;EBX:ECX&quot; %}
 3963   interface(REG_INTER);
 3964 %}
 3965 
 3966 // Special case for integer high multiply
 3967 operand eADXRegL_low_only() %{
 3968   constraint(ALLOC_IN_RC(eadx_reg));
 3969   match(RegL);
 3970 
 3971   format %{ &quot;EAX&quot; %}
 3972   interface(REG_INTER);
 3973 %}
 3974 
 3975 // Flags register, used as output of compare instructions
 3976 operand eFlagsReg() %{
 3977   constraint(ALLOC_IN_RC(int_flags));
 3978   match(RegFlags);
 3979 
 3980   format %{ &quot;EFLAGS&quot; %}
 3981   interface(REG_INTER);
 3982 %}
 3983 
 3984 // Flags register, used as output of FLOATING POINT compare instructions
 3985 operand eFlagsRegU() %{
 3986   constraint(ALLOC_IN_RC(int_flags));
 3987   match(RegFlags);
 3988 
 3989   format %{ &quot;EFLAGS_U&quot; %}
 3990   interface(REG_INTER);
 3991 %}
 3992 
 3993 operand eFlagsRegUCF() %{
 3994   constraint(ALLOC_IN_RC(int_flags));
 3995   match(RegFlags);
 3996   predicate(false);
 3997 
 3998   format %{ &quot;EFLAGS_U_CF&quot; %}
 3999   interface(REG_INTER);
 4000 %}
 4001 
 4002 // Condition Code Register used by long compare
 4003 operand flagsReg_long_LTGE() %{
 4004   constraint(ALLOC_IN_RC(int_flags));
 4005   match(RegFlags);
 4006   format %{ &quot;FLAGS_LTGE&quot; %}
 4007   interface(REG_INTER);
 4008 %}
 4009 operand flagsReg_long_EQNE() %{
 4010   constraint(ALLOC_IN_RC(int_flags));
 4011   match(RegFlags);
 4012   format %{ &quot;FLAGS_EQNE&quot; %}
 4013   interface(REG_INTER);
 4014 %}
 4015 operand flagsReg_long_LEGT() %{
 4016   constraint(ALLOC_IN_RC(int_flags));
 4017   match(RegFlags);
 4018   format %{ &quot;FLAGS_LEGT&quot; %}
 4019   interface(REG_INTER);
 4020 %}
 4021 
 4022 // Condition Code Register used by unsigned long compare
 4023 operand flagsReg_ulong_LTGE() %{
 4024   constraint(ALLOC_IN_RC(int_flags));
 4025   match(RegFlags);
 4026   format %{ &quot;FLAGS_U_LTGE&quot; %}
 4027   interface(REG_INTER);
 4028 %}
 4029 operand flagsReg_ulong_EQNE() %{
 4030   constraint(ALLOC_IN_RC(int_flags));
 4031   match(RegFlags);
 4032   format %{ &quot;FLAGS_U_EQNE&quot; %}
 4033   interface(REG_INTER);
 4034 %}
 4035 operand flagsReg_ulong_LEGT() %{
 4036   constraint(ALLOC_IN_RC(int_flags));
 4037   match(RegFlags);
 4038   format %{ &quot;FLAGS_U_LEGT&quot; %}
 4039   interface(REG_INTER);
 4040 %}
 4041 
 4042 // Float register operands
 4043 operand regDPR() %{
 4044   predicate( UseSSE &lt; 2 );
 4045   constraint(ALLOC_IN_RC(fp_dbl_reg));
 4046   match(RegD);
 4047   match(regDPR1);
 4048   match(regDPR2);
 4049   format %{ %}
 4050   interface(REG_INTER);
 4051 %}
 4052 
 4053 operand regDPR1(regDPR reg) %{
 4054   predicate( UseSSE &lt; 2 );
 4055   constraint(ALLOC_IN_RC(fp_dbl_reg0));
 4056   match(reg);
 4057   format %{ &quot;FPR1&quot; %}
 4058   interface(REG_INTER);
 4059 %}
 4060 
 4061 operand regDPR2(regDPR reg) %{
 4062   predicate( UseSSE &lt; 2 );
 4063   constraint(ALLOC_IN_RC(fp_dbl_reg1));
 4064   match(reg);
 4065   format %{ &quot;FPR2&quot; %}
 4066   interface(REG_INTER);
 4067 %}
 4068 
 4069 operand regnotDPR1(regDPR reg) %{
 4070   predicate( UseSSE &lt; 2 );
 4071   constraint(ALLOC_IN_RC(fp_dbl_notreg0));
 4072   match(reg);
 4073   format %{ %}
 4074   interface(REG_INTER);
 4075 %}
 4076 
 4077 // Float register operands
 4078 operand regFPR() %{
 4079   predicate( UseSSE &lt; 2 );
 4080   constraint(ALLOC_IN_RC(fp_flt_reg));
 4081   match(RegF);
 4082   match(regFPR1);
 4083   format %{ %}
 4084   interface(REG_INTER);
 4085 %}
 4086 
 4087 // Float register operands
 4088 operand regFPR1(regFPR reg) %{
 4089   predicate( UseSSE &lt; 2 );
 4090   constraint(ALLOC_IN_RC(fp_flt_reg0));
 4091   match(reg);
 4092   format %{ &quot;FPR1&quot; %}
 4093   interface(REG_INTER);
 4094 %}
 4095 
 4096 // XMM Float register operands
 4097 operand regF() %{
 4098   predicate( UseSSE&gt;=1 );
 4099   constraint(ALLOC_IN_RC(float_reg_legacy));
 4100   match(RegF);
 4101   format %{ %}
 4102   interface(REG_INTER);
 4103 %}
 4104 
 4105 // Float register operands
 4106 operand vlRegF() %{
 4107    constraint(ALLOC_IN_RC(float_reg_vl));
 4108    match(RegF);
 4109 
 4110    format %{ %}
 4111    interface(REG_INTER);
 4112 %}
 4113 
 4114 // XMM Double register operands
 4115 operand regD() %{
 4116   predicate( UseSSE&gt;=2 );
 4117   constraint(ALLOC_IN_RC(double_reg_legacy));
 4118   match(RegD);
 4119   format %{ %}
 4120   interface(REG_INTER);
 4121 %}
 4122 
 4123 // Double register operands
 4124 operand vlRegD() %{
 4125    constraint(ALLOC_IN_RC(double_reg_vl));
 4126    match(RegD);
 4127 
 4128    format %{ %}
 4129    interface(REG_INTER);
 4130 %}
 4131 
 4132 //----------Memory Operands----------------------------------------------------
 4133 // Direct Memory Operand
 4134 operand direct(immP addr) %{
 4135   match(addr);
 4136 
 4137   format %{ &quot;[$addr]&quot; %}
 4138   interface(MEMORY_INTER) %{
 4139     base(0xFFFFFFFF);
 4140     index(0x4);
 4141     scale(0x0);
 4142     disp($addr);
 4143   %}
 4144 %}
 4145 
 4146 // Indirect Memory Operand
 4147 operand indirect(eRegP reg) %{
 4148   constraint(ALLOC_IN_RC(int_reg));
 4149   match(reg);
 4150 
 4151   format %{ &quot;[$reg]&quot; %}
 4152   interface(MEMORY_INTER) %{
 4153     base($reg);
 4154     index(0x4);
 4155     scale(0x0);
 4156     disp(0x0);
 4157   %}
 4158 %}
 4159 
 4160 // Indirect Memory Plus Short Offset Operand
 4161 operand indOffset8(eRegP reg, immI8 off) %{
 4162   match(AddP reg off);
 4163 
 4164   format %{ &quot;[$reg + $off]&quot; %}
 4165   interface(MEMORY_INTER) %{
 4166     base($reg);
 4167     index(0x4);
 4168     scale(0x0);
 4169     disp($off);
 4170   %}
 4171 %}
 4172 
 4173 // Indirect Memory Plus Long Offset Operand
 4174 operand indOffset32(eRegP reg, immI off) %{
 4175   match(AddP reg off);
 4176 
 4177   format %{ &quot;[$reg + $off]&quot; %}
 4178   interface(MEMORY_INTER) %{
 4179     base($reg);
 4180     index(0x4);
 4181     scale(0x0);
 4182     disp($off);
 4183   %}
 4184 %}
 4185 
 4186 // Indirect Memory Plus Long Offset Operand
 4187 operand indOffset32X(rRegI reg, immP off) %{
 4188   match(AddP off reg);
 4189 
 4190   format %{ &quot;[$reg + $off]&quot; %}
 4191   interface(MEMORY_INTER) %{
 4192     base($reg);
 4193     index(0x4);
 4194     scale(0x0);
 4195     disp($off);
 4196   %}
 4197 %}
 4198 
 4199 // Indirect Memory Plus Index Register Plus Offset Operand
 4200 operand indIndexOffset(eRegP reg, rRegI ireg, immI off) %{
 4201   match(AddP (AddP reg ireg) off);
 4202 
 4203   op_cost(10);
 4204   format %{&quot;[$reg + $off + $ireg]&quot; %}
 4205   interface(MEMORY_INTER) %{
 4206     base($reg);
 4207     index($ireg);
 4208     scale(0x0);
 4209     disp($off);
 4210   %}
 4211 %}
 4212 
 4213 // Indirect Memory Plus Index Register Plus Offset Operand
 4214 operand indIndex(eRegP reg, rRegI ireg) %{
 4215   match(AddP reg ireg);
 4216 
 4217   op_cost(10);
 4218   format %{&quot;[$reg + $ireg]&quot; %}
 4219   interface(MEMORY_INTER) %{
 4220     base($reg);
 4221     index($ireg);
 4222     scale(0x0);
 4223     disp(0x0);
 4224   %}
 4225 %}
 4226 
 4227 // // -------------------------------------------------------------------------
 4228 // // 486 architecture doesn&#39;t support &quot;scale * index + offset&quot; with out a base
 4229 // // -------------------------------------------------------------------------
 4230 // // Scaled Memory Operands
 4231 // // Indirect Memory Times Scale Plus Offset Operand
 4232 // operand indScaleOffset(immP off, rRegI ireg, immI2 scale) %{
 4233 //   match(AddP off (LShiftI ireg scale));
 4234 //
 4235 //   op_cost(10);
 4236 //   format %{&quot;[$off + $ireg &lt;&lt; $scale]&quot; %}
 4237 //   interface(MEMORY_INTER) %{
 4238 //     base(0x4);
 4239 //     index($ireg);
 4240 //     scale($scale);
 4241 //     disp($off);
 4242 //   %}
 4243 // %}
 4244 
 4245 // Indirect Memory Times Scale Plus Index Register
 4246 operand indIndexScale(eRegP reg, rRegI ireg, immI2 scale) %{
 4247   match(AddP reg (LShiftI ireg scale));
 4248 
 4249   op_cost(10);
 4250   format %{&quot;[$reg + $ireg &lt;&lt; $scale]&quot; %}
 4251   interface(MEMORY_INTER) %{
 4252     base($reg);
 4253     index($ireg);
 4254     scale($scale);
 4255     disp(0x0);
 4256   %}
 4257 %}
 4258 
 4259 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4260 operand indIndexScaleOffset(eRegP reg, immI off, rRegI ireg, immI2 scale) %{
 4261   match(AddP (AddP reg (LShiftI ireg scale)) off);
 4262 
 4263   op_cost(10);
 4264   format %{&quot;[$reg + $off + $ireg &lt;&lt; $scale]&quot; %}
 4265   interface(MEMORY_INTER) %{
 4266     base($reg);
 4267     index($ireg);
 4268     scale($scale);
 4269     disp($off);
 4270   %}
 4271 %}
 4272 
 4273 //----------Load Long Memory Operands------------------------------------------
 4274 // The load-long idiom will use it&#39;s address expression again after loading
 4275 // the first word of the long.  If the load-long destination overlaps with
 4276 // registers used in the addressing expression, the 2nd half will be loaded
 4277 // from a clobbered address.  Fix this by requiring that load-long use
 4278 // address registers that do not overlap with the load-long target.
 4279 
 4280 // load-long support
 4281 operand load_long_RegP() %{
 4282   constraint(ALLOC_IN_RC(esi_reg));
 4283   match(RegP);
 4284   match(eSIRegP);
 4285   op_cost(100);
 4286   format %{  %}
 4287   interface(REG_INTER);
 4288 %}
 4289 
 4290 // Indirect Memory Operand Long
 4291 operand load_long_indirect(load_long_RegP reg) %{
 4292   constraint(ALLOC_IN_RC(esi_reg));
 4293   match(reg);
 4294 
 4295   format %{ &quot;[$reg]&quot; %}
 4296   interface(MEMORY_INTER) %{
 4297     base($reg);
 4298     index(0x4);
 4299     scale(0x0);
 4300     disp(0x0);
 4301   %}
 4302 %}
 4303 
 4304 // Indirect Memory Plus Long Offset Operand
 4305 operand load_long_indOffset32(load_long_RegP reg, immI off) %{
 4306   match(AddP reg off);
 4307 
 4308   format %{ &quot;[$reg + $off]&quot; %}
 4309   interface(MEMORY_INTER) %{
 4310     base($reg);
 4311     index(0x4);
 4312     scale(0x0);
 4313     disp($off);
 4314   %}
 4315 %}
 4316 
 4317 opclass load_long_memory(load_long_indirect, load_long_indOffset32);
 4318 
 4319 
 4320 //----------Special Memory Operands--------------------------------------------
 4321 // Stack Slot Operand - This operand is used for loading and storing temporary
 4322 //                      values on the stack where a match requires a value to
 4323 //                      flow through memory.
 4324 operand stackSlotP(sRegP reg) %{
 4325   constraint(ALLOC_IN_RC(stack_slots));
 4326   // No match rule because this operand is only generated in matching
 4327   format %{ &quot;[$reg]&quot; %}
 4328   interface(MEMORY_INTER) %{
 4329     base(0x4);   // ESP
 4330     index(0x4);  // No Index
 4331     scale(0x0);  // No Scale
 4332     disp($reg);  // Stack Offset
 4333   %}
 4334 %}
 4335 
 4336 operand stackSlotI(sRegI reg) %{
 4337   constraint(ALLOC_IN_RC(stack_slots));
 4338   // No match rule because this operand is only generated in matching
 4339   format %{ &quot;[$reg]&quot; %}
 4340   interface(MEMORY_INTER) %{
 4341     base(0x4);   // ESP
 4342     index(0x4);  // No Index
 4343     scale(0x0);  // No Scale
 4344     disp($reg);  // Stack Offset
 4345   %}
 4346 %}
 4347 
 4348 operand stackSlotF(sRegF reg) %{
 4349   constraint(ALLOC_IN_RC(stack_slots));
 4350   // No match rule because this operand is only generated in matching
 4351   format %{ &quot;[$reg]&quot; %}
 4352   interface(MEMORY_INTER) %{
 4353     base(0x4);   // ESP
 4354     index(0x4);  // No Index
 4355     scale(0x0);  // No Scale
 4356     disp($reg);  // Stack Offset
 4357   %}
 4358 %}
 4359 
 4360 operand stackSlotD(sRegD reg) %{
 4361   constraint(ALLOC_IN_RC(stack_slots));
 4362   // No match rule because this operand is only generated in matching
 4363   format %{ &quot;[$reg]&quot; %}
 4364   interface(MEMORY_INTER) %{
 4365     base(0x4);   // ESP
 4366     index(0x4);  // No Index
 4367     scale(0x0);  // No Scale
 4368     disp($reg);  // Stack Offset
 4369   %}
 4370 %}
 4371 
 4372 operand stackSlotL(sRegL reg) %{
 4373   constraint(ALLOC_IN_RC(stack_slots));
 4374   // No match rule because this operand is only generated in matching
 4375   format %{ &quot;[$reg]&quot; %}
 4376   interface(MEMORY_INTER) %{
 4377     base(0x4);   // ESP
 4378     index(0x4);  // No Index
 4379     scale(0x0);  // No Scale
 4380     disp($reg);  // Stack Offset
 4381   %}
 4382 %}
 4383 
 4384 //----------Memory Operands - Win95 Implicit Null Variants----------------
 4385 // Indirect Memory Operand
 4386 operand indirect_win95_safe(eRegP_no_EBP reg)
 4387 %{
 4388   constraint(ALLOC_IN_RC(int_reg));
 4389   match(reg);
 4390 
 4391   op_cost(100);
 4392   format %{ &quot;[$reg]&quot; %}
 4393   interface(MEMORY_INTER) %{
 4394     base($reg);
 4395     index(0x4);
 4396     scale(0x0);
 4397     disp(0x0);
 4398   %}
 4399 %}
 4400 
 4401 // Indirect Memory Plus Short Offset Operand
 4402 operand indOffset8_win95_safe(eRegP_no_EBP reg, immI8 off)
 4403 %{
 4404   match(AddP reg off);
 4405 
 4406   op_cost(100);
 4407   format %{ &quot;[$reg + $off]&quot; %}
 4408   interface(MEMORY_INTER) %{
 4409     base($reg);
 4410     index(0x4);
 4411     scale(0x0);
 4412     disp($off);
 4413   %}
 4414 %}
 4415 
 4416 // Indirect Memory Plus Long Offset Operand
 4417 operand indOffset32_win95_safe(eRegP_no_EBP reg, immI off)
 4418 %{
 4419   match(AddP reg off);
 4420 
 4421   op_cost(100);
 4422   format %{ &quot;[$reg + $off]&quot; %}
 4423   interface(MEMORY_INTER) %{
 4424     base($reg);
 4425     index(0x4);
 4426     scale(0x0);
 4427     disp($off);
 4428   %}
 4429 %}
 4430 
 4431 // Indirect Memory Plus Index Register Plus Offset Operand
 4432 operand indIndexOffset_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI off)
 4433 %{
 4434   match(AddP (AddP reg ireg) off);
 4435 
 4436   op_cost(100);
 4437   format %{&quot;[$reg + $off + $ireg]&quot; %}
 4438   interface(MEMORY_INTER) %{
 4439     base($reg);
 4440     index($ireg);
 4441     scale(0x0);
 4442     disp($off);
 4443   %}
 4444 %}
 4445 
 4446 // Indirect Memory Times Scale Plus Index Register
 4447 operand indIndexScale_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI2 scale)
 4448 %{
 4449   match(AddP reg (LShiftI ireg scale));
 4450 
 4451   op_cost(100);
 4452   format %{&quot;[$reg + $ireg &lt;&lt; $scale]&quot; %}
 4453   interface(MEMORY_INTER) %{
 4454     base($reg);
 4455     index($ireg);
 4456     scale($scale);
 4457     disp(0x0);
 4458   %}
 4459 %}
 4460 
 4461 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4462 operand indIndexScaleOffset_win95_safe(eRegP_no_EBP reg, immI off, rRegI ireg, immI2 scale)
 4463 %{
 4464   match(AddP (AddP reg (LShiftI ireg scale)) off);
 4465 
 4466   op_cost(100);
 4467   format %{&quot;[$reg + $off + $ireg &lt;&lt; $scale]&quot; %}
 4468   interface(MEMORY_INTER) %{
 4469     base($reg);
 4470     index($ireg);
 4471     scale($scale);
 4472     disp($off);
 4473   %}
 4474 %}
 4475 
 4476 //----------Conditional Branch Operands----------------------------------------
 4477 // Comparison Op  - This is the operation of the comparison, and is limited to
 4478 //                  the following set of codes:
 4479 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4480 //
 4481 // Other attributes of the comparison, such as unsignedness, are specified
 4482 // by the comparison instruction that sets a condition code flags register.
 4483 // That result is represented by a flags operand whose subtype is appropriate
 4484 // to the unsignedness (etc.) of the comparison.
 4485 //
 4486 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4487 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4488 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4489 
 4490 // Comparision Code
 4491 operand cmpOp() %{
 4492   match(Bool);
 4493 
 4494   format %{ &quot;&quot; %}
 4495   interface(COND_INTER) %{
 4496     equal(0x4, &quot;e&quot;);
 4497     not_equal(0x5, &quot;ne&quot;);
 4498     less(0xC, &quot;l&quot;);
 4499     greater_equal(0xD, &quot;ge&quot;);
 4500     less_equal(0xE, &quot;le&quot;);
 4501     greater(0xF, &quot;g&quot;);
 4502     overflow(0x0, &quot;o&quot;);
 4503     no_overflow(0x1, &quot;no&quot;);
 4504   %}
 4505 %}
 4506 
 4507 // Comparison Code, unsigned compare.  Used by FP also, with
 4508 // C2 (unordered) turned into GT or LT already.  The other bits
 4509 // C0 and C3 are turned into Carry &amp; Zero flags.
 4510 operand cmpOpU() %{
 4511   match(Bool);
 4512 
 4513   format %{ &quot;&quot; %}
 4514   interface(COND_INTER) %{
 4515     equal(0x4, &quot;e&quot;);
 4516     not_equal(0x5, &quot;ne&quot;);
 4517     less(0x2, &quot;b&quot;);
 4518     greater_equal(0x3, &quot;nb&quot;);
 4519     less_equal(0x6, &quot;be&quot;);
 4520     greater(0x7, &quot;nbe&quot;);
 4521     overflow(0x0, &quot;o&quot;);
 4522     no_overflow(0x1, &quot;no&quot;);
 4523   %}
 4524 %}
 4525 
 4526 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4527 operand cmpOpUCF() %{
 4528   match(Bool);
 4529   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4530             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4531             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4532             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4533   format %{ &quot;&quot; %}
 4534   interface(COND_INTER) %{
 4535     equal(0x4, &quot;e&quot;);
 4536     not_equal(0x5, &quot;ne&quot;);
 4537     less(0x2, &quot;b&quot;);
 4538     greater_equal(0x3, &quot;nb&quot;);
 4539     less_equal(0x6, &quot;be&quot;);
 4540     greater(0x7, &quot;nbe&quot;);
 4541     overflow(0x0, &quot;o&quot;);
 4542     no_overflow(0x1, &quot;no&quot;);
 4543   %}
 4544 %}
 4545 
 4546 
 4547 // Floating comparisons that can be fixed up with extra conditional jumps
 4548 operand cmpOpUCF2() %{
 4549   match(Bool);
 4550   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4551             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4552   format %{ &quot;&quot; %}
 4553   interface(COND_INTER) %{
 4554     equal(0x4, &quot;e&quot;);
 4555     not_equal(0x5, &quot;ne&quot;);
 4556     less(0x2, &quot;b&quot;);
 4557     greater_equal(0x3, &quot;nb&quot;);
 4558     less_equal(0x6, &quot;be&quot;);
 4559     greater(0x7, &quot;nbe&quot;);
 4560     overflow(0x0, &quot;o&quot;);
 4561     no_overflow(0x1, &quot;no&quot;);
 4562   %}
 4563 %}
 4564 
 4565 // Comparison Code for FP conditional move
 4566 operand cmpOp_fcmov() %{
 4567   match(Bool);
 4568 
 4569   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4570             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4571   format %{ &quot;&quot; %}
 4572   interface(COND_INTER) %{
 4573     equal        (0x0C8);
 4574     not_equal    (0x1C8);
 4575     less         (0x0C0);
 4576     greater_equal(0x1C0);
 4577     less_equal   (0x0D0);
 4578     greater      (0x1D0);
 4579     overflow(0x0, &quot;o&quot;); // not really supported by the instruction
 4580     no_overflow(0x1, &quot;no&quot;); // not really supported by the instruction
 4581   %}
 4582 %}
 4583 
 4584 // Comparison Code used in long compares
 4585 operand cmpOp_commute() %{
 4586   match(Bool);
 4587 
 4588   format %{ &quot;&quot; %}
 4589   interface(COND_INTER) %{
 4590     equal(0x4, &quot;e&quot;);
 4591     not_equal(0x5, &quot;ne&quot;);
 4592     less(0xF, &quot;g&quot;);
 4593     greater_equal(0xE, &quot;le&quot;);
 4594     less_equal(0xD, &quot;ge&quot;);
 4595     greater(0xC, &quot;l&quot;);
 4596     overflow(0x0, &quot;o&quot;);
 4597     no_overflow(0x1, &quot;no&quot;);
 4598   %}
 4599 %}
 4600 
 4601 // Comparison Code used in unsigned long compares
 4602 operand cmpOpU_commute() %{
 4603   match(Bool);
 4604 
 4605   format %{ &quot;&quot; %}
 4606   interface(COND_INTER) %{
 4607     equal(0x4, &quot;e&quot;);
 4608     not_equal(0x5, &quot;ne&quot;);
 4609     less(0x7, &quot;nbe&quot;);
 4610     greater_equal(0x6, &quot;be&quot;);
 4611     less_equal(0x3, &quot;nb&quot;);
 4612     greater(0x2, &quot;b&quot;);
 4613     overflow(0x0, &quot;o&quot;);
 4614     no_overflow(0x1, &quot;no&quot;);
 4615   %}
 4616 %}
 4617 
 4618 //----------OPERAND CLASSES----------------------------------------------------
 4619 // Operand Classes are groups of operands that are used as to simplify
 4620 // instruction definitions by not requiring the AD writer to specify separate
 4621 // instructions for every form of operand when the instruction accepts
 4622 // multiple operand types with the same basic encoding and format.  The classic
 4623 // case of this is memory operands.
 4624 
 4625 opclass memory(direct, indirect, indOffset8, indOffset32, indOffset32X, indIndexOffset,
 4626                indIndex, indIndexScale, indIndexScaleOffset);
 4627 
 4628 // Long memory operations are encoded in 2 instructions and a +4 offset.
 4629 // This means some kind of offset is always required and you cannot use
 4630 // an oop as the offset (done when working on static globals).
 4631 opclass long_memory(direct, indirect, indOffset8, indOffset32, indIndexOffset,
 4632                     indIndex, indIndexScale, indIndexScaleOffset);
 4633 
 4634 
 4635 //----------PIPELINE-----------------------------------------------------------
 4636 // Rules which define the behavior of the target architectures pipeline.
 4637 pipeline %{
 4638 
 4639 //----------ATTRIBUTES---------------------------------------------------------
 4640 attributes %{
 4641   variable_size_instructions;        // Fixed size instructions
 4642   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4643   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4644   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4645   instruction_fetch_units = 1;       // of 16 bytes
 4646 
 4647   // List of nop instructions
 4648   nops( MachNop );
 4649 %}
 4650 
 4651 //----------RESOURCES----------------------------------------------------------
 4652 // Resources are the functional units available to the machine
 4653 
 4654 // Generic P2/P3 pipeline
 4655 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4656 // 3 instructions decoded per cycle.
 4657 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4658 // 2 ALU op, only ALU0 handles mul/div instructions.
 4659 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4660            MS0, MS1, MEM = MS0 | MS1,
 4661            BR, FPU,
 4662            ALU0, ALU1, ALU = ALU0 | ALU1 );
 4663 
 4664 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4665 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4666 
 4667 // Generic P2/P3 pipeline
 4668 pipe_desc(S0, S1, S2, S3, S4, S5);
 4669 
 4670 //----------PIPELINE CLASSES---------------------------------------------------
 4671 // Pipeline Classes describe the stages in which input and output are
 4672 // referenced by the hardware pipeline.
 4673 
 4674 // Naming convention: ialu or fpu
 4675 // Then: _reg
 4676 // Then: _reg if there is a 2nd register
 4677 // Then: _long if it&#39;s a pair of instructions implementing a long
 4678 // Then: _fat if it requires the big decoder
 4679 //   Or: _mem if it requires the big decoder and a memory unit.
 4680 
 4681 // Integer ALU reg operation
 4682 pipe_class ialu_reg(rRegI dst) %{
 4683     single_instruction;
 4684     dst    : S4(write);
 4685     dst    : S3(read);
 4686     DECODE : S0;        // any decoder
 4687     ALU    : S3;        // any alu
 4688 %}
 4689 
 4690 // Long ALU reg operation
 4691 pipe_class ialu_reg_long(eRegL dst) %{
 4692     instruction_count(2);
 4693     dst    : S4(write);
 4694     dst    : S3(read);
 4695     DECODE : S0(2);     // any 2 decoders
 4696     ALU    : S3(2);     // both alus
 4697 %}
 4698 
 4699 // Integer ALU reg operation using big decoder
 4700 pipe_class ialu_reg_fat(rRegI dst) %{
 4701     single_instruction;
 4702     dst    : S4(write);
 4703     dst    : S3(read);
 4704     D0     : S0;        // big decoder only
 4705     ALU    : S3;        // any alu
 4706 %}
 4707 
 4708 // Long ALU reg operation using big decoder
 4709 pipe_class ialu_reg_long_fat(eRegL dst) %{
 4710     instruction_count(2);
 4711     dst    : S4(write);
 4712     dst    : S3(read);
 4713     D0     : S0(2);     // big decoder only; twice
 4714     ALU    : S3(2);     // any 2 alus
 4715 %}
 4716 
 4717 // Integer ALU reg-reg operation
 4718 pipe_class ialu_reg_reg(rRegI dst, rRegI src) %{
 4719     single_instruction;
 4720     dst    : S4(write);
 4721     src    : S3(read);
 4722     DECODE : S0;        // any decoder
 4723     ALU    : S3;        // any alu
 4724 %}
 4725 
 4726 // Long ALU reg-reg operation
 4727 pipe_class ialu_reg_reg_long(eRegL dst, eRegL src) %{
 4728     instruction_count(2);
 4729     dst    : S4(write);
 4730     src    : S3(read);
 4731     DECODE : S0(2);     // any 2 decoders
 4732     ALU    : S3(2);     // both alus
 4733 %}
 4734 
 4735 // Integer ALU reg-reg operation
 4736 pipe_class ialu_reg_reg_fat(rRegI dst, memory src) %{
 4737     single_instruction;
 4738     dst    : S4(write);
 4739     src    : S3(read);
 4740     D0     : S0;        // big decoder only
 4741     ALU    : S3;        // any alu
 4742 %}
 4743 
 4744 // Long ALU reg-reg operation
 4745 pipe_class ialu_reg_reg_long_fat(eRegL dst, eRegL src) %{
 4746     instruction_count(2);
 4747     dst    : S4(write);
 4748     src    : S3(read);
 4749     D0     : S0(2);     // big decoder only; twice
 4750     ALU    : S3(2);     // both alus
 4751 %}
 4752 
 4753 // Integer ALU reg-mem operation
 4754 pipe_class ialu_reg_mem(rRegI dst, memory mem) %{
 4755     single_instruction;
 4756     dst    : S5(write);
 4757     mem    : S3(read);
 4758     D0     : S0;        // big decoder only
 4759     ALU    : S4;        // any alu
 4760     MEM    : S3;        // any mem
 4761 %}
 4762 
 4763 // Long ALU reg-mem operation
 4764 pipe_class ialu_reg_long_mem(eRegL dst, load_long_memory mem) %{
 4765     instruction_count(2);
 4766     dst    : S5(write);
 4767     mem    : S3(read);
 4768     D0     : S0(2);     // big decoder only; twice
 4769     ALU    : S4(2);     // any 2 alus
 4770     MEM    : S3(2);     // both mems
 4771 %}
 4772 
 4773 // Integer mem operation (prefetch)
 4774 pipe_class ialu_mem(memory mem)
 4775 %{
 4776     single_instruction;
 4777     mem    : S3(read);
 4778     D0     : S0;        // big decoder only
 4779     MEM    : S3;        // any mem
 4780 %}
 4781 
 4782 // Integer Store to Memory
 4783 pipe_class ialu_mem_reg(memory mem, rRegI src) %{
 4784     single_instruction;
 4785     mem    : S3(read);
 4786     src    : S5(read);
 4787     D0     : S0;        // big decoder only
 4788     ALU    : S4;        // any alu
 4789     MEM    : S3;
 4790 %}
 4791 
 4792 // Long Store to Memory
 4793 pipe_class ialu_mem_long_reg(memory mem, eRegL src) %{
 4794     instruction_count(2);
 4795     mem    : S3(read);
 4796     src    : S5(read);
 4797     D0     : S0(2);     // big decoder only; twice
 4798     ALU    : S4(2);     // any 2 alus
 4799     MEM    : S3(2);     // Both mems
 4800 %}
 4801 
 4802 // Integer Store to Memory
 4803 pipe_class ialu_mem_imm(memory mem) %{
 4804     single_instruction;
 4805     mem    : S3(read);
 4806     D0     : S0;        // big decoder only
 4807     ALU    : S4;        // any alu
 4808     MEM    : S3;
 4809 %}
 4810 
 4811 // Integer ALU0 reg-reg operation
 4812 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src) %{
 4813     single_instruction;
 4814     dst    : S4(write);
 4815     src    : S3(read);
 4816     D0     : S0;        // Big decoder only
 4817     ALU0   : S3;        // only alu0
 4818 %}
 4819 
 4820 // Integer ALU0 reg-mem operation
 4821 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem) %{
 4822     single_instruction;
 4823     dst    : S5(write);
 4824     mem    : S3(read);
 4825     D0     : S0;        // big decoder only
 4826     ALU0   : S4;        // ALU0 only
 4827     MEM    : S3;        // any mem
 4828 %}
 4829 
 4830 // Integer ALU reg-reg operation
 4831 pipe_class ialu_cr_reg_reg(eFlagsReg cr, rRegI src1, rRegI src2) %{
 4832     single_instruction;
 4833     cr     : S4(write);
 4834     src1   : S3(read);
 4835     src2   : S3(read);
 4836     DECODE : S0;        // any decoder
 4837     ALU    : S3;        // any alu
 4838 %}
 4839 
 4840 // Integer ALU reg-imm operation
 4841 pipe_class ialu_cr_reg_imm(eFlagsReg cr, rRegI src1) %{
 4842     single_instruction;
 4843     cr     : S4(write);
 4844     src1   : S3(read);
 4845     DECODE : S0;        // any decoder
 4846     ALU    : S3;        // any alu
 4847 %}
 4848 
 4849 // Integer ALU reg-mem operation
 4850 pipe_class ialu_cr_reg_mem(eFlagsReg cr, rRegI src1, memory src2) %{
 4851     single_instruction;
 4852     cr     : S4(write);
 4853     src1   : S3(read);
 4854     src2   : S3(read);
 4855     D0     : S0;        // big decoder only
 4856     ALU    : S4;        // any alu
 4857     MEM    : S3;
 4858 %}
 4859 
 4860 // Conditional move reg-reg
 4861 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y ) %{
 4862     instruction_count(4);
 4863     y      : S4(read);
 4864     q      : S3(read);
 4865     p      : S3(read);
 4866     DECODE : S0(4);     // any decoder
 4867 %}
 4868 
 4869 // Conditional move reg-reg
 4870 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, eFlagsReg cr ) %{
 4871     single_instruction;
 4872     dst    : S4(write);
 4873     src    : S3(read);
 4874     cr     : S3(read);
 4875     DECODE : S0;        // any decoder
 4876 %}
 4877 
 4878 // Conditional move reg-mem
 4879 pipe_class pipe_cmov_mem( eFlagsReg cr, rRegI dst, memory src) %{
 4880     single_instruction;
 4881     dst    : S4(write);
 4882     src    : S3(read);
 4883     cr     : S3(read);
 4884     DECODE : S0;        // any decoder
 4885     MEM    : S3;
 4886 %}
 4887 
 4888 // Conditional move reg-reg long
 4889 pipe_class pipe_cmov_reg_long( eFlagsReg cr, eRegL dst, eRegL src) %{
 4890     single_instruction;
 4891     dst    : S4(write);
 4892     src    : S3(read);
 4893     cr     : S3(read);
 4894     DECODE : S0(2);     // any 2 decoders
 4895 %}
 4896 
 4897 // Conditional move double reg-reg
 4898 pipe_class pipe_cmovDPR_reg( eFlagsReg cr, regDPR1 dst, regDPR src) %{
 4899     single_instruction;
 4900     dst    : S4(write);
 4901     src    : S3(read);
 4902     cr     : S3(read);
 4903     DECODE : S0;        // any decoder
 4904 %}
 4905 
 4906 // Float reg-reg operation
 4907 pipe_class fpu_reg(regDPR dst) %{
 4908     instruction_count(2);
 4909     dst    : S3(read);
 4910     DECODE : S0(2);     // any 2 decoders
 4911     FPU    : S3;
 4912 %}
 4913 
 4914 // Float reg-reg operation
 4915 pipe_class fpu_reg_reg(regDPR dst, regDPR src) %{
 4916     instruction_count(2);
 4917     dst    : S4(write);
 4918     src    : S3(read);
 4919     DECODE : S0(2);     // any 2 decoders
 4920     FPU    : S3;
 4921 %}
 4922 
 4923 // Float reg-reg operation
 4924 pipe_class fpu_reg_reg_reg(regDPR dst, regDPR src1, regDPR src2) %{
 4925     instruction_count(3);
 4926     dst    : S4(write);
 4927     src1   : S3(read);
 4928     src2   : S3(read);
 4929     DECODE : S0(3);     // any 3 decoders
 4930     FPU    : S3(2);
 4931 %}
 4932 
 4933 // Float reg-reg operation
 4934 pipe_class fpu_reg_reg_reg_reg(regDPR dst, regDPR src1, regDPR src2, regDPR src3) %{
 4935     instruction_count(4);
 4936     dst    : S4(write);
 4937     src1   : S3(read);
 4938     src2   : S3(read);
 4939     src3   : S3(read);
 4940     DECODE : S0(4);     // any 3 decoders
 4941     FPU    : S3(2);
 4942 %}
 4943 
 4944 // Float reg-reg operation
 4945 pipe_class fpu_reg_mem_reg_reg(regDPR dst, memory src1, regDPR src2, regDPR src3) %{
 4946     instruction_count(4);
 4947     dst    : S4(write);
 4948     src1   : S3(read);
 4949     src2   : S3(read);
 4950     src3   : S3(read);
 4951     DECODE : S1(3);     // any 3 decoders
 4952     D0     : S0;        // Big decoder only
 4953     FPU    : S3(2);
 4954     MEM    : S3;
 4955 %}
 4956 
 4957 // Float reg-mem operation
 4958 pipe_class fpu_reg_mem(regDPR dst, memory mem) %{
 4959     instruction_count(2);
 4960     dst    : S5(write);
 4961     mem    : S3(read);
 4962     D0     : S0;        // big decoder only
 4963     DECODE : S1;        // any decoder for FPU POP
 4964     FPU    : S4;
 4965     MEM    : S3;        // any mem
 4966 %}
 4967 
 4968 // Float reg-mem operation
 4969 pipe_class fpu_reg_reg_mem(regDPR dst, regDPR src1, memory mem) %{
 4970     instruction_count(3);
 4971     dst    : S5(write);
 4972     src1   : S3(read);
 4973     mem    : S3(read);
 4974     D0     : S0;        // big decoder only
 4975     DECODE : S1(2);     // any decoder for FPU POP
 4976     FPU    : S4;
 4977     MEM    : S3;        // any mem
 4978 %}
 4979 
 4980 // Float mem-reg operation
 4981 pipe_class fpu_mem_reg(memory mem, regDPR src) %{
 4982     instruction_count(2);
 4983     src    : S5(read);
 4984     mem    : S3(read);
 4985     DECODE : S0;        // any decoder for FPU PUSH
 4986     D0     : S1;        // big decoder only
 4987     FPU    : S4;
 4988     MEM    : S3;        // any mem
 4989 %}
 4990 
 4991 pipe_class fpu_mem_reg_reg(memory mem, regDPR src1, regDPR src2) %{
 4992     instruction_count(3);
 4993     src1   : S3(read);
 4994     src2   : S3(read);
 4995     mem    : S3(read);
 4996     DECODE : S0(2);     // any decoder for FPU PUSH
 4997     D0     : S1;        // big decoder only
 4998     FPU    : S4;
 4999     MEM    : S3;        // any mem
 5000 %}
 5001 
 5002 pipe_class fpu_mem_reg_mem(memory mem, regDPR src1, memory src2) %{
 5003     instruction_count(3);
 5004     src1   : S3(read);
 5005     src2   : S3(read);
 5006     mem    : S4(read);
 5007     DECODE : S0;        // any decoder for FPU PUSH
 5008     D0     : S0(2);     // big decoder only
 5009     FPU    : S4;
 5010     MEM    : S3(2);     // any mem
 5011 %}
 5012 
 5013 pipe_class fpu_mem_mem(memory dst, memory src1) %{
 5014     instruction_count(2);
 5015     src1   : S3(read);
 5016     dst    : S4(read);
 5017     D0     : S0(2);     // big decoder only
 5018     MEM    : S3(2);     // any mem
 5019 %}
 5020 
 5021 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2) %{
 5022     instruction_count(3);
 5023     src1   : S3(read);
 5024     src2   : S3(read);
 5025     dst    : S4(read);
 5026     D0     : S0(3);     // big decoder only
 5027     FPU    : S4;
 5028     MEM    : S3(3);     // any mem
 5029 %}
 5030 
 5031 pipe_class fpu_mem_reg_con(memory mem, regDPR src1) %{
 5032     instruction_count(3);
 5033     src1   : S4(read);
 5034     mem    : S4(read);
 5035     DECODE : S0;        // any decoder for FPU PUSH
 5036     D0     : S0(2);     // big decoder only
 5037     FPU    : S4;
 5038     MEM    : S3(2);     // any mem
 5039 %}
 5040 
 5041 // Float load constant
 5042 pipe_class fpu_reg_con(regDPR dst) %{
 5043     instruction_count(2);
 5044     dst    : S5(write);
 5045     D0     : S0;        // big decoder only for the load
 5046     DECODE : S1;        // any decoder for FPU POP
 5047     FPU    : S4;
 5048     MEM    : S3;        // any mem
 5049 %}
 5050 
 5051 // Float load constant
 5052 pipe_class fpu_reg_reg_con(regDPR dst, regDPR src) %{
 5053     instruction_count(3);
 5054     dst    : S5(write);
 5055     src    : S3(read);
 5056     D0     : S0;        // big decoder only for the load
 5057     DECODE : S1(2);     // any decoder for FPU POP
 5058     FPU    : S4;
 5059     MEM    : S3;        // any mem
 5060 %}
 5061 
 5062 // UnConditional branch
 5063 pipe_class pipe_jmp( label labl ) %{
 5064     single_instruction;
 5065     BR   : S3;
 5066 %}
 5067 
 5068 // Conditional branch
 5069 pipe_class pipe_jcc( cmpOp cmp, eFlagsReg cr, label labl ) %{
 5070     single_instruction;
 5071     cr    : S1(read);
 5072     BR    : S3;
 5073 %}
 5074 
 5075 // Allocation idiom
 5076 pipe_class pipe_cmpxchg( eRegP dst, eRegP heap_ptr ) %{
 5077     instruction_count(1); force_serialization;
 5078     fixed_latency(6);
 5079     heap_ptr : S3(read);
 5080     DECODE   : S0(3);
 5081     D0       : S2;
 5082     MEM      : S3;
 5083     ALU      : S3(2);
 5084     dst      : S5(write);
 5085     BR       : S5;
 5086 %}
 5087 
 5088 // Generic big/slow expanded idiom
 5089 pipe_class pipe_slow(  ) %{
 5090     instruction_count(10); multiple_bundles; force_serialization;
 5091     fixed_latency(100);
 5092     D0  : S0(2);
 5093     MEM : S3(2);
 5094 %}
 5095 
 5096 // The real do-nothing guy
 5097 pipe_class empty( ) %{
 5098     instruction_count(0);
 5099 %}
 5100 
 5101 // Define the class for the Nop node
 5102 define %{
 5103    MachNop = empty;
 5104 %}
 5105 
 5106 %}
 5107 
 5108 //----------INSTRUCTIONS-------------------------------------------------------
 5109 //
 5110 // match      -- States which machine-independent subtree may be replaced
 5111 //               by this instruction.
 5112 // ins_cost   -- The estimated cost of this instruction is used by instruction
 5113 //               selection to identify a minimum cost tree of machine
 5114 //               instructions that matches a tree of machine-independent
 5115 //               instructions.
 5116 // format     -- A string providing the disassembly for this instruction.
 5117 //               The value of an instruction&#39;s operand may be inserted
 5118 //               by referring to it with a &#39;$&#39; prefix.
 5119 // opcode     -- Three instruction opcodes may be provided.  These are referred
 5120 //               to within an encode class as $primary, $secondary, and $tertiary
 5121 //               respectively.  The primary opcode is commonly used to
 5122 //               indicate the type of machine instruction, while secondary
 5123 //               and tertiary are often used for prefix options or addressing
 5124 //               modes.
 5125 // ins_encode -- A list of encode classes with parameters. The encode class
 5126 //               name must have been defined in an &#39;enc_class&#39; specification
 5127 //               in the encode section of the architecture description.
 5128 
 5129 //----------BSWAP-Instruction--------------------------------------------------
 5130 instruct bytes_reverse_int(rRegI dst) %{
 5131   match(Set dst (ReverseBytesI dst));
 5132 
 5133   format %{ &quot;BSWAP  $dst&quot; %}
 5134   opcode(0x0F, 0xC8);
 5135   ins_encode( OpcP, OpcSReg(dst) );
 5136   ins_pipe( ialu_reg );
 5137 %}
 5138 
 5139 instruct bytes_reverse_long(eRegL dst) %{
 5140   match(Set dst (ReverseBytesL dst));
 5141 
 5142   format %{ &quot;BSWAP  $dst.lo\n\t&quot;
 5143             &quot;BSWAP  $dst.hi\n\t&quot;
 5144             &quot;XCHG   $dst.lo $dst.hi&quot; %}
 5145 
 5146   ins_cost(125);
 5147   ins_encode( bswap_long_bytes(dst) );
 5148   ins_pipe( ialu_reg_reg);
 5149 %}
 5150 
 5151 instruct bytes_reverse_unsigned_short(rRegI dst, eFlagsReg cr) %{
 5152   match(Set dst (ReverseBytesUS dst));
 5153   effect(KILL cr);
 5154 
 5155   format %{ &quot;BSWAP  $dst\n\t&quot;
 5156             &quot;SHR    $dst,16\n\t&quot; %}
 5157   ins_encode %{
 5158     __ bswapl($dst$$Register);
 5159     __ shrl($dst$$Register, 16);
 5160   %}
 5161   ins_pipe( ialu_reg );
 5162 %}
 5163 
 5164 instruct bytes_reverse_short(rRegI dst, eFlagsReg cr) %{
 5165   match(Set dst (ReverseBytesS dst));
 5166   effect(KILL cr);
 5167 
 5168   format %{ &quot;BSWAP  $dst\n\t&quot;
 5169             &quot;SAR    $dst,16\n\t&quot; %}
 5170   ins_encode %{
 5171     __ bswapl($dst$$Register);
 5172     __ sarl($dst$$Register, 16);
 5173   %}
 5174   ins_pipe( ialu_reg );
 5175 %}
 5176 
 5177 
 5178 //---------- Zeros Count Instructions ------------------------------------------
 5179 
 5180 instruct countLeadingZerosI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5181   predicate(UseCountLeadingZerosInstruction);
 5182   match(Set dst (CountLeadingZerosI src));
 5183   effect(KILL cr);
 5184 
 5185   format %{ &quot;LZCNT  $dst, $src\t# count leading zeros (int)&quot; %}
 5186   ins_encode %{
 5187     __ lzcntl($dst$$Register, $src$$Register);
 5188   %}
 5189   ins_pipe(ialu_reg);
 5190 %}
 5191 
 5192 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, eFlagsReg cr) %{
 5193   predicate(!UseCountLeadingZerosInstruction);
 5194   match(Set dst (CountLeadingZerosI src));
 5195   effect(KILL cr);
 5196 
 5197   format %{ &quot;BSR    $dst, $src\t# count leading zeros (int)\n\t&quot;
 5198             &quot;JNZ    skip\n\t&quot;
 5199             &quot;MOV    $dst, -1\n&quot;
 5200       &quot;skip:\n\t&quot;
 5201             &quot;NEG    $dst\n\t&quot;
 5202             &quot;ADD    $dst, 31&quot; %}
 5203   ins_encode %{
 5204     Register Rdst = $dst$$Register;
 5205     Register Rsrc = $src$$Register;
 5206     Label skip;
 5207     __ bsrl(Rdst, Rsrc);
 5208     __ jccb(Assembler::notZero, skip);
 5209     __ movl(Rdst, -1);
 5210     __ bind(skip);
 5211     __ negl(Rdst);
 5212     __ addl(Rdst, BitsPerInt - 1);
 5213   %}
 5214   ins_pipe(ialu_reg);
 5215 %}
 5216 
 5217 instruct countLeadingZerosL(rRegI dst, eRegL src, eFlagsReg cr) %{
 5218   predicate(UseCountLeadingZerosInstruction);
 5219   match(Set dst (CountLeadingZerosL src));
 5220   effect(TEMP dst, KILL cr);
 5221 
 5222   format %{ &quot;LZCNT  $dst, $src.hi\t# count leading zeros (long)\n\t&quot;
 5223             &quot;JNC    done\n\t&quot;
 5224             &quot;LZCNT  $dst, $src.lo\n\t&quot;
 5225             &quot;ADD    $dst, 32\n&quot;
 5226       &quot;done:&quot; %}
 5227   ins_encode %{
 5228     Register Rdst = $dst$$Register;
 5229     Register Rsrc = $src$$Register;
 5230     Label done;
 5231     __ lzcntl(Rdst, HIGH_FROM_LOW(Rsrc));
 5232     __ jccb(Assembler::carryClear, done);
 5233     __ lzcntl(Rdst, Rsrc);
 5234     __ addl(Rdst, BitsPerInt);
 5235     __ bind(done);
 5236   %}
 5237   ins_pipe(ialu_reg);
 5238 %}
 5239 
 5240 instruct countLeadingZerosL_bsr(rRegI dst, eRegL src, eFlagsReg cr) %{
 5241   predicate(!UseCountLeadingZerosInstruction);
 5242   match(Set dst (CountLeadingZerosL src));
 5243   effect(TEMP dst, KILL cr);
 5244 
 5245   format %{ &quot;BSR    $dst, $src.hi\t# count leading zeros (long)\n\t&quot;
 5246             &quot;JZ     msw_is_zero\n\t&quot;
 5247             &quot;ADD    $dst, 32\n\t&quot;
 5248             &quot;JMP    not_zero\n&quot;
 5249       &quot;msw_is_zero:\n\t&quot;
 5250             &quot;BSR    $dst, $src.lo\n\t&quot;
 5251             &quot;JNZ    not_zero\n\t&quot;
 5252             &quot;MOV    $dst, -1\n&quot;
 5253       &quot;not_zero:\n\t&quot;
 5254             &quot;NEG    $dst\n\t&quot;
 5255             &quot;ADD    $dst, 63\n&quot; %}
 5256  ins_encode %{
 5257     Register Rdst = $dst$$Register;
 5258     Register Rsrc = $src$$Register;
 5259     Label msw_is_zero;
 5260     Label not_zero;
 5261     __ bsrl(Rdst, HIGH_FROM_LOW(Rsrc));
 5262     __ jccb(Assembler::zero, msw_is_zero);
 5263     __ addl(Rdst, BitsPerInt);
 5264     __ jmpb(not_zero);
 5265     __ bind(msw_is_zero);
 5266     __ bsrl(Rdst, Rsrc);
 5267     __ jccb(Assembler::notZero, not_zero);
 5268     __ movl(Rdst, -1);
 5269     __ bind(not_zero);
 5270     __ negl(Rdst);
 5271     __ addl(Rdst, BitsPerLong - 1);
 5272   %}
 5273   ins_pipe(ialu_reg);
 5274 %}
 5275 
 5276 instruct countTrailingZerosI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5277   predicate(UseCountTrailingZerosInstruction);
 5278   match(Set dst (CountTrailingZerosI src));
 5279   effect(KILL cr);
 5280 
 5281   format %{ &quot;TZCNT    $dst, $src\t# count trailing zeros (int)&quot; %}
 5282   ins_encode %{
 5283     __ tzcntl($dst$$Register, $src$$Register);
 5284   %}
 5285   ins_pipe(ialu_reg);
 5286 %}
 5287 
 5288 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, eFlagsReg cr) %{
 5289   predicate(!UseCountTrailingZerosInstruction);
 5290   match(Set dst (CountTrailingZerosI src));
 5291   effect(KILL cr);
 5292 
 5293   format %{ &quot;BSF    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 5294             &quot;JNZ    done\n\t&quot;
 5295             &quot;MOV    $dst, 32\n&quot;
 5296       &quot;done:&quot; %}
 5297   ins_encode %{
 5298     Register Rdst = $dst$$Register;
 5299     Label done;
 5300     __ bsfl(Rdst, $src$$Register);
 5301     __ jccb(Assembler::notZero, done);
 5302     __ movl(Rdst, BitsPerInt);
 5303     __ bind(done);
 5304   %}
 5305   ins_pipe(ialu_reg);
 5306 %}
 5307 
 5308 instruct countTrailingZerosL(rRegI dst, eRegL src, eFlagsReg cr) %{
 5309   predicate(UseCountTrailingZerosInstruction);
 5310   match(Set dst (CountTrailingZerosL src));
 5311   effect(TEMP dst, KILL cr);
 5312 
 5313   format %{ &quot;TZCNT  $dst, $src.lo\t# count trailing zeros (long) \n\t&quot;
 5314             &quot;JNC    done\n\t&quot;
 5315             &quot;TZCNT  $dst, $src.hi\n\t&quot;
 5316             &quot;ADD    $dst, 32\n&quot;
 5317             &quot;done:&quot; %}
 5318   ins_encode %{
 5319     Register Rdst = $dst$$Register;
 5320     Register Rsrc = $src$$Register;
 5321     Label done;
 5322     __ tzcntl(Rdst, Rsrc);
 5323     __ jccb(Assembler::carryClear, done);
 5324     __ tzcntl(Rdst, HIGH_FROM_LOW(Rsrc));
 5325     __ addl(Rdst, BitsPerInt);
 5326     __ bind(done);
 5327   %}
 5328   ins_pipe(ialu_reg);
 5329 %}
 5330 
 5331 instruct countTrailingZerosL_bsf(rRegI dst, eRegL src, eFlagsReg cr) %{
 5332   predicate(!UseCountTrailingZerosInstruction);
 5333   match(Set dst (CountTrailingZerosL src));
 5334   effect(TEMP dst, KILL cr);
 5335 
 5336   format %{ &quot;BSF    $dst, $src.lo\t# count trailing zeros (long)\n\t&quot;
 5337             &quot;JNZ    done\n\t&quot;
 5338             &quot;BSF    $dst, $src.hi\n\t&quot;
 5339             &quot;JNZ    msw_not_zero\n\t&quot;
 5340             &quot;MOV    $dst, 32\n&quot;
 5341       &quot;msw_not_zero:\n\t&quot;
 5342             &quot;ADD    $dst, 32\n&quot;
 5343       &quot;done:&quot; %}
 5344   ins_encode %{
 5345     Register Rdst = $dst$$Register;
 5346     Register Rsrc = $src$$Register;
 5347     Label msw_not_zero;
 5348     Label done;
 5349     __ bsfl(Rdst, Rsrc);
 5350     __ jccb(Assembler::notZero, done);
 5351     __ bsfl(Rdst, HIGH_FROM_LOW(Rsrc));
 5352     __ jccb(Assembler::notZero, msw_not_zero);
 5353     __ movl(Rdst, BitsPerInt);
 5354     __ bind(msw_not_zero);
 5355     __ addl(Rdst, BitsPerInt);
 5356     __ bind(done);
 5357   %}
 5358   ins_pipe(ialu_reg);
 5359 %}
 5360 
 5361 
 5362 //---------- Population Count Instructions -------------------------------------
 5363 
 5364 instruct popCountI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5365   predicate(UsePopCountInstruction);
 5366   match(Set dst (PopCountI src));
 5367   effect(KILL cr);
 5368 
 5369   format %{ &quot;POPCNT $dst, $src&quot; %}
 5370   ins_encode %{
 5371     __ popcntl($dst$$Register, $src$$Register);
 5372   %}
 5373   ins_pipe(ialu_reg);
 5374 %}
 5375 
 5376 instruct popCountI_mem(rRegI dst, memory mem, eFlagsReg cr) %{
 5377   predicate(UsePopCountInstruction);
 5378   match(Set dst (PopCountI (LoadI mem)));
 5379   effect(KILL cr);
 5380 
 5381   format %{ &quot;POPCNT $dst, $mem&quot; %}
 5382   ins_encode %{
 5383     __ popcntl($dst$$Register, $mem$$Address);
 5384   %}
 5385   ins_pipe(ialu_reg);
 5386 %}
 5387 
 5388 // Note: Long.bitCount(long) returns an int.
 5389 instruct popCountL(rRegI dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 5390   predicate(UsePopCountInstruction);
 5391   match(Set dst (PopCountL src));
 5392   effect(KILL cr, TEMP tmp, TEMP dst);
 5393 
 5394   format %{ &quot;POPCNT $dst, $src.lo\n\t&quot;
 5395             &quot;POPCNT $tmp, $src.hi\n\t&quot;
 5396             &quot;ADD    $dst, $tmp&quot; %}
 5397   ins_encode %{
 5398     __ popcntl($dst$$Register, $src$$Register);
 5399     __ popcntl($tmp$$Register, HIGH_FROM_LOW($src$$Register));
 5400     __ addl($dst$$Register, $tmp$$Register);
 5401   %}
 5402   ins_pipe(ialu_reg);
 5403 %}
 5404 
 5405 // Note: Long.bitCount(long) returns an int.
 5406 instruct popCountL_mem(rRegI dst, memory mem, rRegI tmp, eFlagsReg cr) %{
 5407   predicate(UsePopCountInstruction);
 5408   match(Set dst (PopCountL (LoadL mem)));
 5409   effect(KILL cr, TEMP tmp, TEMP dst);
 5410 
 5411   format %{ &quot;POPCNT $dst, $mem\n\t&quot;
 5412             &quot;POPCNT $tmp, $mem+4\n\t&quot;
 5413             &quot;ADD    $dst, $tmp&quot; %}
 5414   ins_encode %{
 5415     //__ popcntl($dst$$Register, $mem$$Address$$first);
 5416     //__ popcntl($tmp$$Register, $mem$$Address$$second);
 5417     __ popcntl($dst$$Register, Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none));
 5418     __ popcntl($tmp$$Register, Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none));
 5419     __ addl($dst$$Register, $tmp$$Register);
 5420   %}
 5421   ins_pipe(ialu_reg);
 5422 %}
 5423 
 5424 
 5425 //----------Load/Store/Move Instructions---------------------------------------
 5426 //----------Load Instructions--------------------------------------------------
 5427 // Load Byte (8bit signed)
 5428 instruct loadB(xRegI dst, memory mem) %{
 5429   match(Set dst (LoadB mem));
 5430 
 5431   ins_cost(125);
 5432   format %{ &quot;MOVSX8 $dst,$mem\t# byte&quot; %}
 5433 
 5434   ins_encode %{
 5435     __ movsbl($dst$$Register, $mem$$Address);
 5436   %}
 5437 
 5438   ins_pipe(ialu_reg_mem);
 5439 %}
 5440 
 5441 // Load Byte (8bit signed) into Long Register
 5442 instruct loadB2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5443   match(Set dst (ConvI2L (LoadB mem)));
 5444   effect(KILL cr);
 5445 
 5446   ins_cost(375);
 5447   format %{ &quot;MOVSX8 $dst.lo,$mem\t# byte -&gt; long\n\t&quot;
 5448             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5449             &quot;SAR    $dst.hi,7&quot; %}
 5450 
 5451   ins_encode %{
 5452     __ movsbl($dst$$Register, $mem$$Address);
 5453     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5454     __ sarl(HIGH_FROM_LOW($dst$$Register), 7); // 24+1 MSB are already signed extended.
 5455   %}
 5456 
 5457   ins_pipe(ialu_reg_mem);
 5458 %}
 5459 
 5460 // Load Unsigned Byte (8bit UNsigned)
 5461 instruct loadUB(xRegI dst, memory mem) %{
 5462   match(Set dst (LoadUB mem));
 5463 
 5464   ins_cost(125);
 5465   format %{ &quot;MOVZX8 $dst,$mem\t# ubyte -&gt; int&quot; %}
 5466 
 5467   ins_encode %{
 5468     __ movzbl($dst$$Register, $mem$$Address);
 5469   %}
 5470 
 5471   ins_pipe(ialu_reg_mem);
 5472 %}
 5473 
 5474 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 5475 instruct loadUB2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5476   match(Set dst (ConvI2L (LoadUB mem)));
 5477   effect(KILL cr);
 5478 
 5479   ins_cost(250);
 5480   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ubyte -&gt; long\n\t&quot;
 5481             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5482 
 5483   ins_encode %{
 5484     Register Rdst = $dst$$Register;
 5485     __ movzbl(Rdst, $mem$$Address);
 5486     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5487   %}
 5488 
 5489   ins_pipe(ialu_reg_mem);
 5490 %}
 5491 
 5492 // Load Unsigned Byte (8 bit UNsigned) with mask into Long Register
 5493 instruct loadUB2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
 5494   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 5495   effect(KILL cr);
 5496 
 5497   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 5498             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5499             &quot;AND    $dst.lo,right_n_bits($mask, 8)&quot; %}
 5500   ins_encode %{
 5501     Register Rdst = $dst$$Register;
 5502     __ movzbl(Rdst, $mem$$Address);
 5503     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5504     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 5505   %}
 5506   ins_pipe(ialu_reg_mem);
 5507 %}
 5508 
 5509 // Load Short (16bit signed)
 5510 instruct loadS(rRegI dst, memory mem) %{
 5511   match(Set dst (LoadS mem));
 5512 
 5513   ins_cost(125);
 5514   format %{ &quot;MOVSX  $dst,$mem\t# short&quot; %}
 5515 
 5516   ins_encode %{
 5517     __ movswl($dst$$Register, $mem$$Address);
 5518   %}
 5519 
 5520   ins_pipe(ialu_reg_mem);
 5521 %}
 5522 
 5523 // Load Short (16 bit signed) to Byte (8 bit signed)
 5524 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5525   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 5526 
 5527   ins_cost(125);
 5528   format %{ &quot;MOVSX  $dst, $mem\t# short -&gt; byte&quot; %}
 5529   ins_encode %{
 5530     __ movsbl($dst$$Register, $mem$$Address);
 5531   %}
 5532   ins_pipe(ialu_reg_mem);
 5533 %}
 5534 
 5535 // Load Short (16bit signed) into Long Register
 5536 instruct loadS2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5537   match(Set dst (ConvI2L (LoadS mem)));
 5538   effect(KILL cr);
 5539 
 5540   ins_cost(375);
 5541   format %{ &quot;MOVSX  $dst.lo,$mem\t# short -&gt; long\n\t&quot;
 5542             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5543             &quot;SAR    $dst.hi,15&quot; %}
 5544 
 5545   ins_encode %{
 5546     __ movswl($dst$$Register, $mem$$Address);
 5547     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5548     __ sarl(HIGH_FROM_LOW($dst$$Register), 15); // 16+1 MSB are already signed extended.
 5549   %}
 5550 
 5551   ins_pipe(ialu_reg_mem);
 5552 %}
 5553 
 5554 // Load Unsigned Short/Char (16bit unsigned)
 5555 instruct loadUS(rRegI dst, memory mem) %{
 5556   match(Set dst (LoadUS mem));
 5557 
 5558   ins_cost(125);
 5559   format %{ &quot;MOVZX  $dst,$mem\t# ushort/char -&gt; int&quot; %}
 5560 
 5561   ins_encode %{
 5562     __ movzwl($dst$$Register, $mem$$Address);
 5563   %}
 5564 
 5565   ins_pipe(ialu_reg_mem);
 5566 %}
 5567 
 5568 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 5569 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5570   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 5571 
 5572   ins_cost(125);
 5573   format %{ &quot;MOVSX  $dst, $mem\t# ushort -&gt; byte&quot; %}
 5574   ins_encode %{
 5575     __ movsbl($dst$$Register, $mem$$Address);
 5576   %}
 5577   ins_pipe(ialu_reg_mem);
 5578 %}
 5579 
 5580 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 5581 instruct loadUS2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5582   match(Set dst (ConvI2L (LoadUS mem)));
 5583   effect(KILL cr);
 5584 
 5585   ins_cost(250);
 5586   format %{ &quot;MOVZX  $dst.lo,$mem\t# ushort/char -&gt; long\n\t&quot;
 5587             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5588 
 5589   ins_encode %{
 5590     __ movzwl($dst$$Register, $mem$$Address);
 5591     __ xorl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register));
 5592   %}
 5593 
 5594   ins_pipe(ialu_reg_mem);
 5595 %}
 5596 
 5597 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 5598 instruct loadUS2L_immI_255(eRegL dst, memory mem, immI_255 mask, eFlagsReg cr) %{
 5599   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5600   effect(KILL cr);
 5601 
 5602   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ushort/char &amp; 0xFF -&gt; long\n\t&quot;
 5603             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5604   ins_encode %{
 5605     Register Rdst = $dst$$Register;
 5606     __ movzbl(Rdst, $mem$$Address);
 5607     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5608   %}
 5609   ins_pipe(ialu_reg_mem);
 5610 %}
 5611 
 5612 // Load Unsigned Short/Char (16 bit UNsigned) with a 32-bit mask into Long Register
 5613 instruct loadUS2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
 5614   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5615   effect(KILL cr);
 5616 
 5617   format %{ &quot;MOVZX  $dst.lo, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 5618             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5619             &quot;AND    $dst.lo,right_n_bits($mask, 16)&quot; %}
 5620   ins_encode %{
 5621     Register Rdst = $dst$$Register;
 5622     __ movzwl(Rdst, $mem$$Address);
 5623     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5624     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 5625   %}
 5626   ins_pipe(ialu_reg_mem);
 5627 %}
 5628 
 5629 // Load Integer
 5630 instruct loadI(rRegI dst, memory mem) %{
 5631   match(Set dst (LoadI mem));
 5632 
 5633   ins_cost(125);
 5634   format %{ &quot;MOV    $dst,$mem\t# int&quot; %}
 5635 
 5636   ins_encode %{
 5637     __ movl($dst$$Register, $mem$$Address);
 5638   %}
 5639 
 5640   ins_pipe(ialu_reg_mem);
 5641 %}
 5642 
 5643 // Load Integer (32 bit signed) to Byte (8 bit signed)
 5644 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5645   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 5646 
 5647   ins_cost(125);
 5648   format %{ &quot;MOVSX  $dst, $mem\t# int -&gt; byte&quot; %}
 5649   ins_encode %{
 5650     __ movsbl($dst$$Register, $mem$$Address);
 5651   %}
 5652   ins_pipe(ialu_reg_mem);
 5653 %}
 5654 
 5655 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 5656 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 5657   match(Set dst (AndI (LoadI mem) mask));
 5658 
 5659   ins_cost(125);
 5660   format %{ &quot;MOVZX  $dst, $mem\t# int -&gt; ubyte&quot; %}
 5661   ins_encode %{
 5662     __ movzbl($dst$$Register, $mem$$Address);
 5663   %}
 5664   ins_pipe(ialu_reg_mem);
 5665 %}
 5666 
 5667 // Load Integer (32 bit signed) to Short (16 bit signed)
 5668 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 5669   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5670 
 5671   ins_cost(125);
 5672   format %{ &quot;MOVSX  $dst, $mem\t# int -&gt; short&quot; %}
 5673   ins_encode %{
 5674     __ movswl($dst$$Register, $mem$$Address);
 5675   %}
 5676   ins_pipe(ialu_reg_mem);
 5677 %}
 5678 
 5679 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 5680 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 5681   match(Set dst (AndI (LoadI mem) mask));
 5682 
 5683   ins_cost(125);
 5684   format %{ &quot;MOVZX  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 5685   ins_encode %{
 5686     __ movzwl($dst$$Register, $mem$$Address);
 5687   %}
 5688   ins_pipe(ialu_reg_mem);
 5689 %}
 5690 
 5691 // Load Integer into Long Register
 5692 instruct loadI2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5693   match(Set dst (ConvI2L (LoadI mem)));
 5694   effect(KILL cr);
 5695 
 5696   ins_cost(375);
 5697   format %{ &quot;MOV    $dst.lo,$mem\t# int -&gt; long\n\t&quot;
 5698             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5699             &quot;SAR    $dst.hi,31&quot; %}
 5700 
 5701   ins_encode %{
 5702     __ movl($dst$$Register, $mem$$Address);
 5703     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5704     __ sarl(HIGH_FROM_LOW($dst$$Register), 31);
 5705   %}
 5706 
 5707   ins_pipe(ialu_reg_mem);
 5708 %}
 5709 
 5710 // Load Integer with mask 0xFF into Long Register
 5711 instruct loadI2L_immI_255(eRegL dst, memory mem, immI_255 mask, eFlagsReg cr) %{
 5712   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5713   effect(KILL cr);
 5714 
 5715   format %{ &quot;MOVZX8 $dst.lo,$mem\t# int &amp; 0xFF -&gt; long\n\t&quot;
 5716             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5717   ins_encode %{
 5718     Register Rdst = $dst$$Register;
 5719     __ movzbl(Rdst, $mem$$Address);
 5720     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5721   %}
 5722   ins_pipe(ialu_reg_mem);
 5723 %}
 5724 
 5725 // Load Integer with mask 0xFFFF into Long Register
 5726 instruct loadI2L_immI_65535(eRegL dst, memory mem, immI_65535 mask, eFlagsReg cr) %{
 5727   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5728   effect(KILL cr);
 5729 
 5730   format %{ &quot;MOVZX  $dst.lo,$mem\t# int &amp; 0xFFFF -&gt; long\n\t&quot;
 5731             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5732   ins_encode %{
 5733     Register Rdst = $dst$$Register;
 5734     __ movzwl(Rdst, $mem$$Address);
 5735     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5736   %}
 5737   ins_pipe(ialu_reg_mem);
 5738 %}
 5739 
 5740 // Load Integer with 31-bit mask into Long Register
 5741 instruct loadI2L_immU31(eRegL dst, memory mem, immU31 mask, eFlagsReg cr) %{
 5742   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5743   effect(KILL cr);
 5744 
 5745   format %{ &quot;MOV    $dst.lo,$mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5746             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5747             &quot;AND    $dst.lo,$mask&quot; %}
 5748   ins_encode %{
 5749     Register Rdst = $dst$$Register;
 5750     __ movl(Rdst, $mem$$Address);
 5751     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5752     __ andl(Rdst, $mask$$constant);
 5753   %}
 5754   ins_pipe(ialu_reg_mem);
 5755 %}
 5756 
 5757 // Load Unsigned Integer into Long Register
 5758 instruct loadUI2L(eRegL dst, memory mem, immL_32bits mask, eFlagsReg cr) %{
 5759   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5760   effect(KILL cr);
 5761 
 5762   ins_cost(250);
 5763   format %{ &quot;MOV    $dst.lo,$mem\t# uint -&gt; long\n\t&quot;
 5764             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5765 
 5766   ins_encode %{
 5767     __ movl($dst$$Register, $mem$$Address);
 5768     __ xorl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register));
 5769   %}
 5770 
 5771   ins_pipe(ialu_reg_mem);
 5772 %}
 5773 
 5774 // Load Long.  Cannot clobber address while loading, so restrict address
 5775 // register to ESI
 5776 instruct loadL(eRegL dst, load_long_memory mem) %{
 5777   predicate(!((LoadLNode*)n)-&gt;require_atomic_access());
 5778   match(Set dst (LoadL mem));
 5779 
 5780   ins_cost(250);
 5781   format %{ &quot;MOV    $dst.lo,$mem\t# long\n\t&quot;
 5782             &quot;MOV    $dst.hi,$mem+4&quot; %}
 5783 
 5784   ins_encode %{
 5785     Address Amemlo = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none);
 5786     Address Amemhi = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none);
 5787     __ movl($dst$$Register, Amemlo);
 5788     __ movl(HIGH_FROM_LOW($dst$$Register), Amemhi);
 5789   %}
 5790 
 5791   ins_pipe(ialu_reg_long_mem);
 5792 %}
 5793 
 5794 // Volatile Load Long.  Must be atomic, so do 64-bit FILD
 5795 // then store it down to the stack and reload on the int
 5796 // side.
 5797 instruct loadL_volatile(stackSlotL dst, memory mem) %{
 5798   predicate(UseSSE&lt;=1 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5799   match(Set dst (LoadL mem));
 5800 
 5801   ins_cost(200);
 5802   format %{ &quot;FILD   $mem\t# Atomic volatile long load\n\t&quot;
 5803             &quot;FISTp  $dst&quot; %}
 5804   ins_encode(enc_loadL_volatile(mem,dst));
 5805   ins_pipe( fpu_reg_mem );
 5806 %}
 5807 
 5808 instruct loadLX_volatile(stackSlotL dst, memory mem, regD tmp) %{
 5809   predicate(UseSSE&gt;=2 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5810   match(Set dst (LoadL mem));
 5811   effect(TEMP tmp);
 5812   ins_cost(180);
 5813   format %{ &quot;MOVSD  $tmp,$mem\t# Atomic volatile long load\n\t&quot;
 5814             &quot;MOVSD  $dst,$tmp&quot; %}
 5815   ins_encode %{
 5816     __ movdbl($tmp$$XMMRegister, $mem$$Address);
 5817     __ movdbl(Address(rsp, $dst$$disp), $tmp$$XMMRegister);
 5818   %}
 5819   ins_pipe( pipe_slow );
 5820 %}
 5821 
 5822 instruct loadLX_reg_volatile(eRegL dst, memory mem, regD tmp) %{
 5823   predicate(UseSSE&gt;=2 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5824   match(Set dst (LoadL mem));
 5825   effect(TEMP tmp);
 5826   ins_cost(160);
 5827   format %{ &quot;MOVSD  $tmp,$mem\t# Atomic volatile long load\n\t&quot;
 5828             &quot;MOVD   $dst.lo,$tmp\n\t&quot;
 5829             &quot;PSRLQ  $tmp,32\n\t&quot;
 5830             &quot;MOVD   $dst.hi,$tmp&quot; %}
 5831   ins_encode %{
 5832     __ movdbl($tmp$$XMMRegister, $mem$$Address);
 5833     __ movdl($dst$$Register, $tmp$$XMMRegister);
 5834     __ psrlq($tmp$$XMMRegister, 32);
 5835     __ movdl(HIGH_FROM_LOW($dst$$Register), $tmp$$XMMRegister);
 5836   %}
 5837   ins_pipe( pipe_slow );
 5838 %}
 5839 
 5840 // Load Range
 5841 instruct loadRange(rRegI dst, memory mem) %{
 5842   match(Set dst (LoadRange mem));
 5843 
 5844   ins_cost(125);
 5845   format %{ &quot;MOV    $dst,$mem&quot; %}
 5846   opcode(0x8B);
 5847   ins_encode( OpcP, RegMem(dst,mem));
 5848   ins_pipe( ialu_reg_mem );
 5849 %}
 5850 
 5851 
 5852 // Load Pointer
 5853 instruct loadP(eRegP dst, memory mem) %{
 5854   match(Set dst (LoadP mem));
 5855 
 5856   ins_cost(125);
 5857   format %{ &quot;MOV    $dst,$mem&quot; %}
 5858   opcode(0x8B);
 5859   ins_encode( OpcP, RegMem(dst,mem));
 5860   ins_pipe( ialu_reg_mem );
 5861 %}
 5862 
 5863 // Load Klass Pointer
 5864 instruct loadKlass(eRegP dst, memory mem) %{
 5865   match(Set dst (LoadKlass mem));
 5866 
 5867   ins_cost(125);
 5868   format %{ &quot;MOV    $dst,$mem&quot; %}
 5869   opcode(0x8B);
 5870   ins_encode( OpcP, RegMem(dst,mem));
 5871   ins_pipe( ialu_reg_mem );
 5872 %}
 5873 
 5874 // Load Double
 5875 instruct loadDPR(regDPR dst, memory mem) %{
 5876   predicate(UseSSE&lt;=1);
 5877   match(Set dst (LoadD mem));
 5878 
 5879   ins_cost(150);
 5880   format %{ &quot;FLD_D  ST,$mem\n\t&quot;
 5881             &quot;FSTP   $dst&quot; %}
 5882   opcode(0xDD);               /* DD /0 */
 5883   ins_encode( OpcP, RMopc_Mem(0x00,mem),
 5884               Pop_Reg_DPR(dst) );
 5885   ins_pipe( fpu_reg_mem );
 5886 %}
 5887 
 5888 // Load Double to XMM
 5889 instruct loadD(regD dst, memory mem) %{
 5890   predicate(UseSSE&gt;=2 &amp;&amp; UseXmmLoadAndClearUpper);
 5891   match(Set dst (LoadD mem));
 5892   ins_cost(145);
 5893   format %{ &quot;MOVSD  $dst,$mem&quot; %}
 5894   ins_encode %{
 5895     __ movdbl ($dst$$XMMRegister, $mem$$Address);
 5896   %}
 5897   ins_pipe( pipe_slow );
 5898 %}
 5899 
 5900 instruct loadD_partial(regD dst, memory mem) %{
 5901   predicate(UseSSE&gt;=2 &amp;&amp; !UseXmmLoadAndClearUpper);
 5902   match(Set dst (LoadD mem));
 5903   ins_cost(145);
 5904   format %{ &quot;MOVLPD $dst,$mem&quot; %}
 5905   ins_encode %{
 5906     __ movdbl ($dst$$XMMRegister, $mem$$Address);
 5907   %}
 5908   ins_pipe( pipe_slow );
 5909 %}
 5910 
 5911 // Load to XMM register (single-precision floating point)
 5912 // MOVSS instruction
 5913 instruct loadF(regF dst, memory mem) %{
 5914   predicate(UseSSE&gt;=1);
 5915   match(Set dst (LoadF mem));
 5916   ins_cost(145);
 5917   format %{ &quot;MOVSS  $dst,$mem&quot; %}
 5918   ins_encode %{
 5919     __ movflt ($dst$$XMMRegister, $mem$$Address);
 5920   %}
 5921   ins_pipe( pipe_slow );
 5922 %}
 5923 
 5924 // Load Float
 5925 instruct loadFPR(regFPR dst, memory mem) %{
 5926   predicate(UseSSE==0);
 5927   match(Set dst (LoadF mem));
 5928 
 5929   ins_cost(150);
 5930   format %{ &quot;FLD_S  ST,$mem\n\t&quot;
 5931             &quot;FSTP   $dst&quot; %}
 5932   opcode(0xD9);               /* D9 /0 */
 5933   ins_encode( OpcP, RMopc_Mem(0x00,mem),
 5934               Pop_Reg_FPR(dst) );
 5935   ins_pipe( fpu_reg_mem );
 5936 %}
 5937 
 5938 // Load Effective Address
 5939 instruct leaP8(eRegP dst, indOffset8 mem) %{
 5940   match(Set dst mem);
 5941 
 5942   ins_cost(110);
 5943   format %{ &quot;LEA    $dst,$mem&quot; %}
 5944   opcode(0x8D);
 5945   ins_encode( OpcP, RegMem(dst,mem));
 5946   ins_pipe( ialu_reg_reg_fat );
 5947 %}
 5948 
 5949 instruct leaP32(eRegP dst, indOffset32 mem) %{
 5950   match(Set dst mem);
 5951 
 5952   ins_cost(110);
 5953   format %{ &quot;LEA    $dst,$mem&quot; %}
 5954   opcode(0x8D);
 5955   ins_encode( OpcP, RegMem(dst,mem));
 5956   ins_pipe( ialu_reg_reg_fat );
 5957 %}
 5958 
 5959 instruct leaPIdxOff(eRegP dst, indIndexOffset mem) %{
 5960   match(Set dst mem);
 5961 
 5962   ins_cost(110);
 5963   format %{ &quot;LEA    $dst,$mem&quot; %}
 5964   opcode(0x8D);
 5965   ins_encode( OpcP, RegMem(dst,mem));
 5966   ins_pipe( ialu_reg_reg_fat );
 5967 %}
 5968 
 5969 instruct leaPIdxScale(eRegP dst, indIndexScale mem) %{
 5970   match(Set dst mem);
 5971 
 5972   ins_cost(110);
 5973   format %{ &quot;LEA    $dst,$mem&quot; %}
 5974   opcode(0x8D);
 5975   ins_encode( OpcP, RegMem(dst,mem));
 5976   ins_pipe( ialu_reg_reg_fat );
 5977 %}
 5978 
 5979 instruct leaPIdxScaleOff(eRegP dst, indIndexScaleOffset mem) %{
 5980   match(Set dst mem);
 5981 
 5982   ins_cost(110);
 5983   format %{ &quot;LEA    $dst,$mem&quot; %}
 5984   opcode(0x8D);
 5985   ins_encode( OpcP, RegMem(dst,mem));
 5986   ins_pipe( ialu_reg_reg_fat );
 5987 %}
 5988 
 5989 // Load Constant
 5990 instruct loadConI(rRegI dst, immI src) %{
 5991   match(Set dst src);
 5992 
 5993   format %{ &quot;MOV    $dst,$src&quot; %}
 5994   ins_encode( LdImmI(dst, src) );
 5995   ins_pipe( ialu_reg_fat );
 5996 %}
 5997 
 5998 // Load Constant zero
 5999 instruct loadConI0(rRegI dst, immI0 src, eFlagsReg cr) %{
 6000   match(Set dst src);
 6001   effect(KILL cr);
 6002 
 6003   ins_cost(50);
 6004   format %{ &quot;XOR    $dst,$dst&quot; %}
 6005   opcode(0x33);  /* + rd */
 6006   ins_encode( OpcP, RegReg( dst, dst ) );
 6007   ins_pipe( ialu_reg );
 6008 %}
 6009 
 6010 instruct loadConP(eRegP dst, immP src) %{
 6011   match(Set dst src);
 6012 
 6013   format %{ &quot;MOV    $dst,$src&quot; %}
 6014   opcode(0xB8);  /* + rd */
 6015   ins_encode( LdImmP(dst, src) );
 6016   ins_pipe( ialu_reg_fat );
 6017 %}
 6018 
 6019 instruct loadConL(eRegL dst, immL src, eFlagsReg cr) %{
 6020   match(Set dst src);
 6021   effect(KILL cr);
 6022   ins_cost(200);
 6023   format %{ &quot;MOV    $dst.lo,$src.lo\n\t&quot;
 6024             &quot;MOV    $dst.hi,$src.hi&quot; %}
 6025   opcode(0xB8);
 6026   ins_encode( LdImmL_Lo(dst, src), LdImmL_Hi(dst, src) );
 6027   ins_pipe( ialu_reg_long_fat );
 6028 %}
 6029 
 6030 instruct loadConL0(eRegL dst, immL0 src, eFlagsReg cr) %{
 6031   match(Set dst src);
 6032   effect(KILL cr);
 6033   ins_cost(150);
 6034   format %{ &quot;XOR    $dst.lo,$dst.lo\n\t&quot;
 6035             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 6036   opcode(0x33,0x33);
 6037   ins_encode( RegReg_Lo(dst,dst), RegReg_Hi(dst, dst) );
 6038   ins_pipe( ialu_reg_long );
 6039 %}
 6040 
 6041 // The instruction usage is guarded by predicate in operand immFPR().
 6042 instruct loadConFPR(regFPR dst, immFPR con) %{
 6043   match(Set dst con);
 6044   ins_cost(125);
 6045   format %{ &quot;FLD_S  ST,[$constantaddress]\t# load from constant table: float=$con\n\t&quot;
 6046             &quot;FSTP   $dst&quot; %}
 6047   ins_encode %{
 6048     __ fld_s($constantaddress($con));
 6049     __ fstp_d($dst$$reg);
 6050   %}
 6051   ins_pipe(fpu_reg_con);
 6052 %}
 6053 
 6054 // The instruction usage is guarded by predicate in operand immFPR0().
 6055 instruct loadConFPR0(regFPR dst, immFPR0 con) %{
 6056   match(Set dst con);
 6057   ins_cost(125);
 6058   format %{ &quot;FLDZ   ST\n\t&quot;
 6059             &quot;FSTP   $dst&quot; %}
 6060   ins_encode %{
 6061     __ fldz();
 6062     __ fstp_d($dst$$reg);
 6063   %}
 6064   ins_pipe(fpu_reg_con);
 6065 %}
 6066 
 6067 // The instruction usage is guarded by predicate in operand immFPR1().
 6068 instruct loadConFPR1(regFPR dst, immFPR1 con) %{
 6069   match(Set dst con);
 6070   ins_cost(125);
 6071   format %{ &quot;FLD1   ST\n\t&quot;
 6072             &quot;FSTP   $dst&quot; %}
 6073   ins_encode %{
 6074     __ fld1();
 6075     __ fstp_d($dst$$reg);
 6076   %}
 6077   ins_pipe(fpu_reg_con);
 6078 %}
 6079 
 6080 // The instruction usage is guarded by predicate in operand immF().
 6081 instruct loadConF(regF dst, immF con) %{
 6082   match(Set dst con);
 6083   ins_cost(125);
 6084   format %{ &quot;MOVSS  $dst,[$constantaddress]\t# load from constant table: float=$con&quot; %}
 6085   ins_encode %{
 6086     __ movflt($dst$$XMMRegister, $constantaddress($con));
 6087   %}
 6088   ins_pipe(pipe_slow);
 6089 %}
 6090 
 6091 // The instruction usage is guarded by predicate in operand immF0().
 6092 instruct loadConF0(regF dst, immF0 src) %{
 6093   match(Set dst src);
 6094   ins_cost(100);
 6095   format %{ &quot;XORPS  $dst,$dst\t# float 0.0&quot; %}
 6096   ins_encode %{
 6097     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 6098   %}
 6099   ins_pipe(pipe_slow);
 6100 %}
 6101 
 6102 // The instruction usage is guarded by predicate in operand immDPR().
 6103 instruct loadConDPR(regDPR dst, immDPR con) %{
 6104   match(Set dst con);
 6105   ins_cost(125);
 6106 
 6107   format %{ &quot;FLD_D  ST,[$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 6108             &quot;FSTP   $dst&quot; %}
 6109   ins_encode %{
 6110     __ fld_d($constantaddress($con));
 6111     __ fstp_d($dst$$reg);
 6112   %}
 6113   ins_pipe(fpu_reg_con);
 6114 %}
 6115 
 6116 // The instruction usage is guarded by predicate in operand immDPR0().
 6117 instruct loadConDPR0(regDPR dst, immDPR0 con) %{
 6118   match(Set dst con);
 6119   ins_cost(125);
 6120 
 6121   format %{ &quot;FLDZ   ST\n\t&quot;
 6122             &quot;FSTP   $dst&quot; %}
 6123   ins_encode %{
 6124     __ fldz();
 6125     __ fstp_d($dst$$reg);
 6126   %}
 6127   ins_pipe(fpu_reg_con);
 6128 %}
 6129 
 6130 // The instruction usage is guarded by predicate in operand immDPR1().
 6131 instruct loadConDPR1(regDPR dst, immDPR1 con) %{
 6132   match(Set dst con);
 6133   ins_cost(125);
 6134 
 6135   format %{ &quot;FLD1   ST\n\t&quot;
 6136             &quot;FSTP   $dst&quot; %}
 6137   ins_encode %{
 6138     __ fld1();
 6139     __ fstp_d($dst$$reg);
 6140   %}
 6141   ins_pipe(fpu_reg_con);
 6142 %}
 6143 
 6144 // The instruction usage is guarded by predicate in operand immD().
 6145 instruct loadConD(regD dst, immD con) %{
 6146   match(Set dst con);
 6147   ins_cost(125);
 6148   format %{ &quot;MOVSD  $dst,[$constantaddress]\t# load from constant table: double=$con&quot; %}
 6149   ins_encode %{
 6150     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 6151   %}
 6152   ins_pipe(pipe_slow);
 6153 %}
 6154 
 6155 // The instruction usage is guarded by predicate in operand immD0().
 6156 instruct loadConD0(regD dst, immD0 src) %{
 6157   match(Set dst src);
 6158   ins_cost(100);
 6159   format %{ &quot;XORPD  $dst,$dst\t# double 0.0&quot; %}
 6160   ins_encode %{
 6161     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 6162   %}
 6163   ins_pipe( pipe_slow );
 6164 %}
 6165 
 6166 // Load Stack Slot
 6167 instruct loadSSI(rRegI dst, stackSlotI src) %{
 6168   match(Set dst src);
 6169   ins_cost(125);
 6170 
 6171   format %{ &quot;MOV    $dst,$src&quot; %}
 6172   opcode(0x8B);
 6173   ins_encode( OpcP, RegMem(dst,src));
 6174   ins_pipe( ialu_reg_mem );
 6175 %}
 6176 
 6177 instruct loadSSL(eRegL dst, stackSlotL src) %{
 6178   match(Set dst src);
 6179 
 6180   ins_cost(200);
 6181   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
 6182             &quot;MOV    $dst+4,$src.hi&quot; %}
 6183   opcode(0x8B, 0x8B);
 6184   ins_encode( OpcP, RegMem( dst, src ), OpcS, RegMem_Hi( dst, src ) );
 6185   ins_pipe( ialu_mem_long_reg );
 6186 %}
 6187 
 6188 // Load Stack Slot
 6189 instruct loadSSP(eRegP dst, stackSlotP src) %{
 6190   match(Set dst src);
 6191   ins_cost(125);
 6192 
 6193   format %{ &quot;MOV    $dst,$src&quot; %}
 6194   opcode(0x8B);
 6195   ins_encode( OpcP, RegMem(dst,src));
 6196   ins_pipe( ialu_reg_mem );
 6197 %}
 6198 
 6199 // Load Stack Slot
 6200 instruct loadSSF(regFPR dst, stackSlotF src) %{
 6201   match(Set dst src);
 6202   ins_cost(125);
 6203 
 6204   format %{ &quot;FLD_S  $src\n\t&quot;
 6205             &quot;FSTP   $dst&quot; %}
 6206   opcode(0xD9);               /* D9 /0, FLD m32real */
 6207   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
 6208               Pop_Reg_FPR(dst) );
 6209   ins_pipe( fpu_reg_mem );
 6210 %}
 6211 
 6212 // Load Stack Slot
 6213 instruct loadSSD(regDPR dst, stackSlotD src) %{
 6214   match(Set dst src);
 6215   ins_cost(125);
 6216 
 6217   format %{ &quot;FLD_D  $src\n\t&quot;
 6218             &quot;FSTP   $dst&quot; %}
 6219   opcode(0xDD);               /* DD /0, FLD m64real */
 6220   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
 6221               Pop_Reg_DPR(dst) );
 6222   ins_pipe( fpu_reg_mem );
 6223 %}
 6224 
 6225 // Prefetch instructions for allocation.
 6226 // Must be safe to execute with invalid address (cannot fault).
 6227 
 6228 instruct prefetchAlloc0( memory mem ) %{
 6229   predicate(UseSSE==0 &amp;&amp; AllocatePrefetchInstr!=3);
 6230   match(PrefetchAllocation mem);
 6231   ins_cost(0);
 6232   size(0);
 6233   format %{ &quot;Prefetch allocation (non-SSE is empty encoding)&quot; %}
 6234   ins_encode();
 6235   ins_pipe(empty);
 6236 %}
 6237 
 6238 instruct prefetchAlloc( memory mem ) %{
 6239   predicate(AllocatePrefetchInstr==3);
 6240   match( PrefetchAllocation mem );
 6241   ins_cost(100);
 6242 
 6243   format %{ &quot;PREFETCHW $mem\t! Prefetch allocation into L1 cache and mark modified&quot; %}
 6244   ins_encode %{
 6245     __ prefetchw($mem$$Address);
 6246   %}
 6247   ins_pipe(ialu_mem);
 6248 %}
 6249 
 6250 instruct prefetchAllocNTA( memory mem ) %{
 6251   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==0);
 6252   match(PrefetchAllocation mem);
 6253   ins_cost(100);
 6254 
 6255   format %{ &quot;PREFETCHNTA $mem\t! Prefetch allocation into non-temporal cache for write&quot; %}
 6256   ins_encode %{
 6257     __ prefetchnta($mem$$Address);
 6258   %}
 6259   ins_pipe(ialu_mem);
 6260 %}
 6261 
 6262 instruct prefetchAllocT0( memory mem ) %{
 6263   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==1);
 6264   match(PrefetchAllocation mem);
 6265   ins_cost(100);
 6266 
 6267   format %{ &quot;PREFETCHT0 $mem\t! Prefetch allocation into L1 and L2 caches for write&quot; %}
 6268   ins_encode %{
 6269     __ prefetcht0($mem$$Address);
 6270   %}
 6271   ins_pipe(ialu_mem);
 6272 %}
 6273 
 6274 instruct prefetchAllocT2( memory mem ) %{
 6275   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==2);
 6276   match(PrefetchAllocation mem);
 6277   ins_cost(100);
 6278 
 6279   format %{ &quot;PREFETCHT2 $mem\t! Prefetch allocation into L2 cache for write&quot; %}
 6280   ins_encode %{
 6281     __ prefetcht2($mem$$Address);
 6282   %}
 6283   ins_pipe(ialu_mem);
 6284 %}
 6285 
 6286 //----------Store Instructions-------------------------------------------------
 6287 
 6288 // Store Byte
 6289 instruct storeB(memory mem, xRegI src) %{
 6290   match(Set mem (StoreB mem src));
 6291 
 6292   ins_cost(125);
 6293   format %{ &quot;MOV8   $mem,$src&quot; %}
 6294   opcode(0x88);
 6295   ins_encode( OpcP, RegMem( src, mem ) );
 6296   ins_pipe( ialu_mem_reg );
 6297 %}
 6298 
 6299 // Store Char/Short
 6300 instruct storeC(memory mem, rRegI src) %{
 6301   match(Set mem (StoreC mem src));
 6302 
 6303   ins_cost(125);
 6304   format %{ &quot;MOV16  $mem,$src&quot; %}
 6305   opcode(0x89, 0x66);
 6306   ins_encode( OpcS, OpcP, RegMem( src, mem ) );
 6307   ins_pipe( ialu_mem_reg );
 6308 %}
 6309 
 6310 // Store Integer
 6311 instruct storeI(memory mem, rRegI src) %{
 6312   match(Set mem (StoreI mem src));
 6313 
 6314   ins_cost(125);
 6315   format %{ &quot;MOV    $mem,$src&quot; %}
 6316   opcode(0x89);
 6317   ins_encode( OpcP, RegMem( src, mem ) );
 6318   ins_pipe( ialu_mem_reg );
 6319 %}
 6320 
 6321 // Store Long
 6322 instruct storeL(long_memory mem, eRegL src) %{
 6323   predicate(!((StoreLNode*)n)-&gt;require_atomic_access());
 6324   match(Set mem (StoreL mem src));
 6325 
 6326   ins_cost(200);
 6327   format %{ &quot;MOV    $mem,$src.lo\n\t&quot;
 6328             &quot;MOV    $mem+4,$src.hi&quot; %}
 6329   opcode(0x89, 0x89);
 6330   ins_encode( OpcP, RegMem( src, mem ), OpcS, RegMem_Hi( src, mem ) );
 6331   ins_pipe( ialu_mem_long_reg );
 6332 %}
 6333 
 6334 // Store Long to Integer
 6335 instruct storeL2I(memory mem, eRegL src) %{
 6336   match(Set mem (StoreI mem (ConvL2I src)));
 6337 
 6338   format %{ &quot;MOV    $mem,$src.lo\t# long -&gt; int&quot; %}
 6339   ins_encode %{
 6340     __ movl($mem$$Address, $src$$Register);
 6341   %}
 6342   ins_pipe(ialu_mem_reg);
 6343 %}
 6344 
 6345 // Volatile Store Long.  Must be atomic, so move it into
 6346 // the FP TOS and then do a 64-bit FIST.  Has to probe the
 6347 // target address before the store (for null-ptr checks)
 6348 // so the memory operand is used twice in the encoding.
 6349 instruct storeL_volatile(memory mem, stackSlotL src, eFlagsReg cr ) %{
 6350   predicate(UseSSE&lt;=1 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6351   match(Set mem (StoreL mem src));
 6352   effect( KILL cr );
 6353   ins_cost(400);
 6354   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6355             &quot;FILD   $src\n\t&quot;
 6356             &quot;FISTp  $mem\t # 64-bit atomic volatile long store&quot; %}
 6357   opcode(0x3B);
 6358   ins_encode( OpcP, RegMem( EAX, mem ), enc_storeL_volatile(mem,src));
 6359   ins_pipe( fpu_reg_mem );
 6360 %}
 6361 
 6362 instruct storeLX_volatile(memory mem, stackSlotL src, regD tmp, eFlagsReg cr) %{
 6363   predicate(UseSSE&gt;=2 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6364   match(Set mem (StoreL mem src));
 6365   effect( TEMP tmp, KILL cr );
 6366   ins_cost(380);
 6367   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6368             &quot;MOVSD  $tmp,$src\n\t&quot;
 6369             &quot;MOVSD  $mem,$tmp\t # 64-bit atomic volatile long store&quot; %}
 6370   ins_encode %{
 6371     __ cmpl(rax, $mem$$Address);
 6372     __ movdbl($tmp$$XMMRegister, Address(rsp, $src$$disp));
 6373     __ movdbl($mem$$Address, $tmp$$XMMRegister);
 6374   %}
 6375   ins_pipe( pipe_slow );
 6376 %}
 6377 
 6378 instruct storeLX_reg_volatile(memory mem, eRegL src, regD tmp2, regD tmp, eFlagsReg cr) %{
 6379   predicate(UseSSE&gt;=2 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6380   match(Set mem (StoreL mem src));
 6381   effect( TEMP tmp2 , TEMP tmp, KILL cr );
 6382   ins_cost(360);
 6383   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6384             &quot;MOVD   $tmp,$src.lo\n\t&quot;
 6385             &quot;MOVD   $tmp2,$src.hi\n\t&quot;
 6386             &quot;PUNPCKLDQ $tmp,$tmp2\n\t&quot;
 6387             &quot;MOVSD  $mem,$tmp\t # 64-bit atomic volatile long store&quot; %}
 6388   ins_encode %{
 6389     __ cmpl(rax, $mem$$Address);
 6390     __ movdl($tmp$$XMMRegister, $src$$Register);
 6391     __ movdl($tmp2$$XMMRegister, HIGH_FROM_LOW($src$$Register));
 6392     __ punpckldq($tmp$$XMMRegister, $tmp2$$XMMRegister);
 6393     __ movdbl($mem$$Address, $tmp$$XMMRegister);
 6394   %}
 6395   ins_pipe( pipe_slow );
 6396 %}
 6397 
 6398 // Store Pointer; for storing unknown oops and raw pointers
 6399 instruct storeP(memory mem, anyRegP src) %{
 6400   match(Set mem (StoreP mem src));
 6401 
 6402   ins_cost(125);
 6403   format %{ &quot;MOV    $mem,$src&quot; %}
 6404   opcode(0x89);
 6405   ins_encode( OpcP, RegMem( src, mem ) );
 6406   ins_pipe( ialu_mem_reg );
 6407 %}
 6408 
 6409 // Store Integer Immediate
 6410 instruct storeImmI(memory mem, immI src) %{
 6411   match(Set mem (StoreI mem src));
 6412 
 6413   ins_cost(150);
 6414   format %{ &quot;MOV    $mem,$src&quot; %}
 6415   opcode(0xC7);               /* C7 /0 */
 6416   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));
 6417   ins_pipe( ialu_mem_imm );
 6418 %}
 6419 
 6420 // Store Short/Char Immediate
 6421 instruct storeImmI16(memory mem, immI16 src) %{
 6422   predicate(UseStoreImmI16);
 6423   match(Set mem (StoreC mem src));
 6424 
 6425   ins_cost(150);
 6426   format %{ &quot;MOV16  $mem,$src&quot; %}
 6427   opcode(0xC7);     /* C7 /0 Same as 32 store immediate with prefix */
 6428   ins_encode( SizePrefix, OpcP, RMopc_Mem(0x00,mem),  Con16( src ));
 6429   ins_pipe( ialu_mem_imm );
 6430 %}
 6431 
 6432 // Store Pointer Immediate; null pointers or constant oops that do not
 6433 // need card-mark barriers.
 6434 instruct storeImmP(memory mem, immP src) %{
 6435   match(Set mem (StoreP mem src));
 6436 
 6437   ins_cost(150);
 6438   format %{ &quot;MOV    $mem,$src&quot; %}
 6439   opcode(0xC7);               /* C7 /0 */
 6440   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));
 6441   ins_pipe( ialu_mem_imm );
 6442 %}
 6443 
 6444 // Store Byte Immediate
 6445 instruct storeImmB(memory mem, immI8 src) %{
 6446   match(Set mem (StoreB mem src));
 6447 
 6448   ins_cost(150);
 6449   format %{ &quot;MOV8   $mem,$src&quot; %}
 6450   opcode(0xC6);               /* C6 /0 */
 6451   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));
 6452   ins_pipe( ialu_mem_imm );
 6453 %}
 6454 
 6455 // Store CMS card-mark Immediate
 6456 instruct storeImmCM(memory mem, immI8 src) %{
 6457   match(Set mem (StoreCM mem src));
 6458 
 6459   ins_cost(150);
 6460   format %{ &quot;MOV8   $mem,$src\t! CMS card-mark imm0&quot; %}
 6461   opcode(0xC6);               /* C6 /0 */
 6462   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));
 6463   ins_pipe( ialu_mem_imm );
 6464 %}
 6465 
 6466 // Store Double
 6467 instruct storeDPR( memory mem, regDPR1 src) %{
 6468   predicate(UseSSE&lt;=1);
 6469   match(Set mem (StoreD mem src));
 6470 
 6471   ins_cost(100);
 6472   format %{ &quot;FST_D  $mem,$src&quot; %}
 6473   opcode(0xDD);       /* DD /2 */
 6474   ins_encode( enc_FPR_store(mem,src) );
 6475   ins_pipe( fpu_mem_reg );
 6476 %}
 6477 
 6478 // Store double does rounding on x86
 6479 instruct storeDPR_rounded( memory mem, regDPR1 src) %{
 6480   predicate(UseSSE&lt;=1);
 6481   match(Set mem (StoreD mem (RoundDouble src)));
 6482 
 6483   ins_cost(100);
 6484   format %{ &quot;FST_D  $mem,$src\t# round&quot; %}
 6485   opcode(0xDD);       /* DD /2 */
 6486   ins_encode( enc_FPR_store(mem,src) );
 6487   ins_pipe( fpu_mem_reg );
 6488 %}
 6489 
 6490 // Store XMM register to memory (double-precision floating points)
 6491 // MOVSD instruction
 6492 instruct storeD(memory mem, regD src) %{
 6493   predicate(UseSSE&gt;=2);
 6494   match(Set mem (StoreD mem src));
 6495   ins_cost(95);
 6496   format %{ &quot;MOVSD  $mem,$src&quot; %}
 6497   ins_encode %{
 6498     __ movdbl($mem$$Address, $src$$XMMRegister);
 6499   %}
 6500   ins_pipe( pipe_slow );
 6501 %}
 6502 
 6503 // Load Double
 6504 instruct MoveD2VL(vlRegD dst, regD src) %{
 6505   match(Set dst src);
 6506   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 6507   ins_encode %{
 6508     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6509   %}
 6510   ins_pipe( fpu_reg_reg );
 6511 %}
 6512 
 6513 // Load Double
 6514 instruct MoveVL2D(regD dst, vlRegD src) %{
 6515   match(Set dst src);
 6516   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 6517   ins_encode %{
 6518     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6519   %}
 6520   ins_pipe( fpu_reg_reg );
 6521 %}
 6522 
 6523 // Store XMM register to memory (single-precision floating point)
 6524 // MOVSS instruction
 6525 instruct storeF(memory mem, regF src) %{
 6526   predicate(UseSSE&gt;=1);
 6527   match(Set mem (StoreF mem src));
 6528   ins_cost(95);
 6529   format %{ &quot;MOVSS  $mem,$src&quot; %}
 6530   ins_encode %{
 6531     __ movflt($mem$$Address, $src$$XMMRegister);
 6532   %}
 6533   ins_pipe( pipe_slow );
 6534 %}
 6535 
 6536 // Load Float
 6537 instruct MoveF2VL(vlRegF dst, regF src) %{
 6538   match(Set dst src);
 6539   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 6540   ins_encode %{
 6541     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6542   %}
 6543   ins_pipe( fpu_reg_reg );
 6544 %}
 6545 
 6546 // Load Float
 6547 instruct MoveVL2F(regF dst, vlRegF src) %{
 6548   match(Set dst src);
 6549   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 6550   ins_encode %{
 6551     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6552   %}
 6553   ins_pipe( fpu_reg_reg );
 6554 %}
 6555 
 6556 // Store Float
 6557 instruct storeFPR( memory mem, regFPR1 src) %{
 6558   predicate(UseSSE==0);
 6559   match(Set mem (StoreF mem src));
 6560 
 6561   ins_cost(100);
 6562   format %{ &quot;FST_S  $mem,$src&quot; %}
 6563   opcode(0xD9);       /* D9 /2 */
 6564   ins_encode( enc_FPR_store(mem,src) );
 6565   ins_pipe( fpu_mem_reg );
 6566 %}
 6567 
 6568 // Store Float does rounding on x86
 6569 instruct storeFPR_rounded( memory mem, regFPR1 src) %{
 6570   predicate(UseSSE==0);
 6571   match(Set mem (StoreF mem (RoundFloat src)));
 6572 
 6573   ins_cost(100);
 6574   format %{ &quot;FST_S  $mem,$src\t# round&quot; %}
 6575   opcode(0xD9);       /* D9 /2 */
 6576   ins_encode( enc_FPR_store(mem,src) );
 6577   ins_pipe( fpu_mem_reg );
 6578 %}
 6579 
 6580 // Store Float does rounding on x86
 6581 instruct storeFPR_Drounded( memory mem, regDPR1 src) %{
 6582   predicate(UseSSE&lt;=1);
 6583   match(Set mem (StoreF mem (ConvD2F src)));
 6584 
 6585   ins_cost(100);
 6586   format %{ &quot;FST_S  $mem,$src\t# D-round&quot; %}
 6587   opcode(0xD9);       /* D9 /2 */
 6588   ins_encode( enc_FPR_store(mem,src) );
 6589   ins_pipe( fpu_mem_reg );
 6590 %}
 6591 
 6592 // Store immediate Float value (it is faster than store from FPU register)
 6593 // The instruction usage is guarded by predicate in operand immFPR().
 6594 instruct storeFPR_imm( memory mem, immFPR src) %{
 6595   match(Set mem (StoreF mem src));
 6596 
 6597   ins_cost(50);
 6598   format %{ &quot;MOV    $mem,$src\t# store float&quot; %}
 6599   opcode(0xC7);               /* C7 /0 */
 6600   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32FPR_as_bits( src ));
 6601   ins_pipe( ialu_mem_imm );
 6602 %}
 6603 
 6604 // Store immediate Float value (it is faster than store from XMM register)
 6605 // The instruction usage is guarded by predicate in operand immF().
 6606 instruct storeF_imm( memory mem, immF src) %{
 6607   match(Set mem (StoreF mem src));
 6608 
 6609   ins_cost(50);
 6610   format %{ &quot;MOV    $mem,$src\t# store float&quot; %}
 6611   opcode(0xC7);               /* C7 /0 */
 6612   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32F_as_bits( src ));
 6613   ins_pipe( ialu_mem_imm );
 6614 %}
 6615 
 6616 // Store Integer to stack slot
 6617 instruct storeSSI(stackSlotI dst, rRegI src) %{
 6618   match(Set dst src);
 6619 
 6620   ins_cost(100);
 6621   format %{ &quot;MOV    $dst,$src&quot; %}
 6622   opcode(0x89);
 6623   ins_encode( OpcPRegSS( dst, src ) );
 6624   ins_pipe( ialu_mem_reg );
 6625 %}
 6626 
 6627 // Store Integer to stack slot
 6628 instruct storeSSP(stackSlotP dst, eRegP src) %{
 6629   match(Set dst src);
 6630 
 6631   ins_cost(100);
 6632   format %{ &quot;MOV    $dst,$src&quot; %}
 6633   opcode(0x89);
 6634   ins_encode( OpcPRegSS( dst, src ) );
 6635   ins_pipe( ialu_mem_reg );
 6636 %}
 6637 
 6638 // Store Long to stack slot
 6639 instruct storeSSL(stackSlotL dst, eRegL src) %{
 6640   match(Set dst src);
 6641 
 6642   ins_cost(200);
 6643   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
 6644             &quot;MOV    $dst+4,$src.hi&quot; %}
 6645   opcode(0x89, 0x89);
 6646   ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );
 6647   ins_pipe( ialu_mem_long_reg );
 6648 %}
 6649 
 6650 //----------MemBar Instructions-----------------------------------------------
 6651 // Memory barrier flavors
 6652 
 6653 instruct membar_acquire() %{
 6654   match(MemBarAcquire);
 6655   match(LoadFence);
 6656   ins_cost(400);
 6657 
 6658   size(0);
 6659   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6660   ins_encode();
 6661   ins_pipe(empty);
 6662 %}
 6663 
 6664 instruct membar_acquire_lock() %{
 6665   match(MemBarAcquireLock);
 6666   ins_cost(0);
 6667 
 6668   size(0);
 6669   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6670   ins_encode( );
 6671   ins_pipe(empty);
 6672 %}
 6673 
 6674 instruct membar_release() %{
 6675   match(MemBarRelease);
 6676   match(StoreFence);
 6677   ins_cost(400);
 6678 
 6679   size(0);
 6680   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6681   ins_encode( );
 6682   ins_pipe(empty);
 6683 %}
 6684 
 6685 instruct membar_release_lock() %{
 6686   match(MemBarReleaseLock);
 6687   ins_cost(0);
 6688 
 6689   size(0);
 6690   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6691   ins_encode( );
 6692   ins_pipe(empty);
 6693 %}
 6694 
 6695 instruct membar_volatile(eFlagsReg cr) %{
 6696   match(MemBarVolatile);
 6697   effect(KILL cr);
 6698   ins_cost(400);
 6699 
 6700   format %{
 6701     $$template
 6702     $$emit$$&quot;LOCK ADDL [ESP + #0], 0\t! membar_volatile&quot;
 6703   %}
 6704   ins_encode %{
 6705     __ membar(Assembler::StoreLoad);
 6706   %}
 6707   ins_pipe(pipe_slow);
 6708 %}
 6709 
 6710 instruct unnecessary_membar_volatile() %{
 6711   match(MemBarVolatile);
 6712   predicate(Matcher::post_store_load_barrier(n));
 6713   ins_cost(0);
 6714 
 6715   size(0);
 6716   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6717   ins_encode( );
 6718   ins_pipe(empty);
 6719 %}
 6720 
 6721 instruct membar_storestore() %{
 6722   match(MemBarStoreStore);
 6723   ins_cost(0);
 6724 
 6725   size(0);
 6726   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6727   ins_encode( );
 6728   ins_pipe(empty);
 6729 %}
 6730 
 6731 //----------Move Instructions--------------------------------------------------
 6732 instruct castX2P(eAXRegP dst, eAXRegI src) %{
 6733   match(Set dst (CastX2P src));
 6734   format %{ &quot;# X2P  $dst, $src&quot; %}
 6735   ins_encode( /*empty encoding*/ );
 6736   ins_cost(0);
 6737   ins_pipe(empty);
 6738 %}
 6739 
 6740 instruct castP2X(rRegI dst, eRegP src ) %{
 6741   match(Set dst (CastP2X src));
 6742   ins_cost(50);
 6743   format %{ &quot;MOV    $dst, $src\t# CastP2X&quot; %}
 6744   ins_encode( enc_Copy( dst, src) );
 6745   ins_pipe( ialu_reg_reg );
 6746 %}
 6747 
 6748 //----------Conditional Move---------------------------------------------------
 6749 // Conditional move
 6750 instruct jmovI_reg(cmpOp cop, eFlagsReg cr, rRegI dst, rRegI src) %{
 6751   predicate(!VM_Version::supports_cmov() );
 6752   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6753   ins_cost(200);
 6754   format %{ &quot;J$cop,us skip\t# signed cmove\n\t&quot;
 6755             &quot;MOV    $dst,$src\n&quot;
 6756       &quot;skip:&quot; %}
 6757   ins_encode %{
 6758     Label Lskip;
 6759     // Invert sense of branch from sense of CMOV
 6760     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 6761     __ movl($dst$$Register, $src$$Register);
 6762     __ bind(Lskip);
 6763   %}
 6764   ins_pipe( pipe_cmov_reg );
 6765 %}
 6766 
 6767 instruct jmovI_regU(cmpOpU cop, eFlagsRegU cr, rRegI dst, rRegI src) %{
 6768   predicate(!VM_Version::supports_cmov() );
 6769   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6770   ins_cost(200);
 6771   format %{ &quot;J$cop,us skip\t# unsigned cmove\n\t&quot;
 6772             &quot;MOV    $dst,$src\n&quot;
 6773       &quot;skip:&quot; %}
 6774   ins_encode %{
 6775     Label Lskip;
 6776     // Invert sense of branch from sense of CMOV
 6777     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 6778     __ movl($dst$$Register, $src$$Register);
 6779     __ bind(Lskip);
 6780   %}
 6781   ins_pipe( pipe_cmov_reg );
 6782 %}
 6783 
 6784 instruct cmovI_reg(rRegI dst, rRegI src, eFlagsReg cr, cmpOp cop ) %{
 6785   predicate(VM_Version::supports_cmov() );
 6786   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6787   ins_cost(200);
 6788   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6789   opcode(0x0F,0x40);
 6790   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6791   ins_pipe( pipe_cmov_reg );
 6792 %}
 6793 
 6794 instruct cmovI_regU( cmpOpU cop, eFlagsRegU cr, rRegI dst, rRegI src ) %{
 6795   predicate(VM_Version::supports_cmov() );
 6796   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6797   ins_cost(200);
 6798   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6799   opcode(0x0F,0x40);
 6800   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6801   ins_pipe( pipe_cmov_reg );
 6802 %}
 6803 
 6804 instruct cmovI_regUCF( cmpOpUCF cop, eFlagsRegUCF cr, rRegI dst, rRegI src ) %{
 6805   predicate(VM_Version::supports_cmov() );
 6806   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6807   ins_cost(200);
 6808   expand %{
 6809     cmovI_regU(cop, cr, dst, src);
 6810   %}
 6811 %}
 6812 
 6813 // Conditional move
 6814 instruct cmovI_mem(cmpOp cop, eFlagsReg cr, rRegI dst, memory src) %{
 6815   predicate(VM_Version::supports_cmov() );
 6816   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6817   ins_cost(250);
 6818   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6819   opcode(0x0F,0x40);
 6820   ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6821   ins_pipe( pipe_cmov_mem );
 6822 %}
 6823 
 6824 // Conditional move
 6825 instruct cmovI_memU(cmpOpU cop, eFlagsRegU cr, rRegI dst, memory src) %{
 6826   predicate(VM_Version::supports_cmov() );
 6827   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6828   ins_cost(250);
 6829   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6830   opcode(0x0F,0x40);
 6831   ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6832   ins_pipe( pipe_cmov_mem );
 6833 %}
 6834 
 6835 instruct cmovI_memUCF(cmpOpUCF cop, eFlagsRegUCF cr, rRegI dst, memory src) %{
 6836   predicate(VM_Version::supports_cmov() );
 6837   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6838   ins_cost(250);
 6839   expand %{
 6840     cmovI_memU(cop, cr, dst, src);
 6841   %}
 6842 %}
 6843 
 6844 // Conditional move
 6845 instruct cmovP_reg(eRegP dst, eRegP src, eFlagsReg cr, cmpOp cop ) %{
 6846   predicate(VM_Version::supports_cmov() );
 6847   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6848   ins_cost(200);
 6849   format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6850   opcode(0x0F,0x40);
 6851   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6852   ins_pipe( pipe_cmov_reg );
 6853 %}
 6854 
 6855 // Conditional move (non-P6 version)
 6856 // Note:  a CMoveP is generated for  stubs and native wrappers
 6857 //        regardless of whether we are on a P6, so we
 6858 //        emulate a cmov here
 6859 instruct cmovP_reg_nonP6(eRegP dst, eRegP src, eFlagsReg cr, cmpOp cop ) %{
 6860   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6861   ins_cost(300);
 6862   format %{ &quot;Jn$cop   skip\n\t&quot;
 6863           &quot;MOV    $dst,$src\t# pointer\n&quot;
 6864       &quot;skip:&quot; %}
 6865   opcode(0x8b);
 6866   ins_encode( enc_cmov_branch(cop, 0x2), OpcP, RegReg(dst, src));
 6867   ins_pipe( pipe_cmov_reg );
 6868 %}
 6869 
 6870 // Conditional move
 6871 instruct cmovP_regU(cmpOpU cop, eFlagsRegU cr, eRegP dst, eRegP src ) %{
 6872   predicate(VM_Version::supports_cmov() );
 6873   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6874   ins_cost(200);
 6875   format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6876   opcode(0x0F,0x40);
 6877   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6878   ins_pipe( pipe_cmov_reg );
 6879 %}
 6880 
 6881 instruct cmovP_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, eRegP dst, eRegP src ) %{
 6882   predicate(VM_Version::supports_cmov() );
 6883   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6884   ins_cost(200);
 6885   expand %{
 6886     cmovP_regU(cop, cr, dst, src);
 6887   %}
 6888 %}
 6889 
 6890 // DISABLED: Requires the ADLC to emit a bottom_type call that
 6891 // correctly meets the two pointer arguments; one is an incoming
 6892 // register but the other is a memory operand.  ALSO appears to
 6893 // be buggy with implicit null checks.
 6894 //
 6895 //// Conditional move
 6896 //instruct cmovP_mem(cmpOp cop, eFlagsReg cr, eRegP dst, memory src) %{
 6897 //  predicate(VM_Version::supports_cmov() );
 6898 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 6899 //  ins_cost(250);
 6900 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6901 //  opcode(0x0F,0x40);
 6902 //  ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6903 //  ins_pipe( pipe_cmov_mem );
 6904 //%}
 6905 //
 6906 //// Conditional move
 6907 //instruct cmovP_memU(cmpOpU cop, eFlagsRegU cr, eRegP dst, memory src) %{
 6908 //  predicate(VM_Version::supports_cmov() );
 6909 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 6910 //  ins_cost(250);
 6911 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6912 //  opcode(0x0F,0x40);
 6913 //  ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6914 //  ins_pipe( pipe_cmov_mem );
 6915 //%}
 6916 
 6917 // Conditional move
 6918 instruct fcmovDPR_regU(cmpOp_fcmov cop, eFlagsRegU cr, regDPR1 dst, regDPR src) %{
 6919   predicate(UseSSE&lt;=1);
 6920   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6921   ins_cost(200);
 6922   format %{ &quot;FCMOV$cop $dst,$src\t# double&quot; %}
 6923   opcode(0xDA);
 6924   ins_encode( enc_cmov_dpr(cop,src) );
 6925   ins_pipe( pipe_cmovDPR_reg );
 6926 %}
 6927 
 6928 // Conditional move
 6929 instruct fcmovFPR_regU(cmpOp_fcmov cop, eFlagsRegU cr, regFPR1 dst, regFPR src) %{
 6930   predicate(UseSSE==0);
 6931   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6932   ins_cost(200);
 6933   format %{ &quot;FCMOV$cop $dst,$src\t# float&quot; %}
 6934   opcode(0xDA);
 6935   ins_encode( enc_cmov_dpr(cop,src) );
 6936   ins_pipe( pipe_cmovDPR_reg );
 6937 %}
 6938 
 6939 // Float CMOV on Intel doesn&#39;t handle *signed* compares, only unsigned.
 6940 instruct fcmovDPR_regS(cmpOp cop, eFlagsReg cr, regDPR dst, regDPR src) %{
 6941   predicate(UseSSE&lt;=1);
 6942   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6943   ins_cost(200);
 6944   format %{ &quot;Jn$cop   skip\n\t&quot;
 6945             &quot;MOV    $dst,$src\t# double\n&quot;
 6946       &quot;skip:&quot; %}
 6947   opcode (0xdd, 0x3);     /* DD D8+i or DD /3 */
 6948   ins_encode( enc_cmov_branch( cop, 0x4 ), Push_Reg_DPR(src), OpcP, RegOpc(dst) );
 6949   ins_pipe( pipe_cmovDPR_reg );
 6950 %}
 6951 
 6952 // Float CMOV on Intel doesn&#39;t handle *signed* compares, only unsigned.
 6953 instruct fcmovFPR_regS(cmpOp cop, eFlagsReg cr, regFPR dst, regFPR src) %{
 6954   predicate(UseSSE==0);
 6955   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6956   ins_cost(200);
 6957   format %{ &quot;Jn$cop    skip\n\t&quot;
 6958             &quot;MOV    $dst,$src\t# float\n&quot;
 6959       &quot;skip:&quot; %}
 6960   opcode (0xdd, 0x3);     /* DD D8+i or DD /3 */
 6961   ins_encode( enc_cmov_branch( cop, 0x4 ), Push_Reg_FPR(src), OpcP, RegOpc(dst) );
 6962   ins_pipe( pipe_cmovDPR_reg );
 6963 %}
 6964 
 6965 // No CMOVE with SSE/SSE2
 6966 instruct fcmovF_regS(cmpOp cop, eFlagsReg cr, regF dst, regF src) %{
 6967   predicate (UseSSE&gt;=1);
 6968   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6969   ins_cost(200);
 6970   format %{ &quot;Jn$cop   skip\n\t&quot;
 6971             &quot;MOVSS  $dst,$src\t# float\n&quot;
 6972       &quot;skip:&quot; %}
 6973   ins_encode %{
 6974     Label skip;
 6975     // Invert sense of branch from sense of CMOV
 6976     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6977     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6978     __ bind(skip);
 6979   %}
 6980   ins_pipe( pipe_slow );
 6981 %}
 6982 
 6983 // No CMOVE with SSE/SSE2
 6984 instruct fcmovD_regS(cmpOp cop, eFlagsReg cr, regD dst, regD src) %{
 6985   predicate (UseSSE&gt;=2);
 6986   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6987   ins_cost(200);
 6988   format %{ &quot;Jn$cop   skip\n\t&quot;
 6989             &quot;MOVSD  $dst,$src\t# float\n&quot;
 6990       &quot;skip:&quot; %}
 6991   ins_encode %{
 6992     Label skip;
 6993     // Invert sense of branch from sense of CMOV
 6994     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6995     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6996     __ bind(skip);
 6997   %}
 6998   ins_pipe( pipe_slow );
 6999 %}
 7000 
 7001 // unsigned version
 7002 instruct fcmovF_regU(cmpOpU cop, eFlagsRegU cr, regF dst, regF src) %{
 7003   predicate (UseSSE&gt;=1);
 7004   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7005   ins_cost(200);
 7006   format %{ &quot;Jn$cop   skip\n\t&quot;
 7007             &quot;MOVSS  $dst,$src\t# float\n&quot;
 7008       &quot;skip:&quot; %}
 7009   ins_encode %{
 7010     Label skip;
 7011     // Invert sense of branch from sense of CMOV
 7012     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 7013     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7014     __ bind(skip);
 7015   %}
 7016   ins_pipe( pipe_slow );
 7017 %}
 7018 
 7019 instruct fcmovF_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, regF dst, regF src) %{
 7020   predicate (UseSSE&gt;=1);
 7021   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7022   ins_cost(200);
 7023   expand %{
 7024     fcmovF_regU(cop, cr, dst, src);
 7025   %}
 7026 %}
 7027 
 7028 // unsigned version
 7029 instruct fcmovD_regU(cmpOpU cop, eFlagsRegU cr, regD dst, regD src) %{
 7030   predicate (UseSSE&gt;=2);
 7031   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7032   ins_cost(200);
 7033   format %{ &quot;Jn$cop   skip\n\t&quot;
 7034             &quot;MOVSD  $dst,$src\t# float\n&quot;
 7035       &quot;skip:&quot; %}
 7036   ins_encode %{
 7037     Label skip;
 7038     // Invert sense of branch from sense of CMOV
 7039     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 7040     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7041     __ bind(skip);
 7042   %}
 7043   ins_pipe( pipe_slow );
 7044 %}
 7045 
 7046 instruct fcmovD_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, regD dst, regD src) %{
 7047   predicate (UseSSE&gt;=2);
 7048   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7049   ins_cost(200);
 7050   expand %{
 7051     fcmovD_regU(cop, cr, dst, src);
 7052   %}
 7053 %}
 7054 
 7055 instruct cmovL_reg(cmpOp cop, eFlagsReg cr, eRegL dst, eRegL src) %{
 7056   predicate(VM_Version::supports_cmov() );
 7057   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7058   ins_cost(200);
 7059   format %{ &quot;CMOV$cop $dst.lo,$src.lo\n\t&quot;
 7060             &quot;CMOV$cop $dst.hi,$src.hi&quot; %}
 7061   opcode(0x0F,0x40);
 7062   ins_encode( enc_cmov(cop), RegReg_Lo2( dst, src ), enc_cmov(cop), RegReg_Hi2( dst, src ) );
 7063   ins_pipe( pipe_cmov_reg_long );
 7064 %}
 7065 
 7066 instruct cmovL_regU(cmpOpU cop, eFlagsRegU cr, eRegL dst, eRegL src) %{
 7067   predicate(VM_Version::supports_cmov() );
 7068   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7069   ins_cost(200);
 7070   format %{ &quot;CMOV$cop $dst.lo,$src.lo\n\t&quot;
 7071             &quot;CMOV$cop $dst.hi,$src.hi&quot; %}
 7072   opcode(0x0F,0x40);
 7073   ins_encode( enc_cmov(cop), RegReg_Lo2( dst, src ), enc_cmov(cop), RegReg_Hi2( dst, src ) );
 7074   ins_pipe( pipe_cmov_reg_long );
 7075 %}
 7076 
 7077 instruct cmovL_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, eRegL dst, eRegL src) %{
 7078   predicate(VM_Version::supports_cmov() );
 7079   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7080   ins_cost(200);
 7081   expand %{
 7082     cmovL_regU(cop, cr, dst, src);
 7083   %}
 7084 %}
 7085 
 7086 //----------Arithmetic Instructions--------------------------------------------
 7087 //----------Addition Instructions----------------------------------------------
 7088 
 7089 // Integer Addition Instructions
 7090 instruct addI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7091   match(Set dst (AddI dst src));
 7092   effect(KILL cr);
 7093 
 7094   size(2);
 7095   format %{ &quot;ADD    $dst,$src&quot; %}
 7096   opcode(0x03);
 7097   ins_encode( OpcP, RegReg( dst, src) );
 7098   ins_pipe( ialu_reg_reg );
 7099 %}
 7100 
 7101 instruct addI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 7102   match(Set dst (AddI dst src));
 7103   effect(KILL cr);
 7104 
 7105   format %{ &quot;ADD    $dst,$src&quot; %}
 7106   opcode(0x81, 0x00); /* /0 id */
 7107   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7108   ins_pipe( ialu_reg );
 7109 %}
 7110 
 7111 instruct incI_eReg(rRegI dst, immI1 src, eFlagsReg cr) %{
 7112   predicate(UseIncDec);
 7113   match(Set dst (AddI dst src));
 7114   effect(KILL cr);
 7115 
 7116   size(1);
 7117   format %{ &quot;INC    $dst&quot; %}
 7118   opcode(0x40); /*  */
 7119   ins_encode( Opc_plus( primary, dst ) );
 7120   ins_pipe( ialu_reg );
 7121 %}
 7122 
 7123 instruct leaI_eReg_immI(rRegI dst, rRegI src0, immI src1) %{
 7124   match(Set dst (AddI src0 src1));
 7125   ins_cost(110);
 7126 
 7127   format %{ &quot;LEA    $dst,[$src0 + $src1]&quot; %}
 7128   opcode(0x8D); /* 0x8D /r */
 7129   ins_encode( OpcP, RegLea( dst, src0, src1 ) );
 7130   ins_pipe( ialu_reg_reg );
 7131 %}
 7132 
 7133 instruct leaP_eReg_immI(eRegP dst, eRegP src0, immI src1) %{
 7134   match(Set dst (AddP src0 src1));
 7135   ins_cost(110);
 7136 
 7137   format %{ &quot;LEA    $dst,[$src0 + $src1]\t# ptr&quot; %}
 7138   opcode(0x8D); /* 0x8D /r */
 7139   ins_encode( OpcP, RegLea( dst, src0, src1 ) );
 7140   ins_pipe( ialu_reg_reg );
 7141 %}
 7142 
 7143 instruct decI_eReg(rRegI dst, immI_M1 src, eFlagsReg cr) %{
 7144   predicate(UseIncDec);
 7145   match(Set dst (AddI dst src));
 7146   effect(KILL cr);
 7147 
 7148   size(1);
 7149   format %{ &quot;DEC    $dst&quot; %}
 7150   opcode(0x48); /*  */
 7151   ins_encode( Opc_plus( primary, dst ) );
 7152   ins_pipe( ialu_reg );
 7153 %}
 7154 
 7155 instruct addP_eReg(eRegP dst, rRegI src, eFlagsReg cr) %{
 7156   match(Set dst (AddP dst src));
 7157   effect(KILL cr);
 7158 
 7159   size(2);
 7160   format %{ &quot;ADD    $dst,$src&quot; %}
 7161   opcode(0x03);
 7162   ins_encode( OpcP, RegReg( dst, src) );
 7163   ins_pipe( ialu_reg_reg );
 7164 %}
 7165 
 7166 instruct addP_eReg_imm(eRegP dst, immI src, eFlagsReg cr) %{
 7167   match(Set dst (AddP dst src));
 7168   effect(KILL cr);
 7169 
 7170   format %{ &quot;ADD    $dst,$src&quot; %}
 7171   opcode(0x81,0x00); /* Opcode 81 /0 id */
 7172   // ins_encode( RegImm( dst, src) );
 7173   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7174   ins_pipe( ialu_reg );
 7175 %}
 7176 
 7177 instruct addI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 7178   match(Set dst (AddI dst (LoadI src)));
 7179   effect(KILL cr);
 7180 
 7181   ins_cost(125);
 7182   format %{ &quot;ADD    $dst,$src&quot; %}
 7183   opcode(0x03);
 7184   ins_encode( OpcP, RegMem( dst, src) );
 7185   ins_pipe( ialu_reg_mem );
 7186 %}
 7187 
 7188 instruct addI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 7189   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7190   effect(KILL cr);
 7191 
 7192   ins_cost(150);
 7193   format %{ &quot;ADD    $dst,$src&quot; %}
 7194   opcode(0x01);  /* Opcode 01 /r */
 7195   ins_encode( OpcP, RegMem( src, dst ) );
 7196   ins_pipe( ialu_mem_reg );
 7197 %}
 7198 
 7199 // Add Memory with Immediate
 7200 instruct addI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 7201   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7202   effect(KILL cr);
 7203 
 7204   ins_cost(125);
 7205   format %{ &quot;ADD    $dst,$src&quot; %}
 7206   opcode(0x81);               /* Opcode 81 /0 id */
 7207   ins_encode( OpcSE( src ), RMopc_Mem(0x00,dst), Con8or32( src ) );
 7208   ins_pipe( ialu_mem_imm );
 7209 %}
 7210 
 7211 instruct incI_mem(memory dst, immI1 src, eFlagsReg cr) %{
 7212   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7213   effect(KILL cr);
 7214 
 7215   ins_cost(125);
 7216   format %{ &quot;INC    $dst&quot; %}
 7217   opcode(0xFF);               /* Opcode FF /0 */
 7218   ins_encode( OpcP, RMopc_Mem(0x00,dst));
 7219   ins_pipe( ialu_mem_imm );
 7220 %}
 7221 
 7222 instruct decI_mem(memory dst, immI_M1 src, eFlagsReg cr) %{
 7223   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7224   effect(KILL cr);
 7225 
 7226   ins_cost(125);
 7227   format %{ &quot;DEC    $dst&quot; %}
 7228   opcode(0xFF);               /* Opcode FF /1 */
 7229   ins_encode( OpcP, RMopc_Mem(0x01,dst));
 7230   ins_pipe( ialu_mem_imm );
 7231 %}
 7232 
 7233 
 7234 instruct checkCastPP( eRegP dst ) %{
 7235   match(Set dst (CheckCastPP dst));
 7236 
 7237   size(0);
 7238   format %{ &quot;#checkcastPP of $dst&quot; %}
 7239   ins_encode( /*empty encoding*/ );
 7240   ins_pipe( empty );
 7241 %}
 7242 
 7243 instruct castPP( eRegP dst ) %{
 7244   match(Set dst (CastPP dst));
 7245   format %{ &quot;#castPP of $dst&quot; %}
 7246   ins_encode( /*empty encoding*/ );
 7247   ins_pipe( empty );
 7248 %}
 7249 
 7250 instruct castII( rRegI dst ) %{
 7251   match(Set dst (CastII dst));
 7252   format %{ &quot;#castII of $dst&quot; %}
 7253   ins_encode( /*empty encoding*/ );
 7254   ins_cost(0);
 7255   ins_pipe( empty );
 7256 %}
 7257 
 7258 instruct castLL( eRegL dst ) %{
 7259   match(Set dst (CastLL dst));
 7260   format %{ &quot;#castLL of $dst&quot; %}
 7261   ins_encode( /*empty encoding*/ );
 7262   ins_cost(0);
 7263   ins_pipe( empty );
 7264 %}
 7265 
 7266 
 7267 // Load-locked - same as a regular pointer load when used with compare-swap
 7268 instruct loadPLocked(eRegP dst, memory mem) %{
 7269   match(Set dst (LoadPLocked mem));
 7270 
 7271   ins_cost(125);
 7272   format %{ &quot;MOV    $dst,$mem\t# Load ptr. locked&quot; %}
 7273   opcode(0x8B);
 7274   ins_encode( OpcP, RegMem(dst,mem));
 7275   ins_pipe( ialu_reg_mem );
 7276 %}
 7277 
 7278 // Conditional-store of the updated heap-top.
 7279 // Used during allocation of the shared heap.
 7280 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7281 instruct storePConditional( memory heap_top_ptr, eAXRegP oldval, eRegP newval, eFlagsReg cr ) %{
 7282   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7283   // EAX is killed if there is contention, but then it&#39;s also unused.
 7284   // In the common case of no contention, EAX holds the new oop address.
 7285   format %{ &quot;CMPXCHG $heap_top_ptr,$newval\t# If EAX==$heap_top_ptr Then store $newval into $heap_top_ptr&quot; %}
 7286   ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval,heap_top_ptr) );
 7287   ins_pipe( pipe_cmpxchg );
 7288 %}
 7289 
 7290 // Conditional-store of an int value.
 7291 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG on Intel.
 7292 instruct storeIConditional( memory mem, eAXRegI oldval, rRegI newval, eFlagsReg cr ) %{
 7293   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7294   effect(KILL oldval);
 7295   format %{ &quot;CMPXCHG $mem,$newval\t# If EAX==$mem Then store $newval into $mem&quot; %}
 7296   ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval, mem) );
 7297   ins_pipe( pipe_cmpxchg );
 7298 %}
 7299 
 7300 // Conditional-store of a long value.
 7301 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG8 on Intel.
 7302 instruct storeLConditional( memory mem, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7303   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7304   effect(KILL oldval);
 7305   format %{ &quot;XCHG   EBX,ECX\t# correct order for CMPXCHG8 instruction\n\t&quot;
 7306             &quot;CMPXCHG8 $mem,ECX:EBX\t# If EDX:EAX==$mem Then store ECX:EBX into $mem\n\t&quot;
 7307             &quot;XCHG   EBX,ECX&quot;
 7308   %}
 7309   ins_encode %{
 7310     // Note: we need to swap rbx, and rcx before and after the
 7311     //       cmpxchg8 instruction because the instruction uses
 7312     //       rcx as the high order word of the new value to store but
 7313     //       our register encoding uses rbx.
 7314     __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));
 7315     __ lock();
 7316     __ cmpxchg8($mem$$Address);
 7317     __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));
 7318   %}
 7319   ins_pipe( pipe_cmpxchg );
 7320 %}
 7321 
 7322 // No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7323 
 7324 instruct compareAndSwapL( rRegI res, eSIRegP mem_ptr, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7325   predicate(VM_Version::supports_cx8());
 7326   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7327   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7328   effect(KILL cr, KILL oldval);
 7329   format %{ &quot;CMPXCHG8 [$mem_ptr],$newval\t# If EDX:EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7330             &quot;MOV    $res,0\n\t&quot;
 7331             &quot;JNE,s  fail\n\t&quot;
 7332             &quot;MOV    $res,1\n&quot;
 7333           &quot;fail:&quot; %}
 7334   ins_encode( enc_cmpxchg8(mem_ptr),
 7335               enc_flags_ne_to_boolean(res) );
 7336   ins_pipe( pipe_cmpxchg );
 7337 %}
 7338 
 7339 instruct compareAndSwapP( rRegI res,  pRegP mem_ptr, eAXRegP oldval, eCXRegP newval, eFlagsReg cr) %{
 7340   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7341   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7342   effect(KILL cr, KILL oldval);
 7343   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7344             &quot;MOV    $res,0\n\t&quot;
 7345             &quot;JNE,s  fail\n\t&quot;
 7346             &quot;MOV    $res,1\n&quot;
 7347           &quot;fail:&quot; %}
 7348   ins_encode( enc_cmpxchg(mem_ptr), enc_flags_ne_to_boolean(res) );
 7349   ins_pipe( pipe_cmpxchg );
 7350 %}
 7351 
 7352 instruct compareAndSwapB( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr ) %{
 7353   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7354   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7355   effect(KILL cr, KILL oldval);
 7356   format %{ &quot;CMPXCHGB [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7357             &quot;MOV    $res,0\n\t&quot;
 7358             &quot;JNE,s  fail\n\t&quot;
 7359             &quot;MOV    $res,1\n&quot;
 7360           &quot;fail:&quot; %}
 7361   ins_encode( enc_cmpxchgb(mem_ptr),
 7362               enc_flags_ne_to_boolean(res) );
 7363   ins_pipe( pipe_cmpxchg );
 7364 %}
 7365 
 7366 instruct compareAndSwapS( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr ) %{
 7367   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7368   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7369   effect(KILL cr, KILL oldval);
 7370   format %{ &quot;CMPXCHGW [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7371             &quot;MOV    $res,0\n\t&quot;
 7372             &quot;JNE,s  fail\n\t&quot;
 7373             &quot;MOV    $res,1\n&quot;
 7374           &quot;fail:&quot; %}
 7375   ins_encode( enc_cmpxchgw(mem_ptr),
 7376               enc_flags_ne_to_boolean(res) );
 7377   ins_pipe( pipe_cmpxchg );
 7378 %}
 7379 
 7380 instruct compareAndSwapI( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7381   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7382   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7383   effect(KILL cr, KILL oldval);
 7384   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7385             &quot;MOV    $res,0\n\t&quot;
 7386             &quot;JNE,s  fail\n\t&quot;
 7387             &quot;MOV    $res,1\n&quot;
 7388           &quot;fail:&quot; %}
 7389   ins_encode( enc_cmpxchg(mem_ptr), enc_flags_ne_to_boolean(res) );
 7390   ins_pipe( pipe_cmpxchg );
 7391 %}
 7392 
 7393 instruct compareAndExchangeL( eSIRegP mem_ptr, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7394   predicate(VM_Version::supports_cx8());
 7395   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7396   effect(KILL cr);
 7397   format %{ &quot;CMPXCHG8 [$mem_ptr],$newval\t# If EDX:EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7398   ins_encode( enc_cmpxchg8(mem_ptr) );
 7399   ins_pipe( pipe_cmpxchg );
 7400 %}
 7401 
 7402 instruct compareAndExchangeP( pRegP mem_ptr, eAXRegP oldval, eCXRegP newval, eFlagsReg cr) %{
 7403   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7404   effect(KILL cr);
 7405   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7406   ins_encode( enc_cmpxchg(mem_ptr) );
 7407   ins_pipe( pipe_cmpxchg );
 7408 %}
 7409 
 7410 instruct compareAndExchangeB( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7411   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7412   effect(KILL cr);
 7413   format %{ &quot;CMPXCHGB [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7414   ins_encode( enc_cmpxchgb(mem_ptr) );
 7415   ins_pipe( pipe_cmpxchg );
 7416 %}
 7417 
 7418 instruct compareAndExchangeS( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7419   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7420   effect(KILL cr);
 7421   format %{ &quot;CMPXCHGW [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7422   ins_encode( enc_cmpxchgw(mem_ptr) );
 7423   ins_pipe( pipe_cmpxchg );
 7424 %}
 7425 
 7426 instruct compareAndExchangeI( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7427   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7428   effect(KILL cr);
 7429   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7430   ins_encode( enc_cmpxchg(mem_ptr) );
 7431   ins_pipe( pipe_cmpxchg );
 7432 %}
 7433 
 7434 instruct xaddB_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7435   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7436   match(Set dummy (GetAndAddB mem add));
 7437   effect(KILL cr);
 7438   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7439   ins_encode %{
 7440     __ lock();
 7441     __ addb($mem$$Address, $add$$constant);
 7442   %}
 7443   ins_pipe( pipe_cmpxchg );
 7444 %}
 7445 
 7446 // Important to match to xRegI: only 8-bit regs.
 7447 instruct xaddB( memory mem, xRegI newval, eFlagsReg cr) %{
 7448   match(Set newval (GetAndAddB mem newval));
 7449   effect(KILL cr);
 7450   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7451   ins_encode %{
 7452     __ lock();
 7453     __ xaddb($mem$$Address, $newval$$Register);
 7454   %}
 7455   ins_pipe( pipe_cmpxchg );
 7456 %}
 7457 
 7458 instruct xaddS_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7459   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7460   match(Set dummy (GetAndAddS mem add));
 7461   effect(KILL cr);
 7462   format %{ &quot;ADDS  [$mem],$add&quot; %}
 7463   ins_encode %{
 7464     __ lock();
 7465     __ addw($mem$$Address, $add$$constant);
 7466   %}
 7467   ins_pipe( pipe_cmpxchg );
 7468 %}
 7469 
 7470 instruct xaddS( memory mem, rRegI newval, eFlagsReg cr) %{
 7471   match(Set newval (GetAndAddS mem newval));
 7472   effect(KILL cr);
 7473   format %{ &quot;XADDS  [$mem],$newval&quot; %}
 7474   ins_encode %{
 7475     __ lock();
 7476     __ xaddw($mem$$Address, $newval$$Register);
 7477   %}
 7478   ins_pipe( pipe_cmpxchg );
 7479 %}
 7480 
 7481 instruct xaddI_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7482   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7483   match(Set dummy (GetAndAddI mem add));
 7484   effect(KILL cr);
 7485   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7486   ins_encode %{
 7487     __ lock();
 7488     __ addl($mem$$Address, $add$$constant);
 7489   %}
 7490   ins_pipe( pipe_cmpxchg );
 7491 %}
 7492 
 7493 instruct xaddI( memory mem, rRegI newval, eFlagsReg cr) %{
 7494   match(Set newval (GetAndAddI mem newval));
 7495   effect(KILL cr);
 7496   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7497   ins_encode %{
 7498     __ lock();
 7499     __ xaddl($mem$$Address, $newval$$Register);
 7500   %}
 7501   ins_pipe( pipe_cmpxchg );
 7502 %}
 7503 
 7504 // Important to match to xRegI: only 8-bit regs.
 7505 instruct xchgB( memory mem, xRegI newval) %{
 7506   match(Set newval (GetAndSetB mem newval));
 7507   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7508   ins_encode %{
 7509     __ xchgb($newval$$Register, $mem$$Address);
 7510   %}
 7511   ins_pipe( pipe_cmpxchg );
 7512 %}
 7513 
 7514 instruct xchgS( memory mem, rRegI newval) %{
 7515   match(Set newval (GetAndSetS mem newval));
 7516   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7517   ins_encode %{
 7518     __ xchgw($newval$$Register, $mem$$Address);
 7519   %}
 7520   ins_pipe( pipe_cmpxchg );
 7521 %}
 7522 
 7523 instruct xchgI( memory mem, rRegI newval) %{
 7524   match(Set newval (GetAndSetI mem newval));
 7525   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7526   ins_encode %{
 7527     __ xchgl($newval$$Register, $mem$$Address);
 7528   %}
 7529   ins_pipe( pipe_cmpxchg );
 7530 %}
 7531 
 7532 instruct xchgP( memory mem, pRegP newval) %{
 7533   match(Set newval (GetAndSetP mem newval));
 7534   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7535   ins_encode %{
 7536     __ xchgl($newval$$Register, $mem$$Address);
 7537   %}
 7538   ins_pipe( pipe_cmpxchg );
 7539 %}
 7540 
 7541 //----------Subtraction Instructions-------------------------------------------
 7542 
 7543 // Integer Subtraction Instructions
 7544 instruct subI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7545   match(Set dst (SubI dst src));
 7546   effect(KILL cr);
 7547 
 7548   size(2);
 7549   format %{ &quot;SUB    $dst,$src&quot; %}
 7550   opcode(0x2B);
 7551   ins_encode( OpcP, RegReg( dst, src) );
 7552   ins_pipe( ialu_reg_reg );
 7553 %}
 7554 
 7555 instruct subI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 7556   match(Set dst (SubI dst src));
 7557   effect(KILL cr);
 7558 
 7559   format %{ &quot;SUB    $dst,$src&quot; %}
 7560   opcode(0x81,0x05);  /* Opcode 81 /5 */
 7561   // ins_encode( RegImm( dst, src) );
 7562   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7563   ins_pipe( ialu_reg );
 7564 %}
 7565 
 7566 instruct subI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 7567   match(Set dst (SubI dst (LoadI src)));
 7568   effect(KILL cr);
 7569 
 7570   ins_cost(125);
 7571   format %{ &quot;SUB    $dst,$src&quot; %}
 7572   opcode(0x2B);
 7573   ins_encode( OpcP, RegMem( dst, src) );
 7574   ins_pipe( ialu_reg_mem );
 7575 %}
 7576 
 7577 instruct subI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 7578   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 7579   effect(KILL cr);
 7580 
 7581   ins_cost(150);
 7582   format %{ &quot;SUB    $dst,$src&quot; %}
 7583   opcode(0x29);  /* Opcode 29 /r */
 7584   ins_encode( OpcP, RegMem( src, dst ) );
 7585   ins_pipe( ialu_mem_reg );
 7586 %}
 7587 
 7588 // Subtract from a pointer
 7589 instruct subP_eReg(eRegP dst, rRegI src, immI0 zero, eFlagsReg cr) %{
 7590   match(Set dst (AddP dst (SubI zero src)));
 7591   effect(KILL cr);
 7592 
 7593   size(2);
 7594   format %{ &quot;SUB    $dst,$src&quot; %}
 7595   opcode(0x2B);
 7596   ins_encode( OpcP, RegReg( dst, src) );
 7597   ins_pipe( ialu_reg_reg );
 7598 %}
 7599 
 7600 instruct negI_eReg(rRegI dst, immI0 zero, eFlagsReg cr) %{
 7601   match(Set dst (SubI zero dst));
 7602   effect(KILL cr);
 7603 
 7604   size(2);
 7605   format %{ &quot;NEG    $dst&quot; %}
 7606   opcode(0xF7,0x03);  // Opcode F7 /3
 7607   ins_encode( OpcP, RegOpc( dst ) );
 7608   ins_pipe( ialu_reg );
 7609 %}
 7610 
 7611 //----------Multiplication/Division Instructions-------------------------------
 7612 // Integer Multiplication Instructions
 7613 // Multiply Register
 7614 instruct mulI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7615   match(Set dst (MulI dst src));
 7616   effect(KILL cr);
 7617 
 7618   size(3);
 7619   ins_cost(300);
 7620   format %{ &quot;IMUL   $dst,$src&quot; %}
 7621   opcode(0xAF, 0x0F);
 7622   ins_encode( OpcS, OpcP, RegReg( dst, src) );
 7623   ins_pipe( ialu_reg_reg_alu0 );
 7624 %}
 7625 
 7626 // Multiply 32-bit Immediate
 7627 instruct mulI_eReg_imm(rRegI dst, rRegI src, immI imm, eFlagsReg cr) %{
 7628   match(Set dst (MulI src imm));
 7629   effect(KILL cr);
 7630 
 7631   ins_cost(300);
 7632   format %{ &quot;IMUL   $dst,$src,$imm&quot; %}
 7633   opcode(0x69);  /* 69 /r id */
 7634   ins_encode( OpcSE(imm), RegReg( dst, src ), Con8or32( imm ) );
 7635   ins_pipe( ialu_reg_reg_alu0 );
 7636 %}
 7637 
 7638 instruct loadConL_low_only(eADXRegL_low_only dst, immL32 src, eFlagsReg cr) %{
 7639   match(Set dst src);
 7640   effect(KILL cr);
 7641 
 7642   // Note that this is artificially increased to make it more expensive than loadConL
 7643   ins_cost(250);
 7644   format %{ &quot;MOV    EAX,$src\t// low word only&quot; %}
 7645   opcode(0xB8);
 7646   ins_encode( LdImmL_Lo(dst, src) );
 7647   ins_pipe( ialu_reg_fat );
 7648 %}
 7649 
 7650 // Multiply by 32-bit Immediate, taking the shifted high order results
 7651 //  (special case for shift by 32)
 7652 instruct mulI_imm_high(eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32 cnt, eFlagsReg cr) %{
 7653   match(Set dst (ConvL2I (RShiftL (MulL (ConvI2L src1) src2) cnt)));
 7654   predicate( _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;Opcode() == Op_ConL &amp;&amp;
 7655              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &gt;= min_jint &amp;&amp;
 7656              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &lt;= max_jint );
 7657   effect(USE src1, KILL cr);
 7658 
 7659   // Note that this is adjusted by 150 to compensate for the overcosting of loadConL_low_only
 7660   ins_cost(0*100 + 1*400 - 150);
 7661   format %{ &quot;IMUL   EDX:EAX,$src1&quot; %}
 7662   ins_encode( multiply_con_and_shift_high( dst, src1, src2, cnt, cr ) );
 7663   ins_pipe( pipe_slow );
 7664 %}
 7665 
 7666 // Multiply by 32-bit Immediate, taking the shifted high order results
 7667 instruct mulI_imm_RShift_high(eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32_63 cnt, eFlagsReg cr) %{
 7668   match(Set dst (ConvL2I (RShiftL (MulL (ConvI2L src1) src2) cnt)));
 7669   predicate( _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;Opcode() == Op_ConL &amp;&amp;
 7670              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &gt;= min_jint &amp;&amp;
 7671              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &lt;= max_jint );
 7672   effect(USE src1, KILL cr);
 7673 
 7674   // Note that this is adjusted by 150 to compensate for the overcosting of loadConL_low_only
 7675   ins_cost(1*100 + 1*400 - 150);
 7676   format %{ &quot;IMUL   EDX:EAX,$src1\n\t&quot;
 7677             &quot;SAR    EDX,$cnt-32&quot; %}
 7678   ins_encode( multiply_con_and_shift_high( dst, src1, src2, cnt, cr ) );
 7679   ins_pipe( pipe_slow );
 7680 %}
 7681 
 7682 // Multiply Memory 32-bit Immediate
 7683 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, eFlagsReg cr) %{
 7684   match(Set dst (MulI (LoadI src) imm));
 7685   effect(KILL cr);
 7686 
 7687   ins_cost(300);
 7688   format %{ &quot;IMUL   $dst,$src,$imm&quot; %}
 7689   opcode(0x69);  /* 69 /r id */
 7690   ins_encode( OpcSE(imm), RegMem( dst, src ), Con8or32( imm ) );
 7691   ins_pipe( ialu_reg_mem_alu0 );
 7692 %}
 7693 
 7694 // Multiply Memory
 7695 instruct mulI(rRegI dst, memory src, eFlagsReg cr) %{
 7696   match(Set dst (MulI dst (LoadI src)));
 7697   effect(KILL cr);
 7698 
 7699   ins_cost(350);
 7700   format %{ &quot;IMUL   $dst,$src&quot; %}
 7701   opcode(0xAF, 0x0F);
 7702   ins_encode( OpcS, OpcP, RegMem( dst, src) );
 7703   ins_pipe( ialu_reg_mem_alu0 );
 7704 %}
 7705 
 7706 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, eFlagsReg cr)
 7707 %{
 7708   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 7709   effect(KILL cr, KILL src2);
 7710 
 7711   expand %{ mulI_eReg(dst, src1, cr);
 7712            mulI_eReg(src2, src3, cr);
 7713            addI_eReg(dst, src2, cr); %}
 7714 %}
 7715 
 7716 // Multiply Register Int to Long
 7717 instruct mulI2L(eADXRegL dst, eAXRegI src, nadxRegI src1, eFlagsReg flags) %{
 7718   // Basic Idea: long = (long)int * (long)int
 7719   match(Set dst (MulL (ConvI2L src) (ConvI2L src1)));
 7720   effect(DEF dst, USE src, USE src1, KILL flags);
 7721 
 7722   ins_cost(300);
 7723   format %{ &quot;IMUL   $dst,$src1&quot; %}
 7724 
 7725   ins_encode( long_int_multiply( dst, src1 ) );
 7726   ins_pipe( ialu_reg_reg_alu0 );
 7727 %}
 7728 
 7729 instruct mulIS_eReg(eADXRegL dst, immL_32bits mask, eFlagsReg flags, eAXRegI src, nadxRegI src1) %{
 7730   // Basic Idea:  long = (int &amp; 0xffffffffL) * (int &amp; 0xffffffffL)
 7731   match(Set dst (MulL (AndL (ConvI2L src) mask) (AndL (ConvI2L src1) mask)));
 7732   effect(KILL flags);
 7733 
 7734   ins_cost(300);
 7735   format %{ &quot;MUL    $dst,$src1&quot; %}
 7736 
 7737   ins_encode( long_uint_multiply(dst, src1) );
 7738   ins_pipe( ialu_reg_reg_alu0 );
 7739 %}
 7740 
 7741 // Multiply Register Long
 7742 instruct mulL_eReg(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7743   match(Set dst (MulL dst src));
 7744   effect(KILL cr, TEMP tmp);
 7745   ins_cost(4*100+3*400);
 7746 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7747 //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 7748   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
 7749             &quot;IMUL   $tmp,EDX\n\t&quot;
 7750             &quot;MOV    EDX,$src.hi\n\t&quot;
 7751             &quot;IMUL   EDX,EAX\n\t&quot;
 7752             &quot;ADD    $tmp,EDX\n\t&quot;
 7753             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7754             &quot;ADD    EDX,$tmp&quot; %}
 7755   ins_encode( long_multiply( dst, src, tmp ) );
 7756   ins_pipe( pipe_slow );
 7757 %}
 7758 
 7759 // Multiply Register Long where the left operand&#39;s high 32 bits are zero
 7760 instruct mulL_eReg_lhi0(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7761   predicate(is_operand_hi32_zero(n-&gt;in(1)));
 7762   match(Set dst (MulL dst src));
 7763   effect(KILL cr, TEMP tmp);
 7764   ins_cost(2*100+2*400);
 7765 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7766 //             hi(result) = hi(x_lo * y_lo) + lo(x_lo * y_hi) where lo(x_hi * y_lo) = 0 because x_hi = 0
 7767   format %{ &quot;MOV    $tmp,$src.hi\n\t&quot;
 7768             &quot;IMUL   $tmp,EAX\n\t&quot;
 7769             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7770             &quot;ADD    EDX,$tmp&quot; %}
 7771   ins_encode %{
 7772     __ movl($tmp$$Register, HIGH_FROM_LOW($src$$Register));
 7773     __ imull($tmp$$Register, rax);
 7774     __ mull($src$$Register);
 7775     __ addl(rdx, $tmp$$Register);
 7776   %}
 7777   ins_pipe( pipe_slow );
 7778 %}
 7779 
 7780 // Multiply Register Long where the right operand&#39;s high 32 bits are zero
 7781 instruct mulL_eReg_rhi0(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7782   predicate(is_operand_hi32_zero(n-&gt;in(2)));
 7783   match(Set dst (MulL dst src));
 7784   effect(KILL cr, TEMP tmp);
 7785   ins_cost(2*100+2*400);
 7786 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7787 //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) where lo(x_lo * y_hi) = 0 because y_hi = 0
 7788   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
 7789             &quot;IMUL   $tmp,EDX\n\t&quot;
 7790             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7791             &quot;ADD    EDX,$tmp&quot; %}
 7792   ins_encode %{
 7793     __ movl($tmp$$Register, $src$$Register);
 7794     __ imull($tmp$$Register, rdx);
 7795     __ mull($src$$Register);
 7796     __ addl(rdx, $tmp$$Register);
 7797   %}
 7798   ins_pipe( pipe_slow );
 7799 %}
 7800 
 7801 // Multiply Register Long where the left and the right operands&#39; high 32 bits are zero
 7802 instruct mulL_eReg_hi0(eADXRegL dst, eRegL src, eFlagsReg cr) %{
 7803   predicate(is_operand_hi32_zero(n-&gt;in(1)) &amp;&amp; is_operand_hi32_zero(n-&gt;in(2)));
 7804   match(Set dst (MulL dst src));
 7805   effect(KILL cr);
 7806   ins_cost(1*400);
 7807 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7808 //             hi(result) = hi(x_lo * y_lo) where lo(x_hi * y_lo) = 0 and lo(x_lo * y_hi) = 0 because x_hi = 0 and y_hi = 0
 7809   format %{ &quot;MUL    EDX:EAX,$src.lo\n\t&quot; %}
 7810   ins_encode %{
 7811     __ mull($src$$Register);
 7812   %}
 7813   ins_pipe( pipe_slow );
 7814 %}
 7815 
 7816 // Multiply Register Long by small constant
 7817 instruct mulL_eReg_con(eADXRegL dst, immL_127 src, rRegI tmp, eFlagsReg cr) %{
 7818   match(Set dst (MulL dst src));
 7819   effect(KILL cr, TEMP tmp);
 7820   ins_cost(2*100+2*400);
 7821   size(12);
 7822 // Basic idea: lo(result) = lo(src * EAX)
 7823 //             hi(result) = hi(src * EAX) + lo(src * EDX)
 7824   format %{ &quot;IMUL   $tmp,EDX,$src\n\t&quot;
 7825             &quot;MOV    EDX,$src\n\t&quot;
 7826             &quot;MUL    EDX\t# EDX*EAX -&gt; EDX:EAX\n\t&quot;
 7827             &quot;ADD    EDX,$tmp&quot; %}
 7828   ins_encode( long_multiply_con( dst, src, tmp ) );
 7829   ins_pipe( pipe_slow );
 7830 %}
 7831 
 7832 // Integer DIV with Register
 7833 instruct divI_eReg(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{
 7834   match(Set rax (DivI rax div));
 7835   effect(KILL rdx, KILL cr);
 7836   size(26);
 7837   ins_cost(30*100+10*100);
 7838   format %{ &quot;CMP    EAX,0x80000000\n\t&quot;
 7839             &quot;JNE,s  normal\n\t&quot;
 7840             &quot;XOR    EDX,EDX\n\t&quot;
 7841             &quot;CMP    ECX,-1\n\t&quot;
 7842             &quot;JE,s   done\n&quot;
 7843     &quot;normal: CDQ\n\t&quot;
 7844             &quot;IDIV   $div\n\t&quot;
 7845     &quot;done:&quot;        %}
 7846   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7847   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7848   ins_pipe( ialu_reg_reg_alu0 );
 7849 %}
 7850 
 7851 // Divide Register Long
 7852 instruct divL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{
 7853   match(Set dst (DivL src1 src2));
 7854   effect( KILL cr, KILL cx, KILL bx );
 7855   ins_cost(10000);
 7856   format %{ &quot;PUSH   $src1.hi\n\t&quot;
 7857             &quot;PUSH   $src1.lo\n\t&quot;
 7858             &quot;PUSH   $src2.hi\n\t&quot;
 7859             &quot;PUSH   $src2.lo\n\t&quot;
 7860             &quot;CALL   SharedRuntime::ldiv\n\t&quot;
 7861             &quot;ADD    ESP,16&quot; %}
 7862   ins_encode( long_div(src1,src2) );
 7863   ins_pipe( pipe_slow );
 7864 %}
 7865 
 7866 // Integer DIVMOD with Register, both quotient and mod results
 7867 instruct divModI_eReg_divmod(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{
 7868   match(DivModI rax div);
 7869   effect(KILL cr);
 7870   size(26);
 7871   ins_cost(30*100+10*100);
 7872   format %{ &quot;CMP    EAX,0x80000000\n\t&quot;
 7873             &quot;JNE,s  normal\n\t&quot;
 7874             &quot;XOR    EDX,EDX\n\t&quot;
 7875             &quot;CMP    ECX,-1\n\t&quot;
 7876             &quot;JE,s   done\n&quot;
 7877     &quot;normal: CDQ\n\t&quot;
 7878             &quot;IDIV   $div\n\t&quot;
 7879     &quot;done:&quot;        %}
 7880   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7881   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7882   ins_pipe( pipe_slow );
 7883 %}
 7884 
 7885 // Integer MOD with Register
 7886 instruct modI_eReg(eDXRegI rdx, eAXRegI rax, eCXRegI div, eFlagsReg cr) %{
 7887   match(Set rdx (ModI rax div));
 7888   effect(KILL rax, KILL cr);
 7889 
 7890   size(26);
 7891   ins_cost(300);
 7892   format %{ &quot;CDQ\n\t&quot;
 7893             &quot;IDIV   $div&quot; %}
 7894   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7895   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7896   ins_pipe( ialu_reg_reg_alu0 );
 7897 %}
 7898 
 7899 // Remainder Register Long
 7900 instruct modL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{
 7901   match(Set dst (ModL src1 src2));
 7902   effect( KILL cr, KILL cx, KILL bx );
 7903   ins_cost(10000);
 7904   format %{ &quot;PUSH   $src1.hi\n\t&quot;
 7905             &quot;PUSH   $src1.lo\n\t&quot;
 7906             &quot;PUSH   $src2.hi\n\t&quot;
 7907             &quot;PUSH   $src2.lo\n\t&quot;
 7908             &quot;CALL   SharedRuntime::lrem\n\t&quot;
 7909             &quot;ADD    ESP,16&quot; %}
 7910   ins_encode( long_mod(src1,src2) );
 7911   ins_pipe( pipe_slow );
 7912 %}
 7913 
 7914 // Divide Register Long (no special case since divisor != -1)
 7915 instruct divL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{
 7916   match(Set dst (DivL dst imm));
 7917   effect( TEMP tmp, TEMP tmp2, KILL cr );
 7918   ins_cost(1000);
 7919   format %{ &quot;MOV    $tmp,abs($imm) # ldiv EDX:EAX,$imm\n\t&quot;
 7920             &quot;XOR    $tmp2,$tmp2\n\t&quot;
 7921             &quot;CMP    $tmp,EDX\n\t&quot;
 7922             &quot;JA,s   fast\n\t&quot;
 7923             &quot;MOV    $tmp2,EAX\n\t&quot;
 7924             &quot;MOV    EAX,EDX\n\t&quot;
 7925             &quot;MOV    EDX,0\n\t&quot;
 7926             &quot;JLE,s  pos\n\t&quot;
 7927             &quot;LNEG   EAX : $tmp2\n\t&quot;
 7928             &quot;DIV    $tmp # unsigned division\n\t&quot;
 7929             &quot;XCHG   EAX,$tmp2\n\t&quot;
 7930             &quot;DIV    $tmp\n\t&quot;
 7931             &quot;LNEG   $tmp2 : EAX\n\t&quot;
 7932             &quot;JMP,s  done\n&quot;
 7933     &quot;pos:\n\t&quot;
 7934             &quot;DIV    $tmp\n\t&quot;
 7935             &quot;XCHG   EAX,$tmp2\n&quot;
 7936     &quot;fast:\n\t&quot;
 7937             &quot;DIV    $tmp\n&quot;
 7938     &quot;done:\n\t&quot;
 7939             &quot;MOV    EDX,$tmp2\n\t&quot;
 7940             &quot;NEG    EDX:EAX # if $imm &lt; 0&quot; %}
 7941   ins_encode %{
 7942     int con = (int)$imm$$constant;
 7943     assert(con != 0 &amp;&amp; con != -1 &amp;&amp; con != min_jint, &quot;wrong divisor&quot;);
 7944     int pcon = (con &gt; 0) ? con : -con;
 7945     Label Lfast, Lpos, Ldone;
 7946 
 7947     __ movl($tmp$$Register, pcon);
 7948     __ xorl($tmp2$$Register,$tmp2$$Register);
 7949     __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));
 7950     __ jccb(Assembler::above, Lfast); // result fits into 32 bit
 7951 
 7952     __ movl($tmp2$$Register, $dst$$Register); // save
 7953     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 7954     __ movl(HIGH_FROM_LOW($dst$$Register),0); // preserve flags
 7955     __ jccb(Assembler::lessEqual, Lpos); // result is positive
 7956 
 7957     // Negative dividend.
 7958     // convert value to positive to use unsigned division
 7959     __ lneg($dst$$Register, $tmp2$$Register);
 7960     __ divl($tmp$$Register);
 7961     __ xchgl($dst$$Register, $tmp2$$Register);
 7962     __ divl($tmp$$Register);
 7963     // revert result back to negative
 7964     __ lneg($tmp2$$Register, $dst$$Register);
 7965     __ jmpb(Ldone);
 7966 
 7967     __ bind(Lpos);
 7968     __ divl($tmp$$Register); // Use unsigned division
 7969     __ xchgl($dst$$Register, $tmp2$$Register);
 7970     // Fallthrow for final divide, tmp2 has 32 bit hi result
 7971 
 7972     __ bind(Lfast);
 7973     // fast path: src is positive
 7974     __ divl($tmp$$Register); // Use unsigned division
 7975 
 7976     __ bind(Ldone);
 7977     __ movl(HIGH_FROM_LOW($dst$$Register),$tmp2$$Register);
 7978     if (con &lt; 0) {
 7979       __ lneg(HIGH_FROM_LOW($dst$$Register), $dst$$Register);
 7980     }
 7981   %}
 7982   ins_pipe( pipe_slow );
 7983 %}
 7984 
 7985 // Remainder Register Long (remainder fit into 32 bits)
 7986 instruct modL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{
 7987   match(Set dst (ModL dst imm));
 7988   effect( TEMP tmp, TEMP tmp2, KILL cr );
 7989   ins_cost(1000);
 7990   format %{ &quot;MOV    $tmp,abs($imm) # lrem EDX:EAX,$imm\n\t&quot;
 7991             &quot;CMP    $tmp,EDX\n\t&quot;
 7992             &quot;JA,s   fast\n\t&quot;
 7993             &quot;MOV    $tmp2,EAX\n\t&quot;
 7994             &quot;MOV    EAX,EDX\n\t&quot;
 7995             &quot;MOV    EDX,0\n\t&quot;
 7996             &quot;JLE,s  pos\n\t&quot;
 7997             &quot;LNEG   EAX : $tmp2\n\t&quot;
 7998             &quot;DIV    $tmp # unsigned division\n\t&quot;
 7999             &quot;MOV    EAX,$tmp2\n\t&quot;
 8000             &quot;DIV    $tmp\n\t&quot;
 8001             &quot;NEG    EDX\n\t&quot;
 8002             &quot;JMP,s  done\n&quot;
 8003     &quot;pos:\n\t&quot;
 8004             &quot;DIV    $tmp\n\t&quot;
 8005             &quot;MOV    EAX,$tmp2\n&quot;
 8006     &quot;fast:\n\t&quot;
 8007             &quot;DIV    $tmp\n&quot;
 8008     &quot;done:\n\t&quot;
 8009             &quot;MOV    EAX,EDX\n\t&quot;
 8010             &quot;SAR    EDX,31\n\t&quot; %}
 8011   ins_encode %{
 8012     int con = (int)$imm$$constant;
 8013     assert(con != 0 &amp;&amp; con != -1 &amp;&amp; con != min_jint, &quot;wrong divisor&quot;);
 8014     int pcon = (con &gt; 0) ? con : -con;
 8015     Label  Lfast, Lpos, Ldone;
 8016 
 8017     __ movl($tmp$$Register, pcon);
 8018     __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));
 8019     __ jccb(Assembler::above, Lfast); // src is positive and result fits into 32 bit
 8020 
 8021     __ movl($tmp2$$Register, $dst$$Register); // save
 8022     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 8023     __ movl(HIGH_FROM_LOW($dst$$Register),0); // preserve flags
 8024     __ jccb(Assembler::lessEqual, Lpos); // result is positive
 8025 
 8026     // Negative dividend.
 8027     // convert value to positive to use unsigned division
 8028     __ lneg($dst$$Register, $tmp2$$Register);
 8029     __ divl($tmp$$Register);
 8030     __ movl($dst$$Register, $tmp2$$Register);
 8031     __ divl($tmp$$Register);
 8032     // revert remainder back to negative
 8033     __ negl(HIGH_FROM_LOW($dst$$Register));
 8034     __ jmpb(Ldone);
 8035 
 8036     __ bind(Lpos);
 8037     __ divl($tmp$$Register);
 8038     __ movl($dst$$Register, $tmp2$$Register);
 8039 
 8040     __ bind(Lfast);
 8041     // fast path: src is positive
 8042     __ divl($tmp$$Register);
 8043 
 8044     __ bind(Ldone);
 8045     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 8046     __ sarl(HIGH_FROM_LOW($dst$$Register), 31); // result sign
 8047 
 8048   %}
 8049   ins_pipe( pipe_slow );
 8050 %}
 8051 
 8052 // Integer Shift Instructions
 8053 // Shift Left by one
 8054 instruct shlI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8055   match(Set dst (LShiftI dst shift));
 8056   effect(KILL cr);
 8057 
 8058   size(2);
 8059   format %{ &quot;SHL    $dst,$shift&quot; %}
 8060   opcode(0xD1, 0x4);  /* D1 /4 */
 8061   ins_encode( OpcP, RegOpc( dst ) );
 8062   ins_pipe( ialu_reg );
 8063 %}
 8064 
 8065 // Shift Left by 8-bit immediate
 8066 instruct salI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8067   match(Set dst (LShiftI dst shift));
 8068   effect(KILL cr);
 8069 
 8070   size(3);
 8071   format %{ &quot;SHL    $dst,$shift&quot; %}
 8072   opcode(0xC1, 0x4);  /* C1 /4 ib */
 8073   ins_encode( RegOpcImm( dst, shift) );
 8074   ins_pipe( ialu_reg );
 8075 %}
 8076 
 8077 // Shift Left by variable
 8078 instruct salI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8079   match(Set dst (LShiftI dst shift));
 8080   effect(KILL cr);
 8081 
 8082   size(2);
 8083   format %{ &quot;SHL    $dst,$shift&quot; %}
 8084   opcode(0xD3, 0x4);  /* D3 /4 */
 8085   ins_encode( OpcP, RegOpc( dst ) );
 8086   ins_pipe( ialu_reg_reg );
 8087 %}
 8088 
 8089 // Arithmetic shift right by one
 8090 instruct sarI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8091   match(Set dst (RShiftI dst shift));
 8092   effect(KILL cr);
 8093 
 8094   size(2);
 8095   format %{ &quot;SAR    $dst,$shift&quot; %}
 8096   opcode(0xD1, 0x7);  /* D1 /7 */
 8097   ins_encode( OpcP, RegOpc( dst ) );
 8098   ins_pipe( ialu_reg );
 8099 %}
 8100 
 8101 // Arithmetic shift right by one
 8102 instruct sarI_mem_1(memory dst, immI1 shift, eFlagsReg cr) %{
 8103   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8104   effect(KILL cr);
 8105   format %{ &quot;SAR    $dst,$shift&quot; %}
 8106   opcode(0xD1, 0x7);  /* D1 /7 */
 8107   ins_encode( OpcP, RMopc_Mem(secondary,dst) );
 8108   ins_pipe( ialu_mem_imm );
 8109 %}
 8110 
 8111 // Arithmetic Shift Right by 8-bit immediate
 8112 instruct sarI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8113   match(Set dst (RShiftI dst shift));
 8114   effect(KILL cr);
 8115 
 8116   size(3);
 8117   format %{ &quot;SAR    $dst,$shift&quot; %}
 8118   opcode(0xC1, 0x7);  /* C1 /7 ib */
 8119   ins_encode( RegOpcImm( dst, shift ) );
 8120   ins_pipe( ialu_mem_imm );
 8121 %}
 8122 
 8123 // Arithmetic Shift Right by 8-bit immediate
 8124 instruct sarI_mem_imm(memory dst, immI8 shift, eFlagsReg cr) %{
 8125   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8126   effect(KILL cr);
 8127 
 8128   format %{ &quot;SAR    $dst,$shift&quot; %}
 8129   opcode(0xC1, 0x7);  /* C1 /7 ib */
 8130   ins_encode( OpcP, RMopc_Mem(secondary, dst ), Con8or32( shift ) );
 8131   ins_pipe( ialu_mem_imm );
 8132 %}
 8133 
 8134 // Arithmetic Shift Right by variable
 8135 instruct sarI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8136   match(Set dst (RShiftI dst shift));
 8137   effect(KILL cr);
 8138 
 8139   size(2);
 8140   format %{ &quot;SAR    $dst,$shift&quot; %}
 8141   opcode(0xD3, 0x7);  /* D3 /7 */
 8142   ins_encode( OpcP, RegOpc( dst ) );
 8143   ins_pipe( ialu_reg_reg );
 8144 %}
 8145 
 8146 // Logical shift right by one
 8147 instruct shrI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8148   match(Set dst (URShiftI dst shift));
 8149   effect(KILL cr);
 8150 
 8151   size(2);
 8152   format %{ &quot;SHR    $dst,$shift&quot; %}
 8153   opcode(0xD1, 0x5);  /* D1 /5 */
 8154   ins_encode( OpcP, RegOpc( dst ) );
 8155   ins_pipe( ialu_reg );
 8156 %}
 8157 
 8158 // Logical Shift Right by 8-bit immediate
 8159 instruct shrI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8160   match(Set dst (URShiftI dst shift));
 8161   effect(KILL cr);
 8162 
 8163   size(3);
 8164   format %{ &quot;SHR    $dst,$shift&quot; %}
 8165   opcode(0xC1, 0x5);  /* C1 /5 ib */
 8166   ins_encode( RegOpcImm( dst, shift) );
 8167   ins_pipe( ialu_reg );
 8168 %}
 8169 
 8170 
 8171 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 8172 // This idiom is used by the compiler for the i2b bytecode.
 8173 instruct i2b(rRegI dst, xRegI src, immI_24 twentyfour) %{
 8174   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 8175 
 8176   size(3);
 8177   format %{ &quot;MOVSX  $dst,$src :8&quot; %}
 8178   ins_encode %{
 8179     __ movsbl($dst$$Register, $src$$Register);
 8180   %}
 8181   ins_pipe(ialu_reg_reg);
 8182 %}
 8183 
 8184 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 8185 // This idiom is used by the compiler the i2s bytecode.
 8186 instruct i2s(rRegI dst, xRegI src, immI_16 sixteen) %{
 8187   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 8188 
 8189   size(3);
 8190   format %{ &quot;MOVSX  $dst,$src :16&quot; %}
 8191   ins_encode %{
 8192     __ movswl($dst$$Register, $src$$Register);
 8193   %}
 8194   ins_pipe(ialu_reg_reg);
 8195 %}
 8196 
 8197 
 8198 // Logical Shift Right by variable
 8199 instruct shrI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8200   match(Set dst (URShiftI dst shift));
 8201   effect(KILL cr);
 8202 
 8203   size(2);
 8204   format %{ &quot;SHR    $dst,$shift&quot; %}
 8205   opcode(0xD3, 0x5);  /* D3 /5 */
 8206   ins_encode( OpcP, RegOpc( dst ) );
 8207   ins_pipe( ialu_reg_reg );
 8208 %}
 8209 
 8210 
 8211 //----------Logical Instructions-----------------------------------------------
 8212 //----------Integer Logical Instructions---------------------------------------
 8213 // And Instructions
 8214 // And Register with Register
 8215 instruct andI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8216   match(Set dst (AndI dst src));
 8217   effect(KILL cr);
 8218 
 8219   size(2);
 8220   format %{ &quot;AND    $dst,$src&quot; %}
 8221   opcode(0x23);
 8222   ins_encode( OpcP, RegReg( dst, src) );
 8223   ins_pipe( ialu_reg_reg );
 8224 %}
 8225 
 8226 // And Register with Immediate
 8227 instruct andI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8228   match(Set dst (AndI dst src));
 8229   effect(KILL cr);
 8230 
 8231   format %{ &quot;AND    $dst,$src&quot; %}
 8232   opcode(0x81,0x04);  /* Opcode 81 /4 */
 8233   // ins_encode( RegImm( dst, src) );
 8234   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8235   ins_pipe( ialu_reg );
 8236 %}
 8237 
 8238 // And Register with Memory
 8239 instruct andI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8240   match(Set dst (AndI dst (LoadI src)));
 8241   effect(KILL cr);
 8242 
 8243   ins_cost(125);
 8244   format %{ &quot;AND    $dst,$src&quot; %}
 8245   opcode(0x23);
 8246   ins_encode( OpcP, RegMem( dst, src) );
 8247   ins_pipe( ialu_reg_mem );
 8248 %}
 8249 
 8250 // And Memory with Register
 8251 instruct andI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8252   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 8253   effect(KILL cr);
 8254 
 8255   ins_cost(150);
 8256   format %{ &quot;AND    $dst,$src&quot; %}
 8257   opcode(0x21);  /* Opcode 21 /r */
 8258   ins_encode( OpcP, RegMem( src, dst ) );
 8259   ins_pipe( ialu_mem_reg );
 8260 %}
 8261 
 8262 // And Memory with Immediate
 8263 instruct andI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8264   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 8265   effect(KILL cr);
 8266 
 8267   ins_cost(125);
 8268   format %{ &quot;AND    $dst,$src&quot; %}
 8269   opcode(0x81, 0x4);  /* Opcode 81 /4 id */
 8270   // ins_encode( MemImm( dst, src) );
 8271   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8272   ins_pipe( ialu_mem_imm );
 8273 %}
 8274 
 8275 // BMI1 instructions
 8276 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, eFlagsReg cr) %{
 8277   match(Set dst (AndI (XorI src1 minus_1) src2));
 8278   predicate(UseBMI1Instructions);
 8279   effect(KILL cr);
 8280 
 8281   format %{ &quot;ANDNL  $dst, $src1, $src2&quot; %}
 8282 
 8283   ins_encode %{
 8284     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 8285   %}
 8286   ins_pipe(ialu_reg);
 8287 %}
 8288 
 8289 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, eFlagsReg cr) %{
 8290   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2) ));
 8291   predicate(UseBMI1Instructions);
 8292   effect(KILL cr);
 8293 
 8294   ins_cost(125);
 8295   format %{ &quot;ANDNL  $dst, $src1, $src2&quot; %}
 8296 
 8297   ins_encode %{
 8298     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 8299   %}
 8300   ins_pipe(ialu_reg_mem);
 8301 %}
 8302 
 8303 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, eFlagsReg cr) %{
 8304   match(Set dst (AndI (SubI imm_zero src) src));
 8305   predicate(UseBMI1Instructions);
 8306   effect(KILL cr);
 8307 
 8308   format %{ &quot;BLSIL  $dst, $src&quot; %}
 8309 
 8310   ins_encode %{
 8311     __ blsil($dst$$Register, $src$$Register);
 8312   %}
 8313   ins_pipe(ialu_reg);
 8314 %}
 8315 
 8316 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, eFlagsReg cr) %{
 8317   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 8318   predicate(UseBMI1Instructions);
 8319   effect(KILL cr);
 8320 
 8321   ins_cost(125);
 8322   format %{ &quot;BLSIL  $dst, $src&quot; %}
 8323 
 8324   ins_encode %{
 8325     __ blsil($dst$$Register, $src$$Address);
 8326   %}
 8327   ins_pipe(ialu_reg_mem);
 8328 %}
 8329 
 8330 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, eFlagsReg cr)
 8331 %{
 8332   match(Set dst (XorI (AddI src minus_1) src));
 8333   predicate(UseBMI1Instructions);
 8334   effect(KILL cr);
 8335 
 8336   format %{ &quot;BLSMSKL $dst, $src&quot; %}
 8337 
 8338   ins_encode %{
 8339     __ blsmskl($dst$$Register, $src$$Register);
 8340   %}
 8341 
 8342   ins_pipe(ialu_reg);
 8343 %}
 8344 
 8345 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, eFlagsReg cr)
 8346 %{
 8347   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ));
 8348   predicate(UseBMI1Instructions);
 8349   effect(KILL cr);
 8350 
 8351   ins_cost(125);
 8352   format %{ &quot;BLSMSKL $dst, $src&quot; %}
 8353 
 8354   ins_encode %{
 8355     __ blsmskl($dst$$Register, $src$$Address);
 8356   %}
 8357 
 8358   ins_pipe(ialu_reg_mem);
 8359 %}
 8360 
 8361 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, eFlagsReg cr)
 8362 %{
 8363   match(Set dst (AndI (AddI src minus_1) src) );
 8364   predicate(UseBMI1Instructions);
 8365   effect(KILL cr);
 8366 
 8367   format %{ &quot;BLSRL  $dst, $src&quot; %}
 8368 
 8369   ins_encode %{
 8370     __ blsrl($dst$$Register, $src$$Register);
 8371   %}
 8372 
 8373   ins_pipe(ialu_reg);
 8374 %}
 8375 
 8376 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, eFlagsReg cr)
 8377 %{
 8378   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ));
 8379   predicate(UseBMI1Instructions);
 8380   effect(KILL cr);
 8381 
 8382   ins_cost(125);
 8383   format %{ &quot;BLSRL  $dst, $src&quot; %}
 8384 
 8385   ins_encode %{
 8386     __ blsrl($dst$$Register, $src$$Address);
 8387   %}
 8388 
 8389   ins_pipe(ialu_reg_mem);
 8390 %}
 8391 
 8392 // Or Instructions
 8393 // Or Register with Register
 8394 instruct orI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8395   match(Set dst (OrI dst src));
 8396   effect(KILL cr);
 8397 
 8398   size(2);
 8399   format %{ &quot;OR     $dst,$src&quot; %}
 8400   opcode(0x0B);
 8401   ins_encode( OpcP, RegReg( dst, src) );
 8402   ins_pipe( ialu_reg_reg );
 8403 %}
 8404 
 8405 instruct orI_eReg_castP2X(rRegI dst, eRegP src, eFlagsReg cr) %{
 8406   match(Set dst (OrI dst (CastP2X src)));
 8407   effect(KILL cr);
 8408 
 8409   size(2);
 8410   format %{ &quot;OR     $dst,$src&quot; %}
 8411   opcode(0x0B);
 8412   ins_encode( OpcP, RegReg( dst, src) );
 8413   ins_pipe( ialu_reg_reg );
 8414 %}
 8415 
 8416 
 8417 // Or Register with Immediate
 8418 instruct orI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8419   match(Set dst (OrI dst src));
 8420   effect(KILL cr);
 8421 
 8422   format %{ &quot;OR     $dst,$src&quot; %}
 8423   opcode(0x81,0x01);  /* Opcode 81 /1 id */
 8424   // ins_encode( RegImm( dst, src) );
 8425   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8426   ins_pipe( ialu_reg );
 8427 %}
 8428 
 8429 // Or Register with Memory
 8430 instruct orI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8431   match(Set dst (OrI dst (LoadI src)));
 8432   effect(KILL cr);
 8433 
 8434   ins_cost(125);
 8435   format %{ &quot;OR     $dst,$src&quot; %}
 8436   opcode(0x0B);
 8437   ins_encode( OpcP, RegMem( dst, src) );
 8438   ins_pipe( ialu_reg_mem );
 8439 %}
 8440 
 8441 // Or Memory with Register
 8442 instruct orI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8443   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 8444   effect(KILL cr);
 8445 
 8446   ins_cost(150);
 8447   format %{ &quot;OR     $dst,$src&quot; %}
 8448   opcode(0x09);  /* Opcode 09 /r */
 8449   ins_encode( OpcP, RegMem( src, dst ) );
 8450   ins_pipe( ialu_mem_reg );
 8451 %}
 8452 
 8453 // Or Memory with Immediate
 8454 instruct orI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8455   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 8456   effect(KILL cr);
 8457 
 8458   ins_cost(125);
 8459   format %{ &quot;OR     $dst,$src&quot; %}
 8460   opcode(0x81,0x1);  /* Opcode 81 /1 id */
 8461   // ins_encode( MemImm( dst, src) );
 8462   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8463   ins_pipe( ialu_mem_imm );
 8464 %}
 8465 
 8466 // ROL/ROR
 8467 // ROL expand
 8468 instruct rolI_eReg_imm1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8469   effect(USE_DEF dst, USE shift, KILL cr);
 8470 
 8471   format %{ &quot;ROL    $dst, $shift&quot; %}
 8472   opcode(0xD1, 0x0); /* Opcode D1 /0 */
 8473   ins_encode( OpcP, RegOpc( dst ));
 8474   ins_pipe( ialu_reg );
 8475 %}
 8476 
 8477 instruct rolI_eReg_imm8(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8478   effect(USE_DEF dst, USE shift, KILL cr);
 8479 
 8480   format %{ &quot;ROL    $dst, $shift&quot; %}
 8481   opcode(0xC1, 0x0); /*Opcode /C1  /0  */
 8482   ins_encode( RegOpcImm(dst, shift) );
 8483   ins_pipe(ialu_reg);
 8484 %}
 8485 
 8486 instruct rolI_eReg_CL(ncxRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8487   effect(USE_DEF dst, USE shift, KILL cr);
 8488 
 8489   format %{ &quot;ROL    $dst, $shift&quot; %}
 8490   opcode(0xD3, 0x0);    /* Opcode D3 /0 */
 8491   ins_encode(OpcP, RegOpc(dst));
 8492   ins_pipe( ialu_reg_reg );
 8493 %}
 8494 // end of ROL expand
 8495 
 8496 // ROL 32bit by one once
 8497 instruct rolI_eReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, eFlagsReg cr) %{
 8498   match(Set dst ( OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 8499 
 8500   expand %{
 8501     rolI_eReg_imm1(dst, lshift, cr);
 8502   %}
 8503 %}
 8504 
 8505 // ROL 32bit var by imm8 once
 8506 instruct rolI_eReg_i8(rRegI dst, immI8 lshift, immI8 rshift, eFlagsReg cr) %{
 8507   predicate(  0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 8508   match(Set dst ( OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 8509 
 8510   expand %{
 8511     rolI_eReg_imm8(dst, lshift, cr);
 8512   %}
 8513 %}
 8514 
 8515 // ROL 32bit var by var once
 8516 instruct rolI_eReg_Var_C0(ncxRegI dst, eCXRegI shift, immI0 zero, eFlagsReg cr) %{
 8517   match(Set dst ( OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 8518 
 8519   expand %{
 8520     rolI_eReg_CL(dst, shift, cr);
 8521   %}
 8522 %}
 8523 
 8524 // ROL 32bit var by var once
 8525 instruct rolI_eReg_Var_C32(ncxRegI dst, eCXRegI shift, immI_32 c32, eFlagsReg cr) %{
 8526   match(Set dst ( OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 8527 
 8528   expand %{
 8529     rolI_eReg_CL(dst, shift, cr);
 8530   %}
 8531 %}
 8532 
 8533 // ROR expand
 8534 instruct rorI_eReg_imm1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8535   effect(USE_DEF dst, USE shift, KILL cr);
 8536 
 8537   format %{ &quot;ROR    $dst, $shift&quot; %}
 8538   opcode(0xD1,0x1);  /* Opcode D1 /1 */
 8539   ins_encode( OpcP, RegOpc( dst ) );
 8540   ins_pipe( ialu_reg );
 8541 %}
 8542 
 8543 instruct rorI_eReg_imm8(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8544   effect (USE_DEF dst, USE shift, KILL cr);
 8545 
 8546   format %{ &quot;ROR    $dst, $shift&quot; %}
 8547   opcode(0xC1, 0x1); /* Opcode /C1 /1 ib */
 8548   ins_encode( RegOpcImm(dst, shift) );
 8549   ins_pipe( ialu_reg );
 8550 %}
 8551 
 8552 instruct rorI_eReg_CL(ncxRegI dst, eCXRegI shift, eFlagsReg cr)%{
 8553   effect(USE_DEF dst, USE shift, KILL cr);
 8554 
 8555   format %{ &quot;ROR    $dst, $shift&quot; %}
 8556   opcode(0xD3, 0x1);    /* Opcode D3 /1 */
 8557   ins_encode(OpcP, RegOpc(dst));
 8558   ins_pipe( ialu_reg_reg );
 8559 %}
 8560 // end of ROR expand
 8561 
 8562 // ROR right once
 8563 instruct rorI_eReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, eFlagsReg cr) %{
 8564   match(Set dst ( OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 8565 
 8566   expand %{
 8567     rorI_eReg_imm1(dst, rshift, cr);
 8568   %}
 8569 %}
 8570 
 8571 // ROR 32bit by immI8 once
 8572 instruct rorI_eReg_i8(rRegI dst, immI8 rshift, immI8 lshift, eFlagsReg cr) %{
 8573   predicate(  0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 8574   match(Set dst ( OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 8575 
 8576   expand %{
 8577     rorI_eReg_imm8(dst, rshift, cr);
 8578   %}
 8579 %}
 8580 
 8581 // ROR 32bit var by var once
 8582 instruct rorI_eReg_Var_C0(ncxRegI dst, eCXRegI shift, immI0 zero, eFlagsReg cr) %{
 8583   match(Set dst ( OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 8584 
 8585   expand %{
 8586     rorI_eReg_CL(dst, shift, cr);
 8587   %}
 8588 %}
 8589 
 8590 // ROR 32bit var by var once
 8591 instruct rorI_eReg_Var_C32(ncxRegI dst, eCXRegI shift, immI_32 c32, eFlagsReg cr) %{
 8592   match(Set dst ( OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 8593 
 8594   expand %{
 8595     rorI_eReg_CL(dst, shift, cr);
 8596   %}
 8597 %}
 8598 
 8599 // Xor Instructions
 8600 // Xor Register with Register
 8601 instruct xorI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8602   match(Set dst (XorI dst src));
 8603   effect(KILL cr);
 8604 
 8605   size(2);
 8606   format %{ &quot;XOR    $dst,$src&quot; %}
 8607   opcode(0x33);
 8608   ins_encode( OpcP, RegReg( dst, src) );
 8609   ins_pipe( ialu_reg_reg );
 8610 %}
 8611 
 8612 // Xor Register with Immediate -1
 8613 instruct xorI_eReg_im1(rRegI dst, immI_M1 imm) %{
 8614   match(Set dst (XorI dst imm));
 8615 
 8616   size(2);
 8617   format %{ &quot;NOT    $dst&quot; %}
 8618   ins_encode %{
 8619      __ notl($dst$$Register);
 8620   %}
 8621   ins_pipe( ialu_reg );
 8622 %}
 8623 
 8624 // Xor Register with Immediate
 8625 instruct xorI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8626   match(Set dst (XorI dst src));
 8627   effect(KILL cr);
 8628 
 8629   format %{ &quot;XOR    $dst,$src&quot; %}
 8630   opcode(0x81,0x06);  /* Opcode 81 /6 id */
 8631   // ins_encode( RegImm( dst, src) );
 8632   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8633   ins_pipe( ialu_reg );
 8634 %}
 8635 
 8636 // Xor Register with Memory
 8637 instruct xorI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8638   match(Set dst (XorI dst (LoadI src)));
 8639   effect(KILL cr);
 8640 
 8641   ins_cost(125);
 8642   format %{ &quot;XOR    $dst,$src&quot; %}
 8643   opcode(0x33);
 8644   ins_encode( OpcP, RegMem(dst, src) );
 8645   ins_pipe( ialu_reg_mem );
 8646 %}
 8647 
 8648 // Xor Memory with Register
 8649 instruct xorI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8650   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 8651   effect(KILL cr);
 8652 
 8653   ins_cost(150);
 8654   format %{ &quot;XOR    $dst,$src&quot; %}
 8655   opcode(0x31);  /* Opcode 31 /r */
 8656   ins_encode( OpcP, RegMem( src, dst ) );
 8657   ins_pipe( ialu_mem_reg );
 8658 %}
 8659 
 8660 // Xor Memory with Immediate
 8661 instruct xorI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8662   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 8663   effect(KILL cr);
 8664 
 8665   ins_cost(125);
 8666   format %{ &quot;XOR    $dst,$src&quot; %}
 8667   opcode(0x81,0x6);  /* Opcode 81 /6 id */
 8668   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8669   ins_pipe( ialu_mem_imm );
 8670 %}
 8671 
 8672 //----------Convert Int to Boolean---------------------------------------------
 8673 
 8674 instruct movI_nocopy(rRegI dst, rRegI src) %{
 8675   effect( DEF dst, USE src );
 8676   format %{ &quot;MOV    $dst,$src&quot; %}
 8677   ins_encode( enc_Copy( dst, src) );
 8678   ins_pipe( ialu_reg_reg );
 8679 %}
 8680 
 8681 instruct ci2b( rRegI dst, rRegI src, eFlagsReg cr ) %{
 8682   effect( USE_DEF dst, USE src, KILL cr );
 8683 
 8684   size(4);
 8685   format %{ &quot;NEG    $dst\n\t&quot;
 8686             &quot;ADC    $dst,$src&quot; %}
 8687   ins_encode( neg_reg(dst),
 8688               OpcRegReg(0x13,dst,src) );
 8689   ins_pipe( ialu_reg_reg_long );
 8690 %}
 8691 
 8692 instruct convI2B( rRegI dst, rRegI src, eFlagsReg cr ) %{
 8693   match(Set dst (Conv2B src));
 8694 
 8695   expand %{
 8696     movI_nocopy(dst,src);
 8697     ci2b(dst,src,cr);
 8698   %}
 8699 %}
 8700 
 8701 instruct movP_nocopy(rRegI dst, eRegP src) %{
 8702   effect( DEF dst, USE src );
 8703   format %{ &quot;MOV    $dst,$src&quot; %}
 8704   ins_encode( enc_Copy( dst, src) );
 8705   ins_pipe( ialu_reg_reg );
 8706 %}
 8707 
 8708 instruct cp2b( rRegI dst, eRegP src, eFlagsReg cr ) %{
 8709   effect( USE_DEF dst, USE src, KILL cr );
 8710   format %{ &quot;NEG    $dst\n\t&quot;
 8711             &quot;ADC    $dst,$src&quot; %}
 8712   ins_encode( neg_reg(dst),
 8713               OpcRegReg(0x13,dst,src) );
 8714   ins_pipe( ialu_reg_reg_long );
 8715 %}
 8716 
 8717 instruct convP2B( rRegI dst, eRegP src, eFlagsReg cr ) %{
 8718   match(Set dst (Conv2B src));
 8719 
 8720   expand %{
 8721     movP_nocopy(dst,src);
 8722     cp2b(dst,src,cr);
 8723   %}
 8724 %}
 8725 
 8726 instruct cmpLTMask(eCXRegI dst, ncxRegI p, ncxRegI q, eFlagsReg cr) %{
 8727   match(Set dst (CmpLTMask p q));
 8728   effect(KILL cr);
 8729   ins_cost(400);
 8730 
 8731   // SETlt can only use low byte of EAX,EBX, ECX, or EDX as destination
 8732   format %{ &quot;XOR    $dst,$dst\n\t&quot;
 8733             &quot;CMP    $p,$q\n\t&quot;
 8734             &quot;SETlt  $dst\n\t&quot;
 8735             &quot;NEG    $dst&quot; %}
 8736   ins_encode %{
 8737     Register Rp = $p$$Register;
 8738     Register Rq = $q$$Register;
 8739     Register Rd = $dst$$Register;
 8740     Label done;
 8741     __ xorl(Rd, Rd);
 8742     __ cmpl(Rp, Rq);
 8743     __ setb(Assembler::less, Rd);
 8744     __ negl(Rd);
 8745   %}
 8746 
 8747   ins_pipe(pipe_slow);
 8748 %}
 8749 
 8750 instruct cmpLTMask0(rRegI dst, immI0 zero, eFlagsReg cr) %{
 8751   match(Set dst (CmpLTMask dst zero));
 8752   effect(DEF dst, KILL cr);
 8753   ins_cost(100);
 8754 
 8755   format %{ &quot;SAR    $dst,31\t# cmpLTMask0&quot; %}
 8756   ins_encode %{
 8757   __ sarl($dst$$Register, 31);
 8758   %}
 8759   ins_pipe(ialu_reg);
 8760 %}
 8761 
 8762 /* better to save a register than avoid a branch */
 8763 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, eFlagsReg cr) %{
 8764   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
 8765   effect(KILL cr);
 8766   ins_cost(400);
 8767   format %{ &quot;SUB    $p,$q\t# cadd_cmpLTMask\n\t&quot;
 8768             &quot;JGE    done\n\t&quot;
 8769             &quot;ADD    $p,$y\n&quot;
 8770             &quot;done:  &quot; %}
 8771   ins_encode %{
 8772     Register Rp = $p$$Register;
 8773     Register Rq = $q$$Register;
 8774     Register Ry = $y$$Register;
 8775     Label done;
 8776     __ subl(Rp, Rq);
 8777     __ jccb(Assembler::greaterEqual, done);
 8778     __ addl(Rp, Ry);
 8779     __ bind(done);
 8780   %}
 8781 
 8782   ins_pipe(pipe_cmplt);
 8783 %}
 8784 
 8785 /* better to save a register than avoid a branch */
 8786 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, eFlagsReg cr) %{
 8787   match(Set y (AndI (CmpLTMask p q) y));
 8788   effect(KILL cr);
 8789 
 8790   ins_cost(300);
 8791 
 8792   format %{ &quot;CMPL     $p, $q\t# and_cmpLTMask\n\t&quot;
 8793             &quot;JLT      done\n\t&quot;
 8794             &quot;XORL     $y, $y\n&quot;
 8795             &quot;done:  &quot; %}
 8796   ins_encode %{
 8797     Register Rp = $p$$Register;
 8798     Register Rq = $q$$Register;
 8799     Register Ry = $y$$Register;
 8800     Label done;
 8801     __ cmpl(Rp, Rq);
 8802     __ jccb(Assembler::less, done);
 8803     __ xorl(Ry, Ry);
 8804     __ bind(done);
 8805   %}
 8806 
 8807   ins_pipe(pipe_cmplt);
 8808 %}
 8809 
 8810 /* If I enable this, I encourage spilling in the inner loop of compress.
 8811 instruct cadd_cmpLTMask_mem(ncxRegI p, ncxRegI q, memory y, eCXRegI tmp, eFlagsReg cr) %{
 8812   match(Set p (AddI (AndI (CmpLTMask p q) (LoadI y)) (SubI p q)));
 8813 */
 8814 //----------Overflow Math Instructions-----------------------------------------
 8815 
 8816 instruct overflowAddI_eReg(eFlagsReg cr, eAXRegI op1, rRegI op2)
 8817 %{
 8818   match(Set cr (OverflowAddI op1 op2));
 8819   effect(DEF cr, USE_KILL op1, USE op2);
 8820 
 8821   format %{ &quot;ADD    $op1, $op2\t# overflow check int&quot; %}
 8822 
 8823   ins_encode %{
 8824     __ addl($op1$$Register, $op2$$Register);
 8825   %}
 8826   ins_pipe(ialu_reg_reg);
 8827 %}
 8828 
 8829 instruct overflowAddI_rReg_imm(eFlagsReg cr, eAXRegI op1, immI op2)
 8830 %{
 8831   match(Set cr (OverflowAddI op1 op2));
 8832   effect(DEF cr, USE_KILL op1, USE op2);
 8833 
 8834   format %{ &quot;ADD    $op1, $op2\t# overflow check int&quot; %}
 8835 
 8836   ins_encode %{
 8837     __ addl($op1$$Register, $op2$$constant);
 8838   %}
 8839   ins_pipe(ialu_reg_reg);
 8840 %}
 8841 
 8842 instruct overflowSubI_rReg(eFlagsReg cr, rRegI op1, rRegI op2)
 8843 %{
 8844   match(Set cr (OverflowSubI op1 op2));
 8845 
 8846   format %{ &quot;CMP    $op1, $op2\t# overflow check int&quot; %}
 8847   ins_encode %{
 8848     __ cmpl($op1$$Register, $op2$$Register);
 8849   %}
 8850   ins_pipe(ialu_reg_reg);
 8851 %}
 8852 
 8853 instruct overflowSubI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2)
 8854 %{
 8855   match(Set cr (OverflowSubI op1 op2));
 8856 
 8857   format %{ &quot;CMP    $op1, $op2\t# overflow check int&quot; %}
 8858   ins_encode %{
 8859     __ cmpl($op1$$Register, $op2$$constant);
 8860   %}
 8861   ins_pipe(ialu_reg_reg);
 8862 %}
 8863 
 8864 instruct overflowNegI_rReg(eFlagsReg cr, immI0 zero, eAXRegI op2)
 8865 %{
 8866   match(Set cr (OverflowSubI zero op2));
 8867   effect(DEF cr, USE_KILL op2);
 8868 
 8869   format %{ &quot;NEG    $op2\t# overflow check int&quot; %}
 8870   ins_encode %{
 8871     __ negl($op2$$Register);
 8872   %}
 8873   ins_pipe(ialu_reg_reg);
 8874 %}
 8875 
 8876 instruct overflowMulI_rReg(eFlagsReg cr, eAXRegI op1, rRegI op2)
 8877 %{
 8878   match(Set cr (OverflowMulI op1 op2));
 8879   effect(DEF cr, USE_KILL op1, USE op2);
 8880 
 8881   format %{ &quot;IMUL    $op1, $op2\t# overflow check int&quot; %}
 8882   ins_encode %{
 8883     __ imull($op1$$Register, $op2$$Register);
 8884   %}
 8885   ins_pipe(ialu_reg_reg_alu0);
 8886 %}
 8887 
 8888 instruct overflowMulI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
 8889 %{
 8890   match(Set cr (OverflowMulI op1 op2));
 8891   effect(DEF cr, TEMP tmp, USE op1, USE op2);
 8892 
 8893   format %{ &quot;IMUL    $tmp, $op1, $op2\t# overflow check int&quot; %}
 8894   ins_encode %{
 8895     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
 8896   %}
 8897   ins_pipe(ialu_reg_reg_alu0);
 8898 %}
 8899 
 8900 // Integer Absolute Instructions
 8901 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, eFlagsReg cr)
 8902 %{
 8903   match(Set dst (AbsI src));
 8904   effect(TEMP dst, TEMP tmp, KILL cr);
 8905   format %{ &quot;movl $tmp, $src\n\t&quot;
 8906             &quot;sarl $tmp, 31\n\t&quot;
 8907             &quot;movl $dst, $src\n\t&quot;
 8908             &quot;xorl $dst, $tmp\n\t&quot;
 8909             &quot;subl $dst, $tmp\n&quot;
 8910           %}
 8911   ins_encode %{
 8912     __ movl($tmp$$Register, $src$$Register);
 8913     __ sarl($tmp$$Register, 31);
 8914     __ movl($dst$$Register, $src$$Register);
 8915     __ xorl($dst$$Register, $tmp$$Register);
 8916     __ subl($dst$$Register, $tmp$$Register);
 8917   %}
 8918 
 8919   ins_pipe(ialu_reg_reg);
 8920 %}
 8921 
 8922 //----------Long Instructions------------------------------------------------
 8923 // Add Long Register with Register
 8924 instruct addL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8925   match(Set dst (AddL dst src));
 8926   effect(KILL cr);
 8927   ins_cost(200);
 8928   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8929             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8930   opcode(0x03, 0x13);
 8931   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8932   ins_pipe( ialu_reg_reg_long );
 8933 %}
 8934 
 8935 // Add Long Register with Immediate
 8936 instruct addL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8937   match(Set dst (AddL dst src));
 8938   effect(KILL cr);
 8939   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8940             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8941   opcode(0x81,0x00,0x02);  /* Opcode 81 /0, 81 /2 */
 8942   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8943   ins_pipe( ialu_reg_long );
 8944 %}
 8945 
 8946 // Add Long Register with Memory
 8947 instruct addL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8948   match(Set dst (AddL dst (LoadL mem)));
 8949   effect(KILL cr);
 8950   ins_cost(125);
 8951   format %{ &quot;ADD    $dst.lo,$mem\n\t&quot;
 8952             &quot;ADC    $dst.hi,$mem+4&quot; %}
 8953   opcode(0x03, 0x13);
 8954   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 8955   ins_pipe( ialu_reg_long_mem );
 8956 %}
 8957 
 8958 // Subtract Long Register with Register.
 8959 instruct subL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8960   match(Set dst (SubL dst src));
 8961   effect(KILL cr);
 8962   ins_cost(200);
 8963   format %{ &quot;SUB    $dst.lo,$src.lo\n\t&quot;
 8964             &quot;SBB    $dst.hi,$src.hi&quot; %}
 8965   opcode(0x2B, 0x1B);
 8966   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8967   ins_pipe( ialu_reg_reg_long );
 8968 %}
 8969 
 8970 // Subtract Long Register with Immediate
 8971 instruct subL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8972   match(Set dst (SubL dst src));
 8973   effect(KILL cr);
 8974   format %{ &quot;SUB    $dst.lo,$src.lo\n\t&quot;
 8975             &quot;SBB    $dst.hi,$src.hi&quot; %}
 8976   opcode(0x81,0x05,0x03);  /* Opcode 81 /5, 81 /3 */
 8977   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8978   ins_pipe( ialu_reg_long );
 8979 %}
 8980 
 8981 // Subtract Long Register with Memory
 8982 instruct subL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8983   match(Set dst (SubL dst (LoadL mem)));
 8984   effect(KILL cr);
 8985   ins_cost(125);
 8986   format %{ &quot;SUB    $dst.lo,$mem\n\t&quot;
 8987             &quot;SBB    $dst.hi,$mem+4&quot; %}
 8988   opcode(0x2B, 0x1B);
 8989   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 8990   ins_pipe( ialu_reg_long_mem );
 8991 %}
 8992 
 8993 instruct negL_eReg(eRegL dst, immL0 zero, eFlagsReg cr) %{
 8994   match(Set dst (SubL zero dst));
 8995   effect(KILL cr);
 8996   ins_cost(300);
 8997   format %{ &quot;NEG    $dst.hi\n\tNEG    $dst.lo\n\tSBB    $dst.hi,0&quot; %}
 8998   ins_encode( neg_long(dst) );
 8999   ins_pipe( ialu_reg_reg_long );
 9000 %}
 9001 
 9002 // And Long Register with Register
 9003 instruct andL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9004   match(Set dst (AndL dst src));
 9005   effect(KILL cr);
 9006   format %{ &quot;AND    $dst.lo,$src.lo\n\t&quot;
 9007             &quot;AND    $dst.hi,$src.hi&quot; %}
 9008   opcode(0x23,0x23);
 9009   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9010   ins_pipe( ialu_reg_reg_long );
 9011 %}
 9012 
 9013 // And Long Register with Immediate
 9014 instruct andL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9015   match(Set dst (AndL dst src));
 9016   effect(KILL cr);
 9017   format %{ &quot;AND    $dst.lo,$src.lo\n\t&quot;
 9018             &quot;AND    $dst.hi,$src.hi&quot; %}
 9019   opcode(0x81,0x04,0x04);  /* Opcode 81 /4, 81 /4 */
 9020   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9021   ins_pipe( ialu_reg_long );
 9022 %}
 9023 
 9024 // And Long Register with Memory
 9025 instruct andL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9026   match(Set dst (AndL dst (LoadL mem)));
 9027   effect(KILL cr);
 9028   ins_cost(125);
 9029   format %{ &quot;AND    $dst.lo,$mem\n\t&quot;
 9030             &quot;AND    $dst.hi,$mem+4&quot; %}
 9031   opcode(0x23, 0x23);
 9032   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9033   ins_pipe( ialu_reg_long_mem );
 9034 %}
 9035 
 9036 // BMI1 instructions
 9037 instruct andnL_eReg_eReg_eReg(eRegL dst, eRegL src1, eRegL src2, immL_M1 minus_1, eFlagsReg cr) %{
 9038   match(Set dst (AndL (XorL src1 minus_1) src2));
 9039   predicate(UseBMI1Instructions);
 9040   effect(KILL cr, TEMP dst);
 9041 
 9042   format %{ &quot;ANDNL  $dst.lo, $src1.lo, $src2.lo\n\t&quot;
 9043             &quot;ANDNL  $dst.hi, $src1.hi, $src2.hi&quot;
 9044          %}
 9045 
 9046   ins_encode %{
 9047     Register Rdst = $dst$$Register;
 9048     Register Rsrc1 = $src1$$Register;
 9049     Register Rsrc2 = $src2$$Register;
 9050     __ andnl(Rdst, Rsrc1, Rsrc2);
 9051     __ andnl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc1), HIGH_FROM_LOW(Rsrc2));
 9052   %}
 9053   ins_pipe(ialu_reg_reg_long);
 9054 %}
 9055 
 9056 instruct andnL_eReg_eReg_mem(eRegL dst, eRegL src1, memory src2, immL_M1 minus_1, eFlagsReg cr) %{
 9057   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2) ));
 9058   predicate(UseBMI1Instructions);
 9059   effect(KILL cr, TEMP dst);
 9060 
 9061   ins_cost(125);
 9062   format %{ &quot;ANDNL  $dst.lo, $src1.lo, $src2\n\t&quot;
 9063             &quot;ANDNL  $dst.hi, $src1.hi, $src2+4&quot;
 9064          %}
 9065 
 9066   ins_encode %{
 9067     Register Rdst = $dst$$Register;
 9068     Register Rsrc1 = $src1$$Register;
 9069     Address src2_hi = Address::make_raw($src2$$base, $src2$$index, $src2$$scale, $src2$$disp + 4, relocInfo::none);
 9070 
 9071     __ andnl(Rdst, Rsrc1, $src2$$Address);
 9072     __ andnl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc1), src2_hi);
 9073   %}
 9074   ins_pipe(ialu_reg_mem);
 9075 %}
 9076 
 9077 instruct blsiL_eReg_eReg(eRegL dst, eRegL src, immL0 imm_zero, eFlagsReg cr) %{
 9078   match(Set dst (AndL (SubL imm_zero src) src));
 9079   predicate(UseBMI1Instructions);
 9080   effect(KILL cr, TEMP dst);
 9081 
 9082   format %{ &quot;MOVL   $dst.hi, 0\n\t&quot;
 9083             &quot;BLSIL  $dst.lo, $src.lo\n\t&quot;
 9084             &quot;JNZ    done\n\t&quot;
 9085             &quot;BLSIL  $dst.hi, $src.hi\n&quot;
 9086             &quot;done:&quot;
 9087          %}
 9088 
 9089   ins_encode %{
 9090     Label done;
 9091     Register Rdst = $dst$$Register;
 9092     Register Rsrc = $src$$Register;
 9093     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9094     __ blsil(Rdst, Rsrc);
 9095     __ jccb(Assembler::notZero, done);
 9096     __ blsil(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9097     __ bind(done);
 9098   %}
 9099   ins_pipe(ialu_reg);
 9100 %}
 9101 
 9102 instruct blsiL_eReg_mem(eRegL dst, memory src, immL0 imm_zero, eFlagsReg cr) %{
 9103   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9104   predicate(UseBMI1Instructions);
 9105   effect(KILL cr, TEMP dst);
 9106 
 9107   ins_cost(125);
 9108   format %{ &quot;MOVL   $dst.hi, 0\n\t&quot;
 9109             &quot;BLSIL  $dst.lo, $src\n\t&quot;
 9110             &quot;JNZ    done\n\t&quot;
 9111             &quot;BLSIL  $dst.hi, $src+4\n&quot;
 9112             &quot;done:&quot;
 9113          %}
 9114 
 9115   ins_encode %{
 9116     Label done;
 9117     Register Rdst = $dst$$Register;
 9118     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9119 
 9120     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9121     __ blsil(Rdst, $src$$Address);
 9122     __ jccb(Assembler::notZero, done);
 9123     __ blsil(HIGH_FROM_LOW(Rdst), src_hi);
 9124     __ bind(done);
 9125   %}
 9126   ins_pipe(ialu_reg_mem);
 9127 %}
 9128 
 9129 instruct blsmskL_eReg_eReg(eRegL dst, eRegL src, immL_M1 minus_1, eFlagsReg cr)
 9130 %{
 9131   match(Set dst (XorL (AddL src minus_1) src));
 9132   predicate(UseBMI1Instructions);
 9133   effect(KILL cr, TEMP dst);
 9134 
 9135   format %{ &quot;MOVL    $dst.hi, 0\n\t&quot;
 9136             &quot;BLSMSKL $dst.lo, $src.lo\n\t&quot;
 9137             &quot;JNC     done\n\t&quot;
 9138             &quot;BLSMSKL $dst.hi, $src.hi\n&quot;
 9139             &quot;done:&quot;
 9140          %}
 9141 
 9142   ins_encode %{
 9143     Label done;
 9144     Register Rdst = $dst$$Register;
 9145     Register Rsrc = $src$$Register;
 9146     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9147     __ blsmskl(Rdst, Rsrc);
 9148     __ jccb(Assembler::carryClear, done);
 9149     __ blsmskl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9150     __ bind(done);
 9151   %}
 9152 
 9153   ins_pipe(ialu_reg);
 9154 %}
 9155 
 9156 instruct blsmskL_eReg_mem(eRegL dst, memory src, immL_M1 minus_1, eFlagsReg cr)
 9157 %{
 9158   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ));
 9159   predicate(UseBMI1Instructions);
 9160   effect(KILL cr, TEMP dst);
 9161 
 9162   ins_cost(125);
 9163   format %{ &quot;MOVL    $dst.hi, 0\n\t&quot;
 9164             &quot;BLSMSKL $dst.lo, $src\n\t&quot;
 9165             &quot;JNC     done\n\t&quot;
 9166             &quot;BLSMSKL $dst.hi, $src+4\n&quot;
 9167             &quot;done:&quot;
 9168          %}
 9169 
 9170   ins_encode %{
 9171     Label done;
 9172     Register Rdst = $dst$$Register;
 9173     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9174 
 9175     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9176     __ blsmskl(Rdst, $src$$Address);
 9177     __ jccb(Assembler::carryClear, done);
 9178     __ blsmskl(HIGH_FROM_LOW(Rdst), src_hi);
 9179     __ bind(done);
 9180   %}
 9181 
 9182   ins_pipe(ialu_reg_mem);
 9183 %}
 9184 
 9185 instruct blsrL_eReg_eReg(eRegL dst, eRegL src, immL_M1 minus_1, eFlagsReg cr)
 9186 %{
 9187   match(Set dst (AndL (AddL src minus_1) src) );
 9188   predicate(UseBMI1Instructions);
 9189   effect(KILL cr, TEMP dst);
 9190 
 9191   format %{ &quot;MOVL   $dst.hi, $src.hi\n\t&quot;
 9192             &quot;BLSRL  $dst.lo, $src.lo\n\t&quot;
 9193             &quot;JNC    done\n\t&quot;
 9194             &quot;BLSRL  $dst.hi, $src.hi\n&quot;
 9195             &quot;done:&quot;
 9196   %}
 9197 
 9198   ins_encode %{
 9199     Label done;
 9200     Register Rdst = $dst$$Register;
 9201     Register Rsrc = $src$$Register;
 9202     __ movl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9203     __ blsrl(Rdst, Rsrc);
 9204     __ jccb(Assembler::carryClear, done);
 9205     __ blsrl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9206     __ bind(done);
 9207   %}
 9208 
 9209   ins_pipe(ialu_reg);
 9210 %}
 9211 
 9212 instruct blsrL_eReg_mem(eRegL dst, memory src, immL_M1 minus_1, eFlagsReg cr)
 9213 %{
 9214   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src) ));
 9215   predicate(UseBMI1Instructions);
 9216   effect(KILL cr, TEMP dst);
 9217 
 9218   ins_cost(125);
 9219   format %{ &quot;MOVL   $dst.hi, $src+4\n\t&quot;
 9220             &quot;BLSRL  $dst.lo, $src\n\t&quot;
 9221             &quot;JNC    done\n\t&quot;
 9222             &quot;BLSRL  $dst.hi, $src+4\n&quot;
 9223             &quot;done:&quot;
 9224   %}
 9225 
 9226   ins_encode %{
 9227     Label done;
 9228     Register Rdst = $dst$$Register;
 9229     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9230     __ movl(HIGH_FROM_LOW(Rdst), src_hi);
 9231     __ blsrl(Rdst, $src$$Address);
 9232     __ jccb(Assembler::carryClear, done);
 9233     __ blsrl(HIGH_FROM_LOW(Rdst), src_hi);
 9234     __ bind(done);
 9235   %}
 9236 
 9237   ins_pipe(ialu_reg_mem);
 9238 %}
 9239 
 9240 // Or Long Register with Register
 9241 instruct orl_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9242   match(Set dst (OrL dst src));
 9243   effect(KILL cr);
 9244   format %{ &quot;OR     $dst.lo,$src.lo\n\t&quot;
 9245             &quot;OR     $dst.hi,$src.hi&quot; %}
 9246   opcode(0x0B,0x0B);
 9247   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9248   ins_pipe( ialu_reg_reg_long );
 9249 %}
 9250 
 9251 // Or Long Register with Immediate
 9252 instruct orl_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9253   match(Set dst (OrL dst src));
 9254   effect(KILL cr);
 9255   format %{ &quot;OR     $dst.lo,$src.lo\n\t&quot;
 9256             &quot;OR     $dst.hi,$src.hi&quot; %}
 9257   opcode(0x81,0x01,0x01);  /* Opcode 81 /1, 81 /1 */
 9258   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9259   ins_pipe( ialu_reg_long );
 9260 %}
 9261 
 9262 // Or Long Register with Memory
 9263 instruct orl_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9264   match(Set dst (OrL dst (LoadL mem)));
 9265   effect(KILL cr);
 9266   ins_cost(125);
 9267   format %{ &quot;OR     $dst.lo,$mem\n\t&quot;
 9268             &quot;OR     $dst.hi,$mem+4&quot; %}
 9269   opcode(0x0B,0x0B);
 9270   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9271   ins_pipe( ialu_reg_long_mem );
 9272 %}
 9273 
 9274 // Xor Long Register with Register
 9275 instruct xorl_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9276   match(Set dst (XorL dst src));
 9277   effect(KILL cr);
 9278   format %{ &quot;XOR    $dst.lo,$src.lo\n\t&quot;
 9279             &quot;XOR    $dst.hi,$src.hi&quot; %}
 9280   opcode(0x33,0x33);
 9281   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9282   ins_pipe( ialu_reg_reg_long );
 9283 %}
 9284 
 9285 // Xor Long Register with Immediate -1
 9286 instruct xorl_eReg_im1(eRegL dst, immL_M1 imm) %{
 9287   match(Set dst (XorL dst imm));
 9288   format %{ &quot;NOT    $dst.lo\n\t&quot;
 9289             &quot;NOT    $dst.hi&quot; %}
 9290   ins_encode %{
 9291      __ notl($dst$$Register);
 9292      __ notl(HIGH_FROM_LOW($dst$$Register));
 9293   %}
 9294   ins_pipe( ialu_reg_long );
 9295 %}
 9296 
 9297 // Xor Long Register with Immediate
 9298 instruct xorl_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9299   match(Set dst (XorL dst src));
 9300   effect(KILL cr);
 9301   format %{ &quot;XOR    $dst.lo,$src.lo\n\t&quot;
 9302             &quot;XOR    $dst.hi,$src.hi&quot; %}
 9303   opcode(0x81,0x06,0x06);  /* Opcode 81 /6, 81 /6 */
 9304   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9305   ins_pipe( ialu_reg_long );
 9306 %}
 9307 
 9308 // Xor Long Register with Memory
 9309 instruct xorl_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9310   match(Set dst (XorL dst (LoadL mem)));
 9311   effect(KILL cr);
 9312   ins_cost(125);
 9313   format %{ &quot;XOR    $dst.lo,$mem\n\t&quot;
 9314             &quot;XOR    $dst.hi,$mem+4&quot; %}
 9315   opcode(0x33,0x33);
 9316   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9317   ins_pipe( ialu_reg_long_mem );
 9318 %}
 9319 
 9320 // Shift Left Long by 1
 9321 instruct shlL_eReg_1(eRegL dst, immI_1 cnt, eFlagsReg cr) %{
 9322   predicate(UseNewLongLShift);
 9323   match(Set dst (LShiftL dst cnt));
 9324   effect(KILL cr);
 9325   ins_cost(100);
 9326   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9327             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9328   ins_encode %{
 9329     __ addl($dst$$Register,$dst$$Register);
 9330     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9331   %}
 9332   ins_pipe( ialu_reg_long );
 9333 %}
 9334 
 9335 // Shift Left Long by 2
 9336 instruct shlL_eReg_2(eRegL dst, immI_2 cnt, eFlagsReg cr) %{
 9337   predicate(UseNewLongLShift);
 9338   match(Set dst (LShiftL dst cnt));
 9339   effect(KILL cr);
 9340   ins_cost(100);
 9341   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9342             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9343             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9344             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9345   ins_encode %{
 9346     __ addl($dst$$Register,$dst$$Register);
 9347     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9348     __ addl($dst$$Register,$dst$$Register);
 9349     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9350   %}
 9351   ins_pipe( ialu_reg_long );
 9352 %}
 9353 
 9354 // Shift Left Long by 3
 9355 instruct shlL_eReg_3(eRegL dst, immI_3 cnt, eFlagsReg cr) %{
 9356   predicate(UseNewLongLShift);
 9357   match(Set dst (LShiftL dst cnt));
 9358   effect(KILL cr);
 9359   ins_cost(100);
 9360   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9361             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9362             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9363             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9364             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9365             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9366   ins_encode %{
 9367     __ addl($dst$$Register,$dst$$Register);
 9368     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9369     __ addl($dst$$Register,$dst$$Register);
 9370     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9371     __ addl($dst$$Register,$dst$$Register);
 9372     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9373   %}
 9374   ins_pipe( ialu_reg_long );
 9375 %}
 9376 
 9377 // Shift Left Long by 1-31
 9378 instruct shlL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9379   match(Set dst (LShiftL dst cnt));
 9380   effect(KILL cr);
 9381   ins_cost(200);
 9382   format %{ &quot;SHLD   $dst.hi,$dst.lo,$cnt\n\t&quot;
 9383             &quot;SHL    $dst.lo,$cnt&quot; %}
 9384   opcode(0xC1, 0x4, 0xA4);  /* 0F/A4, then C1 /4 ib */
 9385   ins_encode( move_long_small_shift(dst,cnt) );
 9386   ins_pipe( ialu_reg_long );
 9387 %}
 9388 
 9389 // Shift Left Long by 32-63
 9390 instruct shlL_eReg_32_63(eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9391   match(Set dst (LShiftL dst cnt));
 9392   effect(KILL cr);
 9393   ins_cost(300);
 9394   format %{ &quot;MOV    $dst.hi,$dst.lo\n&quot;
 9395           &quot;\tSHL    $dst.hi,$cnt-32\n&quot;
 9396           &quot;\tXOR    $dst.lo,$dst.lo&quot; %}
 9397   opcode(0xC1, 0x4);  /* C1 /4 ib */
 9398   ins_encode( move_long_big_shift_clr(dst,cnt) );
 9399   ins_pipe( ialu_reg_long );
 9400 %}
 9401 
 9402 // Shift Left Long by variable
 9403 instruct salL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9404   match(Set dst (LShiftL dst shift));
 9405   effect(KILL cr);
 9406   ins_cost(500+200);
 9407   size(17);
 9408   format %{ &quot;TEST   $shift,32\n\t&quot;
 9409             &quot;JEQ,s  small\n\t&quot;
 9410             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 9411             &quot;XOR    $dst.lo,$dst.lo\n&quot;
 9412     &quot;small:\tSHLD   $dst.hi,$dst.lo,$shift\n\t&quot;
 9413             &quot;SHL    $dst.lo,$shift&quot; %}
 9414   ins_encode( shift_left_long( dst, shift ) );
 9415   ins_pipe( pipe_slow );
 9416 %}
 9417 
 9418 // Shift Right Long by 1-31
 9419 instruct shrL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9420   match(Set dst (URShiftL dst cnt));
 9421   effect(KILL cr);
 9422   ins_cost(200);
 9423   format %{ &quot;SHRD   $dst.lo,$dst.hi,$cnt\n\t&quot;
 9424             &quot;SHR    $dst.hi,$cnt&quot; %}
 9425   opcode(0xC1, 0x5, 0xAC);  /* 0F/AC, then C1 /5 ib */
 9426   ins_encode( move_long_small_shift(dst,cnt) );
 9427   ins_pipe( ialu_reg_long );
 9428 %}
 9429 
 9430 // Shift Right Long by 32-63
 9431 instruct shrL_eReg_32_63(eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9432   match(Set dst (URShiftL dst cnt));
 9433   effect(KILL cr);
 9434   ins_cost(300);
 9435   format %{ &quot;MOV    $dst.lo,$dst.hi\n&quot;
 9436           &quot;\tSHR    $dst.lo,$cnt-32\n&quot;
 9437           &quot;\tXOR    $dst.hi,$dst.hi&quot; %}
 9438   opcode(0xC1, 0x5);  /* C1 /5 ib */
 9439   ins_encode( move_long_big_shift_clr(dst,cnt) );
 9440   ins_pipe( ialu_reg_long );
 9441 %}
 9442 
 9443 // Shift Right Long by variable
 9444 instruct shrL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9445   match(Set dst (URShiftL dst shift));
 9446   effect(KILL cr);
 9447   ins_cost(600);
 9448   size(17);
 9449   format %{ &quot;TEST   $shift,32\n\t&quot;
 9450             &quot;JEQ,s  small\n\t&quot;
 9451             &quot;MOV    $dst.lo,$dst.hi\n\t&quot;
 9452             &quot;XOR    $dst.hi,$dst.hi\n&quot;
 9453     &quot;small:\tSHRD   $dst.lo,$dst.hi,$shift\n\t&quot;
 9454             &quot;SHR    $dst.hi,$shift&quot; %}
 9455   ins_encode( shift_right_long( dst, shift ) );
 9456   ins_pipe( pipe_slow );
 9457 %}
 9458 
 9459 // Shift Right Long by 1-31
 9460 instruct sarL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9461   match(Set dst (RShiftL dst cnt));
 9462   effect(KILL cr);
 9463   ins_cost(200);
 9464   format %{ &quot;SHRD   $dst.lo,$dst.hi,$cnt\n\t&quot;
 9465             &quot;SAR    $dst.hi,$cnt&quot; %}
 9466   opcode(0xC1, 0x7, 0xAC);  /* 0F/AC, then C1 /7 ib */
 9467   ins_encode( move_long_small_shift(dst,cnt) );
 9468   ins_pipe( ialu_reg_long );
 9469 %}
 9470 
 9471 // Shift Right Long by 32-63
 9472 instruct sarL_eReg_32_63( eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9473   match(Set dst (RShiftL dst cnt));
 9474   effect(KILL cr);
 9475   ins_cost(300);
 9476   format %{ &quot;MOV    $dst.lo,$dst.hi\n&quot;
 9477           &quot;\tSAR    $dst.lo,$cnt-32\n&quot;
 9478           &quot;\tSAR    $dst.hi,31&quot; %}
 9479   opcode(0xC1, 0x7);  /* C1 /7 ib */
 9480   ins_encode( move_long_big_shift_sign(dst,cnt) );
 9481   ins_pipe( ialu_reg_long );
 9482 %}
 9483 
 9484 // Shift Right arithmetic Long by variable
 9485 instruct sarL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9486   match(Set dst (RShiftL dst shift));
 9487   effect(KILL cr);
 9488   ins_cost(600);
 9489   size(18);
 9490   format %{ &quot;TEST   $shift,32\n\t&quot;
 9491             &quot;JEQ,s  small\n\t&quot;
 9492             &quot;MOV    $dst.lo,$dst.hi\n\t&quot;
 9493             &quot;SAR    $dst.hi,31\n&quot;
 9494     &quot;small:\tSHRD   $dst.lo,$dst.hi,$shift\n\t&quot;
 9495             &quot;SAR    $dst.hi,$shift&quot; %}
 9496   ins_encode( shift_right_arith_long( dst, shift ) );
 9497   ins_pipe( pipe_slow );
 9498 %}
 9499 
 9500 
 9501 //----------Double Instructions------------------------------------------------
 9502 // Double Math
 9503 
 9504 // Compare &amp; branch
 9505 
 9506 // P6 version of float compare, sets condition codes in EFLAGS
 9507 instruct cmpDPR_cc_P6(eFlagsRegU cr, regDPR src1, regDPR src2, eAXRegI rax) %{
 9508   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE &lt;=1);
 9509   match(Set cr (CmpD src1 src2));
 9510   effect(KILL rax);
 9511   ins_cost(150);
 9512   format %{ &quot;FLD    $src1\n\t&quot;
 9513             &quot;FUCOMIP ST,$src2  // P6 instruction\n\t&quot;
 9514             &quot;JNP    exit\n\t&quot;
 9515             &quot;MOV    ah,1       // saw a NaN, set CF\n\t&quot;
 9516             &quot;SAHF\n&quot;
 9517      &quot;exit:\tNOP               // avoid branch to branch&quot; %}
 9518   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
 9519   ins_encode( Push_Reg_DPR(src1),
 9520               OpcP, RegOpc(src2),
 9521               cmpF_P6_fixup );
 9522   ins_pipe( pipe_slow );
 9523 %}
 9524 
 9525 instruct cmpDPR_cc_P6CF(eFlagsRegUCF cr, regDPR src1, regDPR src2) %{
 9526   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE &lt;=1);
 9527   match(Set cr (CmpD src1 src2));
 9528   ins_cost(150);
 9529   format %{ &quot;FLD    $src1\n\t&quot;
 9530             &quot;FUCOMIP ST,$src2  // P6 instruction&quot; %}
 9531   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
 9532   ins_encode( Push_Reg_DPR(src1),
 9533               OpcP, RegOpc(src2));
 9534   ins_pipe( pipe_slow );
 9535 %}
 9536 
 9537 // Compare &amp; branch
 9538 instruct cmpDPR_cc(eFlagsRegU cr, regDPR src1, regDPR src2, eAXRegI rax) %{
 9539   predicate(UseSSE&lt;=1);
 9540   match(Set cr (CmpD src1 src2));
 9541   effect(KILL rax);
 9542   ins_cost(200);
 9543   format %{ &quot;FLD    $src1\n\t&quot;
 9544             &quot;FCOMp  $src2\n\t&quot;
 9545             &quot;FNSTSW AX\n\t&quot;
 9546             &quot;TEST   AX,0x400\n\t&quot;
 9547             &quot;JZ,s   flags\n\t&quot;
 9548             &quot;MOV    AH,1\t# unordered treat as LT\n&quot;
 9549     &quot;flags:\tSAHF&quot; %}
 9550   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
 9551   ins_encode( Push_Reg_DPR(src1),
 9552               OpcP, RegOpc(src2),
 9553               fpu_flags);
 9554   ins_pipe( pipe_slow );
 9555 %}
 9556 
 9557 // Compare vs zero into -1,0,1
 9558 instruct cmpDPR_0(rRegI dst, regDPR src1, immDPR0 zero, eAXRegI rax, eFlagsReg cr) %{
 9559   predicate(UseSSE&lt;=1);
 9560   match(Set dst (CmpD3 src1 zero));
 9561   effect(KILL cr, KILL rax);
 9562   ins_cost(280);
 9563   format %{ &quot;FTSTD  $dst,$src1&quot; %}
 9564   opcode(0xE4, 0xD9);
 9565   ins_encode( Push_Reg_DPR(src1),
 9566               OpcS, OpcP, PopFPU,
 9567               CmpF_Result(dst));
 9568   ins_pipe( pipe_slow );
 9569 %}
 9570 
 9571 // Compare into -1,0,1
 9572 instruct cmpDPR_reg(rRegI dst, regDPR src1, regDPR src2, eAXRegI rax, eFlagsReg cr) %{
 9573   predicate(UseSSE&lt;=1);
 9574   match(Set dst (CmpD3 src1 src2));
 9575   effect(KILL cr, KILL rax);
 9576   ins_cost(300);
 9577   format %{ &quot;FCMPD  $dst,$src1,$src2&quot; %}
 9578   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
 9579   ins_encode( Push_Reg_DPR(src1),
 9580               OpcP, RegOpc(src2),
 9581               CmpF_Result(dst));
 9582   ins_pipe( pipe_slow );
 9583 %}
 9584 
 9585 // float compare and set condition codes in EFLAGS by XMM regs
 9586 instruct cmpD_cc(eFlagsRegU cr, regD src1, regD src2) %{
 9587   predicate(UseSSE&gt;=2);
 9588   match(Set cr (CmpD src1 src2));
 9589   ins_cost(145);
 9590   format %{ &quot;UCOMISD $src1,$src2\n\t&quot;
 9591             &quot;JNP,s   exit\n\t&quot;
 9592             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
 9593             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
 9594             &quot;POPF\n&quot;
 9595     &quot;exit:&quot; %}
 9596   ins_encode %{
 9597     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9598     emit_cmpfp_fixup(_masm);
 9599   %}
 9600   ins_pipe( pipe_slow );
 9601 %}
 9602 
 9603 instruct cmpD_ccCF(eFlagsRegUCF cr, regD src1, regD src2) %{
 9604   predicate(UseSSE&gt;=2);
 9605   match(Set cr (CmpD src1 src2));
 9606   ins_cost(100);
 9607   format %{ &quot;UCOMISD $src1,$src2&quot; %}
 9608   ins_encode %{
 9609     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9610   %}
 9611   ins_pipe( pipe_slow );
 9612 %}
 9613 
 9614 // float compare and set condition codes in EFLAGS by XMM regs
 9615 instruct cmpD_ccmem(eFlagsRegU cr, regD src1, memory src2) %{
 9616   predicate(UseSSE&gt;=2);
 9617   match(Set cr (CmpD src1 (LoadD src2)));
 9618   ins_cost(145);
 9619   format %{ &quot;UCOMISD $src1,$src2\n\t&quot;
 9620             &quot;JNP,s   exit\n\t&quot;
 9621             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
 9622             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
 9623             &quot;POPF\n&quot;
 9624     &quot;exit:&quot; %}
 9625   ins_encode %{
 9626     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9627     emit_cmpfp_fixup(_masm);
 9628   %}
 9629   ins_pipe( pipe_slow );
 9630 %}
 9631 
 9632 instruct cmpD_ccmemCF(eFlagsRegUCF cr, regD src1, memory src2) %{
 9633   predicate(UseSSE&gt;=2);
 9634   match(Set cr (CmpD src1 (LoadD src2)));
 9635   ins_cost(100);
 9636   format %{ &quot;UCOMISD $src1,$src2&quot; %}
 9637   ins_encode %{
 9638     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9639   %}
 9640   ins_pipe( pipe_slow );
 9641 %}
 9642 
 9643 // Compare into -1,0,1 in XMM
 9644 instruct cmpD_reg(xRegI dst, regD src1, regD src2, eFlagsReg cr) %{
 9645   predicate(UseSSE&gt;=2);
 9646   match(Set dst (CmpD3 src1 src2));
 9647   effect(KILL cr);
 9648   ins_cost(255);
 9649   format %{ &quot;UCOMISD $src1, $src2\n\t&quot;
 9650             &quot;MOV     $dst, #-1\n\t&quot;
 9651             &quot;JP,s    done\n\t&quot;
 9652             &quot;JB,s    done\n\t&quot;
 9653             &quot;SETNE   $dst\n\t&quot;
 9654             &quot;MOVZB   $dst, $dst\n&quot;
 9655     &quot;done:&quot; %}
 9656   ins_encode %{
 9657     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9658     emit_cmpfp3(_masm, $dst$$Register);
 9659   %}
 9660   ins_pipe( pipe_slow );
 9661 %}
 9662 
 9663 // Compare into -1,0,1 in XMM and memory
 9664 instruct cmpD_regmem(xRegI dst, regD src1, memory src2, eFlagsReg cr) %{
 9665   predicate(UseSSE&gt;=2);
 9666   match(Set dst (CmpD3 src1 (LoadD src2)));
 9667   effect(KILL cr);
 9668   ins_cost(275);
 9669   format %{ &quot;UCOMISD $src1, $src2\n\t&quot;
 9670             &quot;MOV     $dst, #-1\n\t&quot;
 9671             &quot;JP,s    done\n\t&quot;
 9672             &quot;JB,s    done\n\t&quot;
 9673             &quot;SETNE   $dst\n\t&quot;
 9674             &quot;MOVZB   $dst, $dst\n&quot;
 9675     &quot;done:&quot; %}
 9676   ins_encode %{
 9677     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9678     emit_cmpfp3(_masm, $dst$$Register);
 9679   %}
 9680   ins_pipe( pipe_slow );
 9681 %}
 9682 
 9683 
 9684 instruct subDPR_reg(regDPR dst, regDPR src) %{
 9685   predicate (UseSSE &lt;=1);
 9686   match(Set dst (SubD dst src));
 9687 
 9688   format %{ &quot;FLD    $src\n\t&quot;
 9689             &quot;DSUBp  $dst,ST&quot; %}
 9690   opcode(0xDE, 0x5); /* DE E8+i  or DE /5 */
 9691   ins_cost(150);
 9692   ins_encode( Push_Reg_DPR(src),
 9693               OpcP, RegOpc(dst) );
 9694   ins_pipe( fpu_reg_reg );
 9695 %}
 9696 
 9697 instruct subDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9698   predicate (UseSSE &lt;=1);
 9699   match(Set dst (RoundDouble (SubD src1 src2)));
 9700   ins_cost(250);
 9701 
 9702   format %{ &quot;FLD    $src2\n\t&quot;
 9703             &quot;DSUB   ST,$src1\n\t&quot;
 9704             &quot;FSTP_D $dst\t# D-round&quot; %}
 9705   opcode(0xD8, 0x5);
 9706   ins_encode( Push_Reg_DPR(src2),
 9707               OpcP, RegOpc(src1), Pop_Mem_DPR(dst) );
 9708   ins_pipe( fpu_mem_reg_reg );
 9709 %}
 9710 
 9711 
 9712 instruct subDPR_reg_mem(regDPR dst, memory src) %{
 9713   predicate (UseSSE &lt;=1);
 9714   match(Set dst (SubD dst (LoadD src)));
 9715   ins_cost(150);
 9716 
 9717   format %{ &quot;FLD    $src\n\t&quot;
 9718             &quot;DSUBp  $dst,ST&quot; %}
 9719   opcode(0xDE, 0x5, 0xDD); /* DE C0+i */  /* LoadD  DD /0 */
 9720   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9721               OpcP, RegOpc(dst) );
 9722   ins_pipe( fpu_reg_mem );
 9723 %}
 9724 
 9725 instruct absDPR_reg(regDPR1 dst, regDPR1 src) %{
 9726   predicate (UseSSE&lt;=1);
 9727   match(Set dst (AbsD src));
 9728   ins_cost(100);
 9729   format %{ &quot;FABS&quot; %}
 9730   opcode(0xE1, 0xD9);
 9731   ins_encode( OpcS, OpcP );
 9732   ins_pipe( fpu_reg_reg );
 9733 %}
 9734 
 9735 instruct negDPR_reg(regDPR1 dst, regDPR1 src) %{
 9736   predicate(UseSSE&lt;=1);
 9737   match(Set dst (NegD src));
 9738   ins_cost(100);
 9739   format %{ &quot;FCHS&quot; %}
 9740   opcode(0xE0, 0xD9);
 9741   ins_encode( OpcS, OpcP );
 9742   ins_pipe( fpu_reg_reg );
 9743 %}
 9744 
 9745 instruct addDPR_reg(regDPR dst, regDPR src) %{
 9746   predicate(UseSSE&lt;=1);
 9747   match(Set dst (AddD dst src));
 9748   format %{ &quot;FLD    $src\n\t&quot;
 9749             &quot;DADD   $dst,ST&quot; %}
 9750   size(4);
 9751   ins_cost(150);
 9752   opcode(0xDE, 0x0); /* DE C0+i or DE /0*/
 9753   ins_encode( Push_Reg_DPR(src),
 9754               OpcP, RegOpc(dst) );
 9755   ins_pipe( fpu_reg_reg );
 9756 %}
 9757 
 9758 
 9759 instruct addDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9760   predicate(UseSSE&lt;=1);
 9761   match(Set dst (RoundDouble (AddD src1 src2)));
 9762   ins_cost(250);
 9763 
 9764   format %{ &quot;FLD    $src2\n\t&quot;
 9765             &quot;DADD   ST,$src1\n\t&quot;
 9766             &quot;FSTP_D $dst\t# D-round&quot; %}
 9767   opcode(0xD8, 0x0); /* D8 C0+i or D8 /0*/
 9768   ins_encode( Push_Reg_DPR(src2),
 9769               OpcP, RegOpc(src1), Pop_Mem_DPR(dst) );
 9770   ins_pipe( fpu_mem_reg_reg );
 9771 %}
 9772 
 9773 
 9774 instruct addDPR_reg_mem(regDPR dst, memory src) %{
 9775   predicate(UseSSE&lt;=1);
 9776   match(Set dst (AddD dst (LoadD src)));
 9777   ins_cost(150);
 9778 
 9779   format %{ &quot;FLD    $src\n\t&quot;
 9780             &quot;DADDp  $dst,ST&quot; %}
 9781   opcode(0xDE, 0x0, 0xDD); /* DE C0+i */  /* LoadD  DD /0 */
 9782   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9783               OpcP, RegOpc(dst) );
 9784   ins_pipe( fpu_reg_mem );
 9785 %}
 9786 
 9787 // add-to-memory
 9788 instruct addDPR_mem_reg(memory dst, regDPR src) %{
 9789   predicate(UseSSE&lt;=1);
 9790   match(Set dst (StoreD dst (RoundDouble (AddD (LoadD dst) src))));
 9791   ins_cost(150);
 9792 
 9793   format %{ &quot;FLD_D  $dst\n\t&quot;
 9794             &quot;DADD   ST,$src\n\t&quot;
 9795             &quot;FST_D  $dst&quot; %}
 9796   opcode(0xDD, 0x0);
 9797   ins_encode( Opcode(0xDD), RMopc_Mem(0x00,dst),
 9798               Opcode(0xD8), RegOpc(src),
 9799               set_instruction_start,
 9800               Opcode(0xDD), RMopc_Mem(0x03,dst) );
 9801   ins_pipe( fpu_reg_mem );
 9802 %}
 9803 
 9804 instruct addDPR_reg_imm1(regDPR dst, immDPR1 con) %{
 9805   predicate(UseSSE&lt;=1);
 9806   match(Set dst (AddD dst con));
 9807   ins_cost(125);
 9808   format %{ &quot;FLD1\n\t&quot;
 9809             &quot;DADDp  $dst,ST&quot; %}
 9810   ins_encode %{
 9811     __ fld1();
 9812     __ faddp($dst$$reg);
 9813   %}
 9814   ins_pipe(fpu_reg);
 9815 %}
 9816 
 9817 instruct addDPR_reg_imm(regDPR dst, immDPR con) %{
 9818   predicate(UseSSE&lt;=1 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9819   match(Set dst (AddD dst con));
 9820   ins_cost(200);
 9821   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9822             &quot;DADDp  $dst,ST&quot; %}
 9823   ins_encode %{
 9824     __ fld_d($constantaddress($con));
 9825     __ faddp($dst$$reg);
 9826   %}
 9827   ins_pipe(fpu_reg_mem);
 9828 %}
 9829 
 9830 instruct addDPR_reg_imm_round(stackSlotD dst, regDPR src, immDPR con) %{
 9831   predicate(UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9832   match(Set dst (RoundDouble (AddD src con)));
 9833   ins_cost(200);
 9834   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9835             &quot;DADD   ST,$src\n\t&quot;
 9836             &quot;FSTP_D $dst\t# D-round&quot; %}
 9837   ins_encode %{
 9838     __ fld_d($constantaddress($con));
 9839     __ fadd($src$$reg);
 9840     __ fstp_d(Address(rsp, $dst$$disp));
 9841   %}
 9842   ins_pipe(fpu_mem_reg_con);
 9843 %}
 9844 
 9845 instruct mulDPR_reg(regDPR dst, regDPR src) %{
 9846   predicate(UseSSE&lt;=1);
 9847   match(Set dst (MulD dst src));
 9848   format %{ &quot;FLD    $src\n\t&quot;
 9849             &quot;DMULp  $dst,ST&quot; %}
 9850   opcode(0xDE, 0x1); /* DE C8+i or DE /1*/
 9851   ins_cost(150);
 9852   ins_encode( Push_Reg_DPR(src),
 9853               OpcP, RegOpc(dst) );
 9854   ins_pipe( fpu_reg_reg );
 9855 %}
 9856 
 9857 // Strict FP instruction biases argument before multiply then
 9858 // biases result to avoid double rounding of subnormals.
 9859 //
 9860 // scale arg1 by multiplying arg1 by 2^(-15360)
 9861 // load arg2
 9862 // multiply scaled arg1 by arg2
 9863 // rescale product by 2^(15360)
 9864 //
 9865 instruct strictfp_mulDPR_reg(regDPR1 dst, regnotDPR1 src) %{
 9866   predicate( UseSSE&lt;=1 &amp;&amp; Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict() );
 9867   match(Set dst (MulD dst src));
 9868   ins_cost(1);   // Select this instruction for all strict FP double multiplies
 9869 
 9870   format %{ &quot;FLD    StubRoutines::_fpu_subnormal_bias1\n\t&quot;
 9871             &quot;DMULp  $dst,ST\n\t&quot;
 9872             &quot;FLD    $src\n\t&quot;
 9873             &quot;DMULp  $dst,ST\n\t&quot;
 9874             &quot;FLD    StubRoutines::_fpu_subnormal_bias2\n\t&quot;
 9875             &quot;DMULp  $dst,ST\n\t&quot; %}
 9876   opcode(0xDE, 0x1); /* DE C8+i or DE /1*/
 9877   ins_encode( strictfp_bias1(dst),
 9878               Push_Reg_DPR(src),
 9879               OpcP, RegOpc(dst),
 9880               strictfp_bias2(dst) );
 9881   ins_pipe( fpu_reg_reg );
 9882 %}
 9883 
 9884 instruct mulDPR_reg_imm(regDPR dst, immDPR con) %{
 9885   predicate( UseSSE&lt;=1 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9886   match(Set dst (MulD dst con));
 9887   ins_cost(200);
 9888   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9889             &quot;DMULp  $dst,ST&quot; %}
 9890   ins_encode %{
 9891     __ fld_d($constantaddress($con));
 9892     __ fmulp($dst$$reg);
 9893   %}
 9894   ins_pipe(fpu_reg_mem);
 9895 %}
 9896 
 9897 
 9898 instruct mulDPR_reg_mem(regDPR dst, memory src) %{
 9899   predicate( UseSSE&lt;=1 );
 9900   match(Set dst (MulD dst (LoadD src)));
 9901   ins_cost(200);
 9902   format %{ &quot;FLD_D  $src\n\t&quot;
 9903             &quot;DMULp  $dst,ST&quot; %}
 9904   opcode(0xDE, 0x1, 0xDD); /* DE C8+i or DE /1*/  /* LoadD  DD /0 */
 9905   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9906               OpcP, RegOpc(dst) );
 9907   ins_pipe( fpu_reg_mem );
 9908 %}
 9909 
 9910 //
 9911 // Cisc-alternate to reg-reg multiply
 9912 instruct mulDPR_reg_mem_cisc(regDPR dst, regDPR src, memory mem) %{
 9913   predicate( UseSSE&lt;=1 );
 9914   match(Set dst (MulD src (LoadD mem)));
 9915   ins_cost(250);
 9916   format %{ &quot;FLD_D  $mem\n\t&quot;
 9917             &quot;DMUL   ST,$src\n\t&quot;
 9918             &quot;FSTP_D $dst&quot; %}
 9919   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i */  /* LoadD D9 /0 */
 9920   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem),
 9921               OpcReg_FPR(src),
 9922               Pop_Reg_DPR(dst) );
 9923   ins_pipe( fpu_reg_reg_mem );
 9924 %}
 9925 
 9926 
 9927 // MACRO3 -- addDPR a mulDPR
 9928 // This instruction is a &#39;2-address&#39; instruction in that the result goes
 9929 // back to src2.  This eliminates a move from the macro; possibly the
 9930 // register allocator will have to add it back (and maybe not).
 9931 instruct addDPR_mulDPR_reg(regDPR src2, regDPR src1, regDPR src0) %{
 9932   predicate( UseSSE&lt;=1 );
 9933   match(Set src2 (AddD (MulD src0 src1) src2));
 9934   format %{ &quot;FLD    $src0\t# ===MACRO3d===\n\t&quot;
 9935             &quot;DMUL   ST,$src1\n\t&quot;
 9936             &quot;DADDp  $src2,ST&quot; %}
 9937   ins_cost(250);
 9938   opcode(0xDD); /* LoadD DD /0 */
 9939   ins_encode( Push_Reg_FPR(src0),
 9940               FMul_ST_reg(src1),
 9941               FAddP_reg_ST(src2) );
 9942   ins_pipe( fpu_reg_reg_reg );
 9943 %}
 9944 
 9945 
 9946 // MACRO3 -- subDPR a mulDPR
 9947 instruct subDPR_mulDPR_reg(regDPR src2, regDPR src1, regDPR src0) %{
 9948   predicate( UseSSE&lt;=1 );
 9949   match(Set src2 (SubD (MulD src0 src1) src2));
 9950   format %{ &quot;FLD    $src0\t# ===MACRO3d===\n\t&quot;
 9951             &quot;DMUL   ST,$src1\n\t&quot;
 9952             &quot;DSUBRp $src2,ST&quot; %}
 9953   ins_cost(250);
 9954   ins_encode( Push_Reg_FPR(src0),
 9955               FMul_ST_reg(src1),
 9956               Opcode(0xDE), Opc_plus(0xE0,src2));
 9957   ins_pipe( fpu_reg_reg_reg );
 9958 %}
 9959 
 9960 
 9961 instruct divDPR_reg(regDPR dst, regDPR src) %{
 9962   predicate( UseSSE&lt;=1 );
 9963   match(Set dst (DivD dst src));
 9964 
 9965   format %{ &quot;FLD    $src\n\t&quot;
 9966             &quot;FDIVp  $dst,ST&quot; %}
 9967   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
 9968   ins_cost(150);
 9969   ins_encode( Push_Reg_DPR(src),
 9970               OpcP, RegOpc(dst) );
 9971   ins_pipe( fpu_reg_reg );
 9972 %}
 9973 
 9974 // Strict FP instruction biases argument before division then
 9975 // biases result, to avoid double rounding of subnormals.
 9976 //
 9977 // scale dividend by multiplying dividend by 2^(-15360)
 9978 // load divisor
 9979 // divide scaled dividend by divisor
 9980 // rescale quotient by 2^(15360)
 9981 //
 9982 instruct strictfp_divDPR_reg(regDPR1 dst, regnotDPR1 src) %{
 9983   predicate (UseSSE&lt;=1);
 9984   match(Set dst (DivD dst src));
 9985   predicate( UseSSE&lt;=1 &amp;&amp; Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict() );
 9986   ins_cost(01);
 9987 
 9988   format %{ &quot;FLD    StubRoutines::_fpu_subnormal_bias1\n\t&quot;
 9989             &quot;DMULp  $dst,ST\n\t&quot;
 9990             &quot;FLD    $src\n\t&quot;
 9991             &quot;FDIVp  $dst,ST\n\t&quot;
 9992             &quot;FLD    StubRoutines::_fpu_subnormal_bias2\n\t&quot;
 9993             &quot;DMULp  $dst,ST\n\t&quot; %}
 9994   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
 9995   ins_encode( strictfp_bias1(dst),
 9996               Push_Reg_DPR(src),
 9997               OpcP, RegOpc(dst),
 9998               strictfp_bias2(dst) );
 9999   ins_pipe( fpu_reg_reg );
10000 %}
10001 
10002 instruct divDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
10003   predicate( UseSSE&lt;=1 &amp;&amp; !(Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict()) );
10004   match(Set dst (RoundDouble (DivD src1 src2)));
10005 
10006   format %{ &quot;FLD    $src1\n\t&quot;
10007             &quot;FDIV   ST,$src2\n\t&quot;
10008             &quot;FSTP_D $dst\t# D-round&quot; %}
10009   opcode(0xD8, 0x6); /* D8 F0+i or D8 /6 */
10010   ins_encode( Push_Reg_DPR(src1),
10011               OpcP, RegOpc(src2), Pop_Mem_DPR(dst) );
10012   ins_pipe( fpu_mem_reg_reg );
10013 %}
10014 
10015 
10016 instruct modDPR_reg(regDPR dst, regDPR src, eAXRegI rax, eFlagsReg cr) %{
10017   predicate(UseSSE&lt;=1);
10018   match(Set dst (ModD dst src));
10019   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10020 
10021   format %{ &quot;DMOD   $dst,$src&quot; %}
10022   ins_cost(250);
10023   ins_encode(Push_Reg_Mod_DPR(dst, src),
10024               emitModDPR(),
10025               Push_Result_Mod_DPR(src),
10026               Pop_Reg_DPR(dst));
10027   ins_pipe( pipe_slow );
10028 %}
10029 
10030 instruct modD_reg(regD dst, regD src0, regD src1, eAXRegI rax, eFlagsReg cr) %{
10031   predicate(UseSSE&gt;=2);
10032   match(Set dst (ModD src0 src1));
10033   effect(KILL rax, KILL cr);
10034 
10035   format %{ &quot;SUB    ESP,8\t # DMOD\n&quot;
10036           &quot;\tMOVSD  [ESP+0],$src1\n&quot;
10037           &quot;\tFLD_D  [ESP+0]\n&quot;
10038           &quot;\tMOVSD  [ESP+0],$src0\n&quot;
10039           &quot;\tFLD_D  [ESP+0]\n&quot;
10040      &quot;loop:\tFPREM\n&quot;
10041           &quot;\tFWAIT\n&quot;
10042           &quot;\tFNSTSW AX\n&quot;
10043           &quot;\tSAHF\n&quot;
10044           &quot;\tJP     loop\n&quot;
10045           &quot;\tFSTP_D [ESP+0]\n&quot;
10046           &quot;\tMOVSD  $dst,[ESP+0]\n&quot;
10047           &quot;\tADD    ESP,8\n&quot;
10048           &quot;\tFSTP   ST0\t # Restore FPU Stack&quot;
10049     %}
10050   ins_cost(250);
10051   ins_encode( Push_ModD_encoding(src0, src1), emitModDPR(), Push_ResultD(dst), PopFPU);
10052   ins_pipe( pipe_slow );
10053 %}
10054 
10055 instruct atanDPR_reg(regDPR dst, regDPR src) %{
10056   predicate (UseSSE&lt;=1);
10057   match(Set dst(AtanD dst src));
10058   format %{ &quot;DATA   $dst,$src&quot; %}
10059   opcode(0xD9, 0xF3);
10060   ins_encode( Push_Reg_DPR(src),
10061               OpcP, OpcS, RegOpc(dst) );
10062   ins_pipe( pipe_slow );
10063 %}
10064 
10065 instruct atanD_reg(regD dst, regD src, eFlagsReg cr) %{
10066   predicate (UseSSE&gt;=2);
10067   match(Set dst(AtanD dst src));
10068   effect(KILL cr); // Push_{Src|Result}D() uses &quot;{SUB|ADD} ESP,8&quot;
10069   format %{ &quot;DATA   $dst,$src&quot; %}
10070   opcode(0xD9, 0xF3);
10071   ins_encode( Push_SrcD(src),
10072               OpcP, OpcS, Push_ResultD(dst) );
10073   ins_pipe( pipe_slow );
10074 %}
10075 
10076 instruct sqrtDPR_reg(regDPR dst, regDPR src) %{
10077   predicate (UseSSE&lt;=1);
10078   match(Set dst (SqrtD src));
10079   format %{ &quot;DSQRT  $dst,$src&quot; %}
10080   opcode(0xFA, 0xD9);
10081   ins_encode( Push_Reg_DPR(src),
10082               OpcS, OpcP, Pop_Reg_DPR(dst) );
10083   ins_pipe( pipe_slow );
10084 %}
10085 
10086 //-------------Float Instructions-------------------------------
10087 // Float Math
10088 
10089 // Code for float compare:
10090 //     fcompp();
10091 //     fwait(); fnstsw_ax();
10092 //     sahf();
10093 //     movl(dst, unordered_result);
10094 //     jcc(Assembler::parity, exit);
10095 //     movl(dst, less_result);
10096 //     jcc(Assembler::below, exit);
10097 //     movl(dst, equal_result);
10098 //     jcc(Assembler::equal, exit);
10099 //     movl(dst, greater_result);
10100 //   exit:
10101 
10102 // P6 version of float compare, sets condition codes in EFLAGS
10103 instruct cmpFPR_cc_P6(eFlagsRegU cr, regFPR src1, regFPR src2, eAXRegI rax) %{
10104   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE == 0);
10105   match(Set cr (CmpF src1 src2));
10106   effect(KILL rax);
10107   ins_cost(150);
10108   format %{ &quot;FLD    $src1\n\t&quot;
10109             &quot;FUCOMIP ST,$src2  // P6 instruction\n\t&quot;
10110             &quot;JNP    exit\n\t&quot;
10111             &quot;MOV    ah,1       // saw a NaN, set CF (treat as LT)\n\t&quot;
10112             &quot;SAHF\n&quot;
10113      &quot;exit:\tNOP               // avoid branch to branch&quot; %}
10114   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
10115   ins_encode( Push_Reg_DPR(src1),
10116               OpcP, RegOpc(src2),
10117               cmpF_P6_fixup );
10118   ins_pipe( pipe_slow );
10119 %}
10120 
10121 instruct cmpFPR_cc_P6CF(eFlagsRegUCF cr, regFPR src1, regFPR src2) %{
10122   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE == 0);
10123   match(Set cr (CmpF src1 src2));
10124   ins_cost(100);
10125   format %{ &quot;FLD    $src1\n\t&quot;
10126             &quot;FUCOMIP ST,$src2  // P6 instruction&quot; %}
10127   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
10128   ins_encode( Push_Reg_DPR(src1),
10129               OpcP, RegOpc(src2));
10130   ins_pipe( pipe_slow );
10131 %}
10132 
10133 
10134 // Compare &amp; branch
10135 instruct cmpFPR_cc(eFlagsRegU cr, regFPR src1, regFPR src2, eAXRegI rax) %{
10136   predicate(UseSSE == 0);
10137   match(Set cr (CmpF src1 src2));
10138   effect(KILL rax);
10139   ins_cost(200);
10140   format %{ &quot;FLD    $src1\n\t&quot;
10141             &quot;FCOMp  $src2\n\t&quot;
10142             &quot;FNSTSW AX\n\t&quot;
10143             &quot;TEST   AX,0x400\n\t&quot;
10144             &quot;JZ,s   flags\n\t&quot;
10145             &quot;MOV    AH,1\t# unordered treat as LT\n&quot;
10146     &quot;flags:\tSAHF&quot; %}
10147   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
10148   ins_encode( Push_Reg_DPR(src1),
10149               OpcP, RegOpc(src2),
10150               fpu_flags);
10151   ins_pipe( pipe_slow );
10152 %}
10153 
10154 // Compare vs zero into -1,0,1
10155 instruct cmpFPR_0(rRegI dst, regFPR src1, immFPR0 zero, eAXRegI rax, eFlagsReg cr) %{
10156   predicate(UseSSE == 0);
10157   match(Set dst (CmpF3 src1 zero));
10158   effect(KILL cr, KILL rax);
10159   ins_cost(280);
10160   format %{ &quot;FTSTF  $dst,$src1&quot; %}
10161   opcode(0xE4, 0xD9);
10162   ins_encode( Push_Reg_DPR(src1),
10163               OpcS, OpcP, PopFPU,
10164               CmpF_Result(dst));
10165   ins_pipe( pipe_slow );
10166 %}
10167 
10168 // Compare into -1,0,1
10169 instruct cmpFPR_reg(rRegI dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{
10170   predicate(UseSSE == 0);
10171   match(Set dst (CmpF3 src1 src2));
10172   effect(KILL cr, KILL rax);
10173   ins_cost(300);
10174   format %{ &quot;FCMPF  $dst,$src1,$src2&quot; %}
10175   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
10176   ins_encode( Push_Reg_DPR(src1),
10177               OpcP, RegOpc(src2),
10178               CmpF_Result(dst));
10179   ins_pipe( pipe_slow );
10180 %}
10181 
10182 // float compare and set condition codes in EFLAGS by XMM regs
10183 instruct cmpF_cc(eFlagsRegU cr, regF src1, regF src2) %{
10184   predicate(UseSSE&gt;=1);
10185   match(Set cr (CmpF src1 src2));
10186   ins_cost(145);
10187   format %{ &quot;UCOMISS $src1,$src2\n\t&quot;
10188             &quot;JNP,s   exit\n\t&quot;
10189             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
10190             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
10191             &quot;POPF\n&quot;
10192     &quot;exit:&quot; %}
10193   ins_encode %{
10194     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10195     emit_cmpfp_fixup(_masm);
10196   %}
10197   ins_pipe( pipe_slow );
10198 %}
10199 
10200 instruct cmpF_ccCF(eFlagsRegUCF cr, regF src1, regF src2) %{
10201   predicate(UseSSE&gt;=1);
10202   match(Set cr (CmpF src1 src2));
10203   ins_cost(100);
10204   format %{ &quot;UCOMISS $src1,$src2&quot; %}
10205   ins_encode %{
10206     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10207   %}
10208   ins_pipe( pipe_slow );
10209 %}
10210 
10211 // float compare and set condition codes in EFLAGS by XMM regs
10212 instruct cmpF_ccmem(eFlagsRegU cr, regF src1, memory src2) %{
10213   predicate(UseSSE&gt;=1);
10214   match(Set cr (CmpF src1 (LoadF src2)));
10215   ins_cost(165);
10216   format %{ &quot;UCOMISS $src1,$src2\n\t&quot;
10217             &quot;JNP,s   exit\n\t&quot;
10218             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
10219             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
10220             &quot;POPF\n&quot;
10221     &quot;exit:&quot; %}
10222   ins_encode %{
10223     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10224     emit_cmpfp_fixup(_masm);
10225   %}
10226   ins_pipe( pipe_slow );
10227 %}
10228 
10229 instruct cmpF_ccmemCF(eFlagsRegUCF cr, regF src1, memory src2) %{
10230   predicate(UseSSE&gt;=1);
10231   match(Set cr (CmpF src1 (LoadF src2)));
10232   ins_cost(100);
10233   format %{ &quot;UCOMISS $src1,$src2&quot; %}
10234   ins_encode %{
10235     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10236   %}
10237   ins_pipe( pipe_slow );
10238 %}
10239 
10240 // Compare into -1,0,1 in XMM
10241 instruct cmpF_reg(xRegI dst, regF src1, regF src2, eFlagsReg cr) %{
10242   predicate(UseSSE&gt;=1);
10243   match(Set dst (CmpF3 src1 src2));
10244   effect(KILL cr);
10245   ins_cost(255);
10246   format %{ &quot;UCOMISS $src1, $src2\n\t&quot;
10247             &quot;MOV     $dst, #-1\n\t&quot;
10248             &quot;JP,s    done\n\t&quot;
10249             &quot;JB,s    done\n\t&quot;
10250             &quot;SETNE   $dst\n\t&quot;
10251             &quot;MOVZB   $dst, $dst\n&quot;
10252     &quot;done:&quot; %}
10253   ins_encode %{
10254     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10255     emit_cmpfp3(_masm, $dst$$Register);
10256   %}
10257   ins_pipe( pipe_slow );
10258 %}
10259 
10260 // Compare into -1,0,1 in XMM and memory
10261 instruct cmpF_regmem(xRegI dst, regF src1, memory src2, eFlagsReg cr) %{
10262   predicate(UseSSE&gt;=1);
10263   match(Set dst (CmpF3 src1 (LoadF src2)));
10264   effect(KILL cr);
10265   ins_cost(275);
10266   format %{ &quot;UCOMISS $src1, $src2\n\t&quot;
10267             &quot;MOV     $dst, #-1\n\t&quot;
10268             &quot;JP,s    done\n\t&quot;
10269             &quot;JB,s    done\n\t&quot;
10270             &quot;SETNE   $dst\n\t&quot;
10271             &quot;MOVZB   $dst, $dst\n&quot;
10272     &quot;done:&quot; %}
10273   ins_encode %{
10274     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10275     emit_cmpfp3(_masm, $dst$$Register);
10276   %}
10277   ins_pipe( pipe_slow );
10278 %}
10279 
10280 // Spill to obtain 24-bit precision
10281 instruct subFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10282   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10283   match(Set dst (SubF src1 src2));
10284 
10285   format %{ &quot;FSUB   $dst,$src1 - $src2&quot; %}
10286   opcode(0xD8, 0x4); /* D8 E0+i or D8 /4 mod==0x3 ;; result in TOS */
10287   ins_encode( Push_Reg_FPR(src1),
10288               OpcReg_FPR(src2),
10289               Pop_Mem_FPR(dst) );
10290   ins_pipe( fpu_mem_reg_reg );
10291 %}
10292 //
10293 // This instruction does not round to 24-bits
10294 instruct subFPR_reg(regFPR dst, regFPR src) %{
10295   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10296   match(Set dst (SubF dst src));
10297 
10298   format %{ &quot;FSUB   $dst,$src&quot; %}
10299   opcode(0xDE, 0x5); /* DE E8+i  or DE /5 */
10300   ins_encode( Push_Reg_FPR(src),
10301               OpcP, RegOpc(dst) );
10302   ins_pipe( fpu_reg_reg );
10303 %}
10304 
10305 // Spill to obtain 24-bit precision
10306 instruct addFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10307   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10308   match(Set dst (AddF src1 src2));
10309 
10310   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10311   opcode(0xD8, 0x0); /* D8 C0+i */
10312   ins_encode( Push_Reg_FPR(src2),
10313               OpcReg_FPR(src1),
10314               Pop_Mem_FPR(dst) );
10315   ins_pipe( fpu_mem_reg_reg );
10316 %}
10317 //
10318 // This instruction does not round to 24-bits
10319 instruct addFPR_reg(regFPR dst, regFPR src) %{
10320   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10321   match(Set dst (AddF dst src));
10322 
10323   format %{ &quot;FLD    $src\n\t&quot;
10324             &quot;FADDp  $dst,ST&quot; %}
10325   opcode(0xDE, 0x0); /* DE C0+i or DE /0*/
10326   ins_encode( Push_Reg_FPR(src),
10327               OpcP, RegOpc(dst) );
10328   ins_pipe( fpu_reg_reg );
10329 %}
10330 
10331 instruct absFPR_reg(regFPR1 dst, regFPR1 src) %{
10332   predicate(UseSSE==0);
10333   match(Set dst (AbsF src));
10334   ins_cost(100);
10335   format %{ &quot;FABS&quot; %}
10336   opcode(0xE1, 0xD9);
10337   ins_encode( OpcS, OpcP );
10338   ins_pipe( fpu_reg_reg );
10339 %}
10340 
10341 instruct negFPR_reg(regFPR1 dst, regFPR1 src) %{
10342   predicate(UseSSE==0);
10343   match(Set dst (NegF src));
10344   ins_cost(100);
10345   format %{ &quot;FCHS&quot; %}
10346   opcode(0xE0, 0xD9);
10347   ins_encode( OpcS, OpcP );
10348   ins_pipe( fpu_reg_reg );
10349 %}
10350 
10351 // Cisc-alternate to addFPR_reg
10352 // Spill to obtain 24-bit precision
10353 instruct addFPR24_reg_mem(stackSlotF dst, regFPR src1, memory src2) %{
10354   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10355   match(Set dst (AddF src1 (LoadF src2)));
10356 
10357   format %{ &quot;FLD    $src2\n\t&quot;
10358             &quot;FADD   ST,$src1\n\t&quot;
10359             &quot;FSTP_S $dst&quot; %}
10360   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10361   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10362               OpcReg_FPR(src1),
10363               Pop_Mem_FPR(dst) );
10364   ins_pipe( fpu_mem_reg_mem );
10365 %}
10366 //
10367 // Cisc-alternate to addFPR_reg
10368 // This instruction does not round to 24-bits
10369 instruct addFPR_reg_mem(regFPR dst, memory src) %{
10370   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10371   match(Set dst (AddF dst (LoadF src)));
10372 
10373   format %{ &quot;FADD   $dst,$src&quot; %}
10374   opcode(0xDE, 0x0, 0xD9); /* DE C0+i or DE /0*/  /* LoadF  D9 /0 */
10375   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
10376               OpcP, RegOpc(dst) );
10377   ins_pipe( fpu_reg_mem );
10378 %}
10379 
10380 // // Following two instructions for _222_mpegaudio
10381 // Spill to obtain 24-bit precision
10382 instruct addFPR24_mem_reg(stackSlotF dst, regFPR src2, memory src1 ) %{
10383   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10384   match(Set dst (AddF src1 src2));
10385 
10386   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10387   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10388   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src1),
10389               OpcReg_FPR(src2),
10390               Pop_Mem_FPR(dst) );
10391   ins_pipe( fpu_mem_reg_mem );
10392 %}
10393 
10394 // Cisc-spill variant
10395 // Spill to obtain 24-bit precision
10396 instruct addFPR24_mem_cisc(stackSlotF dst, memory src1, memory src2) %{
10397   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10398   match(Set dst (AddF src1 (LoadF src2)));
10399 
10400   format %{ &quot;FADD   $dst,$src1,$src2 cisc&quot; %}
10401   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10402   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10403               set_instruction_start,
10404               OpcP, RMopc_Mem(secondary,src1),
10405               Pop_Mem_FPR(dst) );
10406   ins_pipe( fpu_mem_mem_mem );
10407 %}
10408 
10409 // Spill to obtain 24-bit precision
10410 instruct addFPR24_mem_mem(stackSlotF dst, memory src1, memory src2) %{
10411   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10412   match(Set dst (AddF src1 src2));
10413 
10414   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10415   opcode(0xD8, 0x0, 0xD9); /* D8 /0 */  /* LoadF  D9 /0 */
10416   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10417               set_instruction_start,
10418               OpcP, RMopc_Mem(secondary,src1),
10419               Pop_Mem_FPR(dst) );
10420   ins_pipe( fpu_mem_mem_mem );
10421 %}
10422 
10423 
10424 // Spill to obtain 24-bit precision
10425 instruct addFPR24_reg_imm(stackSlotF dst, regFPR src, immFPR con) %{
10426   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10427   match(Set dst (AddF src con));
10428   format %{ &quot;FLD    $src\n\t&quot;
10429             &quot;FADD_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10430             &quot;FSTP_S $dst&quot;  %}
10431   ins_encode %{
10432     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10433     __ fadd_s($constantaddress($con));
10434     __ fstp_s(Address(rsp, $dst$$disp));
10435   %}
10436   ins_pipe(fpu_mem_reg_con);
10437 %}
10438 //
10439 // This instruction does not round to 24-bits
10440 instruct addFPR_reg_imm(regFPR dst, regFPR src, immFPR con) %{
10441   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10442   match(Set dst (AddF src con));
10443   format %{ &quot;FLD    $src\n\t&quot;
10444             &quot;FADD_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10445             &quot;FSTP   $dst&quot;  %}
10446   ins_encode %{
10447     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10448     __ fadd_s($constantaddress($con));
10449     __ fstp_d($dst$$reg);
10450   %}
10451   ins_pipe(fpu_reg_reg_con);
10452 %}
10453 
10454 // Spill to obtain 24-bit precision
10455 instruct mulFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10456   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10457   match(Set dst (MulF src1 src2));
10458 
10459   format %{ &quot;FLD    $src1\n\t&quot;
10460             &quot;FMUL   $src2\n\t&quot;
10461             &quot;FSTP_S $dst&quot;  %}
10462   opcode(0xD8, 0x1); /* D8 C8+i or D8 /1 ;; result in TOS */
10463   ins_encode( Push_Reg_FPR(src1),
10464               OpcReg_FPR(src2),
10465               Pop_Mem_FPR(dst) );
10466   ins_pipe( fpu_mem_reg_reg );
10467 %}
10468 //
10469 // This instruction does not round to 24-bits
10470 instruct mulFPR_reg(regFPR dst, regFPR src1, regFPR src2) %{
10471   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10472   match(Set dst (MulF src1 src2));
10473 
10474   format %{ &quot;FLD    $src1\n\t&quot;
10475             &quot;FMUL   $src2\n\t&quot;
10476             &quot;FSTP_S $dst&quot;  %}
10477   opcode(0xD8, 0x1); /* D8 C8+i */
10478   ins_encode( Push_Reg_FPR(src2),
10479               OpcReg_FPR(src1),
10480               Pop_Reg_FPR(dst) );
10481   ins_pipe( fpu_reg_reg_reg );
10482 %}
10483 
10484 
10485 // Spill to obtain 24-bit precision
10486 // Cisc-alternate to reg-reg multiply
10487 instruct mulFPR24_reg_mem(stackSlotF dst, regFPR src1, memory src2) %{
10488   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10489   match(Set dst (MulF src1 (LoadF src2)));
10490 
10491   format %{ &quot;FLD_S  $src2\n\t&quot;
10492             &quot;FMUL   $src1\n\t&quot;
10493             &quot;FSTP_S $dst&quot;  %}
10494   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i or DE /1*/  /* LoadF D9 /0 */
10495   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10496               OpcReg_FPR(src1),
10497               Pop_Mem_FPR(dst) );
10498   ins_pipe( fpu_mem_reg_mem );
10499 %}
10500 //
10501 // This instruction does not round to 24-bits
10502 // Cisc-alternate to reg-reg multiply
10503 instruct mulFPR_reg_mem(regFPR dst, regFPR src1, memory src2) %{
10504   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10505   match(Set dst (MulF src1 (LoadF src2)));
10506 
10507   format %{ &quot;FMUL   $dst,$src1,$src2&quot; %}
10508   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i */  /* LoadF D9 /0 */
10509   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10510               OpcReg_FPR(src1),
10511               Pop_Reg_FPR(dst) );
10512   ins_pipe( fpu_reg_reg_mem );
10513 %}
10514 
10515 // Spill to obtain 24-bit precision
10516 instruct mulFPR24_mem_mem(stackSlotF dst, memory src1, memory src2) %{
10517   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10518   match(Set dst (MulF src1 src2));
10519 
10520   format %{ &quot;FMUL   $dst,$src1,$src2&quot; %}
10521   opcode(0xD8, 0x1, 0xD9); /* D8 /1 */  /* LoadF D9 /0 */
10522   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10523               set_instruction_start,
10524               OpcP, RMopc_Mem(secondary,src1),
10525               Pop_Mem_FPR(dst) );
10526   ins_pipe( fpu_mem_mem_mem );
10527 %}
10528 
10529 // Spill to obtain 24-bit precision
10530 instruct mulFPR24_reg_imm(stackSlotF dst, regFPR src, immFPR con) %{
10531   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10532   match(Set dst (MulF src con));
10533 
10534   format %{ &quot;FLD    $src\n\t&quot;
10535             &quot;FMUL_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10536             &quot;FSTP_S $dst&quot;  %}
10537   ins_encode %{
10538     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10539     __ fmul_s($constantaddress($con));
10540     __ fstp_s(Address(rsp, $dst$$disp));
10541   %}
10542   ins_pipe(fpu_mem_reg_con);
10543 %}
10544 //
10545 // This instruction does not round to 24-bits
10546 instruct mulFPR_reg_imm(regFPR dst, regFPR src, immFPR con) %{
10547   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10548   match(Set dst (MulF src con));
10549 
10550   format %{ &quot;FLD    $src\n\t&quot;
10551             &quot;FMUL_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10552             &quot;FSTP   $dst&quot;  %}
10553   ins_encode %{
10554     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10555     __ fmul_s($constantaddress($con));
10556     __ fstp_d($dst$$reg);
10557   %}
10558   ins_pipe(fpu_reg_reg_con);
10559 %}
10560 
10561 
10562 //
10563 // MACRO1 -- subsume unshared load into mulFPR
10564 // This instruction does not round to 24-bits
10565 instruct mulFPR_reg_load1(regFPR dst, regFPR src, memory mem1 ) %{
10566   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10567   match(Set dst (MulF (LoadF mem1) src));
10568 
10569   format %{ &quot;FLD    $mem1    ===MACRO1===\n\t&quot;
10570             &quot;FMUL   ST,$src\n\t&quot;
10571             &quot;FSTP   $dst&quot; %}
10572   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i or D8 /1 */  /* LoadF D9 /0 */
10573   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem1),
10574               OpcReg_FPR(src),
10575               Pop_Reg_FPR(dst) );
10576   ins_pipe( fpu_reg_reg_mem );
10577 %}
10578 //
10579 // MACRO2 -- addFPR a mulFPR which subsumed an unshared load
10580 // This instruction does not round to 24-bits
10581 instruct addFPR_mulFPR_reg_load1(regFPR dst, memory mem1, regFPR src1, regFPR src2) %{
10582   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10583   match(Set dst (AddF (MulF (LoadF mem1) src1) src2));
10584   ins_cost(95);
10585 
10586   format %{ &quot;FLD    $mem1     ===MACRO2===\n\t&quot;
10587             &quot;FMUL   ST,$src1  subsume mulFPR left load\n\t&quot;
10588             &quot;FADD   ST,$src2\n\t&quot;
10589             &quot;FSTP   $dst&quot; %}
10590   opcode(0xD9); /* LoadF D9 /0 */
10591   ins_encode( OpcP, RMopc_Mem(0x00,mem1),
10592               FMul_ST_reg(src1),
10593               FAdd_ST_reg(src2),
10594               Pop_Reg_FPR(dst) );
10595   ins_pipe( fpu_reg_mem_reg_reg );
10596 %}
10597 
10598 // MACRO3 -- addFPR a mulFPR
10599 // This instruction does not round to 24-bits.  It is a &#39;2-address&#39;
10600 // instruction in that the result goes back to src2.  This eliminates
10601 // a move from the macro; possibly the register allocator will have
10602 // to add it back (and maybe not).
10603 instruct addFPR_mulFPR_reg(regFPR src2, regFPR src1, regFPR src0) %{
10604   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10605   match(Set src2 (AddF (MulF src0 src1) src2));
10606 
10607   format %{ &quot;FLD    $src0     ===MACRO3===\n\t&quot;
10608             &quot;FMUL   ST,$src1\n\t&quot;
10609             &quot;FADDP  $src2,ST&quot; %}
10610   opcode(0xD9); /* LoadF D9 /0 */
10611   ins_encode( Push_Reg_FPR(src0),
10612               FMul_ST_reg(src1),
10613               FAddP_reg_ST(src2) );
10614   ins_pipe( fpu_reg_reg_reg );
10615 %}
10616 
10617 // MACRO4 -- divFPR subFPR
10618 // This instruction does not round to 24-bits
10619 instruct subFPR_divFPR_reg(regFPR dst, regFPR src1, regFPR src2, regFPR src3) %{
10620   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10621   match(Set dst (DivF (SubF src2 src1) src3));
10622 
10623   format %{ &quot;FLD    $src2   ===MACRO4===\n\t&quot;
10624             &quot;FSUB   ST,$src1\n\t&quot;
10625             &quot;FDIV   ST,$src3\n\t&quot;
10626             &quot;FSTP  $dst&quot; %}
10627   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
10628   ins_encode( Push_Reg_FPR(src2),
10629               subFPR_divFPR_encode(src1,src3),
10630               Pop_Reg_FPR(dst) );
10631   ins_pipe( fpu_reg_reg_reg_reg );
10632 %}
10633 
10634 // Spill to obtain 24-bit precision
10635 instruct divFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10636   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10637   match(Set dst (DivF src1 src2));
10638 
10639   format %{ &quot;FDIV   $dst,$src1,$src2&quot; %}
10640   opcode(0xD8, 0x6); /* D8 F0+i or DE /6*/
10641   ins_encode( Push_Reg_FPR(src1),
10642               OpcReg_FPR(src2),
10643               Pop_Mem_FPR(dst) );
10644   ins_pipe( fpu_mem_reg_reg );
10645 %}
10646 //
10647 // This instruction does not round to 24-bits
10648 instruct divFPR_reg(regFPR dst, regFPR src) %{
10649   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10650   match(Set dst (DivF dst src));
10651 
10652   format %{ &quot;FDIV   $dst,$src&quot; %}
10653   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
10654   ins_encode( Push_Reg_FPR(src),
10655               OpcP, RegOpc(dst) );
10656   ins_pipe( fpu_reg_reg );
10657 %}
10658 
10659 
10660 // Spill to obtain 24-bit precision
10661 instruct modFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{
10662   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10663   match(Set dst (ModF src1 src2));
10664   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10665 
10666   format %{ &quot;FMOD   $dst,$src1,$src2&quot; %}
10667   ins_encode( Push_Reg_Mod_DPR(src1, src2),
10668               emitModDPR(),
10669               Push_Result_Mod_DPR(src2),
10670               Pop_Mem_FPR(dst));
10671   ins_pipe( pipe_slow );
10672 %}
10673 //
10674 // This instruction does not round to 24-bits
10675 instruct modFPR_reg(regFPR dst, regFPR src, eAXRegI rax, eFlagsReg cr) %{
10676   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10677   match(Set dst (ModF dst src));
10678   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10679 
10680   format %{ &quot;FMOD   $dst,$src&quot; %}
10681   ins_encode(Push_Reg_Mod_DPR(dst, src),
10682               emitModDPR(),
10683               Push_Result_Mod_DPR(src),
10684               Pop_Reg_FPR(dst));
10685   ins_pipe( pipe_slow );
10686 %}
10687 
10688 instruct modF_reg(regF dst, regF src0, regF src1, eAXRegI rax, eFlagsReg cr) %{
10689   predicate(UseSSE&gt;=1);
10690   match(Set dst (ModF src0 src1));
10691   effect(KILL rax, KILL cr);
10692   format %{ &quot;SUB    ESP,4\t # FMOD\n&quot;
10693           &quot;\tMOVSS  [ESP+0],$src1\n&quot;
10694           &quot;\tFLD_S  [ESP+0]\n&quot;
10695           &quot;\tMOVSS  [ESP+0],$src0\n&quot;
10696           &quot;\tFLD_S  [ESP+0]\n&quot;
10697      &quot;loop:\tFPREM\n&quot;
10698           &quot;\tFWAIT\n&quot;
10699           &quot;\tFNSTSW AX\n&quot;
10700           &quot;\tSAHF\n&quot;
10701           &quot;\tJP     loop\n&quot;
10702           &quot;\tFSTP_S [ESP+0]\n&quot;
10703           &quot;\tMOVSS  $dst,[ESP+0]\n&quot;
10704           &quot;\tADD    ESP,4\n&quot;
10705           &quot;\tFSTP   ST0\t # Restore FPU Stack&quot;
10706     %}
10707   ins_cost(250);
10708   ins_encode( Push_ModF_encoding(src0, src1), emitModDPR(), Push_ResultF(dst,0x4), PopFPU);
10709   ins_pipe( pipe_slow );
10710 %}
10711 
10712 
10713 //----------Arithmetic Conversion Instructions---------------------------------
10714 // The conversions operations are all Alpha sorted.  Please keep it that way!
10715 
10716 instruct roundFloat_mem_reg(stackSlotF dst, regFPR src) %{
10717   predicate(UseSSE==0);
10718   match(Set dst (RoundFloat src));
10719   ins_cost(125);
10720   format %{ &quot;FST_S  $dst,$src\t# F-round&quot; %}
10721   ins_encode( Pop_Mem_Reg_FPR(dst, src) );
10722   ins_pipe( fpu_mem_reg );
10723 %}
10724 
10725 instruct roundDouble_mem_reg(stackSlotD dst, regDPR src) %{
10726   predicate(UseSSE&lt;=1);
10727   match(Set dst (RoundDouble src));
10728   ins_cost(125);
10729   format %{ &quot;FST_D  $dst,$src\t# D-round&quot; %}
10730   ins_encode( Pop_Mem_Reg_DPR(dst, src) );
10731   ins_pipe( fpu_mem_reg );
10732 %}
10733 
10734 // Force rounding to 24-bit precision and 6-bit exponent
10735 instruct convDPR2FPR_reg(stackSlotF dst, regDPR src) %{
10736   predicate(UseSSE==0);
10737   match(Set dst (ConvD2F src));
10738   format %{ &quot;FST_S  $dst,$src\t# F-round&quot; %}
10739   expand %{
10740     roundFloat_mem_reg(dst,src);
10741   %}
10742 %}
10743 
10744 // Force rounding to 24-bit precision and 6-bit exponent
10745 instruct convDPR2F_reg(regF dst, regDPR src, eFlagsReg cr) %{
10746   predicate(UseSSE==1);
10747   match(Set dst (ConvD2F src));
10748   effect( KILL cr );
10749   format %{ &quot;SUB    ESP,4\n\t&quot;
10750             &quot;FST_S  [ESP],$src\t# F-round\n\t&quot;
10751             &quot;MOVSS  $dst,[ESP]\n\t&quot;
10752             &quot;ADD ESP,4&quot; %}
10753   ins_encode %{
10754     __ subptr(rsp, 4);
10755     if ($src$$reg != FPR1L_enc) {
10756       __ fld_s($src$$reg-1);
10757       __ fstp_s(Address(rsp, 0));
10758     } else {
10759       __ fst_s(Address(rsp, 0));
10760     }
10761     __ movflt($dst$$XMMRegister, Address(rsp, 0));
10762     __ addptr(rsp, 4);
10763   %}
10764   ins_pipe( pipe_slow );
10765 %}
10766 
10767 // Force rounding double precision to single precision
10768 instruct convD2F_reg(regF dst, regD src) %{
10769   predicate(UseSSE&gt;=2);
10770   match(Set dst (ConvD2F src));
10771   format %{ &quot;CVTSD2SS $dst,$src\t# F-round&quot; %}
10772   ins_encode %{
10773     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10774   %}
10775   ins_pipe( pipe_slow );
10776 %}
10777 
10778 instruct convFPR2DPR_reg_reg(regDPR dst, regFPR src) %{
10779   predicate(UseSSE==0);
10780   match(Set dst (ConvF2D src));
10781   format %{ &quot;FST_S  $dst,$src\t# D-round&quot; %}
10782   ins_encode( Pop_Reg_Reg_DPR(dst, src));
10783   ins_pipe( fpu_reg_reg );
10784 %}
10785 
10786 instruct convFPR2D_reg(stackSlotD dst, regFPR src) %{
10787   predicate(UseSSE==1);
10788   match(Set dst (ConvF2D src));
10789   format %{ &quot;FST_D  $dst,$src\t# D-round&quot; %}
10790   expand %{
10791     roundDouble_mem_reg(dst,src);
10792   %}
10793 %}
10794 
10795 instruct convF2DPR_reg(regDPR dst, regF src, eFlagsReg cr) %{
10796   predicate(UseSSE==1);
10797   match(Set dst (ConvF2D src));
10798   effect( KILL cr );
10799   format %{ &quot;SUB    ESP,4\n\t&quot;
10800             &quot;MOVSS  [ESP] $src\n\t&quot;
10801             &quot;FLD_S  [ESP]\n\t&quot;
10802             &quot;ADD    ESP,4\n\t&quot;
10803             &quot;FSTP   $dst\t# D-round&quot; %}
10804   ins_encode %{
10805     __ subptr(rsp, 4);
10806     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10807     __ fld_s(Address(rsp, 0));
10808     __ addptr(rsp, 4);
10809     __ fstp_d($dst$$reg);
10810   %}
10811   ins_pipe( pipe_slow );
10812 %}
10813 
10814 instruct convF2D_reg(regD dst, regF src) %{
10815   predicate(UseSSE&gt;=2);
10816   match(Set dst (ConvF2D src));
10817   format %{ &quot;CVTSS2SD $dst,$src\t# D-round&quot; %}
10818   ins_encode %{
10819     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10820   %}
10821   ins_pipe( pipe_slow );
10822 %}
10823 
10824 // Convert a double to an int.  If the double is a NAN, stuff a zero in instead.
10825 instruct convDPR2I_reg_reg( eAXRegI dst, eDXRegI tmp, regDPR src, eFlagsReg cr ) %{
10826   predicate(UseSSE&lt;=1);
10827   match(Set dst (ConvD2I src));
10828   effect( KILL tmp, KILL cr );
10829   format %{ &quot;FLD    $src\t# Convert double to int \n\t&quot;
10830             &quot;FLDCW  trunc mode\n\t&quot;
10831             &quot;SUB    ESP,4\n\t&quot;
10832             &quot;FISTp  [ESP + #0]\n\t&quot;
10833             &quot;FLDCW  std/24-bit mode\n\t&quot;
10834             &quot;POP    EAX\n\t&quot;
10835             &quot;CMP    EAX,0x80000000\n\t&quot;
10836             &quot;JNE,s  fast\n\t&quot;
10837             &quot;FLD_D  $src\n\t&quot;
10838             &quot;CALL   d2i_wrapper\n&quot;
10839       &quot;fast:&quot; %}
10840   ins_encode( Push_Reg_DPR(src), DPR2I_encoding(src) );
10841   ins_pipe( pipe_slow );
10842 %}
10843 
10844 // Convert a double to an int.  If the double is a NAN, stuff a zero in instead.
10845 instruct convD2I_reg_reg( eAXRegI dst, eDXRegI tmp, regD src, eFlagsReg cr ) %{
10846   predicate(UseSSE&gt;=2);
10847   match(Set dst (ConvD2I src));
10848   effect( KILL tmp, KILL cr );
10849   format %{ &quot;CVTTSD2SI $dst, $src\n\t&quot;
10850             &quot;CMP    $dst,0x80000000\n\t&quot;
10851             &quot;JNE,s  fast\n\t&quot;
10852             &quot;SUB    ESP, 8\n\t&quot;
10853             &quot;MOVSD  [ESP], $src\n\t&quot;
10854             &quot;FLD_D  [ESP]\n\t&quot;
10855             &quot;ADD    ESP, 8\n\t&quot;
10856             &quot;CALL   d2i_wrapper\n&quot;
10857       &quot;fast:&quot; %}
10858   ins_encode %{
10859     Label fast;
10860     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);
10861     __ cmpl($dst$$Register, 0x80000000);
10862     __ jccb(Assembler::notEqual, fast);
10863     __ subptr(rsp, 8);
10864     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10865     __ fld_d(Address(rsp, 0));
10866     __ addptr(rsp, 8);
10867     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));
10868     __ bind(fast);
10869   %}
10870   ins_pipe( pipe_slow );
10871 %}
10872 
10873 instruct convDPR2L_reg_reg( eADXRegL dst, regDPR src, eFlagsReg cr ) %{
10874   predicate(UseSSE&lt;=1);
10875   match(Set dst (ConvD2L src));
10876   effect( KILL cr );
10877   format %{ &quot;FLD    $src\t# Convert double to long\n\t&quot;
10878             &quot;FLDCW  trunc mode\n\t&quot;
10879             &quot;SUB    ESP,8\n\t&quot;
10880             &quot;FISTp  [ESP + #0]\n\t&quot;
10881             &quot;FLDCW  std/24-bit mode\n\t&quot;
10882             &quot;POP    EAX\n\t&quot;
10883             &quot;POP    EDX\n\t&quot;
10884             &quot;CMP    EDX,0x80000000\n\t&quot;
10885             &quot;JNE,s  fast\n\t&quot;
10886             &quot;TEST   EAX,EAX\n\t&quot;
10887             &quot;JNE,s  fast\n\t&quot;
10888             &quot;FLD    $src\n\t&quot;
10889             &quot;CALL   d2l_wrapper\n&quot;
10890       &quot;fast:&quot; %}
10891   ins_encode( Push_Reg_DPR(src),  DPR2L_encoding(src) );
10892   ins_pipe( pipe_slow );
10893 %}
10894 
10895 // XMM lacks a float/double-&gt;long conversion, so use the old FPU stack.
10896 instruct convD2L_reg_reg( eADXRegL dst, regD src, eFlagsReg cr ) %{
10897   predicate (UseSSE&gt;=2);
10898   match(Set dst (ConvD2L src));
10899   effect( KILL cr );
10900   format %{ &quot;SUB    ESP,8\t# Convert double to long\n\t&quot;
10901             &quot;MOVSD  [ESP],$src\n\t&quot;
10902             &quot;FLD_D  [ESP]\n\t&quot;
10903             &quot;FLDCW  trunc mode\n\t&quot;
10904             &quot;FISTp  [ESP + #0]\n\t&quot;
10905             &quot;FLDCW  std/24-bit mode\n\t&quot;
10906             &quot;POP    EAX\n\t&quot;
10907             &quot;POP    EDX\n\t&quot;
10908             &quot;CMP    EDX,0x80000000\n\t&quot;
10909             &quot;JNE,s  fast\n\t&quot;
10910             &quot;TEST   EAX,EAX\n\t&quot;
10911             &quot;JNE,s  fast\n\t&quot;
10912             &quot;SUB    ESP,8\n\t&quot;
10913             &quot;MOVSD  [ESP],$src\n\t&quot;
10914             &quot;FLD_D  [ESP]\n\t&quot;
10915             &quot;ADD    ESP,8\n\t&quot;
10916             &quot;CALL   d2l_wrapper\n&quot;
10917       &quot;fast:&quot; %}
10918   ins_encode %{
10919     Label fast;
10920     __ subptr(rsp, 8);
10921     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10922     __ fld_d(Address(rsp, 0));
10923     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
10924     __ fistp_d(Address(rsp, 0));
10925     // Restore the rounding mode, mask the exception
10926     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
10927       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
10928     } else {
10929       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
10930     }
10931     // Load the converted long, adjust CPU stack
10932     __ pop(rax);
10933     __ pop(rdx);
10934     __ cmpl(rdx, 0x80000000);
10935     __ jccb(Assembler::notEqual, fast);
10936     __ testl(rax, rax);
10937     __ jccb(Assembler::notEqual, fast);
10938     __ subptr(rsp, 8);
10939     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10940     __ fld_d(Address(rsp, 0));
10941     __ addptr(rsp, 8);
10942     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));
10943     __ bind(fast);
10944   %}
10945   ins_pipe( pipe_slow );
10946 %}
10947 
10948 // Convert a double to an int.  Java semantics require we do complex
10949 // manglations in the corner cases.  So we set the rounding mode to
10950 // &#39;zero&#39;, store the darned double down as an int, and reset the
10951 // rounding mode to &#39;nearest&#39;.  The hardware stores a flag value down
10952 // if we would overflow or converted a NAN; we check for this and
10953 // and go the slow path if needed.
10954 instruct convFPR2I_reg_reg(eAXRegI dst, eDXRegI tmp, regFPR src, eFlagsReg cr ) %{
10955   predicate(UseSSE==0);
10956   match(Set dst (ConvF2I src));
10957   effect( KILL tmp, KILL cr );
10958   format %{ &quot;FLD    $src\t# Convert float to int \n\t&quot;
10959             &quot;FLDCW  trunc mode\n\t&quot;
10960             &quot;SUB    ESP,4\n\t&quot;
10961             &quot;FISTp  [ESP + #0]\n\t&quot;
10962             &quot;FLDCW  std/24-bit mode\n\t&quot;
10963             &quot;POP    EAX\n\t&quot;
10964             &quot;CMP    EAX,0x80000000\n\t&quot;
10965             &quot;JNE,s  fast\n\t&quot;
10966             &quot;FLD    $src\n\t&quot;
10967             &quot;CALL   d2i_wrapper\n&quot;
10968       &quot;fast:&quot; %}
10969   // DPR2I_encoding works for FPR2I
10970   ins_encode( Push_Reg_FPR(src), DPR2I_encoding(src) );
10971   ins_pipe( pipe_slow );
10972 %}
10973 
10974 // Convert a float in xmm to an int reg.
10975 instruct convF2I_reg(eAXRegI dst, eDXRegI tmp, regF src, eFlagsReg cr ) %{
10976   predicate(UseSSE&gt;=1);
10977   match(Set dst (ConvF2I src));
10978   effect( KILL tmp, KILL cr );
10979   format %{ &quot;CVTTSS2SI $dst, $src\n\t&quot;
10980             &quot;CMP    $dst,0x80000000\n\t&quot;
10981             &quot;JNE,s  fast\n\t&quot;
10982             &quot;SUB    ESP, 4\n\t&quot;
10983             &quot;MOVSS  [ESP], $src\n\t&quot;
10984             &quot;FLD    [ESP]\n\t&quot;
10985             &quot;ADD    ESP, 4\n\t&quot;
10986             &quot;CALL   d2i_wrapper\n&quot;
10987       &quot;fast:&quot; %}
10988   ins_encode %{
10989     Label fast;
10990     __ cvttss2sil($dst$$Register, $src$$XMMRegister);
10991     __ cmpl($dst$$Register, 0x80000000);
10992     __ jccb(Assembler::notEqual, fast);
10993     __ subptr(rsp, 4);
10994     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10995     __ fld_s(Address(rsp, 0));
10996     __ addptr(rsp, 4);
10997     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));
10998     __ bind(fast);
10999   %}
11000   ins_pipe( pipe_slow );
11001 %}
11002 
11003 instruct convFPR2L_reg_reg( eADXRegL dst, regFPR src, eFlagsReg cr ) %{
11004   predicate(UseSSE==0);
11005   match(Set dst (ConvF2L src));
11006   effect( KILL cr );
11007   format %{ &quot;FLD    $src\t# Convert float to long\n\t&quot;
11008             &quot;FLDCW  trunc mode\n\t&quot;
11009             &quot;SUB    ESP,8\n\t&quot;
11010             &quot;FISTp  [ESP + #0]\n\t&quot;
11011             &quot;FLDCW  std/24-bit mode\n\t&quot;
11012             &quot;POP    EAX\n\t&quot;
11013             &quot;POP    EDX\n\t&quot;
11014             &quot;CMP    EDX,0x80000000\n\t&quot;
11015             &quot;JNE,s  fast\n\t&quot;
11016             &quot;TEST   EAX,EAX\n\t&quot;
11017             &quot;JNE,s  fast\n\t&quot;
11018             &quot;FLD    $src\n\t&quot;
11019             &quot;CALL   d2l_wrapper\n&quot;
11020       &quot;fast:&quot; %}
11021   // DPR2L_encoding works for FPR2L
11022   ins_encode( Push_Reg_FPR(src), DPR2L_encoding(src) );
11023   ins_pipe( pipe_slow );
11024 %}
11025 
11026 // XMM lacks a float/double-&gt;long conversion, so use the old FPU stack.
11027 instruct convF2L_reg_reg( eADXRegL dst, regF src, eFlagsReg cr ) %{
11028   predicate (UseSSE&gt;=1);
11029   match(Set dst (ConvF2L src));
11030   effect( KILL cr );
11031   format %{ &quot;SUB    ESP,8\t# Convert float to long\n\t&quot;
11032             &quot;MOVSS  [ESP],$src\n\t&quot;
11033             &quot;FLD_S  [ESP]\n\t&quot;
11034             &quot;FLDCW  trunc mode\n\t&quot;
11035             &quot;FISTp  [ESP + #0]\n\t&quot;
11036             &quot;FLDCW  std/24-bit mode\n\t&quot;
11037             &quot;POP    EAX\n\t&quot;
11038             &quot;POP    EDX\n\t&quot;
11039             &quot;CMP    EDX,0x80000000\n\t&quot;
11040             &quot;JNE,s  fast\n\t&quot;
11041             &quot;TEST   EAX,EAX\n\t&quot;
11042             &quot;JNE,s  fast\n\t&quot;
11043             &quot;SUB    ESP,4\t# Convert float to long\n\t&quot;
11044             &quot;MOVSS  [ESP],$src\n\t&quot;
11045             &quot;FLD_S  [ESP]\n\t&quot;
11046             &quot;ADD    ESP,4\n\t&quot;
11047             &quot;CALL   d2l_wrapper\n&quot;
11048       &quot;fast:&quot; %}
11049   ins_encode %{
11050     Label fast;
11051     __ subptr(rsp, 8);
11052     __ movflt(Address(rsp, 0), $src$$XMMRegister);
11053     __ fld_s(Address(rsp, 0));
11054     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
11055     __ fistp_d(Address(rsp, 0));
11056     // Restore the rounding mode, mask the exception
11057     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
11058       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
11059     } else {
11060       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
11061     }
11062     // Load the converted long, adjust CPU stack
11063     __ pop(rax);
11064     __ pop(rdx);
11065     __ cmpl(rdx, 0x80000000);
11066     __ jccb(Assembler::notEqual, fast);
11067     __ testl(rax, rax);
11068     __ jccb(Assembler::notEqual, fast);
11069     __ subptr(rsp, 4);
11070     __ movflt(Address(rsp, 0), $src$$XMMRegister);
11071     __ fld_s(Address(rsp, 0));
11072     __ addptr(rsp, 4);
11073     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));
11074     __ bind(fast);
11075   %}
11076   ins_pipe( pipe_slow );
11077 %}
11078 
11079 instruct convI2DPR_reg(regDPR dst, stackSlotI src) %{
11080   predicate( UseSSE&lt;=1 );
11081   match(Set dst (ConvI2D src));
11082   format %{ &quot;FILD   $src\n\t&quot;
11083             &quot;FSTP   $dst&quot; %}
11084   opcode(0xDB, 0x0);  /* DB /0 */
11085   ins_encode(Push_Mem_I(src), Pop_Reg_DPR(dst));
11086   ins_pipe( fpu_reg_mem );
11087 %}
11088 
11089 instruct convI2D_reg(regD dst, rRegI src) %{
11090   predicate( UseSSE&gt;=2 &amp;&amp; !UseXmmI2D );
11091   match(Set dst (ConvI2D src));
11092   format %{ &quot;CVTSI2SD $dst,$src&quot; %}
11093   ins_encode %{
11094     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
11095   %}
11096   ins_pipe( pipe_slow );
11097 %}
11098 
11099 instruct convI2D_mem(regD dst, memory mem) %{
11100   predicate( UseSSE&gt;=2 );
11101   match(Set dst (ConvI2D (LoadI mem)));
11102   format %{ &quot;CVTSI2SD $dst,$mem&quot; %}
11103   ins_encode %{
11104     __ cvtsi2sdl ($dst$$XMMRegister, $mem$$Address);
11105   %}
11106   ins_pipe( pipe_slow );
11107 %}
11108 
11109 instruct convXI2D_reg(regD dst, rRegI src)
11110 %{
11111   predicate( UseSSE&gt;=2 &amp;&amp; UseXmmI2D );
11112   match(Set dst (ConvI2D src));
11113 
11114   format %{ &quot;MOVD  $dst,$src\n\t&quot;
11115             &quot;CVTDQ2PD $dst,$dst\t# i2d&quot; %}
11116   ins_encode %{
11117     __ movdl($dst$$XMMRegister, $src$$Register);
11118     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
11119   %}
11120   ins_pipe(pipe_slow); // XXX
11121 %}
11122 
11123 instruct convI2DPR_mem(regDPR dst, memory mem) %{
11124   predicate( UseSSE&lt;=1 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11125   match(Set dst (ConvI2D (LoadI mem)));
11126   format %{ &quot;FILD   $mem\n\t&quot;
11127             &quot;FSTP   $dst&quot; %}
11128   opcode(0xDB);      /* DB /0 */
11129   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11130               Pop_Reg_DPR(dst));
11131   ins_pipe( fpu_reg_mem );
11132 %}
11133 
11134 // Convert a byte to a float; no rounding step needed.
11135 instruct conv24I2FPR_reg(regFPR dst, stackSlotI src) %{
11136   predicate( UseSSE==0 &amp;&amp; n-&gt;in(1)-&gt;Opcode() == Op_AndI &amp;&amp; n-&gt;in(1)-&gt;in(2)-&gt;is_Con() &amp;&amp; n-&gt;in(1)-&gt;in(2)-&gt;get_int() == 255 );
11137   match(Set dst (ConvI2F src));
11138   format %{ &quot;FILD   $src\n\t&quot;
11139             &quot;FSTP   $dst&quot; %}
11140 
11141   opcode(0xDB, 0x0);  /* DB /0 */
11142   ins_encode(Push_Mem_I(src), Pop_Reg_FPR(dst));
11143   ins_pipe( fpu_reg_mem );
11144 %}
11145 
11146 // In 24-bit mode, force exponent rounding by storing back out
11147 instruct convI2FPR_SSF(stackSlotF dst, stackSlotI src) %{
11148   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
11149   match(Set dst (ConvI2F src));
11150   ins_cost(200);
11151   format %{ &quot;FILD   $src\n\t&quot;
11152             &quot;FSTP_S $dst&quot; %}
11153   opcode(0xDB, 0x0);  /* DB /0 */
11154   ins_encode( Push_Mem_I(src),
11155               Pop_Mem_FPR(dst));
11156   ins_pipe( fpu_mem_mem );
11157 %}
11158 
11159 // In 24-bit mode, force exponent rounding by storing back out
11160 instruct convI2FPR_SSF_mem(stackSlotF dst, memory mem) %{
11161   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
11162   match(Set dst (ConvI2F (LoadI mem)));
11163   ins_cost(200);
11164   format %{ &quot;FILD   $mem\n\t&quot;
11165             &quot;FSTP_S $dst&quot; %}
11166   opcode(0xDB);  /* DB /0 */
11167   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11168               Pop_Mem_FPR(dst));
11169   ins_pipe( fpu_mem_mem );
11170 %}
11171 
11172 // This instruction does not round to 24-bits
11173 instruct convI2FPR_reg(regFPR dst, stackSlotI src) %{
11174   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11175   match(Set dst (ConvI2F src));
11176   format %{ &quot;FILD   $src\n\t&quot;
11177             &quot;FSTP   $dst&quot; %}
11178   opcode(0xDB, 0x0);  /* DB /0 */
11179   ins_encode( Push_Mem_I(src),
11180               Pop_Reg_FPR(dst));
11181   ins_pipe( fpu_reg_mem );
11182 %}
11183 
11184 // This instruction does not round to 24-bits
11185 instruct convI2FPR_mem(regFPR dst, memory mem) %{
11186   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11187   match(Set dst (ConvI2F (LoadI mem)));
11188   format %{ &quot;FILD   $mem\n\t&quot;
11189             &quot;FSTP   $dst&quot; %}
11190   opcode(0xDB);      /* DB /0 */
11191   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11192               Pop_Reg_FPR(dst));
11193   ins_pipe( fpu_reg_mem );
11194 %}
11195 
11196 // Convert an int to a float in xmm; no rounding step needed.
11197 instruct convI2F_reg(regF dst, rRegI src) %{
11198   predicate( UseSSE==1 || UseSSE&gt;=2 &amp;&amp; !UseXmmI2F );
11199   match(Set dst (ConvI2F src));
11200   format %{ &quot;CVTSI2SS $dst, $src&quot; %}
11201   ins_encode %{
11202     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
11203   %}
11204   ins_pipe( pipe_slow );
11205 %}
11206 
11207  instruct convXI2F_reg(regF dst, rRegI src)
11208 %{
11209   predicate( UseSSE&gt;=2 &amp;&amp; UseXmmI2F );
11210   match(Set dst (ConvI2F src));
11211 
11212   format %{ &quot;MOVD  $dst,$src\n\t&quot;
11213             &quot;CVTDQ2PS $dst,$dst\t# i2f&quot; %}
11214   ins_encode %{
11215     __ movdl($dst$$XMMRegister, $src$$Register);
11216     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
11217   %}
11218   ins_pipe(pipe_slow); // XXX
11219 %}
11220 
11221 instruct convI2L_reg( eRegL dst, rRegI src, eFlagsReg cr) %{
11222   match(Set dst (ConvI2L src));
11223   effect(KILL cr);
11224   ins_cost(375);
11225   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11226             &quot;MOV    $dst.hi,$src\n\t&quot;
11227             &quot;SAR    $dst.hi,31&quot; %}
11228   ins_encode(convert_int_long(dst,src));
11229   ins_pipe( ialu_reg_reg_long );
11230 %}
11231 
11232 // Zero-extend convert int to long
11233 instruct convI2L_reg_zex(eRegL dst, rRegI src, immL_32bits mask, eFlagsReg flags ) %{
11234   match(Set dst (AndL (ConvI2L src) mask) );
11235   effect( KILL flags );
11236   ins_cost(250);
11237   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11238             &quot;XOR    $dst.hi,$dst.hi&quot; %}
11239   opcode(0x33); // XOR
11240   ins_encode(enc_Copy(dst,src), OpcP, RegReg_Hi2(dst,dst) );
11241   ins_pipe( ialu_reg_reg_long );
11242 %}
11243 
11244 // Zero-extend long
11245 instruct zerox_long(eRegL dst, eRegL src, immL_32bits mask, eFlagsReg flags ) %{
11246   match(Set dst (AndL src mask) );
11247   effect( KILL flags );
11248   ins_cost(250);
11249   format %{ &quot;MOV    $dst.lo,$src.lo\n\t&quot;
11250             &quot;XOR    $dst.hi,$dst.hi\n\t&quot; %}
11251   opcode(0x33); // XOR
11252   ins_encode(enc_Copy(dst,src), OpcP, RegReg_Hi2(dst,dst) );
11253   ins_pipe( ialu_reg_reg_long );
11254 %}
11255 
11256 instruct convL2DPR_reg( stackSlotD dst, eRegL src, eFlagsReg cr) %{
11257   predicate (UseSSE&lt;=1);
11258   match(Set dst (ConvL2D src));
11259   effect( KILL cr );
11260   format %{ &quot;PUSH   $src.hi\t# Convert long to double\n\t&quot;
11261             &quot;PUSH   $src.lo\n\t&quot;
11262             &quot;FILD   ST,[ESP + #0]\n\t&quot;
11263             &quot;ADD    ESP,8\n\t&quot;
11264             &quot;FSTP_D $dst\t# D-round&quot; %}
11265   opcode(0xDF, 0x5);  /* DF /5 */
11266   ins_encode(convert_long_double(src), Pop_Mem_DPR(dst));
11267   ins_pipe( pipe_slow );
11268 %}
11269 
11270 instruct convL2D_reg( regD dst, eRegL src, eFlagsReg cr) %{
11271   predicate (UseSSE&gt;=2);
11272   match(Set dst (ConvL2D src));
11273   effect( KILL cr );
11274   format %{ &quot;PUSH   $src.hi\t# Convert long to double\n\t&quot;
11275             &quot;PUSH   $src.lo\n\t&quot;
11276             &quot;FILD_D [ESP]\n\t&quot;
11277             &quot;FSTP_D [ESP]\n\t&quot;
11278             &quot;MOVSD  $dst,[ESP]\n\t&quot;
11279             &quot;ADD    ESP,8&quot; %}
11280   opcode(0xDF, 0x5);  /* DF /5 */
11281   ins_encode(convert_long_double2(src), Push_ResultD(dst));
11282   ins_pipe( pipe_slow );
11283 %}
11284 
11285 instruct convL2F_reg( regF dst, eRegL src, eFlagsReg cr) %{
11286   predicate (UseSSE&gt;=1);
11287   match(Set dst (ConvL2F src));
11288   effect( KILL cr );
11289   format %{ &quot;PUSH   $src.hi\t# Convert long to single float\n\t&quot;
11290             &quot;PUSH   $src.lo\n\t&quot;
11291             &quot;FILD_D [ESP]\n\t&quot;
11292             &quot;FSTP_S [ESP]\n\t&quot;
11293             &quot;MOVSS  $dst,[ESP]\n\t&quot;
11294             &quot;ADD    ESP,8&quot; %}
11295   opcode(0xDF, 0x5);  /* DF /5 */
11296   ins_encode(convert_long_double2(src), Push_ResultF(dst,0x8));
11297   ins_pipe( pipe_slow );
11298 %}
11299 
11300 instruct convL2FPR_reg( stackSlotF dst, eRegL src, eFlagsReg cr) %{
11301   match(Set dst (ConvL2F src));
11302   effect( KILL cr );
11303   format %{ &quot;PUSH   $src.hi\t# Convert long to single float\n\t&quot;
11304             &quot;PUSH   $src.lo\n\t&quot;
11305             &quot;FILD   ST,[ESP + #0]\n\t&quot;
11306             &quot;ADD    ESP,8\n\t&quot;
11307             &quot;FSTP_S $dst\t# F-round&quot; %}
11308   opcode(0xDF, 0x5);  /* DF /5 */
11309   ins_encode(convert_long_double(src), Pop_Mem_FPR(dst));
11310   ins_pipe( pipe_slow );
11311 %}
11312 
11313 instruct convL2I_reg( rRegI dst, eRegL src ) %{
11314   match(Set dst (ConvL2I src));
11315   effect( DEF dst, USE src );
11316   format %{ &quot;MOV    $dst,$src.lo&quot; %}
11317   ins_encode(enc_CopyL_Lo(dst,src));
11318   ins_pipe( ialu_reg_reg );
11319 %}
11320 
11321 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
11322   match(Set dst (MoveF2I src));
11323   effect( DEF dst, USE src );
11324   ins_cost(100);
11325   format %{ &quot;MOV    $dst,$src\t# MoveF2I_stack_reg&quot; %}
11326   ins_encode %{
11327     __ movl($dst$$Register, Address(rsp, $src$$disp));
11328   %}
11329   ins_pipe( ialu_reg_mem );
11330 %}
11331 
11332 instruct MoveFPR2I_reg_stack(stackSlotI dst, regFPR src) %{
11333   predicate(UseSSE==0);
11334   match(Set dst (MoveF2I src));
11335   effect( DEF dst, USE src );
11336 
11337   ins_cost(125);
11338   format %{ &quot;FST_S  $dst,$src\t# MoveF2I_reg_stack&quot; %}
11339   ins_encode( Pop_Mem_Reg_FPR(dst, src) );
11340   ins_pipe( fpu_mem_reg );
11341 %}
11342 
11343 instruct MoveF2I_reg_stack_sse(stackSlotI dst, regF src) %{
11344   predicate(UseSSE&gt;=1);
11345   match(Set dst (MoveF2I src));
11346   effect( DEF dst, USE src );
11347 
11348   ins_cost(95);
11349   format %{ &quot;MOVSS  $dst,$src\t# MoveF2I_reg_stack_sse&quot; %}
11350   ins_encode %{
11351     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
11352   %}
11353   ins_pipe( pipe_slow );
11354 %}
11355 
11356 instruct MoveF2I_reg_reg_sse(rRegI dst, regF src) %{
11357   predicate(UseSSE&gt;=2);
11358   match(Set dst (MoveF2I src));
11359   effect( DEF dst, USE src );
11360   ins_cost(85);
11361   format %{ &quot;MOVD   $dst,$src\t# MoveF2I_reg_reg_sse&quot; %}
11362   ins_encode %{
11363     __ movdl($dst$$Register, $src$$XMMRegister);
11364   %}
11365   ins_pipe( pipe_slow );
11366 %}
11367 
11368 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
11369   match(Set dst (MoveI2F src));
11370   effect( DEF dst, USE src );
11371 
11372   ins_cost(100);
11373   format %{ &quot;MOV    $dst,$src\t# MoveI2F_reg_stack&quot; %}
11374   ins_encode %{
11375     __ movl(Address(rsp, $dst$$disp), $src$$Register);
11376   %}
11377   ins_pipe( ialu_mem_reg );
11378 %}
11379 
11380 
11381 instruct MoveI2FPR_stack_reg(regFPR dst, stackSlotI src) %{
11382   predicate(UseSSE==0);
11383   match(Set dst (MoveI2F src));
11384   effect(DEF dst, USE src);
11385 
11386   ins_cost(125);
11387   format %{ &quot;FLD_S  $src\n\t&quot;
11388             &quot;FSTP   $dst\t# MoveI2F_stack_reg&quot; %}
11389   opcode(0xD9);               /* D9 /0, FLD m32real */
11390   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
11391               Pop_Reg_FPR(dst) );
11392   ins_pipe( fpu_reg_mem );
11393 %}
11394 
11395 instruct MoveI2F_stack_reg_sse(regF dst, stackSlotI src) %{
11396   predicate(UseSSE&gt;=1);
11397   match(Set dst (MoveI2F src));
11398   effect( DEF dst, USE src );
11399 
11400   ins_cost(95);
11401   format %{ &quot;MOVSS  $dst,$src\t# MoveI2F_stack_reg_sse&quot; %}
11402   ins_encode %{
11403     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
11404   %}
11405   ins_pipe( pipe_slow );
11406 %}
11407 
11408 instruct MoveI2F_reg_reg_sse(regF dst, rRegI src) %{
11409   predicate(UseSSE&gt;=2);
11410   match(Set dst (MoveI2F src));
11411   effect( DEF dst, USE src );
11412 
11413   ins_cost(85);
11414   format %{ &quot;MOVD   $dst,$src\t# MoveI2F_reg_reg_sse&quot; %}
11415   ins_encode %{
11416     __ movdl($dst$$XMMRegister, $src$$Register);
11417   %}
11418   ins_pipe( pipe_slow );
11419 %}
11420 
11421 instruct MoveD2L_stack_reg(eRegL dst, stackSlotD src) %{
11422   match(Set dst (MoveD2L src));
11423   effect(DEF dst, USE src);
11424 
11425   ins_cost(250);
11426   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11427             &quot;MOV    $dst.hi,$src+4\t# MoveD2L_stack_reg&quot; %}
11428   opcode(0x8B, 0x8B);
11429   ins_encode( OpcP, RegMem(dst,src), OpcS, RegMem_Hi(dst,src));
11430   ins_pipe( ialu_mem_long_reg );
11431 %}
11432 
11433 instruct MoveDPR2L_reg_stack(stackSlotL dst, regDPR src) %{
11434   predicate(UseSSE&lt;=1);
11435   match(Set dst (MoveD2L src));
11436   effect(DEF dst, USE src);
11437 
11438   ins_cost(125);
11439   format %{ &quot;FST_D  $dst,$src\t# MoveD2L_reg_stack&quot; %}
11440   ins_encode( Pop_Mem_Reg_DPR(dst, src) );
11441   ins_pipe( fpu_mem_reg );
11442 %}
11443 
11444 instruct MoveD2L_reg_stack_sse(stackSlotL dst, regD src) %{
11445   predicate(UseSSE&gt;=2);
11446   match(Set dst (MoveD2L src));
11447   effect(DEF dst, USE src);
11448   ins_cost(95);
11449   format %{ &quot;MOVSD  $dst,$src\t# MoveD2L_reg_stack_sse&quot; %}
11450   ins_encode %{
11451     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
11452   %}
11453   ins_pipe( pipe_slow );
11454 %}
11455 
11456 instruct MoveD2L_reg_reg_sse(eRegL dst, regD src, regD tmp) %{
11457   predicate(UseSSE&gt;=2);
11458   match(Set dst (MoveD2L src));
11459   effect(DEF dst, USE src, TEMP tmp);
11460   ins_cost(85);
11461   format %{ &quot;MOVD   $dst.lo,$src\n\t&quot;
11462             &quot;PSHUFLW $tmp,$src,0x4E\n\t&quot;
11463             &quot;MOVD   $dst.hi,$tmp\t# MoveD2L_reg_reg_sse&quot; %}
11464   ins_encode %{
11465     __ movdl($dst$$Register, $src$$XMMRegister);
11466     __ pshuflw($tmp$$XMMRegister, $src$$XMMRegister, 0x4e);
11467     __ movdl(HIGH_FROM_LOW($dst$$Register), $tmp$$XMMRegister);
11468   %}
11469   ins_pipe( pipe_slow );
11470 %}
11471 
11472 instruct MoveL2D_reg_stack(stackSlotD dst, eRegL src) %{
11473   match(Set dst (MoveL2D src));
11474   effect(DEF dst, USE src);
11475 
11476   ins_cost(200);
11477   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
11478             &quot;MOV    $dst+4,$src.hi\t# MoveL2D_reg_stack&quot; %}
11479   opcode(0x89, 0x89);
11480   ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );
11481   ins_pipe( ialu_mem_long_reg );
11482 %}
11483 
11484 
11485 instruct MoveL2DPR_stack_reg(regDPR dst, stackSlotL src) %{
11486   predicate(UseSSE&lt;=1);
11487   match(Set dst (MoveL2D src));
11488   effect(DEF dst, USE src);
11489   ins_cost(125);
11490 
11491   format %{ &quot;FLD_D  $src\n\t&quot;
11492             &quot;FSTP   $dst\t# MoveL2D_stack_reg&quot; %}
11493   opcode(0xDD);               /* DD /0, FLD m64real */
11494   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
11495               Pop_Reg_DPR(dst) );
11496   ins_pipe( fpu_reg_mem );
11497 %}
11498 
11499 
11500 instruct MoveL2D_stack_reg_sse(regD dst, stackSlotL src) %{
11501   predicate(UseSSE&gt;=2 &amp;&amp; UseXmmLoadAndClearUpper);
11502   match(Set dst (MoveL2D src));
11503   effect(DEF dst, USE src);
11504 
11505   ins_cost(95);
11506   format %{ &quot;MOVSD  $dst,$src\t# MoveL2D_stack_reg_sse&quot; %}
11507   ins_encode %{
11508     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11509   %}
11510   ins_pipe( pipe_slow );
11511 %}
11512 
11513 instruct MoveL2D_stack_reg_sse_partial(regD dst, stackSlotL src) %{
11514   predicate(UseSSE&gt;=2 &amp;&amp; !UseXmmLoadAndClearUpper);
11515   match(Set dst (MoveL2D src));
11516   effect(DEF dst, USE src);
11517 
11518   ins_cost(95);
11519   format %{ &quot;MOVLPD $dst,$src\t# MoveL2D_stack_reg_sse&quot; %}
11520   ins_encode %{
11521     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11522   %}
11523   ins_pipe( pipe_slow );
11524 %}
11525 
11526 instruct MoveL2D_reg_reg_sse(regD dst, eRegL src, regD tmp) %{
11527   predicate(UseSSE&gt;=2);
11528   match(Set dst (MoveL2D src));
11529   effect(TEMP dst, USE src, TEMP tmp);
11530   ins_cost(85);
11531   format %{ &quot;MOVD   $dst,$src.lo\n\t&quot;
11532             &quot;MOVD   $tmp,$src.hi\n\t&quot;
11533             &quot;PUNPCKLDQ $dst,$tmp\t# MoveL2D_reg_reg_sse&quot; %}
11534   ins_encode %{
11535     __ movdl($dst$$XMMRegister, $src$$Register);
11536     __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));
11537     __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);
11538   %}
11539   ins_pipe( pipe_slow );
11540 %}
11541 
11542 
11543 // =======================================================================
11544 // fast clearing of an array
11545 instruct rep_stos(eCXRegI cnt, eDIRegP base, regD tmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{
11546   predicate(!((ClearArrayNode*)n)-&gt;is_large());
11547   match(Set dummy (ClearArray cnt base));
11548   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11549 
11550   format %{ $$template
11551     $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11552     $$emit$$&quot;CMP    InitArrayShortSize,rcx\n\t&quot;
11553     $$emit$$&quot;JG     LARGE\n\t&quot;
11554     $$emit$$&quot;SHL    ECX, 1\n\t&quot;
11555     $$emit$$&quot;DEC    ECX\n\t&quot;
11556     $$emit$$&quot;JS     DONE\t# Zero length\n\t&quot;
11557     $$emit$$&quot;MOV    EAX,(EDI,ECX,4)\t# LOOP\n\t&quot;
11558     $$emit$$&quot;DEC    ECX\n\t&quot;
11559     $$emit$$&quot;JGE    LOOP\n\t&quot;
11560     $$emit$$&quot;JMP    DONE\n\t&quot;
11561     $$emit$$&quot;# LARGE:\n\t&quot;
11562     if (UseFastStosb) {
11563        $$emit$$&quot;SHL    ECX,3\t# Convert doublewords to bytes\n\t&quot;
11564        $$emit$$&quot;REP STOSB\t# store EAX into [EDI++] while ECX--\n\t&quot;
11565     } else if (UseXMMForObjInit) {
11566        $$emit$$&quot;MOV     RDI,RAX\n\t&quot;
11567        $$emit$$&quot;VPXOR    YMM0,YMM0,YMM0\n\t&quot;
11568        $$emit$$&quot;JMPQ    L_zero_64_bytes\n\t&quot;
11569        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11570        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11571        $$emit$$&quot;VMOVDQU YMM0,0x20(RAX)\n\t&quot;
11572        $$emit$$&quot;ADD     0x40,RAX\n\t&quot;
11573        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11574        $$emit$$&quot;SUB     0x8,RCX\n\t&quot;
11575        $$emit$$&quot;JGE     L_loop\n\t&quot;
11576        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11577        $$emit$$&quot;JL      L_tail\n\t&quot;
11578        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11579        $$emit$$&quot;ADD     0x20,RAX\n\t&quot;
11580        $$emit$$&quot;SUB     0x4,RCX\n\t&quot;
11581        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11582        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11583        $$emit$$&quot;JLE     L_end\n\t&quot;
11584        $$emit$$&quot;DEC     RCX\n\t&quot;
11585        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11586        $$emit$$&quot;VMOVQ   XMM0,(RAX)\n\t&quot;
11587        $$emit$$&quot;ADD     0x8,RAX\n\t&quot;
11588        $$emit$$&quot;DEC     RCX\n\t&quot;
11589        $$emit$$&quot;JGE     L_sloop\n\t&quot;
11590        $$emit$$&quot;# L_end:\n\t&quot;
11591     } else {
11592        $$emit$$&quot;SHL    ECX,1\t# Convert doublewords to words\n\t&quot;
11593        $$emit$$&quot;REP STOS\t# store EAX into [EDI++] while ECX--\n\t&quot;
11594     }
11595     $$emit$$&quot;# DONE&quot;
11596   %}
11597   ins_encode %{
11598     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11599                  $tmp$$XMMRegister, false);
11600   %}
11601   ins_pipe( pipe_slow );
11602 %}
11603 
11604 instruct rep_stos_large(eCXRegI cnt, eDIRegP base, regD tmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{
11605   predicate(((ClearArrayNode*)n)-&gt;is_large());
11606   match(Set dummy (ClearArray cnt base));
11607   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11608   format %{ $$template
11609     if (UseFastStosb) {
11610        $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11611        $$emit$$&quot;SHL    ECX,3\t# Convert doublewords to bytes\n\t&quot;
11612        $$emit$$&quot;REP STOSB\t# store EAX into [EDI++] while ECX--\n\t&quot;
11613     } else if (UseXMMForObjInit) {
11614        $$emit$$&quot;MOV     RDI,RAX\t# ClearArray:\n\t&quot;
11615        $$emit$$&quot;VPXOR   YMM0,YMM0,YMM0\n\t&quot;
11616        $$emit$$&quot;JMPQ    L_zero_64_bytes\n\t&quot;
11617        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11618        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11619        $$emit$$&quot;VMOVDQU YMM0,0x20(RAX)\n\t&quot;
11620        $$emit$$&quot;ADD     0x40,RAX\n\t&quot;
11621        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11622        $$emit$$&quot;SUB     0x8,RCX\n\t&quot;
11623        $$emit$$&quot;JGE     L_loop\n\t&quot;
11624        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11625        $$emit$$&quot;JL      L_tail\n\t&quot;
11626        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11627        $$emit$$&quot;ADD     0x20,RAX\n\t&quot;
11628        $$emit$$&quot;SUB     0x4,RCX\n\t&quot;
11629        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11630        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11631        $$emit$$&quot;JLE     L_end\n\t&quot;
11632        $$emit$$&quot;DEC     RCX\n\t&quot;
11633        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11634        $$emit$$&quot;VMOVQ   XMM0,(RAX)\n\t&quot;
11635        $$emit$$&quot;ADD     0x8,RAX\n\t&quot;
11636        $$emit$$&quot;DEC     RCX\n\t&quot;
11637        $$emit$$&quot;JGE     L_sloop\n\t&quot;
11638        $$emit$$&quot;# L_end:\n\t&quot;
11639     } else {
11640        $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11641        $$emit$$&quot;SHL    ECX,1\t# Convert doublewords to words\n\t&quot;
11642        $$emit$$&quot;REP STOS\t# store EAX into [EDI++] while ECX--\n\t&quot;
11643     }
11644     $$emit$$&quot;# DONE&quot;
11645   %}
11646   ins_encode %{
11647     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11648                  $tmp$$XMMRegister, true);
11649   %}
11650   ins_pipe( pipe_slow );
11651 %}
11652 
11653 instruct string_compareL(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11654                          eAXRegI result, regD tmp1, eFlagsReg cr) %{
11655   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11656   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11657   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11658 
11659   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11660   ins_encode %{
11661     __ string_compare($str1$$Register, $str2$$Register,
11662                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11663                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11664   %}
11665   ins_pipe( pipe_slow );
11666 %}
11667 
11668 instruct string_compareU(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11669                          eAXRegI result, regD tmp1, eFlagsReg cr) %{
11670   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11671   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11672   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11673 
11674   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11675   ins_encode %{
11676     __ string_compare($str1$$Register, $str2$$Register,
11677                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11678                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11679   %}
11680   ins_pipe( pipe_slow );
11681 %}
11682 
11683 instruct string_compareLU(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11684                           eAXRegI result, regD tmp1, eFlagsReg cr) %{
11685   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11686   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11687   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11688 
11689   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11690   ins_encode %{
11691     __ string_compare($str1$$Register, $str2$$Register,
11692                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11693                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11694   %}
11695   ins_pipe( pipe_slow );
11696 %}
11697 
11698 instruct string_compareUL(eSIRegP str1, eDXRegI cnt1, eDIRegP str2, eCXRegI cnt2,
11699                           eAXRegI result, regD tmp1, eFlagsReg cr) %{
11700   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11701   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11702   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11703 
11704   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11705   ins_encode %{
11706     __ string_compare($str2$$Register, $str1$$Register,
11707                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11708                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11709   %}
11710   ins_pipe( pipe_slow );
11711 %}
11712 
11713 // fast string equals
11714 instruct string_equals(eDIRegP str1, eSIRegP str2, eCXRegI cnt, eAXRegI result,
11715                        regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr) %{
11716   match(Set result (StrEquals (Binary str1 str2) cnt));
11717   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11718 
11719   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11720   ins_encode %{
11721     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11722                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11723                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11724   %}
11725 
11726   ins_pipe( pipe_slow );
11727 %}
11728 
11729 // fast search of substring with known size.
11730 instruct string_indexof_conL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11731                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11732   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11733   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11734   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11735 
11736   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11737   ins_encode %{
11738     int icnt2 = (int)$int_cnt2$$constant;
11739     if (icnt2 &gt;= 16) {
11740       // IndexOf for constant substrings with size &gt;= 16 elements
11741       // which don&#39;t need to be loaded through stack.
11742       __ string_indexofC8($str1$$Register, $str2$$Register,
11743                           $cnt1$$Register, $cnt2$$Register,
11744                           icnt2, $result$$Register,
11745                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11746     } else {
11747       // Small strings are loaded through stack if they cross page boundary.
11748       __ string_indexof($str1$$Register, $str2$$Register,
11749                         $cnt1$$Register, $cnt2$$Register,
11750                         icnt2, $result$$Register,
11751                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11752     }
11753   %}
11754   ins_pipe( pipe_slow );
11755 %}
11756 
11757 // fast search of substring with known size.
11758 instruct string_indexof_conU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11759                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11760   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11761   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11762   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11763 
11764   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11765   ins_encode %{
11766     int icnt2 = (int)$int_cnt2$$constant;
11767     if (icnt2 &gt;= 8) {
11768       // IndexOf for constant substrings with size &gt;= 8 elements
11769       // which don&#39;t need to be loaded through stack.
11770       __ string_indexofC8($str1$$Register, $str2$$Register,
11771                           $cnt1$$Register, $cnt2$$Register,
11772                           icnt2, $result$$Register,
11773                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11774     } else {
11775       // Small strings are loaded through stack if they cross page boundary.
11776       __ string_indexof($str1$$Register, $str2$$Register,
11777                         $cnt1$$Register, $cnt2$$Register,
11778                         icnt2, $result$$Register,
11779                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11780     }
11781   %}
11782   ins_pipe( pipe_slow );
11783 %}
11784 
11785 // fast search of substring with known size.
11786 instruct string_indexof_conUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11787                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11788   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11789   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11790   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11791 
11792   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11793   ins_encode %{
11794     int icnt2 = (int)$int_cnt2$$constant;
11795     if (icnt2 &gt;= 8) {
11796       // IndexOf for constant substrings with size &gt;= 8 elements
11797       // which don&#39;t need to be loaded through stack.
11798       __ string_indexofC8($str1$$Register, $str2$$Register,
11799                           $cnt1$$Register, $cnt2$$Register,
11800                           icnt2, $result$$Register,
11801                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11802     } else {
11803       // Small strings are loaded through stack if they cross page boundary.
11804       __ string_indexof($str1$$Register, $str2$$Register,
11805                         $cnt1$$Register, $cnt2$$Register,
11806                         icnt2, $result$$Register,
11807                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11808     }
11809   %}
11810   ins_pipe( pipe_slow );
11811 %}
11812 
11813 instruct string_indexofL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11814                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11815   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11816   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11817   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11818 
11819   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11820   ins_encode %{
11821     __ string_indexof($str1$$Register, $str2$$Register,
11822                       $cnt1$$Register, $cnt2$$Register,
11823                       (-1), $result$$Register,
11824                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11825   %}
11826   ins_pipe( pipe_slow );
11827 %}
11828 
11829 instruct string_indexofU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11830                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11831   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11832   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11833   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11834 
11835   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11836   ins_encode %{
11837     __ string_indexof($str1$$Register, $str2$$Register,
11838                       $cnt1$$Register, $cnt2$$Register,
11839                       (-1), $result$$Register,
11840                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11841   %}
11842   ins_pipe( pipe_slow );
11843 %}
11844 
11845 instruct string_indexofUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11846                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11847   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11848   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11849   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11850 
11851   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11852   ins_encode %{
11853     __ string_indexof($str1$$Register, $str2$$Register,
11854                       $cnt1$$Register, $cnt2$$Register,
11855                       (-1), $result$$Register,
11856                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11857   %}
11858   ins_pipe( pipe_slow );
11859 %}
11860 
11861 instruct string_indexofU_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,
11862                               eBXRegI result, regD vec1, regD vec2, regD vec3, eCXRegI tmp, eFlagsReg cr) %{
11863   predicate(UseSSE42Intrinsics);
11864   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11865   effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11866   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11867   ins_encode %{
11868     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11869                            $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);
11870   %}
11871   ins_pipe( pipe_slow );
11872 %}
11873 
11874 // fast array equals
11875 instruct array_equalsB(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11876                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
11877 %{
11878   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11879   match(Set result (AryEq ary1 ary2));
11880   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11881   //ins_cost(300);
11882 
11883   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11884   ins_encode %{
11885     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11886                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11887                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11888   %}
11889   ins_pipe( pipe_slow );
11890 %}
11891 
11892 instruct array_equalsC(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11893                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
11894 %{
11895   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11896   match(Set result (AryEq ary1 ary2));
11897   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11898   //ins_cost(300);
11899 
11900   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11901   ins_encode %{
11902     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11903                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11904                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11905   %}
11906   ins_pipe( pipe_slow );
11907 %}
11908 
11909 instruct has_negatives(eSIRegP ary1, eCXRegI len, eAXRegI result,
11910                       regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)
11911 %{
11912   match(Set result (HasNegatives ary1 len));
11913   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11914 
11915   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11916   ins_encode %{
11917     __ has_negatives($ary1$$Register, $len$$Register,
11918                      $result$$Register, $tmp3$$Register,
11919                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11920   %}
11921   ins_pipe( pipe_slow );
11922 %}
11923 
11924 // fast char[] to byte[] compression
11925 instruct string_compress(eSIRegP src, eDIRegP dst, eDXRegI len, regD tmp1, regD tmp2, regD tmp3, regD tmp4,
11926                          eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{
11927   match(Set result (StrCompressedCopy src (Binary dst len)));
11928   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11929 
11930   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11931   ins_encode %{
11932     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11933                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11934                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11935   %}
11936   ins_pipe( pipe_slow );
11937 %}
11938 
11939 // fast byte[] to char[] inflation
11940 instruct string_inflate(Universe dummy, eSIRegP src, eDIRegP dst, eDXRegI len,
11941                         regD tmp1, eCXRegI tmp2, eFlagsReg cr) %{
11942   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11943   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11944 
11945   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11946   ins_encode %{
11947     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11948                           $tmp1$$XMMRegister, $tmp2$$Register);
11949   %}
11950   ins_pipe( pipe_slow );
11951 %}
11952 
11953 // encode char[] to byte[] in ISO_8859_1
11954 instruct encode_iso_array(eSIRegP src, eDIRegP dst, eDXRegI len,
11955                           regD tmp1, regD tmp2, regD tmp3, regD tmp4,
11956                           eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{
11957   match(Set result (EncodeISOArray src (Binary dst len)));
11958   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11959 
11960   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL ECX, EDX, $tmp1, $tmp2, $tmp3, $tmp4, ESI, EDI &quot; %}
11961   ins_encode %{
11962     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11963                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11964                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11965   %}
11966   ins_pipe( pipe_slow );
11967 %}
11968 
11969 
11970 //----------Control Flow Instructions------------------------------------------
11971 // Signed compare Instructions
11972 instruct compI_eReg(eFlagsReg cr, rRegI op1, rRegI op2) %{
11973   match(Set cr (CmpI op1 op2));
11974   effect( DEF cr, USE op1, USE op2 );
11975   format %{ &quot;CMP    $op1,$op2&quot; %}
11976   opcode(0x3B);  /* Opcode 3B /r */
11977   ins_encode( OpcP, RegReg( op1, op2) );
11978   ins_pipe( ialu_cr_reg_reg );
11979 %}
11980 
11981 instruct compI_eReg_imm(eFlagsReg cr, rRegI op1, immI op2) %{
11982   match(Set cr (CmpI op1 op2));
11983   effect( DEF cr, USE op1 );
11984   format %{ &quot;CMP    $op1,$op2&quot; %}
11985   opcode(0x81,0x07);  /* Opcode 81 /7 */
11986   // ins_encode( RegImm( op1, op2) );  /* Was CmpImm */
11987   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
11988   ins_pipe( ialu_cr_reg_imm );
11989 %}
11990 
11991 // Cisc-spilled version of cmpI_eReg
11992 instruct compI_eReg_mem(eFlagsReg cr, rRegI op1, memory op2) %{
11993   match(Set cr (CmpI op1 (LoadI op2)));
11994 
11995   format %{ &quot;CMP    $op1,$op2&quot; %}
11996   ins_cost(500);
11997   opcode(0x3B);  /* Opcode 3B /r */
11998   ins_encode( OpcP, RegMem( op1, op2) );
11999   ins_pipe( ialu_cr_reg_mem );
12000 %}
12001 
12002 instruct testI_reg( eFlagsReg cr, rRegI src, immI0 zero ) %{
12003   match(Set cr (CmpI src zero));
12004   effect( DEF cr, USE src );
12005 
12006   format %{ &quot;TEST   $src,$src&quot; %}
12007   opcode(0x85);
12008   ins_encode( OpcP, RegReg( src, src ) );
12009   ins_pipe( ialu_cr_reg_imm );
12010 %}
12011 
12012 instruct testI_reg_imm( eFlagsReg cr, rRegI src, immI con, immI0 zero ) %{
12013   match(Set cr (CmpI (AndI src con) zero));
12014 
12015   format %{ &quot;TEST   $src,$con&quot; %}
12016   opcode(0xF7,0x00);
12017   ins_encode( OpcP, RegOpc(src), Con32(con) );
12018   ins_pipe( ialu_cr_reg_imm );
12019 %}
12020 
12021 instruct testI_reg_mem( eFlagsReg cr, rRegI src, memory mem, immI0 zero ) %{
12022   match(Set cr (CmpI (AndI src mem) zero));
12023 
12024   format %{ &quot;TEST   $src,$mem&quot; %}
12025   opcode(0x85);
12026   ins_encode( OpcP, RegMem( src, mem ) );
12027   ins_pipe( ialu_cr_reg_mem );
12028 %}
12029 
12030 // Unsigned compare Instructions; really, same as signed except they
12031 // produce an eFlagsRegU instead of eFlagsReg.
12032 instruct compU_eReg(eFlagsRegU cr, rRegI op1, rRegI op2) %{
12033   match(Set cr (CmpU op1 op2));
12034 
12035   format %{ &quot;CMPu   $op1,$op2&quot; %}
12036   opcode(0x3B);  /* Opcode 3B /r */
12037   ins_encode( OpcP, RegReg( op1, op2) );
12038   ins_pipe( ialu_cr_reg_reg );
12039 %}
12040 
12041 instruct compU_eReg_imm(eFlagsRegU cr, rRegI op1, immI op2) %{
12042   match(Set cr (CmpU op1 op2));
12043 
12044   format %{ &quot;CMPu   $op1,$op2&quot; %}
12045   opcode(0x81,0x07);  /* Opcode 81 /7 */
12046   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
12047   ins_pipe( ialu_cr_reg_imm );
12048 %}
12049 
12050 // // Cisc-spilled version of cmpU_eReg
12051 instruct compU_eReg_mem(eFlagsRegU cr, rRegI op1, memory op2) %{
12052   match(Set cr (CmpU op1 (LoadI op2)));
12053 
12054   format %{ &quot;CMPu   $op1,$op2&quot; %}
12055   ins_cost(500);
12056   opcode(0x3B);  /* Opcode 3B /r */
12057   ins_encode( OpcP, RegMem( op1, op2) );
12058   ins_pipe( ialu_cr_reg_mem );
12059 %}
12060 
12061 // // Cisc-spilled version of cmpU_eReg
12062 //instruct compU_mem_eReg(eFlagsRegU cr, memory op1, rRegI op2) %{
12063 //  match(Set cr (CmpU (LoadI op1) op2));
12064 //
12065 //  format %{ &quot;CMPu   $op1,$op2&quot; %}
12066 //  ins_cost(500);
12067 //  opcode(0x39);  /* Opcode 39 /r */
12068 //  ins_encode( OpcP, RegMem( op1, op2) );
12069 //%}
12070 
12071 instruct testU_reg( eFlagsRegU cr, rRegI src, immI0 zero ) %{
12072   match(Set cr (CmpU src zero));
12073 
12074   format %{ &quot;TESTu  $src,$src&quot; %}
12075   opcode(0x85);
12076   ins_encode( OpcP, RegReg( src, src ) );
12077   ins_pipe( ialu_cr_reg_imm );
12078 %}
12079 
12080 // Unsigned pointer compare Instructions
12081 instruct compP_eReg(eFlagsRegU cr, eRegP op1, eRegP op2) %{
12082   match(Set cr (CmpP op1 op2));
12083 
12084   format %{ &quot;CMPu   $op1,$op2&quot; %}
12085   opcode(0x3B);  /* Opcode 3B /r */
12086   ins_encode( OpcP, RegReg( op1, op2) );
12087   ins_pipe( ialu_cr_reg_reg );
12088 %}
12089 
12090 instruct compP_eReg_imm(eFlagsRegU cr, eRegP op1, immP op2) %{
12091   match(Set cr (CmpP op1 op2));
12092 
12093   format %{ &quot;CMPu   $op1,$op2&quot; %}
12094   opcode(0x81,0x07);  /* Opcode 81 /7 */
12095   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
12096   ins_pipe( ialu_cr_reg_imm );
12097 %}
12098 
12099 // // Cisc-spilled version of cmpP_eReg
12100 instruct compP_eReg_mem(eFlagsRegU cr, eRegP op1, memory op2) %{
12101   match(Set cr (CmpP op1 (LoadP op2)));
12102 
12103   format %{ &quot;CMPu   $op1,$op2&quot; %}
12104   ins_cost(500);
12105   opcode(0x3B);  /* Opcode 3B /r */
12106   ins_encode( OpcP, RegMem( op1, op2) );
12107   ins_pipe( ialu_cr_reg_mem );
12108 %}
12109 
12110 // // Cisc-spilled version of cmpP_eReg
12111 //instruct compP_mem_eReg(eFlagsRegU cr, memory op1, eRegP op2) %{
12112 //  match(Set cr (CmpP (LoadP op1) op2));
12113 //
12114 //  format %{ &quot;CMPu   $op1,$op2&quot; %}
12115 //  ins_cost(500);
12116 //  opcode(0x39);  /* Opcode 39 /r */
12117 //  ins_encode( OpcP, RegMem( op1, op2) );
12118 //%}
12119 
12120 // Compare raw pointer (used in out-of-heap check).
12121 // Only works because non-oop pointers must be raw pointers
12122 // and raw pointers have no anti-dependencies.
12123 instruct compP_mem_eReg( eFlagsRegU cr, eRegP op1, memory op2 ) %{
12124   predicate( n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none );
12125   match(Set cr (CmpP op1 (LoadP op2)));
12126 
12127   format %{ &quot;CMPu   $op1,$op2&quot; %}
12128   opcode(0x3B);  /* Opcode 3B /r */
12129   ins_encode( OpcP, RegMem( op1, op2) );
12130   ins_pipe( ialu_cr_reg_mem );
12131 %}
12132 
12133 //
12134 // This will generate a signed flags result. This should be ok
12135 // since any compare to a zero should be eq/neq.
12136 instruct testP_reg( eFlagsReg cr, eRegP src, immP0 zero ) %{
12137   match(Set cr (CmpP src zero));
12138 
12139   format %{ &quot;TEST   $src,$src&quot; %}
12140   opcode(0x85);
12141   ins_encode( OpcP, RegReg( src, src ) );
12142   ins_pipe( ialu_cr_reg_imm );
12143 %}
12144 
12145 // Cisc-spilled version of testP_reg
12146 // This will generate a signed flags result. This should be ok
12147 // since any compare to a zero should be eq/neq.
12148 instruct testP_Reg_mem( eFlagsReg cr, memory op, immI0 zero ) %{
12149   match(Set cr (CmpP (LoadP op) zero));
12150 
12151   format %{ &quot;TEST   $op,0xFFFFFFFF&quot; %}
12152   ins_cost(500);
12153   opcode(0xF7);               /* Opcode F7 /0 */
12154   ins_encode( OpcP, RMopc_Mem(0x00,op), Con_d32(0xFFFFFFFF) );
12155   ins_pipe( ialu_cr_reg_imm );
12156 %}
12157 
12158 // Yanked all unsigned pointer compare operations.
12159 // Pointer compares are done with CmpP which is already unsigned.
12160 
12161 //----------Max and Min--------------------------------------------------------
12162 // Min Instructions
12163 ////
12164 //   *** Min and Max using the conditional move are slower than the
12165 //   *** branch version on a Pentium III.
12166 // // Conditional move for min
12167 //instruct cmovI_reg_lt( rRegI op2, rRegI op1, eFlagsReg cr ) %{
12168 //  effect( USE_DEF op2, USE op1, USE cr );
12169 //  format %{ &quot;CMOVlt $op2,$op1\t! min&quot; %}
12170 //  opcode(0x4C,0x0F);
12171 //  ins_encode( OpcS, OpcP, RegReg( op2, op1 ) );
12172 //  ins_pipe( pipe_cmov_reg );
12173 //%}
12174 //
12175 //// Min Register with Register (P6 version)
12176 //instruct minI_eReg_p6( rRegI op1, rRegI op2 ) %{
12177 //  predicate(VM_Version::supports_cmov() );
12178 //  match(Set op2 (MinI op1 op2));
12179 //  ins_cost(200);
12180 //  expand %{
12181 //    eFlagsReg cr;
12182 //    compI_eReg(cr,op1,op2);
12183 //    cmovI_reg_lt(op2,op1,cr);
12184 //  %}
12185 //%}
12186 
12187 // Min Register with Register (generic version)
12188 instruct minI_eReg(rRegI dst, rRegI src, eFlagsReg flags) %{
12189   match(Set dst (MinI dst src));
12190   effect(KILL flags);
12191   ins_cost(300);
12192 
12193   format %{ &quot;MIN    $dst,$src&quot; %}
12194   opcode(0xCC);
12195   ins_encode( min_enc(dst,src) );
12196   ins_pipe( pipe_slow );
12197 %}
12198 
12199 // Max Register with Register
12200 //   *** Min and Max using the conditional move are slower than the
12201 //   *** branch version on a Pentium III.
12202 // // Conditional move for max
12203 //instruct cmovI_reg_gt( rRegI op2, rRegI op1, eFlagsReg cr ) %{
12204 //  effect( USE_DEF op2, USE op1, USE cr );
12205 //  format %{ &quot;CMOVgt $op2,$op1\t! max&quot; %}
12206 //  opcode(0x4F,0x0F);
12207 //  ins_encode( OpcS, OpcP, RegReg( op2, op1 ) );
12208 //  ins_pipe( pipe_cmov_reg );
12209 //%}
12210 //
12211 // // Max Register with Register (P6 version)
12212 //instruct maxI_eReg_p6( rRegI op1, rRegI op2 ) %{
12213 //  predicate(VM_Version::supports_cmov() );
12214 //  match(Set op2 (MaxI op1 op2));
12215 //  ins_cost(200);
12216 //  expand %{
12217 //    eFlagsReg cr;
12218 //    compI_eReg(cr,op1,op2);
12219 //    cmovI_reg_gt(op2,op1,cr);
12220 //  %}
12221 //%}
12222 
12223 // Max Register with Register (generic version)
12224 instruct maxI_eReg(rRegI dst, rRegI src, eFlagsReg flags) %{
12225   match(Set dst (MaxI dst src));
12226   effect(KILL flags);
12227   ins_cost(300);
12228 
12229   format %{ &quot;MAX    $dst,$src&quot; %}
12230   opcode(0xCC);
12231   ins_encode( max_enc(dst,src) );
12232   ins_pipe( pipe_slow );
12233 %}
12234 
12235 // ============================================================================
12236 // Counted Loop limit node which represents exact final iterator value.
12237 // Note: the resulting value should fit into integer range since
12238 // counted loops have limit check on overflow.
12239 instruct loopLimit_eReg(eAXRegI limit, nadxRegI init, immI stride, eDXRegI limit_hi, nadxRegI tmp, eFlagsReg flags) %{
12240   match(Set limit (LoopLimit (Binary init limit) stride));
12241   effect(TEMP limit_hi, TEMP tmp, KILL flags);
12242   ins_cost(300);
12243 
12244   format %{ &quot;loopLimit $init,$limit,$stride  # $limit = $init + $stride *( $limit - $init + $stride -1)/ $stride, kills $limit_hi&quot; %}
12245   ins_encode %{
12246     int strd = (int)$stride$$constant;
12247     assert(strd != 1 &amp;&amp; strd != -1, &quot;sanity&quot;);
12248     int m1 = (strd &gt; 0) ? 1 : -1;
12249     // Convert limit to long (EAX:EDX)
12250     __ cdql();
12251     // Convert init to long (init:tmp)
12252     __ movl($tmp$$Register, $init$$Register);
12253     __ sarl($tmp$$Register, 31);
12254     // $limit - $init
12255     __ subl($limit$$Register, $init$$Register);
12256     __ sbbl($limit_hi$$Register, $tmp$$Register);
12257     // + ($stride - 1)
12258     if (strd &gt; 0) {
12259       __ addl($limit$$Register, (strd - 1));
12260       __ adcl($limit_hi$$Register, 0);
12261       __ movl($tmp$$Register, strd);
12262     } else {
12263       __ addl($limit$$Register, (strd + 1));
12264       __ adcl($limit_hi$$Register, -1);
12265       __ lneg($limit_hi$$Register, $limit$$Register);
12266       __ movl($tmp$$Register, -strd);
12267     }
12268     // signed devision: (EAX:EDX) / pos_stride
12269     __ idivl($tmp$$Register);
12270     if (strd &lt; 0) {
12271       // restore sign
12272       __ negl($tmp$$Register);
12273     }
12274     // (EAX) * stride
12275     __ mull($tmp$$Register);
12276     // + init (ignore upper bits)
12277     __ addl($limit$$Register, $init$$Register);
12278   %}
12279   ins_pipe( pipe_slow );
12280 %}
12281 
12282 // ============================================================================
12283 // Branch Instructions
12284 // Jump Table
12285 instruct jumpXtnd(rRegI switch_val) %{
12286   match(Jump switch_val);
12287   ins_cost(350);
12288   format %{  &quot;JMP    [$constantaddress](,$switch_val,1)\n\t&quot; %}
12289   ins_encode %{
12290     // Jump to Address(table_base + switch_reg)
12291     Address index(noreg, $switch_val$$Register, Address::times_1);
12292     __ jump(ArrayAddress($constantaddress, index));
12293   %}
12294   ins_pipe(pipe_jmp);
12295 %}
12296 
12297 // Jump Direct - Label defines a relative address from JMP+1
12298 instruct jmpDir(label labl) %{
12299   match(Goto);
12300   effect(USE labl);
12301 
12302   ins_cost(300);
12303   format %{ &quot;JMP    $labl&quot; %}
12304   size(5);
12305   ins_encode %{
12306     Label* L = $labl$$label;
12307     __ jmp(*L, false); // Always long jump
12308   %}
12309   ins_pipe( pipe_jmp );
12310 %}
12311 
12312 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12313 instruct jmpCon(cmpOp cop, eFlagsReg cr, label labl) %{
12314   match(If cop cr);
12315   effect(USE labl);
12316 
12317   ins_cost(300);
12318   format %{ &quot;J$cop    $labl&quot; %}
12319   size(6);
12320   ins_encode %{
12321     Label* L = $labl$$label;
12322     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12323   %}
12324   ins_pipe( pipe_jcc );
12325 %}
12326 
12327 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12328 instruct jmpLoopEnd(cmpOp cop, eFlagsReg cr, label labl) %{
12329   predicate(!n-&gt;has_vector_mask_set());
12330   match(CountedLoopEnd cop cr);
12331   effect(USE labl);
12332 
12333   ins_cost(300);
12334   format %{ &quot;J$cop    $labl\t# Loop end&quot; %}
12335   size(6);
12336   ins_encode %{
12337     Label* L = $labl$$label;
12338     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12339   %}
12340   ins_pipe( pipe_jcc );
12341 %}
12342 
12343 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12344 instruct jmpLoopEndU(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12345   predicate(!n-&gt;has_vector_mask_set());
12346   match(CountedLoopEnd cop cmp);
12347   effect(USE labl);
12348 
12349   ins_cost(300);
12350   format %{ &quot;J$cop,u  $labl\t# Loop end&quot; %}
12351   size(6);
12352   ins_encode %{
12353     Label* L = $labl$$label;
12354     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12355   %}
12356   ins_pipe( pipe_jcc );
12357 %}
12358 
12359 instruct jmpLoopEndUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12360   predicate(!n-&gt;has_vector_mask_set());
12361   match(CountedLoopEnd cop cmp);
12362   effect(USE labl);
12363 
12364   ins_cost(200);
12365   format %{ &quot;J$cop,u  $labl\t# Loop end&quot; %}
12366   size(6);
12367   ins_encode %{
12368     Label* L = $labl$$label;
12369     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12370   %}
12371   ins_pipe( pipe_jcc );
12372 %}
12373 
12374 // mask version
12375 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12376 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, eFlagsReg cr, label labl) %{
12377   predicate(n-&gt;has_vector_mask_set());
12378   match(CountedLoopEnd cop cr);
12379   effect(USE labl);
12380 
12381   ins_cost(400);
12382   format %{ &quot;J$cop    $labl\t# Loop end\n\t&quot;
12383             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12384   size(10);
12385   ins_encode %{
12386     Label* L = $labl$$label;
12387     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12388     __ restorevectmask();
12389   %}
12390   ins_pipe( pipe_jcc );
12391 %}
12392 
12393 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12394 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12395   predicate(n-&gt;has_vector_mask_set());
12396   match(CountedLoopEnd cop cmp);
12397   effect(USE labl);
12398 
12399   ins_cost(400);
12400   format %{ &quot;J$cop,u  $labl\t# Loop end\n\t&quot;
12401             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12402   size(10);
12403   ins_encode %{
12404     Label* L = $labl$$label;
12405     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12406     __ restorevectmask();
12407   %}
12408   ins_pipe( pipe_jcc );
12409 %}
12410 
12411 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12412   predicate(n-&gt;has_vector_mask_set());
12413   match(CountedLoopEnd cop cmp);
12414   effect(USE labl);
12415 
12416   ins_cost(300);
12417   format %{ &quot;J$cop,u  $labl\t# Loop end\n\t&quot;
12418             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12419   size(10);
12420   ins_encode %{
12421     Label* L = $labl$$label;
12422     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12423     __ restorevectmask();
12424   %}
12425   ins_pipe( pipe_jcc );
12426 %}
12427 
12428 // Jump Direct Conditional - using unsigned comparison
12429 instruct jmpConU(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12430   match(If cop cmp);
12431   effect(USE labl);
12432 
12433   ins_cost(300);
12434   format %{ &quot;J$cop,u  $labl&quot; %}
12435   size(6);
12436   ins_encode %{
12437     Label* L = $labl$$label;
12438     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12439   %}
12440   ins_pipe(pipe_jcc);
12441 %}
12442 
12443 instruct jmpConUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12444   match(If cop cmp);
12445   effect(USE labl);
12446 
12447   ins_cost(200);
12448   format %{ &quot;J$cop,u  $labl&quot; %}
12449   size(6);
12450   ins_encode %{
12451     Label* L = $labl$$label;
12452     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12453   %}
12454   ins_pipe(pipe_jcc);
12455 %}
12456 
12457 instruct jmpConUCF2(cmpOpUCF2 cop, eFlagsRegUCF cmp, label labl) %{
12458   match(If cop cmp);
12459   effect(USE labl);
12460 
12461   ins_cost(200);
12462   format %{ $$template
12463     if ($cop$$cmpcode == Assembler::notEqual) {
12464       $$emit$$&quot;JP,u   $labl\n\t&quot;
12465       $$emit$$&quot;J$cop,u   $labl&quot;
12466     } else {
12467       $$emit$$&quot;JP,u   done\n\t&quot;
12468       $$emit$$&quot;J$cop,u   $labl\n\t&quot;
12469       $$emit$$&quot;done:&quot;
12470     }
12471   %}
12472   ins_encode %{
12473     Label* l = $labl$$label;
12474     if ($cop$$cmpcode == Assembler::notEqual) {
12475       __ jcc(Assembler::parity, *l, false);
12476       __ jcc(Assembler::notEqual, *l, false);
12477     } else if ($cop$$cmpcode == Assembler::equal) {
12478       Label done;
12479       __ jccb(Assembler::parity, done);
12480       __ jcc(Assembler::equal, *l, false);
12481       __ bind(done);
12482     } else {
12483        ShouldNotReachHere();
12484     }
12485   %}
12486   ins_pipe(pipe_jcc);
12487 %}
12488 
12489 // ============================================================================
12490 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary superklass
12491 // array for an instance of the superklass.  Set a hidden internal cache on a
12492 // hit (cache is checked with exposed code in gen_subtype_check()).  Return
12493 // NZ for a miss or zero for a hit.  The encoding ALSO sets flags.
12494 instruct partialSubtypeCheck( eDIRegP result, eSIRegP sub, eAXRegP super, eCXRegI rcx, eFlagsReg cr ) %{
12495   match(Set result (PartialSubtypeCheck sub super));
12496   effect( KILL rcx, KILL cr );
12497 
12498   ins_cost(1100);  // slightly larger than the next version
12499   format %{ &quot;MOV    EDI,[$sub+Klass::secondary_supers]\n\t&quot;
12500             &quot;MOV    ECX,[EDI+ArrayKlass::length]\t# length to scan\n\t&quot;
12501             &quot;ADD    EDI,ArrayKlass::base_offset\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12502             &quot;REPNE SCASD\t# Scan *EDI++ for a match with EAX while CX-- != 0\n\t&quot;
12503             &quot;JNE,s  miss\t\t# Missed: EDI not-zero\n\t&quot;
12504             &quot;MOV    [$sub+Klass::secondary_super_cache],$super\t# Hit: update cache\n\t&quot;
12505             &quot;XOR    $result,$result\t\t Hit: EDI zero\n\t&quot;
12506      &quot;miss:\t&quot; %}
12507 
12508   opcode(0x1); // Force a XOR of EDI
12509   ins_encode( enc_PartialSubtypeCheck() );
12510   ins_pipe( pipe_slow );
12511 %}
12512 
12513 instruct partialSubtypeCheck_vs_Zero( eFlagsReg cr, eSIRegP sub, eAXRegP super, eCXRegI rcx, eDIRegP result, immP0 zero ) %{
12514   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12515   effect( KILL rcx, KILL result );
12516 
12517   ins_cost(1000);
12518   format %{ &quot;MOV    EDI,[$sub+Klass::secondary_supers]\n\t&quot;
12519             &quot;MOV    ECX,[EDI+ArrayKlass::length]\t# length to scan\n\t&quot;
12520             &quot;ADD    EDI,ArrayKlass::base_offset\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12521             &quot;REPNE SCASD\t# Scan *EDI++ for a match with EAX while CX-- != 0\n\t&quot;
12522             &quot;JNE,s  miss\t\t# Missed: flags NZ\n\t&quot;
12523             &quot;MOV    [$sub+Klass::secondary_super_cache],$super\t# Hit: update cache, flags Z\n\t&quot;
12524      &quot;miss:\t&quot; %}
12525 
12526   opcode(0x0);  // No need to XOR EDI
12527   ins_encode( enc_PartialSubtypeCheck() );
12528   ins_pipe( pipe_slow );
12529 %}
12530 
12531 // ============================================================================
12532 // Branch Instructions -- short offset versions
12533 //
12534 // These instructions are used to replace jumps of a long offset (the default
12535 // match) with jumps of a shorter offset.  These instructions are all tagged
12536 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12537 // match rules in general matching.  Instead, the ADLC generates a conversion
12538 // method in the MachNode which can be used to do in-place replacement of the
12539 // long variant with the shorter variant.  The compiler will determine if a
12540 // branch can be taken by the is_short_branch_offset() predicate in the machine
12541 // specific code section of the file.
12542 
12543 // Jump Direct - Label defines a relative address from JMP+1
12544 instruct jmpDir_short(label labl) %{
12545   match(Goto);
12546   effect(USE labl);
12547 
12548   ins_cost(300);
12549   format %{ &quot;JMP,s  $labl&quot; %}
12550   size(2);
12551   ins_encode %{
12552     Label* L = $labl$$label;
12553     __ jmpb(*L);
12554   %}
12555   ins_pipe( pipe_jmp );
12556   ins_short_branch(1);
12557 %}
12558 
12559 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12560 instruct jmpCon_short(cmpOp cop, eFlagsReg cr, label labl) %{
12561   match(If cop cr);
12562   effect(USE labl);
12563 
12564   ins_cost(300);
12565   format %{ &quot;J$cop,s  $labl&quot; %}
12566   size(2);
12567   ins_encode %{
12568     Label* L = $labl$$label;
12569     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12570   %}
12571   ins_pipe( pipe_jcc );
12572   ins_short_branch(1);
12573 %}
12574 
12575 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12576 instruct jmpLoopEnd_short(cmpOp cop, eFlagsReg cr, label labl) %{
12577   match(CountedLoopEnd cop cr);
12578   effect(USE labl);
12579 
12580   ins_cost(300);
12581   format %{ &quot;J$cop,s  $labl\t# Loop end&quot; %}
12582   size(2);
12583   ins_encode %{
12584     Label* L = $labl$$label;
12585     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12586   %}
12587   ins_pipe( pipe_jcc );
12588   ins_short_branch(1);
12589 %}
12590 
12591 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12592 instruct jmpLoopEndU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12593   match(CountedLoopEnd cop cmp);
12594   effect(USE labl);
12595 
12596   ins_cost(300);
12597   format %{ &quot;J$cop,us $labl\t# Loop end&quot; %}
12598   size(2);
12599   ins_encode %{
12600     Label* L = $labl$$label;
12601     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12602   %}
12603   ins_pipe( pipe_jcc );
12604   ins_short_branch(1);
12605 %}
12606 
12607 instruct jmpLoopEndUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12608   match(CountedLoopEnd cop cmp);
12609   effect(USE labl);
12610 
12611   ins_cost(300);
12612   format %{ &quot;J$cop,us $labl\t# Loop end&quot; %}
12613   size(2);
12614   ins_encode %{
12615     Label* L = $labl$$label;
12616     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12617   %}
12618   ins_pipe( pipe_jcc );
12619   ins_short_branch(1);
12620 %}
12621 
12622 // Jump Direct Conditional - using unsigned comparison
12623 instruct jmpConU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12624   match(If cop cmp);
12625   effect(USE labl);
12626 
12627   ins_cost(300);
12628   format %{ &quot;J$cop,us $labl&quot; %}
12629   size(2);
12630   ins_encode %{
12631     Label* L = $labl$$label;
12632     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12633   %}
12634   ins_pipe( pipe_jcc );
12635   ins_short_branch(1);
12636 %}
12637 
12638 instruct jmpConUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12639   match(If cop cmp);
12640   effect(USE labl);
12641 
12642   ins_cost(300);
12643   format %{ &quot;J$cop,us $labl&quot; %}
12644   size(2);
12645   ins_encode %{
12646     Label* L = $labl$$label;
12647     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12648   %}
12649   ins_pipe( pipe_jcc );
12650   ins_short_branch(1);
12651 %}
12652 
12653 instruct jmpConUCF2_short(cmpOpUCF2 cop, eFlagsRegUCF cmp, label labl) %{
12654   match(If cop cmp);
12655   effect(USE labl);
12656 
12657   ins_cost(300);
12658   format %{ $$template
12659     if ($cop$$cmpcode == Assembler::notEqual) {
12660       $$emit$$&quot;JP,u,s   $labl\n\t&quot;
12661       $$emit$$&quot;J$cop,u,s   $labl&quot;
12662     } else {
12663       $$emit$$&quot;JP,u,s   done\n\t&quot;
12664       $$emit$$&quot;J$cop,u,s  $labl\n\t&quot;
12665       $$emit$$&quot;done:&quot;
12666     }
12667   %}
12668   size(4);
12669   ins_encode %{
12670     Label* l = $labl$$label;
12671     if ($cop$$cmpcode == Assembler::notEqual) {
12672       __ jccb(Assembler::parity, *l);
12673       __ jccb(Assembler::notEqual, *l);
12674     } else if ($cop$$cmpcode == Assembler::equal) {
12675       Label done;
12676       __ jccb(Assembler::parity, done);
12677       __ jccb(Assembler::equal, *l);
12678       __ bind(done);
12679     } else {
12680        ShouldNotReachHere();
12681     }
12682   %}
12683   ins_pipe(pipe_jcc);
12684   ins_short_branch(1);
12685 %}
12686 
12687 // ============================================================================
12688 // Long Compare
12689 //
12690 // Currently we hold longs in 2 registers.  Comparing such values efficiently
12691 // is tricky.  The flavor of compare used depends on whether we are testing
12692 // for LT, LE, or EQ.  For a simple LT test we can check just the sign bit.
12693 // The GE test is the negated LT test.  The LE test can be had by commuting
12694 // the operands (yielding a GE test) and then negating; negate again for the
12695 // GT test.  The EQ test is done by ORcc&#39;ing the high and low halves, and the
12696 // NE test is negated from that.
12697 
12698 // Due to a shortcoming in the ADLC, it mixes up expressions like:
12699 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)).  Note the
12700 // difference between &#39;Y&#39; and &#39;0L&#39;.  The tree-matches for the CmpI sections
12701 // are collapsed internally in the ADLC&#39;s dfa-gen code.  The match for
12702 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
12703 // foo match ends up with the wrong leaf.  One fix is to not match both
12704 // reg-reg and reg-zero forms of long-compare.  This is unfortunate because
12705 // both forms beat the trinary form of long-compare and both are very useful
12706 // on Intel which has so few registers.
12707 
12708 // Manifest a CmpL result in an integer register.  Very painful.
12709 // This is the test to avoid.
12710 instruct cmpL3_reg_reg(eSIRegI dst, eRegL src1, eRegL src2, eFlagsReg flags ) %{
12711   match(Set dst (CmpL3 src1 src2));
12712   effect( KILL flags );
12713   ins_cost(1000);
12714   format %{ &quot;XOR    $dst,$dst\n\t&quot;
12715             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12716             &quot;JLT,s  m_one\n\t&quot;
12717             &quot;JGT,s  p_one\n\t&quot;
12718             &quot;CMP    $src1.lo,$src2.lo\n\t&quot;
12719             &quot;JB,s   m_one\n\t&quot;
12720             &quot;JEQ,s  done\n&quot;
12721     &quot;p_one:\tINC    $dst\n\t&quot;
12722             &quot;JMP,s  done\n&quot;
12723     &quot;m_one:\tDEC    $dst\n&quot;
12724      &quot;done:&quot; %}
12725   ins_encode %{
12726     Label p_one, m_one, done;
12727     __ xorptr($dst$$Register, $dst$$Register);
12728     __ cmpl(HIGH_FROM_LOW($src1$$Register), HIGH_FROM_LOW($src2$$Register));
12729     __ jccb(Assembler::less,    m_one);
12730     __ jccb(Assembler::greater, p_one);
12731     __ cmpl($src1$$Register, $src2$$Register);
12732     __ jccb(Assembler::below,   m_one);
12733     __ jccb(Assembler::equal,   done);
12734     __ bind(p_one);
12735     __ incrementl($dst$$Register);
12736     __ jmpb(done);
12737     __ bind(m_one);
12738     __ decrementl($dst$$Register);
12739     __ bind(done);
12740   %}
12741   ins_pipe( pipe_slow );
12742 %}
12743 
12744 //======
12745 // Manifest a CmpL result in the normal flags.  Only good for LT or GE
12746 // compares.  Can be used for LE or GT compares by reversing arguments.
12747 // NOT GOOD FOR EQ/NE tests.
12748 instruct cmpL_zero_flags_LTGE( flagsReg_long_LTGE flags, eRegL src, immL0 zero ) %{
12749   match( Set flags (CmpL src zero ));
12750   ins_cost(100);
12751   format %{ &quot;TEST   $src.hi,$src.hi&quot; %}
12752   opcode(0x85);
12753   ins_encode( OpcP, RegReg_Hi2( src, src ) );
12754   ins_pipe( ialu_cr_reg_reg );
12755 %}
12756 
12757 // Manifest a CmpL result in the normal flags.  Only good for LT or GE
12758 // compares.  Can be used for LE or GT compares by reversing arguments.
12759 // NOT GOOD FOR EQ/NE tests.
12760 instruct cmpL_reg_flags_LTGE( flagsReg_long_LTGE flags, eRegL src1, eRegL src2, rRegI tmp ) %{
12761   match( Set flags (CmpL src1 src2 ));
12762   effect( TEMP tmp );
12763   ins_cost(300);
12764   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits\n\t&quot;
12765             &quot;MOV    $tmp,$src1.hi\n\t&quot;
12766             &quot;SBB    $tmp,$src2.hi\t! Compute flags for long compare&quot; %}
12767   ins_encode( long_cmp_flags2( src1, src2, tmp ) );
12768   ins_pipe( ialu_cr_reg_reg );
12769 %}
12770 
12771 // Long compares reg &lt; zero/req OR reg &gt;= zero/req.
12772 // Just a wrapper for a normal branch, plus the predicate test.
12773 instruct cmpL_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, label labl) %{
12774   match(If cmp flags);
12775   effect(USE labl);
12776   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12777   expand %{
12778     jmpCon(cmp,flags,labl);    // JLT or JGE...
12779   %}
12780 %}
12781 
12782 //======
12783 // Manifest a CmpUL result in the normal flags.  Only good for LT or GE
12784 // compares.  Can be used for LE or GT compares by reversing arguments.
12785 // NOT GOOD FOR EQ/NE tests.
12786 instruct cmpUL_zero_flags_LTGE(flagsReg_ulong_LTGE flags, eRegL src, immL0 zero) %{
12787   match(Set flags (CmpUL src zero));
12788   ins_cost(100);
12789   format %{ &quot;TEST   $src.hi,$src.hi&quot; %}
12790   opcode(0x85);
12791   ins_encode(OpcP, RegReg_Hi2(src, src));
12792   ins_pipe(ialu_cr_reg_reg);
12793 %}
12794 
12795 // Manifest a CmpUL result in the normal flags.  Only good for LT or GE
12796 // compares.  Can be used for LE or GT compares by reversing arguments.
12797 // NOT GOOD FOR EQ/NE tests.
12798 instruct cmpUL_reg_flags_LTGE(flagsReg_ulong_LTGE flags, eRegL src1, eRegL src2, rRegI tmp) %{
12799   match(Set flags (CmpUL src1 src2));
12800   effect(TEMP tmp);
12801   ins_cost(300);
12802   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Unsigned long compare; set flags for low bits\n\t&quot;
12803             &quot;MOV    $tmp,$src1.hi\n\t&quot;
12804             &quot;SBB    $tmp,$src2.hi\t! Compute flags for unsigned long compare&quot; %}
12805   ins_encode(long_cmp_flags2(src1, src2, tmp));
12806   ins_pipe(ialu_cr_reg_reg);
12807 %}
12808 
12809 // Unsigned long compares reg &lt; zero/req OR reg &gt;= zero/req.
12810 // Just a wrapper for a normal branch, plus the predicate test.
12811 instruct cmpUL_LTGE(cmpOpU cmp, flagsReg_ulong_LTGE flags, label labl) %{
12812   match(If cmp flags);
12813   effect(USE labl);
12814   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
12815   expand %{
12816     jmpCon(cmp, flags, labl);    // JLT or JGE...
12817   %}
12818 %}
12819 
12820 // Compare 2 longs and CMOVE longs.
12821 instruct cmovLL_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegL dst, eRegL src) %{
12822   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
12823   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12824   ins_cost(400);
12825   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12826             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12827   opcode(0x0F,0x40);
12828   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
12829   ins_pipe( pipe_cmov_reg_long );
12830 %}
12831 
12832 instruct cmovLL_mem_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegL dst, load_long_memory src) %{
12833   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
12834   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12835   ins_cost(500);
12836   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12837             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12838   opcode(0x0F,0x40);
12839   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
12840   ins_pipe( pipe_cmov_reg_long );
12841 %}
12842 
12843 // Compare 2 longs and CMOVE ints.
12844 instruct cmovII_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, rRegI dst, rRegI src) %{
12845   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12846   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
12847   ins_cost(200);
12848   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12849   opcode(0x0F,0x40);
12850   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12851   ins_pipe( pipe_cmov_reg );
12852 %}
12853 
12854 instruct cmovII_mem_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, rRegI dst, memory src) %{
12855   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12856   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
12857   ins_cost(250);
12858   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12859   opcode(0x0F,0x40);
12860   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
12861   ins_pipe( pipe_cmov_mem );
12862 %}
12863 
12864 // Compare 2 longs and CMOVE ints.
12865 instruct cmovPP_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegP dst, eRegP src) %{
12866   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12867   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
12868   ins_cost(200);
12869   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12870   opcode(0x0F,0x40);
12871   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12872   ins_pipe( pipe_cmov_reg );
12873 %}
12874 
12875 // Compare 2 longs and CMOVE doubles
12876 instruct cmovDDPR_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regDPR dst, regDPR src) %{
12877   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12878   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
12879   ins_cost(200);
12880   expand %{
12881     fcmovDPR_regS(cmp,flags,dst,src);
12882   %}
12883 %}
12884 
12885 // Compare 2 longs and CMOVE doubles
12886 instruct cmovDD_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regD dst, regD src) %{
12887   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12888   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
12889   ins_cost(200);
12890   expand %{
12891     fcmovD_regS(cmp,flags,dst,src);
12892   %}
12893 %}
12894 
12895 instruct cmovFFPR_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regFPR dst, regFPR src) %{
12896   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12897   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
12898   ins_cost(200);
12899   expand %{
12900     fcmovFPR_regS(cmp,flags,dst,src);
12901   %}
12902 %}
12903 
12904 instruct cmovFF_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regF dst, regF src) %{
12905   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12906   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
12907   ins_cost(200);
12908   expand %{
12909     fcmovF_regS(cmp,flags,dst,src);
12910   %}
12911 %}
12912 
12913 //======
12914 // Manifest a CmpL result in the normal flags.  Only good for EQ/NE compares.
12915 instruct cmpL_zero_flags_EQNE( flagsReg_long_EQNE flags, eRegL src, immL0 zero, rRegI tmp ) %{
12916   match( Set flags (CmpL src zero ));
12917   effect(TEMP tmp);
12918   ins_cost(200);
12919   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
12920             &quot;OR     $tmp,$src.hi\t! Long is EQ/NE 0?&quot; %}
12921   ins_encode( long_cmp_flags0( src, tmp ) );
12922   ins_pipe( ialu_reg_reg_long );
12923 %}
12924 
12925 // Manifest a CmpL result in the normal flags.  Only good for EQ/NE compares.
12926 instruct cmpL_reg_flags_EQNE( flagsReg_long_EQNE flags, eRegL src1, eRegL src2 ) %{
12927   match( Set flags (CmpL src1 src2 ));
12928   ins_cost(200+300);
12929   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits\n\t&quot;
12930             &quot;JNE,s  skip\n\t&quot;
12931             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12932      &quot;skip:\t&quot; %}
12933   ins_encode( long_cmp_flags1( src1, src2 ) );
12934   ins_pipe( ialu_cr_reg_reg );
12935 %}
12936 
12937 // Long compare reg == zero/reg OR reg != zero/reg
12938 // Just a wrapper for a normal branch, plus the predicate test.
12939 instruct cmpL_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, label labl) %{
12940   match(If cmp flags);
12941   effect(USE labl);
12942   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
12943   expand %{
12944     jmpCon(cmp,flags,labl);    // JEQ or JNE...
12945   %}
12946 %}
12947 
12948 //======
12949 // Manifest a CmpUL result in the normal flags.  Only good for EQ/NE compares.
12950 instruct cmpUL_zero_flags_EQNE(flagsReg_ulong_EQNE flags, eRegL src, immL0 zero, rRegI tmp) %{
12951   match(Set flags (CmpUL src zero));
12952   effect(TEMP tmp);
12953   ins_cost(200);
12954   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
12955             &quot;OR     $tmp,$src.hi\t! Unsigned long is EQ/NE 0?&quot; %}
12956   ins_encode(long_cmp_flags0(src, tmp));
12957   ins_pipe(ialu_reg_reg_long);
12958 %}
12959 
12960 // Manifest a CmpUL result in the normal flags.  Only good for EQ/NE compares.
12961 instruct cmpUL_reg_flags_EQNE(flagsReg_ulong_EQNE flags, eRegL src1, eRegL src2) %{
12962   match(Set flags (CmpUL src1 src2));
12963   ins_cost(200+300);
12964   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Unsigned long compare; set flags for low bits\n\t&quot;
12965             &quot;JNE,s  skip\n\t&quot;
12966             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12967      &quot;skip:\t&quot; %}
12968   ins_encode(long_cmp_flags1(src1, src2));
12969   ins_pipe(ialu_cr_reg_reg);
12970 %}
12971 
12972 // Unsigned long compare reg == zero/reg OR reg != zero/reg
12973 // Just a wrapper for a normal branch, plus the predicate test.
12974 instruct cmpUL_EQNE(cmpOpU cmp, flagsReg_ulong_EQNE flags, label labl) %{
12975   match(If cmp flags);
12976   effect(USE labl);
12977   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne);
12978   expand %{
12979     jmpCon(cmp, flags, labl);    // JEQ or JNE...
12980   %}
12981 %}
12982 
12983 // Compare 2 longs and CMOVE longs.
12984 instruct cmovLL_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegL dst, eRegL src) %{
12985   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
12986   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12987   ins_cost(400);
12988   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12989             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12990   opcode(0x0F,0x40);
12991   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
12992   ins_pipe( pipe_cmov_reg_long );
12993 %}
12994 
12995 instruct cmovLL_mem_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegL dst, load_long_memory src) %{
12996   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
12997   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12998   ins_cost(500);
12999   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13000             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
13001   opcode(0x0F,0x40);
13002   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
13003   ins_pipe( pipe_cmov_reg_long );
13004 %}
13005 
13006 // Compare 2 longs and CMOVE ints.
13007 instruct cmovII_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, rRegI dst, rRegI src) %{
13008   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13009   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
13010   ins_cost(200);
13011   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13012   opcode(0x0F,0x40);
13013   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13014   ins_pipe( pipe_cmov_reg );
13015 %}
13016 
13017 instruct cmovII_mem_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, rRegI dst, memory src) %{
13018   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13019   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
13020   ins_cost(250);
13021   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13022   opcode(0x0F,0x40);
13023   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
13024   ins_pipe( pipe_cmov_mem );
13025 %}
13026 
13027 // Compare 2 longs and CMOVE ints.
13028 instruct cmovPP_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegP dst, eRegP src) %{
13029   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13030   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
13031   ins_cost(200);
13032   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13033   opcode(0x0F,0x40);
13034   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13035   ins_pipe( pipe_cmov_reg );
13036 %}
13037 
13038 // Compare 2 longs and CMOVE doubles
13039 instruct cmovDDPR_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regDPR dst, regDPR src) %{
13040   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13041   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13042   ins_cost(200);
13043   expand %{
13044     fcmovDPR_regS(cmp,flags,dst,src);
13045   %}
13046 %}
13047 
13048 // Compare 2 longs and CMOVE doubles
13049 instruct cmovDD_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regD dst, regD src) %{
13050   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13051   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13052   ins_cost(200);
13053   expand %{
13054     fcmovD_regS(cmp,flags,dst,src);
13055   %}
13056 %}
13057 
13058 instruct cmovFFPR_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regFPR dst, regFPR src) %{
13059   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13060   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13061   ins_cost(200);
13062   expand %{
13063     fcmovFPR_regS(cmp,flags,dst,src);
13064   %}
13065 %}
13066 
13067 instruct cmovFF_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regF dst, regF src) %{
13068   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13069   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13070   ins_cost(200);
13071   expand %{
13072     fcmovF_regS(cmp,flags,dst,src);
13073   %}
13074 %}
13075 
13076 //======
13077 // Manifest a CmpL result in the normal flags.  Only good for LE or GT compares.
13078 // Same as cmpL_reg_flags_LEGT except must negate src
13079 instruct cmpL_zero_flags_LEGT( flagsReg_long_LEGT flags, eRegL src, immL0 zero, rRegI tmp ) %{
13080   match( Set flags (CmpL src zero ));
13081   effect( TEMP tmp );
13082   ins_cost(300);
13083   format %{ &quot;XOR    $tmp,$tmp\t# Long compare for -$src &lt; 0, use commuted test\n\t&quot;
13084             &quot;CMP    $tmp,$src.lo\n\t&quot;
13085             &quot;SBB    $tmp,$src.hi\n\t&quot; %}
13086   ins_encode( long_cmp_flags3(src, tmp) );
13087   ins_pipe( ialu_reg_reg_long );
13088 %}
13089 
13090 // Manifest a CmpL result in the normal flags.  Only good for LE or GT compares.
13091 // Same as cmpL_reg_flags_LTGE except operands swapped.  Swapping operands
13092 // requires a commuted test to get the same result.
13093 instruct cmpL_reg_flags_LEGT( flagsReg_long_LEGT flags, eRegL src1, eRegL src2, rRegI tmp ) %{
13094   match( Set flags (CmpL src1 src2 ));
13095   effect( TEMP tmp );
13096   ins_cost(300);
13097   format %{ &quot;CMP    $src2.lo,$src1.lo\t! Long compare, swapped operands, use with commuted test\n\t&quot;
13098             &quot;MOV    $tmp,$src2.hi\n\t&quot;
13099             &quot;SBB    $tmp,$src1.hi\t! Compute flags for long compare&quot; %}
13100   ins_encode( long_cmp_flags2( src2, src1, tmp ) );
13101   ins_pipe( ialu_cr_reg_reg );
13102 %}
13103 
13104 // Long compares reg &lt; zero/req OR reg &gt;= zero/req.
13105 // Just a wrapper for a normal branch, plus the predicate test
13106 instruct cmpL_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, label labl) %{
13107   match(If cmp flags);
13108   effect(USE labl);
13109   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le );
13110   ins_cost(300);
13111   expand %{
13112     jmpCon(cmp,flags,labl);    // JGT or JLE...
13113   %}
13114 %}
13115 
13116 //======
13117 // Manifest a CmpUL result in the normal flags.  Only good for LE or GT compares.
13118 // Same as cmpUL_reg_flags_LEGT except must negate src
13119 instruct cmpUL_zero_flags_LEGT(flagsReg_ulong_LEGT flags, eRegL src, immL0 zero, rRegI tmp) %{
13120   match(Set flags (CmpUL src zero));
13121   effect(TEMP tmp);
13122   ins_cost(300);
13123   format %{ &quot;XOR    $tmp,$tmp\t# Unsigned long compare for -$src &lt; 0, use commuted test\n\t&quot;
13124             &quot;CMP    $tmp,$src.lo\n\t&quot;
13125             &quot;SBB    $tmp,$src.hi\n\t&quot; %}
13126   ins_encode(long_cmp_flags3(src, tmp));
13127   ins_pipe(ialu_reg_reg_long);
13128 %}
13129 
13130 // Manifest a CmpUL result in the normal flags.  Only good for LE or GT compares.
13131 // Same as cmpUL_reg_flags_LTGE except operands swapped.  Swapping operands
13132 // requires a commuted test to get the same result.
13133 instruct cmpUL_reg_flags_LEGT(flagsReg_ulong_LEGT flags, eRegL src1, eRegL src2, rRegI tmp) %{
13134   match(Set flags (CmpUL src1 src2));
13135   effect(TEMP tmp);
13136   ins_cost(300);
13137   format %{ &quot;CMP    $src2.lo,$src1.lo\t! Unsigned long compare, swapped operands, use with commuted test\n\t&quot;
13138             &quot;MOV    $tmp,$src2.hi\n\t&quot;
13139             &quot;SBB    $tmp,$src1.hi\t! Compute flags for unsigned long compare&quot; %}
13140   ins_encode(long_cmp_flags2( src2, src1, tmp));
13141   ins_pipe(ialu_cr_reg_reg);
13142 %}
13143 
13144 // Unsigned long compares reg &lt; zero/req OR reg &gt;= zero/req.
13145 // Just a wrapper for a normal branch, plus the predicate test
13146 instruct cmpUL_LEGT(cmpOpU_commute cmp, flagsReg_ulong_LEGT flags, label labl) %{
13147   match(If cmp flags);
13148   effect(USE labl);
13149   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le);
13150   ins_cost(300);
13151   expand %{
13152     jmpCon(cmp, flags, labl);    // JGT or JLE...
13153   %}
13154 %}
13155 
13156 // Compare 2 longs and CMOVE longs.
13157 instruct cmovLL_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegL dst, eRegL src) %{
13158   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
13159   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13160   ins_cost(400);
13161   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13162             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
13163   opcode(0x0F,0x40);
13164   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
13165   ins_pipe( pipe_cmov_reg_long );
13166 %}
13167 
13168 instruct cmovLL_mem_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegL dst, load_long_memory src) %{
13169   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
13170   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13171   ins_cost(500);
13172   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13173             &quot;CMOV$cmp $dst.hi,$src.hi+4&quot; %}
13174   opcode(0x0F,0x40);
13175   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
13176   ins_pipe( pipe_cmov_reg_long );
13177 %}
13178 
13179 // Compare 2 longs and CMOVE ints.
13180 instruct cmovII_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, rRegI dst, rRegI src) %{
13181   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13182   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
13183   ins_cost(200);
13184   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13185   opcode(0x0F,0x40);
13186   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13187   ins_pipe( pipe_cmov_reg );
13188 %}
13189 
13190 instruct cmovII_mem_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, rRegI dst, memory src) %{
13191   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13192   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
13193   ins_cost(250);
13194   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13195   opcode(0x0F,0x40);
13196   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
13197   ins_pipe( pipe_cmov_mem );
13198 %}
13199 
13200 // Compare 2 longs and CMOVE ptrs.
13201 instruct cmovPP_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegP dst, eRegP src) %{
13202   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13203   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
13204   ins_cost(200);
13205   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13206   opcode(0x0F,0x40);
13207   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13208   ins_pipe( pipe_cmov_reg );
13209 %}
13210 
13211 // Compare 2 longs and CMOVE doubles
13212 instruct cmovDDPR_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regDPR dst, regDPR src) %{
13213   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13214   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13215   ins_cost(200);
13216   expand %{
13217     fcmovDPR_regS(cmp,flags,dst,src);
13218   %}
13219 %}
13220 
13221 // Compare 2 longs and CMOVE doubles
13222 instruct cmovDD_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regD dst, regD src) %{
13223   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13224   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13225   ins_cost(200);
13226   expand %{
13227     fcmovD_regS(cmp,flags,dst,src);
13228   %}
13229 %}
13230 
13231 instruct cmovFFPR_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regFPR dst, regFPR src) %{
13232   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13233   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13234   ins_cost(200);
13235   expand %{
13236     fcmovFPR_regS(cmp,flags,dst,src);
13237   %}
13238 %}
13239 
13240 
13241 instruct cmovFF_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regF dst, regF src) %{
13242   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13243   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13244   ins_cost(200);
13245   expand %{
13246     fcmovF_regS(cmp,flags,dst,src);
13247   %}
13248 %}
13249 
13250 
13251 // ============================================================================
13252 // Procedure Call/Return Instructions
13253 // Call Java Static Instruction
13254 // Note: If this code changes, the corresponding ret_addr_offset() and
13255 //       compute_padding() functions will have to be adjusted.
13256 instruct CallStaticJavaDirect(method meth) %{
13257   match(CallStaticJava);
13258   effect(USE meth);
13259 
13260   ins_cost(300);
13261   format %{ &quot;CALL,static &quot; %}
13262   opcode(0xE8); /* E8 cd */
13263   ins_encode( pre_call_resets,
13264               Java_Static_Call( meth ),
13265               call_epilog,
13266               post_call_FPU );
13267   ins_pipe( pipe_slow );
13268   ins_alignment(4);
13269 %}
13270 
13271 // Call Java Dynamic Instruction
13272 // Note: If this code changes, the corresponding ret_addr_offset() and
13273 //       compute_padding() functions will have to be adjusted.
13274 instruct CallDynamicJavaDirect(method meth) %{
13275   match(CallDynamicJava);
13276   effect(USE meth);
13277 
13278   ins_cost(300);
13279   format %{ &quot;MOV    EAX,(oop)-1\n\t&quot;
13280             &quot;CALL,dynamic&quot; %}
13281   opcode(0xE8); /* E8 cd */
13282   ins_encode( pre_call_resets,
13283               Java_Dynamic_Call( meth ),
13284               call_epilog,
13285               post_call_FPU );
13286   ins_pipe( pipe_slow );
13287   ins_alignment(4);
13288 %}
13289 
13290 // Call Runtime Instruction
13291 instruct CallRuntimeDirect(method meth) %{
13292   match(CallRuntime );
13293   effect(USE meth);
13294 
13295   ins_cost(300);
13296   format %{ &quot;CALL,runtime &quot; %}
13297   opcode(0xE8); /* E8 cd */
13298   // Use FFREEs to clear entries in float stack
13299   ins_encode( pre_call_resets,
13300               FFree_Float_Stack_All,
13301               Java_To_Runtime( meth ),
13302               post_call_FPU );
13303   ins_pipe( pipe_slow );
13304 %}
13305 
13306 // Call runtime without safepoint
13307 instruct CallLeafDirect(method meth) %{
13308   match(CallLeaf);
13309   effect(USE meth);
13310 
13311   ins_cost(300);
13312   format %{ &quot;CALL_LEAF,runtime &quot; %}
13313   opcode(0xE8); /* E8 cd */
13314   ins_encode( pre_call_resets,
13315               FFree_Float_Stack_All,
13316               Java_To_Runtime( meth ),
13317               Verify_FPU_For_Leaf, post_call_FPU );
13318   ins_pipe( pipe_slow );
13319 %}
13320 
13321 instruct CallLeafNoFPDirect(method meth) %{
13322   match(CallLeafNoFP);
13323   effect(USE meth);
13324 
13325   ins_cost(300);
13326   format %{ &quot;CALL_LEAF_NOFP,runtime &quot; %}
13327   opcode(0xE8); /* E8 cd */
13328   ins_encode(pre_call_resets, Java_To_Runtime(meth));
13329   ins_pipe( pipe_slow );
13330 %}
13331 
13332 
13333 // Return Instruction
13334 // Remove the return address &amp; jump to it.
13335 instruct Ret() %{
13336   match(Return);
13337   format %{ &quot;RET&quot; %}
13338   opcode(0xC3);
13339   ins_encode(OpcP);
13340   ins_pipe( pipe_jmp );
13341 %}
13342 
13343 // Tail Call; Jump from runtime stub to Java code.
13344 // Also known as an &#39;interprocedural jump&#39;.
13345 // Target of jump will eventually return to caller.
13346 // TailJump below removes the return address.
13347 instruct TailCalljmpInd(eRegP_no_EBP jump_target, eBXRegP method_oop) %{
13348   match(TailCall jump_target method_oop );
13349   ins_cost(300);
13350   format %{ &quot;JMP    $jump_target \t# EBX holds method oop&quot; %}
13351   opcode(0xFF, 0x4);  /* Opcode FF /4 */
13352   ins_encode( OpcP, RegOpc(jump_target) );
13353   ins_pipe( pipe_jmp );
13354 %}
13355 
13356 
13357 // Tail Jump; remove the return address; jump to target.
13358 // TailCall above leaves the return address around.
13359 instruct tailjmpInd(eRegP_no_EBP jump_target, eAXRegP ex_oop) %{
13360   match( TailJump jump_target ex_oop );
13361   ins_cost(300);
13362   format %{ &quot;POP    EDX\t# pop return address into dummy\n\t&quot;
13363             &quot;JMP    $jump_target &quot; %}
13364   opcode(0xFF, 0x4);  /* Opcode FF /4 */
13365   ins_encode( enc_pop_rdx,
13366               OpcP, RegOpc(jump_target) );
13367   ins_pipe( pipe_jmp );
13368 %}
13369 
13370 // Create exception oop: created by stack-crawling runtime code.
13371 // Created exception is now available to this handler, and is setup
13372 // just prior to jumping to this handler.  No code emitted.
13373 instruct CreateException( eAXRegP ex_oop )
13374 %{
13375   match(Set ex_oop (CreateEx));
13376 
13377   size(0);
13378   // use the following format syntax
13379   format %{ &quot;# exception oop is in EAX; no code emitted&quot; %}
13380   ins_encode();
13381   ins_pipe( empty );
13382 %}
13383 
13384 
13385 // Rethrow exception:
13386 // The exception oop will come in the first argument position.
13387 // Then JUMP (not call) to the rethrow stub code.
13388 instruct RethrowException()
13389 %{
13390   match(Rethrow);
13391 
13392   // use the following format syntax
13393   format %{ &quot;JMP    rethrow_stub&quot; %}
13394   ins_encode(enc_rethrow);
13395   ins_pipe( pipe_jmp );
13396 %}
13397 
13398 // inlined locking and unlocking
13399 
13400 instruct cmpFastLockRTM(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eDXRegI scr, rRegI cx1, rRegI cx2) %{
13401   predicate(Compile::current()-&gt;use_rtm());
13402   match(Set cr (FastLock object box));
13403   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
13404   ins_cost(300);
13405   format %{ &quot;FASTLOCK $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
13406   ins_encode %{
13407     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
13408                  $scr$$Register, $cx1$$Register, $cx2$$Register,
13409                  _counters, _rtm_counters, _stack_rtm_counters,
13410                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
13411                  true, ra_-&gt;C-&gt;profile_rtm());
13412   %}
13413   ins_pipe(pipe_slow);
13414 %}
13415 
13416 instruct cmpFastLock(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eRegP scr) %{
13417   predicate(!Compile::current()-&gt;use_rtm());
13418   match(Set cr (FastLock object box));
13419   effect(TEMP tmp, TEMP scr, USE_KILL box);
13420   ins_cost(300);
13421   format %{ &quot;FASTLOCK $object,$box\t! kills $box,$tmp,$scr&quot; %}
13422   ins_encode %{
13423     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
13424                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
13425   %}
13426   ins_pipe(pipe_slow);
13427 %}
13428 
13429 instruct cmpFastUnlock(eFlagsReg cr, eRegP object, eAXRegP box, eRegP tmp ) %{
13430   match(Set cr (FastUnlock object box));
13431   effect(TEMP tmp, USE_KILL box);
13432   ins_cost(300);
13433   format %{ &quot;FASTUNLOCK $object,$box\t! kills $box,$tmp&quot; %}
13434   ins_encode %{
13435     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
13436   %}
13437   ins_pipe(pipe_slow);
13438 %}
13439 
13440 
13441 
13442 // ============================================================================
13443 // Safepoint Instruction
13444 instruct safePoint_poll(eFlagsReg cr) %{
13445   predicate(SafepointMechanism::uses_global_page_poll());
13446   match(SafePoint);
13447   effect(KILL cr);
13448 
13449   // TODO-FIXME: we currently poll at offset 0 of the safepoint polling page.
13450   // On SPARC that might be acceptable as we can generate the address with
13451   // just a sethi, saving an or.  By polling at offset 0 we can end up
13452   // putting additional pressure on the index-0 in the D$.  Because of
13453   // alignment (just like the situation at hand) the lower indices tend
13454   // to see more traffic.  It&#39;d be better to change the polling address
13455   // to offset 0 of the last $line in the polling page.
13456 
13457   format %{ &quot;TSTL   #polladdr,EAX\t! Safepoint: poll for GC&quot; %}
13458   ins_cost(125);
13459   size(6) ;
13460   ins_encode( Safepoint_Poll() );
13461   ins_pipe( ialu_reg_mem );
13462 %}
13463 
13464 instruct safePoint_poll_tls(eFlagsReg cr, eRegP_no_EBP poll) %{
13465   predicate(SafepointMechanism::uses_thread_local_poll());
13466   match(SafePoint poll);
13467   effect(KILL cr, USE poll);
13468 
13469   format %{ &quot;TSTL   #EAX,[$poll]\t! Safepoint: poll for GC&quot; %}
13470   ins_cost(125);
13471   // EBP would need size(3)
13472   size(2); /* setting an explicit size will cause debug builds to assert if size is incorrect */
13473   ins_encode %{
13474     __ relocate(relocInfo::poll_type);
13475     address pre_pc = __ pc();
13476     __ testl(rax, Address($poll$$Register, 0));
13477     address post_pc = __ pc();
13478     guarantee(pre_pc[0] == 0x85, &quot;must emit test-ax [reg]&quot;);
13479   %}
13480   ins_pipe(ialu_reg_mem);
13481 %}
13482 
13483 
13484 // ============================================================================
13485 // This name is KNOWN by the ADLC and cannot be changed.
13486 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
13487 // for this guy.
13488 instruct tlsLoadP(eRegP dst, eFlagsReg cr) %{
13489   match(Set dst (ThreadLocal));
13490   effect(DEF dst, KILL cr);
13491 
13492   format %{ &quot;MOV    $dst, Thread::current()&quot; %}
13493   ins_encode %{
13494     Register dstReg = as_Register($dst$$reg);
13495     __ get_thread(dstReg);
13496   %}
13497   ins_pipe( ialu_reg_fat );
13498 %}
13499 
13500 
13501 
13502 //----------PEEPHOLE RULES-----------------------------------------------------
13503 // These must follow all instruction definitions as they use the names
13504 // defined in the instructions definitions.
13505 //
13506 // peepmatch ( root_instr_name [preceding_instruction]* );
13507 //
13508 // peepconstraint %{
13509 // (instruction_number.operand_name relational_op instruction_number.operand_name
13510 //  [, ...] );
13511 // // instruction numbers are zero-based using left to right order in peepmatch
13512 //
13513 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
13514 // // provide an instruction_number.operand_name for each operand that appears
13515 // // in the replacement instruction&#39;s match rule
13516 //
13517 // ---------VM FLAGS---------------------------------------------------------
13518 //
13519 // All peephole optimizations can be turned off using -XX:-OptoPeephole
13520 //
13521 // Each peephole rule is given an identifying number starting with zero and
13522 // increasing by one in the order seen by the parser.  An individual peephole
13523 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
13524 // on the command-line.
13525 //
13526 // ---------CURRENT LIMITATIONS----------------------------------------------
13527 //
13528 // Only match adjacent instructions in same basic block
13529 // Only equality constraints
13530 // Only constraints between operands, not (0.dest_reg == EAX_enc)
13531 // Only one replacement instruction
13532 //
13533 // ---------EXAMPLE----------------------------------------------------------
13534 //
13535 // // pertinent parts of existing instructions in architecture description
13536 // instruct movI(rRegI dst, rRegI src) %{
13537 //   match(Set dst (CopyI src));
13538 // %}
13539 //
13540 // instruct incI_eReg(rRegI dst, immI1 src, eFlagsReg cr) %{
13541 //   match(Set dst (AddI dst src));
13542 //   effect(KILL cr);
13543 // %}
13544 //
13545 // // Change (inc mov) to lea
13546 // peephole %{
13547 //   // increment preceeded by register-register move
13548 //   peepmatch ( incI_eReg movI );
13549 //   // require that the destination register of the increment
13550 //   // match the destination register of the move
13551 //   peepconstraint ( 0.dst == 1.dst );
13552 //   // construct a replacement instruction that sets
13553 //   // the destination to ( move&#39;s source register + one )
13554 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13555 // %}
13556 //
13557 // Implementation no longer uses movX instructions since
13558 // machine-independent system no longer uses CopyX nodes.
13559 //
13560 // peephole %{
13561 //   peepmatch ( incI_eReg movI );
13562 //   peepconstraint ( 0.dst == 1.dst );
13563 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13564 // %}
13565 //
13566 // peephole %{
13567 //   peepmatch ( decI_eReg movI );
13568 //   peepconstraint ( 0.dst == 1.dst );
13569 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13570 // %}
13571 //
13572 // peephole %{
13573 //   peepmatch ( addI_eReg_imm movI );
13574 //   peepconstraint ( 0.dst == 1.dst );
13575 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13576 // %}
13577 //
13578 // peephole %{
13579 //   peepmatch ( addP_eReg_imm movP );
13580 //   peepconstraint ( 0.dst == 1.dst );
13581 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
13582 // %}
13583 
13584 // // Change load of spilled value to only a spill
13585 // instruct storeI(memory mem, rRegI src) %{
13586 //   match(Set mem (StoreI mem src));
13587 // %}
13588 //
13589 // instruct loadI(rRegI dst, memory mem) %{
13590 //   match(Set dst (LoadI mem));
13591 // %}
13592 //
13593 peephole %{
13594   peepmatch ( loadI storeI );
13595   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
13596   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
13597 %}
13598 
13599 //----------SMARTSPILL RULES---------------------------------------------------
13600 // These must follow all instruction definitions as they use the names
13601 // defined in the instructions definitions.
    </pre>
  </body>
</html>
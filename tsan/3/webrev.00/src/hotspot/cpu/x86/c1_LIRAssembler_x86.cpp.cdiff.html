<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,18 ***</span>
  #include &quot;c1/c1_MacroAssembler.hpp&quot;
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;c1/c1_ValueStack.hpp&quot;
  #include &quot;ci/ciArrayKlass.hpp&quot;
  #include &quot;ci/ciInstance.hpp&quot;
<span class="line-removed">- #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;</span>
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;nativeInst_x86.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;vmreg_x86.inline.hpp&quot;
  
  
  // These masks are used to provide 128-bit aligned bitmasks to the XMM
  // instructions, to allow sign-masking or sign-bit flipping.  They allow
<span class="line-new-header">--- 30,17 ---</span>
  #include &quot;c1/c1_MacroAssembler.hpp&quot;
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;c1/c1_ValueStack.hpp&quot;
  #include &quot;ci/ciArrayKlass.hpp&quot;
  #include &quot;ci/ciInstance.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;nativeInst_x86.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;vmreg_x86.inline.hpp&quot;
  
  
  // These masks are used to provide 128-bit aligned bitmasks to the XMM
  // instructions, to allow sign-masking or sign-bit flipping.  They allow
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,19 ***</span>
    } else {
      return const_addr;
    }
  }
  
<span class="line-modified">! </span>
<span class="line-removed">- void LIR_Assembler::set_24bit_FPU() {</span>
<span class="line-removed">-   __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::reset_FPU() {</span>
<span class="line-removed">-   __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void LIR_Assembler::fpop() {
    __ fpop();
  }
  
  void LIR_Assembler::fxch(int i) {
<span class="line-new-header">--- 157,11 ---</span>
    } else {
      return const_addr;
    }
  }
  
<span class="line-modified">! #ifndef _LP64</span>
  void LIR_Assembler::fpop() {
    __ fpop();
  }
  
  void LIR_Assembler::fxch(int i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,10 ***</span>
<span class="line-new-header">--- 173,11 ---</span>
  }
  
  void LIR_Assembler::ffree(int i) {
    __ ffree(i);
  }
<span class="line-added">+ #endif // !_LP64</span>
  
  void LIR_Assembler::breakpoint() {
    __ int3();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 357,10 ***</span>
<span class="line-new-header">--- 349,26 ---</span>
      __ align(CodeEntryAlignment);
    }
    return offset;
  }
  
<span class="line-added">+ void LIR_Assembler::clinit_barrier(ciMethod* method) {</span>
<span class="line-added">+   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);</span>
<span class="line-added">+   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Label L_skip_barrier;</span>
<span class="line-added">+   Register klass = rscratch1;</span>
<span class="line-added">+   Register thread = LP64_ONLY( r15_thread ) NOT_LP64( noreg );</span>
<span class="line-added">+   assert(thread != noreg, &quot;x86_32 not implemented&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ mov_metadata(klass, method-&gt;holder()-&gt;constant_encoding());</span>
<span class="line-added">+   __ clinit_barrier(klass, thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ bind(L_skip_barrier);</span>
<span class="line-added">+ }</span>
  
  void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
    jobject o = NULL;
    PatchingStub* patch = new PatchingStub(_masm, patching_id(info));
    __ movoop(reg, o);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 654,19 ***</span>
<span class="line-new-header">--- 662,23 ---</span>
          } else {
            __ movflt(dest-&gt;as_xmm_float_reg(),
                     InternalAddress(float_constant(c-&gt;as_jfloat())));
          }
        } else {
<span class="line-added">+ #ifndef _LP64</span>
          assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
          assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
          if (c-&gt;is_zero_float()) {
            __ fldz();
          } else if (c-&gt;is_one_float()) {
            __ fld1();
          } else {
            __ fld_s (InternalAddress(float_constant(c-&gt;as_jfloat())));
          }
<span class="line-added">+ #else</span>
<span class="line-added">+         ShouldNotReachHere();</span>
<span class="line-added">+ #endif // !_LP64</span>
        }
        break;
      }
  
      case T_DOUBLE: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 676,19 ***</span>
<span class="line-new-header">--- 688,23 ---</span>
          } else {
            __ movdbl(dest-&gt;as_xmm_double_reg(),
                      InternalAddress(double_constant(c-&gt;as_jdouble())));
          }
        } else {
<span class="line-added">+ #ifndef _LP64</span>
          assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
          assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
          if (c-&gt;is_zero_double()) {
            __ fldz();
          } else if (c-&gt;is_one_double()) {
            __ fld1();
          } else {
            __ fld_d (InternalAddress(double_constant(c-&gt;as_jdouble())));
          }
<span class="line-added">+ #else</span>
<span class="line-added">+         ShouldNotReachHere();</span>
<span class="line-added">+ #endif // !_LP64</span>
        }
        break;
      }
  
      default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 843,11 ***</span>
      }
      move_regs(src-&gt;as_register(), dest-&gt;as_register());
  
    } else if (dest-&gt;is_double_cpu()) {
  #ifdef _LP64
<span class="line-modified">!     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_ARRAY) {</span>
        // Surprising to me but we can see move of a long to t_object
        __ verify_oop(src-&gt;as_register());
        move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
        return;
      }
<span class="line-new-header">--- 859,11 ---</span>
      }
      move_regs(src-&gt;as_register(), dest-&gt;as_register());
  
    } else if (dest-&gt;is_double_cpu()) {
  #ifdef _LP64
<span class="line-modified">!     if (is_reference_type(src-&gt;type())) {</span>
        // Surprising to me but we can see move of a long to t_object
        __ verify_oop(src-&gt;as_register());
        move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
        return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 876,10 ***</span>
<span class="line-new-header">--- 892,11 ---</span>
        move_regs(f_lo, t_lo);
        move_regs(f_hi, t_hi);
      }
  #endif // LP64
  
<span class="line-added">+ #ifndef _LP64</span>
      // special moves from fpu-register to xmm-register
      // necessary for method results
    } else if (src-&gt;is_single_xmm() &amp;&amp; !dest-&gt;is_single_xmm()) {
      __ movflt(Address(rsp, 0), src-&gt;as_xmm_float_reg());
      __ fld_s(Address(rsp, 0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 890,23 ***</span>
<span class="line-new-header">--- 907,27 ---</span>
      __ fstp_s(Address(rsp, 0));
      __ movflt(dest-&gt;as_xmm_float_reg(), Address(rsp, 0));
    } else if (dest-&gt;is_double_xmm() &amp;&amp; !src-&gt;is_double_xmm()) {
      __ fstp_d(Address(rsp, 0));
      __ movdbl(dest-&gt;as_xmm_double_reg(), Address(rsp, 0));
<span class="line-added">+ #endif // !_LP64</span>
  
      // move between xmm-registers
    } else if (dest-&gt;is_single_xmm()) {
      assert(src-&gt;is_single_xmm(), &quot;must match&quot;);
      __ movflt(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_float_reg());
    } else if (dest-&gt;is_double_xmm()) {
      assert(src-&gt;is_double_xmm(), &quot;must match&quot;);
      __ movdbl(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_double_reg());
  
<span class="line-added">+ #ifndef _LP64</span>
      // move between fpu-registers (no instruction necessary because of fpu-stack)
    } else if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
      assert(src-&gt;is_single_fpu() || src-&gt;is_double_fpu(), &quot;must match&quot;);
      assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;currently should be nothing to do&quot;);
<span class="line-added">+ #endif // !_LP64</span>
<span class="line-added">+ </span>
    } else {
      ShouldNotReachHere();
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 914,14 ***</span>
    assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
    assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
  
    if (src-&gt;is_single_cpu()) {
      Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
<span class="line-modified">!     if (type == T_OBJECT || type == T_ARRAY) {</span>
        __ verify_oop(src-&gt;as_register());
        __ movptr (dst, src-&gt;as_register());
<span class="line-modified">!     } else if (type == T_METADATA) {</span>
        __ movptr (dst, src-&gt;as_register());
      } else {
        __ movl (dst, src-&gt;as_register());
      }
  
<span class="line-new-header">--- 935,14 ---</span>
    assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
    assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
  
    if (src-&gt;is_single_cpu()) {
      Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
<span class="line-modified">!     if (is_reference_type(type)) {</span>
        __ verify_oop(src-&gt;as_register());
        __ movptr (dst, src-&gt;as_register());
<span class="line-modified">!     } else if (type == T_METADATA || type == T_ADDRESS) {</span>
        __ movptr (dst, src-&gt;as_register());
      } else {
        __ movl (dst, src-&gt;as_register());
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 937,10 ***</span>
<span class="line-new-header">--- 958,11 ---</span>
  
    } else if (src-&gt;is_double_xmm()) {
      Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
      __ movdbl(dst_addr, src-&gt;as_xmm_double_reg());
  
<span class="line-added">+ #ifndef _LP64</span>
    } else if (src-&gt;is_single_fpu()) {
      assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
      Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
      if (pop_fpu_stack)     __ fstp_s (dst_addr);
      else                   __ fst_s  (dst_addr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 948,10 ***</span>
<span class="line-new-header">--- 970,11 ---</span>
    } else if (src-&gt;is_double_fpu()) {
      assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
      Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
      if (pop_fpu_stack)     __ fstp_d (dst_addr);
      else                   __ fst_d  (dst_addr);
<span class="line-added">+ #endif // !_LP64</span>
  
    } else {
      ShouldNotReachHere();
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 960,11 ***</span>
  void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
    LIR_Address* to_addr = dest-&gt;as_address_ptr();
    PatchingStub* patch = NULL;
    Register compressed_src = rscratch1;
  
<span class="line-modified">!   if (type == T_ARRAY || type == T_OBJECT) {</span>
      __ verify_oop(src-&gt;as_register());
  #ifdef _LP64
      if (UseCompressedOops &amp;&amp; !wide) {
        __ movptr(compressed_src, src-&gt;as_register());
        __ encode_heap_oop(compressed_src);
<span class="line-new-header">--- 983,11 ---</span>
  void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
    LIR_Address* to_addr = dest-&gt;as_address_ptr();
    PatchingStub* patch = NULL;
    Register compressed_src = rscratch1;
  
<span class="line-modified">!   if (is_reference_type(type)) {</span>
      __ verify_oop(src-&gt;as_register());
  #ifdef _LP64
      if (UseCompressedOops &amp;&amp; !wide) {
        __ movptr(compressed_src, src-&gt;as_register());
        __ encode_heap_oop(compressed_src);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 982,30 ***</span>
<span class="line-new-header">--- 1005,40 ---</span>
    }
  
    int null_check_here = code_offset();
    switch (type) {
      case T_FLOAT: {
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+       assert(src-&gt;is_single_xmm(), &quot;not a float&quot;);</span>
<span class="line-added">+       __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());</span>
<span class="line-added">+ #else</span>
        if (src-&gt;is_single_xmm()) {
          __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
        } else {
          assert(src-&gt;is_single_fpu(), &quot;must be&quot;);
          assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
          if (pop_fpu_stack)      __ fstp_s(as_Address(to_addr));
          else                    __ fst_s (as_Address(to_addr));
        }
<span class="line-added">+ #endif // _LP64</span>
        break;
      }
  
      case T_DOUBLE: {
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+       assert(src-&gt;is_double_xmm(), &quot;not a double&quot;);</span>
<span class="line-added">+       __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());</span>
<span class="line-added">+ #else</span>
        if (src-&gt;is_double_xmm()) {
          __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
        } else {
          assert(src-&gt;is_double_fpu(), &quot;must be&quot;);
          assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
          if (pop_fpu_stack)      __ fstp_d(as_Address(to_addr));
          else                    __ fst_d (as_Address(to_addr));
        }
<span class="line-added">+ #endif // _LP64</span>
        break;
      }
  
      case T_ARRAY:   // fall through
      case T_OBJECT:  // fall through
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1095,14 ***</span>
  void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
    assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
    assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
  
    if (dest-&gt;is_single_cpu()) {
<span class="line-modified">!     if (type == T_ARRAY || type == T_OBJECT) {</span>
        __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
        __ verify_oop(dest-&gt;as_register());
<span class="line-modified">!     } else if (type == T_METADATA) {</span>
        __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
      } else {
        __ movl(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
      }
  
<span class="line-new-header">--- 1128,14 ---</span>
  void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
    assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
    assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
  
    if (dest-&gt;is_single_cpu()) {
<span class="line-modified">!     if (is_reference_type(type)) {</span>
        __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
        __ verify_oop(dest-&gt;as_register());
<span class="line-modified">!     } else if (type == T_METADATA || type == T_ADDRESS) {</span>
        __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
      } else {
        __ movl(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1118,29 ***</span>
  
    } else if (dest-&gt;is_double_xmm()) {
      Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
      __ movdbl(dest-&gt;as_xmm_double_reg(), src_addr);
  
    } else if (dest-&gt;is_single_fpu()) {
      assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
      Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
      __ fld_s(src_addr);
  
    } else if (dest-&gt;is_double_fpu()) {
      assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
      Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
      __ fld_d(src_addr);
  
    } else {
      ShouldNotReachHere();
    }
  }
  
  
  void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
    if (src-&gt;is_single_stack()) {
<span class="line-modified">!     if (type == T_OBJECT || type == T_ARRAY) {</span>
        __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
        __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
      } else {
  #ifndef _LP64
        __ pushl(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
<span class="line-new-header">--- 1151,31 ---</span>
  
    } else if (dest-&gt;is_double_xmm()) {
      Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
      __ movdbl(dest-&gt;as_xmm_double_reg(), src_addr);
  
<span class="line-added">+ #ifndef _LP64</span>
    } else if (dest-&gt;is_single_fpu()) {
      assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
      Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
      __ fld_s(src_addr);
  
    } else if (dest-&gt;is_double_fpu()) {
      assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
      Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
      __ fld_d(src_addr);
<span class="line-added">+ #endif // _LP64</span>
  
    } else {
      ShouldNotReachHere();
    }
  }
  
  
  void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
    if (src-&gt;is_single_stack()) {
<span class="line-modified">!     if (is_reference_type(type)) {</span>
        __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
        __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
      } else {
  #ifndef _LP64
        __ pushl(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1210,24 ***</span>
<span class="line-new-header">--- 1245,32 ---</span>
    switch (type) {
      case T_FLOAT: {
        if (dest-&gt;is_single_xmm()) {
          __ movflt(dest-&gt;as_xmm_float_reg(), from_addr);
        } else {
<span class="line-added">+ #ifndef _LP64</span>
          assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
          assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
          __ fld_s(from_addr);
<span class="line-added">+ #else</span>
<span class="line-added">+         ShouldNotReachHere();</span>
<span class="line-added">+ #endif // !LP64</span>
        }
        break;
      }
  
      case T_DOUBLE: {
        if (dest-&gt;is_double_xmm()) {
          __ movdbl(dest-&gt;as_xmm_double_reg(), from_addr);
        } else {
<span class="line-added">+ #ifndef _LP64</span>
          assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
          assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
          __ fld_d(from_addr);
<span class="line-added">+ #else</span>
<span class="line-added">+         ShouldNotReachHere();</span>
<span class="line-added">+ #endif // !LP64</span>
        }
        break;
      }
  
      case T_OBJECT:  // fall through
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1337,11 ***</span>
  
    if (patch != NULL) {
      patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
    }
  
<span class="line-modified">!   if (type == T_ARRAY || type == T_OBJECT) {</span>
  #ifdef _LP64
      if (UseCompressedOops &amp;&amp; !wide) {
        __ decode_heap_oop(dest-&gt;as_register());
      }
  #endif
<span class="line-new-header">--- 1380,11 ---</span>
  
    if (patch != NULL) {
      patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
    }
  
<span class="line-modified">!   if (is_reference_type(type)) {</span>
  #ifdef _LP64
      if (UseCompressedOops &amp;&amp; !wide) {
        __ decode_heap_oop(dest-&gt;as_register());
      }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1479,10 ***</span>
<span class="line-new-header">--- 1522,51 ---</span>
        move_regs(src-&gt;as_register(), dest-&gt;as_register());
        __ sign_extend_short(dest-&gt;as_register());
        break;
  
  
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+     case Bytecodes::_f2d:</span>
<span class="line-added">+       __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ </span>
<span class="line-added">+     case Bytecodes::_d2f:</span>
<span class="line-added">+       __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ </span>
<span class="line-added">+     case Bytecodes::_i2f:</span>
<span class="line-added">+       __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ </span>
<span class="line-added">+     case Bytecodes::_i2d:</span>
<span class="line-added">+       __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ </span>
<span class="line-added">+     case Bytecodes::_l2f:</span>
<span class="line-added">+       __ cvtsi2ssq(dest-&gt;as_xmm_float_reg(), src-&gt;as_register_lo());</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ </span>
<span class="line-added">+     case Bytecodes::_l2d:</span>
<span class="line-added">+       __ cvtsi2sdq(dest-&gt;as_xmm_double_reg(), src-&gt;as_register_lo());</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ </span>
<span class="line-added">+     case Bytecodes::_f2i:</span>
<span class="line-added">+       __ convert_f2i(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ </span>
<span class="line-added">+     case Bytecodes::_d2i:</span>
<span class="line-added">+       __ convert_d2i(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ </span>
<span class="line-added">+     case Bytecodes::_f2l:</span>
<span class="line-added">+       __ convert_f2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_float_reg());</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ </span>
<span class="line-added">+     case Bytecodes::_d2l:</span>
<span class="line-added">+       __ convert_d2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ #else</span>
      case Bytecodes::_f2d:
      case Bytecodes::_d2f:
        if (dest-&gt;is_single_xmm()) {
          __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
        } else if (dest-&gt;is_double_xmm()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1504,10 ***</span>
<span class="line-new-header">--- 1588,20 ---</span>
          __ movl(Address(rsp, 0), src-&gt;as_register());
          __ fild_s(Address(rsp, 0));
        }
        break;
  
<span class="line-added">+     case Bytecodes::_l2f:</span>
<span class="line-added">+     case Bytecodes::_l2d:</span>
<span class="line-added">+       assert(!dest-&gt;is_xmm_register(), &quot;result in xmm register not supported (no SSE instruction present)&quot;);</span>
<span class="line-added">+       assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);</span>
<span class="line-added">+       __ movptr(Address(rsp, 0),          src-&gt;as_register_lo());</span>
<span class="line-added">+       __ movl(Address(rsp, BytesPerWord), src-&gt;as_register_hi());</span>
<span class="line-added">+       __ fild_d(Address(rsp, 0));</span>
<span class="line-added">+       // float result is rounded later through spilling</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ </span>
      case Bytecodes::_f2i:
      case Bytecodes::_d2i:
        if (src-&gt;is_single_xmm()) {
          __ cvttss2sil(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
        } else if (src-&gt;is_double_xmm()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1517,29 ***</span>
          __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
          __ fist_s(Address(rsp, 0));
          __ movl(dest-&gt;as_register(), Address(rsp, 0));
          __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
        }
<span class="line-removed">- </span>
        // IA32 conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
        assert(op-&gt;stub() != NULL, &quot;stub required&quot;);
        __ cmpl(dest-&gt;as_register(), 0x80000000);
        __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry());
        __ bind(*op-&gt;stub()-&gt;continuation());
        break;
  
<span class="line-removed">-     case Bytecodes::_l2f:</span>
<span class="line-removed">-     case Bytecodes::_l2d:</span>
<span class="line-removed">-       assert(!dest-&gt;is_xmm_register(), &quot;result in xmm register not supported (no SSE instruction present)&quot;);</span>
<span class="line-removed">-       assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       __ movptr(Address(rsp, 0),            src-&gt;as_register_lo());</span>
<span class="line-removed">-       NOT_LP64(__ movl(Address(rsp, BytesPerWord), src-&gt;as_register_hi()));</span>
<span class="line-removed">-       __ fild_d(Address(rsp, 0));</span>
<span class="line-removed">-       // float result is rounded later through spilling</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">- </span>
      case Bytecodes::_f2l:
      case Bytecodes::_d2l:
        assert(!src-&gt;is_xmm_register(), &quot;input in xmm register not supported (no SSE instruction present)&quot;);
        assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
        assert(dest == FrameMap::long0_opr, &quot;runtime stub places result in these registers&quot;);
<span class="line-new-header">--- 1611,17 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1547,10 ***</span>
<span class="line-new-header">--- 1629,11 ---</span>
        // instruction sequence too long to inline it here
        {
          __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::fpu2long_stub_id)));
        }
        break;
<span class="line-added">+ #endif // _LP64</span>
  
      default: ShouldNotReachHere();
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1575,12 ***</span>
  void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
    Register len =  op-&gt;len()-&gt;as_register();
    LP64_ONLY( __ movslq(len, len); )
  
    if (UseSlowPath ||
<span class="line-modified">!       (!UseFastNewObjectArray &amp;&amp; (op-&gt;type() == T_OBJECT || op-&gt;type() == T_ARRAY)) ||</span>
<span class="line-modified">!       (!UseFastNewTypeArray   &amp;&amp; (op-&gt;type() != T_OBJECT &amp;&amp; op-&gt;type() != T_ARRAY))) {</span>
      __ jmp(*op-&gt;stub()-&gt;entry());
    } else {
      Register tmp1 = op-&gt;tmp1()-&gt;as_register();
      Register tmp2 = op-&gt;tmp2()-&gt;as_register();
      Register tmp3 = op-&gt;tmp3()-&gt;as_register();
<span class="line-new-header">--- 1658,12 ---</span>
  void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
    Register len =  op-&gt;len()-&gt;as_register();
    LP64_ONLY( __ movslq(len, len); )
  
    if (UseSlowPath ||
<span class="line-modified">!       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||</span>
<span class="line-modified">!       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {</span>
      __ jmp(*op-&gt;stub()-&gt;entry());
    } else {
      Register tmp1 = op-&gt;tmp1()-&gt;as_register();
      Register tmp2 = op-&gt;tmp2()-&gt;as_register();
      Register tmp3 = op-&gt;tmp3()-&gt;as_register();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2206,10 ***</span>
<span class="line-new-header">--- 2289,11 ---</span>
          case lir_div: __ divsd(lreg, raddr);  break;
          default: ShouldNotReachHere();
        }
      }
  
<span class="line-added">+ #ifndef _LP64</span>
    } else if (left-&gt;is_single_fpu()) {
      assert(dest-&gt;is_single_fpu(),  &quot;fpu stack allocation required&quot;);
  
      if (right-&gt;is_single_fpu()) {
        arith_fpu_implementation(code, left-&gt;fpu_regnr(), right-&gt;fpu_regnr(), dest-&gt;fpu_regnr(), pop_fpu_stack);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2281,10 ***</span>
<span class="line-new-header">--- 2365,11 ---</span>
      if (code == lir_mul_strictfp || code == lir_div_strictfp) {
        // Double values require special handling for strictfp mul/div on x86
        __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
        __ fmulp(dest-&gt;fpu_regnrLo() + 1);
      }
<span class="line-added">+ #endif // !_LP64</span>
  
    } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
      assert(left == dest, &quot;left and dest must be equal&quot;);
  
      Address laddr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2323,10 ***</span>
<span class="line-new-header">--- 2408,11 ---</span>
    } else {
      ShouldNotReachHere();
    }
  }
  
<span class="line-added">+ #ifndef _LP64</span>
  void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) {
    assert(pop_fpu_stack  || (left_index     == dest_index || right_index     == dest_index), &quot;invalid LIR&quot;);
    assert(!pop_fpu_stack || (left_index - 1 == dest_index || right_index - 1 == dest_index), &quot;invalid LIR&quot;);
    assert(left_index == 0 || right_index == 0, &quot;either must be on top of stack&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2380,10 ***</span>
<span class="line-new-header">--- 2466,11 ---</span>
  
      default:
        ShouldNotReachHere();
    }
  }
<span class="line-added">+ #endif // _LP64</span>
  
  
  void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {
    if (value-&gt;is_double_xmm()) {
      switch(code) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2409,17 ***</span>
<span class="line-new-header">--- 2496,19 ---</span>
        case lir_sqrt: __ sqrtsd(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg()); break;
        // all other intrinsics are not available in the SSE instruction set, so FPU is used
        default      : ShouldNotReachHere();
      }
  
<span class="line-added">+ #ifndef _LP64</span>
    } else if (value-&gt;is_double_fpu()) {
      assert(value-&gt;fpu_regnrLo() == 0 &amp;&amp; dest-&gt;fpu_regnrLo() == 0, &quot;both must be on TOS&quot;);
      switch(code) {
        case lir_abs   : __ fabs() ; break;
        case lir_sqrt  : __ fsqrt(); break;
        default      : ShouldNotReachHere();
      }
<span class="line-added">+ #endif // !_LP64</span>
    } else {
      Unimplemented();
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2492,11 ***</span>
        }
  #endif // _LP64
      } else {
  #ifdef _LP64
        Register r_lo;
<span class="line-modified">!       if (right-&gt;type() == T_OBJECT || right-&gt;type() == T_ARRAY) {</span>
          r_lo = right-&gt;as_register();
        } else {
          r_lo = right-&gt;as_register_lo();
        }
  #else
<span class="line-new-header">--- 2581,11 ---</span>
        }
  #endif // _LP64
      } else {
  #ifdef _LP64
        Register r_lo;
<span class="line-modified">!       if (is_reference_type(right-&gt;type())) {</span>
          r_lo = right-&gt;as_register();
        } else {
          r_lo = right-&gt;as_register_lo();
        }
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2605,29 ***</span>
  void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
    if (opr1-&gt;is_single_cpu()) {
      Register reg1 = opr1-&gt;as_register();
      if (opr2-&gt;is_single_cpu()) {
        // cpu register - cpu register
<span class="line-modified">!       if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {</span>
          __ cmpoop(reg1, opr2-&gt;as_register());
        } else {
<span class="line-modified">!         assert(opr2-&gt;type() != T_OBJECT &amp;&amp; opr2-&gt;type() != T_ARRAY, &quot;cmp int, oop?&quot;);</span>
          __ cmpl(reg1, opr2-&gt;as_register());
        }
      } else if (opr2-&gt;is_stack()) {
        // cpu register - stack
<span class="line-modified">!       if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {</span>
          __ cmpoop(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
        } else {
          __ cmpl(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
        }
      } else if (opr2-&gt;is_constant()) {
        // cpu register - constant
        LIR_Const* c = opr2-&gt;as_constant_ptr();
        if (c-&gt;type() == T_INT) {
          __ cmpl(reg1, c-&gt;as_jint());
<span class="line-modified">!       } else if (c-&gt;type() == T_OBJECT || c-&gt;type() == T_ARRAY) {</span>
          // In 64bit oops are single register
          jobject o = c-&gt;as_jobject();
          if (o == NULL) {
            __ cmpptr(reg1, (int32_t)NULL_WORD);
          } else {
<span class="line-new-header">--- 2694,38 ---</span>
  void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
    if (opr1-&gt;is_single_cpu()) {
      Register reg1 = opr1-&gt;as_register();
      if (opr2-&gt;is_single_cpu()) {
        // cpu register - cpu register
<span class="line-modified">!       if (is_reference_type(opr1-&gt;type())) {</span>
          __ cmpoop(reg1, opr2-&gt;as_register());
        } else {
<span class="line-modified">!         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);</span>
          __ cmpl(reg1, opr2-&gt;as_register());
        }
      } else if (opr2-&gt;is_stack()) {
        // cpu register - stack
<span class="line-modified">!       if (is_reference_type(opr1-&gt;type())) {</span>
          __ cmpoop(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
        } else {
          __ cmpl(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
        }
      } else if (opr2-&gt;is_constant()) {
        // cpu register - constant
        LIR_Const* c = opr2-&gt;as_constant_ptr();
        if (c-&gt;type() == T_INT) {
          __ cmpl(reg1, c-&gt;as_jint());
<span class="line-modified">!       } else if (c-&gt;type() == T_METADATA) {</span>
<span class="line-added">+         // All we need for now is a comparison with NULL for equality.</span>
<span class="line-added">+         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);</span>
<span class="line-added">+         Metadata* m = c-&gt;as_metadata();</span>
<span class="line-added">+         if (m == NULL) {</span>
<span class="line-added">+           __ cmpptr(reg1, (int32_t)0);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           ShouldNotReachHere();</span>
<span class="line-added">+         }</span>
<span class="line-added">+       } else if (is_reference_type(c-&gt;type())) {</span>
          // In 64bit oops are single register
          jobject o = c-&gt;as_jobject();
          if (o == NULL) {
            __ cmpptr(reg1, (int32_t)NULL_WORD);
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2715,19 ***</span>
        __ ucomisd(reg1, as_Address(opr2-&gt;pointer()-&gt;as_address()));
      } else {
        ShouldNotReachHere();
      }
  
    } else if(opr1-&gt;is_single_fpu() || opr1-&gt;is_double_fpu()) {
      assert(opr1-&gt;is_fpu_register() &amp;&amp; opr1-&gt;fpu() == 0, &quot;currently left-hand side must be on TOS (relax this restriction)&quot;);
      assert(opr2-&gt;is_fpu_register(), &quot;both must be registers&quot;);
      __ fcmp(noreg, opr2-&gt;fpu(), op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
  
    } else if (opr1-&gt;is_address() &amp;&amp; opr2-&gt;is_constant()) {
      LIR_Const* c = opr2-&gt;as_constant_ptr();
  #ifdef _LP64
<span class="line-modified">!     if (c-&gt;type() == T_OBJECT || c-&gt;type() == T_ARRAY) {</span>
        assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;need to reverse&quot;);
        __ movoop(rscratch1, c-&gt;as_jobject());
      }
  #endif // LP64
      if (op-&gt;info() != NULL) {
<span class="line-new-header">--- 2813,21 ---</span>
        __ ucomisd(reg1, as_Address(opr2-&gt;pointer()-&gt;as_address()));
      } else {
        ShouldNotReachHere();
      }
  
<span class="line-added">+ #ifndef _LP64</span>
    } else if(opr1-&gt;is_single_fpu() || opr1-&gt;is_double_fpu()) {
      assert(opr1-&gt;is_fpu_register() &amp;&amp; opr1-&gt;fpu() == 0, &quot;currently left-hand side must be on TOS (relax this restriction)&quot;);
      assert(opr2-&gt;is_fpu_register(), &quot;both must be registers&quot;);
      __ fcmp(noreg, opr2-&gt;fpu(), op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
<span class="line-added">+ #endif // LP64</span>
  
    } else if (opr1-&gt;is_address() &amp;&amp; opr2-&gt;is_constant()) {
      LIR_Const* c = opr2-&gt;as_constant_ptr();
  #ifdef _LP64
<span class="line-modified">!     if (is_reference_type(c-&gt;type())) {</span>
        assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;need to reverse&quot;);
        __ movoop(rscratch1, c-&gt;as_jobject());
      }
  #endif // LP64
      if (op-&gt;info() != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2735,11 ***</span>
      }
      // special case: address - constant
      LIR_Address* addr = opr1-&gt;as_address_ptr();
      if (c-&gt;type() == T_INT) {
        __ cmpl(as_Address(addr), c-&gt;as_jint());
<span class="line-modified">!     } else if (c-&gt;type() == T_OBJECT || c-&gt;type() == T_ARRAY) {</span>
  #ifdef _LP64
        // %%% Make this explode if addr isn&#39;t reachable until we figure out a
        // better strategy by giving noreg as the temp for as_Address
        __ cmpoop(rscratch1, as_Address(addr, noreg));
  #else
<span class="line-new-header">--- 2835,11 ---</span>
      }
      // special case: address - constant
      LIR_Address* addr = opr1-&gt;as_address_ptr();
      if (c-&gt;type() == T_INT) {
        __ cmpl(as_Address(addr), c-&gt;as_jint());
<span class="line-modified">!     } else if (is_reference_type(c-&gt;type())) {</span>
  #ifdef _LP64
        // %%% Make this explode if addr isn&#39;t reachable until we figure out a
        // better strategy by giving noreg as the temp for as_Address
        __ cmpoop(rscratch1, as_Address(addr, noreg));
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2762,16 ***</span>
<span class="line-new-header">--- 2862,20 ---</span>
      } else if (left-&gt;is_double_xmm()) {
        assert(right-&gt;is_double_xmm(), &quot;must match&quot;);
        __ cmpsd2int(left-&gt;as_xmm_double_reg(), right-&gt;as_xmm_double_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
  
      } else {
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+       ShouldNotReachHere();</span>
<span class="line-added">+ #else</span>
        assert(left-&gt;is_single_fpu() || left-&gt;is_double_fpu(), &quot;must be&quot;);
        assert(right-&gt;is_single_fpu() || right-&gt;is_double_fpu(), &quot;must match&quot;);
  
        assert(left-&gt;fpu() == 0, &quot;left must be on TOS&quot;);
        __ fcmp2int(dst-&gt;as_register(), code == lir_ucmp_fd2i, right-&gt;fpu(),
                    op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
<span class="line-added">+ #endif // LP64</span>
      }
    } else {
      assert(code == lir_cmp_l2i, &quot;check&quot;);
  #ifdef _LP64
      Label done;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3034,11 ***</span>
    __ resolve(ACCESS_WRITE, dst);
  
    CodeStub* stub = op-&gt;stub();
    int flags = op-&gt;flags();
    BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
<span class="line-modified">!   if (basic_type == T_ARRAY) basic_type = T_OBJECT;</span>
  
    // if we don&#39;t know anything, just go through the generic arraycopy
    if (default_type == NULL) {
      // save outgoing arguments on stack in case call to System.arraycopy is needed
      // HACK ALERT. This code used to push the parameters in a hardwired fashion
<span class="line-new-header">--- 3138,11 ---</span>
    __ resolve(ACCESS_WRITE, dst);
  
    CodeStub* stub = op-&gt;stub();
    int flags = op-&gt;flags();
    BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
<span class="line-modified">!   if (is_reference_type(basic_type)) basic_type = T_OBJECT;</span>
  
    // if we don&#39;t know anything, just go through the generic arraycopy
    if (default_type == NULL) {
      // save outgoing arguments on stack in case call to System.arraycopy is needed
      // HACK ALERT. This code used to push the parameters in a hardwired fashion
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3784,14 ***</span>
<span class="line-new-header">--- 3888,16 ---</span>
          __ movdbl(dest-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg());
        }
        __ xorpd(dest-&gt;as_xmm_double_reg(),
                 ExternalAddress((address)double_signflip_pool));
      }
<span class="line-added">+ #ifndef _LP64</span>
    } else if (left-&gt;is_single_fpu() || left-&gt;is_double_fpu()) {
      assert(left-&gt;fpu() == 0, &quot;arg must be on TOS&quot;);
      assert(dest-&gt;fpu() == 0, &quot;dest must be TOS&quot;);
      __ fchs();
<span class="line-added">+ #endif // !_LP64</span>
  
    } else {
      ShouldNotReachHere();
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3857,10 ***</span>
<span class="line-new-header">--- 3963,11 ---</span>
        __ movdbl(dest-&gt;as_xmm_double_reg(), as_Address(src-&gt;as_address_ptr()));
      } else {
        ShouldNotReachHere();
      }
  
<span class="line-added">+ #ifndef _LP64</span>
    } else if (src-&gt;is_double_fpu()) {
      assert(src-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
      if (dest-&gt;is_double_stack()) {
        __ fistp_d(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
      } else if (dest-&gt;is_address()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3876,10 ***</span>
<span class="line-new-header">--- 3983,12 ---</span>
      } else if (src-&gt;is_address()) {
        __ fild_d(as_Address(src-&gt;as_address_ptr()));
      } else {
        ShouldNotReachHere();
      }
<span class="line-added">+ #endif // !_LP64</span>
<span class="line-added">+ </span>
    } else {
      ShouldNotReachHere();
    }
  }
  
</pre>
<center><a href="c1_FrameMap_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/assembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_CodeStubs_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/assembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_ASSEMBLER_X86_HPP
  26 #define CPU_X86_ASSEMBLER_X86_HPP
  27 
  28 #include &quot;asm/register.hpp&quot;
<span class="line-modified">  29 #include &quot;vm_version_x86.hpp&quot;</span>

  30 
  31 class BiasedLockingCounters;
  32 
  33 // Contains all the definitions needed for x86 assembly code generation.
  34 
  35 // Calling convention
  36 class Argument {
  37  public:
  38   enum {
  39 #ifdef _LP64
  40 #ifdef _WIN64
  41     n_int_register_parameters_c   = 4, // rcx, rdx, r8, r9 (c_rarg0, c_rarg1, ...)
  42     n_float_register_parameters_c = 4,  // xmm0 - xmm3 (c_farg0, c_farg1, ... )
  43 #else
  44     n_int_register_parameters_c   = 6, // rdi, rsi, rdx, rcx, r8, r9 (c_rarg0, c_rarg1, ...)
  45     n_float_register_parameters_c = 8,  // xmm0 - xmm7 (c_farg0, c_farg1, ... )
  46 #endif // _WIN64
  47     n_int_register_parameters_j   = 6, // j_rarg0, j_rarg1, ...
  48     n_float_register_parameters_j = 8  // j_farg0, j_farg1, ...
  49 #else
</pre>
<hr />
<pre>
 613     call32_operand = 2,          // embedded 32-bit self-relative displacement
 614 #ifndef _LP64
 615     _WhichOperand_limit = 3
 616 #else
 617      narrow_oop_operand = 3,     // embedded 32-bit immediate narrow oop
 618     _WhichOperand_limit = 4
 619 #endif
 620   };
 621 
 622   enum ComparisonPredicate {
 623     eq = 0,
 624     lt = 1,
 625     le = 2,
 626     _false = 3,
 627     neq = 4,
 628     nlt = 5,
 629     nle = 6,
 630     _true = 7
 631   };
 632 











 633 
 634   // NOTE: The general philopsophy of the declarations here is that 64bit versions
 635   // of instructions are freely declared without the need for wrapping them an ifdef.
 636   // (Some dangerous instructions are ifdef&#39;s out of inappropriate jvm&#39;s.)
 637   // In the .cpp file the implementations are wrapped so that they are dropped out
 638   // of the resulting jvm. This is done mostly to keep the footprint of MINIMAL
 639   // to the size it was prior to merging up the 32bit and 64bit assemblers.
 640   //
 641   // This does mean you&#39;ll get a linker/runtime error if you use a 64bit only instruction
 642   // in a 32bit vm. This is somewhat unfortunate but keeps the ifdef noise down.
 643 
 644 private:
 645 
 646   bool _legacy_mode_bw;
 647   bool _legacy_mode_dq;
 648   bool _legacy_mode_vl;
 649   bool _legacy_mode_vlbw;
 650   bool _is_managed;
 651   bool _vector_masking;    // For stub code use only
 652 
</pre>
<hr />
<pre>
 940   void addr_nop_7();
 941   void addr_nop_8();
 942 
 943   // Add Scalar Double-Precision Floating-Point Values
 944   void addsd(XMMRegister dst, Address src);
 945   void addsd(XMMRegister dst, XMMRegister src);
 946 
 947   // Add Scalar Single-Precision Floating-Point Values
 948   void addss(XMMRegister dst, Address src);
 949   void addss(XMMRegister dst, XMMRegister src);
 950 
 951   // AES instructions
 952   void aesdec(XMMRegister dst, Address src);
 953   void aesdec(XMMRegister dst, XMMRegister src);
 954   void aesdeclast(XMMRegister dst, Address src);
 955   void aesdeclast(XMMRegister dst, XMMRegister src);
 956   void aesenc(XMMRegister dst, Address src);
 957   void aesenc(XMMRegister dst, XMMRegister src);
 958   void aesenclast(XMMRegister dst, Address src);
 959   void aesenclast(XMMRegister dst, XMMRegister src);



 960   void vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
 961   void vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
 962 
 963   void andl(Address  dst, int32_t imm32);
 964   void andl(Register dst, int32_t imm32);
 965   void andl(Register dst, Address src);
 966   void andl(Register dst, Register src);
 967 
 968   void andq(Address  dst, int32_t imm32);
 969   void andq(Register dst, int32_t imm32);
 970   void andq(Register dst, Address src);
 971   void andq(Register dst, Register src);
 972 
 973   // BMI instructions
 974   void andnl(Register dst, Register src1, Register src2);
 975   void andnl(Register dst, Register src1, Address src2);
 976   void andnq(Register dst, Register src1, Register src2);
 977   void andnq(Register dst, Register src1, Address src2);
 978 
 979   void blsil(Register dst, Register src);
</pre>
<hr />
<pre>
 997 #ifdef _LP64
 998   void bsfq(Register dst, Register src);
 999   void bsrq(Register dst, Register src);
1000 #endif
1001 
1002   void bswapl(Register reg);
1003 
1004   void bswapq(Register reg);
1005 
1006   void call(Label&amp; L, relocInfo::relocType rtype);
1007   void call(Register reg);  // push pc; pc &lt;- reg
1008   void call(Address adr);   // push pc; pc &lt;- adr
1009 
1010   void cdql();
1011 
1012   void cdqq();
1013 
1014   void cld();
1015 
1016   void clflush(Address adr);


1017 
1018   void cmovl(Condition cc, Register dst, Register src);
1019   void cmovl(Condition cc, Register dst, Address src);
1020 
1021   void cmovq(Condition cc, Register dst, Register src);
1022   void cmovq(Condition cc, Register dst, Address src);
1023 
1024 
1025   void cmpb(Address dst, int imm8);
1026 
1027   void cmpl(Address dst, int32_t imm32);
1028 
1029   void cmpl(Register dst, int32_t imm32);
1030   void cmpl(Register dst, Register src);
1031   void cmpl(Register dst, Address src);
1032 
1033   void cmpq(Address dst, int32_t imm32);
1034   void cmpq(Address dst, Register src);
1035 
1036   void cmpq(Register dst, int32_t imm32);
</pre>
<hr />
<pre>
1077 
1078   // Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value
1079   void cvtsi2ssl(XMMRegister dst, Register src);
1080   void cvtsi2ssl(XMMRegister dst, Address src);
1081   void cvtsi2ssq(XMMRegister dst, Register src);
1082   void cvtsi2ssq(XMMRegister dst, Address src);
1083 
1084   // Convert Packed Signed Doubleword Integers to Packed Double-Precision Floating-Point Value
1085   void cvtdq2pd(XMMRegister dst, XMMRegister src);
1086 
1087   // Convert Packed Signed Doubleword Integers to Packed Single-Precision Floating-Point Value
1088   void cvtdq2ps(XMMRegister dst, XMMRegister src);
1089 
1090   // Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value
1091   void cvtss2sd(XMMRegister dst, XMMRegister src);
1092   void cvtss2sd(XMMRegister dst, Address src);
1093 
1094   // Convert with Truncation Scalar Double-Precision Floating-Point Value to Doubleword Integer
1095   void cvttsd2sil(Register dst, Address src);
1096   void cvttsd2sil(Register dst, XMMRegister src);

1097   void cvttsd2siq(Register dst, XMMRegister src);
1098 
1099   // Convert with Truncation Scalar Single-Precision Floating-Point Value to Doubleword Integer
1100   void cvttss2sil(Register dst, XMMRegister src);
1101   void cvttss2siq(Register dst, XMMRegister src);
1102 
1103   void cvttpd2dq(XMMRegister dst, XMMRegister src);
1104 









1105   // Divide Scalar Double-Precision Floating-Point Values
1106   void divsd(XMMRegister dst, Address src);
1107   void divsd(XMMRegister dst, XMMRegister src);
1108 
1109   // Divide Scalar Single-Precision Floating-Point Values
1110   void divss(XMMRegister dst, Address src);
1111   void divss(XMMRegister dst, XMMRegister src);
1112 
1113   void emms();
1114 

1115   void fabs();
1116 
1117   void fadd(int i);
1118 
1119   void fadd_d(Address src);
1120   void fadd_s(Address src);
1121 
1122   // &quot;Alternate&quot; versions of x87 instructions place result down in FPU
1123   // stack instead of on TOS
1124 
1125   void fadda(int i); // &quot;alternate&quot; fadd
1126   void faddp(int i = 1);
1127 
1128   void fchs();
1129 
1130   void fcom(int i);
1131 
1132   void fcomp(int i = 1);
1133   void fcomp_d(Address src);
1134   void fcomp_s(Address src);
</pre>
<hr />
<pre>
1228 
1229   void fsubr(int i);
1230   void fsubr_d(Address src);
1231   void fsubr_s(Address src);
1232 
1233   void fsubra(int i); // &quot;alternate&quot; reversed fsub
1234 
1235   void fsubrp(int i = 1);
1236 
1237   void ftan();
1238 
1239   void ftst();
1240 
1241   void fucomi(int i = 1);
1242   void fucomip(int i = 1);
1243 
1244   void fwait();
1245 
1246   void fxch(int i = 1);
1247 






1248   void fxrstor(Address src);
1249   void xrstor(Address src);
1250 
1251   void fxsave(Address dst);
1252   void xsave(Address dst);
1253 
<span class="line-removed">1254   void fyl2x();</span>
<span class="line-removed">1255   void frndint();</span>
<span class="line-removed">1256   void f2xm1();</span>
<span class="line-removed">1257   void fldl2e();</span>
<span class="line-removed">1258 </span>
1259   void hlt();
1260 
1261   void idivl(Register src);
1262   void divl(Register src); // Unsigned division
1263 
1264 #ifdef _LP64
1265   void idivq(Register src);
1266 #endif
1267 
1268   void imull(Register src);
1269   void imull(Register dst, Register src);
1270   void imull(Register dst, Register src, int value);
1271   void imull(Register dst, Address src);
1272 
1273 #ifdef _LP64
1274   void imulq(Register dst, Register src);
1275   void imulq(Register dst, Register src, int value);
1276   void imulq(Register dst, Address src);
1277 #endif
1278 
</pre>
<hr />
<pre>
1364       // cache line, as this will also avoid possible second-order effects
1365       // with locked ops against the cache line. Our choice of offset
1366       // is bounded by x86 operand encoding, which should stay within
1367       // [-128; +127] to have the 8-byte displacement encoding.
1368       //
1369       // Any change to this code may need to revisit other places in
1370       // the code where this idiom is used, in particular the
1371       // orderAccess code.
1372 
1373       int offset = -VM_Version::L1_line_size();
1374       if (offset &lt; -128) {
1375         offset = -128;
1376       }
1377 
1378       lock();
1379       addl(Address(rsp, offset), 0);// Assert the lock# signal here
1380     }
1381   }
1382 
1383   void mfence();

1384 
1385   // Moves
1386 
1387   void mov64(Register dst, int64_t imm64);
1388 
1389   void movb(Address dst, Register src);
1390   void movb(Address dst, int imm8);
1391   void movb(Register dst, Address src);
1392 
1393   void movddup(XMMRegister dst, XMMRegister src);
1394 
1395   void kmovbl(KRegister dst, Register src);
1396   void kmovbl(Register dst, KRegister src);
1397   void kmovwl(KRegister dst, Register src);
1398   void kmovwl(KRegister dst, Address src);
1399   void kmovwl(Register dst, KRegister src);
1400   void kmovdl(KRegister dst, Register src);
1401   void kmovdl(Register dst, KRegister src);
1402   void kmovql(KRegister dst, KRegister src);
1403   void kmovql(Address dst, KRegister src);
</pre>
<hr />
<pre>
1549   // Multiply Scalar Double-Precision Floating-Point Values
1550   void mulsd(XMMRegister dst, Address src);
1551   void mulsd(XMMRegister dst, XMMRegister src);
1552 
1553   // Multiply Scalar Single-Precision Floating-Point Values
1554   void mulss(XMMRegister dst, Address src);
1555   void mulss(XMMRegister dst, XMMRegister src);
1556 
1557   void negl(Register dst);
1558 
1559 #ifdef _LP64
1560   void negq(Register dst);
1561 #endif
1562 
1563   void nop(int i = 1);
1564 
1565   void notl(Register dst);
1566 
1567 #ifdef _LP64
1568   void notq(Register dst);



1569 #endif
1570 
1571   void orl(Address dst, int32_t imm32);
1572   void orl(Register dst, int32_t imm32);
1573   void orl(Register dst, Address src);
1574   void orl(Register dst, Register src);
1575   void orl(Address dst, Register src);
1576 
1577   void orb(Address dst, int imm8);
1578 
1579   void orq(Address dst, int32_t imm32);
1580   void orq(Register dst, int32_t imm32);
1581   void orq(Register dst, Address src);
1582   void orq(Register dst, Register src);
1583 
1584   // Pack with unsigned saturation
1585   void packuswb(XMMRegister dst, XMMRegister src);
1586   void packuswb(XMMRegister dst, Address src);
1587   void vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1588 
1589   // Pemutation of 64bit words
1590   void vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len);
1591   void vpermq(XMMRegister dst, XMMRegister src, int imm8);

1592   void vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8);
1593   void vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8);
1594   void evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1595 
1596   void pause();
1597 
1598   // Undefined Instruction
1599   void ud2();
1600 
1601   // SSE4.2 string instructions
1602   void pcmpestri(XMMRegister xmm1, XMMRegister xmm2, int imm8);
1603   void pcmpestri(XMMRegister xmm1, Address src, int imm8);
1604 
1605   void pcmpeqb(XMMRegister dst, XMMRegister src);
1606   void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1607   void evpcmpeqb(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1608   void evpcmpeqb(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1609   void evpcmpeqb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len);
1610 
1611   void evpcmpgtb(KRegister kdst, XMMRegister nds, Address src, int vector_len);
</pre>
<hr />
<pre>
1651   void pinsrb(XMMRegister dst, Address src, int imm8);
1652   // SSE 2 insert
1653   void pinsrw(XMMRegister dst, Register src, int imm8);
1654   void pinsrw(XMMRegister dst, Address src, int imm8);
1655 
1656   // SSE4.1 packed move
1657   void pmovzxbw(XMMRegister dst, XMMRegister src);
1658   void pmovzxbw(XMMRegister dst, Address src);
1659 
1660   void vpmovzxbw( XMMRegister dst, Address src, int vector_len);
1661   void vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len);
1662   void evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len);
1663 
1664   void evpmovwb(Address dst, XMMRegister src, int vector_len);
1665   void evpmovwb(Address dst, KRegister mask, XMMRegister src, int vector_len);
1666 
1667   void vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len);
1668 
1669   void evpmovdb(Address dst, XMMRegister src, int vector_len);
1670 




1671   // Multiply add
1672   void pmaddwd(XMMRegister dst, XMMRegister src);
1673   void vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1674   // Multiply add accumulate
1675   void evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1676 
1677 #ifndef _LP64 // no 32bit push/pop on amd64
1678   void popl(Address dst);
1679 #endif
1680 
1681 #ifdef _LP64
1682   void popq(Address dst);
1683 #endif
1684 
1685   void popcntl(Register dst, Address src);
1686   void popcntl(Register dst, Register src);
1687 
1688   void vpopcntd(XMMRegister dst, XMMRegister src, int vector_len);
1689 
1690 #ifdef _LP64
</pre>
<hr />
<pre>
1787 
1788   void setb(Condition cc, Register dst);
1789 
1790   void palignr(XMMRegister dst, XMMRegister src, int imm8);
1791   void vpalignr(XMMRegister dst, XMMRegister src1, XMMRegister src2, int imm8, int vector_len);
1792   void evalignq(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
1793 
1794   void pblendw(XMMRegister dst, XMMRegister src, int imm8);
1795 
1796   void sha1rnds4(XMMRegister dst, XMMRegister src, int imm8);
1797   void sha1nexte(XMMRegister dst, XMMRegister src);
1798   void sha1msg1(XMMRegister dst, XMMRegister src);
1799   void sha1msg2(XMMRegister dst, XMMRegister src);
1800   // xmm0 is implicit additional source to the following instruction.
1801   void sha256rnds2(XMMRegister dst, XMMRegister src);
1802   void sha256msg1(XMMRegister dst, XMMRegister src);
1803   void sha256msg2(XMMRegister dst, XMMRegister src);
1804 
1805   void shldl(Register dst, Register src);
1806   void shldl(Register dst, Register src, int8_t imm8);


1807 
1808   void shll(Register dst, int imm8);
1809   void shll(Register dst);
1810 
1811   void shlq(Register dst, int imm8);
1812   void shlq(Register dst);
1813 
<span class="line-removed">1814   void shrdl(Register dst, Register src);</span>
<span class="line-removed">1815 </span>
1816   void shrl(Register dst, int imm8);
1817   void shrl(Register dst);
1818 
1819   void shrq(Register dst, int imm8);
1820   void shrq(Register dst);
1821 
1822   void smovl(); // QQQ generic?
1823 
1824   // Compute Square Root of Scalar Double-Precision Floating-Point Value
1825   void sqrtsd(XMMRegister dst, Address src);
1826   void sqrtsd(XMMRegister dst, XMMRegister src);
1827 



1828   // Compute Square Root of Scalar Single-Precision Floating-Point Value
1829   void sqrtss(XMMRegister dst, Address src);
1830   void sqrtss(XMMRegister dst, XMMRegister src);
1831 
1832   void std();
1833 
1834   void stmxcsr( Address dst );
1835 
1836   void subl(Address dst, int32_t imm32);
1837   void subl(Address dst, Register src);
1838   void subl(Register dst, int32_t imm32);
1839   void subl(Register dst, Address src);
1840   void subl(Register dst, Register src);
1841 
1842   void subq(Address dst, int32_t imm32);
1843   void subq(Address dst, Register src);
1844   void subq(Register dst, int32_t imm32);
1845   void subq(Register dst, Address src);
1846   void subq(Register dst, Register src);
1847 
</pre>
<hr />
<pre>
1972 
1973   void vfmadd231pd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1974   void vfmadd231ps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1975   void vfmadd231pd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1976   void vfmadd231ps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1977 
1978   // Divide Packed Floating-Point Values
1979   void divpd(XMMRegister dst, XMMRegister src);
1980   void divps(XMMRegister dst, XMMRegister src);
1981   void vdivpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1982   void vdivps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1983   void vdivpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1984   void vdivps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1985 
1986   // Sqrt Packed Floating-Point Values
1987   void vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len);
1988   void vsqrtpd(XMMRegister dst, Address src, int vector_len);
1989   void vsqrtps(XMMRegister dst, XMMRegister src, int vector_len);
1990   void vsqrtps(XMMRegister dst, Address src, int vector_len);
1991 






1992   // Bitwise Logical AND of Packed Floating-Point Values
1993   void andpd(XMMRegister dst, XMMRegister src);
1994   void andps(XMMRegister dst, XMMRegister src);
1995   void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1996   void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1997   void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1998   void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1999 
2000   void unpckhpd(XMMRegister dst, XMMRegister src);
2001   void unpcklpd(XMMRegister dst, XMMRegister src);
2002 
2003   // Bitwise Logical XOR of Packed Floating-Point Values
2004   void xorpd(XMMRegister dst, XMMRegister src);
2005   void xorps(XMMRegister dst, XMMRegister src);
2006   void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2007   void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2008   void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2009   void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2010 
2011   // Add horizontal packed integers
</pre>
<hr />
<pre>
2077   void psrlq(XMMRegister dst, XMMRegister shift);
2078   void vpsrlw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2079   void vpsrld(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2080   void vpsrlq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2081   void vpsrlw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2082   void vpsrld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2083   void vpsrlq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2084   void vpsrldq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2085   void evpsrlvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2086   void evpsllvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2087 
2088   // Arithmetic shift right packed integers (only shorts and ints, no instructions for longs)
2089   void psraw(XMMRegister dst, int shift);
2090   void psrad(XMMRegister dst, int shift);
2091   void psraw(XMMRegister dst, XMMRegister shift);
2092   void psrad(XMMRegister dst, XMMRegister shift);
2093   void vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2094   void vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2095   void vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2096   void vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);





2097 
2098   // And packed integers
2099   void pand(XMMRegister dst, XMMRegister src);
2100   void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2101   void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2102   void vpandq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2103 
2104   // Andn packed integers
2105   void pandn(XMMRegister dst, XMMRegister src);
2106   void vpandn(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2107 
2108   // Or packed integers
2109   void por(XMMRegister dst, XMMRegister src);
2110   void vpor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2111   void vpor(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2112   void vporq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2113 
2114   // Xor packed integers
2115   void pxor(XMMRegister dst, XMMRegister src);
2116   void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
</pre>
<hr />
<pre>
2149   void vextractf32x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2150   void vextractf32x4(Address dst, XMMRegister src, uint8_t imm8);
2151   void vextractf64x2(XMMRegister dst, XMMRegister src, uint8_t imm8);
2152   void vextractf64x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2153   void vextractf64x4(Address dst, XMMRegister src, uint8_t imm8);
2154 
2155   // xmm/mem sourced byte/word/dword/qword replicate
2156   void vpbroadcastb(XMMRegister dst, XMMRegister src, int vector_len);
2157   void vpbroadcastb(XMMRegister dst, Address src, int vector_len);
2158   void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
2159   void vpbroadcastw(XMMRegister dst, Address src, int vector_len);
2160   void vpbroadcastd(XMMRegister dst, XMMRegister src, int vector_len);
2161   void vpbroadcastd(XMMRegister dst, Address src, int vector_len);
2162   void vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len);
2163   void vpbroadcastq(XMMRegister dst, Address src, int vector_len);
2164 
2165   void evbroadcasti64x2(XMMRegister dst, XMMRegister src, int vector_len);
2166   void evbroadcasti64x2(XMMRegister dst, Address src, int vector_len);
2167 
2168   // scalar single/double precision replicate
<span class="line-modified">2169   void vpbroadcastss(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="line-modified">2170   void vpbroadcastss(XMMRegister dst, Address src, int vector_len);</span>
<span class="line-modified">2171   void vpbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="line-modified">2172   void vpbroadcastsd(XMMRegister dst, Address src, int vector_len);</span>
2173 
2174   // gpr sourced byte/word/dword/qword replicate
2175   void evpbroadcastb(XMMRegister dst, Register src, int vector_len);
2176   void evpbroadcastw(XMMRegister dst, Register src, int vector_len);
2177   void evpbroadcastd(XMMRegister dst, Register src, int vector_len);
2178   void evpbroadcastq(XMMRegister dst, Register src, int vector_len);
2179 
2180   void evpgatherdd(XMMRegister dst, KRegister k1, Address src, int vector_len);
2181 
2182   // Carry-Less Multiplication Quadword
2183   void pclmulqdq(XMMRegister dst, XMMRegister src, int mask);
2184   void vpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask);
2185   void evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len);
2186   // AVX instruction which is used to clear upper 128 bits of YMM registers and
2187   // to avoid transaction penalty between AVX and SSE states. There is no
2188   // penalty if legacy SSE instructions are encoded using VEX prefix because
2189   // they always clear upper 128 bits. It should be used before calling
2190   // runtime code and native libraries.
2191   void vzeroupper();
2192 
</pre>
</td>
<td>
<hr />
<pre>
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_ASSEMBLER_X86_HPP
  26 #define CPU_X86_ASSEMBLER_X86_HPP
  27 
  28 #include &quot;asm/register.hpp&quot;
<span class="line-modified">  29 #include &quot;runtime/vm_version.hpp&quot;</span>
<span class="line-added">  30 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  31 
  32 class BiasedLockingCounters;
  33 
  34 // Contains all the definitions needed for x86 assembly code generation.
  35 
  36 // Calling convention
  37 class Argument {
  38  public:
  39   enum {
  40 #ifdef _LP64
  41 #ifdef _WIN64
  42     n_int_register_parameters_c   = 4, // rcx, rdx, r8, r9 (c_rarg0, c_rarg1, ...)
  43     n_float_register_parameters_c = 4,  // xmm0 - xmm3 (c_farg0, c_farg1, ... )
  44 #else
  45     n_int_register_parameters_c   = 6, // rdi, rsi, rdx, rcx, r8, r9 (c_rarg0, c_rarg1, ...)
  46     n_float_register_parameters_c = 8,  // xmm0 - xmm7 (c_farg0, c_farg1, ... )
  47 #endif // _WIN64
  48     n_int_register_parameters_j   = 6, // j_rarg0, j_rarg1, ...
  49     n_float_register_parameters_j = 8  // j_farg0, j_farg1, ...
  50 #else
</pre>
<hr />
<pre>
 614     call32_operand = 2,          // embedded 32-bit self-relative displacement
 615 #ifndef _LP64
 616     _WhichOperand_limit = 3
 617 #else
 618      narrow_oop_operand = 3,     // embedded 32-bit immediate narrow oop
 619     _WhichOperand_limit = 4
 620 #endif
 621   };
 622 
 623   enum ComparisonPredicate {
 624     eq = 0,
 625     lt = 1,
 626     le = 2,
 627     _false = 3,
 628     neq = 4,
 629     nlt = 5,
 630     nle = 6,
 631     _true = 7
 632   };
 633 
<span class="line-added"> 634   //---&lt;  calculate length of instruction  &gt;---</span>
<span class="line-added"> 635   // As instruction size can&#39;t be found out easily on x86/x64,</span>
<span class="line-added"> 636   // we just use &#39;4&#39; for len and maxlen.</span>
<span class="line-added"> 637   // instruction must start at passed address</span>
<span class="line-added"> 638   static unsigned int instr_len(unsigned char *instr) { return 4; }</span>
<span class="line-added"> 639 </span>
<span class="line-added"> 640   //---&lt;  longest instructions  &gt;---</span>
<span class="line-added"> 641   // Max instruction length is not specified in architecture documentation.</span>
<span class="line-added"> 642   // We could use a &quot;safe enough&quot; estimate (15), but just default to</span>
<span class="line-added"> 643   // instruction length guess from above.</span>
<span class="line-added"> 644   static unsigned int instr_maxlen() { return 4; }</span>
 645 
 646   // NOTE: The general philopsophy of the declarations here is that 64bit versions
 647   // of instructions are freely declared without the need for wrapping them an ifdef.
 648   // (Some dangerous instructions are ifdef&#39;s out of inappropriate jvm&#39;s.)
 649   // In the .cpp file the implementations are wrapped so that they are dropped out
 650   // of the resulting jvm. This is done mostly to keep the footprint of MINIMAL
 651   // to the size it was prior to merging up the 32bit and 64bit assemblers.
 652   //
 653   // This does mean you&#39;ll get a linker/runtime error if you use a 64bit only instruction
 654   // in a 32bit vm. This is somewhat unfortunate but keeps the ifdef noise down.
 655 
 656 private:
 657 
 658   bool _legacy_mode_bw;
 659   bool _legacy_mode_dq;
 660   bool _legacy_mode_vl;
 661   bool _legacy_mode_vlbw;
 662   bool _is_managed;
 663   bool _vector_masking;    // For stub code use only
 664 
</pre>
<hr />
<pre>
 952   void addr_nop_7();
 953   void addr_nop_8();
 954 
 955   // Add Scalar Double-Precision Floating-Point Values
 956   void addsd(XMMRegister dst, Address src);
 957   void addsd(XMMRegister dst, XMMRegister src);
 958 
 959   // Add Scalar Single-Precision Floating-Point Values
 960   void addss(XMMRegister dst, Address src);
 961   void addss(XMMRegister dst, XMMRegister src);
 962 
 963   // AES instructions
 964   void aesdec(XMMRegister dst, Address src);
 965   void aesdec(XMMRegister dst, XMMRegister src);
 966   void aesdeclast(XMMRegister dst, Address src);
 967   void aesdeclast(XMMRegister dst, XMMRegister src);
 968   void aesenc(XMMRegister dst, Address src);
 969   void aesenc(XMMRegister dst, XMMRegister src);
 970   void aesenclast(XMMRegister dst, Address src);
 971   void aesenclast(XMMRegister dst, XMMRegister src);
<span class="line-added"> 972   // Vector AES instructions</span>
<span class="line-added"> 973   void vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);</span>
<span class="line-added"> 974   void vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);</span>
 975   void vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
 976   void vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
 977 
 978   void andl(Address  dst, int32_t imm32);
 979   void andl(Register dst, int32_t imm32);
 980   void andl(Register dst, Address src);
 981   void andl(Register dst, Register src);
 982 
 983   void andq(Address  dst, int32_t imm32);
 984   void andq(Register dst, int32_t imm32);
 985   void andq(Register dst, Address src);
 986   void andq(Register dst, Register src);
 987 
 988   // BMI instructions
 989   void andnl(Register dst, Register src1, Register src2);
 990   void andnl(Register dst, Register src1, Address src2);
 991   void andnq(Register dst, Register src1, Register src2);
 992   void andnq(Register dst, Register src1, Address src2);
 993 
 994   void blsil(Register dst, Register src);
</pre>
<hr />
<pre>
1012 #ifdef _LP64
1013   void bsfq(Register dst, Register src);
1014   void bsrq(Register dst, Register src);
1015 #endif
1016 
1017   void bswapl(Register reg);
1018 
1019   void bswapq(Register reg);
1020 
1021   void call(Label&amp; L, relocInfo::relocType rtype);
1022   void call(Register reg);  // push pc; pc &lt;- reg
1023   void call(Address adr);   // push pc; pc &lt;- adr
1024 
1025   void cdql();
1026 
1027   void cdqq();
1028 
1029   void cld();
1030 
1031   void clflush(Address adr);
<span class="line-added">1032   void clflushopt(Address adr);</span>
<span class="line-added">1033   void clwb(Address adr);</span>
1034 
1035   void cmovl(Condition cc, Register dst, Register src);
1036   void cmovl(Condition cc, Register dst, Address src);
1037 
1038   void cmovq(Condition cc, Register dst, Register src);
1039   void cmovq(Condition cc, Register dst, Address src);
1040 
1041 
1042   void cmpb(Address dst, int imm8);
1043 
1044   void cmpl(Address dst, int32_t imm32);
1045 
1046   void cmpl(Register dst, int32_t imm32);
1047   void cmpl(Register dst, Register src);
1048   void cmpl(Register dst, Address src);
1049 
1050   void cmpq(Address dst, int32_t imm32);
1051   void cmpq(Address dst, Register src);
1052 
1053   void cmpq(Register dst, int32_t imm32);
</pre>
<hr />
<pre>
1094 
1095   // Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value
1096   void cvtsi2ssl(XMMRegister dst, Register src);
1097   void cvtsi2ssl(XMMRegister dst, Address src);
1098   void cvtsi2ssq(XMMRegister dst, Register src);
1099   void cvtsi2ssq(XMMRegister dst, Address src);
1100 
1101   // Convert Packed Signed Doubleword Integers to Packed Double-Precision Floating-Point Value
1102   void cvtdq2pd(XMMRegister dst, XMMRegister src);
1103 
1104   // Convert Packed Signed Doubleword Integers to Packed Single-Precision Floating-Point Value
1105   void cvtdq2ps(XMMRegister dst, XMMRegister src);
1106 
1107   // Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value
1108   void cvtss2sd(XMMRegister dst, XMMRegister src);
1109   void cvtss2sd(XMMRegister dst, Address src);
1110 
1111   // Convert with Truncation Scalar Double-Precision Floating-Point Value to Doubleword Integer
1112   void cvttsd2sil(Register dst, Address src);
1113   void cvttsd2sil(Register dst, XMMRegister src);
<span class="line-added">1114   void cvttsd2siq(Register dst, Address src);</span>
1115   void cvttsd2siq(Register dst, XMMRegister src);
1116 
1117   // Convert with Truncation Scalar Single-Precision Floating-Point Value to Doubleword Integer
1118   void cvttss2sil(Register dst, XMMRegister src);
1119   void cvttss2siq(Register dst, XMMRegister src);
1120 
1121   void cvttpd2dq(XMMRegister dst, XMMRegister src);
1122 
<span class="line-added">1123   //Abs of packed Integer values</span>
<span class="line-added">1124   void pabsb(XMMRegister dst, XMMRegister src);</span>
<span class="line-added">1125   void pabsw(XMMRegister dst, XMMRegister src);</span>
<span class="line-added">1126   void pabsd(XMMRegister dst, XMMRegister src);</span>
<span class="line-added">1127   void vpabsb(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="line-added">1128   void vpabsw(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="line-added">1129   void vpabsd(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="line-added">1130   void evpabsq(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="line-added">1131 </span>
1132   // Divide Scalar Double-Precision Floating-Point Values
1133   void divsd(XMMRegister dst, Address src);
1134   void divsd(XMMRegister dst, XMMRegister src);
1135 
1136   // Divide Scalar Single-Precision Floating-Point Values
1137   void divss(XMMRegister dst, Address src);
1138   void divss(XMMRegister dst, XMMRegister src);
1139 
1140   void emms();
1141 
<span class="line-added">1142 #ifndef _LP64</span>
1143   void fabs();
1144 
1145   void fadd(int i);
1146 
1147   void fadd_d(Address src);
1148   void fadd_s(Address src);
1149 
1150   // &quot;Alternate&quot; versions of x87 instructions place result down in FPU
1151   // stack instead of on TOS
1152 
1153   void fadda(int i); // &quot;alternate&quot; fadd
1154   void faddp(int i = 1);
1155 
1156   void fchs();
1157 
1158   void fcom(int i);
1159 
1160   void fcomp(int i = 1);
1161   void fcomp_d(Address src);
1162   void fcomp_s(Address src);
</pre>
<hr />
<pre>
1256 
1257   void fsubr(int i);
1258   void fsubr_d(Address src);
1259   void fsubr_s(Address src);
1260 
1261   void fsubra(int i); // &quot;alternate&quot; reversed fsub
1262 
1263   void fsubrp(int i = 1);
1264 
1265   void ftan();
1266 
1267   void ftst();
1268 
1269   void fucomi(int i = 1);
1270   void fucomip(int i = 1);
1271 
1272   void fwait();
1273 
1274   void fxch(int i = 1);
1275 
<span class="line-added">1276   void fyl2x();</span>
<span class="line-added">1277   void frndint();</span>
<span class="line-added">1278   void f2xm1();</span>
<span class="line-added">1279   void fldl2e();</span>
<span class="line-added">1280 #endif // !_LP64</span>
<span class="line-added">1281 </span>
1282   void fxrstor(Address src);
1283   void xrstor(Address src);
1284 
1285   void fxsave(Address dst);
1286   void xsave(Address dst);
1287 





1288   void hlt();
1289 
1290   void idivl(Register src);
1291   void divl(Register src); // Unsigned division
1292 
1293 #ifdef _LP64
1294   void idivq(Register src);
1295 #endif
1296 
1297   void imull(Register src);
1298   void imull(Register dst, Register src);
1299   void imull(Register dst, Register src, int value);
1300   void imull(Register dst, Address src);
1301 
1302 #ifdef _LP64
1303   void imulq(Register dst, Register src);
1304   void imulq(Register dst, Register src, int value);
1305   void imulq(Register dst, Address src);
1306 #endif
1307 
</pre>
<hr />
<pre>
1393       // cache line, as this will also avoid possible second-order effects
1394       // with locked ops against the cache line. Our choice of offset
1395       // is bounded by x86 operand encoding, which should stay within
1396       // [-128; +127] to have the 8-byte displacement encoding.
1397       //
1398       // Any change to this code may need to revisit other places in
1399       // the code where this idiom is used, in particular the
1400       // orderAccess code.
1401 
1402       int offset = -VM_Version::L1_line_size();
1403       if (offset &lt; -128) {
1404         offset = -128;
1405       }
1406 
1407       lock();
1408       addl(Address(rsp, offset), 0);// Assert the lock# signal here
1409     }
1410   }
1411 
1412   void mfence();
<span class="line-added">1413   void sfence();</span>
1414 
1415   // Moves
1416 
1417   void mov64(Register dst, int64_t imm64);
1418 
1419   void movb(Address dst, Register src);
1420   void movb(Address dst, int imm8);
1421   void movb(Register dst, Address src);
1422 
1423   void movddup(XMMRegister dst, XMMRegister src);
1424 
1425   void kmovbl(KRegister dst, Register src);
1426   void kmovbl(Register dst, KRegister src);
1427   void kmovwl(KRegister dst, Register src);
1428   void kmovwl(KRegister dst, Address src);
1429   void kmovwl(Register dst, KRegister src);
1430   void kmovdl(KRegister dst, Register src);
1431   void kmovdl(Register dst, KRegister src);
1432   void kmovql(KRegister dst, KRegister src);
1433   void kmovql(Address dst, KRegister src);
</pre>
<hr />
<pre>
1579   // Multiply Scalar Double-Precision Floating-Point Values
1580   void mulsd(XMMRegister dst, Address src);
1581   void mulsd(XMMRegister dst, XMMRegister src);
1582 
1583   // Multiply Scalar Single-Precision Floating-Point Values
1584   void mulss(XMMRegister dst, Address src);
1585   void mulss(XMMRegister dst, XMMRegister src);
1586 
1587   void negl(Register dst);
1588 
1589 #ifdef _LP64
1590   void negq(Register dst);
1591 #endif
1592 
1593   void nop(int i = 1);
1594 
1595   void notl(Register dst);
1596 
1597 #ifdef _LP64
1598   void notq(Register dst);
<span class="line-added">1599 </span>
<span class="line-added">1600   void btsq(Address dst, int imm8);</span>
<span class="line-added">1601   void btrq(Address dst, int imm8);</span>
1602 #endif
1603 
1604   void orl(Address dst, int32_t imm32);
1605   void orl(Register dst, int32_t imm32);
1606   void orl(Register dst, Address src);
1607   void orl(Register dst, Register src);
1608   void orl(Address dst, Register src);
1609 
1610   void orb(Address dst, int imm8);
1611 
1612   void orq(Address dst, int32_t imm32);
1613   void orq(Register dst, int32_t imm32);
1614   void orq(Register dst, Address src);
1615   void orq(Register dst, Register src);
1616 
1617   // Pack with unsigned saturation
1618   void packuswb(XMMRegister dst, XMMRegister src);
1619   void packuswb(XMMRegister dst, Address src);
1620   void vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1621 
1622   // Pemutation of 64bit words
1623   void vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len);
1624   void vpermq(XMMRegister dst, XMMRegister src, int imm8);
<span class="line-added">1625   void vpermq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);</span>
1626   void vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8);
1627   void vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8);
1628   void evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1629 
1630   void pause();
1631 
1632   // Undefined Instruction
1633   void ud2();
1634 
1635   // SSE4.2 string instructions
1636   void pcmpestri(XMMRegister xmm1, XMMRegister xmm2, int imm8);
1637   void pcmpestri(XMMRegister xmm1, Address src, int imm8);
1638 
1639   void pcmpeqb(XMMRegister dst, XMMRegister src);
1640   void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1641   void evpcmpeqb(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1642   void evpcmpeqb(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1643   void evpcmpeqb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len);
1644 
1645   void evpcmpgtb(KRegister kdst, XMMRegister nds, Address src, int vector_len);
</pre>
<hr />
<pre>
1685   void pinsrb(XMMRegister dst, Address src, int imm8);
1686   // SSE 2 insert
1687   void pinsrw(XMMRegister dst, Register src, int imm8);
1688   void pinsrw(XMMRegister dst, Address src, int imm8);
1689 
1690   // SSE4.1 packed move
1691   void pmovzxbw(XMMRegister dst, XMMRegister src);
1692   void pmovzxbw(XMMRegister dst, Address src);
1693 
1694   void vpmovzxbw( XMMRegister dst, Address src, int vector_len);
1695   void vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len);
1696   void evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len);
1697 
1698   void evpmovwb(Address dst, XMMRegister src, int vector_len);
1699   void evpmovwb(Address dst, KRegister mask, XMMRegister src, int vector_len);
1700 
1701   void vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len);
1702 
1703   void evpmovdb(Address dst, XMMRegister src, int vector_len);
1704 
<span class="line-added">1705   // Sign extend moves</span>
<span class="line-added">1706   void pmovsxbw(XMMRegister dst, XMMRegister src);</span>
<span class="line-added">1707   void vpmovsxbw(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="line-added">1708 </span>
1709   // Multiply add
1710   void pmaddwd(XMMRegister dst, XMMRegister src);
1711   void vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1712   // Multiply add accumulate
1713   void evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1714 
1715 #ifndef _LP64 // no 32bit push/pop on amd64
1716   void popl(Address dst);
1717 #endif
1718 
1719 #ifdef _LP64
1720   void popq(Address dst);
1721 #endif
1722 
1723   void popcntl(Register dst, Address src);
1724   void popcntl(Register dst, Register src);
1725 
1726   void vpopcntd(XMMRegister dst, XMMRegister src, int vector_len);
1727 
1728 #ifdef _LP64
</pre>
<hr />
<pre>
1825 
1826   void setb(Condition cc, Register dst);
1827 
1828   void palignr(XMMRegister dst, XMMRegister src, int imm8);
1829   void vpalignr(XMMRegister dst, XMMRegister src1, XMMRegister src2, int imm8, int vector_len);
1830   void evalignq(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
1831 
1832   void pblendw(XMMRegister dst, XMMRegister src, int imm8);
1833 
1834   void sha1rnds4(XMMRegister dst, XMMRegister src, int imm8);
1835   void sha1nexte(XMMRegister dst, XMMRegister src);
1836   void sha1msg1(XMMRegister dst, XMMRegister src);
1837   void sha1msg2(XMMRegister dst, XMMRegister src);
1838   // xmm0 is implicit additional source to the following instruction.
1839   void sha256rnds2(XMMRegister dst, XMMRegister src);
1840   void sha256msg1(XMMRegister dst, XMMRegister src);
1841   void sha256msg2(XMMRegister dst, XMMRegister src);
1842 
1843   void shldl(Register dst, Register src);
1844   void shldl(Register dst, Register src, int8_t imm8);
<span class="line-added">1845   void shrdl(Register dst, Register src);</span>
<span class="line-added">1846   void shrdl(Register dst, Register src, int8_t imm8);</span>
1847 
1848   void shll(Register dst, int imm8);
1849   void shll(Register dst);
1850 
1851   void shlq(Register dst, int imm8);
1852   void shlq(Register dst);
1853 


1854   void shrl(Register dst, int imm8);
1855   void shrl(Register dst);
1856 
1857   void shrq(Register dst, int imm8);
1858   void shrq(Register dst);
1859 
1860   void smovl(); // QQQ generic?
1861 
1862   // Compute Square Root of Scalar Double-Precision Floating-Point Value
1863   void sqrtsd(XMMRegister dst, Address src);
1864   void sqrtsd(XMMRegister dst, XMMRegister src);
1865 
<span class="line-added">1866   void roundsd(XMMRegister dst, Address src, int32_t rmode);</span>
<span class="line-added">1867   void roundsd(XMMRegister dst, XMMRegister src, int32_t rmode);</span>
<span class="line-added">1868 </span>
1869   // Compute Square Root of Scalar Single-Precision Floating-Point Value
1870   void sqrtss(XMMRegister dst, Address src);
1871   void sqrtss(XMMRegister dst, XMMRegister src);
1872 
1873   void std();
1874 
1875   void stmxcsr( Address dst );
1876 
1877   void subl(Address dst, int32_t imm32);
1878   void subl(Address dst, Register src);
1879   void subl(Register dst, int32_t imm32);
1880   void subl(Register dst, Address src);
1881   void subl(Register dst, Register src);
1882 
1883   void subq(Address dst, int32_t imm32);
1884   void subq(Address dst, Register src);
1885   void subq(Register dst, int32_t imm32);
1886   void subq(Register dst, Address src);
1887   void subq(Register dst, Register src);
1888 
</pre>
<hr />
<pre>
2013 
2014   void vfmadd231pd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2015   void vfmadd231ps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2016   void vfmadd231pd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2017   void vfmadd231ps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2018 
2019   // Divide Packed Floating-Point Values
2020   void divpd(XMMRegister dst, XMMRegister src);
2021   void divps(XMMRegister dst, XMMRegister src);
2022   void vdivpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2023   void vdivps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2024   void vdivpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2025   void vdivps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2026 
2027   // Sqrt Packed Floating-Point Values
2028   void vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len);
2029   void vsqrtpd(XMMRegister dst, Address src, int vector_len);
2030   void vsqrtps(XMMRegister dst, XMMRegister src, int vector_len);
2031   void vsqrtps(XMMRegister dst, Address src, int vector_len);
2032 
<span class="line-added">2033   // Round Packed Double precision value.</span>
<span class="line-added">2034   void vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len);</span>
<span class="line-added">2035   void vroundpd(XMMRegister dst, Address src, int32_t rmode, int vector_len);</span>
<span class="line-added">2036   void vrndscalepd(XMMRegister dst,  XMMRegister src,  int32_t rmode, int vector_len);</span>
<span class="line-added">2037   void vrndscalepd(XMMRegister dst, Address src, int32_t rmode, int vector_len);</span>
<span class="line-added">2038 </span>
2039   // Bitwise Logical AND of Packed Floating-Point Values
2040   void andpd(XMMRegister dst, XMMRegister src);
2041   void andps(XMMRegister dst, XMMRegister src);
2042   void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2043   void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2044   void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2045   void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2046 
2047   void unpckhpd(XMMRegister dst, XMMRegister src);
2048   void unpcklpd(XMMRegister dst, XMMRegister src);
2049 
2050   // Bitwise Logical XOR of Packed Floating-Point Values
2051   void xorpd(XMMRegister dst, XMMRegister src);
2052   void xorps(XMMRegister dst, XMMRegister src);
2053   void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2054   void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2055   void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2056   void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2057 
2058   // Add horizontal packed integers
</pre>
<hr />
<pre>
2124   void psrlq(XMMRegister dst, XMMRegister shift);
2125   void vpsrlw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2126   void vpsrld(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2127   void vpsrlq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2128   void vpsrlw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2129   void vpsrld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2130   void vpsrlq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2131   void vpsrldq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2132   void evpsrlvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2133   void evpsllvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2134 
2135   // Arithmetic shift right packed integers (only shorts and ints, no instructions for longs)
2136   void psraw(XMMRegister dst, int shift);
2137   void psrad(XMMRegister dst, int shift);
2138   void psraw(XMMRegister dst, XMMRegister shift);
2139   void psrad(XMMRegister dst, XMMRegister shift);
2140   void vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2141   void vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2142   void vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2143   void vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
<span class="line-added">2144   void evpsraq(XMMRegister dst, XMMRegister src, int shift, int vector_len);</span>
<span class="line-added">2145   void evpsraq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);</span>
<span class="line-added">2146 </span>
<span class="line-added">2147   void vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);</span>
<span class="line-added">2148   void vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);</span>
2149 
2150   // And packed integers
2151   void pand(XMMRegister dst, XMMRegister src);
2152   void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2153   void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2154   void vpandq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2155 
2156   // Andn packed integers
2157   void pandn(XMMRegister dst, XMMRegister src);
2158   void vpandn(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2159 
2160   // Or packed integers
2161   void por(XMMRegister dst, XMMRegister src);
2162   void vpor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2163   void vpor(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2164   void vporq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2165 
2166   // Xor packed integers
2167   void pxor(XMMRegister dst, XMMRegister src);
2168   void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
</pre>
<hr />
<pre>
2201   void vextractf32x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2202   void vextractf32x4(Address dst, XMMRegister src, uint8_t imm8);
2203   void vextractf64x2(XMMRegister dst, XMMRegister src, uint8_t imm8);
2204   void vextractf64x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2205   void vextractf64x4(Address dst, XMMRegister src, uint8_t imm8);
2206 
2207   // xmm/mem sourced byte/word/dword/qword replicate
2208   void vpbroadcastb(XMMRegister dst, XMMRegister src, int vector_len);
2209   void vpbroadcastb(XMMRegister dst, Address src, int vector_len);
2210   void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
2211   void vpbroadcastw(XMMRegister dst, Address src, int vector_len);
2212   void vpbroadcastd(XMMRegister dst, XMMRegister src, int vector_len);
2213   void vpbroadcastd(XMMRegister dst, Address src, int vector_len);
2214   void vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len);
2215   void vpbroadcastq(XMMRegister dst, Address src, int vector_len);
2216 
2217   void evbroadcasti64x2(XMMRegister dst, XMMRegister src, int vector_len);
2218   void evbroadcasti64x2(XMMRegister dst, Address src, int vector_len);
2219 
2220   // scalar single/double precision replicate
<span class="line-modified">2221   void vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="line-modified">2222   void vbroadcastss(XMMRegister dst, Address src, int vector_len);</span>
<span class="line-modified">2223   void vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len);</span>
<span class="line-modified">2224   void vbroadcastsd(XMMRegister dst, Address src, int vector_len);</span>
2225 
2226   // gpr sourced byte/word/dword/qword replicate
2227   void evpbroadcastb(XMMRegister dst, Register src, int vector_len);
2228   void evpbroadcastw(XMMRegister dst, Register src, int vector_len);
2229   void evpbroadcastd(XMMRegister dst, Register src, int vector_len);
2230   void evpbroadcastq(XMMRegister dst, Register src, int vector_len);
2231 
2232   void evpgatherdd(XMMRegister dst, KRegister k1, Address src, int vector_len);
2233 
2234   // Carry-Less Multiplication Quadword
2235   void pclmulqdq(XMMRegister dst, XMMRegister src, int mask);
2236   void vpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask);
2237   void evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len);
2238   // AVX instruction which is used to clear upper 128 bits of YMM registers and
2239   // to avoid transaction penalty between AVX and SSE states. There is no
2240   // penalty if legacy SSE instructions are encoded using VEX prefix because
2241   // they always clear upper 128 bits. It should be used before calling
2242   // runtime code and native libraries.
2243   void vzeroupper();
2244 
</pre>
</td>
</tr>
</table>
<center><a href="assembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_CodeStubs_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/assembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="abstractInterpreter_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/assembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 787,10 ***</span>
<span class="line-new-header">--- 787,12 ---</span>
      case 0x57: // xorps
      case 0x58: // addpd
      case 0x59: // mulpd
      case 0x6E: // movd
      case 0x7E: // movd
<span class="line-added">+     case 0x6F: // movdq</span>
<span class="line-added">+     case 0x7F: // movdq</span>
      case 0xAE: // ldmxcsr, stmxcsr, fxrstor, fxsave, clflush
      case 0xFE: // paddd
        debug_only(has_disp32 = true);
        break;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1376,10 ***</span>
<span class="line-new-header">--- 1378,19 ---</span>
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8((unsigned char)0xDC);
    emit_int8(0xC0 | encode);
  }
  
<span class="line-added">+ void Assembler::vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {</span>
<span class="line-added">+   assert(VM_Version::supports_vaes(), &quot;requires vaes support/enabling&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   attributes.set_is_evex_instruction();</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8((unsigned char)0xDC);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::aesenclast(XMMRegister dst, Address src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1393,10 ***</span>
<span class="line-new-header">--- 1404,19 ---</span>
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8((unsigned char)0xDD);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
<span class="line-added">+ void Assembler::vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {</span>
<span class="line-added">+   assert(VM_Version::supports_vaes(), &quot;requires vaes support/enabling&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   attributes.set_is_evex_instruction();</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8((unsigned char)0xDD);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::andl(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefix(dst);
    emit_int8((unsigned char)0x81);
    emit_operand(rsp, dst, 4);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1892,10 ***</span>
<span class="line-new-header">--- 1912,73 ---</span>
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8((unsigned char)0xE6);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
<span class="line-added">+ void Assembler::pabsb(XMMRegister dst, XMMRegister src) {</span>
<span class="line-added">+   assert(VM_Version::supports_ssse3(), &quot;&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x1C);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::pabsw(XMMRegister dst, XMMRegister src) {</span>
<span class="line-added">+   assert(VM_Version::supports_ssse3(), &quot;&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x1D);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::pabsd(XMMRegister dst, XMMRegister src) {</span>
<span class="line-added">+   assert(VM_Version::supports_ssse3(), &quot;&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x1E);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::vpabsb(XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="line-added">+   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :</span>
<span class="line-added">+   vector_len == AVX_256bit? VM_Version::supports_avx2() :</span>
<span class="line-added">+   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8((unsigned char)0x1C);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::vpabsw(XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="line-added">+   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :</span>
<span class="line-added">+   vector_len == AVX_256bit? VM_Version::supports_avx2() :</span>
<span class="line-added">+   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8((unsigned char)0x1D);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::vpabsd(XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="line-added">+   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :</span>
<span class="line-added">+   vector_len == AVX_256bit? VM_Version::supports_avx2() :</span>
<span class="line-added">+   vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot;&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8((unsigned char)0x1E);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::evpabsq(XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="line-added">+   assert(UseAVX &gt; 2, &quot;&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   attributes.set_is_evex_instruction();</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8((unsigned char)0x1F);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::decl(Address dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrement() instead.
    InstructionMark im(this);
    prefix(dst);
    emit_int8((unsigned char)0xFF);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2189,10 ***</span>
<span class="line-new-header">--- 2272,18 ---</span>
    emit_int8(0x0F);
    emit_int8((unsigned char)0xAE);
    emit_int8((unsigned char)0xF0);
  }
  
<span class="line-added">+ // Emit sfence instruction</span>
<span class="line-added">+ void Assembler::sfence() {</span>
<span class="line-added">+   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)</span>
<span class="line-added">+   emit_int8(0x0F);</span>
<span class="line-added">+   emit_int8((unsigned char)0xAE);</span>
<span class="line-added">+   emit_int8((unsigned char)0xF8);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::mov(Register dst, Register src) {
    LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
  }
  
  void Assembler::movapd(XMMRegister dst, XMMRegister src) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3097,11 ***</span>
        default:
          assert(i == 0, &quot; &quot;);
      }
      return;
    }
<span class="line-modified">!   if (UseAddressNop &amp;&amp; VM_Version::is_amd()) {</span>
      //
      // Using multi-bytes nops &quot;0x0F 0x1F [address]&quot; for AMD.
      //  1: 0x90
      //  2: 0x66 0x90
      //  3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)
<span class="line-new-header">--- 3188,11 ---</span>
        default:
          assert(i == 0, &quot; &quot;);
      }
      return;
    }
<span class="line-modified">!   if (UseAddressNop &amp;&amp; VM_Version::is_amd_family()) {</span>
      //
      // Using multi-bytes nops &quot;0x0F 0x1F [address]&quot; for AMD.
      //  1: 0x90
      //  2: 0x66 0x90
      //  3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3414,14 ***</span>
  void Assembler::vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
    emit_int8(0x00);
<span class="line-modified">!   emit_int8(0xC0 | encode);</span>
    emit_int8(imm8);
  }
  
  void Assembler::vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
    emit_int8(0x46);
<span class="line-new-header">--- 3505,23 ---</span>
  void Assembler::vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
    emit_int8(0x00);
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
    emit_int8(imm8);
  }
  
<span class="line-added">+ void Assembler::vpermq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {</span>
<span class="line-added">+   assert(UseAVX &gt; 2, &quot;requires AVX512F&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   attributes.set_is_evex_instruction();</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8((unsigned char)0x36);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
    emit_int8(0x46);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3882,10 ***</span>
<span class="line-new-header">--- 3982,18 ---</span>
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x30);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
<span class="line-added">+ void Assembler::pmovsxbw(XMMRegister dst, XMMRegister src) {</span>
<span class="line-added">+   assert(VM_Version::supports_sse4_1(), &quot;&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x20);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3903,10 ***</span>
<span class="line-new-header">--- 4011,19 ---</span>
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x30);
    emit_int8((unsigned char) (0xC0 | encode));
  }
  
<span class="line-added">+ void Assembler::vpmovsxbw(XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="line-added">+   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :</span>
<span class="line-added">+   vector_len == AVX_256bit? VM_Version::supports_avx2() :</span>
<span class="line-added">+   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x20);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
  
  void Assembler::evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4108,11 ***</span>
  }
  
  void Assembler::vpshufb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
           vector_len == AVX_256bit? VM_Version::supports_avx2() :
<span class="line-modified">!          0, &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x00);
    emit_int8((unsigned char)(0xC0 | encode));
  }
<span class="line-new-header">--- 4225,11 ---</span>
  }
  
  void Assembler::vpshufb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
           vector_len == AVX_256bit? VM_Version::supports_avx2() :
<span class="line-modified">!          vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x00);
    emit_int8((unsigned char)(0xC0 | encode));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4138,12 ***</span>
    emit_int8(mode &amp; 0xFF);
  }
  
  void Assembler::vpshufd(XMMRegister dst, XMMRegister src, int mode, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
<span class="line-modified">!          vector_len == AVX_256bit? VM_Version::supports_avx2() :</span>
<span class="line-modified">!          0, &quot;&quot;);</span>
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x70);
    emit_int8((unsigned char)(0xC0 | encode));
<span class="line-new-header">--- 4255,12 ---</span>
    emit_int8(mode &amp; 0xFF);
  }
  
  void Assembler::vpshufd(XMMRegister dst, XMMRegister src, int mode, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
<span class="line-modified">!          (vector_len == AVX_256bit? VM_Version::supports_avx2() :</span>
<span class="line-modified">!          (vector_len == AVX_512bit? VM_Version::supports_evex() : 0)), &quot;&quot;);</span>
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x70);
    emit_int8((unsigned char)(0xC0 | encode));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4183,10 ***</span>
<span class="line-new-header">--- 4300,11 ---</span>
    simd_prefix(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x70);
    emit_operand(dst, src);
    emit_int8(mode &amp; 0xFF);
  }
<span class="line-added">+ </span>
  void Assembler::evshufi64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    assert(vector_len == Assembler::AVX_256bit || vector_len == Assembler::AVX_512bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4617,15 ***</span>
<span class="line-new-header">--- 4735,64 ---</span>
    int encode = prefix_and_encode(dst-&gt;encoding());
    emit_int8((unsigned char)0xD3);
    emit_int8((unsigned char)(0xE8 | encode));
  }
  
<span class="line-added">+ void Assembler::shldl(Register dst, Register src) {</span>
<span class="line-added">+   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());</span>
<span class="line-added">+   emit_int8(0x0F);</span>
<span class="line-added">+   emit_int8((unsigned char)0xA5);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::shldl(Register dst, Register src, int8_t imm8) {</span>
<span class="line-added">+   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());</span>
<span class="line-added">+   emit_int8(0x0F);</span>
<span class="line-added">+   emit_int8((unsigned char)0xA4);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+   emit_int8(imm8);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::shrdl(Register dst, Register src) {</span>
<span class="line-added">+   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());</span>
<span class="line-added">+   emit_int8(0x0F);</span>
<span class="line-added">+   emit_int8((unsigned char)0xAD);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::shrdl(Register dst, Register src, int8_t imm8) {</span>
<span class="line-added">+   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());</span>
<span class="line-added">+   emit_int8(0x0F);</span>
<span class="line-added">+   emit_int8((unsigned char)0xAC);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+   emit_int8(imm8);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // copies a single word from [esi] to [edi]
  void Assembler::smovl() {
    emit_int8((unsigned char)0xA5);
  }
  
<span class="line-added">+ void Assembler::roundsd(XMMRegister dst, XMMRegister src, int32_t rmode) {</span>
<span class="line-added">+   assert(VM_Version::supports_sse4_1(), &quot;&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);</span>
<span class="line-added">+   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x0B);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+   emit_int8((unsigned char)rmode);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::roundsd(XMMRegister dst, Address src, int32_t rmode) {</span>
<span class="line-added">+   assert(VM_Version::supports_sse4_1(), &quot;&quot;);</span>
<span class="line-added">+   InstructionMark im(this);</span>
<span class="line-added">+   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);</span>
<span class="line-added">+   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x0B);</span>
<span class="line-added">+   emit_operand(dst, src);</span>
<span class="line-added">+   emit_int8((unsigned char)rmode);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::sqrtsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5419,10 ***</span>
<span class="line-new-header">--- 5586,53 ---</span>
    vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x5E);
    emit_operand(dst, src);
  }
  
<span class="line-added">+ void Assembler::vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len) {</span>
<span class="line-added">+   assert(VM_Version::supports_avx(), &quot;&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x09);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+   emit_int8((unsigned char)(rmode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::vroundpd(XMMRegister dst, Address src, int32_t rmode,  int vector_len) {</span>
<span class="line-added">+   assert(VM_Version::supports_avx(), &quot;&quot;);</span>
<span class="line-added">+   InstructionMark im(this);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);</span>
<span class="line-added">+   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x09);</span>
<span class="line-added">+   emit_operand(dst, src);</span>
<span class="line-added">+   emit_int8((unsigned char)(rmode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::vrndscalepd(XMMRegister dst,  XMMRegister src,  int32_t rmode, int vector_len) {</span>
<span class="line-added">+   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   attributes.set_is_evex_instruction();</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);</span>
<span class="line-added">+   emit_int8((unsigned char)0x09);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+   emit_int8((unsigned char)(rmode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::vrndscalepd(XMMRegister dst, Address src, int32_t rmode, int vector_len) {</span>
<span class="line-added">+   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);</span>
<span class="line-added">+   assert(dst != xnoreg, &quot;sanity&quot;);</span>
<span class="line-added">+   InstructionMark im(this);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   attributes.set_is_evex_instruction();</span>
<span class="line-added">+   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);</span>
<span class="line-added">+   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);</span>
<span class="line-added">+   emit_int8((unsigned char)0x09);</span>
<span class="line-added">+   emit_operand(dst, src);</span>
<span class="line-added">+   emit_int8((unsigned char)(rmode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  void Assembler::vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6275,10 ***</span>
<span class="line-new-header">--- 6485,30 ---</span>
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8((unsigned char)0xE2);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
<span class="line-added">+ void Assembler::evpsraq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {</span>
<span class="line-added">+   assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);</span>
<span class="line-added">+   assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   attributes.set_is_evex_instruction();</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);</span>
<span class="line-added">+   emit_int8((unsigned char)0x72);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+   emit_int8(shift &amp; 0xFF);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::evpsraq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {</span>
<span class="line-added">+   assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);</span>
<span class="line-added">+   assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   attributes.set_is_evex_instruction();</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);</span>
<span class="line-added">+   emit_int8((unsigned char)0xE2);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
  
  // logical operations packed integers
  void Assembler::pand(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6311,10 ***</span>
<span class="line-new-header">--- 6541,27 ---</span>
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8((unsigned char)0xDB);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
<span class="line-added">+ void Assembler::vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {</span>
<span class="line-added">+   assert(VM_Version::supports_vbmi2(), &quot;requires vbmi2&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   attributes.set_is_evex_instruction();</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x71);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {</span>
<span class="line-added">+   assert(VM_Version::supports_vbmi2(), &quot;requires vbmi2&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   attributes.set_is_evex_instruction();</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x73);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+ }</span>
  
  void Assembler::pandn(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6910,19 ***</span>
  }
  
  // scalar single/double precision replicate
  
  // duplicate single precision data from src into programmed locations in dest : requires AVX512VL
<span class="line-modified">! void Assembler::vpbroadcastss(XMMRegister dst, XMMRegister src, int vector_len) {</span>
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x18);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
<span class="line-modified">! void Assembler::vpbroadcastss(XMMRegister dst, Address src, int vector_len) {</span>
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
<span class="line-new-header">--- 7157,19 ---</span>
  }
  
  // scalar single/double precision replicate
  
  // duplicate single precision data from src into programmed locations in dest : requires AVX512VL
<span class="line-modified">! void Assembler::vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len) {</span>
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x18);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
<span class="line-modified">! void Assembler::vbroadcastss(XMMRegister dst, Address src, int vector_len) {</span>
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6931,20 ***</span>
    emit_int8(0x18);
    emit_operand(dst, src);
  }
  
  // duplicate double precision data from src into programmed locations in dest : requires AVX512VL
<span class="line-modified">! void Assembler::vpbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len) {</span>
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x19);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
<span class="line-modified">! void Assembler::vpbroadcastsd(XMMRegister dst, Address src, int vector_len) {</span>
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
<span class="line-new-header">--- 7178,20 ---</span>
    emit_int8(0x18);
    emit_operand(dst, src);
  }
  
  // duplicate double precision data from src into programmed locations in dest : requires AVX512VL
<span class="line-modified">! void Assembler::vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len) {</span>
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x19);
    emit_int8((unsigned char)(0xC0 | encode));
  }
  
<span class="line-modified">! void Assembler::vbroadcastsd(XMMRegister dst, Address src, int vector_len) {</span>
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6995,11 ***</span>
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x7C);
    emit_int8((unsigned char)(0xC0 | encode));
  }
<span class="line-removed">- </span>
  void Assembler::evpgatherdd(XMMRegister dst, KRegister mask, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
<span class="line-new-header">--- 7242,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7010,11 ***</span>
    // swap src&lt;-&gt;dst for encoding
    vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8((unsigned char)0x90);
    emit_operand(dst, src);
  }
<span class="line-removed">- </span>
  // Carry-Less Multiplication Quadword
  void Assembler::pclmulqdq(XMMRegister dst, XMMRegister src, int mask) {
    assert(VM_Version::supports_clmul(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-new-header">--- 7256,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7032,11 ***</span>
    emit_int8((unsigned char)(0xC0 | encode));
    emit_int8((unsigned char)mask);
  }
  
  void Assembler::evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vpclmulqdq(), &quot;Requires vector carryless multiplication support&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
    emit_int8(0x44);
    emit_int8((unsigned char)(0xC0 | encode));
<span class="line-new-header">--- 7277,11 ---</span>
    emit_int8((unsigned char)(0xC0 | encode));
    emit_int8((unsigned char)mask);
  }
  
  void Assembler::evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vpclmulqdq(), &quot;Requires vector carryless multiplication support&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
    emit_int8(0x44);
    emit_int8((unsigned char)(0xC0 | encode));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7083,13 ***</span>
  void Assembler::decl(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
   emit_int8(0x48 | dst-&gt;encoding());
  }
  
<span class="line-modified">! #endif // _LP64</span>
<span class="line-removed">- </span>
<span class="line-removed">- // 64bit typically doesn&#39;t use the x87 but needs to for the trig funcs</span>
  
  void Assembler::fabs() {
    emit_int8((unsigned char)0xD9);
    emit_int8((unsigned char)0xE1);
  }
<span class="line-new-header">--- 7328,11 ---</span>
  void Assembler::decl(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
   emit_int8(0x48 | dst-&gt;encoding());
  }
  
<span class="line-modified">! // 64bit doesn&#39;t use the x87</span>
  
  void Assembler::fabs() {
    emit_int8((unsigned char)0xD9);
    emit_int8((unsigned char)0xE1);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7520,10 ***</span>
<span class="line-new-header">--- 7763,11 ---</span>
  
  void Assembler::fldl2e() {
    emit_int8((unsigned char)0xD9);
    emit_int8((unsigned char)0xEA);
  }
<span class="line-added">+ #endif // !_LP64</span>
  
  // SSE SIMD prefix byte values corresponding to VexSimdPrefix encoding.
  static int simd_pre[4] = { 0, 0x66, 0xF3, 0xF2 };
  // SSE opcode second byte values (first is 0x0F) corresponding to VexOpcode encoding.
  static int simd_opc[4] = { 0,    0, 0x38, 0x3A };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7909,30 ***</span>
    emit_int8(0x0F);
    emit_int8((unsigned char)0x95);
    emit_int8((unsigned char)(0xE0 | dst-&gt;encoding()));
  }
  
<span class="line-removed">- void Assembler::shldl(Register dst, Register src) {</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xA5);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | src-&gt;encoding() &lt;&lt; 3 | dst-&gt;encoding()));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // 0F A4 / r ib</span>
<span class="line-removed">- void Assembler::shldl(Register dst, Register src, int8_t imm8) {</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xA4);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | src-&gt;encoding() &lt;&lt; 3 | dst-&gt;encoding()));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Assembler::shrdl(Register dst, Register src) {</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAD);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | src-&gt;encoding() &lt;&lt; 3 | dst-&gt;encoding()));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  #else // LP64
  
  void Assembler::set_byte_if_not_zero(Register dst) {
    int enc = prefix_and_encode(dst-&gt;encoding(), true);
    emit_int8(0x0F);
<span class="line-new-header">--- 8153,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8485,16 ***</span>
<span class="line-new-header">--- 8709,49 ---</span>
    prefix(REX_W);
    emit_int8((unsigned char)0x99);
  }
  
  void Assembler::clflush(Address adr) {
<span class="line-added">+   assert(VM_Version::supports_clflush(), &quot;should do&quot;);</span>
<span class="line-added">+   prefix(adr);</span>
<span class="line-added">+   emit_int8(0x0F);</span>
<span class="line-added">+   emit_int8((unsigned char)0xAE);</span>
<span class="line-added">+   emit_operand(rdi, adr);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::clflushopt(Address adr) {</span>
<span class="line-added">+   assert(VM_Version::supports_clflushopt(), &quot;should do!&quot;);</span>
<span class="line-added">+   // adr should be base reg only with no index or offset</span>
<span class="line-added">+   assert(adr.index() == noreg, &quot;index should be noreg&quot;);</span>
<span class="line-added">+   assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);</span>
<span class="line-added">+   assert(adr.disp() == 0, &quot;displacement should be 0&quot;);</span>
<span class="line-added">+   // instruction prefix is 0x66</span>
<span class="line-added">+   emit_int8(0x66);</span>
    prefix(adr);
<span class="line-added">+   // opcode family is 0x0f 0xAE</span>
    emit_int8(0x0F);
    emit_int8((unsigned char)0xAE);
<span class="line-added">+   // extended opcode byte is 7 == rdi</span>
    emit_operand(rdi, adr);
  }
  
<span class="line-added">+ void Assembler::clwb(Address adr) {</span>
<span class="line-added">+   assert(VM_Version::supports_clwb(), &quot;should do!&quot;);</span>
<span class="line-added">+   // adr should be base reg only with no index or offset</span>
<span class="line-added">+   assert(adr.index() == noreg, &quot;index should be noreg&quot;);</span>
<span class="line-added">+   assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);</span>
<span class="line-added">+   assert(adr.disp() == 0, &quot;displacement should be 0&quot;);</span>
<span class="line-added">+   // instruction prefix is 0x66</span>
<span class="line-added">+   emit_int8(0x66);</span>
<span class="line-added">+   prefix(adr);</span>
<span class="line-added">+   // opcode family is 0x0f 0xAE</span>
<span class="line-added">+   emit_int8(0x0F);</span>
<span class="line-added">+   emit_int8((unsigned char)0xAE);</span>
<span class="line-added">+   // extended opcode byte is 6 == rsi</span>
<span class="line-added">+   emit_operand(rsi, adr);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::cmovq(Condition cc, Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_int8(0x0F);
    emit_int8(0x40 | cc);
    emit_int8((unsigned char)(0xC0 | encode));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8574,10 ***</span>
<span class="line-new-header">--- 8831,22 ---</span>
    simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x2A);
    emit_operand(dst, src);
  }
  
<span class="line-added">+ void Assembler::cvttsd2siq(Register dst, Address src) {</span>
<span class="line-added">+   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));</span>
<span class="line-added">+   // F2 REX.W 0F 2C /r</span>
<span class="line-added">+   // CVTTSD2SI r64, xmm1/m64</span>
<span class="line-added">+   InstructionMark im(this);</span>
<span class="line-added">+   emit_int8((unsigned char)0xF2);</span>
<span class="line-added">+   prefix(REX_W);</span>
<span class="line-added">+   emit_int8(0x0F);</span>
<span class="line-added">+   emit_int8(0x2C);</span>
<span class="line-added">+   emit_operand(dst, src);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::cvttsd2siq(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x2C);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8930,10 ***</span>
<span class="line-new-header">--- 9199,30 ---</span>
    int encode = prefixq_and_encode(dst-&gt;encoding());
    emit_int8((unsigned char)0xF7);
    emit_int8((unsigned char)(0xD0 | encode));
  }
  
<span class="line-added">+ void Assembler::btsq(Address dst, int imm8) {</span>
<span class="line-added">+   assert(isByte(imm8), &quot;not a byte&quot;);</span>
<span class="line-added">+   InstructionMark im(this);</span>
<span class="line-added">+   prefixq(dst);</span>
<span class="line-added">+   emit_int8((unsigned char)0x0F);</span>
<span class="line-added">+   emit_int8((unsigned char)0xBA);</span>
<span class="line-added">+   emit_operand(rbp /* 5 */, dst, 1);</span>
<span class="line-added">+   emit_int8(imm8);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::btrq(Address dst, int imm8) {</span>
<span class="line-added">+   assert(isByte(imm8), &quot;not a byte&quot;);</span>
<span class="line-added">+   InstructionMark im(this);</span>
<span class="line-added">+   prefixq(dst);</span>
<span class="line-added">+   emit_int8((unsigned char)0x0F);</span>
<span class="line-added">+   emit_int8((unsigned char)0xBA);</span>
<span class="line-added">+   emit_operand(rsi /* 6 */, dst, 1);</span>
<span class="line-added">+   emit_int8(imm8);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::orq(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefixq(dst);
    emit_int8((unsigned char)0x81);
    emit_operand(rcx, dst, 4);
</pre>
<center><a href="abstractInterpreter_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
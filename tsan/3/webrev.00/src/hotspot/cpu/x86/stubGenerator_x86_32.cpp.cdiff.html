<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/stubGenerator_x86_32.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_x86_64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/stubGenerator_x86_32.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,11 ***</span>
<span class="line-new-header">--- 25,13 ---</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;asm/macroAssembler.hpp&quot;
  #include &quot;asm/macroAssembler.inline.hpp&quot;
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/barrierSetNMethod.hpp&quot;</span>
  #include &quot;interpreter/interpreter.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;nativeInst_x86.hpp&quot;
  #include &quot;oops/instanceOop.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,11 ***</span>
      return start;
    }
  
  
    //----------------------------------------------------------------------------------------------------
<span class="line-modified">!   // Support for int32_t Atomic::xchg(int32_t exchange_value, volatile int32_t* dest)</span>
    //
    // xchg exists as far back as 8086, lock needed for MP only
    // Stack layout immediately after call:
    //
    // 0 [ret addr ] &lt;--- rsp
<span class="line-new-header">--- 429,12 ---</span>
      return start;
    }
  
  
    //----------------------------------------------------------------------------------------------------
<span class="line-modified">!   // Implementation of int32_t atomic_xchg(int32_t exchange_value, volatile int32_t* dest)</span>
<span class="line-added">+   // used by Atomic::xchg(volatile int32_t* dest, int32_t exchange_value)</span>
    //
    // xchg exists as far back as 8086, lock needed for MP only
    // Stack layout immediately after call:
    //
    // 0 [ret addr ] &lt;--- rsp
</pre>
<hr />
<pre>
<span class="line-old-header">*** 600,11 ***</span>
<span class="line-new-header">--- 603,63 ---</span>
  
      __ ret(0);
  
      return start;
    }
<span class="line-added">+   //---------------------------------------------------------------------------------------------------</span>
  
<span class="line-added">+   address generate_vector_mask(const char *stub_name, int32_t mask) {</span>
<span class="line-added">+     __ align(CodeEntryAlignment);</span>
<span class="line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, stub_name);</span>
<span class="line-added">+     address start = __ pc();</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-added">+       __ emit_data(mask, relocInfo::none, 0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return start;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   address generate_vector_mask_long_double(const char *stub_name, int32_t maskhi, int32_t masklo) {</span>
<span class="line-added">+     __ align(CodeEntryAlignment);</span>
<span class="line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, stub_name);</span>
<span class="line-added">+     address start = __ pc();</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (int i = 0; i &lt; 8; i++) {</span>
<span class="line-added">+       __ emit_data(masklo, relocInfo::none, 0);</span>
<span class="line-added">+       __ emit_data(maskhi, relocInfo::none, 0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return start;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   //----------------------------------------------------------------------------------------------------</span>
<span class="line-added">+ </span>
<span class="line-added">+   address generate_vector_byte_perm_mask(const char *stub_name) {</span>
<span class="line-added">+     __ align(CodeEntryAlignment);</span>
<span class="line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, stub_name);</span>
<span class="line-added">+     address start = __ pc();</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ emit_data(0x00000001, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000000, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000003, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000000, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000005, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000000, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000007, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000000, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000000, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000000, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000002, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000000, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000004, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000000, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000006, relocInfo::none, 0);</span>
<span class="line-added">+     __ emit_data(0x00000000, relocInfo::none, 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return start;</span>
<span class="line-added">+   }</span>
  
    //----------------------------------------------------------------------------------------------------
    // Non-destructive plausibility checks for oops
  
    address generate_verify_oop() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 655,12 ***</span>
      __ pop(rdx);                                 // get saved rdx back
      __ popf();                                   // get saved EFLAGS off stack -- will be ignored
      __ pusha();                                  // push registers (eip = return address &amp; msg are already pushed)
      BLOCK_COMMENT(&quot;call MacroAssembler::debug&quot;);
      __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug32)));
<span class="line-modified">!     __ popa();</span>
<span class="line-removed">-     __ ret(3 * wordSize);                        // pop arguments</span>
      return start;
    }
  
  
    // Copy 64 bytes chunks
<span class="line-new-header">--- 710,11 ---</span>
      __ pop(rdx);                                 // get saved rdx back
      __ popf();                                   // get saved EFLAGS off stack -- will be ignored
      __ pusha();                                  // push registers (eip = return address &amp; msg are already pushed)
      BLOCK_COMMENT(&quot;call MacroAssembler::debug&quot;);
      __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug32)));
<span class="line-modified">!     __ hlt();</span>
      return start;
    }
  
  
    // Copy 64 bytes chunks
</pre>
<hr />
<pre>
<span class="line-old-header">*** 834,95 ***</span>
        decorators |= ARRAYCOPY_ALIGNED;
      }
  
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
      bs-&gt;arraycopy_prologue(_masm, decorators, t, from, to, count);
<span class="line-modified">! </span>
<span class="line-modified">!     __ subptr(to, from); // to --&gt; to_from</span>
<span class="line-modified">!     __ cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) copy by element</span>
<span class="line-modified">!     __ jcc(Assembler::below, L_copy_4_bytes); // use unsigned cmp</span>
<span class="line-modified">!     if (!UseUnalignedLoadStores &amp;&amp; !aligned &amp;&amp; (t == T_BYTE || t == T_SHORT)) {</span>
<span class="line-modified">!       // align source address at 4 bytes address boundary</span>
<span class="line-modified">!       if (t == T_BYTE) {</span>
<span class="line-modified">!         // One byte misalignment happens only for byte arrays</span>
<span class="line-modified">!         __ testl(from, 1);</span>
<span class="line-modified">!         __ jccb(Assembler::zero, L_skip_align1);</span>
<span class="line-modified">!         __ movb(rax, Address(from, 0));</span>
<span class="line-modified">!         __ movb(Address(from, to_from, Address::times_1, 0), rax);</span>
<span class="line-modified">!         __ increment(from);</span>
<span class="line-modified">!         __ decrement(count);</span>
<span class="line-modified">!       __ BIND(L_skip_align1);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       // Two bytes misalignment happens only for byte and short (char) arrays</span>
<span class="line-modified">!       __ testl(from, 2);</span>
<span class="line-modified">!       __ jccb(Assembler::zero, L_skip_align2);</span>
<span class="line-modified">!       __ movw(rax, Address(from, 0));</span>
<span class="line-modified">!       __ movw(Address(from, to_from, Address::times_1, 0), rax);</span>
<span class="line-modified">!       __ addptr(from, 2);</span>
<span class="line-modified">!       __ subl(count, 1&lt;&lt;(shift-1));</span>
<span class="line-modified">!     __ BIND(L_skip_align2);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (!VM_Version::supports_mmx()) {</span>
<span class="line-modified">!       __ mov(rax, count);      // save &#39;count&#39;</span>
<span class="line-removed">-       __ shrl(count, shift); // bytes count</span>
<span class="line-removed">-       __ addptr(to_from, from);// restore &#39;to&#39;</span>
<span class="line-removed">-       __ rep_mov();</span>
<span class="line-removed">-       __ subptr(to_from, from);// restore &#39;to_from&#39;</span>
<span class="line-removed">-       __ mov(count, rax);      // restore &#39;count&#39;</span>
<span class="line-removed">-       __ jmpb(L_copy_2_bytes); // all dwords were copied</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       if (!UseUnalignedLoadStores) {</span>
<span class="line-removed">-         // align to 8 bytes, we know we are 4 byte aligned to start</span>
<span class="line-removed">-         __ testptr(from, 4);</span>
<span class="line-removed">-         __ jccb(Assembler::zero, L_copy_64_bytes);</span>
<span class="line-removed">-         __ movl(rax, Address(from, 0));</span>
<span class="line-removed">-         __ movl(Address(from, to_from, Address::times_1, 0), rax);</span>
<span class="line-removed">-         __ addptr(from, 4);</span>
<span class="line-removed">-         __ subl(count, 1&lt;&lt;shift);</span>
        }
<span class="line-modified">!     __ BIND(L_copy_64_bytes);</span>
<span class="line-modified">!       __ mov(rax, count);</span>
<span class="line-modified">!       __ shrl(rax, shift+1);  // 8 bytes chunk count</span>
<span class="line-modified">!       //</span>
<span class="line-modified">!       // Copy 8-byte chunks through MMX registers, 8 per iteration of the loop</span>
<span class="line-modified">!       //</span>
<span class="line-modified">!       if (UseXMMForArrayCopy) {</span>
<span class="line-modified">!         xmm_copy_forward(from, to_from, rax);</span>
        } else {
<span class="line-modified">!         mmx_copy_forward(from, to_from, rax);</span>
        }
<span class="line-modified">!     }</span>
<span class="line-modified">!     // copy tailing dword</span>
<span class="line-modified">!   __ BIND(L_copy_4_bytes);</span>
<span class="line-modified">!     __ testl(count, 1&lt;&lt;shift);</span>
<span class="line-modified">!     __ jccb(Assembler::zero, L_copy_2_bytes);</span>
<span class="line-modified">!     __ movl(rax, Address(from, 0));</span>
<span class="line-modified">!     __ movl(Address(from, to_from, Address::times_1, 0), rax);</span>
<span class="line-modified">!     if (t == T_BYTE || t == T_SHORT) {</span>
<span class="line-modified">!       __ addptr(from, 4);</span>
<span class="line-modified">!     __ BIND(L_copy_2_bytes);</span>
<span class="line-modified">!       // copy tailing word</span>
<span class="line-modified">!       __ testl(count, 1&lt;&lt;(shift-1));</span>
<span class="line-modified">!       __ jccb(Assembler::zero, L_copy_byte);</span>
<span class="line-modified">!       __ movw(rax, Address(from, 0));</span>
<span class="line-modified">!       __ movw(Address(from, to_from, Address::times_1, 0), rax);</span>
<span class="line-modified">!       if (t == T_BYTE) {</span>
<span class="line-modified">!         __ addptr(from, 2);</span>
<span class="line-modified">!       __ BIND(L_copy_byte);</span>
<span class="line-modified">!         // copy tailing byte</span>
<span class="line-modified">!         __ testl(count, 1);</span>
<span class="line-modified">!         __ jccb(Assembler::zero, L_exit);</span>
<span class="line-modified">!         __ movb(rax, Address(from, 0));</span>
<span class="line-modified">!         __ movb(Address(from, to_from, Address::times_1, 0), rax);</span>
<span class="line-modified">!       __ BIND(L_exit);</span>
        } else {
<span class="line-modified">!       __ BIND(L_copy_byte);</span>
        }
<span class="line-removed">-     } else {</span>
<span class="line-removed">-     __ BIND(L_copy_2_bytes);</span>
      }
  
      __ movl(count, Address(rsp, 12+12)); // reread &#39;count&#39;
      bs-&gt;arraycopy_epilogue(_masm, decorators, t, from, to, count);
  
      if (t == T_OBJECT) {
      __ BIND(L_0_count);
<span class="line-new-header">--- 888,102 ---</span>
        decorators |= ARRAYCOPY_ALIGNED;
      }
  
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
      bs-&gt;arraycopy_prologue(_masm, decorators, t, from, to, count);
<span class="line-modified">!     {</span>
<span class="line-modified">!       bool add_entry = (t != T_OBJECT &amp;&amp; (!aligned || t == T_INT));</span>
<span class="line-modified">!       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="line-modified">!       UnsafeCopyMemoryMark ucmm(this, add_entry, true);</span>
<span class="line-modified">!       __ subptr(to, from); // to --&gt; to_from</span>
<span class="line-modified">!       __ cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) copy by element</span>
<span class="line-modified">!       __ jcc(Assembler::below, L_copy_4_bytes); // use unsigned cmp</span>
<span class="line-modified">!       if (!UseUnalignedLoadStores &amp;&amp; !aligned &amp;&amp; (t == T_BYTE || t == T_SHORT)) {</span>
<span class="line-modified">!         // align source address at 4 bytes address boundary</span>
<span class="line-modified">!         if (t == T_BYTE) {</span>
<span class="line-modified">!           // One byte misalignment happens only for byte arrays</span>
<span class="line-modified">!           __ testl(from, 1);</span>
<span class="line-modified">!           __ jccb(Assembler::zero, L_skip_align1);</span>
<span class="line-modified">!           __ movb(rax, Address(from, 0));</span>
<span class="line-modified">!           __ movb(Address(from, to_from, Address::times_1, 0), rax);</span>
<span class="line-modified">!           __ increment(from);</span>
<span class="line-modified">!           __ decrement(count);</span>
<span class="line-modified">!         __ BIND(L_skip_align1);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // Two bytes misalignment happens only for byte and short (char) arrays</span>
<span class="line-modified">!         __ testl(from, 2);</span>
<span class="line-modified">!         __ jccb(Assembler::zero, L_skip_align2);</span>
<span class="line-modified">!         __ movw(rax, Address(from, 0));</span>
<span class="line-modified">!         __ movw(Address(from, to_from, Address::times_1, 0), rax);</span>
<span class="line-modified">!         __ addptr(from, 2);</span>
<span class="line-modified">!         __ subl(count, 1&lt;&lt;(shift-1));</span>
<span class="line-modified">!       __ BIND(L_skip_align2);</span>
        }
<span class="line-modified">!       if (!VM_Version::supports_mmx()) {</span>
<span class="line-modified">!         __ mov(rax, count);      // save &#39;count&#39;</span>
<span class="line-modified">!         __ shrl(count, shift); // bytes count</span>
<span class="line-modified">!         __ addptr(to_from, from);// restore &#39;to&#39;</span>
<span class="line-modified">!         __ rep_mov();</span>
<span class="line-modified">!         __ subptr(to_from, from);// restore &#39;to_from&#39;</span>
<span class="line-modified">!         __ mov(count, rax);      // restore &#39;count&#39;</span>
<span class="line-modified">!         __ jmpb(L_copy_2_bytes); // all dwords were copied</span>
        } else {
<span class="line-modified">!         if (!UseUnalignedLoadStores) {</span>
<span class="line-added">+           // align to 8 bytes, we know we are 4 byte aligned to start</span>
<span class="line-added">+           __ testptr(from, 4);</span>
<span class="line-added">+           __ jccb(Assembler::zero, L_copy_64_bytes);</span>
<span class="line-added">+           __ movl(rax, Address(from, 0));</span>
<span class="line-added">+           __ movl(Address(from, to_from, Address::times_1, 0), rax);</span>
<span class="line-added">+           __ addptr(from, 4);</span>
<span class="line-added">+           __ subl(count, 1&lt;&lt;shift);</span>
<span class="line-added">+          }</span>
<span class="line-added">+       __ BIND(L_copy_64_bytes);</span>
<span class="line-added">+         __ mov(rax, count);</span>
<span class="line-added">+         __ shrl(rax, shift+1);  // 8 bytes chunk count</span>
<span class="line-added">+         //</span>
<span class="line-added">+         // Copy 8-byte chunks through MMX registers, 8 per iteration of the loop</span>
<span class="line-added">+         //</span>
<span class="line-added">+         if (UseXMMForArrayCopy) {</span>
<span class="line-added">+           xmm_copy_forward(from, to_from, rax);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           mmx_copy_forward(from, to_from, rax);</span>
<span class="line-added">+         }</span>
        }
<span class="line-modified">!       // copy tailing dword</span>
<span class="line-modified">!     __ BIND(L_copy_4_bytes);</span>
<span class="line-modified">!       __ testl(count, 1&lt;&lt;shift);</span>
<span class="line-modified">!       __ jccb(Assembler::zero, L_copy_2_bytes);</span>
<span class="line-modified">!       __ movl(rax, Address(from, 0));</span>
<span class="line-modified">!       __ movl(Address(from, to_from, Address::times_1, 0), rax);</span>
<span class="line-modified">!       if (t == T_BYTE || t == T_SHORT) {</span>
<span class="line-modified">!         __ addptr(from, 4);</span>
<span class="line-modified">!       __ BIND(L_copy_2_bytes);</span>
<span class="line-modified">!         // copy tailing word</span>
<span class="line-modified">!         __ testl(count, 1&lt;&lt;(shift-1));</span>
<span class="line-modified">!         __ jccb(Assembler::zero, L_copy_byte);</span>
<span class="line-modified">!         __ movw(rax, Address(from, 0));</span>
<span class="line-modified">!         __ movw(Address(from, to_from, Address::times_1, 0), rax);</span>
<span class="line-modified">!         if (t == T_BYTE) {</span>
<span class="line-modified">!           __ addptr(from, 2);</span>
<span class="line-modified">!         __ BIND(L_copy_byte);</span>
<span class="line-modified">!           // copy tailing byte</span>
<span class="line-modified">!           __ testl(count, 1);</span>
<span class="line-modified">!           __ jccb(Assembler::zero, L_exit);</span>
<span class="line-modified">!           __ movb(rax, Address(from, 0));</span>
<span class="line-modified">!           __ movb(Address(from, to_from, Address::times_1, 0), rax);</span>
<span class="line-modified">!         __ BIND(L_exit);</span>
<span class="line-modified">!         } else {</span>
<span class="line-added">+         __ BIND(L_copy_byte);</span>
<span class="line-added">+         }</span>
        } else {
<span class="line-modified">!       __ BIND(L_copy_2_bytes);</span>
        }
      }
  
<span class="line-added">+     if (VM_Version::supports_mmx() &amp;&amp; !UseXMMForArrayCopy) {</span>
<span class="line-added">+       __ emms();</span>
<span class="line-added">+     }</span>
      __ movl(count, Address(rsp, 12+12)); // reread &#39;count&#39;
      bs-&gt;arraycopy_epilogue(_masm, decorators, t, from, to, count);
  
      if (t == T_OBJECT) {
      __ BIND(L_0_count);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1024,108 ***</span>
      }
  
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
      bs-&gt;arraycopy_prologue(_masm, decorators, t, from, to, count);
  
<span class="line-modified">!     // copy from high to low</span>
<span class="line-modified">!     __ cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) copy by element</span>
<span class="line-modified">!     __ jcc(Assembler::below, L_copy_4_bytes); // use unsigned cmp</span>
<span class="line-modified">!     if (t == T_BYTE || t == T_SHORT) {</span>
<span class="line-modified">!       // Align the end of destination array at 4 bytes address boundary</span>
<span class="line-removed">-       __ lea(end, Address(dst, count, sf, 0));</span>
<span class="line-removed">-       if (t == T_BYTE) {</span>
<span class="line-removed">-         // One byte misalignment happens only for byte arrays</span>
<span class="line-removed">-         __ testl(end, 1);</span>
<span class="line-removed">-         __ jccb(Assembler::zero, L_skip_align1);</span>
<span class="line-removed">-         __ decrement(count);</span>
<span class="line-removed">-         __ movb(rdx, Address(from, count, sf, 0));</span>
<span class="line-removed">-         __ movb(Address(to, count, sf, 0), rdx);</span>
<span class="line-removed">-       __ BIND(L_skip_align1);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       // Two bytes misalignment happens only for byte and short (char) arrays</span>
<span class="line-removed">-       __ testl(end, 2);</span>
<span class="line-removed">-       __ jccb(Assembler::zero, L_skip_align2);</span>
<span class="line-removed">-       __ subptr(count, 1&lt;&lt;(shift-1));</span>
<span class="line-removed">-       __ movw(rdx, Address(from, count, sf, 0));</span>
<span class="line-removed">-       __ movw(Address(to, count, sf, 0), rdx);</span>
<span class="line-removed">-     __ BIND(L_skip_align2);</span>
        __ cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) copy by element
<span class="line-modified">!       __ jcc(Assembler::below, L_copy_4_bytes);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (!VM_Version::supports_mmx()) {</span>
<span class="line-modified">!       __ std();</span>
<span class="line-modified">!       __ mov(rax, count); // Save &#39;count&#39;</span>
<span class="line-modified">!       __ mov(rdx, to);    // Save &#39;to&#39;</span>
<span class="line-modified">!       __ lea(rsi, Address(from, count, sf, -4));</span>
<span class="line-modified">!       __ lea(rdi, Address(to  , count, sf, -4));</span>
<span class="line-modified">!       __ shrptr(count, shift); // bytes count</span>
<span class="line-modified">!       __ rep_mov();</span>
<span class="line-modified">!       __ cld();</span>
<span class="line-modified">!       __ mov(count, rax); // restore &#39;count&#39;</span>
<span class="line-modified">!       __ andl(count, (1&lt;&lt;shift)-1);      // mask the number of rest elements</span>
<span class="line-modified">!       __ movptr(from, Address(rsp, 12+4)); // reread &#39;from&#39;</span>
<span class="line-modified">!       __ mov(to, rdx);   // restore &#39;to&#39;</span>
<span class="line-modified">!       __ jmpb(L_copy_2_bytes); // all dword were copied</span>
<span class="line-modified">!    } else {</span>
<span class="line-modified">!       // Align to 8 bytes the end of array. It is aligned to 4 bytes already.</span>
<span class="line-modified">!       __ testptr(end, 4);</span>
<span class="line-modified">!       __ jccb(Assembler::zero, L_copy_8_bytes);</span>
<span class="line-modified">!       __ subl(count, 1&lt;&lt;shift);</span>
<span class="line-modified">!       __ movl(rdx, Address(from, count, sf, 0));</span>
<span class="line-removed">-       __ movl(Address(to, count, sf, 0), rdx);</span>
<span class="line-removed">-       __ jmpb(L_copy_8_bytes);</span>
  
<span class="line-modified">!       __ align(OptoLoopAlignment);</span>
<span class="line-modified">!       // Move 8 bytes</span>
<span class="line-modified">!     __ BIND(L_copy_8_bytes_loop);</span>
<span class="line-modified">!       if (UseXMMForArrayCopy) {</span>
<span class="line-modified">!         __ movq(xmm0, Address(from, count, sf, 0));</span>
<span class="line-modified">!         __ movq(Address(to, count, sf, 0), xmm0);</span>
        } else {
<span class="line-modified">!         __ movq(mmx0, Address(from, count, sf, 0));</span>
<span class="line-modified">!         __ movq(Address(to, count, sf, 0), mmx0);</span>
        }
<span class="line-modified">!     __ BIND(L_copy_8_bytes);</span>
<span class="line-modified">!       __ subl(count, 2&lt;&lt;shift);</span>
<span class="line-modified">!       __ jcc(Assembler::greaterEqual, L_copy_8_bytes_loop);</span>
<span class="line-modified">!       __ addl(count, 2&lt;&lt;shift);</span>
<span class="line-modified">!       if (!UseXMMForArrayCopy) {</span>
<span class="line-modified">!         __ emms();</span>
        }
      }
<span class="line-removed">-   __ BIND(L_copy_4_bytes);</span>
<span class="line-removed">-     // copy prefix qword</span>
<span class="line-removed">-     __ testl(count, 1&lt;&lt;shift);</span>
<span class="line-removed">-     __ jccb(Assembler::zero, L_copy_2_bytes);</span>
<span class="line-removed">-     __ movl(rdx, Address(from, count, sf, -4));</span>
<span class="line-removed">-     __ movl(Address(to, count, sf, -4), rdx);</span>
  
<span class="line-modified">!     if (t == T_BYTE || t == T_SHORT) {</span>
<span class="line-modified">!         __ subl(count, (1&lt;&lt;shift));</span>
<span class="line-removed">-       __ BIND(L_copy_2_bytes);</span>
<span class="line-removed">-         // copy prefix dword</span>
<span class="line-removed">-         __ testl(count, 1&lt;&lt;(shift-1));</span>
<span class="line-removed">-         __ jccb(Assembler::zero, L_copy_byte);</span>
<span class="line-removed">-         __ movw(rdx, Address(from, count, sf, -2));</span>
<span class="line-removed">-         __ movw(Address(to, count, sf, -2), rdx);</span>
<span class="line-removed">-         if (t == T_BYTE) {</span>
<span class="line-removed">-           __ subl(count, 1&lt;&lt;(shift-1));</span>
<span class="line-removed">-         __ BIND(L_copy_byte);</span>
<span class="line-removed">-           // copy prefix byte</span>
<span class="line-removed">-           __ testl(count, 1);</span>
<span class="line-removed">-           __ jccb(Assembler::zero, L_exit);</span>
<span class="line-removed">-           __ movb(rdx, Address(from, 0));</span>
<span class="line-removed">-           __ movb(Address(to, 0), rdx);</span>
<span class="line-removed">-         __ BIND(L_exit);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-         __ BIND(L_copy_byte);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-     __ BIND(L_copy_2_bytes);</span>
      }
<span class="line-removed">- </span>
      __ movl2ptr(count, Address(rsp, 12+12)); // reread count
      bs-&gt;arraycopy_epilogue(_masm, decorators, t, from, to, count);
  
      if (t == T_OBJECT) {
      __ BIND(L_0_count);
<span class="line-new-header">--- 1085,116 ---</span>
      }
  
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
      bs-&gt;arraycopy_prologue(_masm, decorators, t, from, to, count);
  
<span class="line-modified">!     {</span>
<span class="line-modified">!       bool add_entry = (t != T_OBJECT &amp;&amp; (!aligned || t == T_INT));</span>
<span class="line-modified">!       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="line-modified">!       UnsafeCopyMemoryMark ucmm(this, add_entry, true);</span>
<span class="line-modified">!       // copy from high to low</span>
        __ cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) copy by element
<span class="line-modified">!       __ jcc(Assembler::below, L_copy_4_bytes); // use unsigned cmp</span>
<span class="line-modified">!       if (t == T_BYTE || t == T_SHORT) {</span>
<span class="line-modified">!         // Align the end of destination array at 4 bytes address boundary</span>
<span class="line-modified">!         __ lea(end, Address(dst, count, sf, 0));</span>
<span class="line-modified">!         if (t == T_BYTE) {</span>
<span class="line-modified">!           // One byte misalignment happens only for byte arrays</span>
<span class="line-modified">!           __ testl(end, 1);</span>
<span class="line-modified">!           __ jccb(Assembler::zero, L_skip_align1);</span>
<span class="line-modified">!           __ decrement(count);</span>
<span class="line-modified">!           __ movb(rdx, Address(from, count, sf, 0));</span>
<span class="line-modified">!           __ movb(Address(to, count, sf, 0), rdx);</span>
<span class="line-modified">!         __ BIND(L_skip_align1);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // Two bytes misalignment happens only for byte and short (char) arrays</span>
<span class="line-modified">!         __ testl(end, 2);</span>
<span class="line-modified">!         __ jccb(Assembler::zero, L_skip_align2);</span>
<span class="line-modified">!         __ subptr(count, 1&lt;&lt;(shift-1));</span>
<span class="line-modified">!         __ movw(rdx, Address(from, count, sf, 0));</span>
<span class="line-modified">!         __ movw(Address(to, count, sf, 0), rdx);</span>
<span class="line-modified">!       __ BIND(L_skip_align2);</span>
<span class="line-modified">!         __ cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) copy by element</span>
<span class="line-modified">!         __ jcc(Assembler::below, L_copy_4_bytes);</span>
<span class="line-modified">!       }</span>
  
<span class="line-modified">!       if (!VM_Version::supports_mmx()) {</span>
<span class="line-modified">!         __ std();</span>
<span class="line-modified">!         __ mov(rax, count); // Save &#39;count&#39;</span>
<span class="line-modified">!         __ mov(rdx, to);    // Save &#39;to&#39;</span>
<span class="line-modified">!         __ lea(rsi, Address(from, count, sf, -4));</span>
<span class="line-modified">!         __ lea(rdi, Address(to  , count, sf, -4));</span>
<span class="line-added">+         __ shrptr(count, shift); // bytes count</span>
<span class="line-added">+         __ rep_mov();</span>
<span class="line-added">+         __ cld();</span>
<span class="line-added">+         __ mov(count, rax); // restore &#39;count&#39;</span>
<span class="line-added">+         __ andl(count, (1&lt;&lt;shift)-1);      // mask the number of rest elements</span>
<span class="line-added">+         __ movptr(from, Address(rsp, 12+4)); // reread &#39;from&#39;</span>
<span class="line-added">+         __ mov(to, rdx);   // restore &#39;to&#39;</span>
<span class="line-added">+         __ jmpb(L_copy_2_bytes); // all dword were copied</span>
        } else {
<span class="line-modified">!         // Align to 8 bytes the end of array. It is aligned to 4 bytes already.</span>
<span class="line-modified">!         __ testptr(end, 4);</span>
<span class="line-added">+         __ jccb(Assembler::zero, L_copy_8_bytes);</span>
<span class="line-added">+         __ subl(count, 1&lt;&lt;shift);</span>
<span class="line-added">+         __ movl(rdx, Address(from, count, sf, 0));</span>
<span class="line-added">+         __ movl(Address(to, count, sf, 0), rdx);</span>
<span class="line-added">+         __ jmpb(L_copy_8_bytes);</span>
<span class="line-added">+ </span>
<span class="line-added">+         __ align(OptoLoopAlignment);</span>
<span class="line-added">+         // Move 8 bytes</span>
<span class="line-added">+       __ BIND(L_copy_8_bytes_loop);</span>
<span class="line-added">+         if (UseXMMForArrayCopy) {</span>
<span class="line-added">+           __ movq(xmm0, Address(from, count, sf, 0));</span>
<span class="line-added">+           __ movq(Address(to, count, sf, 0), xmm0);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           __ movq(mmx0, Address(from, count, sf, 0));</span>
<span class="line-added">+           __ movq(Address(to, count, sf, 0), mmx0);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       __ BIND(L_copy_8_bytes);</span>
<span class="line-added">+         __ subl(count, 2&lt;&lt;shift);</span>
<span class="line-added">+         __ jcc(Assembler::greaterEqual, L_copy_8_bytes_loop);</span>
<span class="line-added">+         __ addl(count, 2&lt;&lt;shift);</span>
<span class="line-added">+         if (!UseXMMForArrayCopy) {</span>
<span class="line-added">+           __ emms();</span>
<span class="line-added">+         }</span>
        }
<span class="line-modified">!     __ BIND(L_copy_4_bytes);</span>
<span class="line-modified">!       // copy prefix qword</span>
<span class="line-modified">!       __ testl(count, 1&lt;&lt;shift);</span>
<span class="line-modified">!       __ jccb(Assembler::zero, L_copy_2_bytes);</span>
<span class="line-modified">!       __ movl(rdx, Address(from, count, sf, -4));</span>
<span class="line-modified">!       __ movl(Address(to, count, sf, -4), rdx);</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (t == T_BYTE || t == T_SHORT) {</span>
<span class="line-added">+           __ subl(count, (1&lt;&lt;shift));</span>
<span class="line-added">+         __ BIND(L_copy_2_bytes);</span>
<span class="line-added">+           // copy prefix dword</span>
<span class="line-added">+           __ testl(count, 1&lt;&lt;(shift-1));</span>
<span class="line-added">+           __ jccb(Assembler::zero, L_copy_byte);</span>
<span class="line-added">+           __ movw(rdx, Address(from, count, sf, -2));</span>
<span class="line-added">+           __ movw(Address(to, count, sf, -2), rdx);</span>
<span class="line-added">+           if (t == T_BYTE) {</span>
<span class="line-added">+             __ subl(count, 1&lt;&lt;(shift-1));</span>
<span class="line-added">+           __ BIND(L_copy_byte);</span>
<span class="line-added">+             // copy prefix byte</span>
<span class="line-added">+             __ testl(count, 1);</span>
<span class="line-added">+             __ jccb(Assembler::zero, L_exit);</span>
<span class="line-added">+             __ movb(rdx, Address(from, 0));</span>
<span class="line-added">+             __ movb(Address(to, 0), rdx);</span>
<span class="line-added">+           __ BIND(L_exit);</span>
<span class="line-added">+           } else {</span>
<span class="line-added">+           __ BIND(L_copy_byte);</span>
<span class="line-added">+           }</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+       __ BIND(L_copy_2_bytes);</span>
        }
      }
  
<span class="line-modified">!     if (VM_Version::supports_mmx() &amp;&amp; !UseXMMForArrayCopy) {</span>
<span class="line-modified">!       __ emms();</span>
      }
      __ movl2ptr(count, Address(rsp, 12+12)); // reread count
      bs-&gt;arraycopy_epilogue(_masm, decorators, t, from, to, count);
  
      if (t == T_OBJECT) {
      __ BIND(L_0_count);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1157,27 ***</span>
      __ movl2ptr(count, Address(rsp, 8+8));     // count
  
      *entry = __ pc(); // Entry point from conjoint arraycopy stub.
      BLOCK_COMMENT(&quot;Entry:&quot;);
  
<span class="line-modified">!     __ subptr(to, from); // to --&gt; to_from</span>
<span class="line-modified">!     if (VM_Version::supports_mmx()) {</span>
<span class="line-modified">!       if (UseXMMForArrayCopy) {</span>
<span class="line-modified">!         xmm_copy_forward(from, to_from, count);</span>
        } else {
<span class="line-modified">!         mmx_copy_forward(from, to_from, count);</span>
        }
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       __ jmpb(L_copy_8_bytes);</span>
<span class="line-modified">!       __ align(OptoLoopAlignment);</span>
<span class="line-removed">-     __ BIND(L_copy_8_bytes_loop);</span>
<span class="line-removed">-       __ fild_d(Address(from, 0));</span>
<span class="line-removed">-       __ fistp_d(Address(from, to_from, Address::times_1));</span>
<span class="line-removed">-       __ addptr(from, 8);</span>
<span class="line-removed">-     __ BIND(L_copy_8_bytes);</span>
<span class="line-removed">-       __ decrement(count);</span>
<span class="line-removed">-       __ jcc(Assembler::greaterEqual, L_copy_8_bytes_loop);</span>
      }
      inc_copy_counter_np(T_LONG);
      __ leave(); // required for proper stackwalking of RuntimeStub frame
      __ vzeroupper();
      __ xorptr(rax, rax); // return 0
<span class="line-new-header">--- 1226,34 ---</span>
      __ movl2ptr(count, Address(rsp, 8+8));     // count
  
      *entry = __ pc(); // Entry point from conjoint arraycopy stub.
      BLOCK_COMMENT(&quot;Entry:&quot;);
  
<span class="line-modified">!     {</span>
<span class="line-modified">!       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="line-modified">!       UnsafeCopyMemoryMark ucmm(this, true, true);</span>
<span class="line-modified">!       __ subptr(to, from); // to --&gt; to_from</span>
<span class="line-added">+       if (VM_Version::supports_mmx()) {</span>
<span class="line-added">+         if (UseXMMForArrayCopy) {</span>
<span class="line-added">+           xmm_copy_forward(from, to_from, count);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           mmx_copy_forward(from, to_from, count);</span>
<span class="line-added">+         }</span>
        } else {
<span class="line-modified">!         __ jmpb(L_copy_8_bytes);</span>
<span class="line-added">+         __ align(OptoLoopAlignment);</span>
<span class="line-added">+       __ BIND(L_copy_8_bytes_loop);</span>
<span class="line-added">+         __ fild_d(Address(from, 0));</span>
<span class="line-added">+         __ fistp_d(Address(from, to_from, Address::times_1));</span>
<span class="line-added">+         __ addptr(from, 8);</span>
<span class="line-added">+       __ BIND(L_copy_8_bytes);</span>
<span class="line-added">+         __ decrement(count);</span>
<span class="line-added">+         __ jcc(Assembler::greaterEqual, L_copy_8_bytes_loop);</span>
        }
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (VM_Version::supports_mmx() &amp;&amp; !UseXMMForArrayCopy) {</span>
<span class="line-modified">!       __ emms();</span>
      }
      inc_copy_counter_np(T_LONG);
      __ leave(); // required for proper stackwalking of RuntimeStub frame
      __ vzeroupper();
      __ xorptr(rax, rax); // return 0
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1212,30 ***</span>
      __ lea(end_from, Address(from, count, Address::times_8, 0));
      __ cmpptr(to, end_from);
      __ movptr(from, Address(rsp, 8));  // from
      __ jump_cc(Assembler::aboveEqual, nooverlap);
  
<span class="line-modified">!     __ jmpb(L_copy_8_bytes);</span>
  
<span class="line-modified">!     __ align(OptoLoopAlignment);</span>
<span class="line-modified">!   __ BIND(L_copy_8_bytes_loop);</span>
<span class="line-modified">!     if (VM_Version::supports_mmx()) {</span>
<span class="line-modified">!       if (UseXMMForArrayCopy) {</span>
<span class="line-modified">!         __ movq(xmm0, Address(from, count, Address::times_8));</span>
<span class="line-modified">!         __ movq(Address(to, count, Address::times_8), xmm0);</span>
        } else {
<span class="line-modified">!         __ movq(mmx0, Address(from, count, Address::times_8));</span>
<span class="line-modified">!         __ movq(Address(to, count, Address::times_8), mmx0);</span>
        }
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       __ fild_d(Address(from, count, Address::times_8));</span>
<span class="line-modified">!       __ fistp_d(Address(to, count, Address::times_8));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   __ BIND(L_copy_8_bytes);</span>
<span class="line-removed">-     __ decrement(count);</span>
<span class="line-removed">-     __ jcc(Assembler::greaterEqual, L_copy_8_bytes_loop);</span>
  
      if (VM_Version::supports_mmx() &amp;&amp; !UseXMMForArrayCopy) {
        __ emms();
      }
      inc_copy_counter_np(T_LONG);
      __ leave(); // required for proper stackwalking of RuntimeStub frame
<span class="line-new-header">--- 1288,35 ---</span>
      __ lea(end_from, Address(from, count, Address::times_8, 0));
      __ cmpptr(to, end_from);
      __ movptr(from, Address(rsp, 8));  // from
      __ jump_cc(Assembler::aboveEqual, nooverlap);
  
<span class="line-modified">!     {</span>
<span class="line-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="line-added">+       UnsafeCopyMemoryMark ucmm(this, true, true);</span>
  
<span class="line-modified">!       __ jmpb(L_copy_8_bytes);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       __ align(OptoLoopAlignment);</span>
<span class="line-modified">!     __ BIND(L_copy_8_bytes_loop);</span>
<span class="line-modified">!       if (VM_Version::supports_mmx()) {</span>
<span class="line-modified">!         if (UseXMMForArrayCopy) {</span>
<span class="line-added">+           __ movq(xmm0, Address(from, count, Address::times_8));</span>
<span class="line-added">+           __ movq(Address(to, count, Address::times_8), xmm0);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           __ movq(mmx0, Address(from, count, Address::times_8));</span>
<span class="line-added">+           __ movq(Address(to, count, Address::times_8), mmx0);</span>
<span class="line-added">+         }</span>
        } else {
<span class="line-modified">!         __ fild_d(Address(from, count, Address::times_8));</span>
<span class="line-modified">!         __ fistp_d(Address(to, count, Address::times_8));</span>
        }
<span class="line-modified">!     __ BIND(L_copy_8_bytes);</span>
<span class="line-modified">!       __ decrement(count);</span>
<span class="line-modified">!       __ jcc(Assembler::greaterEqual, L_copy_8_bytes_loop);</span>
  
<span class="line-added">+     }</span>
      if (VM_Version::supports_mmx() &amp;&amp; !UseXMMForArrayCopy) {
        __ emms();
      }
      inc_copy_counter_np(T_LONG);
      __ leave(); // required for proper stackwalking of RuntimeStub frame
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2966,26 ***</span>
      const XMMRegister msg3 = xmm6;
      const XMMRegister shuf_mask = xmm7;
  
      __ enter();
      __ subptr(rsp, 8 * wordSize);
<span class="line-modified">!     if (multi_block) {</span>
<span class="line-modified">!       __ push(limit);</span>
<span class="line-removed">-     }</span>
      __ movptr(buf, buf_param);
      __ movptr(state, state_param);
      if (multi_block) {
        __ movptr(ofs, ofs_param);
        __ movptr(limit, limit_param);
      }
  
      __ fast_sha1(abcd, e0, e1, msg0, msg1, msg2, msg3, shuf_mask,
        buf, state, ofs, limit, rsp, multi_block);
  
<span class="line-modified">!     if (multi_block) {</span>
<span class="line-removed">-       __ pop(limit);</span>
<span class="line-removed">-     }</span>
      __ addptr(rsp, 8 * wordSize);
      __ leave();
      __ ret(0);
      return start;
    }
<span class="line-new-header">--- 3047,23 ---</span>
      const XMMRegister msg3 = xmm6;
      const XMMRegister shuf_mask = xmm7;
  
      __ enter();
      __ subptr(rsp, 8 * wordSize);
<span class="line-modified">!     handleSOERegisters(true /*saving*/);</span>
<span class="line-modified">! </span>
      __ movptr(buf, buf_param);
      __ movptr(state, state_param);
      if (multi_block) {
        __ movptr(ofs, ofs_param);
        __ movptr(limit, limit_param);
      }
  
      __ fast_sha1(abcd, e0, e1, msg0, msg1, msg2, msg3, shuf_mask,
        buf, state, ofs, limit, rsp, multi_block);
  
<span class="line-modified">!     handleSOERegisters(false /*restoring*/);</span>
      __ addptr(rsp, 8 * wordSize);
      __ leave();
      __ ret(0);
      return start;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3584,10 ***</span>
<span class="line-new-header">--- 3662,72 ---</span>
      // Return errValue or *adr.
      *continuation_pc = __ pc();
      __ ret(0);
    }
  
<span class="line-added">+   address generate_method_entry_barrier() {</span>
<span class="line-added">+     __ align(CodeEntryAlignment);</span>
<span class="line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;nmethod_entry_barrier&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Label deoptimize_label;</span>
<span class="line-added">+ </span>
<span class="line-added">+     address start = __ pc();</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ push(-1); // cookie, this is used for writing the new rsp when deoptimizing</span>
<span class="line-added">+ </span>
<span class="line-added">+     BLOCK_COMMENT(&quot;Entry:&quot;);</span>
<span class="line-added">+     __ enter(); // save rbp</span>
<span class="line-added">+ </span>
<span class="line-added">+     // save rbx, because we want to use that value.</span>
<span class="line-added">+     // We could do without it but then we depend on the number of slots used by pusha</span>
<span class="line-added">+     __ push(rbx);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ lea(rbx, Address(rsp, wordSize * 3)); // 1 for cookie, 1 for rbp, 1 for rbx - this should be the return address</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ pusha();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // xmm0 and xmm1 may be used for passing float/double arguments</span>
<span class="line-added">+     const int xmm_size = wordSize * 2;</span>
<span class="line-added">+     const int xmm_spill_size = xmm_size * 2;</span>
<span class="line-added">+     __ subptr(rsp, xmm_spill_size);</span>
<span class="line-added">+     __ movdqu(Address(rsp, xmm_size * 1), xmm1);</span>
<span class="line-added">+     __ movdqu(Address(rsp, xmm_size * 0), xmm0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast&lt;int (*)(address*)&gt;(BarrierSetNMethod::nmethod_stub_entry_barrier)), rbx);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ movdqu(xmm0, Address(rsp, xmm_size * 0));</span>
<span class="line-added">+     __ movdqu(xmm1, Address(rsp, xmm_size * 1));</span>
<span class="line-added">+     __ addptr(rsp, xmm_spill_size);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ cmpl(rax, 1); // 1 means deoptimize</span>
<span class="line-added">+     __ jcc(Assembler::equal, deoptimize_label);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ popa();</span>
<span class="line-added">+     __ pop(rbx);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ leave();</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ addptr(rsp, 1 * wordSize); // cookie</span>
<span class="line-added">+     __ ret(0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ BIND(deoptimize_label);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ popa();</span>
<span class="line-added">+     __ pop(rbx);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ leave();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // this can be taken out, but is good for verification purposes. getting a SIGSEGV</span>
<span class="line-added">+     // here while still having a correct stack is valuable</span>
<span class="line-added">+     __ testptr(rsp, Address(rsp, 0));</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ movptr(rsp, Address(rsp, 0)); // new rsp was written in the barrier</span>
<span class="line-added">+     __ jmp(Address(rsp, -1 * wordSize)); // jmp target should be callers verified_entry_point</span>
<span class="line-added">+ </span>
<span class="line-added">+     return start;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
   public:
    // Information about frame layout at time of blocking runtime call.
    // Note that we only have to preserve callee-saved registers since
    // the compilers are responsible for supplying a continuation point
    // if they expect all registers to be preserved.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3824,10 ***</span>
<span class="line-new-header">--- 3964,18 ---</span>
      StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(&quot;NullPointerException at call throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));
  
      //------------------------------------------------------------------------------------------------------------------------
      // entry points that are platform specific
  
<span class="line-added">+     StubRoutines::x86::_vector_float_sign_mask = generate_vector_mask(&quot;vector_float_sign_mask&quot;, 0x7FFFFFFF);</span>
<span class="line-added">+     StubRoutines::x86::_vector_float_sign_flip = generate_vector_mask(&quot;vector_float_sign_flip&quot;, 0x80000000);</span>
<span class="line-added">+     StubRoutines::x86::_vector_double_sign_mask = generate_vector_mask_long_double(&quot;vector_double_sign_mask&quot;, 0x7FFFFFFF, 0xFFFFFFFF);</span>
<span class="line-added">+     StubRoutines::x86::_vector_double_sign_flip = generate_vector_mask_long_double(&quot;vector_double_sign_flip&quot;, 0x80000000, 0x00000000);</span>
<span class="line-added">+     StubRoutines::x86::_vector_short_to_byte_mask = generate_vector_mask(&quot;vector_short_to_byte_mask&quot;, 0x00ff00ff);</span>
<span class="line-added">+     StubRoutines::x86::_vector_byte_perm_mask = generate_vector_byte_perm_mask(&quot;vector_byte_perm_mask&quot;);</span>
<span class="line-added">+     StubRoutines::x86::_vector_long_sign_mask = generate_vector_mask_long_double(&quot;vector_long_sign_mask&quot;, 0x80000000, 0x00000000);</span>
<span class="line-added">+ </span>
      // support for verify_oop (must happen after universe_init)
      StubRoutines::_verify_oop_subroutine_entry     = generate_verify_oop();
  
      // arraycopy stubs used by compilers
      generate_arraycopy_stubs();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3872,10 ***</span>
<span class="line-new-header">--- 4020,15 ---</span>
                                                     &amp;StubRoutines::_safefetch32_fault_pc,
                                                     &amp;StubRoutines::_safefetch32_continuation_pc);
      StubRoutines::_safefetchN_entry           = StubRoutines::_safefetch32_entry;
      StubRoutines::_safefetchN_fault_pc        = StubRoutines::_safefetch32_fault_pc;
      StubRoutines::_safefetchN_continuation_pc = StubRoutines::_safefetch32_continuation_pc;
<span class="line-added">+ </span>
<span class="line-added">+     BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()-&gt;barrier_set_nmethod();</span>
<span class="line-added">+     if (bs_nm != NULL) {</span>
<span class="line-added">+       StubRoutines::x86::_method_entry_barrier = generate_method_entry_barrier();</span>
<span class="line-added">+     }</span>
    }
  
  
   public:
    StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3885,9 ***</span>
        generate_initial();
      }
    }
  }; // end class declaration
  
<span class="line-modified">! </span>
  void StubGenerator_generate(CodeBuffer* code, bool all) {
    StubGenerator g(code, all);
  }
<span class="line-new-header">--- 4038,12 ---</span>
        generate_initial();
      }
    }
  }; // end class declaration
  
<span class="line-modified">! #define UCM_TABLE_MAX_ENTRIES 8</span>
  void StubGenerator_generate(CodeBuffer* code, bool all) {
<span class="line-added">+   if (UnsafeCopyMemory::_table == NULL) {</span>
<span class="line-added">+     UnsafeCopyMemory::create_table(UCM_TABLE_MAX_ENTRIES);</span>
<span class="line-added">+   }</span>
    StubGenerator g(code, all);
  }
</pre>
<center><a href="sharedRuntime_x86_64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
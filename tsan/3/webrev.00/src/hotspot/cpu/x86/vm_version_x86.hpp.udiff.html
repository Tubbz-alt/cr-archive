<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/vm_version_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vm_version_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86.ad.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/vm_version_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,12 +23,13 @@</span>
   */
  
  #ifndef CPU_X86_VM_VERSION_X86_HPP
  #define CPU_X86_VM_VERSION_X86_HPP
  
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;runtime/abstract_vm_version.hpp&quot;</span>
  #include &quot;runtime/globals_extension.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/vm_version.hpp&quot;</span>
  
  class VM_Version : public Abstract_VM_Version {
    friend class VMStructs;
    friend class JVMCIVMStructs;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -216,11 +217,14 @@</span>
                          : 4,
                  avx512f : 1,
                 avx512dq : 1,
                          : 1,
                      adx : 1,
<span class="udiff-line-modified-removed">-                         : 6,</span>
<span class="udiff-line-modified-added">+                         : 3,</span>
<span class="udiff-line-added">+              clflushopt : 1,</span>
<span class="udiff-line-added">+                    clwb : 1,</span>
<span class="udiff-line-added">+                         : 1,</span>
                 avx512pf : 1,
                 avx512er : 1,
                 avx512cd : 1,
                      sha : 1,
                 avx512bw : 1,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -239,11 +243,11 @@</span>
                             : 1,
                avx512_vbmi2 : 1,
                             : 1,
                        gfni : 1,
                        vaes : 1,
<span class="udiff-line-modified-removed">-                 vpclmulqdq : 1,</span>
<span class="udiff-line-modified-added">+          avx512_vpclmulqdq : 1,</span>
                 avx512_vnni : 1,
               avx512_bitalg : 1,
                             : 1,
            avx512_vpopcntdq : 1,
                             : 17;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -332,15 +336,21 @@</span>
  #define CPU_AVX512VL ((uint64_t)UCONST64(0x200000000)) // EVEX instructions with smaller vector length
  #define CPU_SHA ((uint64_t)UCONST64(0x400000000))      // SHA instructions
  #define CPU_FMA ((uint64_t)UCONST64(0x800000000))      // FMA instructions
  #define CPU_VZEROUPPER ((uint64_t)UCONST64(0x1000000000))       // Vzeroupper instruction
  #define CPU_AVX512_VPOPCNTDQ ((uint64_t)UCONST64(0x2000000000)) // Vector popcount
<span class="udiff-line-modified-removed">- #define CPU_VPCLMULQDQ ((uint64_t)UCONST64(0x4000000000)) //Vector carryless multiplication</span>
<span class="udiff-line-modified-added">+ #define CPU_AVX512_VPCLMULQDQ ((uint64_t)UCONST64(0x4000000000)) //Vector carryless multiplication</span>
  #define CPU_VAES ((uint64_t)UCONST64(0x8000000000))    // Vector AES instructions
  #define CPU_VNNI ((uint64_t)UCONST64(0x10000000000))   // Vector Neural Network Instructions
  
<span class="udiff-line-modified-removed">-   enum Extended_Family {</span>
<span class="udiff-line-modified-added">+ #define CPU_FLUSH ((uint64_t)UCONST64(0x20000000000))  // flush instruction</span>
<span class="udiff-line-added">+ #define CPU_FLUSHOPT ((uint64_t)UCONST64(0x40000000000)) // flushopt instruction</span>
<span class="udiff-line-added">+ #define CPU_CLWB ((uint64_t)UCONST64(0x80000000000))   // clwb instruction</span>
<span class="udiff-line-added">+ #define CPU_VBMI2 ((uint64_t)UCONST64(0x100000000000))   // VBMI2 shift left double instructions</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ enum Extended_Family {</span>
      // AMD
      CPU_FAMILY_AMD_11H       = 0x11,
      // ZX
      CPU_FAMILY_ZX_CORE_F6    = 6,
      CPU_FAMILY_ZX_CORE_F7    = 7,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -356,11 +366,11 @@</span>
      CPU_MODEL_SANDYBRIDGE_EP = 0x2d,
      CPU_MODEL_IVYBRIDGE_EP   = 0x3a,
      CPU_MODEL_HASWELL_E3     = 0x3c,
      CPU_MODEL_HASWELL_E7     = 0x3f,
      CPU_MODEL_BROADWELL      = 0x3d,
<span class="udiff-line-modified-removed">-     CPU_MODEL_SKYLAKE        = CPU_MODEL_HASWELL_E3</span>
<span class="udiff-line-modified-added">+     CPU_MODEL_SKYLAKE        = 0x55</span>
    };
  
    // cpuid information block.  All info derived from executing cpuid with
    // various function numbers is stored here.  Intel and AMD info is
    // merged in this block: accessor methods disentangle it.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -493,17 +503,25 @@</span>
      uint64_t result = 0;
      if (_cpuid_info.std_cpuid1_edx.bits.cmpxchg8 != 0)
        result |= CPU_CX8;
      if (_cpuid_info.std_cpuid1_edx.bits.cmov != 0)
        result |= CPU_CMOV;
<span class="udiff-line-modified-removed">-     if (_cpuid_info.std_cpuid1_edx.bits.fxsr != 0 || (is_amd() &amp;&amp;</span>
<span class="udiff-line-modified-added">+     if (_cpuid_info.std_cpuid1_edx.bits.clflush != 0)</span>
<span class="udiff-line-added">+       result |= CPU_FLUSH;</span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+     // clflush should always be available on x86_64</span>
<span class="udiff-line-added">+     // if not we are in real trouble because we rely on it</span>
<span class="udiff-line-added">+     // to flush the code cache.</span>
<span class="udiff-line-added">+     assert ((result &amp; CPU_FLUSH) != 0, &quot;clflush should be available&quot;);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     if (_cpuid_info.std_cpuid1_edx.bits.fxsr != 0 || (is_amd_family() &amp;&amp;</span>
          _cpuid_info.ext_cpuid1_edx.bits.fxsr != 0))
        result |= CPU_FXSR;
      // HT flag is set for multi-core processors also.
      if (threads_per_core() &gt; 1)
        result |= CPU_HT;
<span class="udiff-line-modified-removed">-     if (_cpuid_info.std_cpuid1_edx.bits.mmx != 0 || (is_amd() &amp;&amp;</span>
<span class="udiff-line-modified-added">+     if (_cpuid_info.std_cpuid1_edx.bits.mmx != 0 || (is_amd_family() &amp;&amp;</span>
          _cpuid_info.ext_cpuid1_edx.bits.mmx != 0))
        result |= CPU_MMX;
      if (_cpuid_info.std_cpuid1_edx.bits.sse != 0)
        result |= CPU_SSE;
      if (_cpuid_info.std_cpuid1_edx.bits.sse2 != 0)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -543,19 +561,21 @@</span>
            result |= CPU_AVX512BW;
          if (_cpuid_info.sef_cpuid7_ebx.bits.avx512vl != 0)
            result |= CPU_AVX512VL;
          if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpopcntdq != 0)
            result |= CPU_AVX512_VPOPCNTDQ;
<span class="udiff-line-modified-removed">-         if (_cpuid_info.sef_cpuid7_ecx.bits.vpclmulqdq != 0)</span>
<span class="udiff-line-modified-removed">-           result |= CPU_VPCLMULQDQ;</span>
<span class="udiff-line-modified-added">+         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpclmulqdq != 0)</span>
<span class="udiff-line-modified-added">+           result |= CPU_AVX512_VPCLMULQDQ;</span>
          if (_cpuid_info.sef_cpuid7_ecx.bits.vaes != 0)
            result |= CPU_VAES;
          if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vnni != 0)
            result |= CPU_VNNI;
<span class="udiff-line-added">+         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vbmi2 != 0)</span>
<span class="udiff-line-added">+           result |= CPU_VBMI2;</span>
        }
      }
<span class="udiff-line-modified-removed">-     if(_cpuid_info.sef_cpuid7_ebx.bits.bmi1 != 0)</span>
<span class="udiff-line-modified-added">+     if (_cpuid_info.sef_cpuid7_ebx.bits.bmi1 != 0)</span>
        result |= CPU_BMI1;
      if (_cpuid_info.std_cpuid1_edx.bits.tsc != 0)
        result |= CPU_TSC;
      if (_cpuid_info.ext_cpuid7_edx.bits.tsc_invariance != 0)
        result |= CPU_TSCINV;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -565,37 +585,42 @@</span>
        result |= CPU_ERMS;
      if (_cpuid_info.std_cpuid1_ecx.bits.clmul != 0)
        result |= CPU_CLMUL;
      if (_cpuid_info.sef_cpuid7_ebx.bits.rtm != 0)
        result |= CPU_RTM;
<span class="udiff-line-modified-removed">-     if(_cpuid_info.sef_cpuid7_ebx.bits.adx != 0)</span>
<span class="udiff-line-modified-added">+     if (_cpuid_info.sef_cpuid7_ebx.bits.adx != 0)</span>
         result |= CPU_ADX;
<span class="udiff-line-modified-removed">-     if(_cpuid_info.sef_cpuid7_ebx.bits.bmi2 != 0)</span>
<span class="udiff-line-modified-added">+     if (_cpuid_info.sef_cpuid7_ebx.bits.bmi2 != 0)</span>
        result |= CPU_BMI2;
      if (_cpuid_info.sef_cpuid7_ebx.bits.sha != 0)
        result |= CPU_SHA;
      if (_cpuid_info.std_cpuid1_ecx.bits.fma != 0)
        result |= CPU_FMA;
<span class="udiff-line-added">+     if (_cpuid_info.sef_cpuid7_ebx.bits.clflushopt != 0)</span>
<span class="udiff-line-added">+       result |= CPU_FLUSHOPT;</span>
  
<span class="udiff-line-modified-removed">-     // AMD features.</span>
<span class="udiff-line-modified-removed">-     if (is_amd()) {</span>
<span class="udiff-line-modified-added">+     // AMD|Hygon features.</span>
<span class="udiff-line-modified-added">+     if (is_amd_family()) {</span>
        if ((_cpuid_info.ext_cpuid1_edx.bits.tdnow != 0) ||
            (_cpuid_info.ext_cpuid1_ecx.bits.prefetchw != 0))
          result |= CPU_3DNOW_PREFETCH;
        if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt != 0)
          result |= CPU_LZCNT;
        if (_cpuid_info.ext_cpuid1_ecx.bits.sse4a != 0)
          result |= CPU_SSE4A;
      }
      // Intel features.
<span class="udiff-line-modified-removed">-     if(is_intel()) {</span>
<span class="udiff-line-modified-removed">-       if(_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)</span>
<span class="udiff-line-modified-added">+     if (is_intel()) {</span>
<span class="udiff-line-modified-added">+       if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)</span>
          result |= CPU_LZCNT;
        // for Intel, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw
        if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {
          result |= CPU_3DNOW_PREFETCH;
        }
<span class="udiff-line-added">+       if (_cpuid_info.sef_cpuid7_ebx.bits.clwb != 0) {</span>
<span class="udiff-line-added">+         result |= CPU_CLWB;</span>
<span class="udiff-line-added">+       }</span>
      }
  
      // ZX features.
      if (is_zx()) {
        if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -683,10 +708,13 @@</span>
  
  
    // Initialization
    static void initialize();
  
<span class="udiff-line-added">+   // Override Abstract_VM_Version implementation</span>
<span class="udiff-line-added">+   static void print_platform_virtualization_info(outputStream*);</span>
<span class="udiff-line-added">+ </span>
    // Override Abstract_VM_Version implementation
    static bool use_biased_locking();
  
    // Asserts
    static void assert_is_initialized() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -709,10 +737,12 @@</span>
    //       determine whether a particular instruction is supported.
    //
    static int  cpu_family()        { return _cpu;}
    static bool is_P6()             { return cpu_family() &gt;= 6; }
    static bool is_amd()            { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x68747541; } // &#39;htuA&#39;
<span class="udiff-line-added">+   static bool is_hygon()          { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x6F677948; } // &#39;ogyH&#39;</span>
<span class="udiff-line-added">+   static bool is_amd_family()     { return is_amd() || is_hygon(); }</span>
    static bool is_intel()          { assert_is_initialized(); return _cpuid_info.std_vendor_name_0 == 0x756e6547; } // &#39;uneG&#39;
    static bool is_zx()             { assert_is_initialized(); return (_cpuid_info.std_vendor_name_0 == 0x746e6543) || (_cpuid_info.std_vendor_name_0 == 0x68532020); } // &#39;tneC&#39;||&#39;hS  &#39;
    static bool is_atom_family()    { return ((cpu_family() == 0x06) &amp;&amp; ((extended_cpu_model() == 0x36) || (extended_cpu_model() == 0x37) || (extended_cpu_model() == 0x4D))); } //Silvermont and Centerton
    static bool is_knights_family() { return ((cpu_family() == 0x06) &amp;&amp; ((extended_cpu_model() == 0x57) || (extended_cpu_model() == 0x85))); } // Xeon Phi 3200/5200/7200 and Future Xeon Phi
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -732,11 +762,11 @@</span>
                   _cpuid_info.tpl_cpuidB0_ebx.bits.logical_cpus;
        }
        if (!supports_topology || result == 0) {
          result = (_cpuid_info.dcp_cpuid4_eax.bits.cores_per_cpu + 1);
        }
<span class="udiff-line-modified-removed">-     } else if (is_amd()) {</span>
<span class="udiff-line-modified-added">+     } else if (is_amd_family()) {</span>
        result = (_cpuid_info.ext_cpuid8_ecx.bits.cores_per_cpu + 1);
      } else if (is_zx()) {
        bool supports_topology = supports_processor_topology();
        if (supports_topology) {
          result = _cpuid_info.tpl_cpuidB1_ebx.bits.logical_cpus /
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -768,11 +798,11 @@</span>
  
    static intx L1_line_size()  {
      intx result = 0;
      if (is_intel()) {
        result = (_cpuid_info.dcp_cpuid4_ebx.bits.L1_line_size + 1);
<span class="udiff-line-modified-removed">-     } else if (is_amd()) {</span>
<span class="udiff-line-modified-added">+     } else if (is_amd_family()) {</span>
        result = _cpuid_info.ext_cpuid5_ecx.bits.L1_line_size;
      } else if (is_zx()) {
        result = (_cpuid_info.dcp_cpuid4_ebx.bits.L1_line_size + 1);
      }
      if (result &lt; 32) // not defined ?
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -827,18 +857,22 @@</span>
    static bool supports_avxonly()    { return ((supports_avx2() || supports_avx()) &amp;&amp; !supports_evex()); }
    static bool supports_sha()        { return (_features &amp; CPU_SHA) != 0; }
    static bool supports_fma()        { return (_features &amp; CPU_FMA) != 0 &amp;&amp; supports_avx(); }
    static bool supports_vzeroupper() { return (_features &amp; CPU_VZEROUPPER) != 0; }
    static bool supports_vpopcntdq()  { return (_features &amp; CPU_AVX512_VPOPCNTDQ) != 0; }
<span class="udiff-line-modified-removed">-   static bool supports_vpclmulqdq() { return (_features &amp; CPU_VPCLMULQDQ) != 0; }</span>
<span class="udiff-line-modified-added">+   static bool supports_avx512_vpclmulqdq() { return (_features &amp; CPU_AVX512_VPCLMULQDQ) != 0; }</span>
    static bool supports_vaes()       { return (_features &amp; CPU_VAES) != 0; }
    static bool supports_vnni()       { return (_features &amp; CPU_VNNI) != 0; }
<span class="udiff-line-added">+   static bool supports_vbmi2()      { return (_features &amp; CPU_VBMI2) != 0; }</span>
  
    // Intel features
    static bool is_intel_family_core() { return is_intel() &amp;&amp;
                                         extended_cpu_family() == CPU_FAMILY_INTEL_CORE; }
  
<span class="udiff-line-added">+   static bool is_intel_skylake() { return is_intel_family_core() &amp;&amp;</span>
<span class="udiff-line-added">+                                           extended_cpu_model() == CPU_MODEL_SKYLAKE; }</span>
<span class="udiff-line-added">+ </span>
    static bool is_intel_tsc_synched_at_init()  {
      if (is_intel_family_core()) {
        uint32_t ext_model = extended_cpu_model();
        if (ext_model == CPU_MODEL_NEHALEM_EP     ||
            ext_model == CPU_MODEL_WESTMERE_EP    ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -855,11 +889,11 @@</span>
      return false;
    }
  
    // AMD features
    static bool supports_3dnow_prefetch()    { return (_features &amp; CPU_3DNOW_PREFETCH) != 0; }
<span class="udiff-line-modified-removed">-   static bool supports_mmx_ext()  { return is_amd() &amp;&amp; _cpuid_info.ext_cpuid1_edx.bits.mmx_amd != 0; }</span>
<span class="udiff-line-modified-added">+   static bool supports_mmx_ext()  { return is_amd_family() &amp;&amp; _cpuid_info.ext_cpuid1_edx.bits.mmx_amd != 0; }</span>
    static bool supports_lzcnt()    { return (_features &amp; CPU_LZCNT) != 0; }
    static bool supports_sse4a()    { return (_features &amp; CPU_SSE4A) != 0; }
  
    static bool is_amd_Barcelona()  { return is_amd() &amp;&amp;
                                             extended_cpu_family() == CPU_FAMILY_AMD_11H; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -868,12 +902,12 @@</span>
    static bool supports_tscinv_bit() {
      return (_features &amp; CPU_TSCINV) != 0;
    }
    static bool supports_tscinv() {
      return supports_tscinv_bit() &amp;&amp;
<span class="udiff-line-modified-removed">-            ( (is_amd() &amp;&amp; !is_amd_Barcelona()) ||</span>
<span class="udiff-line-modified-removed">-              is_intel_tsc_synched_at_init() );</span>
<span class="udiff-line-modified-added">+       ((is_amd_family() &amp;&amp; !is_amd_Barcelona()) ||</span>
<span class="udiff-line-modified-added">+         is_intel_tsc_synched_at_init());</span>
    }
  
    // Intel Core and newer cpus have fast IDIV instruction (excluding Atom).
    static bool has_fast_idiv()     { return is_intel() &amp;&amp; cpu_family() == 6 &amp;&amp;
                                             supports_sse3() &amp;&amp; _model != 0x1C; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -894,11 +928,11 @@</span>
      // Athlon    - 128 / prefetchnta
      // Opteron   - 256 / prefetchnta
      // Core      - 256 / prefetchnta
      // It will be used only when AllocatePrefetchStyle &gt; 0
  
<span class="udiff-line-modified-removed">-     if (is_amd()) { // AMD</span>
<span class="udiff-line-modified-added">+     if (is_amd_family()) { // AMD | Hygon</span>
        if (supports_sse2()) {
          return 256; // Opteron
        } else {
          return 128; // Athlon
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -928,8 +962,56 @@</span>
  
    // SSE2 and later processors implement a &#39;pause&#39; instruction
    // that can be used for efficient implementation of
    // the intrinsic for java.lang.Thread.onSpinWait()
    static bool supports_on_spin_wait() { return supports_sse2(); }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // x86_64 supports fast class initialization checks for static methods.</span>
<span class="udiff-line-added">+   static bool supports_fast_class_init_checks() {</span>
<span class="udiff-line-added">+     return LP64_ONLY(true) NOT_LP64(false); // not implemented on x86_32</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // there are several insns to force cache line sync to memory which</span>
<span class="udiff-line-added">+   // we can use to ensure mapped non-volatile memory is up to date with</span>
<span class="udiff-line-added">+   // pending in-cache changes.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // 64 bit cpus always support clflush which writes back and evicts</span>
<span class="udiff-line-added">+   // on 32 bit cpus support is recorded via a feature flag</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // clflushopt is optional and acts like clflush except it does</span>
<span class="udiff-line-added">+   // not synchronize with other memory ops. it needs a preceding</span>
<span class="udiff-line-added">+   // and trailing StoreStore fence</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // clwb is an optional, intel-specific instruction optional which</span>
<span class="udiff-line-added">+   // writes back without evicting the line. it also does not</span>
<span class="udiff-line-added">+   // synchronize with other memory ops. so, it also needs a preceding</span>
<span class="udiff-line-added">+   // and trailing StoreStore fence.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+   static bool supports_clflush() {</span>
<span class="udiff-line-added">+     // clflush should always be available on x86_64</span>
<span class="udiff-line-added">+     // if not we are in real trouble because we rely on it</span>
<span class="udiff-line-added">+     // to flush the code cache.</span>
<span class="udiff-line-added">+     // Unfortunately, Assembler::clflush is currently called as part</span>
<span class="udiff-line-added">+     // of generation of the code cache flush routine. This happens</span>
<span class="udiff-line-added">+     // under Universe::init before the processor features are set</span>
<span class="udiff-line-added">+     // up. Assembler::flush calls this routine to check that clflush</span>
<span class="udiff-line-added">+     // is allowed. So, we give the caller a free pass if Universe init</span>
<span class="udiff-line-added">+     // is still in progress.</span>
<span class="udiff-line-added">+     assert ((!Universe::is_fully_initialized() || (_features &amp; CPU_FLUSH) != 0), &quot;clflush should be available&quot;);</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   static bool supports_clflushopt() { return ((_features &amp; CPU_FLUSHOPT) != 0); }</span>
<span class="udiff-line-added">+   static bool supports_clwb() { return ((_features &amp; CPU_CLWB) != 0); }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   static bool supports_clflush() { return  ((_features &amp; CPU_FLUSH) != 0); }</span>
<span class="udiff-line-added">+   static bool supports_clflushopt() { return false; }</span>
<span class="udiff-line-added">+   static bool supports_clwb() { return false; }</span>
<span class="udiff-line-added">+ #endif // _LP64</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // support functions for virtualization detection</span>
<span class="udiff-line-added">+  private:</span>
<span class="udiff-line-added">+   static void check_virt_cpuid(uint32_t idx, uint32_t *regs);</span>
<span class="udiff-line-added">+   static void check_virtualizations();</span>
  };
  
  #endif // CPU_X86_VM_VERSION_X86_HPP
</pre>
<center><a href="vm_version_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86.ad.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
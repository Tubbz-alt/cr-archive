<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/jniFastGetField_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;gc/shared/barrierSet.hpp&quot;
 28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;prims/jniFastGetField.hpp&quot;
 31 #include &quot;prims/jvm_misc.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 
 34 #define __ masm-&gt;
 35 
 36 #define BUFFER_SIZE 30*wordSize
 37 
 38 // Common register usage:
 39 // rax/xmm0: result
 40 // c_rarg0:    jni env
 41 // c_rarg1:    obj
 42 // c_rarg2:    jfield id
 43 
 44 static const Register rtmp     = rax; // r8 == c_rarg2 on Windows
 45 static const Register robj     = r9;
 46 static const Register roffset  = r10;
 47 static const Register rcounter = r11;
 48 
 49 // Warning: do not use rip relative addressing after the first counter load
 50 // since that may scratch r10!
 51 
 52 address JNI_FastGetField::generate_fast_get_int_field0(BasicType type) {
 53   const char *name = NULL;
 54   switch (type) {
 55     case T_BOOLEAN: name = &quot;jni_fast_GetBooleanField&quot;; break;
 56     case T_BYTE:    name = &quot;jni_fast_GetByteField&quot;;    break;
 57     case T_CHAR:    name = &quot;jni_fast_GetCharField&quot;;    break;
 58     case T_SHORT:   name = &quot;jni_fast_GetShortField&quot;;   break;
 59     case T_INT:     name = &quot;jni_fast_GetIntField&quot;;     break;
 60     case T_LONG:    name = &quot;jni_fast_GetLongField&quot;;    break;
 61     default:        ShouldNotReachHere();
 62   }
 63   ResourceMark rm;
 64   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE);
 65   CodeBuffer cbuf(blob);
 66   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
 67   address fast_entry = __ pc();
 68 
 69   Label slow;
 70 
 71   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
 72   __ mov32 (rcounter, counter);
 73   __ mov   (robj, c_rarg1);
 74   __ testb (rcounter, 1);
 75   __ jcc (Assembler::notZero, slow);
 76 
 77   if (JvmtiExport::can_post_field_access()) {
 78     // Check to see if a field access watch has been set before we
 79     // take the fast path.
 80     assert_different_registers(rscratch1, robj, rcounter); // cmp32 clobbers rscratch1!
 81     __ cmp32(ExternalAddress((address) JvmtiExport::get_field_access_count_addr()), 0);
 82     __ jcc(Assembler::notZero, slow);
 83   }
 84 
 85   __ mov   (roffset, c_rarg2);
 86   __ shrptr(roffset, 2);                         // offset
 87 
 88   // Both robj and rtmp are clobbered by try_resolve_jobject_in_native.
 89   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 90   bs-&gt;try_resolve_jobject_in_native(masm, /* jni_env */ c_rarg0, robj, rtmp, slow);
 91   DEBUG_ONLY(__ movl(rtmp, 0xDEADC0DE);)
 92 
 93   assert(count &lt; LIST_CAPACITY, &quot;LIST_CAPACITY too small&quot;);
 94   speculative_load_pclist[count] = __ pc();
 95   switch (type) {
 96     case T_BOOLEAN: __ movzbl (rax, Address(robj, roffset, Address::times_1)); break;
 97     case T_BYTE:    __ movsbl (rax, Address(robj, roffset, Address::times_1)); break;
 98     case T_CHAR:    __ movzwl (rax, Address(robj, roffset, Address::times_1)); break;
 99     case T_SHORT:   __ movswl (rax, Address(robj, roffset, Address::times_1)); break;
100     case T_INT:     __ movl   (rax, Address(robj, roffset, Address::times_1)); break;
101     case T_LONG:    __ movq   (rax, Address(robj, roffset, Address::times_1)); break;
102     default:        ShouldNotReachHere();
103   }
104 
105   __ cmp32 (rcounter, counter);
106   __ jcc (Assembler::notEqual, slow);
107 
108   __ ret (0);
109 
110   slowcase_entry_pclist[count++] = __ pc();
111   __ bind (slow);
112   address slow_case_addr = NULL;
113   switch (type) {
114     case T_BOOLEAN: slow_case_addr = jni_GetBooleanField_addr(); break;
115     case T_BYTE:    slow_case_addr = jni_GetByteField_addr();    break;
116     case T_CHAR:    slow_case_addr = jni_GetCharField_addr();    break;
117     case T_SHORT:   slow_case_addr = jni_GetShortField_addr();   break;
118     case T_INT:     slow_case_addr = jni_GetIntField_addr();     break;
119     case T_LONG:    slow_case_addr = jni_GetLongField_addr();    break;
120     default:                                                     break;
121   }
122   // tail call
123   __ jump (ExternalAddress(slow_case_addr));
124 
125   __ flush ();
126 
127   return fast_entry;
128 }
129 
130 address JNI_FastGetField::generate_fast_get_boolean_field() {
131   return generate_fast_get_int_field0(T_BOOLEAN);
132 }
133 
134 address JNI_FastGetField::generate_fast_get_byte_field() {
135   return generate_fast_get_int_field0(T_BYTE);
136 }
137 
138 address JNI_FastGetField::generate_fast_get_char_field() {
139   return generate_fast_get_int_field0(T_CHAR);
140 }
141 
142 address JNI_FastGetField::generate_fast_get_short_field() {
143   return generate_fast_get_int_field0(T_SHORT);
144 }
145 
146 address JNI_FastGetField::generate_fast_get_int_field() {
147   return generate_fast_get_int_field0(T_INT);
148 }
149 
150 address JNI_FastGetField::generate_fast_get_long_field() {
151   return generate_fast_get_int_field0(T_LONG);
152 }
153 
154 address JNI_FastGetField::generate_fast_get_float_field0(BasicType type) {
155   const char *name = NULL;
156   switch (type) {
157     case T_FLOAT:     name = &quot;jni_fast_GetFloatField&quot;;     break;
158     case T_DOUBLE:    name = &quot;jni_fast_GetDoubleField&quot;;    break;
159     default:          ShouldNotReachHere();
160   }
161   ResourceMark rm;
162   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE);
163   CodeBuffer cbuf(blob);
164   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
165   address fast_entry = __ pc();
166 
167   Label slow;
168 
169   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
170   __ mov32 (rcounter, counter);
171   __ mov   (robj, c_rarg1);
172   __ testb (rcounter, 1);
173   __ jcc (Assembler::notZero, slow);
174 
175   if (JvmtiExport::can_post_field_access()) {
176     // Check to see if a field access watch has been set before we
177     // take the fast path.
178     __ cmp32(ExternalAddress((address) JvmtiExport::get_field_access_count_addr()), 0);
179     __ jcc(Assembler::notZero, slow);
180   }
181 
182   // Both robj and rtmp are clobbered by try_resolve_jobject_in_native.
183   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
184   bs-&gt;try_resolve_jobject_in_native(masm, /* jni_env */ c_rarg0, robj, rtmp, slow);
185   DEBUG_ONLY(__ movl(rtmp, 0xDEADC0DE);)
186 
187   __ mov   (roffset, c_rarg2);
188   __ shrptr(roffset, 2);                         // offset
189 
190   assert(count &lt; LIST_CAPACITY, &quot;LIST_CAPACITY too small&quot;);
191   speculative_load_pclist[count] = __ pc();
192   switch (type) {
193     case T_FLOAT:  __ movflt (xmm0, Address(robj, roffset, Address::times_1)); break;
194     case T_DOUBLE: __ movdbl (xmm0, Address(robj, roffset, Address::times_1)); break;
195     default:        ShouldNotReachHere();
196   }
197   __ cmp32 (rcounter, counter);
198   __ jcc (Assembler::notEqual, slow);
199 
200   __ ret (0);
201 
202   slowcase_entry_pclist[count++] = __ pc();
203   __ bind (slow);
204   address slow_case_addr = NULL;
205   switch (type) {
206     case T_FLOAT:     slow_case_addr = jni_GetFloatField_addr();  break;
207     case T_DOUBLE:    slow_case_addr = jni_GetDoubleField_addr(); break;
208     default:                                                      break;
209   }
210   // tail call
211   __ jump (ExternalAddress(slow_case_addr));
212 
213   __ flush ();
214 
215   return fast_entry;
216 }
217 
218 address JNI_FastGetField::generate_fast_get_float_field() {
219   return generate_fast_get_float_field0(T_FLOAT);
220 }
221 
222 address JNI_FastGetField::generate_fast_get_double_field() {
223   return generate_fast_get_float_field0(T_DOUBLE);
224 }
    </pre>
  </body>
</html>
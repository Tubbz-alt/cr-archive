<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/zero/cppInterpreter_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler_zero.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="disassembler_zero.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/zero/cppInterpreter_zero.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/assembler.hpp&quot;
 28 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
 29 #include &quot;interpreter/cppInterpreter.hpp&quot;
 30 #include &quot;interpreter/cppInterpreterGenerator.hpp&quot;
 31 #include &quot;interpreter/interpreter.hpp&quot;
 32 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 33 #include &quot;oops/arrayOop.hpp&quot;
 34 #include &quot;oops/cpCache.inline.hpp&quot;
 35 #include &quot;oops/methodData.hpp&quot;
 36 #include &quot;oops/method.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;prims/jvmtiExport.hpp&quot;
 39 #include &quot;prims/jvmtiThreadState.hpp&quot;
 40 #include &quot;runtime/arguments.hpp&quot;
<span class="line-removed"> 41 #include &quot;runtime/atomic.hpp&quot;</span>
 42 #include &quot;runtime/deoptimization.hpp&quot;
 43 #include &quot;runtime/frame.inline.hpp&quot;
 44 #include &quot;runtime/handles.inline.hpp&quot;
 45 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 46 #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="line-removed"> 47 #include &quot;runtime/orderAccess.hpp&quot;</span>
 48 #include &quot;runtime/sharedRuntime.hpp&quot;
 49 #include &quot;runtime/stubRoutines.hpp&quot;
 50 #include &quot;runtime/synchronizer.hpp&quot;
 51 #include &quot;runtime/timer.hpp&quot;
 52 #include &quot;runtime/vframeArray.hpp&quot;
 53 #include &quot;stack_zero.inline.hpp&quot;
 54 #include &quot;utilities/debug.hpp&quot;
 55 #include &quot;utilities/macros.hpp&quot;
 56 
 57 #ifdef CC_INTERP
 58 
 59 #define fixup_after_potential_safepoint()       \
 60   method = istate-&gt;method()
 61 
 62 #define CALL_VM_NOCHECK_NOFIX(func)             \
 63   thread-&gt;set_last_Java_frame();                \
 64   func;                                         \
 65   thread-&gt;reset_last_Java_frame();
 66 
 67 #define CALL_VM_NOCHECK(func)                   \
</pre>
<hr />
<pre>
256       CALL_VM_NOCHECK(mcs = InterpreterRuntime::build_method_counters(thread, method));
257       if (HAS_PENDING_EXCEPTION)
258         goto unwind_and_return;
259     }
260     InvocationCounter *counter = mcs-&gt;invocation_counter();
261     counter-&gt;increment();
262     if (counter-&gt;reached_InvocationLimit(mcs-&gt;backedge_counter())) {
263       CALL_VM_NOCHECK(
264         InterpreterRuntime::frequency_counter_overflow(thread, NULL));
265       if (HAS_PENDING_EXCEPTION)
266         goto unwind_and_return;
267     }
268   }
269 
270   // Lock if necessary
271   BasicObjectLock *monitor;
272   monitor = NULL;
273   if (method-&gt;is_synchronized()) {
274     monitor = (BasicObjectLock*) istate-&gt;stack_base();
275     oop lockee = monitor-&gt;obj();
<span class="line-modified">276     markOop disp = lockee-&gt;mark()-&gt;set_unlocked();</span>
277 
278     monitor-&gt;lock()-&gt;set_displaced_header(disp);
<span class="line-modified">279     if (lockee-&gt;cas_set_mark((markOop)monitor, disp) != disp) {</span>
<span class="line-modified">280       if (thread-&gt;is_lock_owned((address) disp-&gt;clear_lock_bits())) {</span>
<span class="line-modified">281         monitor-&gt;lock()-&gt;set_displaced_header(NULL);</span>
282       }
283       else {
284         CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));
285         if (HAS_PENDING_EXCEPTION)
286           goto unwind_and_return;
287       }
288     }
289   }
290 
291   // Get the signature handler
292   InterpreterRuntime::SignatureHandler *handler; {
293     address handlerAddr = method-&gt;signature_handler();
294     if (handlerAddr == NULL) {
295       CALL_VM_NOCHECK(InterpreterRuntime::prepare_native_call(thread, method));
296       if (HAS_PENDING_EXCEPTION)
297         goto unlock_unwind_and_return;
298 
299       handlerAddr = method-&gt;signature_handler();
300       assert(handlerAddr != NULL, &quot;eh?&quot;);
301     }
</pre>
<hr />
<pre>
354       else if (type-&gt;size == 8) {
355         src--;
356         *(dst++) = src--;
357       }
358       else {
359         ShouldNotReachHere();
360       }
361     }
362   }
363 
364   // Set up the Java frame anchor
365   thread-&gt;set_last_Java_frame();
366 
367   // Change the thread state to _thread_in_native
368   ThreadStateTransition::transition_from_java(thread, _thread_in_native);
369 
370   // Make the call
371   intptr_t result[4 - LogBytesPerWord];
372   ffi_call(handler-&gt;cif(), (void (*)()) function, result, arguments);
373 
<span class="line-modified">374   // Change the thread state back to _thread_in_Java.</span>

375   // ThreadStateTransition::transition_from_native() cannot be used
376   // here because it does not check for asynchronous exceptions.
377   // We have to manage the transition ourself.
<span class="line-modified">378   thread-&gt;set_thread_state(_thread_in_native_trans);</span>
<span class="line-removed">379 </span>
<span class="line-removed">380   // Make sure new state is visible in the GC thread</span>
<span class="line-removed">381   InterfaceSupport::serialize_thread_state(thread);</span>
382 
383   // Handle safepoint operations, pending suspend requests,
384   // and pending asynchronous exceptions.
385   if (SafepointMechanism::should_block(thread) ||
386       thread-&gt;has_special_condition_for_native_trans()) {
387     JavaThread::check_special_condition_for_native_trans(thread);
388     CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops());
389   }
390 
391   // Finally we can change the thread state to _thread_in_Java.
392   thread-&gt;set_thread_state(_thread_in_Java);
393   fixup_after_potential_safepoint();
394 
395   // Clear the frame anchor
396   thread-&gt;reset_last_Java_frame();
397 
398   // If the result was an oop then unbox it and store it in
399   // oop_temp where the garbage collector can see it before
400   // we release the handle it might be protected by.
401   if (handler-&gt;result_type() == &amp;ffi_type_pointer) {
402     if (result[0] == 0) {
403       istate-&gt;set_oop_temp(NULL);
404     } else {
405       jobject handle = reinterpret_cast&lt;jobject&gt;(result[0]);
406       istate-&gt;set_oop_temp(JNIHandles::resolve(handle));
407     }
408   }
409 
410   // Reset handle block
411   thread-&gt;active_handles()-&gt;clear();
412 
413  unlock_unwind_and_return:
414 
415   // Unlock if necessary
416   if (monitor) {
417     BasicLock *lock = monitor-&gt;lock();
<span class="line-modified">418     markOop header = lock-&gt;displaced_header();</span>
419     oop rcvr = monitor-&gt;obj();
420     monitor-&gt;set_obj(NULL);
421 
<span class="line-modified">422     if (header != NULL) {</span>
<span class="line-modified">423       markOop old_header = markOopDesc::encode(lock);</span>
424       if (rcvr-&gt;cas_set_mark(header, old_header) != old_header) {
425         monitor-&gt;set_obj(rcvr); {
426           HandleMark hm(thread);
427           CALL_VM_NOCHECK(InterpreterRuntime::monitorexit(thread, monitor));
428         }
429       }
430     }
431   }
432 
433  unwind_and_return:
434 
435   // Unwind the current activation
436   thread-&gt;pop_zero_frame();
437 
438   // Pop our parameters
439   stack-&gt;set_sp(stack-&gt;sp() + method-&gt;size_of_parameters());
440 
441   // Push our result
442   if (!HAS_PENDING_EXCEPTION) {
443     BasicType type = method-&gt;result_type();
</pre>
<hr />
<pre>
684     SET_VMSLOTS_SLOT(VMSLOTS_SLOT(i), i + num_slots);
685 
686   // Deallocate the space
687   stack-&gt;set_sp(stack-&gt;sp() + num_slots);
688 }
689 
690 BasicType CppInterpreter::result_type_of_handle(oop method_handle) {
691   oop method_type = java_lang_invoke_MethodHandle::type(method_handle);
692   oop return_type = java_lang_invoke_MethodType::rtype(method_type);
693   return java_lang_Class::as_BasicType(return_type, (Klass* *) NULL);
694 }
695 
696 intptr_t* CppInterpreter::calculate_unwind_sp(ZeroStack* stack,
697                                               oop method_handle) {
698   oop method_type = java_lang_invoke_MethodHandle::type(method_handle);
699   int argument_slots = java_lang_invoke_MethodType::ptype_slot_count(method_type);
700 
701   return stack-&gt;sp() + argument_slots;
702 }
703 
<span class="line-modified">704 IRT_ENTRY(void, CppInterpreter::throw_exception(JavaThread* thread,</span>
705                                                 Symbol*     name,
706                                                 char*       message))
707   THROW_MSG(name, message);
<span class="line-modified">708 IRT_END</span>
709 
710 InterpreterFrame *InterpreterFrame::build(Method* const method, TRAPS) {
711   JavaThread *thread = (JavaThread *) THREAD;
712   ZeroStack *stack = thread-&gt;zero_stack();
713 
714   // Calculate the size of the frame we&#39;ll build, including
715   // any adjustments to the caller&#39;s frame that we&#39;ll make.
716   int extra_locals  = 0;
717   int monitor_words = 0;
718   int stack_words   = 0;
719 
720   if (!method-&gt;is_native()) {
721     extra_locals = method-&gt;max_locals() - method-&gt;size_of_parameters();
722     stack_words  = method-&gt;max_stack();
723   }
724   if (method-&gt;is_synchronized()) {
725     monitor_words = frame::interpreter_frame_monitor_size();
726   }
727   stack-&gt;overflow_check(
728     extra_locals + header_words + monitor_words + stack_words, CHECK_NULL);
</pre>
</td>
<td>
<hr />
<pre>
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/assembler.hpp&quot;
 28 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
 29 #include &quot;interpreter/cppInterpreter.hpp&quot;
 30 #include &quot;interpreter/cppInterpreterGenerator.hpp&quot;
 31 #include &quot;interpreter/interpreter.hpp&quot;
 32 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 33 #include &quot;oops/arrayOop.hpp&quot;
 34 #include &quot;oops/cpCache.inline.hpp&quot;
 35 #include &quot;oops/methodData.hpp&quot;
 36 #include &quot;oops/method.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;prims/jvmtiExport.hpp&quot;
 39 #include &quot;prims/jvmtiThreadState.hpp&quot;
 40 #include &quot;runtime/arguments.hpp&quot;

 41 #include &quot;runtime/deoptimization.hpp&quot;
 42 #include &quot;runtime/frame.inline.hpp&quot;
 43 #include &quot;runtime/handles.inline.hpp&quot;
 44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 45 #include &quot;runtime/jniHandles.inline.hpp&quot;

 46 #include &quot;runtime/sharedRuntime.hpp&quot;
 47 #include &quot;runtime/stubRoutines.hpp&quot;
 48 #include &quot;runtime/synchronizer.hpp&quot;
 49 #include &quot;runtime/timer.hpp&quot;
 50 #include &quot;runtime/vframeArray.hpp&quot;
 51 #include &quot;stack_zero.inline.hpp&quot;
 52 #include &quot;utilities/debug.hpp&quot;
 53 #include &quot;utilities/macros.hpp&quot;
 54 
 55 #ifdef CC_INTERP
 56 
 57 #define fixup_after_potential_safepoint()       \
 58   method = istate-&gt;method()
 59 
 60 #define CALL_VM_NOCHECK_NOFIX(func)             \
 61   thread-&gt;set_last_Java_frame();                \
 62   func;                                         \
 63   thread-&gt;reset_last_Java_frame();
 64 
 65 #define CALL_VM_NOCHECK(func)                   \
</pre>
<hr />
<pre>
254       CALL_VM_NOCHECK(mcs = InterpreterRuntime::build_method_counters(thread, method));
255       if (HAS_PENDING_EXCEPTION)
256         goto unwind_and_return;
257     }
258     InvocationCounter *counter = mcs-&gt;invocation_counter();
259     counter-&gt;increment();
260     if (counter-&gt;reached_InvocationLimit(mcs-&gt;backedge_counter())) {
261       CALL_VM_NOCHECK(
262         InterpreterRuntime::frequency_counter_overflow(thread, NULL));
263       if (HAS_PENDING_EXCEPTION)
264         goto unwind_and_return;
265     }
266   }
267 
268   // Lock if necessary
269   BasicObjectLock *monitor;
270   monitor = NULL;
271   if (method-&gt;is_synchronized()) {
272     monitor = (BasicObjectLock*) istate-&gt;stack_base();
273     oop lockee = monitor-&gt;obj();
<span class="line-modified">274     markWord disp = lockee-&gt;mark().set_unlocked();</span>
275 
276     monitor-&gt;lock()-&gt;set_displaced_header(disp);
<span class="line-modified">277     if (lockee-&gt;cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {</span>
<span class="line-modified">278       if (thread-&gt;is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {</span>
<span class="line-modified">279         monitor-&gt;lock()-&gt;set_displaced_header(markWord::from_pointer(NULL));</span>
280       }
281       else {
282         CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));
283         if (HAS_PENDING_EXCEPTION)
284           goto unwind_and_return;
285       }
286     }
287   }
288 
289   // Get the signature handler
290   InterpreterRuntime::SignatureHandler *handler; {
291     address handlerAddr = method-&gt;signature_handler();
292     if (handlerAddr == NULL) {
293       CALL_VM_NOCHECK(InterpreterRuntime::prepare_native_call(thread, method));
294       if (HAS_PENDING_EXCEPTION)
295         goto unlock_unwind_and_return;
296 
297       handlerAddr = method-&gt;signature_handler();
298       assert(handlerAddr != NULL, &quot;eh?&quot;);
299     }
</pre>
<hr />
<pre>
352       else if (type-&gt;size == 8) {
353         src--;
354         *(dst++) = src--;
355       }
356       else {
357         ShouldNotReachHere();
358       }
359     }
360   }
361 
362   // Set up the Java frame anchor
363   thread-&gt;set_last_Java_frame();
364 
365   // Change the thread state to _thread_in_native
366   ThreadStateTransition::transition_from_java(thread, _thread_in_native);
367 
368   // Make the call
369   intptr_t result[4 - LogBytesPerWord];
370   ffi_call(handler-&gt;cif(), (void (*)()) function, result, arguments);
371 
<span class="line-modified">372   // Change the thread state back to _thread_in_Java and ensure it</span>
<span class="line-added">373   // is seen by the GC thread.</span>
374   // ThreadStateTransition::transition_from_native() cannot be used
375   // here because it does not check for asynchronous exceptions.
376   // We have to manage the transition ourself.
<span class="line-modified">377   thread-&gt;set_thread_state_fence(_thread_in_native_trans);</span>



378 
379   // Handle safepoint operations, pending suspend requests,
380   // and pending asynchronous exceptions.
381   if (SafepointMechanism::should_block(thread) ||
382       thread-&gt;has_special_condition_for_native_trans()) {
383     JavaThread::check_special_condition_for_native_trans(thread);
384     CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops());
385   }
386 
387   // Finally we can change the thread state to _thread_in_Java.
388   thread-&gt;set_thread_state(_thread_in_Java);
389   fixup_after_potential_safepoint();
390 
391   // Clear the frame anchor
392   thread-&gt;reset_last_Java_frame();
393 
394   // If the result was an oop then unbox it and store it in
395   // oop_temp where the garbage collector can see it before
396   // we release the handle it might be protected by.
397   if (handler-&gt;result_type() == &amp;ffi_type_pointer) {
398     if (result[0] == 0) {
399       istate-&gt;set_oop_temp(NULL);
400     } else {
401       jobject handle = reinterpret_cast&lt;jobject&gt;(result[0]);
402       istate-&gt;set_oop_temp(JNIHandles::resolve(handle));
403     }
404   }
405 
406   // Reset handle block
407   thread-&gt;active_handles()-&gt;clear();
408 
409  unlock_unwind_and_return:
410 
411   // Unlock if necessary
412   if (monitor) {
413     BasicLock *lock = monitor-&gt;lock();
<span class="line-modified">414     markWord header = lock-&gt;displaced_header();</span>
415     oop rcvr = monitor-&gt;obj();
416     monitor-&gt;set_obj(NULL);
417 
<span class="line-modified">418     if (header.to_pointer() != NULL) {</span>
<span class="line-modified">419       markWord old_header = markWord::encode(lock);</span>
420       if (rcvr-&gt;cas_set_mark(header, old_header) != old_header) {
421         monitor-&gt;set_obj(rcvr); {
422           HandleMark hm(thread);
423           CALL_VM_NOCHECK(InterpreterRuntime::monitorexit(thread, monitor));
424         }
425       }
426     }
427   }
428 
429  unwind_and_return:
430 
431   // Unwind the current activation
432   thread-&gt;pop_zero_frame();
433 
434   // Pop our parameters
435   stack-&gt;set_sp(stack-&gt;sp() + method-&gt;size_of_parameters());
436 
437   // Push our result
438   if (!HAS_PENDING_EXCEPTION) {
439     BasicType type = method-&gt;result_type();
</pre>
<hr />
<pre>
680     SET_VMSLOTS_SLOT(VMSLOTS_SLOT(i), i + num_slots);
681 
682   // Deallocate the space
683   stack-&gt;set_sp(stack-&gt;sp() + num_slots);
684 }
685 
686 BasicType CppInterpreter::result_type_of_handle(oop method_handle) {
687   oop method_type = java_lang_invoke_MethodHandle::type(method_handle);
688   oop return_type = java_lang_invoke_MethodType::rtype(method_type);
689   return java_lang_Class::as_BasicType(return_type, (Klass* *) NULL);
690 }
691 
692 intptr_t* CppInterpreter::calculate_unwind_sp(ZeroStack* stack,
693                                               oop method_handle) {
694   oop method_type = java_lang_invoke_MethodHandle::type(method_handle);
695   int argument_slots = java_lang_invoke_MethodType::ptype_slot_count(method_type);
696 
697   return stack-&gt;sp() + argument_slots;
698 }
699 
<span class="line-modified">700 JRT_ENTRY(void, CppInterpreter::throw_exception(JavaThread* thread,</span>
701                                                 Symbol*     name,
702                                                 char*       message))
703   THROW_MSG(name, message);
<span class="line-modified">704 JRT_END</span>
705 
706 InterpreterFrame *InterpreterFrame::build(Method* const method, TRAPS) {
707   JavaThread *thread = (JavaThread *) THREAD;
708   ZeroStack *stack = thread-&gt;zero_stack();
709 
710   // Calculate the size of the frame we&#39;ll build, including
711   // any adjustments to the caller&#39;s frame that we&#39;ll make.
712   int extra_locals  = 0;
713   int monitor_words = 0;
714   int stack_words   = 0;
715 
716   if (!method-&gt;is_native()) {
717     extra_locals = method-&gt;max_locals() - method-&gt;size_of_parameters();
718     stack_words  = method-&gt;max_stack();
719   }
720   if (method-&gt;is_synchronized()) {
721     monitor_words = frame::interpreter_frame_monitor_size();
722   }
723   stack-&gt;overflow_check(
724     extra_locals + header_words + monitor_words + stack_words, CHECK_NULL);
</pre>
</td>
</tr>
</table>
<center><a href="assembler_zero.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="disassembler_zero.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
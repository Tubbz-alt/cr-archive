<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/zero/stubGenerator_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright 2007, 2008, 2010, 2015 Red Hat, Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/assembler.hpp&quot;
 28 #include &quot;assembler_zero.inline.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;nativeInst_zero.hpp&quot;
 31 #include &quot;oops/instanceOop.hpp&quot;
 32 #include &quot;oops/method.hpp&quot;
 33 #include &quot;oops/objArrayKlass.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;prims/methodHandles.hpp&quot;
 36 #include &quot;runtime/frame.inline.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/sharedRuntime.hpp&quot;
 39 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 40 #include &quot;runtime/stubRoutines.hpp&quot;
 41 #include &quot;runtime/thread.inline.hpp&quot;
 42 #include &quot;stack_zero.inline.hpp&quot;
 43 #ifdef COMPILER2
 44 #include &quot;opto/runtime.hpp&quot;
 45 #endif
 46 
 47 // For SafeFetch we need POSIX tls and setjmp
 48 #include &lt;setjmp.h&gt;
 49 #include &lt;pthread.h&gt;
 50 static pthread_key_t g_jmpbuf_key;
 51 
 52 // return the currently active jump buffer for this thread
 53 //  - if there is any, NULL otherwise. Called from
 54 //    zero signal handlers.
 55 extern sigjmp_buf* get_jmp_buf_for_continuation() {
 56   return (sigjmp_buf*) pthread_getspecific(g_jmpbuf_key);
 57 }
 58 
 59 // Declaration and definition of StubGenerator (no .hpp file).
 60 // For a more detailed description of the stub routine structure
 61 // see the comment in stubRoutines.hpp
 62 
 63 class StubGenerator: public StubCodeGenerator {
 64  private:
 65   // The call stub is used to call Java from C
 66   static void call_stub(
 67     JavaCallWrapper *call_wrapper,
 68     intptr_t*        result,
 69     BasicType        result_type,
 70     Method*          method,
 71     address          entry_point,
 72     intptr_t*        parameters,
 73     int              parameter_words,
 74     TRAPS) {
 75     JavaThread *thread = (JavaThread *) THREAD;
 76     ZeroStack *stack = thread-&gt;zero_stack();
 77 
 78     // Make sure we have no pending exceptions
 79     assert(!HAS_PENDING_EXCEPTION, &quot;call_stub called with pending exception&quot;);
 80 
 81     // Set up the stack if necessary
 82     bool stack_needs_teardown = false;
 83     if (stack-&gt;needs_setup()) {
 84       size_t zero_stack_size = stack-&gt;suggest_size(thread);
 85       stack-&gt;setup(alloca(zero_stack_size), zero_stack_size);
 86       stack_needs_teardown = true;
 87     }
 88 
 89     // Allocate and initialize our frame
 90     EntryFrame *frame =
 91       EntryFrame::build(parameters, parameter_words, call_wrapper, THREAD);
 92 
 93     if (!HAS_PENDING_EXCEPTION) {
 94       // Push the frame
 95       thread-&gt;push_zero_frame(frame);
 96 
 97       // Make the call
 98       Interpreter::invoke_method(method, entry_point, THREAD);
 99 
100       // Store the result
101       if (!HAS_PENDING_EXCEPTION) {
102         switch (result_type) {
103         case T_INT:
104           *(jint *) result = *(jint *) stack-&gt;sp();
105           break;
106         case T_LONG:
107           *(jlong *) result = *(jlong *) stack-&gt;sp();
108           break;
109         case T_FLOAT:
110           *(jfloat *) result = *(jfloat *) stack-&gt;sp();
111           break;
112         case T_DOUBLE:
113           *(jdouble *) result = *(jdouble *) stack-&gt;sp();
114           break;
115         case T_OBJECT:
116           *(oop *) result = *(oop *) stack-&gt;sp();
117           break;
118         default:
119           ShouldNotReachHere();
120         }
121       }
122 
123       // Unwind the frame
124       thread-&gt;pop_zero_frame();
125     }
126 
127     // Tear down the stack if necessary
128     if (stack_needs_teardown)
129       stack-&gt;teardown();
130   }
131 
132   // These stubs get called from some dumb test routine.
133   // I&#39;ll write them properly when they&#39;re called from
134   // something that&#39;s actually doing something.
135   static void fake_arraycopy_stub(address src, address dst, int count) {
136     assert(count == 0, &quot;huh?&quot;);
137   }
138 
139   void generate_arraycopy_stubs() {
140     // Call the conjoint generation methods immediately after
141     // the disjoint ones so that short branches from the former
142     // to the latter can be generated.
143     StubRoutines::_jbyte_disjoint_arraycopy  = (address) fake_arraycopy_stub;
144     StubRoutines::_jbyte_arraycopy           = (address) fake_arraycopy_stub;
145 
146     StubRoutines::_jshort_disjoint_arraycopy = (address) fake_arraycopy_stub;
147     StubRoutines::_jshort_arraycopy          = (address) fake_arraycopy_stub;
148 
149     StubRoutines::_jint_disjoint_arraycopy   = (address) fake_arraycopy_stub;
150     StubRoutines::_jint_arraycopy            = (address) fake_arraycopy_stub;
151 
152     StubRoutines::_jlong_disjoint_arraycopy  = (address) fake_arraycopy_stub;
153     StubRoutines::_jlong_arraycopy           = (address) fake_arraycopy_stub;
154 
155     StubRoutines::_oop_disjoint_arraycopy    = ShouldNotCallThisStub();
156     StubRoutines::_oop_arraycopy             = ShouldNotCallThisStub();
157 
158     StubRoutines::_checkcast_arraycopy       = ShouldNotCallThisStub();
159     StubRoutines::_generic_arraycopy         = ShouldNotCallThisStub();
160 
161     // Shared code tests for &quot;NULL&quot; to discover the stub is not generated.
162     StubRoutines::_unsafe_arraycopy          = NULL;
163 
164     // We don&#39;t generate specialized code for HeapWord-aligned source
165     // arrays, so just use the code we&#39;ve already generated
166     StubRoutines::_arrayof_jbyte_disjoint_arraycopy =
167       StubRoutines::_jbyte_disjoint_arraycopy;
168     StubRoutines::_arrayof_jbyte_arraycopy =
169       StubRoutines::_jbyte_arraycopy;
170 
171     StubRoutines::_arrayof_jshort_disjoint_arraycopy =
172       StubRoutines::_jshort_disjoint_arraycopy;
173     StubRoutines::_arrayof_jshort_arraycopy =
174       StubRoutines::_jshort_arraycopy;
175 
176     StubRoutines::_arrayof_jint_disjoint_arraycopy =
177       StubRoutines::_jint_disjoint_arraycopy;
178     StubRoutines::_arrayof_jint_arraycopy =
179       StubRoutines::_jint_arraycopy;
180 
181     StubRoutines::_arrayof_jlong_disjoint_arraycopy =
182       StubRoutines::_jlong_disjoint_arraycopy;
183     StubRoutines::_arrayof_jlong_arraycopy =
184       StubRoutines::_jlong_arraycopy;
185 
186     StubRoutines::_arrayof_oop_disjoint_arraycopy =
187       StubRoutines::_oop_disjoint_arraycopy;
188     StubRoutines::_arrayof_oop_arraycopy =
189       StubRoutines::_oop_arraycopy;
190   }
191 
192   static int SafeFetch32(int *adr, int errValue) {
193 
194     // set up a jump buffer; anchor the pointer to the jump buffer in tls; then
195     // do the pointer access. If pointer is invalid, we crash; in signal
196     // handler, we retrieve pointer to jmp buffer from tls, and jump back.
197     //
198     // Note: the jump buffer itself - which can get pretty large depending on
199     // the architecture - lives on the stack and that is fine, because we will
200     // not rewind the stack: either we crash, in which case signal handler
201     // frame is below us, or we don&#39;t crash, in which case it does not matter.
202     sigjmp_buf jb;
203     if (sigsetjmp(jb, 1)) {
204       // we crashed. clean up tls and return default value.
205       pthread_setspecific(g_jmpbuf_key, NULL);
206       return errValue;
207     } else {
208       // preparation phase
209       pthread_setspecific(g_jmpbuf_key, &amp;jb);
210     }
211 
212     int value = errValue;
213     value = *adr;
214 
215     // all went well. clean tls.
216     pthread_setspecific(g_jmpbuf_key, NULL);
217 
218     return value;
219   }
220 
221   static intptr_t SafeFetchN(intptr_t *adr, intptr_t errValue) {
222 
223     sigjmp_buf jb;
224     if (sigsetjmp(jb, 1)) {
225       // we crashed. clean up tls and return default value.
226       pthread_setspecific(g_jmpbuf_key, NULL);
227       return errValue;
228     } else {
229       // preparation phase
230       pthread_setspecific(g_jmpbuf_key, &amp;jb);
231     }
232 
233     intptr_t value = errValue;
234     value = *adr;
235 
236     // all went well. clean tls.
237     pthread_setspecific(g_jmpbuf_key, NULL);
238 
239     return value;
240 
241   }
242 
243   void generate_initial() {
244     // Generates all stubs and initializes the entry points
245 
246     // entry points that exist in all platforms Note: This is code
247     // that could be shared among different platforms - however the
248     // benefit seems to be smaller than the disadvantage of having a
249     // much more complicated generator structure. See also comment in
250     // stubRoutines.hpp.
251 
252     StubRoutines::_forward_exception_entry   = ShouldNotCallThisStub();
253     StubRoutines::_call_stub_entry           = (address) call_stub;
254     StubRoutines::_catch_exception_entry     = ShouldNotCallThisStub();
255 
256     // atomic calls
257     StubRoutines::_atomic_xchg_entry         = ShouldNotCallThisStub();
258     StubRoutines::_atomic_xchg_long_entry    = ShouldNotCallThisStub();
259     StubRoutines::_atomic_cmpxchg_entry      = ShouldNotCallThisStub();
260     StubRoutines::_atomic_cmpxchg_byte_entry = ShouldNotCallThisStub();
261     StubRoutines::_atomic_cmpxchg_long_entry = ShouldNotCallThisStub();
262     StubRoutines::_atomic_add_entry          = ShouldNotCallThisStub();
263     StubRoutines::_atomic_add_long_entry     = ShouldNotCallThisStub();
264     StubRoutines::_fence_entry               = ShouldNotCallThisStub();
265   }
266 
267   void generate_all() {
268     // Generates all stubs and initializes the entry points
269 
270     // These entry points require SharedInfo::stack0 to be set up in
271     // non-core builds and need to be relocatable, so they each
272     // fabricate a RuntimeStub internally.
273     StubRoutines::_throw_AbstractMethodError_entry =
274       ShouldNotCallThisStub();
275 
276     StubRoutines::_throw_NullPointerException_at_call_entry =
277       ShouldNotCallThisStub();
278 
279     StubRoutines::_throw_StackOverflowError_entry =
280       ShouldNotCallThisStub();
281 
282     // support for verify_oop (must happen after universe_init)
283     StubRoutines::_verify_oop_subroutine_entry =
284       ShouldNotCallThisStub();
285 
286     // arraycopy stubs used by compilers
287     generate_arraycopy_stubs();
288 
289     // Safefetch stubs.
290     pthread_key_create(&amp;g_jmpbuf_key, NULL);
291     StubRoutines::_safefetch32_entry = CAST_FROM_FN_PTR(address, StubGenerator::SafeFetch32);
292     StubRoutines::_safefetch32_fault_pc = NULL;
293     StubRoutines::_safefetch32_continuation_pc = NULL;
294 
295     StubRoutines::_safefetchN_entry = CAST_FROM_FN_PTR(address, StubGenerator::SafeFetchN);
296     StubRoutines::_safefetchN_fault_pc = NULL;
297     StubRoutines::_safefetchN_continuation_pc = NULL;
298   }
299 
300  public:
301   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
302     if (all) {
303       generate_all();
304     } else {
305       generate_initial();
306     }
307   }
308 };
309 
310 void StubGenerator_generate(CodeBuffer* code, bool all) {
311   StubGenerator g(code, all);
312 }
313 
314 EntryFrame *EntryFrame::build(const intptr_t*  parameters,
315                               int              parameter_words,
316                               JavaCallWrapper* call_wrapper,
317                               TRAPS) {
318 
319   ZeroStack *stack = ((JavaThread *) THREAD)-&gt;zero_stack();
320   stack-&gt;overflow_check(header_words + parameter_words, CHECK_NULL);
321 
322   stack-&gt;push(0); // next_frame, filled in later
323   intptr_t *fp = stack-&gt;sp();
324   assert(fp - stack-&gt;sp() == next_frame_off, &quot;should be&quot;);
325 
326   stack-&gt;push(ENTRY_FRAME);
327   assert(fp - stack-&gt;sp() == frame_type_off, &quot;should be&quot;);
328 
329   stack-&gt;push((intptr_t) call_wrapper);
330   assert(fp - stack-&gt;sp() == call_wrapper_off, &quot;should be&quot;);
331 
332   for (int i = 0; i &lt; parameter_words; i++)
333     stack-&gt;push(parameters[i]);
334 
335   return (EntryFrame *) fp;
336 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/zero/frame_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;code/scopeDesc.hpp&quot;
 28 #include &quot;interpreter/interpreter.hpp&quot;
 29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 31 #include &quot;oops/markOop.hpp&quot;</span>

 32 #include &quot;oops/method.hpp&quot;
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/frame.inline.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 #include &quot;runtime/javaCalls.hpp&quot;
 37 #include &quot;runtime/monitorChunk.hpp&quot;
 38 #include &quot;runtime/signature.hpp&quot;
 39 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 40 #include &quot;runtime/stubRoutines.hpp&quot;
 41 #include &quot;vmreg_zero.inline.hpp&quot;
 42 #ifdef COMPILER1
 43 #include &quot;c1/c1_Runtime1.hpp&quot;
 44 #include &quot;runtime/vframeArray.hpp&quot;
 45 #endif
 46 
 47 #ifdef ASSERT
 48 void RegisterMap::check_location_valid() {
 49   ShouldNotCallThis();
 50 }
 51 #endif
 52 
 53 bool frame::is_interpreted_frame() const {
 54   return zeroframe()-&gt;is_interpreter_frame();
 55 }
 56 
 57 bool frame::is_fake_stub_frame() const {
 58   return zeroframe()-&gt;is_fake_stub_frame();
 59 }
 60 
 61 frame frame::sender_for_entry_frame(RegisterMap *map) const {
 62   assert(zeroframe()-&gt;is_entry_frame(), &quot;wrong type of frame&quot;);
 63   assert(map != NULL, &quot;map must be set&quot;);
 64   assert(!entry_frame_is_first(), &quot;next Java fp must be non zero&quot;);
 65   assert(entry_frame_call_wrapper()-&gt;anchor()-&gt;last_Java_sp() == sender_sp(),
 66          &quot;sender should be next Java frame&quot;);
 67   map-&gt;clear();
 68   assert(map-&gt;include_argument_oops(), &quot;should be set by clear&quot;);
 69   return frame(zeroframe()-&gt;next(), sender_sp());
 70 }
 71 
 72 frame frame::sender_for_nonentry_frame(RegisterMap *map) const {
 73   assert(zeroframe()-&gt;is_interpreter_frame() ||
 74          zeroframe()-&gt;is_fake_stub_frame(), &quot;wrong type of frame&quot;);
 75   return frame(zeroframe()-&gt;next(), sender_sp());
 76 }
 77 
 78 frame frame::sender(RegisterMap* map) const {
 79   // Default is not to follow arguments; the various
 80   // sender_for_xxx methods update this accordingly.
 81   map-&gt;set_include_argument_oops(false);
 82 
 83   if (is_entry_frame())
 84     return sender_for_entry_frame(map);
 85   else
 86     return sender_for_nonentry_frame(map);
 87 }
 88 
 89 #ifdef CC_INTERP
 90 BasicObjectLock* frame::interpreter_frame_monitor_begin() const {
 91   return get_interpreterState()-&gt;monitor_base();
 92 }
 93 
 94 BasicObjectLock* frame::interpreter_frame_monitor_end() const {
 95   return (BasicObjectLock*) get_interpreterState()-&gt;stack_base();
 96 }
 97 #endif // CC_INTERP
 98 
 99 void frame::patch_pc(Thread* thread, address pc) {
100 
101   if (pc != NULL) {
102     _cb = CodeCache::find_blob(pc);
103     _pc = pc;
104     _deopt_state = is_deoptimized;
105 
106   } else {
107     // We borrow this call to set the thread pointer in the interpreter
108     // state; the hook to set up deoptimized frames isn&#39;t supplied it.
109     assert(pc == NULL, &quot;should be&quot;);
110     get_interpreterState()-&gt;set_thread((JavaThread *) thread);
111   }
112 }
113 
114 bool frame::safe_for_sender(JavaThread *thread) {
115   ShouldNotCallThis();
116   return false;
117 }
118 
119 bool frame::is_interpreted_frame_valid(JavaThread *thread) const {
120   ShouldNotCallThis();
121   return false;
122 }
123 
124 BasicType frame::interpreter_frame_result(oop* oop_result,
125                                           jvalue* value_result) {
126   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
127   Method* method = interpreter_frame_method();
128   BasicType type = method-&gt;result_type();
129   intptr_t* tos_addr = (intptr_t *) interpreter_frame_tos_address();
130   oop obj;
131 
132   switch (type) {
133   case T_VOID:
134     break;
135   case T_BOOLEAN:
136     value_result-&gt;z = *(jboolean *) tos_addr;
137     break;
138   case T_BYTE:
139     value_result-&gt;b = *(jbyte *) tos_addr;
140     break;
141   case T_CHAR:
142     value_result-&gt;c = *(jchar *) tos_addr;
143     break;
144   case T_SHORT:
145     value_result-&gt;s = *(jshort *) tos_addr;
146     break;
147   case T_INT:
148     value_result-&gt;i = *(jint *) tos_addr;
149     break;
150   case T_LONG:
151     value_result-&gt;j = *(jlong *) tos_addr;
152     break;
153   case T_FLOAT:
154     value_result-&gt;f = *(jfloat *) tos_addr;
155     break;
156   case T_DOUBLE:
157     value_result-&gt;d = *(jdouble *) tos_addr;
158     break;
159 
160   case T_OBJECT:
161   case T_ARRAY:
162     if (method-&gt;is_native()) {
163       obj = get_interpreterState()-&gt;oop_temp();
164     }
165     else {
166       oop* obj_p = (oop *) tos_addr;
167       obj = (obj_p == NULL) ? (oop) NULL : *obj_p;
168     }
169     assert(obj == NULL || Universe::heap()-&gt;is_in(obj), &quot;sanity check&quot;);
170     *oop_result = obj;
171     break;
172 
173   default:
174     ShouldNotReachHere();
175   }
176 
177   return type;
178 }
179 
180 int frame::frame_size(RegisterMap* map) const {
181 #ifdef PRODUCT
182   ShouldNotCallThis();
183 #endif // PRODUCT
184   return 0; // make javaVFrame::print_value work
185 }
186 
187 intptr_t* frame::interpreter_frame_tos_at(jint offset) const {
188   int index = (Interpreter::expr_offset_in_bytes(offset) / wordSize);
189   return &amp;interpreter_frame_tos_address()[index];
190 }
191 
192 void frame::zero_print_on_error(int           frame_index,
193                                 outputStream* st,
194                                 char*         buf,
195                                 int           buflen) const {
196   // Divide the buffer between the field and the value
197   buflen &gt;&gt;= 1;
198   char *fieldbuf = buf;
199   char *valuebuf = buf + buflen;
200 
201   // Print each word of the frame
202   for (intptr_t *addr = sp(); addr &lt;= fp(); addr++) {
203     int offset = fp() - addr;
204 
205     // Fill in default values, then try and improve them
206     snprintf(fieldbuf, buflen, &quot;word[%d]&quot;, offset);
207     snprintf(valuebuf, buflen, PTR_FORMAT, *addr);
208     zeroframe()-&gt;identify_word(frame_index, offset, fieldbuf, valuebuf, buflen);
209     fieldbuf[buflen - 1] = &#39;\0&#39;;
210     valuebuf[buflen - 1] = &#39;\0&#39;;
211 
212     // Print the result
213     st-&gt;print_cr(&quot; &quot; PTR_FORMAT &quot;: %-21s = %s&quot;, p2i(addr), fieldbuf, valuebuf);
214   }
215 }
216 
217 void ZeroFrame::identify_word(int   frame_index,
218                               int   offset,
219                               char* fieldbuf,
220                               char* valuebuf,
221                               int   buflen) const {
222   switch (offset) {
223   case next_frame_off:
224     strncpy(fieldbuf, &quot;next_frame&quot;, buflen);
225     break;
226 
227   case frame_type_off:
228     strncpy(fieldbuf, &quot;frame_type&quot;, buflen);
229     if (is_entry_frame())
230       strncpy(valuebuf, &quot;ENTRY_FRAME&quot;, buflen);
231     else if (is_interpreter_frame())
232       strncpy(valuebuf, &quot;INTERPRETER_FRAME&quot;, buflen);
233     else if (is_fake_stub_frame())
234       strncpy(valuebuf, &quot;FAKE_STUB_FRAME&quot;, buflen);
235     break;
236 
237   default:
238     if (is_entry_frame()) {
239       as_entry_frame()-&gt;identify_word(
240         frame_index, offset, fieldbuf, valuebuf, buflen);
241     }
242     else if (is_interpreter_frame()) {
243       as_interpreter_frame()-&gt;identify_word(
244         frame_index, offset, fieldbuf, valuebuf, buflen);
245     }
246     else if (is_fake_stub_frame()) {
247       as_fake_stub_frame()-&gt;identify_word(
248         frame_index, offset, fieldbuf, valuebuf, buflen);
249     }
250   }
251 }
252 
253 void EntryFrame::identify_word(int   frame_index,
254                                int   offset,
255                                char* fieldbuf,
256                                char* valuebuf,
257                                int   buflen) const {
258   switch (offset) {
259   case call_wrapper_off:
260     strncpy(fieldbuf, &quot;call_wrapper&quot;, buflen);
261     break;
262 
263   default:
264     snprintf(fieldbuf, buflen, &quot;local[%d]&quot;, offset - 3);
265   }
266 }
267 
268 void InterpreterFrame::identify_word(int   frame_index,
269                                      int   offset,
270                                      char* fieldbuf,
271                                      char* valuebuf,
272                                      int   buflen) const {
273   interpreterState istate = interpreter_state();
274   bool is_valid = istate-&gt;self_link() == istate;
275   intptr_t *addr = addr_of_word(offset);
276 
277   // Fixed part
278   if (addr &gt;= (intptr_t *) istate) {
279     const char *field = istate-&gt;name_of_field_at_address((address) addr);
280     if (field) {
281       if (is_valid &amp;&amp; !strcmp(field, &quot;_method&quot;)) {
282         istate-&gt;method()-&gt;name_and_sig_as_C_string(valuebuf, buflen);
283       }
284       else if (is_valid &amp;&amp; !strcmp(field, &quot;_bcp&quot;) &amp;&amp; istate-&gt;bcp()) {
285         snprintf(valuebuf, buflen, PTR_FORMAT &quot; (bci %d)&quot;,
286                  (intptr_t) istate-&gt;bcp(),
287                  istate-&gt;method()-&gt;bci_from(istate-&gt;bcp()));
288       }
289       snprintf(fieldbuf, buflen, &quot;%sistate-&gt;%s&quot;,
290                field[strlen(field) - 1] == &#39;)&#39; ? &quot;(&quot;: &quot;&quot;, field);
291     }
292     else if (addr == (intptr_t *) istate) {
293       strncpy(fieldbuf, &quot;(vtable for istate)&quot;, buflen);
294     }
295     return;
296   }
297 
298   // Variable part
299   if (!is_valid)
300     return;
301 
302   // JNI stuff
303   if (istate-&gt;method()-&gt;is_native() &amp;&amp; addr &lt; istate-&gt;stack_base()) {
304     address hA = istate-&gt;method()-&gt;signature_handler();
305     if (hA != NULL) {
306       if (hA != (address) InterpreterRuntime::slow_signature_handler) {
307         InterpreterRuntime::SignatureHandler *handler =
308           InterpreterRuntime::SignatureHandler::from_handlerAddr(hA);
309 
310         intptr_t *params = istate-&gt;stack_base() - handler-&gt;argument_count();
311         if (addr &gt;= params) {
312           int param = addr - params;
313           const char *desc = &quot;&quot;;
314           if (param == 0)
315             desc = &quot; (JNIEnv)&quot;;
316           else if (param == 1) {
317             if (istate-&gt;method()-&gt;is_static())
318               desc = &quot; (mirror)&quot;;
319             else
320               desc = &quot; (this)&quot;;
321           }
322           snprintf(fieldbuf, buflen, &quot;parameter[%d]%s&quot;, param, desc);
323           return;
324         }
325 
326         for (int i = 0; i &lt; handler-&gt;argument_count(); i++) {
327           if (params[i] == (intptr_t) addr) {
328             snprintf(fieldbuf, buflen, &quot;unboxed parameter[%d]&quot;, i);
329             return;
330           }
331         }
332       }
333     }
334     return;
335   }
336 
337   // Monitors and stack
338   identify_vp_word(frame_index, addr,
339                    (intptr_t *) istate-&gt;monitor_base(),
340                    istate-&gt;stack_base(),
341                    fieldbuf, buflen);
342 }
343 
344 void ZeroFrame::identify_vp_word(int       frame_index,
345                                  intptr_t* addr,
346                                  intptr_t* monitor_base,
347                                  intptr_t* stack_base,
348                                  char*     fieldbuf,
349                                  int       buflen) const {
350   // Monitors
351   if (addr &gt;= stack_base &amp;&amp; addr &lt; monitor_base) {
352     int monitor_size = frame::interpreter_frame_monitor_size();
353     int last_index = (monitor_base - stack_base) / monitor_size - 1;
354     int index = last_index - (addr - stack_base) / monitor_size;
355     intptr_t monitor = (intptr_t) (
356       (BasicObjectLock *) monitor_base - 1 - index);
357     intptr_t offset = (intptr_t) addr - monitor;
358 
359     if (offset == BasicObjectLock::obj_offset_in_bytes())
360       snprintf(fieldbuf, buflen, &quot;monitor[%d]-&gt;_obj&quot;, index);
361     else if (offset ==  BasicObjectLock::lock_offset_in_bytes())
362       snprintf(fieldbuf, buflen, &quot;monitor[%d]-&gt;_lock&quot;, index);
363 
364     return;
365   }
366 
367   // Expression stack
368   if (addr &lt; stack_base) {
369     snprintf(fieldbuf, buflen, &quot;%s[%d]&quot;,
370              frame_index == 0 ? &quot;stack_word&quot; : &quot;local&quot;,
371              (int) (stack_base - addr - 1));
372     return;
373   }
374 }
375 
376 #ifndef PRODUCT
377 
378 void frame::describe_pd(FrameValues&amp; values, int frame_no) {
379 
380 }
381 
382 #endif
383 
384 intptr_t *frame::initial_deoptimization_info() {
385   // unused... but returns fp() to minimize changes introduced by 7087445
386   return fp();
387 }
388 
389 #ifndef PRODUCT
390 // This is a generic constructor which is only used by pns() in debug.cpp.
391 frame::frame(void* sp, void* fp, void* pc) {
392   Unimplemented();
393 }
394 
395 void frame::pd_ps() {}
396 #endif
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
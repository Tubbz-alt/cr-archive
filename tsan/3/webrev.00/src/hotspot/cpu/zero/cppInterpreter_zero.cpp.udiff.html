<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/zero/cppInterpreter_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler_zero.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="disassembler_zero.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/zero/cppInterpreter_zero.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -36,17 +36,15 @@</span>
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/synchronizer.hpp&quot;
  #include &quot;runtime/timer.hpp&quot;
  #include &quot;runtime/vframeArray.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -271,16 +269,16 @@</span>
    BasicObjectLock *monitor;
    monitor = NULL;
    if (method-&gt;is_synchronized()) {
      monitor = (BasicObjectLock*) istate-&gt;stack_base();
      oop lockee = monitor-&gt;obj();
<span class="udiff-line-modified-removed">-     markOop disp = lockee-&gt;mark()-&gt;set_unlocked();</span>
<span class="udiff-line-modified-added">+     markWord disp = lockee-&gt;mark().set_unlocked();</span>
  
      monitor-&gt;lock()-&gt;set_displaced_header(disp);
<span class="udiff-line-modified-removed">-     if (lockee-&gt;cas_set_mark((markOop)monitor, disp) != disp) {</span>
<span class="udiff-line-modified-removed">-       if (thread-&gt;is_lock_owned((address) disp-&gt;clear_lock_bits())) {</span>
<span class="udiff-line-modified-removed">-         monitor-&gt;lock()-&gt;set_displaced_header(NULL);</span>
<span class="udiff-line-modified-added">+     if (lockee-&gt;cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {</span>
<span class="udiff-line-modified-added">+       if (thread-&gt;is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {</span>
<span class="udiff-line-modified-added">+         monitor-&gt;lock()-&gt;set_displaced_header(markWord::from_pointer(NULL));</span>
        }
        else {
          CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));
          if (HAS_PENDING_EXCEPTION)
            goto unwind_and_return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -369,18 +367,16 @@</span>
  
    // Make the call
    intptr_t result[4 - LogBytesPerWord];
    ffi_call(handler-&gt;cif(), (void (*)()) function, result, arguments);
  
<span class="udiff-line-modified-removed">-   // Change the thread state back to _thread_in_Java.</span>
<span class="udiff-line-modified-added">+   // Change the thread state back to _thread_in_Java and ensure it</span>
<span class="udiff-line-added">+   // is seen by the GC thread.</span>
    // ThreadStateTransition::transition_from_native() cannot be used
    // here because it does not check for asynchronous exceptions.
    // We have to manage the transition ourself.
<span class="udiff-line-modified-removed">-   thread-&gt;set_thread_state(_thread_in_native_trans);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Make sure new state is visible in the GC thread</span>
<span class="udiff-line-removed">-   InterfaceSupport::serialize_thread_state(thread);</span>
<span class="udiff-line-modified-added">+   thread-&gt;set_thread_state_fence(_thread_in_native_trans);</span>
  
    // Handle safepoint operations, pending suspend requests,
    // and pending asynchronous exceptions.
    if (SafepointMechanism::should_block(thread) ||
        thread-&gt;has_special_condition_for_native_trans()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -413,16 +409,16 @@</span>
   unlock_unwind_and_return:
  
    // Unlock if necessary
    if (monitor) {
      BasicLock *lock = monitor-&gt;lock();
<span class="udiff-line-modified-removed">-     markOop header = lock-&gt;displaced_header();</span>
<span class="udiff-line-modified-added">+     markWord header = lock-&gt;displaced_header();</span>
      oop rcvr = monitor-&gt;obj();
      monitor-&gt;set_obj(NULL);
  
<span class="udiff-line-modified-removed">-     if (header != NULL) {</span>
<span class="udiff-line-modified-removed">-       markOop old_header = markOopDesc::encode(lock);</span>
<span class="udiff-line-modified-added">+     if (header.to_pointer() != NULL) {</span>
<span class="udiff-line-modified-added">+       markWord old_header = markWord::encode(lock);</span>
        if (rcvr-&gt;cas_set_mark(header, old_header) != old_header) {
          monitor-&gt;set_obj(rcvr); {
            HandleMark hm(thread);
            CALL_VM_NOCHECK(InterpreterRuntime::monitorexit(thread, monitor));
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -699,15 +695,15 @@</span>
    int argument_slots = java_lang_invoke_MethodType::ptype_slot_count(method_type);
  
    return stack-&gt;sp() + argument_slots;
  }
  
<span class="udiff-line-modified-removed">- IRT_ENTRY(void, CppInterpreter::throw_exception(JavaThread* thread,</span>
<span class="udiff-line-modified-added">+ JRT_ENTRY(void, CppInterpreter::throw_exception(JavaThread* thread,</span>
                                                  Symbol*     name,
                                                  char*       message))
    THROW_MSG(name, message);
<span class="udiff-line-modified-removed">- IRT_END</span>
<span class="udiff-line-modified-added">+ JRT_END</span>
  
  InterpreterFrame *InterpreterFrame::build(Method* const method, TRAPS) {
    JavaThread *thread = (JavaThread *) THREAD;
    ZeroStack *stack = thread-&gt;zero_stack();
  
</pre>
<center><a href="assembler_zero.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="disassembler_zero.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
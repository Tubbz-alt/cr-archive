<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/zero/stubGenerator_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright 2007, 2008, 2010, 2015 Red Hat, Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/assembler.hpp&quot;
 28 #include &quot;assembler_zero.inline.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;nativeInst_zero.hpp&quot;
 31 #include &quot;oops/instanceOop.hpp&quot;
 32 #include &quot;oops/method.hpp&quot;
 33 #include &quot;oops/objArrayKlass.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;prims/methodHandles.hpp&quot;
 36 #include &quot;runtime/frame.inline.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/sharedRuntime.hpp&quot;
 39 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 40 #include &quot;runtime/stubRoutines.hpp&quot;
 41 #include &quot;runtime/thread.inline.hpp&quot;
 42 #include &quot;stack_zero.inline.hpp&quot;
 43 #ifdef COMPILER2
 44 #include &quot;opto/runtime.hpp&quot;
 45 #endif
 46 
 47 // For SafeFetch we need POSIX tls and setjmp
 48 #include &lt;setjmp.h&gt;
 49 #include &lt;pthread.h&gt;
 50 static pthread_key_t g_jmpbuf_key;
 51 
 52 // return the currently active jump buffer for this thread
 53 //  - if there is any, NULL otherwise. Called from
 54 //    zero signal handlers.
 55 extern sigjmp_buf* get_jmp_buf_for_continuation() {
 56   return (sigjmp_buf*) pthread_getspecific(g_jmpbuf_key);
 57 }
 58 
 59 // Declaration and definition of StubGenerator (no .hpp file).
 60 // For a more detailed description of the stub routine structure
 61 // see the comment in stubRoutines.hpp
 62 
 63 class StubGenerator: public StubCodeGenerator {
 64  private:
 65   // The call stub is used to call Java from C
 66   static void call_stub(
 67     JavaCallWrapper *call_wrapper,
 68     intptr_t*        result,
 69     BasicType        result_type,
 70     Method*          method,
 71     address          entry_point,
 72     intptr_t*        parameters,
 73     int              parameter_words,
 74     TRAPS) {
 75     JavaThread *thread = (JavaThread *) THREAD;
 76     ZeroStack *stack = thread-&gt;zero_stack();
 77 
 78     // Make sure we have no pending exceptions
 79     assert(!HAS_PENDING_EXCEPTION, &quot;call_stub called with pending exception&quot;);
 80 
 81     // Set up the stack if necessary
 82     bool stack_needs_teardown = false;
 83     if (stack-&gt;needs_setup()) {
 84       size_t zero_stack_size = stack-&gt;suggest_size(thread);
 85       stack-&gt;setup(alloca(zero_stack_size), zero_stack_size);
 86       stack_needs_teardown = true;
 87     }
 88 
 89     // Allocate and initialize our frame
 90     EntryFrame *frame =
 91       EntryFrame::build(parameters, parameter_words, call_wrapper, THREAD);
 92 
 93     if (!HAS_PENDING_EXCEPTION) {
 94       // Push the frame
 95       thread-&gt;push_zero_frame(frame);
 96 
 97       // Make the call
 98       Interpreter::invoke_method(method, entry_point, THREAD);
 99 
100       // Store the result
101       if (!HAS_PENDING_EXCEPTION) {
102         switch (result_type) {
103         case T_INT:
104           *(jint *) result = *(jint *) stack-&gt;sp();
105           break;
106         case T_LONG:
107           *(jlong *) result = *(jlong *) stack-&gt;sp();
108           break;
109         case T_FLOAT:
110           *(jfloat *) result = *(jfloat *) stack-&gt;sp();
111           break;
112         case T_DOUBLE:
113           *(jdouble *) result = *(jdouble *) stack-&gt;sp();
114           break;
115         case T_OBJECT:
116           *(oop *) result = *(oop *) stack-&gt;sp();
117           break;
118         default:
119           ShouldNotReachHere();
120         }
121       }
122 
123       // Unwind the frame
124       thread-&gt;pop_zero_frame();
125     }
126 
127     // Tear down the stack if necessary
128     if (stack_needs_teardown)
129       stack-&gt;teardown();
130   }
131 
132   // These stubs get called from some dumb test routine.
133   // I&#39;ll write them properly when they&#39;re called from
134   // something that&#39;s actually doing something.
135   static void fake_arraycopy_stub(address src, address dst, int count) {
136     assert(count == 0, &quot;huh?&quot;);
137   }
138 
139   void generate_arraycopy_stubs() {
140     // Call the conjoint generation methods immediately after
141     // the disjoint ones so that short branches from the former
142     // to the latter can be generated.
143     StubRoutines::_jbyte_disjoint_arraycopy  = (address) fake_arraycopy_stub;
144     StubRoutines::_jbyte_arraycopy           = (address) fake_arraycopy_stub;
145 
146     StubRoutines::_jshort_disjoint_arraycopy = (address) fake_arraycopy_stub;
147     StubRoutines::_jshort_arraycopy          = (address) fake_arraycopy_stub;
148 
149     StubRoutines::_jint_disjoint_arraycopy   = (address) fake_arraycopy_stub;
150     StubRoutines::_jint_arraycopy            = (address) fake_arraycopy_stub;
151 
152     StubRoutines::_jlong_disjoint_arraycopy  = (address) fake_arraycopy_stub;
153     StubRoutines::_jlong_arraycopy           = (address) fake_arraycopy_stub;
154 
155     StubRoutines::_oop_disjoint_arraycopy    = ShouldNotCallThisStub();
156     StubRoutines::_oop_arraycopy             = ShouldNotCallThisStub();
157 
158     StubRoutines::_checkcast_arraycopy       = ShouldNotCallThisStub();
<a name="2" id="anc2"></a><span class="line-removed">159     StubRoutines::_unsafe_arraycopy          = ShouldNotCallThisStub();</span>
160     StubRoutines::_generic_arraycopy         = ShouldNotCallThisStub();
161 
<a name="3" id="anc3"></a>


162     // We don&#39;t generate specialized code for HeapWord-aligned source
163     // arrays, so just use the code we&#39;ve already generated
164     StubRoutines::_arrayof_jbyte_disjoint_arraycopy =
165       StubRoutines::_jbyte_disjoint_arraycopy;
166     StubRoutines::_arrayof_jbyte_arraycopy =
167       StubRoutines::_jbyte_arraycopy;
168 
169     StubRoutines::_arrayof_jshort_disjoint_arraycopy =
170       StubRoutines::_jshort_disjoint_arraycopy;
171     StubRoutines::_arrayof_jshort_arraycopy =
172       StubRoutines::_jshort_arraycopy;
173 
174     StubRoutines::_arrayof_jint_disjoint_arraycopy =
175       StubRoutines::_jint_disjoint_arraycopy;
176     StubRoutines::_arrayof_jint_arraycopy =
177       StubRoutines::_jint_arraycopy;
178 
179     StubRoutines::_arrayof_jlong_disjoint_arraycopy =
180       StubRoutines::_jlong_disjoint_arraycopy;
181     StubRoutines::_arrayof_jlong_arraycopy =
182       StubRoutines::_jlong_arraycopy;
183 
184     StubRoutines::_arrayof_oop_disjoint_arraycopy =
185       StubRoutines::_oop_disjoint_arraycopy;
186     StubRoutines::_arrayof_oop_arraycopy =
187       StubRoutines::_oop_arraycopy;
188   }
189 
190   static int SafeFetch32(int *adr, int errValue) {
191 
192     // set up a jump buffer; anchor the pointer to the jump buffer in tls; then
193     // do the pointer access. If pointer is invalid, we crash; in signal
194     // handler, we retrieve pointer to jmp buffer from tls, and jump back.
195     //
196     // Note: the jump buffer itself - which can get pretty large depending on
197     // the architecture - lives on the stack and that is fine, because we will
198     // not rewind the stack: either we crash, in which case signal handler
199     // frame is below us, or we don&#39;t crash, in which case it does not matter.
200     sigjmp_buf jb;
201     if (sigsetjmp(jb, 1)) {
202       // we crashed. clean up tls and return default value.
203       pthread_setspecific(g_jmpbuf_key, NULL);
204       return errValue;
205     } else {
206       // preparation phase
207       pthread_setspecific(g_jmpbuf_key, &amp;jb);
208     }
209 
210     int value = errValue;
211     value = *adr;
212 
213     // all went well. clean tls.
214     pthread_setspecific(g_jmpbuf_key, NULL);
215 
216     return value;
217   }
218 
219   static intptr_t SafeFetchN(intptr_t *adr, intptr_t errValue) {
220 
221     sigjmp_buf jb;
222     if (sigsetjmp(jb, 1)) {
223       // we crashed. clean up tls and return default value.
224       pthread_setspecific(g_jmpbuf_key, NULL);
225       return errValue;
226     } else {
227       // preparation phase
228       pthread_setspecific(g_jmpbuf_key, &amp;jb);
229     }
230 
231     intptr_t value = errValue;
232     value = *adr;
233 
234     // all went well. clean tls.
235     pthread_setspecific(g_jmpbuf_key, NULL);
236 
237     return value;
238 
239   }
240 
241   void generate_initial() {
242     // Generates all stubs and initializes the entry points
243 
244     // entry points that exist in all platforms Note: This is code
245     // that could be shared among different platforms - however the
246     // benefit seems to be smaller than the disadvantage of having a
247     // much more complicated generator structure. See also comment in
248     // stubRoutines.hpp.
249 
250     StubRoutines::_forward_exception_entry   = ShouldNotCallThisStub();
251     StubRoutines::_call_stub_entry           = (address) call_stub;
252     StubRoutines::_catch_exception_entry     = ShouldNotCallThisStub();
253 
254     // atomic calls
255     StubRoutines::_atomic_xchg_entry         = ShouldNotCallThisStub();
256     StubRoutines::_atomic_xchg_long_entry    = ShouldNotCallThisStub();
257     StubRoutines::_atomic_cmpxchg_entry      = ShouldNotCallThisStub();
258     StubRoutines::_atomic_cmpxchg_byte_entry = ShouldNotCallThisStub();
259     StubRoutines::_atomic_cmpxchg_long_entry = ShouldNotCallThisStub();
260     StubRoutines::_atomic_add_entry          = ShouldNotCallThisStub();
261     StubRoutines::_atomic_add_long_entry     = ShouldNotCallThisStub();
262     StubRoutines::_fence_entry               = ShouldNotCallThisStub();
263   }
264 
265   void generate_all() {
266     // Generates all stubs and initializes the entry points
267 
268     // These entry points require SharedInfo::stack0 to be set up in
269     // non-core builds and need to be relocatable, so they each
270     // fabricate a RuntimeStub internally.
271     StubRoutines::_throw_AbstractMethodError_entry =
272       ShouldNotCallThisStub();
273 
274     StubRoutines::_throw_NullPointerException_at_call_entry =
275       ShouldNotCallThisStub();
276 
277     StubRoutines::_throw_StackOverflowError_entry =
278       ShouldNotCallThisStub();
279 
280     // support for verify_oop (must happen after universe_init)
281     StubRoutines::_verify_oop_subroutine_entry =
282       ShouldNotCallThisStub();
283 
284     // arraycopy stubs used by compilers
285     generate_arraycopy_stubs();
286 
287     // Safefetch stubs.
288     pthread_key_create(&amp;g_jmpbuf_key, NULL);
289     StubRoutines::_safefetch32_entry = CAST_FROM_FN_PTR(address, StubGenerator::SafeFetch32);
290     StubRoutines::_safefetch32_fault_pc = NULL;
291     StubRoutines::_safefetch32_continuation_pc = NULL;
292 
293     StubRoutines::_safefetchN_entry = CAST_FROM_FN_PTR(address, StubGenerator::SafeFetchN);
294     StubRoutines::_safefetchN_fault_pc = NULL;
295     StubRoutines::_safefetchN_continuation_pc = NULL;
296   }
297 
298  public:
299   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
300     if (all) {
301       generate_all();
302     } else {
303       generate_initial();
304     }
305   }
306 };
307 
308 void StubGenerator_generate(CodeBuffer* code, bool all) {
309   StubGenerator g(code, all);
310 }
311 
312 EntryFrame *EntryFrame::build(const intptr_t*  parameters,
313                               int              parameter_words,
314                               JavaCallWrapper* call_wrapper,
315                               TRAPS) {
316 
317   ZeroStack *stack = ((JavaThread *) THREAD)-&gt;zero_stack();
318   stack-&gt;overflow_check(header_words + parameter_words, CHECK_NULL);
319 
320   stack-&gt;push(0); // next_frame, filled in later
321   intptr_t *fp = stack-&gt;sp();
322   assert(fp - stack-&gt;sp() == next_frame_off, &quot;should be&quot;);
323 
324   stack-&gt;push(ENTRY_FRAME);
325   assert(fp - stack-&gt;sp() == frame_type_off, &quot;should be&quot;);
326 
327   stack-&gt;push((intptr_t) call_wrapper);
328   assert(fp - stack-&gt;sp() == call_wrapper_off, &quot;should be&quot;);
329 
330   for (int i = 0; i &lt; parameter_words; i++)
331     stack-&gt;push(parameters[i]);
332 
333   return (EntryFrame *) fp;
334 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
diff a/src/hotspot/cpu/zero/cppInterpreter_zero.cpp b/src/hotspot/cpu/zero/cppInterpreter_zero.cpp
--- a/src/hotspot/cpu/zero/cppInterpreter_zero.cpp
+++ b/src/hotspot/cpu/zero/cppInterpreter_zero.cpp
@@ -36,17 +36,15 @@
 #include "oops/method.hpp"
 #include "oops/oop.inline.hpp"
 #include "prims/jvmtiExport.hpp"
 #include "prims/jvmtiThreadState.hpp"
 #include "runtime/arguments.hpp"
-#include "runtime/atomic.hpp"
 #include "runtime/deoptimization.hpp"
 #include "runtime/frame.inline.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/jniHandles.inline.hpp"
-#include "runtime/orderAccess.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/stubRoutines.hpp"
 #include "runtime/synchronizer.hpp"
 #include "runtime/timer.hpp"
 #include "runtime/vframeArray.hpp"
@@ -271,16 +269,16 @@
   BasicObjectLock *monitor;
   monitor = NULL;
   if (method->is_synchronized()) {
     monitor = (BasicObjectLock*) istate->stack_base();
     oop lockee = monitor->obj();
-    markOop disp = lockee->mark()->set_unlocked();
+    markWord disp = lockee->mark().set_unlocked();
 
     monitor->lock()->set_displaced_header(disp);
-    if (lockee->cas_set_mark((markOop)monitor, disp) != disp) {
-      if (thread->is_lock_owned((address) disp->clear_lock_bits())) {
-        monitor->lock()->set_displaced_header(NULL);
+    if (lockee->cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {
+      if (thread->is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {
+        monitor->lock()->set_displaced_header(markWord::from_pointer(NULL));
       }
       else {
         CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));
         if (HAS_PENDING_EXCEPTION)
           goto unwind_and_return;
@@ -369,18 +367,16 @@
 
   // Make the call
   intptr_t result[4 - LogBytesPerWord];
   ffi_call(handler->cif(), (void (*)()) function, result, arguments);
 
-  // Change the thread state back to _thread_in_Java.
+  // Change the thread state back to _thread_in_Java and ensure it
+  // is seen by the GC thread.
   // ThreadStateTransition::transition_from_native() cannot be used
   // here because it does not check for asynchronous exceptions.
   // We have to manage the transition ourself.
-  thread->set_thread_state(_thread_in_native_trans);
-
-  // Make sure new state is visible in the GC thread
-  InterfaceSupport::serialize_thread_state(thread);
+  thread->set_thread_state_fence(_thread_in_native_trans);
 
   // Handle safepoint operations, pending suspend requests,
   // and pending asynchronous exceptions.
   if (SafepointMechanism::should_block(thread) ||
       thread->has_special_condition_for_native_trans()) {
@@ -413,16 +409,16 @@
  unlock_unwind_and_return:
 
   // Unlock if necessary
   if (monitor) {
     BasicLock *lock = monitor->lock();
-    markOop header = lock->displaced_header();
+    markWord header = lock->displaced_header();
     oop rcvr = monitor->obj();
     monitor->set_obj(NULL);
 
-    if (header != NULL) {
-      markOop old_header = markOopDesc::encode(lock);
+    if (header.to_pointer() != NULL) {
+      markWord old_header = markWord::encode(lock);
       if (rcvr->cas_set_mark(header, old_header) != old_header) {
         monitor->set_obj(rcvr); {
           HandleMark hm(thread);
           CALL_VM_NOCHECK(InterpreterRuntime::monitorexit(thread, monitor));
         }
@@ -699,15 +695,15 @@
   int argument_slots = java_lang_invoke_MethodType::ptype_slot_count(method_type);
 
   return stack->sp() + argument_slots;
 }
 
-IRT_ENTRY(void, CppInterpreter::throw_exception(JavaThread* thread,
+JRT_ENTRY(void, CppInterpreter::throw_exception(JavaThread* thread,
                                                 Symbol*     name,
                                                 char*       message))
   THROW_MSG(name, message);
-IRT_END
+JRT_END
 
 InterpreterFrame *InterpreterFrame::build(Method* const method, TRAPS) {
   JavaThread *thread = (JavaThread *) THREAD;
   ZeroStack *stack = thread->zero_stack();
 

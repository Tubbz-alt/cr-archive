<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/zero/sharedRuntime_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/assembler.hpp&quot;
 28 #include &quot;assembler_zero.inline.hpp&quot;
 29 #include &quot;code/debugInfoRec.hpp&quot;
 30 #include &quot;code/icBuffer.hpp&quot;
 31 #include &quot;code/vtableStubs.hpp&quot;
 32 #include &quot;interpreter/interpreter.hpp&quot;
 33 #include &quot;oops/compiledICHolder.hpp&quot;
 34 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 35 #include &quot;runtime/sharedRuntime.hpp&quot;
 36 #include &quot;runtime/vframeArray.hpp&quot;
 37 #include &quot;vmreg_zero.inline.hpp&quot;
 38 
 39 #ifdef COMPILER1
 40 #include &quot;c1/c1_Runtime1.hpp&quot;
 41 #endif
 42 #ifdef COMPILER2
 43 #include &quot;opto/runtime.hpp&quot;
 44 #endif
 45 
 46 
 47 static address zero_null_code_stub() {
 48   address start = ShouldNotCallThisStub();
 49   return start;
 50 }
 51 
 52 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 53                                            VMRegPair *regs,
 54                                            int total_args_passed,
 55                                            int is_outgoing) {
 56   return 0;
 57 }
 58 
 59 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(
 60                         MacroAssembler *masm,
 61                         int total_args_passed,
 62                         int comp_args_on_stack,
 63                         const BasicType *sig_bt,
 64                         const VMRegPair *regs,
 65                         AdapterFingerPrint *fingerprint) {
 66   return AdapterHandlerLibrary::new_entry(
 67     fingerprint,
 68     CAST_FROM_FN_PTR(address,zero_null_code_stub),
 69     CAST_FROM_FN_PTR(address,zero_null_code_stub),
 70     CAST_FROM_FN_PTR(address,zero_null_code_stub));
 71 }
 72 
 73 nmethod *SharedRuntime::generate_native_wrapper(MacroAssembler *masm,
 74                                                 const methodHandle&amp; method,
 75                                                 int compile_id,
 76                                                 BasicType *sig_bt,
 77                                                 VMRegPair *regs,
 78                                                 BasicType ret_type,
 79                                                 address critical_entry) {
 80   ShouldNotCallThis();
 81   return NULL;
 82 }
 83 
 84 int Deoptimization::last_frame_adjust(int callee_parameters,
 85                                       int callee_locals) {
 86   return 0;
 87 }
 88 
 89 uint SharedRuntime::out_preserve_stack_slots() {
 90   ShouldNotCallThis();
 91   return 0;
 92 }
 93 
 94 JRT_LEAF(void, zero_stub())
 95   ShouldNotCallThis();
 96 JRT_END
 97 
 98 static RuntimeStub* generate_empty_runtime_stub(const char* name) {
 99   return CAST_FROM_FN_PTR(RuntimeStub*,zero_stub);
100 }
101 
102 static SafepointBlob* generate_empty_safepoint_blob() {
103   return CAST_FROM_FN_PTR(SafepointBlob*,zero_stub);
104 }
105 
106 static DeoptimizationBlob* generate_empty_deopt_blob() {
107   return CAST_FROM_FN_PTR(DeoptimizationBlob*,zero_stub);
108 }
109 
110 
111 void SharedRuntime::generate_deopt_blob() {
112   _deopt_blob = generate_empty_deopt_blob();
113 }
114 
115 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
116   return generate_empty_safepoint_blob();
117 }
118 
119 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
120   return generate_empty_runtime_stub(&quot;resolve_blob&quot;);
121 }
122 
123 size_t SharedRuntime::trampoline_size() {
124   ShouldNotCallThis();
125   return 0;
126 }
127 
128 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
129   ShouldNotCallThis();
130   return;
131 }
132 
133 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
134                                          VMRegPair *regs,
135                                          VMRegPair *regs2,
136                                          int total_args_passed) {
137   ShouldNotCallThis();
138   return 0;
139 }
    </pre>
  </body>
</html>
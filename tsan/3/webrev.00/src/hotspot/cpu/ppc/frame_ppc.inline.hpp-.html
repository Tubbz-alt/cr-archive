<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/ppc/frame_ppc.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2012, 2015 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_PPC_FRAME_PPC_INLINE_HPP
 27 #define CPU_PPC_FRAME_PPC_INLINE_HPP
 28 
 29 #include &quot;code/codeCache.hpp&quot;
 30 #include &quot;code/vmreg.inline.hpp&quot;
 31 #include &quot;utilities/align.hpp&quot;
 32 
 33 // Inline functions for ppc64 frames:
 34 
 35 // Find codeblob and set deopt_state.
 36 inline void frame::find_codeblob_and_set_pc_and_deopt_state(address pc) {
 37   assert(pc != NULL, &quot;precondition: must have PC&quot;);
 38 
 39   _cb = CodeCache::find_blob(pc);
 40   _pc = pc;   // Must be set for get_deopt_original_pc()
 41 
 42   _fp = (intptr_t*)own_abi()-&gt;callers_sp;
 43 
 44   address original_pc = CompiledMethod::get_deopt_original_pc(this);
 45   if (original_pc != NULL) {
 46     _pc = original_pc;
 47     _deopt_state = is_deoptimized;
 48   } else {
 49     _deopt_state = not_deoptimized;
 50   }
 51 
 52   assert(((uint64_t)_sp &amp; 0xf) == 0, &quot;SP must be 16-byte aligned&quot;);
 53 }
 54 
 55 // Constructors
 56 
 57 // Initialize all fields, _unextended_sp will be adjusted in find_codeblob_and_set_pc_and_deopt_state.
 58 inline frame::frame() : _sp(NULL), _pc(NULL), _cb(NULL),  _deopt_state(unknown), _unextended_sp(NULL), _fp(NULL) {}
 59 
 60 inline frame::frame(intptr_t* sp) : _sp(sp), _unextended_sp(sp) {
 61   find_codeblob_and_set_pc_and_deopt_state((address)own_abi()-&gt;lr); // also sets _fp and adjusts _unextended_sp
 62 }
 63 
 64 inline frame::frame(intptr_t* sp, address pc) : _sp(sp), _unextended_sp(sp) {
 65   find_codeblob_and_set_pc_and_deopt_state(pc); // also sets _fp and adjusts _unextended_sp
 66 }
 67 
 68 inline frame::frame(intptr_t* sp, address pc, intptr_t* unextended_sp) : _sp(sp), _unextended_sp(unextended_sp) {
 69   find_codeblob_and_set_pc_and_deopt_state(pc); // also sets _fp and adjusts _unextended_sp
 70 }
 71 
 72 // Accessors
 73 
 74 // Return unique id for this frame. The id must have a value where we
 75 // can distinguish identity and younger/older relationship. NULL
 76 // represents an invalid (incomparable) frame.
 77 inline intptr_t* frame::id(void) const {
 78   // Use _fp. _sp or _unextended_sp wouldn&#39;t be correct due to resizing.
 79   return _fp;
 80 }
 81 
 82 // Return true if this frame is older (less recent activation) than
 83 // the frame represented by id.
 84 inline bool frame::is_older(intptr_t* id) const {
 85    assert(this-&gt;id() != NULL &amp;&amp; id != NULL, &quot;NULL frame id&quot;);
 86    // Stack grows towards smaller addresses on ppc64.
 87    return this-&gt;id() &gt; id;
 88 }
 89 
 90 inline int frame::frame_size(RegisterMap* map) const {
 91   // Stack grows towards smaller addresses on PPC64: sender is at a higher address.
 92   return sender_sp() - sp();
 93 }
 94 
 95 // Return the frame&#39;s stack pointer before it has been extended by a
 96 // c2i adapter. This is needed by deoptimization for ignoring c2i adapter
 97 // frames.
 98 inline intptr_t* frame::unextended_sp() const {
 99   return _unextended_sp;
100 }
101 
102 // All frames have this field.
103 inline address frame::sender_pc() const {
104   return (address)callers_abi()-&gt;lr;
105 }
106 inline address* frame::sender_pc_addr() const {
107   return (address*)&amp;(callers_abi()-&gt;lr);
108 }
109 
110 // All frames have this field.
111 inline intptr_t* frame::sender_sp() const {
112   return (intptr_t*)callers_abi();
113 }
114 
115 // All frames have this field.
116 inline intptr_t* frame::link() const {
117   return (intptr_t*)callers_abi()-&gt;callers_sp;
118 }
119 
120 inline intptr_t* frame::real_fp() const {
121   return fp();
122 }
123 
124 // Template Interpreter frame value accessors.
125 
126 inline frame::ijava_state* frame::get_ijava_state() const {
127   return (ijava_state*) ((uintptr_t)fp() - ijava_state_size);
128 }
129 
130 inline intptr_t** frame::interpreter_frame_locals_addr() const {
131   return (intptr_t**) &amp;(get_ijava_state()-&gt;locals);
132 }
133 inline intptr_t* frame::interpreter_frame_bcp_addr() const {
134   return (intptr_t*) &amp;(get_ijava_state()-&gt;bcp);
135 }
136 inline intptr_t* frame::interpreter_frame_mdp_addr() const {
137   return (intptr_t*) &amp;(get_ijava_state()-&gt;mdx);
138 }
139 // Pointer beyond the &quot;oldest/deepest&quot; BasicObjectLock on stack.
140 inline BasicObjectLock* frame::interpreter_frame_monitor_end() const {
141   return (BasicObjectLock *) get_ijava_state()-&gt;monitors;
142 }
143 
144 inline BasicObjectLock* frame::interpreter_frame_monitor_begin() const {
145   return (BasicObjectLock *) get_ijava_state();
146 }
147 
148 // Return register stack slot addr at which currently interpreted method is found.
149 inline Method** frame::interpreter_frame_method_addr() const {
150   return (Method**) &amp;(get_ijava_state()-&gt;method);
151 }
152 
153 inline oop* frame::interpreter_frame_mirror_addr() const {
154   return (oop*) &amp;(get_ijava_state()-&gt;mirror);
155 }
156 
157 inline ConstantPoolCache** frame::interpreter_frame_cpoolcache_addr() const {
158   return (ConstantPoolCache**) &amp;(get_ijava_state()-&gt;cpoolCache);
159 }
160 inline ConstantPoolCache** frame::interpreter_frame_cache_addr() const {
161   return (ConstantPoolCache**) &amp;(get_ijava_state()-&gt;cpoolCache);
162 }
163 
164 inline oop* frame::interpreter_frame_temp_oop_addr() const {
165   return (oop *) &amp;(get_ijava_state()-&gt;oop_tmp);
166 }
167 inline intptr_t* frame::interpreter_frame_esp() const {
168   return (intptr_t*) get_ijava_state()-&gt;esp;
169 }
170 
171 // Convenient setters
172 inline void frame::interpreter_frame_set_monitor_end(BasicObjectLock* end)    { get_ijava_state()-&gt;monitors = (intptr_t) end;}
173 inline void frame::interpreter_frame_set_cpcache(ConstantPoolCache* cp)       { *frame::interpreter_frame_cpoolcache_addr() = cp; }
174 inline void frame::interpreter_frame_set_esp(intptr_t* esp)                   { get_ijava_state()-&gt;esp = (intptr_t) esp; }
175 inline void frame::interpreter_frame_set_top_frame_sp(intptr_t* top_frame_sp) { get_ijava_state()-&gt;top_frame_sp = (intptr_t) top_frame_sp; }
176 inline void frame::interpreter_frame_set_sender_sp(intptr_t* sender_sp)       { get_ijava_state()-&gt;sender_sp = (intptr_t) sender_sp; }
177 
178 inline intptr_t* frame::interpreter_frame_expression_stack() const {
179   return (intptr_t*)interpreter_frame_monitor_end() - 1;
180 }
181 
182 // top of expression stack
183 inline intptr_t* frame::interpreter_frame_tos_address() const {
184   return ((intptr_t*) get_ijava_state()-&gt;esp) + Interpreter::stackElementWords;
185 }
186 
187 inline intptr_t* frame::interpreter_frame_tos_at(jint offset) const {
188   return &amp;interpreter_frame_tos_address()[offset];
189 }
190 
191 inline int frame::interpreter_frame_monitor_size() {
192   // Number of stack slots for a monitor.
193   return align_up(BasicObjectLock::size(),  // number of stack slots
194                   WordsPerLong);            // number of stack slots for a Java long
195 }
196 
197 inline int frame::interpreter_frame_monitor_size_in_bytes() {
198   return frame::interpreter_frame_monitor_size() * wordSize;
199 }
200 
201 // entry frames
202 
203 inline intptr_t* frame::entry_frame_argument_at(int offset) const {
204   // Since an entry frame always calls the interpreter first, the
205   // parameters are on the stack and relative to known register in the
206   // entry frame.
207   intptr_t* tos = (intptr_t*)get_entry_frame_locals()-&gt;arguments_tos_address;
208   return &amp;tos[offset + 1]; // prepushed tos
209 }
210 
211 inline JavaCallWrapper** frame::entry_frame_call_wrapper_addr() const {
212   return (JavaCallWrapper**)&amp;get_entry_frame_locals()-&gt;call_wrapper_address;
213 }
214 
215 inline oop frame::saved_oop_result(RegisterMap* map) const {
216   return *((oop*)map-&gt;location(R3-&gt;as_VMReg()));
217 }
218 
219 inline void frame::set_saved_oop_result(RegisterMap* map, oop obj) {
220   *((oop*)map-&gt;location(R3-&gt;as_VMReg())) = obj;
221 }
222 
223 #endif // CPU_PPC_FRAME_PPC_INLINE_HPP
    </pre>
  </body>
</html>
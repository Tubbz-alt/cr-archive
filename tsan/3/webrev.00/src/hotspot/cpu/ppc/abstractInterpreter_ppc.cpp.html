<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/ppc/abstractInterpreter_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2015 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;oops/constMethod.hpp&quot;
 29 #include &quot;oops/klass.inline.hpp&quot;
 30 #include &quot;oops/method.hpp&quot;
 31 #include &quot;runtime/frame.inline.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 
 35 int AbstractInterpreter::BasicType_as_index(BasicType type) {
 36   int i = 0;
 37   switch (type) {
 38     case T_BOOLEAN: i = 0; break;
 39     case T_CHAR   : i = 1; break;
 40     case T_BYTE   : i = 2; break;
 41     case T_SHORT  : i = 3; break;
 42     case T_INT    : i = 4; break;
 43     case T_LONG   : i = 5; break;
 44     case T_VOID   : i = 6; break;
 45     case T_FLOAT  : i = 7; break;
 46     case T_DOUBLE : i = 8; break;
 47     case T_OBJECT : i = 9; break;
 48     case T_ARRAY  : i = 9; break;
 49     default       : ShouldNotReachHere();
 50   }
 51   assert(0 &lt;= i &amp;&amp; i &lt; AbstractInterpreter::number_of_result_handlers, &quot;index out of bounds&quot;);
 52   return i;
 53 }
 54 
 55 // How much stack a method activation needs in stack slots.
 56 // We must calc this exactly like in generate_fixed_frame.
 57 // Note: This returns the conservative size assuming maximum alignment.
 58 int AbstractInterpreter::size_top_interpreter_activation(Method* method) {
 59   const int max_alignment_size = 2;
 60   const int abi_scratch = frame::abi_reg_args_size;
 61   return method-&gt;max_locals() + method-&gt;max_stack() +
 62          frame::interpreter_frame_monitor_size() + max_alignment_size + abi_scratch;
 63 }
 64 
 65 // Returns number of stackElementWords needed for the interpreter frame with the
 66 // given sections.
 67 // This overestimates the stack by one slot in case of alignments.
 68 int AbstractInterpreter::size_activation(int max_stack,
 69                                          int temps,
 70                                          int extra_args,
 71                                          int monitors,
 72                                          int callee_params,
 73                                          int callee_locals,
 74                                          bool is_top_frame) {
 75   // Note: This calculation must exactly parallel the frame setup
 76   // in TemplateInterpreterGenerator::generate_fixed_frame.
 77   assert(Interpreter::stackElementWords == 1, &quot;sanity&quot;);
 78   const int max_alignment_space = StackAlignmentInBytes / Interpreter::stackElementSize;
 79   const int abi_scratch = is_top_frame ? (frame::abi_reg_args_size / Interpreter::stackElementSize) :
 80                                          (frame::abi_minframe_size / Interpreter::stackElementSize);
 81   const int size =
 82     max_stack                                                +
 83     (callee_locals - callee_params)                          +
 84     monitors * frame::interpreter_frame_monitor_size()       +
 85     max_alignment_space                                      +
 86     abi_scratch                                              +
 87     frame::ijava_state_size / Interpreter::stackElementSize;
 88 
 89   // Fixed size of an interpreter frame, align to 16-byte.
 90   return (size &amp; -2);
 91 }
 92 
 93 // Fills a sceletal interpreter frame generated during deoptimizations.
 94 //
 95 // Parameters:
 96 //
 97 // interpreter_frame != NULL:
 98 //   set up the method, locals, and monitors.
 99 //   The frame interpreter_frame, if not NULL, is guaranteed to be the
100 //   right size, as determined by a previous call to this method.
101 //   It is also guaranteed to be walkable even though it is in a skeletal state
102 //
103 // is_top_frame == true:
104 //   We&#39;re processing the *oldest* interpreter frame!
105 //
106 // pop_frame_extra_args:
107 //   If this is != 0 we are returning to a deoptimized frame by popping
108 //   off the callee frame. We want to re-execute the call that called the
109 //   callee interpreted, but since the return to the interpreter would pop
110 //   the arguments off advance the esp by dummy popframe_extra_args slots.
111 //   Popping off those will establish the stack layout as it was before the call.
112 //
113 void AbstractInterpreter::layout_activation(Method* method,
114                                             int tempcount,
115                                             int popframe_extra_args,
116                                             int moncount,
117                                             int caller_actual_parameters,
118                                             int callee_param_count,
119                                             int callee_locals_count,
120                                             frame* caller,
121                                             frame* interpreter_frame,
122                                             bool is_top_frame,
123                                             bool is_bottom_frame) {
124 
125   const int abi_scratch = is_top_frame ? (frame::abi_reg_args_size / Interpreter::stackElementSize) :
126                                          (frame::abi_minframe_size / Interpreter::stackElementSize);
127 
128   intptr_t* locals_base  = (caller-&gt;is_interpreted_frame()) ?
129     caller-&gt;interpreter_frame_esp() + caller_actual_parameters :
130     caller-&gt;sp() + method-&gt;max_locals() - 1 + (frame::abi_minframe_size / Interpreter::stackElementSize);
131 
132   intptr_t* monitor_base = caller-&gt;sp() - frame::ijava_state_size / Interpreter::stackElementSize;
133   intptr_t* monitor      = monitor_base - (moncount * frame::interpreter_frame_monitor_size());
134   intptr_t* esp_base     = monitor - 1;
135   intptr_t* esp          = esp_base - tempcount - popframe_extra_args;
136   intptr_t* sp           = (intptr_t *) (((intptr_t) (esp_base - callee_locals_count + callee_param_count - method-&gt;max_stack()- abi_scratch)) &amp; -StackAlignmentInBytes);
137   intptr_t* sender_sp    = caller-&gt;sp() + (frame::abi_minframe_size - frame::abi_reg_args_size) / Interpreter::stackElementSize;
138   intptr_t* top_frame_sp = is_top_frame ? sp : sp + (frame::abi_minframe_size - frame::abi_reg_args_size) / Interpreter::stackElementSize;
139 
140   interpreter_frame-&gt;interpreter_frame_set_method(method);
141   interpreter_frame-&gt;interpreter_frame_set_mirror(method-&gt;method_holder()-&gt;java_mirror());
142   interpreter_frame-&gt;interpreter_frame_set_locals(locals_base);
143   interpreter_frame-&gt;interpreter_frame_set_cpcache(method-&gt;constants()-&gt;cache());
144   interpreter_frame-&gt;interpreter_frame_set_esp(esp);
145   interpreter_frame-&gt;interpreter_frame_set_monitor_end((BasicObjectLock *)monitor);
146   interpreter_frame-&gt;interpreter_frame_set_top_frame_sp(top_frame_sp);
147   if (!is_bottom_frame) {
148     interpreter_frame-&gt;interpreter_frame_set_sender_sp(sender_sp);
149   }
150 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/ppc/c1_LIRAssembler_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap_ppc.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_ppc.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/c1_LIRAssembler_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -31,17 +31,18 @@</span>
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;c1/c1_ValueStack.hpp&quot;
  #include &quot;ci/ciArrayKlass.hpp&quot;
  #include &quot;ci/ciInstance.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;nativeInst_ppc.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  #define __ _masm-&gt;
  
  
  const ConditionRegister LIR_Assembler::BOOL_RESULT = CCR5;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -75,10 +76,25 @@</span>
    int offset = __ offset();
    __ inline_cache_check(R3_ARG1, R19_inline_cache_reg);
    return offset;
  }
  
<span class="udiff-line-added">+ void LIR_Assembler::clinit_barrier(ciMethod* method) {</span>
<span class="udiff-line-added">+   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Label L_skip_barrier;</span>
<span class="udiff-line-added">+   Register klass = R20;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   metadata2reg(method-&gt;holder()-&gt;constant_encoding(), klass);</span>
<span class="udiff-line-added">+   __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);</span>
<span class="udiff-line-added">+   __ mtctr(klass);</span>
<span class="udiff-line-added">+   __ bctr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ bind(L_skip_barrier);</span>
<span class="udiff-line-added">+ }</span>
  
  void LIR_Assembler::osr_entry() {
    // On-stack-replacement entry sequence:
    //
    //   1. Create a new compiled activation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -724,14 +740,15 @@</span>
        case T_OBJECT:
          {
            if (UseCompressedOops &amp;&amp; !wide) {
              // Encoding done in caller
              __ stw(from_reg-&gt;as_register(), offset, base);
<span class="udiff-line-added">+             __ verify_coop(from_reg-&gt;as_register(), FILE_AND_LINE);</span>
            } else {
              __ std(from_reg-&gt;as_register(), offset, base);
<span class="udiff-line-added">+             __ verify_oop(from_reg-&gt;as_register(), FILE_AND_LINE);</span>
            }
<span class="udiff-line-removed">-           __ verify_oop(from_reg-&gt;as_register());</span>
            break;
          }
        case T_FLOAT : __ stfs(from_reg-&gt;as_float_reg(), offset, base); break;
        case T_DOUBLE: __ stfd(from_reg-&gt;as_double_reg(), offset, base); break;
        default      : ShouldNotReachHere();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -764,14 +781,15 @@</span>
      case T_OBJECT:
        {
          if (UseCompressedOops &amp;&amp; !wide) {
            // Encoding done in caller.
            __ stwx(from_reg-&gt;as_register(), base, disp);
<span class="udiff-line-added">+           __ verify_coop(from_reg-&gt;as_register(), FILE_AND_LINE); // kills R0</span>
          } else {
            __ stdx(from_reg-&gt;as_register(), base, disp);
<span class="udiff-line-added">+           __ verify_oop(from_reg-&gt;as_register(), FILE_AND_LINE); // kills R0</span>
          }
<span class="udiff-line-removed">-         __ verify_oop(from_reg-&gt;as_register()); // kills R0</span>
          break;
        }
      case T_FLOAT : __ stfsx(from_reg-&gt;as_float_reg(), base, disp); break;
      case T_DOUBLE: __ stfdx(from_reg-&gt;as_double_reg(), base, disp); break;
      default      : ShouldNotReachHere();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -812,11 +830,11 @@</span>
              __ lwz(to_reg-&gt;as_register(), offset, base);
              __ decode_heap_oop(to_reg-&gt;as_register());
            } else {
              __ ld(to_reg-&gt;as_register(), offset, base);
            }
<span class="udiff-line-modified-removed">-           __ verify_oop(to_reg-&gt;as_register());</span>
<span class="udiff-line-modified-added">+           __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);</span>
            break;
          }
        case T_FLOAT:  __ lfs(to_reg-&gt;as_float_reg(), offset, base); break;
        case T_DOUBLE: __ lfd(to_reg-&gt;as_double_reg(), offset, base); break;
        default      : ShouldNotReachHere();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -843,11 +861,11 @@</span>
            __ lwzx(to_reg-&gt;as_register(), base, disp);
            __ decode_heap_oop(to_reg-&gt;as_register());
          } else {
            __ ldx(to_reg-&gt;as_register(), base, disp);
          }
<span class="udiff-line-modified-removed">-         __ verify_oop(to_reg-&gt;as_register());</span>
<span class="udiff-line-modified-added">+         __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);</span>
          break;
        }
      case T_FLOAT:  __ lfsx(to_reg-&gt;as_float_reg() , base, disp); break;
      case T_DOUBLE: __ lfdx(to_reg-&gt;as_double_reg(), base, disp); break;
      case T_LONG  :
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1122,11 +1140,11 @@</span>
    if (info != NULL &amp;&amp; needs_explicit_null_check) {
      explicit_null_check(src, info);
    }
  
    if (addr-&gt;base()-&gt;type() == T_OBJECT) {
<span class="udiff-line-modified-removed">-     __ verify_oop(src);</span>
<span class="udiff-line-modified-added">+     __ verify_oop(src, FILE_AND_LINE);</span>
    }
  
    PatchingStub* patch = NULL;
    if (needs_patching) {
      patch = new PatchingStub(_masm, PatchingStub::access_field_id);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1218,12 +1236,12 @@</span>
        __ mr_if_needed(to_reg-&gt;as_register(), from_reg-&gt;as_register());
      }
    } else {
      ShouldNotReachHere();
    }
<span class="udiff-line-modified-removed">-   if (to_reg-&gt;type() == T_OBJECT || to_reg-&gt;type() == T_ARRAY) {</span>
<span class="udiff-line-modified-removed">-     __ verify_oop(to_reg-&gt;as_register());</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(to_reg-&gt;type())) {</span>
<span class="udiff-line-modified-added">+     __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);</span>
    }
  }
  
  
  void LIR_Assembler::reg2mem(LIR_Opr from_reg, LIR_Opr dest, BasicType type,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1234,23 +1252,23 @@</span>
  
    Register src = addr-&gt;base()-&gt;as_pointer_register();
    Register disp_reg = noreg;
    int disp_value = addr-&gt;disp();
    bool needs_patching = (patch_code != lir_patch_none);
<span class="udiff-line-modified-removed">-   bool compress_oop = (type == T_ARRAY || type == T_OBJECT) &amp;&amp; UseCompressedOops &amp;&amp; !wide &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                       Universe::narrow_oop_mode() != Universe::UnscaledNarrowOop;</span>
<span class="udiff-line-modified-added">+   bool compress_oop = (is_reference_type(type)) &amp;&amp; UseCompressedOops &amp;&amp; !wide &amp;&amp;</span>
<span class="udiff-line-modified-added">+                       CompressedOops::mode() != CompressedOops::UnscaledNarrowOop;</span>
    bool load_disp = addr-&gt;index()-&gt;is_illegal() &amp;&amp; !Assembler::is_simm16(disp_value);
    bool use_R29 = compress_oop &amp;&amp; load_disp; // Avoid register conflict, also do null check before killing R29.
    // Null check for large offsets in LIRGenerator::do_StoreField.
    bool needs_explicit_null_check = !ImplicitNullChecks || use_R29;
  
    if (info != NULL &amp;&amp; needs_explicit_null_check) {
      explicit_null_check(src, info);
    }
  
    if (addr-&gt;base()-&gt;is_oop_register()) {
<span class="udiff-line-modified-removed">-     __ verify_oop(src);</span>
<span class="udiff-line-modified-added">+     __ verify_oop(src, FILE_AND_LINE);</span>
    }
  
    PatchingStub* patch = NULL;
    if (needs_patching) {
      patch = new PatchingStub(_masm, PatchingStub::access_field_id);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1448,22 +1466,33 @@</span>
                __ cmpd(BOOL_RESULT, opr1-&gt;as_register(), R0);
              }
            }
            break;
  
<span class="udiff-line-added">+         case T_METADATA:</span>
<span class="udiff-line-added">+           // We only need, for now, comparison with NULL for metadata.</span>
<span class="udiff-line-added">+           {</span>
<span class="udiff-line-added">+             assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);</span>
<span class="udiff-line-added">+             Metadata* p = opr2-&gt;as_constant_ptr()-&gt;as_metadata();</span>
<span class="udiff-line-added">+             if (p == NULL) {</span>
<span class="udiff-line-added">+               __ cmpdi(BOOL_RESULT, opr1-&gt;as_register(), 0);</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+               ShouldNotReachHere();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           break;</span>
<span class="udiff-line-added">+ </span>
          default:
            ShouldNotReachHere();
            break;
        }
      } else {
<span class="udiff-line-modified-removed">-       if (opr2-&gt;is_address()) {</span>
<span class="udiff-line-modified-removed">-         DEBUG_ONLY( Unimplemented(); ) // Seems to be unused at the moment.</span>
<span class="udiff-line-modified-removed">-         LIR_Address *addr = opr2-&gt;as_address_ptr();</span>
<span class="udiff-line-modified-removed">-         BasicType type = addr-&gt;type();</span>
<span class="udiff-line-modified-removed">-         if (type == T_OBJECT) { __ ld(R0, index_or_disp(addr), addr-&gt;base()-&gt;as_register()); }</span>
<span class="udiff-line-removed">-         else                  { __ lwa(R0, index_or_disp(addr), addr-&gt;base()-&gt;as_register()); }</span>
<span class="udiff-line-removed">-         __ cmpd(BOOL_RESULT, opr1-&gt;as_register(), R0);</span>
<span class="udiff-line-modified-added">+       assert(opr1-&gt;type() != T_ADDRESS &amp;&amp; opr2-&gt;type() != T_ADDRESS, &quot;currently unsupported&quot;);</span>
<span class="udiff-line-modified-added">+       if (is_reference_type(opr1-&gt;type())) {</span>
<span class="udiff-line-modified-added">+         // There are only equal/notequal comparisons on objects.</span>
<span class="udiff-line-modified-added">+         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);</span>
<span class="udiff-line-modified-added">+         __ cmpd(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());</span>
        } else {
          if (unsigned_comp) {
            __ cmplw(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());
          } else {
            __ cmpw(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1495,18 +1524,10 @@</span>
          __ cmpd(BOOL_RESULT, opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo());
        }
      } else {
        ShouldNotReachHere();
      }
<span class="udiff-line-removed">-   } else if (opr1-&gt;is_address()) {</span>
<span class="udiff-line-removed">-     DEBUG_ONLY( Unimplemented(); ) // Seems to be unused at the moment.</span>
<span class="udiff-line-removed">-     LIR_Address * addr = opr1-&gt;as_address_ptr();</span>
<span class="udiff-line-removed">-     BasicType type = addr-&gt;type();</span>
<span class="udiff-line-removed">-     assert (opr2-&gt;is_constant(), &quot;Checking&quot;);</span>
<span class="udiff-line-removed">-     if (type == T_OBJECT) { __ ld(R0, index_or_disp(addr), addr-&gt;base()-&gt;as_register()); }</span>
<span class="udiff-line-removed">-     else                  { __ lwa(R0, index_or_disp(addr), addr-&gt;base()-&gt;as_register()); }</span>
<span class="udiff-line-removed">-     __ cmpdi(BOOL_RESULT, R0, opr2-&gt;as_constant_ptr()-&gt;as_jint());</span>
    } else {
      ShouldNotReachHere();
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1704,16 +1725,10 @@</span>
      }
    }
  }
  
  
<span class="udiff-line-removed">- void LIR_Assembler::fpop() {</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">-   // do nothing</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
    switch (code) {
      case lir_sqrt: {
        __ fsqrt(dest-&gt;as_double_reg(), value-&gt;as_double_reg());
        break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1746,11 +1761,11 @@</span>
      long uimms  = (unsigned long)uimm &gt;&gt; 16,
           uimmss = (unsigned long)uimm &gt;&gt; 32;
  
      switch (code) {
        case lir_logic_and:
<span class="udiff-line-modified-removed">-         if (uimmss != 0 || (uimms != 0 &amp;&amp; (uimm &amp; 0xFFFF) != 0) || is_power_of_2_long(uimm)) {</span>
<span class="udiff-line-modified-added">+         if (uimmss != 0 || (uimms != 0 &amp;&amp; (uimm &amp; 0xFFFF) != 0) || is_power_of_2(uimm)) {</span>
            __ andi(d, l, uimm); // special cases
          } else if (uimms != 0) { __ andis_(d, l, uimms); }
          else { __ andi_(d, l, uimm); }
          break;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2299,19 +2314,19 @@</span>
                       op-&gt;object_size(),
                       op-&gt;klass()-&gt;as_register(),
                       *op-&gt;stub()-&gt;entry());
  
    __ bind(*op-&gt;stub()-&gt;continuation());
<span class="udiff-line-modified-removed">-   __ verify_oop(op-&gt;obj()-&gt;as_register());</span>
<span class="udiff-line-modified-added">+   __ verify_oop(op-&gt;obj()-&gt;as_register(), FILE_AND_LINE);</span>
  }
  
  
  void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
    LP64_ONLY( __ extsw(op-&gt;len()-&gt;as_register(), op-&gt;len()-&gt;as_register()); )
    if (UseSlowPath ||
<span class="udiff-line-modified-removed">-       (!UseFastNewObjectArray &amp;&amp; (op-&gt;type() == T_OBJECT || op-&gt;type() == T_ARRAY)) ||</span>
<span class="udiff-line-modified-removed">-       (!UseFastNewTypeArray   &amp;&amp; (op-&gt;type() != T_OBJECT &amp;&amp; op-&gt;type() != T_ARRAY))) {</span>
<span class="udiff-line-modified-added">+       (!UseFastNewObjectArray &amp;&amp; (is_reference_type(op-&gt;type()))) ||</span>
<span class="udiff-line-modified-added">+       (!UseFastNewTypeArray   &amp;&amp; (!is_reference_type(op-&gt;type())))) {</span>
      __ b(*op-&gt;stub()-&gt;entry());
    } else {
      __ allocate_array(op-&gt;obj()-&gt;as_register(),
                        op-&gt;len()-&gt;as_register(),
                        op-&gt;tmp1()-&gt;as_register(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2524,11 +2539,11 @@</span>
      Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
      Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
      Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
      bool should_profile = op-&gt;should_profile();
  
<span class="udiff-line-modified-removed">-     __ verify_oop(value);</span>
<span class="udiff-line-modified-added">+     __ verify_oop(value, FILE_AND_LINE);</span>
      CodeStub* stub = op-&gt;stub();
      // Check if it needs to be profiled.
      ciMethodData* md = NULL;
      ciProfileData* data = NULL;
      int mdo_offset_bias = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2669,20 +2684,10 @@</span>
    } else {
      __ sync();
    }
  }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void LIR_Assembler::set_24bit_FPU() {</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void LIR_Assembler::reset_FPU() {</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  void LIR_Assembler::breakpoint() {
    __ illtrap();
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2872,23 +2877,10 @@</span>
      __ neg(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
    }
  }
  
  
<span class="udiff-line-removed">- void LIR_Assembler::fxch(int i) {</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void LIR_Assembler::fld(int i) {</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void LIR_Assembler::ffree(int i) {</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  void LIR_Assembler::rt_call(LIR_Opr result, address dest,
                              const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
    // Stubs: Called via rt_call, but dest is a stub address (no function descriptor).
    if (dest == Runtime1::entry_for(Runtime1::register_finalizer_id) ||
        dest == Runtime1::entry_for(Runtime1::new_multi_array_id   )) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3077,11 +3069,11 @@</span>
    bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
  
    assert(do_null || do_update, &quot;why are we here?&quot;);
    assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
  
<span class="udiff-line-modified-removed">-   __ verify_oop(obj);</span>
<span class="udiff-line-modified-added">+   __ verify_oop(obj, FILE_AND_LINE);</span>
  
    if (do_null) {
      if (!TypeEntries::was_null_seen(current_klass)) {
        __ cmpdi(CCR0, obj, 0);
        __ bne(CCR0, Lupdate);
</pre>
<center><a href="c1_FrameMap_ppc.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_ppc.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
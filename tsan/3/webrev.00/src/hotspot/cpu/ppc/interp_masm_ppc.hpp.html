<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/ppc/interp_masm_ppc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2012, 2017 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_PPC_INTERP_MASM_PPC_HPP
 27 #define CPU_PPC_INTERP_MASM_PPC_HPP
 28 
 29 #include &quot;asm/macroAssembler.hpp&quot;
 30 #include &quot;interpreter/invocationCounter.hpp&quot;
 31 
 32 // This file specializes the assembler with interpreter-specific macros.
 33 
 34 
 35 class InterpreterMacroAssembler: public MacroAssembler {
 36 
 37  public:
 38   InterpreterMacroAssembler(CodeBuffer* code) : MacroAssembler(code) {}
 39 
 40   void null_check_throw(Register a, int offset, Register temp_reg);
 41 
 42   void jump_to_entry(address entry, Register Rscratch);
 43 
 44   // Handy address generation macros.
 45 #define thread_(field_name) in_bytes(JavaThread::field_name ## _offset()), R16_thread
 46 #define method_(field_name) in_bytes(Method::field_name ## _offset()), R19_method
 47 
 48   virtual void check_and_handle_popframe(Register scratch_reg);
 49   virtual void check_and_handle_earlyret(Register scratch_reg);
 50 
 51   // Base routine for all dispatches.
 52   void dispatch_base(TosState state, address* table);
 53 
 54   void load_earlyret_value(TosState state, Register Rscratch1);
 55 
 56   static const Address l_tmp;
 57   static const Address d_tmp;
 58 
 59   // dispatch routines
 60   void dispatch_next(TosState state, int step = 0, bool generate_poll = false);
 61   void dispatch_via (TosState state, address* table);
 62   void load_dispatch_table(Register dst, address* table);
 63   void dispatch_Lbyte_code(TosState state, Register bytecode, address* table, bool generate_poll = false);
 64 
 65   // Called by shared interpreter generator.
 66   void dispatch_prolog(TosState state, int step = 0);
 67   void dispatch_epilog(TosState state, int step = 0);
 68 
 69   // Super call_VM calls - correspond to MacroAssembler::call_VM(_leaf) calls.
 70   void super_call_VM_leaf(Register thread_cache, address entry_point, Register arg_1);
 71   void super_call_VM(Register thread_cache, Register oop_result, Register last_java_sp,
 72                      address entry_point, Register arg_1, Register arg_2, bool check_exception = true);
 73 
 74   // Generate a subtype check: branch to ok_is_subtype if sub_klass is
 75   // a subtype of super_klass.  Blows registers tmp1, tmp2 and tmp3.
 76   void gen_subtype_check(Register sub_klass, Register super_klass,
 77                          Register tmp1, Register tmp2, Register tmp3, Label &amp;ok_is_subtype);
 78 
 79   // Load object from cpool-&gt;resolved_references(index).
 80   void load_resolved_reference_at_index(Register result, Register index, Label *L_handle_null = NULL);
 81 
 82   // load cpool-&gt;resolved_klass_at(index)
 83   void load_resolved_klass_at_offset(Register Rcpool, Register Roffset, Register Rklass);
 84 
 85   void load_resolved_method_at_index(int byte_no, Register cache, Register method);
 86 
 87   void load_receiver(Register Rparam_count, Register Rrecv_dst);
 88 
 89   // helpers for expression stack
 90   void pop_i(     Register r = R17_tos);
 91   void pop_ptr(   Register r = R17_tos);
 92   void pop_l(     Register r = R17_tos);
 93   void pop_f(FloatRegister f = F15_ftos);
 94   void pop_d(FloatRegister f = F15_ftos );
 95 
 96   void push_i(     Register r = R17_tos);
 97   void push_ptr(   Register r = R17_tos);
 98   void push_l(     Register r = R17_tos);
 99   void push_f(FloatRegister f = F15_ftos );
100   void push_d(FloatRegister f = F15_ftos);
101 
102   void push_2ptrs(Register first, Register second);
103 
104   void move_l_to_d(Register l = R17_tos, FloatRegister d = F15_ftos);
105   void move_d_to_l(FloatRegister d = F15_ftos, Register l = R17_tos);
106 
107   void pop (TosState state);           // transition vtos -&gt; state
108   void push(TosState state);           // transition state -&gt; vtos
109   void empty_expression_stack();       // Resets both Lesp and SP.
110 
111  public:
112   // Load values from bytecode stream:
113 
114   enum signedOrNot { Signed, Unsigned };
115   enum setCCOrNot  { set_CC, dont_set_CC };
116 
117   void get_2_byte_integer_at_bcp(int         bcp_offset,
118                                  Register    Rdst,
119                                  signedOrNot is_signed);
120 
121   void get_4_byte_integer_at_bcp(int         bcp_offset,
122                                  Register    Rdst,
123                                  signedOrNot is_signed = Unsigned);
124 
125   void get_cache_index_at_bcp(Register Rdst, int bcp_offset, size_t index_size);
126 
127   void get_cache_and_index_at_bcp(Register cache, int bcp_offset, size_t index_size = sizeof(u2));
128 
129   void get_u4(Register Rdst, Register Rsrc, int offset, signedOrNot is_signed);
130 
131   // common code
132 
133   void field_offset_at(int n, Register tmp, Register dest, Register base);
134   int  field_offset_at(Register object, address bcp, int offset);
135   void fast_iaaccess(int n, address bcp);
136   void fast_iaputfield(address bcp, bool do_store_check);
137 
138   void index_check(Register array, Register index, int index_shift, Register tmp, Register res);
139   void index_check_without_pop(Register array, Register index, int index_shift, Register tmp, Register res);
140 
141   void get_const(Register Rdst);
142   void get_constant_pool(Register Rdst);
143   void get_constant_pool_cache(Register Rdst);
144   void get_cpool_and_tags(Register Rcpool, Register Rtags);
145   void is_a(Label&amp; L);
146 
147   void narrow(Register result);
148 
149   // Java Call Helpers
150   void call_from_interpreter(Register Rtarget_method, Register Rret_addr, Register Rscratch1, Register Rscratch2);
151 
152   // --------------------------------------------------
153 
154   void unlock_if_synchronized_method(TosState state, bool throw_monitor_exception = true,
155                                      bool install_monitor_exception = true);
156 
157   // Removes the current activation (incl. unlocking of monitors).
158   // Additionally this code is used for earlyReturn in which case we
159   // want to skip throwing an exception and installing an exception.
160   void remove_activation(TosState state,
161                          bool throw_monitor_exception = true,
162                          bool install_monitor_exception = true);
163   void merge_frames(Register Rtop_frame_sp, Register return_pc, Register Rscratch1, Register Rscratch2); // merge top frames
164 
165   void add_monitor_to_stack(bool stack_is_empty, Register Rtemp1, Register Rtemp2);
166 
167   // Local variable access helpers
168   void load_local_int(Register Rdst_value, Register Rdst_address, Register Rindex);
169   void load_local_long(Register Rdst_value, Register Rdst_address, Register Rindex);
170   void load_local_ptr(Register Rdst_value, Register Rdst_address, Register Rindex);
171   void load_local_float(FloatRegister Rdst_value, Register Rdst_address, Register Rindex);
172   void load_local_double(FloatRegister Rdst_value, Register Rdst_address, Register Rindex);
173   void store_local_int(Register Rvalue, Register Rindex);
174   void store_local_long(Register Rvalue, Register Rindex);
175   void store_local_ptr(Register Rvalue, Register Rindex);
176   void store_local_float(FloatRegister Rvalue, Register Rindex);
177   void store_local_double(FloatRegister Rvalue, Register Rindex);
178 
179   // Call VM for std frames
180   // Special call VM versions that check for exceptions and forward exception
181   // via short cut (not via expensive forward exception stub).
182   void check_and_forward_exception(Register Rscratch1, Register Rscratch2);
183   void call_VM(Register oop_result, address entry_point, bool check_exceptions = true);
184   void call_VM(Register oop_result, address entry_point, Register arg_1, bool check_exceptions = true);
185   void call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
186   void call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
187   // Should not be used:
188   void call_VM(Register oop_result, Register last_java_sp, address entry_point, bool check_exceptions = true) {ShouldNotReachHere();}
189   void call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true) {ShouldNotReachHere();}
190   void call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true) {ShouldNotReachHere();}
191   void call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true) {ShouldNotReachHere();}
192 
193   Address first_local_in_stack();
194 
195   enum LoadOrStore { load, store };
196   void static_iload_or_store(int which_local, LoadOrStore direction, Register Rtmp);
197   void static_aload_or_store(int which_local, LoadOrStore direction, Register Rtmp);
198   void static_dload_or_store(int which_local, LoadOrStore direction);
199 
200   void save_interpreter_state(Register scratch);
201   void restore_interpreter_state(Register scratch, bool bcp_and_mdx_only = false);
202 
203   void increment_backedge_counter(const Register Rcounters, Register Rtmp, Register Rtmp2, Register Rscratch);
204   void test_backedge_count_for_osr(Register backedge_count, Register method_counters, Register target_bcp, Register disp, Register Rtmp);
205 
206   void record_static_call_in_profile(Register Rentry, Register Rtmp);
207   void record_receiver_call_in_profile(Register Rklass, Register Rentry, Register Rtmp);
208 
209   void get_method_counters(Register method, Register Rcounters, Label&amp; skip);
210   void increment_invocation_counter(Register iv_be_count, Register Rtmp1, Register Rtmp2_r0);
211 
212   // Object locking
213   void lock_object  (Register lock_reg, Register obj_reg);
214   void unlock_object(Register lock_reg, bool check_for_exceptions = true);
215 
216   // Interpreter profiling operations
217   void set_method_data_pointer_for_bcp();
218   void test_method_data_pointer(Label&amp; zero_continue);
219   void verify_method_data_pointer();
220   void test_invocation_counter_for_mdp(Register invocation_count, Register method_counters, Register Rscratch, Label &amp;profile_continue);
221 
222   void set_mdp_data_at(int constant, Register value);
223 
224   void increment_mdp_data_at(int constant, Register counter_addr, Register Rbumped_count, bool decrement = false);
225 
226   void increment_mdp_data_at(Register counter_addr, Register Rbumped_count, bool decrement = false);
227   void increment_mdp_data_at(Register reg, int constant, Register scratch, Register Rbumped_count, bool decrement = false);
228 
229   void set_mdp_flag_at(int flag_constant, Register scratch);
230   void test_mdp_data_at(int offset, Register value, Label&amp; not_equal_continue, Register test_out);
231 
232   void update_mdp_by_offset(int offset_of_disp, Register scratch);
233   void update_mdp_by_offset(Register reg, int offset_of_disp,
234                             Register scratch);
235   void update_mdp_by_constant(int constant);
236   void update_mdp_for_ret(TosState state, Register return_bci);
237 
238   void profile_taken_branch(Register scratch, Register bumped_count);
239   void profile_not_taken_branch(Register scratch1, Register scratch2);
240   void profile_call(Register scratch1, Register scratch2);
241   void profile_final_call(Register scratch1, Register scratch2);
242   void profile_virtual_call(Register Rreceiver, Register Rscratch1, Register Rscratch2,  bool receiver_can_be_null);
243   void profile_typecheck(Register Rklass, Register Rscratch1, Register Rscratch2);
244   void profile_typecheck_failed(Register Rscratch1, Register Rscratch2);
245   void profile_ret(TosState state, Register return_bci, Register scratch1, Register scratch2);
246   void profile_switch_default(Register scratch1, Register scratch2);
247   void profile_switch_case(Register index, Register scratch1,Register scratch2, Register scratch3);
248   void profile_null_seen(Register Rscratch1, Register Rscratch2);
249   void record_klass_in_profile(Register receiver, Register scratch1, Register scratch2, bool is_virtual_call);
250   void record_klass_in_profile_helper(Register receiver, Register scratch1, Register scratch2, int start_row, Label&amp; done, bool is_virtual_call);
251 
252   // Argument and return type profiling.
253   void profile_obj_type(Register obj, Register mdo_addr_base, RegisterOrConstant mdo_addr_offs, Register tmp, Register tmp2);
254   void profile_arguments_type(Register callee, Register tmp1, Register tmp2, bool is_virtual);
255   void profile_return_type(Register ret, Register tmp1, Register tmp2);
256   void profile_parameters_type(Register tmp1, Register tmp2, Register tmp3, Register tmp4);
257 
258   // Debugging
259   void verify_oop(Register reg, TosState state = atos);    // only if +VerifyOops &amp;&amp; state == atos
260   void verify_oop_or_return_address(Register reg, Register rtmp); // for astore
261   void verify_FPU(int stack_depth, TosState state = ftos);
262 
263   typedef enum { NotifyJVMTI, SkipNotifyJVMTI } NotifyMethodExitMode;
264 
265   // Support for jvmdi/jvmpi.
266   void notify_method_entry();
267   void notify_method_exit(bool is_native_method, TosState state,
268                           NotifyMethodExitMode mode, bool check_exceptions);
269 };
270 
271 #endif // CPU_PPC_INTERP_MASM_PPC_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/ppc/templateInterpreterGenerator_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubGenerator_ppc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_ppc_64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/templateInterpreterGenerator_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 590,14 ***</span>
    __ empty_expression_stack();
  
    __ load_const_optimized(R4_ARG2, (address) name, R11_scratch1);
    if (pass_oop) {
      __ mr(R5_ARG3, Rexception);
<span class="line-modified">!     __ call_VM(Rexception, CAST_FROM_FN_PTR(address, InterpreterRuntime::create_klass_exception), false);</span>
    } else {
      __ load_const_optimized(R5_ARG3, (address) message, R11_scratch1);
<span class="line-modified">!     __ call_VM(Rexception, CAST_FROM_FN_PTR(address, InterpreterRuntime::create_exception), false);</span>
    }
  
    // Throw exception.
    __ mr(R3_ARG1, Rexception);
    __ load_const_optimized(R11_scratch1, Interpreter::throw_exception_entry(), R12_scratch2);
<span class="line-new-header">--- 590,14 ---</span>
    __ empty_expression_stack();
  
    __ load_const_optimized(R4_ARG2, (address) name, R11_scratch1);
    if (pass_oop) {
      __ mr(R5_ARG3, Rexception);
<span class="line-modified">!     __ call_VM(Rexception, CAST_FROM_FN_PTR(address, InterpreterRuntime::create_klass_exception));</span>
    } else {
      __ load_const_optimized(R5_ARG3, (address) message, R11_scratch1);
<span class="line-modified">!     __ call_VM(Rexception, CAST_FROM_FN_PTR(address, InterpreterRuntime::create_exception));</span>
    }
  
    // Throw exception.
    __ mr(R3_ARG1, Rexception);
    __ load_const_optimized(R11_scratch1, Interpreter::throw_exception_entry(), R12_scratch2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1048,53 ***</span>
    __ std(R12_scratch2, _abi(lr), R1_SP);
  
    // Get mirror and store it in the frame as GC root for this Method*.
    __ load_mirror_from_const_method(R12_scratch2, Rconst_method);
  
<span class="line-modified">!   __ addi(R26_monitor, R1_SP, - frame::ijava_state_size);</span>
<span class="line-modified">!   __ addi(R15_esp, R26_monitor, - Interpreter::stackElementSize);</span>
  
    // Store values.
<span class="line-removed">-   // R15_esp, R14_bcp, R26_monitor, R28_mdx are saved at java calls</span>
<span class="line-removed">-   // in InterpreterMacroAssembler::call_from_interpreter.</span>
    __ std(R19_method, _ijava_state_neg(method), R1_SP);
    __ std(R12_scratch2, _ijava_state_neg(mirror), R1_SP);
<span class="line-removed">-   __ std(R21_sender_SP, _ijava_state_neg(sender_sp), R1_SP);</span>
<span class="line-removed">-   __ std(R27_constPoolCache, _ijava_state_neg(cpoolCache), R1_SP);</span>
    __ std(R18_locals, _ijava_state_neg(locals), R1_SP);
  
    // Note: esp, bcp, monitor, mdx live in registers. Hence, the correct version can only
    // be found in the frame after save_interpreter_state is done. This is always true
    // for non-top frames. But when a signal occurs, dumping the top frame can go wrong,
    // because e.g. frame::interpreter_frame_bcp() will not access the correct value
    // (Enhanced Stack Trace).
    // The signal handler does not save the interpreter state into the frame.
    __ li(R0, 0);
<span class="line-modified">! #ifdef ASSERT</span>
<span class="line-modified">!   // Fill remaining slots with constants.</span>
<span class="line-modified">!   __ load_const_optimized(R11_scratch1, 0x5afe);</span>
<span class="line-modified">!   __ load_const_optimized(R12_scratch2, 0xdead);</span>
<span class="line-modified">! #endif</span>
<span class="line-modified">!   // We have to initialize some frame slots for native calls (accessed by GC).</span>
<span class="line-modified">!   if (native_call) {</span>
<span class="line-removed">-     __ std(R26_monitor, _ijava_state_neg(monitors), R1_SP);</span>
<span class="line-removed">-     __ std(R14_bcp, _ijava_state_neg(bcp), R1_SP);</span>
<span class="line-removed">-     if (ProfileInterpreter) { __ std(R28_mdx, _ijava_state_neg(mdx), R1_SP); }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-   else {</span>
<span class="line-removed">-     __ std(R12_scratch2, _ijava_state_neg(monitors), R1_SP);</span>
<span class="line-removed">-     __ std(R12_scratch2, _ijava_state_neg(bcp), R1_SP);</span>
<span class="line-removed">-     __ std(R12_scratch2, _ijava_state_neg(mdx), R1_SP);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   __ std(R11_scratch1, _ijava_state_neg(ijava_reserved), R1_SP);</span>
<span class="line-removed">-   __ std(R12_scratch2, _ijava_state_neg(esp), R1_SP);</span>
<span class="line-removed">-   __ std(R12_scratch2, _ijava_state_neg(lresult), R1_SP);</span>
<span class="line-removed">-   __ std(R12_scratch2, _ijava_state_neg(fresult), R1_SP);</span>
<span class="line-removed">- #endif</span>
    __ subf(R12_scratch2, top_frame_size, R1_SP);
<span class="line-modified">!   __ std(R0, _ijava_state_neg(oop_tmp), R1_SP);</span>
    __ std(R12_scratch2, _ijava_state_neg(top_frame_sp), R1_SP);
  
    // Push top frame.
    __ push_frame(top_frame_size, R11_scratch1);
  }
<span class="line-new-header">--- 1048,39 ---</span>
    __ std(R12_scratch2, _abi(lr), R1_SP);
  
    // Get mirror and store it in the frame as GC root for this Method*.
    __ load_mirror_from_const_method(R12_scratch2, Rconst_method);
  
<span class="line-modified">!   __ addi(R26_monitor, R1_SP, -frame::ijava_state_size);</span>
<span class="line-modified">!   __ addi(R15_esp, R26_monitor, -Interpreter::stackElementSize);</span>
  
    // Store values.
    __ std(R19_method, _ijava_state_neg(method), R1_SP);
    __ std(R12_scratch2, _ijava_state_neg(mirror), R1_SP);
    __ std(R18_locals, _ijava_state_neg(locals), R1_SP);
<span class="line-added">+   __ std(R27_constPoolCache, _ijava_state_neg(cpoolCache), R1_SP);</span>
  
    // Note: esp, bcp, monitor, mdx live in registers. Hence, the correct version can only
    // be found in the frame after save_interpreter_state is done. This is always true
    // for non-top frames. But when a signal occurs, dumping the top frame can go wrong,
    // because e.g. frame::interpreter_frame_bcp() will not access the correct value
    // (Enhanced Stack Trace).
    // The signal handler does not save the interpreter state into the frame.
<span class="line-added">+ </span>
<span class="line-added">+   // We have to initialize some of these frame slots for native calls (accessed by GC).</span>
<span class="line-added">+   // Also initialize them for non-native calls for better tool support (even though</span>
<span class="line-added">+   // you may not get the most recent version as described above).</span>
    __ li(R0, 0);
<span class="line-modified">!   __ std(R26_monitor, _ijava_state_neg(monitors), R1_SP);</span>
<span class="line-modified">!   __ std(R14_bcp, _ijava_state_neg(bcp), R1_SP);</span>
<span class="line-modified">!   if (ProfileInterpreter) { __ std(R28_mdx, _ijava_state_neg(mdx), R1_SP); }</span>
<span class="line-modified">!   __ std(R15_esp, _ijava_state_neg(esp), R1_SP);</span>
<span class="line-modified">!   __ std(R0, _ijava_state_neg(oop_tmp), R1_SP); // only used for native_call</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Store sender&#39;s SP and this frame&#39;s top SP.</span>
    __ subf(R12_scratch2, top_frame_size, R1_SP);
<span class="line-modified">!   __ std(R21_sender_SP, _ijava_state_neg(sender_sp), R1_SP);</span>
    __ std(R12_scratch2, _ijava_state_neg(top_frame_sp), R1_SP);
  
    // Push top frame.
    __ push_frame(top_frame_size, R11_scratch1);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2117,11 ***</span>
      __ bne(CCR0, L_done);
  
      // The member name argument must be restored if _invokestatic is re-executed after a PopFrame call.
      // Detect such a case in the InterpreterRuntime function and return the member name argument, or NULL.
      __ ld(R4_ARG2, 0, R18_locals);
<span class="line-modified">!     __ MacroAssembler::call_VM(R4_ARG2, CAST_FROM_FN_PTR(address, InterpreterRuntime::member_name_arg_or_null), R4_ARG2, R19_method, R14_bcp, false);</span>
      __ restore_interpreter_state(R11_scratch1, /*bcp_and_mdx_only*/ true);
      __ cmpdi(CCR0, R4_ARG2, 0);
      __ beq(CCR0, L_done);
      __ std(R4_ARG2, wordSize, R15_esp);
      __ bind(L_done);
<span class="line-new-header">--- 2103,11 ---</span>
      __ bne(CCR0, L_done);
  
      // The member name argument must be restored if _invokestatic is re-executed after a PopFrame call.
      // Detect such a case in the InterpreterRuntime function and return the member name argument, or NULL.
      __ ld(R4_ARG2, 0, R18_locals);
<span class="line-modified">!     __ call_VM(R4_ARG2, CAST_FROM_FN_PTR(address, InterpreterRuntime::member_name_arg_or_null), R4_ARG2, R19_method, R14_bcp);</span>
      __ restore_interpreter_state(R11_scratch1, /*bcp_and_mdx_only*/ true);
      __ cmpdi(CCR0, R4_ARG2, 0);
      __ beq(CCR0, L_done);
      __ std(R4_ARG2, wordSize, R15_esp);
      __ bind(L_done);
</pre>
<center><a href="stubGenerator_ppc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_ppc_64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
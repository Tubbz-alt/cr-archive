<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/assembler_ppc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_PPC_ASSEMBLER_PPC_HPP
  27 #define CPU_PPC_ASSEMBLER_PPC_HPP
  28 
  29 #include &quot;asm/register.hpp&quot;
  30 
  31 // Address is an abstraction used to represent a memory location
  32 // as used in assembler instructions.
  33 // PPC instructions grok either baseReg + indexReg or baseReg + disp.
  34 class Address {
  35  private:
  36   Register _base;         // Base register.
  37   Register _index;        // Index register.
  38   intptr_t _disp;         // Displacement.
  39 
  40  public:
  41   Address(Register b, Register i, address d = 0)
  42     : _base(b), _index(i), _disp((intptr_t)d) {
  43     assert(i == noreg || d == 0, &quot;can&#39;t have both&quot;);
  44   }
  45 
  46   Address(Register b, address d = 0)
  47     : _base(b), _index(noreg), _disp((intptr_t)d) {}
  48 
  49   Address(Register b, intptr_t d)
  50     : _base(b), _index(noreg), _disp(d) {}
  51 
  52   Address(Register b, RegisterOrConstant roc)
  53     : _base(b), _index(noreg), _disp(0) {
  54     if (roc.is_constant()) _disp = roc.as_constant(); else _index = roc.as_register();
  55   }
  56 
  57   Address()
  58     : _base(noreg), _index(noreg), _disp(0) {}
  59 
  60   // accessors
  61   Register base()  const { return _base; }
  62   Register index() const { return _index; }
  63   int      disp()  const { return (int)_disp; }
  64   bool     is_const() const { return _base == noreg &amp;&amp; _index == noreg; }
  65 };
  66 
  67 class AddressLiteral {
  68  private:
  69   address          _address;
  70   RelocationHolder _rspec;
  71 
  72   RelocationHolder rspec_from_rtype(relocInfo::relocType rtype, address addr) {
  73     switch (rtype) {
  74     case relocInfo::external_word_type:
  75       return external_word_Relocation::spec(addr);
  76     case relocInfo::internal_word_type:
  77       return internal_word_Relocation::spec(addr);
  78     case relocInfo::opt_virtual_call_type:
  79       return opt_virtual_call_Relocation::spec();
  80     case relocInfo::static_call_type:
  81       return static_call_Relocation::spec();
  82     case relocInfo::runtime_call_type:
  83       return runtime_call_Relocation::spec();
  84     case relocInfo::none:
  85       return RelocationHolder();
  86     default:
  87       ShouldNotReachHere();
  88       return RelocationHolder();
  89     }
  90   }
  91 
  92  protected:
  93   // creation
  94   AddressLiteral() : _address(NULL), _rspec(NULL) {}
  95 
  96  public:
  97   AddressLiteral(address addr, RelocationHolder const&amp; rspec)
  98     : _address(addr),
  99       _rspec(rspec) {}
 100 
 101   AddressLiteral(address addr, relocInfo::relocType rtype = relocInfo::none)
 102     : _address((address) addr),
 103       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 104 
 105   AddressLiteral(oop* addr, relocInfo::relocType rtype = relocInfo::none)
 106     : _address((address) addr),
 107       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 108 
 109   intptr_t value() const { return (intptr_t) _address; }
 110 
 111   const RelocationHolder&amp; rspec() const { return _rspec; }
 112 };
 113 
 114 // Argument is an abstraction used to represent an outgoing
 115 // actual argument or an incoming formal parameter, whether
 116 // it resides in memory or in a register, in a manner consistent
 117 // with the PPC Application Binary Interface, or ABI. This is
 118 // often referred to as the native or C calling convention.
 119 
 120 class Argument {
 121  private:
 122   int _number;  // The number of the argument.
 123  public:
 124   enum {
 125     // Only 8 registers may contain integer parameters.
 126     n_register_parameters = 8,
 127     // Can have up to 8 floating registers.
 128     n_float_register_parameters = 8,
 129 
 130     // PPC C calling conventions.
 131     // The first eight arguments are passed in int regs if they are int.
 132     n_int_register_parameters_c = 8,
 133     // The first thirteen float arguments are passed in float regs.
 134     n_float_register_parameters_c = 13,
 135     // Only the first 8 parameters are not placed on the stack. Aix disassembly
 136     // shows that xlC places all float args after argument 8 on the stack AND
 137     // in a register. This is not documented, but we follow this convention, too.
 138     n_regs_not_on_stack_c = 8,
 139   };
 140   // creation
 141   Argument(int number) : _number(number) {}
 142 
 143   int  number() const { return _number; }
 144 
 145   // Locating register-based arguments:
 146   bool is_register() const { return _number &lt; n_register_parameters; }
 147 
 148   Register as_register() const {
 149     assert(is_register(), &quot;must be a register argument&quot;);
 150     return as_Register(number() + R3_ARG1-&gt;encoding());
 151   }
 152 };
 153 
 154 #if !defined(ABI_ELFv2)
 155 // A ppc64 function descriptor.
 156 struct FunctionDescriptor {
 157  private:
 158   address _entry;
 159   address _toc;
 160   address _env;
 161 
 162  public:
 163   inline address entry() const { return _entry; }
 164   inline address toc()   const { return _toc; }
 165   inline address env()   const { return _env; }
 166 
 167   inline void set_entry(address entry) { _entry = entry; }
 168   inline void set_toc(  address toc)   { _toc   = toc; }
 169   inline void set_env(  address env)   { _env   = env; }
 170 
 171   inline static ByteSize entry_offset() { return byte_offset_of(FunctionDescriptor, _entry); }
 172   inline static ByteSize toc_offset()   { return byte_offset_of(FunctionDescriptor, _toc); }
 173   inline static ByteSize env_offset()   { return byte_offset_of(FunctionDescriptor, _env); }
 174 
 175   // Friend functions can be called without loading toc and env.
 176   enum {
 177     friend_toc = 0xcafe,
 178     friend_env = 0xc0de
 179   };
 180 
 181   inline bool is_friend_function() const {
 182     return (toc() == (address) friend_toc) &amp;&amp; (env() == (address) friend_env);
 183   }
 184 
 185   // Constructor for stack-allocated instances.
 186   FunctionDescriptor() {
 187     _entry = (address) 0xbad;
 188     _toc   = (address) 0xbad;
 189     _env   = (address) 0xbad;
 190   }
 191 };
 192 #endif
 193 
 194 
 195 // The PPC Assembler: Pure assembler doing NO optimizations on the
 196 // instruction level; i.e., what you write is what you get. The
 197 // Assembler is generating code into a CodeBuffer.
 198 
 199 class Assembler : public AbstractAssembler {
 200  protected:
 201   // Displacement routines
 202   static int  patched_branch(int dest_pos, int inst, int inst_pos);
 203   static int  branch_destination(int inst, int pos);
 204 
 205   friend class AbstractAssembler;
 206 
 207   // Code patchers need various routines like inv_wdisp()
 208   friend class NativeInstruction;
 209   friend class NativeGeneralJump;
 210   friend class Relocation;
 211 
 212  public:
 213 
 214   enum shifts {
 215     XO_21_29_SHIFT = 2,
 216     XO_21_30_SHIFT = 1,
 217     XO_27_29_SHIFT = 2,
 218     XO_30_31_SHIFT = 0,
 219     SPR_5_9_SHIFT  = 11u, // SPR_5_9 field in bits 11 -- 15
 220     SPR_0_4_SHIFT  = 16u, // SPR_0_4 field in bits 16 -- 20
 221     RS_SHIFT       = 21u, // RS field in bits 21 -- 25
 222     OPCODE_SHIFT   = 26u, // opcode in bits 26 -- 31
 223   };
 224 
 225   enum opcdxos_masks {
 226     XL_FORM_OPCODE_MASK = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 227     ADDI_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 228     ADDIS_OPCODE_MASK   = (63u &lt;&lt; OPCODE_SHIFT),
 229     BXX_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 230     BCXX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 231     // trap instructions
 232     TDI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 233     TWI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 234     TD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 235     TW_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 236     LD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (3u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 237     STD_OPCODE_MASK     = LD_OPCODE_MASK,
 238     STDU_OPCODE_MASK    = STD_OPCODE_MASK,
 239     STDX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 240     STDUX_OPCODE_MASK   = STDX_OPCODE_MASK,
 241     STW_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 242     STWU_OPCODE_MASK    = STW_OPCODE_MASK,
 243     STWX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 244     STWUX_OPCODE_MASK   = STWX_OPCODE_MASK,
 245     MTCTR_OPCODE_MASK   = ~(31u &lt;&lt; RS_SHIFT),
 246     ORI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 247     ORIS_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 248     RLDICR_OPCODE_MASK  = (63u &lt;&lt; OPCODE_SHIFT) | (7u &lt;&lt; XO_27_29_SHIFT)
 249   };
 250 
 251   enum opcdxos {
 252     ADD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 266u &lt;&lt; 1),
 253     ADDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  10u &lt;&lt; 1),
 254     ADDI_OPCODE   = (14u &lt;&lt; OPCODE_SHIFT),
 255     ADDIS_OPCODE  = (15u &lt;&lt; OPCODE_SHIFT),
 256     ADDIC__OPCODE = (13u &lt;&lt; OPCODE_SHIFT),
 257     ADDE_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 138u &lt;&lt; 1),
 258     ADDME_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 234u &lt;&lt; 1),
 259     ADDZE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 202u &lt;&lt; 1),
 260     SUBF_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  40u &lt;&lt; 1),
 261     SUBFC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   8u &lt;&lt; 1),
 262     SUBFE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 136u &lt;&lt; 1),
 263     SUBFIC_OPCODE = (8u  &lt;&lt; OPCODE_SHIFT),
 264     SUBFME_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 232u &lt;&lt; 1),
 265     SUBFZE_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 200u &lt;&lt; 1),
 266     DIVW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 491u &lt;&lt; 1),
 267     MULLW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 235u &lt;&lt; 1),
 268     MULHW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  75u &lt;&lt; 1),
 269     MULHWU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  11u &lt;&lt; 1),
 270     MULLI_OPCODE  = (7u  &lt;&lt; OPCODE_SHIFT),
 271     AND_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  28u &lt;&lt; 1),
 272     ANDI_OPCODE   = (28u &lt;&lt; OPCODE_SHIFT),
 273     ANDIS_OPCODE  = (29u &lt;&lt; OPCODE_SHIFT),
 274     ANDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  60u &lt;&lt; 1),
 275     ORC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 412u &lt;&lt; 1),
 276     OR_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT | 444u &lt;&lt; 1),
 277     ORI_OPCODE    = (24u &lt;&lt; OPCODE_SHIFT),
 278     ORIS_OPCODE   = (25u &lt;&lt; OPCODE_SHIFT),
 279     XOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 316u &lt;&lt; 1),
 280     XORI_OPCODE   = (26u &lt;&lt; OPCODE_SHIFT),
 281     XORIS_OPCODE  = (27u &lt;&lt; OPCODE_SHIFT),
 282 
 283     NEG_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 104u &lt;&lt; 1),
 284 
 285     RLWINM_OPCODE = (21u &lt;&lt; OPCODE_SHIFT),
 286     CLRRWI_OPCODE = RLWINM_OPCODE,
 287     CLRLWI_OPCODE = RLWINM_OPCODE,
 288 
 289     RLWIMI_OPCODE = (20u &lt;&lt; OPCODE_SHIFT),
 290 
 291     SLW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  24u &lt;&lt; 1),
 292     SLWI_OPCODE   = RLWINM_OPCODE,
 293     SRW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 536u &lt;&lt; 1),
 294     SRWI_OPCODE   = RLWINM_OPCODE,
 295     SRAW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 792u &lt;&lt; 1),
 296     SRAWI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 824u &lt;&lt; 1),
 297 
 298     CMP_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; 1),
 299     CMPI_OPCODE   = (11u &lt;&lt; OPCODE_SHIFT),
 300     CMPL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  32u &lt;&lt; 1),
 301     CMPLI_OPCODE  = (10u &lt;&lt; OPCODE_SHIFT),
 302     CMPRB_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 192u &lt;&lt; 1),
 303     CMPEQB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 224u &lt;&lt; 1),
 304 
 305     ISEL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  15u &lt;&lt; 1),
 306 
 307     // Special purpose registers
 308     MTSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 467u &lt;&lt; 1),
 309     MFSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 339u &lt;&lt; 1),
 310 
 311     MTXER_OPCODE  = (MTSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 312     MFXER_OPCODE  = (MFSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 313 
 314     MTDSCR_OPCODE = (MTSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 315     MFDSCR_OPCODE = (MFSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 316 
 317     MTLR_OPCODE   = (MTSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 318     MFLR_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 319 
 320     MTCTR_OPCODE  = (MTSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 321     MFCTR_OPCODE  = (MFSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 322 
 323     // Attention: Higher and lower half are inserted in reversed order.
 324     MTTFHAR_OPCODE   = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 325     MFTFHAR_OPCODE   = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 326     MTTFIAR_OPCODE   = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 1 &lt;&lt; SPR_0_4_SHIFT),
 327     MFTFIAR_OPCODE   = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 1 &lt;&lt; SPR_0_4_SHIFT),
 328     MTTEXASR_OPCODE  = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 2 &lt;&lt; SPR_0_4_SHIFT),
 329     MFTEXASR_OPCODE  = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 2 &lt;&lt; SPR_0_4_SHIFT),
 330     MTTEXASRU_OPCODE = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 3 &lt;&lt; SPR_0_4_SHIFT),
 331     MFTEXASRU_OPCODE = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 3 &lt;&lt; SPR_0_4_SHIFT),
 332 
 333     MTVRSAVE_OPCODE  = (MTSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 334     MFVRSAVE_OPCODE  = (MFSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 335 
 336     MFTB_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 12 &lt;&lt; SPR_0_4_SHIFT),
 337 
 338     MTCRF_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 144u &lt;&lt; 1),
 339     MFCR_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 19u &lt;&lt; 1),
 340     MCRF_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 0u &lt;&lt; 1),
 341     SETB_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 128u &lt;&lt; 1),
 342 
 343     // condition register logic instructions
 344     CRAND_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 257u &lt;&lt; 1),
 345     CRNAND_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 225u &lt;&lt; 1),
 346     CROR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 449u &lt;&lt; 1),
 347     CRXOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 193u &lt;&lt; 1),
 348     CRNOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT |  33u &lt;&lt; 1),
 349     CREQV_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 289u &lt;&lt; 1),
 350     CRANDC_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 129u &lt;&lt; 1),
 351     CRORC_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 417u &lt;&lt; 1),
 352 
 353     BCLR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 16u &lt;&lt; 1),
 354     BXX_OPCODE      = (18u &lt;&lt; OPCODE_SHIFT),
 355     BCXX_OPCODE     = (16u &lt;&lt; OPCODE_SHIFT),
 356 
 357     // CTR-related opcodes
 358     BCCTR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 528u &lt;&lt; 1),
 359 
 360     LWZ_OPCODE   = (32u &lt;&lt; OPCODE_SHIFT),
 361     LWZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  23u &lt;&lt; 1),
 362     LWZU_OPCODE  = (33u &lt;&lt; OPCODE_SHIFT),
 363     LWBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  534 &lt;&lt; 1),
 364 
 365     LHA_OPCODE   = (42u &lt;&lt; OPCODE_SHIFT),
 366     LHAX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 343u &lt;&lt; 1),
 367     LHAU_OPCODE  = (43u &lt;&lt; OPCODE_SHIFT),
 368 
 369     LHZ_OPCODE   = (40u &lt;&lt; OPCODE_SHIFT),
 370     LHZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 279u &lt;&lt; 1),
 371     LHZU_OPCODE  = (41u &lt;&lt; OPCODE_SHIFT),
 372     LHBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  790 &lt;&lt; 1),
 373 
 374     LBZ_OPCODE   = (34u &lt;&lt; OPCODE_SHIFT),
 375     LBZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  87u &lt;&lt; 1),
 376     LBZU_OPCODE  = (35u &lt;&lt; OPCODE_SHIFT),
 377 
 378     STW_OPCODE   = (36u &lt;&lt; OPCODE_SHIFT),
 379     STWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 151u &lt;&lt; 1),
 380     STWU_OPCODE  = (37u &lt;&lt; OPCODE_SHIFT),
 381     STWUX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 183u &lt;&lt; 1),
 382     STWBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 662u &lt;&lt; 1),
 383 
 384     STH_OPCODE   = (44u &lt;&lt; OPCODE_SHIFT),
 385     STHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 407u &lt;&lt; 1),
 386     STHU_OPCODE  = (45u &lt;&lt; OPCODE_SHIFT),
 387     STHBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 918u &lt;&lt; 1),
 388 
 389     STB_OPCODE   = (38u &lt;&lt; OPCODE_SHIFT),
 390     STBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 215u &lt;&lt; 1),
 391     STBU_OPCODE  = (39u &lt;&lt; OPCODE_SHIFT),
 392 
 393     EXTSB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 954u &lt;&lt; 1),
 394     EXTSH_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 922u &lt;&lt; 1),
 395     EXTSW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 986u &lt;&lt; 1),               // X-FORM
 396 
 397     // 32 bit opcode encodings
 398 
 399     LWA_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 400     LWAX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 341u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 401 
 402     CNTLZW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  26u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 403     CNTTZW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 538u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 404 
 405     // 64 bit opcode encodings
 406 
 407     LD_OPCODE     = (58u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 408     LDU_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 409     LDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 410     LDBRX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 532u &lt;&lt; 1),              // X-FORM
 411 
 412     STD_OPCODE    = (62u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 413     STDU_OPCODE   = (62u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 414     STDUX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 181u &lt;&lt; 1),              // X-FORM
 415     STDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 149u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 416     STDBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 660u &lt;&lt; 1),              // X-FORM
 417 
 418     RLDICR_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 419     RLDICL_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 420     RLDIC_OPCODE  = (30u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 421     RLDIMI_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   3u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 422 
 423     SRADI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 413u &lt;&lt; XO_21_29_SHIFT), // XS-FORM
 424 
 425     SLD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  27u &lt;&lt; 1),              // X-FORM
 426     SRD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 539u &lt;&lt; 1),              // X-FORM
 427     SRAD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 794u &lt;&lt; 1),              // X-FORM
 428 
 429     MULLD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 233u &lt;&lt; 1),              // XO-FORM
 430     MULHD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  73u &lt;&lt; 1),              // XO-FORM
 431     MULHDU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |   9u &lt;&lt; 1),              // XO-FORM
 432     DIVD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 489u &lt;&lt; 1),              // XO-FORM
 433 
 434     CNTLZD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  58u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 435     CNTTZD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 570u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 436     NAND_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 476u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 437     NOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 124u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 438 
 439 
 440     // opcodes only used for floating arithmetic
 441     FADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 442     FADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 443     FCMPU_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  00u &lt;&lt; 1),
 444     FDIV_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 445     FDIVS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 446     FMR_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  72u &lt;&lt; 1),
<a name="1" id="anc1"></a><span class="line-added"> 447     FRIN_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT | 392u &lt;&lt; 1),</span>
<span class="line-added"> 448     FRIP_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT | 456u &lt;&lt; 1),</span>
<span class="line-added"> 449     FRIM_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT | 488u &lt;&lt; 1),</span>
 450     // These are special Power6 opcodes, reused for &quot;lfdepx&quot; and &quot;stfdepx&quot;
 451     // on Power7.  Do not use.
 452     // MFFGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 607u &lt;&lt; 1),
 453     // MFTGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 735u &lt;&lt; 1),
 454     CMPB_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  508  &lt;&lt; 1),
 455     POPCNTB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  122  &lt;&lt; 1),
 456     POPCNTW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  378  &lt;&lt; 1),
 457     POPCNTD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  506  &lt;&lt; 1),
 458     FABS_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  264u &lt;&lt; 1),
 459     FNABS_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  136u &lt;&lt; 1),
 460     FMUL_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 461     FMULS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 462     FNEG_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   40u &lt;&lt; 1),
 463     FSUB_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 464     FSUBS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 465 
 466     // PPC64-internal FPU conversion opcodes
 467     FCFID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 468     FCFIDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 469     FCTID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 470     FCTIDZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  815u &lt;&lt; 1),
 471     FCTIW_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   14u &lt;&lt; 1),
 472     FCTIWZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   15u &lt;&lt; 1),
 473     FRSP_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   12u &lt;&lt; 1),
 474 
 475     // Fused multiply-accumulate instructions.
 476     FMADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 477     FMADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 478     FMSUB_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 479     FMSUBS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 480     FNMADD_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 481     FNMADDS_OPCODE = (59u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 482     FNMSUB_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 483     FNMSUBS_OPCODE = (59u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 484 
 485     LFD_OPCODE     = (50u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 486     LFDU_OPCODE    = (51u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 487     LFDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  599u &lt;&lt; 1),
 488     LFS_OPCODE     = (48u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 489     LFSU_OPCODE    = (49u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 490     LFSX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  535u &lt;&lt; 1),
 491 
 492     STFD_OPCODE    = (54u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 493     STFDU_OPCODE   = (55u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 494     STFDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  727u &lt;&lt; 1),
 495     STFS_OPCODE    = (52u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 496     STFSU_OPCODE   = (53u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 497     STFSX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  663u &lt;&lt; 1),
 498 
 499     FSQRT_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 500     FSQRTS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 501 
 502     // Vector instruction support for &gt;= Power6
 503     // Vector Storage Access
 504     LVEBX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |    7u &lt;&lt; 1),
 505     LVEHX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   39u &lt;&lt; 1),
 506     LVEWX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   71u &lt;&lt; 1),
 507     LVX_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT |  103u &lt;&lt; 1),
 508     LVXL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  359u &lt;&lt; 1),
 509     STVEBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  135u &lt;&lt; 1),
 510     STVEHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  167u &lt;&lt; 1),
 511     STVEWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  199u &lt;&lt; 1),
 512     STVX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  231u &lt;&lt; 1),
 513     STVXL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  487u &lt;&lt; 1),
 514     LVSL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |    6u &lt;&lt; 1),
 515     LVSR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   38u &lt;&lt; 1),
 516 
 517     // Vector-Scalar (VSX) instruction support.
 518     LXVD2X_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  844u &lt;&lt; 1),
 519     STXVD2X_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  972u &lt;&lt; 1),
 520     MTVSRD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  179u &lt;&lt; 1),
 521     MTVSRWZ_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  243u &lt;&lt; 1),
 522     MFVSRD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   51u &lt;&lt; 1),
 523     MTVSRWA_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  211u &lt;&lt; 1),
 524     MFVSRWZ_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  115u &lt;&lt; 1),
 525     XXPERMDI_OPCODE= (60u &lt;&lt; OPCODE_SHIFT |   10u &lt;&lt; 3),
 526     XXMRGHW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   18u &lt;&lt; 3),
 527     XXMRGLW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   50u &lt;&lt; 3),
 528     XXSPLTW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  164u &lt;&lt; 2),
 529     XXLOR_OPCODE   = (60u &lt;&lt; OPCODE_SHIFT |  146u &lt;&lt; 3),
 530     XXLXOR_OPCODE  = (60u &lt;&lt; OPCODE_SHIFT |  154u &lt;&lt; 3),
 531     XXLEQV_OPCODE  = (60u &lt;&lt; OPCODE_SHIFT |  186u &lt;&lt; 3),
 532     XVDIVSP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   88u &lt;&lt; 3),
 533     XVDIVDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  120u &lt;&lt; 3),
 534     XVABSSP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  409u &lt;&lt; 2),
 535     XVABSDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  473u &lt;&lt; 2),
 536     XVNEGSP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  441u &lt;&lt; 2),
 537     XVNEGDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  505u &lt;&lt; 2),
 538     XVSQRTSP_OPCODE= (60u &lt;&lt; OPCODE_SHIFT |  139u &lt;&lt; 2),
 539     XVSQRTDP_OPCODE= (60u &lt;&lt; OPCODE_SHIFT |  203u &lt;&lt; 2),
 540     XSCVDPSPN_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |  267u &lt;&lt; 2),
 541     XVADDDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   96u &lt;&lt; 3),
 542     XVSUBDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  104u &lt;&lt; 3),
 543     XVMULSP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   80u &lt;&lt; 3),
 544     XVMULDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  112u &lt;&lt; 3),
 545     XVMADDASP_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |   65u &lt;&lt; 3),
 546     XVMADDADP_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |   97u &lt;&lt; 3),
 547     XVMSUBASP_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |   81u &lt;&lt; 3),
 548     XVMSUBADP_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |  113u &lt;&lt; 3),
 549     XVNMSUBASP_OPCODE=(60u&lt;&lt; OPCODE_SHIFT |  209u &lt;&lt; 3),
 550     XVNMSUBADP_OPCODE=(60u&lt;&lt; OPCODE_SHIFT |  241u &lt;&lt; 3),
<a name="2" id="anc2"></a><span class="line-added"> 551     XVRDPI_OPCODE  = (60u &lt;&lt; OPCODE_SHIFT |  201u &lt;&lt; 2),</span>
<span class="line-added"> 552     XVRDPIM_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  249u &lt;&lt; 2),</span>
<span class="line-added"> 553     XVRDPIP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  233u &lt;&lt; 2),</span>
 554 
 555     // Deliver A Random Number (introduced with POWER9)
 556     DARN_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  755u &lt;&lt; 1),
 557 
 558     // Vector Permute and Formatting
 559     VPKPX_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  782u     ),
 560     VPKSHSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  398u     ),
 561     VPKSWSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  462u     ),
 562     VPKSHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  270u     ),
 563     VPKSWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  334u     ),
 564     VPKUHUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   14u     ),
 565     VPKUWUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   78u     ),
 566     VPKUHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  142u     ),
 567     VPKUWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  206u     ),
 568     VUPKHPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  846u     ),
 569     VUPKHSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  526u     ),
 570     VUPKHSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  590u     ),
 571     VUPKLPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  974u     ),
 572     VUPKLSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  654u     ),
 573     VUPKLSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  718u     ),
 574 
 575     VMRGHB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   12u     ),
 576     VMRGHW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  140u     ),
 577     VMRGHH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   76u     ),
 578     VMRGLB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  268u     ),
 579     VMRGLW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  396u     ),
 580     VMRGLH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  332u     ),
 581 
 582     VSPLT_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  524u     ),
 583     VSPLTH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  588u     ),
 584     VSPLTW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  652u     ),
 585     VSPLTISB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  780u     ),
 586     VSPLTISH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  844u     ),
 587     VSPLTISW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  908u     ),
 588 
 589     VPERM_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |   43u     ),
 590     VSEL_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   42u     ),
 591 
 592     VSL_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  452u     ),
 593     VSLDOI_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   44u     ),
 594     VSLO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1036u     ),
 595     VSR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  708u     ),
 596     VSRO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1100u     ),
 597 
 598     // Vector Integer
 599     VADDCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  384u     ),
 600     VADDSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  832u     ),
 601     VADDSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  768u     ),
 602     VADDSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  896u     ),
 603     VADDUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    0u     ),
 604     VADDUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  128u     ),
 605     VADDUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   64u     ),
 606     VADDUDM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  192u     ),
 607     VADDUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  512u     ),
 608     VADDUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  640u     ),
 609     VADDUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  576u     ),
 610     VADDFP_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   10u     ),
 611     VSUBCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1408u     ),
 612     VSUBSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1856u     ),
 613     VSUBSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1792u     ),
 614     VSUBSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1920u     ),
 615     VSUBUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1024u     ),
 616     VSUBUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1152u     ),
 617     VSUBUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1088u     ),
 618     VSUBUDM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1216u     ),
 619     VSUBUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1536u     ),
 620     VSUBUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1664u     ),
 621     VSUBUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1600u     ),
 622     VSUBFP_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   74u     ),
 623 
 624     VMULESB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  776u     ),
 625     VMULEUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  520u     ),
 626     VMULESH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  840u     ),
 627     VMULEUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  584u     ),
 628     VMULOSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  264u     ),
 629     VMULOUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    8u     ),
 630     VMULOSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  328u     ),
 631     VMULOSW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  392u     ),
 632     VMULOUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   72u     ),
 633     VMULUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  137u     ),
 634     VMHADDSHS_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   32u     ),
 635     VMHRADDSHS_OPCODE=(4u &lt;&lt; OPCODE_SHIFT |   33u     ),
 636     VMLADDUHM_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   34u     ),
 637     VMSUBUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   36u     ),
 638     VMSUMMBM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   37u     ),
 639     VMSUMSHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   40u     ),
 640     VMSUMSHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   41u     ),
 641     VMSUMUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   38u     ),
 642     VMSUMUHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   39u     ),
 643     VMADDFP_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   46u     ),
 644 
 645     VSUMSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1928u     ),
 646     VSUM2SWS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1672u     ),
 647     VSUM4SBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1800u     ),
 648     VSUM4UBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1544u     ),
 649     VSUM4SHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1608u     ),
 650 
 651     VAVGSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1282u     ),
 652     VAVGSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1410u     ),
 653     VAVGSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1346u     ),
 654     VAVGUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1026u     ),
 655     VAVGUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1154u     ),
 656     VAVGUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1090u     ),
 657 
 658     VMAXSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  258u     ),
 659     VMAXSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  386u     ),
 660     VMAXSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  322u     ),
 661     VMAXUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |    2u     ),
 662     VMAXUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  130u     ),
 663     VMAXUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   66u     ),
 664     VMINSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  770u     ),
 665     VMINSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  898u     ),
 666     VMINSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  834u     ),
 667     VMINUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  514u     ),
 668     VMINUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  642u     ),
 669     VMINUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  578u     ),
 670 
 671     VCMPEQUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |    6u     ),
 672     VCMPEQUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   70u     ),
 673     VCMPEQUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  134u     ),
 674     VCMPGTSH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  838u     ),
 675     VCMPGTSB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  774u     ),
 676     VCMPGTSW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  902u     ),
 677     VCMPGTUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  518u     ),
 678     VCMPGTUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  582u     ),
 679     VCMPGTUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  646u     ),
 680 
 681     VAND_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1028u     ),
 682     VANDC_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1092u     ),
 683     VNOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1284u     ),
 684     VOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1156u     ),
 685     VXOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1220u     ),
 686     VRLD_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  196u     ),
 687     VRLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |    4u     ),
 688     VRLW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  132u     ),
 689     VRLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   68u     ),
 690     VSLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  260u     ),
 691     VSKW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  388u     ),
 692     VSLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  324u     ),
 693     VSRB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  516u     ),
 694     VSRW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  644u     ),
 695     VSRH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  580u     ),
 696     VSRAB_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  772u     ),
 697     VSRAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  900u     ),
 698     VSRAH_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  836u     ),
 699     VPOPCNTW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1923u     ),
 700 
 701     // Vector Floating-Point
 702     // not implemented yet
 703 
 704     // Vector Status and Control
 705     MTVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1604u     ),
 706     MFVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1540u     ),
 707 
 708     // AES (introduced with Power 8)
 709     VCIPHER_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1288u),
 710     VCIPHERLAST_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1289u),
 711     VNCIPHER_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1352u),
 712     VNCIPHERLAST_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1353u),
 713     VSBOX_OPCODE        = (4u  &lt;&lt; OPCODE_SHIFT | 1480u),
 714 
 715     // SHA (introduced with Power 8)
 716     VSHASIGMAD_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1730u),
 717     VSHASIGMAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1666u),
 718 
 719     // Vector Binary Polynomial Multiplication (introduced with Power 8)
 720     VPMSUMB_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1032u),
 721     VPMSUMD_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1224u),
 722     VPMSUMH_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1096u),
 723     VPMSUMW_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1160u),
 724 
 725     // Vector Permute and Xor (introduced with Power 8)
 726     VPERMXOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |   45u),
 727 
 728     // Transactional Memory instructions (introduced with Power 8)
 729     TBEGIN_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  654u &lt;&lt; 1),
 730     TEND_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |  686u &lt;&lt; 1),
 731     TABORT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  910u &lt;&lt; 1),
 732     TABORTWC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  782u &lt;&lt; 1),
 733     TABORTWCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 734     TABORTDC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 735     TABORTDCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  878u &lt;&lt; 1),
 736     TSR_OPCODE       = (31u &lt;&lt; OPCODE_SHIFT |  750u &lt;&lt; 1),
 737     TCHECK_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  718u &lt;&lt; 1),
 738 
 739     // Icache and dcache related instructions
 740     DCBA_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  758u &lt;&lt; 1),
 741     DCBZ_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 1014u &lt;&lt; 1),
 742     DCBST_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   54u &lt;&lt; 1),
 743     DCBF_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   86u &lt;&lt; 1),
 744 
 745     DCBT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  278u &lt;&lt; 1),
 746     DCBTST_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  246u &lt;&lt; 1),
 747     ICBI_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  982u &lt;&lt; 1),
 748 
 749     // Instruction synchronization
 750     ISYNC_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 751     // Memory barriers
 752     SYNC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  598u &lt;&lt; 1),
 753     EIEIO_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  854u &lt;&lt; 1),
 754 
 755     // Wait instructions for polling.
 756     WAIT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   62u &lt;&lt; 1),
 757 
 758     // Trap instructions
 759     TDI_OPCODE     = (2u  &lt;&lt; OPCODE_SHIFT),
 760     TWI_OPCODE     = (3u  &lt;&lt; OPCODE_SHIFT),
 761     TD_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |   68u &lt;&lt; 1),
 762     TW_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |    4u &lt;&lt; 1),
 763 
 764     // Atomics.
 765     LBARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   52u &lt;&lt; 1),
 766     LHARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  116u &lt;&lt; 1),
 767     LWARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 768     LDARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   84u &lt;&lt; 1),
 769     LQARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  276u &lt;&lt; 1),
 770     STBCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  694u &lt;&lt; 1),
 771     STHCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  726u &lt;&lt; 1),
 772     STWCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 773     STDCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  214u &lt;&lt; 1),
 774     STQCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  182u &lt;&lt; 1)
 775 
 776   };
 777 
 778   // Trap instructions TO bits
 779   enum trap_to_bits {
 780     // single bits
 781     traptoLessThanSigned      = 1 &lt;&lt; 4, // 0, left end
 782     traptoGreaterThanSigned   = 1 &lt;&lt; 3,
 783     traptoEqual               = 1 &lt;&lt; 2,
 784     traptoLessThanUnsigned    = 1 &lt;&lt; 1,
 785     traptoGreaterThanUnsigned = 1 &lt;&lt; 0, // 4, right end
 786 
 787     // compound ones
 788     traptoUnconditional       = (traptoLessThanSigned |
 789                                  traptoGreaterThanSigned |
 790                                  traptoEqual |
 791                                  traptoLessThanUnsigned |
 792                                  traptoGreaterThanUnsigned)
 793   };
 794 
 795   // Branch hints BH field
 796   enum branch_hint_bh {
 797     // bclr cases:
 798     bhintbhBCLRisReturn            = 0,
 799     bhintbhBCLRisNotReturnButSame  = 1,
 800     bhintbhBCLRisNotPredictable    = 3,
 801 
 802     // bcctr cases:
 803     bhintbhBCCTRisNotReturnButSame = 0,
 804     bhintbhBCCTRisNotPredictable   = 3
 805   };
 806 
 807   // Branch prediction hints AT field
 808   enum branch_hint_at {
 809     bhintatNoHint     = 0,  // at=00
 810     bhintatIsNotTaken = 2,  // at=10
 811     bhintatIsTaken    = 3   // at=11
 812   };
 813 
 814   // Branch prediction hints
 815   enum branch_hint_concept {
 816     // Use the same encoding as branch_hint_at to simply code.
 817     bhintNoHint       = bhintatNoHint,
 818     bhintIsNotTaken   = bhintatIsNotTaken,
 819     bhintIsTaken      = bhintatIsTaken
 820   };
 821 
 822   // Used in BO field of branch instruction.
 823   enum branch_condition {
 824     bcondCRbiIs0      =  4, // bo=001at
 825     bcondCRbiIs1      = 12, // bo=011at
 826     bcondAlways       = 20  // bo=10100
 827   };
 828 
 829   // Branch condition with combined prediction hints.
 830   enum branch_condition_with_hint {
 831     bcondCRbiIs0_bhintNoHint     = bcondCRbiIs0 | bhintatNoHint,
 832     bcondCRbiIs0_bhintIsNotTaken = bcondCRbiIs0 | bhintatIsNotTaken,
 833     bcondCRbiIs0_bhintIsTaken    = bcondCRbiIs0 | bhintatIsTaken,
 834     bcondCRbiIs1_bhintNoHint     = bcondCRbiIs1 | bhintatNoHint,
 835     bcondCRbiIs1_bhintIsNotTaken = bcondCRbiIs1 | bhintatIsNotTaken,
 836     bcondCRbiIs1_bhintIsTaken    = bcondCRbiIs1 | bhintatIsTaken,
 837   };
 838 
 839   // Elemental Memory Barriers (&gt;=Power 8)
 840   enum Elemental_Membar_mask_bits {
 841     StoreStore = 1 &lt;&lt; 0,
 842     StoreLoad  = 1 &lt;&lt; 1,
 843     LoadStore  = 1 &lt;&lt; 2,
 844     LoadLoad   = 1 &lt;&lt; 3
 845   };
 846 
 847   // Branch prediction hints.
 848   inline static int add_bhint_to_boint(const int bhint, const int boint) {
 849     switch (boint) {
 850       case bcondCRbiIs0:
 851       case bcondCRbiIs1:
 852         // branch_hint and branch_hint_at have same encodings
 853         assert(   (int)bhintNoHint     == (int)bhintatNoHint
 854                &amp;&amp; (int)bhintIsNotTaken == (int)bhintatIsNotTaken
 855                &amp;&amp; (int)bhintIsTaken    == (int)bhintatIsTaken,
 856                &quot;wrong encodings&quot;);
 857         assert((bhint &amp; 0x03) == bhint, &quot;wrong encodings&quot;);
 858         return (boint &amp; ~0x03) | bhint;
 859       case bcondAlways:
 860         // no branch_hint
 861         return boint;
 862       default:
 863         ShouldNotReachHere();
 864         return 0;
 865     }
 866   }
 867 
 868   // Extract bcond from boint.
 869   inline static int inv_boint_bcond(const int boint) {
 870     int r_bcond = boint &amp; ~0x03;
 871     assert(r_bcond == bcondCRbiIs0 ||
 872            r_bcond == bcondCRbiIs1 ||
 873            r_bcond == bcondAlways,
 874            &quot;bad branch condition&quot;);
 875     return r_bcond;
 876   }
 877 
 878   // Extract bhint from boint.
 879   inline static int inv_boint_bhint(const int boint) {
 880     int r_bhint = boint &amp; 0x03;
 881     assert(r_bhint == bhintatNoHint ||
 882            r_bhint == bhintatIsNotTaken ||
 883            r_bhint == bhintatIsTaken,
 884            &quot;bad branch hint&quot;);
 885     return r_bhint;
 886   }
 887 
 888   // Calculate opposite of given bcond.
 889   inline static int opposite_bcond(const int bcond) {
 890     switch (bcond) {
 891       case bcondCRbiIs0:
 892         return bcondCRbiIs1;
 893       case bcondCRbiIs1:
 894         return bcondCRbiIs0;
 895       default:
 896         ShouldNotReachHere();
 897         return 0;
 898     }
 899   }
 900 
 901   // Calculate opposite of given bhint.
 902   inline static int opposite_bhint(const int bhint) {
 903     switch (bhint) {
 904       case bhintatNoHint:
 905         return bhintatNoHint;
 906       case bhintatIsNotTaken:
 907         return bhintatIsTaken;
 908       case bhintatIsTaken:
 909         return bhintatIsNotTaken;
 910       default:
 911         ShouldNotReachHere();
 912         return 0;
 913     }
 914   }
 915 
 916   // PPC branch instructions
 917   enum ppcops {
 918     b_op    = 18,
 919     bc_op   = 16,
 920     bcr_op  = 19
 921   };
 922 
 923   enum Condition {
 924     negative         = 0,
 925     less             = 0,
 926     positive         = 1,
 927     greater          = 1,
 928     zero             = 2,
 929     equal            = 2,
 930     summary_overflow = 3,
 931   };
 932 
 933  public:
 934   // Helper functions for groups of instructions
 935 
 936   enum Predict { pt = 1, pn = 0 }; // pt = predict taken
 937 
<a name="3" id="anc3"></a><span class="line-modified"> 938   //---&lt;  calculate length of instruction  &gt;---</span>
<span class="line-modified"> 939   // With PPC64 being a RISC architecture, this always is BytesPerInstWord</span>
<span class="line-added"> 940   // instruction must start at passed address</span>
<span class="line-added"> 941   static unsigned int instr_len(unsigned char *instr) { return BytesPerInstWord; }</span>
 942 
<a name="4" id="anc4"></a><span class="line-modified"> 943   //---&lt;  longest instructions  &gt;---</span>
<span class="line-modified"> 944   static unsigned int instr_maxlen() { return BytesPerInstWord; }</span>
 945 
 946   // Test if x is within signed immediate range for nbits.
 947   static bool is_simm(int x, unsigned int nbits) {
 948     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, &quot;out of bounds&quot;);
 949     const int   min      = -(((int)1) &lt;&lt; nbits-1);
 950     const int   maxplus1 =  (((int)1) &lt;&lt; nbits-1);
 951     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 952   }
 953 
 954   static bool is_simm(jlong x, unsigned int nbits) {
 955     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, &quot;out of bounds&quot;);
 956     const jlong min      = -(((jlong)1) &lt;&lt; nbits-1);
 957     const jlong maxplus1 =  (((jlong)1) &lt;&lt; nbits-1);
 958     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 959   }
 960 
 961   // Test if x is within unsigned immediate range for nbits.
 962   static bool is_uimm(int x, unsigned int nbits) {
 963     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, &quot;out of bounds&quot;);
 964     const unsigned int maxplus1 = (((unsigned int)1) &lt;&lt; nbits);
 965     return (unsigned int)x &lt; maxplus1;
 966   }
 967 
 968   static bool is_uimm(jlong x, unsigned int nbits) {
 969     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, &quot;out of bounds&quot;);
 970     const julong maxplus1 = (((julong)1) &lt;&lt; nbits);
 971     return (julong)x &lt; maxplus1;
 972   }
 973 
 974  protected:
 975   // helpers
 976 
 977   // X is supposed to fit in a field &quot;nbits&quot; wide
 978   // and be sign-extended. Check the range.
 979   static void assert_signed_range(intptr_t x, int nbits) {
 980     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 981            &quot;value out of range&quot;);
 982   }
 983 
 984   static void assert_signed_word_disp_range(intptr_t x, int nbits) {
 985     assert((x &amp; 3) == 0, &quot;not word aligned&quot;);
 986     assert_signed_range(x, nbits + 2);
 987   }
 988 
 989   static void assert_unsigned_const(int x, int nbits) {
 990     assert(juint(x) &lt; juint(1 &lt;&lt; nbits), &quot;unsigned constant out of range&quot;);
 991   }
 992 
 993   static int fmask(juint hi_bit, juint lo_bit) {
 994     assert(hi_bit &gt;= lo_bit &amp;&amp; hi_bit &lt; 32, &quot;bad bits&quot;);
 995     return (1 &lt;&lt; ( hi_bit-lo_bit + 1 )) - 1;
 996   }
 997 
 998   // inverse of u_field
 999   static int inv_u_field(int x, int hi_bit, int lo_bit) {
1000     juint r = juint(x) &gt;&gt; lo_bit;
1001     r &amp;= fmask(hi_bit, lo_bit);
1002     return int(r);
1003   }
1004 
1005   // signed version: extract from field and sign-extend
1006   static int inv_s_field_ppc(int x, int hi_bit, int lo_bit) {
1007     x = x &lt;&lt; (31-hi_bit);
1008     x = x &gt;&gt; (31-hi_bit+lo_bit);
1009     return x;
1010   }
1011 
1012   static int u_field(int x, int hi_bit, int lo_bit) {
1013     assert((x &amp; ~fmask(hi_bit, lo_bit)) == 0, &quot;value out of range&quot;);
1014     int r = x &lt;&lt; lo_bit;
1015     assert(inv_u_field(r, hi_bit, lo_bit) == x, &quot;just checking&quot;);
1016     return r;
1017   }
1018 
1019   // Same as u_field for signed values
1020   static int s_field(int x, int hi_bit, int lo_bit) {
1021     int nbits = hi_bit - lo_bit + 1;
1022     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
1023       &quot;value out of range&quot;);
1024     x &amp;= fmask(hi_bit, lo_bit);
1025     int r = x &lt;&lt; lo_bit;
1026     return r;
1027   }
1028 
1029   // inv_op for ppc instructions
1030   static int inv_op_ppc(int x) { return inv_u_field(x, 31, 26); }
1031 
1032   // Determine target address from li, bd field of branch instruction.
1033   static intptr_t inv_li_field(int x) {
1034     intptr_t r = inv_s_field_ppc(x, 25, 2);
1035     r = (r &lt;&lt; 2);
1036     return r;
1037   }
1038   static intptr_t inv_bd_field(int x, intptr_t pos) {
1039     intptr_t r = inv_s_field_ppc(x, 15, 2);
1040     r = (r &lt;&lt; 2) + pos;
1041     return r;
1042   }
1043 
1044   #define inv_opp_u_field(x, hi_bit, lo_bit) inv_u_field(x, 31-(lo_bit), 31-(hi_bit))
1045   #define inv_opp_s_field(x, hi_bit, lo_bit) inv_s_field_ppc(x, 31-(lo_bit), 31-(hi_bit))
1046   // Extract instruction fields from instruction words.
1047  public:
1048   static int inv_ra_field(int x)  { return inv_opp_u_field(x, 15, 11); }
1049   static int inv_rb_field(int x)  { return inv_opp_u_field(x, 20, 16); }
1050   static int inv_rt_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1051   static int inv_rta_field(int x) { return inv_opp_u_field(x, 15, 11); }
1052   static int inv_rs_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1053   // Ds uses opp_s_field(x, 31, 16), but lowest 2 bits must be 0.
1054   // Inv_ds_field uses range (x, 29, 16) but shifts by 2 to ensure that lowest bits are 0.
1055   static int inv_ds_field(int x)  { return inv_opp_s_field(x, 29, 16) &lt;&lt; 2; }
1056   static int inv_d1_field(int x)  { return inv_opp_s_field(x, 31, 16); }
1057   static int inv_si_field(int x)  { return inv_opp_s_field(x, 31, 16); }
1058   static int inv_to_field(int x)  { return inv_opp_u_field(x, 10, 6);  }
1059   static int inv_lk_field(int x)  { return inv_opp_u_field(x, 31, 31); }
1060   static int inv_bo_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1061   static int inv_bi_field(int x)  { return inv_opp_u_field(x, 15, 11); }
1062 
1063   #define opp_u_field(x, hi_bit, lo_bit) u_field(x, 31-(lo_bit), 31-(hi_bit))
1064   #define opp_s_field(x, hi_bit, lo_bit) s_field(x, 31-(lo_bit), 31-(hi_bit))
1065 
1066   // instruction fields
1067   static int aa(       int         x)  { return  opp_u_field(x,             30, 30); }
1068   static int ba(       int         x)  { return  opp_u_field(x,             15, 11); }
1069   static int bb(       int         x)  { return  opp_u_field(x,             20, 16); }
1070   static int bc(       int         x)  { return  opp_u_field(x,             25, 21); }
1071   static int bd(       int         x)  { return  opp_s_field(x,             29, 16); }
1072   static int bf( ConditionRegister cr) { return  bf(cr-&gt;encoding()); }
1073   static int bf(       int         x)  { return  opp_u_field(x,              8,  6); }
1074   static int bfa(ConditionRegister cr) { return  bfa(cr-&gt;encoding()); }
1075   static int bfa(      int         x)  { return  opp_u_field(x,             13, 11); }
1076   static int bh(       int         x)  { return  opp_u_field(x,             20, 19); }
1077   static int bi(       int         x)  { return  opp_u_field(x,             15, 11); }
1078   static int bi0(ConditionRegister cr, Condition c) { return (cr-&gt;encoding() &lt;&lt; 2) | c; }
1079   static int bo(       int         x)  { return  opp_u_field(x,             10,  6); }
1080   static int bt(       int         x)  { return  opp_u_field(x,             10,  6); }
1081   static int d1(       int         x)  { return  opp_s_field(x,             31, 16); }
1082   static int ds(       int         x)  { assert((x &amp; 0x3) == 0, &quot;unaligned offset&quot;); return opp_s_field(x, 31, 16); }
1083   static int eh(       int         x)  { return  opp_u_field(x,             31, 31); }
1084   static int flm(      int         x)  { return  opp_u_field(x,             14,  7); }
1085   static int fra(    FloatRegister r)  { return  fra(r-&gt;encoding());}
1086   static int frb(    FloatRegister r)  { return  frb(r-&gt;encoding());}
1087   static int frc(    FloatRegister r)  { return  frc(r-&gt;encoding());}
1088   static int frs(    FloatRegister r)  { return  frs(r-&gt;encoding());}
1089   static int frt(    FloatRegister r)  { return  frt(r-&gt;encoding());}
1090   static int fra(      int         x)  { return  opp_u_field(x,             15, 11); }
1091   static int frb(      int         x)  { return  opp_u_field(x,             20, 16); }
1092   static int frc(      int         x)  { return  opp_u_field(x,             25, 21); }
1093   static int frs(      int         x)  { return  opp_u_field(x,             10,  6); }
1094   static int frt(      int         x)  { return  opp_u_field(x,             10,  6); }
1095   static int fxm(      int         x)  { return  opp_u_field(x,             19, 12); }
1096   static int l10(      int         x)  { assert(x == 0 || x == 1,  &quot;must be 0 or 1&quot;); return opp_u_field(x, 10, 10); }
1097   static int l14(      int         x)  { return  opp_u_field(x,             15, 14); }
1098   static int l15(      int         x)  { return  opp_u_field(x,             15, 15); }
1099   static int l910(     int         x)  { return  opp_u_field(x,             10,  9); }
1100   static int e1215(    int         x)  { return  opp_u_field(x,             15, 12); }
1101   static int lev(      int         x)  { return  opp_u_field(x,             26, 20); }
1102   static int li(       int         x)  { return  opp_s_field(x,             29,  6); }
1103   static int lk(       int         x)  { return  opp_u_field(x,             31, 31); }
1104   static int mb2125(   int         x)  { return  opp_u_field(x,             25, 21); }
1105   static int me2630(   int         x)  { return  opp_u_field(x,             30, 26); }
1106   static int mb2126(   int         x)  { return  opp_u_field(((x &amp; 0x1f) &lt;&lt; 1) | ((x &amp; 0x20) &gt;&gt; 5), 26, 21); }
1107   static int me2126(   int         x)  { return  mb2126(x); }
1108   static int nb(       int         x)  { return  opp_u_field(x,             20, 16); }
1109   //static int opcd(   int         x)  { return  opp_u_field(x,              5,  0); } // is contained in our opcodes
1110   static int oe(       int         x)  { return  opp_u_field(x,             21, 21); }
1111   static int ra(       Register    r)  { return  ra(r-&gt;encoding()); }
1112   static int ra(       int         x)  { return  opp_u_field(x,             15, 11); }
1113   static int rb(       Register    r)  { return  rb(r-&gt;encoding()); }
1114   static int rb(       int         x)  { return  opp_u_field(x,             20, 16); }
1115   static int rc(       int         x)  { return  opp_u_field(x,             31, 31); }
1116   static int rs(       Register    r)  { return  rs(r-&gt;encoding()); }
1117   static int rs(       int         x)  { return  opp_u_field(x,             10,  6); }
1118   // we don&#39;t want to use R0 in memory accesses, because it has value `0&#39; then
1119   static int ra0mem(   Register    r)  { assert(r != R0, &quot;cannot use register R0 in memory access&quot;); return ra(r); }
1120   static int ra0mem(   int         x)  { assert(x != 0,  &quot;cannot use register 0 in memory access&quot;);  return ra(x); }
1121 
1122   // register r is target
1123   static int rt(       Register    r)  { return rs(r); }
1124   static int rt(       int         x)  { return rs(x); }
1125   static int rta(      Register    r)  { return ra(r); }
1126   static int rta0mem(  Register    r)  { rta(r); return ra0mem(r); }
1127 
1128   static int sh1620(   int         x)  { return  opp_u_field(x,             20, 16); }
1129   static int sh30(     int         x)  { return  opp_u_field(x,             30, 30); }
1130   static int sh162030( int         x)  { return  sh1620(x &amp; 0x1f) | sh30((x &amp; 0x20) &gt;&gt; 5); }
1131   static int si(       int         x)  { return  opp_s_field(x,             31, 16); }
1132   static int spr(      int         x)  { return  opp_u_field(x,             20, 11); }
1133   static int sr(       int         x)  { return  opp_u_field(x,             15, 12); }
1134   static int tbr(      int         x)  { return  opp_u_field(x,             20, 11); }
1135   static int th(       int         x)  { return  opp_u_field(x,             10,  7); }
1136   static int thct(     int         x)  { assert((x&amp;8) == 0, &quot;must be valid cache specification&quot;);  return th(x); }
1137   static int thds(     int         x)  { assert((x&amp;8) == 8, &quot;must be valid stream specification&quot;); return th(x); }
1138   static int to(       int         x)  { return  opp_u_field(x,             10,  6); }
1139   static int u(        int         x)  { return  opp_u_field(x,             19, 16); }
1140   static int ui(       int         x)  { return  opp_u_field(x,             31, 16); }
1141 
1142   // Support vector instructions for &gt;= Power6.
1143   static int vra(      int         x)  { return  opp_u_field(x,             15, 11); }
1144   static int vrb(      int         x)  { return  opp_u_field(x,             20, 16); }
1145   static int vrc(      int         x)  { return  opp_u_field(x,             25, 21); }
1146   static int vrs(      int         x)  { return  opp_u_field(x,             10,  6); }
1147   static int vrt(      int         x)  { return  opp_u_field(x,             10,  6); }
1148 
1149   static int vra(   VectorRegister r)  { return  vra(r-&gt;encoding());}
1150   static int vrb(   VectorRegister r)  { return  vrb(r-&gt;encoding());}
1151   static int vrc(   VectorRegister r)  { return  vrc(r-&gt;encoding());}
1152   static int vrs(   VectorRegister r)  { return  vrs(r-&gt;encoding());}
1153   static int vrt(   VectorRegister r)  { return  vrt(r-&gt;encoding());}
1154 
1155   // Only used on SHA sigma instructions (VX-form)
1156   static int vst(      int         x)  { return  opp_u_field(x,             16, 16); }
1157   static int vsix(     int         x)  { return  opp_u_field(x,             20, 17); }
1158 
1159   // Support Vector-Scalar (VSX) instructions.
1160   static int vsra(      int         x)  { return  opp_u_field(x &amp; 0x1F,     15, 11) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 29, 29); }
1161   static int vsrb(      int         x)  { return  opp_u_field(x &amp; 0x1F,     20, 16) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 30, 30); }
1162   static int vsrs(      int         x)  { return  opp_u_field(x &amp; 0x1F,     10,  6) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 31, 31); }
1163   static int vsrt(      int         x)  { return  vsrs(x); }
1164   static int vsdm(      int         x)  { return  opp_u_field(x,            23, 22); }
1165 
1166   static int vsra(   VectorSRegister r)  { return  vsra(r-&gt;encoding());}
1167   static int vsrb(   VectorSRegister r)  { return  vsrb(r-&gt;encoding());}
1168   static int vsrs(   VectorSRegister r)  { return  vsrs(r-&gt;encoding());}
1169   static int vsrt(   VectorSRegister r)  { return  vsrt(r-&gt;encoding());}
1170 
1171   static int vsplt_uim( int        x)  { return  opp_u_field(x,             15, 12); } // for vsplt* instructions
1172   static int vsplti_sim(int        x)  { return  opp_u_field(x,             15, 11); } // for vsplti* instructions
1173   static int vsldoi_shb(int        x)  { return  opp_u_field(x,             25, 22); } // for vsldoi instruction
1174   static int vcmp_rc(   int        x)  { return  opp_u_field(x,             21, 21); } // for vcmp* instructions
1175   static int xxsplt_uim(int        x)  { return  opp_u_field(x,             15, 14); } // for xxsplt* instructions
1176 
1177   //static int xo1(     int        x)  { return  opp_u_field(x,             29, 21); }// is contained in our opcodes
1178   //static int xo2(     int        x)  { return  opp_u_field(x,             30, 21); }// is contained in our opcodes
1179   //static int xo3(     int        x)  { return  opp_u_field(x,             30, 22); }// is contained in our opcodes
1180   //static int xo4(     int        x)  { return  opp_u_field(x,             30, 26); }// is contained in our opcodes
1181   //static int xo5(     int        x)  { return  opp_u_field(x,             29, 27); }// is contained in our opcodes
1182   //static int xo6(     int        x)  { return  opp_u_field(x,             30, 27); }// is contained in our opcodes
1183   //static int xo7(     int        x)  { return  opp_u_field(x,             31, 30); }// is contained in our opcodes
1184 
1185  protected:
1186   // Compute relative address for branch.
1187   static intptr_t disp(intptr_t x, intptr_t off) {
1188     int xx = x - off;
1189     xx = xx &gt;&gt; 2;
1190     return xx;
1191   }
1192 
1193  public:
1194   // signed immediate, in low bits, nbits long
1195   static int simm(int x, int nbits) {
1196     assert_signed_range(x, nbits);
1197     return x &amp; ((1 &lt;&lt; nbits) - 1);
1198   }
1199 
1200   // unsigned immediate, in low bits, nbits long
1201   static int uimm(int x, int nbits) {
1202     assert_unsigned_const(x, nbits);
1203     return x &amp; ((1 &lt;&lt; nbits) - 1);
1204   }
1205 
1206   static void set_imm(int* instr, short s) {
1207     // imm is always in the lower 16 bits of the instruction,
1208     // so this is endian-neutral. Same for the get_imm below.
1209     uint32_t w = *(uint32_t *)instr;
1210     *instr = (int)((w &amp; ~0x0000FFFF) | (s &amp; 0x0000FFFF));
1211   }
1212 
1213   static int get_imm(address a, int instruction_number) {
1214     return (short)((int *)a)[instruction_number];
1215   }
1216 
1217   static inline int hi16_signed(  int x) { return (int)(int16_t)(x &gt;&gt; 16); }
1218   static inline int lo16_unsigned(int x) { return x &amp; 0xffff; }
1219 
1220  protected:
1221 
1222   // Extract the top 32 bits in a 64 bit word.
1223   static int32_t hi32(int64_t x) {
1224     int32_t r = int32_t((uint64_t)x &gt;&gt; 32);
1225     return r;
1226   }
1227 
1228  public:
1229 
1230   static inline unsigned int align_addr(unsigned int addr, unsigned int a) {
1231     return ((addr + (a - 1)) &amp; ~(a - 1));
1232   }
1233 
1234   static inline bool is_aligned(unsigned int addr, unsigned int a) {
1235     return (0 == addr % a);
1236   }
1237 
1238   void flush() {
1239     AbstractAssembler::flush();
1240   }
1241 
1242   inline void emit_int32(int);  // shadows AbstractAssembler::emit_int32
1243   inline void emit_data(int);
1244   inline void emit_data(int, RelocationHolder const&amp;);
1245   inline void emit_data(int, relocInfo::relocType rtype);
1246 
1247   // Emit an address.
1248   inline address emit_addr(const address addr = NULL);
1249 
1250 #if !defined(ABI_ELFv2)
1251   // Emit a function descriptor with the specified entry point, TOC,
1252   // and ENV. If the entry point is NULL, the descriptor will point
1253   // just past the descriptor.
1254   // Use values from friend functions as defaults.
1255   inline address emit_fd(address entry = NULL,
1256                          address toc = (address) FunctionDescriptor::friend_toc,
1257                          address env = (address) FunctionDescriptor::friend_env);
1258 #endif
1259 
1260   /////////////////////////////////////////////////////////////////////////////////////
1261   // PPC instructions
1262   /////////////////////////////////////////////////////////////////////////////////////
1263 
1264   // Memory instructions use r0 as hard coded 0, e.g. to simulate loading
1265   // immediates. The normal instruction encoders enforce that r0 is not
1266   // passed to them. Use either extended mnemonics encoders or the special ra0
1267   // versions.
1268 
1269   // Issue an illegal instruction.
1270   inline void illtrap();
1271   static inline bool is_illtrap(int x);
1272 
1273   // PPC 1, section 3.3.8, Fixed-Point Arithmetic Instructions
1274   inline void addi( Register d, Register a, int si16);
1275   inline void addis(Register d, Register a, int si16);
1276  private:
1277   inline void addi_r0ok( Register d, Register a, int si16);
1278   inline void addis_r0ok(Register d, Register a, int si16);
1279  public:
1280   inline void addic_( Register d, Register a, int si16);
1281   inline void subfic( Register d, Register a, int si16);
1282   inline void add(    Register d, Register a, Register b);
1283   inline void add_(   Register d, Register a, Register b);
1284   inline void subf(   Register d, Register a, Register b);  // d = b - a    &quot;Sub_from&quot;, as in ppc spec.
1285   inline void sub(    Register d, Register a, Register b);  // d = a - b    Swap operands of subf for readability.
1286   inline void subf_(  Register d, Register a, Register b);
1287   inline void addc(   Register d, Register a, Register b);
1288   inline void addc_(  Register d, Register a, Register b);
1289   inline void subfc(  Register d, Register a, Register b);
1290   inline void subfc_( Register d, Register a, Register b);
1291   inline void adde(   Register d, Register a, Register b);
1292   inline void adde_(  Register d, Register a, Register b);
1293   inline void subfe(  Register d, Register a, Register b);
1294   inline void subfe_( Register d, Register a, Register b);
1295   inline void addme(  Register d, Register a);
1296   inline void addme_( Register d, Register a);
1297   inline void subfme( Register d, Register a);
1298   inline void subfme_(Register d, Register a);
1299   inline void addze(  Register d, Register a);
1300   inline void addze_( Register d, Register a);
1301   inline void subfze( Register d, Register a);
1302   inline void subfze_(Register d, Register a);
1303   inline void neg(    Register d, Register a);
1304   inline void neg_(   Register d, Register a);
1305   inline void mulli(  Register d, Register a, int si16);
1306   inline void mulld(  Register d, Register a, Register b);
1307   inline void mulld_( Register d, Register a, Register b);
1308   inline void mullw(  Register d, Register a, Register b);
1309   inline void mullw_( Register d, Register a, Register b);
1310   inline void mulhw(  Register d, Register a, Register b);
1311   inline void mulhw_( Register d, Register a, Register b);
1312   inline void mulhwu( Register d, Register a, Register b);
1313   inline void mulhwu_(Register d, Register a, Register b);
1314   inline void mulhd(  Register d, Register a, Register b);
1315   inline void mulhd_( Register d, Register a, Register b);
1316   inline void mulhdu( Register d, Register a, Register b);
1317   inline void mulhdu_(Register d, Register a, Register b);
1318   inline void divd(   Register d, Register a, Register b);
1319   inline void divd_(  Register d, Register a, Register b);
1320   inline void divw(   Register d, Register a, Register b);
1321   inline void divw_(  Register d, Register a, Register b);
1322 
1323   // Fixed-Point Arithmetic Instructions with Overflow detection
1324   inline void addo(    Register d, Register a, Register b);
1325   inline void addo_(   Register d, Register a, Register b);
1326   inline void subfo(   Register d, Register a, Register b);
1327   inline void subfo_(  Register d, Register a, Register b);
1328   inline void addco(   Register d, Register a, Register b);
1329   inline void addco_(  Register d, Register a, Register b);
1330   inline void subfco(  Register d, Register a, Register b);
1331   inline void subfco_( Register d, Register a, Register b);
1332   inline void addeo(   Register d, Register a, Register b);
1333   inline void addeo_(  Register d, Register a, Register b);
1334   inline void subfeo(  Register d, Register a, Register b);
1335   inline void subfeo_( Register d, Register a, Register b);
1336   inline void addmeo(  Register d, Register a);
1337   inline void addmeo_( Register d, Register a);
1338   inline void subfmeo( Register d, Register a);
1339   inline void subfmeo_(Register d, Register a);
1340   inline void addzeo(  Register d, Register a);
1341   inline void addzeo_( Register d, Register a);
1342   inline void subfzeo( Register d, Register a);
1343   inline void subfzeo_(Register d, Register a);
1344   inline void nego(    Register d, Register a);
1345   inline void nego_(   Register d, Register a);
1346   inline void mulldo(  Register d, Register a, Register b);
1347   inline void mulldo_( Register d, Register a, Register b);
1348   inline void mullwo(  Register d, Register a, Register b);
1349   inline void mullwo_( Register d, Register a, Register b);
1350   inline void divdo(   Register d, Register a, Register b);
1351   inline void divdo_(  Register d, Register a, Register b);
1352   inline void divwo(   Register d, Register a, Register b);
1353   inline void divwo_(  Register d, Register a, Register b);
1354 
1355   // extended mnemonics
1356   inline void li(   Register d, int si16);
1357   inline void lis(  Register d, int si16);
1358   inline void addir(Register d, int si16, Register a);
1359   inline void subi( Register d, Register a, int si16);
1360 
1361   static bool is_addi(int x) {
1362      return ADDI_OPCODE == (x &amp; ADDI_OPCODE_MASK);
1363   }
1364   static bool is_addis(int x) {
1365      return ADDIS_OPCODE == (x &amp; ADDIS_OPCODE_MASK);
1366   }
1367   static bool is_bxx(int x) {
1368      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK);
1369   }
1370   static bool is_b(int x) {
1371      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 0;
1372   }
1373   static bool is_bl(int x) {
1374      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 1;
1375   }
1376   static bool is_bcxx(int x) {
1377      return BCXX_OPCODE == (x &amp; BCXX_OPCODE_MASK);
1378   }
1379   static bool is_bxx_or_bcxx(int x) {
1380      return is_bxx(x) || is_bcxx(x);
1381   }
1382   static bool is_bctrl(int x) {
1383      return x == 0x4e800421;
1384   }
1385   static bool is_bctr(int x) {
1386      return x == 0x4e800420;
1387   }
1388   static bool is_bclr(int x) {
1389      return BCLR_OPCODE == (x &amp; XL_FORM_OPCODE_MASK);
1390   }
1391   static bool is_li(int x) {
1392      return is_addi(x) &amp;&amp; inv_ra_field(x)==0;
1393   }
1394   static bool is_lis(int x) {
1395      return is_addis(x) &amp;&amp; inv_ra_field(x)==0;
1396   }
1397   static bool is_mtctr(int x) {
1398      return MTCTR_OPCODE == (x &amp; MTCTR_OPCODE_MASK);
1399   }
1400   static bool is_ld(int x) {
1401      return LD_OPCODE == (x &amp; LD_OPCODE_MASK);
1402   }
1403   static bool is_std(int x) {
1404      return STD_OPCODE == (x &amp; STD_OPCODE_MASK);
1405   }
1406   static bool is_stdu(int x) {
1407      return STDU_OPCODE == (x &amp; STDU_OPCODE_MASK);
1408   }
1409   static bool is_stdx(int x) {
1410      return STDX_OPCODE == (x &amp; STDX_OPCODE_MASK);
1411   }
1412   static bool is_stdux(int x) {
1413      return STDUX_OPCODE == (x &amp; STDUX_OPCODE_MASK);
1414   }
1415   static bool is_stwx(int x) {
1416      return STWX_OPCODE == (x &amp; STWX_OPCODE_MASK);
1417   }
1418   static bool is_stwux(int x) {
1419      return STWUX_OPCODE == (x &amp; STWUX_OPCODE_MASK);
1420   }
1421   static bool is_stw(int x) {
1422      return STW_OPCODE == (x &amp; STW_OPCODE_MASK);
1423   }
1424   static bool is_stwu(int x) {
1425      return STWU_OPCODE == (x &amp; STWU_OPCODE_MASK);
1426   }
1427   static bool is_ori(int x) {
1428      return ORI_OPCODE == (x &amp; ORI_OPCODE_MASK);
1429   };
1430   static bool is_oris(int x) {
1431      return ORIS_OPCODE == (x &amp; ORIS_OPCODE_MASK);
1432   };
1433   static bool is_rldicr(int x) {
1434      return (RLDICR_OPCODE == (x &amp; RLDICR_OPCODE_MASK));
1435   };
1436   static bool is_nop(int x) {
1437     return x == 0x60000000;
1438   }
1439   // endgroup opcode for Power6
1440   static bool is_endgroup(int x) {
1441     return is_ori(x) &amp;&amp; inv_ra_field(x) == 1 &amp;&amp; inv_rs_field(x) == 1 &amp;&amp; inv_d1_field(x) == 0;
1442   }
1443 
1444 
1445  private:
1446   // PPC 1, section 3.3.9, Fixed-Point Compare Instructions
1447   inline void cmpi( ConditionRegister bf, int l, Register a, int si16);
1448   inline void cmp(  ConditionRegister bf, int l, Register a, Register b);
1449   inline void cmpli(ConditionRegister bf, int l, Register a, int ui16);
1450   inline void cmpl( ConditionRegister bf, int l, Register a, Register b);
1451 
1452  public:
1453   // extended mnemonics of Compare Instructions
1454   inline void cmpwi( ConditionRegister crx, Register a, int si16);
1455   inline void cmpdi( ConditionRegister crx, Register a, int si16);
1456   inline void cmpw(  ConditionRegister crx, Register a, Register b);
1457   inline void cmpd(  ConditionRegister crx, Register a, Register b);
1458   inline void cmplwi(ConditionRegister crx, Register a, int ui16);
1459   inline void cmpldi(ConditionRegister crx, Register a, int ui16);
1460   inline void cmplw( ConditionRegister crx, Register a, Register b);
1461   inline void cmpld( ConditionRegister crx, Register a, Register b);
1462 
1463   // &gt;= Power9
1464   inline void cmprb( ConditionRegister bf, int l, Register a, Register b);
1465   inline void cmpeqb(ConditionRegister bf, Register a, Register b);
1466 
1467   inline void isel(   Register d, Register a, Register b, int bc);
1468   // Convenient version which takes: Condition register, Condition code and invert flag. Omit b to keep old value.
1469   inline void isel(   Register d, ConditionRegister cr, Condition cc, bool inv, Register a, Register b = noreg);
1470   // Set d = 0 if (cr.cc) equals 1, otherwise b.
1471   inline void isel_0( Register d, ConditionRegister cr, Condition cc, Register b = noreg);
1472 
1473   // PPC 1, section 3.3.11, Fixed-Point Logical Instructions
1474          void andi(   Register a, Register s, long ui16);   // optimized version
1475   inline void andi_(  Register a, Register s, int ui16);
1476   inline void andis_( Register a, Register s, int ui16);
1477   inline void ori(    Register a, Register s, int ui16);
1478   inline void oris(   Register a, Register s, int ui16);
1479   inline void xori(   Register a, Register s, int ui16);
1480   inline void xoris(  Register a, Register s, int ui16);
1481   inline void andr(   Register a, Register s, Register b);  // suffixed by &#39;r&#39; as &#39;and&#39; is C++ keyword
1482   inline void and_(   Register a, Register s, Register b);
1483   // Turn or0(rx,rx,rx) into a nop and avoid that we accidently emit a
1484   // SMT-priority change instruction (see SMT instructions below).
1485   inline void or_unchecked(Register a, Register s, Register b);
1486   inline void orr(    Register a, Register s, Register b);  // suffixed by &#39;r&#39; as &#39;or&#39; is C++ keyword
1487   inline void or_(    Register a, Register s, Register b);
1488   inline void xorr(   Register a, Register s, Register b);  // suffixed by &#39;r&#39; as &#39;xor&#39; is C++ keyword
1489   inline void xor_(   Register a, Register s, Register b);
1490   inline void nand(   Register a, Register s, Register b);
1491   inline void nand_(  Register a, Register s, Register b);
1492   inline void nor(    Register a, Register s, Register b);
1493   inline void nor_(   Register a, Register s, Register b);
1494   inline void andc(   Register a, Register s, Register b);
1495   inline void andc_(  Register a, Register s, Register b);
1496   inline void orc(    Register a, Register s, Register b);
1497   inline void orc_(   Register a, Register s, Register b);
1498   inline void extsb(  Register a, Register s);
1499   inline void extsb_( Register a, Register s);
1500   inline void extsh(  Register a, Register s);
1501   inline void extsh_( Register a, Register s);
1502   inline void extsw(  Register a, Register s);
1503   inline void extsw_( Register a, Register s);
1504 
1505   // extended mnemonics
1506   inline void nop();
1507   // NOP for FP and BR units (different versions to allow them to be in one group)
1508   inline void fpnop0();
1509   inline void fpnop1();
1510   inline void brnop0();
1511   inline void brnop1();
1512   inline void brnop2();
1513 
1514   inline void mr(      Register d, Register s);
1515   inline void ori_opt( Register d, int ui16);
1516   inline void oris_opt(Register d, int ui16);
1517 
1518   // endgroup opcode for Power6
1519   inline void endgroup();
1520 
1521   // count instructions
1522   inline void cntlzw(  Register a, Register s);
1523   inline void cntlzw_( Register a, Register s);
1524   inline void cntlzd(  Register a, Register s);
1525   inline void cntlzd_( Register a, Register s);
1526   inline void cnttzw(  Register a, Register s);
1527   inline void cnttzw_( Register a, Register s);
1528   inline void cnttzd(  Register a, Register s);
1529   inline void cnttzd_( Register a, Register s);
1530 
1531   // PPC 1, section 3.3.12, Fixed-Point Rotate and Shift Instructions
1532   inline void sld(     Register a, Register s, Register b);
1533   inline void sld_(    Register a, Register s, Register b);
1534   inline void slw(     Register a, Register s, Register b);
1535   inline void slw_(    Register a, Register s, Register b);
1536   inline void srd(     Register a, Register s, Register b);
1537   inline void srd_(    Register a, Register s, Register b);
1538   inline void srw(     Register a, Register s, Register b);
1539   inline void srw_(    Register a, Register s, Register b);
1540   inline void srad(    Register a, Register s, Register b);
1541   inline void srad_(   Register a, Register s, Register b);
1542   inline void sraw(    Register a, Register s, Register b);
1543   inline void sraw_(   Register a, Register s, Register b);
1544   inline void sradi(   Register a, Register s, int sh6);
1545   inline void sradi_(  Register a, Register s, int sh6);
1546   inline void srawi(   Register a, Register s, int sh5);
1547   inline void srawi_(  Register a, Register s, int sh5);
1548 
1549   // extended mnemonics for Shift Instructions
1550   inline void sldi(    Register a, Register s, int sh6);
1551   inline void sldi_(   Register a, Register s, int sh6);
1552   inline void slwi(    Register a, Register s, int sh5);
1553   inline void slwi_(   Register a, Register s, int sh5);
1554   inline void srdi(    Register a, Register s, int sh6);
1555   inline void srdi_(   Register a, Register s, int sh6);
1556   inline void srwi(    Register a, Register s, int sh5);
1557   inline void srwi_(   Register a, Register s, int sh5);
1558 
1559   inline void clrrdi(  Register a, Register s, int ui6);
1560   inline void clrrdi_( Register a, Register s, int ui6);
1561   inline void clrldi(  Register a, Register s, int ui6);
1562   inline void clrldi_( Register a, Register s, int ui6);
1563   inline void clrlsldi(Register a, Register s, int clrl6, int shl6);
1564   inline void clrlsldi_(Register a, Register s, int clrl6, int shl6);
1565   inline void extrdi(  Register a, Register s, int n, int b);
1566   // testbit with condition register
1567   inline void testbitdi(ConditionRegister cr, Register a, Register s, int ui6);
1568 
1569   // rotate instructions
1570   inline void rotldi(  Register a, Register s, int n);
1571   inline void rotrdi(  Register a, Register s, int n);
1572   inline void rotlwi(  Register a, Register s, int n);
1573   inline void rotrwi(  Register a, Register s, int n);
1574 
1575   // Rotate Instructions
1576   inline void rldic(   Register a, Register s, int sh6, int mb6);
1577   inline void rldic_(  Register a, Register s, int sh6, int mb6);
1578   inline void rldicr(  Register a, Register s, int sh6, int mb6);
1579   inline void rldicr_( Register a, Register s, int sh6, int mb6);
1580   inline void rldicl(  Register a, Register s, int sh6, int mb6);
1581   inline void rldicl_( Register a, Register s, int sh6, int mb6);
1582   inline void rlwinm(  Register a, Register s, int sh5, int mb5, int me5);
1583   inline void rlwinm_( Register a, Register s, int sh5, int mb5, int me5);
1584   inline void rldimi(  Register a, Register s, int sh6, int mb6);
1585   inline void rldimi_( Register a, Register s, int sh6, int mb6);
1586   inline void rlwimi(  Register a, Register s, int sh5, int mb5, int me5);
1587   inline void insrdi(  Register a, Register s, int n,   int b);
1588   inline void insrwi(  Register a, Register s, int n,   int b);
1589 
1590   // PPC 1, section 3.3.2 Fixed-Point Load Instructions
1591   // 4 bytes
1592   inline void lwzx( Register d, Register s1, Register s2);
1593   inline void lwz(  Register d, int si16,    Register s1);
1594   inline void lwzu( Register d, int si16,    Register s1);
1595 
1596   // 4 bytes
1597   inline void lwax( Register d, Register s1, Register s2);
1598   inline void lwa(  Register d, int si16,    Register s1);
1599 
1600   // 4 bytes reversed
1601   inline void lwbrx( Register d, Register s1, Register s2);
1602 
1603   // 2 bytes
1604   inline void lhzx( Register d, Register s1, Register s2);
1605   inline void lhz(  Register d, int si16,    Register s1);
1606   inline void lhzu( Register d, int si16,    Register s1);
1607 
1608   // 2 bytes reversed
1609   inline void lhbrx( Register d, Register s1, Register s2);
1610 
1611   // 2 bytes
1612   inline void lhax( Register d, Register s1, Register s2);
1613   inline void lha(  Register d, int si16,    Register s1);
1614   inline void lhau( Register d, int si16,    Register s1);
1615 
1616   // 1 byte
1617   inline void lbzx( Register d, Register s1, Register s2);
1618   inline void lbz(  Register d, int si16,    Register s1);
1619   inline void lbzu( Register d, int si16,    Register s1);
1620 
1621   // 8 bytes
1622   inline void ldx(  Register d, Register s1, Register s2);
1623   inline void ld(   Register d, int si16,    Register s1);
1624   inline void ldu(  Register d, int si16,    Register s1);
1625 
1626   // 8 bytes reversed
1627   inline void ldbrx( Register d, Register s1, Register s2);
1628 
1629   // For convenience. Load pointer into d from b+s1.
1630   inline void ld_ptr(Register d, int b, Register s1);
1631   DEBUG_ONLY(inline void ld_ptr(Register d, ByteSize b, Register s1);)
1632 
1633   //  PPC 1, section 3.3.3 Fixed-Point Store Instructions
1634   inline void stwx( Register d, Register s1, Register s2);
1635   inline void stw(  Register d, int si16,    Register s1);
1636   inline void stwu( Register d, int si16,    Register s1);
1637   inline void stwbrx( Register d, Register s1, Register s2);
1638 
1639   inline void sthx( Register d, Register s1, Register s2);
1640   inline void sth(  Register d, int si16,    Register s1);
1641   inline void sthu( Register d, int si16,    Register s1);
1642   inline void sthbrx( Register d, Register s1, Register s2);
1643 
1644   inline void stbx( Register d, Register s1, Register s2);
1645   inline void stb(  Register d, int si16,    Register s1);
1646   inline void stbu( Register d, int si16,    Register s1);
1647 
1648   inline void stdx( Register d, Register s1, Register s2);
1649   inline void std(  Register d, int si16,    Register s1);
1650   inline void stdu( Register d, int si16,    Register s1);
1651   inline void stdux(Register s, Register a,  Register b);
1652   inline void stdbrx( Register d, Register s1, Register s2);
1653 
1654   inline void st_ptr(Register d, int si16,    Register s1);
1655   DEBUG_ONLY(inline void st_ptr(Register d, ByteSize b, Register s1);)
1656 
1657   // PPC 1, section 3.3.13 Move To/From System Register Instructions
1658   inline void mtlr( Register s1);
1659   inline void mflr( Register d);
1660   inline void mtctr(Register s1);
1661   inline void mfctr(Register d);
1662   inline void mtcrf(int fxm, Register s);
1663   inline void mfcr( Register d);
1664   inline void mcrf( ConditionRegister crd, ConditionRegister cra);
1665   inline void mtcr( Register s);
1666   // &gt;= Power9
1667   inline void setb( Register d, ConditionRegister cra);
1668 
1669   // Special purpose registers
1670   // Exception Register
1671   inline void mtxer(Register s1);
1672   inline void mfxer(Register d);
1673   // Vector Register Save Register
1674   inline void mtvrsave(Register s1);
1675   inline void mfvrsave(Register d);
1676   // Timebase
1677   inline void mftb(Register d);
1678   // Introduced with Power 8:
1679   // Data Stream Control Register
1680   inline void mtdscr(Register s1);
1681   inline void mfdscr(Register d );
1682   // Transactional Memory Registers
1683   inline void mftfhar(Register d);
1684   inline void mftfiar(Register d);
1685   inline void mftexasr(Register d);
1686   inline void mftexasru(Register d);
1687 
1688   // TEXASR bit description
1689   enum transaction_failure_reason {
1690     // Upper half (TEXASRU):
1691     tm_failure_code       =  0, // The Failure Code is copied from tabort or treclaim operand.
1692     tm_failure_persistent =  7, // The failure is likely to recur on each execution.
1693     tm_disallowed         =  8, // The instruction is not permitted.
1694     tm_nesting_of         =  9, // The maximum transaction level was exceeded.
1695     tm_footprint_of       = 10, // The tracking limit for transactional storage accesses was exceeded.
1696     tm_self_induced_cf    = 11, // A self-induced conflict occurred in Suspended state.
1697     tm_non_trans_cf       = 12, // A conflict occurred with a non-transactional access by another processor.
1698     tm_trans_cf           = 13, // A conflict occurred with another transaction.
1699     tm_translation_cf     = 14, // A conflict occurred with a TLB invalidation.
1700     tm_inst_fetch_cf      = 16, // An instruction fetch was performed from a block that was previously written transactionally.
1701     tm_tabort             = 31, // Termination was caused by the execution of an abort instruction.
1702     // Lower half:
1703     tm_suspended          = 32, // Failure was recorded in Suspended state.
1704     tm_failure_summary    = 36, // Failure has been detected and recorded.
1705     tm_tfiar_exact        = 37, // Value in the TFIAR is exact.
1706     tm_rot                = 38, // Rollback-only transaction.
1707     tm_transaction_level  = 52, // Transaction level (nesting depth + 1).
1708   };
1709 
1710   // PPC 1, section 2.4.1 Branch Instructions
1711   inline void b(  address a, relocInfo::relocType rt = relocInfo::none);
1712   inline void b(  Label&amp; L);
1713   inline void bl( address a, relocInfo::relocType rt = relocInfo::none);
1714   inline void bl( Label&amp; L);
1715   inline void bc( int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1716   inline void bc( int boint, int biint, Label&amp; L);
1717   inline void bcl(int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1718   inline void bcl(int boint, int biint, Label&amp; L);
1719 
1720   inline void bclr(  int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1721   inline void bclrl( int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1722   inline void bcctr( int boint, int biint, int bhint = bhintbhBCCTRisNotReturnButSame,
1723                          relocInfo::relocType rt = relocInfo::none);
1724   inline void bcctrl(int boint, int biint, int bhint = bhintbhBCLRisReturn,
1725                          relocInfo::relocType rt = relocInfo::none);
1726 
1727   // helper function for b, bcxx
1728   inline bool is_within_range_of_b(address a, address pc);
1729   inline bool is_within_range_of_bcxx(address a, address pc);
1730 
1731   // get the destination of a bxx branch (b, bl, ba, bla)
1732   static inline address  bxx_destination(address baddr);
1733   static inline address  bxx_destination(int instr, address pc);
1734   static inline intptr_t bxx_destination_offset(int instr, intptr_t bxx_pos);
1735 
1736   // extended mnemonics for branch instructions
1737   inline void blt(ConditionRegister crx, Label&amp; L);
1738   inline void bgt(ConditionRegister crx, Label&amp; L);
1739   inline void beq(ConditionRegister crx, Label&amp; L);
1740   inline void bso(ConditionRegister crx, Label&amp; L);
1741   inline void bge(ConditionRegister crx, Label&amp; L);
1742   inline void ble(ConditionRegister crx, Label&amp; L);
1743   inline void bne(ConditionRegister crx, Label&amp; L);
1744   inline void bns(ConditionRegister crx, Label&amp; L);
1745 
1746   // Branch instructions with static prediction hints.
1747   inline void blt_predict_taken(    ConditionRegister crx, Label&amp; L);
1748   inline void bgt_predict_taken(    ConditionRegister crx, Label&amp; L);
1749   inline void beq_predict_taken(    ConditionRegister crx, Label&amp; L);
1750   inline void bso_predict_taken(    ConditionRegister crx, Label&amp; L);
1751   inline void bge_predict_taken(    ConditionRegister crx, Label&amp; L);
1752   inline void ble_predict_taken(    ConditionRegister crx, Label&amp; L);
1753   inline void bne_predict_taken(    ConditionRegister crx, Label&amp; L);
1754   inline void bns_predict_taken(    ConditionRegister crx, Label&amp; L);
1755   inline void blt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1756   inline void bgt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1757   inline void beq_predict_not_taken(ConditionRegister crx, Label&amp; L);
1758   inline void bso_predict_not_taken(ConditionRegister crx, Label&amp; L);
1759   inline void bge_predict_not_taken(ConditionRegister crx, Label&amp; L);
1760   inline void ble_predict_not_taken(ConditionRegister crx, Label&amp; L);
1761   inline void bne_predict_not_taken(ConditionRegister crx, Label&amp; L);
1762   inline void bns_predict_not_taken(ConditionRegister crx, Label&amp; L);
1763 
1764   // for use in conjunction with testbitdi:
1765   inline void btrue( ConditionRegister crx, Label&amp; L);
1766   inline void bfalse(ConditionRegister crx, Label&amp; L);
1767 
1768   inline void bltl(ConditionRegister crx, Label&amp; L);
1769   inline void bgtl(ConditionRegister crx, Label&amp; L);
1770   inline void beql(ConditionRegister crx, Label&amp; L);
1771   inline void bsol(ConditionRegister crx, Label&amp; L);
1772   inline void bgel(ConditionRegister crx, Label&amp; L);
1773   inline void blel(ConditionRegister crx, Label&amp; L);
1774   inline void bnel(ConditionRegister crx, Label&amp; L);
1775   inline void bnsl(ConditionRegister crx, Label&amp; L);
1776 
1777   // extended mnemonics for Branch Instructions via LR
1778   // We use `blr&#39; for returns.
1779   inline void blr(relocInfo::relocType rt = relocInfo::none);
1780 
1781   // extended mnemonics for Branch Instructions with CTR
1782   // bdnz means `decrement CTR and jump to L if CTR is not zero&#39;
1783   inline void bdnz(Label&amp; L);
1784   // Decrement and branch if result is zero.
1785   inline void bdz(Label&amp; L);
1786   // we use `bctr[l]&#39; for jumps/calls in function descriptor glue
1787   // code, e.g. calls to runtime functions
1788   inline void bctr( relocInfo::relocType rt = relocInfo::none);
1789   inline void bctrl(relocInfo::relocType rt = relocInfo::none);
1790   // conditional jumps/branches via CTR
1791   inline void beqctr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1792   inline void beqctrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1793   inline void bnectr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1794   inline void bnectrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1795 
1796   // condition register logic instructions
1797   // NOTE: There&#39;s a preferred form: d and s2 should point into the same condition register.
1798   inline void crand( int d, int s1, int s2);
1799   inline void crnand(int d, int s1, int s2);
1800   inline void cror(  int d, int s1, int s2);
1801   inline void crxor( int d, int s1, int s2);
1802   inline void crnor( int d, int s1, int s2);
1803   inline void creqv( int d, int s1, int s2);
1804   inline void crandc(int d, int s1, int s2);
1805   inline void crorc( int d, int s1, int s2);
1806 
1807   // More convenient version.
1808   int condition_register_bit(ConditionRegister cr, Condition c) {
1809     return 4 * (int)(intptr_t)cr + c;
1810   }
1811   void crand( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1812   void crnand(ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1813   void cror(  ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1814   void crxor( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1815   void crnor( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1816   void creqv( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1817   void crandc(ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1818   void crorc( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1819 
1820   // icache and dcache related instructions
1821   inline void icbi(  Register s1, Register s2);
1822   //inline void dcba(Register s1, Register s2); // Instruction for embedded processor only.
1823   inline void dcbz(  Register s1, Register s2);
1824   inline void dcbst( Register s1, Register s2);
1825   inline void dcbf(  Register s1, Register s2);
1826 
1827   enum ct_cache_specification {
1828     ct_primary_cache   = 0,
1829     ct_secondary_cache = 2
1830   };
1831   // dcache read hint
1832   inline void dcbt(    Register s1, Register s2);
1833   inline void dcbtct(  Register s1, Register s2, int ct);
1834   inline void dcbtds(  Register s1, Register s2, int ds);
1835   // dcache write hint
1836   inline void dcbtst(  Register s1, Register s2);
1837   inline void dcbtstct(Register s1, Register s2, int ct);
1838 
1839   //  machine barrier instructions:
1840   //
1841   //  - sync    two-way memory barrier, aka fence
1842   //  - lwsync  orders  Store|Store,
1843   //                     Load|Store,
1844   //                     Load|Load,
1845   //            but not Store|Load
1846   //  - eieio   orders memory accesses for device memory (only)
1847   //  - isync   invalidates speculatively executed instructions
1848   //            From the Power ISA 2.06 documentation:
1849   //             &quot;[...] an isync instruction prevents the execution of
1850   //            instructions following the isync until instructions
1851   //            preceding the isync have completed, [...]&quot;
1852   //            From IBM&#39;s AIX assembler reference:
1853   //             &quot;The isync [...] instructions causes the processor to
1854   //            refetch any instructions that might have been fetched
1855   //            prior to the isync instruction. The instruction isync
1856   //            causes the processor to wait for all previous instructions
1857   //            to complete. Then any instructions already fetched are
1858   //            discarded and instruction processing continues in the
1859   //            environment established by the previous instructions.&quot;
1860   //
1861   //  semantic barrier instructions:
1862   //  (as defined in orderAccess.hpp)
1863   //
1864   //  - release  orders Store|Store,       (maps to lwsync)
1865   //                     Load|Store
1866   //  - acquire  orders  Load|Store,       (maps to lwsync)
1867   //                     Load|Load
1868   //  - fence    orders Store|Store,       (maps to sync)
1869   //                     Load|Store,
1870   //                     Load|Load,
1871   //                    Store|Load
1872   //
1873  private:
1874   inline void sync(int l);
1875  public:
1876   inline void sync();
1877   inline void lwsync();
1878   inline void ptesync();
1879   inline void eieio();
1880   inline void isync();
1881   inline void elemental_membar(int e); // Elemental Memory Barriers (&gt;=Power 8)
1882 
1883   // Wait instructions for polling. Attention: May result in SIGILL.
1884   inline void wait();
1885   inline void waitrsv(); // &gt;=Power7
1886 
1887   // atomics
1888   inline void lbarx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1889   inline void lharx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1890   inline void lwarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1891   inline void ldarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1892   inline void lqarx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1893   inline bool lxarx_hint_exclusive_access();
1894   inline void lbarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1895   inline void lharx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1896   inline void lwarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1897   inline void ldarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1898   inline void lqarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1899   inline void stbcx_( Register s, Register a, Register b);
1900   inline void sthcx_( Register s, Register a, Register b);
1901   inline void stwcx_( Register s, Register a, Register b);
1902   inline void stdcx_( Register s, Register a, Register b);
1903   inline void stqcx_( Register s, Register a, Register b);
1904 
1905   // Instructions for adjusting thread priority for simultaneous
1906   // multithreading (SMT) on Power5.
1907  private:
1908   inline void smt_prio_very_low();
1909   inline void smt_prio_medium_high();
1910   inline void smt_prio_high();
1911 
1912  public:
1913   inline void smt_prio_low();
1914   inline void smt_prio_medium_low();
1915   inline void smt_prio_medium();
1916   // &gt;= Power7
1917   inline void smt_yield();
1918   inline void smt_mdoio();
1919   inline void smt_mdoom();
1920   // &gt;= Power8
1921   inline void smt_miso();
1922 
1923   // trap instructions
1924   inline void twi_0(Register a); // for load with acquire semantics use load+twi_0+isync (trap can&#39;t occur)
1925   // NOT FOR DIRECT USE!!
1926  protected:
1927   inline void tdi_unchecked(int tobits, Register a, int si16);
1928   inline void twi_unchecked(int tobits, Register a, int si16);
1929   inline void tdi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1930   inline void twi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1931   inline void td(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1932   inline void tw(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1933 
1934   static bool is_tdi(int x, int tobits, int ra, int si16) {
1935      return (TDI_OPCODE == (x &amp; TDI_OPCODE_MASK))
1936          &amp;&amp; (tobits == inv_to_field(x))
1937          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1938          &amp;&amp; (si16 == inv_si_field(x));
1939   }
1940 
1941   static bool is_twi(int x, int tobits, int ra, int si16) {
1942      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1943          &amp;&amp; (tobits == inv_to_field(x))
1944          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1945          &amp;&amp; (si16 == inv_si_field(x));
1946   }
1947 
1948   static bool is_twi(int x, int tobits, int ra) {
1949      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1950          &amp;&amp; (tobits == inv_to_field(x))
1951          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x));
1952   }
1953 
1954   static bool is_td(int x, int tobits, int ra, int rb) {
1955      return (TD_OPCODE == (x &amp; TD_OPCODE_MASK))
1956          &amp;&amp; (tobits == inv_to_field(x))
1957          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1958          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1959   }
1960 
1961   static bool is_tw(int x, int tobits, int ra, int rb) {
1962      return (TW_OPCODE == (x &amp; TW_OPCODE_MASK))
1963          &amp;&amp; (tobits == inv_to_field(x))
1964          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1965          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1966   }
1967 
1968  public:
1969   // PPC floating point instructions
1970   // PPC 1, section 4.6.2 Floating-Point Load Instructions
1971   inline void lfs(  FloatRegister d, int si16,   Register a);
1972   inline void lfsu( FloatRegister d, int si16,   Register a);
1973   inline void lfsx( FloatRegister d, Register a, Register b);
1974   inline void lfd(  FloatRegister d, int si16,   Register a);
1975   inline void lfdu( FloatRegister d, int si16,   Register a);
1976   inline void lfdx( FloatRegister d, Register a, Register b);
1977 
1978   // PPC 1, section 4.6.3 Floating-Point Store Instructions
1979   inline void stfs(  FloatRegister s, int si16,   Register a);
1980   inline void stfsu( FloatRegister s, int si16,   Register a);
1981   inline void stfsx( FloatRegister s, Register a, Register b);
1982   inline void stfd(  FloatRegister s, int si16,   Register a);
1983   inline void stfdu( FloatRegister s, int si16,   Register a);
1984   inline void stfdx( FloatRegister s, Register a, Register b);
1985 
1986   // PPC 1, section 4.6.4 Floating-Point Move Instructions
1987   inline void fmr(  FloatRegister d, FloatRegister b);
1988   inline void fmr_( FloatRegister d, FloatRegister b);
1989 
<a name="5" id="anc5"></a><span class="line-added">1990   inline void frin( FloatRegister d, FloatRegister b);</span>
<span class="line-added">1991   inline void frip( FloatRegister d, FloatRegister b);</span>
<span class="line-added">1992   inline void frim( FloatRegister d, FloatRegister b);</span>
<span class="line-added">1993 </span>
1994   //  inline void mffgpr( FloatRegister d, Register b);
1995   //  inline void mftgpr( Register d, FloatRegister b);
1996   inline void cmpb(   Register a, Register s, Register b);
1997   inline void popcntb(Register a, Register s);
1998   inline void popcntw(Register a, Register s);
1999   inline void popcntd(Register a, Register s);
2000 
2001   inline void fneg(  FloatRegister d, FloatRegister b);
2002   inline void fneg_( FloatRegister d, FloatRegister b);
2003   inline void fabs(  FloatRegister d, FloatRegister b);
2004   inline void fabs_( FloatRegister d, FloatRegister b);
2005   inline void fnabs( FloatRegister d, FloatRegister b);
2006   inline void fnabs_(FloatRegister d, FloatRegister b);
2007 
2008   // PPC 1, section 4.6.5.1 Floating-Point Elementary Arithmetic Instructions
2009   inline void fadd(  FloatRegister d, FloatRegister a, FloatRegister b);
2010   inline void fadd_( FloatRegister d, FloatRegister a, FloatRegister b);
2011   inline void fadds( FloatRegister d, FloatRegister a, FloatRegister b);
2012   inline void fadds_(FloatRegister d, FloatRegister a, FloatRegister b);
2013   inline void fsub(  FloatRegister d, FloatRegister a, FloatRegister b);
2014   inline void fsub_( FloatRegister d, FloatRegister a, FloatRegister b);
2015   inline void fsubs( FloatRegister d, FloatRegister a, FloatRegister b);
2016   inline void fsubs_(FloatRegister d, FloatRegister a, FloatRegister b);
2017   inline void fmul(  FloatRegister d, FloatRegister a, FloatRegister c);
2018   inline void fmul_( FloatRegister d, FloatRegister a, FloatRegister c);
2019   inline void fmuls( FloatRegister d, FloatRegister a, FloatRegister c);
2020   inline void fmuls_(FloatRegister d, FloatRegister a, FloatRegister c);
2021   inline void fdiv(  FloatRegister d, FloatRegister a, FloatRegister b);
2022   inline void fdiv_( FloatRegister d, FloatRegister a, FloatRegister b);
2023   inline void fdivs( FloatRegister d, FloatRegister a, FloatRegister b);
2024   inline void fdivs_(FloatRegister d, FloatRegister a, FloatRegister b);
2025 
2026   // Fused multiply-accumulate instructions.
2027   // WARNING: Use only when rounding between the 2 parts is not desired.
2028   // Some floating point tck tests will fail if used incorrectly.
2029   inline void fmadd(   FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2030   inline void fmadd_(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2031   inline void fmadds(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2032   inline void fmadds_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2033   inline void fmsub(   FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2034   inline void fmsub_(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2035   inline void fmsubs(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2036   inline void fmsubs_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2037   inline void fnmadd(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2038   inline void fnmadd_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2039   inline void fnmadds( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2040   inline void fnmadds_(FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2041   inline void fnmsub(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2042   inline void fnmsub_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2043   inline void fnmsubs( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2044   inline void fnmsubs_(FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2045 
2046   // PPC 1, section 4.6.6 Floating-Point Rounding and Conversion Instructions
2047   inline void frsp(  FloatRegister d, FloatRegister b);
2048   inline void fctid( FloatRegister d, FloatRegister b);
2049   inline void fctidz(FloatRegister d, FloatRegister b);
2050   inline void fctiw( FloatRegister d, FloatRegister b);
2051   inline void fctiwz(FloatRegister d, FloatRegister b);
2052   inline void fcfid( FloatRegister d, FloatRegister b);
2053   inline void fcfids(FloatRegister d, FloatRegister b);
2054 
2055   // PPC 1, section 4.6.7 Floating-Point Compare Instructions
2056   inline void fcmpu( ConditionRegister crx, FloatRegister a, FloatRegister b);
2057 
2058   inline void fsqrt( FloatRegister d, FloatRegister b);
2059   inline void fsqrts(FloatRegister d, FloatRegister b);
2060 
2061   // Vector instructions for &gt;= Power6.
2062   inline void lvebx(    VectorRegister d, Register s1, Register s2);
2063   inline void lvehx(    VectorRegister d, Register s1, Register s2);
2064   inline void lvewx(    VectorRegister d, Register s1, Register s2);
2065   inline void lvx(      VectorRegister d, Register s1, Register s2);
2066   inline void lvxl(     VectorRegister d, Register s1, Register s2);
2067   inline void stvebx(   VectorRegister d, Register s1, Register s2);
2068   inline void stvehx(   VectorRegister d, Register s1, Register s2);
2069   inline void stvewx(   VectorRegister d, Register s1, Register s2);
2070   inline void stvx(     VectorRegister d, Register s1, Register s2);
2071   inline void stvxl(    VectorRegister d, Register s1, Register s2);
2072   inline void lvsl(     VectorRegister d, Register s1, Register s2);
2073   inline void lvsr(     VectorRegister d, Register s1, Register s2);
2074   inline void vpkpx(    VectorRegister d, VectorRegister a, VectorRegister b);
2075   inline void vpkshss(  VectorRegister d, VectorRegister a, VectorRegister b);
2076   inline void vpkswss(  VectorRegister d, VectorRegister a, VectorRegister b);
2077   inline void vpkshus(  VectorRegister d, VectorRegister a, VectorRegister b);
2078   inline void vpkswus(  VectorRegister d, VectorRegister a, VectorRegister b);
2079   inline void vpkuhum(  VectorRegister d, VectorRegister a, VectorRegister b);
2080   inline void vpkuwum(  VectorRegister d, VectorRegister a, VectorRegister b);
2081   inline void vpkuhus(  VectorRegister d, VectorRegister a, VectorRegister b);
2082   inline void vpkuwus(  VectorRegister d, VectorRegister a, VectorRegister b);
2083   inline void vupkhpx(  VectorRegister d, VectorRegister b);
2084   inline void vupkhsb(  VectorRegister d, VectorRegister b);
2085   inline void vupkhsh(  VectorRegister d, VectorRegister b);
2086   inline void vupklpx(  VectorRegister d, VectorRegister b);
2087   inline void vupklsb(  VectorRegister d, VectorRegister b);
2088   inline void vupklsh(  VectorRegister d, VectorRegister b);
2089   inline void vmrghb(   VectorRegister d, VectorRegister a, VectorRegister b);
2090   inline void vmrghw(   VectorRegister d, VectorRegister a, VectorRegister b);
2091   inline void vmrghh(   VectorRegister d, VectorRegister a, VectorRegister b);
2092   inline void vmrglb(   VectorRegister d, VectorRegister a, VectorRegister b);
2093   inline void vmrglw(   VectorRegister d, VectorRegister a, VectorRegister b);
2094   inline void vmrglh(   VectorRegister d, VectorRegister a, VectorRegister b);
2095   inline void vsplt(    VectorRegister d, int ui4,          VectorRegister b);
2096   inline void vsplth(   VectorRegister d, int ui3,          VectorRegister b);
2097   inline void vspltw(   VectorRegister d, int ui2,          VectorRegister b);
2098   inline void vspltisb( VectorRegister d, int si5);
2099   inline void vspltish( VectorRegister d, int si5);
2100   inline void vspltisw( VectorRegister d, int si5);
2101   inline void vperm(    VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2102   inline void vsel(     VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2103   inline void vsl(      VectorRegister d, VectorRegister a, VectorRegister b);
2104   inline void vsldoi(   VectorRegister d, VectorRegister a, VectorRegister b, int ui4);
2105   inline void vslo(     VectorRegister d, VectorRegister a, VectorRegister b);
2106   inline void vsr(      VectorRegister d, VectorRegister a, VectorRegister b);
2107   inline void vsro(     VectorRegister d, VectorRegister a, VectorRegister b);
2108   inline void vaddcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
2109   inline void vaddshs(  VectorRegister d, VectorRegister a, VectorRegister b);
2110   inline void vaddsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
2111   inline void vaddsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2112   inline void vaddubm(  VectorRegister d, VectorRegister a, VectorRegister b);
2113   inline void vadduwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2114   inline void vadduhm(  VectorRegister d, VectorRegister a, VectorRegister b);
2115   inline void vaddudm(  VectorRegister d, VectorRegister a, VectorRegister b);
2116   inline void vaddubs(  VectorRegister d, VectorRegister a, VectorRegister b);
2117   inline void vadduws(  VectorRegister d, VectorRegister a, VectorRegister b);
2118   inline void vadduhs(  VectorRegister d, VectorRegister a, VectorRegister b);
2119   inline void vaddfp(   VectorRegister d, VectorRegister a, VectorRegister b);
2120   inline void vsubcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
2121   inline void vsubshs(  VectorRegister d, VectorRegister a, VectorRegister b);
2122   inline void vsubsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
2123   inline void vsubsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2124   inline void vsububm(  VectorRegister d, VectorRegister a, VectorRegister b);
2125   inline void vsubuwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2126   inline void vsubuhm(  VectorRegister d, VectorRegister a, VectorRegister b);
2127   inline void vsubudm(  VectorRegister d, VectorRegister a, VectorRegister b);
2128   inline void vsububs(  VectorRegister d, VectorRegister a, VectorRegister b);
2129   inline void vsubuws(  VectorRegister d, VectorRegister a, VectorRegister b);
2130   inline void vsubuhs(  VectorRegister d, VectorRegister a, VectorRegister b);
2131   inline void vsubfp(   VectorRegister d, VectorRegister a, VectorRegister b);
2132   inline void vmulesb(  VectorRegister d, VectorRegister a, VectorRegister b);
2133   inline void vmuleub(  VectorRegister d, VectorRegister a, VectorRegister b);
2134   inline void vmulesh(  VectorRegister d, VectorRegister a, VectorRegister b);
2135   inline void vmuleuh(  VectorRegister d, VectorRegister a, VectorRegister b);
2136   inline void vmulosb(  VectorRegister d, VectorRegister a, VectorRegister b);
2137   inline void vmuloub(  VectorRegister d, VectorRegister a, VectorRegister b);
2138   inline void vmulosh(  VectorRegister d, VectorRegister a, VectorRegister b);
2139   inline void vmulosw(  VectorRegister d, VectorRegister a, VectorRegister b);
2140   inline void vmulouh(  VectorRegister d, VectorRegister a, VectorRegister b);
2141   inline void vmuluwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2142   inline void vmhaddshs(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2143   inline void vmhraddshs(VectorRegister d,VectorRegister a, VectorRegister b, VectorRegister c);
2144   inline void vmladduhm(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2145   inline void vmsubuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2146   inline void vmsummbm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2147   inline void vmsumshm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2148   inline void vmsumshs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2149   inline void vmsumuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2150   inline void vmsumuhs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2151   inline void vmaddfp(  VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2152   inline void vsumsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2153   inline void vsum2sws( VectorRegister d, VectorRegister a, VectorRegister b);
2154   inline void vsum4sbs( VectorRegister d, VectorRegister a, VectorRegister b);
2155   inline void vsum4ubs( VectorRegister d, VectorRegister a, VectorRegister b);
2156   inline void vsum4shs( VectorRegister d, VectorRegister a, VectorRegister b);
2157   inline void vavgsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2158   inline void vavgsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2159   inline void vavgsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2160   inline void vavgub(   VectorRegister d, VectorRegister a, VectorRegister b);
2161   inline void vavguw(   VectorRegister d, VectorRegister a, VectorRegister b);
2162   inline void vavguh(   VectorRegister d, VectorRegister a, VectorRegister b);
2163   inline void vmaxsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2164   inline void vmaxsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2165   inline void vmaxsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2166   inline void vmaxub(   VectorRegister d, VectorRegister a, VectorRegister b);
2167   inline void vmaxuw(   VectorRegister d, VectorRegister a, VectorRegister b);
2168   inline void vmaxuh(   VectorRegister d, VectorRegister a, VectorRegister b);
2169   inline void vminsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2170   inline void vminsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2171   inline void vminsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2172   inline void vminub(   VectorRegister d, VectorRegister a, VectorRegister b);
2173   inline void vminuw(   VectorRegister d, VectorRegister a, VectorRegister b);
2174   inline void vminuh(   VectorRegister d, VectorRegister a, VectorRegister b);
2175   inline void vcmpequb( VectorRegister d, VectorRegister a, VectorRegister b);
2176   inline void vcmpequh( VectorRegister d, VectorRegister a, VectorRegister b);
2177   inline void vcmpequw( VectorRegister d, VectorRegister a, VectorRegister b);
2178   inline void vcmpgtsh( VectorRegister d, VectorRegister a, VectorRegister b);
2179   inline void vcmpgtsb( VectorRegister d, VectorRegister a, VectorRegister b);
2180   inline void vcmpgtsw( VectorRegister d, VectorRegister a, VectorRegister b);
2181   inline void vcmpgtub( VectorRegister d, VectorRegister a, VectorRegister b);
2182   inline void vcmpgtuh( VectorRegister d, VectorRegister a, VectorRegister b);
2183   inline void vcmpgtuw( VectorRegister d, VectorRegister a, VectorRegister b);
2184   inline void vcmpequb_(VectorRegister d, VectorRegister a, VectorRegister b);
2185   inline void vcmpequh_(VectorRegister d, VectorRegister a, VectorRegister b);
2186   inline void vcmpequw_(VectorRegister d, VectorRegister a, VectorRegister b);
2187   inline void vcmpgtsh_(VectorRegister d, VectorRegister a, VectorRegister b);
2188   inline void vcmpgtsb_(VectorRegister d, VectorRegister a, VectorRegister b);
2189   inline void vcmpgtsw_(VectorRegister d, VectorRegister a, VectorRegister b);
2190   inline void vcmpgtub_(VectorRegister d, VectorRegister a, VectorRegister b);
2191   inline void vcmpgtuh_(VectorRegister d, VectorRegister a, VectorRegister b);
2192   inline void vcmpgtuw_(VectorRegister d, VectorRegister a, VectorRegister b);
2193   inline void vand(     VectorRegister d, VectorRegister a, VectorRegister b);
2194   inline void vandc(    VectorRegister d, VectorRegister a, VectorRegister b);
2195   inline void vnor(     VectorRegister d, VectorRegister a, VectorRegister b);
2196   inline void vor(      VectorRegister d, VectorRegister a, VectorRegister b);
2197   inline void vmr(      VectorRegister d, VectorRegister a);
2198   inline void vxor(     VectorRegister d, VectorRegister a, VectorRegister b);
2199   inline void vrld(     VectorRegister d, VectorRegister a, VectorRegister b);
2200   inline void vrlb(     VectorRegister d, VectorRegister a, VectorRegister b);
2201   inline void vrlw(     VectorRegister d, VectorRegister a, VectorRegister b);
2202   inline void vrlh(     VectorRegister d, VectorRegister a, VectorRegister b);
2203   inline void vslb(     VectorRegister d, VectorRegister a, VectorRegister b);
2204   inline void vskw(     VectorRegister d, VectorRegister a, VectorRegister b);
2205   inline void vslh(     VectorRegister d, VectorRegister a, VectorRegister b);
2206   inline void vsrb(     VectorRegister d, VectorRegister a, VectorRegister b);
2207   inline void vsrw(     VectorRegister d, VectorRegister a, VectorRegister b);
2208   inline void vsrh(     VectorRegister d, VectorRegister a, VectorRegister b);
2209   inline void vsrab(    VectorRegister d, VectorRegister a, VectorRegister b);
2210   inline void vsraw(    VectorRegister d, VectorRegister a, VectorRegister b);
2211   inline void vsrah(    VectorRegister d, VectorRegister a, VectorRegister b);
2212   inline void vpopcntw( VectorRegister d, VectorRegister b);
2213   // Vector Floating-Point not implemented yet
2214   inline void mtvscr(   VectorRegister b);
2215   inline void mfvscr(   VectorRegister d);
2216 
2217   // Vector-Scalar (VSX) instructions.
2218   inline void lxvd2x(   VectorSRegister d, Register a);
2219   inline void lxvd2x(   VectorSRegister d, Register a, Register b);
2220   inline void stxvd2x(  VectorSRegister d, Register a);
2221   inline void stxvd2x(  VectorSRegister d, Register a, Register b);
2222   inline void mtvrwz(   VectorRegister  d, Register a);
2223   inline void mfvrwz(   Register        a, VectorRegister d);
2224   inline void mtvrd(    VectorRegister  d, Register a);
2225   inline void mfvrd(    Register        a, VectorRegister d);
2226   inline void xxpermdi( VectorSRegister d, VectorSRegister a, VectorSRegister b, int dm);
2227   inline void xxmrghw(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2228   inline void xxmrglw(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2229   inline void mtvsrd(   VectorSRegister d, Register a);
2230   inline void mtvsrwz(  VectorSRegister d, Register a);
2231   inline void xxspltw(  VectorSRegister d, VectorSRegister b, int ui2);
2232   inline void xxlor(    VectorSRegister d, VectorSRegister a, VectorSRegister b);
2233   inline void xxlxor(   VectorSRegister d, VectorSRegister a, VectorSRegister b);
2234   inline void xxleqv(   VectorSRegister d, VectorSRegister a, VectorSRegister b);
2235   inline void xvdivsp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2236   inline void xvdivdp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2237   inline void xvabssp(  VectorSRegister d, VectorSRegister b);
2238   inline void xvabsdp(  VectorSRegister d, VectorSRegister b);
2239   inline void xvnegsp(  VectorSRegister d, VectorSRegister b);
2240   inline void xvnegdp(  VectorSRegister d, VectorSRegister b);
2241   inline void xvsqrtsp( VectorSRegister d, VectorSRegister b);
2242   inline void xvsqrtdp( VectorSRegister d, VectorSRegister b);
2243   inline void xscvdpspn(VectorSRegister d, VectorSRegister b);
2244   inline void xvadddp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2245   inline void xvsubdp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2246   inline void xvmulsp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2247   inline void xvmuldp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2248   inline void xvmaddasp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2249   inline void xvmaddadp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2250   inline void xvmsubasp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2251   inline void xvmsubadp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2252   inline void xvnmsubasp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2253   inline void xvnmsubadp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
<a name="6" id="anc6"></a><span class="line-added">2254   inline void xvrdpi(   VectorSRegister d, VectorSRegister b);</span>
<span class="line-added">2255   inline void xvrdpim(  VectorSRegister d, VectorSRegister b);</span>
<span class="line-added">2256   inline void xvrdpip(  VectorSRegister d, VectorSRegister b);</span>
2257 
2258   // VSX Extended Mnemonics
2259   inline void xxspltd(  VectorSRegister d, VectorSRegister a, int x);
2260   inline void xxmrghd(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2261   inline void xxmrgld(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2262   inline void xxswapd(  VectorSRegister d, VectorSRegister a);
2263 
2264   // Vector-Scalar (VSX) instructions.
2265   inline void mtfprd(   FloatRegister   d, Register a);
2266   inline void mtfprwa(  FloatRegister   d, Register a);
2267   inline void mffprd(   Register        a, FloatRegister d);
2268 
2269   // Deliver A Random Number (introduced with POWER9)
2270   inline void darn( Register d, int l = 1 /*L=CRN*/);
2271 
2272   // AES (introduced with Power 8)
2273   inline void vcipher(     VectorRegister d, VectorRegister a, VectorRegister b);
2274   inline void vcipherlast( VectorRegister d, VectorRegister a, VectorRegister b);
2275   inline void vncipher(    VectorRegister d, VectorRegister a, VectorRegister b);
2276   inline void vncipherlast(VectorRegister d, VectorRegister a, VectorRegister b);
2277   inline void vsbox(       VectorRegister d, VectorRegister a);
2278 
2279   // SHA (introduced with Power 8)
2280   inline void vshasigmad(VectorRegister d, VectorRegister a, bool st, int six);
2281   inline void vshasigmaw(VectorRegister d, VectorRegister a, bool st, int six);
2282 
2283   // Vector Binary Polynomial Multiplication (introduced with Power 8)
2284   inline void vpmsumb(  VectorRegister d, VectorRegister a, VectorRegister b);
2285   inline void vpmsumd(  VectorRegister d, VectorRegister a, VectorRegister b);
2286   inline void vpmsumh(  VectorRegister d, VectorRegister a, VectorRegister b);
2287   inline void vpmsumw(  VectorRegister d, VectorRegister a, VectorRegister b);
2288 
2289   // Vector Permute and Xor (introduced with Power 8)
2290   inline void vpermxor( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2291 
2292   // Transactional Memory instructions (introduced with Power 8)
2293   inline void tbegin_();    // R=0
2294   inline void tbeginrot_(); // R=1 Rollback-Only Transaction
2295   inline void tend_();    // A=0
2296   inline void tendall_(); // A=1
2297   inline void tabort_();
2298   inline void tabort_(Register a);
2299   inline void tabortwc_(int t, Register a, Register b);
2300   inline void tabortwci_(int t, Register a, int si);
2301   inline void tabortdc_(int t, Register a, Register b);
2302   inline void tabortdci_(int t, Register a, int si);
2303   inline void tsuspend_(); // tsr with L=0
2304   inline void tresume_();  // tsr with L=1
2305   inline void tcheck(int f);
2306 
2307   static bool is_tbegin(int x) {
2308     return TBEGIN_OPCODE == (x &amp; (0x3f &lt;&lt; OPCODE_SHIFT | 0x3ff &lt;&lt; 1));
2309   }
2310 
2311   // The following encoders use r0 as second operand. These instructions
2312   // read r0 as &#39;0&#39;.
2313   inline void lwzx( Register d, Register s2);
2314   inline void lwz(  Register d, int si16);
2315   inline void lwax( Register d, Register s2);
2316   inline void lwa(  Register d, int si16);
2317   inline void lwbrx(Register d, Register s2);
2318   inline void lhzx( Register d, Register s2);
2319   inline void lhz(  Register d, int si16);
2320   inline void lhax( Register d, Register s2);
2321   inline void lha(  Register d, int si16);
2322   inline void lhbrx(Register d, Register s2);
2323   inline void lbzx( Register d, Register s2);
2324   inline void lbz(  Register d, int si16);
2325   inline void ldx(  Register d, Register s2);
2326   inline void ld(   Register d, int si16);
2327   inline void ldbrx(Register d, Register s2);
2328   inline void stwx( Register d, Register s2);
2329   inline void stw(  Register d, int si16);
2330   inline void stwbrx( Register d, Register s2);
2331   inline void sthx( Register d, Register s2);
2332   inline void sth(  Register d, int si16);
2333   inline void sthbrx( Register d, Register s2);
2334   inline void stbx( Register d, Register s2);
2335   inline void stb(  Register d, int si16);
2336   inline void stdx( Register d, Register s2);
2337   inline void std(  Register d, int si16);
2338   inline void stdbrx( Register d, Register s2);
2339 
2340   // PPC 2, section 3.2.1 Instruction Cache Instructions
2341   inline void icbi(    Register s2);
2342   // PPC 2, section 3.2.2 Data Cache Instructions
2343   //inlinevoid dcba(   Register s2); // Instruction for embedded processor only.
2344   inline void dcbz(    Register s2);
2345   inline void dcbst(   Register s2);
2346   inline void dcbf(    Register s2);
2347   // dcache read hint
2348   inline void dcbt(    Register s2);
2349   inline void dcbtct(  Register s2, int ct);
2350   inline void dcbtds(  Register s2, int ds);
2351   // dcache write hint
2352   inline void dcbtst(  Register s2);
2353   inline void dcbtstct(Register s2, int ct);
2354 
2355   // Atomics: use ra0mem to disallow R0 as base.
2356   inline void lbarx_unchecked(Register d, Register b, int eh1);
2357   inline void lharx_unchecked(Register d, Register b, int eh1);
2358   inline void lwarx_unchecked(Register d, Register b, int eh1);
2359   inline void ldarx_unchecked(Register d, Register b, int eh1);
2360   inline void lqarx_unchecked(Register d, Register b, int eh1);
2361   inline void lbarx( Register d, Register b, bool hint_exclusive_access);
2362   inline void lharx( Register d, Register b, bool hint_exclusive_access);
2363   inline void lwarx( Register d, Register b, bool hint_exclusive_access);
2364   inline void ldarx( Register d, Register b, bool hint_exclusive_access);
2365   inline void lqarx( Register d, Register b, bool hint_exclusive_access);
2366   inline void stbcx_(Register s, Register b);
2367   inline void sthcx_(Register s, Register b);
2368   inline void stwcx_(Register s, Register b);
2369   inline void stdcx_(Register s, Register b);
2370   inline void stqcx_(Register s, Register b);
2371   inline void lfs(   FloatRegister d, int si16);
2372   inline void lfsx(  FloatRegister d, Register b);
2373   inline void lfd(   FloatRegister d, int si16);
2374   inline void lfdx(  FloatRegister d, Register b);
2375   inline void stfs(  FloatRegister s, int si16);
2376   inline void stfsx( FloatRegister s, Register b);
2377   inline void stfd(  FloatRegister s, int si16);
2378   inline void stfdx( FloatRegister s, Register b);
2379   inline void lvebx( VectorRegister d, Register s2);
2380   inline void lvehx( VectorRegister d, Register s2);
2381   inline void lvewx( VectorRegister d, Register s2);
2382   inline void lvx(   VectorRegister d, Register s2);
2383   inline void lvxl(  VectorRegister d, Register s2);
2384   inline void stvebx(VectorRegister d, Register s2);
2385   inline void stvehx(VectorRegister d, Register s2);
2386   inline void stvewx(VectorRegister d, Register s2);
2387   inline void stvx(  VectorRegister d, Register s2);
2388   inline void stvxl( VectorRegister d, Register s2);
2389   inline void lvsl(  VectorRegister d, Register s2);
2390   inline void lvsr(  VectorRegister d, Register s2);
2391 
2392   // Endianess specific concatenation of 2 loaded vectors.
2393   inline void load_perm(VectorRegister perm, Register addr);
2394   inline void vec_perm(VectorRegister first_dest, VectorRegister second, VectorRegister perm);
2395   inline void vec_perm(VectorRegister dest, VectorRegister first, VectorRegister second, VectorRegister perm);
2396 
2397   // RegisterOrConstant versions.
2398   // These emitters choose between the versions using two registers and
2399   // those with register and immediate, depending on the content of roc.
2400   // If the constant is not encodable as immediate, instructions to
2401   // load the constant are emitted beforehand. Store instructions need a
2402   // tmp reg if the constant is not encodable as immediate.
2403   // Size unpredictable.
2404   void ld(  Register d, RegisterOrConstant roc, Register s1 = noreg);
2405   void lwa( Register d, RegisterOrConstant roc, Register s1 = noreg);
2406   void lwz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2407   void lha( Register d, RegisterOrConstant roc, Register s1 = noreg);
2408   void lhz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2409   void lbz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2410   void std( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2411   void stw( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2412   void sth( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2413   void stb( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2414   void add( Register d, RegisterOrConstant roc, Register s1);
2415   void subf(Register d, RegisterOrConstant roc, Register s1);
2416   void cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1);
2417   // Load pointer d from s1+roc.
2418   void ld_ptr(Register d, RegisterOrConstant roc, Register s1 = noreg) { ld(d, roc, s1); }
2419 
2420   // Emit several instructions to load a 64 bit constant. This issues a fixed
2421   // instruction pattern so that the constant can be patched later on.
2422   enum {
2423     load_const_size = 5 * BytesPerInstWord
2424   };
2425          void load_const(Register d, long a,            Register tmp = noreg);
2426   inline void load_const(Register d, void* a,           Register tmp = noreg);
2427   inline void load_const(Register d, Label&amp; L,          Register tmp = noreg);
2428   inline void load_const(Register d, AddressLiteral&amp; a, Register tmp = noreg);
2429   inline void load_const32(Register d, int i); // load signed int (patchable)
2430 
2431   // Load a 64 bit constant, optimized, not identifyable.
2432   // Tmp can be used to increase ILP. Set return_simm16_rest = true to get a
2433   // 16 bit immediate offset. This is useful if the offset can be encoded in
2434   // a succeeding instruction.
2435          int load_const_optimized(Register d, long a,  Register tmp = noreg, bool return_simm16_rest = false);
2436   inline int load_const_optimized(Register d, void* a, Register tmp = noreg, bool return_simm16_rest = false) {
2437     return load_const_optimized(d, (long)(unsigned long)a, tmp, return_simm16_rest);
2438   }
2439 
2440   // If return_simm16_rest, the return value needs to get added afterwards.
2441          int add_const_optimized(Register d, Register s, long x, Register tmp = R0, bool return_simm16_rest = false);
2442   inline int add_const_optimized(Register d, Register s, void* a, Register tmp = R0, bool return_simm16_rest = false) {
2443     return add_const_optimized(d, s, (long)(unsigned long)a, tmp, return_simm16_rest);
2444   }
2445 
2446   // If return_simm16_rest, the return value needs to get added afterwards.
2447   inline int sub_const_optimized(Register d, Register s, long x, Register tmp = R0, bool return_simm16_rest = false) {
2448     return add_const_optimized(d, s, -x, tmp, return_simm16_rest);
2449   }
2450   inline int sub_const_optimized(Register d, Register s, void* a, Register tmp = R0, bool return_simm16_rest = false) {
2451     return sub_const_optimized(d, s, (long)(unsigned long)a, tmp, return_simm16_rest);
2452   }
2453 
2454   // Creation
2455   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
2456 #ifdef CHECK_DELAY
2457     delay_state = no_delay;
2458 #endif
2459   }
2460 
2461   // Testing
2462 #ifndef PRODUCT
2463   void test_asm();
2464 #endif
2465 };
2466 
2467 
2468 #endif // CPU_PPC_ASSEMBLER_PPC_HPP
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
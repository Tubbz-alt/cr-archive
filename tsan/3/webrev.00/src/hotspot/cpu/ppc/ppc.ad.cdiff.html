<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/ppc/ppc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nativeInst_ppc.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="relocInfo_ppc.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/ppc.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  //
<span class="line-modified">! // Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">! // Copyright (c) 2012, 2018 SAP SE. All rights reserved.</span>
  // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  //
  // This code is free software; you can redistribute it and/or modify it
  // under the terms of the GNU General Public License version 2 only, as
  // published by the Free Software Foundation.
<span class="line-new-header">--- 1,8 ---</span>
  //
<span class="line-modified">! // Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">! // Copyright (c) 2012, 2019 SAP SE. All rights reserved.</span>
  // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  //
  // This code is free software; you can redistribute it and/or modify it
  // under the terms of the GNU General Public License version 2 only, as
  // published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 970,10 ***</span>
<span class="line-new-header">--- 970,12 ---</span>
    // the ad-scope can conveniently be defined here.
    //
    // To keep related declarations/definitions/uses close together,
    // we switch between source %{ }% and source_hpp %{ }% freely as needed.
  
<span class="line-added">+ #include &quot;opto/convertnode.hpp&quot;</span>
<span class="line-added">+ </span>
    // Returns true if Node n is followed by a MemBar node that
    // will do an acquire. If so, this node must not do the acquire
    // operation.
    bool followed_by_acquire(const Node *n);
  %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1398,10 ***</span>
<span class="line-new-header">--- 1400,28 ---</span>
    } else {
      // Get return pc.
      ___(mflr) mflr(return_pc);
    }
  
<span class="line-added">+   if (C-&gt;clinit_barrier_on_entry()) {</span>
<span class="line-added">+     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Label L_skip_barrier;</span>
<span class="line-added">+     Register klass = toc_temp;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Notify OOP recorder (don&#39;t need the relocation)</span>
<span class="line-added">+     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());</span>
<span class="line-added">+     __ load_const_optimized(klass, md.value(), R0);</span>
<span class="line-added">+     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);</span>
<span class="line-added">+     __ mtctr(klass);</span>
<span class="line-added">+     __ bctr();</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ bind(L_skip_barrier);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them. But be
    // careful, because some VM calls (such as call site linkage) can
    // use several kilobytes of stack. But the stack safety zone should
    // account for that. See bugs 4446381, 4468289, 4497237.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2202,10 ***</span>
<span class="line-new-header">--- 2222,11 ---</span>
  
  const bool Matcher::match_rule_supported(int opcode) {
    if (!has_match_rule(opcode))
      return false;
  
<span class="line-added">+   bool ret_value = true;</span>
    switch (opcode) {
    case Op_SqrtD:
      return VM_Version::has_fsqrt();
    case Op_CountLeadingZerosI:
    case Op_CountLeadingZerosL:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2252,10 ***</span>
<span class="line-new-header">--- 2273,11 ---</span>
    case Op_SqrtVF:
    case Op_SqrtVD:
    case Op_AddVL:
    case Op_SubVL:
    case Op_MulVI:
<span class="line-added">+   case Op_RoundDoubleModeV:</span>
      return SuperwordUseVSX;
    case Op_PopCountVI:
      return (SuperwordUseVSX &amp;&amp; UsePopCountInstruction);
    case Op_FmaVF:
    case Op_FmaVD:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2263,16 ***</span>
    case Op_Digit:
    case Op_LowerCase:
    case Op_UpperCase:
    case Op_Whitespace:
      return UseCharacterCompareIntrinsics;
    }
  
<span class="line-modified">!   return true;  // Per default match rules are supported.</span>
  }
  
<span class="line-modified">! const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {</span>
  
    // TODO
    // identify extra cases that we might want to provide match rules for
    // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
    bool ret_value = match_rule_supported(opcode);
<span class="line-new-header">--- 2285,24 ---</span>
    case Op_Digit:
    case Op_LowerCase:
    case Op_UpperCase:
    case Op_Whitespace:
      return UseCharacterCompareIntrinsics;
<span class="line-added">+ </span>
<span class="line-added">+   case Op_CacheWB:</span>
<span class="line-added">+   case Op_CacheWBPreSync:</span>
<span class="line-added">+   case Op_CacheWBPostSync:</span>
<span class="line-added">+     if (!VM_Version::supports_data_cache_line_flush()) {</span>
<span class="line-added">+       ret_value = false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     break;</span>
    }
  
<span class="line-modified">!   return ret_value;  // Per default match rules are supported.</span>
  }
  
<span class="line-modified">! const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {</span>
  
    // TODO
    // identify extra cases that we might want to provide match rules for
    // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
    bool ret_value = match_rule_supported(opcode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2376,11 ***</span>
    return true;
  }
  /* TODO: PPC port
  // Make a new machine dependent decode node (with its operands).
  MachTypeNode *Matcher::make_decode_node() {
<span class="line-modified">!   assert(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0,</span>
           &quot;This method is only implemented for unscaled cOops mode so far&quot;);
    MachTypeNode *decode = new decodeN_unscaledNode();
    decode-&gt;set_opnd_array(0, new iRegPdstOper());
    decode-&gt;set_opnd_array(1, new iRegNsrcOper());
    return decode;
<span class="line-new-header">--- 2406,11 ---</span>
    return true;
  }
  /* TODO: PPC port
  // Make a new machine dependent decode node (with its operands).
  MachTypeNode *Matcher::make_decode_node() {
<span class="line-modified">!   assert(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0,</span>
           &quot;This method is only implemented for unscaled cOops mode so far&quot;);
    MachTypeNode *decode = new decodeN_unscaledNode();
    decode-&gt;set_opnd_array(0, new iRegPdstOper());
    decode-&gt;set_opnd_array(1, new iRegNsrcOper());
    return decode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2403,10 ***</span>
<span class="line-new-header">--- 2433,28 ---</span>
  // Do we need to mask the count passed to shift instructions or does
  // the cpu only look at the lower 5/6 bits anyway?
  // PowerPC requires masked shift counts.
  const bool Matcher::need_masked_shift_count = true;
  
<span class="line-added">+ // No support for generic vector operands.</span>
<span class="line-added">+ const bool Matcher::supports_generic_vector_operands  = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+ MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {</span>
<span class="line-added">+   ShouldNotReachHere(); // generic vector operands not supported</span>
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Matcher::is_generic_reg2reg_move(MachNode* m) {</span>
<span class="line-added">+   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Matcher::is_generic_vector(MachOper* opnd)  {</span>
<span class="line-added">+   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // This affects two different things:
  //  - how Decode nodes are matched
  //  - how ImplicitNullCheck opportunities are recognized
  // If true, the matcher will try to remove all Decodes and match them
  // (as operands) into nodes. NullChecks are not prepared to deal with
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2427,16 ***</span>
    return false;
  }
  
  bool Matcher::const_oop_prefer_decode() {
    // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="line-modified">!   return Universe::narrow_oop_base() == NULL;</span>
  }
  
  bool Matcher::const_klass_prefer_decode() {
    // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified">!   return Universe::narrow_klass_base() == NULL;</span>
  }
  
  // Is it better to copy float constants, or load them directly from memory?
  // Intel can load a float constant from a direct address, requiring no
  // extra registers. Most RISCs will have to materialize an address into a
<span class="line-new-header">--- 2475,16 ---</span>
    return false;
  }
  
  bool Matcher::const_oop_prefer_decode() {
    // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="line-modified">!   return CompressedOops::base() == NULL;</span>
  }
  
  bool Matcher::const_klass_prefer_decode() {
    // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified">!   return CompressedKlassPointers::base() == NULL;</span>
  }
  
  // Is it better to copy float constants, or load them directly from memory?
  // Intel can load a float constant from a direct address, requiring no
  // extra registers. Most RISCs will have to materialize an address into a
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2451,12 ***</span>
  
  void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
   Unimplemented();
  }
  
<span class="line-modified">! // Advertise here if the CPU requires explicit rounding operations</span>
<span class="line-removed">- // to implement the UseStrictFP mode.</span>
  const bool Matcher::strict_fp_requires_explicit_rounding = false;
  
  // Do floats take an entire double register or just half?
  //
  // A float occupies a ppc64 double register. For the allocator, a
<span class="line-new-header">--- 2499,11 ---</span>
  
  void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
   Unimplemented();
  }
  
<span class="line-modified">! // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>
  const bool Matcher::strict_fp_requires_explicit_rounding = false;
  
  // Do floats take an entire double register or just half?
  //
  // A float occupies a ppc64 double register. For the allocator, a
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4149,22 ***</span>
    // returned to the interpreter in I0:I1. The copying to and from
    // the register pairs is done by the appropriate call and epilog
    // opcodes. This simplifies the register allocator.
    c_return_value %{
      assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
<span class="line-modified">!             (ideal_reg == Op_RegN &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0),</span>
              &quot;only return normal values&quot;);
      // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
      static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
      static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
      return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
    %}
  
    // Location of compiled Java return values.  Same as C
    return_value %{
      assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
<span class="line-modified">!             (ideal_reg == Op_RegN &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0),</span>
              &quot;only return normal values&quot;);
      // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
      static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
      static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
      return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
<span class="line-new-header">--- 4196,22 ---</span>
    // returned to the interpreter in I0:I1. The copying to and from
    // the register pairs is done by the appropriate call and epilog
    // opcodes. This simplifies the register allocator.
    c_return_value %{
      assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
<span class="line-modified">!             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),</span>
              &quot;only return normal values&quot;);
      // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
      static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
      static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
      return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
    %}
  
    // Location of compiled Java return values.  Same as C
    return_value %{
      assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
<span class="line-modified">!             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),</span>
              &quot;only return normal values&quot;);
      // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
      static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
      static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
      return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4301,27 ***</span>
    format %{ %}
    interface(CONST_INTER);
  %}
  
  operand immInegpow2() %{
<span class="line-modified">!   predicate(is_power_of_2_long((jlong) (julong) (juint) (-(n-&gt;get_int()))));</span>
    match(ConI);
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
  %}
  
  operand immIpow2minus1() %{
<span class="line-modified">!   predicate(is_power_of_2_long((((jlong) (n-&gt;get_int()))+1)));</span>
    match(ConI);
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
  %}
  
  operand immIpowerOf2() %{
<span class="line-modified">!   predicate(is_power_of_2_long((((jlong) (julong) (juint) (n-&gt;get_int())))));</span>
    match(ConI);
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
  %}
<span class="line-new-header">--- 4348,27 ---</span>
    format %{ %}
    interface(CONST_INTER);
  %}
  
  operand immInegpow2() %{
<span class="line-modified">!   predicate(is_power_of_2((jlong) (julong) (juint) (-(n-&gt;get_int()))));</span>
    match(ConI);
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
  %}
  
  operand immIpow2minus1() %{
<span class="line-modified">!   predicate(is_power_of_2((((jlong) (n-&gt;get_int()))+1)));</span>
    match(ConI);
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
  %}
  
  operand immIpowerOf2() %{
<span class="line-modified">!   predicate(is_power_of_2((((jlong) (julong) (juint) (n-&gt;get_int())))));</span>
    match(ConI);
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
  %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4551,19 ***</span>
    format %{ %}
    interface(CONST_INTER);
  %}
  
  operand immLnegpow2() %{
<span class="line-modified">!   predicate(is_power_of_2_long((jlong)-(n-&gt;get_long())));</span>
    match(ConL);
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
  %}
  
  operand immLpow2minus1() %{
<span class="line-modified">!   predicate(is_power_of_2_long((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;</span>
              (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
    match(ConL);
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
<span class="line-new-header">--- 4598,19 ---</span>
    format %{ %}
    interface(CONST_INTER);
  %}
  
  operand immLnegpow2() %{
<span class="line-modified">!   predicate(is_power_of_2((jlong)-(n-&gt;get_long())));</span>
    match(ConL);
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
  %}
  
  operand immLpow2minus1() %{
<span class="line-modified">!   predicate(is_power_of_2((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;</span>
              (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
    match(ConL);
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4629,10 ***</span>
<span class="line-new-header">--- 4676,20 ---</span>
    op_cost(40);
    format %{ %}
    interface(CONST_INTER);
  %}
  
<span class="line-added">+ // Double Immediate: +0.0d.</span>
<span class="line-added">+ operand immD_0() %{</span>
<span class="line-added">+   predicate(jlong_cast(n-&gt;getd()) == 0);</span>
<span class="line-added">+   match(ConD);</span>
<span class="line-added">+ </span>
<span class="line-added">+   op_cost(0);</span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(CONST_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  // Integer Register Operands
  // Integer Destination Register
  // See definition of reg_class bits32_reg_rw.
  operand iRegIdst() %{
    constraint(ALLOC_IN_RC(bits32_reg_rw));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4976,11 ***</span>
  %}
  
  // Operands to remove register moves in unscaled mode.
  // Match read/write registers with an EncodeP node if neither shift nor add are required.
  operand iRegP2N(iRegPsrc reg) %{
<span class="line-modified">!   predicate(false /* TODO: PPC port MatchDecodeNodes*/&amp;&amp; Universe::narrow_oop_shift() == 0);</span>
    constraint(ALLOC_IN_RC(bits64_reg_ro));
    match(EncodeP reg);
    format %{ &quot;$reg&quot; %}
    interface(REG_INTER)
  %}
<span class="line-new-header">--- 5033,11 ---</span>
  %}
  
  // Operands to remove register moves in unscaled mode.
  // Match read/write registers with an EncodeP node if neither shift nor add are required.
  operand iRegP2N(iRegPsrc reg) %{
<span class="line-modified">!   predicate(false /* TODO: PPC port MatchDecodeNodes*/&amp;&amp; CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(bits64_reg_ro));
    match(EncodeP reg);
    format %{ &quot;$reg&quot; %}
    interface(REG_INTER)
  %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4992,11 ***</span>
    format %{ &quot;$reg&quot; %}
    interface(REG_INTER)
  %}
  
  operand iRegN2P_klass(iRegNsrc reg) %{
<span class="line-modified">!   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);</span>
    constraint(ALLOC_IN_RC(bits32_reg_ro));
    match(DecodeNKlass reg);
    format %{ &quot;$reg&quot; %}
    interface(REG_INTER)
  %}
<span class="line-new-header">--- 5049,11 ---</span>
    format %{ &quot;$reg&quot; %}
    interface(REG_INTER)
  %}
  
  operand iRegN2P_klass(iRegNsrc reg) %{
<span class="line-modified">!   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);</span>
    constraint(ALLOC_IN_RC(bits32_reg_ro));
    match(DecodeNKlass reg);
    format %{ &quot;$reg&quot; %}
    interface(REG_INTER)
  %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5061,11 ***</span>
      disp(0x0);
    %}
  %}
  
  operand indirectNarrow_klass(iRegNsrc reg) %{
<span class="line-modified">!   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);</span>
    constraint(ALLOC_IN_RC(bits64_reg_ro));
    match(DecodeNKlass reg);
    op_cost(100);
    format %{ &quot;[$reg]&quot; %}
    interface(MEMORY_INTER) %{
<span class="line-new-header">--- 5118,11 ---</span>
      disp(0x0);
    %}
  %}
  
  operand indirectNarrow_klass(iRegNsrc reg) %{
<span class="line-modified">!   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);</span>
    constraint(ALLOC_IN_RC(bits64_reg_ro));
    match(DecodeNKlass reg);
    op_cost(100);
    format %{ &quot;[$reg]&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5090,11 ***</span>
      disp($offset);
    %}
  %}
  
  operand indOffset16Narrow_klass(iRegNsrc reg, immL16 offset) %{
<span class="line-modified">!   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);</span>
    constraint(ALLOC_IN_RC(bits64_reg_ro));
    match(AddP (DecodeNKlass reg) offset);
    op_cost(100);
    format %{ &quot;[$reg + $offset]&quot; %}
    interface(MEMORY_INTER) %{
<span class="line-new-header">--- 5147,11 ---</span>
      disp($offset);
    %}
  %}
  
  operand indOffset16Narrow_klass(iRegNsrc reg, immL16 offset) %{
<span class="line-modified">!   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);</span>
    constraint(ALLOC_IN_RC(bits64_reg_ro));
    match(AddP (DecodeNKlass reg) offset);
    op_cost(100);
    format %{ &quot;[$reg + $offset]&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5119,11 ***</span>
      disp($offset);
    %}
  %}
  
  operand indOffset16NarrowAlg4_klass(iRegNsrc reg, immL16Alg4 offset) %{
<span class="line-modified">!   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);</span>
    constraint(ALLOC_IN_RC(bits64_reg_ro));
    match(AddP (DecodeNKlass reg) offset);
    op_cost(100);
    format %{ &quot;[$reg + $offset]&quot; %}
    interface(MEMORY_INTER) %{
<span class="line-new-header">--- 5176,11 ---</span>
      disp($offset);
    %}
  %}
  
  operand indOffset16NarrowAlg4_klass(iRegNsrc reg, immL16Alg4 offset) %{
<span class="line-modified">!   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);</span>
    constraint(ALLOC_IN_RC(bits64_reg_ro));
    match(AddP (DecodeNKlass reg) offset);
    op_cost(100);
    format %{ &quot;[$reg + $offset]&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5848,22 ***</span>
  %}
  
  // Load Compressed Pointer and decode it if narrow_oop_shift == 0.
  instruct loadN2P_unscaled(iRegPdst dst, memory mem) %{
    match(Set dst (DecodeN (LoadN mem)));
<span class="line-modified">!   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() &amp;&amp; Universe::narrow_oop_shift() == 0);</span>
    ins_cost(MEMORY_REF_COST);
  
    format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
    size(4);
    ins_encode( enc_lwz(dst, mem) );
    ins_pipe(pipe_class_memory);
  %}
  
  instruct loadN2P_klass_unscaled(iRegPdst dst, memory mem) %{
    match(Set dst (DecodeNKlass (LoadNKlass mem)));
<span class="line-modified">!   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0 &amp;&amp;</span>
              _kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
    ins_cost(MEMORY_REF_COST);
  
    format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
    size(4);
<span class="line-new-header">--- 5905,22 ---</span>
  %}
  
  // Load Compressed Pointer and decode it if narrow_oop_shift == 0.
  instruct loadN2P_unscaled(iRegPdst dst, memory mem) %{
    match(Set dst (DecodeN (LoadN mem)));
<span class="line-modified">!   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() &amp;&amp; CompressedOops::shift() == 0);</span>
    ins_cost(MEMORY_REF_COST);
  
    format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
    size(4);
    ins_encode( enc_lwz(dst, mem) );
    ins_pipe(pipe_class_memory);
  %}
  
  instruct loadN2P_klass_unscaled(iRegPdst dst, memory mem) %{
    match(Set dst (DecodeNKlass (LoadNKlass mem)));
<span class="line-modified">!   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0 &amp;&amp;</span>
              _kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
    ins_cost(MEMORY_REF_COST);
  
    format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
    size(4);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6325,11 ***</span>
    effect(DEF dst);
  
    format %{ &quot;LoadConst $dst, heapbase&quot; %}
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="line-modified">!     __ load_const_optimized($dst$$Register, Universe::narrow_oop_base(), R0);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Loading ConN must be postalloc expanded so that edges between
<span class="line-new-header">--- 6382,11 ---</span>
    effect(DEF dst);
  
    format %{ &quot;LoadConst $dst, heapbase&quot; %}
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="line-modified">!     __ load_const_optimized($dst$$Register, CompressedOops::base(), R0);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Loading ConN must be postalloc expanded so that edges between
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6373,11 ***</span>
  
    format %{ &quot;LIS     $dst, $src \t// narrow klass hi&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_addis);
<span class="line-modified">!     intptr_t Csrc = Klass::encode_klass((Klass *)$src$$constant);</span>
      __ lis($dst$$Register, (int)(short)((Csrc &gt;&gt; 16) &amp; 0xffff));
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-new-header">--- 6430,11 ---</span>
  
    format %{ &quot;LIS     $dst, $src \t// narrow klass hi&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_addis);
<span class="line-modified">!     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src$$constant);</span>
      __ lis($dst$$Register, (int)(short)((Csrc &gt;&gt; 16) &amp; 0xffff));
    %}
    ins_pipe(pipe_class_default);
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6405,11 ***</span>
  
    format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow klass lo&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_ori);
<span class="line-modified">!     intptr_t Csrc = Klass::encode_klass((Klass *)$src1$$constant);</span>
      assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
      int klass_index = __ oop_recorder()-&gt;find_index((Klass *)$src1$$constant);
      RelocationHolder rspec = metadata_Relocation::spec(klass_index);
  
      __ relocate(rspec, 1);
<span class="line-new-header">--- 6462,11 ---</span>
  
    format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow klass lo&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_ori);
<span class="line-modified">!     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src1$$constant);</span>
      assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
      int klass_index = __ oop_recorder()-&gt;find_index((Klass *)$src1$$constant);
      RelocationHolder rspec = metadata_Relocation::spec(klass_index);
  
      __ relocate(rspec, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6433,11 ***</span>
      m1-&gt;_opnds[1] = op_src;
      ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
      nodes-&gt;push(m1);
  
      MachNode *m2 = m1;
<span class="line-modified">!     if (!Assembler::is_uimm((jlong)Klass::encode_klass((Klass *)op_src-&gt;constant()), 31)) {</span>
        // Value might be 1-extended. Mask out these bits.
        m2 = new loadConNKlass_maskNode();
        m2-&gt;add_req(NULL, m1);
        m2-&gt;_opnds[0] = op_dst;
        m2-&gt;_opnds[1] = op_src;
<span class="line-new-header">--- 6490,11 ---</span>
      m1-&gt;_opnds[1] = op_src;
      ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
      nodes-&gt;push(m1);
  
      MachNode *m2 = m1;
<span class="line-modified">!     if (!Assembler::is_uimm((jlong)CompressedKlassPointers::encode((Klass *)op_src-&gt;constant()), 31)) {</span>
        // Value might be 1-extended. Mask out these bits.
        m2 = new loadConNKlass_maskNode();
        m2-&gt;add_req(NULL, m1);
        m2-&gt;_opnds[0] = op_dst;
        m2-&gt;_opnds[1] = op_src;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6895,29 ***</span>
    format %{ &quot;STB     #0, $mem \t// CMS card-mark byte (must be 0!), checking requires_release in [$releaseFieldAddr]&quot; %}
    ins_encode( enc_cms_card_mark(mem, releaseFieldAddr, crx) );
    ins_pipe(pipe_class_memory);
  %}
  
<span class="line-removed">- // Card-mark for CMS garbage collection.</span>
<span class="line-removed">- // This cardmark does an optimization so that it must not always</span>
<span class="line-removed">- // do a releasing store. For this, it needs the constant address of</span>
<span class="line-removed">- // CMSCollectorCardTableBarrierSetBSExt::_requires_release.</span>
<span class="line-removed">- // This constant address is split off here by expand so we can use</span>
<span class="line-removed">- // adlc / matcher functionality to load it from the constant section.</span>
<span class="line-removed">- instruct storeCM_CMS_ExEx(memory mem, immI_0 zero) %{</span>
<span class="line-removed">-   match(Set mem (StoreCM mem zero));</span>
<span class="line-removed">-   predicate(UseConcMarkSweepGC);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   expand %{</span>
<span class="line-removed">-     immL baseImm %{ 0 /* TODO: PPC port (jlong)CMSCollectorCardTableBarrierSetBSExt::requires_release_address() */ %}</span>
<span class="line-removed">-     iRegLdst releaseFieldAddress;</span>
<span class="line-removed">-     flagsReg crx;</span>
<span class="line-removed">-     loadConL_Ex(releaseFieldAddress, baseImm);</span>
<span class="line-removed">-     storeCM_CMS(mem, releaseFieldAddress, crx);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  instruct storeCM_G1(memory mem, immI_0 zero) %{
    match(Set mem (StoreCM mem zero));
    predicate(UseG1GC);
    ins_cost(MEMORY_REF_COST);
  
<span class="line-new-header">--- 6952,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6947,11 ***</span>
  
    format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified">!     __ srdi($dst$$Register, $src$$Register, Universe::narrow_oop_shift() &amp; 0x3f);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Add node for expand.
<span class="line-new-header">--- 6985,11 ---</span>
  
    format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified">!     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Add node for expand.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6961,11 ***</span>
    predicate(false);
  
    format %{ &quot;SUB     $dst, $src, oop_base \t// encode&quot; %}
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="line-modified">!     __ sub_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Conditional sub base.
<span class="line-new-header">--- 6999,11 ---</span>
    predicate(false);
  
    format %{ &quot;SUB     $dst, $src, oop_base \t// encode&quot; %}
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="line-modified">!     __ sub_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Conditional sub base.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6979,11 ***</span>
              &quot;done:&quot; %}
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
      Label done;
      __ beq($crx$$CondRegister, done);
<span class="line-modified">!     __ sub_const_optimized($dst$$Register, $src1$$Register, Universe::narrow_oop_base(), R0);</span>
      __ bind(done);
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-new-header">--- 7017,11 ---</span>
              &quot;done:&quot; %}
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
      Label done;
      __ beq($crx$$CondRegister, done);
<span class="line-modified">!     __ sub_const_optimized($dst$$Register, $src1$$Register, CompressedOops::base(), R0);</span>
      __ bind(done);
    %}
    ins_pipe(pipe_class_default);
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7004,65 ***</span>
  %}
  
  // Disjoint narrow oop base.
  instruct encodeP_Disjoint(iRegNdst dst, iRegPsrc src) %{
    match(Set dst (EncodeP src));
<span class="line-modified">!   predicate(Universe::narrow_oop_base_disjoint());</span>
  
    format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified">!     __ rldicl($dst$$Register, $src$$Register, 64-Universe::narrow_oop_shift(), 32);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // shift != 0, base != 0
  instruct encodeP_Ex(iRegNdst dst, flagsReg crx, iRegPsrc src) %{
    match(Set dst (EncodeP src));
    effect(TEMP crx);
    predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
<span class="line-modified">!             Universe::narrow_oop_shift() != 0 &amp;&amp;</span>
<span class="line-modified">!             Universe::narrow_oop_base_overlaps());</span>
  
    format %{ &quot;EncodeP $dst, $crx, $src \t// postalloc expanded&quot; %}
    postalloc_expand( postalloc_expand_encode_oop(dst, src, crx));
  %}
  
  // shift != 0, base != 0
  instruct encodeP_not_null_Ex(iRegNdst dst, iRegPsrc src) %{
    match(Set dst (EncodeP src));
    predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull &amp;&amp;
<span class="line-modified">!             Universe::narrow_oop_shift() != 0 &amp;&amp;</span>
<span class="line-modified">!             Universe::narrow_oop_base_overlaps());</span>
  
    format %{ &quot;EncodeP $dst, $src\t// $src != Null, postalloc expanded&quot; %}
    postalloc_expand( postalloc_expand_encode_oop_not_null(dst, src) );
  %}
  
  // shift != 0, base == 0
  // TODO: This is the same as encodeP_shift. Merge!
  instruct encodeP_not_null_base_null(iRegNdst dst, iRegPsrc src) %{
    match(Set dst (EncodeP src));
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() != 0 &amp;&amp;</span>
<span class="line-modified">!             Universe::narrow_oop_base() ==0);</span>
  
    format %{ &quot;SRDI    $dst, $src, #3 \t// encodeP, $src != NULL&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified">!     __ srdi($dst$$Register, $src$$Register, Universe::narrow_oop_shift() &amp; 0x3f);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Compressed OOPs with narrow_oop_shift == 0.
  // shift == 0, base == 0
  instruct encodeP_narrow_oop_shift_0(iRegNdst dst, iRegPsrc src) %{
    match(Set dst (EncodeP src));
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
  
    format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Narrow&quot; %}
    // variable size, 0 or 4.
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_or);
<span class="line-new-header">--- 7042,65 ---</span>
  %}
  
  // Disjoint narrow oop base.
  instruct encodeP_Disjoint(iRegNdst dst, iRegPsrc src) %{
    match(Set dst (EncodeP src));
<span class="line-modified">!   predicate(CompressedOops::base_disjoint());</span>
  
    format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified">!     __ rldicl($dst$$Register, $src$$Register, 64-CompressedOops::shift(), 32);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // shift != 0, base != 0
  instruct encodeP_Ex(iRegNdst dst, flagsReg crx, iRegPsrc src) %{
    match(Set dst (EncodeP src));
    effect(TEMP crx);
    predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
<span class="line-modified">!             CompressedOops::shift() != 0 &amp;&amp;</span>
<span class="line-modified">!             CompressedOops::base_overlaps());</span>
  
    format %{ &quot;EncodeP $dst, $crx, $src \t// postalloc expanded&quot; %}
    postalloc_expand( postalloc_expand_encode_oop(dst, src, crx));
  %}
  
  // shift != 0, base != 0
  instruct encodeP_not_null_Ex(iRegNdst dst, iRegPsrc src) %{
    match(Set dst (EncodeP src));
    predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull &amp;&amp;
<span class="line-modified">!             CompressedOops::shift() != 0 &amp;&amp;</span>
<span class="line-modified">!             CompressedOops::base_overlaps());</span>
  
    format %{ &quot;EncodeP $dst, $src\t// $src != Null, postalloc expanded&quot; %}
    postalloc_expand( postalloc_expand_encode_oop_not_null(dst, src) );
  %}
  
  // shift != 0, base == 0
  // TODO: This is the same as encodeP_shift. Merge!
  instruct encodeP_not_null_base_null(iRegNdst dst, iRegPsrc src) %{
    match(Set dst (EncodeP src));
<span class="line-modified">!   predicate(CompressedOops::shift() != 0 &amp;&amp;</span>
<span class="line-modified">!             CompressedOops::base() ==0);</span>
  
    format %{ &quot;SRDI    $dst, $src, #3 \t// encodeP, $src != NULL&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified">!     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Compressed OOPs with narrow_oop_shift == 0.
  // shift == 0, base == 0
  instruct encodeP_narrow_oop_shift_0(iRegNdst dst, iRegPsrc src) %{
    match(Set dst (EncodeP src));
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
  
    format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Narrow&quot; %}
    // variable size, 0 or 4.
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_or);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7081,11 ***</span>
  
    format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
<span class="line-modified">!     __ sldi($dst$$Register, $src$$Register, Universe::narrow_oop_shift());</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Add node for expand.
<span class="line-new-header">--- 7119,11 ---</span>
  
    format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
<span class="line-modified">!     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Add node for expand.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7095,11 ***</span>
    predicate(false);
  
    format %{ &quot;ADD     $dst, $src, heapbase \t// DecodeN, add oop base&quot; %}
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="line-modified">!     __ add_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // conditianal add base for expand
<span class="line-new-header">--- 7133,11 ---</span>
    predicate(false);
  
    format %{ &quot;ADD     $dst, $src, heapbase \t// DecodeN, add oop base&quot; %}
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="line-modified">!     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // conditianal add base for expand
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7116,11 ***</span>
              &quot;done:&quot; %}
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
      Label done;
      __ beq($crx$$CondRegister, done);
<span class="line-modified">!     __ add_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);</span>
      __ bind(done);
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-new-header">--- 7154,11 ---</span>
              &quot;done:&quot; %}
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
      Label done;
      __ beq($crx$$CondRegister, done);
<span class="line-modified">!     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);</span>
      __ bind(done);
    %}
    ins_pipe(pipe_class_default);
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7145,30 ***</span>
  //  shift != 0, base != 0
  instruct decodeN_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
    match(Set dst (DecodeN src));
    predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
               n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
<span class="line-modified">!             Universe::narrow_oop_shift() != 0 &amp;&amp;</span>
<span class="line-modified">!             Universe::narrow_oop_base() != 0);</span>
    ins_cost(4 * DEFAULT_COST); // Should be more expensive than decodeN_Disjoint_isel_Ex.
    effect(TEMP crx);
  
    format %{ &quot;DecodeN $dst, $src \t// Kills $crx, postalloc expanded&quot; %}
    postalloc_expand( postalloc_expand_decode_oop(dst, src, crx) );
  %}
  
  // shift != 0, base == 0
  instruct decodeN_nullBase(iRegPdst dst, iRegNsrc src) %{
    match(Set dst (DecodeN src));
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() != 0 &amp;&amp;</span>
<span class="line-modified">!             Universe::narrow_oop_base() == 0);</span>
  
    format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN (zerobased)&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
<span class="line-modified">!     __ sldi($dst$$Register, $src$$Register, Universe::narrow_oop_shift());</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Optimize DecodeN for disjoint base.
<span class="line-new-header">--- 7183,30 ---</span>
  //  shift != 0, base != 0
  instruct decodeN_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
    match(Set dst (DecodeN src));
    predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
               n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
<span class="line-modified">!             CompressedOops::shift() != 0 &amp;&amp;</span>
<span class="line-modified">!             CompressedOops::base() != 0);</span>
    ins_cost(4 * DEFAULT_COST); // Should be more expensive than decodeN_Disjoint_isel_Ex.
    effect(TEMP crx);
  
    format %{ &quot;DecodeN $dst, $src \t// Kills $crx, postalloc expanded&quot; %}
    postalloc_expand( postalloc_expand_decode_oop(dst, src, crx) );
  %}
  
  // shift != 0, base == 0
  instruct decodeN_nullBase(iRegPdst dst, iRegNsrc src) %{
    match(Set dst (DecodeN src));
<span class="line-modified">!   predicate(CompressedOops::shift() != 0 &amp;&amp;</span>
<span class="line-modified">!             CompressedOops::base() == 0);</span>
  
    format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN (zerobased)&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
<span class="line-modified">!     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Optimize DecodeN for disjoint base.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7181,11 ***</span>
  
    format %{ &quot;RLDIMI  $dst, $src, shift, 32-shift \t// DecodeN (disjoint base)&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
<span class="line-modified">!     __ rldimi($dst$$Register, $src$$Register, Universe::narrow_oop_shift(), 32-Universe::narrow_oop_shift());</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Optimize DecodeN for disjoint base.
<span class="line-new-header">--- 7219,11 ---</span>
  
    format %{ &quot;RLDIMI  $dst, $src, shift, 32-shift \t// DecodeN (disjoint base)&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
<span class="line-modified">!     __ rldimi($dst$$Register, $src$$Register, CompressedOops::shift(), 32-CompressedOops::shift());</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Optimize DecodeN for disjoint base.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7195,11 ***</span>
  instruct decodeN_Disjoint_notNull_Ex(iRegPdst dst, iRegNsrc src) %{
    match(Set dst (DecodeN src));
    effect(TEMP_DEF dst);
    predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
               n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified">!             Universe::narrow_oop_base_disjoint());</span>
    ins_cost(DEFAULT_COST);
  
    format %{ &quot;MOV     $dst, heapbase \t\n&quot;
              &quot;RLDIMI  $dst, $src, shift, 32-shift \t// decode with disjoint base&quot; %}
    postalloc_expand %{
<span class="line-new-header">--- 7233,11 ---</span>
  instruct decodeN_Disjoint_notNull_Ex(iRegPdst dst, iRegNsrc src) %{
    match(Set dst (DecodeN src));
    effect(TEMP_DEF dst);
    predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
               n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified">!             CompressedOops::base_disjoint());</span>
    ins_cost(DEFAULT_COST);
  
    format %{ &quot;MOV     $dst, heapbase \t\n&quot;
              &quot;RLDIMI  $dst, $src, shift, 32-shift \t// decode with disjoint base&quot; %}
    postalloc_expand %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7225,11 ***</span>
  instruct decodeN_Disjoint_isel_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
    match(Set dst (DecodeN src));
    effect(TEMP_DEF dst, TEMP crx);
    predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
               n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
<span class="line-modified">!             Universe::narrow_oop_base_disjoint() &amp;&amp; VM_Version::has_isel());</span>
    ins_cost(3 * DEFAULT_COST);
  
    format %{ &quot;DecodeN  $dst, $src \t// decode with disjoint base using isel&quot; %}
    postalloc_expand %{
      loadBaseNode *n1 = new loadBaseNode();
<span class="line-new-header">--- 7263,11 ---</span>
  instruct decodeN_Disjoint_isel_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
    match(Set dst (DecodeN src));
    effect(TEMP_DEF dst, TEMP crx);
    predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
               n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
<span class="line-modified">!             CompressedOops::base_disjoint() &amp;&amp; VM_Version::has_isel());</span>
    ins_cost(3 * DEFAULT_COST);
  
    format %{ &quot;DecodeN  $dst, $src \t// decode with disjoint base using isel&quot; %}
    postalloc_expand %{
      loadBaseNode *n1 = new loadBaseNode();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7274,22 ***</span>
  // src != 0, shift != 0, base != 0
  instruct decodeN_notNull_addBase_Ex(iRegPdst dst, iRegNsrc src) %{
    match(Set dst (DecodeN src));
    predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
               n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified">!             Universe::narrow_oop_shift() != 0 &amp;&amp;</span>
<span class="line-modified">!             Universe::narrow_oop_base() != 0);</span>
    ins_cost(2 * DEFAULT_COST);
  
    format %{ &quot;DecodeN $dst, $src \t// $src != NULL, postalloc expanded&quot; %}
    postalloc_expand( postalloc_expand_decode_oop_not_null(dst, src));
  %}
  
  // Compressed OOPs with narrow_oop_shift == 0.
  instruct decodeN_unscaled(iRegPdst dst, iRegNsrc src) %{
    match(Set dst (DecodeN src));
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    ins_cost(DEFAULT_COST);
  
    format %{ &quot;MR      $dst, $src \t// DecodeN (unscaled)&quot; %}
    // variable size, 0 or 4.
    ins_encode %{
<span class="line-new-header">--- 7312,22 ---</span>
  // src != 0, shift != 0, base != 0
  instruct decodeN_notNull_addBase_Ex(iRegPdst dst, iRegNsrc src) %{
    match(Set dst (DecodeN src));
    predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
               n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified">!             CompressedOops::shift() != 0 &amp;&amp;</span>
<span class="line-modified">!             CompressedOops::base() != 0);</span>
    ins_cost(2 * DEFAULT_COST);
  
    format %{ &quot;DecodeN $dst, $src \t// $src != NULL, postalloc expanded&quot; %}
    postalloc_expand( postalloc_expand_decode_oop_not_null(dst, src));
  %}
  
  // Compressed OOPs with narrow_oop_shift == 0.
  instruct decodeN_unscaled(iRegPdst dst, iRegNsrc src) %{
    match(Set dst (DecodeN src));
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    ins_cost(DEFAULT_COST);
  
    format %{ &quot;MR      $dst, $src \t// DecodeN (unscaled)&quot; %}
    // variable size, 0 or 4.
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7300,11 ***</span>
  %}
  
  // Convert compressed oop into int for vectors alignment masking.
  instruct decodeN2I_unscaled(iRegIdst dst, iRegNsrc src) %{
    match(Set dst (ConvL2I (CastP2X (DecodeN src))));
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0);</span>
    ins_cost(DEFAULT_COST);
  
    format %{ &quot;MR      $dst, $src \t// (int)DecodeN (unscaled)&quot; %}
    // variable size, 0 or 4.
    ins_encode %{
<span class="line-new-header">--- 7338,11 ---</span>
  %}
  
  // Convert compressed oop into int for vectors alignment masking.
  instruct decodeN2I_unscaled(iRegIdst dst, iRegNsrc src) %{
    match(Set dst (ConvL2I (CastP2X (DecodeN src))));
<span class="line-modified">!   predicate(CompressedOops::shift() == 0);</span>
    ins_cost(DEFAULT_COST);
  
    format %{ &quot;MR      $dst, $src \t// (int)DecodeN (unscaled)&quot; %}
    // variable size, 0 or 4.
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7326,11 ***</span>
  
    format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified">!     __ srdi($dst$$Register, $src$$Register, Universe::narrow_klass_shift());</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Add node for expand.
<span class="line-new-header">--- 7364,11 ---</span>
  
    format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified">!     __ srdi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Add node for expand.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7349,17 ***</span>
  %}
  
  // Disjoint narrow oop base.
  instruct encodePKlass_Disjoint(iRegNdst dst, iRegPsrc src) %{
    match(Set dst (EncodePKlass src));
<span class="line-modified">!   predicate(false /* TODO: PPC port Universe::narrow_klass_base_disjoint()*/);</span>
  
    format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified">!     __ rldicl($dst$$Register, $src$$Register, 64-Universe::narrow_klass_shift(), 32);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // shift != 0, base != 0
<span class="line-new-header">--- 7387,17 ---</span>
  %}
  
  // Disjoint narrow oop base.
  instruct encodePKlass_Disjoint(iRegNdst dst, iRegPsrc src) %{
    match(Set dst (EncodePKlass src));
<span class="line-modified">!   predicate(false /* TODO: PPC port CompressedKlassPointers::base_disjoint()*/);</span>
  
    format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified">!     __ rldicl($dst$$Register, $src$$Register, 64-CompressedKlassPointers::shift(), 32);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // shift != 0, base != 0
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7390,17 ***</span>
  %}
  
  // shift != 0, base != 0
  instruct encodePKlass_not_null_ExEx(iRegNdst dst, iRegPsrc src) %{
    match(Set dst (EncodePKlass src));
<span class="line-modified">!   //predicate(Universe::narrow_klass_shift() != 0 &amp;&amp;</span>
<span class="line-modified">!   //          true /* TODO: PPC port Universe::narrow_klass_base_overlaps()*/);</span>
  
    //format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
    ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
    expand %{
<span class="line-modified">!     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_klass_base() %}</span>
      iRegLdst base;
      loadConL_Ex(base, baseImm);
      encodePKlass_not_null_Ex(dst, base, src);
    %}
  %}
<span class="line-new-header">--- 7428,17 ---</span>
  %}
  
  // shift != 0, base != 0
  instruct encodePKlass_not_null_ExEx(iRegNdst dst, iRegPsrc src) %{
    match(Set dst (EncodePKlass src));
<span class="line-modified">!   //predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;</span>
<span class="line-modified">!   //          true /* TODO: PPC port CompressedKlassPointers::base_overlaps()*/);</span>
  
    //format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
    ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
    expand %{
<span class="line-modified">!     immL baseImm %{ (jlong)(intptr_t)CompressedKlassPointers::base() %}</span>
      iRegLdst base;
      loadConL_Ex(base, baseImm);
      encodePKlass_not_null_Ex(dst, base, src);
    %}
  %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7415,11 ***</span>
  
    format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeNKlass&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
<span class="line-modified">!     __ sldi($dst$$Register, $src$$Register, Universe::narrow_klass_shift());</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Add node for expand.
<span class="line-new-header">--- 7453,11 ---</span>
  
    format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeNKlass&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
<span class="line-modified">!     __ sldi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  // Add node for expand.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7468,20 ***</span>
  %}
  
  // src != 0, shift != 0, base != 0
  instruct decodeNKlass_notNull_addBase_ExEx(iRegPdst dst, iRegNsrc src) %{
    match(Set dst (DecodeNKlass src));
<span class="line-modified">!   // predicate(Universe::narrow_klass_shift() != 0 &amp;&amp;</span>
<span class="line-modified">!   //           Universe::narrow_klass_base() != 0);</span>
  
    //format %{ &quot;DecodeNKlass $dst, $src \t// $src != NULL, expanded&quot; %}
  
    ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
    expand %{
      // We add first, then we shift. Like this, we can get along with one register less.
      // But we have to load the base pre-shifted.
<span class="line-modified">!     immL baseImm %{ (jlong)((intptr_t)Universe::narrow_klass_base() &gt;&gt; Universe::narrow_klass_shift()) %}</span>
      iRegLdst base;
      loadConL_Ex(base, baseImm);
      decodeNKlass_notNull_addBase_Ex(dst, base, src);
    %}
  %}
<span class="line-new-header">--- 7506,20 ---</span>
  %}
  
  // src != 0, shift != 0, base != 0
  instruct decodeNKlass_notNull_addBase_ExEx(iRegPdst dst, iRegNsrc src) %{
    match(Set dst (DecodeNKlass src));
<span class="line-modified">!   // predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;</span>
<span class="line-modified">!   //           CompressedKlassPointers::base() != 0);</span>
  
    //format %{ &quot;DecodeNKlass $dst, $src \t// $src != NULL, expanded&quot; %}
  
    ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
    expand %{
      // We add first, then we shift. Like this, we can get along with one register less.
      // But we have to load the base pre-shifted.
<span class="line-modified">!     immL baseImm %{ (jlong)((intptr_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift()) %}</span>
      iRegLdst base;
      loadConL_Ex(base, baseImm);
      decodeNKlass_notNull_addBase_Ex(dst, base, src);
    %}
  %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10837,10 ***</span>
<span class="line-new-header">--- 10875,18 ---</span>
    size(0);
    ins_encode( /*empty*/ );
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-added">+ instruct castLL(iRegLdst dst) %{</span>
<span class="line-added">+   match(Set dst (CastLL dst));</span>
<span class="line-added">+   format %{ &quot; -- \t// castLL of $dst&quot; %}</span>
<span class="line-added">+   size(0);</span>
<span class="line-added">+   ins_encode( /*empty*/ );</span>
<span class="line-added">+   ins_pipe(pipe_class_default);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  instruct checkCastPP(iRegPdst dst) %{
    match(Set dst (CheckCastPP dst));
    format %{ &quot; -- \t// checkcastPP of $dst&quot; %}
    size(0);
    ins_encode( /*empty*/ );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14007,11 ***</span>
  %}
  
  instruct repl4S_immI0(iRegLdst dst, immI_0 zero) %{
    match(Set dst (ReplicateS zero));
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">!   format %{ &quot;LI      $dst, #0 \t// replicate4C&quot; %}</span>
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_addi);
      __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
    %}
<span class="line-new-header">--- 14053,11 ---</span>
  %}
  
  instruct repl4S_immI0(iRegLdst dst, immI_0 zero) %{
    match(Set dst (ReplicateS zero));
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">!   format %{ &quot;LI      $dst, #0 \t// replicate4S&quot; %}</span>
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_addi);
      __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14019,11 ***</span>
  %}
  
  instruct repl4S_immIminus1(iRegLdst dst, immI_minus1 src) %{
    match(Set dst (ReplicateS src));
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">!   format %{ &quot;LI      $dst, -1 \t// replicate4C&quot; %}</span>
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_addi);
      __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
    %}
<span class="line-new-header">--- 14065,11 ---</span>
  %}
  
  instruct repl4S_immIminus1(iRegLdst dst, immI_minus1 src) %{
    match(Set dst (ReplicateS src));
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">!   format %{ &quot;LI      $dst, -1 \t// replicate4S&quot; %}</span>
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_addi);
      __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14060,11 ***</span>
  
  instruct repl8S_immIminus1(vecX dst, immI_minus1 src) %{
    match(Set dst (ReplicateS src));
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
  
<span class="line-modified">!   format %{ &quot;XXLEQV      $dst, $src \t// replicate16B&quot; %}</span>
    size(4);
    ins_encode %{
      __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
    %}
    ins_pipe(pipe_class_default);
<span class="line-new-header">--- 14106,11 ---</span>
  
  instruct repl8S_immIminus1(vecX dst, immI_minus1 src) %{
    match(Set dst (ReplicateS src));
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
  
<span class="line-modified">!   format %{ &quot;XXLEQV      $dst, $src \t// replicate8S&quot; %}</span>
    size(4);
    ins_encode %{
      __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
    %}
    ins_pipe(pipe_class_default);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14081,11 ***</span>
  %}
  
  instruct repl2I_immI0(iRegLdst dst, immI_0 zero) %{
    match(Set dst (ReplicateI zero));
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">!   format %{ &quot;LI      $dst, #0 \t// replicate4C&quot; %}</span>
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_addi);
      __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
    %}
<span class="line-new-header">--- 14127,11 ---</span>
  %}
  
  instruct repl2I_immI0(iRegLdst dst, immI_0 zero) %{
    match(Set dst (ReplicateI zero));
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">!   format %{ &quot;LI      $dst, #0 \t// replicate2I&quot; %}</span>
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_addi);
      __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14093,11 ***</span>
  %}
  
  instruct repl2I_immIminus1(iRegLdst dst, immI_minus1 src) %{
    match(Set dst (ReplicateI src));
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">!   format %{ &quot;LI      $dst, -1 \t// replicate4C&quot; %}</span>
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_addi);
      __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
    %}
<span class="line-new-header">--- 14139,11 ---</span>
  %}
  
  instruct repl2I_immIminus1(iRegLdst dst, immI_minus1 src) %{
    match(Set dst (ReplicateI src));
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">!   format %{ &quot;LI      $dst, -1 \t// replicate2I&quot; %}</span>
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_addi);
      __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14416,10 ***</span>
<span class="line-new-header">--- 14462,57 ---</span>
      __ xvabsdp($dst$$VectorSRegister, $src$$VectorSRegister);
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-added">+ // Round Instructions</span>
<span class="line-added">+ instruct roundD_reg(regD dst, regD src, immI8 rmode) %{</span>
<span class="line-added">+   match(Set dst (RoundDoubleMode src rmode));</span>
<span class="line-added">+   format %{ &quot;RoundDoubleMode $src,$rmode&quot; %}</span>
<span class="line-added">+   size(4);</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     switch ($rmode$$constant) {</span>
<span class="line-added">+       case RoundDoubleModeNode::rmode_rint:</span>
<span class="line-added">+         __ frin($dst$$FloatRegister, $src$$FloatRegister);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       case RoundDoubleModeNode::rmode_floor:</span>
<span class="line-added">+         __ frim($dst$$FloatRegister, $src$$FloatRegister);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       case RoundDoubleModeNode::rmode_ceil:</span>
<span class="line-added">+         __ frip($dst$$FloatRegister, $src$$FloatRegister);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       default:</span>
<span class="line-added">+         ShouldNotReachHere();</span>
<span class="line-added">+     }</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_class_default);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Vector Round Instructions</span>
<span class="line-added">+ instruct vround2D_reg(vecX dst, vecX src, immI8 rmode) %{</span>
<span class="line-added">+   match(Set dst (RoundDoubleModeV src rmode));</span>
<span class="line-added">+   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-added">+   format %{ &quot;RoundDoubleModeV $src,$rmode&quot; %}</span>
<span class="line-added">+   size(4);</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     switch ($rmode$$constant) {</span>
<span class="line-added">+       case RoundDoubleModeNode::rmode_rint:</span>
<span class="line-added">+         __ xvrdpi($dst$$VectorSRegister, $src$$VectorSRegister);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       case RoundDoubleModeNode::rmode_floor:</span>
<span class="line-added">+         __ xvrdpim($dst$$VectorSRegister, $src$$VectorSRegister);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       case RoundDoubleModeNode::rmode_ceil:</span>
<span class="line-added">+         __ xvrdpip($dst$$VectorSRegister, $src$$VectorSRegister);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       default:</span>
<span class="line-added">+         ShouldNotReachHere();</span>
<span class="line-added">+     }</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_class_default);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  // Vector Negate Instructions
  
  instruct vneg4F_reg(vecX dst, vecX src) %{
    match(Set dst (NegVF src));
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14667,11 ***</span>
      __ xxpermdi($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr(), $src$$FloatRegister-&gt;to_vsr(), 0);
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct repl2D_immI0(vecX dst, immI_0 zero) %{</span>
    match(Set dst (ReplicateD zero));
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
  
    format %{ &quot;XXLXOR      $dst, $zero \t// replicate2D&quot; %}
    size(4);
<span class="line-new-header">--- 14760,11 ---</span>
      __ xxpermdi($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr(), $src$$FloatRegister-&gt;to_vsr(), 0);
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-modified">! instruct repl2D_immD0(vecX dst, immD_0 zero) %{</span>
    match(Set dst (ReplicateD zero));
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
  
    format %{ &quot;XXLXOR      $dst, $zero \t// replicate2D&quot; %}
    size(4);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14679,22 ***</span>
      __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-removed">- instruct repl2D_immIminus1(vecX dst, immI_minus1 src) %{</span>
<span class="line-removed">-   match(Set dst (ReplicateD src));</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   format %{ &quot;XXLEQV      $dst, $src \t// replicate16B&quot; %}</span>
<span class="line-removed">-   size(4);</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe(pipe_class_default);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  instruct mtvsrd(vecX dst, iRegLsrc src) %{
    predicate(false);
    effect(DEF dst, USE src);
  
    format %{ &quot;MTVSRD      $dst, $src \t// Move to 16-byte register&quot; %}
<span class="line-new-header">--- 14772,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14752,11 ***</span>
  
  instruct repl2L_immIminus1(vecX dst, immI_minus1 src) %{
    match(Set dst (ReplicateL src));
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
  
<span class="line-modified">!   format %{ &quot;XXLEQV      $dst, $src \t// replicate16B&quot; %}</span>
    size(4);
    ins_encode %{
      __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
    %}
    ins_pipe(pipe_class_default);
<span class="line-new-header">--- 14833,11 ---</span>
  
  instruct repl2L_immIminus1(vecX dst, immI_minus1 src) %{
    match(Set dst (ReplicateL src));
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
  
<span class="line-modified">!   format %{ &quot;XXLEQV      $dst, $src \t// replicate2L&quot; %}</span>
    size(4);
    ins_encode %{
      __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
    %}
    ins_pipe(pipe_class_default);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15142,10 ***</span>
<span class="line-new-header">--- 15223,48 ---</span>
      __ brnop2();
    %}
    ins_pipe(pipe_class_default);
  %}
  
<span class="line-added">+ instruct cacheWB(indirect addr)</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   match(CacheWB addr);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_cost(100);</span>
<span class="line-added">+   format %{ &quot;cache writeback, address = $addr&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);</span>
<span class="line-added">+     assert($addr$$disp == 0, &quot;should be&quot;);</span>
<span class="line-added">+     __ cache_wb(Address($addr$$base$$Register));</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_class_default);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct cacheWBPreSync()</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   match(CacheWBPreSync);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_cost(0);</span>
<span class="line-added">+   format %{ &quot;cache writeback presync&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     __ cache_wbsync(true);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_class_default);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct cacheWBPostSync()</span>
<span class="line-added">+ %{</span>
<span class="line-added">+   match(CacheWBPostSync);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_cost(100);</span>
<span class="line-added">+   format %{ &quot;cache writeback postsync&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     __ cache_wbsync(false);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_class_default);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  //----------PEEPHOLE RULES-----------------------------------------------------
  // These must follow all instruction definitions as they use the names
  // defined in the instructions definitions.
  //
  // peepmatch ( root_instr_name [preceeding_instruction]* );
</pre>
<center><a href="nativeInst_ppc.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="relocInfo_ppc.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
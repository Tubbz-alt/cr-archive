<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/methodHandles_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_ppc.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/methodHandles_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 60 
 61 #ifdef ASSERT
 62 static int check_nonzero(const char* xname, int x) {
 63   assert(x != 0, &quot;%s should be nonzero&quot;, xname);
 64   return x;
 65 }
 66 #define NONZERO(x) check_nonzero(#x, x)
 67 #else //ASSERT
 68 #define NONZERO(x) (x)
 69 #endif //ASSERT
 70 
 71 #ifdef ASSERT
 72 void MethodHandles::verify_klass(MacroAssembler* _masm,
 73                                  Register obj_reg, SystemDictionary::WKID klass_id,
 74                                  Register temp_reg, Register temp2_reg,
 75                                  const char* error_message) {
 76   InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);
 77   Klass* klass = SystemDictionary::well_known_klass(klass_id);
 78   Label L_ok, L_bad;
 79   BLOCK_COMMENT(&quot;verify_klass {&quot;);
<span class="line-modified"> 80   __ verify_oop(obj_reg);</span>
 81   __ cmpdi(CCR0, obj_reg, 0);
 82   __ beq(CCR0, L_bad);
 83   __ load_klass(temp_reg, obj_reg);
 84   __ load_const_optimized(temp2_reg, (address) klass_addr);
 85   __ ld(temp2_reg, 0, temp2_reg);
 86   __ cmpd(CCR0, temp_reg, temp2_reg);
 87   __ beq(CCR0, L_ok);
 88   __ ld(temp_reg, klass-&gt;super_check_offset(), temp_reg);
 89   __ cmpd(CCR0, temp_reg, temp2_reg);
 90   __ beq(CCR0, L_ok);
 91   __ BIND(L_bad);
 92   __ stop(error_message);
 93   __ BIND(L_ok);
 94   BLOCK_COMMENT(&quot;} verify_klass&quot;);
 95 }
 96 
 97 void MethodHandles::verify_ref_kind(MacroAssembler* _masm, int ref_kind, Register member_reg, Register temp) {
 98   Label L;
 99   BLOCK_COMMENT(&quot;verify_ref_kind {&quot;);
100   __ load_sized_value(temp, NONZERO(java_lang_invoke_MemberName::flags_offset_in_bytes()), member_reg,
</pre>
<hr />
<pre>
155 
156   __ bind(L_no_such_method);
157   assert(StubRoutines::throw_AbstractMethodError_entry() != NULL, &quot;not yet generated!&quot;);
158   __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());
159   __ mtctr(target);
160   __ bctr();
161 }
162 
163 
164 void MethodHandles::jump_to_lambda_form(MacroAssembler* _masm,
165                                         Register recv, Register method_temp,
166                                         Register temp2, Register temp3,
167                                         bool for_compiler_entry) {
168   BLOCK_COMMENT(&quot;jump_to_lambda_form {&quot;);
169   // This is the initial entry point of a lazy method handle.
170   // After type checking, it picks up the invoker from the LambdaForm.
171   assert_different_registers(recv, method_temp, temp2);  // temp3 is only passed on
172   assert(method_temp == R19_method, &quot;required register for loading method&quot;);
173 
174   // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
<span class="line-modified">175   __ verify_oop(recv);</span>
176   __ load_heap_oop(method_temp, NONZERO(java_lang_invoke_MethodHandle::form_offset_in_bytes()), recv,
177                    temp2, noreg, false, IS_NOT_NULL);
<span class="line-modified">178   __ verify_oop(method_temp);</span>
179   __ load_heap_oop(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset_in_bytes()), method_temp,
180                    temp2, noreg, false, IS_NOT_NULL);
<span class="line-modified">181   __ verify_oop(method_temp);</span>
182   __ load_heap_oop(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()), method_temp,
183                    temp2, noreg, false, IS_NOT_NULL);
<span class="line-modified">184   __ verify_oop(method_temp);</span>
185   __ ld(method_temp, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()), method_temp);
186 
187   if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
188     // Make sure recv is already on stack.
189     __ ld(temp2, in_bytes(Method::const_offset()), method_temp);
190     __ load_sized_value(temp2, in_bytes(ConstMethod::size_of_parameters_offset()), temp2,
191                         sizeof(u2), /*is_signed*/ false);
192     // assert(sizeof(u2) == sizeof(ConstMethod::_size_of_parameters), &quot;&quot;);
193     Label L;
194     __ ld(temp2, __ argument_offset(temp2, temp2, 0), R15_esp);
195     __ cmpd(CCR1, temp2, recv);
196     __ beq(CCR1, L);
197     __ stop(&quot;receiver not on stack&quot;);
198     __ BIND(L);
199   }
200 
201   jump_from_method_handle(_masm, method_temp, temp2, temp3, for_compiler_entry);
202   BLOCK_COMMENT(&quot;} jump_to_lambda_form&quot;);
203 }
204 
</pre>
<hr />
<pre>
301   Register temp2 = (for_compiler_entry ? R22_tmp2 : R8);
302   Register temp3 = (for_compiler_entry ? R23_tmp3 : R9);
303   Register temp4 = (for_compiler_entry ? R24_tmp4 : R10);
304   if (receiver_reg != noreg)  assert_different_registers(temp1, temp2, temp3, temp4, receiver_reg);
305   if (member_reg   != noreg)  assert_different_registers(temp1, temp2, temp3, temp4, member_reg);
306 
307   if (iid == vmIntrinsics::_invokeBasic) {
308     // indirect through MH.form.vmentry.vmtarget
309     jump_to_lambda_form(_masm, receiver_reg, R19_method, temp1, temp2, for_compiler_entry);
310   } else {
311     // The method is a member invoker used by direct method handles.
312     if (VerifyMethodHandles) {
313       // make sure the trailing argument really is a MemberName (caller responsibility)
314       verify_klass(_masm, member_reg, SystemDictionary::WK_KLASS_ENUM_NAME(MemberName_klass),
315                    temp1, temp2,
316                    &quot;MemberName required for invokeVirtual etc.&quot;);
317     }
318 
319     Register temp1_recv_klass = temp1;
320     if (iid != vmIntrinsics::_linkToStatic) {
<span class="line-modified">321       __ verify_oop(receiver_reg);</span>
322       if (iid == vmIntrinsics::_linkToSpecial) {
323         // Don&#39;t actually load the klass; just null-check the receiver.
324         __ null_check_throw(receiver_reg, -1, temp1,
325                             Interpreter::throw_NullPointerException_entry());
326       } else {
327         // load receiver klass itself
328         __ null_check_throw(receiver_reg, oopDesc::klass_offset_in_bytes(), temp1,
329                             Interpreter::throw_NullPointerException_entry());
330         __ load_klass(temp1_recv_klass, receiver_reg);
331         __ verify_klass_ptr(temp1_recv_klass);
332       }
333       BLOCK_COMMENT(&quot;check_receiver {&quot;);
334       // The receiver for the MemberName must be in receiver_reg.
335       // Check the receiver against the MemberName.clazz
336       if (VerifyMethodHandles &amp;&amp; iid == vmIntrinsics::_linkToSpecial) {
337         // Did not load it above...
338         __ load_klass(temp1_recv_klass, receiver_reg);
339         __ verify_klass_ptr(temp1_recv_klass);
340       }
341       if (VerifyMethodHandles &amp;&amp; iid != vmIntrinsics::_linkToInterface) {
</pre>
</td>
<td>
<hr />
<pre>
 60 
 61 #ifdef ASSERT
 62 static int check_nonzero(const char* xname, int x) {
 63   assert(x != 0, &quot;%s should be nonzero&quot;, xname);
 64   return x;
 65 }
 66 #define NONZERO(x) check_nonzero(#x, x)
 67 #else //ASSERT
 68 #define NONZERO(x) (x)
 69 #endif //ASSERT
 70 
 71 #ifdef ASSERT
 72 void MethodHandles::verify_klass(MacroAssembler* _masm,
 73                                  Register obj_reg, SystemDictionary::WKID klass_id,
 74                                  Register temp_reg, Register temp2_reg,
 75                                  const char* error_message) {
 76   InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);
 77   Klass* klass = SystemDictionary::well_known_klass(klass_id);
 78   Label L_ok, L_bad;
 79   BLOCK_COMMENT(&quot;verify_klass {&quot;);
<span class="line-modified"> 80   __ verify_oop(obj_reg, FILE_AND_LINE);</span>
 81   __ cmpdi(CCR0, obj_reg, 0);
 82   __ beq(CCR0, L_bad);
 83   __ load_klass(temp_reg, obj_reg);
 84   __ load_const_optimized(temp2_reg, (address) klass_addr);
 85   __ ld(temp2_reg, 0, temp2_reg);
 86   __ cmpd(CCR0, temp_reg, temp2_reg);
 87   __ beq(CCR0, L_ok);
 88   __ ld(temp_reg, klass-&gt;super_check_offset(), temp_reg);
 89   __ cmpd(CCR0, temp_reg, temp2_reg);
 90   __ beq(CCR0, L_ok);
 91   __ BIND(L_bad);
 92   __ stop(error_message);
 93   __ BIND(L_ok);
 94   BLOCK_COMMENT(&quot;} verify_klass&quot;);
 95 }
 96 
 97 void MethodHandles::verify_ref_kind(MacroAssembler* _masm, int ref_kind, Register member_reg, Register temp) {
 98   Label L;
 99   BLOCK_COMMENT(&quot;verify_ref_kind {&quot;);
100   __ load_sized_value(temp, NONZERO(java_lang_invoke_MemberName::flags_offset_in_bytes()), member_reg,
</pre>
<hr />
<pre>
155 
156   __ bind(L_no_such_method);
157   assert(StubRoutines::throw_AbstractMethodError_entry() != NULL, &quot;not yet generated!&quot;);
158   __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());
159   __ mtctr(target);
160   __ bctr();
161 }
162 
163 
164 void MethodHandles::jump_to_lambda_form(MacroAssembler* _masm,
165                                         Register recv, Register method_temp,
166                                         Register temp2, Register temp3,
167                                         bool for_compiler_entry) {
168   BLOCK_COMMENT(&quot;jump_to_lambda_form {&quot;);
169   // This is the initial entry point of a lazy method handle.
170   // After type checking, it picks up the invoker from the LambdaForm.
171   assert_different_registers(recv, method_temp, temp2);  // temp3 is only passed on
172   assert(method_temp == R19_method, &quot;required register for loading method&quot;);
173 
174   // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
<span class="line-modified">175   __ verify_oop(recv, FILE_AND_LINE);</span>
176   __ load_heap_oop(method_temp, NONZERO(java_lang_invoke_MethodHandle::form_offset_in_bytes()), recv,
177                    temp2, noreg, false, IS_NOT_NULL);
<span class="line-modified">178   __ verify_oop(method_temp, FILE_AND_LINE);</span>
179   __ load_heap_oop(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset_in_bytes()), method_temp,
180                    temp2, noreg, false, IS_NOT_NULL);
<span class="line-modified">181   __ verify_oop(method_temp, FILE_AND_LINE);</span>
182   __ load_heap_oop(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()), method_temp,
183                    temp2, noreg, false, IS_NOT_NULL);
<span class="line-modified">184   __ verify_oop(method_temp, FILE_AND_LINE);</span>
185   __ ld(method_temp, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()), method_temp);
186 
187   if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
188     // Make sure recv is already on stack.
189     __ ld(temp2, in_bytes(Method::const_offset()), method_temp);
190     __ load_sized_value(temp2, in_bytes(ConstMethod::size_of_parameters_offset()), temp2,
191                         sizeof(u2), /*is_signed*/ false);
192     // assert(sizeof(u2) == sizeof(ConstMethod::_size_of_parameters), &quot;&quot;);
193     Label L;
194     __ ld(temp2, __ argument_offset(temp2, temp2, 0), R15_esp);
195     __ cmpd(CCR1, temp2, recv);
196     __ beq(CCR1, L);
197     __ stop(&quot;receiver not on stack&quot;);
198     __ BIND(L);
199   }
200 
201   jump_from_method_handle(_masm, method_temp, temp2, temp3, for_compiler_entry);
202   BLOCK_COMMENT(&quot;} jump_to_lambda_form&quot;);
203 }
204 
</pre>
<hr />
<pre>
301   Register temp2 = (for_compiler_entry ? R22_tmp2 : R8);
302   Register temp3 = (for_compiler_entry ? R23_tmp3 : R9);
303   Register temp4 = (for_compiler_entry ? R24_tmp4 : R10);
304   if (receiver_reg != noreg)  assert_different_registers(temp1, temp2, temp3, temp4, receiver_reg);
305   if (member_reg   != noreg)  assert_different_registers(temp1, temp2, temp3, temp4, member_reg);
306 
307   if (iid == vmIntrinsics::_invokeBasic) {
308     // indirect through MH.form.vmentry.vmtarget
309     jump_to_lambda_form(_masm, receiver_reg, R19_method, temp1, temp2, for_compiler_entry);
310   } else {
311     // The method is a member invoker used by direct method handles.
312     if (VerifyMethodHandles) {
313       // make sure the trailing argument really is a MemberName (caller responsibility)
314       verify_klass(_masm, member_reg, SystemDictionary::WK_KLASS_ENUM_NAME(MemberName_klass),
315                    temp1, temp2,
316                    &quot;MemberName required for invokeVirtual etc.&quot;);
317     }
318 
319     Register temp1_recv_klass = temp1;
320     if (iid != vmIntrinsics::_linkToStatic) {
<span class="line-modified">321       __ verify_oop(receiver_reg, FILE_AND_LINE);</span>
322       if (iid == vmIntrinsics::_linkToSpecial) {
323         // Don&#39;t actually load the klass; just null-check the receiver.
324         __ null_check_throw(receiver_reg, -1, temp1,
325                             Interpreter::throw_NullPointerException_entry());
326       } else {
327         // load receiver klass itself
328         __ null_check_throw(receiver_reg, oopDesc::klass_offset_in_bytes(), temp1,
329                             Interpreter::throw_NullPointerException_entry());
330         __ load_klass(temp1_recv_klass, receiver_reg);
331         __ verify_klass_ptr(temp1_recv_klass);
332       }
333       BLOCK_COMMENT(&quot;check_receiver {&quot;);
334       // The receiver for the MemberName must be in receiver_reg.
335       // Check the receiver against the MemberName.clazz
336       if (VerifyMethodHandles &amp;&amp; iid == vmIntrinsics::_linkToSpecial) {
337         // Did not load it above...
338         __ load_klass(temp1_recv_klass, receiver_reg);
339         __ verify_klass_ptr(temp1_recv_klass);
340       }
341       if (VerifyMethodHandles &amp;&amp; iid != vmIntrinsics::_linkToInterface) {
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_ppc.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/c1_MacroAssembler_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRGenerator_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Runtime1_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/c1_MacroAssembler_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 29 #include &quot;c1/c1_Runtime1.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;
 32 #include &quot;interpreter/interpreter.hpp&quot;
 33 #include &quot;oops/arrayOop.hpp&quot;
<span class="line-modified"> 34 #include &quot;oops/markOop.hpp&quot;</span>
 35 #include &quot;runtime/basicLock.hpp&quot;
 36 #include &quot;runtime/biasedLocking.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 #include &quot;runtime/sharedRuntime.hpp&quot;
 39 #include &quot;runtime/stubRoutines.hpp&quot;
 40 #include &quot;utilities/align.hpp&quot;
<span class="line-modified"> 41 </span>
 42 
 43 void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
 44   const Register temp_reg = R12_scratch2;
 45   Label Lmiss;
 46 
<span class="line-modified"> 47   verify_oop(receiver);</span>
 48   MacroAssembler::null_check(receiver, oopDesc::klass_offset_in_bytes(), &amp;Lmiss);
 49   load_klass(temp_reg, receiver);
 50 
 51   if (TrapBasedICMissChecks &amp;&amp; TrapBasedNullChecks) {
 52     trap_ic_miss_check(temp_reg, iCache);
 53   } else {
 54     Label Lok;
 55     cmpd(CCR0, temp_reg, iCache);
 56     beq(CCR0, Lok);
 57     bind(Lmiss);
 58     //load_const_optimized(temp_reg, SharedRuntime::get_ic_miss_stub(), R0);
 59     calculate_address_from_global_toc(temp_reg, SharedRuntime::get_ic_miss_stub(), true, true, false);
 60     mtctr(temp_reg);
 61     bctr();
 62     align(32, 12);
 63     bind(Lok);
 64   }
 65 }
 66 
 67 
</pre>
<hr />
<pre>
 83   push_frame(frame_size_in_bytes, R0); // SP -= frame_size_in_bytes
 84 }
 85 
 86 
 87 void C1_MacroAssembler::verified_entry() {
 88   if (C1Breakpoint) illtrap();
 89   // build frame
 90 }
 91 
 92 
 93 void C1_MacroAssembler::lock_object(Register Rmark, Register Roop, Register Rbox, Register Rscratch, Label&amp; slow_case) {
 94   assert_different_registers(Rmark, Roop, Rbox, Rscratch);
 95 
 96   Label done, cas_failed, slow_int;
 97 
 98   // The following move must be the first instruction of emitted since debug
 99   // information may be generated for it.
100   // Load object header.
101   ld(Rmark, oopDesc::mark_offset_in_bytes(), Roop);
102 
<span class="line-modified">103   verify_oop(Roop);</span>
104 
105   // Save object being locked into the BasicObjectLock...
106   std(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);
107 
108   if (UseBiasedLocking) {
109     biased_locking_enter(CCR0, Roop, Rmark, Rscratch, R0, done, &amp;slow_int);
110   }
111 
112   // ... and mark it unlocked.
<span class="line-modified">113   ori(Rmark, Rmark, markOopDesc::unlocked_value);</span>
114 
115   // Save unlocked object header into the displaced header location on the stack.
116   std(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);
117 
<span class="line-modified">118   // Compare object markOop with Rmark and if equal exchange Rscratch with object markOop.</span>
119   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;cas must take a zero displacement&quot;);
120   cmpxchgd(/*flag=*/CCR0,
121            /*current_value=*/Rscratch,
122            /*compare_value=*/Rmark,
123            /*exchange_value=*/Rbox,
124            /*where=*/Roop/*+0==mark_offset_in_bytes*/,
125            MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,
126            MacroAssembler::cmpxchgx_hint_acquire_lock(),
127            noreg,
128            &amp;cas_failed,
129            /*check without membar and ldarx first*/true);
130   // If compare/exchange succeeded we found an unlocked object and we now have locked it
131   // hence we are done.
132   b(done);
133 
134   bind(slow_int);
135   b(slow_case); // far
136 
137   bind(cas_failed);
138   // We did not find an unlocked object so see if this is a recursive case.
139   sub(Rscratch, Rscratch, R1_SP);
<span class="line-modified">140   load_const_optimized(R0, (~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place));</span>
141   and_(R0/*==0?*/, Rscratch, R0);
142   std(R0/*==0, perhaps*/, BasicLock::displaced_header_offset_in_bytes(), Rbox);
143   bne(CCR0, slow_int);
144 
145   bind(done);
146 }
147 
148 
149 void C1_MacroAssembler::unlock_object(Register Rmark, Register Roop, Register Rbox, Label&amp; slow_case) {
150   assert_different_registers(Rmark, Roop, Rbox);
151 
152   Label slow_int, done;
153 
154   Address mark_addr(Roop, oopDesc::mark_offset_in_bytes());
155   assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
156 
157   if (UseBiasedLocking) {
158     // Load the object out of the BasicObjectLock.
159     ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);
<span class="line-modified">160     verify_oop(Roop);</span>
161     biased_locking_exit(CCR0, Roop, R0, done);
162   }
163   // Test first it it is a fast recursive unlock.
164   ld(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);
165   cmpdi(CCR0, Rmark, 0);
166   beq(CCR0, done);
167   if (!UseBiasedLocking) {
168     // Load object.
169     ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);
<span class="line-modified">170     verify_oop(Roop);</span>
171   }
172 
173   // Check if it is still a light weight lock, this is is true if we see
<span class="line-modified">174   // the stack address of the basicLock in the markOop of the object.</span>
175   cmpxchgd(/*flag=*/CCR0,
176            /*current_value=*/R0,
177            /*compare_value=*/Rbox,
178            /*exchange_value=*/Rmark,
179            /*where=*/Roop,
180            MacroAssembler::MemBarRel,
181            MacroAssembler::cmpxchgx_hint_release_lock(),
182            noreg,
183            &amp;slow_int);
184   b(done);
185   bind(slow_int);
186   b(slow_case); // far
187 
188   // Done
189   bind(done);
190 }
191 
192 
193 void C1_MacroAssembler::try_allocate(
194   Register obj,                        // result: pointer to object after successful allocation
</pre>
<hr />
<pre>
198   Register t2,                         // temp register
199   Label&amp;   slow_case                   // continuation point if fast allocation fails
200 ) {
201   if (UseTLAB) {
202     tlab_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
203   } else {
204     eden_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
205     RegisterOrConstant size_in_bytes = var_size_in_bytes-&gt;is_valid()
206                                        ? RegisterOrConstant(var_size_in_bytes)
207                                        : RegisterOrConstant(con_size_in_bytes);
208     incr_allocated_bytes(size_in_bytes, t1, t2);
209   }
210 }
211 
212 
213 void C1_MacroAssembler::initialize_header(Register obj, Register klass, Register len, Register t1, Register t2) {
214   assert_different_registers(obj, klass, len, t1, t2);
215   if (UseBiasedLocking &amp;&amp; !len-&gt;is_valid()) {
216     ld(t1, in_bytes(Klass::prototype_header_offset()), klass);
217   } else {
<span class="line-modified">218     load_const_optimized(t1, (intx)markOopDesc::prototype());</span>
219   }
220   std(t1, oopDesc::mark_offset_in_bytes(), obj);
221   store_klass(obj, klass);
222   if (len-&gt;is_valid()) {
223     stw(len, arrayOopDesc::length_offset_in_bytes(), obj);
224   } else if (UseCompressedClassPointers) {
225     // Otherwise length is in the class gap.
226     store_klass_gap(obj);
227   }
228 }
229 
230 
231 void C1_MacroAssembler::initialize_body(Register base, Register index) {
232   assert_different_registers(base, index);
233   srdi(index, index, LogBytesPerWord);
234   clear_memory_doubleword(base, index);
235 }
236 
237 void C1_MacroAssembler::initialize_body(Register obj, Register tmp1, Register tmp2,
238                                         int obj_size_in_bytes, int hdr_size_in_bytes) {
</pre>
<hr />
<pre>
299 #endif
300 
301   // Initialize body.
302   if (var_size_in_bytes != noreg) {
303     // Use a loop.
304     addi(t1, obj, hdr_size_in_bytes);                // Compute address of first element.
305     addi(t2, var_size_in_bytes, -hdr_size_in_bytes); // Compute size of body.
306     initialize_body(t1, t2);
307   } else if (con_size_in_bytes &gt; hdr_size_in_bytes) {
308     // Use a loop.
309     initialize_body(obj, t1, t2, con_size_in_bytes, hdr_size_in_bytes);
310   }
311 
312   if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
313     Unimplemented();
314 //    assert(obj == O0, &quot;must be&quot;);
315 //    call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)),
316 //         relocInfo::runtime_call_type);
317   }
318 
<span class="line-modified">319   verify_oop(obj);</span>
320 }
321 
322 
323 void C1_MacroAssembler::allocate_array(
324   Register obj,                        // result: pointer to array after successful allocation
325   Register len,                        // array length
326   Register t1,                         // temp register
327   Register t2,                         // temp register
328   Register t3,                         // temp register
329   int      hdr_size,                   // object header size in words
330   int      elt_size,                   // element size in bytes
331   Register klass,                      // object klass
332   Label&amp;   slow_case                   // continuation point if fast allocation fails
333 ) {
334   assert_different_registers(obj, len, t1, t2, t3, klass);
335 
336   // Determine alignment mask.
337   assert(!(BytesPerWord &amp; 1), &quot;must be a multiple of 2 for masking code to work&quot;);
338   int log2_elt_size = exact_log2(elt_size);
339 
</pre>
<hr />
<pre>
366     tlab_allocate(obj, arr_size, 0, t2, slow_case);
367   } else {
368     eden_allocate(obj, arr_size, 0, t2, t3, slow_case);
369   }
370   initialize_header(obj, klass, len, t2, t3);
371 
372   // Initialize body.
373   const Register base  = t2;
374   const Register index = t3;
375   addi(base, obj, hdr_size * wordSize);               // compute address of first element
376   addi(index, arr_size, -(hdr_size * wordSize));      // compute index = number of bytes to clear
377   initialize_body(base, index);
378 
379   if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
380     Unimplemented();
381     //assert(obj == O0, &quot;must be&quot;);
382     //call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)),
383     //     relocInfo::runtime_call_type);
384   }
385 
<span class="line-modified">386   verify_oop(obj);</span>
387 }
388 
389 
390 #ifndef PRODUCT
391 
392 void C1_MacroAssembler::verify_stack_oop(int stack_offset) {
393   verify_oop_addr((RegisterOrConstant)(stack_offset + STACK_BIAS), R1_SP, &quot;broken oop in stack slot&quot;);
394 }
395 
396 void C1_MacroAssembler::verify_not_null_oop(Register r) {
397   Label not_null;
398   cmpdi(CCR0, r, 0);
399   bne(CCR0, not_null);
400   stop(&quot;non-null oop required&quot;);
401   bind(not_null);
<span class="line-modified">402   if (!VerifyOops) return;</span>
<span class="line-removed">403   verify_oop(r);</span>
404 }
405 
406 #endif // PRODUCT
407 
408 void C1_MacroAssembler::null_check(Register r, Label* Lnull) {
409   if (TrapBasedNullChecks) { // SIGTRAP based
410     trap_null_check(r);
411   } else { // explicit
412     //const address exception_entry = Runtime1::entry_for(Runtime1::throw_null_pointer_exception_id);
413     assert(Lnull != NULL, &quot;must have Label for explicit check&quot;);
414     cmpdi(CCR0, r, 0);
415     bc_far_optimized(Assembler::bcondCRbiIs1, bi0(CCR0, Assembler::equal), *Lnull);
416   }
417 }
418 
419 address C1_MacroAssembler::call_c_with_frame_resize(address dest, int frame_resize) {
420   if (frame_resize) { resize_frame(-frame_resize, R0); }
421 #if defined(ABI_ELFv2)
422   address return_pc = call_c(dest, relocInfo::runtime_call_type);
423 #else
</pre>
</td>
<td>
<hr />
<pre>
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 29 #include &quot;c1/c1_Runtime1.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;
 32 #include &quot;interpreter/interpreter.hpp&quot;
 33 #include &quot;oops/arrayOop.hpp&quot;
<span class="line-modified"> 34 #include &quot;oops/markWord.hpp&quot;</span>
 35 #include &quot;runtime/basicLock.hpp&quot;
 36 #include &quot;runtime/biasedLocking.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 #include &quot;runtime/sharedRuntime.hpp&quot;
 39 #include &quot;runtime/stubRoutines.hpp&quot;
 40 #include &quot;utilities/align.hpp&quot;
<span class="line-modified"> 41 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 42 
 43 void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
 44   const Register temp_reg = R12_scratch2;
 45   Label Lmiss;
 46 
<span class="line-modified"> 47   verify_oop(receiver, FILE_AND_LINE);</span>
 48   MacroAssembler::null_check(receiver, oopDesc::klass_offset_in_bytes(), &amp;Lmiss);
 49   load_klass(temp_reg, receiver);
 50 
 51   if (TrapBasedICMissChecks &amp;&amp; TrapBasedNullChecks) {
 52     trap_ic_miss_check(temp_reg, iCache);
 53   } else {
 54     Label Lok;
 55     cmpd(CCR0, temp_reg, iCache);
 56     beq(CCR0, Lok);
 57     bind(Lmiss);
 58     //load_const_optimized(temp_reg, SharedRuntime::get_ic_miss_stub(), R0);
 59     calculate_address_from_global_toc(temp_reg, SharedRuntime::get_ic_miss_stub(), true, true, false);
 60     mtctr(temp_reg);
 61     bctr();
 62     align(32, 12);
 63     bind(Lok);
 64   }
 65 }
 66 
 67 
</pre>
<hr />
<pre>
 83   push_frame(frame_size_in_bytes, R0); // SP -= frame_size_in_bytes
 84 }
 85 
 86 
 87 void C1_MacroAssembler::verified_entry() {
 88   if (C1Breakpoint) illtrap();
 89   // build frame
 90 }
 91 
 92 
 93 void C1_MacroAssembler::lock_object(Register Rmark, Register Roop, Register Rbox, Register Rscratch, Label&amp; slow_case) {
 94   assert_different_registers(Rmark, Roop, Rbox, Rscratch);
 95 
 96   Label done, cas_failed, slow_int;
 97 
 98   // The following move must be the first instruction of emitted since debug
 99   // information may be generated for it.
100   // Load object header.
101   ld(Rmark, oopDesc::mark_offset_in_bytes(), Roop);
102 
<span class="line-modified">103   verify_oop(Roop, FILE_AND_LINE);</span>
104 
105   // Save object being locked into the BasicObjectLock...
106   std(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);
107 
108   if (UseBiasedLocking) {
109     biased_locking_enter(CCR0, Roop, Rmark, Rscratch, R0, done, &amp;slow_int);
110   }
111 
112   // ... and mark it unlocked.
<span class="line-modified">113   ori(Rmark, Rmark, markWord::unlocked_value);</span>
114 
115   // Save unlocked object header into the displaced header location on the stack.
116   std(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);
117 
<span class="line-modified">118   // Compare object markWord with Rmark and if equal exchange Rscratch with object markWord.</span>
119   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;cas must take a zero displacement&quot;);
120   cmpxchgd(/*flag=*/CCR0,
121            /*current_value=*/Rscratch,
122            /*compare_value=*/Rmark,
123            /*exchange_value=*/Rbox,
124            /*where=*/Roop/*+0==mark_offset_in_bytes*/,
125            MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,
126            MacroAssembler::cmpxchgx_hint_acquire_lock(),
127            noreg,
128            &amp;cas_failed,
129            /*check without membar and ldarx first*/true);
130   // If compare/exchange succeeded we found an unlocked object and we now have locked it
131   // hence we are done.
132   b(done);
133 
134   bind(slow_int);
135   b(slow_case); // far
136 
137   bind(cas_failed);
138   // We did not find an unlocked object so see if this is a recursive case.
139   sub(Rscratch, Rscratch, R1_SP);
<span class="line-modified">140   load_const_optimized(R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));</span>
141   and_(R0/*==0?*/, Rscratch, R0);
142   std(R0/*==0, perhaps*/, BasicLock::displaced_header_offset_in_bytes(), Rbox);
143   bne(CCR0, slow_int);
144 
145   bind(done);
146 }
147 
148 
149 void C1_MacroAssembler::unlock_object(Register Rmark, Register Roop, Register Rbox, Label&amp; slow_case) {
150   assert_different_registers(Rmark, Roop, Rbox);
151 
152   Label slow_int, done;
153 
154   Address mark_addr(Roop, oopDesc::mark_offset_in_bytes());
155   assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
156 
157   if (UseBiasedLocking) {
158     // Load the object out of the BasicObjectLock.
159     ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);
<span class="line-modified">160     verify_oop(Roop, FILE_AND_LINE);</span>
161     biased_locking_exit(CCR0, Roop, R0, done);
162   }
163   // Test first it it is a fast recursive unlock.
164   ld(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);
165   cmpdi(CCR0, Rmark, 0);
166   beq(CCR0, done);
167   if (!UseBiasedLocking) {
168     // Load object.
169     ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);
<span class="line-modified">170     verify_oop(Roop, FILE_AND_LINE);</span>
171   }
172 
173   // Check if it is still a light weight lock, this is is true if we see
<span class="line-modified">174   // the stack address of the basicLock in the markWord of the object.</span>
175   cmpxchgd(/*flag=*/CCR0,
176            /*current_value=*/R0,
177            /*compare_value=*/Rbox,
178            /*exchange_value=*/Rmark,
179            /*where=*/Roop,
180            MacroAssembler::MemBarRel,
181            MacroAssembler::cmpxchgx_hint_release_lock(),
182            noreg,
183            &amp;slow_int);
184   b(done);
185   bind(slow_int);
186   b(slow_case); // far
187 
188   // Done
189   bind(done);
190 }
191 
192 
193 void C1_MacroAssembler::try_allocate(
194   Register obj,                        // result: pointer to object after successful allocation
</pre>
<hr />
<pre>
198   Register t2,                         // temp register
199   Label&amp;   slow_case                   // continuation point if fast allocation fails
200 ) {
201   if (UseTLAB) {
202     tlab_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
203   } else {
204     eden_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
205     RegisterOrConstant size_in_bytes = var_size_in_bytes-&gt;is_valid()
206                                        ? RegisterOrConstant(var_size_in_bytes)
207                                        : RegisterOrConstant(con_size_in_bytes);
208     incr_allocated_bytes(size_in_bytes, t1, t2);
209   }
210 }
211 
212 
213 void C1_MacroAssembler::initialize_header(Register obj, Register klass, Register len, Register t1, Register t2) {
214   assert_different_registers(obj, klass, len, t1, t2);
215   if (UseBiasedLocking &amp;&amp; !len-&gt;is_valid()) {
216     ld(t1, in_bytes(Klass::prototype_header_offset()), klass);
217   } else {
<span class="line-modified">218     load_const_optimized(t1, (intx)markWord::prototype().value());</span>
219   }
220   std(t1, oopDesc::mark_offset_in_bytes(), obj);
221   store_klass(obj, klass);
222   if (len-&gt;is_valid()) {
223     stw(len, arrayOopDesc::length_offset_in_bytes(), obj);
224   } else if (UseCompressedClassPointers) {
225     // Otherwise length is in the class gap.
226     store_klass_gap(obj);
227   }
228 }
229 
230 
231 void C1_MacroAssembler::initialize_body(Register base, Register index) {
232   assert_different_registers(base, index);
233   srdi(index, index, LogBytesPerWord);
234   clear_memory_doubleword(base, index);
235 }
236 
237 void C1_MacroAssembler::initialize_body(Register obj, Register tmp1, Register tmp2,
238                                         int obj_size_in_bytes, int hdr_size_in_bytes) {
</pre>
<hr />
<pre>
299 #endif
300 
301   // Initialize body.
302   if (var_size_in_bytes != noreg) {
303     // Use a loop.
304     addi(t1, obj, hdr_size_in_bytes);                // Compute address of first element.
305     addi(t2, var_size_in_bytes, -hdr_size_in_bytes); // Compute size of body.
306     initialize_body(t1, t2);
307   } else if (con_size_in_bytes &gt; hdr_size_in_bytes) {
308     // Use a loop.
309     initialize_body(obj, t1, t2, con_size_in_bytes, hdr_size_in_bytes);
310   }
311 
312   if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
313     Unimplemented();
314 //    assert(obj == O0, &quot;must be&quot;);
315 //    call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)),
316 //         relocInfo::runtime_call_type);
317   }
318 
<span class="line-modified">319   verify_oop(obj, FILE_AND_LINE);</span>
320 }
321 
322 
323 void C1_MacroAssembler::allocate_array(
324   Register obj,                        // result: pointer to array after successful allocation
325   Register len,                        // array length
326   Register t1,                         // temp register
327   Register t2,                         // temp register
328   Register t3,                         // temp register
329   int      hdr_size,                   // object header size in words
330   int      elt_size,                   // element size in bytes
331   Register klass,                      // object klass
332   Label&amp;   slow_case                   // continuation point if fast allocation fails
333 ) {
334   assert_different_registers(obj, len, t1, t2, t3, klass);
335 
336   // Determine alignment mask.
337   assert(!(BytesPerWord &amp; 1), &quot;must be a multiple of 2 for masking code to work&quot;);
338   int log2_elt_size = exact_log2(elt_size);
339 
</pre>
<hr />
<pre>
366     tlab_allocate(obj, arr_size, 0, t2, slow_case);
367   } else {
368     eden_allocate(obj, arr_size, 0, t2, t3, slow_case);
369   }
370   initialize_header(obj, klass, len, t2, t3);
371 
372   // Initialize body.
373   const Register base  = t2;
374   const Register index = t3;
375   addi(base, obj, hdr_size * wordSize);               // compute address of first element
376   addi(index, arr_size, -(hdr_size * wordSize));      // compute index = number of bytes to clear
377   initialize_body(base, index);
378 
379   if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
380     Unimplemented();
381     //assert(obj == O0, &quot;must be&quot;);
382     //call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)),
383     //     relocInfo::runtime_call_type);
384   }
385 
<span class="line-modified">386   verify_oop(obj, FILE_AND_LINE);</span>
387 }
388 
389 
390 #ifndef PRODUCT
391 
392 void C1_MacroAssembler::verify_stack_oop(int stack_offset) {
393   verify_oop_addr((RegisterOrConstant)(stack_offset + STACK_BIAS), R1_SP, &quot;broken oop in stack slot&quot;);
394 }
395 
396 void C1_MacroAssembler::verify_not_null_oop(Register r) {
397   Label not_null;
398   cmpdi(CCR0, r, 0);
399   bne(CCR0, not_null);
400   stop(&quot;non-null oop required&quot;);
401   bind(not_null);
<span class="line-modified">402   verify_oop(r, FILE_AND_LINE);</span>

403 }
404 
405 #endif // PRODUCT
406 
407 void C1_MacroAssembler::null_check(Register r, Label* Lnull) {
408   if (TrapBasedNullChecks) { // SIGTRAP based
409     trap_null_check(r);
410   } else { // explicit
411     //const address exception_entry = Runtime1::entry_for(Runtime1::throw_null_pointer_exception_id);
412     assert(Lnull != NULL, &quot;must have Label for explicit check&quot;);
413     cmpdi(CCR0, r, 0);
414     bc_far_optimized(Assembler::bcondCRbiIs1, bi0(CCR0, Assembler::equal), *Lnull);
415   }
416 }
417 
418 address C1_MacroAssembler::call_c_with_frame_resize(address dest, int frame_resize) {
419   if (frame_resize) { resize_frame(-frame_resize, R0); }
420 #if defined(ABI_ELFv2)
421   address return_pc = call_c(dest, relocInfo::runtime_call_type);
422 #else
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRGenerator_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Runtime1_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
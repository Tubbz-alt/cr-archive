diff a/src/hotspot/cpu/ppc/macroAssembler_ppc.inline.hpp b/src/hotspot/cpu/ppc/macroAssembler_ppc.inline.hpp
--- a/src/hotspot/cpu/ppc/macroAssembler_ppc.inline.hpp
+++ b/src/hotspot/cpu/ppc/macroAssembler_ppc.inline.hpp
@@ -31,11 +31,13 @@
 #include "asm/codeBuffer.hpp"
 #include "code/codeCache.hpp"
 #include "gc/shared/barrierSet.hpp"
 #include "gc/shared/barrierSetAssembler.hpp"
 #include "oops/accessDecorators.hpp"
+#include "oops/compressedOops.hpp"
 #include "runtime/safepointMechanism.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 inline bool MacroAssembler::is_ld_largeoffset(address a) {
   const int inst1 = *(int *)a;
   const int inst2 = *(int *)(a+4);
   return (is_ld(inst1)) ||
@@ -53,11 +55,11 @@
     return (inv_d1_field(inst1) << 16) + inv_d1_field(inst2);
   }
 }
 
 inline void MacroAssembler::round_to(Register r, int modulus) {
-  assert(is_power_of_2_long((jlong)modulus), "must be power of 2");
+  assert(is_power_of_2((jlong)modulus), "must be power of 2");
   addi(r, r, modulus-1);
   clrrdi(r, r, log2_long((jlong)modulus));
 }
 
 // Move register if destination register and target register are different.
@@ -376,23 +378,23 @@
   access_store_at(T_OBJECT, IN_HEAP | decorators, s1, offs, d, tmp1, tmp2, tmp3, needs_frame);
 }
 
 inline Register MacroAssembler::encode_heap_oop_not_null(Register d, Register src) {
   Register current = (src != noreg) ? src : d; // Oop to be compressed is in d if no src provided.
-  if (Universe::narrow_oop_base_overlaps()) {
-    sub_const_optimized(d, current, Universe::narrow_oop_base(), R0);
+  if (CompressedOops::base_overlaps()) {
+    sub_const_optimized(d, current, CompressedOops::base(), R0);
     current = d;
   }
-  if (Universe::narrow_oop_shift() != 0) {
-    rldicl(d, current, 64-Universe::narrow_oop_shift(), 32);  // Clears the upper bits.
+  if (CompressedOops::shift() != 0) {
+    rldicl(d, current, 64-CompressedOops::shift(), 32);  // Clears the upper bits.
     current = d;
   }
   return current; // Encoded oop is in this register.
 }
 
 inline Register MacroAssembler::encode_heap_oop(Register d, Register src) {
-  if (Universe::narrow_oop_base() != NULL) {
+  if (CompressedOops::base() != NULL) {
     if (VM_Version::has_isel()) {
       cmpdi(CCR0, src, 0);
       Register co = encode_heap_oop_not_null(d, src);
       assert(co == d, "sanity");
       isel_0(d, CCR0, Assembler::equal);
@@ -408,33 +410,33 @@
     return encode_heap_oop_not_null(d, src);
   }
 }
 
 inline Register MacroAssembler::decode_heap_oop_not_null(Register d, Register src) {
-  if (Universe::narrow_oop_base_disjoint() && src != noreg && src != d &&
-      Universe::narrow_oop_shift() != 0) {
-    load_const_optimized(d, Universe::narrow_oop_base(), R0);
-    rldimi(d, src, Universe::narrow_oop_shift(), 32-Universe::narrow_oop_shift());
+  if (CompressedOops::base_disjoint() && src != noreg && src != d &&
+      CompressedOops::shift() != 0) {
+    load_const_optimized(d, CompressedOops::base(), R0);
+    rldimi(d, src, CompressedOops::shift(), 32-CompressedOops::shift());
     return d;
   }
 
   Register current = (src != noreg) ? src : d; // Compressed oop is in d if no src provided.
-  if (Universe::narrow_oop_shift() != 0) {
-    sldi(d, current, Universe::narrow_oop_shift());
+  if (CompressedOops::shift() != 0) {
+    sldi(d, current, CompressedOops::shift());
     current = d;
   }
-  if (Universe::narrow_oop_base() != NULL) {
-    add_const_optimized(d, current, Universe::narrow_oop_base(), R0);
+  if (CompressedOops::base() != NULL) {
+    add_const_optimized(d, current, CompressedOops::base(), R0);
     current = d;
   }
   return current; // Decoded oop is in this register.
 }
 
 inline void MacroAssembler::decode_heap_oop(Register d) {
   Label isNull;
   bool use_isel = false;
-  if (Universe::narrow_oop_base() != NULL) {
+  if (CompressedOops::base() != NULL) {
     cmpwi(CCR0, d, 0);
     if (VM_Version::has_isel()) {
       use_isel = true;
     } else {
       beq(CCR0, isNull);

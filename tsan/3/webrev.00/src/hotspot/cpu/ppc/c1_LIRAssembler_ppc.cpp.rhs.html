<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/c1_LIRAssembler_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2019, SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified">  36 #include &quot;memory/universe.hpp&quot;</span>

  37 #include &quot;nativeInst_ppc.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  38 #include &quot;oops/compressedOops.hpp&quot;</span>
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added">  43 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  44 
  45 #define __ _masm-&gt;
  46 
  47 
  48 const ConditionRegister LIR_Assembler::BOOL_RESULT = CCR5;
  49 
  50 
  51 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  52   Unimplemented(); return false; // Currently not used on this platform.
  53 }
  54 
  55 
  56 LIR_Opr LIR_Assembler::receiverOpr() {
  57   return FrameMap::R3_oop_opr;
  58 }
  59 
  60 
  61 LIR_Opr LIR_Assembler::osrBufferPointer() {
  62   return FrameMap::R3_opr;
  63 }
  64 
  65 
  66 // This specifies the stack pointer decrement needed to build the frame.
  67 int LIR_Assembler::initial_frame_size_in_bytes() const {
  68   return in_bytes(frame_map()-&gt;framesize_in_bytes());
  69 }
  70 
  71 
  72 // Inline cache check: the inline cached class is in inline_cache_reg;
  73 // we fetch the class of the receiver and compare it with the cached class.
  74 // If they do not match we jump to slow case.
  75 int LIR_Assembler::check_icache() {
  76   int offset = __ offset();
  77   __ inline_cache_check(R3_ARG1, R19_inline_cache_reg);
  78   return offset;
  79 }
  80 
<a name="4" id="anc4"></a><span class="line-added">  81 void LIR_Assembler::clinit_barrier(ciMethod* method) {</span>
<span class="line-added">  82   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added">  83 </span>
<span class="line-added">  84   Label L_skip_barrier;</span>
<span class="line-added">  85   Register klass = R20;</span>
<span class="line-added">  86 </span>
<span class="line-added">  87   metadata2reg(method-&gt;holder()-&gt;constant_encoding(), klass);</span>
<span class="line-added">  88   __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added">  89 </span>
<span class="line-added">  90   __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);</span>
<span class="line-added">  91   __ mtctr(klass);</span>
<span class="line-added">  92   __ bctr();</span>
<span class="line-added">  93 </span>
<span class="line-added">  94   __ bind(L_skip_barrier);</span>
<span class="line-added">  95 }</span>
  96 
  97 void LIR_Assembler::osr_entry() {
  98   // On-stack-replacement entry sequence:
  99   //
 100   //   1. Create a new compiled activation.
 101   //   2. Initialize local variables in the compiled activation. The expression
 102   //      stack must be empty at the osr_bci; it is not initialized.
 103   //   3. Jump to the continuation address in compiled code to resume execution.
 104 
 105   // OSR entry point
 106   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 107   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 108   ValueStack* entry_state = osr_entry-&gt;end()-&gt;state();
 109   int number_of_locks = entry_state-&gt;locks_size();
 110 
 111   // Create a frame for the compiled activation.
 112   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 113 
 114   // OSR buffer is
 115   //
 116   // locals[nlocals-1..0]
 117   // monitors[number_of_locks-1..0]
 118   //
 119   // Locals is a direct copy of the interpreter frame so in the osr buffer
 120   // the first slot in the local array is the last local from the interpreter
 121   // and the last slot is local[0] (receiver) from the interpreter.
 122   //
 123   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 124   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 125   // in the interpreter frame (the method lock if a sync method).
 126 
 127   // Initialize monitors in the compiled activation.
 128   //   R3: pointer to osr buffer
 129   //
 130   // All other registers are dead at this point and the locals will be
 131   // copied into place by code emitted in the IR.
 132 
 133   Register OSR_buf = osrBufferPointer()-&gt;as_register();
 134   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 135     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 136       (2 * BytesPerWord) * (number_of_locks - 1);
 137     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 138     // the OSR buffer using 2 word entries: first the lock and then
 139     // the oop.
 140     for (int i = 0; i &lt; number_of_locks; i++) {
 141       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 142 #ifdef ASSERT
 143       // Verify the interpreter&#39;s monitor has a non-null object.
 144       {
 145         Label L;
 146         __ ld(R0, slot_offset + 1*BytesPerWord, OSR_buf);
 147         __ cmpdi(CCR0, R0, 0);
 148         __ bne(CCR0, L);
 149         __ stop(&quot;locked object is NULL&quot;);
 150         __ bind(L);
 151       }
 152 #endif // ASSERT
 153       // Copy the lock field into the compiled activation.
 154       Address ml = frame_map()-&gt;address_for_monitor_lock(i),
 155               mo = frame_map()-&gt;address_for_monitor_object(i);
 156       assert(ml.index() == noreg &amp;&amp; mo.index() == noreg, &quot;sanity&quot;);
 157       __ ld(R0, slot_offset + 0, OSR_buf);
 158       __ std(R0, ml.disp(), ml.base());
 159       __ ld(R0, slot_offset + 1*BytesPerWord, OSR_buf);
 160       __ std(R0, mo.disp(), mo.base());
 161     }
 162   }
 163 }
 164 
 165 
 166 int LIR_Assembler::emit_exception_handler() {
 167   // If the last instruction is a call (typically to do a throw which
 168   // is coming at the end after block reordering) the return address
 169   // must still point into the code area in order to avoid assertion
 170   // failures when searching for the corresponding bci =&gt; add a nop
 171   // (was bug 5/14/1999 - gri).
 172   __ nop();
 173 
 174   // Generate code for the exception handler.
 175   address handler_base = __ start_a_stub(exception_handler_size());
 176 
 177   if (handler_base == NULL) {
 178     // Not enough space left for the handler.
 179     bailout(&quot;exception handler overflow&quot;);
 180     return -1;
 181   }
 182 
 183   int offset = code_offset();
 184   address entry_point = CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::handle_exception_from_callee_id));
 185   //__ load_const_optimized(R0, entry_point);
 186   __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(entry_point));
 187   __ mtctr(R0);
 188   __ bctr();
 189 
 190   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 191   __ end_a_stub();
 192 
 193   return offset;
 194 }
 195 
 196 
 197 // Emit the code to remove the frame from the stack in the exception
 198 // unwind path.
 199 int LIR_Assembler::emit_unwind_handler() {
 200   _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 201 
 202   int offset = code_offset();
 203   bool preserve_exception = method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes();
 204   const Register Rexception = R3 /*LIRGenerator::exceptionOopOpr()*/, Rexception_save = R31;
 205 
 206   // Fetch the exception from TLS and clear out exception related thread state.
 207   __ ld(Rexception, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
 208   __ li(R0, 0);
 209   __ std(R0, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
 210   __ std(R0, in_bytes(JavaThread::exception_pc_offset()), R16_thread);
 211 
 212   __ bind(_unwind_handler_entry);
 213   __ verify_not_null_oop(Rexception);
 214   if (preserve_exception) { __ mr(Rexception_save, Rexception); }
 215 
 216   // Perform needed unlocking
 217   MonitorExitStub* stub = NULL;
 218   if (method()-&gt;is_synchronized()) {
 219     monitor_address(0, FrameMap::R4_opr);
 220     stub = new MonitorExitStub(FrameMap::R4_opr, true, 0);
 221     __ unlock_object(R5, R6, R4, *stub-&gt;entry());
 222     __ bind(*stub-&gt;continuation());
 223   }
 224 
 225   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 226     Unimplemented();
 227   }
 228 
 229   // Dispatch to the unwind logic.
 230   address unwind_stub = Runtime1::entry_for(Runtime1::unwind_exception_id);
 231   //__ load_const_optimized(R0, unwind_stub);
 232   __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(unwind_stub));
 233   if (preserve_exception) { __ mr(Rexception, Rexception_save); }
 234   __ mtctr(R0);
 235   __ bctr();
 236 
 237   // Emit the slow path assembly.
 238   if (stub != NULL) {
 239     stub-&gt;emit_code(this);
 240   }
 241 
 242   return offset;
 243 }
 244 
 245 
 246 int LIR_Assembler::emit_deopt_handler() {
 247   // If the last instruction is a call (typically to do a throw which
 248   // is coming at the end after block reordering) the return address
 249   // must still point into the code area in order to avoid assertion
 250   // failures when searching for the corresponding bci =&gt; add a nop
 251   // (was bug 5/14/1999 - gri).
 252   __ nop();
 253 
 254   // Generate code for deopt handler.
 255   address handler_base = __ start_a_stub(deopt_handler_size());
 256 
 257   if (handler_base == NULL) {
 258     // Not enough space left for the handler.
 259     bailout(&quot;deopt handler overflow&quot;);
 260     return -1;
 261   }
 262 
 263   int offset = code_offset();
 264   __ bl64_patchable(SharedRuntime::deopt_blob()-&gt;unpack(), relocInfo::runtime_call_type);
 265 
 266   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 267   __ end_a_stub();
 268 
 269   return offset;
 270 }
 271 
 272 
 273 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 274   if (o == NULL) {
 275     __ li(reg, 0);
 276   } else {
 277     AddressLiteral addrlit = __ constant_oop_address(o);
 278     __ load_const(reg, addrlit, (reg != R0) ? R0 : noreg);
 279   }
 280 }
 281 
 282 
 283 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 284   // Allocate a new index in table to hold the object once it&#39;s been patched.
 285   int oop_index = __ oop_recorder()-&gt;allocate_oop_index(NULL);
 286   PatchingStub* patch = new PatchingStub(_masm, patching_id(info), oop_index);
 287 
 288   AddressLiteral addrlit((address)NULL, oop_Relocation::spec(oop_index));
 289   __ load_const(reg, addrlit, R0);
 290 
 291   patching_epilog(patch, lir_patch_normal, reg, info);
 292 }
 293 
 294 
 295 void LIR_Assembler::metadata2reg(Metadata* o, Register reg) {
 296   AddressLiteral md = __ constant_metadata_address(o); // Notify OOP recorder (don&#39;t need the relocation)
 297   __ load_const_optimized(reg, md.value(), (reg != R0) ? R0 : noreg);
 298 }
 299 
 300 
 301 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo *info) {
 302   // Allocate a new index in table to hold the klass once it&#39;s been patched.
 303   int index = __ oop_recorder()-&gt;allocate_metadata_index(NULL);
 304   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id, index);
 305 
 306   AddressLiteral addrlit((address)NULL, metadata_Relocation::spec(index));
 307   assert(addrlit.rspec().type() == relocInfo::metadata_type, &quot;must be an metadata reloc&quot;);
 308   __ load_const(reg, addrlit, R0);
 309 
 310   patching_epilog(patch, lir_patch_normal, reg, info);
 311 }
 312 
 313 
 314 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
 315   const bool is_int = result-&gt;is_single_cpu();
 316   Register Rdividend = is_int ? left-&gt;as_register() : left-&gt;as_register_lo();
 317   Register Rdivisor  = noreg;
 318   Register Rscratch  = temp-&gt;as_register();
 319   Register Rresult   = is_int ? result-&gt;as_register() : result-&gt;as_register_lo();
 320   long divisor = -1;
 321 
 322   if (right-&gt;is_register()) {
 323     Rdivisor = is_int ? right-&gt;as_register() : right-&gt;as_register_lo();
 324   } else {
 325     divisor = is_int ? right-&gt;as_constant_ptr()-&gt;as_jint()
 326                      : right-&gt;as_constant_ptr()-&gt;as_jlong();
 327   }
 328 
 329   assert(Rdividend != Rscratch, &quot;&quot;);
 330   assert(Rdivisor  != Rscratch, &quot;&quot;);
 331   assert(code == lir_idiv || code == lir_irem, &quot;Must be irem or idiv&quot;);
 332 
 333   if (Rdivisor == noreg) {
 334     if (divisor == 1) { // stupid, but can happen
 335       if (code == lir_idiv) {
 336         __ mr_if_needed(Rresult, Rdividend);
 337       } else {
 338         __ li(Rresult, 0);
 339       }
 340 
 341     } else if (is_power_of_2(divisor)) {
 342       // Convert division by a power of two into some shifts and logical operations.
 343       int log2 = log2_intptr(divisor);
 344 
 345       // Round towards 0.
 346       if (divisor == 2) {
 347         if (is_int) {
 348           __ srwi(Rscratch, Rdividend, 31);
 349         } else {
 350           __ srdi(Rscratch, Rdividend, 63);
 351         }
 352       } else {
 353         if (is_int) {
 354           __ srawi(Rscratch, Rdividend, 31);
 355         } else {
 356           __ sradi(Rscratch, Rdividend, 63);
 357         }
 358         __ clrldi(Rscratch, Rscratch, 64-log2);
 359       }
 360       __ add(Rscratch, Rdividend, Rscratch);
 361 
 362       if (code == lir_idiv) {
 363         if (is_int) {
 364           __ srawi(Rresult, Rscratch, log2);
 365         } else {
 366           __ sradi(Rresult, Rscratch, log2);
 367         }
 368       } else { // lir_irem
 369         __ clrrdi(Rscratch, Rscratch, log2);
 370         __ sub(Rresult, Rdividend, Rscratch);
 371       }
 372 
 373     } else if (divisor == -1) {
 374       if (code == lir_idiv) {
 375         __ neg(Rresult, Rdividend);
 376       } else {
 377         __ li(Rresult, 0);
 378       }
 379 
 380     } else {
 381       __ load_const_optimized(Rscratch, divisor);
 382       if (code == lir_idiv) {
 383         if (is_int) {
 384           __ divw(Rresult, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 385         } else {
 386           __ divd(Rresult, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 387         }
 388       } else {
 389         assert(Rscratch != R0, &quot;need both&quot;);
 390         if (is_int) {
 391           __ divw(R0, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 392           __ mullw(Rscratch, R0, Rscratch);
 393         } else {
 394           __ divd(R0, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 395           __ mulld(Rscratch, R0, Rscratch);
 396         }
 397         __ sub(Rresult, Rdividend, Rscratch);
 398       }
 399 
 400     }
 401     return;
 402   }
 403 
 404   Label regular, done;
 405   if (is_int) {
 406     __ cmpwi(CCR0, Rdivisor, -1);
 407   } else {
 408     __ cmpdi(CCR0, Rdivisor, -1);
 409   }
 410   __ bne(CCR0, regular);
 411   if (code == lir_idiv) {
 412     __ neg(Rresult, Rdividend);
 413     __ b(done);
 414     __ bind(regular);
 415     if (is_int) {
 416       __ divw(Rresult, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 417     } else {
 418       __ divd(Rresult, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 419     }
 420   } else { // lir_irem
 421     __ li(Rresult, 0);
 422     __ b(done);
 423     __ bind(regular);
 424     if (is_int) {
 425       __ divw(Rscratch, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 426       __ mullw(Rscratch, Rscratch, Rdivisor);
 427     } else {
 428       __ divd(Rscratch, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 429       __ mulld(Rscratch, Rscratch, Rdivisor);
 430     }
 431     __ sub(Rresult, Rdividend, Rscratch);
 432   }
 433   __ bind(done);
 434 }
 435 
 436 
 437 void LIR_Assembler::emit_op3(LIR_Op3* op) {
 438   switch (op-&gt;code()) {
 439   case lir_idiv:
 440   case lir_irem:
 441     arithmetic_idiv(op-&gt;code(), op-&gt;in_opr1(), op-&gt;in_opr2(), op-&gt;in_opr3(),
 442                     op-&gt;result_opr(), op-&gt;info());
 443     break;
 444   case lir_fmad:
 445     __ fmadd(op-&gt;result_opr()-&gt;as_double_reg(), op-&gt;in_opr1()-&gt;as_double_reg(),
 446              op-&gt;in_opr2()-&gt;as_double_reg(), op-&gt;in_opr3()-&gt;as_double_reg());
 447     break;
 448   case lir_fmaf:
 449     __ fmadds(op-&gt;result_opr()-&gt;as_float_reg(), op-&gt;in_opr1()-&gt;as_float_reg(),
 450               op-&gt;in_opr2()-&gt;as_float_reg(), op-&gt;in_opr3()-&gt;as_float_reg());
 451     break;
 452   default: ShouldNotReachHere(); break;
 453   }
 454 }
 455 
 456 
 457 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
 458 #ifdef ASSERT
 459   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
 460   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
 461   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
 462   assert(op-&gt;info() == NULL, &quot;shouldn&#39;t have CodeEmitInfo&quot;);
 463 #endif
 464 
 465   Label *L = op-&gt;label();
 466   if (op-&gt;cond() == lir_cond_always) {
 467     __ b(*L);
 468   } else {
 469     Label done;
 470     bool is_unordered = false;
 471     if (op-&gt;code() == lir_cond_float_branch) {
 472       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
 473       is_unordered = true;
 474     } else {
 475       assert(op-&gt;code() == lir_branch, &quot;just checking&quot;);
 476     }
 477 
 478     bool positive = false;
 479     Assembler::Condition cond = Assembler::equal;
 480     switch (op-&gt;cond()) {
 481       case lir_cond_equal:        positive = true ; cond = Assembler::equal  ; is_unordered = false; break;
 482       case lir_cond_notEqual:     positive = false; cond = Assembler::equal  ; is_unordered = false; break;
 483       case lir_cond_less:         positive = true ; cond = Assembler::less   ; break;
 484       case lir_cond_belowEqual:   assert(op-&gt;code() != lir_cond_float_branch, &quot;&quot;); // fallthru
 485       case lir_cond_lessEqual:    positive = false; cond = Assembler::greater; break;
 486       case lir_cond_greater:      positive = true ; cond = Assembler::greater; break;
 487       case lir_cond_aboveEqual:   assert(op-&gt;code() != lir_cond_float_branch, &quot;&quot;); // fallthru
 488       case lir_cond_greaterEqual: positive = false; cond = Assembler::less   ; break;
 489       default:                    ShouldNotReachHere();
 490     }
 491     int bo = positive ? Assembler::bcondCRbiIs1 : Assembler::bcondCRbiIs0;
 492     int bi = Assembler::bi0(BOOL_RESULT, cond);
 493     if (is_unordered) {
 494       if (positive) {
 495         if (op-&gt;ublock() == op-&gt;block()) {
 496           __ bc_far_optimized(Assembler::bcondCRbiIs1, __ bi0(BOOL_RESULT, Assembler::summary_overflow), *L);
 497         }
 498       } else {
 499         if (op-&gt;ublock() != op-&gt;block()) { __ bso(BOOL_RESULT, done); }
 500       }
 501     }
 502     __ bc_far_optimized(bo, bi, *L);
 503     __ bind(done);
 504   }
 505 }
 506 
 507 
 508 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
 509   Bytecodes::Code code = op-&gt;bytecode();
 510   LIR_Opr src = op-&gt;in_opr(),
 511           dst = op-&gt;result_opr();
 512 
 513   switch(code) {
 514     case Bytecodes::_i2l: {
 515       __ extsw(dst-&gt;as_register_lo(), src-&gt;as_register());
 516       break;
 517     }
 518     case Bytecodes::_l2i: {
 519       __ mr_if_needed(dst-&gt;as_register(), src-&gt;as_register_lo()); // high bits are garbage
 520       break;
 521     }
 522     case Bytecodes::_i2b: {
 523       __ extsb(dst-&gt;as_register(), src-&gt;as_register());
 524       break;
 525     }
 526     case Bytecodes::_i2c: {
 527       __ clrldi(dst-&gt;as_register(), src-&gt;as_register(), 64-16);
 528       break;
 529     }
 530     case Bytecodes::_i2s: {
 531       __ extsh(dst-&gt;as_register(), src-&gt;as_register());
 532       break;
 533     }
 534     case Bytecodes::_i2d:
 535     case Bytecodes::_l2d: {
 536       bool src_in_memory = !VM_Version::has_mtfprd();
 537       FloatRegister rdst = dst-&gt;as_double_reg();
 538       FloatRegister rsrc;
 539       if (src_in_memory) {
 540         rsrc = src-&gt;as_double_reg(); // via mem
 541       } else {
 542         // move src to dst register
 543         if (code == Bytecodes::_i2d) {
 544           __ mtfprwa(rdst, src-&gt;as_register());
 545         } else {
 546           __ mtfprd(rdst, src-&gt;as_register_lo());
 547         }
 548         rsrc = rdst;
 549       }
 550       __ fcfid(rdst, rsrc);
 551       break;
 552     }
 553     case Bytecodes::_i2f:
 554     case Bytecodes::_l2f: {
 555       bool src_in_memory = !VM_Version::has_mtfprd();
 556       FloatRegister rdst = dst-&gt;as_float_reg();
 557       FloatRegister rsrc;
 558       if (src_in_memory) {
 559         rsrc = src-&gt;as_double_reg(); // via mem
 560       } else {
 561         // move src to dst register
 562         if (code == Bytecodes::_i2f) {
 563           __ mtfprwa(rdst, src-&gt;as_register());
 564         } else {
 565           __ mtfprd(rdst, src-&gt;as_register_lo());
 566         }
 567         rsrc = rdst;
 568       }
 569       if (VM_Version::has_fcfids()) {
 570         __ fcfids(rdst, rsrc);
 571       } else {
 572         assert(code == Bytecodes::_i2f, &quot;fcfid+frsp needs fixup code to avoid rounding incompatibility&quot;);
 573         __ fcfid(rdst, rsrc);
 574         __ frsp(rdst, rdst);
 575       }
 576       break;
 577     }
 578     case Bytecodes::_f2d: {
 579       __ fmr_if_needed(dst-&gt;as_double_reg(), src-&gt;as_float_reg());
 580       break;
 581     }
 582     case Bytecodes::_d2f: {
 583       __ frsp(dst-&gt;as_float_reg(), src-&gt;as_double_reg());
 584       break;
 585     }
 586     case Bytecodes::_d2i:
 587     case Bytecodes::_f2i: {
 588       bool dst_in_memory = !VM_Version::has_mtfprd();
 589       FloatRegister rsrc = (code == Bytecodes::_d2i) ? src-&gt;as_double_reg() : src-&gt;as_float_reg();
 590       Address       addr = dst_in_memory ? frame_map()-&gt;address_for_slot(dst-&gt;double_stack_ix()) : NULL;
 591       Label L;
 592       // Result must be 0 if value is NaN; test by comparing value to itself.
 593       __ fcmpu(CCR0, rsrc, rsrc);
 594       if (dst_in_memory) {
 595         __ li(R0, 0); // 0 in case of NAN
 596         __ std(R0, addr.disp(), addr.base());
 597       } else {
 598         __ li(dst-&gt;as_register(), 0);
 599       }
 600       __ bso(CCR0, L);
 601       __ fctiwz(rsrc, rsrc); // USE_KILL
 602       if (dst_in_memory) {
 603         __ stfd(rsrc, addr.disp(), addr.base());
 604       } else {
 605         __ mffprd(dst-&gt;as_register(), rsrc);
 606       }
 607       __ bind(L);
 608       break;
 609     }
 610     case Bytecodes::_d2l:
 611     case Bytecodes::_f2l: {
 612       bool dst_in_memory = !VM_Version::has_mtfprd();
 613       FloatRegister rsrc = (code == Bytecodes::_d2l) ? src-&gt;as_double_reg() : src-&gt;as_float_reg();
 614       Address       addr = dst_in_memory ? frame_map()-&gt;address_for_slot(dst-&gt;double_stack_ix()) : NULL;
 615       Label L;
 616       // Result must be 0 if value is NaN; test by comparing value to itself.
 617       __ fcmpu(CCR0, rsrc, rsrc);
 618       if (dst_in_memory) {
 619         __ li(R0, 0); // 0 in case of NAN
 620         __ std(R0, addr.disp(), addr.base());
 621       } else {
 622         __ li(dst-&gt;as_register_lo(), 0);
 623       }
 624       __ bso(CCR0, L);
 625       __ fctidz(rsrc, rsrc); // USE_KILL
 626       if (dst_in_memory) {
 627         __ stfd(rsrc, addr.disp(), addr.base());
 628       } else {
 629         __ mffprd(dst-&gt;as_register_lo(), rsrc);
 630       }
 631       __ bind(L);
 632       break;
 633     }
 634 
 635     default: ShouldNotReachHere();
 636   }
 637 }
 638 
 639 
 640 void LIR_Assembler::align_call(LIR_Code) {
 641   // do nothing since all instructions are word aligned on ppc
 642 }
 643 
 644 
 645 bool LIR_Assembler::emit_trampoline_stub_for_call(address target, Register Rtoc) {
 646   int start_offset = __ offset();
 647   // Put the entry point as a constant into the constant pool.
 648   const address entry_point_toc_addr   = __ address_constant(target, RelocationHolder::none);
 649   if (entry_point_toc_addr == NULL) {
 650     bailout(&quot;const section overflow&quot;);
 651     return false;
 652   }
 653   const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 654 
 655   // Emit the trampoline stub which will be related to the branch-and-link below.
 656   address stub = __ emit_trampoline_stub(entry_point_toc_offset, start_offset, Rtoc);
 657   if (!stub) {
 658     bailout(&quot;no space for trampoline stub&quot;);
 659     return false;
 660   }
 661   return true;
 662 }
 663 
 664 
 665 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
 666   assert(rtype==relocInfo::opt_virtual_call_type || rtype==relocInfo::static_call_type, &quot;unexpected rtype&quot;);
 667 
 668   bool success = emit_trampoline_stub_for_call(op-&gt;addr());
 669   if (!success) { return; }
 670 
 671   __ relocate(rtype);
 672   // Note: At this point we do not have the address of the trampoline
 673   // stub, and the entry point might be too far away for bl, so __ pc()
 674   // serves as dummy and the bl will be patched later.
 675   __ code()-&gt;set_insts_mark();
 676   __ bl(__ pc());
 677   add_call_info(code_offset(), op-&gt;info());
 678 }
 679 
 680 
 681 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
 682   __ calculate_address_from_global_toc(R2_TOC, __ method_toc());
 683 
 684   // Virtual call relocation will point to ic load.
 685   address virtual_call_meta_addr = __ pc();
 686   // Load a clear inline cache.
 687   AddressLiteral empty_ic((address) Universe::non_oop_word());
 688   bool success = __ load_const_from_method_toc(R19_inline_cache_reg, empty_ic, R2_TOC);
 689   if (!success) {
 690     bailout(&quot;const section overflow&quot;);
 691     return;
 692   }
 693   // Call to fixup routine. Fixup routine uses ScopeDesc info
 694   // to determine who we intended to call.
 695   __ relocate(virtual_call_Relocation::spec(virtual_call_meta_addr));
 696 
 697   success = emit_trampoline_stub_for_call(op-&gt;addr(), R2_TOC);
 698   if (!success) { return; }
 699 
 700   // Note: At this point we do not have the address of the trampoline
 701   // stub, and the entry point might be too far away for bl, so __ pc()
 702   // serves as dummy and the bl will be patched later.
 703   __ bl(__ pc());
 704   add_call_info(code_offset(), op-&gt;info());
 705 }
 706 
 707 
 708 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
 709   ShouldNotReachHere(); // ic_call is used instead.
 710 }
 711 
 712 
 713 void LIR_Assembler::explicit_null_check(Register addr, CodeEmitInfo* info) {
 714   ImplicitNullCheckStub* stub = new ImplicitNullCheckStub(code_offset(), info);
 715   __ null_check(addr, stub-&gt;entry());
 716   append_code_stub(stub);
 717 }
 718 
 719 
 720 // Attention: caller must encode oop if needed
 721 int LIR_Assembler::store(LIR_Opr from_reg, Register base, int offset, BasicType type, bool wide, bool unaligned) {
 722   int store_offset;
 723   if (!Assembler::is_simm16(offset)) {
 724     // For offsets larger than a simm16 we setup the offset.
 725     assert(wide &amp;&amp; !from_reg-&gt;is_same_register(FrameMap::R0_opr), &quot;large offset only supported in special case&quot;);
 726     __ load_const_optimized(R0, offset);
 727     store_offset = store(from_reg, base, R0, type, wide);
 728   } else {
 729     store_offset = code_offset();
 730     switch (type) {
 731       case T_BOOLEAN: // fall through
 732       case T_BYTE  : __ stb(from_reg-&gt;as_register(), offset, base); break;
 733       case T_CHAR  :
 734       case T_SHORT : __ sth(from_reg-&gt;as_register(), offset, base); break;
 735       case T_INT   : __ stw(from_reg-&gt;as_register(), offset, base); break;
 736       case T_LONG  : __ std(from_reg-&gt;as_register_lo(), offset, base); break;
 737       case T_ADDRESS:
 738       case T_METADATA: __ std(from_reg-&gt;as_register(), offset, base); break;
 739       case T_ARRAY : // fall through
 740       case T_OBJECT:
 741         {
 742           if (UseCompressedOops &amp;&amp; !wide) {
 743             // Encoding done in caller
 744             __ stw(from_reg-&gt;as_register(), offset, base);
<a name="5" id="anc5"></a><span class="line-added"> 745             __ verify_coop(from_reg-&gt;as_register(), FILE_AND_LINE);</span>
 746           } else {
 747             __ std(from_reg-&gt;as_register(), offset, base);
<a name="6" id="anc6"></a><span class="line-added"> 748             __ verify_oop(from_reg-&gt;as_register(), FILE_AND_LINE);</span>
 749           }
<a name="7" id="anc7"></a>
 750           break;
 751         }
 752       case T_FLOAT : __ stfs(from_reg-&gt;as_float_reg(), offset, base); break;
 753       case T_DOUBLE: __ stfd(from_reg-&gt;as_double_reg(), offset, base); break;
 754       default      : ShouldNotReachHere();
 755     }
 756   }
 757   return store_offset;
 758 }
 759 
 760 
 761 // Attention: caller must encode oop if needed
 762 int LIR_Assembler::store(LIR_Opr from_reg, Register base, Register disp, BasicType type, bool wide) {
 763   int store_offset = code_offset();
 764   switch (type) {
 765     case T_BOOLEAN: // fall through
 766     case T_BYTE  : __ stbx(from_reg-&gt;as_register(), base, disp); break;
 767     case T_CHAR  :
 768     case T_SHORT : __ sthx(from_reg-&gt;as_register(), base, disp); break;
 769     case T_INT   : __ stwx(from_reg-&gt;as_register(), base, disp); break;
 770     case T_LONG  :
 771 #ifdef _LP64
 772       __ stdx(from_reg-&gt;as_register_lo(), base, disp);
 773 #else
 774       Unimplemented();
 775 #endif
 776       break;
 777     case T_ADDRESS:
 778       __ stdx(from_reg-&gt;as_register(), base, disp);
 779       break;
 780     case T_ARRAY : // fall through
 781     case T_OBJECT:
 782       {
 783         if (UseCompressedOops &amp;&amp; !wide) {
 784           // Encoding done in caller.
 785           __ stwx(from_reg-&gt;as_register(), base, disp);
<a name="8" id="anc8"></a><span class="line-added"> 786           __ verify_coop(from_reg-&gt;as_register(), FILE_AND_LINE); // kills R0</span>
 787         } else {
 788           __ stdx(from_reg-&gt;as_register(), base, disp);
<a name="9" id="anc9"></a><span class="line-added"> 789           __ verify_oop(from_reg-&gt;as_register(), FILE_AND_LINE); // kills R0</span>
 790         }
<a name="10" id="anc10"></a>
 791         break;
 792       }
 793     case T_FLOAT : __ stfsx(from_reg-&gt;as_float_reg(), base, disp); break;
 794     case T_DOUBLE: __ stfdx(from_reg-&gt;as_double_reg(), base, disp); break;
 795     default      : ShouldNotReachHere();
 796   }
 797   return store_offset;
 798 }
 799 
 800 
 801 int LIR_Assembler::load(Register base, int offset, LIR_Opr to_reg, BasicType type, bool wide, bool unaligned) {
 802   int load_offset;
 803   if (!Assembler::is_simm16(offset)) {
 804     // For offsets larger than a simm16 we setup the offset.
 805     __ load_const_optimized(R0, offset);
 806     load_offset = load(base, R0, to_reg, type, wide);
 807   } else {
 808     load_offset = code_offset();
 809     switch(type) {
 810       case T_BOOLEAN: // fall through
 811       case T_BYTE  :   __ lbz(to_reg-&gt;as_register(), offset, base);
 812                        __ extsb(to_reg-&gt;as_register(), to_reg-&gt;as_register()); break;
 813       case T_CHAR  :   __ lhz(to_reg-&gt;as_register(), offset, base); break;
 814       case T_SHORT :   __ lha(to_reg-&gt;as_register(), offset, base); break;
 815       case T_INT   :   __ lwa(to_reg-&gt;as_register(), offset, base); break;
 816       case T_LONG  :   __ ld(to_reg-&gt;as_register_lo(), offset, base); break;
 817       case T_METADATA: __ ld(to_reg-&gt;as_register(), offset, base); break;
 818       case T_ADDRESS:
 819         if (offset == oopDesc::klass_offset_in_bytes() &amp;&amp; UseCompressedClassPointers) {
 820           __ lwz(to_reg-&gt;as_register(), offset, base);
 821           __ decode_klass_not_null(to_reg-&gt;as_register());
 822         } else {
 823           __ ld(to_reg-&gt;as_register(), offset, base);
 824         }
 825         break;
 826       case T_ARRAY : // fall through
 827       case T_OBJECT:
 828         {
 829           if (UseCompressedOops &amp;&amp; !wide) {
 830             __ lwz(to_reg-&gt;as_register(), offset, base);
 831             __ decode_heap_oop(to_reg-&gt;as_register());
 832           } else {
 833             __ ld(to_reg-&gt;as_register(), offset, base);
 834           }
<a name="11" id="anc11"></a><span class="line-modified"> 835           __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);</span>
 836           break;
 837         }
 838       case T_FLOAT:  __ lfs(to_reg-&gt;as_float_reg(), offset, base); break;
 839       case T_DOUBLE: __ lfd(to_reg-&gt;as_double_reg(), offset, base); break;
 840       default      : ShouldNotReachHere();
 841     }
 842   }
 843   return load_offset;
 844 }
 845 
 846 
 847 int LIR_Assembler::load(Register base, Register disp, LIR_Opr to_reg, BasicType type, bool wide) {
 848   int load_offset = code_offset();
 849   switch(type) {
 850     case T_BOOLEAN: // fall through
 851     case T_BYTE  :  __ lbzx(to_reg-&gt;as_register(), base, disp);
 852                     __ extsb(to_reg-&gt;as_register(), to_reg-&gt;as_register()); break;
 853     case T_CHAR  :  __ lhzx(to_reg-&gt;as_register(), base, disp); break;
 854     case T_SHORT :  __ lhax(to_reg-&gt;as_register(), base, disp); break;
 855     case T_INT   :  __ lwax(to_reg-&gt;as_register(), base, disp); break;
 856     case T_ADDRESS: __ ldx(to_reg-&gt;as_register(), base, disp); break;
 857     case T_ARRAY : // fall through
 858     case T_OBJECT:
 859       {
 860         if (UseCompressedOops &amp;&amp; !wide) {
 861           __ lwzx(to_reg-&gt;as_register(), base, disp);
 862           __ decode_heap_oop(to_reg-&gt;as_register());
 863         } else {
 864           __ ldx(to_reg-&gt;as_register(), base, disp);
 865         }
<a name="12" id="anc12"></a><span class="line-modified"> 866         __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);</span>
 867         break;
 868       }
 869     case T_FLOAT:  __ lfsx(to_reg-&gt;as_float_reg() , base, disp); break;
 870     case T_DOUBLE: __ lfdx(to_reg-&gt;as_double_reg(), base, disp); break;
 871     case T_LONG  :
 872 #ifdef _LP64
 873       __ ldx(to_reg-&gt;as_register_lo(), base, disp);
 874 #else
 875       Unimplemented();
 876 #endif
 877       break;
 878     default      : ShouldNotReachHere();
 879   }
 880   return load_offset;
 881 }
 882 
 883 
 884 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 885   LIR_Const* c = src-&gt;as_constant_ptr();
 886   Register src_reg = R0;
 887   switch (c-&gt;type()) {
 888     case T_INT:
 889     case T_FLOAT: {
 890       int value = c-&gt;as_jint_bits();
 891       __ load_const_optimized(src_reg, value);
 892       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 893       __ stw(src_reg, addr.disp(), addr.base());
 894       break;
 895     }
 896     case T_ADDRESS: {
 897       int value = c-&gt;as_jint_bits();
 898       __ load_const_optimized(src_reg, value);
 899       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 900       __ std(src_reg, addr.disp(), addr.base());
 901       break;
 902     }
 903     case T_OBJECT: {
 904       jobject2reg(c-&gt;as_jobject(), src_reg);
 905       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 906       __ std(src_reg, addr.disp(), addr.base());
 907       break;
 908     }
 909     case T_LONG:
 910     case T_DOUBLE: {
 911       int value = c-&gt;as_jlong_bits();
 912       __ load_const_optimized(src_reg, value);
 913       Address addr = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
 914       __ std(src_reg, addr.disp(), addr.base());
 915       break;
 916     }
 917     default:
 918       Unimplemented();
 919   }
 920 }
 921 
 922 
 923 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 924   LIR_Const* c = src-&gt;as_constant_ptr();
 925   LIR_Address* addr = dest-&gt;as_address_ptr();
 926   Register base = addr-&gt;base()-&gt;as_pointer_register();
 927   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 928   int offset = -1;
 929   // Null check for large offsets in LIRGenerator::do_StoreField.
 930   bool needs_explicit_null_check = !ImplicitNullChecks;
 931 
 932   if (info != NULL &amp;&amp; needs_explicit_null_check) {
 933     explicit_null_check(base, info);
 934   }
 935 
 936   switch (c-&gt;type()) {
 937     case T_FLOAT: type = T_INT;
 938     case T_INT:
 939     case T_ADDRESS: {
 940       tmp = FrameMap::R0_opr;
 941       __ load_const_optimized(tmp-&gt;as_register(), c-&gt;as_jint_bits());
 942       break;
 943     }
 944     case T_DOUBLE: type = T_LONG;
 945     case T_LONG: {
 946       tmp = FrameMap::R0_long_opr;
 947       __ load_const_optimized(tmp-&gt;as_register_lo(), c-&gt;as_jlong_bits());
 948       break;
 949     }
 950     case T_OBJECT: {
 951       tmp = FrameMap::R0_opr;
 952       if (UseCompressedOops &amp;&amp; !wide &amp;&amp; c-&gt;as_jobject() != NULL) {
 953         AddressLiteral oop_addr = __ constant_oop_address(c-&gt;as_jobject());
 954         __ lis(R0, oop_addr.value() &gt;&gt; 16); // Don&#39;t care about sign extend (will use stw).
 955         __ relocate(oop_addr.rspec(), /*compressed format*/ 1);
 956         __ ori(R0, R0, oop_addr.value() &amp; 0xffff);
 957       } else {
 958         jobject2reg(c-&gt;as_jobject(), R0);
 959       }
 960       break;
 961     }
 962     default:
 963       Unimplemented();
 964   }
 965 
 966   // Handle either reg+reg or reg+disp address.
 967   if (addr-&gt;index()-&gt;is_valid()) {
 968     assert(addr-&gt;disp() == 0, &quot;must be zero&quot;);
 969     offset = store(tmp, base, addr-&gt;index()-&gt;as_pointer_register(), type, wide);
 970   } else {
 971     assert(Assembler::is_simm16(addr-&gt;disp()), &quot;can&#39;t handle larger addresses&quot;);
 972     offset = store(tmp, base, addr-&gt;disp(), type, wide, false);
 973   }
 974 
 975   if (info != NULL) {
 976     assert(offset != -1, &quot;offset should&#39;ve been set&quot;);
 977     if (!needs_explicit_null_check) {
 978       add_debug_info_for_null_check(offset, info);
 979     }
 980   }
 981 }
 982 
 983 
 984 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 985   LIR_Const* c = src-&gt;as_constant_ptr();
 986   LIR_Opr to_reg = dest;
 987 
 988   switch (c-&gt;type()) {
 989     case T_INT: {
 990       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 991       __ load_const_optimized(dest-&gt;as_register(), c-&gt;as_jint(), R0);
 992       break;
 993     }
 994     case T_ADDRESS: {
 995       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 996       __ load_const_optimized(dest-&gt;as_register(), c-&gt;as_jint(), R0);  // Yes, as_jint ...
 997       break;
 998     }
 999     case T_LONG: {
1000       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
1001       __ load_const_optimized(dest-&gt;as_register_lo(), c-&gt;as_jlong(), R0);
1002       break;
1003     }
1004 
1005     case T_OBJECT: {
1006       if (patch_code == lir_patch_none) {
1007         jobject2reg(c-&gt;as_jobject(), to_reg-&gt;as_register());
1008       } else {
1009         jobject2reg_with_patching(to_reg-&gt;as_register(), info);
1010       }
1011       break;
1012     }
1013 
1014     case T_METADATA:
1015       {
1016         if (patch_code == lir_patch_none) {
1017           metadata2reg(c-&gt;as_metadata(), to_reg-&gt;as_register());
1018         } else {
1019           klass2reg_with_patching(to_reg-&gt;as_register(), info);
1020         }
1021       }
1022       break;
1023 
1024     case T_FLOAT:
1025       {
1026         if (to_reg-&gt;is_single_fpu()) {
1027           address const_addr = __ float_constant(c-&gt;as_jfloat());
1028           if (const_addr == NULL) {
1029             bailout(&quot;const section overflow&quot;);
1030             break;
1031           }
1032           RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1033           __ relocate(rspec);
1034           __ load_const(R0, const_addr);
1035           __ lfsx(to_reg-&gt;as_float_reg(), R0);
1036         } else {
1037           assert(to_reg-&gt;is_single_cpu(), &quot;Must be a cpu register.&quot;);
1038           __ load_const_optimized(to_reg-&gt;as_register(), jint_cast(c-&gt;as_jfloat()), R0);
1039         }
1040       }
1041       break;
1042 
1043     case T_DOUBLE:
1044       {
1045         if (to_reg-&gt;is_double_fpu()) {
1046           address const_addr = __ double_constant(c-&gt;as_jdouble());
1047           if (const_addr == NULL) {
1048             bailout(&quot;const section overflow&quot;);
1049             break;
1050           }
1051           RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1052           __ relocate(rspec);
1053           __ load_const(R0, const_addr);
1054           __ lfdx(to_reg-&gt;as_double_reg(), R0);
1055         } else {
1056           assert(to_reg-&gt;is_double_cpu(), &quot;Must be a long register.&quot;);
1057           __ load_const_optimized(to_reg-&gt;as_register_lo(), jlong_cast(c-&gt;as_jdouble()), R0);
1058         }
1059       }
1060       break;
1061 
1062     default:
1063       ShouldNotReachHere();
1064   }
1065 }
1066 
1067 
1068 Address LIR_Assembler::as_Address(LIR_Address* addr) {
1069   Unimplemented(); return Address();
1070 }
1071 
1072 
1073 inline RegisterOrConstant index_or_disp(LIR_Address* addr) {
1074   if (addr-&gt;index()-&gt;is_illegal()) {
1075     return (RegisterOrConstant)(addr-&gt;disp());
1076   } else {
1077     return (RegisterOrConstant)(addr-&gt;index()-&gt;as_pointer_register());
1078   }
1079 }
1080 
1081 
1082 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1083   const Register tmp = R0;
1084   switch (type) {
1085     case T_INT:
1086     case T_FLOAT: {
1087       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1088       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1089       __ lwz(tmp, from.disp(), from.base());
1090       __ stw(tmp, to.disp(), to.base());
1091       break;
1092     }
1093     case T_ADDRESS:
1094     case T_OBJECT: {
1095       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1096       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1097       __ ld(tmp, from.disp(), from.base());
1098       __ std(tmp, to.disp(), to.base());
1099       break;
1100     }
1101     case T_LONG:
1102     case T_DOUBLE: {
1103       Address from = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1104       Address to   = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
1105       __ ld(tmp, from.disp(), from.base());
1106       __ std(tmp, to.disp(), to.base());
1107       break;
1108     }
1109 
1110     default:
1111       ShouldNotReachHere();
1112   }
1113 }
1114 
1115 
1116 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
1117   Unimplemented(); return Address();
1118 }
1119 
1120 
1121 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
1122   Unimplemented(); return Address();
1123 }
1124 
1125 
1126 void LIR_Assembler::mem2reg(LIR_Opr src_opr, LIR_Opr dest, BasicType type,
1127                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool unaligned) {
1128 
1129   assert(type != T_METADATA, &quot;load of metadata ptr not supported&quot;);
1130   LIR_Address* addr = src_opr-&gt;as_address_ptr();
1131   LIR_Opr to_reg = dest;
1132 
1133   Register src = addr-&gt;base()-&gt;as_pointer_register();
1134   Register disp_reg = noreg;
1135   int disp_value = addr-&gt;disp();
1136   bool needs_patching = (patch_code != lir_patch_none);
1137   // null check for large offsets in LIRGenerator::do_LoadField
1138   bool needs_explicit_null_check = !os::zero_page_read_protected() || !ImplicitNullChecks;
1139 
1140   if (info != NULL &amp;&amp; needs_explicit_null_check) {
1141     explicit_null_check(src, info);
1142   }
1143 
1144   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
<a name="13" id="anc13"></a><span class="line-modified">1145     __ verify_oop(src, FILE_AND_LINE);</span>
1146   }
1147 
1148   PatchingStub* patch = NULL;
1149   if (needs_patching) {
1150     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1151     assert(!to_reg-&gt;is_double_cpu() ||
1152            patch_code == lir_patch_none ||
1153            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1154   }
1155 
1156   if (addr-&gt;index()-&gt;is_illegal()) {
1157     if (!Assembler::is_simm16(disp_value)) {
1158       if (needs_patching) {
1159         __ load_const32(R0, 0); // patchable int
1160       } else {
1161         __ load_const_optimized(R0, disp_value);
1162       }
1163       disp_reg = R0;
1164     }
1165   } else {
1166     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1167     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1168   }
1169 
1170   // Remember the offset of the load. The patching_epilog must be done
1171   // before the call to add_debug_info, otherwise the PcDescs don&#39;t get
1172   // entered in increasing order.
1173   int offset;
1174 
1175   if (disp_reg == noreg) {
1176     assert(Assembler::is_simm16(disp_value), &quot;should have set this up&quot;);
1177     offset = load(src, disp_value, to_reg, type, wide, unaligned);
1178   } else {
1179     assert(!unaligned, &quot;unexpected&quot;);
1180     offset = load(src, disp_reg, to_reg, type, wide);
1181   }
1182 
1183   if (patch != NULL) {
1184     patching_epilog(patch, patch_code, src, info);
1185   }
1186   if (info != NULL &amp;&amp; !needs_explicit_null_check) {
1187     add_debug_info_for_null_check(offset, info);
1188   }
1189 }
1190 
1191 
1192 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1193   Address addr;
1194   if (src-&gt;is_single_word()) {
1195     addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1196   } else if (src-&gt;is_double_word())  {
1197     addr = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1198   }
1199 
1200   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1201   load(addr.base(), addr.disp(), dest, dest-&gt;type(), true /*wide*/, unaligned);
1202 }
1203 
1204 
1205 void LIR_Assembler::reg2stack(LIR_Opr from_reg, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
1206   Address addr;
1207   if (dest-&gt;is_single_word()) {
1208     addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1209   } else if (dest-&gt;is_double_word())  {
1210     addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1211   }
1212   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1213   store(from_reg, addr.base(), addr.disp(), from_reg-&gt;type(), true /*wide*/, unaligned);
1214 }
1215 
1216 
1217 void LIR_Assembler::reg2reg(LIR_Opr from_reg, LIR_Opr to_reg) {
1218   if (from_reg-&gt;is_float_kind() &amp;&amp; to_reg-&gt;is_float_kind()) {
1219     if (from_reg-&gt;is_double_fpu()) {
1220       // double to double moves
1221       assert(to_reg-&gt;is_double_fpu(), &quot;should match&quot;);
1222       __ fmr_if_needed(to_reg-&gt;as_double_reg(), from_reg-&gt;as_double_reg());
1223     } else {
1224       // float to float moves
1225       assert(to_reg-&gt;is_single_fpu(), &quot;should match&quot;);
1226       __ fmr_if_needed(to_reg-&gt;as_float_reg(), from_reg-&gt;as_float_reg());
1227     }
1228   } else if (!from_reg-&gt;is_float_kind() &amp;&amp; !to_reg-&gt;is_float_kind()) {
1229     if (from_reg-&gt;is_double_cpu()) {
1230       __ mr_if_needed(to_reg-&gt;as_pointer_register(), from_reg-&gt;as_pointer_register());
1231     } else if (to_reg-&gt;is_double_cpu()) {
1232       // int to int moves
1233       __ mr_if_needed(to_reg-&gt;as_register_lo(), from_reg-&gt;as_register());
1234     } else {
1235       // int to int moves
1236       __ mr_if_needed(to_reg-&gt;as_register(), from_reg-&gt;as_register());
1237     }
1238   } else {
1239     ShouldNotReachHere();
1240   }
<a name="14" id="anc14"></a><span class="line-modified">1241   if (is_reference_type(to_reg-&gt;type())) {</span>
<span class="line-modified">1242     __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);</span>
1243   }
1244 }
1245 
1246 
1247 void LIR_Assembler::reg2mem(LIR_Opr from_reg, LIR_Opr dest, BasicType type,
1248                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
1249                             bool wide, bool unaligned) {
1250   assert(type != T_METADATA, &quot;store of metadata ptr not supported&quot;);
1251   LIR_Address* addr = dest-&gt;as_address_ptr();
1252 
1253   Register src = addr-&gt;base()-&gt;as_pointer_register();
1254   Register disp_reg = noreg;
1255   int disp_value = addr-&gt;disp();
1256   bool needs_patching = (patch_code != lir_patch_none);
<a name="15" id="anc15"></a><span class="line-modified">1257   bool compress_oop = (is_reference_type(type)) &amp;&amp; UseCompressedOops &amp;&amp; !wide &amp;&amp;</span>
<span class="line-modified">1258                       CompressedOops::mode() != CompressedOops::UnscaledNarrowOop;</span>
1259   bool load_disp = addr-&gt;index()-&gt;is_illegal() &amp;&amp; !Assembler::is_simm16(disp_value);
1260   bool use_R29 = compress_oop &amp;&amp; load_disp; // Avoid register conflict, also do null check before killing R29.
1261   // Null check for large offsets in LIRGenerator::do_StoreField.
1262   bool needs_explicit_null_check = !ImplicitNullChecks || use_R29;
1263 
1264   if (info != NULL &amp;&amp; needs_explicit_null_check) {
1265     explicit_null_check(src, info);
1266   }
1267 
1268   if (addr-&gt;base()-&gt;is_oop_register()) {
<a name="16" id="anc16"></a><span class="line-modified">1269     __ verify_oop(src, FILE_AND_LINE);</span>
1270   }
1271 
1272   PatchingStub* patch = NULL;
1273   if (needs_patching) {
1274     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1275     assert(!from_reg-&gt;is_double_cpu() ||
1276            patch_code == lir_patch_none ||
1277            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1278   }
1279 
1280   if (addr-&gt;index()-&gt;is_illegal()) {
1281     if (load_disp) {
1282       disp_reg = use_R29 ? R29_TOC : R0;
1283       if (needs_patching) {
1284         __ load_const32(disp_reg, 0); // patchable int
1285       } else {
1286         __ load_const_optimized(disp_reg, disp_value);
1287       }
1288     }
1289   } else {
1290     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1291     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1292   }
1293 
1294   // remember the offset of the store. The patching_epilog must be done
1295   // before the call to add_debug_info_for_null_check, otherwise the PcDescs don&#39;t get
1296   // entered in increasing order.
1297   int offset;
1298 
1299   if (compress_oop) {
1300     Register co = __ encode_heap_oop(R0, from_reg-&gt;as_register());
1301     from_reg = FrameMap::as_opr(co);
1302   }
1303 
1304   if (disp_reg == noreg) {
1305     assert(Assembler::is_simm16(disp_value), &quot;should have set this up&quot;);
1306     offset = store(from_reg, src, disp_value, type, wide, unaligned);
1307   } else {
1308     assert(!unaligned, &quot;unexpected&quot;);
1309     offset = store(from_reg, src, disp_reg, type, wide);
1310   }
1311 
1312   if (use_R29) {
1313     __ load_const_optimized(R29_TOC, MacroAssembler::global_toc(), R0); // reinit
1314   }
1315 
1316   if (patch != NULL) {
1317     patching_epilog(patch, patch_code, src, info);
1318   }
1319 
1320   if (info != NULL &amp;&amp; !needs_explicit_null_check) {
1321     add_debug_info_for_null_check(offset, info);
1322   }
1323 }
1324 
1325 
1326 void LIR_Assembler::return_op(LIR_Opr result) {
1327   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
1328   const Register polling_page     = R12;
1329 
1330   // Pop the stack before the safepoint code.
1331   int frame_size = initial_frame_size_in_bytes();
1332   if (Assembler::is_simm(frame_size, 16)) {
1333     __ addi(R1_SP, R1_SP, frame_size);
1334   } else {
1335     __ pop_frame();
1336   }
1337 
1338   if (SafepointMechanism::uses_thread_local_poll()) {
1339     __ ld(polling_page, in_bytes(Thread::polling_page_offset()), R16_thread);
1340   } else {
1341     __ load_const_optimized(polling_page, (long)(address) os::get_polling_page(), R0);
1342   }
1343 
1344   // Restore return pc relative to callers&#39; sp.
1345   __ ld(return_pc, _abi(lr), R1_SP);
1346   // Move return pc to LR.
1347   __ mtlr(return_pc);
1348 
1349   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
1350     __ reserved_stack_check(return_pc);
1351   }
1352 
1353   // We need to mark the code position where the load from the safepoint
1354   // polling page was emitted as relocInfo::poll_return_type here.
1355   __ relocate(relocInfo::poll_return_type);
1356   __ load_from_polling_page(polling_page);
1357 
1358   // Return.
1359   __ blr();
1360 }
1361 
1362 
1363 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
1364   const Register poll_addr = tmp-&gt;as_register();
1365   if (SafepointMechanism::uses_thread_local_poll()) {
1366     __ ld(poll_addr, in_bytes(Thread::polling_page_offset()), R16_thread);
1367   } else {
1368     __ load_const_optimized(poll_addr, (intptr_t)os::get_polling_page(), R0);
1369   }
1370   if (info != NULL) {
1371     add_debug_info_for_branch(info);
1372   }
1373   int offset = __ offset();
1374   __ relocate(relocInfo::poll_type);
1375   __ load_from_polling_page(poll_addr);
1376 
1377   return offset;
1378 }
1379 
1380 
1381 void LIR_Assembler::emit_static_call_stub() {
1382   address call_pc = __ pc();
1383   address stub = __ start_a_stub(static_call_stub_size());
1384   if (stub == NULL) {
1385     bailout(&quot;static call stub overflow&quot;);
1386     return;
1387   }
1388 
1389   // For java_to_interp stubs we use R11_scratch1 as scratch register
1390   // and in call trampoline stubs we use R12_scratch2. This way we
1391   // can distinguish them (see is_NativeCallTrampolineStub_at()).
1392   const Register reg_scratch = R11_scratch1;
1393 
1394   // Create a static stub relocation which relates this stub
1395   // with the call instruction at insts_call_instruction_offset in the
1396   // instructions code-section.
1397   int start = __ offset();
1398   __ relocate(static_stub_Relocation::spec(call_pc));
1399 
1400   // Now, create the stub&#39;s code:
1401   // - load the TOC
1402   // - load the inline cache oop from the constant pool
1403   // - load the call target from the constant pool
1404   // - call
1405   __ calculate_address_from_global_toc(reg_scratch, __ method_toc());
1406   AddressLiteral ic = __ allocate_metadata_address((Metadata *)NULL);
1407   bool success = __ load_const_from_method_toc(R19_inline_cache_reg, ic, reg_scratch, /*fixed_size*/ true);
1408 
1409   if (ReoptimizeCallSequences) {
1410     __ b64_patchable((address)-1, relocInfo::none);
1411   } else {
1412     AddressLiteral a((address)-1);
1413     success = success &amp;&amp; __ load_const_from_method_toc(reg_scratch, a, reg_scratch, /*fixed_size*/ true);
1414     __ mtctr(reg_scratch);
1415     __ bctr();
1416   }
1417   if (!success) {
1418     bailout(&quot;const section overflow&quot;);
1419     return;
1420   }
1421 
1422   assert(__ offset() - start &lt;= static_call_stub_size(), &quot;stub too big&quot;);
1423   __ end_a_stub();
1424 }
1425 
1426 
1427 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1428   bool unsigned_comp = (condition == lir_cond_belowEqual || condition == lir_cond_aboveEqual);
1429   if (opr1-&gt;is_single_fpu()) {
1430     __ fcmpu(BOOL_RESULT, opr1-&gt;as_float_reg(), opr2-&gt;as_float_reg());
1431   } else if (opr1-&gt;is_double_fpu()) {
1432     __ fcmpu(BOOL_RESULT, opr1-&gt;as_double_reg(), opr2-&gt;as_double_reg());
1433   } else if (opr1-&gt;is_single_cpu()) {
1434     if (opr2-&gt;is_constant()) {
1435       switch (opr2-&gt;as_constant_ptr()-&gt;type()) {
1436         case T_INT:
1437           {
1438             jint con = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1439             if (unsigned_comp) {
1440               if (Assembler::is_uimm(con, 16)) {
1441                 __ cmplwi(BOOL_RESULT, opr1-&gt;as_register(), con);
1442               } else {
1443                 __ load_const_optimized(R0, con);
1444                 __ cmplw(BOOL_RESULT, opr1-&gt;as_register(), R0);
1445               }
1446             } else {
1447               if (Assembler::is_simm(con, 16)) {
1448                 __ cmpwi(BOOL_RESULT, opr1-&gt;as_register(), con);
1449               } else {
1450                 __ load_const_optimized(R0, con);
1451                 __ cmpw(BOOL_RESULT, opr1-&gt;as_register(), R0);
1452               }
1453             }
1454           }
1455           break;
1456 
1457         case T_OBJECT:
1458           // There are only equal/notequal comparisons on objects.
1459           {
1460             assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
1461             jobject con = opr2-&gt;as_constant_ptr()-&gt;as_jobject();
1462             if (con == NULL) {
1463               __ cmpdi(BOOL_RESULT, opr1-&gt;as_register(), 0);
1464             } else {
1465               jobject2reg(con, R0);
1466               __ cmpd(BOOL_RESULT, opr1-&gt;as_register(), R0);
1467             }
1468           }
1469           break;
1470 
<a name="17" id="anc17"></a><span class="line-added">1471         case T_METADATA:</span>
<span class="line-added">1472           // We only need, for now, comparison with NULL for metadata.</span>
<span class="line-added">1473           {</span>
<span class="line-added">1474             assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);</span>
<span class="line-added">1475             Metadata* p = opr2-&gt;as_constant_ptr()-&gt;as_metadata();</span>
<span class="line-added">1476             if (p == NULL) {</span>
<span class="line-added">1477               __ cmpdi(BOOL_RESULT, opr1-&gt;as_register(), 0);</span>
<span class="line-added">1478             } else {</span>
<span class="line-added">1479               ShouldNotReachHere();</span>
<span class="line-added">1480             }</span>
<span class="line-added">1481           }</span>
<span class="line-added">1482           break;</span>
<span class="line-added">1483 </span>
1484         default:
1485           ShouldNotReachHere();
1486           break;
1487       }
1488     } else {
<a name="18" id="anc18"></a><span class="line-modified">1489       assert(opr1-&gt;type() != T_ADDRESS &amp;&amp; opr2-&gt;type() != T_ADDRESS, &quot;currently unsupported&quot;);</span>
<span class="line-modified">1490       if (is_reference_type(opr1-&gt;type())) {</span>
<span class="line-modified">1491         // There are only equal/notequal comparisons on objects.</span>
<span class="line-modified">1492         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);</span>
<span class="line-modified">1493         __ cmpd(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());</span>


1494       } else {
1495         if (unsigned_comp) {
1496           __ cmplw(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());
1497         } else {
1498           __ cmpw(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());
1499         }
1500       }
1501     }
1502   } else if (opr1-&gt;is_double_cpu()) {
1503     if (opr2-&gt;is_constant()) {
1504       jlong con = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
1505       if (unsigned_comp) {
1506         if (Assembler::is_uimm(con, 16)) {
1507           __ cmpldi(BOOL_RESULT, opr1-&gt;as_register_lo(), con);
1508         } else {
1509           __ load_const_optimized(R0, con);
1510           __ cmpld(BOOL_RESULT, opr1-&gt;as_register_lo(), R0);
1511         }
1512       } else {
1513         if (Assembler::is_simm(con, 16)) {
1514           __ cmpdi(BOOL_RESULT, opr1-&gt;as_register_lo(), con);
1515         } else {
1516           __ load_const_optimized(R0, con);
1517           __ cmpd(BOOL_RESULT, opr1-&gt;as_register_lo(), R0);
1518         }
1519       }
1520     } else if (opr2-&gt;is_register()) {
1521       if (unsigned_comp) {
1522         __ cmpld(BOOL_RESULT, opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo());
1523       } else {
1524         __ cmpd(BOOL_RESULT, opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo());
1525       }
1526     } else {
1527       ShouldNotReachHere();
1528     }
<a name="19" id="anc19"></a>







1529   } else {
1530     ShouldNotReachHere();
1531   }
1532 }
1533 
1534 
1535 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
1536   const Register Rdst = dst-&gt;as_register();
1537   Label done;
1538   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
1539     bool is_unordered_less = (code == lir_ucmp_fd2i);
1540     if (left-&gt;is_single_fpu()) {
1541       __ fcmpu(CCR0, left-&gt;as_float_reg(), right-&gt;as_float_reg());
1542     } else if (left-&gt;is_double_fpu()) {
1543       __ fcmpu(CCR0, left-&gt;as_double_reg(), right-&gt;as_double_reg());
1544     } else {
1545       ShouldNotReachHere();
1546     }
1547     __ li(Rdst, is_unordered_less ? -1 : 1);
1548     __ bso(CCR0, done);
1549   } else if (code == lir_cmp_l2i) {
1550     __ cmpd(CCR0, left-&gt;as_register_lo(), right-&gt;as_register_lo());
1551   } else {
1552     ShouldNotReachHere();
1553   }
1554   __ mfcr(R0); // set bit 32..33 as follows: &lt;: 0b10, =: 0b00, &gt;: 0b01
1555   __ srwi(Rdst, R0, 30);
1556   __ srawi(R0, R0, 31);
1557   __ orr(Rdst, R0, Rdst); // set result as follows: &lt;: -1, =: 0, &gt;: 1
1558   __ bind(done);
1559 }
1560 
1561 
1562 inline void load_to_reg(LIR_Assembler *lasm, LIR_Opr src, LIR_Opr dst) {
1563   if (src-&gt;is_constant()) {
1564     lasm-&gt;const2reg(src, dst, lir_patch_none, NULL);
1565   } else if (src-&gt;is_register()) {
1566     lasm-&gt;reg2reg(src, dst);
1567   } else if (src-&gt;is_stack()) {
1568     lasm-&gt;stack2reg(src, dst, dst-&gt;type());
1569   } else {
1570     ShouldNotReachHere();
1571   }
1572 }
1573 
1574 
1575 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1576   if (opr1-&gt;is_equal(opr2) || opr1-&gt;is_same_register(opr2)) {
1577     load_to_reg(this, opr1, result); // Condition doesn&#39;t matter.
1578     return;
1579   }
1580 
1581   bool positive = false;
1582   Assembler::Condition cond = Assembler::equal;
1583   switch (condition) {
1584     case lir_cond_equal:        positive = true ; cond = Assembler::equal  ; break;
1585     case lir_cond_notEqual:     positive = false; cond = Assembler::equal  ; break;
1586     case lir_cond_less:         positive = true ; cond = Assembler::less   ; break;
1587     case lir_cond_belowEqual:
1588     case lir_cond_lessEqual:    positive = false; cond = Assembler::greater; break;
1589     case lir_cond_greater:      positive = true ; cond = Assembler::greater; break;
1590     case lir_cond_aboveEqual:
1591     case lir_cond_greaterEqual: positive = false; cond = Assembler::less   ; break;
1592     default:                    ShouldNotReachHere();
1593   }
1594 
1595   // Try to use isel on &gt;=Power7.
1596   if (VM_Version::has_isel() &amp;&amp; result-&gt;is_cpu_register()) {
1597     bool o1_is_reg = opr1-&gt;is_cpu_register(), o2_is_reg = opr2-&gt;is_cpu_register();
1598     const Register result_reg = result-&gt;is_single_cpu() ? result-&gt;as_register() : result-&gt;as_register_lo();
1599 
1600     // We can use result_reg to load one operand if not already in register.
1601     Register first  = o1_is_reg ? (opr1-&gt;is_single_cpu() ? opr1-&gt;as_register() : opr1-&gt;as_register_lo()) : result_reg,
1602              second = o2_is_reg ? (opr2-&gt;is_single_cpu() ? opr2-&gt;as_register() : opr2-&gt;as_register_lo()) : result_reg;
1603 
1604     if (first != second) {
1605       if (!o1_is_reg) {
1606         load_to_reg(this, opr1, result);
1607       }
1608 
1609       if (!o2_is_reg) {
1610         load_to_reg(this, opr2, result);
1611       }
1612 
1613       __ isel(result_reg, BOOL_RESULT, cond, !positive, first, second);
1614       return;
1615     }
1616   } // isel
1617 
1618   load_to_reg(this, opr1, result);
1619 
1620   Label skip;
1621   int bo = positive ? Assembler::bcondCRbiIs1 : Assembler::bcondCRbiIs0;
1622   int bi = Assembler::bi0(BOOL_RESULT, cond);
1623   __ bc(bo, bi, skip);
1624 
1625   load_to_reg(this, opr2, result);
1626   __ bind(skip);
1627 }
1628 
1629 
1630 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest,
1631                              CodeEmitInfo* info, bool pop_fpu_stack) {
1632   assert(info == NULL, &quot;unused on this code path&quot;);
1633   assert(left-&gt;is_register(), &quot;wrong items state&quot;);
1634   assert(dest-&gt;is_register(), &quot;wrong items state&quot;);
1635 
1636   if (right-&gt;is_register()) {
1637     if (dest-&gt;is_float_kind()) {
1638 
1639       FloatRegister lreg, rreg, res;
1640       if (right-&gt;is_single_fpu()) {
1641         lreg = left-&gt;as_float_reg();
1642         rreg = right-&gt;as_float_reg();
1643         res  = dest-&gt;as_float_reg();
1644         switch (code) {
1645           case lir_add: __ fadds(res, lreg, rreg); break;
1646           case lir_sub: __ fsubs(res, lreg, rreg); break;
1647           case lir_mul: // fall through
1648           case lir_mul_strictfp: __ fmuls(res, lreg, rreg); break;
1649           case lir_div: // fall through
1650           case lir_div_strictfp: __ fdivs(res, lreg, rreg); break;
1651           default: ShouldNotReachHere();
1652         }
1653       } else {
1654         lreg = left-&gt;as_double_reg();
1655         rreg = right-&gt;as_double_reg();
1656         res  = dest-&gt;as_double_reg();
1657         switch (code) {
1658           case lir_add: __ fadd(res, lreg, rreg); break;
1659           case lir_sub: __ fsub(res, lreg, rreg); break;
1660           case lir_mul: // fall through
1661           case lir_mul_strictfp: __ fmul(res, lreg, rreg); break;
1662           case lir_div: // fall through
1663           case lir_div_strictfp: __ fdiv(res, lreg, rreg); break;
1664           default: ShouldNotReachHere();
1665         }
1666       }
1667 
1668     } else if (dest-&gt;is_double_cpu()) {
1669 
1670       Register dst_lo = dest-&gt;as_register_lo();
1671       Register op1_lo = left-&gt;as_pointer_register();
1672       Register op2_lo = right-&gt;as_pointer_register();
1673 
1674       switch (code) {
1675         case lir_add: __ add(dst_lo, op1_lo, op2_lo); break;
1676         case lir_sub: __ sub(dst_lo, op1_lo, op2_lo); break;
1677         case lir_mul: __ mulld(dst_lo, op1_lo, op2_lo); break;
1678         default: ShouldNotReachHere();
1679       }
1680     } else {
1681       assert (right-&gt;is_single_cpu(), &quot;Just Checking&quot;);
1682 
1683       Register lreg = left-&gt;as_register();
1684       Register res  = dest-&gt;as_register();
1685       Register rreg = right-&gt;as_register();
1686       switch (code) {
1687         case lir_add:  __ add  (res, lreg, rreg); break;
1688         case lir_sub:  __ sub  (res, lreg, rreg); break;
1689         case lir_mul:  __ mullw(res, lreg, rreg); break;
1690         default: ShouldNotReachHere();
1691       }
1692     }
1693   } else {
1694     assert (right-&gt;is_constant(), &quot;must be constant&quot;);
1695 
1696     if (dest-&gt;is_single_cpu()) {
1697       Register lreg = left-&gt;as_register();
1698       Register res  = dest-&gt;as_register();
1699       int    simm16 = right-&gt;as_constant_ptr()-&gt;as_jint();
1700 
1701       switch (code) {
1702         case lir_sub:  assert(Assembler::is_simm16(-simm16), &quot;cannot encode&quot;); // see do_ArithmeticOp_Int
1703                        simm16 = -simm16;
1704         case lir_add:  if (res == lreg &amp;&amp; simm16 == 0) break;
1705                        __ addi(res, lreg, simm16); break;
1706         case lir_mul:  if (res == lreg &amp;&amp; simm16 == 1) break;
1707                        __ mulli(res, lreg, simm16); break;
1708         default: ShouldNotReachHere();
1709       }
1710     } else {
1711       Register lreg = left-&gt;as_pointer_register();
1712       Register res  = dest-&gt;as_register_lo();
1713       long con = right-&gt;as_constant_ptr()-&gt;as_jlong();
1714       assert(Assembler::is_simm16(con), &quot;must be simm16&quot;);
1715 
1716       switch (code) {
1717         case lir_sub:  assert(Assembler::is_simm16(-con), &quot;cannot encode&quot;);  // see do_ArithmeticOp_Long
1718                        con = -con;
1719         case lir_add:  if (res == lreg &amp;&amp; con == 0) break;
1720                        __ addi(res, lreg, (int)con); break;
1721         case lir_mul:  if (res == lreg &amp;&amp; con == 1) break;
1722                        __ mulli(res, lreg, (int)con); break;
1723         default: ShouldNotReachHere();
1724       }
1725     }
1726   }
1727 }
1728 
1729 
<a name="20" id="anc20"></a>





1730 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
1731   switch (code) {
1732     case lir_sqrt: {
1733       __ fsqrt(dest-&gt;as_double_reg(), value-&gt;as_double_reg());
1734       break;
1735     }
1736     case lir_abs: {
1737       __ fabs(dest-&gt;as_double_reg(), value-&gt;as_double_reg());
1738       break;
1739     }
1740     default: {
1741       ShouldNotReachHere();
1742       break;
1743     }
1744   }
1745 }
1746 
1747 
1748 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest) {
1749   if (right-&gt;is_constant()) { // see do_LogicOp
1750     long uimm;
1751     Register d, l;
1752     if (dest-&gt;is_single_cpu()) {
1753       uimm = right-&gt;as_constant_ptr()-&gt;as_jint();
1754       d = dest-&gt;as_register();
1755       l = left-&gt;as_register();
1756     } else {
1757       uimm = right-&gt;as_constant_ptr()-&gt;as_jlong();
1758       d = dest-&gt;as_register_lo();
1759       l = left-&gt;as_register_lo();
1760     }
1761     long uimms  = (unsigned long)uimm &gt;&gt; 16,
1762          uimmss = (unsigned long)uimm &gt;&gt; 32;
1763 
1764     switch (code) {
1765       case lir_logic_and:
<a name="21" id="anc21"></a><span class="line-modified">1766         if (uimmss != 0 || (uimms != 0 &amp;&amp; (uimm &amp; 0xFFFF) != 0) || is_power_of_2(uimm)) {</span>
1767           __ andi(d, l, uimm); // special cases
1768         } else if (uimms != 0) { __ andis_(d, l, uimms); }
1769         else { __ andi_(d, l, uimm); }
1770         break;
1771 
1772       case lir_logic_or:
1773         if (uimms != 0) { assert((uimm &amp; 0xFFFF) == 0, &quot;sanity&quot;); __ oris(d, l, uimms); }
1774         else { __ ori(d, l, uimm); }
1775         break;
1776 
1777       case lir_logic_xor:
1778         if (uimm == -1) { __ nand(d, l, l); } // special case
1779         else if (uimms != 0) { assert((uimm &amp; 0xFFFF) == 0, &quot;sanity&quot;); __ xoris(d, l, uimms); }
1780         else { __ xori(d, l, uimm); }
1781         break;
1782 
1783       default: ShouldNotReachHere();
1784     }
1785   } else {
1786     assert(right-&gt;is_register(), &quot;right should be in register&quot;);
1787 
1788     if (dest-&gt;is_single_cpu()) {
1789       switch (code) {
1790         case lir_logic_and: __ andr(dest-&gt;as_register(), left-&gt;as_register(), right-&gt;as_register()); break;
1791         case lir_logic_or:  __ orr (dest-&gt;as_register(), left-&gt;as_register(), right-&gt;as_register()); break;
1792         case lir_logic_xor: __ xorr(dest-&gt;as_register(), left-&gt;as_register(), right-&gt;as_register()); break;
1793         default: ShouldNotReachHere();
1794       }
1795     } else {
1796       Register l = (left-&gt;is_single_cpu() &amp;&amp; left-&gt;is_oop_register()) ? left-&gt;as_register() :
1797                                                                         left-&gt;as_register_lo();
1798       Register r = (right-&gt;is_single_cpu() &amp;&amp; right-&gt;is_oop_register()) ? right-&gt;as_register() :
1799                                                                           right-&gt;as_register_lo();
1800 
1801       switch (code) {
1802         case lir_logic_and: __ andr(dest-&gt;as_register_lo(), l, r); break;
1803         case lir_logic_or:  __ orr (dest-&gt;as_register_lo(), l, r); break;
1804         case lir_logic_xor: __ xorr(dest-&gt;as_register_lo(), l, r); break;
1805         default: ShouldNotReachHere();
1806       }
1807     }
1808   }
1809 }
1810 
1811 
1812 int LIR_Assembler::shift_amount(BasicType t) {
1813   int elem_size = type2aelembytes(t);
1814   switch (elem_size) {
1815     case 1 : return 0;
1816     case 2 : return 1;
1817     case 4 : return 2;
1818     case 8 : return 3;
1819   }
1820   ShouldNotReachHere();
1821   return -1;
1822 }
1823 
1824 
1825 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
1826   info-&gt;add_register_oop(exceptionOop);
1827 
1828   // Reuse the debug info from the safepoint poll for the throw op itself.
1829   address pc_for_athrow = __ pc();
1830   int pc_for_athrow_offset = __ offset();
1831   //RelocationHolder rspec = internal_word_Relocation::spec(pc_for_athrow);
1832   //__ relocate(rspec);
1833   //__ load_const(exceptionPC-&gt;as_register(), pc_for_athrow, R0);
1834   __ calculate_address_from_global_toc(exceptionPC-&gt;as_register(), pc_for_athrow, true, true, /*add_relocation*/ true);
1835   add_call_info(pc_for_athrow_offset, info); // for exception handler
1836 
1837   address stub = Runtime1::entry_for(compilation()-&gt;has_fpu_code() ? Runtime1::handle_exception_id
1838                                                                    : Runtime1::handle_exception_nofpu_id);
1839   //__ load_const_optimized(R0, stub);
1840   __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));
1841   __ mtctr(R0);
1842   __ bctr();
1843 }
1844 
1845 
1846 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
1847   // Note: Not used with EnableDebuggingOnDemand.
1848   assert(exceptionOop-&gt;as_register() == R3, &quot;should match&quot;);
1849   __ b(_unwind_handler_entry);
1850 }
1851 
1852 
1853 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
1854   Register src = op-&gt;src()-&gt;as_register();
1855   Register dst = op-&gt;dst()-&gt;as_register();
1856   Register src_pos = op-&gt;src_pos()-&gt;as_register();
1857   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
1858   Register length  = op-&gt;length()-&gt;as_register();
1859   Register tmp = op-&gt;tmp()-&gt;as_register();
1860   Register tmp2 = R0;
1861 
1862   int flags = op-&gt;flags();
1863   ciArrayKlass* default_type = op-&gt;expected_type();
1864   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
1865   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
1866 
1867   // Set up the arraycopy stub information.
1868   ArrayCopyStub* stub = op-&gt;stub();
1869   const int frame_resize = frame::abi_reg_args_size - sizeof(frame::jit_abi); // C calls need larger frame.
1870 
1871   // Always do stub if no type information is available. It&#39;s ok if
1872   // the known type isn&#39;t loaded since the code sanity checks
1873   // in debug mode and the type isn&#39;t required when we know the exact type
1874   // also check that the type is an array type.
1875   if (op-&gt;expected_type() == NULL) {
1876     assert(src-&gt;is_nonvolatile() &amp;&amp; src_pos-&gt;is_nonvolatile() &amp;&amp; dst-&gt;is_nonvolatile() &amp;&amp; dst_pos-&gt;is_nonvolatile() &amp;&amp;
1877            length-&gt;is_nonvolatile(), &quot;must preserve&quot;);
1878     address copyfunc_addr = StubRoutines::generic_arraycopy();
1879     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
1880 
1881     // 3 parms are int. Convert to long.
1882     __ mr(R3_ARG1, src);
1883     __ extsw(R4_ARG2, src_pos);
1884     __ mr(R5_ARG3, dst);
1885     __ extsw(R6_ARG4, dst_pos);
1886     __ extsw(R7_ARG5, length);
1887 
1888 #ifndef PRODUCT
1889     if (PrintC1Statistics) {
1890       address counter = (address)&amp;Runtime1::_generic_arraycopystub_cnt;
1891       int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
1892       __ lwz(R11_scratch1, simm16_offs, tmp);
1893       __ addi(R11_scratch1, R11_scratch1, 1);
1894       __ stw(R11_scratch1, simm16_offs, tmp);
1895     }
1896 #endif
1897     __ call_c_with_frame_resize(copyfunc_addr, /*stub does not need resized frame*/ 0);
1898 
1899     __ nand(tmp, R3_RET, R3_RET);
1900     __ subf(length, tmp, length);
1901     __ add(src_pos, tmp, src_pos);
1902     __ add(dst_pos, tmp, dst_pos);
1903 
1904     __ cmpwi(CCR0, R3_RET, 0);
1905     __ bc_far_optimized(Assembler::bcondCRbiIs1, __ bi0(CCR0, Assembler::less), *stub-&gt;entry());
1906     __ bind(*stub-&gt;continuation());
1907     return;
1908   }
1909 
1910   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass(), &quot;must be true at this point&quot;);
1911   Label cont, slow, copyfunc;
1912 
1913   bool simple_check_flag_set = flags &amp; (LIR_OpArrayCopy::src_null_check |
1914                                         LIR_OpArrayCopy::dst_null_check |
1915                                         LIR_OpArrayCopy::src_pos_positive_check |
1916                                         LIR_OpArrayCopy::dst_pos_positive_check |
1917                                         LIR_OpArrayCopy::length_positive_check);
1918 
1919   // Use only one conditional branch for simple checks.
1920   if (simple_check_flag_set) {
1921     ConditionRegister combined_check = CCR1, tmp_check = CCR1;
1922 
1923     // Make sure src and dst are non-null.
1924     if (flags &amp; LIR_OpArrayCopy::src_null_check) {
1925       __ cmpdi(combined_check, src, 0);
1926       tmp_check = CCR0;
1927     }
1928 
1929     if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
1930       __ cmpdi(tmp_check, dst, 0);
1931       if (tmp_check != combined_check) {
1932         __ cror(combined_check, Assembler::equal, tmp_check, Assembler::equal);
1933       }
1934       tmp_check = CCR0;
1935     }
1936 
1937     // Clear combined_check.eq if not already used.
1938     if (tmp_check == combined_check) {
1939       __ crandc(combined_check, Assembler::equal, combined_check, Assembler::equal);
1940       tmp_check = CCR0;
1941     }
1942 
1943     if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
1944       // Test src_pos register.
1945       __ cmpwi(tmp_check, src_pos, 0);
1946       __ cror(combined_check, Assembler::equal, tmp_check, Assembler::less);
1947     }
1948 
1949     if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
1950       // Test dst_pos register.
1951       __ cmpwi(tmp_check, dst_pos, 0);
1952       __ cror(combined_check, Assembler::equal, tmp_check, Assembler::less);
1953     }
1954 
1955     if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
1956       // Make sure length isn&#39;t negative.
1957       __ cmpwi(tmp_check, length, 0);
1958       __ cror(combined_check, Assembler::equal, tmp_check, Assembler::less);
1959     }
1960 
1961     __ beq(combined_check, slow);
1962   }
1963 
1964   // If the compiler was not able to prove that exact type of the source or the destination
1965   // of the arraycopy is an array type, check at runtime if the source or the destination is
1966   // an instance type.
1967   if (flags &amp; LIR_OpArrayCopy::type_check) {
1968     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
1969       __ load_klass(tmp, dst);
1970       __ lwz(tmp2, in_bytes(Klass::layout_helper_offset()), tmp);
1971       __ cmpwi(CCR0, tmp2, Klass::_lh_neutral_value);
1972       __ bge(CCR0, slow);
1973     }
1974 
1975     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
1976       __ load_klass(tmp, src);
1977       __ lwz(tmp2, in_bytes(Klass::layout_helper_offset()), tmp);
1978       __ cmpwi(CCR0, tmp2, Klass::_lh_neutral_value);
1979       __ bge(CCR0, slow);
1980     }
1981   }
1982 
1983   // Higher 32bits must be null.
1984   __ extsw(length, length);
1985 
1986   __ extsw(src_pos, src_pos);
1987   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
1988     __ lwz(tmp2, arrayOopDesc::length_offset_in_bytes(), src);
1989     __ add(tmp, length, src_pos);
1990     __ cmpld(CCR0, tmp2, tmp);
1991     __ ble(CCR0, slow);
1992   }
1993 
1994   __ extsw(dst_pos, dst_pos);
1995   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
1996     __ lwz(tmp2, arrayOopDesc::length_offset_in_bytes(), dst);
1997     __ add(tmp, length, dst_pos);
1998     __ cmpld(CCR0, tmp2, tmp);
1999     __ ble(CCR0, slow);
2000   }
2001 
2002   int shift = shift_amount(basic_type);
2003 
2004   if (!(flags &amp; LIR_OpArrayCopy::type_check)) {
2005     __ b(cont);
2006   } else {
2007     // We don&#39;t know the array types are compatible.
2008     if (basic_type != T_OBJECT) {
2009       // Simple test for basic type arrays.
2010       if (UseCompressedClassPointers) {
2011         // We don&#39;t need decode because we just need to compare.
2012         __ lwz(tmp, oopDesc::klass_offset_in_bytes(), src);
2013         __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2014         __ cmpw(CCR0, tmp, tmp2);
2015       } else {
2016         __ ld(tmp, oopDesc::klass_offset_in_bytes(), src);
2017         __ ld(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2018         __ cmpd(CCR0, tmp, tmp2);
2019       }
2020       __ beq(CCR0, cont);
2021     } else {
2022       // For object arrays, if src is a sub class of dst then we can
2023       // safely do the copy.
2024       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2025 
2026       const Register sub_klass = R5, super_klass = R4; // like CheckCast/InstanceOf
2027       assert_different_registers(tmp, tmp2, sub_klass, super_klass);
2028 
2029       __ load_klass(sub_klass, src);
2030       __ load_klass(super_klass, dst);
2031 
2032       __ check_klass_subtype_fast_path(sub_klass, super_klass, tmp, tmp2,
2033                                        &amp;cont, copyfunc_addr != NULL ? &amp;copyfunc : &amp;slow, NULL);
2034 
2035       address slow_stc = Runtime1::entry_for(Runtime1::slow_subtype_check_id);
2036       //__ load_const_optimized(tmp, slow_stc, tmp2);
2037       __ calculate_address_from_global_toc(tmp, slow_stc, true, true, false);
2038       __ mtctr(tmp);
2039       __ bctrl(); // sets CR0
2040       __ beq(CCR0, cont);
2041 
2042       if (copyfunc_addr != NULL) { // Use stub if available.
2043         __ bind(copyfunc);
2044         // Src is not a sub class of dst so we have to do a
2045         // per-element check.
2046         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2047         if ((flags &amp; mask) != mask) {
2048           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2049 
2050           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2051             __ load_klass(tmp, src);
2052           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2053             __ load_klass(tmp, dst);
2054           }
2055 
2056           __ lwz(tmp2, in_bytes(Klass::layout_helper_offset()), tmp);
2057 
2058           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2059           __ load_const_optimized(tmp, objArray_lh);
2060           __ cmpw(CCR0, tmp, tmp2);
2061           __ bne(CCR0, slow);
2062         }
2063 
2064         Register src_ptr = R3_ARG1;
2065         Register dst_ptr = R4_ARG2;
2066         Register len     = R5_ARG3;
2067         Register chk_off = R6_ARG4;
2068         Register super_k = R7_ARG5;
2069 
2070         __ addi(src_ptr, src, arrayOopDesc::base_offset_in_bytes(basic_type));
2071         __ addi(dst_ptr, dst, arrayOopDesc::base_offset_in_bytes(basic_type));
2072         if (shift == 0) {
2073           __ add(src_ptr, src_pos, src_ptr);
2074           __ add(dst_ptr, dst_pos, dst_ptr);
2075         } else {
2076           __ sldi(tmp, src_pos, shift);
2077           __ sldi(tmp2, dst_pos, shift);
2078           __ add(src_ptr, tmp, src_ptr);
2079           __ add(dst_ptr, tmp2, dst_ptr);
2080         }
2081 
2082         __ load_klass(tmp, dst);
2083         __ mr(len, length);
2084 
2085         int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
2086         __ ld(super_k, ek_offset, tmp);
2087 
2088         int sco_offset = in_bytes(Klass::super_check_offset_offset());
2089         __ lwz(chk_off, sco_offset, super_k);
2090 
2091         __ call_c_with_frame_resize(copyfunc_addr, /*stub does not need resized frame*/ 0);
2092 
2093 #ifndef PRODUCT
2094         if (PrintC1Statistics) {
2095           Label failed;
2096           __ cmpwi(CCR0, R3_RET, 0);
2097           __ bne(CCR0, failed);
2098           address counter = (address)&amp;Runtime1::_arraycopy_checkcast_cnt;
2099           int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
2100           __ lwz(R11_scratch1, simm16_offs, tmp);
2101           __ addi(R11_scratch1, R11_scratch1, 1);
2102           __ stw(R11_scratch1, simm16_offs, tmp);
2103           __ bind(failed);
2104         }
2105 #endif
2106 
2107         __ nand(tmp, R3_RET, R3_RET);
2108         __ cmpwi(CCR0, R3_RET, 0);
2109         __ beq(CCR0, *stub-&gt;continuation());
2110 
2111 #ifndef PRODUCT
2112         if (PrintC1Statistics) {
2113           address counter = (address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt;
2114           int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
2115           __ lwz(R11_scratch1, simm16_offs, tmp);
2116           __ addi(R11_scratch1, R11_scratch1, 1);
2117           __ stw(R11_scratch1, simm16_offs, tmp);
2118         }
2119 #endif
2120 
2121         __ subf(length, tmp, length);
2122         __ add(src_pos, tmp, src_pos);
2123         __ add(dst_pos, tmp, dst_pos);
2124       }
2125     }
2126   }
2127   __ bind(slow);
2128   __ b(*stub-&gt;entry());
2129   __ bind(cont);
2130 
2131 #ifdef ASSERT
2132   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2133     // Sanity check the known type with the incoming class. For the
2134     // primitive case the types must match exactly with src.klass and
2135     // dst.klass each exactly matching the default type. For the
2136     // object array case, if no type check is needed then either the
2137     // dst type is exactly the expected type and the src type is a
2138     // subtype which we can&#39;t check or src is the same array as dst
2139     // but not necessarily exactly of type default_type.
2140     Label known_ok, halt;
2141     metadata2reg(op-&gt;expected_type()-&gt;constant_encoding(), tmp);
2142     if (UseCompressedClassPointers) {
2143       // Tmp holds the default type. It currently comes uncompressed after the
2144       // load of a constant, so encode it.
2145       __ encode_klass_not_null(tmp);
2146       // Load the raw value of the dst klass, since we will be comparing
2147       // uncompressed values directly.
2148       __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2149       __ cmpw(CCR0, tmp, tmp2);
2150       if (basic_type != T_OBJECT) {
2151         __ bne(CCR0, halt);
2152         // Load the raw value of the src klass.
2153         __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), src);
2154         __ cmpw(CCR0, tmp, tmp2);
2155         __ beq(CCR0, known_ok);
2156       } else {
2157         __ beq(CCR0, known_ok);
2158         __ cmpw(CCR0, src, dst);
2159         __ beq(CCR0, known_ok);
2160       }
2161     } else {
2162       __ ld(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2163       __ cmpd(CCR0, tmp, tmp2);
2164       if (basic_type != T_OBJECT) {
2165         __ bne(CCR0, halt);
2166         // Load the raw value of the src klass.
2167         __ ld(tmp2, oopDesc::klass_offset_in_bytes(), src);
2168         __ cmpd(CCR0, tmp, tmp2);
2169         __ beq(CCR0, known_ok);
2170       } else {
2171         __ beq(CCR0, known_ok);
2172         __ cmpd(CCR0, src, dst);
2173         __ beq(CCR0, known_ok);
2174       }
2175     }
2176     __ bind(halt);
2177     __ stop(&quot;incorrect type information in arraycopy&quot;);
2178     __ bind(known_ok);
2179   }
2180 #endif
2181 
2182 #ifndef PRODUCT
2183   if (PrintC1Statistics) {
2184     address counter = Runtime1::arraycopy_count_address(basic_type);
2185     int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
2186     __ lwz(R11_scratch1, simm16_offs, tmp);
2187     __ addi(R11_scratch1, R11_scratch1, 1);
2188     __ stw(R11_scratch1, simm16_offs, tmp);
2189   }
2190 #endif
2191 
2192   Register src_ptr = R3_ARG1;
2193   Register dst_ptr = R4_ARG2;
2194   Register len     = R5_ARG3;
2195 
2196   __ addi(src_ptr, src, arrayOopDesc::base_offset_in_bytes(basic_type));
2197   __ addi(dst_ptr, dst, arrayOopDesc::base_offset_in_bytes(basic_type));
2198   if (shift == 0) {
2199     __ add(src_ptr, src_pos, src_ptr);
2200     __ add(dst_ptr, dst_pos, dst_ptr);
2201   } else {
2202     __ sldi(tmp, src_pos, shift);
2203     __ sldi(tmp2, dst_pos, shift);
2204     __ add(src_ptr, tmp, src_ptr);
2205     __ add(dst_ptr, tmp2, dst_ptr);
2206   }
2207 
2208   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2209   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2210   const char *name;
2211   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2212 
2213   // Arraycopy stubs takes a length in number of elements, so don&#39;t scale it.
2214   __ mr(len, length);
2215   __ call_c_with_frame_resize(entry, /*stub does not need resized frame*/ 0);
2216 
2217   __ bind(*stub-&gt;continuation());
2218 }
2219 
2220 
2221 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2222   if (dest-&gt;is_single_cpu()) {
2223     __ rldicl(tmp-&gt;as_register(), count-&gt;as_register(), 0, 64-5);
2224 #ifdef _LP64
2225     if (left-&gt;type() == T_OBJECT) {
2226       switch (code) {
2227         case lir_shl:  __ sld(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2228         case lir_shr:  __ srad(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2229         case lir_ushr: __ srd(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2230         default: ShouldNotReachHere();
2231       }
2232     } else
2233 #endif
2234       switch (code) {
2235         case lir_shl:  __ slw(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2236         case lir_shr:  __ sraw(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2237         case lir_ushr: __ srw(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2238         default: ShouldNotReachHere();
2239       }
2240   } else {
2241     __ rldicl(tmp-&gt;as_register(), count-&gt;as_register(), 0, 64-6);
2242     switch (code) {
2243       case lir_shl:  __ sld(dest-&gt;as_register_lo(), left-&gt;as_register_lo(), tmp-&gt;as_register()); break;
2244       case lir_shr:  __ srad(dest-&gt;as_register_lo(), left-&gt;as_register_lo(), tmp-&gt;as_register()); break;
2245       case lir_ushr: __ srd(dest-&gt;as_register_lo(), left-&gt;as_register_lo(), tmp-&gt;as_register()); break;
2246       default: ShouldNotReachHere();
2247     }
2248   }
2249 }
2250 
2251 
2252 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2253 #ifdef _LP64
2254   if (left-&gt;type() == T_OBJECT) {
2255     count = count &amp; 63;  // Shouldn&#39;t shift by more than sizeof(intptr_t).
2256     if (count == 0) { __ mr_if_needed(dest-&gt;as_register_lo(), left-&gt;as_register()); }
2257     else {
2258       switch (code) {
2259         case lir_shl:  __ sldi(dest-&gt;as_register_lo(), left-&gt;as_register(), count); break;
2260         case lir_shr:  __ sradi(dest-&gt;as_register_lo(), left-&gt;as_register(), count); break;
2261         case lir_ushr: __ srdi(dest-&gt;as_register_lo(), left-&gt;as_register(), count); break;
2262         default: ShouldNotReachHere();
2263       }
2264     }
2265     return;
2266   }
2267 #endif
2268 
2269   if (dest-&gt;is_single_cpu()) {
2270     count = count &amp; 0x1F; // Java spec
2271     if (count == 0) { __ mr_if_needed(dest-&gt;as_register(), left-&gt;as_register()); }
2272     else {
2273       switch (code) {
2274         case lir_shl: __ slwi(dest-&gt;as_register(), left-&gt;as_register(), count); break;
2275         case lir_shr:  __ srawi(dest-&gt;as_register(), left-&gt;as_register(), count); break;
2276         case lir_ushr: __ srwi(dest-&gt;as_register(), left-&gt;as_register(), count); break;
2277         default: ShouldNotReachHere();
2278       }
2279     }
2280   } else if (dest-&gt;is_double_cpu()) {
2281     count = count &amp; 63; // Java spec
2282     if (count == 0) { __ mr_if_needed(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register()); }
2283     else {
2284       switch (code) {
2285         case lir_shl:  __ sldi(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register(), count); break;
2286         case lir_shr:  __ sradi(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register(), count); break;
2287         case lir_ushr: __ srdi(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register(), count); break;
2288         default: ShouldNotReachHere();
2289       }
2290     }
2291   } else {
2292     ShouldNotReachHere();
2293   }
2294 }
2295 
2296 
2297 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
2298   if (op-&gt;init_check()) {
2299     if (!os::zero_page_read_protected() || !ImplicitNullChecks) {
2300       explicit_null_check(op-&gt;klass()-&gt;as_register(), op-&gt;stub()-&gt;info());
2301     } else {
2302       add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
2303     }
2304     __ lbz(op-&gt;tmp1()-&gt;as_register(),
2305            in_bytes(InstanceKlass::init_state_offset()), op-&gt;klass()-&gt;as_register());
2306     __ cmpwi(CCR0, op-&gt;tmp1()-&gt;as_register(), InstanceKlass::fully_initialized);
2307     __ bc_far_optimized(Assembler::bcondCRbiIs0, __ bi0(CCR0, Assembler::equal), *op-&gt;stub()-&gt;entry());
2308   }
2309   __ allocate_object(op-&gt;obj()-&gt;as_register(),
2310                      op-&gt;tmp1()-&gt;as_register(),
2311                      op-&gt;tmp2()-&gt;as_register(),
2312                      op-&gt;tmp3()-&gt;as_register(),
2313                      op-&gt;header_size(),
2314                      op-&gt;object_size(),
2315                      op-&gt;klass()-&gt;as_register(),
2316                      *op-&gt;stub()-&gt;entry());
2317 
2318   __ bind(*op-&gt;stub()-&gt;continuation());
<a name="22" id="anc22"></a><span class="line-modified">2319   __ verify_oop(op-&gt;obj()-&gt;as_register(), FILE_AND_LINE);</span>
2320 }
2321 
2322 
2323 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
2324   LP64_ONLY( __ extsw(op-&gt;len()-&gt;as_register(), op-&gt;len()-&gt;as_register()); )
2325   if (UseSlowPath ||
<a name="23" id="anc23"></a><span class="line-modified">2326       (!UseFastNewObjectArray &amp;&amp; (is_reference_type(op-&gt;type()))) ||</span>
<span class="line-modified">2327       (!UseFastNewTypeArray   &amp;&amp; (!is_reference_type(op-&gt;type())))) {</span>
2328     __ b(*op-&gt;stub()-&gt;entry());
2329   } else {
2330     __ allocate_array(op-&gt;obj()-&gt;as_register(),
2331                       op-&gt;len()-&gt;as_register(),
2332                       op-&gt;tmp1()-&gt;as_register(),
2333                       op-&gt;tmp2()-&gt;as_register(),
2334                       op-&gt;tmp3()-&gt;as_register(),
2335                       arrayOopDesc::header_size(op-&gt;type()),
2336                       type2aelembytes(op-&gt;type()),
2337                       op-&gt;klass()-&gt;as_register(),
2338                       *op-&gt;stub()-&gt;entry());
2339   }
2340   __ bind(*op-&gt;stub()-&gt;continuation());
2341 }
2342 
2343 
2344 void LIR_Assembler::type_profile_helper(Register mdo, int mdo_offset_bias,
2345                                         ciMethodData *md, ciProfileData *data,
2346                                         Register recv, Register tmp1, Label* update_done) {
2347   uint i;
2348   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2349     Label next_test;
2350     // See if the receiver is receiver[n].
2351     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) - mdo_offset_bias, mdo);
2352     __ verify_klass_ptr(tmp1);
2353     __ cmpd(CCR0, recv, tmp1);
2354     __ bne(CCR0, next_test);
2355 
2356     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2357     __ addi(tmp1, tmp1, DataLayout::counter_increment);
2358     __ std(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2359     __ b(*update_done);
2360 
2361     __ bind(next_test);
2362   }
2363 
2364   // Didn&#39;t find receiver; find next empty slot and fill it in.
2365   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2366     Label next_test;
2367     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) - mdo_offset_bias, mdo);
2368     __ cmpdi(CCR0, tmp1, 0);
2369     __ bne(CCR0, next_test);
2370     __ li(tmp1, DataLayout::counter_increment);
2371     __ std(recv, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) - mdo_offset_bias, mdo);
2372     __ std(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2373     __ b(*update_done);
2374 
2375     __ bind(next_test);
2376   }
2377 }
2378 
2379 
2380 void LIR_Assembler::setup_md_access(ciMethod* method, int bci,
2381                                     ciMethodData*&amp; md, ciProfileData*&amp; data, int&amp; mdo_offset_bias) {
2382   md = method-&gt;method_data_or_null();
2383   assert(md != NULL, &quot;Sanity&quot;);
2384   data = md-&gt;bci_to_data(bci);
2385   assert(data != NULL,       &quot;need data for checkcast&quot;);
2386   assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
2387   if (!Assembler::is_simm16(md-&gt;byte_offset_of_slot(data, DataLayout::header_offset()) + data-&gt;size_in_bytes())) {
2388     // The offset is large so bias the mdo by the base of the slot so
2389     // that the ld can use simm16s to reference the slots of the data.
2390     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, DataLayout::header_offset());
2391   }
2392 }
2393 
2394 
2395 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
2396   const Register obj = op-&gt;object()-&gt;as_register(); // Needs to live in this register at safepoint (patching stub).
2397   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2398   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2399   Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2400   Register dst = op-&gt;result_opr()-&gt;as_register();
2401   ciKlass* k = op-&gt;klass();
2402   bool should_profile = op-&gt;should_profile();
2403   // Attention: do_temp(opTypeCheck-&gt;_object) is not used, i.e. obj may be same as one of the temps.
2404   bool reg_conflict = false;
2405   if (obj == k_RInfo) {
2406     k_RInfo = dst;
2407     reg_conflict = true;
2408   } else if (obj == klass_RInfo) {
2409     klass_RInfo = dst;
2410     reg_conflict = true;
2411   } else if (obj == Rtmp1) {
2412     Rtmp1 = dst;
2413     reg_conflict = true;
2414   }
2415   assert_different_registers(obj, k_RInfo, klass_RInfo, Rtmp1);
2416 
2417   __ cmpdi(CCR0, obj, 0);
2418 
2419   ciMethodData* md = NULL;
2420   ciProfileData* data = NULL;
2421   int mdo_offset_bias = 0;
2422   if (should_profile) {
2423     ciMethod* method = op-&gt;profiled_method();
2424     assert(method != NULL, &quot;Should have method&quot;);
2425     setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2426 
2427     Register mdo      = k_RInfo;
2428     Register data_val = Rtmp1;
2429     Label not_null;
2430     __ bne(CCR0, not_null);
2431     metadata2reg(md-&gt;constant_encoding(), mdo);
2432     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2433     __ lbz(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2434     __ ori(data_val, data_val, BitData::null_seen_byte_constant());
2435     __ stb(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2436     __ b(*obj_is_null);
2437     __ bind(not_null);
2438   } else {
2439     __ beq(CCR0, *obj_is_null);
2440   }
2441 
2442   // get object class
2443   __ load_klass(klass_RInfo, obj);
2444 
2445   if (k-&gt;is_loaded()) {
2446     metadata2reg(k-&gt;constant_encoding(), k_RInfo);
2447   } else {
2448     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
2449   }
2450 
2451   Label profile_cast_failure, failure_restore_obj, profile_cast_success;
2452   Label *failure_target = should_profile ? &amp;profile_cast_failure : failure;
2453   Label *success_target = should_profile ? &amp;profile_cast_success : success;
2454 
2455   if (op-&gt;fast_check()) {
2456     assert_different_registers(klass_RInfo, k_RInfo);
2457     __ cmpd(CCR0, k_RInfo, klass_RInfo);
2458     if (should_profile) {
2459       __ bne(CCR0, *failure_target);
2460       // Fall through to success case.
2461     } else {
2462       __ beq(CCR0, *success);
2463       // Fall through to failure case.
2464     }
2465   } else {
2466     bool need_slow_path = true;
2467     if (k-&gt;is_loaded()) {
2468       if ((int) k-&gt;super_check_offset() != in_bytes(Klass::secondary_super_cache_offset())) {
2469         need_slow_path = false;
2470       }
2471       // Perform the fast part of the checking logic.
2472       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, (need_slow_path ? success_target : NULL),
2473                                        failure_target, NULL, RegisterOrConstant(k-&gt;super_check_offset()));
2474     } else {
2475       // Perform the fast part of the checking logic.
2476       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, failure_target);
2477     }
2478     if (!need_slow_path) {
2479       if (!should_profile) { __ b(*success); }
2480     } else {
2481       // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2482       address entry = Runtime1::entry_for(Runtime1::slow_subtype_check_id);
2483       // Stub needs fixed registers (tmp1-3).
2484       Register original_k_RInfo = op-&gt;tmp1()-&gt;as_register();
2485       Register original_klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2486       Register original_Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2487       bool keep_obj_alive = reg_conflict &amp;&amp; (op-&gt;code() == lir_checkcast);
2488       bool keep_klass_RInfo_alive = (obj == original_klass_RInfo) &amp;&amp; should_profile;
2489       if (keep_obj_alive &amp;&amp; (obj != original_Rtmp1)) { __ mr(R0, obj); }
2490       __ mr_if_needed(original_k_RInfo, k_RInfo);
2491       __ mr_if_needed(original_klass_RInfo, klass_RInfo);
2492       if (keep_obj_alive) { __ mr(dst, (obj == original_Rtmp1) ? obj : R0); }
2493       //__ load_const_optimized(original_Rtmp1, entry, R0);
2494       __ calculate_address_from_global_toc(original_Rtmp1, entry, true, true, false);
2495       __ mtctr(original_Rtmp1);
2496       __ bctrl(); // sets CR0
2497       if (keep_obj_alive) {
2498         if (keep_klass_RInfo_alive) { __ mr(R0, obj); }
2499         __ mr(obj, dst);
2500       }
2501       if (should_profile) {
2502         __ bne(CCR0, *failure_target);
2503         if (keep_klass_RInfo_alive) { __ mr(klass_RInfo, keep_obj_alive ? R0 : obj); }
2504         // Fall through to success case.
2505       } else {
2506         __ beq(CCR0, *success);
2507         // Fall through to failure case.
2508       }
2509     }
2510   }
2511 
2512   if (should_profile) {
2513     Register mdo = k_RInfo, recv = klass_RInfo;
2514     assert_different_registers(mdo, recv, Rtmp1);
2515     __ bind(profile_cast_success);
2516     metadata2reg(md-&gt;constant_encoding(), mdo);
2517     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2518     type_profile_helper(mdo, mdo_offset_bias, md, data, recv, Rtmp1, success);
2519     __ b(*success);
2520 
2521     // Cast failure case.
2522     __ bind(profile_cast_failure);
2523     metadata2reg(md-&gt;constant_encoding(), mdo);
2524     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2525     __ ld(Rtmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2526     __ addi(Rtmp1, Rtmp1, -DataLayout::counter_increment);
2527     __ std(Rtmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2528   }
2529 
2530   __ bind(*failure);
2531 }
2532 
2533 
2534 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
2535   LIR_Code code = op-&gt;code();
2536   if (code == lir_store_check) {
2537     Register value = op-&gt;object()-&gt;as_register();
2538     Register array = op-&gt;array()-&gt;as_register();
2539     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2540     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2541     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2542     bool should_profile = op-&gt;should_profile();
2543 
<a name="24" id="anc24"></a><span class="line-modified">2544     __ verify_oop(value, FILE_AND_LINE);</span>
2545     CodeStub* stub = op-&gt;stub();
2546     // Check if it needs to be profiled.
2547     ciMethodData* md = NULL;
2548     ciProfileData* data = NULL;
2549     int mdo_offset_bias = 0;
2550     if (should_profile) {
2551       ciMethod* method = op-&gt;profiled_method();
2552       assert(method != NULL, &quot;Should have method&quot;);
2553       setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2554     }
2555     Label profile_cast_success, failure, done;
2556     Label *success_target = should_profile ? &amp;profile_cast_success : &amp;done;
2557 
2558     __ cmpdi(CCR0, value, 0);
2559     if (should_profile) {
2560       Label not_null;
2561       __ bne(CCR0, not_null);
2562       Register mdo      = k_RInfo;
2563       Register data_val = Rtmp1;
2564       metadata2reg(md-&gt;constant_encoding(), mdo);
2565       __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2566       __ lbz(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2567       __ ori(data_val, data_val, BitData::null_seen_byte_constant());
2568       __ stb(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2569       __ b(done);
2570       __ bind(not_null);
2571     } else {
2572       __ beq(CCR0, done);
2573     }
2574     if (!os::zero_page_read_protected() || !ImplicitNullChecks) {
2575       explicit_null_check(array, op-&gt;info_for_exception());
2576     } else {
2577       add_debug_info_for_null_check_here(op-&gt;info_for_exception());
2578     }
2579     __ load_klass(k_RInfo, array);
2580     __ load_klass(klass_RInfo, value);
2581 
2582     // Get instance klass.
2583     __ ld(k_RInfo, in_bytes(ObjArrayKlass::element_klass_offset()), k_RInfo);
2584     // Perform the fast part of the checking logic.
2585     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, &amp;failure, NULL);
2586 
2587     // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2588     const address slow_path = Runtime1::entry_for(Runtime1::slow_subtype_check_id);
2589     //__ load_const_optimized(R0, slow_path);
2590     __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(slow_path));
2591     __ mtctr(R0);
2592     __ bctrl(); // sets CR0
2593     if (!should_profile) {
2594       __ beq(CCR0, done);
2595       __ bind(failure);
2596     } else {
2597       __ bne(CCR0, failure);
2598       // Fall through to the success case.
2599 
2600       Register mdo  = klass_RInfo, recv = k_RInfo, tmp1 = Rtmp1;
2601       assert_different_registers(value, mdo, recv, tmp1);
2602       __ bind(profile_cast_success);
2603       metadata2reg(md-&gt;constant_encoding(), mdo);
2604       __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2605       __ load_klass(recv, value);
2606       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;done);
2607       __ b(done);
2608 
2609       // Cast failure case.
2610       __ bind(failure);
2611       metadata2reg(md-&gt;constant_encoding(), mdo);
2612       __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2613       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2614       __ ld(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2615       __ addi(tmp1, tmp1, -DataLayout::counter_increment);
2616       __ std(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2617     }
2618     __ b(*stub-&gt;entry());
2619     __ bind(done);
2620 
2621   } else if (code == lir_checkcast) {
2622     Label success, failure;
2623     emit_typecheck_helper(op, &amp;success, /*fallthru*/&amp;failure, &amp;success);
2624     __ b(*op-&gt;stub()-&gt;entry());
2625     __ align(32, 12);
2626     __ bind(success);
2627     __ mr_if_needed(op-&gt;result_opr()-&gt;as_register(), op-&gt;object()-&gt;as_register());
2628   } else if (code == lir_instanceof) {
2629     Register dst = op-&gt;result_opr()-&gt;as_register();
2630     Label success, failure, done;
2631     emit_typecheck_helper(op, &amp;success, /*fallthru*/&amp;failure, &amp;failure);
2632     __ li(dst, 0);
2633     __ b(done);
2634     __ align(32, 12);
2635     __ bind(success);
2636     __ li(dst, 1);
2637     __ bind(done);
2638   } else {
2639     ShouldNotReachHere();
2640   }
2641 }
2642 
2643 
2644 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2645   Register addr = op-&gt;addr()-&gt;as_pointer_register();
2646   Register cmp_value = noreg, new_value = noreg;
2647   bool is_64bit = false;
2648 
2649   if (op-&gt;code() == lir_cas_long) {
2650     cmp_value = op-&gt;cmp_value()-&gt;as_register_lo();
2651     new_value = op-&gt;new_value()-&gt;as_register_lo();
2652     is_64bit = true;
2653   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj) {
2654     cmp_value = op-&gt;cmp_value()-&gt;as_register();
2655     new_value = op-&gt;new_value()-&gt;as_register();
2656     if (op-&gt;code() == lir_cas_obj) {
2657       if (UseCompressedOops) {
2658         Register t1 = op-&gt;tmp1()-&gt;as_register();
2659         Register t2 = op-&gt;tmp2()-&gt;as_register();
2660         cmp_value = __ encode_heap_oop(t1, cmp_value);
2661         new_value = __ encode_heap_oop(t2, new_value);
2662       } else {
2663         is_64bit = true;
2664       }
2665     }
2666   } else {
2667     Unimplemented();
2668   }
2669 
2670   if (is_64bit) {
2671     __ cmpxchgd(BOOL_RESULT, /*current_value=*/R0, cmp_value, new_value, addr,
2672                 MacroAssembler::MemBarNone,
2673                 MacroAssembler::cmpxchgx_hint_atomic_update(),
2674                 noreg, NULL, /*check without ldarx first*/true);
2675   } else {
2676     __ cmpxchgw(BOOL_RESULT, /*current_value=*/R0, cmp_value, new_value, addr,
2677                 MacroAssembler::MemBarNone,
2678                 MacroAssembler::cmpxchgx_hint_atomic_update(),
2679                 noreg, /*check without ldarx first*/true);
2680   }
2681 
2682   if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
2683     __ isync();
2684   } else {
2685     __ sync();
2686   }
2687 }
2688 
<a name="25" id="anc25"></a>









2689 void LIR_Assembler::breakpoint() {
2690   __ illtrap();
2691 }
2692 
2693 
2694 void LIR_Assembler::push(LIR_Opr opr) {
2695   Unimplemented();
2696 }
2697 
2698 void LIR_Assembler::pop(LIR_Opr opr) {
2699   Unimplemented();
2700 }
2701 
2702 
2703 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst_opr) {
2704   Address mon_addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
2705   Register dst = dst_opr-&gt;as_register();
2706   Register reg = mon_addr.base();
2707   int offset = mon_addr.disp();
2708   // Compute pointer to BasicLock.
2709   __ add_const_optimized(dst, reg, offset);
2710 }
2711 
2712 
2713 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2714   Register obj = op-&gt;obj_opr()-&gt;as_register();
2715   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2716   Register lock = op-&gt;lock_opr()-&gt;as_register();
2717 
2718   // Obj may not be an oop.
2719   if (op-&gt;code() == lir_lock) {
2720     MonitorEnterStub* stub = (MonitorEnterStub*)op-&gt;stub();
2721     if (UseFastLocking) {
2722       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2723       // Add debug info for NullPointerException only if one is possible.
2724       if (op-&gt;info() != NULL) {
2725         if (!os::zero_page_read_protected() || !ImplicitNullChecks) {
2726           explicit_null_check(obj, op-&gt;info());
2727         } else {
2728           add_debug_info_for_null_check_here(op-&gt;info());
2729         }
2730       }
2731       __ lock_object(hdr, obj, lock, op-&gt;scratch_opr()-&gt;as_register(), *op-&gt;stub()-&gt;entry());
2732     } else {
2733       // always do slow locking
2734       // note: The slow locking code could be inlined here, however if we use
2735       //       slow locking, speed doesn&#39;t matter anyway and this solution is
2736       //       simpler and requires less duplicated code - additionally, the
2737       //       slow locking code is the same in either case which simplifies
2738       //       debugging.
2739       __ b(*op-&gt;stub()-&gt;entry());
2740     }
2741   } else {
2742     assert (op-&gt;code() == lir_unlock, &quot;Invalid code, expected lir_unlock&quot;);
2743     if (UseFastLocking) {
2744       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2745       __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2746     } else {
2747       // always do slow unlocking
2748       // note: The slow unlocking code could be inlined here, however if we use
2749       //       slow unlocking, speed doesn&#39;t matter anyway and this solution is
2750       //       simpler and requires less duplicated code - additionally, the
2751       //       slow unlocking code is the same in either case which simplifies
2752       //       debugging.
2753       __ b(*op-&gt;stub()-&gt;entry());
2754     }
2755   }
2756   __ bind(*op-&gt;stub()-&gt;continuation());
2757 }
2758 
2759 
2760 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2761   ciMethod* method = op-&gt;profiled_method();
2762   int bci          = op-&gt;profiled_bci();
2763   ciMethod* callee = op-&gt;profiled_callee();
2764 
2765   // Update counter for all call types.
2766   ciMethodData* md = method-&gt;method_data_or_null();
2767   assert(md != NULL, &quot;Sanity&quot;);
2768   ciProfileData* data = md-&gt;bci_to_data(bci);
2769   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2770   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2771   Register mdo = op-&gt;mdo()-&gt;as_register();
2772 #ifdef _LP64
2773   assert(op-&gt;tmp1()-&gt;is_double_cpu(), &quot;tmp1 must be allocated&quot;);
2774   Register tmp1 = op-&gt;tmp1()-&gt;as_register_lo();
2775 #else
2776   assert(op-&gt;tmp1()-&gt;is_single_cpu(), &quot;tmp1 must be allocated&quot;);
2777   Register tmp1 = op-&gt;tmp1()-&gt;as_register();
2778 #endif
2779   metadata2reg(md-&gt;constant_encoding(), mdo);
2780   int mdo_offset_bias = 0;
2781   if (!Assembler::is_simm16(md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) +
2782                             data-&gt;size_in_bytes())) {
2783     // The offset is large so bias the mdo by the base of the slot so
2784     // that the ld can use simm16s to reference the slots of the data.
2785     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, CounterData::count_offset());
2786     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2787   }
2788 
2789   // Perform additional virtual call profiling for invokevirtual and
2790   // invokeinterface bytecodes
2791   if (op-&gt;should_profile_receiver_type()) {
2792     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2793     Register recv = op-&gt;recv()-&gt;as_register();
2794     assert_different_registers(mdo, tmp1, recv);
2795     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2796     ciKlass* known_klass = op-&gt;known_holder();
2797     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2798       // We know the type that will be seen at this call site; we can
2799       // statically update the MethodData* rather than needing to do
2800       // dynamic tests on the receiver type.
2801 
2802       // NOTE: we should probably put a lock around this search to
2803       // avoid collisions by concurrent compilations.
2804       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2805       uint i;
2806       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2807         ciKlass* receiver = vc_data-&gt;receiver(i);
2808         if (known_klass-&gt;equals(receiver)) {
2809           __ ld(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2810           __ addi(tmp1, tmp1, DataLayout::counter_increment);
2811           __ std(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2812           return;
2813         }
2814       }
2815 
2816       // Receiver type not found in profile data; select an empty slot.
2817 
2818       // Note that this is less efficient than it should be because it
2819       // always does a write to the receiver part of the
2820       // VirtualCallData rather than just the first time.
2821       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2822         ciKlass* receiver = vc_data-&gt;receiver(i);
2823         if (receiver == NULL) {
2824           metadata2reg(known_klass-&gt;constant_encoding(), tmp1);
2825           __ std(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)) - mdo_offset_bias, mdo);
2826 
2827           __ ld(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2828           __ addi(tmp1, tmp1, DataLayout::counter_increment);
2829           __ std(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2830           return;
2831         }
2832       }
2833     } else {
2834       __ load_klass(recv, recv);
2835       Label update_done;
2836       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;update_done);
2837       // Receiver did not match any saved receiver and there is no empty row for it.
2838       // Increment total counter to indicate polymorphic case.
2839       __ ld(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2840       __ addi(tmp1, tmp1, DataLayout::counter_increment);
2841       __ std(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2842 
2843       __ bind(update_done);
2844     }
2845   } else {
2846     // Static call
2847     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2848     __ addi(tmp1, tmp1, DataLayout::counter_increment);
2849     __ std(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2850   }
2851 }
2852 
2853 
2854 void LIR_Assembler::align_backward_branch_target() {
2855   __ align(32, 12); // Insert up to 3 nops to align with 32 byte boundary.
2856 }
2857 
2858 
2859 void LIR_Assembler::emit_delay(LIR_OpDelay* op) {
2860   Unimplemented();
2861 }
2862 
2863 
2864 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
2865   // tmp must be unused
2866   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2867   assert(left-&gt;is_register(), &quot;can only handle registers&quot;);
2868 
2869   if (left-&gt;is_single_cpu()) {
2870     __ neg(dest-&gt;as_register(), left-&gt;as_register());
2871   } else if (left-&gt;is_single_fpu()) {
2872     __ fneg(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
2873   } else if (left-&gt;is_double_fpu()) {
2874     __ fneg(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
2875   } else {
2876     assert (left-&gt;is_double_cpu(), &quot;Must be a long&quot;);
2877     __ neg(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
2878   }
2879 }
2880 
2881 
<a name="26" id="anc26"></a>












2882 void LIR_Assembler::rt_call(LIR_Opr result, address dest,
2883                             const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
2884   // Stubs: Called via rt_call, but dest is a stub address (no function descriptor).
2885   if (dest == Runtime1::entry_for(Runtime1::register_finalizer_id) ||
2886       dest == Runtime1::entry_for(Runtime1::new_multi_array_id   )) {
2887     //__ load_const_optimized(R0, dest);
2888     __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(dest));
2889     __ mtctr(R0);
2890     __ bctrl();
2891     assert(info != NULL, &quot;sanity&quot;);
2892     add_call_info_here(info);
2893     return;
2894   }
2895 
2896   __ call_c_with_frame_resize(dest, /*no resizing*/ 0);
2897   if (info != NULL) {
2898     add_call_info_here(info);
2899   }
2900 }
2901 
2902 
2903 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
2904   ShouldNotReachHere(); // Not needed on _LP64.
2905 }
2906 
2907 void LIR_Assembler::membar() {
2908   __ fence();
2909 }
2910 
2911 void LIR_Assembler::membar_acquire() {
2912   __ acquire();
2913 }
2914 
2915 void LIR_Assembler::membar_release() {
2916   __ release();
2917 }
2918 
2919 void LIR_Assembler::membar_loadload() {
2920   __ membar(Assembler::LoadLoad);
2921 }
2922 
2923 void LIR_Assembler::membar_storestore() {
2924   __ membar(Assembler::StoreStore);
2925 }
2926 
2927 void LIR_Assembler::membar_loadstore() {
2928   __ membar(Assembler::LoadStore);
2929 }
2930 
2931 void LIR_Assembler::membar_storeload() {
2932   __ membar(Assembler::StoreLoad);
2933 }
2934 
2935 void LIR_Assembler::on_spin_wait() {
2936   Unimplemented();
2937 }
2938 
2939 void LIR_Assembler::leal(LIR_Opr addr_opr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
2940   assert(patch_code == lir_patch_none, &quot;Patch code not supported&quot;);
2941   LIR_Address* addr = addr_opr-&gt;as_address_ptr();
2942   assert(addr-&gt;scale() == LIR_Address::times_1, &quot;no scaling on this platform&quot;);
2943   if (addr-&gt;index()-&gt;is_illegal()) {
2944     __ add_const_optimized(dest-&gt;as_pointer_register(), addr-&gt;base()-&gt;as_pointer_register(), addr-&gt;disp());
2945   } else {
2946     assert(addr-&gt;disp() == 0, &quot;can&#39;t have both: index and disp&quot;);
2947     __ add(dest-&gt;as_pointer_register(), addr-&gt;index()-&gt;as_pointer_register(), addr-&gt;base()-&gt;as_pointer_register());
2948   }
2949 }
2950 
2951 
2952 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
2953   ShouldNotReachHere();
2954 }
2955 
2956 
2957 #ifdef ASSERT
2958 // Emit run-time assertion.
2959 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
2960   Unimplemented();
2961 }
2962 #endif
2963 
2964 
2965 void LIR_Assembler::peephole(LIR_List* lir) {
2966   // Optimize instruction pairs before emitting.
2967   LIR_OpList* inst = lir-&gt;instructions_list();
2968   for (int i = 1; i &lt; inst-&gt;length(); i++) {
2969     LIR_Op* op = inst-&gt;at(i);
2970 
2971     // 2 register-register-moves
2972     if (op-&gt;code() == lir_move) {
2973       LIR_Opr in2  = ((LIR_Op1*)op)-&gt;in_opr(),
2974               res2 = ((LIR_Op1*)op)-&gt;result_opr();
2975       if (in2-&gt;is_register() &amp;&amp; res2-&gt;is_register()) {
2976         LIR_Op* prev = inst-&gt;at(i - 1);
2977         if (prev &amp;&amp; prev-&gt;code() == lir_move) {
2978           LIR_Opr in1  = ((LIR_Op1*)prev)-&gt;in_opr(),
2979                   res1 = ((LIR_Op1*)prev)-&gt;result_opr();
2980           if (in1-&gt;is_same_register(res2) &amp;&amp; in2-&gt;is_same_register(res1)) {
2981             inst-&gt;remove_at(i);
2982           }
2983         }
2984       }
2985     }
2986 
2987   }
2988   return;
2989 }
2990 
2991 
2992 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
2993   const LIR_Address *addr = src-&gt;as_address_ptr();
2994   assert(addr-&gt;disp() == 0 &amp;&amp; addr-&gt;index()-&gt;is_illegal(), &quot;use leal!&quot;);
2995   const Register Rptr = addr-&gt;base()-&gt;as_pointer_register(),
2996                  Rtmp = tmp-&gt;as_register();
2997   Register Rco = noreg;
2998   if (UseCompressedOops &amp;&amp; data-&gt;is_oop()) {
2999     Rco = __ encode_heap_oop(Rtmp, data-&gt;as_register());
3000   }
3001 
3002   Label Lretry;
3003   __ bind(Lretry);
3004 
3005   if (data-&gt;type() == T_INT) {
3006     const Register Rold = dest-&gt;as_register(),
3007                    Rsrc = data-&gt;as_register();
3008     assert_different_registers(Rptr, Rtmp, Rold, Rsrc);
3009     __ lwarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3010     if (code == lir_xadd) {
3011       __ add(Rtmp, Rsrc, Rold);
3012       __ stwcx_(Rtmp, Rptr);
3013     } else {
3014       __ stwcx_(Rsrc, Rptr);
3015     }
3016   } else if (data-&gt;is_oop()) {
3017     assert(code == lir_xchg, &quot;xadd for oops&quot;);
3018     const Register Rold = dest-&gt;as_register();
3019     if (UseCompressedOops) {
3020       assert_different_registers(Rptr, Rold, Rco);
3021       __ lwarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3022       __ stwcx_(Rco, Rptr);
3023     } else {
3024       const Register Robj = data-&gt;as_register();
3025       assert_different_registers(Rptr, Rold, Robj);
3026       __ ldarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3027       __ stdcx_(Robj, Rptr);
3028     }
3029   } else if (data-&gt;type() == T_LONG) {
3030     const Register Rold = dest-&gt;as_register_lo(),
3031                    Rsrc = data-&gt;as_register_lo();
3032     assert_different_registers(Rptr, Rtmp, Rold, Rsrc);
3033     __ ldarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3034     if (code == lir_xadd) {
3035       __ add(Rtmp, Rsrc, Rold);
3036       __ stdcx_(Rtmp, Rptr);
3037     } else {
3038       __ stdcx_(Rsrc, Rptr);
3039     }
3040   } else {
3041     ShouldNotReachHere();
3042   }
3043 
3044   if (UseStaticBranchPredictionInCompareAndSwapPPC64) {
3045     __ bne_predict_not_taken(CCR0, Lretry);
3046   } else {
3047     __ bne(                  CCR0, Lretry);
3048   }
3049 
3050   if (UseCompressedOops &amp;&amp; data-&gt;is_oop()) {
3051     __ decode_heap_oop(dest-&gt;as_register());
3052   }
3053 }
3054 
3055 
3056 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3057   Register obj = op-&gt;obj()-&gt;as_register();
3058   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3059   LIR_Address* mdo_addr = op-&gt;mdp()-&gt;as_address_ptr();
3060   ciKlass* exact_klass = op-&gt;exact_klass();
3061   intptr_t current_klass = op-&gt;current_klass();
3062   bool not_null = op-&gt;not_null();
3063   bool no_conflict = op-&gt;no_conflict();
3064 
3065   Label Lupdate, Ldo_update, Ldone;
3066 
3067   bool do_null = !not_null;
3068   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3069   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3070 
3071   assert(do_null || do_update, &quot;why are we here?&quot;);
3072   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3073 
<a name="27" id="anc27"></a><span class="line-modified">3074   __ verify_oop(obj, FILE_AND_LINE);</span>
3075 
3076   if (do_null) {
3077     if (!TypeEntries::was_null_seen(current_klass)) {
3078       __ cmpdi(CCR0, obj, 0);
3079       __ bne(CCR0, Lupdate);
3080       __ ld(R0, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3081       __ ori(R0, R0, TypeEntries::null_seen);
3082       if (do_update) {
3083         __ b(Ldo_update);
3084       } else {
3085         __ std(R0, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3086       }
3087     } else {
3088       if (do_update) {
3089         __ cmpdi(CCR0, obj, 0);
3090         __ beq(CCR0, Ldone);
3091       }
3092     }
3093 #ifdef ASSERT
3094   } else {
3095     __ cmpdi(CCR0, obj, 0);
3096     __ bne(CCR0, Lupdate);
3097     __ stop(&quot;unexpect null obj&quot;, 0x9652);
3098 #endif
3099   }
3100 
3101   __ bind(Lupdate);
3102   if (do_update) {
3103     Label Lnext;
3104     const Register klass = R29_TOC; // kill and reload
3105     bool klass_reg_used = false;
3106 #ifdef ASSERT
3107     if (exact_klass != NULL) {
3108       Label ok;
3109       klass_reg_used = true;
3110       __ load_klass(klass, obj);
3111       metadata2reg(exact_klass-&gt;constant_encoding(), R0);
3112       __ cmpd(CCR0, klass, R0);
3113       __ beq(CCR0, ok);
3114       __ stop(&quot;exact klass and actual klass differ&quot;, 0x8564);
3115       __ bind(ok);
3116     }
3117 #endif
3118 
3119     if (!no_conflict) {
3120       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3121         klass_reg_used = true;
3122         if (exact_klass != NULL) {
3123           __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3124           metadata2reg(exact_klass-&gt;constant_encoding(), klass);
3125         } else {
3126           __ load_klass(klass, obj);
3127           __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register()); // may kill obj
3128         }
3129 
3130         // Like InterpreterMacroAssembler::profile_obj_type
3131         __ clrrdi(R0, tmp, exact_log2(-TypeEntries::type_klass_mask));
3132         // Basically same as andi(R0, tmp, TypeEntries::type_klass_mask);
3133         __ cmpd(CCR1, R0, klass);
3134         // Klass seen before, nothing to do (regardless of unknown bit).
3135         //beq(CCR1, do_nothing);
3136 
3137         __ andi_(R0, klass, TypeEntries::type_unknown);
3138         // Already unknown. Nothing to do anymore.
3139         //bne(CCR0, do_nothing);
3140         __ crorc(CCR0, Assembler::equal, CCR1, Assembler::equal); // cr0 eq = cr1 eq or cr0 ne
3141         __ beq(CCR0, Lnext);
3142 
3143         if (TypeEntries::is_type_none(current_klass)) {
3144           __ clrrdi_(R0, tmp, exact_log2(-TypeEntries::type_mask));
3145           __ orr(R0, klass, tmp); // Combine klass and null_seen bit (only used if (tmp &amp; type_mask)==0).
3146           __ beq(CCR0, Ldo_update); // First time here. Set profile type.
3147         }
3148 
3149       } else {
3150         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3151                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3152 
3153         __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3154         __ andi_(R0, tmp, TypeEntries::type_unknown);
3155         // Already unknown. Nothing to do anymore.
3156         __ bne(CCR0, Lnext);
3157       }
3158 
3159       // Different than before. Cannot keep accurate profile.
3160       __ ori(R0, tmp, TypeEntries::type_unknown);
3161     } else {
3162       // There&#39;s a single possible klass at this profile point
3163       assert(exact_klass != NULL, &quot;should be&quot;);
3164       __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3165 
3166       if (TypeEntries::is_type_none(current_klass)) {
3167         klass_reg_used = true;
3168         metadata2reg(exact_klass-&gt;constant_encoding(), klass);
3169 
3170         __ clrrdi(R0, tmp, exact_log2(-TypeEntries::type_klass_mask));
3171         // Basically same as andi(R0, tmp, TypeEntries::type_klass_mask);
3172         __ cmpd(CCR1, R0, klass);
3173         // Klass seen before, nothing to do (regardless of unknown bit).
3174         __ beq(CCR1, Lnext);
3175 #ifdef ASSERT
3176         {
3177           Label ok;
3178           __ clrrdi_(R0, tmp, exact_log2(-TypeEntries::type_mask));
3179           __ beq(CCR0, ok); // First time here.
3180 
3181           __ stop(&quot;unexpected profiling mismatch&quot;, 0x7865);
3182           __ bind(ok);
3183         }
3184 #endif
3185         // First time here. Set profile type.
3186         __ orr(R0, klass, tmp); // Combine klass and null_seen bit (only used if (tmp &amp; type_mask)==0).
3187       } else {
3188         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3189                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3190 
3191         // Already unknown. Nothing to do anymore.
3192         __ andi_(R0, tmp, TypeEntries::type_unknown);
3193         __ bne(CCR0, Lnext);
3194 
3195         // Different than before. Cannot keep accurate profile.
3196         __ ori(R0, tmp, TypeEntries::type_unknown);
3197       }
3198     }
3199 
3200     __ bind(Ldo_update);
3201     __ std(R0, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3202 
3203     __ bind(Lnext);
3204     if (klass_reg_used) { __ load_const_optimized(R29_TOC, MacroAssembler::global_toc(), R0); } // reinit
3205   }
3206   __ bind(Ldone);
3207 }
3208 
3209 
3210 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3211   assert(op-&gt;crc()-&gt;is_single_cpu(), &quot;crc must be register&quot;);
3212   assert(op-&gt;val()-&gt;is_single_cpu(), &quot;byte value must be register&quot;);
3213   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3214   Register crc = op-&gt;crc()-&gt;as_register();
3215   Register val = op-&gt;val()-&gt;as_register();
3216   Register res = op-&gt;result_opr()-&gt;as_register();
3217 
3218   assert_different_registers(val, crc, res);
3219 
3220   __ load_const_optimized(res, StubRoutines::crc_table_addr(), R0);
3221   __ kernel_crc32_singleByteReg(crc, val, res, true);
3222   __ mr(res, crc);
3223 }
3224 
3225 #undef __
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
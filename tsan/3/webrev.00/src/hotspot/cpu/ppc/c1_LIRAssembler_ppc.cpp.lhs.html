<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/c1_LIRAssembler_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2019, SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified">  36 #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="line-removed">  37 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;</span>
  38 #include &quot;nativeInst_ppc.hpp&quot;
<a name="2" id="anc2"></a>
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
<a name="3" id="anc3"></a>
  43 
  44 #define __ _masm-&gt;
  45 
  46 
  47 const ConditionRegister LIR_Assembler::BOOL_RESULT = CCR5;
  48 
  49 
  50 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  51   Unimplemented(); return false; // Currently not used on this platform.
  52 }
  53 
  54 
  55 LIR_Opr LIR_Assembler::receiverOpr() {
  56   return FrameMap::R3_oop_opr;
  57 }
  58 
  59 
  60 LIR_Opr LIR_Assembler::osrBufferPointer() {
  61   return FrameMap::R3_opr;
  62 }
  63 
  64 
  65 // This specifies the stack pointer decrement needed to build the frame.
  66 int LIR_Assembler::initial_frame_size_in_bytes() const {
  67   return in_bytes(frame_map()-&gt;framesize_in_bytes());
  68 }
  69 
  70 
  71 // Inline cache check: the inline cached class is in inline_cache_reg;
  72 // we fetch the class of the receiver and compare it with the cached class.
  73 // If they do not match we jump to slow case.
  74 int LIR_Assembler::check_icache() {
  75   int offset = __ offset();
  76   __ inline_cache_check(R3_ARG1, R19_inline_cache_reg);
  77   return offset;
  78 }
  79 
<a name="4" id="anc4"></a>














  80 
  81 void LIR_Assembler::osr_entry() {
  82   // On-stack-replacement entry sequence:
  83   //
  84   //   1. Create a new compiled activation.
  85   //   2. Initialize local variables in the compiled activation. The expression
  86   //      stack must be empty at the osr_bci; it is not initialized.
  87   //   3. Jump to the continuation address in compiled code to resume execution.
  88 
  89   // OSR entry point
  90   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
  91   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
  92   ValueStack* entry_state = osr_entry-&gt;end()-&gt;state();
  93   int number_of_locks = entry_state-&gt;locks_size();
  94 
  95   // Create a frame for the compiled activation.
  96   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
  97 
  98   // OSR buffer is
  99   //
 100   // locals[nlocals-1..0]
 101   // monitors[number_of_locks-1..0]
 102   //
 103   // Locals is a direct copy of the interpreter frame so in the osr buffer
 104   // the first slot in the local array is the last local from the interpreter
 105   // and the last slot is local[0] (receiver) from the interpreter.
 106   //
 107   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 108   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 109   // in the interpreter frame (the method lock if a sync method).
 110 
 111   // Initialize monitors in the compiled activation.
 112   //   R3: pointer to osr buffer
 113   //
 114   // All other registers are dead at this point and the locals will be
 115   // copied into place by code emitted in the IR.
 116 
 117   Register OSR_buf = osrBufferPointer()-&gt;as_register();
 118   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 119     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 120       (2 * BytesPerWord) * (number_of_locks - 1);
 121     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 122     // the OSR buffer using 2 word entries: first the lock and then
 123     // the oop.
 124     for (int i = 0; i &lt; number_of_locks; i++) {
 125       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 126 #ifdef ASSERT
 127       // Verify the interpreter&#39;s monitor has a non-null object.
 128       {
 129         Label L;
 130         __ ld(R0, slot_offset + 1*BytesPerWord, OSR_buf);
 131         __ cmpdi(CCR0, R0, 0);
 132         __ bne(CCR0, L);
 133         __ stop(&quot;locked object is NULL&quot;);
 134         __ bind(L);
 135       }
 136 #endif // ASSERT
 137       // Copy the lock field into the compiled activation.
 138       Address ml = frame_map()-&gt;address_for_monitor_lock(i),
 139               mo = frame_map()-&gt;address_for_monitor_object(i);
 140       assert(ml.index() == noreg &amp;&amp; mo.index() == noreg, &quot;sanity&quot;);
 141       __ ld(R0, slot_offset + 0, OSR_buf);
 142       __ std(R0, ml.disp(), ml.base());
 143       __ ld(R0, slot_offset + 1*BytesPerWord, OSR_buf);
 144       __ std(R0, mo.disp(), mo.base());
 145     }
 146   }
 147 }
 148 
 149 
 150 int LIR_Assembler::emit_exception_handler() {
 151   // If the last instruction is a call (typically to do a throw which
 152   // is coming at the end after block reordering) the return address
 153   // must still point into the code area in order to avoid assertion
 154   // failures when searching for the corresponding bci =&gt; add a nop
 155   // (was bug 5/14/1999 - gri).
 156   __ nop();
 157 
 158   // Generate code for the exception handler.
 159   address handler_base = __ start_a_stub(exception_handler_size());
 160 
 161   if (handler_base == NULL) {
 162     // Not enough space left for the handler.
 163     bailout(&quot;exception handler overflow&quot;);
 164     return -1;
 165   }
 166 
 167   int offset = code_offset();
 168   address entry_point = CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::handle_exception_from_callee_id));
 169   //__ load_const_optimized(R0, entry_point);
 170   __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(entry_point));
 171   __ mtctr(R0);
 172   __ bctr();
 173 
 174   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 175   __ end_a_stub();
 176 
 177   return offset;
 178 }
 179 
 180 
 181 // Emit the code to remove the frame from the stack in the exception
 182 // unwind path.
 183 int LIR_Assembler::emit_unwind_handler() {
 184   _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 185 
 186   int offset = code_offset();
 187   bool preserve_exception = method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes();
 188   const Register Rexception = R3 /*LIRGenerator::exceptionOopOpr()*/, Rexception_save = R31;
 189 
 190   // Fetch the exception from TLS and clear out exception related thread state.
 191   __ ld(Rexception, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
 192   __ li(R0, 0);
 193   __ std(R0, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
 194   __ std(R0, in_bytes(JavaThread::exception_pc_offset()), R16_thread);
 195 
 196   __ bind(_unwind_handler_entry);
 197   __ verify_not_null_oop(Rexception);
 198   if (preserve_exception) { __ mr(Rexception_save, Rexception); }
 199 
 200   // Perform needed unlocking
 201   MonitorExitStub* stub = NULL;
 202   if (method()-&gt;is_synchronized()) {
 203     monitor_address(0, FrameMap::R4_opr);
 204     stub = new MonitorExitStub(FrameMap::R4_opr, true, 0);
 205     __ unlock_object(R5, R6, R4, *stub-&gt;entry());
 206     __ bind(*stub-&gt;continuation());
 207   }
 208 
 209   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 210     Unimplemented();
 211   }
 212 
 213   // Dispatch to the unwind logic.
 214   address unwind_stub = Runtime1::entry_for(Runtime1::unwind_exception_id);
 215   //__ load_const_optimized(R0, unwind_stub);
 216   __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(unwind_stub));
 217   if (preserve_exception) { __ mr(Rexception, Rexception_save); }
 218   __ mtctr(R0);
 219   __ bctr();
 220 
 221   // Emit the slow path assembly.
 222   if (stub != NULL) {
 223     stub-&gt;emit_code(this);
 224   }
 225 
 226   return offset;
 227 }
 228 
 229 
 230 int LIR_Assembler::emit_deopt_handler() {
 231   // If the last instruction is a call (typically to do a throw which
 232   // is coming at the end after block reordering) the return address
 233   // must still point into the code area in order to avoid assertion
 234   // failures when searching for the corresponding bci =&gt; add a nop
 235   // (was bug 5/14/1999 - gri).
 236   __ nop();
 237 
 238   // Generate code for deopt handler.
 239   address handler_base = __ start_a_stub(deopt_handler_size());
 240 
 241   if (handler_base == NULL) {
 242     // Not enough space left for the handler.
 243     bailout(&quot;deopt handler overflow&quot;);
 244     return -1;
 245   }
 246 
 247   int offset = code_offset();
 248   __ bl64_patchable(SharedRuntime::deopt_blob()-&gt;unpack(), relocInfo::runtime_call_type);
 249 
 250   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 251   __ end_a_stub();
 252 
 253   return offset;
 254 }
 255 
 256 
 257 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 258   if (o == NULL) {
 259     __ li(reg, 0);
 260   } else {
 261     AddressLiteral addrlit = __ constant_oop_address(o);
 262     __ load_const(reg, addrlit, (reg != R0) ? R0 : noreg);
 263   }
 264 }
 265 
 266 
 267 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 268   // Allocate a new index in table to hold the object once it&#39;s been patched.
 269   int oop_index = __ oop_recorder()-&gt;allocate_oop_index(NULL);
 270   PatchingStub* patch = new PatchingStub(_masm, patching_id(info), oop_index);
 271 
 272   AddressLiteral addrlit((address)NULL, oop_Relocation::spec(oop_index));
 273   __ load_const(reg, addrlit, R0);
 274 
 275   patching_epilog(patch, lir_patch_normal, reg, info);
 276 }
 277 
 278 
 279 void LIR_Assembler::metadata2reg(Metadata* o, Register reg) {
 280   AddressLiteral md = __ constant_metadata_address(o); // Notify OOP recorder (don&#39;t need the relocation)
 281   __ load_const_optimized(reg, md.value(), (reg != R0) ? R0 : noreg);
 282 }
 283 
 284 
 285 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo *info) {
 286   // Allocate a new index in table to hold the klass once it&#39;s been patched.
 287   int index = __ oop_recorder()-&gt;allocate_metadata_index(NULL);
 288   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id, index);
 289 
 290   AddressLiteral addrlit((address)NULL, metadata_Relocation::spec(index));
 291   assert(addrlit.rspec().type() == relocInfo::metadata_type, &quot;must be an metadata reloc&quot;);
 292   __ load_const(reg, addrlit, R0);
 293 
 294   patching_epilog(patch, lir_patch_normal, reg, info);
 295 }
 296 
 297 
 298 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
 299   const bool is_int = result-&gt;is_single_cpu();
 300   Register Rdividend = is_int ? left-&gt;as_register() : left-&gt;as_register_lo();
 301   Register Rdivisor  = noreg;
 302   Register Rscratch  = temp-&gt;as_register();
 303   Register Rresult   = is_int ? result-&gt;as_register() : result-&gt;as_register_lo();
 304   long divisor = -1;
 305 
 306   if (right-&gt;is_register()) {
 307     Rdivisor = is_int ? right-&gt;as_register() : right-&gt;as_register_lo();
 308   } else {
 309     divisor = is_int ? right-&gt;as_constant_ptr()-&gt;as_jint()
 310                      : right-&gt;as_constant_ptr()-&gt;as_jlong();
 311   }
 312 
 313   assert(Rdividend != Rscratch, &quot;&quot;);
 314   assert(Rdivisor  != Rscratch, &quot;&quot;);
 315   assert(code == lir_idiv || code == lir_irem, &quot;Must be irem or idiv&quot;);
 316 
 317   if (Rdivisor == noreg) {
 318     if (divisor == 1) { // stupid, but can happen
 319       if (code == lir_idiv) {
 320         __ mr_if_needed(Rresult, Rdividend);
 321       } else {
 322         __ li(Rresult, 0);
 323       }
 324 
 325     } else if (is_power_of_2(divisor)) {
 326       // Convert division by a power of two into some shifts and logical operations.
 327       int log2 = log2_intptr(divisor);
 328 
 329       // Round towards 0.
 330       if (divisor == 2) {
 331         if (is_int) {
 332           __ srwi(Rscratch, Rdividend, 31);
 333         } else {
 334           __ srdi(Rscratch, Rdividend, 63);
 335         }
 336       } else {
 337         if (is_int) {
 338           __ srawi(Rscratch, Rdividend, 31);
 339         } else {
 340           __ sradi(Rscratch, Rdividend, 63);
 341         }
 342         __ clrldi(Rscratch, Rscratch, 64-log2);
 343       }
 344       __ add(Rscratch, Rdividend, Rscratch);
 345 
 346       if (code == lir_idiv) {
 347         if (is_int) {
 348           __ srawi(Rresult, Rscratch, log2);
 349         } else {
 350           __ sradi(Rresult, Rscratch, log2);
 351         }
 352       } else { // lir_irem
 353         __ clrrdi(Rscratch, Rscratch, log2);
 354         __ sub(Rresult, Rdividend, Rscratch);
 355       }
 356 
 357     } else if (divisor == -1) {
 358       if (code == lir_idiv) {
 359         __ neg(Rresult, Rdividend);
 360       } else {
 361         __ li(Rresult, 0);
 362       }
 363 
 364     } else {
 365       __ load_const_optimized(Rscratch, divisor);
 366       if (code == lir_idiv) {
 367         if (is_int) {
 368           __ divw(Rresult, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 369         } else {
 370           __ divd(Rresult, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 371         }
 372       } else {
 373         assert(Rscratch != R0, &quot;need both&quot;);
 374         if (is_int) {
 375           __ divw(R0, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 376           __ mullw(Rscratch, R0, Rscratch);
 377         } else {
 378           __ divd(R0, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 379           __ mulld(Rscratch, R0, Rscratch);
 380         }
 381         __ sub(Rresult, Rdividend, Rscratch);
 382       }
 383 
 384     }
 385     return;
 386   }
 387 
 388   Label regular, done;
 389   if (is_int) {
 390     __ cmpwi(CCR0, Rdivisor, -1);
 391   } else {
 392     __ cmpdi(CCR0, Rdivisor, -1);
 393   }
 394   __ bne(CCR0, regular);
 395   if (code == lir_idiv) {
 396     __ neg(Rresult, Rdividend);
 397     __ b(done);
 398     __ bind(regular);
 399     if (is_int) {
 400       __ divw(Rresult, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 401     } else {
 402       __ divd(Rresult, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 403     }
 404   } else { // lir_irem
 405     __ li(Rresult, 0);
 406     __ b(done);
 407     __ bind(regular);
 408     if (is_int) {
 409       __ divw(Rscratch, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 410       __ mullw(Rscratch, Rscratch, Rdivisor);
 411     } else {
 412       __ divd(Rscratch, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 413       __ mulld(Rscratch, Rscratch, Rdivisor);
 414     }
 415     __ sub(Rresult, Rdividend, Rscratch);
 416   }
 417   __ bind(done);
 418 }
 419 
 420 
 421 void LIR_Assembler::emit_op3(LIR_Op3* op) {
 422   switch (op-&gt;code()) {
 423   case lir_idiv:
 424   case lir_irem:
 425     arithmetic_idiv(op-&gt;code(), op-&gt;in_opr1(), op-&gt;in_opr2(), op-&gt;in_opr3(),
 426                     op-&gt;result_opr(), op-&gt;info());
 427     break;
 428   case lir_fmad:
 429     __ fmadd(op-&gt;result_opr()-&gt;as_double_reg(), op-&gt;in_opr1()-&gt;as_double_reg(),
 430              op-&gt;in_opr2()-&gt;as_double_reg(), op-&gt;in_opr3()-&gt;as_double_reg());
 431     break;
 432   case lir_fmaf:
 433     __ fmadds(op-&gt;result_opr()-&gt;as_float_reg(), op-&gt;in_opr1()-&gt;as_float_reg(),
 434               op-&gt;in_opr2()-&gt;as_float_reg(), op-&gt;in_opr3()-&gt;as_float_reg());
 435     break;
 436   default: ShouldNotReachHere(); break;
 437   }
 438 }
 439 
 440 
 441 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
 442 #ifdef ASSERT
 443   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
 444   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
 445   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
 446   assert(op-&gt;info() == NULL, &quot;shouldn&#39;t have CodeEmitInfo&quot;);
 447 #endif
 448 
 449   Label *L = op-&gt;label();
 450   if (op-&gt;cond() == lir_cond_always) {
 451     __ b(*L);
 452   } else {
 453     Label done;
 454     bool is_unordered = false;
 455     if (op-&gt;code() == lir_cond_float_branch) {
 456       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
 457       is_unordered = true;
 458     } else {
 459       assert(op-&gt;code() == lir_branch, &quot;just checking&quot;);
 460     }
 461 
 462     bool positive = false;
 463     Assembler::Condition cond = Assembler::equal;
 464     switch (op-&gt;cond()) {
 465       case lir_cond_equal:        positive = true ; cond = Assembler::equal  ; is_unordered = false; break;
 466       case lir_cond_notEqual:     positive = false; cond = Assembler::equal  ; is_unordered = false; break;
 467       case lir_cond_less:         positive = true ; cond = Assembler::less   ; break;
 468       case lir_cond_belowEqual:   assert(op-&gt;code() != lir_cond_float_branch, &quot;&quot;); // fallthru
 469       case lir_cond_lessEqual:    positive = false; cond = Assembler::greater; break;
 470       case lir_cond_greater:      positive = true ; cond = Assembler::greater; break;
 471       case lir_cond_aboveEqual:   assert(op-&gt;code() != lir_cond_float_branch, &quot;&quot;); // fallthru
 472       case lir_cond_greaterEqual: positive = false; cond = Assembler::less   ; break;
 473       default:                    ShouldNotReachHere();
 474     }
 475     int bo = positive ? Assembler::bcondCRbiIs1 : Assembler::bcondCRbiIs0;
 476     int bi = Assembler::bi0(BOOL_RESULT, cond);
 477     if (is_unordered) {
 478       if (positive) {
 479         if (op-&gt;ublock() == op-&gt;block()) {
 480           __ bc_far_optimized(Assembler::bcondCRbiIs1, __ bi0(BOOL_RESULT, Assembler::summary_overflow), *L);
 481         }
 482       } else {
 483         if (op-&gt;ublock() != op-&gt;block()) { __ bso(BOOL_RESULT, done); }
 484       }
 485     }
 486     __ bc_far_optimized(bo, bi, *L);
 487     __ bind(done);
 488   }
 489 }
 490 
 491 
 492 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
 493   Bytecodes::Code code = op-&gt;bytecode();
 494   LIR_Opr src = op-&gt;in_opr(),
 495           dst = op-&gt;result_opr();
 496 
 497   switch(code) {
 498     case Bytecodes::_i2l: {
 499       __ extsw(dst-&gt;as_register_lo(), src-&gt;as_register());
 500       break;
 501     }
 502     case Bytecodes::_l2i: {
 503       __ mr_if_needed(dst-&gt;as_register(), src-&gt;as_register_lo()); // high bits are garbage
 504       break;
 505     }
 506     case Bytecodes::_i2b: {
 507       __ extsb(dst-&gt;as_register(), src-&gt;as_register());
 508       break;
 509     }
 510     case Bytecodes::_i2c: {
 511       __ clrldi(dst-&gt;as_register(), src-&gt;as_register(), 64-16);
 512       break;
 513     }
 514     case Bytecodes::_i2s: {
 515       __ extsh(dst-&gt;as_register(), src-&gt;as_register());
 516       break;
 517     }
 518     case Bytecodes::_i2d:
 519     case Bytecodes::_l2d: {
 520       bool src_in_memory = !VM_Version::has_mtfprd();
 521       FloatRegister rdst = dst-&gt;as_double_reg();
 522       FloatRegister rsrc;
 523       if (src_in_memory) {
 524         rsrc = src-&gt;as_double_reg(); // via mem
 525       } else {
 526         // move src to dst register
 527         if (code == Bytecodes::_i2d) {
 528           __ mtfprwa(rdst, src-&gt;as_register());
 529         } else {
 530           __ mtfprd(rdst, src-&gt;as_register_lo());
 531         }
 532         rsrc = rdst;
 533       }
 534       __ fcfid(rdst, rsrc);
 535       break;
 536     }
 537     case Bytecodes::_i2f:
 538     case Bytecodes::_l2f: {
 539       bool src_in_memory = !VM_Version::has_mtfprd();
 540       FloatRegister rdst = dst-&gt;as_float_reg();
 541       FloatRegister rsrc;
 542       if (src_in_memory) {
 543         rsrc = src-&gt;as_double_reg(); // via mem
 544       } else {
 545         // move src to dst register
 546         if (code == Bytecodes::_i2f) {
 547           __ mtfprwa(rdst, src-&gt;as_register());
 548         } else {
 549           __ mtfprd(rdst, src-&gt;as_register_lo());
 550         }
 551         rsrc = rdst;
 552       }
 553       if (VM_Version::has_fcfids()) {
 554         __ fcfids(rdst, rsrc);
 555       } else {
 556         assert(code == Bytecodes::_i2f, &quot;fcfid+frsp needs fixup code to avoid rounding incompatibility&quot;);
 557         __ fcfid(rdst, rsrc);
 558         __ frsp(rdst, rdst);
 559       }
 560       break;
 561     }
 562     case Bytecodes::_f2d: {
 563       __ fmr_if_needed(dst-&gt;as_double_reg(), src-&gt;as_float_reg());
 564       break;
 565     }
 566     case Bytecodes::_d2f: {
 567       __ frsp(dst-&gt;as_float_reg(), src-&gt;as_double_reg());
 568       break;
 569     }
 570     case Bytecodes::_d2i:
 571     case Bytecodes::_f2i: {
 572       bool dst_in_memory = !VM_Version::has_mtfprd();
 573       FloatRegister rsrc = (code == Bytecodes::_d2i) ? src-&gt;as_double_reg() : src-&gt;as_float_reg();
 574       Address       addr = dst_in_memory ? frame_map()-&gt;address_for_slot(dst-&gt;double_stack_ix()) : NULL;
 575       Label L;
 576       // Result must be 0 if value is NaN; test by comparing value to itself.
 577       __ fcmpu(CCR0, rsrc, rsrc);
 578       if (dst_in_memory) {
 579         __ li(R0, 0); // 0 in case of NAN
 580         __ std(R0, addr.disp(), addr.base());
 581       } else {
 582         __ li(dst-&gt;as_register(), 0);
 583       }
 584       __ bso(CCR0, L);
 585       __ fctiwz(rsrc, rsrc); // USE_KILL
 586       if (dst_in_memory) {
 587         __ stfd(rsrc, addr.disp(), addr.base());
 588       } else {
 589         __ mffprd(dst-&gt;as_register(), rsrc);
 590       }
 591       __ bind(L);
 592       break;
 593     }
 594     case Bytecodes::_d2l:
 595     case Bytecodes::_f2l: {
 596       bool dst_in_memory = !VM_Version::has_mtfprd();
 597       FloatRegister rsrc = (code == Bytecodes::_d2l) ? src-&gt;as_double_reg() : src-&gt;as_float_reg();
 598       Address       addr = dst_in_memory ? frame_map()-&gt;address_for_slot(dst-&gt;double_stack_ix()) : NULL;
 599       Label L;
 600       // Result must be 0 if value is NaN; test by comparing value to itself.
 601       __ fcmpu(CCR0, rsrc, rsrc);
 602       if (dst_in_memory) {
 603         __ li(R0, 0); // 0 in case of NAN
 604         __ std(R0, addr.disp(), addr.base());
 605       } else {
 606         __ li(dst-&gt;as_register_lo(), 0);
 607       }
 608       __ bso(CCR0, L);
 609       __ fctidz(rsrc, rsrc); // USE_KILL
 610       if (dst_in_memory) {
 611         __ stfd(rsrc, addr.disp(), addr.base());
 612       } else {
 613         __ mffprd(dst-&gt;as_register_lo(), rsrc);
 614       }
 615       __ bind(L);
 616       break;
 617     }
 618 
 619     default: ShouldNotReachHere();
 620   }
 621 }
 622 
 623 
 624 void LIR_Assembler::align_call(LIR_Code) {
 625   // do nothing since all instructions are word aligned on ppc
 626 }
 627 
 628 
 629 bool LIR_Assembler::emit_trampoline_stub_for_call(address target, Register Rtoc) {
 630   int start_offset = __ offset();
 631   // Put the entry point as a constant into the constant pool.
 632   const address entry_point_toc_addr   = __ address_constant(target, RelocationHolder::none);
 633   if (entry_point_toc_addr == NULL) {
 634     bailout(&quot;const section overflow&quot;);
 635     return false;
 636   }
 637   const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 638 
 639   // Emit the trampoline stub which will be related to the branch-and-link below.
 640   address stub = __ emit_trampoline_stub(entry_point_toc_offset, start_offset, Rtoc);
 641   if (!stub) {
 642     bailout(&quot;no space for trampoline stub&quot;);
 643     return false;
 644   }
 645   return true;
 646 }
 647 
 648 
 649 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
 650   assert(rtype==relocInfo::opt_virtual_call_type || rtype==relocInfo::static_call_type, &quot;unexpected rtype&quot;);
 651 
 652   bool success = emit_trampoline_stub_for_call(op-&gt;addr());
 653   if (!success) { return; }
 654 
 655   __ relocate(rtype);
 656   // Note: At this point we do not have the address of the trampoline
 657   // stub, and the entry point might be too far away for bl, so __ pc()
 658   // serves as dummy and the bl will be patched later.
 659   __ code()-&gt;set_insts_mark();
 660   __ bl(__ pc());
 661   add_call_info(code_offset(), op-&gt;info());
 662 }
 663 
 664 
 665 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
 666   __ calculate_address_from_global_toc(R2_TOC, __ method_toc());
 667 
 668   // Virtual call relocation will point to ic load.
 669   address virtual_call_meta_addr = __ pc();
 670   // Load a clear inline cache.
 671   AddressLiteral empty_ic((address) Universe::non_oop_word());
 672   bool success = __ load_const_from_method_toc(R19_inline_cache_reg, empty_ic, R2_TOC);
 673   if (!success) {
 674     bailout(&quot;const section overflow&quot;);
 675     return;
 676   }
 677   // Call to fixup routine. Fixup routine uses ScopeDesc info
 678   // to determine who we intended to call.
 679   __ relocate(virtual_call_Relocation::spec(virtual_call_meta_addr));
 680 
 681   success = emit_trampoline_stub_for_call(op-&gt;addr(), R2_TOC);
 682   if (!success) { return; }
 683 
 684   // Note: At this point we do not have the address of the trampoline
 685   // stub, and the entry point might be too far away for bl, so __ pc()
 686   // serves as dummy and the bl will be patched later.
 687   __ bl(__ pc());
 688   add_call_info(code_offset(), op-&gt;info());
 689 }
 690 
 691 
 692 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
 693   ShouldNotReachHere(); // ic_call is used instead.
 694 }
 695 
 696 
 697 void LIR_Assembler::explicit_null_check(Register addr, CodeEmitInfo* info) {
 698   ImplicitNullCheckStub* stub = new ImplicitNullCheckStub(code_offset(), info);
 699   __ null_check(addr, stub-&gt;entry());
 700   append_code_stub(stub);
 701 }
 702 
 703 
 704 // Attention: caller must encode oop if needed
 705 int LIR_Assembler::store(LIR_Opr from_reg, Register base, int offset, BasicType type, bool wide, bool unaligned) {
 706   int store_offset;
 707   if (!Assembler::is_simm16(offset)) {
 708     // For offsets larger than a simm16 we setup the offset.
 709     assert(wide &amp;&amp; !from_reg-&gt;is_same_register(FrameMap::R0_opr), &quot;large offset only supported in special case&quot;);
 710     __ load_const_optimized(R0, offset);
 711     store_offset = store(from_reg, base, R0, type, wide);
 712   } else {
 713     store_offset = code_offset();
 714     switch (type) {
 715       case T_BOOLEAN: // fall through
 716       case T_BYTE  : __ stb(from_reg-&gt;as_register(), offset, base); break;
 717       case T_CHAR  :
 718       case T_SHORT : __ sth(from_reg-&gt;as_register(), offset, base); break;
 719       case T_INT   : __ stw(from_reg-&gt;as_register(), offset, base); break;
 720       case T_LONG  : __ std(from_reg-&gt;as_register_lo(), offset, base); break;
 721       case T_ADDRESS:
 722       case T_METADATA: __ std(from_reg-&gt;as_register(), offset, base); break;
 723       case T_ARRAY : // fall through
 724       case T_OBJECT:
 725         {
 726           if (UseCompressedOops &amp;&amp; !wide) {
 727             // Encoding done in caller
 728             __ stw(from_reg-&gt;as_register(), offset, base);
<a name="5" id="anc5"></a>
 729           } else {
 730             __ std(from_reg-&gt;as_register(), offset, base);
<a name="6" id="anc6"></a>
 731           }
<a name="7" id="anc7"></a><span class="line-removed"> 732           __ verify_oop(from_reg-&gt;as_register());</span>
 733           break;
 734         }
 735       case T_FLOAT : __ stfs(from_reg-&gt;as_float_reg(), offset, base); break;
 736       case T_DOUBLE: __ stfd(from_reg-&gt;as_double_reg(), offset, base); break;
 737       default      : ShouldNotReachHere();
 738     }
 739   }
 740   return store_offset;
 741 }
 742 
 743 
 744 // Attention: caller must encode oop if needed
 745 int LIR_Assembler::store(LIR_Opr from_reg, Register base, Register disp, BasicType type, bool wide) {
 746   int store_offset = code_offset();
 747   switch (type) {
 748     case T_BOOLEAN: // fall through
 749     case T_BYTE  : __ stbx(from_reg-&gt;as_register(), base, disp); break;
 750     case T_CHAR  :
 751     case T_SHORT : __ sthx(from_reg-&gt;as_register(), base, disp); break;
 752     case T_INT   : __ stwx(from_reg-&gt;as_register(), base, disp); break;
 753     case T_LONG  :
 754 #ifdef _LP64
 755       __ stdx(from_reg-&gt;as_register_lo(), base, disp);
 756 #else
 757       Unimplemented();
 758 #endif
 759       break;
 760     case T_ADDRESS:
 761       __ stdx(from_reg-&gt;as_register(), base, disp);
 762       break;
 763     case T_ARRAY : // fall through
 764     case T_OBJECT:
 765       {
 766         if (UseCompressedOops &amp;&amp; !wide) {
 767           // Encoding done in caller.
 768           __ stwx(from_reg-&gt;as_register(), base, disp);
<a name="8" id="anc8"></a>
 769         } else {
 770           __ stdx(from_reg-&gt;as_register(), base, disp);
<a name="9" id="anc9"></a>
 771         }
<a name="10" id="anc10"></a><span class="line-removed"> 772         __ verify_oop(from_reg-&gt;as_register()); // kills R0</span>
 773         break;
 774       }
 775     case T_FLOAT : __ stfsx(from_reg-&gt;as_float_reg(), base, disp); break;
 776     case T_DOUBLE: __ stfdx(from_reg-&gt;as_double_reg(), base, disp); break;
 777     default      : ShouldNotReachHere();
 778   }
 779   return store_offset;
 780 }
 781 
 782 
 783 int LIR_Assembler::load(Register base, int offset, LIR_Opr to_reg, BasicType type, bool wide, bool unaligned) {
 784   int load_offset;
 785   if (!Assembler::is_simm16(offset)) {
 786     // For offsets larger than a simm16 we setup the offset.
 787     __ load_const_optimized(R0, offset);
 788     load_offset = load(base, R0, to_reg, type, wide);
 789   } else {
 790     load_offset = code_offset();
 791     switch(type) {
 792       case T_BOOLEAN: // fall through
 793       case T_BYTE  :   __ lbz(to_reg-&gt;as_register(), offset, base);
 794                        __ extsb(to_reg-&gt;as_register(), to_reg-&gt;as_register()); break;
 795       case T_CHAR  :   __ lhz(to_reg-&gt;as_register(), offset, base); break;
 796       case T_SHORT :   __ lha(to_reg-&gt;as_register(), offset, base); break;
 797       case T_INT   :   __ lwa(to_reg-&gt;as_register(), offset, base); break;
 798       case T_LONG  :   __ ld(to_reg-&gt;as_register_lo(), offset, base); break;
 799       case T_METADATA: __ ld(to_reg-&gt;as_register(), offset, base); break;
 800       case T_ADDRESS:
 801         if (offset == oopDesc::klass_offset_in_bytes() &amp;&amp; UseCompressedClassPointers) {
 802           __ lwz(to_reg-&gt;as_register(), offset, base);
 803           __ decode_klass_not_null(to_reg-&gt;as_register());
 804         } else {
 805           __ ld(to_reg-&gt;as_register(), offset, base);
 806         }
 807         break;
 808       case T_ARRAY : // fall through
 809       case T_OBJECT:
 810         {
 811           if (UseCompressedOops &amp;&amp; !wide) {
 812             __ lwz(to_reg-&gt;as_register(), offset, base);
 813             __ decode_heap_oop(to_reg-&gt;as_register());
 814           } else {
 815             __ ld(to_reg-&gt;as_register(), offset, base);
 816           }
<a name="11" id="anc11"></a><span class="line-modified"> 817           __ verify_oop(to_reg-&gt;as_register());</span>
 818           break;
 819         }
 820       case T_FLOAT:  __ lfs(to_reg-&gt;as_float_reg(), offset, base); break;
 821       case T_DOUBLE: __ lfd(to_reg-&gt;as_double_reg(), offset, base); break;
 822       default      : ShouldNotReachHere();
 823     }
 824   }
 825   return load_offset;
 826 }
 827 
 828 
 829 int LIR_Assembler::load(Register base, Register disp, LIR_Opr to_reg, BasicType type, bool wide) {
 830   int load_offset = code_offset();
 831   switch(type) {
 832     case T_BOOLEAN: // fall through
 833     case T_BYTE  :  __ lbzx(to_reg-&gt;as_register(), base, disp);
 834                     __ extsb(to_reg-&gt;as_register(), to_reg-&gt;as_register()); break;
 835     case T_CHAR  :  __ lhzx(to_reg-&gt;as_register(), base, disp); break;
 836     case T_SHORT :  __ lhax(to_reg-&gt;as_register(), base, disp); break;
 837     case T_INT   :  __ lwax(to_reg-&gt;as_register(), base, disp); break;
 838     case T_ADDRESS: __ ldx(to_reg-&gt;as_register(), base, disp); break;
 839     case T_ARRAY : // fall through
 840     case T_OBJECT:
 841       {
 842         if (UseCompressedOops &amp;&amp; !wide) {
 843           __ lwzx(to_reg-&gt;as_register(), base, disp);
 844           __ decode_heap_oop(to_reg-&gt;as_register());
 845         } else {
 846           __ ldx(to_reg-&gt;as_register(), base, disp);
 847         }
<a name="12" id="anc12"></a><span class="line-modified"> 848         __ verify_oop(to_reg-&gt;as_register());</span>
 849         break;
 850       }
 851     case T_FLOAT:  __ lfsx(to_reg-&gt;as_float_reg() , base, disp); break;
 852     case T_DOUBLE: __ lfdx(to_reg-&gt;as_double_reg(), base, disp); break;
 853     case T_LONG  :
 854 #ifdef _LP64
 855       __ ldx(to_reg-&gt;as_register_lo(), base, disp);
 856 #else
 857       Unimplemented();
 858 #endif
 859       break;
 860     default      : ShouldNotReachHere();
 861   }
 862   return load_offset;
 863 }
 864 
 865 
 866 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 867   LIR_Const* c = src-&gt;as_constant_ptr();
 868   Register src_reg = R0;
 869   switch (c-&gt;type()) {
 870     case T_INT:
 871     case T_FLOAT: {
 872       int value = c-&gt;as_jint_bits();
 873       __ load_const_optimized(src_reg, value);
 874       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 875       __ stw(src_reg, addr.disp(), addr.base());
 876       break;
 877     }
 878     case T_ADDRESS: {
 879       int value = c-&gt;as_jint_bits();
 880       __ load_const_optimized(src_reg, value);
 881       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 882       __ std(src_reg, addr.disp(), addr.base());
 883       break;
 884     }
 885     case T_OBJECT: {
 886       jobject2reg(c-&gt;as_jobject(), src_reg);
 887       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 888       __ std(src_reg, addr.disp(), addr.base());
 889       break;
 890     }
 891     case T_LONG:
 892     case T_DOUBLE: {
 893       int value = c-&gt;as_jlong_bits();
 894       __ load_const_optimized(src_reg, value);
 895       Address addr = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
 896       __ std(src_reg, addr.disp(), addr.base());
 897       break;
 898     }
 899     default:
 900       Unimplemented();
 901   }
 902 }
 903 
 904 
 905 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 906   LIR_Const* c = src-&gt;as_constant_ptr();
 907   LIR_Address* addr = dest-&gt;as_address_ptr();
 908   Register base = addr-&gt;base()-&gt;as_pointer_register();
 909   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 910   int offset = -1;
 911   // Null check for large offsets in LIRGenerator::do_StoreField.
 912   bool needs_explicit_null_check = !ImplicitNullChecks;
 913 
 914   if (info != NULL &amp;&amp; needs_explicit_null_check) {
 915     explicit_null_check(base, info);
 916   }
 917 
 918   switch (c-&gt;type()) {
 919     case T_FLOAT: type = T_INT;
 920     case T_INT:
 921     case T_ADDRESS: {
 922       tmp = FrameMap::R0_opr;
 923       __ load_const_optimized(tmp-&gt;as_register(), c-&gt;as_jint_bits());
 924       break;
 925     }
 926     case T_DOUBLE: type = T_LONG;
 927     case T_LONG: {
 928       tmp = FrameMap::R0_long_opr;
 929       __ load_const_optimized(tmp-&gt;as_register_lo(), c-&gt;as_jlong_bits());
 930       break;
 931     }
 932     case T_OBJECT: {
 933       tmp = FrameMap::R0_opr;
 934       if (UseCompressedOops &amp;&amp; !wide &amp;&amp; c-&gt;as_jobject() != NULL) {
 935         AddressLiteral oop_addr = __ constant_oop_address(c-&gt;as_jobject());
 936         __ lis(R0, oop_addr.value() &gt;&gt; 16); // Don&#39;t care about sign extend (will use stw).
 937         __ relocate(oop_addr.rspec(), /*compressed format*/ 1);
 938         __ ori(R0, R0, oop_addr.value() &amp; 0xffff);
 939       } else {
 940         jobject2reg(c-&gt;as_jobject(), R0);
 941       }
 942       break;
 943     }
 944     default:
 945       Unimplemented();
 946   }
 947 
 948   // Handle either reg+reg or reg+disp address.
 949   if (addr-&gt;index()-&gt;is_valid()) {
 950     assert(addr-&gt;disp() == 0, &quot;must be zero&quot;);
 951     offset = store(tmp, base, addr-&gt;index()-&gt;as_pointer_register(), type, wide);
 952   } else {
 953     assert(Assembler::is_simm16(addr-&gt;disp()), &quot;can&#39;t handle larger addresses&quot;);
 954     offset = store(tmp, base, addr-&gt;disp(), type, wide, false);
 955   }
 956 
 957   if (info != NULL) {
 958     assert(offset != -1, &quot;offset should&#39;ve been set&quot;);
 959     if (!needs_explicit_null_check) {
 960       add_debug_info_for_null_check(offset, info);
 961     }
 962   }
 963 }
 964 
 965 
 966 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 967   LIR_Const* c = src-&gt;as_constant_ptr();
 968   LIR_Opr to_reg = dest;
 969 
 970   switch (c-&gt;type()) {
 971     case T_INT: {
 972       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 973       __ load_const_optimized(dest-&gt;as_register(), c-&gt;as_jint(), R0);
 974       break;
 975     }
 976     case T_ADDRESS: {
 977       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 978       __ load_const_optimized(dest-&gt;as_register(), c-&gt;as_jint(), R0);  // Yes, as_jint ...
 979       break;
 980     }
 981     case T_LONG: {
 982       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 983       __ load_const_optimized(dest-&gt;as_register_lo(), c-&gt;as_jlong(), R0);
 984       break;
 985     }
 986 
 987     case T_OBJECT: {
 988       if (patch_code == lir_patch_none) {
 989         jobject2reg(c-&gt;as_jobject(), to_reg-&gt;as_register());
 990       } else {
 991         jobject2reg_with_patching(to_reg-&gt;as_register(), info);
 992       }
 993       break;
 994     }
 995 
 996     case T_METADATA:
 997       {
 998         if (patch_code == lir_patch_none) {
 999           metadata2reg(c-&gt;as_metadata(), to_reg-&gt;as_register());
1000         } else {
1001           klass2reg_with_patching(to_reg-&gt;as_register(), info);
1002         }
1003       }
1004       break;
1005 
1006     case T_FLOAT:
1007       {
1008         if (to_reg-&gt;is_single_fpu()) {
1009           address const_addr = __ float_constant(c-&gt;as_jfloat());
1010           if (const_addr == NULL) {
1011             bailout(&quot;const section overflow&quot;);
1012             break;
1013           }
1014           RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1015           __ relocate(rspec);
1016           __ load_const(R0, const_addr);
1017           __ lfsx(to_reg-&gt;as_float_reg(), R0);
1018         } else {
1019           assert(to_reg-&gt;is_single_cpu(), &quot;Must be a cpu register.&quot;);
1020           __ load_const_optimized(to_reg-&gt;as_register(), jint_cast(c-&gt;as_jfloat()), R0);
1021         }
1022       }
1023       break;
1024 
1025     case T_DOUBLE:
1026       {
1027         if (to_reg-&gt;is_double_fpu()) {
1028           address const_addr = __ double_constant(c-&gt;as_jdouble());
1029           if (const_addr == NULL) {
1030             bailout(&quot;const section overflow&quot;);
1031             break;
1032           }
1033           RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1034           __ relocate(rspec);
1035           __ load_const(R0, const_addr);
1036           __ lfdx(to_reg-&gt;as_double_reg(), R0);
1037         } else {
1038           assert(to_reg-&gt;is_double_cpu(), &quot;Must be a long register.&quot;);
1039           __ load_const_optimized(to_reg-&gt;as_register_lo(), jlong_cast(c-&gt;as_jdouble()), R0);
1040         }
1041       }
1042       break;
1043 
1044     default:
1045       ShouldNotReachHere();
1046   }
1047 }
1048 
1049 
1050 Address LIR_Assembler::as_Address(LIR_Address* addr) {
1051   Unimplemented(); return Address();
1052 }
1053 
1054 
1055 inline RegisterOrConstant index_or_disp(LIR_Address* addr) {
1056   if (addr-&gt;index()-&gt;is_illegal()) {
1057     return (RegisterOrConstant)(addr-&gt;disp());
1058   } else {
1059     return (RegisterOrConstant)(addr-&gt;index()-&gt;as_pointer_register());
1060   }
1061 }
1062 
1063 
1064 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1065   const Register tmp = R0;
1066   switch (type) {
1067     case T_INT:
1068     case T_FLOAT: {
1069       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1070       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1071       __ lwz(tmp, from.disp(), from.base());
1072       __ stw(tmp, to.disp(), to.base());
1073       break;
1074     }
1075     case T_ADDRESS:
1076     case T_OBJECT: {
1077       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1078       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1079       __ ld(tmp, from.disp(), from.base());
1080       __ std(tmp, to.disp(), to.base());
1081       break;
1082     }
1083     case T_LONG:
1084     case T_DOUBLE: {
1085       Address from = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1086       Address to   = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
1087       __ ld(tmp, from.disp(), from.base());
1088       __ std(tmp, to.disp(), to.base());
1089       break;
1090     }
1091 
1092     default:
1093       ShouldNotReachHere();
1094   }
1095 }
1096 
1097 
1098 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
1099   Unimplemented(); return Address();
1100 }
1101 
1102 
1103 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
1104   Unimplemented(); return Address();
1105 }
1106 
1107 
1108 void LIR_Assembler::mem2reg(LIR_Opr src_opr, LIR_Opr dest, BasicType type,
1109                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool unaligned) {
1110 
1111   assert(type != T_METADATA, &quot;load of metadata ptr not supported&quot;);
1112   LIR_Address* addr = src_opr-&gt;as_address_ptr();
1113   LIR_Opr to_reg = dest;
1114 
1115   Register src = addr-&gt;base()-&gt;as_pointer_register();
1116   Register disp_reg = noreg;
1117   int disp_value = addr-&gt;disp();
1118   bool needs_patching = (patch_code != lir_patch_none);
1119   // null check for large offsets in LIRGenerator::do_LoadField
1120   bool needs_explicit_null_check = !os::zero_page_read_protected() || !ImplicitNullChecks;
1121 
1122   if (info != NULL &amp;&amp; needs_explicit_null_check) {
1123     explicit_null_check(src, info);
1124   }
1125 
1126   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
<a name="13" id="anc13"></a><span class="line-modified">1127     __ verify_oop(src);</span>
1128   }
1129 
1130   PatchingStub* patch = NULL;
1131   if (needs_patching) {
1132     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1133     assert(!to_reg-&gt;is_double_cpu() ||
1134            patch_code == lir_patch_none ||
1135            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1136   }
1137 
1138   if (addr-&gt;index()-&gt;is_illegal()) {
1139     if (!Assembler::is_simm16(disp_value)) {
1140       if (needs_patching) {
1141         __ load_const32(R0, 0); // patchable int
1142       } else {
1143         __ load_const_optimized(R0, disp_value);
1144       }
1145       disp_reg = R0;
1146     }
1147   } else {
1148     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1149     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1150   }
1151 
1152   // Remember the offset of the load. The patching_epilog must be done
1153   // before the call to add_debug_info, otherwise the PcDescs don&#39;t get
1154   // entered in increasing order.
1155   int offset;
1156 
1157   if (disp_reg == noreg) {
1158     assert(Assembler::is_simm16(disp_value), &quot;should have set this up&quot;);
1159     offset = load(src, disp_value, to_reg, type, wide, unaligned);
1160   } else {
1161     assert(!unaligned, &quot;unexpected&quot;);
1162     offset = load(src, disp_reg, to_reg, type, wide);
1163   }
1164 
1165   if (patch != NULL) {
1166     patching_epilog(patch, patch_code, src, info);
1167   }
1168   if (info != NULL &amp;&amp; !needs_explicit_null_check) {
1169     add_debug_info_for_null_check(offset, info);
1170   }
1171 }
1172 
1173 
1174 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1175   Address addr;
1176   if (src-&gt;is_single_word()) {
1177     addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1178   } else if (src-&gt;is_double_word())  {
1179     addr = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1180   }
1181 
1182   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1183   load(addr.base(), addr.disp(), dest, dest-&gt;type(), true /*wide*/, unaligned);
1184 }
1185 
1186 
1187 void LIR_Assembler::reg2stack(LIR_Opr from_reg, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
1188   Address addr;
1189   if (dest-&gt;is_single_word()) {
1190     addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1191   } else if (dest-&gt;is_double_word())  {
1192     addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1193   }
1194   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1195   store(from_reg, addr.base(), addr.disp(), from_reg-&gt;type(), true /*wide*/, unaligned);
1196 }
1197 
1198 
1199 void LIR_Assembler::reg2reg(LIR_Opr from_reg, LIR_Opr to_reg) {
1200   if (from_reg-&gt;is_float_kind() &amp;&amp; to_reg-&gt;is_float_kind()) {
1201     if (from_reg-&gt;is_double_fpu()) {
1202       // double to double moves
1203       assert(to_reg-&gt;is_double_fpu(), &quot;should match&quot;);
1204       __ fmr_if_needed(to_reg-&gt;as_double_reg(), from_reg-&gt;as_double_reg());
1205     } else {
1206       // float to float moves
1207       assert(to_reg-&gt;is_single_fpu(), &quot;should match&quot;);
1208       __ fmr_if_needed(to_reg-&gt;as_float_reg(), from_reg-&gt;as_float_reg());
1209     }
1210   } else if (!from_reg-&gt;is_float_kind() &amp;&amp; !to_reg-&gt;is_float_kind()) {
1211     if (from_reg-&gt;is_double_cpu()) {
1212       __ mr_if_needed(to_reg-&gt;as_pointer_register(), from_reg-&gt;as_pointer_register());
1213     } else if (to_reg-&gt;is_double_cpu()) {
1214       // int to int moves
1215       __ mr_if_needed(to_reg-&gt;as_register_lo(), from_reg-&gt;as_register());
1216     } else {
1217       // int to int moves
1218       __ mr_if_needed(to_reg-&gt;as_register(), from_reg-&gt;as_register());
1219     }
1220   } else {
1221     ShouldNotReachHere();
1222   }
<a name="14" id="anc14"></a><span class="line-modified">1223   if (to_reg-&gt;type() == T_OBJECT || to_reg-&gt;type() == T_ARRAY) {</span>
<span class="line-modified">1224     __ verify_oop(to_reg-&gt;as_register());</span>
1225   }
1226 }
1227 
1228 
1229 void LIR_Assembler::reg2mem(LIR_Opr from_reg, LIR_Opr dest, BasicType type,
1230                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
1231                             bool wide, bool unaligned) {
1232   assert(type != T_METADATA, &quot;store of metadata ptr not supported&quot;);
1233   LIR_Address* addr = dest-&gt;as_address_ptr();
1234 
1235   Register src = addr-&gt;base()-&gt;as_pointer_register();
1236   Register disp_reg = noreg;
1237   int disp_value = addr-&gt;disp();
1238   bool needs_patching = (patch_code != lir_patch_none);
<a name="15" id="anc15"></a><span class="line-modified">1239   bool compress_oop = (type == T_ARRAY || type == T_OBJECT) &amp;&amp; UseCompressedOops &amp;&amp; !wide &amp;&amp;</span>
<span class="line-modified">1240                       Universe::narrow_oop_mode() != Universe::UnscaledNarrowOop;</span>
1241   bool load_disp = addr-&gt;index()-&gt;is_illegal() &amp;&amp; !Assembler::is_simm16(disp_value);
1242   bool use_R29 = compress_oop &amp;&amp; load_disp; // Avoid register conflict, also do null check before killing R29.
1243   // Null check for large offsets in LIRGenerator::do_StoreField.
1244   bool needs_explicit_null_check = !ImplicitNullChecks || use_R29;
1245 
1246   if (info != NULL &amp;&amp; needs_explicit_null_check) {
1247     explicit_null_check(src, info);
1248   }
1249 
1250   if (addr-&gt;base()-&gt;is_oop_register()) {
<a name="16" id="anc16"></a><span class="line-modified">1251     __ verify_oop(src);</span>
1252   }
1253 
1254   PatchingStub* patch = NULL;
1255   if (needs_patching) {
1256     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1257     assert(!from_reg-&gt;is_double_cpu() ||
1258            patch_code == lir_patch_none ||
1259            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1260   }
1261 
1262   if (addr-&gt;index()-&gt;is_illegal()) {
1263     if (load_disp) {
1264       disp_reg = use_R29 ? R29_TOC : R0;
1265       if (needs_patching) {
1266         __ load_const32(disp_reg, 0); // patchable int
1267       } else {
1268         __ load_const_optimized(disp_reg, disp_value);
1269       }
1270     }
1271   } else {
1272     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1273     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1274   }
1275 
1276   // remember the offset of the store. The patching_epilog must be done
1277   // before the call to add_debug_info_for_null_check, otherwise the PcDescs don&#39;t get
1278   // entered in increasing order.
1279   int offset;
1280 
1281   if (compress_oop) {
1282     Register co = __ encode_heap_oop(R0, from_reg-&gt;as_register());
1283     from_reg = FrameMap::as_opr(co);
1284   }
1285 
1286   if (disp_reg == noreg) {
1287     assert(Assembler::is_simm16(disp_value), &quot;should have set this up&quot;);
1288     offset = store(from_reg, src, disp_value, type, wide, unaligned);
1289   } else {
1290     assert(!unaligned, &quot;unexpected&quot;);
1291     offset = store(from_reg, src, disp_reg, type, wide);
1292   }
1293 
1294   if (use_R29) {
1295     __ load_const_optimized(R29_TOC, MacroAssembler::global_toc(), R0); // reinit
1296   }
1297 
1298   if (patch != NULL) {
1299     patching_epilog(patch, patch_code, src, info);
1300   }
1301 
1302   if (info != NULL &amp;&amp; !needs_explicit_null_check) {
1303     add_debug_info_for_null_check(offset, info);
1304   }
1305 }
1306 
1307 
1308 void LIR_Assembler::return_op(LIR_Opr result) {
1309   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
1310   const Register polling_page     = R12;
1311 
1312   // Pop the stack before the safepoint code.
1313   int frame_size = initial_frame_size_in_bytes();
1314   if (Assembler::is_simm(frame_size, 16)) {
1315     __ addi(R1_SP, R1_SP, frame_size);
1316   } else {
1317     __ pop_frame();
1318   }
1319 
1320   if (SafepointMechanism::uses_thread_local_poll()) {
1321     __ ld(polling_page, in_bytes(Thread::polling_page_offset()), R16_thread);
1322   } else {
1323     __ load_const_optimized(polling_page, (long)(address) os::get_polling_page(), R0);
1324   }
1325 
1326   // Restore return pc relative to callers&#39; sp.
1327   __ ld(return_pc, _abi(lr), R1_SP);
1328   // Move return pc to LR.
1329   __ mtlr(return_pc);
1330 
1331   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
1332     __ reserved_stack_check(return_pc);
1333   }
1334 
1335   // We need to mark the code position where the load from the safepoint
1336   // polling page was emitted as relocInfo::poll_return_type here.
1337   __ relocate(relocInfo::poll_return_type);
1338   __ load_from_polling_page(polling_page);
1339 
1340   // Return.
1341   __ blr();
1342 }
1343 
1344 
1345 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
1346   const Register poll_addr = tmp-&gt;as_register();
1347   if (SafepointMechanism::uses_thread_local_poll()) {
1348     __ ld(poll_addr, in_bytes(Thread::polling_page_offset()), R16_thread);
1349   } else {
1350     __ load_const_optimized(poll_addr, (intptr_t)os::get_polling_page(), R0);
1351   }
1352   if (info != NULL) {
1353     add_debug_info_for_branch(info);
1354   }
1355   int offset = __ offset();
1356   __ relocate(relocInfo::poll_type);
1357   __ load_from_polling_page(poll_addr);
1358 
1359   return offset;
1360 }
1361 
1362 
1363 void LIR_Assembler::emit_static_call_stub() {
1364   address call_pc = __ pc();
1365   address stub = __ start_a_stub(static_call_stub_size());
1366   if (stub == NULL) {
1367     bailout(&quot;static call stub overflow&quot;);
1368     return;
1369   }
1370 
1371   // For java_to_interp stubs we use R11_scratch1 as scratch register
1372   // and in call trampoline stubs we use R12_scratch2. This way we
1373   // can distinguish them (see is_NativeCallTrampolineStub_at()).
1374   const Register reg_scratch = R11_scratch1;
1375 
1376   // Create a static stub relocation which relates this stub
1377   // with the call instruction at insts_call_instruction_offset in the
1378   // instructions code-section.
1379   int start = __ offset();
1380   __ relocate(static_stub_Relocation::spec(call_pc));
1381 
1382   // Now, create the stub&#39;s code:
1383   // - load the TOC
1384   // - load the inline cache oop from the constant pool
1385   // - load the call target from the constant pool
1386   // - call
1387   __ calculate_address_from_global_toc(reg_scratch, __ method_toc());
1388   AddressLiteral ic = __ allocate_metadata_address((Metadata *)NULL);
1389   bool success = __ load_const_from_method_toc(R19_inline_cache_reg, ic, reg_scratch, /*fixed_size*/ true);
1390 
1391   if (ReoptimizeCallSequences) {
1392     __ b64_patchable((address)-1, relocInfo::none);
1393   } else {
1394     AddressLiteral a((address)-1);
1395     success = success &amp;&amp; __ load_const_from_method_toc(reg_scratch, a, reg_scratch, /*fixed_size*/ true);
1396     __ mtctr(reg_scratch);
1397     __ bctr();
1398   }
1399   if (!success) {
1400     bailout(&quot;const section overflow&quot;);
1401     return;
1402   }
1403 
1404   assert(__ offset() - start &lt;= static_call_stub_size(), &quot;stub too big&quot;);
1405   __ end_a_stub();
1406 }
1407 
1408 
1409 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1410   bool unsigned_comp = (condition == lir_cond_belowEqual || condition == lir_cond_aboveEqual);
1411   if (opr1-&gt;is_single_fpu()) {
1412     __ fcmpu(BOOL_RESULT, opr1-&gt;as_float_reg(), opr2-&gt;as_float_reg());
1413   } else if (opr1-&gt;is_double_fpu()) {
1414     __ fcmpu(BOOL_RESULT, opr1-&gt;as_double_reg(), opr2-&gt;as_double_reg());
1415   } else if (opr1-&gt;is_single_cpu()) {
1416     if (opr2-&gt;is_constant()) {
1417       switch (opr2-&gt;as_constant_ptr()-&gt;type()) {
1418         case T_INT:
1419           {
1420             jint con = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1421             if (unsigned_comp) {
1422               if (Assembler::is_uimm(con, 16)) {
1423                 __ cmplwi(BOOL_RESULT, opr1-&gt;as_register(), con);
1424               } else {
1425                 __ load_const_optimized(R0, con);
1426                 __ cmplw(BOOL_RESULT, opr1-&gt;as_register(), R0);
1427               }
1428             } else {
1429               if (Assembler::is_simm(con, 16)) {
1430                 __ cmpwi(BOOL_RESULT, opr1-&gt;as_register(), con);
1431               } else {
1432                 __ load_const_optimized(R0, con);
1433                 __ cmpw(BOOL_RESULT, opr1-&gt;as_register(), R0);
1434               }
1435             }
1436           }
1437           break;
1438 
1439         case T_OBJECT:
1440           // There are only equal/notequal comparisons on objects.
1441           {
1442             assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
1443             jobject con = opr2-&gt;as_constant_ptr()-&gt;as_jobject();
1444             if (con == NULL) {
1445               __ cmpdi(BOOL_RESULT, opr1-&gt;as_register(), 0);
1446             } else {
1447               jobject2reg(con, R0);
1448               __ cmpd(BOOL_RESULT, opr1-&gt;as_register(), R0);
1449             }
1450           }
1451           break;
1452 
<a name="17" id="anc17"></a>












1453         default:
1454           ShouldNotReachHere();
1455           break;
1456       }
1457     } else {
<a name="18" id="anc18"></a><span class="line-modified">1458       if (opr2-&gt;is_address()) {</span>
<span class="line-modified">1459         DEBUG_ONLY( Unimplemented(); ) // Seems to be unused at the moment.</span>
<span class="line-modified">1460         LIR_Address *addr = opr2-&gt;as_address_ptr();</span>
<span class="line-modified">1461         BasicType type = addr-&gt;type();</span>
<span class="line-modified">1462         if (type == T_OBJECT) { __ ld(R0, index_or_disp(addr), addr-&gt;base()-&gt;as_register()); }</span>
<span class="line-removed">1463         else                  { __ lwa(R0, index_or_disp(addr), addr-&gt;base()-&gt;as_register()); }</span>
<span class="line-removed">1464         __ cmpd(BOOL_RESULT, opr1-&gt;as_register(), R0);</span>
1465       } else {
1466         if (unsigned_comp) {
1467           __ cmplw(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());
1468         } else {
1469           __ cmpw(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());
1470         }
1471       }
1472     }
1473   } else if (opr1-&gt;is_double_cpu()) {
1474     if (opr2-&gt;is_constant()) {
1475       jlong con = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
1476       if (unsigned_comp) {
1477         if (Assembler::is_uimm(con, 16)) {
1478           __ cmpldi(BOOL_RESULT, opr1-&gt;as_register_lo(), con);
1479         } else {
1480           __ load_const_optimized(R0, con);
1481           __ cmpld(BOOL_RESULT, opr1-&gt;as_register_lo(), R0);
1482         }
1483       } else {
1484         if (Assembler::is_simm(con, 16)) {
1485           __ cmpdi(BOOL_RESULT, opr1-&gt;as_register_lo(), con);
1486         } else {
1487           __ load_const_optimized(R0, con);
1488           __ cmpd(BOOL_RESULT, opr1-&gt;as_register_lo(), R0);
1489         }
1490       }
1491     } else if (opr2-&gt;is_register()) {
1492       if (unsigned_comp) {
1493         __ cmpld(BOOL_RESULT, opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo());
1494       } else {
1495         __ cmpd(BOOL_RESULT, opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo());
1496       }
1497     } else {
1498       ShouldNotReachHere();
1499     }
<a name="19" id="anc19"></a><span class="line-removed">1500   } else if (opr1-&gt;is_address()) {</span>
<span class="line-removed">1501     DEBUG_ONLY( Unimplemented(); ) // Seems to be unused at the moment.</span>
<span class="line-removed">1502     LIR_Address * addr = opr1-&gt;as_address_ptr();</span>
<span class="line-removed">1503     BasicType type = addr-&gt;type();</span>
<span class="line-removed">1504     assert (opr2-&gt;is_constant(), &quot;Checking&quot;);</span>
<span class="line-removed">1505     if (type == T_OBJECT) { __ ld(R0, index_or_disp(addr), addr-&gt;base()-&gt;as_register()); }</span>
<span class="line-removed">1506     else                  { __ lwa(R0, index_or_disp(addr), addr-&gt;base()-&gt;as_register()); }</span>
<span class="line-removed">1507     __ cmpdi(BOOL_RESULT, R0, opr2-&gt;as_constant_ptr()-&gt;as_jint());</span>
1508   } else {
1509     ShouldNotReachHere();
1510   }
1511 }
1512 
1513 
1514 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
1515   const Register Rdst = dst-&gt;as_register();
1516   Label done;
1517   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
1518     bool is_unordered_less = (code == lir_ucmp_fd2i);
1519     if (left-&gt;is_single_fpu()) {
1520       __ fcmpu(CCR0, left-&gt;as_float_reg(), right-&gt;as_float_reg());
1521     } else if (left-&gt;is_double_fpu()) {
1522       __ fcmpu(CCR0, left-&gt;as_double_reg(), right-&gt;as_double_reg());
1523     } else {
1524       ShouldNotReachHere();
1525     }
1526     __ li(Rdst, is_unordered_less ? -1 : 1);
1527     __ bso(CCR0, done);
1528   } else if (code == lir_cmp_l2i) {
1529     __ cmpd(CCR0, left-&gt;as_register_lo(), right-&gt;as_register_lo());
1530   } else {
1531     ShouldNotReachHere();
1532   }
1533   __ mfcr(R0); // set bit 32..33 as follows: &lt;: 0b10, =: 0b00, &gt;: 0b01
1534   __ srwi(Rdst, R0, 30);
1535   __ srawi(R0, R0, 31);
1536   __ orr(Rdst, R0, Rdst); // set result as follows: &lt;: -1, =: 0, &gt;: 1
1537   __ bind(done);
1538 }
1539 
1540 
1541 inline void load_to_reg(LIR_Assembler *lasm, LIR_Opr src, LIR_Opr dst) {
1542   if (src-&gt;is_constant()) {
1543     lasm-&gt;const2reg(src, dst, lir_patch_none, NULL);
1544   } else if (src-&gt;is_register()) {
1545     lasm-&gt;reg2reg(src, dst);
1546   } else if (src-&gt;is_stack()) {
1547     lasm-&gt;stack2reg(src, dst, dst-&gt;type());
1548   } else {
1549     ShouldNotReachHere();
1550   }
1551 }
1552 
1553 
1554 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1555   if (opr1-&gt;is_equal(opr2) || opr1-&gt;is_same_register(opr2)) {
1556     load_to_reg(this, opr1, result); // Condition doesn&#39;t matter.
1557     return;
1558   }
1559 
1560   bool positive = false;
1561   Assembler::Condition cond = Assembler::equal;
1562   switch (condition) {
1563     case lir_cond_equal:        positive = true ; cond = Assembler::equal  ; break;
1564     case lir_cond_notEqual:     positive = false; cond = Assembler::equal  ; break;
1565     case lir_cond_less:         positive = true ; cond = Assembler::less   ; break;
1566     case lir_cond_belowEqual:
1567     case lir_cond_lessEqual:    positive = false; cond = Assembler::greater; break;
1568     case lir_cond_greater:      positive = true ; cond = Assembler::greater; break;
1569     case lir_cond_aboveEqual:
1570     case lir_cond_greaterEqual: positive = false; cond = Assembler::less   ; break;
1571     default:                    ShouldNotReachHere();
1572   }
1573 
1574   // Try to use isel on &gt;=Power7.
1575   if (VM_Version::has_isel() &amp;&amp; result-&gt;is_cpu_register()) {
1576     bool o1_is_reg = opr1-&gt;is_cpu_register(), o2_is_reg = opr2-&gt;is_cpu_register();
1577     const Register result_reg = result-&gt;is_single_cpu() ? result-&gt;as_register() : result-&gt;as_register_lo();
1578 
1579     // We can use result_reg to load one operand if not already in register.
1580     Register first  = o1_is_reg ? (opr1-&gt;is_single_cpu() ? opr1-&gt;as_register() : opr1-&gt;as_register_lo()) : result_reg,
1581              second = o2_is_reg ? (opr2-&gt;is_single_cpu() ? opr2-&gt;as_register() : opr2-&gt;as_register_lo()) : result_reg;
1582 
1583     if (first != second) {
1584       if (!o1_is_reg) {
1585         load_to_reg(this, opr1, result);
1586       }
1587 
1588       if (!o2_is_reg) {
1589         load_to_reg(this, opr2, result);
1590       }
1591 
1592       __ isel(result_reg, BOOL_RESULT, cond, !positive, first, second);
1593       return;
1594     }
1595   } // isel
1596 
1597   load_to_reg(this, opr1, result);
1598 
1599   Label skip;
1600   int bo = positive ? Assembler::bcondCRbiIs1 : Assembler::bcondCRbiIs0;
1601   int bi = Assembler::bi0(BOOL_RESULT, cond);
1602   __ bc(bo, bi, skip);
1603 
1604   load_to_reg(this, opr2, result);
1605   __ bind(skip);
1606 }
1607 
1608 
1609 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest,
1610                              CodeEmitInfo* info, bool pop_fpu_stack) {
1611   assert(info == NULL, &quot;unused on this code path&quot;);
1612   assert(left-&gt;is_register(), &quot;wrong items state&quot;);
1613   assert(dest-&gt;is_register(), &quot;wrong items state&quot;);
1614 
1615   if (right-&gt;is_register()) {
1616     if (dest-&gt;is_float_kind()) {
1617 
1618       FloatRegister lreg, rreg, res;
1619       if (right-&gt;is_single_fpu()) {
1620         lreg = left-&gt;as_float_reg();
1621         rreg = right-&gt;as_float_reg();
1622         res  = dest-&gt;as_float_reg();
1623         switch (code) {
1624           case lir_add: __ fadds(res, lreg, rreg); break;
1625           case lir_sub: __ fsubs(res, lreg, rreg); break;
1626           case lir_mul: // fall through
1627           case lir_mul_strictfp: __ fmuls(res, lreg, rreg); break;
1628           case lir_div: // fall through
1629           case lir_div_strictfp: __ fdivs(res, lreg, rreg); break;
1630           default: ShouldNotReachHere();
1631         }
1632       } else {
1633         lreg = left-&gt;as_double_reg();
1634         rreg = right-&gt;as_double_reg();
1635         res  = dest-&gt;as_double_reg();
1636         switch (code) {
1637           case lir_add: __ fadd(res, lreg, rreg); break;
1638           case lir_sub: __ fsub(res, lreg, rreg); break;
1639           case lir_mul: // fall through
1640           case lir_mul_strictfp: __ fmul(res, lreg, rreg); break;
1641           case lir_div: // fall through
1642           case lir_div_strictfp: __ fdiv(res, lreg, rreg); break;
1643           default: ShouldNotReachHere();
1644         }
1645       }
1646 
1647     } else if (dest-&gt;is_double_cpu()) {
1648 
1649       Register dst_lo = dest-&gt;as_register_lo();
1650       Register op1_lo = left-&gt;as_pointer_register();
1651       Register op2_lo = right-&gt;as_pointer_register();
1652 
1653       switch (code) {
1654         case lir_add: __ add(dst_lo, op1_lo, op2_lo); break;
1655         case lir_sub: __ sub(dst_lo, op1_lo, op2_lo); break;
1656         case lir_mul: __ mulld(dst_lo, op1_lo, op2_lo); break;
1657         default: ShouldNotReachHere();
1658       }
1659     } else {
1660       assert (right-&gt;is_single_cpu(), &quot;Just Checking&quot;);
1661 
1662       Register lreg = left-&gt;as_register();
1663       Register res  = dest-&gt;as_register();
1664       Register rreg = right-&gt;as_register();
1665       switch (code) {
1666         case lir_add:  __ add  (res, lreg, rreg); break;
1667         case lir_sub:  __ sub  (res, lreg, rreg); break;
1668         case lir_mul:  __ mullw(res, lreg, rreg); break;
1669         default: ShouldNotReachHere();
1670       }
1671     }
1672   } else {
1673     assert (right-&gt;is_constant(), &quot;must be constant&quot;);
1674 
1675     if (dest-&gt;is_single_cpu()) {
1676       Register lreg = left-&gt;as_register();
1677       Register res  = dest-&gt;as_register();
1678       int    simm16 = right-&gt;as_constant_ptr()-&gt;as_jint();
1679 
1680       switch (code) {
1681         case lir_sub:  assert(Assembler::is_simm16(-simm16), &quot;cannot encode&quot;); // see do_ArithmeticOp_Int
1682                        simm16 = -simm16;
1683         case lir_add:  if (res == lreg &amp;&amp; simm16 == 0) break;
1684                        __ addi(res, lreg, simm16); break;
1685         case lir_mul:  if (res == lreg &amp;&amp; simm16 == 1) break;
1686                        __ mulli(res, lreg, simm16); break;
1687         default: ShouldNotReachHere();
1688       }
1689     } else {
1690       Register lreg = left-&gt;as_pointer_register();
1691       Register res  = dest-&gt;as_register_lo();
1692       long con = right-&gt;as_constant_ptr()-&gt;as_jlong();
1693       assert(Assembler::is_simm16(con), &quot;must be simm16&quot;);
1694 
1695       switch (code) {
1696         case lir_sub:  assert(Assembler::is_simm16(-con), &quot;cannot encode&quot;);  // see do_ArithmeticOp_Long
1697                        con = -con;
1698         case lir_add:  if (res == lreg &amp;&amp; con == 0) break;
1699                        __ addi(res, lreg, (int)con); break;
1700         case lir_mul:  if (res == lreg &amp;&amp; con == 1) break;
1701                        __ mulli(res, lreg, (int)con); break;
1702         default: ShouldNotReachHere();
1703       }
1704     }
1705   }
1706 }
1707 
1708 
<a name="20" id="anc20"></a><span class="line-removed">1709 void LIR_Assembler::fpop() {</span>
<span class="line-removed">1710   Unimplemented();</span>
<span class="line-removed">1711   // do nothing</span>
<span class="line-removed">1712 }</span>
<span class="line-removed">1713 </span>
<span class="line-removed">1714 </span>
1715 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
1716   switch (code) {
1717     case lir_sqrt: {
1718       __ fsqrt(dest-&gt;as_double_reg(), value-&gt;as_double_reg());
1719       break;
1720     }
1721     case lir_abs: {
1722       __ fabs(dest-&gt;as_double_reg(), value-&gt;as_double_reg());
1723       break;
1724     }
1725     default: {
1726       ShouldNotReachHere();
1727       break;
1728     }
1729   }
1730 }
1731 
1732 
1733 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest) {
1734   if (right-&gt;is_constant()) { // see do_LogicOp
1735     long uimm;
1736     Register d, l;
1737     if (dest-&gt;is_single_cpu()) {
1738       uimm = right-&gt;as_constant_ptr()-&gt;as_jint();
1739       d = dest-&gt;as_register();
1740       l = left-&gt;as_register();
1741     } else {
1742       uimm = right-&gt;as_constant_ptr()-&gt;as_jlong();
1743       d = dest-&gt;as_register_lo();
1744       l = left-&gt;as_register_lo();
1745     }
1746     long uimms  = (unsigned long)uimm &gt;&gt; 16,
1747          uimmss = (unsigned long)uimm &gt;&gt; 32;
1748 
1749     switch (code) {
1750       case lir_logic_and:
<a name="21" id="anc21"></a><span class="line-modified">1751         if (uimmss != 0 || (uimms != 0 &amp;&amp; (uimm &amp; 0xFFFF) != 0) || is_power_of_2_long(uimm)) {</span>
1752           __ andi(d, l, uimm); // special cases
1753         } else if (uimms != 0) { __ andis_(d, l, uimms); }
1754         else { __ andi_(d, l, uimm); }
1755         break;
1756 
1757       case lir_logic_or:
1758         if (uimms != 0) { assert((uimm &amp; 0xFFFF) == 0, &quot;sanity&quot;); __ oris(d, l, uimms); }
1759         else { __ ori(d, l, uimm); }
1760         break;
1761 
1762       case lir_logic_xor:
1763         if (uimm == -1) { __ nand(d, l, l); } // special case
1764         else if (uimms != 0) { assert((uimm &amp; 0xFFFF) == 0, &quot;sanity&quot;); __ xoris(d, l, uimms); }
1765         else { __ xori(d, l, uimm); }
1766         break;
1767 
1768       default: ShouldNotReachHere();
1769     }
1770   } else {
1771     assert(right-&gt;is_register(), &quot;right should be in register&quot;);
1772 
1773     if (dest-&gt;is_single_cpu()) {
1774       switch (code) {
1775         case lir_logic_and: __ andr(dest-&gt;as_register(), left-&gt;as_register(), right-&gt;as_register()); break;
1776         case lir_logic_or:  __ orr (dest-&gt;as_register(), left-&gt;as_register(), right-&gt;as_register()); break;
1777         case lir_logic_xor: __ xorr(dest-&gt;as_register(), left-&gt;as_register(), right-&gt;as_register()); break;
1778         default: ShouldNotReachHere();
1779       }
1780     } else {
1781       Register l = (left-&gt;is_single_cpu() &amp;&amp; left-&gt;is_oop_register()) ? left-&gt;as_register() :
1782                                                                         left-&gt;as_register_lo();
1783       Register r = (right-&gt;is_single_cpu() &amp;&amp; right-&gt;is_oop_register()) ? right-&gt;as_register() :
1784                                                                           right-&gt;as_register_lo();
1785 
1786       switch (code) {
1787         case lir_logic_and: __ andr(dest-&gt;as_register_lo(), l, r); break;
1788         case lir_logic_or:  __ orr (dest-&gt;as_register_lo(), l, r); break;
1789         case lir_logic_xor: __ xorr(dest-&gt;as_register_lo(), l, r); break;
1790         default: ShouldNotReachHere();
1791       }
1792     }
1793   }
1794 }
1795 
1796 
1797 int LIR_Assembler::shift_amount(BasicType t) {
1798   int elem_size = type2aelembytes(t);
1799   switch (elem_size) {
1800     case 1 : return 0;
1801     case 2 : return 1;
1802     case 4 : return 2;
1803     case 8 : return 3;
1804   }
1805   ShouldNotReachHere();
1806   return -1;
1807 }
1808 
1809 
1810 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
1811   info-&gt;add_register_oop(exceptionOop);
1812 
1813   // Reuse the debug info from the safepoint poll for the throw op itself.
1814   address pc_for_athrow = __ pc();
1815   int pc_for_athrow_offset = __ offset();
1816   //RelocationHolder rspec = internal_word_Relocation::spec(pc_for_athrow);
1817   //__ relocate(rspec);
1818   //__ load_const(exceptionPC-&gt;as_register(), pc_for_athrow, R0);
1819   __ calculate_address_from_global_toc(exceptionPC-&gt;as_register(), pc_for_athrow, true, true, /*add_relocation*/ true);
1820   add_call_info(pc_for_athrow_offset, info); // for exception handler
1821 
1822   address stub = Runtime1::entry_for(compilation()-&gt;has_fpu_code() ? Runtime1::handle_exception_id
1823                                                                    : Runtime1::handle_exception_nofpu_id);
1824   //__ load_const_optimized(R0, stub);
1825   __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));
1826   __ mtctr(R0);
1827   __ bctr();
1828 }
1829 
1830 
1831 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
1832   // Note: Not used with EnableDebuggingOnDemand.
1833   assert(exceptionOop-&gt;as_register() == R3, &quot;should match&quot;);
1834   __ b(_unwind_handler_entry);
1835 }
1836 
1837 
1838 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
1839   Register src = op-&gt;src()-&gt;as_register();
1840   Register dst = op-&gt;dst()-&gt;as_register();
1841   Register src_pos = op-&gt;src_pos()-&gt;as_register();
1842   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
1843   Register length  = op-&gt;length()-&gt;as_register();
1844   Register tmp = op-&gt;tmp()-&gt;as_register();
1845   Register tmp2 = R0;
1846 
1847   int flags = op-&gt;flags();
1848   ciArrayKlass* default_type = op-&gt;expected_type();
1849   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
1850   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
1851 
1852   // Set up the arraycopy stub information.
1853   ArrayCopyStub* stub = op-&gt;stub();
1854   const int frame_resize = frame::abi_reg_args_size - sizeof(frame::jit_abi); // C calls need larger frame.
1855 
1856   // Always do stub if no type information is available. It&#39;s ok if
1857   // the known type isn&#39;t loaded since the code sanity checks
1858   // in debug mode and the type isn&#39;t required when we know the exact type
1859   // also check that the type is an array type.
1860   if (op-&gt;expected_type() == NULL) {
1861     assert(src-&gt;is_nonvolatile() &amp;&amp; src_pos-&gt;is_nonvolatile() &amp;&amp; dst-&gt;is_nonvolatile() &amp;&amp; dst_pos-&gt;is_nonvolatile() &amp;&amp;
1862            length-&gt;is_nonvolatile(), &quot;must preserve&quot;);
1863     address copyfunc_addr = StubRoutines::generic_arraycopy();
1864     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
1865 
1866     // 3 parms are int. Convert to long.
1867     __ mr(R3_ARG1, src);
1868     __ extsw(R4_ARG2, src_pos);
1869     __ mr(R5_ARG3, dst);
1870     __ extsw(R6_ARG4, dst_pos);
1871     __ extsw(R7_ARG5, length);
1872 
1873 #ifndef PRODUCT
1874     if (PrintC1Statistics) {
1875       address counter = (address)&amp;Runtime1::_generic_arraycopystub_cnt;
1876       int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
1877       __ lwz(R11_scratch1, simm16_offs, tmp);
1878       __ addi(R11_scratch1, R11_scratch1, 1);
1879       __ stw(R11_scratch1, simm16_offs, tmp);
1880     }
1881 #endif
1882     __ call_c_with_frame_resize(copyfunc_addr, /*stub does not need resized frame*/ 0);
1883 
1884     __ nand(tmp, R3_RET, R3_RET);
1885     __ subf(length, tmp, length);
1886     __ add(src_pos, tmp, src_pos);
1887     __ add(dst_pos, tmp, dst_pos);
1888 
1889     __ cmpwi(CCR0, R3_RET, 0);
1890     __ bc_far_optimized(Assembler::bcondCRbiIs1, __ bi0(CCR0, Assembler::less), *stub-&gt;entry());
1891     __ bind(*stub-&gt;continuation());
1892     return;
1893   }
1894 
1895   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass(), &quot;must be true at this point&quot;);
1896   Label cont, slow, copyfunc;
1897 
1898   bool simple_check_flag_set = flags &amp; (LIR_OpArrayCopy::src_null_check |
1899                                         LIR_OpArrayCopy::dst_null_check |
1900                                         LIR_OpArrayCopy::src_pos_positive_check |
1901                                         LIR_OpArrayCopy::dst_pos_positive_check |
1902                                         LIR_OpArrayCopy::length_positive_check);
1903 
1904   // Use only one conditional branch for simple checks.
1905   if (simple_check_flag_set) {
1906     ConditionRegister combined_check = CCR1, tmp_check = CCR1;
1907 
1908     // Make sure src and dst are non-null.
1909     if (flags &amp; LIR_OpArrayCopy::src_null_check) {
1910       __ cmpdi(combined_check, src, 0);
1911       tmp_check = CCR0;
1912     }
1913 
1914     if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
1915       __ cmpdi(tmp_check, dst, 0);
1916       if (tmp_check != combined_check) {
1917         __ cror(combined_check, Assembler::equal, tmp_check, Assembler::equal);
1918       }
1919       tmp_check = CCR0;
1920     }
1921 
1922     // Clear combined_check.eq if not already used.
1923     if (tmp_check == combined_check) {
1924       __ crandc(combined_check, Assembler::equal, combined_check, Assembler::equal);
1925       tmp_check = CCR0;
1926     }
1927 
1928     if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
1929       // Test src_pos register.
1930       __ cmpwi(tmp_check, src_pos, 0);
1931       __ cror(combined_check, Assembler::equal, tmp_check, Assembler::less);
1932     }
1933 
1934     if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
1935       // Test dst_pos register.
1936       __ cmpwi(tmp_check, dst_pos, 0);
1937       __ cror(combined_check, Assembler::equal, tmp_check, Assembler::less);
1938     }
1939 
1940     if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
1941       // Make sure length isn&#39;t negative.
1942       __ cmpwi(tmp_check, length, 0);
1943       __ cror(combined_check, Assembler::equal, tmp_check, Assembler::less);
1944     }
1945 
1946     __ beq(combined_check, slow);
1947   }
1948 
1949   // If the compiler was not able to prove that exact type of the source or the destination
1950   // of the arraycopy is an array type, check at runtime if the source or the destination is
1951   // an instance type.
1952   if (flags &amp; LIR_OpArrayCopy::type_check) {
1953     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
1954       __ load_klass(tmp, dst);
1955       __ lwz(tmp2, in_bytes(Klass::layout_helper_offset()), tmp);
1956       __ cmpwi(CCR0, tmp2, Klass::_lh_neutral_value);
1957       __ bge(CCR0, slow);
1958     }
1959 
1960     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
1961       __ load_klass(tmp, src);
1962       __ lwz(tmp2, in_bytes(Klass::layout_helper_offset()), tmp);
1963       __ cmpwi(CCR0, tmp2, Klass::_lh_neutral_value);
1964       __ bge(CCR0, slow);
1965     }
1966   }
1967 
1968   // Higher 32bits must be null.
1969   __ extsw(length, length);
1970 
1971   __ extsw(src_pos, src_pos);
1972   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
1973     __ lwz(tmp2, arrayOopDesc::length_offset_in_bytes(), src);
1974     __ add(tmp, length, src_pos);
1975     __ cmpld(CCR0, tmp2, tmp);
1976     __ ble(CCR0, slow);
1977   }
1978 
1979   __ extsw(dst_pos, dst_pos);
1980   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
1981     __ lwz(tmp2, arrayOopDesc::length_offset_in_bytes(), dst);
1982     __ add(tmp, length, dst_pos);
1983     __ cmpld(CCR0, tmp2, tmp);
1984     __ ble(CCR0, slow);
1985   }
1986 
1987   int shift = shift_amount(basic_type);
1988 
1989   if (!(flags &amp; LIR_OpArrayCopy::type_check)) {
1990     __ b(cont);
1991   } else {
1992     // We don&#39;t know the array types are compatible.
1993     if (basic_type != T_OBJECT) {
1994       // Simple test for basic type arrays.
1995       if (UseCompressedClassPointers) {
1996         // We don&#39;t need decode because we just need to compare.
1997         __ lwz(tmp, oopDesc::klass_offset_in_bytes(), src);
1998         __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), dst);
1999         __ cmpw(CCR0, tmp, tmp2);
2000       } else {
2001         __ ld(tmp, oopDesc::klass_offset_in_bytes(), src);
2002         __ ld(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2003         __ cmpd(CCR0, tmp, tmp2);
2004       }
2005       __ beq(CCR0, cont);
2006     } else {
2007       // For object arrays, if src is a sub class of dst then we can
2008       // safely do the copy.
2009       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2010 
2011       const Register sub_klass = R5, super_klass = R4; // like CheckCast/InstanceOf
2012       assert_different_registers(tmp, tmp2, sub_klass, super_klass);
2013 
2014       __ load_klass(sub_klass, src);
2015       __ load_klass(super_klass, dst);
2016 
2017       __ check_klass_subtype_fast_path(sub_klass, super_klass, tmp, tmp2,
2018                                        &amp;cont, copyfunc_addr != NULL ? &amp;copyfunc : &amp;slow, NULL);
2019 
2020       address slow_stc = Runtime1::entry_for(Runtime1::slow_subtype_check_id);
2021       //__ load_const_optimized(tmp, slow_stc, tmp2);
2022       __ calculate_address_from_global_toc(tmp, slow_stc, true, true, false);
2023       __ mtctr(tmp);
2024       __ bctrl(); // sets CR0
2025       __ beq(CCR0, cont);
2026 
2027       if (copyfunc_addr != NULL) { // Use stub if available.
2028         __ bind(copyfunc);
2029         // Src is not a sub class of dst so we have to do a
2030         // per-element check.
2031         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2032         if ((flags &amp; mask) != mask) {
2033           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2034 
2035           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2036             __ load_klass(tmp, src);
2037           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2038             __ load_klass(tmp, dst);
2039           }
2040 
2041           __ lwz(tmp2, in_bytes(Klass::layout_helper_offset()), tmp);
2042 
2043           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2044           __ load_const_optimized(tmp, objArray_lh);
2045           __ cmpw(CCR0, tmp, tmp2);
2046           __ bne(CCR0, slow);
2047         }
2048 
2049         Register src_ptr = R3_ARG1;
2050         Register dst_ptr = R4_ARG2;
2051         Register len     = R5_ARG3;
2052         Register chk_off = R6_ARG4;
2053         Register super_k = R7_ARG5;
2054 
2055         __ addi(src_ptr, src, arrayOopDesc::base_offset_in_bytes(basic_type));
2056         __ addi(dst_ptr, dst, arrayOopDesc::base_offset_in_bytes(basic_type));
2057         if (shift == 0) {
2058           __ add(src_ptr, src_pos, src_ptr);
2059           __ add(dst_ptr, dst_pos, dst_ptr);
2060         } else {
2061           __ sldi(tmp, src_pos, shift);
2062           __ sldi(tmp2, dst_pos, shift);
2063           __ add(src_ptr, tmp, src_ptr);
2064           __ add(dst_ptr, tmp2, dst_ptr);
2065         }
2066 
2067         __ load_klass(tmp, dst);
2068         __ mr(len, length);
2069 
2070         int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
2071         __ ld(super_k, ek_offset, tmp);
2072 
2073         int sco_offset = in_bytes(Klass::super_check_offset_offset());
2074         __ lwz(chk_off, sco_offset, super_k);
2075 
2076         __ call_c_with_frame_resize(copyfunc_addr, /*stub does not need resized frame*/ 0);
2077 
2078 #ifndef PRODUCT
2079         if (PrintC1Statistics) {
2080           Label failed;
2081           __ cmpwi(CCR0, R3_RET, 0);
2082           __ bne(CCR0, failed);
2083           address counter = (address)&amp;Runtime1::_arraycopy_checkcast_cnt;
2084           int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
2085           __ lwz(R11_scratch1, simm16_offs, tmp);
2086           __ addi(R11_scratch1, R11_scratch1, 1);
2087           __ stw(R11_scratch1, simm16_offs, tmp);
2088           __ bind(failed);
2089         }
2090 #endif
2091 
2092         __ nand(tmp, R3_RET, R3_RET);
2093         __ cmpwi(CCR0, R3_RET, 0);
2094         __ beq(CCR0, *stub-&gt;continuation());
2095 
2096 #ifndef PRODUCT
2097         if (PrintC1Statistics) {
2098           address counter = (address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt;
2099           int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
2100           __ lwz(R11_scratch1, simm16_offs, tmp);
2101           __ addi(R11_scratch1, R11_scratch1, 1);
2102           __ stw(R11_scratch1, simm16_offs, tmp);
2103         }
2104 #endif
2105 
2106         __ subf(length, tmp, length);
2107         __ add(src_pos, tmp, src_pos);
2108         __ add(dst_pos, tmp, dst_pos);
2109       }
2110     }
2111   }
2112   __ bind(slow);
2113   __ b(*stub-&gt;entry());
2114   __ bind(cont);
2115 
2116 #ifdef ASSERT
2117   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2118     // Sanity check the known type with the incoming class. For the
2119     // primitive case the types must match exactly with src.klass and
2120     // dst.klass each exactly matching the default type. For the
2121     // object array case, if no type check is needed then either the
2122     // dst type is exactly the expected type and the src type is a
2123     // subtype which we can&#39;t check or src is the same array as dst
2124     // but not necessarily exactly of type default_type.
2125     Label known_ok, halt;
2126     metadata2reg(op-&gt;expected_type()-&gt;constant_encoding(), tmp);
2127     if (UseCompressedClassPointers) {
2128       // Tmp holds the default type. It currently comes uncompressed after the
2129       // load of a constant, so encode it.
2130       __ encode_klass_not_null(tmp);
2131       // Load the raw value of the dst klass, since we will be comparing
2132       // uncompressed values directly.
2133       __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2134       __ cmpw(CCR0, tmp, tmp2);
2135       if (basic_type != T_OBJECT) {
2136         __ bne(CCR0, halt);
2137         // Load the raw value of the src klass.
2138         __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), src);
2139         __ cmpw(CCR0, tmp, tmp2);
2140         __ beq(CCR0, known_ok);
2141       } else {
2142         __ beq(CCR0, known_ok);
2143         __ cmpw(CCR0, src, dst);
2144         __ beq(CCR0, known_ok);
2145       }
2146     } else {
2147       __ ld(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2148       __ cmpd(CCR0, tmp, tmp2);
2149       if (basic_type != T_OBJECT) {
2150         __ bne(CCR0, halt);
2151         // Load the raw value of the src klass.
2152         __ ld(tmp2, oopDesc::klass_offset_in_bytes(), src);
2153         __ cmpd(CCR0, tmp, tmp2);
2154         __ beq(CCR0, known_ok);
2155       } else {
2156         __ beq(CCR0, known_ok);
2157         __ cmpd(CCR0, src, dst);
2158         __ beq(CCR0, known_ok);
2159       }
2160     }
2161     __ bind(halt);
2162     __ stop(&quot;incorrect type information in arraycopy&quot;);
2163     __ bind(known_ok);
2164   }
2165 #endif
2166 
2167 #ifndef PRODUCT
2168   if (PrintC1Statistics) {
2169     address counter = Runtime1::arraycopy_count_address(basic_type);
2170     int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
2171     __ lwz(R11_scratch1, simm16_offs, tmp);
2172     __ addi(R11_scratch1, R11_scratch1, 1);
2173     __ stw(R11_scratch1, simm16_offs, tmp);
2174   }
2175 #endif
2176 
2177   Register src_ptr = R3_ARG1;
2178   Register dst_ptr = R4_ARG2;
2179   Register len     = R5_ARG3;
2180 
2181   __ addi(src_ptr, src, arrayOopDesc::base_offset_in_bytes(basic_type));
2182   __ addi(dst_ptr, dst, arrayOopDesc::base_offset_in_bytes(basic_type));
2183   if (shift == 0) {
2184     __ add(src_ptr, src_pos, src_ptr);
2185     __ add(dst_ptr, dst_pos, dst_ptr);
2186   } else {
2187     __ sldi(tmp, src_pos, shift);
2188     __ sldi(tmp2, dst_pos, shift);
2189     __ add(src_ptr, tmp, src_ptr);
2190     __ add(dst_ptr, tmp2, dst_ptr);
2191   }
2192 
2193   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2194   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2195   const char *name;
2196   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2197 
2198   // Arraycopy stubs takes a length in number of elements, so don&#39;t scale it.
2199   __ mr(len, length);
2200   __ call_c_with_frame_resize(entry, /*stub does not need resized frame*/ 0);
2201 
2202   __ bind(*stub-&gt;continuation());
2203 }
2204 
2205 
2206 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2207   if (dest-&gt;is_single_cpu()) {
2208     __ rldicl(tmp-&gt;as_register(), count-&gt;as_register(), 0, 64-5);
2209 #ifdef _LP64
2210     if (left-&gt;type() == T_OBJECT) {
2211       switch (code) {
2212         case lir_shl:  __ sld(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2213         case lir_shr:  __ srad(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2214         case lir_ushr: __ srd(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2215         default: ShouldNotReachHere();
2216       }
2217     } else
2218 #endif
2219       switch (code) {
2220         case lir_shl:  __ slw(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2221         case lir_shr:  __ sraw(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2222         case lir_ushr: __ srw(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2223         default: ShouldNotReachHere();
2224       }
2225   } else {
2226     __ rldicl(tmp-&gt;as_register(), count-&gt;as_register(), 0, 64-6);
2227     switch (code) {
2228       case lir_shl:  __ sld(dest-&gt;as_register_lo(), left-&gt;as_register_lo(), tmp-&gt;as_register()); break;
2229       case lir_shr:  __ srad(dest-&gt;as_register_lo(), left-&gt;as_register_lo(), tmp-&gt;as_register()); break;
2230       case lir_ushr: __ srd(dest-&gt;as_register_lo(), left-&gt;as_register_lo(), tmp-&gt;as_register()); break;
2231       default: ShouldNotReachHere();
2232     }
2233   }
2234 }
2235 
2236 
2237 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2238 #ifdef _LP64
2239   if (left-&gt;type() == T_OBJECT) {
2240     count = count &amp; 63;  // Shouldn&#39;t shift by more than sizeof(intptr_t).
2241     if (count == 0) { __ mr_if_needed(dest-&gt;as_register_lo(), left-&gt;as_register()); }
2242     else {
2243       switch (code) {
2244         case lir_shl:  __ sldi(dest-&gt;as_register_lo(), left-&gt;as_register(), count); break;
2245         case lir_shr:  __ sradi(dest-&gt;as_register_lo(), left-&gt;as_register(), count); break;
2246         case lir_ushr: __ srdi(dest-&gt;as_register_lo(), left-&gt;as_register(), count); break;
2247         default: ShouldNotReachHere();
2248       }
2249     }
2250     return;
2251   }
2252 #endif
2253 
2254   if (dest-&gt;is_single_cpu()) {
2255     count = count &amp; 0x1F; // Java spec
2256     if (count == 0) { __ mr_if_needed(dest-&gt;as_register(), left-&gt;as_register()); }
2257     else {
2258       switch (code) {
2259         case lir_shl: __ slwi(dest-&gt;as_register(), left-&gt;as_register(), count); break;
2260         case lir_shr:  __ srawi(dest-&gt;as_register(), left-&gt;as_register(), count); break;
2261         case lir_ushr: __ srwi(dest-&gt;as_register(), left-&gt;as_register(), count); break;
2262         default: ShouldNotReachHere();
2263       }
2264     }
2265   } else if (dest-&gt;is_double_cpu()) {
2266     count = count &amp; 63; // Java spec
2267     if (count == 0) { __ mr_if_needed(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register()); }
2268     else {
2269       switch (code) {
2270         case lir_shl:  __ sldi(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register(), count); break;
2271         case lir_shr:  __ sradi(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register(), count); break;
2272         case lir_ushr: __ srdi(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register(), count); break;
2273         default: ShouldNotReachHere();
2274       }
2275     }
2276   } else {
2277     ShouldNotReachHere();
2278   }
2279 }
2280 
2281 
2282 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
2283   if (op-&gt;init_check()) {
2284     if (!os::zero_page_read_protected() || !ImplicitNullChecks) {
2285       explicit_null_check(op-&gt;klass()-&gt;as_register(), op-&gt;stub()-&gt;info());
2286     } else {
2287       add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
2288     }
2289     __ lbz(op-&gt;tmp1()-&gt;as_register(),
2290            in_bytes(InstanceKlass::init_state_offset()), op-&gt;klass()-&gt;as_register());
2291     __ cmpwi(CCR0, op-&gt;tmp1()-&gt;as_register(), InstanceKlass::fully_initialized);
2292     __ bc_far_optimized(Assembler::bcondCRbiIs0, __ bi0(CCR0, Assembler::equal), *op-&gt;stub()-&gt;entry());
2293   }
2294   __ allocate_object(op-&gt;obj()-&gt;as_register(),
2295                      op-&gt;tmp1()-&gt;as_register(),
2296                      op-&gt;tmp2()-&gt;as_register(),
2297                      op-&gt;tmp3()-&gt;as_register(),
2298                      op-&gt;header_size(),
2299                      op-&gt;object_size(),
2300                      op-&gt;klass()-&gt;as_register(),
2301                      *op-&gt;stub()-&gt;entry());
2302 
2303   __ bind(*op-&gt;stub()-&gt;continuation());
<a name="22" id="anc22"></a><span class="line-modified">2304   __ verify_oop(op-&gt;obj()-&gt;as_register());</span>
2305 }
2306 
2307 
2308 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
2309   LP64_ONLY( __ extsw(op-&gt;len()-&gt;as_register(), op-&gt;len()-&gt;as_register()); )
2310   if (UseSlowPath ||
<a name="23" id="anc23"></a><span class="line-modified">2311       (!UseFastNewObjectArray &amp;&amp; (op-&gt;type() == T_OBJECT || op-&gt;type() == T_ARRAY)) ||</span>
<span class="line-modified">2312       (!UseFastNewTypeArray   &amp;&amp; (op-&gt;type() != T_OBJECT &amp;&amp; op-&gt;type() != T_ARRAY))) {</span>
2313     __ b(*op-&gt;stub()-&gt;entry());
2314   } else {
2315     __ allocate_array(op-&gt;obj()-&gt;as_register(),
2316                       op-&gt;len()-&gt;as_register(),
2317                       op-&gt;tmp1()-&gt;as_register(),
2318                       op-&gt;tmp2()-&gt;as_register(),
2319                       op-&gt;tmp3()-&gt;as_register(),
2320                       arrayOopDesc::header_size(op-&gt;type()),
2321                       type2aelembytes(op-&gt;type()),
2322                       op-&gt;klass()-&gt;as_register(),
2323                       *op-&gt;stub()-&gt;entry());
2324   }
2325   __ bind(*op-&gt;stub()-&gt;continuation());
2326 }
2327 
2328 
2329 void LIR_Assembler::type_profile_helper(Register mdo, int mdo_offset_bias,
2330                                         ciMethodData *md, ciProfileData *data,
2331                                         Register recv, Register tmp1, Label* update_done) {
2332   uint i;
2333   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2334     Label next_test;
2335     // See if the receiver is receiver[n].
2336     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) - mdo_offset_bias, mdo);
2337     __ verify_klass_ptr(tmp1);
2338     __ cmpd(CCR0, recv, tmp1);
2339     __ bne(CCR0, next_test);
2340 
2341     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2342     __ addi(tmp1, tmp1, DataLayout::counter_increment);
2343     __ std(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2344     __ b(*update_done);
2345 
2346     __ bind(next_test);
2347   }
2348 
2349   // Didn&#39;t find receiver; find next empty slot and fill it in.
2350   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2351     Label next_test;
2352     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) - mdo_offset_bias, mdo);
2353     __ cmpdi(CCR0, tmp1, 0);
2354     __ bne(CCR0, next_test);
2355     __ li(tmp1, DataLayout::counter_increment);
2356     __ std(recv, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) - mdo_offset_bias, mdo);
2357     __ std(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2358     __ b(*update_done);
2359 
2360     __ bind(next_test);
2361   }
2362 }
2363 
2364 
2365 void LIR_Assembler::setup_md_access(ciMethod* method, int bci,
2366                                     ciMethodData*&amp; md, ciProfileData*&amp; data, int&amp; mdo_offset_bias) {
2367   md = method-&gt;method_data_or_null();
2368   assert(md != NULL, &quot;Sanity&quot;);
2369   data = md-&gt;bci_to_data(bci);
2370   assert(data != NULL,       &quot;need data for checkcast&quot;);
2371   assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
2372   if (!Assembler::is_simm16(md-&gt;byte_offset_of_slot(data, DataLayout::header_offset()) + data-&gt;size_in_bytes())) {
2373     // The offset is large so bias the mdo by the base of the slot so
2374     // that the ld can use simm16s to reference the slots of the data.
2375     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, DataLayout::header_offset());
2376   }
2377 }
2378 
2379 
2380 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
2381   const Register obj = op-&gt;object()-&gt;as_register(); // Needs to live in this register at safepoint (patching stub).
2382   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2383   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2384   Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2385   Register dst = op-&gt;result_opr()-&gt;as_register();
2386   ciKlass* k = op-&gt;klass();
2387   bool should_profile = op-&gt;should_profile();
2388   // Attention: do_temp(opTypeCheck-&gt;_object) is not used, i.e. obj may be same as one of the temps.
2389   bool reg_conflict = false;
2390   if (obj == k_RInfo) {
2391     k_RInfo = dst;
2392     reg_conflict = true;
2393   } else if (obj == klass_RInfo) {
2394     klass_RInfo = dst;
2395     reg_conflict = true;
2396   } else if (obj == Rtmp1) {
2397     Rtmp1 = dst;
2398     reg_conflict = true;
2399   }
2400   assert_different_registers(obj, k_RInfo, klass_RInfo, Rtmp1);
2401 
2402   __ cmpdi(CCR0, obj, 0);
2403 
2404   ciMethodData* md = NULL;
2405   ciProfileData* data = NULL;
2406   int mdo_offset_bias = 0;
2407   if (should_profile) {
2408     ciMethod* method = op-&gt;profiled_method();
2409     assert(method != NULL, &quot;Should have method&quot;);
2410     setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2411 
2412     Register mdo      = k_RInfo;
2413     Register data_val = Rtmp1;
2414     Label not_null;
2415     __ bne(CCR0, not_null);
2416     metadata2reg(md-&gt;constant_encoding(), mdo);
2417     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2418     __ lbz(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2419     __ ori(data_val, data_val, BitData::null_seen_byte_constant());
2420     __ stb(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2421     __ b(*obj_is_null);
2422     __ bind(not_null);
2423   } else {
2424     __ beq(CCR0, *obj_is_null);
2425   }
2426 
2427   // get object class
2428   __ load_klass(klass_RInfo, obj);
2429 
2430   if (k-&gt;is_loaded()) {
2431     metadata2reg(k-&gt;constant_encoding(), k_RInfo);
2432   } else {
2433     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
2434   }
2435 
2436   Label profile_cast_failure, failure_restore_obj, profile_cast_success;
2437   Label *failure_target = should_profile ? &amp;profile_cast_failure : failure;
2438   Label *success_target = should_profile ? &amp;profile_cast_success : success;
2439 
2440   if (op-&gt;fast_check()) {
2441     assert_different_registers(klass_RInfo, k_RInfo);
2442     __ cmpd(CCR0, k_RInfo, klass_RInfo);
2443     if (should_profile) {
2444       __ bne(CCR0, *failure_target);
2445       // Fall through to success case.
2446     } else {
2447       __ beq(CCR0, *success);
2448       // Fall through to failure case.
2449     }
2450   } else {
2451     bool need_slow_path = true;
2452     if (k-&gt;is_loaded()) {
2453       if ((int) k-&gt;super_check_offset() != in_bytes(Klass::secondary_super_cache_offset())) {
2454         need_slow_path = false;
2455       }
2456       // Perform the fast part of the checking logic.
2457       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, (need_slow_path ? success_target : NULL),
2458                                        failure_target, NULL, RegisterOrConstant(k-&gt;super_check_offset()));
2459     } else {
2460       // Perform the fast part of the checking logic.
2461       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, failure_target);
2462     }
2463     if (!need_slow_path) {
2464       if (!should_profile) { __ b(*success); }
2465     } else {
2466       // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2467       address entry = Runtime1::entry_for(Runtime1::slow_subtype_check_id);
2468       // Stub needs fixed registers (tmp1-3).
2469       Register original_k_RInfo = op-&gt;tmp1()-&gt;as_register();
2470       Register original_klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2471       Register original_Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2472       bool keep_obj_alive = reg_conflict &amp;&amp; (op-&gt;code() == lir_checkcast);
2473       bool keep_klass_RInfo_alive = (obj == original_klass_RInfo) &amp;&amp; should_profile;
2474       if (keep_obj_alive &amp;&amp; (obj != original_Rtmp1)) { __ mr(R0, obj); }
2475       __ mr_if_needed(original_k_RInfo, k_RInfo);
2476       __ mr_if_needed(original_klass_RInfo, klass_RInfo);
2477       if (keep_obj_alive) { __ mr(dst, (obj == original_Rtmp1) ? obj : R0); }
2478       //__ load_const_optimized(original_Rtmp1, entry, R0);
2479       __ calculate_address_from_global_toc(original_Rtmp1, entry, true, true, false);
2480       __ mtctr(original_Rtmp1);
2481       __ bctrl(); // sets CR0
2482       if (keep_obj_alive) {
2483         if (keep_klass_RInfo_alive) { __ mr(R0, obj); }
2484         __ mr(obj, dst);
2485       }
2486       if (should_profile) {
2487         __ bne(CCR0, *failure_target);
2488         if (keep_klass_RInfo_alive) { __ mr(klass_RInfo, keep_obj_alive ? R0 : obj); }
2489         // Fall through to success case.
2490       } else {
2491         __ beq(CCR0, *success);
2492         // Fall through to failure case.
2493       }
2494     }
2495   }
2496 
2497   if (should_profile) {
2498     Register mdo = k_RInfo, recv = klass_RInfo;
2499     assert_different_registers(mdo, recv, Rtmp1);
2500     __ bind(profile_cast_success);
2501     metadata2reg(md-&gt;constant_encoding(), mdo);
2502     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2503     type_profile_helper(mdo, mdo_offset_bias, md, data, recv, Rtmp1, success);
2504     __ b(*success);
2505 
2506     // Cast failure case.
2507     __ bind(profile_cast_failure);
2508     metadata2reg(md-&gt;constant_encoding(), mdo);
2509     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2510     __ ld(Rtmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2511     __ addi(Rtmp1, Rtmp1, -DataLayout::counter_increment);
2512     __ std(Rtmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2513   }
2514 
2515   __ bind(*failure);
2516 }
2517 
2518 
2519 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
2520   LIR_Code code = op-&gt;code();
2521   if (code == lir_store_check) {
2522     Register value = op-&gt;object()-&gt;as_register();
2523     Register array = op-&gt;array()-&gt;as_register();
2524     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2525     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2526     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2527     bool should_profile = op-&gt;should_profile();
2528 
<a name="24" id="anc24"></a><span class="line-modified">2529     __ verify_oop(value);</span>
2530     CodeStub* stub = op-&gt;stub();
2531     // Check if it needs to be profiled.
2532     ciMethodData* md = NULL;
2533     ciProfileData* data = NULL;
2534     int mdo_offset_bias = 0;
2535     if (should_profile) {
2536       ciMethod* method = op-&gt;profiled_method();
2537       assert(method != NULL, &quot;Should have method&quot;);
2538       setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2539     }
2540     Label profile_cast_success, failure, done;
2541     Label *success_target = should_profile ? &amp;profile_cast_success : &amp;done;
2542 
2543     __ cmpdi(CCR0, value, 0);
2544     if (should_profile) {
2545       Label not_null;
2546       __ bne(CCR0, not_null);
2547       Register mdo      = k_RInfo;
2548       Register data_val = Rtmp1;
2549       metadata2reg(md-&gt;constant_encoding(), mdo);
2550       __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2551       __ lbz(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2552       __ ori(data_val, data_val, BitData::null_seen_byte_constant());
2553       __ stb(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2554       __ b(done);
2555       __ bind(not_null);
2556     } else {
2557       __ beq(CCR0, done);
2558     }
2559     if (!os::zero_page_read_protected() || !ImplicitNullChecks) {
2560       explicit_null_check(array, op-&gt;info_for_exception());
2561     } else {
2562       add_debug_info_for_null_check_here(op-&gt;info_for_exception());
2563     }
2564     __ load_klass(k_RInfo, array);
2565     __ load_klass(klass_RInfo, value);
2566 
2567     // Get instance klass.
2568     __ ld(k_RInfo, in_bytes(ObjArrayKlass::element_klass_offset()), k_RInfo);
2569     // Perform the fast part of the checking logic.
2570     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, &amp;failure, NULL);
2571 
2572     // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2573     const address slow_path = Runtime1::entry_for(Runtime1::slow_subtype_check_id);
2574     //__ load_const_optimized(R0, slow_path);
2575     __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(slow_path));
2576     __ mtctr(R0);
2577     __ bctrl(); // sets CR0
2578     if (!should_profile) {
2579       __ beq(CCR0, done);
2580       __ bind(failure);
2581     } else {
2582       __ bne(CCR0, failure);
2583       // Fall through to the success case.
2584 
2585       Register mdo  = klass_RInfo, recv = k_RInfo, tmp1 = Rtmp1;
2586       assert_different_registers(value, mdo, recv, tmp1);
2587       __ bind(profile_cast_success);
2588       metadata2reg(md-&gt;constant_encoding(), mdo);
2589       __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2590       __ load_klass(recv, value);
2591       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;done);
2592       __ b(done);
2593 
2594       // Cast failure case.
2595       __ bind(failure);
2596       metadata2reg(md-&gt;constant_encoding(), mdo);
2597       __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2598       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2599       __ ld(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2600       __ addi(tmp1, tmp1, -DataLayout::counter_increment);
2601       __ std(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2602     }
2603     __ b(*stub-&gt;entry());
2604     __ bind(done);
2605 
2606   } else if (code == lir_checkcast) {
2607     Label success, failure;
2608     emit_typecheck_helper(op, &amp;success, /*fallthru*/&amp;failure, &amp;success);
2609     __ b(*op-&gt;stub()-&gt;entry());
2610     __ align(32, 12);
2611     __ bind(success);
2612     __ mr_if_needed(op-&gt;result_opr()-&gt;as_register(), op-&gt;object()-&gt;as_register());
2613   } else if (code == lir_instanceof) {
2614     Register dst = op-&gt;result_opr()-&gt;as_register();
2615     Label success, failure, done;
2616     emit_typecheck_helper(op, &amp;success, /*fallthru*/&amp;failure, &amp;failure);
2617     __ li(dst, 0);
2618     __ b(done);
2619     __ align(32, 12);
2620     __ bind(success);
2621     __ li(dst, 1);
2622     __ bind(done);
2623   } else {
2624     ShouldNotReachHere();
2625   }
2626 }
2627 
2628 
2629 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2630   Register addr = op-&gt;addr()-&gt;as_pointer_register();
2631   Register cmp_value = noreg, new_value = noreg;
2632   bool is_64bit = false;
2633 
2634   if (op-&gt;code() == lir_cas_long) {
2635     cmp_value = op-&gt;cmp_value()-&gt;as_register_lo();
2636     new_value = op-&gt;new_value()-&gt;as_register_lo();
2637     is_64bit = true;
2638   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj) {
2639     cmp_value = op-&gt;cmp_value()-&gt;as_register();
2640     new_value = op-&gt;new_value()-&gt;as_register();
2641     if (op-&gt;code() == lir_cas_obj) {
2642       if (UseCompressedOops) {
2643         Register t1 = op-&gt;tmp1()-&gt;as_register();
2644         Register t2 = op-&gt;tmp2()-&gt;as_register();
2645         cmp_value = __ encode_heap_oop(t1, cmp_value);
2646         new_value = __ encode_heap_oop(t2, new_value);
2647       } else {
2648         is_64bit = true;
2649       }
2650     }
2651   } else {
2652     Unimplemented();
2653   }
2654 
2655   if (is_64bit) {
2656     __ cmpxchgd(BOOL_RESULT, /*current_value=*/R0, cmp_value, new_value, addr,
2657                 MacroAssembler::MemBarNone,
2658                 MacroAssembler::cmpxchgx_hint_atomic_update(),
2659                 noreg, NULL, /*check without ldarx first*/true);
2660   } else {
2661     __ cmpxchgw(BOOL_RESULT, /*current_value=*/R0, cmp_value, new_value, addr,
2662                 MacroAssembler::MemBarNone,
2663                 MacroAssembler::cmpxchgx_hint_atomic_update(),
2664                 noreg, /*check without ldarx first*/true);
2665   }
2666 
2667   if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
2668     __ isync();
2669   } else {
2670     __ sync();
2671   }
2672 }
2673 
<a name="25" id="anc25"></a><span class="line-removed">2674 </span>
<span class="line-removed">2675 void LIR_Assembler::set_24bit_FPU() {</span>
<span class="line-removed">2676   Unimplemented();</span>
<span class="line-removed">2677 }</span>
<span class="line-removed">2678 </span>
<span class="line-removed">2679 void LIR_Assembler::reset_FPU() {</span>
<span class="line-removed">2680   Unimplemented();</span>
<span class="line-removed">2681 }</span>
<span class="line-removed">2682 </span>
<span class="line-removed">2683 </span>
2684 void LIR_Assembler::breakpoint() {
2685   __ illtrap();
2686 }
2687 
2688 
2689 void LIR_Assembler::push(LIR_Opr opr) {
2690   Unimplemented();
2691 }
2692 
2693 void LIR_Assembler::pop(LIR_Opr opr) {
2694   Unimplemented();
2695 }
2696 
2697 
2698 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst_opr) {
2699   Address mon_addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
2700   Register dst = dst_opr-&gt;as_register();
2701   Register reg = mon_addr.base();
2702   int offset = mon_addr.disp();
2703   // Compute pointer to BasicLock.
2704   __ add_const_optimized(dst, reg, offset);
2705 }
2706 
2707 
2708 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2709   Register obj = op-&gt;obj_opr()-&gt;as_register();
2710   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2711   Register lock = op-&gt;lock_opr()-&gt;as_register();
2712 
2713   // Obj may not be an oop.
2714   if (op-&gt;code() == lir_lock) {
2715     MonitorEnterStub* stub = (MonitorEnterStub*)op-&gt;stub();
2716     if (UseFastLocking) {
2717       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2718       // Add debug info for NullPointerException only if one is possible.
2719       if (op-&gt;info() != NULL) {
2720         if (!os::zero_page_read_protected() || !ImplicitNullChecks) {
2721           explicit_null_check(obj, op-&gt;info());
2722         } else {
2723           add_debug_info_for_null_check_here(op-&gt;info());
2724         }
2725       }
2726       __ lock_object(hdr, obj, lock, op-&gt;scratch_opr()-&gt;as_register(), *op-&gt;stub()-&gt;entry());
2727     } else {
2728       // always do slow locking
2729       // note: The slow locking code could be inlined here, however if we use
2730       //       slow locking, speed doesn&#39;t matter anyway and this solution is
2731       //       simpler and requires less duplicated code - additionally, the
2732       //       slow locking code is the same in either case which simplifies
2733       //       debugging.
2734       __ b(*op-&gt;stub()-&gt;entry());
2735     }
2736   } else {
2737     assert (op-&gt;code() == lir_unlock, &quot;Invalid code, expected lir_unlock&quot;);
2738     if (UseFastLocking) {
2739       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2740       __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2741     } else {
2742       // always do slow unlocking
2743       // note: The slow unlocking code could be inlined here, however if we use
2744       //       slow unlocking, speed doesn&#39;t matter anyway and this solution is
2745       //       simpler and requires less duplicated code - additionally, the
2746       //       slow unlocking code is the same in either case which simplifies
2747       //       debugging.
2748       __ b(*op-&gt;stub()-&gt;entry());
2749     }
2750   }
2751   __ bind(*op-&gt;stub()-&gt;continuation());
2752 }
2753 
2754 
2755 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2756   ciMethod* method = op-&gt;profiled_method();
2757   int bci          = op-&gt;profiled_bci();
2758   ciMethod* callee = op-&gt;profiled_callee();
2759 
2760   // Update counter for all call types.
2761   ciMethodData* md = method-&gt;method_data_or_null();
2762   assert(md != NULL, &quot;Sanity&quot;);
2763   ciProfileData* data = md-&gt;bci_to_data(bci);
2764   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2765   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2766   Register mdo = op-&gt;mdo()-&gt;as_register();
2767 #ifdef _LP64
2768   assert(op-&gt;tmp1()-&gt;is_double_cpu(), &quot;tmp1 must be allocated&quot;);
2769   Register tmp1 = op-&gt;tmp1()-&gt;as_register_lo();
2770 #else
2771   assert(op-&gt;tmp1()-&gt;is_single_cpu(), &quot;tmp1 must be allocated&quot;);
2772   Register tmp1 = op-&gt;tmp1()-&gt;as_register();
2773 #endif
2774   metadata2reg(md-&gt;constant_encoding(), mdo);
2775   int mdo_offset_bias = 0;
2776   if (!Assembler::is_simm16(md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) +
2777                             data-&gt;size_in_bytes())) {
2778     // The offset is large so bias the mdo by the base of the slot so
2779     // that the ld can use simm16s to reference the slots of the data.
2780     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, CounterData::count_offset());
2781     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2782   }
2783 
2784   // Perform additional virtual call profiling for invokevirtual and
2785   // invokeinterface bytecodes
2786   if (op-&gt;should_profile_receiver_type()) {
2787     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2788     Register recv = op-&gt;recv()-&gt;as_register();
2789     assert_different_registers(mdo, tmp1, recv);
2790     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2791     ciKlass* known_klass = op-&gt;known_holder();
2792     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2793       // We know the type that will be seen at this call site; we can
2794       // statically update the MethodData* rather than needing to do
2795       // dynamic tests on the receiver type.
2796 
2797       // NOTE: we should probably put a lock around this search to
2798       // avoid collisions by concurrent compilations.
2799       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2800       uint i;
2801       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2802         ciKlass* receiver = vc_data-&gt;receiver(i);
2803         if (known_klass-&gt;equals(receiver)) {
2804           __ ld(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2805           __ addi(tmp1, tmp1, DataLayout::counter_increment);
2806           __ std(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2807           return;
2808         }
2809       }
2810 
2811       // Receiver type not found in profile data; select an empty slot.
2812 
2813       // Note that this is less efficient than it should be because it
2814       // always does a write to the receiver part of the
2815       // VirtualCallData rather than just the first time.
2816       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2817         ciKlass* receiver = vc_data-&gt;receiver(i);
2818         if (receiver == NULL) {
2819           metadata2reg(known_klass-&gt;constant_encoding(), tmp1);
2820           __ std(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)) - mdo_offset_bias, mdo);
2821 
2822           __ ld(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2823           __ addi(tmp1, tmp1, DataLayout::counter_increment);
2824           __ std(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2825           return;
2826         }
2827       }
2828     } else {
2829       __ load_klass(recv, recv);
2830       Label update_done;
2831       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;update_done);
2832       // Receiver did not match any saved receiver and there is no empty row for it.
2833       // Increment total counter to indicate polymorphic case.
2834       __ ld(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2835       __ addi(tmp1, tmp1, DataLayout::counter_increment);
2836       __ std(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2837 
2838       __ bind(update_done);
2839     }
2840   } else {
2841     // Static call
2842     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2843     __ addi(tmp1, tmp1, DataLayout::counter_increment);
2844     __ std(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2845   }
2846 }
2847 
2848 
2849 void LIR_Assembler::align_backward_branch_target() {
2850   __ align(32, 12); // Insert up to 3 nops to align with 32 byte boundary.
2851 }
2852 
2853 
2854 void LIR_Assembler::emit_delay(LIR_OpDelay* op) {
2855   Unimplemented();
2856 }
2857 
2858 
2859 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
2860   // tmp must be unused
2861   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2862   assert(left-&gt;is_register(), &quot;can only handle registers&quot;);
2863 
2864   if (left-&gt;is_single_cpu()) {
2865     __ neg(dest-&gt;as_register(), left-&gt;as_register());
2866   } else if (left-&gt;is_single_fpu()) {
2867     __ fneg(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
2868   } else if (left-&gt;is_double_fpu()) {
2869     __ fneg(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
2870   } else {
2871     assert (left-&gt;is_double_cpu(), &quot;Must be a long&quot;);
2872     __ neg(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
2873   }
2874 }
2875 
2876 
<a name="26" id="anc26"></a><span class="line-removed">2877 void LIR_Assembler::fxch(int i) {</span>
<span class="line-removed">2878   Unimplemented();</span>
<span class="line-removed">2879 }</span>
<span class="line-removed">2880 </span>
<span class="line-removed">2881 void LIR_Assembler::fld(int i) {</span>
<span class="line-removed">2882   Unimplemented();</span>
<span class="line-removed">2883 }</span>
<span class="line-removed">2884 </span>
<span class="line-removed">2885 void LIR_Assembler::ffree(int i) {</span>
<span class="line-removed">2886   Unimplemented();</span>
<span class="line-removed">2887 }</span>
<span class="line-removed">2888 </span>
<span class="line-removed">2889 </span>
2890 void LIR_Assembler::rt_call(LIR_Opr result, address dest,
2891                             const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
2892   // Stubs: Called via rt_call, but dest is a stub address (no function descriptor).
2893   if (dest == Runtime1::entry_for(Runtime1::register_finalizer_id) ||
2894       dest == Runtime1::entry_for(Runtime1::new_multi_array_id   )) {
2895     //__ load_const_optimized(R0, dest);
2896     __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(dest));
2897     __ mtctr(R0);
2898     __ bctrl();
2899     assert(info != NULL, &quot;sanity&quot;);
2900     add_call_info_here(info);
2901     return;
2902   }
2903 
2904   __ call_c_with_frame_resize(dest, /*no resizing*/ 0);
2905   if (info != NULL) {
2906     add_call_info_here(info);
2907   }
2908 }
2909 
2910 
2911 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
2912   ShouldNotReachHere(); // Not needed on _LP64.
2913 }
2914 
2915 void LIR_Assembler::membar() {
2916   __ fence();
2917 }
2918 
2919 void LIR_Assembler::membar_acquire() {
2920   __ acquire();
2921 }
2922 
2923 void LIR_Assembler::membar_release() {
2924   __ release();
2925 }
2926 
2927 void LIR_Assembler::membar_loadload() {
2928   __ membar(Assembler::LoadLoad);
2929 }
2930 
2931 void LIR_Assembler::membar_storestore() {
2932   __ membar(Assembler::StoreStore);
2933 }
2934 
2935 void LIR_Assembler::membar_loadstore() {
2936   __ membar(Assembler::LoadStore);
2937 }
2938 
2939 void LIR_Assembler::membar_storeload() {
2940   __ membar(Assembler::StoreLoad);
2941 }
2942 
2943 void LIR_Assembler::on_spin_wait() {
2944   Unimplemented();
2945 }
2946 
2947 void LIR_Assembler::leal(LIR_Opr addr_opr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
2948   assert(patch_code == lir_patch_none, &quot;Patch code not supported&quot;);
2949   LIR_Address* addr = addr_opr-&gt;as_address_ptr();
2950   assert(addr-&gt;scale() == LIR_Address::times_1, &quot;no scaling on this platform&quot;);
2951   if (addr-&gt;index()-&gt;is_illegal()) {
2952     __ add_const_optimized(dest-&gt;as_pointer_register(), addr-&gt;base()-&gt;as_pointer_register(), addr-&gt;disp());
2953   } else {
2954     assert(addr-&gt;disp() == 0, &quot;can&#39;t have both: index and disp&quot;);
2955     __ add(dest-&gt;as_pointer_register(), addr-&gt;index()-&gt;as_pointer_register(), addr-&gt;base()-&gt;as_pointer_register());
2956   }
2957 }
2958 
2959 
2960 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
2961   ShouldNotReachHere();
2962 }
2963 
2964 
2965 #ifdef ASSERT
2966 // Emit run-time assertion.
2967 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
2968   Unimplemented();
2969 }
2970 #endif
2971 
2972 
2973 void LIR_Assembler::peephole(LIR_List* lir) {
2974   // Optimize instruction pairs before emitting.
2975   LIR_OpList* inst = lir-&gt;instructions_list();
2976   for (int i = 1; i &lt; inst-&gt;length(); i++) {
2977     LIR_Op* op = inst-&gt;at(i);
2978 
2979     // 2 register-register-moves
2980     if (op-&gt;code() == lir_move) {
2981       LIR_Opr in2  = ((LIR_Op1*)op)-&gt;in_opr(),
2982               res2 = ((LIR_Op1*)op)-&gt;result_opr();
2983       if (in2-&gt;is_register() &amp;&amp; res2-&gt;is_register()) {
2984         LIR_Op* prev = inst-&gt;at(i - 1);
2985         if (prev &amp;&amp; prev-&gt;code() == lir_move) {
2986           LIR_Opr in1  = ((LIR_Op1*)prev)-&gt;in_opr(),
2987                   res1 = ((LIR_Op1*)prev)-&gt;result_opr();
2988           if (in1-&gt;is_same_register(res2) &amp;&amp; in2-&gt;is_same_register(res1)) {
2989             inst-&gt;remove_at(i);
2990           }
2991         }
2992       }
2993     }
2994 
2995   }
2996   return;
2997 }
2998 
2999 
3000 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
3001   const LIR_Address *addr = src-&gt;as_address_ptr();
3002   assert(addr-&gt;disp() == 0 &amp;&amp; addr-&gt;index()-&gt;is_illegal(), &quot;use leal!&quot;);
3003   const Register Rptr = addr-&gt;base()-&gt;as_pointer_register(),
3004                  Rtmp = tmp-&gt;as_register();
3005   Register Rco = noreg;
3006   if (UseCompressedOops &amp;&amp; data-&gt;is_oop()) {
3007     Rco = __ encode_heap_oop(Rtmp, data-&gt;as_register());
3008   }
3009 
3010   Label Lretry;
3011   __ bind(Lretry);
3012 
3013   if (data-&gt;type() == T_INT) {
3014     const Register Rold = dest-&gt;as_register(),
3015                    Rsrc = data-&gt;as_register();
3016     assert_different_registers(Rptr, Rtmp, Rold, Rsrc);
3017     __ lwarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3018     if (code == lir_xadd) {
3019       __ add(Rtmp, Rsrc, Rold);
3020       __ stwcx_(Rtmp, Rptr);
3021     } else {
3022       __ stwcx_(Rsrc, Rptr);
3023     }
3024   } else if (data-&gt;is_oop()) {
3025     assert(code == lir_xchg, &quot;xadd for oops&quot;);
3026     const Register Rold = dest-&gt;as_register();
3027     if (UseCompressedOops) {
3028       assert_different_registers(Rptr, Rold, Rco);
3029       __ lwarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3030       __ stwcx_(Rco, Rptr);
3031     } else {
3032       const Register Robj = data-&gt;as_register();
3033       assert_different_registers(Rptr, Rold, Robj);
3034       __ ldarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3035       __ stdcx_(Robj, Rptr);
3036     }
3037   } else if (data-&gt;type() == T_LONG) {
3038     const Register Rold = dest-&gt;as_register_lo(),
3039                    Rsrc = data-&gt;as_register_lo();
3040     assert_different_registers(Rptr, Rtmp, Rold, Rsrc);
3041     __ ldarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3042     if (code == lir_xadd) {
3043       __ add(Rtmp, Rsrc, Rold);
3044       __ stdcx_(Rtmp, Rptr);
3045     } else {
3046       __ stdcx_(Rsrc, Rptr);
3047     }
3048   } else {
3049     ShouldNotReachHere();
3050   }
3051 
3052   if (UseStaticBranchPredictionInCompareAndSwapPPC64) {
3053     __ bne_predict_not_taken(CCR0, Lretry);
3054   } else {
3055     __ bne(                  CCR0, Lretry);
3056   }
3057 
3058   if (UseCompressedOops &amp;&amp; data-&gt;is_oop()) {
3059     __ decode_heap_oop(dest-&gt;as_register());
3060   }
3061 }
3062 
3063 
3064 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3065   Register obj = op-&gt;obj()-&gt;as_register();
3066   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3067   LIR_Address* mdo_addr = op-&gt;mdp()-&gt;as_address_ptr();
3068   ciKlass* exact_klass = op-&gt;exact_klass();
3069   intptr_t current_klass = op-&gt;current_klass();
3070   bool not_null = op-&gt;not_null();
3071   bool no_conflict = op-&gt;no_conflict();
3072 
3073   Label Lupdate, Ldo_update, Ldone;
3074 
3075   bool do_null = !not_null;
3076   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3077   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3078 
3079   assert(do_null || do_update, &quot;why are we here?&quot;);
3080   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3081 
<a name="27" id="anc27"></a><span class="line-modified">3082   __ verify_oop(obj);</span>
3083 
3084   if (do_null) {
3085     if (!TypeEntries::was_null_seen(current_klass)) {
3086       __ cmpdi(CCR0, obj, 0);
3087       __ bne(CCR0, Lupdate);
3088       __ ld(R0, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3089       __ ori(R0, R0, TypeEntries::null_seen);
3090       if (do_update) {
3091         __ b(Ldo_update);
3092       } else {
3093         __ std(R0, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3094       }
3095     } else {
3096       if (do_update) {
3097         __ cmpdi(CCR0, obj, 0);
3098         __ beq(CCR0, Ldone);
3099       }
3100     }
3101 #ifdef ASSERT
3102   } else {
3103     __ cmpdi(CCR0, obj, 0);
3104     __ bne(CCR0, Lupdate);
3105     __ stop(&quot;unexpect null obj&quot;, 0x9652);
3106 #endif
3107   }
3108 
3109   __ bind(Lupdate);
3110   if (do_update) {
3111     Label Lnext;
3112     const Register klass = R29_TOC; // kill and reload
3113     bool klass_reg_used = false;
3114 #ifdef ASSERT
3115     if (exact_klass != NULL) {
3116       Label ok;
3117       klass_reg_used = true;
3118       __ load_klass(klass, obj);
3119       metadata2reg(exact_klass-&gt;constant_encoding(), R0);
3120       __ cmpd(CCR0, klass, R0);
3121       __ beq(CCR0, ok);
3122       __ stop(&quot;exact klass and actual klass differ&quot;, 0x8564);
3123       __ bind(ok);
3124     }
3125 #endif
3126 
3127     if (!no_conflict) {
3128       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3129         klass_reg_used = true;
3130         if (exact_klass != NULL) {
3131           __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3132           metadata2reg(exact_klass-&gt;constant_encoding(), klass);
3133         } else {
3134           __ load_klass(klass, obj);
3135           __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register()); // may kill obj
3136         }
3137 
3138         // Like InterpreterMacroAssembler::profile_obj_type
3139         __ clrrdi(R0, tmp, exact_log2(-TypeEntries::type_klass_mask));
3140         // Basically same as andi(R0, tmp, TypeEntries::type_klass_mask);
3141         __ cmpd(CCR1, R0, klass);
3142         // Klass seen before, nothing to do (regardless of unknown bit).
3143         //beq(CCR1, do_nothing);
3144 
3145         __ andi_(R0, klass, TypeEntries::type_unknown);
3146         // Already unknown. Nothing to do anymore.
3147         //bne(CCR0, do_nothing);
3148         __ crorc(CCR0, Assembler::equal, CCR1, Assembler::equal); // cr0 eq = cr1 eq or cr0 ne
3149         __ beq(CCR0, Lnext);
3150 
3151         if (TypeEntries::is_type_none(current_klass)) {
3152           __ clrrdi_(R0, tmp, exact_log2(-TypeEntries::type_mask));
3153           __ orr(R0, klass, tmp); // Combine klass and null_seen bit (only used if (tmp &amp; type_mask)==0).
3154           __ beq(CCR0, Ldo_update); // First time here. Set profile type.
3155         }
3156 
3157       } else {
3158         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3159                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3160 
3161         __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3162         __ andi_(R0, tmp, TypeEntries::type_unknown);
3163         // Already unknown. Nothing to do anymore.
3164         __ bne(CCR0, Lnext);
3165       }
3166 
3167       // Different than before. Cannot keep accurate profile.
3168       __ ori(R0, tmp, TypeEntries::type_unknown);
3169     } else {
3170       // There&#39;s a single possible klass at this profile point
3171       assert(exact_klass != NULL, &quot;should be&quot;);
3172       __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3173 
3174       if (TypeEntries::is_type_none(current_klass)) {
3175         klass_reg_used = true;
3176         metadata2reg(exact_klass-&gt;constant_encoding(), klass);
3177 
3178         __ clrrdi(R0, tmp, exact_log2(-TypeEntries::type_klass_mask));
3179         // Basically same as andi(R0, tmp, TypeEntries::type_klass_mask);
3180         __ cmpd(CCR1, R0, klass);
3181         // Klass seen before, nothing to do (regardless of unknown bit).
3182         __ beq(CCR1, Lnext);
3183 #ifdef ASSERT
3184         {
3185           Label ok;
3186           __ clrrdi_(R0, tmp, exact_log2(-TypeEntries::type_mask));
3187           __ beq(CCR0, ok); // First time here.
3188 
3189           __ stop(&quot;unexpected profiling mismatch&quot;, 0x7865);
3190           __ bind(ok);
3191         }
3192 #endif
3193         // First time here. Set profile type.
3194         __ orr(R0, klass, tmp); // Combine klass and null_seen bit (only used if (tmp &amp; type_mask)==0).
3195       } else {
3196         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3197                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3198 
3199         // Already unknown. Nothing to do anymore.
3200         __ andi_(R0, tmp, TypeEntries::type_unknown);
3201         __ bne(CCR0, Lnext);
3202 
3203         // Different than before. Cannot keep accurate profile.
3204         __ ori(R0, tmp, TypeEntries::type_unknown);
3205       }
3206     }
3207 
3208     __ bind(Ldo_update);
3209     __ std(R0, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3210 
3211     __ bind(Lnext);
3212     if (klass_reg_used) { __ load_const_optimized(R29_TOC, MacroAssembler::global_toc(), R0); } // reinit
3213   }
3214   __ bind(Ldone);
3215 }
3216 
3217 
3218 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3219   assert(op-&gt;crc()-&gt;is_single_cpu(), &quot;crc must be register&quot;);
3220   assert(op-&gt;val()-&gt;is_single_cpu(), &quot;byte value must be register&quot;);
3221   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3222   Register crc = op-&gt;crc()-&gt;as_register();
3223   Register val = op-&gt;val()-&gt;as_register();
3224   Register res = op-&gt;result_opr()-&gt;as_register();
3225 
3226   assert_different_registers(val, crc, res);
3227 
3228   __ load_const_optimized(res, StubRoutines::crc_table_addr(), R0);
3229   __ kernel_crc32_singleByteReg(crc, val, res, true);
3230   __ mr(res, crc);
3231 }
3232 
3233 #undef __
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
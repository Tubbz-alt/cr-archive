<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/ppc/interp_masm_ppc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2012, 2017 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_PPC_INTERP_MASM_PPC_HPP
 27 #define CPU_PPC_INTERP_MASM_PPC_HPP
 28 
 29 #include &quot;asm/macroAssembler.hpp&quot;
 30 #include &quot;interpreter/invocationCounter.hpp&quot;
 31 
 32 // This file specializes the assembler with interpreter-specific macros.
 33 
 34 
 35 class InterpreterMacroAssembler: public MacroAssembler {
 36 
 37  public:
 38   InterpreterMacroAssembler(CodeBuffer* code) : MacroAssembler(code) {}
 39 
 40   void null_check_throw(Register a, int offset, Register temp_reg);
 41 
 42   void jump_to_entry(address entry, Register Rscratch);
 43 
 44   // Handy address generation macros.
 45 #define thread_(field_name) in_bytes(JavaThread::field_name ## _offset()), R16_thread
 46 #define method_(field_name) in_bytes(Method::field_name ## _offset()), R19_method
 47 
 48   virtual void check_and_handle_popframe(Register scratch_reg);
 49   virtual void check_and_handle_earlyret(Register scratch_reg);
 50 
 51   // Base routine for all dispatches.
 52   void dispatch_base(TosState state, address* table);
 53 
 54   void load_earlyret_value(TosState state, Register Rscratch1);
 55 
 56   static const Address l_tmp;
 57   static const Address d_tmp;
 58 
 59   // dispatch routines
 60   void dispatch_next(TosState state, int step = 0, bool generate_poll = false);
 61   void dispatch_via (TosState state, address* table);
 62   void load_dispatch_table(Register dst, address* table);
 63   void dispatch_Lbyte_code(TosState state, Register bytecode, address* table, bool generate_poll = false);
 64 
 65   // Called by shared interpreter generator.
 66   void dispatch_prolog(TosState state, int step = 0);
 67   void dispatch_epilog(TosState state, int step = 0);
 68 
 69   // Super call_VM calls - correspond to MacroAssembler::call_VM(_leaf) calls.
 70   void super_call_VM_leaf(Register thread_cache, address entry_point, Register arg_1);
 71   void super_call_VM(Register thread_cache, Register oop_result, Register last_java_sp,
 72                      address entry_point, Register arg_1, Register arg_2, bool check_exception = true);
 73 
 74   // Generate a subtype check: branch to ok_is_subtype if sub_klass is
 75   // a subtype of super_klass.  Blows registers tmp1, tmp2 and tmp3.
 76   void gen_subtype_check(Register sub_klass, Register super_klass,
 77                          Register tmp1, Register tmp2, Register tmp3, Label &amp;ok_is_subtype);
 78 
 79   // Load object from cpool-&gt;resolved_references(index).
 80   void load_resolved_reference_at_index(Register result, Register index, Label *L_handle_null = NULL);
 81 
 82   // load cpool-&gt;resolved_klass_at(index)
 83   void load_resolved_klass_at_offset(Register Rcpool, Register Roffset, Register Rklass);
 84 
 85   void load_receiver(Register Rparam_count, Register Rrecv_dst);
 86 
 87   // helpers for expression stack
 88   void pop_i(     Register r = R17_tos);
 89   void pop_ptr(   Register r = R17_tos);
 90   void pop_l(     Register r = R17_tos);
 91   void pop_f(FloatRegister f = F15_ftos);
 92   void pop_d(FloatRegister f = F15_ftos );
 93 
 94   void push_i(     Register r = R17_tos);
 95   void push_ptr(   Register r = R17_tos);
 96   void push_l(     Register r = R17_tos);
 97   void push_f(FloatRegister f = F15_ftos );
 98   void push_d(FloatRegister f = F15_ftos);
 99 
100   void push_2ptrs(Register first, Register second);
101 
102   void move_l_to_d(Register l = R17_tos, FloatRegister d = F15_ftos);
103   void move_d_to_l(FloatRegister d = F15_ftos, Register l = R17_tos);
104 
105   void pop (TosState state);           // transition vtos -&gt; state
106   void push(TosState state);           // transition state -&gt; vtos
107   void empty_expression_stack();       // Resets both Lesp and SP.
108 
109  public:
110   // Load values from bytecode stream:
111 
112   enum signedOrNot { Signed, Unsigned };
113   enum setCCOrNot  { set_CC, dont_set_CC };
114 
115   void get_2_byte_integer_at_bcp(int         bcp_offset,
116                                  Register    Rdst,
117                                  signedOrNot is_signed);
118 
119   void get_4_byte_integer_at_bcp(int         bcp_offset,
120                                  Register    Rdst,
121                                  signedOrNot is_signed = Unsigned);
122 
123   void get_cache_index_at_bcp(Register Rdst, int bcp_offset, size_t index_size);
124 
125   void get_cache_and_index_at_bcp(Register cache, int bcp_offset, size_t index_size = sizeof(u2));
126 
127   void get_u4(Register Rdst, Register Rsrc, int offset, signedOrNot is_signed);
128 
129   // common code
130 
131   void field_offset_at(int n, Register tmp, Register dest, Register base);
132   int  field_offset_at(Register object, address bcp, int offset);
133   void fast_iaaccess(int n, address bcp);
134   void fast_iaputfield(address bcp, bool do_store_check);
135 
136   void index_check(Register array, Register index, int index_shift, Register tmp, Register res);
137   void index_check_without_pop(Register array, Register index, int index_shift, Register tmp, Register res);
138 
139   void get_const(Register Rdst);
140   void get_constant_pool(Register Rdst);
141   void get_constant_pool_cache(Register Rdst);
142   void get_cpool_and_tags(Register Rcpool, Register Rtags);
143   void is_a(Label&amp; L);
144 
145   void narrow(Register result);
146 
147   // Java Call Helpers
148   void call_from_interpreter(Register Rtarget_method, Register Rret_addr, Register Rscratch1, Register Rscratch2);
149 
150   // --------------------------------------------------
151 
152   void unlock_if_synchronized_method(TosState state, bool throw_monitor_exception = true,
153                                      bool install_monitor_exception = true);
154 
155   // Removes the current activation (incl. unlocking of monitors).
156   // Additionally this code is used for earlyReturn in which case we
157   // want to skip throwing an exception and installing an exception.
158   void remove_activation(TosState state,
159                          bool throw_monitor_exception = true,
160                          bool install_monitor_exception = true);
161   void merge_frames(Register Rtop_frame_sp, Register return_pc, Register Rscratch1, Register Rscratch2); // merge top frames
162 
163   void add_monitor_to_stack(bool stack_is_empty, Register Rtemp1, Register Rtemp2);
164 
165   // Local variable access helpers
166   void load_local_int(Register Rdst_value, Register Rdst_address, Register Rindex);
167   void load_local_long(Register Rdst_value, Register Rdst_address, Register Rindex);
168   void load_local_ptr(Register Rdst_value, Register Rdst_address, Register Rindex);
169   void load_local_float(FloatRegister Rdst_value, Register Rdst_address, Register Rindex);
170   void load_local_double(FloatRegister Rdst_value, Register Rdst_address, Register Rindex);
171   void store_local_int(Register Rvalue, Register Rindex);
172   void store_local_long(Register Rvalue, Register Rindex);
173   void store_local_ptr(Register Rvalue, Register Rindex);
174   void store_local_float(FloatRegister Rvalue, Register Rindex);
175   void store_local_double(FloatRegister Rvalue, Register Rindex);
176 
177   // Call VM for std frames
178   // Special call VM versions that check for exceptions and forward exception
179   // via short cut (not via expensive forward exception stub).
180   void check_and_forward_exception(Register Rscratch1, Register Rscratch2);
181   void call_VM(Register oop_result, address entry_point, bool check_exceptions = true);
182   void call_VM(Register oop_result, address entry_point, Register arg_1, bool check_exceptions = true);
183   void call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
184   void call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
185   // Should not be used:
186   void call_VM(Register oop_result, Register last_java_sp, address entry_point, bool check_exceptions = true) {ShouldNotReachHere();}
187   void call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true) {ShouldNotReachHere();}
188   void call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true) {ShouldNotReachHere();}
189   void call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true) {ShouldNotReachHere();}
190 
191   Address first_local_in_stack();
192 
193   enum LoadOrStore { load, store };
194   void static_iload_or_store(int which_local, LoadOrStore direction, Register Rtmp);
195   void static_aload_or_store(int which_local, LoadOrStore direction, Register Rtmp);
196   void static_dload_or_store(int which_local, LoadOrStore direction);
197 
198   void save_interpreter_state(Register scratch);
199   void restore_interpreter_state(Register scratch, bool bcp_and_mdx_only = false);
200 
201   void increment_backedge_counter(const Register Rcounters, Register Rtmp, Register Rtmp2, Register Rscratch);
202   void test_backedge_count_for_osr(Register backedge_count, Register method_counters, Register target_bcp, Register disp, Register Rtmp);
203 
204   void record_static_call_in_profile(Register Rentry, Register Rtmp);
205   void record_receiver_call_in_profile(Register Rklass, Register Rentry, Register Rtmp);
206 
207   void get_method_counters(Register method, Register Rcounters, Label&amp; skip);
208   void increment_invocation_counter(Register iv_be_count, Register Rtmp1, Register Rtmp2_r0);
209 
210   // Object locking
211   void lock_object  (Register lock_reg, Register obj_reg);
212   void unlock_object(Register lock_reg, bool check_for_exceptions = true);
213 
214   // Interpreter profiling operations
215   void set_method_data_pointer_for_bcp();
216   void test_method_data_pointer(Label&amp; zero_continue);
217   void verify_method_data_pointer();
218   void test_invocation_counter_for_mdp(Register invocation_count, Register method_counters, Register Rscratch, Label &amp;profile_continue);
219 
220   void set_mdp_data_at(int constant, Register value);
221 
222   void increment_mdp_data_at(int constant, Register counter_addr, Register Rbumped_count, bool decrement = false);
223 
224   void increment_mdp_data_at(Register counter_addr, Register Rbumped_count, bool decrement = false);
225   void increment_mdp_data_at(Register reg, int constant, Register scratch, Register Rbumped_count, bool decrement = false);
226 
227   void set_mdp_flag_at(int flag_constant, Register scratch);
228   void test_mdp_data_at(int offset, Register value, Label&amp; not_equal_continue, Register test_out);
229 
230   void update_mdp_by_offset(int offset_of_disp, Register scratch);
231   void update_mdp_by_offset(Register reg, int offset_of_disp,
232                             Register scratch);
233   void update_mdp_by_constant(int constant);
234   void update_mdp_for_ret(TosState state, Register return_bci);
235 
236   void profile_taken_branch(Register scratch, Register bumped_count);
237   void profile_not_taken_branch(Register scratch1, Register scratch2);
238   void profile_call(Register scratch1, Register scratch2);
239   void profile_final_call(Register scratch1, Register scratch2);
240   void profile_virtual_call(Register Rreceiver, Register Rscratch1, Register Rscratch2,  bool receiver_can_be_null);
241   void profile_typecheck(Register Rklass, Register Rscratch1, Register Rscratch2);
242   void profile_typecheck_failed(Register Rscratch1, Register Rscratch2);
243   void profile_ret(TosState state, Register return_bci, Register scratch1, Register scratch2);
244   void profile_switch_default(Register scratch1, Register scratch2);
245   void profile_switch_case(Register index, Register scratch1,Register scratch2, Register scratch3);
246   void profile_null_seen(Register Rscratch1, Register Rscratch2);
247   void record_klass_in_profile(Register receiver, Register scratch1, Register scratch2, bool is_virtual_call);
248   void record_klass_in_profile_helper(Register receiver, Register scratch1, Register scratch2, int start_row, Label&amp; done, bool is_virtual_call);
249 
250   // Argument and return type profiling.
251   void profile_obj_type(Register obj, Register mdo_addr_base, RegisterOrConstant mdo_addr_offs, Register tmp, Register tmp2);
252   void profile_arguments_type(Register callee, Register tmp1, Register tmp2, bool is_virtual);
253   void profile_return_type(Register ret, Register tmp1, Register tmp2);
254   void profile_parameters_type(Register tmp1, Register tmp2, Register tmp3, Register tmp4);
255 
256   // Debugging
257   void verify_oop(Register reg, TosState state = atos);    // only if +VerifyOops &amp;&amp; state == atos
258   void verify_oop_or_return_address(Register reg, Register rtmp); // for astore
259   void verify_FPU(int stack_depth, TosState state = ftos);
260 
261   typedef enum { NotifyJVMTI, SkipNotifyJVMTI } NotifyMethodExitMode;
262 
263   // Support for jvmdi/jvmpi.
264   void notify_method_entry();
265   void notify_method_exit(bool is_native_method, TosState state,
266                           NotifyMethodExitMode mode, bool check_exceptions);
267 };
268 
269 #endif // CPU_PPC_INTERP_MASM_PPC_HPP
    </pre>
  </body>
</html>
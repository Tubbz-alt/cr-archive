<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/ppc/interp_masm_ppc_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_ppc.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRT_ppc.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/interp_masm_ppc_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -32,10 +32,11 @@</span>
  #include &quot;interpreter/interpreterRuntime.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  // Implementation of InterpreterMacroAssembler.
  
  // This file specializes the assembler with interpreter-specific macros.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -514,10 +515,22 @@</span>
    addi(Roffset, Roffset, Array&lt;Klass*&gt;::base_offset_in_bytes());
    isync(); // Order load of instance Klass wrt. tags.
    ldx(Rklass, Rklass, Roffset);
  }
  
<span class="udiff-line-added">+ void InterpreterMacroAssembler::load_resolved_method_at_index(int byte_no,</span>
<span class="udiff-line-added">+                                                               Register cache,</span>
<span class="udiff-line-added">+                                                               Register method) {</span>
<span class="udiff-line-added">+   const int method_offset = in_bytes(</span>
<span class="udiff-line-added">+     ConstantPoolCache::base_offset() +</span>
<span class="udiff-line-added">+       ((byte_no == TemplateTable::f2_byte)</span>
<span class="udiff-line-added">+        ? ConstantPoolCacheEntry::f2_offset()</span>
<span class="udiff-line-added">+        : ConstantPoolCacheEntry::f1_offset()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ld(method, method_offset, cache); // get f1 Method*</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Generate a subtype check: branch to ok_is_subtype if sub_klass is
  // a subtype of super_klass. Blows registers Rsub_klass, tmp1, tmp2.
  void InterpreterMacroAssembler::gen_subtype_check(Register Rsub_klass, Register Rsuper_klass, Register Rtmp1,
                                                    Register Rtmp2, Register Rtmp3, Label &amp;ok_is_subtype) {
    // Profile the not-null value&#39;s klass.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -754,20 +767,10 @@</span>
                                               Register Rscratch1, Register Rscratch2) {
    // Pop interpreter frame.
    ld(Rscratch1, 0, R1_SP); // *SP
    ld(Rsender_sp, _ijava_state_neg(sender_sp), Rscratch1); // top_frame_sp
    ld(Rscratch2, 0, Rscratch1); // **SP
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     Label Lok;</span>
<span class="udiff-line-removed">-     ld(R0, _ijava_state_neg(ijava_reserved), Rscratch1);</span>
<span class="udiff-line-removed">-     cmpdi(CCR0, R0, 0x5afe);</span>
<span class="udiff-line-removed">-     beq(CCR0, Lok);</span>
<span class="udiff-line-removed">-     stop(&quot;frame corrupted (remove activation)&quot;, 0x5afe);</span>
<span class="udiff-line-removed">-     bind(Lok);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
    if (return_pc!=noreg) {
      ld(return_pc, _abi(lr), Rscratch1); // LR
    }
  
    // Merge top frames.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -877,13 +880,13 @@</span>
      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),
              monitor, /*check_for_exceptions=*/true);
    } else {
      // template code:
      //
<span class="udiff-line-modified-removed">-     // markOop displaced_header = obj-&gt;mark().set_unlocked();</span>
<span class="udiff-line-modified-added">+     // markWord displaced_header = obj-&gt;mark().set_unlocked();</span>
      // monitor-&gt;lock()-&gt;set_displaced_header(displaced_header);
<span class="udiff-line-modified-removed">-     // if (Atomic::cmpxchg(/*ex=*/monitor, /*addr*/obj-&gt;mark_addr(), /*cmp*/displaced_header) == displaced_header) {</span>
<span class="udiff-line-modified-added">+     // if (Atomic::cmpxchg(/*addr*/obj-&gt;mark_addr(), /*cmp*/displaced_header, /*ex=*/monitor) == displaced_header) {</span>
      //   // We stored the monitor address into the object&#39;s mark word.
      // } else if (THREAD-&gt;is_lock_owned((address)displaced_header))
      //   // Simple recursive case.
      //   monitor-&gt;lock()-&gt;set_displaced_header(NULL);
      // } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -899,29 +902,29 @@</span>
      Label done;
      Label cas_failed, slow_case;
  
      assert_different_registers(displaced_header, object_mark_addr, current_header, tmp);
  
<span class="udiff-line-modified-removed">-     // markOop displaced_header = obj-&gt;mark().set_unlocked();</span>
<span class="udiff-line-modified-added">+     // markWord displaced_header = obj-&gt;mark().set_unlocked();</span>
  
<span class="udiff-line-modified-removed">-     // Load markOop from object into displaced_header.</span>
<span class="udiff-line-modified-added">+     // Load markWord from object into displaced_header.</span>
      ld(displaced_header, oopDesc::mark_offset_in_bytes(), object);
  
      if (UseBiasedLocking) {
        biased_locking_enter(CCR0, object, displaced_header, tmp, current_header, done, &amp;slow_case);
      }
  
<span class="udiff-line-modified-removed">-     // Set displaced_header to be (markOop of object | UNLOCK_VALUE).</span>
<span class="udiff-line-modified-removed">-     ori(displaced_header, displaced_header, markOopDesc::unlocked_value);</span>
<span class="udiff-line-modified-added">+     // Set displaced_header to be (markWord of object | UNLOCK_VALUE).</span>
<span class="udiff-line-modified-added">+     ori(displaced_header, displaced_header, markWord::unlocked_value);</span>
  
      // monitor-&gt;lock()-&gt;set_displaced_header(displaced_header);
  
      // Initialize the box (Must happen before we update the object mark!).
      std(displaced_header, BasicObjectLock::lock_offset_in_bytes() +
          BasicLock::displaced_header_offset_in_bytes(), monitor);
  
<span class="udiff-line-modified-removed">-     // if (Atomic::cmpxchg(/*ex=*/monitor, /*addr*/obj-&gt;mark_addr(), /*cmp*/displaced_header) == displaced_header) {</span>
<span class="udiff-line-modified-added">+     // if (Atomic::cmpxchg(/*addr*/obj-&gt;mark_addr(), /*cmp*/displaced_header, /*ex=*/monitor) == displaced_header) {</span>
  
      // Store stack address of the BasicObjectLock (this is monitor) into object.
      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());
  
      // Must fence, otherwise, preceding store(s) may float below cmpxchg.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -945,16 +948,16 @@</span>
      //   // Simple recursive case.
      //   monitor-&gt;lock()-&gt;set_displaced_header(NULL);
  
      // We did not see an unlocked object so try the fast recursive case.
  
<span class="udiff-line-modified-removed">-     // Check if owner is self by comparing the value in the markOop of object</span>
<span class="udiff-line-modified-added">+     // Check if owner is self by comparing the value in the markWord of object</span>
      // (current_header) with the stack pointer.
      sub(current_header, current_header, R1_SP);
  
      assert(os::vm_page_size() &gt; 0xfff, &quot;page size too small - change the constant&quot;);
<span class="udiff-line-modified-removed">-     load_const_optimized(tmp, ~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place);</span>
<span class="udiff-line-modified-added">+     load_const_optimized(tmp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);</span>
  
      and_(R0/*==0?*/, current_header, tmp);
      // If condition is true we are done and hence we can store 0 in the displaced
      // header indicating it is a recursive lock.
      bne(CCR0, slow_case);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -993,11 +996,11 @@</span>
      // template code:
      //
      // if ((displaced_header = monitor-&gt;displaced_header()) == NULL) {
      //   // Recursive unlock. Mark the monitor unlocked by setting the object field to NULL.
      //   monitor-&gt;set_obj(NULL);
<span class="udiff-line-modified-removed">-     // } else if (Atomic::cmpxchg(displaced_header, obj-&gt;mark_addr(), monitor) == monitor) {</span>
<span class="udiff-line-modified-added">+     // } else if (Atomic::cmpxchg(obj-&gt;mark_addr(), monitor, displaced_header) == monitor) {</span>
      //   // We swapped the unlocked mark in displaced_header into the object&#39;s mark word.
      //   monitor-&gt;set_obj(NULL);
      // } else {
      //   // Slow path.
      //   InterpreterRuntime::monitorexit(THREAD, monitor);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1026,11 +1029,11 @@</span>
  
      // If the displaced header is zero, we have a recursive unlock.
      cmpdi(CCR0, displaced_header, 0);
      beq(CCR0, free_slot); // recursive unlock
  
<span class="udiff-line-modified-removed">-     // } else if (Atomic::cmpxchg(displaced_header, obj-&gt;mark_addr(), monitor) == monitor) {</span>
<span class="udiff-line-modified-added">+     // } else if (Atomic::cmpxchg(obj-&gt;mark_addr(), monitor, displaced_header) == monitor) {</span>
      //   // We swapped the unlocked mark in displaced_header into the object&#39;s mark word.
      //   monitor-&gt;set_obj(NULL);
  
      // If we still have a lightweight lock, unlock the object and be done.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2249,18 +2252,10 @@</span>
      cmpdi(CCR0, R0, frame::abi_reg_args_size + frame::ijava_state_size);
      bge(CCR0, Lok);
      stop(&quot;frame too small (restore istate)&quot;, 0x5432);
      bind(Lok);
    }
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     Label Lok;</span>
<span class="udiff-line-removed">-     ld(R0, _ijava_state_neg(ijava_reserved), scratch);</span>
<span class="udiff-line-removed">-     cmpdi(CCR0, R0, 0x5afe);</span>
<span class="udiff-line-removed">-     beq(CCR0, Lok);</span>
<span class="udiff-line-removed">-     stop(&quot;frame corrupted (restore istate)&quot;, 0x5afe);</span>
<span class="udiff-line-removed">-     bind(Lok);</span>
<span class="udiff-line-removed">-   }</span>
  #endif
  }
  
  void InterpreterMacroAssembler::get_method_counters(Register method,
                                                      Register Rcounters,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2269,11 +2264,11 @@</span>
    Label has_counters;
    ld(Rcounters, in_bytes(Method::method_counters_offset()), method);
    cmpdi(CCR0, Rcounters, 0);
    bne(CCR0, has_counters);
    call_VM(noreg, CAST_FROM_FN_PTR(address,
<span class="udiff-line-modified-removed">-                                   InterpreterRuntime::build_method_counters), method, false);</span>
<span class="udiff-line-modified-added">+                                   InterpreterRuntime::build_method_counters), method);</span>
    ld(Rcounters, in_bytes(Method::method_counters_offset()), method);
    cmpdi(CCR0, Rcounters, 0);
    beq(CCR0, skip); // No MethodCounters, OutOfMemory.
    BLOCK_COMMENT(&quot;} Load and ev. allocate counter object&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2317,11 +2312,11 @@</span>
    // register iv_be_count!
    BLOCK_COMMENT(&quot;} Increment profiling counters&quot;);
  }
  
  void InterpreterMacroAssembler::verify_oop(Register reg, TosState state) {
<span class="udiff-line-modified-removed">-   if (state == atos) { MacroAssembler::verify_oop(reg); }</span>
<span class="udiff-line-modified-added">+   if (state == atos) { MacroAssembler::verify_oop(reg, FILE_AND_LINE); }</span>
  }
  
  // Local helper function for the verify_oop_or_return_address macro.
  static bool verify_return_address(Method* m, int bci) {
  #ifndef PRODUCT
</pre>
<center><a href="interp_masm_ppc.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRT_ppc.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
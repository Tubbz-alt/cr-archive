<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/frame_ppc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2012, 2015 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_PPC_FRAME_PPC_HPP
 27 #define CPU_PPC_FRAME_PPC_HPP
 28 
 29 #include &quot;runtime/synchronizer.hpp&quot;
 30 
 31   //  C frame layout on PPC-64.
 32   //
 33   //  In this figure the stack grows upwards, while memory grows
 34   //  downwards. See &quot;64-bit PowerPC ELF ABI Supplement Version 1.7&quot;,
 35   //  IBM Corp. (2003-10-29)
 36   //  (http://math-atlas.sourceforge.net/devel/assembly/PPC-elf64abi-1.7.pdf).
 37   //
 38   //  Square brackets denote stack regions possibly larger
 39   //  than a single 64 bit slot.
 40   //
 41   //  STACK:
 42   //    0       [C_FRAME]               &lt;-- SP after prolog (mod 16 = 0)
 43   //            [C_FRAME]               &lt;-- SP before prolog
 44   //            ...
 45   //            [C_FRAME]
 46   //
 47   //  C_FRAME:
 48   //    0       [ABI_REG_ARGS]
 49   //    112     CARG_9: outgoing arg 9 (arg_1 ... arg_8 via gpr_3 ... gpr_{10})
 50   //            ...
 51   //    40+M*8  CARG_M: outgoing arg M (M is the maximum of outgoing args taken over all call sites in the procedure)
 52   //            local 1
 53   //            ...
 54   //            local N
 55   //            spill slot for vector reg (16 bytes aligned)
 56   //            ...
 57   //            spill slot for vector reg
 58   //            alignment       (4 or 12 bytes)
 59   //    V       SR_VRSAVE
 60   //    V+4     spill slot for GR
 61   //    ...     ...
 62   //            spill slot for GR
 63   //            spill slot for FR
 64   //            ...
 65   //            spill slot for FR
 66   //
 67   //  ABI_48:
 68   //    0       caller&#39;s SP
 69   //    8       space for condition register (CR) for next call
 70   //    16      space for link register (LR) for next call
 71   //    24      reserved
 72   //    32      reserved
 73   //    40      space for TOC (=R2) register for next call
 74   //
 75   //  ABI_REG_ARGS:
 76   //    0       [ABI_48]
 77   //    48      CARG_1: spill slot for outgoing arg 1. used by next callee.
 78   //    ...     ...
 79   //    104     CARG_8: spill slot for outgoing arg 8. used by next callee.
 80   //
 81 
 82  public:
 83 
 84   // C frame layout
 85   static const int alignment_in_bytes = 16;
 86 
 87   // ABI_MINFRAME:
 88   struct abi_minframe {
 89     uint64_t callers_sp;
 90     uint64_t cr;                                  //_16
 91     uint64_t lr;
 92 #if !defined(ABI_ELFv2)
 93     uint64_t reserved1;                           //_16
 94     uint64_t reserved2;
 95 #endif
 96     uint64_t toc;                                 //_16
 97     // nothing to add here!
 98     // aligned to frame::alignment_in_bytes (16)
 99   };
100 
101   enum {
102     abi_minframe_size = sizeof(abi_minframe)
103   };
104 
105   struct abi_reg_args : abi_minframe {
106     uint64_t carg_1;
107     uint64_t carg_2;                              //_16
108     uint64_t carg_3;
109     uint64_t carg_4;                              //_16
110     uint64_t carg_5;
111     uint64_t carg_6;                              //_16
112     uint64_t carg_7;
113     uint64_t carg_8;                              //_16
114     // aligned to frame::alignment_in_bytes (16)
115   };
116 
117   enum {
118     abi_reg_args_size = sizeof(abi_reg_args)
119   };
120 
121   #define _abi(_component) \
122           (offset_of(frame::abi_reg_args, _component))
123 
124   struct abi_reg_args_spill : abi_reg_args {
125     // additional spill slots
126     uint64_t spill_ret;
127     uint64_t spill_fret;                          //_16
128     // aligned to frame::alignment_in_bytes (16)
129   };
130 
131   enum {
132     abi_reg_args_spill_size = sizeof(abi_reg_args_spill)
133   };
134 
135   #define _abi_reg_args_spill(_component) \
136           (offset_of(frame::abi_reg_args_spill, _component))
137 
138   // non-volatile GPRs:
139 
140   struct spill_nonvolatiles {
141     uint64_t r14;
142     uint64_t r15;                                 //_16
143     uint64_t r16;
144     uint64_t r17;                                 //_16
145     uint64_t r18;
146     uint64_t r19;                                 //_16
147     uint64_t r20;
148     uint64_t r21;                                 //_16
149     uint64_t r22;
150     uint64_t r23;                                 //_16
151     uint64_t r24;
152     uint64_t r25;                                 //_16
153     uint64_t r26;
154     uint64_t r27;                                 //_16
155     uint64_t r28;
156     uint64_t r29;                                 //_16
157     uint64_t r30;
158     uint64_t r31;                                 //_16
159 
160     double f14;
161     double f15;
162     double f16;
163     double f17;
164     double f18;
165     double f19;
166     double f20;
167     double f21;
168     double f22;
169     double f23;
170     double f24;
171     double f25;
172     double f26;
173     double f27;
174     double f28;
175     double f29;
176     double f30;
177     double f31;
178 
179     // aligned to frame::alignment_in_bytes (16)
180   };
181 
182   enum {
183     spill_nonvolatiles_size = sizeof(spill_nonvolatiles)
184   };
185 
186   #define _spill_nonvolatiles_neg(_component) \
187      (int)(-frame::spill_nonvolatiles_size + offset_of(frame::spill_nonvolatiles, _component))
188 
189   // Frame layout for the Java template interpreter on PPC64.
190   //
191   // In these figures the stack grows upwards, while memory grows
192   // downwards. Square brackets denote regions possibly larger than
193   // single 64 bit slots.
194   //
195   //  STACK (interpreter is active):
196   //    0       [TOP_IJAVA_FRAME]
197   //            [PARENT_IJAVA_FRAME]
198   //            ...
199   //            [PARENT_IJAVA_FRAME]
200   //            [ENTRY_FRAME]
201   //            [C_FRAME]
202   //            ...
203   //            [C_FRAME]
204   //
205   //  With the following frame layouts:
206   //  TOP_IJAVA_FRAME:
207   //    0       [TOP_IJAVA_FRAME_ABI]
208   //            alignment (optional)
209   //            [operand stack]
210   //            [monitors] (optional)
211   //            [IJAVA_STATE]
212   //            note: own locals are located in the caller frame.
213   //
214   //  PARENT_IJAVA_FRAME:
215   //    0       [PARENT_IJAVA_FRAME_ABI]
216   //            alignment (optional)
217   //            [callee&#39;s Java result]
218   //            [callee&#39;s locals w/o arguments]
219   //            [outgoing arguments]
220   //            [used part of operand stack w/o arguments]
221   //            [monitors] (optional)
222   //            [IJAVA_STATE]
223   //
224   //  ENTRY_FRAME:
225   //    0       [PARENT_IJAVA_FRAME_ABI]
226   //            alignment (optional)
227   //            [callee&#39;s Java result]
228   //            [callee&#39;s locals w/o arguments]
229   //            [outgoing arguments]
230   //            [ENTRY_FRAME_LOCALS]
231 
232   struct parent_ijava_frame_abi : abi_minframe {
233   };
234 
235   enum {
236     parent_ijava_frame_abi_size = sizeof(parent_ijava_frame_abi)
237   };
238 
239 #define _parent_ijava_frame_abi(_component) \
240         (offset_of(frame::parent_ijava_frame_abi, _component))
241 
242   struct top_ijava_frame_abi : abi_reg_args {
243   };
244 
245   enum {
246     top_ijava_frame_abi_size = sizeof(top_ijava_frame_abi)
247   };
248 
249 #define _top_ijava_frame_abi(_component) \
250         (offset_of(frame::top_ijava_frame_abi, _component))
251 
252   struct ijava_state {
<a name="1" id="anc1"></a><span class="line-removed">253 #ifdef ASSERT</span>
<span class="line-removed">254     uint64_t ijava_reserved; // Used for assertion.</span>
<span class="line-removed">255 #endif</span>
256     uint64_t method;
257     uint64_t mirror;
258     uint64_t locals;
259     uint64_t monitors;
260     uint64_t cpoolCache;
261     uint64_t bcp;
262     uint64_t esp;
263     uint64_t mdx;
264     uint64_t top_frame_sp; // Maybe define parent_frame_abi and move there.
265     uint64_t sender_sp;
266     // Slots only needed for native calls. Maybe better to move elsewhere.
267     uint64_t oop_tmp;
268     uint64_t lresult;
269     uint64_t fresult;
270   };
271 
272   enum {
273     ijava_state_size = sizeof(ijava_state)
274   };
275 
276 #define _ijava_state_neg(_component) \
277         (int) (-frame::ijava_state_size + offset_of(frame::ijava_state, _component))
278 
279   // ENTRY_FRAME
280 
281   struct entry_frame_locals {
282     uint64_t call_wrapper_address;
283     uint64_t result_address;                      //_16
284     uint64_t result_type;
285     uint64_t arguments_tos_address;               //_16
286     // aligned to frame::alignment_in_bytes (16)
287     uint64_t r[spill_nonvolatiles_size/sizeof(uint64_t)];
288   };
289 
290   enum {
291     entry_frame_locals_size = sizeof(entry_frame_locals)
292   };
293 
294   #define _entry_frame_locals_neg(_component) \
295     (int)(-frame::entry_frame_locals_size + offset_of(frame::entry_frame_locals, _component))
296 
297 
298   //  Frame layout for JIT generated methods
299   //
300   //  In these figures the stack grows upwards, while memory grows
301   //  downwards. Square brackets denote regions possibly larger than single
302   //  64 bit slots.
303   //
304   //  STACK (interpreted Java calls JIT generated Java):
305   //          [JIT_FRAME]                                &lt;-- SP (mod 16 = 0)
306   //          [TOP_IJAVA_FRAME]
307   //         ...
308   //
309   //  JIT_FRAME (is a C frame according to PPC-64 ABI):
310   //          [out_preserve]
311   //          [out_args]
312   //          [spills]
313   //          [pad_1]
314   //          [monitor] (optional)
315   //       ...
316   //          [monitor] (optional)
317   //          [pad_2]
318   //          [in_preserve] added / removed by prolog / epilog
319   //
320 
321   // JIT_ABI (TOP and PARENT)
322 
323   struct jit_abi {
324     uint64_t callers_sp;
325     uint64_t cr;
326     uint64_t lr;
327     uint64_t toc;
328     // Nothing to add here!
329     // NOT ALIGNED to frame::alignment_in_bytes (16).
330   };
331 
332   struct jit_out_preserve : jit_abi {
333     // Nothing to add here!
334   };
335 
336   struct jit_in_preserve {
337     // Nothing to add here!
338   };
339 
340   enum {
341     jit_out_preserve_size = sizeof(jit_out_preserve),
342     jit_in_preserve_size  = sizeof(jit_in_preserve)
343   };
344 
345   struct jit_monitor {
346     uint64_t monitor[1];
347   };
348 
349   enum {
350     jit_monitor_size = sizeof(jit_monitor),
351   };
352 
353  private:
354 
355   //  STACK:
356   //            ...
357   //            [THIS_FRAME]             &lt;-- this._sp (stack pointer for this frame)
358   //            [CALLER_FRAME]           &lt;-- this.fp() (_sp of caller&#39;s frame)
359   //            ...
360   //
361 
362   // The frame&#39;s stack pointer before it has been extended by a c2i adapter;
363   // needed by deoptimization
364   intptr_t* _unextended_sp;
365 
366   // frame pointer for this frame
367   intptr_t* _fp;
368 
369  public:
370 
371   // Accessors for fields
372   intptr_t* fp() const { return _fp; }
373 
374   // Accessors for ABIs
375   inline abi_minframe* own_abi()     const { return (abi_minframe*) _sp; }
376   inline abi_minframe* callers_abi() const { return (abi_minframe*) _fp; }
377 
378  private:
379 
380   // Find codeblob and set deopt_state.
381   inline void find_codeblob_and_set_pc_and_deopt_state(address pc);
382 
383  public:
384 
385   // Constructors
386   inline frame(intptr_t* sp);
387   inline frame(intptr_t* sp, address pc);
388   inline frame(intptr_t* sp, address pc, intptr_t* unextended_sp);
389 
390  private:
391 
392   intptr_t* compiled_sender_sp(CodeBlob* cb) const;
393   address*  compiled_sender_pc_addr(CodeBlob* cb) const;
394   address*  sender_pc_addr(void) const;
395 
396  public:
397 
398   inline ijava_state* get_ijava_state() const;
399   // Some convenient register frame setters/getters for deoptimization.
400   inline intptr_t* interpreter_frame_esp() const;
401   inline void interpreter_frame_set_cpcache(ConstantPoolCache* cp);
402   inline void interpreter_frame_set_esp(intptr_t* esp);
403   inline void interpreter_frame_set_top_frame_sp(intptr_t* top_frame_sp);
404   inline void interpreter_frame_set_sender_sp(intptr_t* sender_sp);
405 
406   // Size of a monitor in bytes.
407   static int interpreter_frame_monitor_size_in_bytes();
408 
409   // The size of a cInterpreter object.
410   static inline int interpreter_frame_cinterpreterstate_size_in_bytes();
411 
<a name="2" id="anc2"></a><span class="line-removed">412  private:</span>
<span class="line-removed">413 </span>
<span class="line-removed">414   ConstantPoolCache** interpreter_frame_cpoolcache_addr() const;</span>
<span class="line-removed">415 </span>
<span class="line-removed">416  public:</span>
<span class="line-removed">417 </span>
418   // Additional interface for entry frames:
419   inline entry_frame_locals* get_entry_frame_locals() const {
420     return (entry_frame_locals*) (((address) fp()) - entry_frame_locals_size);
421   }
422 
423   enum {
424     // normal return address is 1 bundle past PC
425     pc_return_offset = 0
426   };
427 
428   static jint interpreter_frame_expression_stack_direction() { return -1; }
429 
430 #endif // CPU_PPC_FRAME_PPC_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/methodHandles_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2012, 2017 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;jvm.h&quot;
 28 #include &quot;asm/macroAssembler.inline.hpp&quot;
 29 #include &quot;classfile/javaClasses.inline.hpp&quot;
 30 #include &quot;interpreter/interpreter.hpp&quot;
 31 #include &quot;memory/allocation.inline.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;
 33 #include &quot;prims/methodHandles.hpp&quot;
 34 #include &quot;runtime/frame.inline.hpp&quot;
 35 #include &quot;utilities/preserveException.hpp&quot;
 36 
 37 #define __ _masm-&gt;
 38 
 39 #ifdef PRODUCT
 40 #define BLOCK_COMMENT(str) // nothing
 41 #else
 42 #define BLOCK_COMMENT(str) __ block_comment(str)
 43 #endif
 44 
 45 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
 46 
 47 // Workaround for C++ overloading nastiness on &#39;0&#39; for RegisterOrConstant.
 48 inline static RegisterOrConstant constant(int value) {
 49   return RegisterOrConstant(value);
 50 }
 51 
 52 void MethodHandles::load_klass_from_Class(MacroAssembler* _masm, Register klass_reg,
 53                                           Register temp_reg, Register temp2_reg) {
 54   if (VerifyMethodHandles) {
 55     verify_klass(_masm, klass_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),
 56                  temp_reg, temp2_reg, &quot;MH argument is a Class&quot;);
 57   }
 58   __ ld(klass_reg, java_lang_Class::klass_offset_in_bytes(), klass_reg);
 59 }
 60 
 61 #ifdef ASSERT
 62 static int check_nonzero(const char* xname, int x) {
 63   assert(x != 0, &quot;%s should be nonzero&quot;, xname);
 64   return x;
 65 }
 66 #define NONZERO(x) check_nonzero(#x, x)
 67 #else //ASSERT
 68 #define NONZERO(x) (x)
 69 #endif //ASSERT
 70 
 71 #ifdef ASSERT
 72 void MethodHandles::verify_klass(MacroAssembler* _masm,
 73                                  Register obj_reg, SystemDictionary::WKID klass_id,
 74                                  Register temp_reg, Register temp2_reg,
 75                                  const char* error_message) {
 76   InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);
 77   Klass* klass = SystemDictionary::well_known_klass(klass_id);
 78   Label L_ok, L_bad;
 79   BLOCK_COMMENT(&quot;verify_klass {&quot;);
<a name="1" id="anc1"></a><span class="line-modified"> 80   __ verify_oop(obj_reg, FILE_AND_LINE);</span>
 81   __ cmpdi(CCR0, obj_reg, 0);
 82   __ beq(CCR0, L_bad);
 83   __ load_klass(temp_reg, obj_reg);
 84   __ load_const_optimized(temp2_reg, (address) klass_addr);
 85   __ ld(temp2_reg, 0, temp2_reg);
 86   __ cmpd(CCR0, temp_reg, temp2_reg);
 87   __ beq(CCR0, L_ok);
 88   __ ld(temp_reg, klass-&gt;super_check_offset(), temp_reg);
 89   __ cmpd(CCR0, temp_reg, temp2_reg);
 90   __ beq(CCR0, L_ok);
 91   __ BIND(L_bad);
 92   __ stop(error_message);
 93   __ BIND(L_ok);
 94   BLOCK_COMMENT(&quot;} verify_klass&quot;);
 95 }
 96 
 97 void MethodHandles::verify_ref_kind(MacroAssembler* _masm, int ref_kind, Register member_reg, Register temp) {
 98   Label L;
 99   BLOCK_COMMENT(&quot;verify_ref_kind {&quot;);
100   __ load_sized_value(temp, NONZERO(java_lang_invoke_MemberName::flags_offset_in_bytes()), member_reg,
101                       sizeof(u4), /*is_signed*/ false);
102   // assert(sizeof(u4) == sizeof(java.lang.invoke.MemberName.flags), &quot;&quot;);
103   __ srwi( temp, temp, java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT);
104   __ andi(temp, temp, java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK);
105   __ cmpwi(CCR1, temp, ref_kind);
106   __ beq(CCR1, L);
107   { char* buf = NEW_C_HEAP_ARRAY(char, 100, mtInternal);
108     jio_snprintf(buf, 100, &quot;verify_ref_kind expected %x&quot;, ref_kind);
109     if (ref_kind == JVM_REF_invokeVirtual ||
110         ref_kind == JVM_REF_invokeSpecial)
111       // could do this for all ref_kinds, but would explode assembly code size
112       trace_method_handle(_masm, buf);
113     __ stop(buf);
114   }
115   BLOCK_COMMENT(&quot;} verify_ref_kind&quot;);
116   __ BIND(L);
117 }
118 
119 #endif // ASSERT
120 
121 void MethodHandles::jump_from_method_handle(MacroAssembler* _masm, Register method, Register target, Register temp,
122                                             bool for_compiler_entry) {
123   Label L_no_such_method;
124   assert(method == R19_method, &quot;interpreter calling convention&quot;);
125   assert_different_registers(method, target, temp);
126 
127   if (!for_compiler_entry &amp;&amp; JvmtiExport::can_post_interpreter_events()) {
128     Label run_compiled_code;
129     // JVMTI events, such as single-stepping, are implemented partly by avoiding running
130     // compiled code in threads for which the event is enabled.  Check here for
131     // interp_only_mode if these events CAN be enabled.
132     __ verify_thread();
133     __ lwz(temp, in_bytes(JavaThread::interp_only_mode_offset()), R16_thread);
134     __ cmplwi(CCR0, temp, 0);
135     __ beq(CCR0, run_compiled_code);
136     // Null method test is replicated below in compiled case,
137     // it might be able to address across the verify_thread()
138     __ cmplwi(CCR0, R19_method, 0);
139     __ beq(CCR0, L_no_such_method);
140     __ ld(target, in_bytes(Method::interpreter_entry_offset()), R19_method);
141     __ mtctr(target);
142     __ bctr();
143     __ BIND(run_compiled_code);
144   }
145 
146   // Compiled case, either static or fall-through from runtime conditional
147   __ cmplwi(CCR0, R19_method, 0);
148   __ beq(CCR0, L_no_such_method);
149 
150   const ByteSize entry_offset = for_compiler_entry ? Method::from_compiled_offset() :
151                                                      Method::from_interpreted_offset();
152   __ ld(target, in_bytes(entry_offset), R19_method);
153   __ mtctr(target);
154   __ bctr();
155 
156   __ bind(L_no_such_method);
157   assert(StubRoutines::throw_AbstractMethodError_entry() != NULL, &quot;not yet generated!&quot;);
158   __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());
159   __ mtctr(target);
160   __ bctr();
161 }
162 
163 
164 void MethodHandles::jump_to_lambda_form(MacroAssembler* _masm,
165                                         Register recv, Register method_temp,
166                                         Register temp2, Register temp3,
167                                         bool for_compiler_entry) {
168   BLOCK_COMMENT(&quot;jump_to_lambda_form {&quot;);
169   // This is the initial entry point of a lazy method handle.
170   // After type checking, it picks up the invoker from the LambdaForm.
171   assert_different_registers(recv, method_temp, temp2);  // temp3 is only passed on
172   assert(method_temp == R19_method, &quot;required register for loading method&quot;);
173 
174   // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
<a name="2" id="anc2"></a><span class="line-modified">175   __ verify_oop(recv, FILE_AND_LINE);</span>
176   __ load_heap_oop(method_temp, NONZERO(java_lang_invoke_MethodHandle::form_offset_in_bytes()), recv,
177                    temp2, noreg, false, IS_NOT_NULL);
<a name="3" id="anc3"></a><span class="line-modified">178   __ verify_oop(method_temp, FILE_AND_LINE);</span>
179   __ load_heap_oop(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset_in_bytes()), method_temp,
180                    temp2, noreg, false, IS_NOT_NULL);
<a name="4" id="anc4"></a><span class="line-modified">181   __ verify_oop(method_temp, FILE_AND_LINE);</span>
182   __ load_heap_oop(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()), method_temp,
183                    temp2, noreg, false, IS_NOT_NULL);
<a name="5" id="anc5"></a><span class="line-modified">184   __ verify_oop(method_temp, FILE_AND_LINE);</span>
185   __ ld(method_temp, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()), method_temp);
186 
187   if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
188     // Make sure recv is already on stack.
189     __ ld(temp2, in_bytes(Method::const_offset()), method_temp);
190     __ load_sized_value(temp2, in_bytes(ConstMethod::size_of_parameters_offset()), temp2,
191                         sizeof(u2), /*is_signed*/ false);
192     // assert(sizeof(u2) == sizeof(ConstMethod::_size_of_parameters), &quot;&quot;);
193     Label L;
194     __ ld(temp2, __ argument_offset(temp2, temp2, 0), R15_esp);
195     __ cmpd(CCR1, temp2, recv);
196     __ beq(CCR1, L);
197     __ stop(&quot;receiver not on stack&quot;);
198     __ BIND(L);
199   }
200 
201   jump_from_method_handle(_masm, method_temp, temp2, temp3, for_compiler_entry);
202   BLOCK_COMMENT(&quot;} jump_to_lambda_form&quot;);
203 }
204 
205 
206 
207 // Code generation
208 address MethodHandles::generate_method_handle_interpreter_entry(MacroAssembler* _masm,
209                                                                 vmIntrinsics::ID iid) {
210   const bool not_for_compiler_entry = false;  // this is the interpreter entry
211   assert(is_signature_polymorphic(iid), &quot;expected invoke iid&quot;);
212   if (iid == vmIntrinsics::_invokeGeneric ||
213       iid == vmIntrinsics::_compiledLambdaForm) {
214     // Perhaps surprisingly, the symbolic references visible to Java are not directly used.
215     // They are linked to Java-generated adapters via MethodHandleNatives.linkMethod.
216     // They all allow an appendix argument.
217     __ stop(&quot;Should not reach here&quot;);           // empty stubs make SG sick
218     return NULL;
219   }
220 
221   Register argbase    = R15_esp; // parameter (preserved)
222   Register argslot    = R3;
223   Register temp1      = R6;
224   Register param_size = R7;
225 
226   // here&#39;s where control starts out:
227   __ align(CodeEntryAlignment);
228   address entry_point = __ pc();
229 
230   if (VerifyMethodHandles) {
231     assert(Method::intrinsic_id_size_in_bytes() == 2, &quot;assuming Method::_intrinsic_id is u2&quot;);
232 
233     Label L;
234     BLOCK_COMMENT(&quot;verify_intrinsic_id {&quot;);
235     __ load_sized_value(temp1, Method::intrinsic_id_offset_in_bytes(), R19_method,
236                         sizeof(u2), /*is_signed*/ false);
237     __ cmpwi(CCR1, temp1, (int) iid);
238     __ beq(CCR1, L);
239     if (iid == vmIntrinsics::_linkToVirtual ||
240         iid == vmIntrinsics::_linkToSpecial) {
241       // could do this for all kinds, but would explode assembly code size
242       trace_method_handle(_masm, &quot;bad Method*:intrinsic_id&quot;);
243     }
244     __ stop(&quot;bad Method*::intrinsic_id&quot;);
245     __ BIND(L);
246     BLOCK_COMMENT(&quot;} verify_intrinsic_id&quot;);
247   }
248 
249   // First task:  Find out how big the argument list is.
250   int ref_kind = signature_polymorphic_intrinsic_ref_kind(iid);
251   assert(ref_kind != 0 || iid == vmIntrinsics::_invokeBasic, &quot;must be _invokeBasic or a linkTo intrinsic&quot;);
252   if (ref_kind == 0 || MethodHandles::ref_kind_has_receiver(ref_kind)) {
253     __ ld(param_size, in_bytes(Method::const_offset()), R19_method);
254     __ load_sized_value(param_size, in_bytes(ConstMethod::size_of_parameters_offset()), param_size,
255                         sizeof(u2), /*is_signed*/ false);
256     // assert(sizeof(u2) == sizeof(ConstMethod::_size_of_parameters), &quot;&quot;);
257   } else {
258     DEBUG_ONLY(param_size = noreg);
259   }
260 
261   Register tmp_mh = noreg;
262   if (!is_signature_polymorphic_static(iid)) {
263     __ ld(tmp_mh = temp1, __ argument_offset(param_size, param_size, 0), argbase);
264     DEBUG_ONLY(param_size = noreg);
265   }
266 
267   if (TraceMethodHandles) {
268     if (tmp_mh != noreg) {
269       __ mr(R23_method_handle, tmp_mh);  // make stub happy
270     }
271     trace_method_handle_interpreter_entry(_masm, iid);
272   }
273 
274   if (iid == vmIntrinsics::_invokeBasic) {
275     generate_method_handle_dispatch(_masm, iid, tmp_mh, noreg, not_for_compiler_entry);
276 
277   } else {
278     // Adjust argument list by popping the trailing MemberName argument.
279     Register tmp_recv = noreg;
280     if (MethodHandles::ref_kind_has_receiver(ref_kind)) {
281       // Load the receiver (not the MH; the actual MemberName&#39;s receiver) up from the interpreter stack.
282       __ ld(tmp_recv = temp1, __ argument_offset(param_size, param_size, 0), argbase);
283       DEBUG_ONLY(param_size = noreg);
284     }
285     Register R19_member = R19_method;  // MemberName ptr; incoming method ptr is dead now
286     __ ld(R19_member, RegisterOrConstant((intptr_t)8), argbase);
287     __ add(argbase, Interpreter::stackElementSize, argbase);
288     generate_method_handle_dispatch(_masm, iid, tmp_recv, R19_member, not_for_compiler_entry);
289   }
290 
291   return entry_point;
292 }
293 
294 void MethodHandles::generate_method_handle_dispatch(MacroAssembler* _masm,
295                                                     vmIntrinsics::ID iid,
296                                                     Register receiver_reg,
297                                                     Register member_reg,
298                                                     bool for_compiler_entry) {
299   assert(is_signature_polymorphic(iid), &quot;expected invoke iid&quot;);
300   Register temp1 = (for_compiler_entry ? R25_tmp5 : R7);
301   Register temp2 = (for_compiler_entry ? R22_tmp2 : R8);
302   Register temp3 = (for_compiler_entry ? R23_tmp3 : R9);
303   Register temp4 = (for_compiler_entry ? R24_tmp4 : R10);
304   if (receiver_reg != noreg)  assert_different_registers(temp1, temp2, temp3, temp4, receiver_reg);
305   if (member_reg   != noreg)  assert_different_registers(temp1, temp2, temp3, temp4, member_reg);
306 
307   if (iid == vmIntrinsics::_invokeBasic) {
308     // indirect through MH.form.vmentry.vmtarget
309     jump_to_lambda_form(_masm, receiver_reg, R19_method, temp1, temp2, for_compiler_entry);
310   } else {
311     // The method is a member invoker used by direct method handles.
312     if (VerifyMethodHandles) {
313       // make sure the trailing argument really is a MemberName (caller responsibility)
314       verify_klass(_masm, member_reg, SystemDictionary::WK_KLASS_ENUM_NAME(MemberName_klass),
315                    temp1, temp2,
316                    &quot;MemberName required for invokeVirtual etc.&quot;);
317     }
318 
319     Register temp1_recv_klass = temp1;
320     if (iid != vmIntrinsics::_linkToStatic) {
<a name="6" id="anc6"></a><span class="line-modified">321       __ verify_oop(receiver_reg, FILE_AND_LINE);</span>
322       if (iid == vmIntrinsics::_linkToSpecial) {
323         // Don&#39;t actually load the klass; just null-check the receiver.
324         __ null_check_throw(receiver_reg, -1, temp1,
325                             Interpreter::throw_NullPointerException_entry());
326       } else {
327         // load receiver klass itself
328         __ null_check_throw(receiver_reg, oopDesc::klass_offset_in_bytes(), temp1,
329                             Interpreter::throw_NullPointerException_entry());
330         __ load_klass(temp1_recv_klass, receiver_reg);
331         __ verify_klass_ptr(temp1_recv_klass);
332       }
333       BLOCK_COMMENT(&quot;check_receiver {&quot;);
334       // The receiver for the MemberName must be in receiver_reg.
335       // Check the receiver against the MemberName.clazz
336       if (VerifyMethodHandles &amp;&amp; iid == vmIntrinsics::_linkToSpecial) {
337         // Did not load it above...
338         __ load_klass(temp1_recv_klass, receiver_reg);
339         __ verify_klass_ptr(temp1_recv_klass);
340       }
341       if (VerifyMethodHandles &amp;&amp; iid != vmIntrinsics::_linkToInterface) {
342         Label L_ok;
343         Register temp2_defc = temp2;
344         __ load_heap_oop(temp2_defc, NONZERO(java_lang_invoke_MemberName::clazz_offset_in_bytes()), member_reg,
345                          temp3, noreg, false, IS_NOT_NULL);
346         load_klass_from_Class(_masm, temp2_defc, temp3, temp4);
347         __ verify_klass_ptr(temp2_defc);
348         __ check_klass_subtype(temp1_recv_klass, temp2_defc, temp3, temp4, L_ok);
349         // If we get here, the type check failed!
350         __ stop(&quot;receiver class disagrees with MemberName.clazz&quot;);
351         __ BIND(L_ok);
352       }
353       BLOCK_COMMENT(&quot;} check_receiver&quot;);
354     }
355     if (iid == vmIntrinsics::_linkToSpecial ||
356         iid == vmIntrinsics::_linkToStatic) {
357       DEBUG_ONLY(temp1_recv_klass = noreg);  // these guys didn&#39;t load the recv_klass
358     }
359 
360     // Live registers at this point:
361     //  member_reg - MemberName that was the trailing argument
362     //  temp1_recv_klass - klass of stacked receiver, if needed
363     //  O5_savedSP - interpreter linkage (if interpreted)
364     //  O0..O5 - compiler arguments (if compiled)
365 
366     Label L_incompatible_class_change_error;
367     switch (iid) {
368     case vmIntrinsics::_linkToSpecial:
369       if (VerifyMethodHandles) {
370         verify_ref_kind(_masm, JVM_REF_invokeSpecial, member_reg, temp2);
371       }
372       __ load_heap_oop(R19_method, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()), member_reg,
373                        temp3, noreg, false, IS_NOT_NULL);
374       __ ld(R19_method, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()), R19_method);
375       break;
376 
377     case vmIntrinsics::_linkToStatic:
378       if (VerifyMethodHandles) {
379         verify_ref_kind(_masm, JVM_REF_invokeStatic, member_reg, temp2);
380       }
381       __ load_heap_oop(R19_method, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()), member_reg,
382                        temp3, noreg, false, IS_NOT_NULL);
383       __ ld(R19_method, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()), R19_method);
384       break;
385 
386     case vmIntrinsics::_linkToVirtual:
387     {
388       // same as TemplateTable::invokevirtual,
389       // minus the CP setup and profiling:
390 
391       if (VerifyMethodHandles) {
392         verify_ref_kind(_masm, JVM_REF_invokeVirtual, member_reg, temp2);
393       }
394 
395       // pick out the vtable index from the MemberName, and then we can discard it:
396       Register temp2_index = temp2;
397       __ ld(temp2_index, NONZERO(java_lang_invoke_MemberName::vmindex_offset_in_bytes()), member_reg);
398 
399       if (VerifyMethodHandles) {
400         Label L_index_ok;
401         __ cmpdi(CCR1, temp2_index, 0);
402         __ bge(CCR1, L_index_ok);
403         __ stop(&quot;no virtual index&quot;);
404         __ BIND(L_index_ok);
405       }
406 
407       // Note:  The verifier invariants allow us to ignore MemberName.clazz and vmtarget
408       // at this point.  And VerifyMethodHandles has already checked clazz, if needed.
409 
410       // get target Method* &amp; entry point
411       __ lookup_virtual_method(temp1_recv_klass, temp2_index, R19_method);
412       break;
413     }
414 
415     case vmIntrinsics::_linkToInterface:
416     {
417       // same as TemplateTable::invokeinterface
418       // (minus the CP setup and profiling, with different argument motion)
419       if (VerifyMethodHandles) {
420         verify_ref_kind(_masm, JVM_REF_invokeInterface, member_reg, temp2);
421       }
422 
423       Register temp2_intf = temp2;
424       __ load_heap_oop(temp2_intf, NONZERO(java_lang_invoke_MemberName::clazz_offset_in_bytes()), member_reg,
425                        temp3, noreg, false, IS_NOT_NULL);
426       load_klass_from_Class(_masm, temp2_intf, temp3, temp4);
427       __ verify_klass_ptr(temp2_intf);
428 
429       Register vtable_index = R19_method;
430       __ ld(vtable_index, NONZERO(java_lang_invoke_MemberName::vmindex_offset_in_bytes()), member_reg);
431       if (VerifyMethodHandles) {
432         Label L_index_ok;
433         __ cmpdi(CCR1, vtable_index, 0);
434         __ bge(CCR1, L_index_ok);
435         __ stop(&quot;invalid vtable index for MH.invokeInterface&quot;);
436         __ BIND(L_index_ok);
437       }
438 
439       // given intf, index, and recv klass, dispatch to the implementation method
440       __ lookup_interface_method(temp1_recv_klass, temp2_intf,
441                                  // note: next two args must be the same:
442                                  vtable_index, R19_method,
443                                  temp3, temp4,
444                                  L_incompatible_class_change_error);
445       break;
446     }
447 
448     default:
449       fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
450       break;
451     }
452 
453     // Live at this point:
454     //   R19_method
455     //   O5_savedSP (if interpreted)
456 
457     // After figuring out which concrete method to call, jump into it.
458     // Note that this works in the interpreter with no data motion.
459     // But the compiled version will require that rcx_recv be shifted out.
460     __ verify_method_ptr(R19_method);
461     jump_from_method_handle(_masm, R19_method, temp1, temp2, for_compiler_entry);
462 
463     if (iid == vmIntrinsics::_linkToInterface) {
464       __ BIND(L_incompatible_class_change_error);
465       __ load_const_optimized(temp1, StubRoutines::throw_IncompatibleClassChangeError_entry());
466       __ mtctr(temp1);
467       __ bctr();
468     }
469   }
470 }
471 
472 #ifndef PRODUCT
473 void trace_method_handle_stub(const char* adaptername,
474                               oopDesc* mh,
475                               intptr_t* entry_sp,
476                               intptr_t* saved_regs) {
477 
478   bool has_mh = (strstr(adaptername, &quot;/static&quot;) == NULL &amp;&amp;
479                  strstr(adaptername, &quot;linkTo&quot;) == NULL);    // static linkers don&#39;t have MH
480   const char* mh_reg_name = has_mh ? &quot;R23_method_handle&quot; : &quot;G23&quot;;
481   tty-&gt;print_cr(&quot;MH %s %s=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT,
482                 adaptername, mh_reg_name, p2i(mh), p2i(entry_sp));
483 
484   if (Verbose) {
485     tty-&gt;print_cr(&quot;Registers:&quot;);
486     const int abi_offset = frame::abi_reg_args_size / 8;
487     for (int i = R3-&gt;encoding(); i &lt;= R12-&gt;encoding(); i++) {
488       Register r = as_Register(i);
489       int count = i - R3-&gt;encoding();
490       // The registers are stored in reverse order on the stack (by save_volatile_gprs(R1_SP, abi_reg_args_size)).
491       tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[abi_offset + count]);
492       if ((count + 1) % 4 == 0) {
493         tty-&gt;cr();
494       } else {
495         tty-&gt;print(&quot;, &quot;);
496       }
497     }
498     tty-&gt;cr();
499 
500     {
501       // dumping last frame with frame::describe
502 
503       JavaThread* p = JavaThread::active();
504 
505       ResourceMark rm;
506       PRESERVE_EXCEPTION_MARK; // may not be needed by safer and unexpensive here
507       FrameValues values;
508 
509       // Note: We want to allow trace_method_handle from any call site.
510       // While trace_method_handle creates a frame, it may be entered
511       // without a PC on the stack top (e.g. not just after a call).
512       // Walking that frame could lead to failures due to that invalid PC.
513       // =&gt; carefully detect that frame when doing the stack walking
514 
515       // Current C frame
516       frame cur_frame = os::current_frame();
517 
518       // Robust search of trace_calling_frame (independant of inlining).
519       assert(cur_frame.sp() &lt;= saved_regs, &quot;registers not saved on stack ?&quot;);
520       frame trace_calling_frame = os::get_sender_for_C_frame(&amp;cur_frame);
521       while (trace_calling_frame.fp() &lt; saved_regs) {
522         trace_calling_frame = os::get_sender_for_C_frame(&amp;trace_calling_frame);
523       }
524 
525       // Safely create a frame and call frame::describe.
526       intptr_t *dump_sp = trace_calling_frame.sender_sp();
527 
528       frame dump_frame = frame(dump_sp);
529       dump_frame.describe(values, 1);
530 
531       values.describe(-1, saved_regs, &quot;raw top of stack&quot;);
532 
533       tty-&gt;print_cr(&quot;Stack layout:&quot;);
534       values.print(p);
535     }
536 
537     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
538       mh-&gt;print();
539       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
540         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0)
541           java_lang_invoke_MethodHandle::form(mh)-&gt;print();
542       }
543     }
544   }
545 }
546 
547 void MethodHandles::trace_method_handle(MacroAssembler* _masm, const char* adaptername) {
548   if (!TraceMethodHandles) return;
549 
550   BLOCK_COMMENT(&quot;trace_method_handle {&quot;);
551 
552   const Register tmp = R11; // Will be preserved.
553   const int nbytes_save = MacroAssembler::num_volatile_regs * 8;
554   __ save_volatile_gprs(R1_SP, -nbytes_save); // except R0
555   __ save_LR_CR(tmp); // save in old frame
556 
557   __ mr(R5_ARG3, R1_SP);     // saved_sp
558   __ push_frame_reg_args(nbytes_save, tmp);
559 
560   __ load_const_optimized(R3_ARG1, (address)adaptername, tmp);
561   __ mr(R4_ARG2, R23_method_handle);
562   __ mr(R6_ARG4, R1_SP);
563   __ call_VM_leaf(CAST_FROM_FN_PTR(address, trace_method_handle_stub));
564 
565   __ pop_frame();
566   __ restore_LR_CR(tmp);
567   __ restore_volatile_gprs(R1_SP, -nbytes_save); // except R0
568 
569   BLOCK_COMMENT(&quot;} trace_method_handle&quot;);
570 }
571 #endif // PRODUCT
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
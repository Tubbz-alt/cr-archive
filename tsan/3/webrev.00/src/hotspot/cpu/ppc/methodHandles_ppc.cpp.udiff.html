<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/ppc/methodHandles_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_ppc.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_ppc.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/methodHandles_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -75,11 +75,11 @@</span>
                                   const char* error_message) {
    InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);
    Klass* klass = SystemDictionary::well_known_klass(klass_id);
    Label L_ok, L_bad;
    BLOCK_COMMENT(&quot;verify_klass {&quot;);
<span class="udiff-line-modified-removed">-   __ verify_oop(obj_reg);</span>
<span class="udiff-line-modified-added">+   __ verify_oop(obj_reg, FILE_AND_LINE);</span>
    __ cmpdi(CCR0, obj_reg, 0);
    __ beq(CCR0, L_bad);
    __ load_klass(temp_reg, obj_reg);
    __ load_const_optimized(temp2_reg, (address) klass_addr);
    __ ld(temp2_reg, 0, temp2_reg);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -170,20 +170,20 @@</span>
    // After type checking, it picks up the invoker from the LambdaForm.
    assert_different_registers(recv, method_temp, temp2);  // temp3 is only passed on
    assert(method_temp == R19_method, &quot;required register for loading method&quot;);
  
    // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
<span class="udiff-line-modified-removed">-   __ verify_oop(recv);</span>
<span class="udiff-line-modified-added">+   __ verify_oop(recv, FILE_AND_LINE);</span>
    __ load_heap_oop(method_temp, NONZERO(java_lang_invoke_MethodHandle::form_offset_in_bytes()), recv,
                     temp2, noreg, false, IS_NOT_NULL);
<span class="udiff-line-modified-removed">-   __ verify_oop(method_temp);</span>
<span class="udiff-line-modified-added">+   __ verify_oop(method_temp, FILE_AND_LINE);</span>
    __ load_heap_oop(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset_in_bytes()), method_temp,
                     temp2, noreg, false, IS_NOT_NULL);
<span class="udiff-line-modified-removed">-   __ verify_oop(method_temp);</span>
<span class="udiff-line-modified-added">+   __ verify_oop(method_temp, FILE_AND_LINE);</span>
    __ load_heap_oop(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()), method_temp,
                     temp2, noreg, false, IS_NOT_NULL);
<span class="udiff-line-modified-removed">-   __ verify_oop(method_temp);</span>
<span class="udiff-line-modified-added">+   __ verify_oop(method_temp, FILE_AND_LINE);</span>
    __ ld(method_temp, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()), method_temp);
  
    if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
      // Make sure recv is already on stack.
      __ ld(temp2, in_bytes(Method::const_offset()), method_temp);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -316,11 +316,11 @@</span>
                     &quot;MemberName required for invokeVirtual etc.&quot;);
      }
  
      Register temp1_recv_klass = temp1;
      if (iid != vmIntrinsics::_linkToStatic) {
<span class="udiff-line-modified-removed">-       __ verify_oop(receiver_reg);</span>
<span class="udiff-line-modified-added">+       __ verify_oop(receiver_reg, FILE_AND_LINE);</span>
        if (iid == vmIntrinsics::_linkToSpecial) {
          // Don&#39;t actually load the klass; just null-check the receiver.
          __ null_check_throw(receiver_reg, -1, temp1,
                              Interpreter::throw_NullPointerException_entry());
        } else {
</pre>
<center><a href="macroAssembler_ppc.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_ppc.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
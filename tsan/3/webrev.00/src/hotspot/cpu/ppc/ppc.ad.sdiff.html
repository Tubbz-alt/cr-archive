<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/ppc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nativeInst_ppc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="relocInfo_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/ppc.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">    3 // Copyright (c) 2012, 2018 SAP SE. All rights reserved.</span>
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
</pre>
<hr />
<pre>
  955   int_def MEMORY_REF_COST_LOW     (    200, DEFAULT_COST * 2);
  956   int_def MEMORY_REF_COST         (    300, DEFAULT_COST * 3);
  957 
  958   // Branches are even more expensive.
  959   int_def BRANCH_COST             (    900, DEFAULT_COST * 9);
  960   int_def CALL_COST               (   1300, DEFAULT_COST * 13);
  961 %}
  962 
  963 
  964 //----------SOURCE BLOCK-------------------------------------------------------
  965 // This is a block of C++ code which provides values, functions, and
  966 // definitions necessary in the rest of the architecture description.
  967 source_hpp %{
  968   // Header information of the source block.
  969   // Method declarations/definitions which are used outside
  970   // the ad-scope can conveniently be defined here.
  971   //
  972   // To keep related declarations/definitions/uses close together,
  973   // we switch between source %{ }% and source_hpp %{ }% freely as needed.
  974 


  975   // Returns true if Node n is followed by a MemBar node that
  976   // will do an acquire. If so, this node must not do the acquire
  977   // operation.
  978   bool followed_by_acquire(const Node *n);
  979 %}
  980 
  981 source %{
  982 
  983 // Should the Matcher clone shifts on addressing modes, expecting them
  984 // to be subsumed into complex addressing expressions or compute them
  985 // into registers?
  986 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
  987   return clone_base_plus_offset_address(m, mstack, address_visited);
  988 }
  989 
  990 void Compile::reshape_address(AddPNode* addp) {
  991 }
  992 
  993 // Optimize load-acquire.
  994 //
</pre>
<hr />
<pre>
 1383   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1384 
 1385   const bool method_is_frameless      = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1386 
 1387   const Register return_pc            = R20; // Must match return_addr() in frame section.
 1388   const Register callers_sp           = R21;
 1389   const Register push_frame_temp      = R22;
 1390   const Register toc_temp             = R23;
 1391   assert_different_registers(R11, return_pc, callers_sp, push_frame_temp, toc_temp);
 1392 
 1393   if (method_is_frameless) {
 1394     // Add nop at beginning of all frameless methods to prevent any
 1395     // oop instructions from getting overwritten by make_not_entrant
 1396     // (patching attempt would fail).
 1397     ___(nop) nop();
 1398   } else {
 1399     // Get return pc.
 1400     ___(mflr) mflr(return_pc);
 1401   }
 1402 


















 1403   // Calls to C2R adapters often do not accept exceptional returns.
 1404   // We require that their callers must bang for them. But be
 1405   // careful, because some VM calls (such as call site linkage) can
 1406   // use several kilobytes of stack. But the stack safety zone should
 1407   // account for that. See bugs 4446381, 4468289, 4497237.
 1408 
 1409   int bangsize = C-&gt;bang_size_in_bytes();
 1410   assert(bangsize &gt;= framesize || bangsize &lt;= 0, &quot;stack bang size incorrect&quot;);
 1411   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
 1412     // Unfortunately we cannot use the function provided in
 1413     // assembler.cpp as we have to emulate the pipes. So I had to
 1414     // insert the code of generate_stack_overflow_check(), see
 1415     // assembler.cpp for some illuminative comments.
 1416     const int page_size = os::vm_page_size();
 1417     int bang_end = JavaThread::stack_shadow_zone_size();
 1418 
 1419     // This is how far the previous frame&#39;s stack banging extended.
 1420     const int bang_end_safe = bang_end;
 1421 
 1422     if (bangsize &gt; page_size) {
</pre>
<hr />
<pre>
 2187   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 2188   __ end_a_stub();
 2189 
 2190   return offset;
 2191 }
 2192 
 2193 //=============================================================================
 2194 
 2195 // Use a frame slots bias for frameless methods if accessing the stack.
 2196 static int frame_slots_bias(int reg_enc, PhaseRegAlloc* ra_) {
 2197   if (as_Register(reg_enc) == R1_SP) {
 2198     return 0; // TODO: PPC port ra_-&gt;C-&gt;frame_slots_sp_bias_in_bytes();
 2199   }
 2200   return 0;
 2201 }
 2202 
 2203 const bool Matcher::match_rule_supported(int opcode) {
 2204   if (!has_match_rule(opcode))
 2205     return false;
 2206 

 2207   switch (opcode) {
 2208   case Op_SqrtD:
 2209     return VM_Version::has_fsqrt();
 2210   case Op_CountLeadingZerosI:
 2211   case Op_CountLeadingZerosL:
 2212     if (!UseCountLeadingZerosInstructionsPPC64)
 2213       return false;
 2214     break;
 2215   case Op_CountTrailingZerosI:
 2216   case Op_CountTrailingZerosL:
 2217     if (!UseCountLeadingZerosInstructionsPPC64 &amp;&amp;
 2218         !UseCountTrailingZerosInstructionsPPC64)
 2219       return false;
 2220     break;
 2221 
 2222   case Op_PopCountI:
 2223   case Op_PopCountL:
 2224     return (UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
 2225 
 2226   case Op_StrComp:
</pre>
<hr />
<pre>
 2237   case Op_AddVD:
 2238   case Op_SubVB:
 2239   case Op_SubVS:
 2240   case Op_SubVI:
 2241   case Op_SubVF:
 2242   case Op_SubVD:
 2243   case Op_MulVS:
 2244   case Op_MulVF:
 2245   case Op_MulVD:
 2246   case Op_DivVF:
 2247   case Op_DivVD:
 2248   case Op_AbsVF:
 2249   case Op_AbsVD:
 2250   case Op_NegVF:
 2251   case Op_NegVD:
 2252   case Op_SqrtVF:
 2253   case Op_SqrtVD:
 2254   case Op_AddVL:
 2255   case Op_SubVL:
 2256   case Op_MulVI:

 2257     return SuperwordUseVSX;
 2258   case Op_PopCountVI:
 2259     return (SuperwordUseVSX &amp;&amp; UsePopCountInstruction);
 2260   case Op_FmaVF:
 2261   case Op_FmaVD:
 2262     return (SuperwordUseVSX &amp;&amp; UseFMA);
 2263   case Op_Digit:
 2264   case Op_LowerCase:
 2265   case Op_UpperCase:
 2266   case Op_Whitespace:
 2267     return UseCharacterCompareIntrinsics;








 2268   }
 2269 
<span class="line-modified"> 2270   return true;  // Per default match rules are supported.</span>
 2271 }
 2272 
<span class="line-modified"> 2273 const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {</span>
 2274 
 2275   // TODO
 2276   // identify extra cases that we might want to provide match rules for
 2277   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 2278   bool ret_value = match_rule_supported(opcode);
 2279   // Add rules here.
 2280 
 2281   return ret_value;  // Per default match rules are supported.
 2282 }
 2283 
 2284 const bool Matcher::has_predicated_vectors(void) {
 2285   return false;
 2286 }
 2287 
 2288 const int Matcher::float_pressure(int default_pressure_threshold) {
 2289   return default_pressure_threshold;
 2290 }
 2291 
 2292 int Matcher::regnum_to_fpu_offset(int regnum) {
 2293   // No user for this method?
</pre>
<hr />
<pre>
 2361 // And `Compile::Shorten_branches&#39; will decide on basis of this
 2362 // information whether to replace particular branch sites by short
 2363 // ones.
 2364 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 2365   // Is the offset within the range of a ppc64 pc relative branch?
 2366   bool b;
 2367 
 2368   const int safety_zone = 3 * BytesPerInstWord;
 2369   b = Assembler::is_simm((offset&lt;0 ? offset-safety_zone : offset+safety_zone),
 2370                          29 - 16 + 1 + 2);
 2371   return b;
 2372 }
 2373 
 2374 const bool Matcher::isSimpleConstant64(jlong value) {
 2375   // Probably always true, even if a temp register is required.
 2376   return true;
 2377 }
 2378 /* TODO: PPC port
 2379 // Make a new machine dependent decode node (with its operands).
 2380 MachTypeNode *Matcher::make_decode_node() {
<span class="line-modified"> 2381   assert(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0,</span>
 2382          &quot;This method is only implemented for unscaled cOops mode so far&quot;);
 2383   MachTypeNode *decode = new decodeN_unscaledNode();
 2384   decode-&gt;set_opnd_array(0, new iRegPdstOper());
 2385   decode-&gt;set_opnd_array(1, new iRegNsrcOper());
 2386   return decode;
 2387 }
 2388 */
 2389 
 2390 // false =&gt; size gets scaled to BytesPerLong, ok.
 2391 const bool Matcher::init_array_count_is_in_bytes = false;
 2392 
 2393 // Use conditional move (CMOVL) on Power7.
 2394 const int Matcher::long_cmove_cost() { return 0; } // this only makes long cmoves more expensive than int cmoves
 2395 
 2396 // Suppress CMOVF. Conditional move available (sort of) on PPC64 only from P7 onwards. Not exploited yet.
 2397 // fsel doesn&#39;t accept a condition register as input, so this would be slightly different.
 2398 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 2399 
 2400 // Power6 requires postalloc expand (see block.cpp for description of postalloc expand).
 2401 const bool Matcher::require_postalloc_expand = true;
 2402 
 2403 // Do we need to mask the count passed to shift instructions or does
 2404 // the cpu only look at the lower 5/6 bits anyway?
 2405 // PowerPC requires masked shift counts.
 2406 const bool Matcher::need_masked_shift_count = true;
 2407 


















 2408 // This affects two different things:
 2409 //  - how Decode nodes are matched
 2410 //  - how ImplicitNullCheck opportunities are recognized
 2411 // If true, the matcher will try to remove all Decodes and match them
 2412 // (as operands) into nodes. NullChecks are not prepared to deal with
 2413 // Decodes by final_graph_reshaping().
 2414 // If false, final_graph_reshaping() forces the decode behind the Cmp
 2415 // for a NullCheck. The matcher matches the Decode node into a register.
 2416 // Implicit_null_check optimization moves the Decode along with the
 2417 // memory operation back up before the NullCheck.
 2418 bool Matcher::narrow_oop_use_complex_address() {
 2419   // TODO: PPC port if (MatchDecodeNodes) return true;
 2420   return false;
 2421 }
 2422 
 2423 bool Matcher::narrow_klass_use_complex_address() {
 2424   NOT_LP64(ShouldNotCallThis());
 2425   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 2426   // TODO: PPC port if (MatchDecodeNodes) return true;
 2427   return false;
 2428 }
 2429 
 2430 bool Matcher::const_oop_prefer_decode() {
 2431   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="line-modified"> 2432   return Universe::narrow_oop_base() == NULL;</span>
 2433 }
 2434 
 2435 bool Matcher::const_klass_prefer_decode() {
 2436   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified"> 2437   return Universe::narrow_klass_base() == NULL;</span>
 2438 }
 2439 
 2440 // Is it better to copy float constants, or load them directly from memory?
 2441 // Intel can load a float constant from a direct address, requiring no
 2442 // extra registers. Most RISCs will have to materialize an address into a
 2443 // register first, so they would do better to copy the constant from stack.
 2444 const bool Matcher::rematerialize_float_constants = false;
 2445 
 2446 // If CPU can load and store mis-aligned doubles directly then no fixup is
 2447 // needed. Else we split the double into 2 integer pieces and move it
 2448 // piece-by-piece. Only happens when passing doubles into C code as the
 2449 // Java calling convention forces doubles to be aligned.
 2450 const bool Matcher::misaligned_doubles_ok = true;
 2451 
 2452 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2453  Unimplemented();
 2454 }
 2455 
<span class="line-modified"> 2456 // Advertise here if the CPU requires explicit rounding operations</span>
<span class="line-removed"> 2457 // to implement the UseStrictFP mode.</span>
 2458 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2459 
 2460 // Do floats take an entire double register or just half?
 2461 //
 2462 // A float occupies a ppc64 double register. For the allocator, a
 2463 // ppc64 double register appears as a pair of float registers.
 2464 bool Matcher::float_in_double() { return true; }
 2465 
 2466 // Do ints take an entire long register or just half?
 2467 // The relevant question is how the int is callee-saved:
 2468 // the whole long is written but de-opt&#39;ing will have to extract
 2469 // the relevant 32 bits.
 2470 const bool Matcher::int_in_long = true;
 2471 
 2472 // Constants for c2c and c calling conventions.
 2473 
 2474 const MachRegisterNumbers iarg_reg[8] = {
 2475   R3_num, R4_num, R5_num, R6_num,
 2476   R7_num, R8_num, R9_num, R10_num
 2477 };
</pre>
<hr />
<pre>
 4134   // Body of function which returns an integer array locating
 4135   // arguments either in registers or in stack slots. Passed an array
 4136   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 4137   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 4138   // arguments for a CALLEE. Incoming stack arguments are
 4139   // automatically biased by the preserve_stack_slots field above.
 4140   c_calling_convention %{
 4141     // This is obviously always outgoing.
 4142     // C argument in register AND stack slot.
 4143     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 4144   %}
 4145 
 4146   // Location of native (C/C++) and interpreter return values. This
 4147   // is specified to be the same as Java. In the 32-bit VM, long
 4148   // values are actually returned from native calls in O0:O1 and
 4149   // returned to the interpreter in I0:I1. The copying to and from
 4150   // the register pairs is done by the appropriate call and epilog
 4151   // opcodes. This simplifies the register allocator.
 4152   c_return_value %{
 4153     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
<span class="line-modified"> 4154             (ideal_reg == Op_RegN &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0),</span>
 4155             &quot;only return normal values&quot;);
 4156     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4157     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4158     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4159     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4160   %}
 4161 
 4162   // Location of compiled Java return values.  Same as C
 4163   return_value %{
 4164     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
<span class="line-modified"> 4165             (ideal_reg == Op_RegN &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0),</span>
 4166             &quot;only return normal values&quot;);
 4167     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4168     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4169     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4170     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4171   %}
 4172 %}
 4173 
 4174 
 4175 //----------ATTRIBUTES---------------------------------------------------------
 4176 
 4177 //----------Operand Attributes-------------------------------------------------
 4178 op_attrib op_cost(1);          // Required cost attribute.
 4179 
 4180 //----------Instruction Attributes---------------------------------------------
 4181 
 4182 // Cost attribute. required.
 4183 ins_attrib ins_cost(DEFAULT_COST);
 4184 
 4185 // Is this instruction a non-matching short branch variant of some
</pre>
<hr />
<pre>
 4286 
 4287 // Integer Immediate: 16-bit
 4288 operand immI16() %{
 4289   predicate(Assembler::is_simm(n-&gt;get_int(), 16));
 4290   op_cost(0);
 4291   match(ConI);
 4292   format %{ %}
 4293   interface(CONST_INTER);
 4294 %}
 4295 
 4296 // Integer Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4297 operand immIhi16() %{
 4298   predicate(((n-&gt;get_int() &amp; 0xffff0000) != 0) &amp;&amp; ((n-&gt;get_int() &amp; 0xffff) == 0));
 4299   match(ConI);
 4300   op_cost(0);
 4301   format %{ %}
 4302   interface(CONST_INTER);
 4303 %}
 4304 
 4305 operand immInegpow2() %{
<span class="line-modified"> 4306   predicate(is_power_of_2_long((jlong) (julong) (juint) (-(n-&gt;get_int()))));</span>
 4307   match(ConI);
 4308   op_cost(0);
 4309   format %{ %}
 4310   interface(CONST_INTER);
 4311 %}
 4312 
 4313 operand immIpow2minus1() %{
<span class="line-modified"> 4314   predicate(is_power_of_2_long((((jlong) (n-&gt;get_int()))+1)));</span>
 4315   match(ConI);
 4316   op_cost(0);
 4317   format %{ %}
 4318   interface(CONST_INTER);
 4319 %}
 4320 
 4321 operand immIpowerOf2() %{
<span class="line-modified"> 4322   predicate(is_power_of_2_long((((jlong) (julong) (juint) (n-&gt;get_int())))));</span>
 4323   match(ConI);
 4324   op_cost(0);
 4325   format %{ %}
 4326   interface(CONST_INTER);
 4327 %}
 4328 
 4329 // Unsigned Integer Immediate: the values 0-31
 4330 operand uimmI5() %{
 4331   predicate(Assembler::is_uimm(n-&gt;get_int(), 5));
 4332   match(ConI);
 4333   op_cost(0);
 4334   format %{ %}
 4335   interface(CONST_INTER);
 4336 %}
 4337 
 4338 // Unsigned Integer Immediate: 6-bit
 4339 operand uimmI6() %{
 4340   predicate(Assembler::is_uimm(n-&gt;get_int(), 6));
 4341   match(ConI);
 4342   op_cost(0);
</pre>
<hr />
<pre>
 4536 
 4537 // Long Immediate: 32-bit
 4538 operand immL32() %{
 4539   predicate(Assembler::is_simm(n-&gt;get_long(), 32));
 4540   match(ConL);
 4541   op_cost(0);
 4542   format %{ %}
 4543   interface(CONST_INTER);
 4544 %}
 4545 
 4546 // Long Immediate: 64-bit, where highest 16 bits are not 0x0000.
 4547 operand immLhighest16() %{
 4548   predicate((n-&gt;get_long() &amp; 0xffff000000000000L) != 0L &amp;&amp; (n-&gt;get_long() &amp; 0x0000ffffffffffffL) == 0L);
 4549   match(ConL);
 4550   op_cost(0);
 4551   format %{ %}
 4552   interface(CONST_INTER);
 4553 %}
 4554 
 4555 operand immLnegpow2() %{
<span class="line-modified"> 4556   predicate(is_power_of_2_long((jlong)-(n-&gt;get_long())));</span>
 4557   match(ConL);
 4558   op_cost(0);
 4559   format %{ %}
 4560   interface(CONST_INTER);
 4561 %}
 4562 
 4563 operand immLpow2minus1() %{
<span class="line-modified"> 4564   predicate(is_power_of_2_long((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;</span>
 4565             (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
 4566   match(ConL);
 4567   op_cost(0);
 4568   format %{ %}
 4569   interface(CONST_INTER);
 4570 %}
 4571 
 4572 // constant &#39;long 0&#39;.
 4573 operand immL_0() %{
 4574   predicate(n-&gt;get_long() == 0L);
 4575   match(ConL);
 4576   op_cost(0);
 4577   format %{ %}
 4578   interface(CONST_INTER);
 4579 %}
 4580 
 4581 // constat &#39; long -1&#39;.
 4582 operand immL_minus1() %{
 4583   predicate(n-&gt;get_long() == -1L);
 4584   match(ConL);
</pre>
<hr />
<pre>
 4614 %}
 4615 
 4616 // Float Immediate: +0.0f.
 4617 operand immF_0() %{
 4618   predicate(jint_cast(n-&gt;getf()) == 0);
 4619   match(ConF);
 4620 
 4621   op_cost(0);
 4622   format %{ %}
 4623   interface(CONST_INTER);
 4624 %}
 4625 
 4626 // Double Immediate
 4627 operand immD() %{
 4628   match(ConD);
 4629   op_cost(40);
 4630   format %{ %}
 4631   interface(CONST_INTER);
 4632 %}
 4633 










 4634 // Integer Register Operands
 4635 // Integer Destination Register
 4636 // See definition of reg_class bits32_reg_rw.
 4637 operand iRegIdst() %{
 4638   constraint(ALLOC_IN_RC(bits32_reg_rw));
 4639   match(RegI);
 4640   match(rscratch1RegI);
 4641   match(rscratch2RegI);
 4642   match(rarg1RegI);
 4643   match(rarg2RegI);
 4644   match(rarg3RegI);
 4645   match(rarg4RegI);
 4646   format %{ %}
 4647   interface(REG_INTER);
 4648 %}
 4649 
 4650 // Integer Source Register
 4651 // See definition of reg_class bits32_reg_ro.
 4652 operand iRegIsrc() %{
 4653   constraint(ALLOC_IN_RC(bits32_reg_ro));
</pre>
<hr />
<pre>
 4961   interface(REG_INTER);
 4962 %}
 4963 
 4964 operand compiler_method_oop_regP(iRegPdst reg) %{
 4965   constraint(ALLOC_IN_RC(rscratch1_bits64_reg)); // compiler_method_oop_reg
 4966   match(reg);
 4967   format %{ %}
 4968   interface(REG_INTER);
 4969 %}
 4970 
 4971 operand interpreter_method_oop_regP(iRegPdst reg) %{
 4972   constraint(ALLOC_IN_RC(r19_bits64_reg)); // interpreter_method_oop_reg
 4973   match(reg);
 4974   format %{ %}
 4975   interface(REG_INTER);
 4976 %}
 4977 
 4978 // Operands to remove register moves in unscaled mode.
 4979 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 4980 operand iRegP2N(iRegPsrc reg) %{
<span class="line-modified"> 4981   predicate(false /* TODO: PPC port MatchDecodeNodes*/&amp;&amp; Universe::narrow_oop_shift() == 0);</span>
 4982   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4983   match(EncodeP reg);
 4984   format %{ &quot;$reg&quot; %}
 4985   interface(REG_INTER)
 4986 %}
 4987 
 4988 operand iRegN2P(iRegNsrc reg) %{
 4989   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 4990   constraint(ALLOC_IN_RC(bits32_reg_ro));
 4991   match(DecodeN reg);
 4992   format %{ &quot;$reg&quot; %}
 4993   interface(REG_INTER)
 4994 %}
 4995 
 4996 operand iRegN2P_klass(iRegNsrc reg) %{
<span class="line-modified"> 4997   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);</span>
 4998   constraint(ALLOC_IN_RC(bits32_reg_ro));
 4999   match(DecodeNKlass reg);
 5000   format %{ &quot;$reg&quot; %}
 5001   interface(REG_INTER)
 5002 %}
 5003 
 5004 //----------Complex Operands---------------------------------------------------
 5005 // Indirect Memory Reference
 5006 operand indirect(iRegPsrc reg) %{
 5007   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5008   match(reg);
 5009   op_cost(100);
 5010   format %{ &quot;[$reg]&quot; %}
 5011   interface(MEMORY_INTER) %{
 5012     base($reg);
 5013     index(0x0);
 5014     scale(0x0);
 5015     disp(0x0);
 5016   %}
 5017 %}
</pre>
<hr />
<pre>
 5046 
 5047 //----------Complex Operands for Compressed OOPs-------------------------------
 5048 // Compressed OOPs with narrow_oop_shift == 0.
 5049 
 5050 // Indirect Memory Reference, compressed OOP
 5051 operand indirectNarrow(iRegNsrc reg) %{
 5052   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5053   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5054   match(DecodeN reg);
 5055   op_cost(100);
 5056   format %{ &quot;[$reg]&quot; %}
 5057   interface(MEMORY_INTER) %{
 5058     base($reg);
 5059     index(0x0);
 5060     scale(0x0);
 5061     disp(0x0);
 5062   %}
 5063 %}
 5064 
 5065 operand indirectNarrow_klass(iRegNsrc reg) %{
<span class="line-modified"> 5066   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);</span>
 5067   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5068   match(DecodeNKlass reg);
 5069   op_cost(100);
 5070   format %{ &quot;[$reg]&quot; %}
 5071   interface(MEMORY_INTER) %{
 5072     base($reg);
 5073     index(0x0);
 5074     scale(0x0);
 5075     disp(0x0);
 5076   %}
 5077 %}
 5078 
 5079 // Indirect with Offset, compressed OOP
 5080 operand indOffset16Narrow(iRegNsrc reg, immL16 offset) %{
 5081   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5082   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5083   match(AddP (DecodeN reg) offset);
 5084   op_cost(100);
 5085   format %{ &quot;[$reg + $offset]&quot; %}
 5086   interface(MEMORY_INTER) %{
 5087     base($reg);
 5088     index(0x0);
 5089     scale(0x0);
 5090     disp($offset);
 5091   %}
 5092 %}
 5093 
 5094 operand indOffset16Narrow_klass(iRegNsrc reg, immL16 offset) %{
<span class="line-modified"> 5095   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);</span>
 5096   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5097   match(AddP (DecodeNKlass reg) offset);
 5098   op_cost(100);
 5099   format %{ &quot;[$reg + $offset]&quot; %}
 5100   interface(MEMORY_INTER) %{
 5101     base($reg);
 5102     index(0x0);
 5103     scale(0x0);
 5104     disp($offset);
 5105   %}
 5106 %}
 5107 
 5108 // Indirect with 4-aligned Offset, compressed OOP
 5109 operand indOffset16NarrowAlg4(iRegNsrc reg, immL16Alg4 offset) %{
 5110   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5111   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5112   match(AddP (DecodeN reg) offset);
 5113   op_cost(100);
 5114   format %{ &quot;[$reg + $offset]&quot; %}
 5115   interface(MEMORY_INTER) %{
 5116     base($reg);
 5117     index(0x0);
 5118     scale(0x0);
 5119     disp($offset);
 5120   %}
 5121 %}
 5122 
 5123 operand indOffset16NarrowAlg4_klass(iRegNsrc reg, immL16Alg4 offset) %{
<span class="line-modified"> 5124   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);</span>
 5125   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5126   match(AddP (DecodeNKlass reg) offset);
 5127   op_cost(100);
 5128   format %{ &quot;[$reg + $offset]&quot; %}
 5129   interface(MEMORY_INTER) %{
 5130     base($reg);
 5131     index(0x0);
 5132     scale(0x0);
 5133     disp($offset);
 5134   %}
 5135 %}
 5136 
 5137 //----------Special Memory Operands--------------------------------------------
 5138 // Stack Slot Operand
 5139 //
 5140 // This operand is used for loading and storing temporary values on
 5141 // the stack where a match requires a value to flow through memory.
 5142 operand stackSlotI(sRegI reg) %{
 5143   constraint(ALLOC_IN_RC(stack_slots));
 5144   op_cost(100);
</pre>
<hr />
<pre>
 5833   ins_encode( enc_lwz(dst, mem) );
 5834   ins_pipe(pipe_class_memory);
 5835 %}
 5836 
 5837 // Load Compressed Pointer acquire.
 5838 instruct loadN_ac(iRegNdst dst, memory mem) %{
 5839   match(Set dst (LoadN mem));
 5840   ins_cost(3*MEMORY_REF_COST);
 5841 
 5842   format %{ &quot;LWZ     $dst, $mem \t// load acquire compressed ptr\n\t&quot;
 5843             &quot;TWI     $dst\n\t&quot;
 5844             &quot;ISYNC&quot; %}
 5845   size(12);
 5846   ins_encode( enc_lwz_ac(dst, mem) );
 5847   ins_pipe(pipe_class_memory);
 5848 %}
 5849 
 5850 // Load Compressed Pointer and decode it if narrow_oop_shift == 0.
 5851 instruct loadN2P_unscaled(iRegPdst dst, memory mem) %{
 5852   match(Set dst (DecodeN (LoadN mem)));
<span class="line-modified"> 5853   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() &amp;&amp; Universe::narrow_oop_shift() == 0);</span>
 5854   ins_cost(MEMORY_REF_COST);
 5855 
 5856   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5857   size(4);
 5858   ins_encode( enc_lwz(dst, mem) );
 5859   ins_pipe(pipe_class_memory);
 5860 %}
 5861 
 5862 instruct loadN2P_klass_unscaled(iRegPdst dst, memory mem) %{
 5863   match(Set dst (DecodeNKlass (LoadNKlass mem)));
<span class="line-modified"> 5864   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0 &amp;&amp;</span>
 5865             _kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5866   ins_cost(MEMORY_REF_COST);
 5867 
 5868   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5869   size(4);
 5870   ins_encode( enc_lwz(dst, mem) );
 5871   ins_pipe(pipe_class_memory);
 5872 %}
 5873 
 5874 // Load Pointer
 5875 instruct loadP(iRegPdst dst, memoryAlg4 mem) %{
 5876   match(Set dst (LoadP mem));
 5877   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5878   ins_cost(MEMORY_REF_COST);
 5879 
 5880   format %{ &quot;LD      $dst, $mem \t// ptr&quot; %}
 5881   size(4);
 5882   ins_encode( enc_ld(dst, mem) );
 5883   ins_pipe(pipe_class_memory);
 5884 %}
</pre>
<hr />
<pre>
 6310   effect(DEF dst, USE src);
 6311   predicate(false);
 6312 
 6313   format %{ &quot;MASK    $dst, $src, 0xFFFFFFFF&quot; %} // mask
 6314   size(4);
 6315   ins_encode %{
 6316     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6317     __ clrldi($dst$$Register, $src$$Register, 0x20);
 6318   %}
 6319   ins_pipe(pipe_class_default);
 6320 %}
 6321 
 6322 // Optimize DecodeN for disjoint base.
 6323 // Load base of compressed oops into a register
 6324 instruct loadBase(iRegLdst dst) %{
 6325   effect(DEF dst);
 6326 
 6327   format %{ &quot;LoadConst $dst, heapbase&quot; %}
 6328   ins_encode %{
 6329     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="line-modified"> 6330     __ load_const_optimized($dst$$Register, Universe::narrow_oop_base(), R0);</span>
 6331   %}
 6332   ins_pipe(pipe_class_default);
 6333 %}
 6334 
 6335 // Loading ConN must be postalloc expanded so that edges between
 6336 // the nodes are safe. They may not interfere with a safepoint.
 6337 // GL TODO: This needs three instructions: better put this into the constant pool.
 6338 instruct loadConN_Ex(iRegNdst dst, immN src) %{
 6339   match(Set dst src);
 6340   ins_cost(DEFAULT_COST*2);
 6341 
 6342   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6343   postalloc_expand %{
 6344     MachNode *m1 = new loadConN_hiNode();
 6345     MachNode *m2 = new loadConN_loNode();
 6346     MachNode *m3 = new clearMs32bNode();
 6347     m1-&gt;add_req(NULL);
 6348     m2-&gt;add_req(NULL, m1);
 6349     m3-&gt;add_req(NULL, m2);
 6350     m1-&gt;_opnds[0] = op_dst;
</pre>
<hr />
<pre>
 6358     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6359     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6360     nodes-&gt;push(m1);
 6361     nodes-&gt;push(m2);
 6362     nodes-&gt;push(m3);
 6363   %}
 6364 %}
 6365 
 6366 // We have seen a safepoint between the hi and lo parts, and this node was handled
 6367 // as an oop. Therefore this needs a match rule so that build_oop_map knows this is
 6368 // not a narrow oop.
 6369 instruct loadConNKlass_hi(iRegNdst dst, immNKlass_NM src) %{
 6370   match(Set dst src);
 6371   effect(DEF dst, USE src);
 6372   ins_cost(DEFAULT_COST);
 6373 
 6374   format %{ &quot;LIS     $dst, $src \t// narrow klass hi&quot; %}
 6375   size(4);
 6376   ins_encode %{
 6377     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
<span class="line-modified"> 6378     intptr_t Csrc = Klass::encode_klass((Klass *)$src$$constant);</span>
 6379     __ lis($dst$$Register, (int)(short)((Csrc &gt;&gt; 16) &amp; 0xffff));
 6380   %}
 6381   ins_pipe(pipe_class_default);
 6382 %}
 6383 
 6384 // As loadConNKlass_hi this must be recognized as narrow klass, not oop!
 6385 instruct loadConNKlass_mask(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6386   match(Set dst src1);
 6387   effect(TEMP src2);
 6388   ins_cost(DEFAULT_COST);
 6389 
 6390   format %{ &quot;MASK    $dst, $src2, 0xFFFFFFFF&quot; %} // mask
 6391   size(4);
 6392   ins_encode %{
 6393     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6394     __ clrldi($dst$$Register, $src2$$Register, 0x20);
 6395   %}
 6396   ins_pipe(pipe_class_default);
 6397 %}
 6398 
 6399 // This needs a match rule so that build_oop_map knows this is
 6400 // not a narrow oop.
 6401 instruct loadConNKlass_lo(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6402   match(Set dst src1);
 6403   effect(TEMP src2);
 6404   ins_cost(DEFAULT_COST);
 6405 
 6406   format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow klass lo&quot; %}
 6407   size(4);
 6408   ins_encode %{
 6409     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
<span class="line-modified"> 6410     intptr_t Csrc = Klass::encode_klass((Klass *)$src1$$constant);</span>
 6411     assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 6412     int klass_index = __ oop_recorder()-&gt;find_index((Klass *)$src1$$constant);
 6413     RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 6414 
 6415     __ relocate(rspec, 1);
 6416     __ ori($dst$$Register, $src2$$Register, Csrc &amp; 0xffff);
 6417   %}
 6418   ins_pipe(pipe_class_default);
 6419 %}
 6420 
 6421 // Loading ConNKlass must be postalloc expanded so that edges between
 6422 // the nodes are safe. They may not interfere with a safepoint.
 6423 instruct loadConNKlass_Ex(iRegNdst dst, immNKlass src) %{
 6424   match(Set dst src);
 6425   ins_cost(DEFAULT_COST*2);
 6426 
 6427   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6428   postalloc_expand %{
 6429     // Load high bits into register. Sign extended.
 6430     MachNode *m1 = new loadConNKlass_hiNode();
 6431     m1-&gt;add_req(NULL);
 6432     m1-&gt;_opnds[0] = op_dst;
 6433     m1-&gt;_opnds[1] = op_src;
 6434     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6435     nodes-&gt;push(m1);
 6436 
 6437     MachNode *m2 = m1;
<span class="line-modified"> 6438     if (!Assembler::is_uimm((jlong)Klass::encode_klass((Klass *)op_src-&gt;constant()), 31)) {</span>
 6439       // Value might be 1-extended. Mask out these bits.
 6440       m2 = new loadConNKlass_maskNode();
 6441       m2-&gt;add_req(NULL, m1);
 6442       m2-&gt;_opnds[0] = op_dst;
 6443       m2-&gt;_opnds[1] = op_src;
 6444       m2-&gt;_opnds[2] = op_dst;
 6445       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6446       nodes-&gt;push(m2);
 6447     }
 6448 
 6449     MachNode *m3 = new loadConNKlass_loNode();
 6450     m3-&gt;add_req(NULL, m2);
 6451     m3-&gt;_opnds[0] = op_dst;
 6452     m3-&gt;_opnds[1] = op_src;
 6453     m3-&gt;_opnds[2] = op_dst;
 6454     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6455     nodes-&gt;push(m3);
 6456   %}
 6457 %}
 6458 
</pre>
<hr />
<pre>
 6880 
 6881 // Card-mark for CMS garbage collection.
 6882 // This cardmark does an optimization so that it must not always
 6883 // do a releasing store. For this, it gets the address of
 6884 // CMSCollectorCardTableBarrierSetBSExt::_requires_release as input.
 6885 // (Using releaseFieldAddr in the match rule is a hack.)
 6886 instruct storeCM_CMS(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
 6887   match(Set mem (StoreCM mem releaseFieldAddr));
 6888   effect(TEMP crx);
 6889   predicate(false);
 6890   ins_cost(MEMORY_REF_COST);
 6891 
 6892   // See loadConP.
 6893   ins_cannot_rematerialize(true);
 6894 
 6895   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte (must be 0!), checking requires_release in [$releaseFieldAddr]&quot; %}
 6896   ins_encode( enc_cms_card_mark(mem, releaseFieldAddr, crx) );
 6897   ins_pipe(pipe_class_memory);
 6898 %}
 6899 
<span class="line-removed"> 6900 // Card-mark for CMS garbage collection.</span>
<span class="line-removed"> 6901 // This cardmark does an optimization so that it must not always</span>
<span class="line-removed"> 6902 // do a releasing store. For this, it needs the constant address of</span>
<span class="line-removed"> 6903 // CMSCollectorCardTableBarrierSetBSExt::_requires_release.</span>
<span class="line-removed"> 6904 // This constant address is split off here by expand so we can use</span>
<span class="line-removed"> 6905 // adlc / matcher functionality to load it from the constant section.</span>
<span class="line-removed"> 6906 instruct storeCM_CMS_ExEx(memory mem, immI_0 zero) %{</span>
<span class="line-removed"> 6907   match(Set mem (StoreCM mem zero));</span>
<span class="line-removed"> 6908   predicate(UseConcMarkSweepGC);</span>
<span class="line-removed"> 6909 </span>
<span class="line-removed"> 6910   expand %{</span>
<span class="line-removed"> 6911     immL baseImm %{ 0 /* TODO: PPC port (jlong)CMSCollectorCardTableBarrierSetBSExt::requires_release_address() */ %}</span>
<span class="line-removed"> 6912     iRegLdst releaseFieldAddress;</span>
<span class="line-removed"> 6913     flagsReg crx;</span>
<span class="line-removed"> 6914     loadConL_Ex(releaseFieldAddress, baseImm);</span>
<span class="line-removed"> 6915     storeCM_CMS(mem, releaseFieldAddress, crx);</span>
<span class="line-removed"> 6916   %}</span>
<span class="line-removed"> 6917 %}</span>
<span class="line-removed"> 6918 </span>
 6919 instruct storeCM_G1(memory mem, immI_0 zero) %{
 6920   match(Set mem (StoreCM mem zero));
 6921   predicate(UseG1GC);
 6922   ins_cost(MEMORY_REF_COST);
 6923 
 6924   ins_cannot_rematerialize(true);
 6925 
 6926   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte store (G1)&quot; %}
 6927   size(8);
 6928   ins_encode %{
 6929     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6930     __ li(R0, 0);
 6931     //__ release(); // G1: oops are allowed to get visible after dirty marking
 6932     guarantee($mem$$base$$Register != R1_SP, &quot;use frame_slots_bias&quot;);
 6933     __ stb(R0, $mem$$disp, $mem$$base$$Register);
 6934   %}
 6935   ins_pipe(pipe_class_memory);
 6936 %}
 6937 
 6938 // Convert oop pointer into compressed form.
 6939 
 6940 // Nodes for postalloc expand.
 6941 
 6942 // Shift node for expand.
 6943 instruct encodeP_shift(iRegNdst dst, iRegNsrc src) %{
 6944   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6945   match(Set dst (EncodeP src));
 6946   predicate(false);
 6947 
 6948   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 6949   size(4);
 6950   ins_encode %{
 6951     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified"> 6952     __ srdi($dst$$Register, $src$$Register, Universe::narrow_oop_shift() &amp; 0x3f);</span>
 6953   %}
 6954   ins_pipe(pipe_class_default);
 6955 %}
 6956 
 6957 // Add node for expand.
 6958 instruct encodeP_sub(iRegPdst dst, iRegPdst src) %{
 6959   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6960   match(Set dst (EncodeP src));
 6961   predicate(false);
 6962 
 6963   format %{ &quot;SUB     $dst, $src, oop_base \t// encode&quot; %}
 6964   ins_encode %{
 6965     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="line-modified"> 6966     __ sub_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);</span>
 6967   %}
 6968   ins_pipe(pipe_class_default);
 6969 %}
 6970 
 6971 // Conditional sub base.
 6972 instruct cond_sub_base(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 6973   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6974   match(Set dst (EncodeP (Binary crx src1)));
 6975   predicate(false);
 6976 
 6977   format %{ &quot;BEQ     $crx, done\n\t&quot;
 6978             &quot;SUB     $dst, $src1, heapbase \t// encode: subtract base if != NULL\n&quot;
 6979             &quot;done:&quot; %}
 6980   ins_encode %{
 6981     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6982     Label done;
 6983     __ beq($crx$$CondRegister, done);
<span class="line-modified"> 6984     __ sub_const_optimized($dst$$Register, $src1$$Register, Universe::narrow_oop_base(), R0);</span>
 6985     __ bind(done);
 6986   %}
 6987   ins_pipe(pipe_class_default);
 6988 %}
 6989 
 6990 // Power 7 can use isel instruction
 6991 instruct cond_set_0_oop(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 6992   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6993   match(Set dst (EncodeP (Binary crx src1)));
 6994   predicate(false);
 6995 
 6996   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// encode: preserve 0&quot; %}
 6997   size(4);
 6998   ins_encode %{
 6999     // This is a Power7 instruction for which no machine description exists.
 7000     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7001     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7002   %}
 7003   ins_pipe(pipe_class_default);
 7004 %}
 7005 
 7006 // Disjoint narrow oop base.
 7007 instruct encodeP_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7008   match(Set dst (EncodeP src));
<span class="line-modified"> 7009   predicate(Universe::narrow_oop_base_disjoint());</span>
 7010 
 7011   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7012   size(4);
 7013   ins_encode %{
 7014     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified"> 7015     __ rldicl($dst$$Register, $src$$Register, 64-Universe::narrow_oop_shift(), 32);</span>
 7016   %}
 7017   ins_pipe(pipe_class_default);
 7018 %}
 7019 
 7020 // shift != 0, base != 0
 7021 instruct encodeP_Ex(iRegNdst dst, flagsReg crx, iRegPsrc src) %{
 7022   match(Set dst (EncodeP src));
 7023   effect(TEMP crx);
 7024   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
<span class="line-modified"> 7025             Universe::narrow_oop_shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7026             Universe::narrow_oop_base_overlaps());</span>
 7027 
 7028   format %{ &quot;EncodeP $dst, $crx, $src \t// postalloc expanded&quot; %}
 7029   postalloc_expand( postalloc_expand_encode_oop(dst, src, crx));
 7030 %}
 7031 
 7032 // shift != 0, base != 0
 7033 instruct encodeP_not_null_Ex(iRegNdst dst, iRegPsrc src) %{
 7034   match(Set dst (EncodeP src));
 7035   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull &amp;&amp;
<span class="line-modified"> 7036             Universe::narrow_oop_shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7037             Universe::narrow_oop_base_overlaps());</span>
 7038 
 7039   format %{ &quot;EncodeP $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7040   postalloc_expand( postalloc_expand_encode_oop_not_null(dst, src) );
 7041 %}
 7042 
 7043 // shift != 0, base == 0
 7044 // TODO: This is the same as encodeP_shift. Merge!
 7045 instruct encodeP_not_null_base_null(iRegNdst dst, iRegPsrc src) %{
 7046   match(Set dst (EncodeP src));
<span class="line-modified"> 7047   predicate(Universe::narrow_oop_shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7048             Universe::narrow_oop_base() ==0);</span>
 7049 
 7050   format %{ &quot;SRDI    $dst, $src, #3 \t// encodeP, $src != NULL&quot; %}
 7051   size(4);
 7052   ins_encode %{
 7053     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified"> 7054     __ srdi($dst$$Register, $src$$Register, Universe::narrow_oop_shift() &amp; 0x3f);</span>
 7055   %}
 7056   ins_pipe(pipe_class_default);
 7057 %}
 7058 
 7059 // Compressed OOPs with narrow_oop_shift == 0.
 7060 // shift == 0, base == 0
 7061 instruct encodeP_narrow_oop_shift_0(iRegNdst dst, iRegPsrc src) %{
 7062   match(Set dst (EncodeP src));
<span class="line-modified"> 7063   predicate(Universe::narrow_oop_shift() == 0);</span>
 7064 
 7065   format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Narrow&quot; %}
 7066   // variable size, 0 or 4.
 7067   ins_encode %{
 7068     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7069     __ mr_if_needed($dst$$Register, $src$$Register);
 7070   %}
 7071   ins_pipe(pipe_class_default);
 7072 %}
 7073 
 7074 // Decode nodes.
 7075 
 7076 // Shift node for expand.
 7077 instruct decodeN_shift(iRegPdst dst, iRegPsrc src) %{
 7078   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7079   match(Set dst (DecodeN src));
 7080   predicate(false);
 7081 
 7082   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN&quot; %}
 7083   size(4);
 7084   ins_encode %{
 7085     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
<span class="line-modified"> 7086     __ sldi($dst$$Register, $src$$Register, Universe::narrow_oop_shift());</span>
 7087   %}
 7088   ins_pipe(pipe_class_default);
 7089 %}
 7090 
 7091 // Add node for expand.
 7092 instruct decodeN_add(iRegPdst dst, iRegPdst src) %{
 7093   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7094   match(Set dst (DecodeN src));
 7095   predicate(false);
 7096 
 7097   format %{ &quot;ADD     $dst, $src, heapbase \t// DecodeN, add oop base&quot; %}
 7098   ins_encode %{
 7099     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="line-modified"> 7100     __ add_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);</span>
 7101   %}
 7102   ins_pipe(pipe_class_default);
 7103 %}
 7104 
 7105 // conditianal add base for expand
 7106 instruct cond_add_base(iRegPdst dst, flagsRegSrc crx, iRegPsrc src) %{
 7107   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7108   // NOTICE that the rule is nonsense - we just have to make sure that:
 7109   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7110   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7111   match(Set dst (DecodeN (Binary crx src)));
 7112   predicate(false);
 7113 
 7114   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7115             &quot;ADD     $dst, $src, heapbase \t// DecodeN: add oop base if $src != NULL\n&quot;
 7116             &quot;done:&quot; %}
 7117   ins_encode %{
 7118     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7119     Label done;
 7120     __ beq($crx$$CondRegister, done);
<span class="line-modified"> 7121     __ add_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);</span>
 7122     __ bind(done);
 7123   %}
 7124   ins_pipe(pipe_class_default);
 7125 %}
 7126 
 7127 instruct cond_set_0_ptr(iRegPdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7128   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7129   // NOTICE that the rule is nonsense - we just have to make sure that:
 7130   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7131   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7132   match(Set dst (DecodeN (Binary crx src1)));
 7133   predicate(false);
 7134 
 7135   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// decode: preserve 0&quot; %}
 7136   size(4);
 7137   ins_encode %{
 7138     // This is a Power7 instruction for which no machine description exists.
 7139     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7140     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7141   %}
 7142   ins_pipe(pipe_class_default);
 7143 %}
 7144 
 7145 //  shift != 0, base != 0
 7146 instruct decodeN_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7147   match(Set dst (DecodeN src));
 7148   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7149              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
<span class="line-modified"> 7150             Universe::narrow_oop_shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7151             Universe::narrow_oop_base() != 0);</span>
 7152   ins_cost(4 * DEFAULT_COST); // Should be more expensive than decodeN_Disjoint_isel_Ex.
 7153   effect(TEMP crx);
 7154 
 7155   format %{ &quot;DecodeN $dst, $src \t// Kills $crx, postalloc expanded&quot; %}
 7156   postalloc_expand( postalloc_expand_decode_oop(dst, src, crx) );
 7157 %}
 7158 
 7159 // shift != 0, base == 0
 7160 instruct decodeN_nullBase(iRegPdst dst, iRegNsrc src) %{
 7161   match(Set dst (DecodeN src));
<span class="line-modified"> 7162   predicate(Universe::narrow_oop_shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7163             Universe::narrow_oop_base() == 0);</span>
 7164 
 7165   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN (zerobased)&quot; %}
 7166   size(4);
 7167   ins_encode %{
 7168     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
<span class="line-modified"> 7169     __ sldi($dst$$Register, $src$$Register, Universe::narrow_oop_shift());</span>
 7170   %}
 7171   ins_pipe(pipe_class_default);
 7172 %}
 7173 
 7174 // Optimize DecodeN for disjoint base.
 7175 // Shift narrow oop and or it into register that already contains the heap base.
 7176 // Base == dst must hold, and is assured by construction in postaloc_expand.
 7177 instruct decodeN_mergeDisjoint(iRegPdst dst, iRegNsrc src, iRegLsrc base) %{
 7178   match(Set dst (DecodeN src));
 7179   effect(TEMP base);
 7180   predicate(false);
 7181 
 7182   format %{ &quot;RLDIMI  $dst, $src, shift, 32-shift \t// DecodeN (disjoint base)&quot; %}
 7183   size(4);
 7184   ins_encode %{
 7185     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
<span class="line-modified"> 7186     __ rldimi($dst$$Register, $src$$Register, Universe::narrow_oop_shift(), 32-Universe::narrow_oop_shift());</span>
 7187   %}
 7188   ins_pipe(pipe_class_default);
 7189 %}
 7190 
 7191 // Optimize DecodeN for disjoint base.
 7192 // This node requires only one cycle on the critical path.
 7193 // We must postalloc_expand as we can not express use_def effects where
 7194 // the used register is L and the def&#39;ed register P.
 7195 instruct decodeN_Disjoint_notNull_Ex(iRegPdst dst, iRegNsrc src) %{
 7196   match(Set dst (DecodeN src));
 7197   effect(TEMP_DEF dst);
 7198   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7199              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified"> 7200             Universe::narrow_oop_base_disjoint());</span>
 7201   ins_cost(DEFAULT_COST);
 7202 
 7203   format %{ &quot;MOV     $dst, heapbase \t\n&quot;
 7204             &quot;RLDIMI  $dst, $src, shift, 32-shift \t// decode with disjoint base&quot; %}
 7205   postalloc_expand %{
 7206     loadBaseNode *n1 = new loadBaseNode();
 7207     n1-&gt;add_req(NULL);
 7208     n1-&gt;_opnds[0] = op_dst;
 7209 
 7210     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7211     n2-&gt;add_req(n_region, n_src, n1);
 7212     n2-&gt;_opnds[0] = op_dst;
 7213     n2-&gt;_opnds[1] = op_src;
 7214     n2-&gt;_opnds[2] = op_dst;
 7215     n2-&gt;_bottom_type = _bottom_type;
 7216 
 7217     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7218     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7219 
 7220     nodes-&gt;push(n1);
 7221     nodes-&gt;push(n2);
 7222   %}
 7223 %}
 7224 
 7225 instruct decodeN_Disjoint_isel_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7226   match(Set dst (DecodeN src));
 7227   effect(TEMP_DEF dst, TEMP crx);
 7228   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7229              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
<span class="line-modified"> 7230             Universe::narrow_oop_base_disjoint() &amp;&amp; VM_Version::has_isel());</span>
 7231   ins_cost(3 * DEFAULT_COST);
 7232 
 7233   format %{ &quot;DecodeN  $dst, $src \t// decode with disjoint base using isel&quot; %}
 7234   postalloc_expand %{
 7235     loadBaseNode *n1 = new loadBaseNode();
 7236     n1-&gt;add_req(NULL);
 7237     n1-&gt;_opnds[0] = op_dst;
 7238 
 7239     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
 7240     n_compare-&gt;add_req(n_region, n_src);
 7241     n_compare-&gt;_opnds[0] = op_crx;
 7242     n_compare-&gt;_opnds[1] = op_src;
 7243     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
 7244 
 7245     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7246     n2-&gt;add_req(n_region, n_src, n1);
 7247     n2-&gt;_opnds[0] = op_dst;
 7248     n2-&gt;_opnds[1] = op_src;
 7249     n2-&gt;_opnds[2] = op_dst;
 7250     n2-&gt;_bottom_type = _bottom_type;
</pre>
<hr />
<pre>
 7259     assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 7260     ra_-&gt;set_oop(n_cond_set, true);
 7261 
 7262     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7263     ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 7264     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7265     ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7266 
 7267     nodes-&gt;push(n1);
 7268     nodes-&gt;push(n_compare);
 7269     nodes-&gt;push(n2);
 7270     nodes-&gt;push(n_cond_set);
 7271   %}
 7272 %}
 7273 
 7274 // src != 0, shift != 0, base != 0
 7275 instruct decodeN_notNull_addBase_Ex(iRegPdst dst, iRegNsrc src) %{
 7276   match(Set dst (DecodeN src));
 7277   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7278              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified"> 7279             Universe::narrow_oop_shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7280             Universe::narrow_oop_base() != 0);</span>
 7281   ins_cost(2 * DEFAULT_COST);
 7282 
 7283   format %{ &quot;DecodeN $dst, $src \t// $src != NULL, postalloc expanded&quot; %}
 7284   postalloc_expand( postalloc_expand_decode_oop_not_null(dst, src));
 7285 %}
 7286 
 7287 // Compressed OOPs with narrow_oop_shift == 0.
 7288 instruct decodeN_unscaled(iRegPdst dst, iRegNsrc src) %{
 7289   match(Set dst (DecodeN src));
<span class="line-modified"> 7290   predicate(Universe::narrow_oop_shift() == 0);</span>
 7291   ins_cost(DEFAULT_COST);
 7292 
 7293   format %{ &quot;MR      $dst, $src \t// DecodeN (unscaled)&quot; %}
 7294   // variable size, 0 or 4.
 7295   ins_encode %{
 7296     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7297     __ mr_if_needed($dst$$Register, $src$$Register);
 7298   %}
 7299   ins_pipe(pipe_class_default);
 7300 %}
 7301 
 7302 // Convert compressed oop into int for vectors alignment masking.
 7303 instruct decodeN2I_unscaled(iRegIdst dst, iRegNsrc src) %{
 7304   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
<span class="line-modified"> 7305   predicate(Universe::narrow_oop_shift() == 0);</span>
 7306   ins_cost(DEFAULT_COST);
 7307 
 7308   format %{ &quot;MR      $dst, $src \t// (int)DecodeN (unscaled)&quot; %}
 7309   // variable size, 0 or 4.
 7310   ins_encode %{
 7311     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7312     __ mr_if_needed($dst$$Register, $src$$Register);
 7313   %}
 7314   ins_pipe(pipe_class_default);
 7315 %}
 7316 
 7317 // Convert klass pointer into compressed form.
 7318 
 7319 // Nodes for postalloc expand.
 7320 
 7321 // Shift node for expand.
 7322 instruct encodePKlass_shift(iRegNdst dst, iRegNsrc src) %{
 7323   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7324   match(Set dst (EncodePKlass src));
 7325   predicate(false);
 7326 
 7327   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 7328   size(4);
 7329   ins_encode %{
 7330     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified"> 7331     __ srdi($dst$$Register, $src$$Register, Universe::narrow_klass_shift());</span>
 7332   %}
 7333   ins_pipe(pipe_class_default);
 7334 %}
 7335 
 7336 // Add node for expand.
 7337 instruct encodePKlass_sub_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7338   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7339   match(Set dst (EncodePKlass (Binary base src)));
 7340   predicate(false);
 7341 
 7342   format %{ &quot;SUB     $dst, $base, $src \t// encode&quot; %}
 7343   size(4);
 7344   ins_encode %{
 7345     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 7346     __ subf($dst$$Register, $base$$Register, $src$$Register);
 7347   %}
 7348   ins_pipe(pipe_class_default);
 7349 %}
 7350 
 7351 // Disjoint narrow oop base.
 7352 instruct encodePKlass_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7353   match(Set dst (EncodePKlass src));
<span class="line-modified"> 7354   predicate(false /* TODO: PPC port Universe::narrow_klass_base_disjoint()*/);</span>
 7355 
 7356   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7357   size(4);
 7358   ins_encode %{
 7359     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified"> 7360     __ rldicl($dst$$Register, $src$$Register, 64-Universe::narrow_klass_shift(), 32);</span>
 7361   %}
 7362   ins_pipe(pipe_class_default);
 7363 %}
 7364 
 7365 // shift != 0, base != 0
 7366 instruct encodePKlass_not_null_Ex(iRegNdst dst, iRegLsrc base, iRegPsrc src) %{
 7367   match(Set dst (EncodePKlass (Binary base src)));
 7368   predicate(false);
 7369 
 7370   format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7371   postalloc_expand %{
 7372     encodePKlass_sub_baseNode *n1 = new encodePKlass_sub_baseNode();
 7373     n1-&gt;add_req(n_region, n_base, n_src);
 7374     n1-&gt;_opnds[0] = op_dst;
 7375     n1-&gt;_opnds[1] = op_base;
 7376     n1-&gt;_opnds[2] = op_src;
 7377     n1-&gt;_bottom_type = _bottom_type;
 7378 
 7379     encodePKlass_shiftNode *n2 = new encodePKlass_shiftNode();
 7380     n2-&gt;add_req(n_region, n1);
 7381     n2-&gt;_opnds[0] = op_dst;
 7382     n2-&gt;_opnds[1] = op_dst;
 7383     n2-&gt;_bottom_type = _bottom_type;
 7384     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7385     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7386 
 7387     nodes-&gt;push(n1);
 7388     nodes-&gt;push(n2);
 7389   %}
 7390 %}
 7391 
 7392 // shift != 0, base != 0
 7393 instruct encodePKlass_not_null_ExEx(iRegNdst dst, iRegPsrc src) %{
 7394   match(Set dst (EncodePKlass src));
<span class="line-modified"> 7395   //predicate(Universe::narrow_klass_shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7396   //          true /* TODO: PPC port Universe::narrow_klass_base_overlaps()*/);</span>
 7397 
 7398   //format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7399   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7400   expand %{
<span class="line-modified"> 7401     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_klass_base() %}</span>
 7402     iRegLdst base;
 7403     loadConL_Ex(base, baseImm);
 7404     encodePKlass_not_null_Ex(dst, base, src);
 7405   %}
 7406 %}
 7407 
 7408 // Decode nodes.
 7409 
 7410 // Shift node for expand.
 7411 instruct decodeNKlass_shift(iRegPdst dst, iRegPsrc src) %{
 7412   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7413   match(Set dst (DecodeNKlass src));
 7414   predicate(false);
 7415 
 7416   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeNKlass&quot; %}
 7417   size(4);
 7418   ins_encode %{
 7419     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
<span class="line-modified"> 7420     __ sldi($dst$$Register, $src$$Register, Universe::narrow_klass_shift());</span>
 7421   %}
 7422   ins_pipe(pipe_class_default);
 7423 %}
 7424 
 7425 // Add node for expand.
 7426 
 7427 instruct decodeNKlass_add_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7428   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7429   match(Set dst (DecodeNKlass (Binary base src)));
 7430   predicate(false);
 7431 
 7432   format %{ &quot;ADD     $dst, $base, $src \t// DecodeNKlass, add klass base&quot; %}
 7433   size(4);
 7434   ins_encode %{
 7435     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 7436     __ add($dst$$Register, $base$$Register, $src$$Register);
 7437   %}
 7438   ins_pipe(pipe_class_default);
 7439 %}
 7440 
</pre>
<hr />
<pre>
 7453     n1-&gt;_opnds[2] = op_src;
 7454     n1-&gt;_bottom_type = _bottom_type;
 7455 
 7456     decodeNKlass_shiftNode *n2 = new decodeNKlass_shiftNode();
 7457     n2-&gt;add_req(n_region, n1);
 7458     n2-&gt;_opnds[0] = op_dst;
 7459     n2-&gt;_opnds[1] = op_dst;
 7460     n2-&gt;_bottom_type = _bottom_type;
 7461 
 7462     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7463     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7464 
 7465     nodes-&gt;push(n1);
 7466     nodes-&gt;push(n2);
 7467   %}
 7468 %}
 7469 
 7470 // src != 0, shift != 0, base != 0
 7471 instruct decodeNKlass_notNull_addBase_ExEx(iRegPdst dst, iRegNsrc src) %{
 7472   match(Set dst (DecodeNKlass src));
<span class="line-modified"> 7473   // predicate(Universe::narrow_klass_shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7474   //           Universe::narrow_klass_base() != 0);</span>
 7475 
 7476   //format %{ &quot;DecodeNKlass $dst, $src \t// $src != NULL, expanded&quot; %}
 7477 
 7478   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7479   expand %{
 7480     // We add first, then we shift. Like this, we can get along with one register less.
 7481     // But we have to load the base pre-shifted.
<span class="line-modified"> 7482     immL baseImm %{ (jlong)((intptr_t)Universe::narrow_klass_base() &gt;&gt; Universe::narrow_klass_shift()) %}</span>
 7483     iRegLdst base;
 7484     loadConL_Ex(base, baseImm);
 7485     decodeNKlass_notNull_addBase_Ex(dst, base, src);
 7486   %}
 7487 %}
 7488 
 7489 //----------MemBar Instructions-----------------------------------------------
 7490 // Memory barrier flavors
 7491 
 7492 instruct membar_acquire() %{
 7493   match(LoadFence);
 7494   ins_cost(4*MEMORY_REF_COST);
 7495 
 7496   format %{ &quot;MEMBAR-acquire&quot; %}
 7497   size(4);
 7498   ins_encode %{
 7499     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7500     __ acquire();
 7501   %}
 7502   ins_pipe(pipe_class_default);
</pre>
<hr />
<pre>
10822   %}
10823   ins_pipe(pipe_class_default);
10824 %}
10825 
10826 instruct castPP(iRegPdst dst) %{
10827   match(Set dst (CastPP dst));
10828   format %{ &quot; -- \t// castPP of $dst&quot; %}
10829   size(0);
10830   ins_encode( /*empty*/ );
10831   ins_pipe(pipe_class_default);
10832 %}
10833 
10834 instruct castII(iRegIdst dst) %{
10835   match(Set dst (CastII dst));
10836   format %{ &quot; -- \t// castII of $dst&quot; %}
10837   size(0);
10838   ins_encode( /*empty*/ );
10839   ins_pipe(pipe_class_default);
10840 %}
10841 








10842 instruct checkCastPP(iRegPdst dst) %{
10843   match(Set dst (CheckCastPP dst));
10844   format %{ &quot; -- \t// checkcastPP of $dst&quot; %}
10845   size(0);
10846   ins_encode( /*empty*/ );
10847   ins_pipe(pipe_class_default);
10848 %}
10849 
10850 //----------Convert instructions-----------------------------------------------
10851 
10852 // Convert to boolean.
10853 
10854 // int_to_bool(src) : { 1   if src != 0
10855 //                    { 0   else
10856 //
10857 // strategy:
10858 // 1) Count leading zeros of 32 bit-value src,
10859 //    this returns 32 (0b10.0000) iff src == 0 and &lt;32 otherwise.
10860 // 2) Shift 5 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10861 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
</pre>
<hr />
<pre>
13992   size(4);
13993   ins_encode %{
13994     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
13995   %}
13996   ins_pipe(pipe_class_default);
13997 %}
13998 
13999 instruct repl4S_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14000   match(Set dst (ReplicateS src));
14001   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14002   expand %{
14003     moveReg(dst, src);
14004     repl48(dst);
14005     repl32(dst);
14006   %}
14007 %}
14008 
14009 instruct repl4S_immI0(iRegLdst dst, immI_0 zero) %{
14010   match(Set dst (ReplicateS zero));
14011   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">14012   format %{ &quot;LI      $dst, #0 \t// replicate4C&quot; %}</span>
14013   size(4);
14014   ins_encode %{
14015     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14016     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14017   %}
14018   ins_pipe(pipe_class_default);
14019 %}
14020 
14021 instruct repl4S_immIminus1(iRegLdst dst, immI_minus1 src) %{
14022   match(Set dst (ReplicateS src));
14023   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">14024   format %{ &quot;LI      $dst, -1 \t// replicate4C&quot; %}</span>
14025   size(4);
14026   ins_encode %{
14027     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14028     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14029   %}
14030   ins_pipe(pipe_class_default);
14031 %}
14032 
14033 instruct repl8S_reg_Ex(vecX dst, iRegIsrc src) %{
14034   match(Set dst (ReplicateS src));
14035   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14036 
14037   expand %{
14038     iRegLdst tmpL;
14039     vecX tmpV;
14040     immI8  zero %{ (int)  0 %}
14041     moveReg(tmpL, src);
14042     repl48(tmpL);
14043     repl32(tmpL);
14044     mtvsrd(tmpV, tmpL);
14045     xxpermdi(dst, tmpV, tmpV, zero);
14046   %}
14047 %}
14048 
14049 instruct repl8S_immI0(vecX dst, immI_0 zero) %{
14050   match(Set dst (ReplicateS zero));
14051   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14052 
14053   format %{ &quot;XXLXOR      $dst, $zero \t// replicate8S&quot; %}
14054   size(4);
14055   ins_encode %{
14056     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14057   %}
14058   ins_pipe(pipe_class_default);
14059 %}
14060 
14061 instruct repl8S_immIminus1(vecX dst, immI_minus1 src) %{
14062   match(Set dst (ReplicateS src));
14063   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14064 
<span class="line-modified">14065   format %{ &quot;XXLEQV      $dst, $src \t// replicate16B&quot; %}</span>
14066   size(4);
14067   ins_encode %{
14068     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14069   %}
14070   ins_pipe(pipe_class_default);
14071 %}
14072 
14073 instruct repl2I_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14074   match(Set dst (ReplicateI src));
14075   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14076   ins_cost(2 * DEFAULT_COST);
14077   expand %{
14078     moveReg(dst, src);
14079     repl32(dst);
14080   %}
14081 %}
14082 
14083 instruct repl2I_immI0(iRegLdst dst, immI_0 zero) %{
14084   match(Set dst (ReplicateI zero));
14085   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">14086   format %{ &quot;LI      $dst, #0 \t// replicate4C&quot; %}</span>
14087   size(4);
14088   ins_encode %{
14089     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14090     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14091   %}
14092   ins_pipe(pipe_class_default);
14093 %}
14094 
14095 instruct repl2I_immIminus1(iRegLdst dst, immI_minus1 src) %{
14096   match(Set dst (ReplicateI src));
14097   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">14098   format %{ &quot;LI      $dst, -1 \t// replicate4C&quot; %}</span>
14099   size(4);
14100   ins_encode %{
14101     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14102     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14103   %}
14104   ins_pipe(pipe_class_default);
14105 %}
14106 
14107 instruct repl4I_reg_Ex(vecX dst, iRegIsrc src) %{
14108   match(Set dst (ReplicateI src));
14109   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14110   ins_cost(2 * DEFAULT_COST);
14111 
14112   expand %{
14113     iRegLdst tmpL;
14114     vecX tmpV;
14115     immI8  zero %{ (int)  0 %}
14116     moveReg(tmpL, src);
14117     repl32(tmpL);
14118     mtvsrd(tmpV, tmpL);
</pre>
<hr />
<pre>
14401   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14402   format %{ &quot;XVABSSP $dst,$src\t// absolute packed4F&quot; %}
14403   size(4);
14404   ins_encode %{
14405     __ xvabssp($dst$$VectorSRegister, $src$$VectorSRegister);
14406   %}
14407   ins_pipe(pipe_class_default);
14408 %}
14409 
14410 instruct vabs2D_reg(vecX dst, vecX src) %{
14411   match(Set dst (AbsVD src));
14412   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14413   format %{ &quot;XVABSDP $dst,$src\t// absolute packed2D&quot; %}
14414   size(4);
14415   ins_encode %{
14416     __ xvabsdp($dst$$VectorSRegister, $src$$VectorSRegister);
14417   %}
14418   ins_pipe(pipe_class_default);
14419 %}
14420 















































14421 // Vector Negate Instructions
14422 
14423 instruct vneg4F_reg(vecX dst, vecX src) %{
14424   match(Set dst (NegVF src));
14425   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14426   format %{ &quot;XVNEGSP $dst,$src\t// negate packed4F&quot; %}
14427   size(4);
14428   ins_encode %{
14429     __ xvnegsp($dst$$VectorSRegister, $src$$VectorSRegister);
14430   %}
14431   ins_pipe(pipe_class_default);
14432 %}
14433 
14434 instruct vneg2D_reg(vecX dst, vecX src) %{
14435   match(Set dst (NegVD src));
14436   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14437   format %{ &quot;XVNEGDP $dst,$src\t// negate packed2D&quot; %}
14438   size(4);
14439   ins_encode %{
14440     __ xvnegdp($dst$$VectorSRegister, $src$$VectorSRegister);
</pre>
<hr />
<pre>
14652 
14653   format %{ &quot;XXLXOR      $dst, $zero \t// replicate4F&quot; %}
14654   ins_encode %{
14655     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14656   %}
14657   ins_pipe(pipe_class_default);
14658 %}
14659 
14660 instruct repl2D_reg_Ex(vecX dst, regD src) %{
14661   match(Set dst (ReplicateD src));
14662   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14663 
14664   format %{ &quot;XXPERMDI      $dst, $src, $src, 0 \t// Splat doubleword&quot; %}
14665   size(4);
14666   ins_encode %{
14667     __ xxpermdi($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr(), $src$$FloatRegister-&gt;to_vsr(), 0);
14668   %}
14669   ins_pipe(pipe_class_default);
14670 %}
14671 
<span class="line-modified">14672 instruct repl2D_immI0(vecX dst, immI_0 zero) %{</span>
14673   match(Set dst (ReplicateD zero));
14674   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14675 
14676   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2D&quot; %}
14677   size(4);
14678   ins_encode %{
14679     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14680   %}
14681   ins_pipe(pipe_class_default);
14682 %}
14683 
<span class="line-removed">14684 instruct repl2D_immIminus1(vecX dst, immI_minus1 src) %{</span>
<span class="line-removed">14685   match(Set dst (ReplicateD src));</span>
<span class="line-removed">14686   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-removed">14687 </span>
<span class="line-removed">14688   format %{ &quot;XXLEQV      $dst, $src \t// replicate16B&quot; %}</span>
<span class="line-removed">14689   size(4);</span>
<span class="line-removed">14690   ins_encode %{</span>
<span class="line-removed">14691     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);</span>
<span class="line-removed">14692   %}</span>
<span class="line-removed">14693   ins_pipe(pipe_class_default);</span>
<span class="line-removed">14694 %}</span>
<span class="line-removed">14695 </span>
14696 instruct mtvsrd(vecX dst, iRegLsrc src) %{
14697   predicate(false);
14698   effect(DEF dst, USE src);
14699 
14700   format %{ &quot;MTVSRD      $dst, $src \t// Move to 16-byte register&quot; %}
14701   size(4);
14702   ins_encode %{
14703     __ mtvsrd($dst$$VectorSRegister, $src$$Register);
14704   %}
14705   ins_pipe(pipe_class_default);
14706 %}
14707 
14708 instruct xxspltd(vecX dst, vecX src, immI8 zero) %{
14709   effect(DEF dst, USE src, USE zero);
14710 
14711   format %{ &quot;XXSPLATD      $dst, $src, $zero \t// Splat doubleword&quot; %}
14712   size(4);
14713   ins_encode %{
14714     __ xxpermdi($dst$$VectorSRegister, $src$$VectorSRegister, $src$$VectorSRegister, $zero$$constant);
14715   %}
</pre>
<hr />
<pre>
14737     xxpermdi(dst, tmpV, tmpV, zero);
14738   %}
14739 %}
14740 
14741 instruct repl2L_immI0(vecX dst, immI_0 zero) %{
14742   match(Set dst (ReplicateL zero));
14743   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14744 
14745   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2L&quot; %}
14746   size(4);
14747   ins_encode %{
14748     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14749   %}
14750   ins_pipe(pipe_class_default);
14751 %}
14752 
14753 instruct repl2L_immIminus1(vecX dst, immI_minus1 src) %{
14754   match(Set dst (ReplicateL src));
14755   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14756 
<span class="line-modified">14757   format %{ &quot;XXLEQV      $dst, $src \t// replicate16B&quot; %}</span>
14758   size(4);
14759   ins_encode %{
14760     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14761   %}
14762   ins_pipe(pipe_class_default);
14763 %}
14764 
14765 // ============================================================================
14766 // Safepoint Instruction
14767 
14768 instruct safePoint_poll(iRegPdst poll) %{
14769   match(SafePoint poll);
14770 
14771   // It caused problems to add the effect that r0 is killed, but this
14772   // effect no longer needs to be mentioned, since r0 is not contained
14773   // in a reg_class.
14774 
14775   format %{ &quot;LD      R0, #0, $poll \t// Safepoint poll for GC&quot; %}
14776   size(4);
14777   ins_encode( enc_poll(0x0, poll) );
</pre>
<hr />
<pre>
15127     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15128     __ brnop1();
15129   %}
15130   ins_pipe(pipe_class_default);
15131 %}
15132 
15133 instruct brNop2() %{
15134   ins_cost(0);
15135 
15136   ins_is_nop(true);
15137 
15138   format %{ &quot;brNop2&quot; %}
15139   size(4);
15140   ins_encode %{
15141     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15142     __ brnop2();
15143   %}
15144   ins_pipe(pipe_class_default);
15145 %}
15146 






































15147 //----------PEEPHOLE RULES-----------------------------------------------------
15148 // These must follow all instruction definitions as they use the names
15149 // defined in the instructions definitions.
15150 //
15151 // peepmatch ( root_instr_name [preceeding_instruction]* );
15152 //
15153 // peepconstraint %{
15154 // (instruction_number.operand_name relational_op instruction_number.operand_name
15155 //  [, ...] );
15156 // // instruction numbers are zero-based using left to right order in peepmatch
15157 //
15158 // peepreplace ( instr_name ( [instruction_number.operand_name]* ) );
15159 // // provide an instruction_number.operand_name for each operand that appears
15160 // // in the replacement instruction&#39;s match rule
15161 //
15162 // ---------VM FLAGS---------------------------------------------------------
15163 //
15164 // All peephole optimizations can be turned off using -XX:-OptoPeephole
15165 //
15166 // Each peephole rule is given an identifying number starting with zero and
</pre>
</td>
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">    3 // Copyright (c) 2012, 2019 SAP SE. All rights reserved.</span>
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
</pre>
<hr />
<pre>
  955   int_def MEMORY_REF_COST_LOW     (    200, DEFAULT_COST * 2);
  956   int_def MEMORY_REF_COST         (    300, DEFAULT_COST * 3);
  957 
  958   // Branches are even more expensive.
  959   int_def BRANCH_COST             (    900, DEFAULT_COST * 9);
  960   int_def CALL_COST               (   1300, DEFAULT_COST * 13);
  961 %}
  962 
  963 
  964 //----------SOURCE BLOCK-------------------------------------------------------
  965 // This is a block of C++ code which provides values, functions, and
  966 // definitions necessary in the rest of the architecture description.
  967 source_hpp %{
  968   // Header information of the source block.
  969   // Method declarations/definitions which are used outside
  970   // the ad-scope can conveniently be defined here.
  971   //
  972   // To keep related declarations/definitions/uses close together,
  973   // we switch between source %{ }% and source_hpp %{ }% freely as needed.
  974 
<span class="line-added">  975 #include &quot;opto/convertnode.hpp&quot;</span>
<span class="line-added">  976 </span>
  977   // Returns true if Node n is followed by a MemBar node that
  978   // will do an acquire. If so, this node must not do the acquire
  979   // operation.
  980   bool followed_by_acquire(const Node *n);
  981 %}
  982 
  983 source %{
  984 
  985 // Should the Matcher clone shifts on addressing modes, expecting them
  986 // to be subsumed into complex addressing expressions or compute them
  987 // into registers?
  988 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
  989   return clone_base_plus_offset_address(m, mstack, address_visited);
  990 }
  991 
  992 void Compile::reshape_address(AddPNode* addp) {
  993 }
  994 
  995 // Optimize load-acquire.
  996 //
</pre>
<hr />
<pre>
 1385   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1386 
 1387   const bool method_is_frameless      = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1388 
 1389   const Register return_pc            = R20; // Must match return_addr() in frame section.
 1390   const Register callers_sp           = R21;
 1391   const Register push_frame_temp      = R22;
 1392   const Register toc_temp             = R23;
 1393   assert_different_registers(R11, return_pc, callers_sp, push_frame_temp, toc_temp);
 1394 
 1395   if (method_is_frameless) {
 1396     // Add nop at beginning of all frameless methods to prevent any
 1397     // oop instructions from getting overwritten by make_not_entrant
 1398     // (patching attempt would fail).
 1399     ___(nop) nop();
 1400   } else {
 1401     // Get return pc.
 1402     ___(mflr) mflr(return_pc);
 1403   }
 1404 
<span class="line-added"> 1405   if (C-&gt;clinit_barrier_on_entry()) {</span>
<span class="line-added"> 1406     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added"> 1407 </span>
<span class="line-added"> 1408     Label L_skip_barrier;</span>
<span class="line-added"> 1409     Register klass = toc_temp;</span>
<span class="line-added"> 1410 </span>
<span class="line-added"> 1411     // Notify OOP recorder (don&#39;t need the relocation)</span>
<span class="line-added"> 1412     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());</span>
<span class="line-added"> 1413     __ load_const_optimized(klass, md.value(), R0);</span>
<span class="line-added"> 1414     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added"> 1415 </span>
<span class="line-added"> 1416     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);</span>
<span class="line-added"> 1417     __ mtctr(klass);</span>
<span class="line-added"> 1418     __ bctr();</span>
<span class="line-added"> 1419 </span>
<span class="line-added"> 1420     __ bind(L_skip_barrier);</span>
<span class="line-added"> 1421   }</span>
<span class="line-added"> 1422 </span>
 1423   // Calls to C2R adapters often do not accept exceptional returns.
 1424   // We require that their callers must bang for them. But be
 1425   // careful, because some VM calls (such as call site linkage) can
 1426   // use several kilobytes of stack. But the stack safety zone should
 1427   // account for that. See bugs 4446381, 4468289, 4497237.
 1428 
 1429   int bangsize = C-&gt;bang_size_in_bytes();
 1430   assert(bangsize &gt;= framesize || bangsize &lt;= 0, &quot;stack bang size incorrect&quot;);
 1431   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
 1432     // Unfortunately we cannot use the function provided in
 1433     // assembler.cpp as we have to emulate the pipes. So I had to
 1434     // insert the code of generate_stack_overflow_check(), see
 1435     // assembler.cpp for some illuminative comments.
 1436     const int page_size = os::vm_page_size();
 1437     int bang_end = JavaThread::stack_shadow_zone_size();
 1438 
 1439     // This is how far the previous frame&#39;s stack banging extended.
 1440     const int bang_end_safe = bang_end;
 1441 
 1442     if (bangsize &gt; page_size) {
</pre>
<hr />
<pre>
 2207   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 2208   __ end_a_stub();
 2209 
 2210   return offset;
 2211 }
 2212 
 2213 //=============================================================================
 2214 
 2215 // Use a frame slots bias for frameless methods if accessing the stack.
 2216 static int frame_slots_bias(int reg_enc, PhaseRegAlloc* ra_) {
 2217   if (as_Register(reg_enc) == R1_SP) {
 2218     return 0; // TODO: PPC port ra_-&gt;C-&gt;frame_slots_sp_bias_in_bytes();
 2219   }
 2220   return 0;
 2221 }
 2222 
 2223 const bool Matcher::match_rule_supported(int opcode) {
 2224   if (!has_match_rule(opcode))
 2225     return false;
 2226 
<span class="line-added"> 2227   bool ret_value = true;</span>
 2228   switch (opcode) {
 2229   case Op_SqrtD:
 2230     return VM_Version::has_fsqrt();
 2231   case Op_CountLeadingZerosI:
 2232   case Op_CountLeadingZerosL:
 2233     if (!UseCountLeadingZerosInstructionsPPC64)
 2234       return false;
 2235     break;
 2236   case Op_CountTrailingZerosI:
 2237   case Op_CountTrailingZerosL:
 2238     if (!UseCountLeadingZerosInstructionsPPC64 &amp;&amp;
 2239         !UseCountTrailingZerosInstructionsPPC64)
 2240       return false;
 2241     break;
 2242 
 2243   case Op_PopCountI:
 2244   case Op_PopCountL:
 2245     return (UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
 2246 
 2247   case Op_StrComp:
</pre>
<hr />
<pre>
 2258   case Op_AddVD:
 2259   case Op_SubVB:
 2260   case Op_SubVS:
 2261   case Op_SubVI:
 2262   case Op_SubVF:
 2263   case Op_SubVD:
 2264   case Op_MulVS:
 2265   case Op_MulVF:
 2266   case Op_MulVD:
 2267   case Op_DivVF:
 2268   case Op_DivVD:
 2269   case Op_AbsVF:
 2270   case Op_AbsVD:
 2271   case Op_NegVF:
 2272   case Op_NegVD:
 2273   case Op_SqrtVF:
 2274   case Op_SqrtVD:
 2275   case Op_AddVL:
 2276   case Op_SubVL:
 2277   case Op_MulVI:
<span class="line-added"> 2278   case Op_RoundDoubleModeV:</span>
 2279     return SuperwordUseVSX;
 2280   case Op_PopCountVI:
 2281     return (SuperwordUseVSX &amp;&amp; UsePopCountInstruction);
 2282   case Op_FmaVF:
 2283   case Op_FmaVD:
 2284     return (SuperwordUseVSX &amp;&amp; UseFMA);
 2285   case Op_Digit:
 2286   case Op_LowerCase:
 2287   case Op_UpperCase:
 2288   case Op_Whitespace:
 2289     return UseCharacterCompareIntrinsics;
<span class="line-added"> 2290 </span>
<span class="line-added"> 2291   case Op_CacheWB:</span>
<span class="line-added"> 2292   case Op_CacheWBPreSync:</span>
<span class="line-added"> 2293   case Op_CacheWBPostSync:</span>
<span class="line-added"> 2294     if (!VM_Version::supports_data_cache_line_flush()) {</span>
<span class="line-added"> 2295       ret_value = false;</span>
<span class="line-added"> 2296     }</span>
<span class="line-added"> 2297     break;</span>
 2298   }
 2299 
<span class="line-modified"> 2300   return ret_value;  // Per default match rules are supported.</span>
 2301 }
 2302 
<span class="line-modified"> 2303 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {</span>
 2304 
 2305   // TODO
 2306   // identify extra cases that we might want to provide match rules for
 2307   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 2308   bool ret_value = match_rule_supported(opcode);
 2309   // Add rules here.
 2310 
 2311   return ret_value;  // Per default match rules are supported.
 2312 }
 2313 
 2314 const bool Matcher::has_predicated_vectors(void) {
 2315   return false;
 2316 }
 2317 
 2318 const int Matcher::float_pressure(int default_pressure_threshold) {
 2319   return default_pressure_threshold;
 2320 }
 2321 
 2322 int Matcher::regnum_to_fpu_offset(int regnum) {
 2323   // No user for this method?
</pre>
<hr />
<pre>
 2391 // And `Compile::Shorten_branches&#39; will decide on basis of this
 2392 // information whether to replace particular branch sites by short
 2393 // ones.
 2394 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 2395   // Is the offset within the range of a ppc64 pc relative branch?
 2396   bool b;
 2397 
 2398   const int safety_zone = 3 * BytesPerInstWord;
 2399   b = Assembler::is_simm((offset&lt;0 ? offset-safety_zone : offset+safety_zone),
 2400                          29 - 16 + 1 + 2);
 2401   return b;
 2402 }
 2403 
 2404 const bool Matcher::isSimpleConstant64(jlong value) {
 2405   // Probably always true, even if a temp register is required.
 2406   return true;
 2407 }
 2408 /* TODO: PPC port
 2409 // Make a new machine dependent decode node (with its operands).
 2410 MachTypeNode *Matcher::make_decode_node() {
<span class="line-modified"> 2411   assert(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0,</span>
 2412          &quot;This method is only implemented for unscaled cOops mode so far&quot;);
 2413   MachTypeNode *decode = new decodeN_unscaledNode();
 2414   decode-&gt;set_opnd_array(0, new iRegPdstOper());
 2415   decode-&gt;set_opnd_array(1, new iRegNsrcOper());
 2416   return decode;
 2417 }
 2418 */
 2419 
 2420 // false =&gt; size gets scaled to BytesPerLong, ok.
 2421 const bool Matcher::init_array_count_is_in_bytes = false;
 2422 
 2423 // Use conditional move (CMOVL) on Power7.
 2424 const int Matcher::long_cmove_cost() { return 0; } // this only makes long cmoves more expensive than int cmoves
 2425 
 2426 // Suppress CMOVF. Conditional move available (sort of) on PPC64 only from P7 onwards. Not exploited yet.
 2427 // fsel doesn&#39;t accept a condition register as input, so this would be slightly different.
 2428 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 2429 
 2430 // Power6 requires postalloc expand (see block.cpp for description of postalloc expand).
 2431 const bool Matcher::require_postalloc_expand = true;
 2432 
 2433 // Do we need to mask the count passed to shift instructions or does
 2434 // the cpu only look at the lower 5/6 bits anyway?
 2435 // PowerPC requires masked shift counts.
 2436 const bool Matcher::need_masked_shift_count = true;
 2437 
<span class="line-added"> 2438 // No support for generic vector operands.</span>
<span class="line-added"> 2439 const bool Matcher::supports_generic_vector_operands  = false;</span>
<span class="line-added"> 2440 </span>
<span class="line-added"> 2441 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {</span>
<span class="line-added"> 2442   ShouldNotReachHere(); // generic vector operands not supported</span>
<span class="line-added"> 2443   return NULL;</span>
<span class="line-added"> 2444 }</span>
<span class="line-added"> 2445 </span>
<span class="line-added"> 2446 bool Matcher::is_generic_reg2reg_move(MachNode* m) {</span>
<span class="line-added"> 2447   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added"> 2448   return false;</span>
<span class="line-added"> 2449 }</span>
<span class="line-added"> 2450 </span>
<span class="line-added"> 2451 bool Matcher::is_generic_vector(MachOper* opnd)  {</span>
<span class="line-added"> 2452   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added"> 2453   return false;</span>
<span class="line-added"> 2454 }</span>
<span class="line-added"> 2455 </span>
 2456 // This affects two different things:
 2457 //  - how Decode nodes are matched
 2458 //  - how ImplicitNullCheck opportunities are recognized
 2459 // If true, the matcher will try to remove all Decodes and match them
 2460 // (as operands) into nodes. NullChecks are not prepared to deal with
 2461 // Decodes by final_graph_reshaping().
 2462 // If false, final_graph_reshaping() forces the decode behind the Cmp
 2463 // for a NullCheck. The matcher matches the Decode node into a register.
 2464 // Implicit_null_check optimization moves the Decode along with the
 2465 // memory operation back up before the NullCheck.
 2466 bool Matcher::narrow_oop_use_complex_address() {
 2467   // TODO: PPC port if (MatchDecodeNodes) return true;
 2468   return false;
 2469 }
 2470 
 2471 bool Matcher::narrow_klass_use_complex_address() {
 2472   NOT_LP64(ShouldNotCallThis());
 2473   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 2474   // TODO: PPC port if (MatchDecodeNodes) return true;
 2475   return false;
 2476 }
 2477 
 2478 bool Matcher::const_oop_prefer_decode() {
 2479   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="line-modified"> 2480   return CompressedOops::base() == NULL;</span>
 2481 }
 2482 
 2483 bool Matcher::const_klass_prefer_decode() {
 2484   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified"> 2485   return CompressedKlassPointers::base() == NULL;</span>
 2486 }
 2487 
 2488 // Is it better to copy float constants, or load them directly from memory?
 2489 // Intel can load a float constant from a direct address, requiring no
 2490 // extra registers. Most RISCs will have to materialize an address into a
 2491 // register first, so they would do better to copy the constant from stack.
 2492 const bool Matcher::rematerialize_float_constants = false;
 2493 
 2494 // If CPU can load and store mis-aligned doubles directly then no fixup is
 2495 // needed. Else we split the double into 2 integer pieces and move it
 2496 // piece-by-piece. Only happens when passing doubles into C code as the
 2497 // Java calling convention forces doubles to be aligned.
 2498 const bool Matcher::misaligned_doubles_ok = true;
 2499 
 2500 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2501  Unimplemented();
 2502 }
 2503 
<span class="line-modified"> 2504 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>

 2505 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2506 
 2507 // Do floats take an entire double register or just half?
 2508 //
 2509 // A float occupies a ppc64 double register. For the allocator, a
 2510 // ppc64 double register appears as a pair of float registers.
 2511 bool Matcher::float_in_double() { return true; }
 2512 
 2513 // Do ints take an entire long register or just half?
 2514 // The relevant question is how the int is callee-saved:
 2515 // the whole long is written but de-opt&#39;ing will have to extract
 2516 // the relevant 32 bits.
 2517 const bool Matcher::int_in_long = true;
 2518 
 2519 // Constants for c2c and c calling conventions.
 2520 
 2521 const MachRegisterNumbers iarg_reg[8] = {
 2522   R3_num, R4_num, R5_num, R6_num,
 2523   R7_num, R8_num, R9_num, R10_num
 2524 };
</pre>
<hr />
<pre>
 4181   // Body of function which returns an integer array locating
 4182   // arguments either in registers or in stack slots. Passed an array
 4183   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 4184   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 4185   // arguments for a CALLEE. Incoming stack arguments are
 4186   // automatically biased by the preserve_stack_slots field above.
 4187   c_calling_convention %{
 4188     // This is obviously always outgoing.
 4189     // C argument in register AND stack slot.
 4190     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 4191   %}
 4192 
 4193   // Location of native (C/C++) and interpreter return values. This
 4194   // is specified to be the same as Java. In the 32-bit VM, long
 4195   // values are actually returned from native calls in O0:O1 and
 4196   // returned to the interpreter in I0:I1. The copying to and from
 4197   // the register pairs is done by the appropriate call and epilog
 4198   // opcodes. This simplifies the register allocator.
 4199   c_return_value %{
 4200     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
<span class="line-modified"> 4201             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),</span>
 4202             &quot;only return normal values&quot;);
 4203     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4204     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4205     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4206     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4207   %}
 4208 
 4209   // Location of compiled Java return values.  Same as C
 4210   return_value %{
 4211     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
<span class="line-modified"> 4212             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),</span>
 4213             &quot;only return normal values&quot;);
 4214     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4215     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4216     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4217     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4218   %}
 4219 %}
 4220 
 4221 
 4222 //----------ATTRIBUTES---------------------------------------------------------
 4223 
 4224 //----------Operand Attributes-------------------------------------------------
 4225 op_attrib op_cost(1);          // Required cost attribute.
 4226 
 4227 //----------Instruction Attributes---------------------------------------------
 4228 
 4229 // Cost attribute. required.
 4230 ins_attrib ins_cost(DEFAULT_COST);
 4231 
 4232 // Is this instruction a non-matching short branch variant of some
</pre>
<hr />
<pre>
 4333 
 4334 // Integer Immediate: 16-bit
 4335 operand immI16() %{
 4336   predicate(Assembler::is_simm(n-&gt;get_int(), 16));
 4337   op_cost(0);
 4338   match(ConI);
 4339   format %{ %}
 4340   interface(CONST_INTER);
 4341 %}
 4342 
 4343 // Integer Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4344 operand immIhi16() %{
 4345   predicate(((n-&gt;get_int() &amp; 0xffff0000) != 0) &amp;&amp; ((n-&gt;get_int() &amp; 0xffff) == 0));
 4346   match(ConI);
 4347   op_cost(0);
 4348   format %{ %}
 4349   interface(CONST_INTER);
 4350 %}
 4351 
 4352 operand immInegpow2() %{
<span class="line-modified"> 4353   predicate(is_power_of_2((jlong) (julong) (juint) (-(n-&gt;get_int()))));</span>
 4354   match(ConI);
 4355   op_cost(0);
 4356   format %{ %}
 4357   interface(CONST_INTER);
 4358 %}
 4359 
 4360 operand immIpow2minus1() %{
<span class="line-modified"> 4361   predicate(is_power_of_2((((jlong) (n-&gt;get_int()))+1)));</span>
 4362   match(ConI);
 4363   op_cost(0);
 4364   format %{ %}
 4365   interface(CONST_INTER);
 4366 %}
 4367 
 4368 operand immIpowerOf2() %{
<span class="line-modified"> 4369   predicate(is_power_of_2((((jlong) (julong) (juint) (n-&gt;get_int())))));</span>
 4370   match(ConI);
 4371   op_cost(0);
 4372   format %{ %}
 4373   interface(CONST_INTER);
 4374 %}
 4375 
 4376 // Unsigned Integer Immediate: the values 0-31
 4377 operand uimmI5() %{
 4378   predicate(Assembler::is_uimm(n-&gt;get_int(), 5));
 4379   match(ConI);
 4380   op_cost(0);
 4381   format %{ %}
 4382   interface(CONST_INTER);
 4383 %}
 4384 
 4385 // Unsigned Integer Immediate: 6-bit
 4386 operand uimmI6() %{
 4387   predicate(Assembler::is_uimm(n-&gt;get_int(), 6));
 4388   match(ConI);
 4389   op_cost(0);
</pre>
<hr />
<pre>
 4583 
 4584 // Long Immediate: 32-bit
 4585 operand immL32() %{
 4586   predicate(Assembler::is_simm(n-&gt;get_long(), 32));
 4587   match(ConL);
 4588   op_cost(0);
 4589   format %{ %}
 4590   interface(CONST_INTER);
 4591 %}
 4592 
 4593 // Long Immediate: 64-bit, where highest 16 bits are not 0x0000.
 4594 operand immLhighest16() %{
 4595   predicate((n-&gt;get_long() &amp; 0xffff000000000000L) != 0L &amp;&amp; (n-&gt;get_long() &amp; 0x0000ffffffffffffL) == 0L);
 4596   match(ConL);
 4597   op_cost(0);
 4598   format %{ %}
 4599   interface(CONST_INTER);
 4600 %}
 4601 
 4602 operand immLnegpow2() %{
<span class="line-modified"> 4603   predicate(is_power_of_2((jlong)-(n-&gt;get_long())));</span>
 4604   match(ConL);
 4605   op_cost(0);
 4606   format %{ %}
 4607   interface(CONST_INTER);
 4608 %}
 4609 
 4610 operand immLpow2minus1() %{
<span class="line-modified"> 4611   predicate(is_power_of_2((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;</span>
 4612             (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
 4613   match(ConL);
 4614   op_cost(0);
 4615   format %{ %}
 4616   interface(CONST_INTER);
 4617 %}
 4618 
 4619 // constant &#39;long 0&#39;.
 4620 operand immL_0() %{
 4621   predicate(n-&gt;get_long() == 0L);
 4622   match(ConL);
 4623   op_cost(0);
 4624   format %{ %}
 4625   interface(CONST_INTER);
 4626 %}
 4627 
 4628 // constat &#39; long -1&#39;.
 4629 operand immL_minus1() %{
 4630   predicate(n-&gt;get_long() == -1L);
 4631   match(ConL);
</pre>
<hr />
<pre>
 4661 %}
 4662 
 4663 // Float Immediate: +0.0f.
 4664 operand immF_0() %{
 4665   predicate(jint_cast(n-&gt;getf()) == 0);
 4666   match(ConF);
 4667 
 4668   op_cost(0);
 4669   format %{ %}
 4670   interface(CONST_INTER);
 4671 %}
 4672 
 4673 // Double Immediate
 4674 operand immD() %{
 4675   match(ConD);
 4676   op_cost(40);
 4677   format %{ %}
 4678   interface(CONST_INTER);
 4679 %}
 4680 
<span class="line-added"> 4681 // Double Immediate: +0.0d.</span>
<span class="line-added"> 4682 operand immD_0() %{</span>
<span class="line-added"> 4683   predicate(jlong_cast(n-&gt;getd()) == 0);</span>
<span class="line-added"> 4684   match(ConD);</span>
<span class="line-added"> 4685 </span>
<span class="line-added"> 4686   op_cost(0);</span>
<span class="line-added"> 4687   format %{ %}</span>
<span class="line-added"> 4688   interface(CONST_INTER);</span>
<span class="line-added"> 4689 %}</span>
<span class="line-added"> 4690 </span>
 4691 // Integer Register Operands
 4692 // Integer Destination Register
 4693 // See definition of reg_class bits32_reg_rw.
 4694 operand iRegIdst() %{
 4695   constraint(ALLOC_IN_RC(bits32_reg_rw));
 4696   match(RegI);
 4697   match(rscratch1RegI);
 4698   match(rscratch2RegI);
 4699   match(rarg1RegI);
 4700   match(rarg2RegI);
 4701   match(rarg3RegI);
 4702   match(rarg4RegI);
 4703   format %{ %}
 4704   interface(REG_INTER);
 4705 %}
 4706 
 4707 // Integer Source Register
 4708 // See definition of reg_class bits32_reg_ro.
 4709 operand iRegIsrc() %{
 4710   constraint(ALLOC_IN_RC(bits32_reg_ro));
</pre>
<hr />
<pre>
 5018   interface(REG_INTER);
 5019 %}
 5020 
 5021 operand compiler_method_oop_regP(iRegPdst reg) %{
 5022   constraint(ALLOC_IN_RC(rscratch1_bits64_reg)); // compiler_method_oop_reg
 5023   match(reg);
 5024   format %{ %}
 5025   interface(REG_INTER);
 5026 %}
 5027 
 5028 operand interpreter_method_oop_regP(iRegPdst reg) %{
 5029   constraint(ALLOC_IN_RC(r19_bits64_reg)); // interpreter_method_oop_reg
 5030   match(reg);
 5031   format %{ %}
 5032   interface(REG_INTER);
 5033 %}
 5034 
 5035 // Operands to remove register moves in unscaled mode.
 5036 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 5037 operand iRegP2N(iRegPsrc reg) %{
<span class="line-modified"> 5038   predicate(false /* TODO: PPC port MatchDecodeNodes*/&amp;&amp; CompressedOops::shift() == 0);</span>
 5039   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5040   match(EncodeP reg);
 5041   format %{ &quot;$reg&quot; %}
 5042   interface(REG_INTER)
 5043 %}
 5044 
 5045 operand iRegN2P(iRegNsrc reg) %{
 5046   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5047   constraint(ALLOC_IN_RC(bits32_reg_ro));
 5048   match(DecodeN reg);
 5049   format %{ &quot;$reg&quot; %}
 5050   interface(REG_INTER)
 5051 %}
 5052 
 5053 operand iRegN2P_klass(iRegNsrc reg) %{
<span class="line-modified"> 5054   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);</span>
 5055   constraint(ALLOC_IN_RC(bits32_reg_ro));
 5056   match(DecodeNKlass reg);
 5057   format %{ &quot;$reg&quot; %}
 5058   interface(REG_INTER)
 5059 %}
 5060 
 5061 //----------Complex Operands---------------------------------------------------
 5062 // Indirect Memory Reference
 5063 operand indirect(iRegPsrc reg) %{
 5064   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5065   match(reg);
 5066   op_cost(100);
 5067   format %{ &quot;[$reg]&quot; %}
 5068   interface(MEMORY_INTER) %{
 5069     base($reg);
 5070     index(0x0);
 5071     scale(0x0);
 5072     disp(0x0);
 5073   %}
 5074 %}
</pre>
<hr />
<pre>
 5103 
 5104 //----------Complex Operands for Compressed OOPs-------------------------------
 5105 // Compressed OOPs with narrow_oop_shift == 0.
 5106 
 5107 // Indirect Memory Reference, compressed OOP
 5108 operand indirectNarrow(iRegNsrc reg) %{
 5109   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5110   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5111   match(DecodeN reg);
 5112   op_cost(100);
 5113   format %{ &quot;[$reg]&quot; %}
 5114   interface(MEMORY_INTER) %{
 5115     base($reg);
 5116     index(0x0);
 5117     scale(0x0);
 5118     disp(0x0);
 5119   %}
 5120 %}
 5121 
 5122 operand indirectNarrow_klass(iRegNsrc reg) %{
<span class="line-modified"> 5123   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);</span>
 5124   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5125   match(DecodeNKlass reg);
 5126   op_cost(100);
 5127   format %{ &quot;[$reg]&quot; %}
 5128   interface(MEMORY_INTER) %{
 5129     base($reg);
 5130     index(0x0);
 5131     scale(0x0);
 5132     disp(0x0);
 5133   %}
 5134 %}
 5135 
 5136 // Indirect with Offset, compressed OOP
 5137 operand indOffset16Narrow(iRegNsrc reg, immL16 offset) %{
 5138   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5139   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5140   match(AddP (DecodeN reg) offset);
 5141   op_cost(100);
 5142   format %{ &quot;[$reg + $offset]&quot; %}
 5143   interface(MEMORY_INTER) %{
 5144     base($reg);
 5145     index(0x0);
 5146     scale(0x0);
 5147     disp($offset);
 5148   %}
 5149 %}
 5150 
 5151 operand indOffset16Narrow_klass(iRegNsrc reg, immL16 offset) %{
<span class="line-modified"> 5152   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);</span>
 5153   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5154   match(AddP (DecodeNKlass reg) offset);
 5155   op_cost(100);
 5156   format %{ &quot;[$reg + $offset]&quot; %}
 5157   interface(MEMORY_INTER) %{
 5158     base($reg);
 5159     index(0x0);
 5160     scale(0x0);
 5161     disp($offset);
 5162   %}
 5163 %}
 5164 
 5165 // Indirect with 4-aligned Offset, compressed OOP
 5166 operand indOffset16NarrowAlg4(iRegNsrc reg, immL16Alg4 offset) %{
 5167   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5168   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5169   match(AddP (DecodeN reg) offset);
 5170   op_cost(100);
 5171   format %{ &quot;[$reg + $offset]&quot; %}
 5172   interface(MEMORY_INTER) %{
 5173     base($reg);
 5174     index(0x0);
 5175     scale(0x0);
 5176     disp($offset);
 5177   %}
 5178 %}
 5179 
 5180 operand indOffset16NarrowAlg4_klass(iRegNsrc reg, immL16Alg4 offset) %{
<span class="line-modified"> 5181   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);</span>
 5182   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5183   match(AddP (DecodeNKlass reg) offset);
 5184   op_cost(100);
 5185   format %{ &quot;[$reg + $offset]&quot; %}
 5186   interface(MEMORY_INTER) %{
 5187     base($reg);
 5188     index(0x0);
 5189     scale(0x0);
 5190     disp($offset);
 5191   %}
 5192 %}
 5193 
 5194 //----------Special Memory Operands--------------------------------------------
 5195 // Stack Slot Operand
 5196 //
 5197 // This operand is used for loading and storing temporary values on
 5198 // the stack where a match requires a value to flow through memory.
 5199 operand stackSlotI(sRegI reg) %{
 5200   constraint(ALLOC_IN_RC(stack_slots));
 5201   op_cost(100);
</pre>
<hr />
<pre>
 5890   ins_encode( enc_lwz(dst, mem) );
 5891   ins_pipe(pipe_class_memory);
 5892 %}
 5893 
 5894 // Load Compressed Pointer acquire.
 5895 instruct loadN_ac(iRegNdst dst, memory mem) %{
 5896   match(Set dst (LoadN mem));
 5897   ins_cost(3*MEMORY_REF_COST);
 5898 
 5899   format %{ &quot;LWZ     $dst, $mem \t// load acquire compressed ptr\n\t&quot;
 5900             &quot;TWI     $dst\n\t&quot;
 5901             &quot;ISYNC&quot; %}
 5902   size(12);
 5903   ins_encode( enc_lwz_ac(dst, mem) );
 5904   ins_pipe(pipe_class_memory);
 5905 %}
 5906 
 5907 // Load Compressed Pointer and decode it if narrow_oop_shift == 0.
 5908 instruct loadN2P_unscaled(iRegPdst dst, memory mem) %{
 5909   match(Set dst (DecodeN (LoadN mem)));
<span class="line-modified"> 5910   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() &amp;&amp; CompressedOops::shift() == 0);</span>
 5911   ins_cost(MEMORY_REF_COST);
 5912 
 5913   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5914   size(4);
 5915   ins_encode( enc_lwz(dst, mem) );
 5916   ins_pipe(pipe_class_memory);
 5917 %}
 5918 
 5919 instruct loadN2P_klass_unscaled(iRegPdst dst, memory mem) %{
 5920   match(Set dst (DecodeNKlass (LoadNKlass mem)));
<span class="line-modified"> 5921   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0 &amp;&amp;</span>
 5922             _kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5923   ins_cost(MEMORY_REF_COST);
 5924 
 5925   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5926   size(4);
 5927   ins_encode( enc_lwz(dst, mem) );
 5928   ins_pipe(pipe_class_memory);
 5929 %}
 5930 
 5931 // Load Pointer
 5932 instruct loadP(iRegPdst dst, memoryAlg4 mem) %{
 5933   match(Set dst (LoadP mem));
 5934   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5935   ins_cost(MEMORY_REF_COST);
 5936 
 5937   format %{ &quot;LD      $dst, $mem \t// ptr&quot; %}
 5938   size(4);
 5939   ins_encode( enc_ld(dst, mem) );
 5940   ins_pipe(pipe_class_memory);
 5941 %}
</pre>
<hr />
<pre>
 6367   effect(DEF dst, USE src);
 6368   predicate(false);
 6369 
 6370   format %{ &quot;MASK    $dst, $src, 0xFFFFFFFF&quot; %} // mask
 6371   size(4);
 6372   ins_encode %{
 6373     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6374     __ clrldi($dst$$Register, $src$$Register, 0x20);
 6375   %}
 6376   ins_pipe(pipe_class_default);
 6377 %}
 6378 
 6379 // Optimize DecodeN for disjoint base.
 6380 // Load base of compressed oops into a register
 6381 instruct loadBase(iRegLdst dst) %{
 6382   effect(DEF dst);
 6383 
 6384   format %{ &quot;LoadConst $dst, heapbase&quot; %}
 6385   ins_encode %{
 6386     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="line-modified"> 6387     __ load_const_optimized($dst$$Register, CompressedOops::base(), R0);</span>
 6388   %}
 6389   ins_pipe(pipe_class_default);
 6390 %}
 6391 
 6392 // Loading ConN must be postalloc expanded so that edges between
 6393 // the nodes are safe. They may not interfere with a safepoint.
 6394 // GL TODO: This needs three instructions: better put this into the constant pool.
 6395 instruct loadConN_Ex(iRegNdst dst, immN src) %{
 6396   match(Set dst src);
 6397   ins_cost(DEFAULT_COST*2);
 6398 
 6399   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6400   postalloc_expand %{
 6401     MachNode *m1 = new loadConN_hiNode();
 6402     MachNode *m2 = new loadConN_loNode();
 6403     MachNode *m3 = new clearMs32bNode();
 6404     m1-&gt;add_req(NULL);
 6405     m2-&gt;add_req(NULL, m1);
 6406     m3-&gt;add_req(NULL, m2);
 6407     m1-&gt;_opnds[0] = op_dst;
</pre>
<hr />
<pre>
 6415     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6416     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6417     nodes-&gt;push(m1);
 6418     nodes-&gt;push(m2);
 6419     nodes-&gt;push(m3);
 6420   %}
 6421 %}
 6422 
 6423 // We have seen a safepoint between the hi and lo parts, and this node was handled
 6424 // as an oop. Therefore this needs a match rule so that build_oop_map knows this is
 6425 // not a narrow oop.
 6426 instruct loadConNKlass_hi(iRegNdst dst, immNKlass_NM src) %{
 6427   match(Set dst src);
 6428   effect(DEF dst, USE src);
 6429   ins_cost(DEFAULT_COST);
 6430 
 6431   format %{ &quot;LIS     $dst, $src \t// narrow klass hi&quot; %}
 6432   size(4);
 6433   ins_encode %{
 6434     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
<span class="line-modified"> 6435     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src$$constant);</span>
 6436     __ lis($dst$$Register, (int)(short)((Csrc &gt;&gt; 16) &amp; 0xffff));
 6437   %}
 6438   ins_pipe(pipe_class_default);
 6439 %}
 6440 
 6441 // As loadConNKlass_hi this must be recognized as narrow klass, not oop!
 6442 instruct loadConNKlass_mask(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6443   match(Set dst src1);
 6444   effect(TEMP src2);
 6445   ins_cost(DEFAULT_COST);
 6446 
 6447   format %{ &quot;MASK    $dst, $src2, 0xFFFFFFFF&quot; %} // mask
 6448   size(4);
 6449   ins_encode %{
 6450     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6451     __ clrldi($dst$$Register, $src2$$Register, 0x20);
 6452   %}
 6453   ins_pipe(pipe_class_default);
 6454 %}
 6455 
 6456 // This needs a match rule so that build_oop_map knows this is
 6457 // not a narrow oop.
 6458 instruct loadConNKlass_lo(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6459   match(Set dst src1);
 6460   effect(TEMP src2);
 6461   ins_cost(DEFAULT_COST);
 6462 
 6463   format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow klass lo&quot; %}
 6464   size(4);
 6465   ins_encode %{
 6466     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
<span class="line-modified"> 6467     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src1$$constant);</span>
 6468     assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 6469     int klass_index = __ oop_recorder()-&gt;find_index((Klass *)$src1$$constant);
 6470     RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 6471 
 6472     __ relocate(rspec, 1);
 6473     __ ori($dst$$Register, $src2$$Register, Csrc &amp; 0xffff);
 6474   %}
 6475   ins_pipe(pipe_class_default);
 6476 %}
 6477 
 6478 // Loading ConNKlass must be postalloc expanded so that edges between
 6479 // the nodes are safe. They may not interfere with a safepoint.
 6480 instruct loadConNKlass_Ex(iRegNdst dst, immNKlass src) %{
 6481   match(Set dst src);
 6482   ins_cost(DEFAULT_COST*2);
 6483 
 6484   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6485   postalloc_expand %{
 6486     // Load high bits into register. Sign extended.
 6487     MachNode *m1 = new loadConNKlass_hiNode();
 6488     m1-&gt;add_req(NULL);
 6489     m1-&gt;_opnds[0] = op_dst;
 6490     m1-&gt;_opnds[1] = op_src;
 6491     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6492     nodes-&gt;push(m1);
 6493 
 6494     MachNode *m2 = m1;
<span class="line-modified"> 6495     if (!Assembler::is_uimm((jlong)CompressedKlassPointers::encode((Klass *)op_src-&gt;constant()), 31)) {</span>
 6496       // Value might be 1-extended. Mask out these bits.
 6497       m2 = new loadConNKlass_maskNode();
 6498       m2-&gt;add_req(NULL, m1);
 6499       m2-&gt;_opnds[0] = op_dst;
 6500       m2-&gt;_opnds[1] = op_src;
 6501       m2-&gt;_opnds[2] = op_dst;
 6502       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6503       nodes-&gt;push(m2);
 6504     }
 6505 
 6506     MachNode *m3 = new loadConNKlass_loNode();
 6507     m3-&gt;add_req(NULL, m2);
 6508     m3-&gt;_opnds[0] = op_dst;
 6509     m3-&gt;_opnds[1] = op_src;
 6510     m3-&gt;_opnds[2] = op_dst;
 6511     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6512     nodes-&gt;push(m3);
 6513   %}
 6514 %}
 6515 
</pre>
<hr />
<pre>
 6937 
 6938 // Card-mark for CMS garbage collection.
 6939 // This cardmark does an optimization so that it must not always
 6940 // do a releasing store. For this, it gets the address of
 6941 // CMSCollectorCardTableBarrierSetBSExt::_requires_release as input.
 6942 // (Using releaseFieldAddr in the match rule is a hack.)
 6943 instruct storeCM_CMS(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
 6944   match(Set mem (StoreCM mem releaseFieldAddr));
 6945   effect(TEMP crx);
 6946   predicate(false);
 6947   ins_cost(MEMORY_REF_COST);
 6948 
 6949   // See loadConP.
 6950   ins_cannot_rematerialize(true);
 6951 
 6952   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte (must be 0!), checking requires_release in [$releaseFieldAddr]&quot; %}
 6953   ins_encode( enc_cms_card_mark(mem, releaseFieldAddr, crx) );
 6954   ins_pipe(pipe_class_memory);
 6955 %}
 6956 



















 6957 instruct storeCM_G1(memory mem, immI_0 zero) %{
 6958   match(Set mem (StoreCM mem zero));
 6959   predicate(UseG1GC);
 6960   ins_cost(MEMORY_REF_COST);
 6961 
 6962   ins_cannot_rematerialize(true);
 6963 
 6964   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte store (G1)&quot; %}
 6965   size(8);
 6966   ins_encode %{
 6967     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6968     __ li(R0, 0);
 6969     //__ release(); // G1: oops are allowed to get visible after dirty marking
 6970     guarantee($mem$$base$$Register != R1_SP, &quot;use frame_slots_bias&quot;);
 6971     __ stb(R0, $mem$$disp, $mem$$base$$Register);
 6972   %}
 6973   ins_pipe(pipe_class_memory);
 6974 %}
 6975 
 6976 // Convert oop pointer into compressed form.
 6977 
 6978 // Nodes for postalloc expand.
 6979 
 6980 // Shift node for expand.
 6981 instruct encodeP_shift(iRegNdst dst, iRegNsrc src) %{
 6982   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6983   match(Set dst (EncodeP src));
 6984   predicate(false);
 6985 
 6986   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 6987   size(4);
 6988   ins_encode %{
 6989     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified"> 6990     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);</span>
 6991   %}
 6992   ins_pipe(pipe_class_default);
 6993 %}
 6994 
 6995 // Add node for expand.
 6996 instruct encodeP_sub(iRegPdst dst, iRegPdst src) %{
 6997   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6998   match(Set dst (EncodeP src));
 6999   predicate(false);
 7000 
 7001   format %{ &quot;SUB     $dst, $src, oop_base \t// encode&quot; %}
 7002   ins_encode %{
 7003     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="line-modified"> 7004     __ sub_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);</span>
 7005   %}
 7006   ins_pipe(pipe_class_default);
 7007 %}
 7008 
 7009 // Conditional sub base.
 7010 instruct cond_sub_base(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7011   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7012   match(Set dst (EncodeP (Binary crx src1)));
 7013   predicate(false);
 7014 
 7015   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7016             &quot;SUB     $dst, $src1, heapbase \t// encode: subtract base if != NULL\n&quot;
 7017             &quot;done:&quot; %}
 7018   ins_encode %{
 7019     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7020     Label done;
 7021     __ beq($crx$$CondRegister, done);
<span class="line-modified"> 7022     __ sub_const_optimized($dst$$Register, $src1$$Register, CompressedOops::base(), R0);</span>
 7023     __ bind(done);
 7024   %}
 7025   ins_pipe(pipe_class_default);
 7026 %}
 7027 
 7028 // Power 7 can use isel instruction
 7029 instruct cond_set_0_oop(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7030   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7031   match(Set dst (EncodeP (Binary crx src1)));
 7032   predicate(false);
 7033 
 7034   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// encode: preserve 0&quot; %}
 7035   size(4);
 7036   ins_encode %{
 7037     // This is a Power7 instruction for which no machine description exists.
 7038     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7039     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7040   %}
 7041   ins_pipe(pipe_class_default);
 7042 %}
 7043 
 7044 // Disjoint narrow oop base.
 7045 instruct encodeP_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7046   match(Set dst (EncodeP src));
<span class="line-modified"> 7047   predicate(CompressedOops::base_disjoint());</span>
 7048 
 7049   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7050   size(4);
 7051   ins_encode %{
 7052     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified"> 7053     __ rldicl($dst$$Register, $src$$Register, 64-CompressedOops::shift(), 32);</span>
 7054   %}
 7055   ins_pipe(pipe_class_default);
 7056 %}
 7057 
 7058 // shift != 0, base != 0
 7059 instruct encodeP_Ex(iRegNdst dst, flagsReg crx, iRegPsrc src) %{
 7060   match(Set dst (EncodeP src));
 7061   effect(TEMP crx);
 7062   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
<span class="line-modified"> 7063             CompressedOops::shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7064             CompressedOops::base_overlaps());</span>
 7065 
 7066   format %{ &quot;EncodeP $dst, $crx, $src \t// postalloc expanded&quot; %}
 7067   postalloc_expand( postalloc_expand_encode_oop(dst, src, crx));
 7068 %}
 7069 
 7070 // shift != 0, base != 0
 7071 instruct encodeP_not_null_Ex(iRegNdst dst, iRegPsrc src) %{
 7072   match(Set dst (EncodeP src));
 7073   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull &amp;&amp;
<span class="line-modified"> 7074             CompressedOops::shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7075             CompressedOops::base_overlaps());</span>
 7076 
 7077   format %{ &quot;EncodeP $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7078   postalloc_expand( postalloc_expand_encode_oop_not_null(dst, src) );
 7079 %}
 7080 
 7081 // shift != 0, base == 0
 7082 // TODO: This is the same as encodeP_shift. Merge!
 7083 instruct encodeP_not_null_base_null(iRegNdst dst, iRegPsrc src) %{
 7084   match(Set dst (EncodeP src));
<span class="line-modified"> 7085   predicate(CompressedOops::shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7086             CompressedOops::base() ==0);</span>
 7087 
 7088   format %{ &quot;SRDI    $dst, $src, #3 \t// encodeP, $src != NULL&quot; %}
 7089   size(4);
 7090   ins_encode %{
 7091     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified"> 7092     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);</span>
 7093   %}
 7094   ins_pipe(pipe_class_default);
 7095 %}
 7096 
 7097 // Compressed OOPs with narrow_oop_shift == 0.
 7098 // shift == 0, base == 0
 7099 instruct encodeP_narrow_oop_shift_0(iRegNdst dst, iRegPsrc src) %{
 7100   match(Set dst (EncodeP src));
<span class="line-modified"> 7101   predicate(CompressedOops::shift() == 0);</span>
 7102 
 7103   format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Narrow&quot; %}
 7104   // variable size, 0 or 4.
 7105   ins_encode %{
 7106     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7107     __ mr_if_needed($dst$$Register, $src$$Register);
 7108   %}
 7109   ins_pipe(pipe_class_default);
 7110 %}
 7111 
 7112 // Decode nodes.
 7113 
 7114 // Shift node for expand.
 7115 instruct decodeN_shift(iRegPdst dst, iRegPsrc src) %{
 7116   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7117   match(Set dst (DecodeN src));
 7118   predicate(false);
 7119 
 7120   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN&quot; %}
 7121   size(4);
 7122   ins_encode %{
 7123     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
<span class="line-modified"> 7124     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());</span>
 7125   %}
 7126   ins_pipe(pipe_class_default);
 7127 %}
 7128 
 7129 // Add node for expand.
 7130 instruct decodeN_add(iRegPdst dst, iRegPdst src) %{
 7131   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7132   match(Set dst (DecodeN src));
 7133   predicate(false);
 7134 
 7135   format %{ &quot;ADD     $dst, $src, heapbase \t// DecodeN, add oop base&quot; %}
 7136   ins_encode %{
 7137     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="line-modified"> 7138     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);</span>
 7139   %}
 7140   ins_pipe(pipe_class_default);
 7141 %}
 7142 
 7143 // conditianal add base for expand
 7144 instruct cond_add_base(iRegPdst dst, flagsRegSrc crx, iRegPsrc src) %{
 7145   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7146   // NOTICE that the rule is nonsense - we just have to make sure that:
 7147   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7148   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7149   match(Set dst (DecodeN (Binary crx src)));
 7150   predicate(false);
 7151 
 7152   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7153             &quot;ADD     $dst, $src, heapbase \t// DecodeN: add oop base if $src != NULL\n&quot;
 7154             &quot;done:&quot; %}
 7155   ins_encode %{
 7156     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7157     Label done;
 7158     __ beq($crx$$CondRegister, done);
<span class="line-modified"> 7159     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);</span>
 7160     __ bind(done);
 7161   %}
 7162   ins_pipe(pipe_class_default);
 7163 %}
 7164 
 7165 instruct cond_set_0_ptr(iRegPdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7166   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7167   // NOTICE that the rule is nonsense - we just have to make sure that:
 7168   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7169   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7170   match(Set dst (DecodeN (Binary crx src1)));
 7171   predicate(false);
 7172 
 7173   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// decode: preserve 0&quot; %}
 7174   size(4);
 7175   ins_encode %{
 7176     // This is a Power7 instruction for which no machine description exists.
 7177     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7178     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7179   %}
 7180   ins_pipe(pipe_class_default);
 7181 %}
 7182 
 7183 //  shift != 0, base != 0
 7184 instruct decodeN_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7185   match(Set dst (DecodeN src));
 7186   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7187              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
<span class="line-modified"> 7188             CompressedOops::shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7189             CompressedOops::base() != 0);</span>
 7190   ins_cost(4 * DEFAULT_COST); // Should be more expensive than decodeN_Disjoint_isel_Ex.
 7191   effect(TEMP crx);
 7192 
 7193   format %{ &quot;DecodeN $dst, $src \t// Kills $crx, postalloc expanded&quot; %}
 7194   postalloc_expand( postalloc_expand_decode_oop(dst, src, crx) );
 7195 %}
 7196 
 7197 // shift != 0, base == 0
 7198 instruct decodeN_nullBase(iRegPdst dst, iRegNsrc src) %{
 7199   match(Set dst (DecodeN src));
<span class="line-modified"> 7200   predicate(CompressedOops::shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7201             CompressedOops::base() == 0);</span>
 7202 
 7203   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN (zerobased)&quot; %}
 7204   size(4);
 7205   ins_encode %{
 7206     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
<span class="line-modified"> 7207     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());</span>
 7208   %}
 7209   ins_pipe(pipe_class_default);
 7210 %}
 7211 
 7212 // Optimize DecodeN for disjoint base.
 7213 // Shift narrow oop and or it into register that already contains the heap base.
 7214 // Base == dst must hold, and is assured by construction in postaloc_expand.
 7215 instruct decodeN_mergeDisjoint(iRegPdst dst, iRegNsrc src, iRegLsrc base) %{
 7216   match(Set dst (DecodeN src));
 7217   effect(TEMP base);
 7218   predicate(false);
 7219 
 7220   format %{ &quot;RLDIMI  $dst, $src, shift, 32-shift \t// DecodeN (disjoint base)&quot; %}
 7221   size(4);
 7222   ins_encode %{
 7223     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
<span class="line-modified"> 7224     __ rldimi($dst$$Register, $src$$Register, CompressedOops::shift(), 32-CompressedOops::shift());</span>
 7225   %}
 7226   ins_pipe(pipe_class_default);
 7227 %}
 7228 
 7229 // Optimize DecodeN for disjoint base.
 7230 // This node requires only one cycle on the critical path.
 7231 // We must postalloc_expand as we can not express use_def effects where
 7232 // the used register is L and the def&#39;ed register P.
 7233 instruct decodeN_Disjoint_notNull_Ex(iRegPdst dst, iRegNsrc src) %{
 7234   match(Set dst (DecodeN src));
 7235   effect(TEMP_DEF dst);
 7236   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7237              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified"> 7238             CompressedOops::base_disjoint());</span>
 7239   ins_cost(DEFAULT_COST);
 7240 
 7241   format %{ &quot;MOV     $dst, heapbase \t\n&quot;
 7242             &quot;RLDIMI  $dst, $src, shift, 32-shift \t// decode with disjoint base&quot; %}
 7243   postalloc_expand %{
 7244     loadBaseNode *n1 = new loadBaseNode();
 7245     n1-&gt;add_req(NULL);
 7246     n1-&gt;_opnds[0] = op_dst;
 7247 
 7248     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7249     n2-&gt;add_req(n_region, n_src, n1);
 7250     n2-&gt;_opnds[0] = op_dst;
 7251     n2-&gt;_opnds[1] = op_src;
 7252     n2-&gt;_opnds[2] = op_dst;
 7253     n2-&gt;_bottom_type = _bottom_type;
 7254 
 7255     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7256     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7257 
 7258     nodes-&gt;push(n1);
 7259     nodes-&gt;push(n2);
 7260   %}
 7261 %}
 7262 
 7263 instruct decodeN_Disjoint_isel_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7264   match(Set dst (DecodeN src));
 7265   effect(TEMP_DEF dst, TEMP crx);
 7266   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7267              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
<span class="line-modified"> 7268             CompressedOops::base_disjoint() &amp;&amp; VM_Version::has_isel());</span>
 7269   ins_cost(3 * DEFAULT_COST);
 7270 
 7271   format %{ &quot;DecodeN  $dst, $src \t// decode with disjoint base using isel&quot; %}
 7272   postalloc_expand %{
 7273     loadBaseNode *n1 = new loadBaseNode();
 7274     n1-&gt;add_req(NULL);
 7275     n1-&gt;_opnds[0] = op_dst;
 7276 
 7277     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
 7278     n_compare-&gt;add_req(n_region, n_src);
 7279     n_compare-&gt;_opnds[0] = op_crx;
 7280     n_compare-&gt;_opnds[1] = op_src;
 7281     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
 7282 
 7283     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7284     n2-&gt;add_req(n_region, n_src, n1);
 7285     n2-&gt;_opnds[0] = op_dst;
 7286     n2-&gt;_opnds[1] = op_src;
 7287     n2-&gt;_opnds[2] = op_dst;
 7288     n2-&gt;_bottom_type = _bottom_type;
</pre>
<hr />
<pre>
 7297     assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 7298     ra_-&gt;set_oop(n_cond_set, true);
 7299 
 7300     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7301     ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 7302     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7303     ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7304 
 7305     nodes-&gt;push(n1);
 7306     nodes-&gt;push(n_compare);
 7307     nodes-&gt;push(n2);
 7308     nodes-&gt;push(n_cond_set);
 7309   %}
 7310 %}
 7311 
 7312 // src != 0, shift != 0, base != 0
 7313 instruct decodeN_notNull_addBase_Ex(iRegPdst dst, iRegNsrc src) %{
 7314   match(Set dst (DecodeN src));
 7315   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7316              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified"> 7317             CompressedOops::shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7318             CompressedOops::base() != 0);</span>
 7319   ins_cost(2 * DEFAULT_COST);
 7320 
 7321   format %{ &quot;DecodeN $dst, $src \t// $src != NULL, postalloc expanded&quot; %}
 7322   postalloc_expand( postalloc_expand_decode_oop_not_null(dst, src));
 7323 %}
 7324 
 7325 // Compressed OOPs with narrow_oop_shift == 0.
 7326 instruct decodeN_unscaled(iRegPdst dst, iRegNsrc src) %{
 7327   match(Set dst (DecodeN src));
<span class="line-modified"> 7328   predicate(CompressedOops::shift() == 0);</span>
 7329   ins_cost(DEFAULT_COST);
 7330 
 7331   format %{ &quot;MR      $dst, $src \t// DecodeN (unscaled)&quot; %}
 7332   // variable size, 0 or 4.
 7333   ins_encode %{
 7334     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7335     __ mr_if_needed($dst$$Register, $src$$Register);
 7336   %}
 7337   ins_pipe(pipe_class_default);
 7338 %}
 7339 
 7340 // Convert compressed oop into int for vectors alignment masking.
 7341 instruct decodeN2I_unscaled(iRegIdst dst, iRegNsrc src) %{
 7342   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
<span class="line-modified"> 7343   predicate(CompressedOops::shift() == 0);</span>
 7344   ins_cost(DEFAULT_COST);
 7345 
 7346   format %{ &quot;MR      $dst, $src \t// (int)DecodeN (unscaled)&quot; %}
 7347   // variable size, 0 or 4.
 7348   ins_encode %{
 7349     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7350     __ mr_if_needed($dst$$Register, $src$$Register);
 7351   %}
 7352   ins_pipe(pipe_class_default);
 7353 %}
 7354 
 7355 // Convert klass pointer into compressed form.
 7356 
 7357 // Nodes for postalloc expand.
 7358 
 7359 // Shift node for expand.
 7360 instruct encodePKlass_shift(iRegNdst dst, iRegNsrc src) %{
 7361   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7362   match(Set dst (EncodePKlass src));
 7363   predicate(false);
 7364 
 7365   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 7366   size(4);
 7367   ins_encode %{
 7368     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified"> 7369     __ srdi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());</span>
 7370   %}
 7371   ins_pipe(pipe_class_default);
 7372 %}
 7373 
 7374 // Add node for expand.
 7375 instruct encodePKlass_sub_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7376   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7377   match(Set dst (EncodePKlass (Binary base src)));
 7378   predicate(false);
 7379 
 7380   format %{ &quot;SUB     $dst, $base, $src \t// encode&quot; %}
 7381   size(4);
 7382   ins_encode %{
 7383     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 7384     __ subf($dst$$Register, $base$$Register, $src$$Register);
 7385   %}
 7386   ins_pipe(pipe_class_default);
 7387 %}
 7388 
 7389 // Disjoint narrow oop base.
 7390 instruct encodePKlass_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7391   match(Set dst (EncodePKlass src));
<span class="line-modified"> 7392   predicate(false /* TODO: PPC port CompressedKlassPointers::base_disjoint()*/);</span>
 7393 
 7394   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7395   size(4);
 7396   ins_encode %{
 7397     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
<span class="line-modified"> 7398     __ rldicl($dst$$Register, $src$$Register, 64-CompressedKlassPointers::shift(), 32);</span>
 7399   %}
 7400   ins_pipe(pipe_class_default);
 7401 %}
 7402 
 7403 // shift != 0, base != 0
 7404 instruct encodePKlass_not_null_Ex(iRegNdst dst, iRegLsrc base, iRegPsrc src) %{
 7405   match(Set dst (EncodePKlass (Binary base src)));
 7406   predicate(false);
 7407 
 7408   format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7409   postalloc_expand %{
 7410     encodePKlass_sub_baseNode *n1 = new encodePKlass_sub_baseNode();
 7411     n1-&gt;add_req(n_region, n_base, n_src);
 7412     n1-&gt;_opnds[0] = op_dst;
 7413     n1-&gt;_opnds[1] = op_base;
 7414     n1-&gt;_opnds[2] = op_src;
 7415     n1-&gt;_bottom_type = _bottom_type;
 7416 
 7417     encodePKlass_shiftNode *n2 = new encodePKlass_shiftNode();
 7418     n2-&gt;add_req(n_region, n1);
 7419     n2-&gt;_opnds[0] = op_dst;
 7420     n2-&gt;_opnds[1] = op_dst;
 7421     n2-&gt;_bottom_type = _bottom_type;
 7422     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7423     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7424 
 7425     nodes-&gt;push(n1);
 7426     nodes-&gt;push(n2);
 7427   %}
 7428 %}
 7429 
 7430 // shift != 0, base != 0
 7431 instruct encodePKlass_not_null_ExEx(iRegNdst dst, iRegPsrc src) %{
 7432   match(Set dst (EncodePKlass src));
<span class="line-modified"> 7433   //predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7434   //          true /* TODO: PPC port CompressedKlassPointers::base_overlaps()*/);</span>
 7435 
 7436   //format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7437   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7438   expand %{
<span class="line-modified"> 7439     immL baseImm %{ (jlong)(intptr_t)CompressedKlassPointers::base() %}</span>
 7440     iRegLdst base;
 7441     loadConL_Ex(base, baseImm);
 7442     encodePKlass_not_null_Ex(dst, base, src);
 7443   %}
 7444 %}
 7445 
 7446 // Decode nodes.
 7447 
 7448 // Shift node for expand.
 7449 instruct decodeNKlass_shift(iRegPdst dst, iRegPsrc src) %{
 7450   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7451   match(Set dst (DecodeNKlass src));
 7452   predicate(false);
 7453 
 7454   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeNKlass&quot; %}
 7455   size(4);
 7456   ins_encode %{
 7457     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
<span class="line-modified"> 7458     __ sldi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());</span>
 7459   %}
 7460   ins_pipe(pipe_class_default);
 7461 %}
 7462 
 7463 // Add node for expand.
 7464 
 7465 instruct decodeNKlass_add_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7466   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7467   match(Set dst (DecodeNKlass (Binary base src)));
 7468   predicate(false);
 7469 
 7470   format %{ &quot;ADD     $dst, $base, $src \t// DecodeNKlass, add klass base&quot; %}
 7471   size(4);
 7472   ins_encode %{
 7473     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 7474     __ add($dst$$Register, $base$$Register, $src$$Register);
 7475   %}
 7476   ins_pipe(pipe_class_default);
 7477 %}
 7478 
</pre>
<hr />
<pre>
 7491     n1-&gt;_opnds[2] = op_src;
 7492     n1-&gt;_bottom_type = _bottom_type;
 7493 
 7494     decodeNKlass_shiftNode *n2 = new decodeNKlass_shiftNode();
 7495     n2-&gt;add_req(n_region, n1);
 7496     n2-&gt;_opnds[0] = op_dst;
 7497     n2-&gt;_opnds[1] = op_dst;
 7498     n2-&gt;_bottom_type = _bottom_type;
 7499 
 7500     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7501     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7502 
 7503     nodes-&gt;push(n1);
 7504     nodes-&gt;push(n2);
 7505   %}
 7506 %}
 7507 
 7508 // src != 0, shift != 0, base != 0
 7509 instruct decodeNKlass_notNull_addBase_ExEx(iRegPdst dst, iRegNsrc src) %{
 7510   match(Set dst (DecodeNKlass src));
<span class="line-modified"> 7511   // predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;</span>
<span class="line-modified"> 7512   //           CompressedKlassPointers::base() != 0);</span>
 7513 
 7514   //format %{ &quot;DecodeNKlass $dst, $src \t// $src != NULL, expanded&quot; %}
 7515 
 7516   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7517   expand %{
 7518     // We add first, then we shift. Like this, we can get along with one register less.
 7519     // But we have to load the base pre-shifted.
<span class="line-modified"> 7520     immL baseImm %{ (jlong)((intptr_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift()) %}</span>
 7521     iRegLdst base;
 7522     loadConL_Ex(base, baseImm);
 7523     decodeNKlass_notNull_addBase_Ex(dst, base, src);
 7524   %}
 7525 %}
 7526 
 7527 //----------MemBar Instructions-----------------------------------------------
 7528 // Memory barrier flavors
 7529 
 7530 instruct membar_acquire() %{
 7531   match(LoadFence);
 7532   ins_cost(4*MEMORY_REF_COST);
 7533 
 7534   format %{ &quot;MEMBAR-acquire&quot; %}
 7535   size(4);
 7536   ins_encode %{
 7537     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7538     __ acquire();
 7539   %}
 7540   ins_pipe(pipe_class_default);
</pre>
<hr />
<pre>
10860   %}
10861   ins_pipe(pipe_class_default);
10862 %}
10863 
10864 instruct castPP(iRegPdst dst) %{
10865   match(Set dst (CastPP dst));
10866   format %{ &quot; -- \t// castPP of $dst&quot; %}
10867   size(0);
10868   ins_encode( /*empty*/ );
10869   ins_pipe(pipe_class_default);
10870 %}
10871 
10872 instruct castII(iRegIdst dst) %{
10873   match(Set dst (CastII dst));
10874   format %{ &quot; -- \t// castII of $dst&quot; %}
10875   size(0);
10876   ins_encode( /*empty*/ );
10877   ins_pipe(pipe_class_default);
10878 %}
10879 
<span class="line-added">10880 instruct castLL(iRegLdst dst) %{</span>
<span class="line-added">10881   match(Set dst (CastLL dst));</span>
<span class="line-added">10882   format %{ &quot; -- \t// castLL of $dst&quot; %}</span>
<span class="line-added">10883   size(0);</span>
<span class="line-added">10884   ins_encode( /*empty*/ );</span>
<span class="line-added">10885   ins_pipe(pipe_class_default);</span>
<span class="line-added">10886 %}</span>
<span class="line-added">10887 </span>
10888 instruct checkCastPP(iRegPdst dst) %{
10889   match(Set dst (CheckCastPP dst));
10890   format %{ &quot; -- \t// checkcastPP of $dst&quot; %}
10891   size(0);
10892   ins_encode( /*empty*/ );
10893   ins_pipe(pipe_class_default);
10894 %}
10895 
10896 //----------Convert instructions-----------------------------------------------
10897 
10898 // Convert to boolean.
10899 
10900 // int_to_bool(src) : { 1   if src != 0
10901 //                    { 0   else
10902 //
10903 // strategy:
10904 // 1) Count leading zeros of 32 bit-value src,
10905 //    this returns 32 (0b10.0000) iff src == 0 and &lt;32 otherwise.
10906 // 2) Shift 5 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10907 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
</pre>
<hr />
<pre>
14038   size(4);
14039   ins_encode %{
14040     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14041   %}
14042   ins_pipe(pipe_class_default);
14043 %}
14044 
14045 instruct repl4S_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14046   match(Set dst (ReplicateS src));
14047   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14048   expand %{
14049     moveReg(dst, src);
14050     repl48(dst);
14051     repl32(dst);
14052   %}
14053 %}
14054 
14055 instruct repl4S_immI0(iRegLdst dst, immI_0 zero) %{
14056   match(Set dst (ReplicateS zero));
14057   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">14058   format %{ &quot;LI      $dst, #0 \t// replicate4S&quot; %}</span>
14059   size(4);
14060   ins_encode %{
14061     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14062     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14063   %}
14064   ins_pipe(pipe_class_default);
14065 %}
14066 
14067 instruct repl4S_immIminus1(iRegLdst dst, immI_minus1 src) %{
14068   match(Set dst (ReplicateS src));
14069   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">14070   format %{ &quot;LI      $dst, -1 \t// replicate4S&quot; %}</span>
14071   size(4);
14072   ins_encode %{
14073     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14074     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14075   %}
14076   ins_pipe(pipe_class_default);
14077 %}
14078 
14079 instruct repl8S_reg_Ex(vecX dst, iRegIsrc src) %{
14080   match(Set dst (ReplicateS src));
14081   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14082 
14083   expand %{
14084     iRegLdst tmpL;
14085     vecX tmpV;
14086     immI8  zero %{ (int)  0 %}
14087     moveReg(tmpL, src);
14088     repl48(tmpL);
14089     repl32(tmpL);
14090     mtvsrd(tmpV, tmpL);
14091     xxpermdi(dst, tmpV, tmpV, zero);
14092   %}
14093 %}
14094 
14095 instruct repl8S_immI0(vecX dst, immI_0 zero) %{
14096   match(Set dst (ReplicateS zero));
14097   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14098 
14099   format %{ &quot;XXLXOR      $dst, $zero \t// replicate8S&quot; %}
14100   size(4);
14101   ins_encode %{
14102     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14103   %}
14104   ins_pipe(pipe_class_default);
14105 %}
14106 
14107 instruct repl8S_immIminus1(vecX dst, immI_minus1 src) %{
14108   match(Set dst (ReplicateS src));
14109   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14110 
<span class="line-modified">14111   format %{ &quot;XXLEQV      $dst, $src \t// replicate8S&quot; %}</span>
14112   size(4);
14113   ins_encode %{
14114     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14115   %}
14116   ins_pipe(pipe_class_default);
14117 %}
14118 
14119 instruct repl2I_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14120   match(Set dst (ReplicateI src));
14121   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14122   ins_cost(2 * DEFAULT_COST);
14123   expand %{
14124     moveReg(dst, src);
14125     repl32(dst);
14126   %}
14127 %}
14128 
14129 instruct repl2I_immI0(iRegLdst dst, immI_0 zero) %{
14130   match(Set dst (ReplicateI zero));
14131   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">14132   format %{ &quot;LI      $dst, #0 \t// replicate2I&quot; %}</span>
14133   size(4);
14134   ins_encode %{
14135     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14136     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14137   %}
14138   ins_pipe(pipe_class_default);
14139 %}
14140 
14141 instruct repl2I_immIminus1(iRegLdst dst, immI_minus1 src) %{
14142   match(Set dst (ReplicateI src));
14143   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">14144   format %{ &quot;LI      $dst, -1 \t// replicate2I&quot; %}</span>
14145   size(4);
14146   ins_encode %{
14147     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14148     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14149   %}
14150   ins_pipe(pipe_class_default);
14151 %}
14152 
14153 instruct repl4I_reg_Ex(vecX dst, iRegIsrc src) %{
14154   match(Set dst (ReplicateI src));
14155   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14156   ins_cost(2 * DEFAULT_COST);
14157 
14158   expand %{
14159     iRegLdst tmpL;
14160     vecX tmpV;
14161     immI8  zero %{ (int)  0 %}
14162     moveReg(tmpL, src);
14163     repl32(tmpL);
14164     mtvsrd(tmpV, tmpL);
</pre>
<hr />
<pre>
14447   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14448   format %{ &quot;XVABSSP $dst,$src\t// absolute packed4F&quot; %}
14449   size(4);
14450   ins_encode %{
14451     __ xvabssp($dst$$VectorSRegister, $src$$VectorSRegister);
14452   %}
14453   ins_pipe(pipe_class_default);
14454 %}
14455 
14456 instruct vabs2D_reg(vecX dst, vecX src) %{
14457   match(Set dst (AbsVD src));
14458   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14459   format %{ &quot;XVABSDP $dst,$src\t// absolute packed2D&quot; %}
14460   size(4);
14461   ins_encode %{
14462     __ xvabsdp($dst$$VectorSRegister, $src$$VectorSRegister);
14463   %}
14464   ins_pipe(pipe_class_default);
14465 %}
14466 
<span class="line-added">14467 // Round Instructions</span>
<span class="line-added">14468 instruct roundD_reg(regD dst, regD src, immI8 rmode) %{</span>
<span class="line-added">14469   match(Set dst (RoundDoubleMode src rmode));</span>
<span class="line-added">14470   format %{ &quot;RoundDoubleMode $src,$rmode&quot; %}</span>
<span class="line-added">14471   size(4);</span>
<span class="line-added">14472   ins_encode %{</span>
<span class="line-added">14473     switch ($rmode$$constant) {</span>
<span class="line-added">14474       case RoundDoubleModeNode::rmode_rint:</span>
<span class="line-added">14475         __ frin($dst$$FloatRegister, $src$$FloatRegister);</span>
<span class="line-added">14476         break;</span>
<span class="line-added">14477       case RoundDoubleModeNode::rmode_floor:</span>
<span class="line-added">14478         __ frim($dst$$FloatRegister, $src$$FloatRegister);</span>
<span class="line-added">14479         break;</span>
<span class="line-added">14480       case RoundDoubleModeNode::rmode_ceil:</span>
<span class="line-added">14481         __ frip($dst$$FloatRegister, $src$$FloatRegister);</span>
<span class="line-added">14482         break;</span>
<span class="line-added">14483       default:</span>
<span class="line-added">14484         ShouldNotReachHere();</span>
<span class="line-added">14485     }</span>
<span class="line-added">14486   %}</span>
<span class="line-added">14487   ins_pipe(pipe_class_default);</span>
<span class="line-added">14488 %}</span>
<span class="line-added">14489 </span>
<span class="line-added">14490 // Vector Round Instructions</span>
<span class="line-added">14491 instruct vround2D_reg(vecX dst, vecX src, immI8 rmode) %{</span>
<span class="line-added">14492   match(Set dst (RoundDoubleModeV src rmode));</span>
<span class="line-added">14493   predicate(n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-added">14494   format %{ &quot;RoundDoubleModeV $src,$rmode&quot; %}</span>
<span class="line-added">14495   size(4);</span>
<span class="line-added">14496   ins_encode %{</span>
<span class="line-added">14497     switch ($rmode$$constant) {</span>
<span class="line-added">14498       case RoundDoubleModeNode::rmode_rint:</span>
<span class="line-added">14499         __ xvrdpi($dst$$VectorSRegister, $src$$VectorSRegister);</span>
<span class="line-added">14500         break;</span>
<span class="line-added">14501       case RoundDoubleModeNode::rmode_floor:</span>
<span class="line-added">14502         __ xvrdpim($dst$$VectorSRegister, $src$$VectorSRegister);</span>
<span class="line-added">14503         break;</span>
<span class="line-added">14504       case RoundDoubleModeNode::rmode_ceil:</span>
<span class="line-added">14505         __ xvrdpip($dst$$VectorSRegister, $src$$VectorSRegister);</span>
<span class="line-added">14506         break;</span>
<span class="line-added">14507       default:</span>
<span class="line-added">14508         ShouldNotReachHere();</span>
<span class="line-added">14509     }</span>
<span class="line-added">14510   %}</span>
<span class="line-added">14511   ins_pipe(pipe_class_default);</span>
<span class="line-added">14512 %}</span>
<span class="line-added">14513 </span>
14514 // Vector Negate Instructions
14515 
14516 instruct vneg4F_reg(vecX dst, vecX src) %{
14517   match(Set dst (NegVF src));
14518   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14519   format %{ &quot;XVNEGSP $dst,$src\t// negate packed4F&quot; %}
14520   size(4);
14521   ins_encode %{
14522     __ xvnegsp($dst$$VectorSRegister, $src$$VectorSRegister);
14523   %}
14524   ins_pipe(pipe_class_default);
14525 %}
14526 
14527 instruct vneg2D_reg(vecX dst, vecX src) %{
14528   match(Set dst (NegVD src));
14529   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14530   format %{ &quot;XVNEGDP $dst,$src\t// negate packed2D&quot; %}
14531   size(4);
14532   ins_encode %{
14533     __ xvnegdp($dst$$VectorSRegister, $src$$VectorSRegister);
</pre>
<hr />
<pre>
14745 
14746   format %{ &quot;XXLXOR      $dst, $zero \t// replicate4F&quot; %}
14747   ins_encode %{
14748     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14749   %}
14750   ins_pipe(pipe_class_default);
14751 %}
14752 
14753 instruct repl2D_reg_Ex(vecX dst, regD src) %{
14754   match(Set dst (ReplicateD src));
14755   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14756 
14757   format %{ &quot;XXPERMDI      $dst, $src, $src, 0 \t// Splat doubleword&quot; %}
14758   size(4);
14759   ins_encode %{
14760     __ xxpermdi($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr(), $src$$FloatRegister-&gt;to_vsr(), 0);
14761   %}
14762   ins_pipe(pipe_class_default);
14763 %}
14764 
<span class="line-modified">14765 instruct repl2D_immD0(vecX dst, immD_0 zero) %{</span>
14766   match(Set dst (ReplicateD zero));
14767   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14768 
14769   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2D&quot; %}
14770   size(4);
14771   ins_encode %{
14772     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14773   %}
14774   ins_pipe(pipe_class_default);
14775 %}
14776 












14777 instruct mtvsrd(vecX dst, iRegLsrc src) %{
14778   predicate(false);
14779   effect(DEF dst, USE src);
14780 
14781   format %{ &quot;MTVSRD      $dst, $src \t// Move to 16-byte register&quot; %}
14782   size(4);
14783   ins_encode %{
14784     __ mtvsrd($dst$$VectorSRegister, $src$$Register);
14785   %}
14786   ins_pipe(pipe_class_default);
14787 %}
14788 
14789 instruct xxspltd(vecX dst, vecX src, immI8 zero) %{
14790   effect(DEF dst, USE src, USE zero);
14791 
14792   format %{ &quot;XXSPLATD      $dst, $src, $zero \t// Splat doubleword&quot; %}
14793   size(4);
14794   ins_encode %{
14795     __ xxpermdi($dst$$VectorSRegister, $src$$VectorSRegister, $src$$VectorSRegister, $zero$$constant);
14796   %}
</pre>
<hr />
<pre>
14818     xxpermdi(dst, tmpV, tmpV, zero);
14819   %}
14820 %}
14821 
14822 instruct repl2L_immI0(vecX dst, immI_0 zero) %{
14823   match(Set dst (ReplicateL zero));
14824   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14825 
14826   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2L&quot; %}
14827   size(4);
14828   ins_encode %{
14829     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14830   %}
14831   ins_pipe(pipe_class_default);
14832 %}
14833 
14834 instruct repl2L_immIminus1(vecX dst, immI_minus1 src) %{
14835   match(Set dst (ReplicateL src));
14836   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14837 
<span class="line-modified">14838   format %{ &quot;XXLEQV      $dst, $src \t// replicate2L&quot; %}</span>
14839   size(4);
14840   ins_encode %{
14841     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14842   %}
14843   ins_pipe(pipe_class_default);
14844 %}
14845 
14846 // ============================================================================
14847 // Safepoint Instruction
14848 
14849 instruct safePoint_poll(iRegPdst poll) %{
14850   match(SafePoint poll);
14851 
14852   // It caused problems to add the effect that r0 is killed, but this
14853   // effect no longer needs to be mentioned, since r0 is not contained
14854   // in a reg_class.
14855 
14856   format %{ &quot;LD      R0, #0, $poll \t// Safepoint poll for GC&quot; %}
14857   size(4);
14858   ins_encode( enc_poll(0x0, poll) );
</pre>
<hr />
<pre>
15208     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15209     __ brnop1();
15210   %}
15211   ins_pipe(pipe_class_default);
15212 %}
15213 
15214 instruct brNop2() %{
15215   ins_cost(0);
15216 
15217   ins_is_nop(true);
15218 
15219   format %{ &quot;brNop2&quot; %}
15220   size(4);
15221   ins_encode %{
15222     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15223     __ brnop2();
15224   %}
15225   ins_pipe(pipe_class_default);
15226 %}
15227 
<span class="line-added">15228 instruct cacheWB(indirect addr)</span>
<span class="line-added">15229 %{</span>
<span class="line-added">15230   match(CacheWB addr);</span>
<span class="line-added">15231 </span>
<span class="line-added">15232   ins_cost(100);</span>
<span class="line-added">15233   format %{ &quot;cache writeback, address = $addr&quot; %}</span>
<span class="line-added">15234   ins_encode %{</span>
<span class="line-added">15235     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);</span>
<span class="line-added">15236     assert($addr$$disp == 0, &quot;should be&quot;);</span>
<span class="line-added">15237     __ cache_wb(Address($addr$$base$$Register));</span>
<span class="line-added">15238   %}</span>
<span class="line-added">15239   ins_pipe(pipe_class_default);</span>
<span class="line-added">15240 %}</span>
<span class="line-added">15241 </span>
<span class="line-added">15242 instruct cacheWBPreSync()</span>
<span class="line-added">15243 %{</span>
<span class="line-added">15244   match(CacheWBPreSync);</span>
<span class="line-added">15245 </span>
<span class="line-added">15246   ins_cost(0);</span>
<span class="line-added">15247   format %{ &quot;cache writeback presync&quot; %}</span>
<span class="line-added">15248   ins_encode %{</span>
<span class="line-added">15249     __ cache_wbsync(true);</span>
<span class="line-added">15250   %}</span>
<span class="line-added">15251   ins_pipe(pipe_class_default);</span>
<span class="line-added">15252 %}</span>
<span class="line-added">15253 </span>
<span class="line-added">15254 instruct cacheWBPostSync()</span>
<span class="line-added">15255 %{</span>
<span class="line-added">15256   match(CacheWBPostSync);</span>
<span class="line-added">15257 </span>
<span class="line-added">15258   ins_cost(100);</span>
<span class="line-added">15259   format %{ &quot;cache writeback postsync&quot; %}</span>
<span class="line-added">15260   ins_encode %{</span>
<span class="line-added">15261     __ cache_wbsync(false);</span>
<span class="line-added">15262   %}</span>
<span class="line-added">15263   ins_pipe(pipe_class_default);</span>
<span class="line-added">15264 %}</span>
<span class="line-added">15265 </span>
15266 //----------PEEPHOLE RULES-----------------------------------------------------
15267 // These must follow all instruction definitions as they use the names
15268 // defined in the instructions definitions.
15269 //
15270 // peepmatch ( root_instr_name [preceeding_instruction]* );
15271 //
15272 // peepconstraint %{
15273 // (instruction_number.operand_name relational_op instruction_number.operand_name
15274 //  [, ...] );
15275 // // instruction numbers are zero-based using left to right order in peepmatch
15276 //
15277 // peepreplace ( instr_name ( [instruction_number.operand_name]* ) );
15278 // // provide an instruction_number.operand_name for each operand that appears
15279 // // in the replacement instruction&#39;s match rule
15280 //
15281 // ---------VM FLAGS---------------------------------------------------------
15282 //
15283 // All peephole optimizations can be turned off using -XX:-OptoPeephole
15284 //
15285 // Each peephole rule is given an identifying number starting with zero and
</pre>
</td>
</tr>
</table>
<center><a href="nativeInst_ppc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="relocInfo_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
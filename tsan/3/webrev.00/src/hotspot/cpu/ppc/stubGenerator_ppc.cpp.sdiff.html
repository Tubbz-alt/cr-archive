<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/stubGenerator_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreterGenerator_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/stubGenerator_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;
  31 #include &quot;nativeInst_ppc.hpp&quot;
  32 #include &quot;oops/instanceOop.hpp&quot;
  33 #include &quot;oops/method.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;prims/methodHandles.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/handles.inline.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/thread.inline.hpp&quot;
  43 #include &quot;utilities/align.hpp&quot;

  44 
  45 // Declaration and definition of StubGenerator (no .hpp file).
  46 // For a more detailed description of the stub routine structure
  47 // see the comment in stubRoutines.hpp.
  48 
  49 #define __ _masm-&gt;
  50 
  51 #ifdef PRODUCT
  52 #define BLOCK_COMMENT(str) // nothing
  53 #else
  54 #define BLOCK_COMMENT(str) __ block_comment(str)
  55 #endif
  56 
  57 #if defined(ABI_ELFv2)
  58 #define STUB_ENTRY(name) StubRoutines::name()
  59 #else
  60 #define STUB_ENTRY(name) ((FunctionDescriptor*)StubRoutines::name())-&gt;entry()
  61 #endif
  62 
  63 class StubGenerator: public StubCodeGenerator {
</pre>
<hr />
<pre>
 423   //
 424   //   LR:     The pc the runtime library callee wants to return to.
 425   //           Since the exception occurred in the callee, the return pc
 426   //           from the point of view of Java is the exception pc.
 427   //   thread: Needed for method handles.
 428   //
 429   // Invalidate:
 430   //
 431   //   volatile registers (except below).
 432   //
 433   // Update:
 434   //
 435   //   R4_ARG2: exception
 436   //
 437   // (LR is unchanged and is live out).
 438   //
 439   address generate_forward_exception() {
 440     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;forward_exception&quot;);
 441     address start = __ pc();
 442 
<span class="line-removed"> 443 #if !defined(PRODUCT)</span>
 444     if (VerifyOops) {
 445       // Get pending exception oop.
 446       __ ld(R3_ARG1,
 447                 in_bytes(Thread::pending_exception_offset()),
 448                 R16_thread);
 449       // Make sure that this code is only executed if there is a pending exception.
 450       {
 451         Label L;
 452         __ cmpdi(CCR0, R3_ARG1, 0);
 453         __ bne(CCR0, L);
 454         __ stop(&quot;StubRoutines::forward exception: no pending exception (1)&quot;);
 455         __ bind(L);
 456       }
 457       __ verify_oop(R3_ARG1, &quot;StubRoutines::forward exception: not an oop&quot;);
 458     }
<span class="line-removed"> 459 #endif</span>
 460 
 461     // Save LR/CR and copy exception pc (LR) into R4_ARG2.
 462     __ save_LR_CR(R4_ARG2);
 463     __ push_frame_reg_args(0, R0);
 464     // Find exception handler.
 465     __ call_VM_leaf(CAST_FROM_FN_PTR(address,
 466                      SharedRuntime::exception_handler_for_return_address),
 467                     R16_thread,
 468                     R4_ARG2);
 469     // Copy handler&#39;s address.
 470     __ mtctr(R3_RET);
 471     __ pop_frame();
 472     __ restore_LR_CR(R0);
 473 
 474     // Set up the arguments for the exception handler:
 475     //  - R3_ARG1: exception oop
 476     //  - R4_ARG2: exception pc.
 477 
 478     // Load pending exception oop.
 479     __ ld(R3_ARG1,
</pre>
<hr />
<pre>
 685 
 686     // Clear rest.
 687     __ bind(restloop);
 688       __ std(zero_reg, 0, base_ptr_reg);        // Clear 8byte aligned block.
 689       __ std(zero_reg, 8, base_ptr_reg);        // Clear 8byte aligned block.
 690       __ addi(base_ptr_reg, base_ptr_reg, 16);
 691     __ bdnz(restloop);
 692 
 693     __ bind(lastdword);
 694     __ beq(CCR1, done);
 695     __ std(zero_reg, 0, base_ptr_reg);
 696     __ bind(done);
 697     __ blr();                                   // return
 698 
 699     return start;
 700   }
 701 
 702 #if !defined(PRODUCT)
 703   // Wrapper which calls oopDesc::is_oop_or_null()
 704   // Only called by MacroAssembler::verify_oop
<span class="line-modified"> 705   static void verify_oop_helper(const char* message, oop o) {</span>
 706     if (!oopDesc::is_oop_or_null(o)) {
<span class="line-modified"> 707       fatal(&quot;%s&quot;, message);</span>
 708     }
 709     ++ StubRoutines::_verify_oop_count;
 710   }
 711 #endif
 712 
 713   // Return address of code to be called from code generated by
 714   // MacroAssembler::verify_oop.
 715   //
 716   // Don&#39;t generate, rather use C++ code.
 717   address generate_verify_oop() {
 718     // this is actually a `FunctionDescriptor*&#39;.
 719     address start = 0;
 720 
 721 #if !defined(PRODUCT)
 722     start = CAST_FROM_FN_PTR(address, verify_oop_helper);
 723 #endif
 724 
 725     return start;
 726   }
 727 
<span class="line-removed"> 728 </span>
 729   // -XX:+OptimizeFill : convert fill/copy loops into intrinsic
 730   //
 731   // The code is implemented(ported from sparc) as we believe it benefits JVM98, however
 732   // tracing(-XX:+TraceOptimizeFill) shows the intrinsic replacement doesn&#39;t happen at all!
 733   //
 734   // Source code in function is_range_check_if() shows that OptimizeFill relaxed the condition
 735   // for turning on loop predication optimization, and hence the behavior of &quot;array range check&quot;
 736   // and &quot;loop invariant check&quot; could be influenced, which potentially boosted JVM98.
 737   //
 738   // Generate stub for disjoint short fill. If &quot;aligned&quot; is true, the
 739   // &quot;to&quot; address is assumed to be heapword aligned.
 740   //
 741   // Arguments for generated stub:
 742   //   to:    R3_ARG1
 743   //   value: R4_ARG2
 744   //   count: R5_ARG3 treated as signed
 745   //
 746   address generate_fill(BasicType t, bool aligned, const char* name) {
 747     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
 748     address start = __ function_entry();
</pre>
<hr />
<pre>
 935   //   R5_ARG3    -  element count
 936   //
 937   void array_overlap_test(address no_overlap_target, int log2_elem_size) {
 938     Register tmp1 = R6_ARG4;
 939     Register tmp2 = R7_ARG5;
 940 
 941     assert_positive_int(R5_ARG3);
 942 
 943     __ subf(tmp1, R3_ARG1, R4_ARG2); // distance in bytes
 944     __ sldi(tmp2, R5_ARG3, log2_elem_size); // size in bytes
 945     __ cmpld(CCR0, R3_ARG1, R4_ARG2); // Use unsigned comparison!
 946     __ cmpld(CCR1, tmp1, tmp2);
 947     __ crnand(CCR0, Assembler::less, CCR1, Assembler::less);
 948     // Overlaps if Src before dst and distance smaller than size.
 949     // Branch to forward copy routine otherwise (within range of 32kB).
 950     __ bc(Assembler::bcondCRbiIs1, Assembler::bi0(CCR0, Assembler::less), no_overlap_target);
 951 
 952     // need to copy backwards
 953   }
 954 














 955   // The guideline in the implementations of generate_disjoint_xxx_copy
 956   // (xxx=byte,short,int,long,oop) is to copy as many elements as possible with
 957   // single instructions, but to avoid alignment interrupts (see subsequent
 958   // comment). Furthermore, we try to minimize misaligned access, even
 959   // though they cause no alignment interrupt.
 960   //
 961   // In Big-Endian mode, the PowerPC architecture requires implementations to
 962   // handle automatically misaligned integer halfword and word accesses,
 963   // word-aligned integer doubleword accesses, and word-aligned floating-point
 964   // accesses. Other accesses may or may not generate an Alignment interrupt
 965   // depending on the implementation.
 966   // Alignment interrupt handling may require on the order of hundreds of cycles,
 967   // so every effort should be made to avoid misaligned memory values.
 968   //
 969   //
 970   // Generate stub for disjoint byte copy.  If &quot;aligned&quot; is true, the
 971   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
 972   //
 973   // Arguments for generated stub:
 974   //      from:  R3_ARG1
 975   //      to:    R4_ARG2
 976   //      count: R5_ARG3 treated as signed
 977   //
 978   address generate_disjoint_byte_copy(bool aligned, const char * name) {
 979     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
 980     address start = __ function_entry();
 981     assert_positive_int(R5_ARG3);
 982 
 983     Register tmp1 = R6_ARG4;
 984     Register tmp2 = R7_ARG5;
 985     Register tmp3 = R8_ARG6;
 986     Register tmp4 = R9_ARG7;
 987 
 988     VectorSRegister tmp_vsr1  = VSR1;
 989     VectorSRegister tmp_vsr2  = VSR2;
 990 
 991     Label l_1, l_2, l_3, l_4, l_5, l_6, l_7, l_8, l_9, l_10;



 992 
<span class="line-modified"> 993     // Don&#39;t try anything fancy if arrays don&#39;t have many elements.</span>
<span class="line-modified"> 994     __ li(tmp3, 0);</span>
<span class="line-modified"> 995     __ cmpwi(CCR0, R5_ARG3, 17);</span>
<span class="line-modified"> 996     __ ble(CCR0, l_6); // copy 4 at a time</span>
 997 
<span class="line-modified"> 998     if (!aligned) {</span>
<span class="line-modified"> 999       __ xorr(tmp1, R3_ARG1, R4_ARG2);</span>
<span class="line-modified">1000       __ andi_(tmp1, tmp1, 3);</span>
<span class="line-modified">1001       __ bne(CCR0, l_6); // If arrays don&#39;t have the same alignment mod 4, do 4 element copy.</span>
<span class="line-removed">1002 </span>
<span class="line-removed">1003       // Copy elements if necessary to align to 4 bytes.</span>
<span class="line-removed">1004       __ neg(tmp1, R3_ARG1); // Compute distance to alignment boundary.</span>
<span class="line-removed">1005       __ andi_(tmp1, tmp1, 3);</span>
<span class="line-removed">1006       __ beq(CCR0, l_2);</span>
<span class="line-removed">1007 </span>
<span class="line-removed">1008       __ subf(R5_ARG3, tmp1, R5_ARG3);</span>
<span class="line-removed">1009       __ bind(l_9);</span>
<span class="line-removed">1010       __ lbz(tmp2, 0, R3_ARG1);</span>
<span class="line-removed">1011       __ addic_(tmp1, tmp1, -1);</span>
<span class="line-removed">1012       __ stb(tmp2, 0, R4_ARG2);</span>
<span class="line-removed">1013       __ addi(R3_ARG1, R3_ARG1, 1);</span>
<span class="line-removed">1014       __ addi(R4_ARG2, R4_ARG2, 1);</span>
<span class="line-removed">1015       __ bne(CCR0, l_9);</span>
1016 
<span class="line-modified">1017       __ bind(l_2);</span>
<span class="line-modified">1018     }</span>


1019 
<span class="line-modified">1020     // copy 8 elements at a time</span>
<span class="line-modified">1021     __ xorr(tmp2, R3_ARG1, R4_ARG2); // skip if src &amp; dest have differing alignment mod 8</span>
<span class="line-modified">1022     __ andi_(tmp1, tmp2, 7);</span>
<span class="line-modified">1023     __ bne(CCR0, l_7); // not same alignment -&gt; to or from is aligned -&gt; copy 8</span>







1024 
<span class="line-modified">1025     // copy a 2-element word if necessary to align to 8 bytes</span>
<span class="line-modified">1026     __ andi_(R0, R3_ARG1, 7);</span>
<span class="line-modified">1027     __ beq(CCR0, l_7);</span>

1028 
<span class="line-modified">1029     __ lwzx(tmp2, R3_ARG1, tmp3);</span>
<span class="line-modified">1030     __ addi(R5_ARG3, R5_ARG3, -4);</span>
<span class="line-modified">1031     __ stwx(tmp2, R4_ARG2, tmp3);</span>
<span class="line-removed">1032     { // FasterArrayCopy</span>
<span class="line-removed">1033       __ addi(R3_ARG1, R3_ARG1, 4);</span>
<span class="line-removed">1034       __ addi(R4_ARG2, R4_ARG2, 4);</span>
<span class="line-removed">1035     }</span>
<span class="line-removed">1036     __ bind(l_7);</span>
1037 
<span class="line-modified">1038     { // FasterArrayCopy</span>
<span class="line-modified">1039       __ cmpwi(CCR0, R5_ARG3, 31);</span>
<span class="line-modified">1040       __ ble(CCR0, l_6); // copy 2 at a time if less than 32 elements remain</span>





1041 
<span class="line-modified">1042       __ srdi(tmp1, R5_ARG3, 5);</span>
<span class="line-modified">1043       __ andi_(R5_ARG3, R5_ARG3, 31);</span>
<span class="line-modified">1044       __ mtctr(tmp1);</span>
1045 
<span class="line-modified">1046      if (!VM_Version::has_vsx()) {</span>


1047 
<span class="line-modified">1048       __ bind(l_8);</span>
<span class="line-removed">1049       // Use unrolled version for mass copying (copy 32 elements a time)</span>
<span class="line-removed">1050       // Load feeding store gets zero latency on Power6, however not on Power5.</span>
<span class="line-removed">1051       // Therefore, the following sequence is made for the good of both.</span>
<span class="line-removed">1052       __ ld(tmp1, 0, R3_ARG1);</span>
<span class="line-removed">1053       __ ld(tmp2, 8, R3_ARG1);</span>
<span class="line-removed">1054       __ ld(tmp3, 16, R3_ARG1);</span>
<span class="line-removed">1055       __ ld(tmp4, 24, R3_ARG1);</span>
<span class="line-removed">1056       __ std(tmp1, 0, R4_ARG2);</span>
<span class="line-removed">1057       __ std(tmp2, 8, R4_ARG2);</span>
<span class="line-removed">1058       __ std(tmp3, 16, R4_ARG2);</span>
<span class="line-removed">1059       __ std(tmp4, 24, R4_ARG2);</span>
<span class="line-removed">1060       __ addi(R3_ARG1, R3_ARG1, 32);</span>
<span class="line-removed">1061       __ addi(R4_ARG2, R4_ARG2, 32);</span>
<span class="line-removed">1062       __ bdnz(l_8);</span>
1063 
<span class="line-modified">1064     } else { // Processor supports VSX, so use it to mass copy.</span>














1065 
<span class="line-modified">1066       // Prefetch the data into the L2 cache.</span>
<span class="line-removed">1067       __ dcbt(R3_ARG1, 0);</span>
1068 
<span class="line-modified">1069       // If supported set DSCR pre-fetch to deepest.</span>
<span class="line-modified">1070       if (VM_Version::has_mfdscr()) {</span>
<span class="line-removed">1071         __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);</span>
<span class="line-removed">1072         __ mtdscr(tmp2);</span>
<span class="line-removed">1073       }</span>
1074 
<span class="line-modified">1075       __ li(tmp1, 16);</span>




1076 
<span class="line-modified">1077       // Backbranch target aligned to 32-byte. Not 16-byte align as</span>
<span class="line-removed">1078       // loop contains &lt; 8 instructions that fit inside a single</span>
<span class="line-removed">1079       // i-cache sector.</span>
<span class="line-removed">1080       __ align(32);</span>
1081 
<span class="line-modified">1082       __ bind(l_10);</span>
<span class="line-modified">1083       // Use loop with VSX load/store instructions to</span>
<span class="line-modified">1084       // copy 32 elements a time.</span>
<span class="line-modified">1085       __ lxvd2x(tmp_vsr1, R3_ARG1);        // Load src</span>
<span class="line-removed">1086       __ stxvd2x(tmp_vsr1, R4_ARG2);       // Store to dst</span>
<span class="line-removed">1087       __ lxvd2x(tmp_vsr2, tmp1, R3_ARG1);  // Load src + 16</span>
<span class="line-removed">1088       __ stxvd2x(tmp_vsr2, tmp1, R4_ARG2); // Store to dst + 16</span>
<span class="line-removed">1089       __ addi(R3_ARG1, R3_ARG1, 32);       // Update src+=32</span>
<span class="line-removed">1090       __ addi(R4_ARG2, R4_ARG2, 32);       // Update dsc+=32</span>
<span class="line-removed">1091       __ bdnz(l_10);                       // Dec CTR and loop if not zero.</span>
1092 
<span class="line-modified">1093       // Restore DSCR pre-fetch value.</span>
<span class="line-modified">1094       if (VM_Version::has_mfdscr()) {</span>
<span class="line-modified">1095         __ load_const_optimized(tmp2, VM_Version::_dscr_val);</span>
<span class="line-modified">1096         __ mtdscr(tmp2);</span>
<span class="line-modified">1097       }</span>





1098 
<span class="line-modified">1099     } // VSX</span>
<span class="line-modified">1100    } // FasterArrayCopy</span>



1101 
<span class="line-modified">1102     __ bind(l_6);</span>

1103 
<span class="line-modified">1104     // copy 4 elements at a time</span>
<span class="line-removed">1105     __ cmpwi(CCR0, R5_ARG3, 4);</span>
<span class="line-removed">1106     __ blt(CCR0, l_1);</span>
<span class="line-removed">1107     __ srdi(tmp1, R5_ARG3, 2);</span>
<span class="line-removed">1108     __ mtctr(tmp1); // is &gt; 0</span>
<span class="line-removed">1109     __ andi_(R5_ARG3, R5_ARG3, 3);</span>
1110 
<span class="line-modified">1111     { // FasterArrayCopy</span>
<span class="line-modified">1112       __ addi(R3_ARG1, R3_ARG1, -4);</span>
<span class="line-modified">1113       __ addi(R4_ARG2, R4_ARG2, -4);</span>
<span class="line-modified">1114       __ bind(l_3);</span>
<span class="line-modified">1115       __ lwzu(tmp2, 4, R3_ARG1);</span>
<span class="line-modified">1116       __ stwu(tmp2, 4, R4_ARG2);</span>
<span class="line-removed">1117       __ bdnz(l_3);</span>
<span class="line-removed">1118       __ addi(R3_ARG1, R3_ARG1, 4);</span>
<span class="line-removed">1119       __ addi(R4_ARG2, R4_ARG2, 4);</span>
<span class="line-removed">1120     }</span>
1121 
<span class="line-modified">1122     // do single element copy</span>
<span class="line-modified">1123     __ bind(l_1);</span>
<span class="line-modified">1124     __ cmpwi(CCR0, R5_ARG3, 0);</span>
<span class="line-modified">1125     __ beq(CCR0, l_4);</span>






1126 
<span class="line-modified">1127     { // FasterArrayCopy</span>
<span class="line-modified">1128       __ mtctr(R5_ARG3);</span>
<span class="line-modified">1129       __ addi(R3_ARG1, R3_ARG1, -1);</span>
<span class="line-modified">1130       __ addi(R4_ARG2, R4_ARG2, -1);</span>
1131 
<span class="line-modified">1132       __ bind(l_5);</span>
<span class="line-modified">1133       __ lbzu(tmp2, 1, R3_ARG1);</span>
<span class="line-modified">1134       __ stbu(tmp2, 1, R4_ARG2);</span>
<span class="line-modified">1135       __ bdnz(l_5);</span>






1136     }
1137 
1138     __ bind(l_4);
1139     __ li(R3_RET, 0); // return 0
1140     __ blr();
1141 
1142     return start;
1143   }
1144 
1145   // Generate stub for conjoint byte copy.  If &quot;aligned&quot; is true, the
1146   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1147   //
1148   // Arguments for generated stub:
1149   //      from:  R3_ARG1
1150   //      to:    R4_ARG2
1151   //      count: R5_ARG3 treated as signed
1152   //
1153   address generate_conjoint_byte_copy(bool aligned, const char * name) {
1154     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1155     address start = __ function_entry();
1156     assert_positive_int(R5_ARG3);
1157 
1158     Register tmp1 = R6_ARG4;
1159     Register tmp2 = R7_ARG5;
1160     Register tmp3 = R8_ARG6;
1161 
1162     address nooverlap_target = aligned ?
1163       STUB_ENTRY(arrayof_jbyte_disjoint_arraycopy) :
1164       STUB_ENTRY(jbyte_disjoint_arraycopy);
1165 
1166     array_overlap_test(nooverlap_target, 0);
1167     // Do reverse copy. We assume the case of actual overlap is rare enough
1168     // that we don&#39;t have to optimize it.
1169     Label l_1, l_2;
<span class="line-modified">1170 </span>
<span class="line-modified">1171     __ b(l_2);</span>
<span class="line-modified">1172     __ bind(l_1);</span>
<span class="line-modified">1173     __ stbx(tmp1, R4_ARG2, R5_ARG3);</span>
<span class="line-modified">1174     __ bind(l_2);</span>
<span class="line-modified">1175     __ addic_(R5_ARG3, R5_ARG3, -1);</span>
<span class="line-modified">1176     __ lbzx(tmp1, R3_ARG1, R5_ARG3);</span>
<span class="line-modified">1177     __ bge(CCR0, l_1);</span>
<span class="line-modified">1178 </span>


1179     __ li(R3_RET, 0); // return 0
1180     __ blr();
1181 
1182     return start;
1183   }
1184 
1185   // Generate stub for disjoint short copy.  If &quot;aligned&quot; is true, the
1186   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1187   //
1188   // Arguments for generated stub:
1189   //      from:  R3_ARG1
1190   //      to:    R4_ARG2
1191   //  elm.count: R5_ARG3 treated as signed
1192   //
1193   // Strategy for aligned==true:
1194   //
1195   //  If length &lt;= 9:
1196   //     1. copy 2 elements at a time (l_6)
1197   //     2. copy last element if original element count was odd (l_1)
1198   //
</pre>
<hr />
<pre>
1235   //
1236   //  TODO:
1237   //
1238   //  1. check if aligning the backbranch target of loops is beneficial
1239   //
1240   address generate_disjoint_short_copy(bool aligned, const char * name) {
1241     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1242 
1243     Register tmp1 = R6_ARG4;
1244     Register tmp2 = R7_ARG5;
1245     Register tmp3 = R8_ARG6;
1246     Register tmp4 = R9_ARG7;
1247 
1248     VectorSRegister tmp_vsr1  = VSR1;
1249     VectorSRegister tmp_vsr2  = VSR2;
1250 
1251     address start = __ function_entry();
1252     assert_positive_int(R5_ARG3);
1253 
1254     Label l_1, l_2, l_3, l_4, l_5, l_6, l_7, l_8, l_9;







1255 
<span class="line-modified">1256     // don&#39;t try anything fancy if arrays don&#39;t have many elements</span>
<span class="line-modified">1257     __ li(tmp3, 0);</span>
<span class="line-modified">1258     __ cmpwi(CCR0, R5_ARG3, 9);</span>
<span class="line-modified">1259     __ ble(CCR0, l_6); // copy 2 at a time</span>
<span class="line-removed">1260 </span>
<span class="line-removed">1261     if (!aligned) {</span>
<span class="line-removed">1262       __ xorr(tmp1, R3_ARG1, R4_ARG2);</span>
<span class="line-removed">1263       __ andi_(tmp1, tmp1, 3);</span>
<span class="line-removed">1264       __ bne(CCR0, l_6); // if arrays don&#39;t have the same alignment mod 4, do 2 element copy</span>
1265 
<span class="line-modified">1266       // At this point it is guaranteed that both, from and to have the same alignment mod 4.</span>
1267 
<span class="line-modified">1268       // Copy 1 element if necessary to align to 4 bytes.</span>
<span class="line-modified">1269       __ andi_(tmp1, R3_ARG1, 3);</span>
<span class="line-modified">1270       __ beq(CCR0, l_2);</span>
1271 
<span class="line-modified">1272       __ lhz(tmp2, 0, R3_ARG1);</span>
<span class="line-modified">1273       __ addi(R3_ARG1, R3_ARG1, 2);</span>
<span class="line-modified">1274       __ sth(tmp2, 0, R4_ARG2);</span>
<span class="line-modified">1275       __ addi(R4_ARG2, R4_ARG2, 2);</span>
<span class="line-modified">1276       __ addi(R5_ARG3, R5_ARG3, -1);</span>
<span class="line-modified">1277       __ bind(l_2);</span>
1278 
<span class="line-modified">1279       // At this point the positions of both, from and to, are at least 4 byte aligned.</span>
1280 
<span class="line-modified">1281       // Copy 4 elements at a time.</span>
<span class="line-modified">1282       // Align to 8 bytes, but only if both, from and to, have same alignment mod 8.</span>
<span class="line-modified">1283       __ xorr(tmp2, R3_ARG1, R4_ARG2);</span>
<span class="line-modified">1284       __ andi_(tmp1, tmp2, 7);</span>
<span class="line-modified">1285       __ bne(CCR0, l_7); // not same alignment mod 8 -&gt; copy 4, either from or to will be unaligned</span>
1286 
<span class="line-modified">1287       // Copy a 2-element word if necessary to align to 8 bytes.</span>
<span class="line-modified">1288       __ andi_(R0, R3_ARG1, 7);</span>
<span class="line-modified">1289       __ beq(CCR0, l_7);</span>
1290 
<span class="line-modified">1291       __ lwzx(tmp2, R3_ARG1, tmp3);</span>
<span class="line-modified">1292       __ addi(R5_ARG3, R5_ARG3, -2);</span>
<span class="line-modified">1293       __ stwx(tmp2, R4_ARG2, tmp3);</span>
<span class="line-modified">1294       { // FasterArrayCopy</span>
<span class="line-modified">1295         __ addi(R3_ARG1, R3_ARG1, 4);</span>
<span class="line-modified">1296         __ addi(R4_ARG2, R4_ARG2, 4);</span>

1297       }
<span class="line-removed">1298     }</span>
<span class="line-removed">1299 </span>
<span class="line-removed">1300     __ bind(l_7);</span>
<span class="line-removed">1301 </span>
<span class="line-removed">1302     // Copy 4 elements at a time; either the loads or the stores can</span>
<span class="line-removed">1303     // be unaligned if aligned == false.</span>
<span class="line-removed">1304 </span>
<span class="line-removed">1305     { // FasterArrayCopy</span>
<span class="line-removed">1306       __ cmpwi(CCR0, R5_ARG3, 15);</span>
<span class="line-removed">1307       __ ble(CCR0, l_6); // copy 2 at a time if less than 16 elements remain</span>
1308 
<span class="line-modified">1309       __ srdi(tmp1, R5_ARG3, 4);</span>
<span class="line-removed">1310       __ andi_(R5_ARG3, R5_ARG3, 15);</span>
<span class="line-removed">1311       __ mtctr(tmp1);</span>
<span class="line-removed">1312 </span>
<span class="line-removed">1313       if (!VM_Version::has_vsx()) {</span>
<span class="line-removed">1314 </span>
<span class="line-removed">1315         __ bind(l_8);</span>
<span class="line-removed">1316         // Use unrolled version for mass copying (copy 16 elements a time).</span>
<span class="line-removed">1317         // Load feeding store gets zero latency on Power6, however not on Power5.</span>
<span class="line-removed">1318         // Therefore, the following sequence is made for the good of both.</span>
<span class="line-removed">1319         __ ld(tmp1, 0, R3_ARG1);</span>
<span class="line-removed">1320         __ ld(tmp2, 8, R3_ARG1);</span>
<span class="line-removed">1321         __ ld(tmp3, 16, R3_ARG1);</span>
<span class="line-removed">1322         __ ld(tmp4, 24, R3_ARG1);</span>
<span class="line-removed">1323         __ std(tmp1, 0, R4_ARG2);</span>
<span class="line-removed">1324         __ std(tmp2, 8, R4_ARG2);</span>
<span class="line-removed">1325         __ std(tmp3, 16, R4_ARG2);</span>
<span class="line-removed">1326         __ std(tmp4, 24, R4_ARG2);</span>
<span class="line-removed">1327         __ addi(R3_ARG1, R3_ARG1, 32);</span>
<span class="line-removed">1328         __ addi(R4_ARG2, R4_ARG2, 32);</span>
<span class="line-removed">1329         __ bdnz(l_8);</span>
1330 
<span class="line-modified">1331       } else { // Processor supports VSX, so use it to mass copy.</span>

1332 
<span class="line-modified">1333         // Prefetch src data into L2 cache.</span>
<span class="line-modified">1334         __ dcbt(R3_ARG1, 0);</span>

























































1335 
<span class="line-removed">1336         // If supported set DSCR pre-fetch to deepest.</span>
<span class="line-removed">1337         if (VM_Version::has_mfdscr()) {</span>
<span class="line-removed">1338           __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);</span>
<span class="line-removed">1339           __ mtdscr(tmp2);</span>
1340         }
<span class="line-modified">1341         __ li(tmp1, 16);</span>

1342 
<span class="line-modified">1343         // Backbranch target aligned to 32-byte. It&#39;s not aligned 16-byte</span>
<span class="line-modified">1344         // as loop contains &lt; 8 instructions that fit inside a single</span>
<span class="line-modified">1345         // i-cache sector.</span>
<span class="line-modified">1346         __ align(32);</span>


1347 
<span class="line-modified">1348         __ bind(l_9);</span>
<span class="line-modified">1349         // Use loop with VSX load/store instructions to</span>
<span class="line-modified">1350         // copy 16 elements a time.</span>
<span class="line-removed">1351         __ lxvd2x(tmp_vsr1, R3_ARG1);        // Load from src.</span>
<span class="line-removed">1352         __ stxvd2x(tmp_vsr1, R4_ARG2);       // Store to dst.</span>
<span class="line-removed">1353         __ lxvd2x(tmp_vsr2, R3_ARG1, tmp1);  // Load from src + 16.</span>
<span class="line-removed">1354         __ stxvd2x(tmp_vsr2, R4_ARG2, tmp1); // Store to dst + 16.</span>
<span class="line-removed">1355         __ addi(R3_ARG1, R3_ARG1, 32);       // Update src+=32.</span>
<span class="line-removed">1356         __ addi(R4_ARG2, R4_ARG2, 32);       // Update dsc+=32.</span>
<span class="line-removed">1357         __ bdnz(l_9);                        // Dec CTR and loop if not zero.</span>
1358 
<span class="line-modified">1359         // Restore DSCR pre-fetch value.</span>
<span class="line-modified">1360         if (VM_Version::has_mfdscr()) {</span>
<span class="line-modified">1361           __ load_const_optimized(tmp2, VM_Version::_dscr_val);</span>
<span class="line-modified">1362           __ mtdscr(tmp2);</span>
<span class="line-removed">1363         }</span>
1364 


1365       }
<span class="line-removed">1366     } // FasterArrayCopy</span>
<span class="line-removed">1367     __ bind(l_6);</span>
1368 
<span class="line-modified">1369     // copy 2 elements at a time</span>
<span class="line-modified">1370     { // FasterArrayCopy</span>
<span class="line-modified">1371       __ cmpwi(CCR0, R5_ARG3, 2);</span>
<span class="line-modified">1372       __ blt(CCR0, l_1);</span>
<span class="line-removed">1373       __ srdi(tmp1, R5_ARG3, 1);</span>
<span class="line-removed">1374       __ andi_(R5_ARG3, R5_ARG3, 1);</span>
<span class="line-removed">1375 </span>
<span class="line-removed">1376       __ addi(R3_ARG1, R3_ARG1, -4);</span>
<span class="line-removed">1377       __ addi(R4_ARG2, R4_ARG2, -4);</span>
<span class="line-removed">1378       __ mtctr(tmp1);</span>
<span class="line-removed">1379 </span>
<span class="line-removed">1380       __ bind(l_3);</span>
<span class="line-removed">1381       __ lwzu(tmp2, 4, R3_ARG1);</span>
<span class="line-removed">1382       __ stwu(tmp2, 4, R4_ARG2);</span>
<span class="line-removed">1383       __ bdnz(l_3);</span>
1384 
<span class="line-modified">1385       __ addi(R3_ARG1, R3_ARG1, 4);</span>
<span class="line-modified">1386       __ addi(R4_ARG2, R4_ARG2, 4);</span>








1387     }
1388 
<span class="line-removed">1389     // do single element copy</span>
<span class="line-removed">1390     __ bind(l_1);</span>
<span class="line-removed">1391     __ cmpwi(CCR0, R5_ARG3, 0);</span>
<span class="line-removed">1392     __ beq(CCR0, l_4);</span>
<span class="line-removed">1393 </span>
<span class="line-removed">1394     { // FasterArrayCopy</span>
<span class="line-removed">1395       __ mtctr(R5_ARG3);</span>
<span class="line-removed">1396       __ addi(R3_ARG1, R3_ARG1, -2);</span>
<span class="line-removed">1397       __ addi(R4_ARG2, R4_ARG2, -2);</span>
<span class="line-removed">1398 </span>
<span class="line-removed">1399       __ bind(l_5);</span>
<span class="line-removed">1400       __ lhzu(tmp2, 2, R3_ARG1);</span>
<span class="line-removed">1401       __ sthu(tmp2, 2, R4_ARG2);</span>
<span class="line-removed">1402       __ bdnz(l_5);</span>
<span class="line-removed">1403     }</span>
1404     __ bind(l_4);
1405     __ li(R3_RET, 0); // return 0
1406     __ blr();
1407 
1408     return start;
1409   }
1410 
1411   // Generate stub for conjoint short copy.  If &quot;aligned&quot; is true, the
1412   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1413   //
1414   // Arguments for generated stub:
1415   //      from:  R3_ARG1
1416   //      to:    R4_ARG2
1417   //      count: R5_ARG3 treated as signed
1418   //
1419   address generate_conjoint_short_copy(bool aligned, const char * name) {
1420     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1421     address start = __ function_entry();
1422     assert_positive_int(R5_ARG3);
1423 
1424     Register tmp1 = R6_ARG4;
1425     Register tmp2 = R7_ARG5;
1426     Register tmp3 = R8_ARG6;
1427 
1428     address nooverlap_target = aligned ?
1429       STUB_ENTRY(arrayof_jshort_disjoint_arraycopy) :
1430       STUB_ENTRY(jshort_disjoint_arraycopy);
1431 
1432     array_overlap_test(nooverlap_target, 1);
1433 
1434     Label l_1, l_2;
<span class="line-modified">1435     __ sldi(tmp1, R5_ARG3, 1);</span>
<span class="line-modified">1436     __ b(l_2);</span>
<span class="line-modified">1437     __ bind(l_1);</span>
<span class="line-modified">1438     __ sthx(tmp2, R4_ARG2, tmp1);</span>
<span class="line-modified">1439     __ bind(l_2);</span>
<span class="line-modified">1440     __ addic_(tmp1, tmp1, -2);</span>
<span class="line-modified">1441     __ lhzx(tmp2, R3_ARG1, tmp1);</span>
<span class="line-modified">1442     __ bge(CCR0, l_1);</span>
<span class="line-modified">1443 </span>



1444     __ li(R3_RET, 0); // return 0
1445     __ blr();
1446 
1447     return start;
1448   }
1449 
1450   // Generate core code for disjoint int copy (and oop copy on 32-bit).  If &quot;aligned&quot;
1451   // is true, the &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1452   //
1453   // Arguments:
1454   //      from:  R3_ARG1
1455   //      to:    R4_ARG2
1456   //      count: R5_ARG3 treated as signed
1457   //
1458   void generate_disjoint_int_copy_core(bool aligned) {
1459     Register tmp1 = R6_ARG4;
1460     Register tmp2 = R7_ARG5;
1461     Register tmp3 = R8_ARG6;
1462     Register tmp4 = R0;
1463 
</pre>
<hr />
<pre>
1571       __ stwu(tmp2, 4, R4_ARG2);
1572       __ bdnz(l_3);
1573     }
1574 
1575     __ bind(l_1);
1576     return;
1577   }
1578 
1579   // Generate stub for disjoint int copy.  If &quot;aligned&quot; is true, the
1580   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1581   //
1582   // Arguments for generated stub:
1583   //      from:  R3_ARG1
1584   //      to:    R4_ARG2
1585   //      count: R5_ARG3 treated as signed
1586   //
1587   address generate_disjoint_int_copy(bool aligned, const char * name) {
1588     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1589     address start = __ function_entry();
1590     assert_positive_int(R5_ARG3);
<span class="line-modified">1591     generate_disjoint_int_copy_core(aligned);</span>




1592     __ li(R3_RET, 0); // return 0
1593     __ blr();
1594     return start;
1595   }
1596 
1597   // Generate core code for conjoint int copy (and oop copy on
1598   // 32-bit).  If &quot;aligned&quot; is true, the &quot;from&quot; and &quot;to&quot; addresses
1599   // are assumed to be heapword aligned.
1600   //
1601   // Arguments:
1602   //      from:  R3_ARG1
1603   //      to:    R4_ARG2
1604   //      count: R5_ARG3 treated as signed
1605   //
1606   void generate_conjoint_int_copy_core(bool aligned) {
1607     // Do reverse copy.  We assume the case of actual overlap is rare enough
1608     // that we don&#39;t have to optimize it.
1609 
1610     Label l_1, l_2, l_3, l_4, l_5, l_6, l_7;
1611 
</pre>
<hr />
<pre>
1719     }
1720   }
1721 
1722   // Generate stub for conjoint int copy.  If &quot;aligned&quot; is true, the
1723   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1724   //
1725   // Arguments for generated stub:
1726   //      from:  R3_ARG1
1727   //      to:    R4_ARG2
1728   //      count: R5_ARG3 treated as signed
1729   //
1730   address generate_conjoint_int_copy(bool aligned, const char * name) {
1731     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1732     address start = __ function_entry();
1733     assert_positive_int(R5_ARG3);
1734     address nooverlap_target = aligned ?
1735       STUB_ENTRY(arrayof_jint_disjoint_arraycopy) :
1736       STUB_ENTRY(jint_disjoint_arraycopy);
1737 
1738     array_overlap_test(nooverlap_target, 2);
<span class="line-modified">1739 </span>
<span class="line-modified">1740     generate_conjoint_int_copy_core(aligned);</span>



1741 
1742     __ li(R3_RET, 0); // return 0
1743     __ blr();
1744 
1745     return start;
1746   }
1747 
1748   // Generate core code for disjoint long copy (and oop copy on
1749   // 64-bit).  If &quot;aligned&quot; is true, the &quot;from&quot; and &quot;to&quot; addresses
1750   // are assumed to be heapword aligned.
1751   //
1752   // Arguments:
1753   //      from:  R3_ARG1
1754   //      to:    R4_ARG2
1755   //      count: R5_ARG3 treated as signed
1756   //
1757   void generate_disjoint_long_copy_core(bool aligned) {
1758     Register tmp1 = R6_ARG4;
1759     Register tmp2 = R7_ARG5;
1760     Register tmp3 = R8_ARG6;
</pre>
<hr />
<pre>
1842       __ ldu(R0, 8, R3_ARG1);
1843       __ stdu(R0, 8, R4_ARG2);
1844       __ bdnz(l_2);
1845 
1846     }
1847     __ bind(l_1);
1848   }
1849 
1850   // Generate stub for disjoint long copy.  If &quot;aligned&quot; is true, the
1851   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1852   //
1853   // Arguments for generated stub:
1854   //      from:  R3_ARG1
1855   //      to:    R4_ARG2
1856   //      count: R5_ARG3 treated as signed
1857   //
1858   address generate_disjoint_long_copy(bool aligned, const char * name) {
1859     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1860     address start = __ function_entry();
1861     assert_positive_int(R5_ARG3);
<span class="line-modified">1862     generate_disjoint_long_copy_core(aligned);</span>




1863     __ li(R3_RET, 0); // return 0
1864     __ blr();
1865 
<span class="line-modified">1866     return start;</span>
1867   }
1868 
1869   // Generate core code for conjoint long copy (and oop copy on
1870   // 64-bit).  If &quot;aligned&quot; is true, the &quot;from&quot; and &quot;to&quot; addresses
1871   // are assumed to be heapword aligned.
1872   //
1873   // Arguments:
1874   //      from:  R3_ARG1
1875   //      to:    R4_ARG2
1876   //      count: R5_ARG3 treated as signed
1877   //
1878   void generate_conjoint_long_copy_core(bool aligned) {
1879     Register tmp1 = R6_ARG4;
1880     Register tmp2 = R7_ARG5;
1881     Register tmp3 = R8_ARG6;
1882     Register tmp4 = R0;
1883 
1884     VectorSRegister tmp_vsr1  = VSR1;
1885     VectorSRegister tmp_vsr2  = VSR2;
1886 
</pre>
<hr />
<pre>
1969     __ bind(l_1);
1970   }
1971 
1972   // Generate stub for conjoint long copy.  If &quot;aligned&quot; is true, the
1973   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1974   //
1975   // Arguments for generated stub:
1976   //      from:  R3_ARG1
1977   //      to:    R4_ARG2
1978   //      count: R5_ARG3 treated as signed
1979   //
1980   address generate_conjoint_long_copy(bool aligned, const char * name) {
1981     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1982     address start = __ function_entry();
1983     assert_positive_int(R5_ARG3);
1984     address nooverlap_target = aligned ?
1985       STUB_ENTRY(arrayof_jlong_disjoint_arraycopy) :
1986       STUB_ENTRY(jlong_disjoint_arraycopy);
1987 
1988     array_overlap_test(nooverlap_target, 3);
<span class="line-modified">1989     generate_conjoint_long_copy_core(aligned);</span>
<span class="line-modified">1990 </span>



1991     __ li(R3_RET, 0); // return 0
1992     __ blr();
1993 
1994     return start;
1995   }
1996 
1997   // Generate stub for conjoint oop copy.  If &quot;aligned&quot; is true, the
1998   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1999   //
2000   // Arguments for generated stub:
2001   //      from:  R3_ARG1
2002   //      to:    R4_ARG2
2003   //      count: R5_ARG3 treated as signed
2004   //      dest_uninitialized: G1 support
2005   //
2006   address generate_conjoint_oop_copy(bool aligned, const char * name, bool dest_uninitialized) {
2007     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2008 
2009     address start = __ function_entry();
2010     assert_positive_int(R5_ARG3);
</pre>
<hr />
<pre>
2971     __ vxor            (toPerm, toPerm, fSplt);       // swap bytes
2972 #else
2973     __ vperm           (vTmp3, vTmp4, vTmp3, toPerm); // generate select mask
2974 #endif
2975     __ vperm           (vTmp4, vRet, vRet, toPerm);   // rotate data
2976     __ vsel            (vTmp2, vTmp4, vTmp2, vTmp3);
2977     __ vsel            (vTmp1, vTmp1, vTmp4, vTmp3);
2978     __ stvx            (vTmp2, fifteen, to);          // store this one first (may alias)
2979     __ stvx            (vTmp1, to);
2980 
2981     __ blr();
2982      return start;
2983   }
2984 
2985   address generate_sha256_implCompress(bool multi_block, const char *name) {
2986     assert(UseSHA, &quot;need SHA instructions&quot;);
2987     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2988     address start = __ function_entry();
2989 
2990     __ sha256 (multi_block);
<span class="line-removed">2991 </span>
2992     __ blr();

2993     return start;
2994   }
2995 
2996   address generate_sha512_implCompress(bool multi_block, const char *name) {
2997     assert(UseSHA, &quot;need SHA instructions&quot;);
2998     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2999     address start = __ function_entry();
3000 
3001     __ sha512 (multi_block);




















3002 







3003     __ blr();

3004     return start;
3005   }
3006 
3007   void generate_arraycopy_stubs() {
3008     // Note: the disjoint stubs must be generated first, some of
3009     // the conjoint stubs use them.
3010 



3011     // non-aligned disjoint versions
3012     StubRoutines::_jbyte_disjoint_arraycopy       = generate_disjoint_byte_copy(false, &quot;jbyte_disjoint_arraycopy&quot;);
3013     StubRoutines::_jshort_disjoint_arraycopy      = generate_disjoint_short_copy(false, &quot;jshort_disjoint_arraycopy&quot;);
3014     StubRoutines::_jint_disjoint_arraycopy        = generate_disjoint_int_copy(false, &quot;jint_disjoint_arraycopy&quot;);
3015     StubRoutines::_jlong_disjoint_arraycopy       = generate_disjoint_long_copy(false, &quot;jlong_disjoint_arraycopy&quot;);
3016     StubRoutines::_oop_disjoint_arraycopy         = generate_disjoint_oop_copy(false, &quot;oop_disjoint_arraycopy&quot;, false);
3017     StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_oop_copy(false, &quot;oop_disjoint_arraycopy_uninit&quot;, true);
3018 
3019     // aligned disjoint versions
3020     StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy(true, &quot;arrayof_jbyte_disjoint_arraycopy&quot;);
3021     StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(true, &quot;arrayof_jshort_disjoint_arraycopy&quot;);
3022     StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_int_copy(true, &quot;arrayof_jint_disjoint_arraycopy&quot;);
3023     StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_long_copy(true, &quot;arrayof_jlong_disjoint_arraycopy&quot;);
3024     StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy(true, &quot;arrayof_oop_disjoint_arraycopy&quot;, false);
3025     StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy(true, &quot;oop_disjoint_arraycopy_uninit&quot;, true);
3026 
3027     // non-aligned conjoint versions
3028     StubRoutines::_jbyte_arraycopy      = generate_conjoint_byte_copy(false, &quot;jbyte_arraycopy&quot;);
3029     StubRoutines::_jshort_arraycopy     = generate_conjoint_short_copy(false, &quot;jshort_arraycopy&quot;);
3030     StubRoutines::_jint_arraycopy       = generate_conjoint_int_copy(false, &quot;jint_arraycopy&quot;);
</pre>
<hr />
<pre>
3042 
3043     // special/generic versions
3044     StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(&quot;checkcast_arraycopy&quot;, false);
3045     StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(&quot;checkcast_arraycopy_uninit&quot;, true);
3046 
3047     StubRoutines::_unsafe_arraycopy  = generate_unsafe_copy(&quot;unsafe_arraycopy&quot;,
3048                                                             STUB_ENTRY(jbyte_arraycopy),
3049                                                             STUB_ENTRY(jshort_arraycopy),
3050                                                             STUB_ENTRY(jint_arraycopy),
3051                                                             STUB_ENTRY(jlong_arraycopy));
3052     StubRoutines::_generic_arraycopy = generate_generic_copy(&quot;generic_arraycopy&quot;,
3053                                                              STUB_ENTRY(jbyte_arraycopy),
3054                                                              STUB_ENTRY(jshort_arraycopy),
3055                                                              STUB_ENTRY(jint_arraycopy),
3056                                                              STUB_ENTRY(oop_arraycopy),
3057                                                              STUB_ENTRY(oop_disjoint_arraycopy),
3058                                                              STUB_ENTRY(jlong_arraycopy),
3059                                                              STUB_ENTRY(checkcast_arraycopy));
3060 
3061     // fill routines

3062     if (OptimizeFill) {
3063       StubRoutines::_jbyte_fill          = generate_fill(T_BYTE,  false, &quot;jbyte_fill&quot;);
3064       StubRoutines::_jshort_fill         = generate_fill(T_SHORT, false, &quot;jshort_fill&quot;);
3065       StubRoutines::_jint_fill           = generate_fill(T_INT,   false, &quot;jint_fill&quot;);
3066       StubRoutines::_arrayof_jbyte_fill  = generate_fill(T_BYTE,  true, &quot;arrayof_jbyte_fill&quot;);
3067       StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, &quot;arrayof_jshort_fill&quot;);
3068       StubRoutines::_arrayof_jint_fill   = generate_fill(T_INT,   true, &quot;arrayof_jint_fill&quot;);
3069     }

3070   }
3071 
3072   // Safefetch stubs.
3073   void generate_safefetch(const char* name, int size, address* entry, address* fault_pc, address* continuation_pc) {
3074     // safefetch signatures:
3075     //   int      SafeFetch32(int*      adr, int      errValue);
3076     //   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue);
3077     //
3078     // arguments:
3079     //   R3_ARG1 = adr
3080     //   R4_ARG2 = errValue
3081     //
3082     // result:
3083     //   R3_RET  = *adr or errValue
3084 
3085     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
3086 
3087     // Entry point, pc or function descriptor.
3088     *entry = __ function_entry();
3089 
</pre>
<hr />
<pre>
3518     StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(&quot;NullPointerException at call throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call), false);
3519 
3520     // support for verify_oop (must happen after universe_init)
3521     StubRoutines::_verify_oop_subroutine_entry             = generate_verify_oop();
3522 
3523     // arraycopy stubs used by compilers
3524     generate_arraycopy_stubs();
3525 
3526     // Safefetch stubs.
3527     generate_safefetch(&quot;SafeFetch32&quot;, sizeof(int),     &amp;StubRoutines::_safefetch32_entry,
3528                                                        &amp;StubRoutines::_safefetch32_fault_pc,
3529                                                        &amp;StubRoutines::_safefetch32_continuation_pc);
3530     generate_safefetch(&quot;SafeFetchN&quot;, sizeof(intptr_t), &amp;StubRoutines::_safefetchN_entry,
3531                                                        &amp;StubRoutines::_safefetchN_fault_pc,
3532                                                        &amp;StubRoutines::_safefetchN_continuation_pc);
3533 
3534 #ifdef COMPILER2
3535     if (UseMultiplyToLenIntrinsic) {
3536       StubRoutines::_multiplyToLen = generate_multiplyToLen();
3537     }
<span class="line-removed">3538 #endif</span>
<span class="line-removed">3539 </span>
3540     if (UseSquareToLenIntrinsic) {
3541       StubRoutines::_squareToLen = generate_squareToLen();
3542     }
3543     if (UseMulAddIntrinsic) {
3544       StubRoutines::_mulAdd = generate_mulAdd();
3545     }
3546     if (UseMontgomeryMultiplyIntrinsic) {
3547       StubRoutines::_montgomeryMultiply
3548         = CAST_FROM_FN_PTR(address, SharedRuntime::montgomery_multiply);
3549     }
3550     if (UseMontgomerySquareIntrinsic) {
3551       StubRoutines::_montgomerySquare
3552         = CAST_FROM_FN_PTR(address, SharedRuntime::montgomery_square);
3553     }







3554 
3555     if (UseAESIntrinsics) {
3556       StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
3557       StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
3558     }
3559 
3560     if (UseSHA256Intrinsics) {
3561       StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(false, &quot;sha256_implCompress&quot;);
3562       StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(true,  &quot;sha256_implCompressMB&quot;);
3563     }
3564     if (UseSHA512Intrinsics) {
3565       StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(false, &quot;sha512_implCompress&quot;);
3566       StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(true, &quot;sha512_implCompressMB&quot;);
3567     }
3568   }
3569 
3570  public:
3571   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
3572     // replace the standard masm with a special one:
3573     _masm = new MacroAssembler(code);
3574     if (all) {
3575       generate_all();
3576     } else {
3577       generate_initial();
3578     }
3579   }
3580 };
3581 

3582 void StubGenerator_generate(CodeBuffer* code, bool all) {



3583   StubGenerator g(code, all);
3584 }
</pre>
</td>
<td>
<hr />
<pre>
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;
  31 #include &quot;nativeInst_ppc.hpp&quot;
  32 #include &quot;oops/instanceOop.hpp&quot;
  33 #include &quot;oops/method.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;prims/methodHandles.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/handles.inline.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/thread.inline.hpp&quot;
  43 #include &quot;utilities/align.hpp&quot;
<span class="line-added">  44 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  45 
  46 // Declaration and definition of StubGenerator (no .hpp file).
  47 // For a more detailed description of the stub routine structure
  48 // see the comment in stubRoutines.hpp.
  49 
  50 #define __ _masm-&gt;
  51 
  52 #ifdef PRODUCT
  53 #define BLOCK_COMMENT(str) // nothing
  54 #else
  55 #define BLOCK_COMMENT(str) __ block_comment(str)
  56 #endif
  57 
  58 #if defined(ABI_ELFv2)
  59 #define STUB_ENTRY(name) StubRoutines::name()
  60 #else
  61 #define STUB_ENTRY(name) ((FunctionDescriptor*)StubRoutines::name())-&gt;entry()
  62 #endif
  63 
  64 class StubGenerator: public StubCodeGenerator {
</pre>
<hr />
<pre>
 424   //
 425   //   LR:     The pc the runtime library callee wants to return to.
 426   //           Since the exception occurred in the callee, the return pc
 427   //           from the point of view of Java is the exception pc.
 428   //   thread: Needed for method handles.
 429   //
 430   // Invalidate:
 431   //
 432   //   volatile registers (except below).
 433   //
 434   // Update:
 435   //
 436   //   R4_ARG2: exception
 437   //
 438   // (LR is unchanged and is live out).
 439   //
 440   address generate_forward_exception() {
 441     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;forward_exception&quot;);
 442     address start = __ pc();
 443 

 444     if (VerifyOops) {
 445       // Get pending exception oop.
 446       __ ld(R3_ARG1,
 447                 in_bytes(Thread::pending_exception_offset()),
 448                 R16_thread);
 449       // Make sure that this code is only executed if there is a pending exception.
 450       {
 451         Label L;
 452         __ cmpdi(CCR0, R3_ARG1, 0);
 453         __ bne(CCR0, L);
 454         __ stop(&quot;StubRoutines::forward exception: no pending exception (1)&quot;);
 455         __ bind(L);
 456       }
 457       __ verify_oop(R3_ARG1, &quot;StubRoutines::forward exception: not an oop&quot;);
 458     }

 459 
 460     // Save LR/CR and copy exception pc (LR) into R4_ARG2.
 461     __ save_LR_CR(R4_ARG2);
 462     __ push_frame_reg_args(0, R0);
 463     // Find exception handler.
 464     __ call_VM_leaf(CAST_FROM_FN_PTR(address,
 465                      SharedRuntime::exception_handler_for_return_address),
 466                     R16_thread,
 467                     R4_ARG2);
 468     // Copy handler&#39;s address.
 469     __ mtctr(R3_RET);
 470     __ pop_frame();
 471     __ restore_LR_CR(R0);
 472 
 473     // Set up the arguments for the exception handler:
 474     //  - R3_ARG1: exception oop
 475     //  - R4_ARG2: exception pc.
 476 
 477     // Load pending exception oop.
 478     __ ld(R3_ARG1,
</pre>
<hr />
<pre>
 684 
 685     // Clear rest.
 686     __ bind(restloop);
 687       __ std(zero_reg, 0, base_ptr_reg);        // Clear 8byte aligned block.
 688       __ std(zero_reg, 8, base_ptr_reg);        // Clear 8byte aligned block.
 689       __ addi(base_ptr_reg, base_ptr_reg, 16);
 690     __ bdnz(restloop);
 691 
 692     __ bind(lastdword);
 693     __ beq(CCR1, done);
 694     __ std(zero_reg, 0, base_ptr_reg);
 695     __ bind(done);
 696     __ blr();                                   // return
 697 
 698     return start;
 699   }
 700 
 701 #if !defined(PRODUCT)
 702   // Wrapper which calls oopDesc::is_oop_or_null()
 703   // Only called by MacroAssembler::verify_oop
<span class="line-modified"> 704   static void verify_oop_helper(const char* message, oopDesc* o) {</span>
 705     if (!oopDesc::is_oop_or_null(o)) {
<span class="line-modified"> 706       fatal(&quot;%s. oop: &quot; PTR_FORMAT, message, p2i(o));</span>
 707     }
 708     ++ StubRoutines::_verify_oop_count;
 709   }
 710 #endif
 711 
 712   // Return address of code to be called from code generated by
 713   // MacroAssembler::verify_oop.
 714   //
 715   // Don&#39;t generate, rather use C++ code.
 716   address generate_verify_oop() {
 717     // this is actually a `FunctionDescriptor*&#39;.
 718     address start = 0;
 719 
 720 #if !defined(PRODUCT)
 721     start = CAST_FROM_FN_PTR(address, verify_oop_helper);
 722 #endif
 723 
 724     return start;
 725   }
 726 

 727   // -XX:+OptimizeFill : convert fill/copy loops into intrinsic
 728   //
 729   // The code is implemented(ported from sparc) as we believe it benefits JVM98, however
 730   // tracing(-XX:+TraceOptimizeFill) shows the intrinsic replacement doesn&#39;t happen at all!
 731   //
 732   // Source code in function is_range_check_if() shows that OptimizeFill relaxed the condition
 733   // for turning on loop predication optimization, and hence the behavior of &quot;array range check&quot;
 734   // and &quot;loop invariant check&quot; could be influenced, which potentially boosted JVM98.
 735   //
 736   // Generate stub for disjoint short fill. If &quot;aligned&quot; is true, the
 737   // &quot;to&quot; address is assumed to be heapword aligned.
 738   //
 739   // Arguments for generated stub:
 740   //   to:    R3_ARG1
 741   //   value: R4_ARG2
 742   //   count: R5_ARG3 treated as signed
 743   //
 744   address generate_fill(BasicType t, bool aligned, const char* name) {
 745     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
 746     address start = __ function_entry();
</pre>
<hr />
<pre>
 933   //   R5_ARG3    -  element count
 934   //
 935   void array_overlap_test(address no_overlap_target, int log2_elem_size) {
 936     Register tmp1 = R6_ARG4;
 937     Register tmp2 = R7_ARG5;
 938 
 939     assert_positive_int(R5_ARG3);
 940 
 941     __ subf(tmp1, R3_ARG1, R4_ARG2); // distance in bytes
 942     __ sldi(tmp2, R5_ARG3, log2_elem_size); // size in bytes
 943     __ cmpld(CCR0, R3_ARG1, R4_ARG2); // Use unsigned comparison!
 944     __ cmpld(CCR1, tmp1, tmp2);
 945     __ crnand(CCR0, Assembler::less, CCR1, Assembler::less);
 946     // Overlaps if Src before dst and distance smaller than size.
 947     // Branch to forward copy routine otherwise (within range of 32kB).
 948     __ bc(Assembler::bcondCRbiIs1, Assembler::bi0(CCR0, Assembler::less), no_overlap_target);
 949 
 950     // need to copy backwards
 951   }
 952 
<span class="line-added"> 953   // This is common errorexit stub for UnsafeCopyMemory.</span>
<span class="line-added"> 954   address generate_unsafecopy_common_error_exit() {</span>
<span class="line-added"> 955     address start_pc = __ pc();</span>
<span class="line-added"> 956     Register tmp1 = R6_ARG4;</span>
<span class="line-added"> 957     // probably copy stub would have changed value reset it.</span>
<span class="line-added"> 958     if (VM_Version::has_mfdscr()) {</span>
<span class="line-added"> 959       __ load_const_optimized(tmp1, VM_Version::_dscr_val);</span>
<span class="line-added"> 960       __ mtdscr(tmp1);</span>
<span class="line-added"> 961     }</span>
<span class="line-added"> 962     __ li(R3_RET, 0); // return 0</span>
<span class="line-added"> 963     __ blr();</span>
<span class="line-added"> 964     return start_pc;</span>
<span class="line-added"> 965   }</span>
<span class="line-added"> 966 </span>
 967   // The guideline in the implementations of generate_disjoint_xxx_copy
 968   // (xxx=byte,short,int,long,oop) is to copy as many elements as possible with
 969   // single instructions, but to avoid alignment interrupts (see subsequent
 970   // comment). Furthermore, we try to minimize misaligned access, even
 971   // though they cause no alignment interrupt.
 972   //
 973   // In Big-Endian mode, the PowerPC architecture requires implementations to
 974   // handle automatically misaligned integer halfword and word accesses,
 975   // word-aligned integer doubleword accesses, and word-aligned floating-point
 976   // accesses. Other accesses may or may not generate an Alignment interrupt
 977   // depending on the implementation.
 978   // Alignment interrupt handling may require on the order of hundreds of cycles,
 979   // so every effort should be made to avoid misaligned memory values.
 980   //
 981   //
 982   // Generate stub for disjoint byte copy.  If &quot;aligned&quot; is true, the
 983   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
 984   //
 985   // Arguments for generated stub:
 986   //      from:  R3_ARG1
 987   //      to:    R4_ARG2
 988   //      count: R5_ARG3 treated as signed
 989   //
 990   address generate_disjoint_byte_copy(bool aligned, const char * name) {
 991     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
 992     address start = __ function_entry();
 993     assert_positive_int(R5_ARG3);
 994 
 995     Register tmp1 = R6_ARG4;
 996     Register tmp2 = R7_ARG5;
 997     Register tmp3 = R8_ARG6;
 998     Register tmp4 = R9_ARG7;
 999 
1000     VectorSRegister tmp_vsr1  = VSR1;
1001     VectorSRegister tmp_vsr2  = VSR2;
1002 
1003     Label l_1, l_2, l_3, l_4, l_5, l_6, l_7, l_8, l_9, l_10;
<span class="line-added">1004     {</span>
<span class="line-added">1005       // UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit</span>
<span class="line-added">1006       UnsafeCopyMemoryMark ucmm(this, !aligned, false);</span>
1007 
<span class="line-modified">1008       // Don&#39;t try anything fancy if arrays don&#39;t have many elements.</span>
<span class="line-modified">1009       __ li(tmp3, 0);</span>
<span class="line-modified">1010       __ cmpwi(CCR0, R5_ARG3, 17);</span>
<span class="line-modified">1011       __ ble(CCR0, l_6); // copy 4 at a time</span>
1012 
<span class="line-modified">1013       if (!aligned) {</span>
<span class="line-modified">1014         __ xorr(tmp1, R3_ARG1, R4_ARG2);</span>
<span class="line-modified">1015         __ andi_(tmp1, tmp1, 3);</span>
<span class="line-modified">1016         __ bne(CCR0, l_6); // If arrays don&#39;t have the same alignment mod 4, do 4 element copy.</span>














1017 
<span class="line-modified">1018         // Copy elements if necessary to align to 4 bytes.</span>
<span class="line-modified">1019         __ neg(tmp1, R3_ARG1); // Compute distance to alignment boundary.</span>
<span class="line-added">1020         __ andi_(tmp1, tmp1, 3);</span>
<span class="line-added">1021         __ beq(CCR0, l_2);</span>
1022 
<span class="line-modified">1023         __ subf(R5_ARG3, tmp1, R5_ARG3);</span>
<span class="line-modified">1024         __ bind(l_9);</span>
<span class="line-modified">1025         __ lbz(tmp2, 0, R3_ARG1);</span>
<span class="line-modified">1026         __ addic_(tmp1, tmp1, -1);</span>
<span class="line-added">1027         __ stb(tmp2, 0, R4_ARG2);</span>
<span class="line-added">1028         __ addi(R3_ARG1, R3_ARG1, 1);</span>
<span class="line-added">1029         __ addi(R4_ARG2, R4_ARG2, 1);</span>
<span class="line-added">1030         __ bne(CCR0, l_9);</span>
<span class="line-added">1031 </span>
<span class="line-added">1032         __ bind(l_2);</span>
<span class="line-added">1033       }</span>
1034 
<span class="line-modified">1035       // copy 8 elements at a time</span>
<span class="line-modified">1036       __ xorr(tmp2, R3_ARG1, R4_ARG2); // skip if src &amp; dest have differing alignment mod 8</span>
<span class="line-modified">1037       __ andi_(tmp1, tmp2, 7);</span>
<span class="line-added">1038       __ bne(CCR0, l_7); // not same alignment -&gt; to or from is aligned -&gt; copy 8</span>
1039 
<span class="line-modified">1040       // copy a 2-element word if necessary to align to 8 bytes</span>
<span class="line-modified">1041       __ andi_(R0, R3_ARG1, 7);</span>
<span class="line-modified">1042       __ beq(CCR0, l_7);</span>





1043 
<span class="line-modified">1044       __ lwzx(tmp2, R3_ARG1, tmp3);</span>
<span class="line-modified">1045       __ addi(R5_ARG3, R5_ARG3, -4);</span>
<span class="line-modified">1046       __ stwx(tmp2, R4_ARG2, tmp3);</span>
<span class="line-added">1047       { // FasterArrayCopy</span>
<span class="line-added">1048         __ addi(R3_ARG1, R3_ARG1, 4);</span>
<span class="line-added">1049         __ addi(R4_ARG2, R4_ARG2, 4);</span>
<span class="line-added">1050       }</span>
<span class="line-added">1051       __ bind(l_7);</span>
1052 
<span class="line-modified">1053       { // FasterArrayCopy</span>
<span class="line-modified">1054         __ cmpwi(CCR0, R5_ARG3, 31);</span>
<span class="line-modified">1055         __ ble(CCR0, l_6); // copy 2 at a time if less than 32 elements remain</span>
1056 
<span class="line-modified">1057         __ srdi(tmp1, R5_ARG3, 5);</span>
<span class="line-added">1058         __ andi_(R5_ARG3, R5_ARG3, 31);</span>
<span class="line-added">1059         __ mtctr(tmp1);</span>
1060 
<span class="line-modified">1061        if (!VM_Version::has_vsx()) {</span>














1062 
<span class="line-modified">1063         __ bind(l_8);</span>
<span class="line-added">1064         // Use unrolled version for mass copying (copy 32 elements a time)</span>
<span class="line-added">1065         // Load feeding store gets zero latency on Power6, however not on Power5.</span>
<span class="line-added">1066         // Therefore, the following sequence is made for the good of both.</span>
<span class="line-added">1067         __ ld(tmp1, 0, R3_ARG1);</span>
<span class="line-added">1068         __ ld(tmp2, 8, R3_ARG1);</span>
<span class="line-added">1069         __ ld(tmp3, 16, R3_ARG1);</span>
<span class="line-added">1070         __ ld(tmp4, 24, R3_ARG1);</span>
<span class="line-added">1071         __ std(tmp1, 0, R4_ARG2);</span>
<span class="line-added">1072         __ std(tmp2, 8, R4_ARG2);</span>
<span class="line-added">1073         __ std(tmp3, 16, R4_ARG2);</span>
<span class="line-added">1074         __ std(tmp4, 24, R4_ARG2);</span>
<span class="line-added">1075         __ addi(R3_ARG1, R3_ARG1, 32);</span>
<span class="line-added">1076         __ addi(R4_ARG2, R4_ARG2, 32);</span>
<span class="line-added">1077         __ bdnz(l_8);</span>
1078 
<span class="line-modified">1079       } else { // Processor supports VSX, so use it to mass copy.</span>

1080 
<span class="line-modified">1081         // Prefetch the data into the L2 cache.</span>
<span class="line-modified">1082         __ dcbt(R3_ARG1, 0);</span>



1083 
<span class="line-modified">1084         // If supported set DSCR pre-fetch to deepest.</span>
<span class="line-added">1085         if (VM_Version::has_mfdscr()) {</span>
<span class="line-added">1086           __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);</span>
<span class="line-added">1087           __ mtdscr(tmp2);</span>
<span class="line-added">1088         }</span>
1089 
<span class="line-modified">1090         __ li(tmp1, 16);</span>



1091 
<span class="line-modified">1092         // Backbranch target aligned to 32-byte. Not 16-byte align as</span>
<span class="line-modified">1093         // loop contains &lt; 8 instructions that fit inside a single</span>
<span class="line-modified">1094         // i-cache sector.</span>
<span class="line-modified">1095         __ align(32);</span>






1096 
<span class="line-modified">1097         __ bind(l_10);</span>
<span class="line-modified">1098         // Use loop with VSX load/store instructions to</span>
<span class="line-modified">1099         // copy 32 elements a time.</span>
<span class="line-modified">1100         __ lxvd2x(tmp_vsr1, R3_ARG1);        // Load src</span>
<span class="line-modified">1101         __ stxvd2x(tmp_vsr1, R4_ARG2);       // Store to dst</span>
<span class="line-added">1102         __ lxvd2x(tmp_vsr2, tmp1, R3_ARG1);  // Load src + 16</span>
<span class="line-added">1103         __ stxvd2x(tmp_vsr2, tmp1, R4_ARG2); // Store to dst + 16</span>
<span class="line-added">1104         __ addi(R3_ARG1, R3_ARG1, 32);       // Update src+=32</span>
<span class="line-added">1105         __ addi(R4_ARG2, R4_ARG2, 32);       // Update dsc+=32</span>
<span class="line-added">1106         __ bdnz(l_10);                       // Dec CTR and loop if not zero.</span>
1107 
<span class="line-modified">1108         // Restore DSCR pre-fetch value.</span>
<span class="line-modified">1109         if (VM_Version::has_mfdscr()) {</span>
<span class="line-added">1110           __ load_const_optimized(tmp2, VM_Version::_dscr_val);</span>
<span class="line-added">1111           __ mtdscr(tmp2);</span>
<span class="line-added">1112         }</span>
1113 
<span class="line-modified">1114       } // VSX</span>
<span class="line-added">1115      } // FasterArrayCopy</span>
1116 
<span class="line-modified">1117       __ bind(l_6);</span>





1118 
<span class="line-modified">1119       // copy 4 elements at a time</span>
<span class="line-modified">1120       __ cmpwi(CCR0, R5_ARG3, 4);</span>
<span class="line-modified">1121       __ blt(CCR0, l_1);</span>
<span class="line-modified">1122       __ srdi(tmp1, R5_ARG3, 2);</span>
<span class="line-modified">1123       __ mtctr(tmp1); // is &gt; 0</span>
<span class="line-modified">1124       __ andi_(R5_ARG3, R5_ARG3, 3);</span>




1125 
<span class="line-modified">1126       { // FasterArrayCopy</span>
<span class="line-modified">1127         __ addi(R3_ARG1, R3_ARG1, -4);</span>
<span class="line-modified">1128         __ addi(R4_ARG2, R4_ARG2, -4);</span>
<span class="line-modified">1129         __ bind(l_3);</span>
<span class="line-added">1130         __ lwzu(tmp2, 4, R3_ARG1);</span>
<span class="line-added">1131         __ stwu(tmp2, 4, R4_ARG2);</span>
<span class="line-added">1132         __ bdnz(l_3);</span>
<span class="line-added">1133         __ addi(R3_ARG1, R3_ARG1, 4);</span>
<span class="line-added">1134         __ addi(R4_ARG2, R4_ARG2, 4);</span>
<span class="line-added">1135       }</span>
1136 
<span class="line-modified">1137       // do single element copy</span>
<span class="line-modified">1138       __ bind(l_1);</span>
<span class="line-modified">1139       __ cmpwi(CCR0, R5_ARG3, 0);</span>
<span class="line-modified">1140       __ beq(CCR0, l_4);</span>
1141 
<span class="line-modified">1142       { // FasterArrayCopy</span>
<span class="line-modified">1143         __ mtctr(R5_ARG3);</span>
<span class="line-modified">1144         __ addi(R3_ARG1, R3_ARG1, -1);</span>
<span class="line-modified">1145         __ addi(R4_ARG2, R4_ARG2, -1);</span>
<span class="line-added">1146 </span>
<span class="line-added">1147         __ bind(l_5);</span>
<span class="line-added">1148         __ lbzu(tmp2, 1, R3_ARG1);</span>
<span class="line-added">1149         __ stbu(tmp2, 1, R4_ARG2);</span>
<span class="line-added">1150         __ bdnz(l_5);</span>
<span class="line-added">1151       }</span>
1152     }
1153 
1154     __ bind(l_4);
1155     __ li(R3_RET, 0); // return 0
1156     __ blr();
1157 
1158     return start;
1159   }
1160 
1161   // Generate stub for conjoint byte copy.  If &quot;aligned&quot; is true, the
1162   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1163   //
1164   // Arguments for generated stub:
1165   //      from:  R3_ARG1
1166   //      to:    R4_ARG2
1167   //      count: R5_ARG3 treated as signed
1168   //
1169   address generate_conjoint_byte_copy(bool aligned, const char * name) {
1170     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1171     address start = __ function_entry();
1172     assert_positive_int(R5_ARG3);
1173 
1174     Register tmp1 = R6_ARG4;
1175     Register tmp2 = R7_ARG5;
1176     Register tmp3 = R8_ARG6;
1177 
1178     address nooverlap_target = aligned ?
1179       STUB_ENTRY(arrayof_jbyte_disjoint_arraycopy) :
1180       STUB_ENTRY(jbyte_disjoint_arraycopy);
1181 
1182     array_overlap_test(nooverlap_target, 0);
1183     // Do reverse copy. We assume the case of actual overlap is rare enough
1184     // that we don&#39;t have to optimize it.
1185     Label l_1, l_2;
<span class="line-modified">1186     {</span>
<span class="line-modified">1187       // UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit</span>
<span class="line-modified">1188       UnsafeCopyMemoryMark ucmm(this, !aligned, false);</span>
<span class="line-modified">1189       __ b(l_2);</span>
<span class="line-modified">1190       __ bind(l_1);</span>
<span class="line-modified">1191       __ stbx(tmp1, R4_ARG2, R5_ARG3);</span>
<span class="line-modified">1192       __ bind(l_2);</span>
<span class="line-modified">1193       __ addic_(R5_ARG3, R5_ARG3, -1);</span>
<span class="line-modified">1194       __ lbzx(tmp1, R3_ARG1, R5_ARG3);</span>
<span class="line-added">1195       __ bge(CCR0, l_1);</span>
<span class="line-added">1196     }</span>
1197     __ li(R3_RET, 0); // return 0
1198     __ blr();
1199 
1200     return start;
1201   }
1202 
1203   // Generate stub for disjoint short copy.  If &quot;aligned&quot; is true, the
1204   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1205   //
1206   // Arguments for generated stub:
1207   //      from:  R3_ARG1
1208   //      to:    R4_ARG2
1209   //  elm.count: R5_ARG3 treated as signed
1210   //
1211   // Strategy for aligned==true:
1212   //
1213   //  If length &lt;= 9:
1214   //     1. copy 2 elements at a time (l_6)
1215   //     2. copy last element if original element count was odd (l_1)
1216   //
</pre>
<hr />
<pre>
1253   //
1254   //  TODO:
1255   //
1256   //  1. check if aligning the backbranch target of loops is beneficial
1257   //
1258   address generate_disjoint_short_copy(bool aligned, const char * name) {
1259     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1260 
1261     Register tmp1 = R6_ARG4;
1262     Register tmp2 = R7_ARG5;
1263     Register tmp3 = R8_ARG6;
1264     Register tmp4 = R9_ARG7;
1265 
1266     VectorSRegister tmp_vsr1  = VSR1;
1267     VectorSRegister tmp_vsr2  = VSR2;
1268 
1269     address start = __ function_entry();
1270     assert_positive_int(R5_ARG3);
1271 
1272     Label l_1, l_2, l_3, l_4, l_5, l_6, l_7, l_8, l_9;
<span class="line-added">1273     {</span>
<span class="line-added">1274       // UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit</span>
<span class="line-added">1275       UnsafeCopyMemoryMark ucmm(this, !aligned, false);</span>
<span class="line-added">1276       // don&#39;t try anything fancy if arrays don&#39;t have many elements</span>
<span class="line-added">1277       __ li(tmp3, 0);</span>
<span class="line-added">1278       __ cmpwi(CCR0, R5_ARG3, 9);</span>
<span class="line-added">1279       __ ble(CCR0, l_6); // copy 2 at a time</span>
1280 
<span class="line-modified">1281       if (!aligned) {</span>
<span class="line-modified">1282         __ xorr(tmp1, R3_ARG1, R4_ARG2);</span>
<span class="line-modified">1283         __ andi_(tmp1, tmp1, 3);</span>
<span class="line-modified">1284         __ bne(CCR0, l_6); // if arrays don&#39;t have the same alignment mod 4, do 2 element copy</span>





1285 
<span class="line-modified">1286         // At this point it is guaranteed that both, from and to have the same alignment mod 4.</span>
1287 
<span class="line-modified">1288         // Copy 1 element if necessary to align to 4 bytes.</span>
<span class="line-modified">1289         __ andi_(tmp1, R3_ARG1, 3);</span>
<span class="line-modified">1290         __ beq(CCR0, l_2);</span>
1291 
<span class="line-modified">1292         __ lhz(tmp2, 0, R3_ARG1);</span>
<span class="line-modified">1293         __ addi(R3_ARG1, R3_ARG1, 2);</span>
<span class="line-modified">1294         __ sth(tmp2, 0, R4_ARG2);</span>
<span class="line-modified">1295         __ addi(R4_ARG2, R4_ARG2, 2);</span>
<span class="line-modified">1296         __ addi(R5_ARG3, R5_ARG3, -1);</span>
<span class="line-modified">1297         __ bind(l_2);</span>
1298 
<span class="line-modified">1299         // At this point the positions of both, from and to, are at least 4 byte aligned.</span>
1300 
<span class="line-modified">1301         // Copy 4 elements at a time.</span>
<span class="line-modified">1302         // Align to 8 bytes, but only if both, from and to, have same alignment mod 8.</span>
<span class="line-modified">1303         __ xorr(tmp2, R3_ARG1, R4_ARG2);</span>
<span class="line-modified">1304         __ andi_(tmp1, tmp2, 7);</span>
<span class="line-modified">1305         __ bne(CCR0, l_7); // not same alignment mod 8 -&gt; copy 4, either from or to will be unaligned</span>
1306 
<span class="line-modified">1307         // Copy a 2-element word if necessary to align to 8 bytes.</span>
<span class="line-modified">1308         __ andi_(R0, R3_ARG1, 7);</span>
<span class="line-modified">1309         __ beq(CCR0, l_7);</span>
1310 
<span class="line-modified">1311         __ lwzx(tmp2, R3_ARG1, tmp3);</span>
<span class="line-modified">1312         __ addi(R5_ARG3, R5_ARG3, -2);</span>
<span class="line-modified">1313         __ stwx(tmp2, R4_ARG2, tmp3);</span>
<span class="line-modified">1314         { // FasterArrayCopy</span>
<span class="line-modified">1315           __ addi(R3_ARG1, R3_ARG1, 4);</span>
<span class="line-modified">1316           __ addi(R4_ARG2, R4_ARG2, 4);</span>
<span class="line-added">1317         }</span>
1318       }










1319 
<span class="line-modified">1320       __ bind(l_7);</span>




















1321 
<span class="line-modified">1322       // Copy 4 elements at a time; either the loads or the stores can</span>
<span class="line-added">1323       // be unaligned if aligned == false.</span>
1324 
<span class="line-modified">1325       { // FasterArrayCopy</span>
<span class="line-modified">1326         __ cmpwi(CCR0, R5_ARG3, 15);</span>
<span class="line-added">1327         __ ble(CCR0, l_6); // copy 2 at a time if less than 16 elements remain</span>
<span class="line-added">1328 </span>
<span class="line-added">1329         __ srdi(tmp1, R5_ARG3, 4);</span>
<span class="line-added">1330         __ andi_(R5_ARG3, R5_ARG3, 15);</span>
<span class="line-added">1331         __ mtctr(tmp1);</span>
<span class="line-added">1332 </span>
<span class="line-added">1333         if (!VM_Version::has_vsx()) {</span>
<span class="line-added">1334 </span>
<span class="line-added">1335           __ bind(l_8);</span>
<span class="line-added">1336           // Use unrolled version for mass copying (copy 16 elements a time).</span>
<span class="line-added">1337           // Load feeding store gets zero latency on Power6, however not on Power5.</span>
<span class="line-added">1338           // Therefore, the following sequence is made for the good of both.</span>
<span class="line-added">1339           __ ld(tmp1, 0, R3_ARG1);</span>
<span class="line-added">1340           __ ld(tmp2, 8, R3_ARG1);</span>
<span class="line-added">1341           __ ld(tmp3, 16, R3_ARG1);</span>
<span class="line-added">1342           __ ld(tmp4, 24, R3_ARG1);</span>
<span class="line-added">1343           __ std(tmp1, 0, R4_ARG2);</span>
<span class="line-added">1344           __ std(tmp2, 8, R4_ARG2);</span>
<span class="line-added">1345           __ std(tmp3, 16, R4_ARG2);</span>
<span class="line-added">1346           __ std(tmp4, 24, R4_ARG2);</span>
<span class="line-added">1347           __ addi(R3_ARG1, R3_ARG1, 32);</span>
<span class="line-added">1348           __ addi(R4_ARG2, R4_ARG2, 32);</span>
<span class="line-added">1349           __ bdnz(l_8);</span>
<span class="line-added">1350 </span>
<span class="line-added">1351         } else { // Processor supports VSX, so use it to mass copy.</span>
<span class="line-added">1352 </span>
<span class="line-added">1353           // Prefetch src data into L2 cache.</span>
<span class="line-added">1354           __ dcbt(R3_ARG1, 0);</span>
<span class="line-added">1355 </span>
<span class="line-added">1356           // If supported set DSCR pre-fetch to deepest.</span>
<span class="line-added">1357           if (VM_Version::has_mfdscr()) {</span>
<span class="line-added">1358             __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);</span>
<span class="line-added">1359             __ mtdscr(tmp2);</span>
<span class="line-added">1360           }</span>
<span class="line-added">1361           __ li(tmp1, 16);</span>
<span class="line-added">1362 </span>
<span class="line-added">1363           // Backbranch target aligned to 32-byte. It&#39;s not aligned 16-byte</span>
<span class="line-added">1364           // as loop contains &lt; 8 instructions that fit inside a single</span>
<span class="line-added">1365           // i-cache sector.</span>
<span class="line-added">1366           __ align(32);</span>
<span class="line-added">1367 </span>
<span class="line-added">1368           __ bind(l_9);</span>
<span class="line-added">1369           // Use loop with VSX load/store instructions to</span>
<span class="line-added">1370           // copy 16 elements a time.</span>
<span class="line-added">1371           __ lxvd2x(tmp_vsr1, R3_ARG1);        // Load from src.</span>
<span class="line-added">1372           __ stxvd2x(tmp_vsr1, R4_ARG2);       // Store to dst.</span>
<span class="line-added">1373           __ lxvd2x(tmp_vsr2, R3_ARG1, tmp1);  // Load from src + 16.</span>
<span class="line-added">1374           __ stxvd2x(tmp_vsr2, R4_ARG2, tmp1); // Store to dst + 16.</span>
<span class="line-added">1375           __ addi(R3_ARG1, R3_ARG1, 32);       // Update src+=32.</span>
<span class="line-added">1376           __ addi(R4_ARG2, R4_ARG2, 32);       // Update dsc+=32.</span>
<span class="line-added">1377           __ bdnz(l_9);                        // Dec CTR and loop if not zero.</span>
<span class="line-added">1378 </span>
<span class="line-added">1379           // Restore DSCR pre-fetch value.</span>
<span class="line-added">1380           if (VM_Version::has_mfdscr()) {</span>
<span class="line-added">1381             __ load_const_optimized(tmp2, VM_Version::_dscr_val);</span>
<span class="line-added">1382             __ mtdscr(tmp2);</span>
<span class="line-added">1383           }</span>
1384 




1385         }
<span class="line-modified">1386       } // FasterArrayCopy</span>
<span class="line-added">1387       __ bind(l_6);</span>
1388 
<span class="line-modified">1389       // copy 2 elements at a time</span>
<span class="line-modified">1390       { // FasterArrayCopy</span>
<span class="line-modified">1391         __ cmpwi(CCR0, R5_ARG3, 2);</span>
<span class="line-modified">1392         __ blt(CCR0, l_1);</span>
<span class="line-added">1393         __ srdi(tmp1, R5_ARG3, 1);</span>
<span class="line-added">1394         __ andi_(R5_ARG3, R5_ARG3, 1);</span>
1395 
<span class="line-modified">1396         __ addi(R3_ARG1, R3_ARG1, -4);</span>
<span class="line-modified">1397         __ addi(R4_ARG2, R4_ARG2, -4);</span>
<span class="line-modified">1398         __ mtctr(tmp1);</span>







1399 
<span class="line-modified">1400         __ bind(l_3);</span>
<span class="line-modified">1401         __ lwzu(tmp2, 4, R3_ARG1);</span>
<span class="line-modified">1402         __ stwu(tmp2, 4, R4_ARG2);</span>
<span class="line-modified">1403         __ bdnz(l_3);</span>

1404 
<span class="line-added">1405         __ addi(R3_ARG1, R3_ARG1, 4);</span>
<span class="line-added">1406         __ addi(R4_ARG2, R4_ARG2, 4);</span>
1407       }


1408 
<span class="line-modified">1409       // do single element copy</span>
<span class="line-modified">1410       __ bind(l_1);</span>
<span class="line-modified">1411       __ cmpwi(CCR0, R5_ARG3, 0);</span>
<span class="line-modified">1412       __ beq(CCR0, l_4);</span>











1413 
<span class="line-modified">1414       { // FasterArrayCopy</span>
<span class="line-modified">1415         __ mtctr(R5_ARG3);</span>
<span class="line-added">1416         __ addi(R3_ARG1, R3_ARG1, -2);</span>
<span class="line-added">1417         __ addi(R4_ARG2, R4_ARG2, -2);</span>
<span class="line-added">1418 </span>
<span class="line-added">1419         __ bind(l_5);</span>
<span class="line-added">1420         __ lhzu(tmp2, 2, R3_ARG1);</span>
<span class="line-added">1421         __ sthu(tmp2, 2, R4_ARG2);</span>
<span class="line-added">1422         __ bdnz(l_5);</span>
<span class="line-added">1423       }</span>
1424     }
1425 















1426     __ bind(l_4);
1427     __ li(R3_RET, 0); // return 0
1428     __ blr();
1429 
1430     return start;
1431   }
1432 
1433   // Generate stub for conjoint short copy.  If &quot;aligned&quot; is true, the
1434   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1435   //
1436   // Arguments for generated stub:
1437   //      from:  R3_ARG1
1438   //      to:    R4_ARG2
1439   //      count: R5_ARG3 treated as signed
1440   //
1441   address generate_conjoint_short_copy(bool aligned, const char * name) {
1442     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1443     address start = __ function_entry();
1444     assert_positive_int(R5_ARG3);
1445 
1446     Register tmp1 = R6_ARG4;
1447     Register tmp2 = R7_ARG5;
1448     Register tmp3 = R8_ARG6;
1449 
1450     address nooverlap_target = aligned ?
1451       STUB_ENTRY(arrayof_jshort_disjoint_arraycopy) :
1452       STUB_ENTRY(jshort_disjoint_arraycopy);
1453 
1454     array_overlap_test(nooverlap_target, 1);
1455 
1456     Label l_1, l_2;
<span class="line-modified">1457     {</span>
<span class="line-modified">1458       // UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit</span>
<span class="line-modified">1459       UnsafeCopyMemoryMark ucmm(this, !aligned, false);</span>
<span class="line-modified">1460       __ sldi(tmp1, R5_ARG3, 1);</span>
<span class="line-modified">1461       __ b(l_2);</span>
<span class="line-modified">1462       __ bind(l_1);</span>
<span class="line-modified">1463       __ sthx(tmp2, R4_ARG2, tmp1);</span>
<span class="line-modified">1464       __ bind(l_2);</span>
<span class="line-modified">1465       __ addic_(tmp1, tmp1, -2);</span>
<span class="line-added">1466       __ lhzx(tmp2, R3_ARG1, tmp1);</span>
<span class="line-added">1467       __ bge(CCR0, l_1);</span>
<span class="line-added">1468     }</span>
1469     __ li(R3_RET, 0); // return 0
1470     __ blr();
1471 
1472     return start;
1473   }
1474 
1475   // Generate core code for disjoint int copy (and oop copy on 32-bit).  If &quot;aligned&quot;
1476   // is true, the &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1477   //
1478   // Arguments:
1479   //      from:  R3_ARG1
1480   //      to:    R4_ARG2
1481   //      count: R5_ARG3 treated as signed
1482   //
1483   void generate_disjoint_int_copy_core(bool aligned) {
1484     Register tmp1 = R6_ARG4;
1485     Register tmp2 = R7_ARG5;
1486     Register tmp3 = R8_ARG6;
1487     Register tmp4 = R0;
1488 
</pre>
<hr />
<pre>
1596       __ stwu(tmp2, 4, R4_ARG2);
1597       __ bdnz(l_3);
1598     }
1599 
1600     __ bind(l_1);
1601     return;
1602   }
1603 
1604   // Generate stub for disjoint int copy.  If &quot;aligned&quot; is true, the
1605   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1606   //
1607   // Arguments for generated stub:
1608   //      from:  R3_ARG1
1609   //      to:    R4_ARG2
1610   //      count: R5_ARG3 treated as signed
1611   //
1612   address generate_disjoint_int_copy(bool aligned, const char * name) {
1613     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1614     address start = __ function_entry();
1615     assert_positive_int(R5_ARG3);
<span class="line-modified">1616     {</span>
<span class="line-added">1617       // UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit</span>
<span class="line-added">1618       UnsafeCopyMemoryMark ucmm(this, !aligned, false);</span>
<span class="line-added">1619       generate_disjoint_int_copy_core(aligned);</span>
<span class="line-added">1620     }</span>
1621     __ li(R3_RET, 0); // return 0
1622     __ blr();
1623     return start;
1624   }
1625 
1626   // Generate core code for conjoint int copy (and oop copy on
1627   // 32-bit).  If &quot;aligned&quot; is true, the &quot;from&quot; and &quot;to&quot; addresses
1628   // are assumed to be heapword aligned.
1629   //
1630   // Arguments:
1631   //      from:  R3_ARG1
1632   //      to:    R4_ARG2
1633   //      count: R5_ARG3 treated as signed
1634   //
1635   void generate_conjoint_int_copy_core(bool aligned) {
1636     // Do reverse copy.  We assume the case of actual overlap is rare enough
1637     // that we don&#39;t have to optimize it.
1638 
1639     Label l_1, l_2, l_3, l_4, l_5, l_6, l_7;
1640 
</pre>
<hr />
<pre>
1748     }
1749   }
1750 
1751   // Generate stub for conjoint int copy.  If &quot;aligned&quot; is true, the
1752   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1753   //
1754   // Arguments for generated stub:
1755   //      from:  R3_ARG1
1756   //      to:    R4_ARG2
1757   //      count: R5_ARG3 treated as signed
1758   //
1759   address generate_conjoint_int_copy(bool aligned, const char * name) {
1760     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1761     address start = __ function_entry();
1762     assert_positive_int(R5_ARG3);
1763     address nooverlap_target = aligned ?
1764       STUB_ENTRY(arrayof_jint_disjoint_arraycopy) :
1765       STUB_ENTRY(jint_disjoint_arraycopy);
1766 
1767     array_overlap_test(nooverlap_target, 2);
<span class="line-modified">1768     {</span>
<span class="line-modified">1769       // UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit</span>
<span class="line-added">1770       UnsafeCopyMemoryMark ucmm(this, !aligned, false);</span>
<span class="line-added">1771       generate_conjoint_int_copy_core(aligned);</span>
<span class="line-added">1772     }</span>
1773 
1774     __ li(R3_RET, 0); // return 0
1775     __ blr();
1776 
1777     return start;
1778   }
1779 
1780   // Generate core code for disjoint long copy (and oop copy on
1781   // 64-bit).  If &quot;aligned&quot; is true, the &quot;from&quot; and &quot;to&quot; addresses
1782   // are assumed to be heapword aligned.
1783   //
1784   // Arguments:
1785   //      from:  R3_ARG1
1786   //      to:    R4_ARG2
1787   //      count: R5_ARG3 treated as signed
1788   //
1789   void generate_disjoint_long_copy_core(bool aligned) {
1790     Register tmp1 = R6_ARG4;
1791     Register tmp2 = R7_ARG5;
1792     Register tmp3 = R8_ARG6;
</pre>
<hr />
<pre>
1874       __ ldu(R0, 8, R3_ARG1);
1875       __ stdu(R0, 8, R4_ARG2);
1876       __ bdnz(l_2);
1877 
1878     }
1879     __ bind(l_1);
1880   }
1881 
1882   // Generate stub for disjoint long copy.  If &quot;aligned&quot; is true, the
1883   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1884   //
1885   // Arguments for generated stub:
1886   //      from:  R3_ARG1
1887   //      to:    R4_ARG2
1888   //      count: R5_ARG3 treated as signed
1889   //
1890   address generate_disjoint_long_copy(bool aligned, const char * name) {
1891     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1892     address start = __ function_entry();
1893     assert_positive_int(R5_ARG3);
<span class="line-modified">1894     {</span>
<span class="line-added">1895       // UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit</span>
<span class="line-added">1896       UnsafeCopyMemoryMark ucmm(this, !aligned, false);</span>
<span class="line-added">1897       generate_disjoint_long_copy_core(aligned);</span>
<span class="line-added">1898     }</span>
1899     __ li(R3_RET, 0); // return 0
1900     __ blr();
1901 
<span class="line-modified">1902   return start;</span>
1903   }
1904 
1905   // Generate core code for conjoint long copy (and oop copy on
1906   // 64-bit).  If &quot;aligned&quot; is true, the &quot;from&quot; and &quot;to&quot; addresses
1907   // are assumed to be heapword aligned.
1908   //
1909   // Arguments:
1910   //      from:  R3_ARG1
1911   //      to:    R4_ARG2
1912   //      count: R5_ARG3 treated as signed
1913   //
1914   void generate_conjoint_long_copy_core(bool aligned) {
1915     Register tmp1 = R6_ARG4;
1916     Register tmp2 = R7_ARG5;
1917     Register tmp3 = R8_ARG6;
1918     Register tmp4 = R0;
1919 
1920     VectorSRegister tmp_vsr1  = VSR1;
1921     VectorSRegister tmp_vsr2  = VSR2;
1922 
</pre>
<hr />
<pre>
2005     __ bind(l_1);
2006   }
2007 
2008   // Generate stub for conjoint long copy.  If &quot;aligned&quot; is true, the
2009   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
2010   //
2011   // Arguments for generated stub:
2012   //      from:  R3_ARG1
2013   //      to:    R4_ARG2
2014   //      count: R5_ARG3 treated as signed
2015   //
2016   address generate_conjoint_long_copy(bool aligned, const char * name) {
2017     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2018     address start = __ function_entry();
2019     assert_positive_int(R5_ARG3);
2020     address nooverlap_target = aligned ?
2021       STUB_ENTRY(arrayof_jlong_disjoint_arraycopy) :
2022       STUB_ENTRY(jlong_disjoint_arraycopy);
2023 
2024     array_overlap_test(nooverlap_target, 3);
<span class="line-modified">2025     {</span>
<span class="line-modified">2026       // UnsafeCopyMemory page error: continue at UnsafeCopyMemory common_error_exit</span>
<span class="line-added">2027       UnsafeCopyMemoryMark ucmm(this, !aligned, false);</span>
<span class="line-added">2028       generate_conjoint_long_copy_core(aligned);</span>
<span class="line-added">2029     }</span>
2030     __ li(R3_RET, 0); // return 0
2031     __ blr();
2032 
2033     return start;
2034   }
2035 
2036   // Generate stub for conjoint oop copy.  If &quot;aligned&quot; is true, the
2037   // &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
2038   //
2039   // Arguments for generated stub:
2040   //      from:  R3_ARG1
2041   //      to:    R4_ARG2
2042   //      count: R5_ARG3 treated as signed
2043   //      dest_uninitialized: G1 support
2044   //
2045   address generate_conjoint_oop_copy(bool aligned, const char * name, bool dest_uninitialized) {
2046     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2047 
2048     address start = __ function_entry();
2049     assert_positive_int(R5_ARG3);
</pre>
<hr />
<pre>
3010     __ vxor            (toPerm, toPerm, fSplt);       // swap bytes
3011 #else
3012     __ vperm           (vTmp3, vTmp4, vTmp3, toPerm); // generate select mask
3013 #endif
3014     __ vperm           (vTmp4, vRet, vRet, toPerm);   // rotate data
3015     __ vsel            (vTmp2, vTmp4, vTmp2, vTmp3);
3016     __ vsel            (vTmp1, vTmp1, vTmp4, vTmp3);
3017     __ stvx            (vTmp2, fifteen, to);          // store this one first (may alias)
3018     __ stvx            (vTmp1, to);
3019 
3020     __ blr();
3021      return start;
3022   }
3023 
3024   address generate_sha256_implCompress(bool multi_block, const char *name) {
3025     assert(UseSHA, &quot;need SHA instructions&quot;);
3026     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
3027     address start = __ function_entry();
3028 
3029     __ sha256 (multi_block);

3030     __ blr();
<span class="line-added">3031 </span>
3032     return start;
3033   }
3034 
3035   address generate_sha512_implCompress(bool multi_block, const char *name) {
3036     assert(UseSHA, &quot;need SHA instructions&quot;);
3037     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
3038     address start = __ function_entry();
3039 
3040     __ sha512 (multi_block);
<span class="line-added">3041     __ blr();</span>
<span class="line-added">3042 </span>
<span class="line-added">3043     return start;</span>
<span class="line-added">3044   }</span>
<span class="line-added">3045 </span>
<span class="line-added">3046   address generate_data_cache_writeback() {</span>
<span class="line-added">3047     const Register cacheline = R3_ARG1;</span>
<span class="line-added">3048     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;_data_cache_writeback&quot;);</span>
<span class="line-added">3049     address start = __ pc();</span>
<span class="line-added">3050 </span>
<span class="line-added">3051     __ cache_wb(Address(cacheline));</span>
<span class="line-added">3052     __ blr();</span>
<span class="line-added">3053 </span>
<span class="line-added">3054     return start;</span>
<span class="line-added">3055   }</span>
<span class="line-added">3056 </span>
<span class="line-added">3057   address generate_data_cache_writeback_sync() {</span>
<span class="line-added">3058     const Register is_presync = R3_ARG1;</span>
<span class="line-added">3059     Register temp = R4;</span>
<span class="line-added">3060     Label SKIP;</span>
3061 
<span class="line-added">3062     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;_data_cache_writeback_sync&quot;);</span>
<span class="line-added">3063     address start = __ pc();</span>
<span class="line-added">3064 </span>
<span class="line-added">3065     __ andi_(temp, is_presync, 1);</span>
<span class="line-added">3066     __ bne(CCR0, SKIP);</span>
<span class="line-added">3067     __ cache_wbsync(false); // post sync =&gt; emit &#39;sync&#39;</span>
<span class="line-added">3068     __ bind(SKIP);          // pre sync =&gt; emit nothing</span>
3069     __ blr();
<span class="line-added">3070 </span>
3071     return start;
3072   }
3073 
3074   void generate_arraycopy_stubs() {
3075     // Note: the disjoint stubs must be generated first, some of
3076     // the conjoint stubs use them.
3077 
<span class="line-added">3078     address ucm_common_error_exit       =  generate_unsafecopy_common_error_exit();</span>
<span class="line-added">3079     UnsafeCopyMemory::set_common_exit_stub_pc(ucm_common_error_exit);</span>
<span class="line-added">3080 </span>
3081     // non-aligned disjoint versions
3082     StubRoutines::_jbyte_disjoint_arraycopy       = generate_disjoint_byte_copy(false, &quot;jbyte_disjoint_arraycopy&quot;);
3083     StubRoutines::_jshort_disjoint_arraycopy      = generate_disjoint_short_copy(false, &quot;jshort_disjoint_arraycopy&quot;);
3084     StubRoutines::_jint_disjoint_arraycopy        = generate_disjoint_int_copy(false, &quot;jint_disjoint_arraycopy&quot;);
3085     StubRoutines::_jlong_disjoint_arraycopy       = generate_disjoint_long_copy(false, &quot;jlong_disjoint_arraycopy&quot;);
3086     StubRoutines::_oop_disjoint_arraycopy         = generate_disjoint_oop_copy(false, &quot;oop_disjoint_arraycopy&quot;, false);
3087     StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_oop_copy(false, &quot;oop_disjoint_arraycopy_uninit&quot;, true);
3088 
3089     // aligned disjoint versions
3090     StubRoutines::_arrayof_jbyte_disjoint_arraycopy      = generate_disjoint_byte_copy(true, &quot;arrayof_jbyte_disjoint_arraycopy&quot;);
3091     StubRoutines::_arrayof_jshort_disjoint_arraycopy     = generate_disjoint_short_copy(true, &quot;arrayof_jshort_disjoint_arraycopy&quot;);
3092     StubRoutines::_arrayof_jint_disjoint_arraycopy       = generate_disjoint_int_copy(true, &quot;arrayof_jint_disjoint_arraycopy&quot;);
3093     StubRoutines::_arrayof_jlong_disjoint_arraycopy      = generate_disjoint_long_copy(true, &quot;arrayof_jlong_disjoint_arraycopy&quot;);
3094     StubRoutines::_arrayof_oop_disjoint_arraycopy        = generate_disjoint_oop_copy(true, &quot;arrayof_oop_disjoint_arraycopy&quot;, false);
3095     StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit = generate_disjoint_oop_copy(true, &quot;oop_disjoint_arraycopy_uninit&quot;, true);
3096 
3097     // non-aligned conjoint versions
3098     StubRoutines::_jbyte_arraycopy      = generate_conjoint_byte_copy(false, &quot;jbyte_arraycopy&quot;);
3099     StubRoutines::_jshort_arraycopy     = generate_conjoint_short_copy(false, &quot;jshort_arraycopy&quot;);
3100     StubRoutines::_jint_arraycopy       = generate_conjoint_int_copy(false, &quot;jint_arraycopy&quot;);
</pre>
<hr />
<pre>
3112 
3113     // special/generic versions
3114     StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(&quot;checkcast_arraycopy&quot;, false);
3115     StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(&quot;checkcast_arraycopy_uninit&quot;, true);
3116 
3117     StubRoutines::_unsafe_arraycopy  = generate_unsafe_copy(&quot;unsafe_arraycopy&quot;,
3118                                                             STUB_ENTRY(jbyte_arraycopy),
3119                                                             STUB_ENTRY(jshort_arraycopy),
3120                                                             STUB_ENTRY(jint_arraycopy),
3121                                                             STUB_ENTRY(jlong_arraycopy));
3122     StubRoutines::_generic_arraycopy = generate_generic_copy(&quot;generic_arraycopy&quot;,
3123                                                              STUB_ENTRY(jbyte_arraycopy),
3124                                                              STUB_ENTRY(jshort_arraycopy),
3125                                                              STUB_ENTRY(jint_arraycopy),
3126                                                              STUB_ENTRY(oop_arraycopy),
3127                                                              STUB_ENTRY(oop_disjoint_arraycopy),
3128                                                              STUB_ENTRY(jlong_arraycopy),
3129                                                              STUB_ENTRY(checkcast_arraycopy));
3130 
3131     // fill routines
<span class="line-added">3132 #ifdef COMPILER2</span>
3133     if (OptimizeFill) {
3134       StubRoutines::_jbyte_fill          = generate_fill(T_BYTE,  false, &quot;jbyte_fill&quot;);
3135       StubRoutines::_jshort_fill         = generate_fill(T_SHORT, false, &quot;jshort_fill&quot;);
3136       StubRoutines::_jint_fill           = generate_fill(T_INT,   false, &quot;jint_fill&quot;);
3137       StubRoutines::_arrayof_jbyte_fill  = generate_fill(T_BYTE,  true, &quot;arrayof_jbyte_fill&quot;);
3138       StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, &quot;arrayof_jshort_fill&quot;);
3139       StubRoutines::_arrayof_jint_fill   = generate_fill(T_INT,   true, &quot;arrayof_jint_fill&quot;);
3140     }
<span class="line-added">3141 #endif</span>
3142   }
3143 
3144   // Safefetch stubs.
3145   void generate_safefetch(const char* name, int size, address* entry, address* fault_pc, address* continuation_pc) {
3146     // safefetch signatures:
3147     //   int      SafeFetch32(int*      adr, int      errValue);
3148     //   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue);
3149     //
3150     // arguments:
3151     //   R3_ARG1 = adr
3152     //   R4_ARG2 = errValue
3153     //
3154     // result:
3155     //   R3_RET  = *adr or errValue
3156 
3157     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
3158 
3159     // Entry point, pc or function descriptor.
3160     *entry = __ function_entry();
3161 
</pre>
<hr />
<pre>
3590     StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(&quot;NullPointerException at call throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call), false);
3591 
3592     // support for verify_oop (must happen after universe_init)
3593     StubRoutines::_verify_oop_subroutine_entry             = generate_verify_oop();
3594 
3595     // arraycopy stubs used by compilers
3596     generate_arraycopy_stubs();
3597 
3598     // Safefetch stubs.
3599     generate_safefetch(&quot;SafeFetch32&quot;, sizeof(int),     &amp;StubRoutines::_safefetch32_entry,
3600                                                        &amp;StubRoutines::_safefetch32_fault_pc,
3601                                                        &amp;StubRoutines::_safefetch32_continuation_pc);
3602     generate_safefetch(&quot;SafeFetchN&quot;, sizeof(intptr_t), &amp;StubRoutines::_safefetchN_entry,
3603                                                        &amp;StubRoutines::_safefetchN_fault_pc,
3604                                                        &amp;StubRoutines::_safefetchN_continuation_pc);
3605 
3606 #ifdef COMPILER2
3607     if (UseMultiplyToLenIntrinsic) {
3608       StubRoutines::_multiplyToLen = generate_multiplyToLen();
3609     }


3610     if (UseSquareToLenIntrinsic) {
3611       StubRoutines::_squareToLen = generate_squareToLen();
3612     }
3613     if (UseMulAddIntrinsic) {
3614       StubRoutines::_mulAdd = generate_mulAdd();
3615     }
3616     if (UseMontgomeryMultiplyIntrinsic) {
3617       StubRoutines::_montgomeryMultiply
3618         = CAST_FROM_FN_PTR(address, SharedRuntime::montgomery_multiply);
3619     }
3620     if (UseMontgomerySquareIntrinsic) {
3621       StubRoutines::_montgomerySquare
3622         = CAST_FROM_FN_PTR(address, SharedRuntime::montgomery_square);
3623     }
<span class="line-added">3624 #endif</span>
<span class="line-added">3625 </span>
<span class="line-added">3626     // data cache line writeback</span>
<span class="line-added">3627     if (VM_Version::supports_data_cache_line_flush()) {</span>
<span class="line-added">3628       StubRoutines::_data_cache_writeback = generate_data_cache_writeback();</span>
<span class="line-added">3629       StubRoutines::_data_cache_writeback_sync = generate_data_cache_writeback_sync();</span>
<span class="line-added">3630     }</span>
3631 
3632     if (UseAESIntrinsics) {
3633       StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
3634       StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
3635     }
3636 
3637     if (UseSHA256Intrinsics) {
3638       StubRoutines::_sha256_implCompress   = generate_sha256_implCompress(false, &quot;sha256_implCompress&quot;);
3639       StubRoutines::_sha256_implCompressMB = generate_sha256_implCompress(true,  &quot;sha256_implCompressMB&quot;);
3640     }
3641     if (UseSHA512Intrinsics) {
3642       StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(false, &quot;sha512_implCompress&quot;);
3643       StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(true, &quot;sha512_implCompressMB&quot;);
3644     }
3645   }
3646 
3647  public:
3648   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
3649     // replace the standard masm with a special one:
3650     _masm = new MacroAssembler(code);
3651     if (all) {
3652       generate_all();
3653     } else {
3654       generate_initial();
3655     }
3656   }
3657 };
3658 
<span class="line-added">3659 #define UCM_TABLE_MAX_ENTRIES 8</span>
3660 void StubGenerator_generate(CodeBuffer* code, bool all) {
<span class="line-added">3661   if (UnsafeCopyMemory::_table == NULL) {</span>
<span class="line-added">3662     UnsafeCopyMemory::create_table(UCM_TABLE_MAX_ENTRIES);</span>
<span class="line-added">3663   }</span>
3664   StubGenerator g(code, all);
3665 }
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreterGenerator_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
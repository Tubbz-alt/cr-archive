<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/relocInfo_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2012, 2015 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/assembler.inline.hpp&quot;
 28 #include &quot;code/relocInfo.hpp&quot;
 29 #include &quot;nativeInst_ppc.hpp&quot;
 30 #include &quot;oops/compressedOops.inline.hpp&quot;
 31 #include &quot;oops/klass.inline.hpp&quot;
 32 #include &quot;oops/oop.hpp&quot;
 33 #include &quot;runtime/safepoint.hpp&quot;
 34 
 35 void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {
 36   // The following comment is from the declaration of DataRelocation:
 37   //
 38   //  &quot;The &quot;o&quot; (displacement) argument is relevant only to split relocations
 39   //   on RISC machines.  In some CPUs (SPARC), the set-hi and set-lo ins&#39;ns
 40   //   can encode more than 32 bits between them.  This allows compilers to
 41   //   share set-hi instructions between addresses that differ by a small
 42   //   offset (e.g., different static variables in the same class).
 43   //   On such machines, the &quot;x&quot; argument to set_value on all set-lo
 44   //   instructions must be the same as the &quot;x&quot; argument for the
 45   //   corresponding set-hi instructions.  The &quot;o&quot; arguments for the
 46   //   set-hi instructions are ignored, and must not affect the high-half
 47   //   immediate constant.  The &quot;o&quot; arguments for the set-lo instructions are
 48   //   added into the low-half immediate constant, and must not overflow it.&quot;
 49   //
 50   // Currently we don&#39;t support splitting of relocations, so o must be
 51   // zero:
 52   assert(o == 0, &quot;tried to split relocations&quot;);
 53 
 54   if (!verify_only) {
 55     if (format() != 1) {
 56       nativeMovConstReg_at(addr())-&gt;set_data_plain(((intptr_t)x), code());
 57     } else {
 58       assert(type() == relocInfo::oop_type || type() == relocInfo::metadata_type,
 59              &quot;how to encode else?&quot;);
 60       narrowOop no = (type() == relocInfo::oop_type) ?
<a name="1" id="anc1"></a><span class="line-modified"> 61           CompressedOops::encode((oop)x) : Klass::encode_klass((Klass*)x);</span>
 62       nativeMovConstReg_at(addr())-&gt;set_narrow_oop(no, code());
 63     }
 64   } else {
 65     guarantee((address) (nativeMovConstReg_at(addr())-&gt;data()) == x, &quot;data must match&quot;);
 66   }
 67 }
 68 
 69 address Relocation::pd_call_destination(address orig_addr) {
 70   intptr_t adj = 0;
 71   address inst_loc = addr();
 72 
 73   if (orig_addr != NULL) {
 74     // We just moved this call instruction from orig_addr to addr().
 75     // This means its target will appear to have grown by addr() - orig_addr.
 76     adj = -(inst_loc - orig_addr);
 77   }
 78   if (NativeFarCall::is_far_call_at(inst_loc)) {
 79     NativeFarCall* call = nativeFarCall_at(inst_loc);
 80     return call-&gt;destination() + (intptr_t)(call-&gt;is_pcrelative() ? adj : 0);
 81   } else if (NativeJump::is_jump_at(inst_loc)) {
 82     NativeJump* jump = nativeJump_at(inst_loc);
 83     return jump-&gt;jump_destination() + (intptr_t)(jump-&gt;is_pcrelative() ? adj : 0);
 84   } else if (NativeConditionalFarBranch::is_conditional_far_branch_at(inst_loc)) {
 85     NativeConditionalFarBranch* branch = NativeConditionalFarBranch_at(inst_loc);
 86     return branch-&gt;branch_destination();
 87   } else {
 88     orig_addr = nativeCall_at(inst_loc)-&gt;get_trampoline();
 89     if (orig_addr == NULL) {
 90       return (address) -1;
 91     } else {
 92       return ((NativeCallTrampolineStub*)orig_addr)-&gt;destination();
 93     }
 94   }
 95 }
 96 
 97 void Relocation::pd_set_call_destination(address x) {
 98   address inst_loc = addr();
 99 
100   if (NativeFarCall::is_far_call_at(inst_loc)) {
101     NativeFarCall* call = nativeFarCall_at(inst_loc);
102     call-&gt;set_destination(x);
103   } else if (NativeJump::is_jump_at(inst_loc)) {
104     NativeJump* jump= nativeJump_at(inst_loc);
105     jump-&gt;set_jump_destination(x);
106   } else if (NativeConditionalFarBranch::is_conditional_far_branch_at(inst_loc)) {
107     NativeConditionalFarBranch* branch = NativeConditionalFarBranch_at(inst_loc);
108     branch-&gt;set_branch_destination(x);
109   } else {
110     NativeCall* call = nativeCall_at(inst_loc);
111     call-&gt;set_destination_mt_safe(x, false);
112   }
113 }
114 
115 address* Relocation::pd_address_in_code() {
116   ShouldNotReachHere();
117   return 0;
118 }
119 
120 address Relocation::pd_get_address_from_code() {
121   return (address)(nativeMovConstReg_at(addr())-&gt;data());
122 }
123 
124 void poll_Relocation::fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) {
125 }
126 
127 void metadata_Relocation::pd_fix_value(address x) {
128 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
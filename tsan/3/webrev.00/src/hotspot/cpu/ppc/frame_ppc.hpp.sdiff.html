<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/frame_ppc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="frame_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame_ppc.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/frame_ppc.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
233   };
234 
235   enum {
236     parent_ijava_frame_abi_size = sizeof(parent_ijava_frame_abi)
237   };
238 
239 #define _parent_ijava_frame_abi(_component) \
240         (offset_of(frame::parent_ijava_frame_abi, _component))
241 
242   struct top_ijava_frame_abi : abi_reg_args {
243   };
244 
245   enum {
246     top_ijava_frame_abi_size = sizeof(top_ijava_frame_abi)
247   };
248 
249 #define _top_ijava_frame_abi(_component) \
250         (offset_of(frame::top_ijava_frame_abi, _component))
251 
252   struct ijava_state {
<span class="line-removed">253 #ifdef ASSERT</span>
<span class="line-removed">254     uint64_t ijava_reserved; // Used for assertion.</span>
<span class="line-removed">255 #endif</span>
256     uint64_t method;
257     uint64_t mirror;
258     uint64_t locals;
259     uint64_t monitors;
260     uint64_t cpoolCache;
261     uint64_t bcp;
262     uint64_t esp;
263     uint64_t mdx;
264     uint64_t top_frame_sp; // Maybe define parent_frame_abi and move there.
265     uint64_t sender_sp;
266     // Slots only needed for native calls. Maybe better to move elsewhere.
267     uint64_t oop_tmp;
268     uint64_t lresult;
269     uint64_t fresult;
270   };
271 
272   enum {
273     ijava_state_size = sizeof(ijava_state)
274   };
275 
</pre>
<hr />
<pre>
392   intptr_t* compiled_sender_sp(CodeBlob* cb) const;
393   address*  compiled_sender_pc_addr(CodeBlob* cb) const;
394   address*  sender_pc_addr(void) const;
395 
396  public:
397 
398   inline ijava_state* get_ijava_state() const;
399   // Some convenient register frame setters/getters for deoptimization.
400   inline intptr_t* interpreter_frame_esp() const;
401   inline void interpreter_frame_set_cpcache(ConstantPoolCache* cp);
402   inline void interpreter_frame_set_esp(intptr_t* esp);
403   inline void interpreter_frame_set_top_frame_sp(intptr_t* top_frame_sp);
404   inline void interpreter_frame_set_sender_sp(intptr_t* sender_sp);
405 
406   // Size of a monitor in bytes.
407   static int interpreter_frame_monitor_size_in_bytes();
408 
409   // The size of a cInterpreter object.
410   static inline int interpreter_frame_cinterpreterstate_size_in_bytes();
411 
<span class="line-removed">412  private:</span>
<span class="line-removed">413 </span>
<span class="line-removed">414   ConstantPoolCache** interpreter_frame_cpoolcache_addr() const;</span>
<span class="line-removed">415 </span>
<span class="line-removed">416  public:</span>
<span class="line-removed">417 </span>
418   // Additional interface for entry frames:
419   inline entry_frame_locals* get_entry_frame_locals() const {
420     return (entry_frame_locals*) (((address) fp()) - entry_frame_locals_size);
421   }
422 
423   enum {
424     // normal return address is 1 bundle past PC
425     pc_return_offset = 0
426   };
427 
428   static jint interpreter_frame_expression_stack_direction() { return -1; }
429 
430 #endif // CPU_PPC_FRAME_PPC_HPP
</pre>
</td>
<td>
<hr />
<pre>
233   };
234 
235   enum {
236     parent_ijava_frame_abi_size = sizeof(parent_ijava_frame_abi)
237   };
238 
239 #define _parent_ijava_frame_abi(_component) \
240         (offset_of(frame::parent_ijava_frame_abi, _component))
241 
242   struct top_ijava_frame_abi : abi_reg_args {
243   };
244 
245   enum {
246     top_ijava_frame_abi_size = sizeof(top_ijava_frame_abi)
247   };
248 
249 #define _top_ijava_frame_abi(_component) \
250         (offset_of(frame::top_ijava_frame_abi, _component))
251 
252   struct ijava_state {



253     uint64_t method;
254     uint64_t mirror;
255     uint64_t locals;
256     uint64_t monitors;
257     uint64_t cpoolCache;
258     uint64_t bcp;
259     uint64_t esp;
260     uint64_t mdx;
261     uint64_t top_frame_sp; // Maybe define parent_frame_abi and move there.
262     uint64_t sender_sp;
263     // Slots only needed for native calls. Maybe better to move elsewhere.
264     uint64_t oop_tmp;
265     uint64_t lresult;
266     uint64_t fresult;
267   };
268 
269   enum {
270     ijava_state_size = sizeof(ijava_state)
271   };
272 
</pre>
<hr />
<pre>
389   intptr_t* compiled_sender_sp(CodeBlob* cb) const;
390   address*  compiled_sender_pc_addr(CodeBlob* cb) const;
391   address*  sender_pc_addr(void) const;
392 
393  public:
394 
395   inline ijava_state* get_ijava_state() const;
396   // Some convenient register frame setters/getters for deoptimization.
397   inline intptr_t* interpreter_frame_esp() const;
398   inline void interpreter_frame_set_cpcache(ConstantPoolCache* cp);
399   inline void interpreter_frame_set_esp(intptr_t* esp);
400   inline void interpreter_frame_set_top_frame_sp(intptr_t* top_frame_sp);
401   inline void interpreter_frame_set_sender_sp(intptr_t* sender_sp);
402 
403   // Size of a monitor in bytes.
404   static int interpreter_frame_monitor_size_in_bytes();
405 
406   // The size of a cInterpreter object.
407   static inline int interpreter_frame_cinterpreterstate_size_in_bytes();
408 






409   // Additional interface for entry frames:
410   inline entry_frame_locals* get_entry_frame_locals() const {
411     return (entry_frame_locals*) (((address) fp()) - entry_frame_locals_size);
412   }
413 
414   enum {
415     // normal return address is 1 bundle past PC
416     pc_return_offset = 0
417   };
418 
419   static jint interpreter_frame_expression_stack_direction() { return -1; }
420 
421 #endif // CPU_PPC_FRAME_PPC_HPP
</pre>
</td>
</tr>
</table>
<center><a href="frame_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame_ppc.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
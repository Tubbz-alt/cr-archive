<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/ppc/interpreterRT_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2012, 2013 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/assembler.inline.hpp&quot;
 28 #include &quot;interpreter/interp_masm.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 31 #include &quot;memory/allocation.inline.hpp&quot;
 32 #include &quot;oops/method.hpp&quot;
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/icache.hpp&quot;
 36 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 37 #include &quot;runtime/signature.hpp&quot;
 38 
 39 #define __ _masm-&gt;
 40 
 41 // Access macros for Java and C arguments.
 42 // The first Java argument is at index -1.
 43 #define locals_j_arg_at(index)    (Interpreter::local_offset_in_bytes(index)), R18_locals
 44 // The first C argument is at index 0.
 45 #define sp_c_arg_at(index)        ((index)*wordSize + _abi(carg_1)), R1_SP
 46 
 47 // Implementation of SignatureHandlerGenerator
 48 
 49 InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 50     const methodHandle&amp; method, CodeBuffer* buffer) : NativeSignatureIterator(method) {
 51   _masm = new MacroAssembler(buffer);
 52   _num_used_fp_arg_regs = 0;
 53 }
 54 
 55 void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
 56   Argument jni_arg(jni_offset());
 57   Register r = jni_arg.is_register() ? jni_arg.as_register() : R0;
 58 
 59   __ lwa(r, locals_j_arg_at(offset())); // sign extension of integer
 60   if (DEBUG_ONLY(true ||) !jni_arg.is_register()) {
 61     __ std(r, sp_c_arg_at(jni_arg.number()));
 62   }
 63 }
 64 
 65 void InterpreterRuntime::SignatureHandlerGenerator::pass_long() {
 66   Argument jni_arg(jni_offset());
 67   Register r = jni_arg.is_register() ? jni_arg.as_register() : R0;
 68 
 69   __ ld(r, locals_j_arg_at(offset()+1)); // long resides in upper slot
 70   if (DEBUG_ONLY(true ||) !jni_arg.is_register()) {
 71     __ std(r, sp_c_arg_at(jni_arg.number()));
 72   }
 73 }
 74 
 75 void InterpreterRuntime::SignatureHandlerGenerator::pass_float() {
 76   FloatRegister fp_reg = (_num_used_fp_arg_regs &lt; 13/*max_fp_register_arguments*/)
 77                          ? as_FloatRegister((_num_used_fp_arg_regs++) + F1_ARG1-&gt;encoding())
 78                          : F0;
 79 
 80   __ lfs(fp_reg, locals_j_arg_at(offset()));
 81   if (DEBUG_ONLY(true ||) jni_offset() &gt; 8) {
 82     __ stfs(fp_reg, sp_c_arg_at(jni_offset()));
 83   }
 84 }
 85 
 86 void InterpreterRuntime::SignatureHandlerGenerator::pass_double() {
 87   FloatRegister fp_reg = (_num_used_fp_arg_regs &lt; 13/*max_fp_register_arguments*/)
 88                          ? as_FloatRegister((_num_used_fp_arg_regs++) + F1_ARG1-&gt;encoding())
 89                          : F0;
 90 
 91   __ lfd(fp_reg, locals_j_arg_at(offset()+1));
 92   if (DEBUG_ONLY(true ||) jni_offset() &gt; 8) {
 93     __ stfd(fp_reg, sp_c_arg_at(jni_offset()));
 94   }
 95 }
 96 
 97 void InterpreterRuntime::SignatureHandlerGenerator::pass_object() {
 98   Argument jni_arg(jni_offset());
 99   Register r = jni_arg.is_register() ? jni_arg.as_register() : R11_scratch1;
100 
101   // The handle for a receiver will never be null.
102   bool do_NULL_check = offset() != 0 || is_static();
103 
104   Label do_null;
105   if (do_NULL_check) {
106     __ ld(R0, locals_j_arg_at(offset()));
107     __ cmpdi(CCR0, R0, 0);
108     __ li(r, 0);
109     __ beq(CCR0, do_null);
110   }
111   __ addir(r, locals_j_arg_at(offset()));
112   __ bind(do_null);
113   if (DEBUG_ONLY(true ||) !jni_arg.is_register()) {
114     __ std(r, sp_c_arg_at(jni_arg.number()));
115   }
116 }
117 
118 void InterpreterRuntime::SignatureHandlerGenerator::generate(uint64_t fingerprint) {
119 #if !defined(ABI_ELFv2)
120   // Emit fd for current codebuffer. Needs patching!
121   __ emit_fd();
122 #endif
123 
124   // Generate code to handle arguments.
125   iterate(fingerprint);
126 
127   // Return the result handler.
128   __ load_const(R3_RET, AbstractInterpreter::result_handler(method()-&gt;result_type()));
129   __ blr();
130 
131   __ flush();
132 }
133 
134 #undef __
135 
136 // Implementation of SignatureHandlerLibrary
137 
138 void SignatureHandlerLibrary::pd_set_handler(address handler) {
139 #if !defined(ABI_ELFv2)
140   // patch fd here.
141   FunctionDescriptor* fd = (FunctionDescriptor*) handler;
142 
143   fd-&gt;set_entry(handler + (int)sizeof(FunctionDescriptor));
144   assert(fd-&gt;toc() == (address)0xcafe, &quot;need to adjust TOC here&quot;);
145 #endif
146 }
147 
148 
149 // Access function to get the signature.
150 JRT_ENTRY(address, InterpreterRuntime::get_signature(JavaThread* thread, Method* method))
151   methodHandle m(thread, method);
152   assert(m-&gt;is_native(), &quot;sanity check&quot;);
153   Symbol *s = m-&gt;signature();
154   return (address) s-&gt;base();
155 JRT_END
156 
157 JRT_ENTRY(address, InterpreterRuntime::get_result_handler(JavaThread* thread, Method* method))
158   methodHandle m(thread, method);
159   assert(m-&gt;is_native(), &quot;sanity check&quot;);
160   return AbstractInterpreter::result_handler(m-&gt;result_type());
161 JRT_END
    </pre>
  </body>
</html>
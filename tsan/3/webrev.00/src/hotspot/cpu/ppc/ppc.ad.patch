diff a/src/hotspot/cpu/ppc/ppc.ad b/src/hotspot/cpu/ppc/ppc.ad
--- a/src/hotspot/cpu/ppc/ppc.ad
+++ b/src/hotspot/cpu/ppc/ppc.ad
@@ -1,8 +1,8 @@
 //
-// Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
-// Copyright (c) 2012, 2018 SAP SE. All rights reserved.
+// Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 2012, 2019 SAP SE. All rights reserved.
 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 //
 // This code is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License version 2 only, as
 // published by the Free Software Foundation.
@@ -970,10 +970,12 @@
   // the ad-scope can conveniently be defined here.
   //
   // To keep related declarations/definitions/uses close together,
   // we switch between source %{ }% and source_hpp %{ }% freely as needed.
 
+#include "opto/convertnode.hpp"
+
   // Returns true if Node n is followed by a MemBar node that
   // will do an acquire. If so, this node must not do the acquire
   // operation.
   bool followed_by_acquire(const Node *n);
 %}
@@ -1398,10 +1400,28 @@
   } else {
     // Get return pc.
     ___(mflr) mflr(return_pc);
   }
 
+  if (C->clinit_barrier_on_entry()) {
+    assert(!C->method()->holder()->is_not_initialized(), "initialization should have been started");
+
+    Label L_skip_barrier;
+    Register klass = toc_temp;
+
+    // Notify OOP recorder (don't need the relocation)
+    AddressLiteral md = __ constant_metadata_address(C->method()->holder()->constant_encoding());
+    __ load_const_optimized(klass, md.value(), R0);
+    __ clinit_barrier(klass, R16_thread, &L_skip_barrier /*L_fast_path*/);
+
+    __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);
+    __ mtctr(klass);
+    __ bctr();
+
+    __ bind(L_skip_barrier);
+  }
+
   // Calls to C2R adapters often do not accept exceptional returns.
   // We require that their callers must bang for them. But be
   // careful, because some VM calls (such as call site linkage) can
   // use several kilobytes of stack. But the stack safety zone should
   // account for that. See bugs 4446381, 4468289, 4497237.
@@ -2202,10 +2222,11 @@
 
 const bool Matcher::match_rule_supported(int opcode) {
   if (!has_match_rule(opcode))
     return false;
 
+  bool ret_value = true;
   switch (opcode) {
   case Op_SqrtD:
     return VM_Version::has_fsqrt();
   case Op_CountLeadingZerosI:
   case Op_CountLeadingZerosL:
@@ -2252,10 +2273,11 @@
   case Op_SqrtVF:
   case Op_SqrtVD:
   case Op_AddVL:
   case Op_SubVL:
   case Op_MulVI:
+  case Op_RoundDoubleModeV:
     return SuperwordUseVSX;
   case Op_PopCountVI:
     return (SuperwordUseVSX && UsePopCountInstruction);
   case Op_FmaVF:
   case Op_FmaVD:
@@ -2263,16 +2285,24 @@
   case Op_Digit:
   case Op_LowerCase:
   case Op_UpperCase:
   case Op_Whitespace:
     return UseCharacterCompareIntrinsics;
+
+  case Op_CacheWB:
+  case Op_CacheWBPreSync:
+  case Op_CacheWBPostSync:
+    if (!VM_Version::supports_data_cache_line_flush()) {
+      ret_value = false;
+    }
+    break;
   }
 
-  return true;  // Per default match rules are supported.
+  return ret_value;  // Per default match rules are supported.
 }
 
-const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {
+const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 
   // TODO
   // identify extra cases that we might want to provide match rules for
   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
   bool ret_value = match_rule_supported(opcode);
@@ -2376,11 +2406,11 @@
   return true;
 }
 /* TODO: PPC port
 // Make a new machine dependent decode node (with its operands).
 MachTypeNode *Matcher::make_decode_node() {
-  assert(Universe::narrow_oop_base() == NULL && Universe::narrow_oop_shift() == 0,
+  assert(CompressedOops::base() == NULL && CompressedOops::shift() == 0,
          "This method is only implemented for unscaled cOops mode so far");
   MachTypeNode *decode = new decodeN_unscaledNode();
   decode->set_opnd_array(0, new iRegPdstOper());
   decode->set_opnd_array(1, new iRegNsrcOper());
   return decode;
@@ -2403,10 +2433,28 @@
 // Do we need to mask the count passed to shift instructions or does
 // the cpu only look at the lower 5/6 bits anyway?
 // PowerPC requires masked shift counts.
 const bool Matcher::need_masked_shift_count = true;
 
+// No support for generic vector operands.
+const bool Matcher::supports_generic_vector_operands  = false;
+
+MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
+  ShouldNotReachHere(); // generic vector operands not supported
+  return NULL;
+}
+
+bool Matcher::is_generic_reg2reg_move(MachNode* m) {
+  ShouldNotReachHere();  // generic vector operands not supported
+  return false;
+}
+
+bool Matcher::is_generic_vector(MachOper* opnd)  {
+  ShouldNotReachHere();  // generic vector operands not supported
+  return false;
+}
+
 // This affects two different things:
 //  - how Decode nodes are matched
 //  - how ImplicitNullCheck opportunities are recognized
 // If true, the matcher will try to remove all Decodes and match them
 // (as operands) into nodes. NullChecks are not prepared to deal with
@@ -2427,16 +2475,16 @@
   return false;
 }
 
 bool Matcher::const_oop_prefer_decode() {
   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
-  return Universe::narrow_oop_base() == NULL;
+  return CompressedOops::base() == NULL;
 }
 
 bool Matcher::const_klass_prefer_decode() {
   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
-  return Universe::narrow_klass_base() == NULL;
+  return CompressedKlassPointers::base() == NULL;
 }
 
 // Is it better to copy float constants, or load them directly from memory?
 // Intel can load a float constant from a direct address, requiring no
 // extra registers. Most RISCs will have to materialize an address into a
@@ -2451,12 +2499,11 @@
 
 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
  Unimplemented();
 }
 
-// Advertise here if the CPU requires explicit rounding operations
-// to implement the UseStrictFP mode.
+// Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 
 // Do floats take an entire double register or just half?
 //
 // A float occupies a ppc64 double register. For the allocator, a
@@ -4149,22 +4196,22 @@
   // returned to the interpreter in I0:I1. The copying to and from
   // the register pairs is done by the appropriate call and epilog
   // opcodes. This simplifies the register allocator.
   c_return_value %{
     assert((ideal_reg >= Op_RegI && ideal_reg <= Op_RegL) ||
-            (ideal_reg == Op_RegN && Universe::narrow_oop_base() == NULL && Universe::narrow_oop_shift() == 0),
+            (ideal_reg == Op_RegN && CompressedOops::base() == NULL && CompressedOops::shift() == 0),
             "only return normal values");
     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
   %}
 
   // Location of compiled Java return values.  Same as C
   return_value %{
     assert((ideal_reg >= Op_RegI && ideal_reg <= Op_RegL) ||
-            (ideal_reg == Op_RegN && Universe::narrow_oop_base() == NULL && Universe::narrow_oop_shift() == 0),
+            (ideal_reg == Op_RegN && CompressedOops::base() == NULL && CompressedOops::shift() == 0),
             "only return normal values");
     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
@@ -4301,27 +4348,27 @@
   format %{ %}
   interface(CONST_INTER);
 %}
 
 operand immInegpow2() %{
-  predicate(is_power_of_2_long((jlong) (julong) (juint) (-(n->get_int()))));
+  predicate(is_power_of_2((jlong) (julong) (juint) (-(n->get_int()))));
   match(ConI);
   op_cost(0);
   format %{ %}
   interface(CONST_INTER);
 %}
 
 operand immIpow2minus1() %{
-  predicate(is_power_of_2_long((((jlong) (n->get_int()))+1)));
+  predicate(is_power_of_2((((jlong) (n->get_int()))+1)));
   match(ConI);
   op_cost(0);
   format %{ %}
   interface(CONST_INTER);
 %}
 
 operand immIpowerOf2() %{
-  predicate(is_power_of_2_long((((jlong) (julong) (juint) (n->get_int())))));
+  predicate(is_power_of_2((((jlong) (julong) (juint) (n->get_int())))));
   match(ConI);
   op_cost(0);
   format %{ %}
   interface(CONST_INTER);
 %}
@@ -4551,19 +4598,19 @@
   format %{ %}
   interface(CONST_INTER);
 %}
 
 operand immLnegpow2() %{
-  predicate(is_power_of_2_long((jlong)-(n->get_long())));
+  predicate(is_power_of_2((jlong)-(n->get_long())));
   match(ConL);
   op_cost(0);
   format %{ %}
   interface(CONST_INTER);
 %}
 
 operand immLpow2minus1() %{
-  predicate(is_power_of_2_long((((jlong) (n->get_long()))+1)) &&
+  predicate(is_power_of_2((((jlong) (n->get_long()))+1)) &&
             (n->get_long() != (jlong)0xffffffffffffffffL));
   match(ConL);
   op_cost(0);
   format %{ %}
   interface(CONST_INTER);
@@ -4629,10 +4676,20 @@
   op_cost(40);
   format %{ %}
   interface(CONST_INTER);
 %}
 
+// Double Immediate: +0.0d.
+operand immD_0() %{
+  predicate(jlong_cast(n->getd()) == 0);
+  match(ConD);
+
+  op_cost(0);
+  format %{ %}
+  interface(CONST_INTER);
+%}
+
 // Integer Register Operands
 // Integer Destination Register
 // See definition of reg_class bits32_reg_rw.
 operand iRegIdst() %{
   constraint(ALLOC_IN_RC(bits32_reg_rw));
@@ -4976,11 +5033,11 @@
 %}
 
 // Operands to remove register moves in unscaled mode.
 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 operand iRegP2N(iRegPsrc reg) %{
-  predicate(false /* TODO: PPC port MatchDecodeNodes*/&& Universe::narrow_oop_shift() == 0);
+  predicate(false /* TODO: PPC port MatchDecodeNodes*/&& CompressedOops::shift() == 0);
   constraint(ALLOC_IN_RC(bits64_reg_ro));
   match(EncodeP reg);
   format %{ "$reg" %}
   interface(REG_INTER)
 %}
@@ -4992,11 +5049,11 @@
   format %{ "$reg" %}
   interface(REG_INTER)
 %}
 
 operand iRegN2P_klass(iRegNsrc reg) %{
-  predicate(Universe::narrow_klass_base() == NULL && Universe::narrow_klass_shift() == 0);
+  predicate(CompressedKlassPointers::base() == NULL && CompressedKlassPointers::shift() == 0);
   constraint(ALLOC_IN_RC(bits32_reg_ro));
   match(DecodeNKlass reg);
   format %{ "$reg" %}
   interface(REG_INTER)
 %}
@@ -5061,11 +5118,11 @@
     disp(0x0);
   %}
 %}
 
 operand indirectNarrow_klass(iRegNsrc reg) %{
-  predicate(Universe::narrow_klass_base() == NULL && Universe::narrow_klass_shift() == 0);
+  predicate(CompressedKlassPointers::base() == NULL && CompressedKlassPointers::shift() == 0);
   constraint(ALLOC_IN_RC(bits64_reg_ro));
   match(DecodeNKlass reg);
   op_cost(100);
   format %{ "[$reg]" %}
   interface(MEMORY_INTER) %{
@@ -5090,11 +5147,11 @@
     disp($offset);
   %}
 %}
 
 operand indOffset16Narrow_klass(iRegNsrc reg, immL16 offset) %{
-  predicate(Universe::narrow_klass_base() == NULL && Universe::narrow_klass_shift() == 0);
+  predicate(CompressedKlassPointers::base() == NULL && CompressedKlassPointers::shift() == 0);
   constraint(ALLOC_IN_RC(bits64_reg_ro));
   match(AddP (DecodeNKlass reg) offset);
   op_cost(100);
   format %{ "[$reg + $offset]" %}
   interface(MEMORY_INTER) %{
@@ -5119,11 +5176,11 @@
     disp($offset);
   %}
 %}
 
 operand indOffset16NarrowAlg4_klass(iRegNsrc reg, immL16Alg4 offset) %{
-  predicate(Universe::narrow_klass_base() == NULL && Universe::narrow_klass_shift() == 0);
+  predicate(CompressedKlassPointers::base() == NULL && CompressedKlassPointers::shift() == 0);
   constraint(ALLOC_IN_RC(bits64_reg_ro));
   match(AddP (DecodeNKlass reg) offset);
   op_cost(100);
   format %{ "[$reg + $offset]" %}
   interface(MEMORY_INTER) %{
@@ -5848,22 +5905,22 @@
 %}
 
 // Load Compressed Pointer and decode it if narrow_oop_shift == 0.
 instruct loadN2P_unscaled(iRegPdst dst, memory mem) %{
   match(Set dst (DecodeN (LoadN mem)));
-  predicate(_kids[0]->_leaf->as_Load()->is_unordered() && Universe::narrow_oop_shift() == 0);
+  predicate(_kids[0]->_leaf->as_Load()->is_unordered() && CompressedOops::shift() == 0);
   ins_cost(MEMORY_REF_COST);
 
   format %{ "LWZ     $dst, $mem \t// DecodeN (unscaled)" %}
   size(4);
   ins_encode( enc_lwz(dst, mem) );
   ins_pipe(pipe_class_memory);
 %}
 
 instruct loadN2P_klass_unscaled(iRegPdst dst, memory mem) %{
   match(Set dst (DecodeNKlass (LoadNKlass mem)));
-  predicate(Universe::narrow_klass_base() == NULL && Universe::narrow_klass_shift() == 0 &&
+  predicate(CompressedKlassPointers::base() == NULL && CompressedKlassPointers::shift() == 0 &&
             _kids[0]->_leaf->as_Load()->is_unordered());
   ins_cost(MEMORY_REF_COST);
 
   format %{ "LWZ     $dst, $mem \t// DecodeN (unscaled)" %}
   size(4);
@@ -6325,11 +6382,11 @@
   effect(DEF dst);
 
   format %{ "LoadConst $dst, heapbase" %}
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
-    __ load_const_optimized($dst$$Register, Universe::narrow_oop_base(), R0);
+    __ load_const_optimized($dst$$Register, CompressedOops::base(), R0);
   %}
   ins_pipe(pipe_class_default);
 %}
 
 // Loading ConN must be postalloc expanded so that edges between
@@ -6373,11 +6430,11 @@
 
   format %{ "LIS     $dst, $src \t// narrow klass hi" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
-    intptr_t Csrc = Klass::encode_klass((Klass *)$src$$constant);
+    intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src$$constant);
     __ lis($dst$$Register, (int)(short)((Csrc >> 16) & 0xffff));
   %}
   ins_pipe(pipe_class_default);
 %}
 
@@ -6405,11 +6462,11 @@
 
   format %{ "ORI     $dst, $src1, $src2 \t// narrow klass lo" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
-    intptr_t Csrc = Klass::encode_klass((Klass *)$src1$$constant);
+    intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src1$$constant);
     assert(__ oop_recorder() != NULL, "this assembler needs an OopRecorder");
     int klass_index = __ oop_recorder()->find_index((Klass *)$src1$$constant);
     RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 
     __ relocate(rspec, 1);
@@ -6433,11 +6490,11 @@
     m1->_opnds[1] = op_src;
     ra_->set_pair(m1->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));
     nodes->push(m1);
 
     MachNode *m2 = m1;
-    if (!Assembler::is_uimm((jlong)Klass::encode_klass((Klass *)op_src->constant()), 31)) {
+    if (!Assembler::is_uimm((jlong)CompressedKlassPointers::encode((Klass *)op_src->constant()), 31)) {
       // Value might be 1-extended. Mask out these bits.
       m2 = new loadConNKlass_maskNode();
       m2->add_req(NULL, m1);
       m2->_opnds[0] = op_dst;
       m2->_opnds[1] = op_src;
@@ -6895,29 +6952,10 @@
   format %{ "STB     #0, $mem \t// CMS card-mark byte (must be 0!), checking requires_release in [$releaseFieldAddr]" %}
   ins_encode( enc_cms_card_mark(mem, releaseFieldAddr, crx) );
   ins_pipe(pipe_class_memory);
 %}
 
-// Card-mark for CMS garbage collection.
-// This cardmark does an optimization so that it must not always
-// do a releasing store. For this, it needs the constant address of
-// CMSCollectorCardTableBarrierSetBSExt::_requires_release.
-// This constant address is split off here by expand so we can use
-// adlc / matcher functionality to load it from the constant section.
-instruct storeCM_CMS_ExEx(memory mem, immI_0 zero) %{
-  match(Set mem (StoreCM mem zero));
-  predicate(UseConcMarkSweepGC);
-
-  expand %{
-    immL baseImm %{ 0 /* TODO: PPC port (jlong)CMSCollectorCardTableBarrierSetBSExt::requires_release_address() */ %}
-    iRegLdst releaseFieldAddress;
-    flagsReg crx;
-    loadConL_Ex(releaseFieldAddress, baseImm);
-    storeCM_CMS(mem, releaseFieldAddress, crx);
-  %}
-%}
-
 instruct storeCM_G1(memory mem, immI_0 zero) %{
   match(Set mem (StoreCM mem zero));
   predicate(UseG1GC);
   ins_cost(MEMORY_REF_COST);
 
@@ -6947,11 +6985,11 @@
 
   format %{ "SRDI    $dst, $src, 3 \t// encode" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
-    __ srdi($dst$$Register, $src$$Register, Universe::narrow_oop_shift() & 0x3f);
+    __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() & 0x3f);
   %}
   ins_pipe(pipe_class_default);
 %}
 
 // Add node for expand.
@@ -6961,11 +6999,11 @@
   predicate(false);
 
   format %{ "SUB     $dst, $src, oop_base \t// encode" %}
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
-    __ sub_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);
+    __ sub_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
   %}
   ins_pipe(pipe_class_default);
 %}
 
 // Conditional sub base.
@@ -6979,11 +7017,11 @@
             "done:" %}
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
     Label done;
     __ beq($crx$$CondRegister, done);
-    __ sub_const_optimized($dst$$Register, $src1$$Register, Universe::narrow_oop_base(), R0);
+    __ sub_const_optimized($dst$$Register, $src1$$Register, CompressedOops::base(), R0);
     __ bind(done);
   %}
   ins_pipe(pipe_class_default);
 %}
 
@@ -7004,65 +7042,65 @@
 %}
 
 // Disjoint narrow oop base.
 instruct encodeP_Disjoint(iRegNdst dst, iRegPsrc src) %{
   match(Set dst (EncodeP src));
-  predicate(Universe::narrow_oop_base_disjoint());
+  predicate(CompressedOops::base_disjoint());
 
   format %{ "EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
-    __ rldicl($dst$$Register, $src$$Register, 64-Universe::narrow_oop_shift(), 32);
+    __ rldicl($dst$$Register, $src$$Register, 64-CompressedOops::shift(), 32);
   %}
   ins_pipe(pipe_class_default);
 %}
 
 // shift != 0, base != 0
 instruct encodeP_Ex(iRegNdst dst, flagsReg crx, iRegPsrc src) %{
   match(Set dst (EncodeP src));
   effect(TEMP crx);
   predicate(n->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull &&
-            Universe::narrow_oop_shift() != 0 &&
-            Universe::narrow_oop_base_overlaps());
+            CompressedOops::shift() != 0 &&
+            CompressedOops::base_overlaps());
 
   format %{ "EncodeP $dst, $crx, $src \t// postalloc expanded" %}
   postalloc_expand( postalloc_expand_encode_oop(dst, src, crx));
 %}
 
 // shift != 0, base != 0
 instruct encodeP_not_null_Ex(iRegNdst dst, iRegPsrc src) %{
   match(Set dst (EncodeP src));
   predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull &&
-            Universe::narrow_oop_shift() != 0 &&
-            Universe::narrow_oop_base_overlaps());
+            CompressedOops::shift() != 0 &&
+            CompressedOops::base_overlaps());
 
   format %{ "EncodeP $dst, $src\t// $src != Null, postalloc expanded" %}
   postalloc_expand( postalloc_expand_encode_oop_not_null(dst, src) );
 %}
 
 // shift != 0, base == 0
 // TODO: This is the same as encodeP_shift. Merge!
 instruct encodeP_not_null_base_null(iRegNdst dst, iRegPsrc src) %{
   match(Set dst (EncodeP src));
-  predicate(Universe::narrow_oop_shift() != 0 &&
-            Universe::narrow_oop_base() ==0);
+  predicate(CompressedOops::shift() != 0 &&
+            CompressedOops::base() ==0);
 
   format %{ "SRDI    $dst, $src, #3 \t// encodeP, $src != NULL" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
-    __ srdi($dst$$Register, $src$$Register, Universe::narrow_oop_shift() & 0x3f);
+    __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() & 0x3f);
   %}
   ins_pipe(pipe_class_default);
 %}
 
 // Compressed OOPs with narrow_oop_shift == 0.
 // shift == 0, base == 0
 instruct encodeP_narrow_oop_shift_0(iRegNdst dst, iRegPsrc src) %{
   match(Set dst (EncodeP src));
-  predicate(Universe::narrow_oop_shift() == 0);
+  predicate(CompressedOops::shift() == 0);
 
   format %{ "MR      $dst, $src \t// Ptr->Narrow" %}
   // variable size, 0 or 4.
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_or);
@@ -7081,11 +7119,11 @@
 
   format %{ "SLDI    $dst, $src, #3 \t// DecodeN" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
-    __ sldi($dst$$Register, $src$$Register, Universe::narrow_oop_shift());
+    __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());
   %}
   ins_pipe(pipe_class_default);
 %}
 
 // Add node for expand.
@@ -7095,11 +7133,11 @@
   predicate(false);
 
   format %{ "ADD     $dst, $src, heapbase \t// DecodeN, add oop base" %}
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
-    __ add_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);
+    __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
   %}
   ins_pipe(pipe_class_default);
 %}
 
 // conditianal add base for expand
@@ -7116,11 +7154,11 @@
             "done:" %}
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
     Label done;
     __ beq($crx$$CondRegister, done);
-    __ add_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);
+    __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
     __ bind(done);
   %}
   ins_pipe(pipe_class_default);
 %}
 
@@ -7145,30 +7183,30 @@
 //  shift != 0, base != 0
 instruct decodeN_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
   match(Set dst (DecodeN src));
   predicate((n->bottom_type()->is_oopptr()->ptr() != TypePtr::NotNull &&
              n->bottom_type()->is_oopptr()->ptr() != TypePtr::Constant) &&
-            Universe::narrow_oop_shift() != 0 &&
-            Universe::narrow_oop_base() != 0);
+            CompressedOops::shift() != 0 &&
+            CompressedOops::base() != 0);
   ins_cost(4 * DEFAULT_COST); // Should be more expensive than decodeN_Disjoint_isel_Ex.
   effect(TEMP crx);
 
   format %{ "DecodeN $dst, $src \t// Kills $crx, postalloc expanded" %}
   postalloc_expand( postalloc_expand_decode_oop(dst, src, crx) );
 %}
 
 // shift != 0, base == 0
 instruct decodeN_nullBase(iRegPdst dst, iRegNsrc src) %{
   match(Set dst (DecodeN src));
-  predicate(Universe::narrow_oop_shift() != 0 &&
-            Universe::narrow_oop_base() == 0);
+  predicate(CompressedOops::shift() != 0 &&
+            CompressedOops::base() == 0);
 
   format %{ "SLDI    $dst, $src, #3 \t// DecodeN (zerobased)" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
-    __ sldi($dst$$Register, $src$$Register, Universe::narrow_oop_shift());
+    __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());
   %}
   ins_pipe(pipe_class_default);
 %}
 
 // Optimize DecodeN for disjoint base.
@@ -7181,11 +7219,11 @@
 
   format %{ "RLDIMI  $dst, $src, shift, 32-shift \t// DecodeN (disjoint base)" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
-    __ rldimi($dst$$Register, $src$$Register, Universe::narrow_oop_shift(), 32-Universe::narrow_oop_shift());
+    __ rldimi($dst$$Register, $src$$Register, CompressedOops::shift(), 32-CompressedOops::shift());
   %}
   ins_pipe(pipe_class_default);
 %}
 
 // Optimize DecodeN for disjoint base.
@@ -7195,11 +7233,11 @@
 instruct decodeN_Disjoint_notNull_Ex(iRegPdst dst, iRegNsrc src) %{
   match(Set dst (DecodeN src));
   effect(TEMP_DEF dst);
   predicate((n->bottom_type()->is_oopptr()->ptr() == TypePtr::NotNull ||
              n->bottom_type()->is_oopptr()->ptr() == TypePtr::Constant) &&
-            Universe::narrow_oop_base_disjoint());
+            CompressedOops::base_disjoint());
   ins_cost(DEFAULT_COST);
 
   format %{ "MOV     $dst, heapbase \t\n"
             "RLDIMI  $dst, $src, shift, 32-shift \t// decode with disjoint base" %}
   postalloc_expand %{
@@ -7225,11 +7263,11 @@
 instruct decodeN_Disjoint_isel_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
   match(Set dst (DecodeN src));
   effect(TEMP_DEF dst, TEMP crx);
   predicate((n->bottom_type()->is_oopptr()->ptr() != TypePtr::NotNull &&
              n->bottom_type()->is_oopptr()->ptr() != TypePtr::Constant) &&
-            Universe::narrow_oop_base_disjoint() && VM_Version::has_isel());
+            CompressedOops::base_disjoint() && VM_Version::has_isel());
   ins_cost(3 * DEFAULT_COST);
 
   format %{ "DecodeN  $dst, $src \t// decode with disjoint base using isel" %}
   postalloc_expand %{
     loadBaseNode *n1 = new loadBaseNode();
@@ -7274,22 +7312,22 @@
 // src != 0, shift != 0, base != 0
 instruct decodeN_notNull_addBase_Ex(iRegPdst dst, iRegNsrc src) %{
   match(Set dst (DecodeN src));
   predicate((n->bottom_type()->is_oopptr()->ptr() == TypePtr::NotNull ||
              n->bottom_type()->is_oopptr()->ptr() == TypePtr::Constant) &&
-            Universe::narrow_oop_shift() != 0 &&
-            Universe::narrow_oop_base() != 0);
+            CompressedOops::shift() != 0 &&
+            CompressedOops::base() != 0);
   ins_cost(2 * DEFAULT_COST);
 
   format %{ "DecodeN $dst, $src \t// $src != NULL, postalloc expanded" %}
   postalloc_expand( postalloc_expand_decode_oop_not_null(dst, src));
 %}
 
 // Compressed OOPs with narrow_oop_shift == 0.
 instruct decodeN_unscaled(iRegPdst dst, iRegNsrc src) %{
   match(Set dst (DecodeN src));
-  predicate(Universe::narrow_oop_shift() == 0);
+  predicate(CompressedOops::shift() == 0);
   ins_cost(DEFAULT_COST);
 
   format %{ "MR      $dst, $src \t// DecodeN (unscaled)" %}
   // variable size, 0 or 4.
   ins_encode %{
@@ -7300,11 +7338,11 @@
 %}
 
 // Convert compressed oop into int for vectors alignment masking.
 instruct decodeN2I_unscaled(iRegIdst dst, iRegNsrc src) %{
   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
-  predicate(Universe::narrow_oop_shift() == 0);
+  predicate(CompressedOops::shift() == 0);
   ins_cost(DEFAULT_COST);
 
   format %{ "MR      $dst, $src \t// (int)DecodeN (unscaled)" %}
   // variable size, 0 or 4.
   ins_encode %{
@@ -7326,11 +7364,11 @@
 
   format %{ "SRDI    $dst, $src, 3 \t// encode" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
-    __ srdi($dst$$Register, $src$$Register, Universe::narrow_klass_shift());
+    __ srdi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());
   %}
   ins_pipe(pipe_class_default);
 %}
 
 // Add node for expand.
@@ -7349,17 +7387,17 @@
 %}
 
 // Disjoint narrow oop base.
 instruct encodePKlass_Disjoint(iRegNdst dst, iRegPsrc src) %{
   match(Set dst (EncodePKlass src));
-  predicate(false /* TODO: PPC port Universe::narrow_klass_base_disjoint()*/);
+  predicate(false /* TODO: PPC port CompressedKlassPointers::base_disjoint()*/);
 
   format %{ "EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
-    __ rldicl($dst$$Register, $src$$Register, 64-Universe::narrow_klass_shift(), 32);
+    __ rldicl($dst$$Register, $src$$Register, 64-CompressedKlassPointers::shift(), 32);
   %}
   ins_pipe(pipe_class_default);
 %}
 
 // shift != 0, base != 0
@@ -7390,17 +7428,17 @@
 %}
 
 // shift != 0, base != 0
 instruct encodePKlass_not_null_ExEx(iRegNdst dst, iRegPsrc src) %{
   match(Set dst (EncodePKlass src));
-  //predicate(Universe::narrow_klass_shift() != 0 &&
-  //          true /* TODO: PPC port Universe::narrow_klass_base_overlaps()*/);
+  //predicate(CompressedKlassPointers::shift() != 0 &&
+  //          true /* TODO: PPC port CompressedKlassPointers::base_overlaps()*/);
 
   //format %{ "EncodePKlass $dst, $src\t// $src != Null, postalloc expanded" %}
   ins_cost(DEFAULT_COST*2);  // Don't count constant.
   expand %{
-    immL baseImm %{ (jlong)(intptr_t)Universe::narrow_klass_base() %}
+    immL baseImm %{ (jlong)(intptr_t)CompressedKlassPointers::base() %}
     iRegLdst base;
     loadConL_Ex(base, baseImm);
     encodePKlass_not_null_Ex(dst, base, src);
   %}
 %}
@@ -7415,11 +7453,11 @@
 
   format %{ "SLDI    $dst, $src, #3 \t// DecodeNKlass" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
-    __ sldi($dst$$Register, $src$$Register, Universe::narrow_klass_shift());
+    __ sldi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());
   %}
   ins_pipe(pipe_class_default);
 %}
 
 // Add node for expand.
@@ -7468,20 +7506,20 @@
 %}
 
 // src != 0, shift != 0, base != 0
 instruct decodeNKlass_notNull_addBase_ExEx(iRegPdst dst, iRegNsrc src) %{
   match(Set dst (DecodeNKlass src));
-  // predicate(Universe::narrow_klass_shift() != 0 &&
-  //           Universe::narrow_klass_base() != 0);
+  // predicate(CompressedKlassPointers::shift() != 0 &&
+  //           CompressedKlassPointers::base() != 0);
 
   //format %{ "DecodeNKlass $dst, $src \t// $src != NULL, expanded" %}
 
   ins_cost(DEFAULT_COST*2);  // Don't count constant.
   expand %{
     // We add first, then we shift. Like this, we can get along with one register less.
     // But we have to load the base pre-shifted.
-    immL baseImm %{ (jlong)((intptr_t)Universe::narrow_klass_base() >> Universe::narrow_klass_shift()) %}
+    immL baseImm %{ (jlong)((intptr_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift()) %}
     iRegLdst base;
     loadConL_Ex(base, baseImm);
     decodeNKlass_notNull_addBase_Ex(dst, base, src);
   %}
 %}
@@ -10837,10 +10875,18 @@
   size(0);
   ins_encode( /*empty*/ );
   ins_pipe(pipe_class_default);
 %}
 
+instruct castLL(iRegLdst dst) %{
+  match(Set dst (CastLL dst));
+  format %{ " -- \t// castLL of $dst" %}
+  size(0);
+  ins_encode( /*empty*/ );
+  ins_pipe(pipe_class_default);
+%}
+
 instruct checkCastPP(iRegPdst dst) %{
   match(Set dst (CheckCastPP dst));
   format %{ " -- \t// checkcastPP of $dst" %}
   size(0);
   ins_encode( /*empty*/ );
@@ -14007,11 +14053,11 @@
 %}
 
 instruct repl4S_immI0(iRegLdst dst, immI_0 zero) %{
   match(Set dst (ReplicateS zero));
   predicate(n->as_Vector()->length() == 4);
-  format %{ "LI      $dst, #0 \t// replicate4C" %}
+  format %{ "LI      $dst, #0 \t// replicate4S" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
     __ li($dst$$Register, (int)((short)($zero$$constant & 0xFFFF)));
   %}
@@ -14019,11 +14065,11 @@
 %}
 
 instruct repl4S_immIminus1(iRegLdst dst, immI_minus1 src) %{
   match(Set dst (ReplicateS src));
   predicate(n->as_Vector()->length() == 4);
-  format %{ "LI      $dst, -1 \t// replicate4C" %}
+  format %{ "LI      $dst, -1 \t// replicate4S" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
     __ li($dst$$Register, (int)((short)($src$$constant & 0xFFFF)));
   %}
@@ -14060,11 +14106,11 @@
 
 instruct repl8S_immIminus1(vecX dst, immI_minus1 src) %{
   match(Set dst (ReplicateS src));
   predicate(n->as_Vector()->length() == 8);
 
-  format %{ "XXLEQV      $dst, $src \t// replicate16B" %}
+  format %{ "XXLEQV      $dst, $src \t// replicate8S" %}
   size(4);
   ins_encode %{
     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
   %}
   ins_pipe(pipe_class_default);
@@ -14081,11 +14127,11 @@
 %}
 
 instruct repl2I_immI0(iRegLdst dst, immI_0 zero) %{
   match(Set dst (ReplicateI zero));
   predicate(n->as_Vector()->length() == 2);
-  format %{ "LI      $dst, #0 \t// replicate4C" %}
+  format %{ "LI      $dst, #0 \t// replicate2I" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
     __ li($dst$$Register, (int)((short)($zero$$constant & 0xFFFF)));
   %}
@@ -14093,11 +14139,11 @@
 %}
 
 instruct repl2I_immIminus1(iRegLdst dst, immI_minus1 src) %{
   match(Set dst (ReplicateI src));
   predicate(n->as_Vector()->length() == 2);
-  format %{ "LI      $dst, -1 \t// replicate4C" %}
+  format %{ "LI      $dst, -1 \t// replicate2I" %}
   size(4);
   ins_encode %{
     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
     __ li($dst$$Register, (int)((short)($src$$constant & 0xFFFF)));
   %}
@@ -14416,10 +14462,57 @@
     __ xvabsdp($dst$$VectorSRegister, $src$$VectorSRegister);
   %}
   ins_pipe(pipe_class_default);
 %}
 
+// Round Instructions
+instruct roundD_reg(regD dst, regD src, immI8 rmode) %{
+  match(Set dst (RoundDoubleMode src rmode));
+  format %{ "RoundDoubleMode $src,$rmode" %}
+  size(4);
+  ins_encode %{
+    switch ($rmode$$constant) {
+      case RoundDoubleModeNode::rmode_rint:
+        __ frin($dst$$FloatRegister, $src$$FloatRegister);
+        break;
+      case RoundDoubleModeNode::rmode_floor:
+        __ frim($dst$$FloatRegister, $src$$FloatRegister);
+        break;
+      case RoundDoubleModeNode::rmode_ceil:
+        __ frip($dst$$FloatRegister, $src$$FloatRegister);
+        break;
+      default:
+        ShouldNotReachHere();
+    }
+  %}
+  ins_pipe(pipe_class_default);
+%}
+
+// Vector Round Instructions
+instruct vround2D_reg(vecX dst, vecX src, immI8 rmode) %{
+  match(Set dst (RoundDoubleModeV src rmode));
+  predicate(n->as_Vector()->length() == 2);
+  format %{ "RoundDoubleModeV $src,$rmode" %}
+  size(4);
+  ins_encode %{
+    switch ($rmode$$constant) {
+      case RoundDoubleModeNode::rmode_rint:
+        __ xvrdpi($dst$$VectorSRegister, $src$$VectorSRegister);
+        break;
+      case RoundDoubleModeNode::rmode_floor:
+        __ xvrdpim($dst$$VectorSRegister, $src$$VectorSRegister);
+        break;
+      case RoundDoubleModeNode::rmode_ceil:
+        __ xvrdpip($dst$$VectorSRegister, $src$$VectorSRegister);
+        break;
+      default:
+        ShouldNotReachHere();
+    }
+  %}
+  ins_pipe(pipe_class_default);
+%}
+
 // Vector Negate Instructions
 
 instruct vneg4F_reg(vecX dst, vecX src) %{
   match(Set dst (NegVF src));
   predicate(n->as_Vector()->length() == 4);
@@ -14667,11 +14760,11 @@
     __ xxpermdi($dst$$VectorSRegister, $src$$FloatRegister->to_vsr(), $src$$FloatRegister->to_vsr(), 0);
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct repl2D_immI0(vecX dst, immI_0 zero) %{
+instruct repl2D_immD0(vecX dst, immD_0 zero) %{
   match(Set dst (ReplicateD zero));
   predicate(n->as_Vector()->length() == 2);
 
   format %{ "XXLXOR      $dst, $zero \t// replicate2D" %}
   size(4);
@@ -14679,22 +14772,10 @@
     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct repl2D_immIminus1(vecX dst, immI_minus1 src) %{
-  match(Set dst (ReplicateD src));
-  predicate(n->as_Vector()->length() == 2);
-
-  format %{ "XXLEQV      $dst, $src \t// replicate16B" %}
-  size(4);
-  ins_encode %{
-    __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
-  %}
-  ins_pipe(pipe_class_default);
-%}
-
 instruct mtvsrd(vecX dst, iRegLsrc src) %{
   predicate(false);
   effect(DEF dst, USE src);
 
   format %{ "MTVSRD      $dst, $src \t// Move to 16-byte register" %}
@@ -14752,11 +14833,11 @@
 
 instruct repl2L_immIminus1(vecX dst, immI_minus1 src) %{
   match(Set dst (ReplicateL src));
   predicate(n->as_Vector()->length() == 2);
 
-  format %{ "XXLEQV      $dst, $src \t// replicate16B" %}
+  format %{ "XXLEQV      $dst, $src \t// replicate2L" %}
   size(4);
   ins_encode %{
     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
   %}
   ins_pipe(pipe_class_default);
@@ -15142,10 +15223,48 @@
     __ brnop2();
   %}
   ins_pipe(pipe_class_default);
 %}
 
+instruct cacheWB(indirect addr)
+%{
+  match(CacheWB addr);
+
+  ins_cost(100);
+  format %{ "cache writeback, address = $addr" %}
+  ins_encode %{
+    assert($addr->index_position() < 0, "should be");
+    assert($addr$$disp == 0, "should be");
+    __ cache_wb(Address($addr$$base$$Register));
+  %}
+  ins_pipe(pipe_class_default);
+%}
+
+instruct cacheWBPreSync()
+%{
+  match(CacheWBPreSync);
+
+  ins_cost(0);
+  format %{ "cache writeback presync" %}
+  ins_encode %{
+    __ cache_wbsync(true);
+  %}
+  ins_pipe(pipe_class_default);
+%}
+
+instruct cacheWBPostSync()
+%{
+  match(CacheWBPostSync);
+
+  ins_cost(100);
+  format %{ "cache writeback postsync" %}
+  ins_encode %{
+    __ cache_wbsync(false);
+  %}
+  ins_pipe(pipe_class_default);
+%}
+
 //----------PEEPHOLE RULES-----------------------------------------------------
 // These must follow all instruction definitions as they use the names
 // defined in the instructions definitions.
 //
 // peepmatch ( root_instr_name [preceeding_instruction]* );

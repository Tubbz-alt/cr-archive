<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/nativeInst_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodHandles_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_ppc.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/nativeInst_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
357     fatal(&quot;not a NativeJump at &quot; PTR_FORMAT, p2i(addr));
358   }
359 }
360 #endif // ASSERT
361 
362 
363 void NativeGeneralJump::insert_unconditional(address code_pos, address entry) {
364   CodeBuffer cb(code_pos, BytesPerInstWord + 1);
365   MacroAssembler a(&amp;cb);
366   a.b(entry);
367   ICache::ppc64_flush_icache_bytes(code_pos, NativeGeneralJump::instruction_size);
368 }
369 
370 // MT-safe patching of a jmp instruction.
371 void NativeGeneralJump::replace_mt_safe(address instr_addr, address code_buffer) {
372   // Bytes beyond offset NativeGeneralJump::instruction_size are copied by caller.
373 
374   // Finally patch out the jump.
375   volatile juint *jump_addr = (volatile juint*)instr_addr;
376   // Release not needed because caller uses invalidate_range after copying the remaining bytes.
<span class="line-modified">377   //OrderAccess::release_store(jump_addr, *((juint*)code_buffer));</span>
378   *jump_addr = *((juint*)code_buffer); // atomically store code over branch instruction
379   ICache::ppc64_flush_icache_bytes(instr_addr, NativeGeneralJump::instruction_size);
380 }
381 
382 
383 //-------------------------------------------------------------------
384 
385 // Call trampoline stubs.
386 //
387 // Layout and instructions of a call trampoline stub:
388 //    0:  load the TOC (part 1)
389 //    4:  load the TOC (part 2)
390 //    8:  load the call target from the constant pool (part 1)
391 //  [12:  load the call target from the constant pool (part 2, optional)]
392 //   ..:  branch via CTR
393 //
394 
395 address NativeCallTrampolineStub::encoded_destination_addr() const {
396   address instruction_addr = addr_at(0 * BytesPerInstWord);
397   if (!MacroAssembler::is_ld_largeoffset(instruction_addr)) {
</pre>
</td>
<td>
<hr />
<pre>
357     fatal(&quot;not a NativeJump at &quot; PTR_FORMAT, p2i(addr));
358   }
359 }
360 #endif // ASSERT
361 
362 
363 void NativeGeneralJump::insert_unconditional(address code_pos, address entry) {
364   CodeBuffer cb(code_pos, BytesPerInstWord + 1);
365   MacroAssembler a(&amp;cb);
366   a.b(entry);
367   ICache::ppc64_flush_icache_bytes(code_pos, NativeGeneralJump::instruction_size);
368 }
369 
370 // MT-safe patching of a jmp instruction.
371 void NativeGeneralJump::replace_mt_safe(address instr_addr, address code_buffer) {
372   // Bytes beyond offset NativeGeneralJump::instruction_size are copied by caller.
373 
374   // Finally patch out the jump.
375   volatile juint *jump_addr = (volatile juint*)instr_addr;
376   // Release not needed because caller uses invalidate_range after copying the remaining bytes.
<span class="line-modified">377   //Atomic::release_store(jump_addr, *((juint*)code_buffer));</span>
378   *jump_addr = *((juint*)code_buffer); // atomically store code over branch instruction
379   ICache::ppc64_flush_icache_bytes(instr_addr, NativeGeneralJump::instruction_size);
380 }
381 
382 
383 //-------------------------------------------------------------------
384 
385 // Call trampoline stubs.
386 //
387 // Layout and instructions of a call trampoline stub:
388 //    0:  load the TOC (part 1)
389 //    4:  load the TOC (part 2)
390 //    8:  load the call target from the constant pool (part 1)
391 //  [12:  load the call target from the constant pool (part 2, optional)]
392 //   ..:  branch via CTR
393 //
394 
395 address NativeCallTrampolineStub::encoded_destination_addr() const {
396   address instruction_addr = addr_at(0 * BytesPerInstWord);
397   if (!MacroAssembler::is_ld_largeoffset(instruction_addr)) {
</pre>
</td>
</tr>
</table>
<center><a href="methodHandles_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_ppc.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
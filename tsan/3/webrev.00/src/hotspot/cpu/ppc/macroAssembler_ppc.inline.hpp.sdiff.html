<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/macroAssembler_ppc.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_ppc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/macroAssembler_ppc.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_PPC_MACROASSEMBLER_PPC_INLINE_HPP
 27 #define CPU_PPC_MACROASSEMBLER_PPC_INLINE_HPP
 28 
 29 #include &quot;asm/assembler.inline.hpp&quot;
 30 #include &quot;asm/macroAssembler.hpp&quot;
 31 #include &quot;asm/codeBuffer.hpp&quot;
 32 #include &quot;code/codeCache.hpp&quot;
 33 #include &quot;gc/shared/barrierSet.hpp&quot;
 34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
 35 #include &quot;oops/accessDecorators.hpp&quot;

 36 #include &quot;runtime/safepointMechanism.hpp&quot;

 37 
 38 inline bool MacroAssembler::is_ld_largeoffset(address a) {
 39   const int inst1 = *(int *)a;
 40   const int inst2 = *(int *)(a+4);
 41   return (is_ld(inst1)) ||
 42          (is_addis(inst1) &amp;&amp; is_ld(inst2) &amp;&amp; inv_ra_field(inst2) == inv_rt_field(inst1));
 43 }
 44 
 45 inline int MacroAssembler::get_ld_largeoffset_offset(address a) {
 46   assert(MacroAssembler::is_ld_largeoffset(a), &quot;must be ld with large offset&quot;);
 47 
 48   const int inst1 = *(int *)a;
 49   if (is_ld(inst1)) {
 50     return inv_d1_field(inst1);
 51   } else {
 52     const int inst2 = *(int *)(a+4);
 53     return (inv_d1_field(inst1) &lt;&lt; 16) + inv_d1_field(inst2);
 54   }
 55 }
 56 
 57 inline void MacroAssembler::round_to(Register r, int modulus) {
<span class="line-modified"> 58   assert(is_power_of_2_long((jlong)modulus), &quot;must be power of 2&quot;);</span>
 59   addi(r, r, modulus-1);
 60   clrrdi(r, r, log2_long((jlong)modulus));
 61 }
 62 
 63 // Move register if destination register and target register are different.
 64 inline void MacroAssembler::mr_if_needed(Register rd, Register rs) {
 65   if (rs != rd) mr(rd, rs);
 66 }
 67 inline void MacroAssembler::fmr_if_needed(FloatRegister rd, FloatRegister rs) {
 68   if (rs != rd) fmr(rd, rs);
 69 }
 70 inline void MacroAssembler::endgroup_if_needed(bool needed) {
 71   if (needed) {
 72     endgroup();
 73   }
 74 }
 75 
 76 inline void MacroAssembler::membar(int bits) {
 77   // Comment: Usage of elemental_membar(bits) is not recommended for Power 8.
 78   // If elemental_membar(bits) is used, disable optimization of acquire-release
</pre>
<hr />
<pre>
361     bs-&gt;load_at(this, decorators, type,
362                 base, ind_or_offs, dst,
363                 tmp1, tmp2, needs_frame, L_handle_null);
364   }
365 }
366 
367 inline void MacroAssembler::load_heap_oop(Register d, RegisterOrConstant offs, Register s1,
368                                           Register tmp1, Register tmp2,
369                                           bool needs_frame, DecoratorSet decorators, Label *L_handle_null) {
370   access_load_at(T_OBJECT, IN_HEAP | decorators, s1, offs, d, tmp1, tmp2, needs_frame, L_handle_null);
371 }
372 
373 inline void MacroAssembler::store_heap_oop(Register d, RegisterOrConstant offs, Register s1,
374                                            Register tmp1, Register tmp2, Register tmp3,
375                                            bool needs_frame, DecoratorSet decorators) {
376   access_store_at(T_OBJECT, IN_HEAP | decorators, s1, offs, d, tmp1, tmp2, tmp3, needs_frame);
377 }
378 
379 inline Register MacroAssembler::encode_heap_oop_not_null(Register d, Register src) {
380   Register current = (src != noreg) ? src : d; // Oop to be compressed is in d if no src provided.
<span class="line-modified">381   if (Universe::narrow_oop_base_overlaps()) {</span>
<span class="line-modified">382     sub_const_optimized(d, current, Universe::narrow_oop_base(), R0);</span>
383     current = d;
384   }
<span class="line-modified">385   if (Universe::narrow_oop_shift() != 0) {</span>
<span class="line-modified">386     rldicl(d, current, 64-Universe::narrow_oop_shift(), 32);  // Clears the upper bits.</span>
387     current = d;
388   }
389   return current; // Encoded oop is in this register.
390 }
391 
392 inline Register MacroAssembler::encode_heap_oop(Register d, Register src) {
<span class="line-modified">393   if (Universe::narrow_oop_base() != NULL) {</span>
394     if (VM_Version::has_isel()) {
395       cmpdi(CCR0, src, 0);
396       Register co = encode_heap_oop_not_null(d, src);
397       assert(co == d, &quot;sanity&quot;);
398       isel_0(d, CCR0, Assembler::equal);
399     } else {
400       Label isNull;
401       or_(d, src, src); // move and compare 0
402       beq(CCR0, isNull);
403       encode_heap_oop_not_null(d, src);
404       bind(isNull);
405     }
406     return d;
407   } else {
408     return encode_heap_oop_not_null(d, src);
409   }
410 }
411 
412 inline Register MacroAssembler::decode_heap_oop_not_null(Register d, Register src) {
<span class="line-modified">413   if (Universe::narrow_oop_base_disjoint() &amp;&amp; src != noreg &amp;&amp; src != d &amp;&amp;</span>
<span class="line-modified">414       Universe::narrow_oop_shift() != 0) {</span>
<span class="line-modified">415     load_const_optimized(d, Universe::narrow_oop_base(), R0);</span>
<span class="line-modified">416     rldimi(d, src, Universe::narrow_oop_shift(), 32-Universe::narrow_oop_shift());</span>
417     return d;
418   }
419 
420   Register current = (src != noreg) ? src : d; // Compressed oop is in d if no src provided.
<span class="line-modified">421   if (Universe::narrow_oop_shift() != 0) {</span>
<span class="line-modified">422     sldi(d, current, Universe::narrow_oop_shift());</span>
423     current = d;
424   }
<span class="line-modified">425   if (Universe::narrow_oop_base() != NULL) {</span>
<span class="line-modified">426     add_const_optimized(d, current, Universe::narrow_oop_base(), R0);</span>
427     current = d;
428   }
429   return current; // Decoded oop is in this register.
430 }
431 
432 inline void MacroAssembler::decode_heap_oop(Register d) {
433   Label isNull;
434   bool use_isel = false;
<span class="line-modified">435   if (Universe::narrow_oop_base() != NULL) {</span>
436     cmpwi(CCR0, d, 0);
437     if (VM_Version::has_isel()) {
438       use_isel = true;
439     } else {
440       beq(CCR0, isNull);
441     }
442   }
443   decode_heap_oop_not_null(d);
444   if (use_isel) {
445     isel_0(d, CCR0, Assembler::equal);
446   }
447   bind(isNull);
448 }
449 
450 // SIGTRAP-based range checks for arrays.
451 inline void MacroAssembler::trap_range_check_l(Register a, Register b) {
452   tw (traptoLessThanUnsigned,                  a/*reg a*/, b/*reg b*/);
453 }
454 inline void MacroAssembler::trap_range_check_l(Register a, int si16) {
455   twi(traptoLessThanUnsigned,                  a/*reg a*/, si16);
</pre>
</td>
<td>
<hr />
<pre>
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_PPC_MACROASSEMBLER_PPC_INLINE_HPP
 27 #define CPU_PPC_MACROASSEMBLER_PPC_INLINE_HPP
 28 
 29 #include &quot;asm/assembler.inline.hpp&quot;
 30 #include &quot;asm/macroAssembler.hpp&quot;
 31 #include &quot;asm/codeBuffer.hpp&quot;
 32 #include &quot;code/codeCache.hpp&quot;
 33 #include &quot;gc/shared/barrierSet.hpp&quot;
 34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
 35 #include &quot;oops/accessDecorators.hpp&quot;
<span class="line-added"> 36 #include &quot;oops/compressedOops.hpp&quot;</span>
 37 #include &quot;runtime/safepointMechanism.hpp&quot;
<span class="line-added"> 38 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 39 
 40 inline bool MacroAssembler::is_ld_largeoffset(address a) {
 41   const int inst1 = *(int *)a;
 42   const int inst2 = *(int *)(a+4);
 43   return (is_ld(inst1)) ||
 44          (is_addis(inst1) &amp;&amp; is_ld(inst2) &amp;&amp; inv_ra_field(inst2) == inv_rt_field(inst1));
 45 }
 46 
 47 inline int MacroAssembler::get_ld_largeoffset_offset(address a) {
 48   assert(MacroAssembler::is_ld_largeoffset(a), &quot;must be ld with large offset&quot;);
 49 
 50   const int inst1 = *(int *)a;
 51   if (is_ld(inst1)) {
 52     return inv_d1_field(inst1);
 53   } else {
 54     const int inst2 = *(int *)(a+4);
 55     return (inv_d1_field(inst1) &lt;&lt; 16) + inv_d1_field(inst2);
 56   }
 57 }
 58 
 59 inline void MacroAssembler::round_to(Register r, int modulus) {
<span class="line-modified"> 60   assert(is_power_of_2((jlong)modulus), &quot;must be power of 2&quot;);</span>
 61   addi(r, r, modulus-1);
 62   clrrdi(r, r, log2_long((jlong)modulus));
 63 }
 64 
 65 // Move register if destination register and target register are different.
 66 inline void MacroAssembler::mr_if_needed(Register rd, Register rs) {
 67   if (rs != rd) mr(rd, rs);
 68 }
 69 inline void MacroAssembler::fmr_if_needed(FloatRegister rd, FloatRegister rs) {
 70   if (rs != rd) fmr(rd, rs);
 71 }
 72 inline void MacroAssembler::endgroup_if_needed(bool needed) {
 73   if (needed) {
 74     endgroup();
 75   }
 76 }
 77 
 78 inline void MacroAssembler::membar(int bits) {
 79   // Comment: Usage of elemental_membar(bits) is not recommended for Power 8.
 80   // If elemental_membar(bits) is used, disable optimization of acquire-release
</pre>
<hr />
<pre>
363     bs-&gt;load_at(this, decorators, type,
364                 base, ind_or_offs, dst,
365                 tmp1, tmp2, needs_frame, L_handle_null);
366   }
367 }
368 
369 inline void MacroAssembler::load_heap_oop(Register d, RegisterOrConstant offs, Register s1,
370                                           Register tmp1, Register tmp2,
371                                           bool needs_frame, DecoratorSet decorators, Label *L_handle_null) {
372   access_load_at(T_OBJECT, IN_HEAP | decorators, s1, offs, d, tmp1, tmp2, needs_frame, L_handle_null);
373 }
374 
375 inline void MacroAssembler::store_heap_oop(Register d, RegisterOrConstant offs, Register s1,
376                                            Register tmp1, Register tmp2, Register tmp3,
377                                            bool needs_frame, DecoratorSet decorators) {
378   access_store_at(T_OBJECT, IN_HEAP | decorators, s1, offs, d, tmp1, tmp2, tmp3, needs_frame);
379 }
380 
381 inline Register MacroAssembler::encode_heap_oop_not_null(Register d, Register src) {
382   Register current = (src != noreg) ? src : d; // Oop to be compressed is in d if no src provided.
<span class="line-modified">383   if (CompressedOops::base_overlaps()) {</span>
<span class="line-modified">384     sub_const_optimized(d, current, CompressedOops::base(), R0);</span>
385     current = d;
386   }
<span class="line-modified">387   if (CompressedOops::shift() != 0) {</span>
<span class="line-modified">388     rldicl(d, current, 64-CompressedOops::shift(), 32);  // Clears the upper bits.</span>
389     current = d;
390   }
391   return current; // Encoded oop is in this register.
392 }
393 
394 inline Register MacroAssembler::encode_heap_oop(Register d, Register src) {
<span class="line-modified">395   if (CompressedOops::base() != NULL) {</span>
396     if (VM_Version::has_isel()) {
397       cmpdi(CCR0, src, 0);
398       Register co = encode_heap_oop_not_null(d, src);
399       assert(co == d, &quot;sanity&quot;);
400       isel_0(d, CCR0, Assembler::equal);
401     } else {
402       Label isNull;
403       or_(d, src, src); // move and compare 0
404       beq(CCR0, isNull);
405       encode_heap_oop_not_null(d, src);
406       bind(isNull);
407     }
408     return d;
409   } else {
410     return encode_heap_oop_not_null(d, src);
411   }
412 }
413 
414 inline Register MacroAssembler::decode_heap_oop_not_null(Register d, Register src) {
<span class="line-modified">415   if (CompressedOops::base_disjoint() &amp;&amp; src != noreg &amp;&amp; src != d &amp;&amp;</span>
<span class="line-modified">416       CompressedOops::shift() != 0) {</span>
<span class="line-modified">417     load_const_optimized(d, CompressedOops::base(), R0);</span>
<span class="line-modified">418     rldimi(d, src, CompressedOops::shift(), 32-CompressedOops::shift());</span>
419     return d;
420   }
421 
422   Register current = (src != noreg) ? src : d; // Compressed oop is in d if no src provided.
<span class="line-modified">423   if (CompressedOops::shift() != 0) {</span>
<span class="line-modified">424     sldi(d, current, CompressedOops::shift());</span>
425     current = d;
426   }
<span class="line-modified">427   if (CompressedOops::base() != NULL) {</span>
<span class="line-modified">428     add_const_optimized(d, current, CompressedOops::base(), R0);</span>
429     current = d;
430   }
431   return current; // Decoded oop is in this register.
432 }
433 
434 inline void MacroAssembler::decode_heap_oop(Register d) {
435   Label isNull;
436   bool use_isel = false;
<span class="line-modified">437   if (CompressedOops::base() != NULL) {</span>
438     cmpwi(CCR0, d, 0);
439     if (VM_Version::has_isel()) {
440       use_isel = true;
441     } else {
442       beq(CCR0, isNull);
443     }
444   }
445   decode_heap_oop_not_null(d);
446   if (use_isel) {
447     isel_0(d, CCR0, Assembler::equal);
448   }
449   bind(isNull);
450 }
451 
452 // SIGTRAP-based range checks for arrays.
453 inline void MacroAssembler::trap_range_check_l(Register a, Register b) {
454   tw (traptoLessThanUnsigned,                  a/*reg a*/, b/*reg b*/);
455 }
456 inline void MacroAssembler::trap_range_check_l(Register a, int si16) {
457   twi(traptoLessThanUnsigned,                  a/*reg a*/, si16);
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_ppc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
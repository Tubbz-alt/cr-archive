<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/ppc/macroAssembler_ppc.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_ppc.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_ppc.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/macroAssembler_ppc.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,11 ***</span>
<span class="line-new-header">--- 31,13 ---</span>
  #include &quot;asm/codeBuffer.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  #include &quot;oops/accessDecorators.hpp&quot;
<span class="line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;runtime/safepointMechanism.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  inline bool MacroAssembler::is_ld_largeoffset(address a) {
    const int inst1 = *(int *)a;
    const int inst2 = *(int *)(a+4);
    return (is_ld(inst1)) ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,11 ***</span>
      return (inv_d1_field(inst1) &lt;&lt; 16) + inv_d1_field(inst2);
    }
  }
  
  inline void MacroAssembler::round_to(Register r, int modulus) {
<span class="line-modified">!   assert(is_power_of_2_long((jlong)modulus), &quot;must be power of 2&quot;);</span>
    addi(r, r, modulus-1);
    clrrdi(r, r, log2_long((jlong)modulus));
  }
  
  // Move register if destination register and target register are different.
<span class="line-new-header">--- 55,11 ---</span>
      return (inv_d1_field(inst1) &lt;&lt; 16) + inv_d1_field(inst2);
    }
  }
  
  inline void MacroAssembler::round_to(Register r, int modulus) {
<span class="line-modified">!   assert(is_power_of_2((jlong)modulus), &quot;must be power of 2&quot;);</span>
    addi(r, r, modulus-1);
    clrrdi(r, r, log2_long((jlong)modulus));
  }
  
  // Move register if destination register and target register are different.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 376,23 ***</span>
    access_store_at(T_OBJECT, IN_HEAP | decorators, s1, offs, d, tmp1, tmp2, tmp3, needs_frame);
  }
  
  inline Register MacroAssembler::encode_heap_oop_not_null(Register d, Register src) {
    Register current = (src != noreg) ? src : d; // Oop to be compressed is in d if no src provided.
<span class="line-modified">!   if (Universe::narrow_oop_base_overlaps()) {</span>
<span class="line-modified">!     sub_const_optimized(d, current, Universe::narrow_oop_base(), R0);</span>
      current = d;
    }
<span class="line-modified">!   if (Universe::narrow_oop_shift() != 0) {</span>
<span class="line-modified">!     rldicl(d, current, 64-Universe::narrow_oop_shift(), 32);  // Clears the upper bits.</span>
      current = d;
    }
    return current; // Encoded oop is in this register.
  }
  
  inline Register MacroAssembler::encode_heap_oop(Register d, Register src) {
<span class="line-modified">!   if (Universe::narrow_oop_base() != NULL) {</span>
      if (VM_Version::has_isel()) {
        cmpdi(CCR0, src, 0);
        Register co = encode_heap_oop_not_null(d, src);
        assert(co == d, &quot;sanity&quot;);
        isel_0(d, CCR0, Assembler::equal);
<span class="line-new-header">--- 378,23 ---</span>
    access_store_at(T_OBJECT, IN_HEAP | decorators, s1, offs, d, tmp1, tmp2, tmp3, needs_frame);
  }
  
  inline Register MacroAssembler::encode_heap_oop_not_null(Register d, Register src) {
    Register current = (src != noreg) ? src : d; // Oop to be compressed is in d if no src provided.
<span class="line-modified">!   if (CompressedOops::base_overlaps()) {</span>
<span class="line-modified">!     sub_const_optimized(d, current, CompressedOops::base(), R0);</span>
      current = d;
    }
<span class="line-modified">!   if (CompressedOops::shift() != 0) {</span>
<span class="line-modified">!     rldicl(d, current, 64-CompressedOops::shift(), 32);  // Clears the upper bits.</span>
      current = d;
    }
    return current; // Encoded oop is in this register.
  }
  
  inline Register MacroAssembler::encode_heap_oop(Register d, Register src) {
<span class="line-modified">!   if (CompressedOops::base() != NULL) {</span>
      if (VM_Version::has_isel()) {
        cmpdi(CCR0, src, 0);
        Register co = encode_heap_oop_not_null(d, src);
        assert(co == d, &quot;sanity&quot;);
        isel_0(d, CCR0, Assembler::equal);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 408,33 ***</span>
      return encode_heap_oop_not_null(d, src);
    }
  }
  
  inline Register MacroAssembler::decode_heap_oop_not_null(Register d, Register src) {
<span class="line-modified">!   if (Universe::narrow_oop_base_disjoint() &amp;&amp; src != noreg &amp;&amp; src != d &amp;&amp;</span>
<span class="line-modified">!       Universe::narrow_oop_shift() != 0) {</span>
<span class="line-modified">!     load_const_optimized(d, Universe::narrow_oop_base(), R0);</span>
<span class="line-modified">!     rldimi(d, src, Universe::narrow_oop_shift(), 32-Universe::narrow_oop_shift());</span>
      return d;
    }
  
    Register current = (src != noreg) ? src : d; // Compressed oop is in d if no src provided.
<span class="line-modified">!   if (Universe::narrow_oop_shift() != 0) {</span>
<span class="line-modified">!     sldi(d, current, Universe::narrow_oop_shift());</span>
      current = d;
    }
<span class="line-modified">!   if (Universe::narrow_oop_base() != NULL) {</span>
<span class="line-modified">!     add_const_optimized(d, current, Universe::narrow_oop_base(), R0);</span>
      current = d;
    }
    return current; // Decoded oop is in this register.
  }
  
  inline void MacroAssembler::decode_heap_oop(Register d) {
    Label isNull;
    bool use_isel = false;
<span class="line-modified">!   if (Universe::narrow_oop_base() != NULL) {</span>
      cmpwi(CCR0, d, 0);
      if (VM_Version::has_isel()) {
        use_isel = true;
      } else {
        beq(CCR0, isNull);
<span class="line-new-header">--- 410,33 ---</span>
      return encode_heap_oop_not_null(d, src);
    }
  }
  
  inline Register MacroAssembler::decode_heap_oop_not_null(Register d, Register src) {
<span class="line-modified">!   if (CompressedOops::base_disjoint() &amp;&amp; src != noreg &amp;&amp; src != d &amp;&amp;</span>
<span class="line-modified">!       CompressedOops::shift() != 0) {</span>
<span class="line-modified">!     load_const_optimized(d, CompressedOops::base(), R0);</span>
<span class="line-modified">!     rldimi(d, src, CompressedOops::shift(), 32-CompressedOops::shift());</span>
      return d;
    }
  
    Register current = (src != noreg) ? src : d; // Compressed oop is in d if no src provided.
<span class="line-modified">!   if (CompressedOops::shift() != 0) {</span>
<span class="line-modified">!     sldi(d, current, CompressedOops::shift());</span>
      current = d;
    }
<span class="line-modified">!   if (CompressedOops::base() != NULL) {</span>
<span class="line-modified">!     add_const_optimized(d, current, CompressedOops::base(), R0);</span>
      current = d;
    }
    return current; // Decoded oop is in this register.
  }
  
  inline void MacroAssembler::decode_heap_oop(Register d) {
    Label isNull;
    bool use_isel = false;
<span class="line-modified">!   if (CompressedOops::base() != NULL) {</span>
      cmpwi(CCR0, d, 0);
      if (VM_Version::has_isel()) {
        use_isel = true;
      } else {
        beq(CCR0, isNull);
</pre>
<center><a href="macroAssembler_ppc.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_ppc.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
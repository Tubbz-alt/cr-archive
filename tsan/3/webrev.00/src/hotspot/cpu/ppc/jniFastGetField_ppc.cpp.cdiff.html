<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/ppc/jniFastGetField_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interpreterRT_ppc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_ppc.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/jniFastGetField_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">!  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">!  * Copyright (c) 2012, 2019 SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,20 ***</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-modified">! #include &quot;asm/assembler.inline.hpp&quot;</span>
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;prims/jniFastGetField.hpp&quot;
  #include &quot;prims/jvm_misc.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  
  
  address JNI_FastGetField::generate_fast_get_int_field0(BasicType type) {
<span class="line-modified">!   // We don&#39;t have fast jni accessors.</span>
<span class="line-modified">!   return (address) -1;</span>
  }
  
  address JNI_FastGetField::generate_fast_get_boolean_field() {
    return generate_fast_get_int_field0(T_BOOLEAN);
  }
<span class="line-new-header">--- 22,142 ---</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-modified">! #include &quot;asm/macroAssembler.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shared/barrierSetAssembler.hpp&quot;</span>
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;prims/jniFastGetField.hpp&quot;
  #include &quot;prims/jvm_misc.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  
<span class="line-added">+ #define __ masm-&gt;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define BUFFER_SIZE 48*BytesPerInstWord</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ // Common register usage:</span>
<span class="line-added">+ // R3/F0:      result</span>
<span class="line-added">+ // R3_ARG1:    jni env</span>
<span class="line-added">+ // R4_ARG2:    obj</span>
<span class="line-added">+ // R5_ARG3:    jfield id</span>
  
  address JNI_FastGetField::generate_fast_get_int_field0(BasicType type) {
<span class="line-modified">!   const char *name;</span>
<span class="line-modified">!   switch (type) {</span>
<span class="line-added">+     case T_BOOLEAN: name = &quot;jni_fast_GetBooleanField&quot;; break;</span>
<span class="line-added">+     case T_BYTE:    name = &quot;jni_fast_GetByteField&quot;;    break;</span>
<span class="line-added">+     case T_CHAR:    name = &quot;jni_fast_GetCharField&quot;;    break;</span>
<span class="line-added">+     case T_SHORT:   name = &quot;jni_fast_GetShortField&quot;;   break;</span>
<span class="line-added">+     case T_INT:     name = &quot;jni_fast_GetIntField&quot;;     break;</span>
<span class="line-added">+     case T_LONG:    name = &quot;jni_fast_GetLongField&quot;;    break;</span>
<span class="line-added">+     case T_FLOAT:   name = &quot;jni_fast_GetFloatField&quot;;   break;</span>
<span class="line-added">+     case T_DOUBLE:  name = &quot;jni_fast_GetDoubleField&quot;;  break;</span>
<span class="line-added">+     default:        ShouldNotReachHere();</span>
<span class="line-added">+       name = NULL;  // unreachable</span>
<span class="line-added">+   }</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE);</span>
<span class="line-added">+   CodeBuffer cbuf(blob);</span>
<span class="line-added">+   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);</span>
<span class="line-added">+   address fast_entry = __ function_entry();</span>
<span class="line-added">+ </span>
<span class="line-added">+   Label slow;</span>
<span class="line-added">+ </span>
<span class="line-added">+   const Register Rcounter_addr = R6_ARG4,</span>
<span class="line-added">+                  Rcounter      = R7_ARG5,</span>
<span class="line-added">+                  Robj          = R8_ARG6,</span>
<span class="line-added">+                  Rtmp          = R9_ARG7;</span>
<span class="line-added">+   const int counter_offs = __ load_const_optimized(Rcounter_addr,</span>
<span class="line-added">+                                                    SafepointSynchronize::safepoint_counter_addr(),</span>
<span class="line-added">+                                                    R0, true);</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ ld(Rcounter, counter_offs, Rcounter_addr);</span>
<span class="line-added">+   __ andi_(R0, Rcounter, 1);</span>
<span class="line-added">+   __ bne(CCR0, slow);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (support_IRIW_for_not_multiple_copy_atomic_cpu) {</span>
<span class="line-added">+     // Field may be volatile.</span>
<span class="line-added">+     __ fence();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // Using acquire to order wrt. JVMTI check and load of result.</span>
<span class="line-added">+     __ isync(); // order wrt. to following load(s)</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (JvmtiExport::can_post_field_access()) {</span>
<span class="line-added">+     // Check to see if a field access watch has been set before we</span>
<span class="line-added">+     // take the fast path.</span>
<span class="line-added">+     int fac_offs = __ load_const_optimized(Rtmp, JvmtiExport::get_field_access_count_addr(),</span>
<span class="line-added">+                                            R0, true);</span>
<span class="line-added">+     __ lwa(Rtmp, fac_offs, Rtmp);</span>
<span class="line-added">+     __ cmpwi(CCR0, Rtmp, 0);</span>
<span class="line-added">+     __ bne(CCR0, slow);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="line-added">+   bs-&gt;try_resolve_jobject_in_native(masm, Robj, R3_ARG1, R4_ARG2, Rtmp, slow);</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ srwi(Rtmp, R5_ARG3, 2); // offset</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(count &lt; LIST_CAPACITY, &quot;LIST_CAPACITY too small&quot;);</span>
<span class="line-added">+   speculative_load_pclist[count] = __ pc();   // Used by the segfault handler</span>
<span class="line-added">+   bool is_fp = false;</span>
<span class="line-added">+   switch (type) {</span>
<span class="line-added">+     case T_BOOLEAN: __ lbzx(Rtmp, Rtmp, Robj); break;</span>
<span class="line-added">+     case T_BYTE:    __ lbzx(Rtmp, Rtmp, Robj); __ extsb(Rtmp, Rtmp); break;</span>
<span class="line-added">+     case T_CHAR:    __ lhzx(Rtmp, Rtmp, Robj); break;</span>
<span class="line-added">+     case T_SHORT:   __ lhax(Rtmp, Rtmp, Robj); break;</span>
<span class="line-added">+     case T_INT:     __ lwax(Rtmp, Rtmp, Robj); break;</span>
<span class="line-added">+     case T_LONG:    __ ldx( Rtmp, Rtmp, Robj); break;</span>
<span class="line-added">+     case T_FLOAT:   __ lfsx(F1_RET, Rtmp, Robj); is_fp = true; break;</span>
<span class="line-added">+     case T_DOUBLE:  __ lfdx(F1_RET, Rtmp, Robj); is_fp = true; break;</span>
<span class="line-added">+     default:        ShouldNotReachHere();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Order preceding load(s) wrt. succeeding check (LoadStore for volatile field).</span>
<span class="line-added">+   if (is_fp) {</span>
<span class="line-added">+     Label next;</span>
<span class="line-added">+     __ fcmpu(CCR0, F1_RET, F1_RET);</span>
<span class="line-added">+     __ bne(CCR0, next);</span>
<span class="line-added">+     __ bind(next);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     __ twi_0(Rtmp);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   __ isync();</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ ld(R0, counter_offs, Rcounter_addr);</span>
<span class="line-added">+   __ cmpd(CCR0, R0, Rcounter);</span>
<span class="line-added">+   __ bne(CCR0, slow);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!is_fp) {</span>
<span class="line-added">+     __ mr(R3_RET, Rtmp);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   __ blr();</span>
<span class="line-added">+ </span>
<span class="line-added">+   slowcase_entry_pclist[count++] = __ pc();</span>
<span class="line-added">+   __ bind(slow);</span>
<span class="line-added">+   address slow_case_addr;</span>
<span class="line-added">+   switch (type) {</span>
<span class="line-added">+     case T_BOOLEAN: slow_case_addr = jni_GetBooleanField_addr(); break;</span>
<span class="line-added">+     case T_BYTE:    slow_case_addr = jni_GetByteField_addr();    break;</span>
<span class="line-added">+     case T_CHAR:    slow_case_addr = jni_GetCharField_addr();    break;</span>
<span class="line-added">+     case T_SHORT:   slow_case_addr = jni_GetShortField_addr();   break;</span>
<span class="line-added">+     case T_INT:     slow_case_addr = jni_GetIntField_addr();     break;</span>
<span class="line-added">+     case T_LONG:    slow_case_addr = jni_GetLongField_addr();    break;</span>
<span class="line-added">+     case T_FLOAT:   slow_case_addr = jni_GetFloatField_addr();   break;</span>
<span class="line-added">+     case T_DOUBLE:  slow_case_addr = jni_GetDoubleField_addr();  break;</span>
<span class="line-added">+     default:        ShouldNotReachHere();</span>
<span class="line-added">+       slow_case_addr = NULL;  // unreachable</span>
<span class="line-added">+   }</span>
<span class="line-added">+   __ load_const_optimized(R12, slow_case_addr, R0);</span>
<span class="line-added">+   __ call_c_and_return_to_caller(R12); // tail call</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ flush();</span>
<span class="line-added">+ </span>
<span class="line-added">+   return fast_entry;</span>
  }
  
  address JNI_FastGetField::generate_fast_get_boolean_field() {
    return generate_fast_get_int_field0(T_BOOLEAN);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 55,21 ***</span>
  address JNI_FastGetField::generate_fast_get_int_field() {
    return generate_fast_get_int_field0(T_INT);
  }
  
  address JNI_FastGetField::generate_fast_get_long_field() {
<span class="line-modified">!   // We don&#39;t have fast jni accessors.</span>
<span class="line-removed">-   return (address) -1;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- address JNI_FastGetField::generate_fast_get_float_field0(BasicType type) {</span>
<span class="line-removed">-   // We don&#39;t have fast jni accessors.</span>
<span class="line-removed">-   return (address) -1;</span>
  }
  
  address JNI_FastGetField::generate_fast_get_float_field() {
<span class="line-modified">!   return generate_fast_get_float_field0(T_FLOAT);</span>
  }
  
  address JNI_FastGetField::generate_fast_get_double_field() {
<span class="line-modified">!   return generate_fast_get_float_field0(T_DOUBLE);</span>
  }
<span class="line-new-header">--- 177,15 ---</span>
  address JNI_FastGetField::generate_fast_get_int_field() {
    return generate_fast_get_int_field0(T_INT);
  }
  
  address JNI_FastGetField::generate_fast_get_long_field() {
<span class="line-modified">!   return generate_fast_get_int_field0(T_LONG);</span>
  }
  
  address JNI_FastGetField::generate_fast_get_float_field() {
<span class="line-modified">!   return generate_fast_get_int_field0(T_FLOAT);</span>
  }
  
  address JNI_FastGetField::generate_fast_get_double_field() {
<span class="line-modified">!   return generate_fast_get_int_field0(T_DOUBLE);</span>
  }
</pre>
<center><a href="interpreterRT_ppc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_ppc.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
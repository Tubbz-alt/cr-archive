<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/ppc/sharedRuntime_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="relocInfo_ppc.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_ppc.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/sharedRuntime_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,8 +1,8 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2019 SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -32,10 +32,11 @@</span>
  #include &quot;gc/shared/gcLocker.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/interp_masm.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/compiledICHolder.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/klass.inline.hpp&quot;</span>
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/vframeArray.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;vmreg_ppc.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -568,19 +569,17 @@</span>
    __ load_const(Rtemp, destination);
    __ mtctr(Rtemp);
    __ bctr();
  }
  
<span class="udiff-line-removed">- #ifdef COMPILER2</span>
  static int reg2slot(VMReg r) {
    return r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
  }
  
  static int reg2offset(VMReg r) {
    return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
  }
<span class="udiff-line-removed">- #endif</span>
  
  // ---------------------------------------------------------------------------
  // Read the array of BasicTypes from a signature, and compute where the
  // arguments should go. Values in the VMRegPair regs array refer to 4-byte
  // quantities. Values less than VMRegImpl::stack0 are registers, those above
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1140,11 +1139,11 @@</span>
        } else {
          r = r_1-&gt;as_Register();
        }
        if (!r_2-&gt;is_valid()) {
          // Not sure we need to do this but it shouldn&#39;t hurt.
<span class="udiff-line-modified-removed">-         if (sig_bt[i] == T_OBJECT || sig_bt[i] == T_ADDRESS || sig_bt[i] == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+         if (is_reference_type(sig_bt[i]) || sig_bt[i] == T_ADDRESS) {</span>
            __ ld(r, ld_offset, ld_ptr);
            ld_offset-=wordSize;
          } else {
            __ lwz(r, ld_offset, ld_ptr);
            ld_offset-=wordSize;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1272,16 +1271,40 @@</span>
    // Branch to ic_miss_stub.
    __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type);
  
    // entry: c2i
  
<span class="udiff-line-modified-removed">-   c2i_entry = gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, call_interpreter, ientry);</span>
<span class="udiff-line-modified-added">+   c2i_entry = __ pc();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Class initialization barrier for static methods</span>
<span class="udiff-line-added">+   address c2i_no_clinit_check_entry = NULL;</span>
<span class="udiff-line-added">+   if (VM_Version::supports_fast_class_init_checks()) {</span>
<span class="udiff-line-added">+     Label L_skip_barrier;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     { // Bypass the barrier for non-static methods</span>
<span class="udiff-line-added">+       __ lwz(R0, in_bytes(Method::access_flags_offset()), R19_method);</span>
<span class="udiff-line-added">+       __ andi_(R0, R0, JVM_ACC_STATIC);</span>
<span class="udiff-line-added">+       __ beq(CCR0, L_skip_barrier); // non-static</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Register klass = R11_scratch1;</span>
<span class="udiff-line-added">+     __ load_method_holder(klass, R19_method);</span>
<span class="udiff-line-added">+     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);</span>
<span class="udiff-line-added">+     __ mtctr(klass);</span>
<span class="udiff-line-added">+     __ bctr();</span>
  
<span class="udiff-line-modified-removed">-   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);</span>
<span class="udiff-line-modified-added">+     __ bind(L_skip_barrier);</span>
<span class="udiff-line-added">+     c2i_no_clinit_check_entry = __ pc();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, call_interpreter, ientry);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>
  }
  
<span class="udiff-line-removed">- #ifdef COMPILER2</span>
  // An oop arg. Must pass a handle not the oop itself.
  static void object_move(MacroAssembler* masm,
                          int frame_size_in_slots,
                          OopMap* oop_map, int oop_handle_offset,
                          bool is_receiver, int* receiver_offset,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1712,19 +1735,18 @@</span>
                              const BasicType* sig_bt,
                              const VMRegPair* regs) {
    Register temp_reg = R19_method;  // not part of any compiled calling seq
    if (VerifyOops) {
      for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
<span class="udiff-line-modified-removed">-       if (sig_bt[i] == T_OBJECT ||</span>
<span class="udiff-line-removed">-           sig_bt[i] == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+       if (is_reference_type(sig_bt[i])) {</span>
          VMReg r = regs[i].first();
          assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
          if (r-&gt;is_stack()) {
            __ ld(temp_reg, reg2offset(r), R1_SP);
<span class="udiff-line-modified-removed">-           __ verify_oop(temp_reg);</span>
<span class="udiff-line-modified-added">+           __ verify_oop(temp_reg, FILE_AND_LINE);</span>
          } else {
<span class="udiff-line-modified-removed">-           __ verify_oop(r-&gt;as_Register());</span>
<span class="udiff-line-modified-added">+           __ verify_oop(r-&gt;as_Register(), FILE_AND_LINE);</span>
          }
        }
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1786,12 +1808,10 @@</span>
    // Figure out which address we are really jumping to:
    MethodHandles::generate_method_handle_dispatch(masm, iid,
                                                   receiver_reg, member_reg, /*for_compiler_entry:*/ true);
  }
  
<span class="udiff-line-removed">- #endif // COMPILER2</span>
<span class="udiff-line-removed">- </span>
  // ---------------------------------------------------------------------------
  // Generate a native wrapper for a given method. The method takes arguments
  // in the Java compiled code convention, marshals them to the native
  // convention (handlizes oops, etc), transitions to native, makes the call,
  // returns to java state (possibly blocking), unhandlizes any result and
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1822,12 +1842,12 @@</span>
  nmethod *SharedRuntime::generate_native_wrapper(MacroAssembler *masm,
                                                  const methodHandle&amp; method,
                                                  int compile_id,
                                                  BasicType *in_sig_bt,
                                                  VMRegPair *in_regs,
<span class="udiff-line-modified-removed">-                                                 BasicType ret_type) {</span>
<span class="udiff-line-modified-removed">- #ifdef COMPILER2</span>
<span class="udiff-line-modified-added">+                                                 BasicType ret_type,</span>
<span class="udiff-line-modified-added">+                                                 address critical_entry) {</span>
    if (method-&gt;is_method_handle_intrinsic()) {
      vmIntrinsics::ID iid = method-&gt;intrinsic_id();
      intptr_t start = (intptr_t)__ pc();
      int vep_offset = ((intptr_t)__ pc()) - start;
      gen_special_dispatch(masm,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1847,11 +1867,11 @@</span>
                                         in_ByteSize(-1),
                                         (OopMapSet*)NULL);
    }
  
    bool is_critical_native = true;
<span class="udiff-line-modified-removed">-   address native_func = method-&gt;critical_native_function();</span>
<span class="udiff-line-modified-added">+   address native_func = critical_entry;</span>
    if (native_func == NULL) {
      native_func = method-&gt;native_function();
      is_critical_native = false;
    }
    assert(native_func != NULL, &quot;must have function&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1906,38 +1926,25 @@</span>
  
      for (int i = 0; i &lt; total_in_args ; i++ ) {
        out_sig_bt[argc++] = in_sig_bt[i];
      }
    } else {
<span class="udiff-line-removed">-     Thread* THREAD = Thread::current();</span>
      in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
      SignatureStream ss(method-&gt;signature());
      int o = 0;
      for (int i = 0; i &lt; total_in_args ; i++, o++) {
        if (in_sig_bt[i] == T_ARRAY) {
          // Arrays are passed as int, elem* pair
<span class="udiff-line-modified-removed">-         Symbol* atype = ss.as_symbol(CHECK_NULL);</span>
<span class="udiff-line-modified-removed">-         const char* at = atype-&gt;as_C_string();</span>
<span class="udiff-line-modified-removed">-         if (strlen(at) == 2) {</span>
<span class="udiff-line-removed">-           assert(at[0] == &#39;[&#39;, &quot;must be&quot;);</span>
<span class="udiff-line-removed">-           switch (at[1]) {</span>
<span class="udiff-line-removed">-             case &#39;B&#39;: in_elem_bt[o] = T_BYTE; break;</span>
<span class="udiff-line-removed">-             case &#39;C&#39;: in_elem_bt[o] = T_CHAR; break;</span>
<span class="udiff-line-removed">-             case &#39;D&#39;: in_elem_bt[o] = T_DOUBLE; break;</span>
<span class="udiff-line-removed">-             case &#39;F&#39;: in_elem_bt[o] = T_FLOAT; break;</span>
<span class="udiff-line-removed">-             case &#39;I&#39;: in_elem_bt[o] = T_INT; break;</span>
<span class="udiff-line-removed">-             case &#39;J&#39;: in_elem_bt[o] = T_LONG; break;</span>
<span class="udiff-line-removed">-             case &#39;S&#39;: in_elem_bt[o] = T_SHORT; break;</span>
<span class="udiff-line-removed">-             case &#39;Z&#39;: in_elem_bt[o] = T_BOOLEAN; break;</span>
<span class="udiff-line-removed">-             default: ShouldNotReachHere();</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         ss.skip_array_prefix(1);  // skip one &#39;[&#39;</span>
<span class="udiff-line-modified-added">+         assert(ss.is_primitive(), &quot;primitive type expected&quot;);</span>
<span class="udiff-line-modified-added">+         in_elem_bt[o] = ss.type();</span>
        } else {
          in_elem_bt[o] = T_VOID;
        }
        if (in_sig_bt[i] != T_VOID) {
<span class="udiff-line-modified-removed">-         assert(in_sig_bt[i] == ss.type(), &quot;must match&quot;);</span>
<span class="udiff-line-modified-added">+         assert(in_sig_bt[i] == ss.type() ||</span>
<span class="udiff-line-added">+                in_sig_bt[i] == T_ARRAY, &quot;must match&quot;);</span>
          ss.next();
        }
      }
  
      for (int i = 0; i &lt; total_in_args ; i++ ) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2081,16 +2088,16 @@</span>
    // --------------------------------------------------------------------------
    assert(start_pc == (intptr_t)__ pc(), &quot;uep must be at start&quot;);
  
    // Check ic: object class == cached class?
    if (!method_is_static) {
<span class="udiff-line-modified-removed">-   Register ic = as_Register(Matcher::inline_cache_reg_encode());</span>
<span class="udiff-line-modified-added">+   Register ic = R19_inline_cache_reg;</span>
    Register receiver_klass = r_temp_1;
  
    __ cmpdi(CCR0, R3_ARG1, 0);
    __ beq(CCR0, ic_miss);
<span class="udiff-line-modified-removed">-   __ verify_oop(R3_ARG1);</span>
<span class="udiff-line-modified-added">+   __ verify_oop(R3_ARG1, FILE_AND_LINE);</span>
    __ load_klass(receiver_klass, R3_ARG1);
  
    __ cmpd(CCR0, receiver_klass, ic);
    __ bne(CCR0, ic_miss);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2105,10 +2112,25 @@</span>
      // because critical section can be large and
      // abort anyway. Also nmethod can be deoptimized.
      __ tabort_();
    }
  
<span class="udiff-line-added">+   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {</span>
<span class="udiff-line-added">+     Label L_skip_barrier;</span>
<span class="udiff-line-added">+     Register klass = r_temp_1;</span>
<span class="udiff-line-added">+     // Notify OOP recorder (don&#39;t need the relocation)</span>
<span class="udiff-line-added">+     AddressLiteral md = __ constant_metadata_address(method-&gt;method_holder());</span>
<span class="udiff-line-added">+     __ load_const_optimized(klass, md.value(), R0);</span>
<span class="udiff-line-added">+     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);</span>
<span class="udiff-line-added">+     __ mtctr(klass);</span>
<span class="udiff-line-added">+     __ bctr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ bind(L_skip_barrier);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    __ save_LR_CR(r_temp_1);
    __ generate_stack_overflow_check(frame_size_in_bytes); // Check before creating frame.
    __ mr(r_callers_sp, R1_SP);                            // Remember frame pointer.
    __ push_frame(frame_size_in_bytes, r_temp_1);          // Push the c2n adapter&#39;s frame.
    frame_done_pc = (intptr_t)__ pc();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2560,11 +2582,11 @@</span>
    __ reset_last_Java_frame();
  
    // Unbox oop result, e.g. JNIHandles::resolve value.
    // --------------------------------------------------------------------------
  
<span class="udiff-line-modified-removed">-   if (ret_type == T_OBJECT || ret_type == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(ret_type)) {</span>
      __ resolve_jobject(R3_RET, r_temp_1, r_temp_2, /* needs_frame */ false);
    }
  
    if (CheckJNICalls) {
      // clear_pending_jni_exception_check
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2596,16 +2618,14 @@</span>
    __ blr();
  
  
    // Handler for pending exceptions (out-of-line).
    // --------------------------------------------------------------------------
<span class="udiff-line-removed">- </span>
    // Since this is a native call, we know the proper exception handler
    // is the empty function. We just pop this frame and then jump to
    // forward_exception_entry.
    if (!is_critical_native) {
<span class="udiff-line-removed">-   __ align(InteriorEntryAlignment);</span>
    __ bind(handle_pending_exception);
  
    __ pop_frame();
    __ restore_LR_CR(R11);
    __ b64_patchable((address)StubRoutines::forward_exception_entry(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2614,11 +2634,10 @@</span>
  
    // Handler for a cache miss (out-of-line).
    // --------------------------------------------------------------------------
  
    if (!method_is_static) {
<span class="udiff-line-removed">-   __ align(InteriorEntryAlignment);</span>
    __ bind(ic_miss);
  
    __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
                         relocInfo::runtime_call_type);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2641,14 +2660,10 @@</span>
    if (is_critical_native) {
      nm-&gt;set_lazy_critical_native(true);
    }
  
    return nm;
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-   ShouldNotReachHere();</span>
<span class="udiff-line-removed">-   return NULL;</span>
<span class="udiff-line-removed">- #endif // COMPILER2</span>
  }
  
  // This function returns the adjust size (in number of words) to a c2i adapter
  // activation for use during deoptimization.
  int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2678,14 +2693,10 @@</span>
  
    __ ld(pc_reg, 0, pcs_reg);
    __ ld(frame_size_reg, 0, frame_sizes_reg);
    __ std(pc_reg, _abi(lr), R1_SP);
    __ push_frame(frame_size_reg, R0/*tmp*/);
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-   __ load_const_optimized(pc_reg, 0x5afe);</span>
<span class="udiff-line-removed">-   __ std(pc_reg, _ijava_state_neg(ijava_reserved), R1_SP);</span>
<span class="udiff-line-removed">- #endif</span>
    __ std(R1_SP, _ijava_state_neg(sender_sp), R1_SP);
    __ addi(number_of_frames_reg, number_of_frames_reg, -1);
    __ addi(frame_sizes_reg, frame_sizes_reg, wordSize);
    __ addi(pcs_reg, pcs_reg, wordSize);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2754,14 +2765,10 @@</span>
    // In the case where we have resized a c2i frame above, the optional
    // alignment below the locals has size 32 (why?).
    __ std(R12_scratch2, _abi(lr), R1_SP);
  
    // Initialize initial_caller_sp.
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-  __ load_const_optimized(pc_reg, 0x5afe);</span>
<span class="udiff-line-removed">-  __ std(pc_reg, _ijava_state_neg(ijava_reserved), R1_SP);</span>
<span class="udiff-line-removed">- #endif</span>
   __ std(frame_size_reg, _ijava_state_neg(sender_sp), R1_SP);
  
  #ifdef ASSERT
    // Make sure that there is at least one entry in the array.
    __ cmpdi(CCR0, number_of_frames_reg, 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2829,11 +2836,11 @@</span>
    // will replace the address of the deopt_handler in the call
    // to Deoptimization::fetch_unroll_info below.
    // We can&#39;t grab a free register here, because all registers may
    // contain live values, so let the RegisterSaver do the adjustment
    // of the return pc.
<span class="udiff-line-modified-removed">-   const int return_pc_adjustment_no_exception = -HandlerImpl::size_deopt_handler();</span>
<span class="udiff-line-modified-added">+   const int return_pc_adjustment_no_exception = -MacroAssembler::bl64_patchable_size;</span>
  
    // Push the &quot;unpack frame&quot;
    // Save everything in sight.
    map = RegisterSaver::push_frame_reg_args_and_save_live_registers(masm,
                                                                     &amp;first_frame_size_in_bytes,
</pre>
<center><a href="relocInfo_ppc.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_ppc.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
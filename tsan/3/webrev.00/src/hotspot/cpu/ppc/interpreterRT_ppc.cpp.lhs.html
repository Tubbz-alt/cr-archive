<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/interpreterRT_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2012, 2013 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/assembler.inline.hpp&quot;
 28 #include &quot;interpreter/interp_masm.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 31 #include &quot;memory/allocation.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 32 #include &quot;memory/universe.hpp&quot;</span>
 33 #include &quot;oops/method.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 #include &quot;runtime/icache.hpp&quot;
 37 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 38 #include &quot;runtime/signature.hpp&quot;
 39 
 40 #define __ _masm-&gt;
 41 
 42 // Access macros for Java and C arguments.
 43 // The first Java argument is at index -1.
 44 #define locals_j_arg_at(index)    (Interpreter::local_offset_in_bytes(index)), R18_locals
 45 // The first C argument is at index 0.
 46 #define sp_c_arg_at(index)        ((index)*wordSize + _abi(carg_1)), R1_SP
 47 
 48 // Implementation of SignatureHandlerGenerator
 49 
 50 InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 51     const methodHandle&amp; method, CodeBuffer* buffer) : NativeSignatureIterator(method) {
 52   _masm = new MacroAssembler(buffer);
 53   _num_used_fp_arg_regs = 0;
 54 }
 55 
 56 void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
 57   Argument jni_arg(jni_offset());
 58   Register r = jni_arg.is_register() ? jni_arg.as_register() : R0;
 59 
 60   __ lwa(r, locals_j_arg_at(offset())); // sign extension of integer
 61   if (DEBUG_ONLY(true ||) !jni_arg.is_register()) {
 62     __ std(r, sp_c_arg_at(jni_arg.number()));
 63   }
 64 }
 65 
 66 void InterpreterRuntime::SignatureHandlerGenerator::pass_long() {
 67   Argument jni_arg(jni_offset());
 68   Register r = jni_arg.is_register() ? jni_arg.as_register() : R0;
 69 
 70   __ ld(r, locals_j_arg_at(offset()+1)); // long resides in upper slot
 71   if (DEBUG_ONLY(true ||) !jni_arg.is_register()) {
 72     __ std(r, sp_c_arg_at(jni_arg.number()));
 73   }
 74 }
 75 
 76 void InterpreterRuntime::SignatureHandlerGenerator::pass_float() {
 77   FloatRegister fp_reg = (_num_used_fp_arg_regs &lt; 13/*max_fp_register_arguments*/)
 78                          ? as_FloatRegister((_num_used_fp_arg_regs++) + F1_ARG1-&gt;encoding())
 79                          : F0;
 80 
 81   __ lfs(fp_reg, locals_j_arg_at(offset()));
 82   if (DEBUG_ONLY(true ||) jni_offset() &gt; 8) {
 83     __ stfs(fp_reg, sp_c_arg_at(jni_offset()));
 84   }
 85 }
 86 
 87 void InterpreterRuntime::SignatureHandlerGenerator::pass_double() {
 88   FloatRegister fp_reg = (_num_used_fp_arg_regs &lt; 13/*max_fp_register_arguments*/)
 89                          ? as_FloatRegister((_num_used_fp_arg_regs++) + F1_ARG1-&gt;encoding())
 90                          : F0;
 91 
 92   __ lfd(fp_reg, locals_j_arg_at(offset()+1));
 93   if (DEBUG_ONLY(true ||) jni_offset() &gt; 8) {
 94     __ stfd(fp_reg, sp_c_arg_at(jni_offset()));
 95   }
 96 }
 97 
 98 void InterpreterRuntime::SignatureHandlerGenerator::pass_object() {
 99   Argument jni_arg(jni_offset());
100   Register r = jni_arg.is_register() ? jni_arg.as_register() : R11_scratch1;
101 
102   // The handle for a receiver will never be null.
103   bool do_NULL_check = offset() != 0 || is_static();
104 
105   Label do_null;
106   if (do_NULL_check) {
107     __ ld(R0, locals_j_arg_at(offset()));
108     __ cmpdi(CCR0, R0, 0);
109     __ li(r, 0);
110     __ beq(CCR0, do_null);
111   }
112   __ addir(r, locals_j_arg_at(offset()));
113   __ bind(do_null);
114   if (DEBUG_ONLY(true ||) !jni_arg.is_register()) {
115     __ std(r, sp_c_arg_at(jni_arg.number()));
116   }
117 }
118 
119 void InterpreterRuntime::SignatureHandlerGenerator::generate(uint64_t fingerprint) {
120 #if !defined(ABI_ELFv2)
121   // Emit fd for current codebuffer. Needs patching!
122   __ emit_fd();
123 #endif
124 
125   // Generate code to handle arguments.
126   iterate(fingerprint);
127 
128   // Return the result handler.
129   __ load_const(R3_RET, AbstractInterpreter::result_handler(method()-&gt;result_type()));
130   __ blr();
131 
132   __ flush();
133 }
134 
135 #undef __
136 
137 // Implementation of SignatureHandlerLibrary
138 
139 void SignatureHandlerLibrary::pd_set_handler(address handler) {
140 #if !defined(ABI_ELFv2)
141   // patch fd here.
142   FunctionDescriptor* fd = (FunctionDescriptor*) handler;
143 
144   fd-&gt;set_entry(handler + (int)sizeof(FunctionDescriptor));
145   assert(fd-&gt;toc() == (address)0xcafe, &quot;need to adjust TOC here&quot;);
146 #endif
147 }
148 
149 
150 // Access function to get the signature.
<a name="3" id="anc3"></a><span class="line-modified">151 IRT_ENTRY(address, InterpreterRuntime::get_signature(JavaThread* thread, Method* method))</span>
152   methodHandle m(thread, method);
153   assert(m-&gt;is_native(), &quot;sanity check&quot;);
154   Symbol *s = m-&gt;signature();
155   return (address) s-&gt;base();
<a name="4" id="anc4"></a><span class="line-modified">156 IRT_END</span>
157 
<a name="5" id="anc5"></a><span class="line-modified">158 IRT_ENTRY(address, InterpreterRuntime::get_result_handler(JavaThread* thread, Method* method))</span>
159   methodHandle m(thread, method);
160   assert(m-&gt;is_native(), &quot;sanity check&quot;);
161   return AbstractInterpreter::result_handler(m-&gt;result_type());
<a name="6" id="anc6"></a><span class="line-modified">162 IRT_END</span>
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
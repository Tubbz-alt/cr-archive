<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/ppc/vm_version_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2012, 2018, SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;jvm.h&quot;
 28 #include &quot;asm/assembler.inline.hpp&quot;
 29 #include &quot;asm/macroAssembler.inline.hpp&quot;
 30 #include &quot;compiler/disassembler.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;runtime/os.hpp&quot;
 34 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 35 #include &quot;utilities/align.hpp&quot;
 36 #include &quot;utilities/defaultStream.hpp&quot;
 37 #include &quot;utilities/globalDefinitions.hpp&quot;
 38 #include &quot;vm_version_ppc.hpp&quot;
 39 
 40 #include &lt;sys/sysinfo.h&gt;
 41 
 42 #if defined(LINUX) &amp;&amp; defined(VM_LITTLE_ENDIAN)
 43 #include &lt;sys/auxv.h&gt;
 44 
 45 #ifndef PPC_FEATURE2_HTM_NOSC
 46 #define PPC_FEATURE2_HTM_NOSC (1 &lt;&lt; 24)
 47 #endif
 48 #endif
 49 
 50 bool VM_Version::_is_determine_features_test_running = false;
 51 uint64_t VM_Version::_dscr_val = 0;
 52 
 53 #define MSG(flag)   \
 54   if (flag &amp;&amp; !FLAG_IS_DEFAULT(flag))                                  \
 55       jio_fprintf(defaultStream::error_stream(),                       \
 56                   &quot;warning: -XX:+&quot; #flag &quot; requires -XX:+UseSIGTRAP\n&quot; \
 57                   &quot;         -XX:+&quot; #flag &quot; will be disabled!\n&quot;);
 58 
 59 void VM_Version::initialize() {
 60 
 61   // Test which instructions are supported and measure cache line size.
 62   determine_features();
 63 
 64   // If PowerArchitecturePPC64 hasn&#39;t been specified explicitly determine from features.
 65   if (FLAG_IS_DEFAULT(PowerArchitecturePPC64)) {
 66     if (VM_Version::has_darn()) {
 67       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 9);
 68     } else if (VM_Version::has_lqarx()) {
 69       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 8);
 70     } else if (VM_Version::has_popcntw()) {
 71       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 7);
 72     } else if (VM_Version::has_cmpb()) {
 73       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 6);
 74     } else if (VM_Version::has_popcntb()) {
 75       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 5);
 76     } else {
 77       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 0);
 78     }
 79   }
 80 
 81   bool PowerArchitecturePPC64_ok = false;
 82   switch (PowerArchitecturePPC64) {
 83     case 9: if (!VM_Version::has_darn()   ) break;
 84     case 8: if (!VM_Version::has_lqarx()  ) break;
 85     case 7: if (!VM_Version::has_popcntw()) break;
 86     case 6: if (!VM_Version::has_cmpb()   ) break;
 87     case 5: if (!VM_Version::has_popcntb()) break;
 88     case 0: PowerArchitecturePPC64_ok = true; break;
 89     default: break;
 90   }
 91   guarantee(PowerArchitecturePPC64_ok, &quot;PowerArchitecturePPC64 cannot be set to &quot;
 92             UINTX_FORMAT &quot; on this machine&quot;, PowerArchitecturePPC64);
 93 
 94   // Power 8: Configure Data Stream Control Register.
 95   if (PowerArchitecturePPC64 &gt;= 8 &amp;&amp; has_mfdscr()) {
 96     config_dscr();
 97   }
 98 
 99   if (!UseSIGTRAP) {
100     MSG(TrapBasedICMissChecks);
101     MSG(TrapBasedNotEntrantChecks);
102     MSG(TrapBasedNullChecks);
103     FLAG_SET_ERGO(bool, TrapBasedNotEntrantChecks, false);
104     FLAG_SET_ERGO(bool, TrapBasedNullChecks,       false);
105     FLAG_SET_ERGO(bool, TrapBasedICMissChecks,     false);
106   }
107 
108 #ifdef COMPILER2
109   if (!UseSIGTRAP) {
110     MSG(TrapBasedRangeChecks);
111     FLAG_SET_ERGO(bool, TrapBasedRangeChecks, false);
112   }
113 
114   // On Power6 test for section size.
115   if (PowerArchitecturePPC64 == 6) {
116     determine_section_size();
117   // TODO: PPC port } else {
118   // TODO: PPC port PdScheduling::power6SectorSize = 0x20;
119   }
120 
121   if (PowerArchitecturePPC64 &gt;= 8) {
122     if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {
123       FLAG_SET_ERGO(bool, SuperwordUseVSX, true);
124     }
125   } else {
126     if (SuperwordUseVSX) {
127       warning(&quot;SuperwordUseVSX specified, but needs at least Power8.&quot;);
128       FLAG_SET_DEFAULT(SuperwordUseVSX, false);
129     }
130   }
131   MaxVectorSize = SuperwordUseVSX ? 16 : 8;
132 
133   if (PowerArchitecturePPC64 &gt;= 9) {
134     if (FLAG_IS_DEFAULT(UseCountTrailingZerosInstructionsPPC64)) {
135       FLAG_SET_ERGO(bool, UseCountTrailingZerosInstructionsPPC64, true);
136     }
137     if (FLAG_IS_DEFAULT(UseCharacterCompareIntrinsics)) {
138       FLAG_SET_ERGO(bool, UseCharacterCompareIntrinsics, true);
139     }
140   } else {
141     if (UseCountTrailingZerosInstructionsPPC64) {
142       warning(&quot;UseCountTrailingZerosInstructionsPPC64 specified, but needs at least Power9.&quot;);
143       FLAG_SET_DEFAULT(UseCountTrailingZerosInstructionsPPC64, false);
144     }
145     if (UseCharacterCompareIntrinsics) {
146       warning(&quot;UseCharacterCompareIntrinsics specified, but needs at least Power9.&quot;);
147       FLAG_SET_DEFAULT(UseCharacterCompareIntrinsics, false);
148     }
149   }
150 #endif
151 
152   // Create and print feature-string.
153   char buf[(num_features+1) * 16]; // Max 16 chars per feature.
154   jio_snprintf(buf, sizeof(buf),
155                &quot;ppc64%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;,
156                (has_fsqrt()   ? &quot; fsqrt&quot;   : &quot;&quot;),
157                (has_isel()    ? &quot; isel&quot;    : &quot;&quot;),
158                (has_lxarxeh() ? &quot; lxarxeh&quot; : &quot;&quot;),
159                (has_cmpb()    ? &quot; cmpb&quot;    : &quot;&quot;),
160                (has_popcntb() ? &quot; popcntb&quot; : &quot;&quot;),
161                (has_popcntw() ? &quot; popcntw&quot; : &quot;&quot;),
162                (has_fcfids()  ? &quot; fcfids&quot;  : &quot;&quot;),
163                (has_vand()    ? &quot; vand&quot;    : &quot;&quot;),
164                (has_lqarx()   ? &quot; lqarx&quot;   : &quot;&quot;),
165                (has_vcipher() ? &quot; aes&quot;     : &quot;&quot;),
166                (has_vpmsumb() ? &quot; vpmsumb&quot; : &quot;&quot;),
167                (has_mfdscr()  ? &quot; mfdscr&quot;  : &quot;&quot;),
168                (has_vsx()     ? &quot; vsx&quot;     : &quot;&quot;),
169                (has_ldbrx()   ? &quot; ldbrx&quot;   : &quot;&quot;),
170                (has_stdbrx()  ? &quot; stdbrx&quot;  : &quot;&quot;),
171                (has_vshasig() ? &quot; sha&quot;     : &quot;&quot;),
172                (has_tm()      ? &quot; rtm&quot;     : &quot;&quot;),
173                (has_darn()    ? &quot; darn&quot;    : &quot;&quot;)
174                // Make sure number of %s matches num_features!
175               );
176   _features_string = os::strdup(buf);
177   if (Verbose) {
178     print_features();
179   }
180 
181   // PPC64 supports 8-byte compare-exchange operations (see Atomic::cmpxchg)
182   // and &#39;atomic long memory ops&#39; (see Unsafe_GetLongVolatile).
183   _supports_cx8 = true;
184 
185   // Used by C1.
186   _supports_atomic_getset4 = true;
187   _supports_atomic_getadd4 = true;
188   _supports_atomic_getset8 = true;
189   _supports_atomic_getadd8 = true;
190 
191   UseSSE = 0; // Only on x86 and x64
192 
193   intx cache_line_size = L1_data_cache_line_size();
194 
195   if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) AllocatePrefetchStyle = 1;
196 
197   if (AllocatePrefetchStyle == 4) {
198     AllocatePrefetchStepSize = cache_line_size; // Need exact value.
199     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 12; // Use larger blocks by default.
200     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 2*cache_line_size; // Default is not defined?
201   } else {
202     if (cache_line_size &gt; AllocatePrefetchStepSize) AllocatePrefetchStepSize = cache_line_size;
203     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 3; // Optimistic value.
204     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 3*cache_line_size; // Default is not defined?
205   }
206 
207   assert(AllocatePrefetchLines &gt; 0, &quot;invalid value&quot;);
208   if (AllocatePrefetchLines &lt; 1) { // Set valid value in product VM.
209     AllocatePrefetchLines = 1; // Conservative value.
210   }
211 
212   if (AllocatePrefetchStyle == 3 &amp;&amp; AllocatePrefetchDistance &lt; cache_line_size) {
213     AllocatePrefetchStyle = 1; // Fall back if inappropriate.
214   }
215 
216   assert(AllocatePrefetchStyle &gt;= 0, &quot;AllocatePrefetchStyle should be positive&quot;);
217 
218   // If running on Power8 or newer hardware, the implementation uses the available vector instructions.
219   // In all other cases, the implementation uses only generally available instructions.
220   if (!UseCRC32Intrinsics) {
221     if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
222       FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);
223     }
224   }
225 
226   // Implementation does not use any of the vector instructions available with Power8.
227   // Their exploitation is still pending (aka &quot;work in progress&quot;).
228   if (!UseCRC32CIntrinsics) {
229     if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
230       FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
231     }
232   }
233 
234   // TODO: Provide implementation.
235   if (UseAdler32Intrinsics) {
236     warning(&quot;Adler32Intrinsics not available on this CPU.&quot;);
237     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
238   }
239 
240   // The AES intrinsic stubs require AES instruction support.
241   if (has_vcipher()) {
242     if (FLAG_IS_DEFAULT(UseAES)) {
243       UseAES = true;
244     }
245   } else if (UseAES) {
246     if (!FLAG_IS_DEFAULT(UseAES))
247       warning(&quot;AES instructions are not available on this CPU&quot;);
248     FLAG_SET_DEFAULT(UseAES, false);
249   }
250 
251   if (UseAES &amp;&amp; has_vcipher()) {
252     if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
253       UseAESIntrinsics = true;
254     }
255   } else if (UseAESIntrinsics) {
256     if (!FLAG_IS_DEFAULT(UseAESIntrinsics))
257       warning(&quot;AES intrinsics are not available on this CPU&quot;);
258     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
259   }
260 
261   if (UseAESCTRIntrinsics) {
262     warning(&quot;AES/CTR intrinsics are not available on this CPU&quot;);
263     FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
264   }
265 
266   if (UseGHASHIntrinsics) {
267     warning(&quot;GHASH intrinsics are not available on this CPU&quot;);
268     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
269   }
270 
271   if (FLAG_IS_DEFAULT(UseFMA)) {
272     FLAG_SET_DEFAULT(UseFMA, true);
273   }
274 
275   if (has_vshasig()) {
276     if (FLAG_IS_DEFAULT(UseSHA)) {
277       UseSHA = true;
278     }
279   } else if (UseSHA) {
280     if (!FLAG_IS_DEFAULT(UseSHA))
281       warning(&quot;SHA instructions are not available on this CPU&quot;);
282     FLAG_SET_DEFAULT(UseSHA, false);
283   }
284 
285   if (UseSHA1Intrinsics) {
286     warning(&quot;Intrinsics for SHA-1 crypto hash functions not available on this CPU.&quot;);
287     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
288   }
289 
290   if (UseSHA &amp;&amp; has_vshasig()) {
291     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
292       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
293     }
294   } else if (UseSHA256Intrinsics) {
295     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
296     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
297   }
298 
299   if (UseSHA &amp;&amp; has_vshasig()) {
300     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
301       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
302     }
303   } else if (UseSHA512Intrinsics) {
304     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
305     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
306   }
307 
308   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
309     FLAG_SET_DEFAULT(UseSHA, false);
310   }
311 
312   if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {
313     UseSquareToLenIntrinsic = true;
314   }
315   if (FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {
316     UseMulAddIntrinsic = true;
317   }
318   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
319     UseMultiplyToLenIntrinsic = true;
320   }
321   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
322     UseMontgomeryMultiplyIntrinsic = true;
323   }
324   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
325     UseMontgomerySquareIntrinsic = true;
326   }
327 
328   if (UseVectorizedMismatchIntrinsic) {
329     warning(&quot;UseVectorizedMismatchIntrinsic specified, but not available on this CPU.&quot;);
330     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
331   }
332 
333 
334   // Adjust RTM (Restricted Transactional Memory) flags.
335   if (UseRTMLocking) {
336     // If CPU or OS do not support TM:
337     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
338     // setting during arguments processing. See use_biased_locking().
339     // VM_Version_init() is executed after UseBiasedLocking is used
340     // in Thread::allocate().
341     if (PowerArchitecturePPC64 &lt; 8) {
342       vm_exit_during_initialization(&quot;RTM instructions are not available on this CPU.&quot;);
343     }
344 
345     if (!has_tm()) {
346       vm_exit_during_initialization(&quot;RTM is not supported on this OS version.&quot;);
347     }
348   }
349 
350   if (UseRTMLocking) {
351 #if INCLUDE_RTM_OPT
352     if (!FLAG_IS_CMDLINE(UseRTMLocking)) {
353       // RTM locking should be used only for applications with
354       // high lock contention. For now we do not use it by default.
355       vm_exit_during_initialization(&quot;UseRTMLocking flag should be only set on command line&quot;);
356     }
357 #else
358     // Only C2 does RTM locking optimization.
359     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
360     // setting during arguments processing. See use_biased_locking().
361     vm_exit_during_initialization(&quot;RTM locking optimization is not supported in this VM&quot;);
362 #endif
363   } else { // !UseRTMLocking
364     if (UseRTMForStackLocks) {
365       if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {
366         warning(&quot;UseRTMForStackLocks flag should be off when UseRTMLocking flag is off&quot;);
367       }
368       FLAG_SET_DEFAULT(UseRTMForStackLocks, false);
369     }
370     if (UseRTMDeopt) {
371       FLAG_SET_DEFAULT(UseRTMDeopt, false);
372     }
373     if (PrintPreciseRTMLockingStatistics) {
374       FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);
375     }
376   }
377 
378   // This machine allows unaligned memory accesses
379   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
380     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
381   }
382 }
383 
384 bool VM_Version::use_biased_locking() {
385 #if INCLUDE_RTM_OPT
386   // RTM locking is most useful when there is high lock contention and
387   // low data contention. With high lock contention the lock is usually
388   // inflated and biased locking is not suitable for that case.
389   // RTM locking code requires that biased locking is off.
390   // Note: we can&#39;t switch off UseBiasedLocking in get_processor_features()
391   // because it is used by Thread::allocate() which is called before
392   // VM_Version::initialize().
393   if (UseRTMLocking &amp;&amp; UseBiasedLocking) {
394     if (FLAG_IS_DEFAULT(UseBiasedLocking)) {
395       FLAG_SET_DEFAULT(UseBiasedLocking, false);
396     } else {
397       warning(&quot;Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.&quot; );
398       UseBiasedLocking = false;
399     }
400   }
401 #endif
402   return UseBiasedLocking;
403 }
404 
405 void VM_Version::print_features() {
406   tty-&gt;print_cr(&quot;Version: %s L1_data_cache_line_size=%d&quot;, features_string(), L1_data_cache_line_size());
407 }
408 
409 #ifdef COMPILER2
410 // Determine section size on power6: If section size is 8 instructions,
411 // there should be a difference between the two testloops of ~15 %. If
412 // no difference is detected the section is assumed to be 32 instructions.
413 void VM_Version::determine_section_size() {
414 
415   int unroll = 80;
416 
417   const int code_size = (2* unroll * 32 + 100)*BytesPerInstWord;
418 
419   // Allocate space for the code.
420   ResourceMark rm;
421   CodeBuffer cb(&quot;detect_section_size&quot;, code_size, 0);
422   MacroAssembler* a = new MacroAssembler(&amp;cb);
423 
424   uint32_t *code = (uint32_t *)a-&gt;pc();
425   // Emit code.
426   void (*test1)() = (void(*)())(void *)a-&gt;function_entry();
427 
428   Label l1;
429 
430   a-&gt;li(R4, 1);
431   a-&gt;sldi(R4, R4, 28);
432   a-&gt;b(l1);
433   a-&gt;align(CodeEntryAlignment);
434 
435   a-&gt;bind(l1);
436 
437   for (int i = 0; i &lt; unroll; i++) {
438     // Schleife 1
439     // ------- sector 0 ------------
440     // ;; 0
441     a-&gt;nop();                   // 1
442     a-&gt;fpnop0();                // 2
443     a-&gt;fpnop1();                // 3
444     a-&gt;addi(R4,R4, -1); // 4
445 
446     // ;;  1
447     a-&gt;nop();                   // 5
448     a-&gt;fmr(F6, F6);             // 6
449     a-&gt;fmr(F7, F7);             // 7
450     a-&gt;endgroup();              // 8
451     // ------- sector 8 ------------
452 
453     // ;;  2
454     a-&gt;nop();                   // 9
455     a-&gt;nop();                   // 10
456     a-&gt;fmr(F8, F8);             // 11
457     a-&gt;fmr(F9, F9);             // 12
458 
459     // ;;  3
460     a-&gt;nop();                   // 13
461     a-&gt;fmr(F10, F10);           // 14
462     a-&gt;fmr(F11, F11);           // 15
463     a-&gt;endgroup();              // 16
464     // -------- sector 16 -------------
465 
466     // ;;  4
467     a-&gt;nop();                   // 17
468     a-&gt;nop();                   // 18
469     a-&gt;fmr(F15, F15);           // 19
470     a-&gt;fmr(F16, F16);           // 20
471 
472     // ;;  5
473     a-&gt;nop();                   // 21
474     a-&gt;fmr(F17, F17);           // 22
475     a-&gt;fmr(F18, F18);           // 23
476     a-&gt;endgroup();              // 24
477     // ------- sector 24  ------------
478 
479     // ;;  6
480     a-&gt;nop();                   // 25
481     a-&gt;nop();                   // 26
482     a-&gt;fmr(F19, F19);           // 27
483     a-&gt;fmr(F20, F20);           // 28
484 
485     // ;;  7
486     a-&gt;nop();                   // 29
487     a-&gt;fmr(F21, F21);           // 30
488     a-&gt;fmr(F22, F22);           // 31
489     a-&gt;brnop0();                // 32
490 
491     // ------- sector 32 ------------
492   }
493 
494   // ;; 8
495   a-&gt;cmpdi(CCR0, R4, unroll);   // 33
496   a-&gt;bge(CCR0, l1);             // 34
497   a-&gt;blr();
498 
499   // Emit code.
500   void (*test2)() = (void(*)())(void *)a-&gt;function_entry();
501   // uint32_t *code = (uint32_t *)a-&gt;pc();
502 
503   Label l2;
504 
505   a-&gt;li(R4, 1);
506   a-&gt;sldi(R4, R4, 28);
507   a-&gt;b(l2);
508   a-&gt;align(CodeEntryAlignment);
509 
510   a-&gt;bind(l2);
511 
512   for (int i = 0; i &lt; unroll; i++) {
513     // Schleife 2
514     // ------- sector 0 ------------
515     // ;; 0
516     a-&gt;brnop0();                  // 1
517     a-&gt;nop();                     // 2
518     //a-&gt;cmpdi(CCR0, R4, unroll);
519     a-&gt;fpnop0();                  // 3
520     a-&gt;fpnop1();                  // 4
521     a-&gt;addi(R4,R4, -1);           // 5
522 
523     // ;; 1
524 
525     a-&gt;nop();                     // 6
526     a-&gt;fmr(F6, F6);               // 7
527     a-&gt;fmr(F7, F7);               // 8
528     // ------- sector 8 ---------------
529 
530     // ;; 2
531     a-&gt;endgroup();                // 9
532 
533     // ;; 3
534     a-&gt;nop();                     // 10
535     a-&gt;nop();                     // 11
536     a-&gt;fmr(F8, F8);               // 12
537 
538     // ;; 4
539     a-&gt;fmr(F9, F9);               // 13
540     a-&gt;nop();                     // 14
541     a-&gt;fmr(F10, F10);             // 15
542 
543     // ;; 5
544     a-&gt;fmr(F11, F11);             // 16
545     // -------- sector 16 -------------
546 
547     // ;; 6
548     a-&gt;endgroup();                // 17
549 
550     // ;; 7
551     a-&gt;nop();                     // 18
552     a-&gt;nop();                     // 19
553     a-&gt;fmr(F15, F15);             // 20
554 
555     // ;; 8
556     a-&gt;fmr(F16, F16);             // 21
557     a-&gt;nop();                     // 22
558     a-&gt;fmr(F17, F17);             // 23
559 
560     // ;; 9
561     a-&gt;fmr(F18, F18);             // 24
562     // -------- sector 24 -------------
563 
564     // ;; 10
565     a-&gt;endgroup();                // 25
566 
567     // ;; 11
568     a-&gt;nop();                     // 26
569     a-&gt;nop();                     // 27
570     a-&gt;fmr(F19, F19);             // 28
571 
572     // ;; 12
573     a-&gt;fmr(F20, F20);             // 29
574     a-&gt;nop();                     // 30
575     a-&gt;fmr(F21, F21);             // 31
576 
577     // ;; 13
578     a-&gt;fmr(F22, F22);             // 32
579   }
580 
581   // -------- sector 32 -------------
582   // ;; 14
583   a-&gt;cmpdi(CCR0, R4, unroll); // 33
584   a-&gt;bge(CCR0, l2);           // 34
585 
586   a-&gt;blr();
587   uint32_t *code_end = (uint32_t *)a-&gt;pc();
588   a-&gt;flush();
589 
590   double loop1_seconds,loop2_seconds, rel_diff;
591   uint64_t start1, stop1;
592 
593   start1 = os::current_thread_cpu_time(false);
594   (*test1)();
595   stop1 = os::current_thread_cpu_time(false);
596   loop1_seconds = (stop1- start1) / (1000 *1000 *1000.0);
597 
598 
599   start1 = os::current_thread_cpu_time(false);
600   (*test2)();
601   stop1 = os::current_thread_cpu_time(false);
602 
603   loop2_seconds = (stop1 - start1) / (1000 *1000 *1000.0);
604 
605   rel_diff = (loop2_seconds - loop1_seconds) / loop1_seconds *100;
606 
607   if (PrintAssembly) {
608     ttyLocker ttyl;
609     tty-&gt;print_cr(&quot;Decoding section size detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
610     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
611     tty-&gt;print_cr(&quot;Time loop1 :%f&quot;, loop1_seconds);
612     tty-&gt;print_cr(&quot;Time loop2 :%f&quot;, loop2_seconds);
613     tty-&gt;print_cr(&quot;(time2 - time1) / time1 = %f %%&quot;, rel_diff);
614 
615     if (rel_diff &gt; 12.0) {
616       tty-&gt;print_cr(&quot;Section Size 8 Instructions&quot;);
617     } else{
618       tty-&gt;print_cr(&quot;Section Size 32 Instructions or Power5&quot;);
619     }
620   }
621 
622 #if 0 // TODO: PPC port
623   // Set sector size (if not set explicitly).
624   if (FLAG_IS_DEFAULT(Power6SectorSize128PPC64)) {
625     if (rel_diff &gt; 12.0) {
626       PdScheduling::power6SectorSize = 0x20;
627     } else {
628       PdScheduling::power6SectorSize = 0x80;
629     }
630   } else if (Power6SectorSize128PPC64) {
631     PdScheduling::power6SectorSize = 0x80;
632   } else {
633     PdScheduling::power6SectorSize = 0x20;
634   }
635 #endif
636   if (UsePower6SchedulerPPC64) Unimplemented();
637 }
638 #endif // COMPILER2
639 
640 void VM_Version::determine_features() {
641 #if defined(ABI_ELFv2)
642   // 1 InstWord per call for the blr instruction.
643   const int code_size = (num_features+1+2*1)*BytesPerInstWord;
644 #else
645   // 7 InstWords for each call (function descriptor + blr instruction).
646   const int code_size = (num_features+1+2*7)*BytesPerInstWord;
647 #endif
648   int features = 0;
649 
650   // create test area
651   enum { BUFFER_SIZE = 2*4*K }; // Needs to be &gt;=2* max cache line size (cache line size can&#39;t exceed min page size).
652   char test_area[BUFFER_SIZE];
653   char *mid_of_test_area = &amp;test_area[BUFFER_SIZE&gt;&gt;1];
654 
655   // Allocate space for the code.
656   ResourceMark rm;
657   CodeBuffer cb(&quot;detect_cpu_features&quot;, code_size, 0);
658   MacroAssembler* a = new MacroAssembler(&amp;cb);
659 
660   // Must be set to true so we can generate the test code.
661   _features = VM_Version::all_features_m;
662 
663   // Emit code.
664   void (*test)(address addr, uint64_t offset)=(void(*)(address addr, uint64_t offset))(void *)a-&gt;function_entry();
665   uint32_t *code = (uint32_t *)a-&gt;pc();
666   // Don&#39;t use R0 in ldarx.
667   // Keep R3_ARG1 unmodified, it contains &amp;field (see below).
668   // Keep R4_ARG2 unmodified, it contains offset = 0 (see below).
669   a-&gt;fsqrt(F3, F4);                            // code[0]  -&gt; fsqrt_m
670   a-&gt;fsqrts(F3, F4);                           // code[1]  -&gt; fsqrts_m
671   a-&gt;isel(R7, R5, R6, 0);                      // code[2]  -&gt; isel_m
672   a-&gt;ldarx_unchecked(R7, R3_ARG1, R4_ARG2, 1); // code[3]  -&gt; lxarx_m
673   a-&gt;cmpb(R7, R5, R6);                         // code[4]  -&gt; cmpb
674   a-&gt;popcntb(R7, R5);                          // code[5]  -&gt; popcntb
675   a-&gt;popcntw(R7, R5);                          // code[6]  -&gt; popcntw
676   a-&gt;fcfids(F3, F4);                           // code[7]  -&gt; fcfids
677   a-&gt;vand(VR0, VR0, VR0);                      // code[8]  -&gt; vand
678   // arg0 of lqarx must be an even register, (arg1 + arg2) must be a multiple of 16
679   a-&gt;lqarx_unchecked(R6, R3_ARG1, R4_ARG2, 1); // code[9]  -&gt; lqarx_m
680   a-&gt;vcipher(VR0, VR1, VR2);                   // code[10] -&gt; vcipher
681   a-&gt;vpmsumb(VR0, VR1, VR2);                   // code[11] -&gt; vpmsumb
682   a-&gt;mfdscr(R0);                               // code[12] -&gt; mfdscr
683   a-&gt;lxvd2x(VSR0, R3_ARG1);                    // code[13] -&gt; vsx
684   a-&gt;ldbrx(R7, R3_ARG1, R4_ARG2);              // code[14] -&gt; ldbrx
685   a-&gt;stdbrx(R7, R3_ARG1, R4_ARG2);             // code[15] -&gt; stdbrx
686   a-&gt;vshasigmaw(VR0, VR1, 1, 0xF);             // code[16] -&gt; vshasig
687   // rtm is determined by OS
688   a-&gt;darn(R7);                                 // code[17] -&gt; darn
689   a-&gt;blr();
690 
691   // Emit function to set one cache line to zero. Emit function descriptor and get pointer to it.
692   void (*zero_cacheline_func_ptr)(char*) = (void(*)(char*))(void *)a-&gt;function_entry();
693   a-&gt;dcbz(R3_ARG1); // R3_ARG1 = addr
694   a-&gt;blr();
695 
696   uint32_t *code_end = (uint32_t *)a-&gt;pc();
697   a-&gt;flush();
698   _features = VM_Version::unknown_m;
699 
700   // Print the detection code.
701   if (PrintAssembly) {
702     ttyLocker ttyl;
703     tty-&gt;print_cr(&quot;Decoding cpu-feature detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
704     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
705   }
706 
707   // Measure cache line size.
708   memset(test_area, 0xFF, BUFFER_SIZE); // Fill test area with 0xFF.
709   (*zero_cacheline_func_ptr)(mid_of_test_area); // Call function which executes dcbz to the middle.
710   int count = 0; // count zeroed bytes
711   for (int i = 0; i &lt; BUFFER_SIZE; i++) if (test_area[i] == 0) count++;
712   guarantee(is_power_of_2(count), &quot;cache line size needs to be a power of 2&quot;);
713   _L1_data_cache_line_size = count;
714 
715   // Execute code. Illegal instructions will be replaced by 0 in the signal handler.
716   VM_Version::_is_determine_features_test_running = true;
717   // We must align the first argument to 16 bytes because of the lqarx check.
718   (*test)(align_up((address)mid_of_test_area, 16), 0);
719   VM_Version::_is_determine_features_test_running = false;
720 
721   // determine which instructions are legal.
722   int feature_cntr = 0;
723   if (code[feature_cntr++]) features |= fsqrt_m;
724   if (code[feature_cntr++]) features |= fsqrts_m;
725   if (code[feature_cntr++]) features |= isel_m;
726   if (code[feature_cntr++]) features |= lxarxeh_m;
727   if (code[feature_cntr++]) features |= cmpb_m;
728   if (code[feature_cntr++]) features |= popcntb_m;
729   if (code[feature_cntr++]) features |= popcntw_m;
730   if (code[feature_cntr++]) features |= fcfids_m;
731   if (code[feature_cntr++]) features |= vand_m;
732   if (code[feature_cntr++]) features |= lqarx_m;
733   if (code[feature_cntr++]) features |= vcipher_m;
734   if (code[feature_cntr++]) features |= vpmsumb_m;
735   if (code[feature_cntr++]) features |= mfdscr_m;
736   if (code[feature_cntr++]) features |= vsx_m;
737   if (code[feature_cntr++]) features |= ldbrx_m;
738   if (code[feature_cntr++]) features |= stdbrx_m;
739   if (code[feature_cntr++]) features |= vshasig_m;
740   // feature rtm_m is determined by OS
741   if (code[feature_cntr++]) features |= darn_m;
742 
743   // Print the detection code.
744   if (PrintAssembly) {
745     ttyLocker ttyl;
746     tty-&gt;print_cr(&quot;Decoding cpu-feature detection stub at &quot; INTPTR_FORMAT &quot; after execution:&quot;, p2i(code));
747     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
748   }
749 
750   _features = features;
751 
752 #ifdef AIX
753   // To enable it on AIX it&#39;s necessary POWER8 or above and at least AIX 7.2.
754   // Actually, this is supported since AIX 7.1.. Unfortunately, this first
755   // contained bugs, so that it can only be enabled after AIX 7.1.3.30.
756   // The Java property os.version, which is used in RTM tests to decide
757   // whether the feature is available, only knows major and minor versions.
758   // We don&#39;t want to change this property, as user code might depend on it.
759   // So the tests can not check on subversion 3.30, and we only enable RTM
760   // with AIX 7.2.
761   if (has_lqarx()) { // POWER8 or above
762     if (os::Aix::os_version() &gt;= 0x07020000) { // At least AIX 7.2.
763       _features |= rtm_m;
764     }
765   }
766 #endif
767 #if defined(LINUX) &amp;&amp; defined(VM_LITTLE_ENDIAN)
768   unsigned long auxv = getauxval(AT_HWCAP2);
769 
770   if (auxv &amp; PPC_FEATURE2_HTM_NOSC) {
771     if (auxv &amp; PPC_FEATURE2_HAS_HTM) {
772       // TM on POWER8 and POWER9 in compat mode (VM) is supported by the JVM.
773       // TM on POWER9 DD2.1 NV (baremetal) is not supported by the JVM (TM on
774       // POWER9 DD2.1 NV has a few issues that need a couple of firmware
775       // and kernel workarounds, so there is a new mode only supported
776       // on non-virtualized P9 machines called HTM with no Suspend Mode).
777       // TM on POWER9 D2.2+ NV is not supported at all by Linux.
778       _features |= rtm_m;
779     }
780   }
781 #endif
782 }
783 
784 // Power 8: Configure Data Stream Control Register.
785 void VM_Version::config_dscr() {
786   // 7 InstWords for each call (function descriptor + blr instruction).
787   const int code_size = (2+2*7)*BytesPerInstWord;
788 
789   // Allocate space for the code.
790   ResourceMark rm;
791   CodeBuffer cb(&quot;config_dscr&quot;, code_size, 0);
792   MacroAssembler* a = new MacroAssembler(&amp;cb);
793 
794   // Emit code.
795   uint64_t (*get_dscr)() = (uint64_t(*)())(void *)a-&gt;function_entry();
796   uint32_t *code = (uint32_t *)a-&gt;pc();
797   a-&gt;mfdscr(R3);
798   a-&gt;blr();
799 
800   void (*set_dscr)(long) = (void(*)(long))(void *)a-&gt;function_entry();
801   a-&gt;mtdscr(R3);
802   a-&gt;blr();
803 
804   uint32_t *code_end = (uint32_t *)a-&gt;pc();
805   a-&gt;flush();
806 
807   // Print the detection code.
808   if (PrintAssembly) {
809     ttyLocker ttyl;
810     tty-&gt;print_cr(&quot;Decoding dscr configuration stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
811     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
812   }
813 
814   // Apply the configuration if needed.
815   _dscr_val = (*get_dscr)();
816   if (Verbose) {
817     tty-&gt;print_cr(&quot;dscr value was 0x%lx&quot; , _dscr_val);
818   }
819   bool change_requested = false;
820   if (DSCR_PPC64 != (uintx)-1) {
821     _dscr_val = DSCR_PPC64;
822     change_requested = true;
823   }
824   if (DSCR_DPFD_PPC64 &lt;= 7) {
825     uint64_t mask = 0x7;
826     if ((_dscr_val &amp; mask) != DSCR_DPFD_PPC64) {
827       _dscr_val = (_dscr_val &amp; ~mask) | (DSCR_DPFD_PPC64);
828       change_requested = true;
829     }
830   }
831   if (DSCR_URG_PPC64 &lt;= 7) {
832     uint64_t mask = 0x7 &lt;&lt; 6;
833     if ((_dscr_val &amp; mask) != DSCR_DPFD_PPC64 &lt;&lt; 6) {
834       _dscr_val = (_dscr_val &amp; ~mask) | (DSCR_URG_PPC64 &lt;&lt; 6);
835       change_requested = true;
836     }
837   }
838   if (change_requested) {
839     (*set_dscr)(_dscr_val);
840     if (Verbose) {
841       tty-&gt;print_cr(&quot;dscr was set to 0x%lx&quot; , (*get_dscr)());
842     }
843   }
844 }
845 
846 static uint64_t saved_features = 0;
847 
848 void VM_Version::allow_all() {
849   saved_features = _features;
850   _features      = all_features_m;
851 }
852 
853 void VM_Version::revert() {
854   _features = saved_features;
855 }
    </pre>
  </body>
</html>
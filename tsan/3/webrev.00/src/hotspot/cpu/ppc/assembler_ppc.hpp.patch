diff a/src/hotspot/cpu/ppc/assembler_ppc.hpp b/src/hotspot/cpu/ppc/assembler_ppc.hpp
--- a/src/hotspot/cpu/ppc/assembler_ppc.hpp
+++ b/src/hotspot/cpu/ppc/assembler_ppc.hpp
@@ -442,10 +442,13 @@
     FADDS_OPCODE  = (59u << OPCODE_SHIFT |  21u << 1),
     FCMPU_OPCODE  = (63u << OPCODE_SHIFT |  00u << 1),
     FDIV_OPCODE   = (63u << OPCODE_SHIFT |  18u << 1),
     FDIVS_OPCODE  = (59u << OPCODE_SHIFT |  18u << 1),
     FMR_OPCODE    = (63u << OPCODE_SHIFT |  72u << 1),
+    FRIN_OPCODE   = (63u << OPCODE_SHIFT | 392u << 1),
+    FRIP_OPCODE   = (63u << OPCODE_SHIFT | 456u << 1),
+    FRIM_OPCODE   = (63u << OPCODE_SHIFT | 488u << 1),
     // These are special Power6 opcodes, reused for "lfdepx" and "stfdepx"
     // on Power7.  Do not use.
     // MFFGPR_OPCODE  = (31u << OPCODE_SHIFT | 607u << 1),
     // MFTGPR_OPCODE  = (31u << OPCODE_SHIFT | 735u << 1),
     CMPB_OPCODE    = (31u << OPCODE_SHIFT |  508  << 1),
@@ -543,10 +546,13 @@
     XVMADDADP_OPCODE=(60u << OPCODE_SHIFT |   97u << 3),
     XVMSUBASP_OPCODE=(60u << OPCODE_SHIFT |   81u << 3),
     XVMSUBADP_OPCODE=(60u << OPCODE_SHIFT |  113u << 3),
     XVNMSUBASP_OPCODE=(60u<< OPCODE_SHIFT |  209u << 3),
     XVNMSUBADP_OPCODE=(60u<< OPCODE_SHIFT |  241u << 3),
+    XVRDPI_OPCODE  = (60u << OPCODE_SHIFT |  201u << 2),
+    XVRDPIM_OPCODE = (60u << OPCODE_SHIFT |  249u << 2),
+    XVRDPIP_OPCODE = (60u << OPCODE_SHIFT |  233u << 2),
 
     // Deliver A Random Number (introduced with POWER9)
     DARN_OPCODE    = (31u << OPCODE_SHIFT |  755u << 1),
 
     // Vector Permute and Formatting
@@ -927,15 +933,17 @@
  public:
   // Helper functions for groups of instructions
 
   enum Predict { pt = 1, pn = 0 }; // pt = predict taken
 
-  // Instruction must start at passed address.
-  static int instr_len(unsigned char *instr) { return BytesPerInstWord; }
+  //---<  calculate length of instruction  >---
+  // With PPC64 being a RISC architecture, this always is BytesPerInstWord
+  // instruction must start at passed address
+  static unsigned int instr_len(unsigned char *instr) { return BytesPerInstWord; }
 
-  // longest instructions
-  static int instr_maxlen() { return BytesPerInstWord; }
+  //---<  longest instructions  >---
+  static unsigned int instr_maxlen() { return BytesPerInstWord; }
 
   // Test if x is within signed immediate range for nbits.
   static bool is_simm(int x, unsigned int nbits) {
     assert(0 < nbits && nbits < 32, "out of bounds");
     const int   min      = -(((int)1) << nbits-1);
@@ -1977,10 +1985,14 @@
 
   // PPC 1, section 4.6.4 Floating-Point Move Instructions
   inline void fmr(  FloatRegister d, FloatRegister b);
   inline void fmr_( FloatRegister d, FloatRegister b);
 
+  inline void frin( FloatRegister d, FloatRegister b);
+  inline void frip( FloatRegister d, FloatRegister b);
+  inline void frim( FloatRegister d, FloatRegister b);
+
   //  inline void mffgpr( FloatRegister d, Register b);
   //  inline void mftgpr( Register d, FloatRegister b);
   inline void cmpb(   Register a, Register s, Register b);
   inline void popcntb(Register a, Register s);
   inline void popcntw(Register a, Register s);
@@ -2237,10 +2249,13 @@
   inline void xvmaddadp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
   inline void xvmsubasp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
   inline void xvmsubadp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
   inline void xvnmsubasp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
   inline void xvnmsubadp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
+  inline void xvrdpi(   VectorSRegister d, VectorSRegister b);
+  inline void xvrdpim(  VectorSRegister d, VectorSRegister b);
+  inline void xvrdpip(  VectorSRegister d, VectorSRegister b);
 
   // VSX Extended Mnemonics
   inline void xxspltd(  VectorSRegister d, VectorSRegister a, int x);
   inline void xxmrghd(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
   inline void xxmrgld(  VectorSRegister d, VectorSRegister a, VectorSRegister b);

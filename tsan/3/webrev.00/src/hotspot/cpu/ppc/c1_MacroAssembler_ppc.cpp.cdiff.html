<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/ppc/c1_MacroAssembler_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRGenerator_ppc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Runtime1_ppc.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/c1_MacroAssembler_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,24 ***</span>
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;oops/arrayOop.hpp&quot;
<span class="line-modified">! #include &quot;oops/markOop.hpp&quot;</span>
  #include &quot;runtime/basicLock.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
<span class="line-modified">! </span>
  
  void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
    const Register temp_reg = R12_scratch2;
    Label Lmiss;
  
<span class="line-modified">!   verify_oop(receiver);</span>
    MacroAssembler::null_check(receiver, oopDesc::klass_offset_in_bytes(), &amp;Lmiss);
    load_klass(temp_reg, receiver);
  
    if (TrapBasedICMissChecks &amp;&amp; TrapBasedNullChecks) {
      trap_ic_miss_check(temp_reg, iCache);
<span class="line-new-header">--- 29,24 ---</span>
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;oops/arrayOop.hpp&quot;
<span class="line-modified">! #include &quot;oops/markWord.hpp&quot;</span>
  #include &quot;runtime/basicLock.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
<span class="line-modified">! #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
    const Register temp_reg = R12_scratch2;
    Label Lmiss;
  
<span class="line-modified">!   verify_oop(receiver, FILE_AND_LINE);</span>
    MacroAssembler::null_check(receiver, oopDesc::klass_offset_in_bytes(), &amp;Lmiss);
    load_klass(temp_reg, receiver);
  
    if (TrapBasedICMissChecks &amp;&amp; TrapBasedNullChecks) {
      trap_ic_miss_check(temp_reg, iCache);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,26 ***</span>
    // The following move must be the first instruction of emitted since debug
    // information may be generated for it.
    // Load object header.
    ld(Rmark, oopDesc::mark_offset_in_bytes(), Roop);
  
<span class="line-modified">!   verify_oop(Roop);</span>
  
    // Save object being locked into the BasicObjectLock...
    std(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);
  
    if (UseBiasedLocking) {
      biased_locking_enter(CCR0, Roop, Rmark, Rscratch, R0, done, &amp;slow_int);
    }
  
    // ... and mark it unlocked.
<span class="line-modified">!   ori(Rmark, Rmark, markOopDesc::unlocked_value);</span>
  
    // Save unlocked object header into the displaced header location on the stack.
    std(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);
  
<span class="line-modified">!   // Compare object markOop with Rmark and if equal exchange Rscratch with object markOop.</span>
    assert(oopDesc::mark_offset_in_bytes() == 0, &quot;cas must take a zero displacement&quot;);
    cmpxchgd(/*flag=*/CCR0,
             /*current_value=*/Rscratch,
             /*compare_value=*/Rmark,
             /*exchange_value=*/Rbox,
<span class="line-new-header">--- 98,26 ---</span>
    // The following move must be the first instruction of emitted since debug
    // information may be generated for it.
    // Load object header.
    ld(Rmark, oopDesc::mark_offset_in_bytes(), Roop);
  
<span class="line-modified">!   verify_oop(Roop, FILE_AND_LINE);</span>
  
    // Save object being locked into the BasicObjectLock...
    std(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);
  
    if (UseBiasedLocking) {
      biased_locking_enter(CCR0, Roop, Rmark, Rscratch, R0, done, &amp;slow_int);
    }
  
    // ... and mark it unlocked.
<span class="line-modified">!   ori(Rmark, Rmark, markWord::unlocked_value);</span>
  
    // Save unlocked object header into the displaced header location on the stack.
    std(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);
  
<span class="line-modified">!   // Compare object markWord with Rmark and if equal exchange Rscratch with object markWord.</span>
    assert(oopDesc::mark_offset_in_bytes() == 0, &quot;cas must take a zero displacement&quot;);
    cmpxchgd(/*flag=*/CCR0,
             /*current_value=*/Rscratch,
             /*compare_value=*/Rmark,
             /*exchange_value=*/Rbox,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,11 ***</span>
    b(slow_case); // far
  
    bind(cas_failed);
    // We did not find an unlocked object so see if this is a recursive case.
    sub(Rscratch, Rscratch, R1_SP);
<span class="line-modified">!   load_const_optimized(R0, (~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place));</span>
    and_(R0/*==0?*/, Rscratch, R0);
    std(R0/*==0, perhaps*/, BasicLock::displaced_header_offset_in_bytes(), Rbox);
    bne(CCR0, slow_int);
  
    bind(done);
<span class="line-new-header">--- 135,11 ---</span>
    b(slow_case); // far
  
    bind(cas_failed);
    // We did not find an unlocked object so see if this is a recursive case.
    sub(Rscratch, Rscratch, R1_SP);
<span class="line-modified">!   load_const_optimized(R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));</span>
    and_(R0/*==0?*/, Rscratch, R0);
    std(R0/*==0, perhaps*/, BasicLock::displaced_header_offset_in_bytes(), Rbox);
    bne(CCR0, slow_int);
  
    bind(done);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,25 ***</span>
    assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
  
    if (UseBiasedLocking) {
      // Load the object out of the BasicObjectLock.
      ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);
<span class="line-modified">!     verify_oop(Roop);</span>
      biased_locking_exit(CCR0, Roop, R0, done);
    }
    // Test first it it is a fast recursive unlock.
    ld(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);
    cmpdi(CCR0, Rmark, 0);
    beq(CCR0, done);
    if (!UseBiasedLocking) {
      // Load object.
      ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);
<span class="line-modified">!     verify_oop(Roop);</span>
    }
  
    // Check if it is still a light weight lock, this is is true if we see
<span class="line-modified">!   // the stack address of the basicLock in the markOop of the object.</span>
    cmpxchgd(/*flag=*/CCR0,
             /*current_value=*/R0,
             /*compare_value=*/Rbox,
             /*exchange_value=*/Rmark,
             /*where=*/Roop,
<span class="line-new-header">--- 155,25 ---</span>
    assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
  
    if (UseBiasedLocking) {
      // Load the object out of the BasicObjectLock.
      ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);
<span class="line-modified">!     verify_oop(Roop, FILE_AND_LINE);</span>
      biased_locking_exit(CCR0, Roop, R0, done);
    }
    // Test first it it is a fast recursive unlock.
    ld(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);
    cmpdi(CCR0, Rmark, 0);
    beq(CCR0, done);
    if (!UseBiasedLocking) {
      // Load object.
      ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);
<span class="line-modified">!     verify_oop(Roop, FILE_AND_LINE);</span>
    }
  
    // Check if it is still a light weight lock, this is is true if we see
<span class="line-modified">!   // the stack address of the basicLock in the markWord of the object.</span>
    cmpxchgd(/*flag=*/CCR0,
             /*current_value=*/R0,
             /*compare_value=*/Rbox,
             /*exchange_value=*/Rmark,
             /*where=*/Roop,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 213,11 ***</span>
  void C1_MacroAssembler::initialize_header(Register obj, Register klass, Register len, Register t1, Register t2) {
    assert_different_registers(obj, klass, len, t1, t2);
    if (UseBiasedLocking &amp;&amp; !len-&gt;is_valid()) {
      ld(t1, in_bytes(Klass::prototype_header_offset()), klass);
    } else {
<span class="line-modified">!     load_const_optimized(t1, (intx)markOopDesc::prototype());</span>
    }
    std(t1, oopDesc::mark_offset_in_bytes(), obj);
    store_klass(obj, klass);
    if (len-&gt;is_valid()) {
      stw(len, arrayOopDesc::length_offset_in_bytes(), obj);
<span class="line-new-header">--- 213,11 ---</span>
  void C1_MacroAssembler::initialize_header(Register obj, Register klass, Register len, Register t1, Register t2) {
    assert_different_registers(obj, klass, len, t1, t2);
    if (UseBiasedLocking &amp;&amp; !len-&gt;is_valid()) {
      ld(t1, in_bytes(Klass::prototype_header_offset()), klass);
    } else {
<span class="line-modified">!     load_const_optimized(t1, (intx)markWord::prototype().value());</span>
    }
    std(t1, oopDesc::mark_offset_in_bytes(), obj);
    store_klass(obj, klass);
    if (len-&gt;is_valid()) {
      stw(len, arrayOopDesc::length_offset_in_bytes(), obj);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,11 ***</span>
  //    assert(obj == O0, &quot;must be&quot;);
  //    call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)),
  //         relocInfo::runtime_call_type);
    }
  
<span class="line-modified">!   verify_oop(obj);</span>
  }
  
  
  void C1_MacroAssembler::allocate_array(
    Register obj,                        // result: pointer to array after successful allocation
<span class="line-new-header">--- 314,11 ---</span>
  //    assert(obj == O0, &quot;must be&quot;);
  //    call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)),
  //         relocInfo::runtime_call_type);
    }
  
<span class="line-modified">!   verify_oop(obj, FILE_AND_LINE);</span>
  }
  
  
  void C1_MacroAssembler::allocate_array(
    Register obj,                        // result: pointer to array after successful allocation
</pre>
<hr />
<pre>
<span class="line-old-header">*** 381,11 ***</span>
      //assert(obj == O0, &quot;must be&quot;);
      //call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)),
      //     relocInfo::runtime_call_type);
    }
  
<span class="line-modified">!   verify_oop(obj);</span>
  }
  
  
  #ifndef PRODUCT
  
<span class="line-new-header">--- 381,11 ---</span>
      //assert(obj == O0, &quot;must be&quot;);
      //call(CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)),
      //     relocInfo::runtime_call_type);
    }
  
<span class="line-modified">!   verify_oop(obj, FILE_AND_LINE);</span>
  }
  
  
  #ifndef PRODUCT
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 397,12 ***</span>
    Label not_null;
    cmpdi(CCR0, r, 0);
    bne(CCR0, not_null);
    stop(&quot;non-null oop required&quot;);
    bind(not_null);
<span class="line-modified">!   if (!VerifyOops) return;</span>
<span class="line-removed">-   verify_oop(r);</span>
  }
  
  #endif // PRODUCT
  
  void C1_MacroAssembler::null_check(Register r, Label* Lnull) {
<span class="line-new-header">--- 397,11 ---</span>
    Label not_null;
    cmpdi(CCR0, r, 0);
    bne(CCR0, not_null);
    stop(&quot;non-null oop required&quot;);
    bind(not_null);
<span class="line-modified">!   verify_oop(r, FILE_AND_LINE);</span>
  }
  
  #endif // PRODUCT
  
  void C1_MacroAssembler::null_check(Register r, Label* Lnull) {
</pre>
<center><a href="c1_LIRGenerator_ppc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Runtime1_ppc.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/frame_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2012, 2017 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 29 #include &quot;oops/markOop.hpp&quot;</span>

 30 #include &quot;oops/method.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/frame.inline.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/javaCalls.hpp&quot;
 35 #include &quot;runtime/jniHandles.inline.hpp&quot;
 36 #include &quot;runtime/monitorChunk.hpp&quot;
 37 #include &quot;runtime/os.inline.hpp&quot;
 38 #include &quot;runtime/signature.hpp&quot;
 39 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 40 #include &quot;runtime/stubRoutines.hpp&quot;
 41 #ifdef COMPILER1
 42 #include &quot;c1/c1_Runtime1.hpp&quot;
 43 #include &quot;runtime/vframeArray.hpp&quot;
 44 #endif
 45 
 46 #ifdef ASSERT
 47 void RegisterMap::check_location_valid() {
 48 }
 49 #endif // ASSERT
 50 
 51 bool frame::safe_for_sender(JavaThread *thread) {
 52   bool safe = false;
 53   address sp = (address)_sp;
 54   address fp = (address)_fp;
 55   address unextended_sp = (address)_unextended_sp;
 56 
<a name="3" id="anc3"></a><span class="line-modified"> 57   // Consider stack guards when trying to determine &quot;safe&quot; stack pointers</span>
<span class="line-removed"> 58   static size_t stack_guard_size = os::uses_stack_guard_pages() ?</span>
<span class="line-removed"> 59     JavaThread::stack_red_zone_size() + JavaThread::stack_yellow_reserved_zone_size() : 0;</span>
<span class="line-removed"> 60   size_t usable_stack_size = thread-&gt;stack_size() - stack_guard_size;</span>
<span class="line-removed"> 61 </span>
 62   // sp must be within the usable part of the stack (not in guards)
<a name="4" id="anc4"></a><span class="line-modified"> 63   bool sp_safe = (sp &lt; thread-&gt;stack_base()) &amp;&amp;</span>
<span class="line-removed"> 64                  (sp &gt;= thread-&gt;stack_base() - usable_stack_size);</span>
<span class="line-removed"> 65 </span>
<span class="line-removed"> 66 </span>
<span class="line-removed"> 67   if (!sp_safe) {</span>
 68     return false;
 69   }
 70 
 71   // Unextended sp must be within the stack
 72   bool unextended_sp_safe = (unextended_sp &lt; thread-&gt;stack_base());
 73 
 74   if (!unextended_sp_safe) {
 75     return false;
 76   }
 77 
 78   // An fp must be within the stack and above (but not equal) sp.
<a name="5" id="anc5"></a><span class="line-modified"> 79   bool fp_safe = (fp &lt;= thread-&gt;stack_base()) &amp;&amp;  (fp &gt; sp);</span>
 80   // An interpreter fp must be within the stack and above (but not equal) sp.
 81   // Moreover, it must be at least the size of the ijava_state structure.
<a name="6" id="anc6"></a><span class="line-modified"> 82   bool fp_interp_safe = (fp &lt;= thread-&gt;stack_base()) &amp;&amp; (fp &gt; sp) &amp;&amp;</span>
 83     ((fp - sp) &gt;= ijava_state_size);
 84 
 85   // We know sp/unextended_sp are safe, only fp is questionable here
 86 
 87   // If the current frame is known to the code cache then we can attempt to
 88   // to construct the sender and do some validation of it. This goes a long way
 89   // toward eliminating issues when we get in frame construction code
 90 
 91   if (_cb != NULL ){
 92     // Entry frame checks
 93     if (is_entry_frame()) {
 94       // An entry frame must have a valid fp.
 95       return fp_safe &amp;&amp; is_entry_frame_valid(thread);
 96     }
 97 
 98     // Now check if the frame is complete and the test is
 99     // reliable. Unfortunately we can only check frame completeness for
100     // runtime stubs and nmethods. Other generic buffer blobs are more
101     // problematic so we just assume they are OK. Adapter blobs never have a
102     // complete frame and are never OK
103     if (!_cb-&gt;is_frame_complete_at(_pc)) {
104       if (_cb-&gt;is_compiled() || _cb-&gt;is_adapter_blob() || _cb-&gt;is_runtime_stub()) {
105         return false;
106       }
107     }
108 
109     // Could just be some random pointer within the codeBlob.
110     if (!_cb-&gt;code_contains(_pc)) {
111       return false;
112     }
113 
114     if (is_interpreted_frame() &amp;&amp; !fp_interp_safe) {
115       return false;
116     }
117 
118     abi_minframe* sender_abi = (abi_minframe*) fp;
119     intptr_t* sender_sp = (intptr_t*) fp;
120     address   sender_pc = (address) sender_abi-&gt;lr;;
121 
122     // We must always be able to find a recognizable pc.
123     CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);
124     if (sender_blob == NULL) {
125       return false;
126     }
127 
128     // Could be a zombie method
129     if (sender_blob-&gt;is_zombie() || sender_blob-&gt;is_unloaded()) {
130       return false;
131     }
132 
133     // It should be safe to construct the sender though it might not be valid.
134 
135     frame sender(sender_sp, sender_pc);
136 
137     // Do we have a valid fp?
138     address sender_fp = (address) sender.fp();
139 
140     // sender_fp must be within the stack and above (but not
141     // equal) current frame&#39;s fp.
<a name="7" id="anc7"></a><span class="line-modified">142     if (sender_fp &gt; thread-&gt;stack_base() || sender_fp &lt;= fp) {</span>
143         return false;
144     }
145 
146     // If the potential sender is the interpreter then we can do some more checking.
147     if (Interpreter::contains(sender_pc)) {
148       return sender.is_interpreted_frame_valid(thread);
149     }
150 
151     // Could just be some random pointer within the codeBlob.
152     if (!sender.cb()-&gt;code_contains(sender_pc)) {
153       return false;
154     }
155 
156     // We should never be able to see an adapter if the current frame is something from code cache.
157     if (sender_blob-&gt;is_adapter_blob()) {
158       return false;
159     }
160 
161     if (sender.is_entry_frame()) {
162       return sender.is_entry_frame_valid(thread);
163     }
164 
165     // Frame size is always greater than zero. If the sender frame size is zero or less,
166     // something is really weird and we better give up.
167     if (sender_blob-&gt;frame_size() &lt;= 0) {
168       return false;
169     }
170 
171     return true;
172   }
173 
174   // Must be native-compiled frame. Since sender will try and use fp to find
175   // linkages it must be safe
176 
177   if (!fp_safe) {
178     return false;
179   }
180 
181   return true;
182 }
183 
184 bool frame::is_interpreted_frame() const  {
185   return Interpreter::contains(pc());
186 }
187 
188 frame frame::sender_for_entry_frame(RegisterMap *map) const {
189   assert(map != NULL, &quot;map must be set&quot;);
190   // Java frame called from C; skip all C frames and return top C
191   // frame of that chunk as the sender.
192   JavaFrameAnchor* jfa = entry_frame_call_wrapper()-&gt;anchor();
193   assert(!entry_frame_is_first(), &quot;next Java fp must be non zero&quot;);
194   assert(jfa-&gt;last_Java_sp() &gt; _sp, &quot;must be above this frame on stack&quot;);
195   map-&gt;clear();
196   assert(map-&gt;include_argument_oops(), &quot;should be set by clear&quot;);
197 
198   if (jfa-&gt;last_Java_pc() != NULL) {
199     frame fr(jfa-&gt;last_Java_sp(), jfa-&gt;last_Java_pc());
200     return fr;
201   }
202   // Last_java_pc is not set, if we come here from compiled code. The
203   // constructor retrieves the PC from the stack.
204   frame fr(jfa-&gt;last_Java_sp());
205   return fr;
206 }
207 
208 frame frame::sender_for_interpreter_frame(RegisterMap *map) const {
209   // Pass callers initial_caller_sp as unextended_sp.
210   return frame(sender_sp(), sender_pc(), (intptr_t*)get_ijava_state()-&gt;sender_sp);
211 }
212 
213 frame frame::sender_for_compiled_frame(RegisterMap *map) const {
214   assert(map != NULL, &quot;map must be set&quot;);
215 
216   // Frame owned by compiler.
217   address pc = *compiled_sender_pc_addr(_cb);
218   frame caller(compiled_sender_sp(_cb), pc);
219 
220   // Now adjust the map.
221 
222   // Get the rest.
223   if (map-&gt;update_map()) {
224     // Tell GC to use argument oopmaps for some runtime stubs that need it.
225     map-&gt;set_include_argument_oops(_cb-&gt;caller_must_gc_arguments(map-&gt;thread()));
226     if (_cb-&gt;oop_maps() != NULL) {
227       OopMapSet::update_register_map(this, map);
228     }
229   }
230 
231   return caller;
232 }
233 
234 intptr_t* frame::compiled_sender_sp(CodeBlob* cb) const {
235   return sender_sp();
236 }
237 
238 address* frame::compiled_sender_pc_addr(CodeBlob* cb) const {
239   return sender_pc_addr();
240 }
241 
242 frame frame::sender(RegisterMap* map) const {
243   // Default is we do have to follow them. The sender_for_xxx will
244   // update it accordingly.
245   map-&gt;set_include_argument_oops(false);
246 
247   if (is_entry_frame())       return sender_for_entry_frame(map);
248   if (is_interpreted_frame()) return sender_for_interpreter_frame(map);
249   assert(_cb == CodeCache::find_blob(pc()),&quot;Must be the same&quot;);
250 
251   if (_cb != NULL) {
252     return sender_for_compiled_frame(map);
253   }
254   // Must be native-compiled frame, i.e. the marshaling code for native
255   // methods that exists in the core system.
256   return frame(sender_sp(), sender_pc());
257 }
258 
259 void frame::patch_pc(Thread* thread, address pc) {
260   if (TracePcPatching) {
261     tty-&gt;print_cr(&quot;patch_pc at address &quot; PTR_FORMAT &quot; [&quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT &quot;]&quot;,
262                   p2i(&amp;((address*) _sp)[-1]), p2i(((address*) _sp)[-1]), p2i(pc));
263   }
264   own_abi()-&gt;lr = (uint64_t)pc;
265   _cb = CodeCache::find_blob(pc);
266   if (_cb != NULL &amp;&amp; _cb-&gt;is_nmethod() &amp;&amp; ((nmethod*)_cb)-&gt;is_deopt_pc(_pc)) {
267     address orig = (((nmethod*)_cb)-&gt;get_original_pc(this));
268     assert(orig == _pc, &quot;expected original to be stored before patching&quot;);
269     _deopt_state = is_deoptimized;
270     // Leave _pc as is.
271   } else {
272     _deopt_state = not_deoptimized;
273     _pc = pc;
274   }
275 }
276 
277 bool frame::is_interpreted_frame_valid(JavaThread* thread) const {
278   // Is there anything to do?
279   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
280   return true;
281 }
282 
283 BasicType frame::interpreter_frame_result(oop* oop_result, jvalue* value_result) {
284   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
285   Method* method = interpreter_frame_method();
286   BasicType type = method-&gt;result_type();
287 
288   if (method-&gt;is_native()) {
289     // Prior to calling into the runtime to notify the method exit the possible
290     // result value is saved into the interpreter frame.
291     address lresult = (address)&amp;(get_ijava_state()-&gt;lresult);
292     address fresult = (address)&amp;(get_ijava_state()-&gt;fresult);
293 
294     switch (method-&gt;result_type()) {
295       case T_OBJECT:
296       case T_ARRAY: {
297         *oop_result = JNIHandles::resolve(*(jobject*)lresult);
298         break;
299       }
300       // We use std/stfd to store the values.
301       case T_BOOLEAN : value_result-&gt;z = (jboolean) *(unsigned long*)lresult; break;
302       case T_INT     : value_result-&gt;i = (jint)     *(long*)lresult;          break;
303       case T_CHAR    : value_result-&gt;c = (jchar)    *(unsigned long*)lresult; break;
304       case T_SHORT   : value_result-&gt;s = (jshort)   *(long*)lresult;          break;
305       case T_BYTE    : value_result-&gt;z = (jbyte)    *(long*)lresult;          break;
306       case T_LONG    : value_result-&gt;j = (jlong)    *(long*)lresult;          break;
307       case T_FLOAT   : value_result-&gt;f = (jfloat)   *(double*)fresult;        break;
308       case T_DOUBLE  : value_result-&gt;d = (jdouble)  *(double*)fresult;        break;
309       case T_VOID    : /* Nothing to do */ break;
310       default        : ShouldNotReachHere();
311     }
312   } else {
313     intptr_t* tos_addr = interpreter_frame_tos_address();
314     switch (method-&gt;result_type()) {
315       case T_OBJECT:
316       case T_ARRAY: {
317         oop obj = *(oop*)tos_addr;
318         assert(obj == NULL || Universe::heap()-&gt;is_in(obj), &quot;sanity check&quot;);
319         *oop_result = obj;
320       }
321       case T_BOOLEAN : value_result-&gt;z = (jboolean) *(jint*)tos_addr; break;
322       case T_BYTE    : value_result-&gt;b = (jbyte) *(jint*)tos_addr; break;
323       case T_CHAR    : value_result-&gt;c = (jchar) *(jint*)tos_addr; break;
324       case T_SHORT   : value_result-&gt;s = (jshort) *(jint*)tos_addr; break;
325       case T_INT     : value_result-&gt;i = *(jint*)tos_addr; break;
326       case T_LONG    : value_result-&gt;j = *(jlong*)tos_addr; break;
327       case T_FLOAT   : value_result-&gt;f = *(jfloat*)tos_addr; break;
328       case T_DOUBLE  : value_result-&gt;d = *(jdouble*)tos_addr; break;
329       case T_VOID    : /* Nothing to do */ break;
330       default        : ShouldNotReachHere();
331     }
332   }
333   return type;
334 }
335 
336 #ifndef PRODUCT
337 
338 void frame::describe_pd(FrameValues&amp; values, int frame_no) {
339   if (is_interpreted_frame()) {
340 #define DESCRIBE_ADDRESS(name) \
341   values.describe(frame_no, (intptr_t*)&amp;(get_ijava_state()-&gt;name), #name);
342 
343       DESCRIBE_ADDRESS(method);
344       DESCRIBE_ADDRESS(mirror);
345       DESCRIBE_ADDRESS(locals);
346       DESCRIBE_ADDRESS(monitors);
347       DESCRIBE_ADDRESS(cpoolCache);
348       DESCRIBE_ADDRESS(bcp);
349       DESCRIBE_ADDRESS(esp);
350       DESCRIBE_ADDRESS(mdx);
351       DESCRIBE_ADDRESS(top_frame_sp);
352       DESCRIBE_ADDRESS(sender_sp);
353       DESCRIBE_ADDRESS(oop_tmp);
354       DESCRIBE_ADDRESS(lresult);
355       DESCRIBE_ADDRESS(fresult);
356   }
357 }
358 #endif
359 
360 intptr_t *frame::initial_deoptimization_info() {
361   // unused... but returns fp() to minimize changes introduced by 7087445
362   return fp();
363 }
364 
365 #ifndef PRODUCT
366 // This is a generic constructor which is only used by pns() in debug.cpp.
367 frame::frame(void* sp, void* fp, void* pc) : _sp((intptr_t*)sp), _unextended_sp((intptr_t*)sp) {
368   find_codeblob_and_set_pc_and_deopt_state((address)pc); // also sets _fp and adjusts _unextended_sp
369 }
370 
371 void frame::pd_ps() {}
372 #endif
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/ppc/assembler_ppc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_PPC_ASSEMBLER_PPC_HPP
  27 #define CPU_PPC_ASSEMBLER_PPC_HPP
  28 
  29 #include &quot;asm/register.hpp&quot;
  30 
  31 // Address is an abstraction used to represent a memory location
  32 // as used in assembler instructions.
  33 // PPC instructions grok either baseReg + indexReg or baseReg + disp.
  34 class Address {
  35  private:
  36   Register _base;         // Base register.
  37   Register _index;        // Index register.
  38   intptr_t _disp;         // Displacement.
  39 
  40  public:
  41   Address(Register b, Register i, address d = 0)
  42     : _base(b), _index(i), _disp((intptr_t)d) {
  43     assert(i == noreg || d == 0, &quot;can&#39;t have both&quot;);
  44   }
  45 
  46   Address(Register b, address d = 0)
  47     : _base(b), _index(noreg), _disp((intptr_t)d) {}
  48 
  49   Address(Register b, intptr_t d)
  50     : _base(b), _index(noreg), _disp(d) {}
  51 
  52   Address(Register b, RegisterOrConstant roc)
  53     : _base(b), _index(noreg), _disp(0) {
  54     if (roc.is_constant()) _disp = roc.as_constant(); else _index = roc.as_register();
  55   }
  56 
  57   Address()
  58     : _base(noreg), _index(noreg), _disp(0) {}
  59 
  60   // accessors
  61   Register base()  const { return _base; }
  62   Register index() const { return _index; }
  63   int      disp()  const { return (int)_disp; }
  64   bool     is_const() const { return _base == noreg &amp;&amp; _index == noreg; }
  65 };
  66 
  67 class AddressLiteral {
  68  private:
  69   address          _address;
  70   RelocationHolder _rspec;
  71 
  72   RelocationHolder rspec_from_rtype(relocInfo::relocType rtype, address addr) {
  73     switch (rtype) {
  74     case relocInfo::external_word_type:
  75       return external_word_Relocation::spec(addr);
  76     case relocInfo::internal_word_type:
  77       return internal_word_Relocation::spec(addr);
  78     case relocInfo::opt_virtual_call_type:
  79       return opt_virtual_call_Relocation::spec();
  80     case relocInfo::static_call_type:
  81       return static_call_Relocation::spec();
  82     case relocInfo::runtime_call_type:
  83       return runtime_call_Relocation::spec();
  84     case relocInfo::none:
  85       return RelocationHolder();
  86     default:
  87       ShouldNotReachHere();
  88       return RelocationHolder();
  89     }
  90   }
  91 
  92  protected:
  93   // creation
  94   AddressLiteral() : _address(NULL), _rspec(NULL) {}
  95 
  96  public:
  97   AddressLiteral(address addr, RelocationHolder const&amp; rspec)
  98     : _address(addr),
  99       _rspec(rspec) {}
 100 
 101   AddressLiteral(address addr, relocInfo::relocType rtype = relocInfo::none)
 102     : _address((address) addr),
 103       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 104 
 105   AddressLiteral(oop* addr, relocInfo::relocType rtype = relocInfo::none)
 106     : _address((address) addr),
 107       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 108 
 109   intptr_t value() const { return (intptr_t) _address; }
 110 
 111   const RelocationHolder&amp; rspec() const { return _rspec; }
 112 };
 113 
 114 // Argument is an abstraction used to represent an outgoing
 115 // actual argument or an incoming formal parameter, whether
 116 // it resides in memory or in a register, in a manner consistent
 117 // with the PPC Application Binary Interface, or ABI. This is
 118 // often referred to as the native or C calling convention.
 119 
 120 class Argument {
 121  private:
 122   int _number;  // The number of the argument.
 123  public:
 124   enum {
 125     // Only 8 registers may contain integer parameters.
 126     n_register_parameters = 8,
 127     // Can have up to 8 floating registers.
 128     n_float_register_parameters = 8,
 129 
 130     // PPC C calling conventions.
 131     // The first eight arguments are passed in int regs if they are int.
 132     n_int_register_parameters_c = 8,
 133     // The first thirteen float arguments are passed in float regs.
 134     n_float_register_parameters_c = 13,
 135     // Only the first 8 parameters are not placed on the stack. Aix disassembly
 136     // shows that xlC places all float args after argument 8 on the stack AND
 137     // in a register. This is not documented, but we follow this convention, too.
 138     n_regs_not_on_stack_c = 8,
 139   };
 140   // creation
 141   Argument(int number) : _number(number) {}
 142 
 143   int  number() const { return _number; }
 144 
 145   // Locating register-based arguments:
 146   bool is_register() const { return _number &lt; n_register_parameters; }
 147 
 148   Register as_register() const {
 149     assert(is_register(), &quot;must be a register argument&quot;);
 150     return as_Register(number() + R3_ARG1-&gt;encoding());
 151   }
 152 };
 153 
 154 #if !defined(ABI_ELFv2)
 155 // A ppc64 function descriptor.
 156 struct FunctionDescriptor {
 157  private:
 158   address _entry;
 159   address _toc;
 160   address _env;
 161 
 162  public:
 163   inline address entry() const { return _entry; }
 164   inline address toc()   const { return _toc; }
 165   inline address env()   const { return _env; }
 166 
 167   inline void set_entry(address entry) { _entry = entry; }
 168   inline void set_toc(  address toc)   { _toc   = toc; }
 169   inline void set_env(  address env)   { _env   = env; }
 170 
 171   inline static ByteSize entry_offset() { return byte_offset_of(FunctionDescriptor, _entry); }
 172   inline static ByteSize toc_offset()   { return byte_offset_of(FunctionDescriptor, _toc); }
 173   inline static ByteSize env_offset()   { return byte_offset_of(FunctionDescriptor, _env); }
 174 
 175   // Friend functions can be called without loading toc and env.
 176   enum {
 177     friend_toc = 0xcafe,
 178     friend_env = 0xc0de
 179   };
 180 
 181   inline bool is_friend_function() const {
 182     return (toc() == (address) friend_toc) &amp;&amp; (env() == (address) friend_env);
 183   }
 184 
 185   // Constructor for stack-allocated instances.
 186   FunctionDescriptor() {
 187     _entry = (address) 0xbad;
 188     _toc   = (address) 0xbad;
 189     _env   = (address) 0xbad;
 190   }
 191 };
 192 #endif
 193 
 194 
 195 // The PPC Assembler: Pure assembler doing NO optimizations on the
 196 // instruction level; i.e., what you write is what you get. The
 197 // Assembler is generating code into a CodeBuffer.
 198 
 199 class Assembler : public AbstractAssembler {
 200  protected:
 201   // Displacement routines
 202   static int  patched_branch(int dest_pos, int inst, int inst_pos);
 203   static int  branch_destination(int inst, int pos);
 204 
 205   friend class AbstractAssembler;
 206 
 207   // Code patchers need various routines like inv_wdisp()
 208   friend class NativeInstruction;
 209   friend class NativeGeneralJump;
 210   friend class Relocation;
 211 
 212  public:
 213 
 214   enum shifts {
 215     XO_21_29_SHIFT = 2,
 216     XO_21_30_SHIFT = 1,
 217     XO_27_29_SHIFT = 2,
 218     XO_30_31_SHIFT = 0,
 219     SPR_5_9_SHIFT  = 11u, // SPR_5_9 field in bits 11 -- 15
 220     SPR_0_4_SHIFT  = 16u, // SPR_0_4 field in bits 16 -- 20
 221     RS_SHIFT       = 21u, // RS field in bits 21 -- 25
 222     OPCODE_SHIFT   = 26u, // opcode in bits 26 -- 31
 223   };
 224 
 225   enum opcdxos_masks {
 226     XL_FORM_OPCODE_MASK = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 227     ADDI_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 228     ADDIS_OPCODE_MASK   = (63u &lt;&lt; OPCODE_SHIFT),
 229     BXX_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 230     BCXX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 231     // trap instructions
 232     TDI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 233     TWI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 234     TD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 235     TW_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 236     LD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (3u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 237     STD_OPCODE_MASK     = LD_OPCODE_MASK,
 238     STDU_OPCODE_MASK    = STD_OPCODE_MASK,
 239     STDX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 240     STDUX_OPCODE_MASK   = STDX_OPCODE_MASK,
 241     STW_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 242     STWU_OPCODE_MASK    = STW_OPCODE_MASK,
 243     STWX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 244     STWUX_OPCODE_MASK   = STWX_OPCODE_MASK,
 245     MTCTR_OPCODE_MASK   = ~(31u &lt;&lt; RS_SHIFT),
 246     ORI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 247     ORIS_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 248     RLDICR_OPCODE_MASK  = (63u &lt;&lt; OPCODE_SHIFT) | (7u &lt;&lt; XO_27_29_SHIFT)
 249   };
 250 
 251   enum opcdxos {
 252     ADD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 266u &lt;&lt; 1),
 253     ADDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  10u &lt;&lt; 1),
 254     ADDI_OPCODE   = (14u &lt;&lt; OPCODE_SHIFT),
 255     ADDIS_OPCODE  = (15u &lt;&lt; OPCODE_SHIFT),
 256     ADDIC__OPCODE = (13u &lt;&lt; OPCODE_SHIFT),
 257     ADDE_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 138u &lt;&lt; 1),
 258     ADDME_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 234u &lt;&lt; 1),
 259     ADDZE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 202u &lt;&lt; 1),
 260     SUBF_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  40u &lt;&lt; 1),
 261     SUBFC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   8u &lt;&lt; 1),
 262     SUBFE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 136u &lt;&lt; 1),
 263     SUBFIC_OPCODE = (8u  &lt;&lt; OPCODE_SHIFT),
 264     SUBFME_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 232u &lt;&lt; 1),
 265     SUBFZE_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 200u &lt;&lt; 1),
 266     DIVW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 491u &lt;&lt; 1),
 267     MULLW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 235u &lt;&lt; 1),
 268     MULHW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  75u &lt;&lt; 1),
 269     MULHWU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  11u &lt;&lt; 1),
 270     MULLI_OPCODE  = (7u  &lt;&lt; OPCODE_SHIFT),
 271     AND_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  28u &lt;&lt; 1),
 272     ANDI_OPCODE   = (28u &lt;&lt; OPCODE_SHIFT),
 273     ANDIS_OPCODE  = (29u &lt;&lt; OPCODE_SHIFT),
 274     ANDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  60u &lt;&lt; 1),
 275     ORC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 412u &lt;&lt; 1),
 276     OR_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT | 444u &lt;&lt; 1),
 277     ORI_OPCODE    = (24u &lt;&lt; OPCODE_SHIFT),
 278     ORIS_OPCODE   = (25u &lt;&lt; OPCODE_SHIFT),
 279     XOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 316u &lt;&lt; 1),
 280     XORI_OPCODE   = (26u &lt;&lt; OPCODE_SHIFT),
 281     XORIS_OPCODE  = (27u &lt;&lt; OPCODE_SHIFT),
 282 
 283     NEG_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 104u &lt;&lt; 1),
 284 
 285     RLWINM_OPCODE = (21u &lt;&lt; OPCODE_SHIFT),
 286     CLRRWI_OPCODE = RLWINM_OPCODE,
 287     CLRLWI_OPCODE = RLWINM_OPCODE,
 288 
 289     RLWIMI_OPCODE = (20u &lt;&lt; OPCODE_SHIFT),
 290 
 291     SLW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  24u &lt;&lt; 1),
 292     SLWI_OPCODE   = RLWINM_OPCODE,
 293     SRW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 536u &lt;&lt; 1),
 294     SRWI_OPCODE   = RLWINM_OPCODE,
 295     SRAW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 792u &lt;&lt; 1),
 296     SRAWI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 824u &lt;&lt; 1),
 297 
 298     CMP_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; 1),
 299     CMPI_OPCODE   = (11u &lt;&lt; OPCODE_SHIFT),
 300     CMPL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  32u &lt;&lt; 1),
 301     CMPLI_OPCODE  = (10u &lt;&lt; OPCODE_SHIFT),
 302     CMPRB_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 192u &lt;&lt; 1),
 303     CMPEQB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 224u &lt;&lt; 1),
 304 
 305     ISEL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  15u &lt;&lt; 1),
 306 
 307     // Special purpose registers
 308     MTSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 467u &lt;&lt; 1),
 309     MFSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 339u &lt;&lt; 1),
 310 
 311     MTXER_OPCODE  = (MTSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 312     MFXER_OPCODE  = (MFSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 313 
 314     MTDSCR_OPCODE = (MTSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 315     MFDSCR_OPCODE = (MFSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 316 
 317     MTLR_OPCODE   = (MTSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 318     MFLR_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 319 
 320     MTCTR_OPCODE  = (MTSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 321     MFCTR_OPCODE  = (MFSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 322 
 323     // Attention: Higher and lower half are inserted in reversed order.
 324     MTTFHAR_OPCODE   = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 325     MFTFHAR_OPCODE   = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 326     MTTFIAR_OPCODE   = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 1 &lt;&lt; SPR_0_4_SHIFT),
 327     MFTFIAR_OPCODE   = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 1 &lt;&lt; SPR_0_4_SHIFT),
 328     MTTEXASR_OPCODE  = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 2 &lt;&lt; SPR_0_4_SHIFT),
 329     MFTEXASR_OPCODE  = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 2 &lt;&lt; SPR_0_4_SHIFT),
 330     MTTEXASRU_OPCODE = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 3 &lt;&lt; SPR_0_4_SHIFT),
 331     MFTEXASRU_OPCODE = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 3 &lt;&lt; SPR_0_4_SHIFT),
 332 
 333     MTVRSAVE_OPCODE  = (MTSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 334     MFVRSAVE_OPCODE  = (MFSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 335 
 336     MFTB_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 12 &lt;&lt; SPR_0_4_SHIFT),
 337 
 338     MTCRF_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 144u &lt;&lt; 1),
 339     MFCR_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 19u &lt;&lt; 1),
 340     MCRF_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 0u &lt;&lt; 1),
 341     SETB_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 128u &lt;&lt; 1),
 342 
 343     // condition register logic instructions
 344     CRAND_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 257u &lt;&lt; 1),
 345     CRNAND_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 225u &lt;&lt; 1),
 346     CROR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 449u &lt;&lt; 1),
 347     CRXOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 193u &lt;&lt; 1),
 348     CRNOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT |  33u &lt;&lt; 1),
 349     CREQV_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 289u &lt;&lt; 1),
 350     CRANDC_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 129u &lt;&lt; 1),
 351     CRORC_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 417u &lt;&lt; 1),
 352 
 353     BCLR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 16u &lt;&lt; 1),
 354     BXX_OPCODE      = (18u &lt;&lt; OPCODE_SHIFT),
 355     BCXX_OPCODE     = (16u &lt;&lt; OPCODE_SHIFT),
 356 
 357     // CTR-related opcodes
 358     BCCTR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 528u &lt;&lt; 1),
 359 
 360     LWZ_OPCODE   = (32u &lt;&lt; OPCODE_SHIFT),
 361     LWZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  23u &lt;&lt; 1),
 362     LWZU_OPCODE  = (33u &lt;&lt; OPCODE_SHIFT),
 363     LWBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  534 &lt;&lt; 1),
 364 
 365     LHA_OPCODE   = (42u &lt;&lt; OPCODE_SHIFT),
 366     LHAX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 343u &lt;&lt; 1),
 367     LHAU_OPCODE  = (43u &lt;&lt; OPCODE_SHIFT),
 368 
 369     LHZ_OPCODE   = (40u &lt;&lt; OPCODE_SHIFT),
 370     LHZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 279u &lt;&lt; 1),
 371     LHZU_OPCODE  = (41u &lt;&lt; OPCODE_SHIFT),
 372     LHBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  790 &lt;&lt; 1),
 373 
 374     LBZ_OPCODE   = (34u &lt;&lt; OPCODE_SHIFT),
 375     LBZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  87u &lt;&lt; 1),
 376     LBZU_OPCODE  = (35u &lt;&lt; OPCODE_SHIFT),
 377 
 378     STW_OPCODE   = (36u &lt;&lt; OPCODE_SHIFT),
 379     STWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 151u &lt;&lt; 1),
 380     STWU_OPCODE  = (37u &lt;&lt; OPCODE_SHIFT),
 381     STWUX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 183u &lt;&lt; 1),
 382     STWBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 662u &lt;&lt; 1),
 383 
 384     STH_OPCODE   = (44u &lt;&lt; OPCODE_SHIFT),
 385     STHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 407u &lt;&lt; 1),
 386     STHU_OPCODE  = (45u &lt;&lt; OPCODE_SHIFT),
 387     STHBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 918u &lt;&lt; 1),
 388 
 389     STB_OPCODE   = (38u &lt;&lt; OPCODE_SHIFT),
 390     STBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 215u &lt;&lt; 1),
 391     STBU_OPCODE  = (39u &lt;&lt; OPCODE_SHIFT),
 392 
 393     EXTSB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 954u &lt;&lt; 1),
 394     EXTSH_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 922u &lt;&lt; 1),
 395     EXTSW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 986u &lt;&lt; 1),               // X-FORM
 396 
 397     // 32 bit opcode encodings
 398 
 399     LWA_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 400     LWAX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 341u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 401 
 402     CNTLZW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  26u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 403     CNTTZW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 538u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 404 
 405     // 64 bit opcode encodings
 406 
 407     LD_OPCODE     = (58u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 408     LDU_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 409     LDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 410     LDBRX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 532u &lt;&lt; 1),              // X-FORM
 411 
 412     STD_OPCODE    = (62u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 413     STDU_OPCODE   = (62u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 414     STDUX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 181u &lt;&lt; 1),              // X-FORM
 415     STDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 149u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 416     STDBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 660u &lt;&lt; 1),              // X-FORM
 417 
 418     RLDICR_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 419     RLDICL_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 420     RLDIC_OPCODE  = (30u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 421     RLDIMI_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   3u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 422 
 423     SRADI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 413u &lt;&lt; XO_21_29_SHIFT), // XS-FORM
 424 
 425     SLD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  27u &lt;&lt; 1),              // X-FORM
 426     SRD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 539u &lt;&lt; 1),              // X-FORM
 427     SRAD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 794u &lt;&lt; 1),              // X-FORM
 428 
 429     MULLD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 233u &lt;&lt; 1),              // XO-FORM
 430     MULHD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  73u &lt;&lt; 1),              // XO-FORM
 431     MULHDU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |   9u &lt;&lt; 1),              // XO-FORM
 432     DIVD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 489u &lt;&lt; 1),              // XO-FORM
 433 
 434     CNTLZD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  58u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 435     CNTTZD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 570u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 436     NAND_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 476u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 437     NOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 124u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 438 
 439 
 440     // opcodes only used for floating arithmetic
 441     FADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 442     FADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 443     FCMPU_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  00u &lt;&lt; 1),
 444     FDIV_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 445     FDIVS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 446     FMR_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  72u &lt;&lt; 1),
 447     // These are special Power6 opcodes, reused for &quot;lfdepx&quot; and &quot;stfdepx&quot;
 448     // on Power7.  Do not use.
 449     // MFFGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 607u &lt;&lt; 1),
 450     // MFTGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 735u &lt;&lt; 1),
 451     CMPB_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  508  &lt;&lt; 1),
 452     POPCNTB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  122  &lt;&lt; 1),
 453     POPCNTW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  378  &lt;&lt; 1),
 454     POPCNTD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  506  &lt;&lt; 1),
 455     FABS_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  264u &lt;&lt; 1),
 456     FNABS_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  136u &lt;&lt; 1),
 457     FMUL_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 458     FMULS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 459     FNEG_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   40u &lt;&lt; 1),
 460     FSUB_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 461     FSUBS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 462 
 463     // PPC64-internal FPU conversion opcodes
 464     FCFID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 465     FCFIDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 466     FCTID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 467     FCTIDZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  815u &lt;&lt; 1),
 468     FCTIW_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   14u &lt;&lt; 1),
 469     FCTIWZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   15u &lt;&lt; 1),
 470     FRSP_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   12u &lt;&lt; 1),
 471 
 472     // Fused multiply-accumulate instructions.
 473     FMADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 474     FMADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 475     FMSUB_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 476     FMSUBS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 477     FNMADD_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 478     FNMADDS_OPCODE = (59u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 479     FNMSUB_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 480     FNMSUBS_OPCODE = (59u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 481 
 482     LFD_OPCODE     = (50u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 483     LFDU_OPCODE    = (51u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 484     LFDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  599u &lt;&lt; 1),
 485     LFS_OPCODE     = (48u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 486     LFSU_OPCODE    = (49u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 487     LFSX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  535u &lt;&lt; 1),
 488 
 489     STFD_OPCODE    = (54u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 490     STFDU_OPCODE   = (55u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 491     STFDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  727u &lt;&lt; 1),
 492     STFS_OPCODE    = (52u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 493     STFSU_OPCODE   = (53u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 494     STFSX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  663u &lt;&lt; 1),
 495 
 496     FSQRT_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 497     FSQRTS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 498 
 499     // Vector instruction support for &gt;= Power6
 500     // Vector Storage Access
 501     LVEBX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |    7u &lt;&lt; 1),
 502     LVEHX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   39u &lt;&lt; 1),
 503     LVEWX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   71u &lt;&lt; 1),
 504     LVX_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT |  103u &lt;&lt; 1),
 505     LVXL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  359u &lt;&lt; 1),
 506     STVEBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  135u &lt;&lt; 1),
 507     STVEHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  167u &lt;&lt; 1),
 508     STVEWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  199u &lt;&lt; 1),
 509     STVX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  231u &lt;&lt; 1),
 510     STVXL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  487u &lt;&lt; 1),
 511     LVSL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |    6u &lt;&lt; 1),
 512     LVSR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   38u &lt;&lt; 1),
 513 
 514     // Vector-Scalar (VSX) instruction support.
 515     LXVD2X_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  844u &lt;&lt; 1),
 516     STXVD2X_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  972u &lt;&lt; 1),
 517     MTVSRD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  179u &lt;&lt; 1),
 518     MTVSRWZ_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  243u &lt;&lt; 1),
 519     MFVSRD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   51u &lt;&lt; 1),
 520     MTVSRWA_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  211u &lt;&lt; 1),
 521     MFVSRWZ_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  115u &lt;&lt; 1),
 522     XXPERMDI_OPCODE= (60u &lt;&lt; OPCODE_SHIFT |   10u &lt;&lt; 3),
 523     XXMRGHW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   18u &lt;&lt; 3),
 524     XXMRGLW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   50u &lt;&lt; 3),
 525     XXSPLTW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  164u &lt;&lt; 2),
 526     XXLOR_OPCODE   = (60u &lt;&lt; OPCODE_SHIFT |  146u &lt;&lt; 3),
 527     XXLXOR_OPCODE  = (60u &lt;&lt; OPCODE_SHIFT |  154u &lt;&lt; 3),
 528     XXLEQV_OPCODE  = (60u &lt;&lt; OPCODE_SHIFT |  186u &lt;&lt; 3),
 529     XVDIVSP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   88u &lt;&lt; 3),
 530     XVDIVDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  120u &lt;&lt; 3),
 531     XVABSSP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  409u &lt;&lt; 2),
 532     XVABSDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  473u &lt;&lt; 2),
 533     XVNEGSP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  441u &lt;&lt; 2),
 534     XVNEGDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  505u &lt;&lt; 2),
 535     XVSQRTSP_OPCODE= (60u &lt;&lt; OPCODE_SHIFT |  139u &lt;&lt; 2),
 536     XVSQRTDP_OPCODE= (60u &lt;&lt; OPCODE_SHIFT |  203u &lt;&lt; 2),
 537     XSCVDPSPN_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |  267u &lt;&lt; 2),
 538     XVADDDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   96u &lt;&lt; 3),
 539     XVSUBDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  104u &lt;&lt; 3),
 540     XVMULSP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   80u &lt;&lt; 3),
 541     XVMULDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  112u &lt;&lt; 3),
 542     XVMADDASP_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |   65u &lt;&lt; 3),
 543     XVMADDADP_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |   97u &lt;&lt; 3),
 544     XVMSUBASP_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |   81u &lt;&lt; 3),
 545     XVMSUBADP_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |  113u &lt;&lt; 3),
 546     XVNMSUBASP_OPCODE=(60u&lt;&lt; OPCODE_SHIFT |  209u &lt;&lt; 3),
 547     XVNMSUBADP_OPCODE=(60u&lt;&lt; OPCODE_SHIFT |  241u &lt;&lt; 3),
 548 
 549     // Deliver A Random Number (introduced with POWER9)
 550     DARN_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  755u &lt;&lt; 1),
 551 
 552     // Vector Permute and Formatting
 553     VPKPX_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  782u     ),
 554     VPKSHSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  398u     ),
 555     VPKSWSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  462u     ),
 556     VPKSHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  270u     ),
 557     VPKSWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  334u     ),
 558     VPKUHUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   14u     ),
 559     VPKUWUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   78u     ),
 560     VPKUHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  142u     ),
 561     VPKUWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  206u     ),
 562     VUPKHPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  846u     ),
 563     VUPKHSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  526u     ),
 564     VUPKHSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  590u     ),
 565     VUPKLPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  974u     ),
 566     VUPKLSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  654u     ),
 567     VUPKLSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  718u     ),
 568 
 569     VMRGHB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   12u     ),
 570     VMRGHW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  140u     ),
 571     VMRGHH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   76u     ),
 572     VMRGLB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  268u     ),
 573     VMRGLW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  396u     ),
 574     VMRGLH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  332u     ),
 575 
 576     VSPLT_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  524u     ),
 577     VSPLTH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  588u     ),
 578     VSPLTW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  652u     ),
 579     VSPLTISB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  780u     ),
 580     VSPLTISH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  844u     ),
 581     VSPLTISW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  908u     ),
 582 
 583     VPERM_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |   43u     ),
 584     VSEL_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   42u     ),
 585 
 586     VSL_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  452u     ),
 587     VSLDOI_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   44u     ),
 588     VSLO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1036u     ),
 589     VSR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  708u     ),
 590     VSRO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1100u     ),
 591 
 592     // Vector Integer
 593     VADDCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  384u     ),
 594     VADDSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  832u     ),
 595     VADDSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  768u     ),
 596     VADDSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  896u     ),
 597     VADDUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    0u     ),
 598     VADDUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  128u     ),
 599     VADDUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   64u     ),
 600     VADDUDM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  192u     ),
 601     VADDUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  512u     ),
 602     VADDUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  640u     ),
 603     VADDUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  576u     ),
 604     VADDFP_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   10u     ),
 605     VSUBCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1408u     ),
 606     VSUBSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1856u     ),
 607     VSUBSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1792u     ),
 608     VSUBSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1920u     ),
 609     VSUBUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1024u     ),
 610     VSUBUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1152u     ),
 611     VSUBUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1088u     ),
 612     VSUBUDM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1216u     ),
 613     VSUBUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1536u     ),
 614     VSUBUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1664u     ),
 615     VSUBUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1600u     ),
 616     VSUBFP_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   74u     ),
 617 
 618     VMULESB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  776u     ),
 619     VMULEUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  520u     ),
 620     VMULESH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  840u     ),
 621     VMULEUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  584u     ),
 622     VMULOSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  264u     ),
 623     VMULOUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    8u     ),
 624     VMULOSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  328u     ),
 625     VMULOSW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  392u     ),
 626     VMULOUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   72u     ),
 627     VMULUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  137u     ),
 628     VMHADDSHS_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   32u     ),
 629     VMHRADDSHS_OPCODE=(4u &lt;&lt; OPCODE_SHIFT |   33u     ),
 630     VMLADDUHM_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   34u     ),
 631     VMSUBUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   36u     ),
 632     VMSUMMBM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   37u     ),
 633     VMSUMSHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   40u     ),
 634     VMSUMSHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   41u     ),
 635     VMSUMUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   38u     ),
 636     VMSUMUHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   39u     ),
 637     VMADDFP_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   46u     ),
 638 
 639     VSUMSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1928u     ),
 640     VSUM2SWS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1672u     ),
 641     VSUM4SBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1800u     ),
 642     VSUM4UBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1544u     ),
 643     VSUM4SHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1608u     ),
 644 
 645     VAVGSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1282u     ),
 646     VAVGSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1410u     ),
 647     VAVGSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1346u     ),
 648     VAVGUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1026u     ),
 649     VAVGUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1154u     ),
 650     VAVGUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1090u     ),
 651 
 652     VMAXSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  258u     ),
 653     VMAXSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  386u     ),
 654     VMAXSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  322u     ),
 655     VMAXUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |    2u     ),
 656     VMAXUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  130u     ),
 657     VMAXUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   66u     ),
 658     VMINSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  770u     ),
 659     VMINSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  898u     ),
 660     VMINSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  834u     ),
 661     VMINUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  514u     ),
 662     VMINUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  642u     ),
 663     VMINUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  578u     ),
 664 
 665     VCMPEQUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |    6u     ),
 666     VCMPEQUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   70u     ),
 667     VCMPEQUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  134u     ),
 668     VCMPGTSH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  838u     ),
 669     VCMPGTSB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  774u     ),
 670     VCMPGTSW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  902u     ),
 671     VCMPGTUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  518u     ),
 672     VCMPGTUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  582u     ),
 673     VCMPGTUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  646u     ),
 674 
 675     VAND_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1028u     ),
 676     VANDC_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1092u     ),
 677     VNOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1284u     ),
 678     VOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1156u     ),
 679     VXOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1220u     ),
 680     VRLD_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  196u     ),
 681     VRLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |    4u     ),
 682     VRLW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  132u     ),
 683     VRLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   68u     ),
 684     VSLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  260u     ),
 685     VSKW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  388u     ),
 686     VSLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  324u     ),
 687     VSRB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  516u     ),
 688     VSRW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  644u     ),
 689     VSRH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  580u     ),
 690     VSRAB_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  772u     ),
 691     VSRAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  900u     ),
 692     VSRAH_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  836u     ),
 693     VPOPCNTW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1923u     ),
 694 
 695     // Vector Floating-Point
 696     // not implemented yet
 697 
 698     // Vector Status and Control
 699     MTVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1604u     ),
 700     MFVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1540u     ),
 701 
 702     // AES (introduced with Power 8)
 703     VCIPHER_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1288u),
 704     VCIPHERLAST_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1289u),
 705     VNCIPHER_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1352u),
 706     VNCIPHERLAST_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1353u),
 707     VSBOX_OPCODE        = (4u  &lt;&lt; OPCODE_SHIFT | 1480u),
 708 
 709     // SHA (introduced with Power 8)
 710     VSHASIGMAD_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1730u),
 711     VSHASIGMAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1666u),
 712 
 713     // Vector Binary Polynomial Multiplication (introduced with Power 8)
 714     VPMSUMB_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1032u),
 715     VPMSUMD_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1224u),
 716     VPMSUMH_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1096u),
 717     VPMSUMW_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1160u),
 718 
 719     // Vector Permute and Xor (introduced with Power 8)
 720     VPERMXOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |   45u),
 721 
 722     // Transactional Memory instructions (introduced with Power 8)
 723     TBEGIN_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  654u &lt;&lt; 1),
 724     TEND_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |  686u &lt;&lt; 1),
 725     TABORT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  910u &lt;&lt; 1),
 726     TABORTWC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  782u &lt;&lt; 1),
 727     TABORTWCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 728     TABORTDC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 729     TABORTDCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  878u &lt;&lt; 1),
 730     TSR_OPCODE       = (31u &lt;&lt; OPCODE_SHIFT |  750u &lt;&lt; 1),
 731     TCHECK_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  718u &lt;&lt; 1),
 732 
 733     // Icache and dcache related instructions
 734     DCBA_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  758u &lt;&lt; 1),
 735     DCBZ_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 1014u &lt;&lt; 1),
 736     DCBST_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   54u &lt;&lt; 1),
 737     DCBF_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   86u &lt;&lt; 1),
 738 
 739     DCBT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  278u &lt;&lt; 1),
 740     DCBTST_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  246u &lt;&lt; 1),
 741     ICBI_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  982u &lt;&lt; 1),
 742 
 743     // Instruction synchronization
 744     ISYNC_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 745     // Memory barriers
 746     SYNC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  598u &lt;&lt; 1),
 747     EIEIO_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  854u &lt;&lt; 1),
 748 
 749     // Wait instructions for polling.
 750     WAIT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   62u &lt;&lt; 1),
 751 
 752     // Trap instructions
 753     TDI_OPCODE     = (2u  &lt;&lt; OPCODE_SHIFT),
 754     TWI_OPCODE     = (3u  &lt;&lt; OPCODE_SHIFT),
 755     TD_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |   68u &lt;&lt; 1),
 756     TW_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |    4u &lt;&lt; 1),
 757 
 758     // Atomics.
 759     LBARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   52u &lt;&lt; 1),
 760     LHARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  116u &lt;&lt; 1),
 761     LWARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 762     LDARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   84u &lt;&lt; 1),
 763     LQARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  276u &lt;&lt; 1),
 764     STBCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  694u &lt;&lt; 1),
 765     STHCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  726u &lt;&lt; 1),
 766     STWCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 767     STDCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  214u &lt;&lt; 1),
 768     STQCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  182u &lt;&lt; 1)
 769 
 770   };
 771 
 772   // Trap instructions TO bits
 773   enum trap_to_bits {
 774     // single bits
 775     traptoLessThanSigned      = 1 &lt;&lt; 4, // 0, left end
 776     traptoGreaterThanSigned   = 1 &lt;&lt; 3,
 777     traptoEqual               = 1 &lt;&lt; 2,
 778     traptoLessThanUnsigned    = 1 &lt;&lt; 1,
 779     traptoGreaterThanUnsigned = 1 &lt;&lt; 0, // 4, right end
 780 
 781     // compound ones
 782     traptoUnconditional       = (traptoLessThanSigned |
 783                                  traptoGreaterThanSigned |
 784                                  traptoEqual |
 785                                  traptoLessThanUnsigned |
 786                                  traptoGreaterThanUnsigned)
 787   };
 788 
 789   // Branch hints BH field
 790   enum branch_hint_bh {
 791     // bclr cases:
 792     bhintbhBCLRisReturn            = 0,
 793     bhintbhBCLRisNotReturnButSame  = 1,
 794     bhintbhBCLRisNotPredictable    = 3,
 795 
 796     // bcctr cases:
 797     bhintbhBCCTRisNotReturnButSame = 0,
 798     bhintbhBCCTRisNotPredictable   = 3
 799   };
 800 
 801   // Branch prediction hints AT field
 802   enum branch_hint_at {
 803     bhintatNoHint     = 0,  // at=00
 804     bhintatIsNotTaken = 2,  // at=10
 805     bhintatIsTaken    = 3   // at=11
 806   };
 807 
 808   // Branch prediction hints
 809   enum branch_hint_concept {
 810     // Use the same encoding as branch_hint_at to simply code.
 811     bhintNoHint       = bhintatNoHint,
 812     bhintIsNotTaken   = bhintatIsNotTaken,
 813     bhintIsTaken      = bhintatIsTaken
 814   };
 815 
 816   // Used in BO field of branch instruction.
 817   enum branch_condition {
 818     bcondCRbiIs0      =  4, // bo=001at
 819     bcondCRbiIs1      = 12, // bo=011at
 820     bcondAlways       = 20  // bo=10100
 821   };
 822 
 823   // Branch condition with combined prediction hints.
 824   enum branch_condition_with_hint {
 825     bcondCRbiIs0_bhintNoHint     = bcondCRbiIs0 | bhintatNoHint,
 826     bcondCRbiIs0_bhintIsNotTaken = bcondCRbiIs0 | bhintatIsNotTaken,
 827     bcondCRbiIs0_bhintIsTaken    = bcondCRbiIs0 | bhintatIsTaken,
 828     bcondCRbiIs1_bhintNoHint     = bcondCRbiIs1 | bhintatNoHint,
 829     bcondCRbiIs1_bhintIsNotTaken = bcondCRbiIs1 | bhintatIsNotTaken,
 830     bcondCRbiIs1_bhintIsTaken    = bcondCRbiIs1 | bhintatIsTaken,
 831   };
 832 
 833   // Elemental Memory Barriers (&gt;=Power 8)
 834   enum Elemental_Membar_mask_bits {
 835     StoreStore = 1 &lt;&lt; 0,
 836     StoreLoad  = 1 &lt;&lt; 1,
 837     LoadStore  = 1 &lt;&lt; 2,
 838     LoadLoad   = 1 &lt;&lt; 3
 839   };
 840 
 841   // Branch prediction hints.
 842   inline static int add_bhint_to_boint(const int bhint, const int boint) {
 843     switch (boint) {
 844       case bcondCRbiIs0:
 845       case bcondCRbiIs1:
 846         // branch_hint and branch_hint_at have same encodings
 847         assert(   (int)bhintNoHint     == (int)bhintatNoHint
 848                &amp;&amp; (int)bhintIsNotTaken == (int)bhintatIsNotTaken
 849                &amp;&amp; (int)bhintIsTaken    == (int)bhintatIsTaken,
 850                &quot;wrong encodings&quot;);
 851         assert((bhint &amp; 0x03) == bhint, &quot;wrong encodings&quot;);
 852         return (boint &amp; ~0x03) | bhint;
 853       case bcondAlways:
 854         // no branch_hint
 855         return boint;
 856       default:
 857         ShouldNotReachHere();
 858         return 0;
 859     }
 860   }
 861 
 862   // Extract bcond from boint.
 863   inline static int inv_boint_bcond(const int boint) {
 864     int r_bcond = boint &amp; ~0x03;
 865     assert(r_bcond == bcondCRbiIs0 ||
 866            r_bcond == bcondCRbiIs1 ||
 867            r_bcond == bcondAlways,
 868            &quot;bad branch condition&quot;);
 869     return r_bcond;
 870   }
 871 
 872   // Extract bhint from boint.
 873   inline static int inv_boint_bhint(const int boint) {
 874     int r_bhint = boint &amp; 0x03;
 875     assert(r_bhint == bhintatNoHint ||
 876            r_bhint == bhintatIsNotTaken ||
 877            r_bhint == bhintatIsTaken,
 878            &quot;bad branch hint&quot;);
 879     return r_bhint;
 880   }
 881 
 882   // Calculate opposite of given bcond.
 883   inline static int opposite_bcond(const int bcond) {
 884     switch (bcond) {
 885       case bcondCRbiIs0:
 886         return bcondCRbiIs1;
 887       case bcondCRbiIs1:
 888         return bcondCRbiIs0;
 889       default:
 890         ShouldNotReachHere();
 891         return 0;
 892     }
 893   }
 894 
 895   // Calculate opposite of given bhint.
 896   inline static int opposite_bhint(const int bhint) {
 897     switch (bhint) {
 898       case bhintatNoHint:
 899         return bhintatNoHint;
 900       case bhintatIsNotTaken:
 901         return bhintatIsTaken;
 902       case bhintatIsTaken:
 903         return bhintatIsNotTaken;
 904       default:
 905         ShouldNotReachHere();
 906         return 0;
 907     }
 908   }
 909 
 910   // PPC branch instructions
 911   enum ppcops {
 912     b_op    = 18,
 913     bc_op   = 16,
 914     bcr_op  = 19
 915   };
 916 
 917   enum Condition {
 918     negative         = 0,
 919     less             = 0,
 920     positive         = 1,
 921     greater          = 1,
 922     zero             = 2,
 923     equal            = 2,
 924     summary_overflow = 3,
 925   };
 926 
 927  public:
 928   // Helper functions for groups of instructions
 929 
 930   enum Predict { pt = 1, pn = 0 }; // pt = predict taken
 931 
 932   // Instruction must start at passed address.
 933   static int instr_len(unsigned char *instr) { return BytesPerInstWord; }
 934 
 935   // longest instructions
 936   static int instr_maxlen() { return BytesPerInstWord; }
 937 
 938   // Test if x is within signed immediate range for nbits.
 939   static bool is_simm(int x, unsigned int nbits) {
 940     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, &quot;out of bounds&quot;);
 941     const int   min      = -(((int)1) &lt;&lt; nbits-1);
 942     const int   maxplus1 =  (((int)1) &lt;&lt; nbits-1);
 943     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 944   }
 945 
 946   static bool is_simm(jlong x, unsigned int nbits) {
 947     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, &quot;out of bounds&quot;);
 948     const jlong min      = -(((jlong)1) &lt;&lt; nbits-1);
 949     const jlong maxplus1 =  (((jlong)1) &lt;&lt; nbits-1);
 950     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 951   }
 952 
 953   // Test if x is within unsigned immediate range for nbits.
 954   static bool is_uimm(int x, unsigned int nbits) {
 955     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, &quot;out of bounds&quot;);
 956     const unsigned int maxplus1 = (((unsigned int)1) &lt;&lt; nbits);
 957     return (unsigned int)x &lt; maxplus1;
 958   }
 959 
 960   static bool is_uimm(jlong x, unsigned int nbits) {
 961     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, &quot;out of bounds&quot;);
 962     const julong maxplus1 = (((julong)1) &lt;&lt; nbits);
 963     return (julong)x &lt; maxplus1;
 964   }
 965 
 966  protected:
 967   // helpers
 968 
 969   // X is supposed to fit in a field &quot;nbits&quot; wide
 970   // and be sign-extended. Check the range.
 971   static void assert_signed_range(intptr_t x, int nbits) {
 972     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 973            &quot;value out of range&quot;);
 974   }
 975 
 976   static void assert_signed_word_disp_range(intptr_t x, int nbits) {
 977     assert((x &amp; 3) == 0, &quot;not word aligned&quot;);
 978     assert_signed_range(x, nbits + 2);
 979   }
 980 
 981   static void assert_unsigned_const(int x, int nbits) {
 982     assert(juint(x) &lt; juint(1 &lt;&lt; nbits), &quot;unsigned constant out of range&quot;);
 983   }
 984 
 985   static int fmask(juint hi_bit, juint lo_bit) {
 986     assert(hi_bit &gt;= lo_bit &amp;&amp; hi_bit &lt; 32, &quot;bad bits&quot;);
 987     return (1 &lt;&lt; ( hi_bit-lo_bit + 1 )) - 1;
 988   }
 989 
 990   // inverse of u_field
 991   static int inv_u_field(int x, int hi_bit, int lo_bit) {
 992     juint r = juint(x) &gt;&gt; lo_bit;
 993     r &amp;= fmask(hi_bit, lo_bit);
 994     return int(r);
 995   }
 996 
 997   // signed version: extract from field and sign-extend
 998   static int inv_s_field_ppc(int x, int hi_bit, int lo_bit) {
 999     x = x &lt;&lt; (31-hi_bit);
1000     x = x &gt;&gt; (31-hi_bit+lo_bit);
1001     return x;
1002   }
1003 
1004   static int u_field(int x, int hi_bit, int lo_bit) {
1005     assert((x &amp; ~fmask(hi_bit, lo_bit)) == 0, &quot;value out of range&quot;);
1006     int r = x &lt;&lt; lo_bit;
1007     assert(inv_u_field(r, hi_bit, lo_bit) == x, &quot;just checking&quot;);
1008     return r;
1009   }
1010 
1011   // Same as u_field for signed values
1012   static int s_field(int x, int hi_bit, int lo_bit) {
1013     int nbits = hi_bit - lo_bit + 1;
1014     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
1015       &quot;value out of range&quot;);
1016     x &amp;= fmask(hi_bit, lo_bit);
1017     int r = x &lt;&lt; lo_bit;
1018     return r;
1019   }
1020 
1021   // inv_op for ppc instructions
1022   static int inv_op_ppc(int x) { return inv_u_field(x, 31, 26); }
1023 
1024   // Determine target address from li, bd field of branch instruction.
1025   static intptr_t inv_li_field(int x) {
1026     intptr_t r = inv_s_field_ppc(x, 25, 2);
1027     r = (r &lt;&lt; 2);
1028     return r;
1029   }
1030   static intptr_t inv_bd_field(int x, intptr_t pos) {
1031     intptr_t r = inv_s_field_ppc(x, 15, 2);
1032     r = (r &lt;&lt; 2) + pos;
1033     return r;
1034   }
1035 
1036   #define inv_opp_u_field(x, hi_bit, lo_bit) inv_u_field(x, 31-(lo_bit), 31-(hi_bit))
1037   #define inv_opp_s_field(x, hi_bit, lo_bit) inv_s_field_ppc(x, 31-(lo_bit), 31-(hi_bit))
1038   // Extract instruction fields from instruction words.
1039  public:
1040   static int inv_ra_field(int x)  { return inv_opp_u_field(x, 15, 11); }
1041   static int inv_rb_field(int x)  { return inv_opp_u_field(x, 20, 16); }
1042   static int inv_rt_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1043   static int inv_rta_field(int x) { return inv_opp_u_field(x, 15, 11); }
1044   static int inv_rs_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1045   // Ds uses opp_s_field(x, 31, 16), but lowest 2 bits must be 0.
1046   // Inv_ds_field uses range (x, 29, 16) but shifts by 2 to ensure that lowest bits are 0.
1047   static int inv_ds_field(int x)  { return inv_opp_s_field(x, 29, 16) &lt;&lt; 2; }
1048   static int inv_d1_field(int x)  { return inv_opp_s_field(x, 31, 16); }
1049   static int inv_si_field(int x)  { return inv_opp_s_field(x, 31, 16); }
1050   static int inv_to_field(int x)  { return inv_opp_u_field(x, 10, 6);  }
1051   static int inv_lk_field(int x)  { return inv_opp_u_field(x, 31, 31); }
1052   static int inv_bo_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1053   static int inv_bi_field(int x)  { return inv_opp_u_field(x, 15, 11); }
1054 
1055   #define opp_u_field(x, hi_bit, lo_bit) u_field(x, 31-(lo_bit), 31-(hi_bit))
1056   #define opp_s_field(x, hi_bit, lo_bit) s_field(x, 31-(lo_bit), 31-(hi_bit))
1057 
1058   // instruction fields
1059   static int aa(       int         x)  { return  opp_u_field(x,             30, 30); }
1060   static int ba(       int         x)  { return  opp_u_field(x,             15, 11); }
1061   static int bb(       int         x)  { return  opp_u_field(x,             20, 16); }
1062   static int bc(       int         x)  { return  opp_u_field(x,             25, 21); }
1063   static int bd(       int         x)  { return  opp_s_field(x,             29, 16); }
1064   static int bf( ConditionRegister cr) { return  bf(cr-&gt;encoding()); }
1065   static int bf(       int         x)  { return  opp_u_field(x,              8,  6); }
1066   static int bfa(ConditionRegister cr) { return  bfa(cr-&gt;encoding()); }
1067   static int bfa(      int         x)  { return  opp_u_field(x,             13, 11); }
1068   static int bh(       int         x)  { return  opp_u_field(x,             20, 19); }
1069   static int bi(       int         x)  { return  opp_u_field(x,             15, 11); }
1070   static int bi0(ConditionRegister cr, Condition c) { return (cr-&gt;encoding() &lt;&lt; 2) | c; }
1071   static int bo(       int         x)  { return  opp_u_field(x,             10,  6); }
1072   static int bt(       int         x)  { return  opp_u_field(x,             10,  6); }
1073   static int d1(       int         x)  { return  opp_s_field(x,             31, 16); }
1074   static int ds(       int         x)  { assert((x &amp; 0x3) == 0, &quot;unaligned offset&quot;); return opp_s_field(x, 31, 16); }
1075   static int eh(       int         x)  { return  opp_u_field(x,             31, 31); }
1076   static int flm(      int         x)  { return  opp_u_field(x,             14,  7); }
1077   static int fra(    FloatRegister r)  { return  fra(r-&gt;encoding());}
1078   static int frb(    FloatRegister r)  { return  frb(r-&gt;encoding());}
1079   static int frc(    FloatRegister r)  { return  frc(r-&gt;encoding());}
1080   static int frs(    FloatRegister r)  { return  frs(r-&gt;encoding());}
1081   static int frt(    FloatRegister r)  { return  frt(r-&gt;encoding());}
1082   static int fra(      int         x)  { return  opp_u_field(x,             15, 11); }
1083   static int frb(      int         x)  { return  opp_u_field(x,             20, 16); }
1084   static int frc(      int         x)  { return  opp_u_field(x,             25, 21); }
1085   static int frs(      int         x)  { return  opp_u_field(x,             10,  6); }
1086   static int frt(      int         x)  { return  opp_u_field(x,             10,  6); }
1087   static int fxm(      int         x)  { return  opp_u_field(x,             19, 12); }
1088   static int l10(      int         x)  { assert(x == 0 || x == 1,  &quot;must be 0 or 1&quot;); return opp_u_field(x, 10, 10); }
1089   static int l14(      int         x)  { return  opp_u_field(x,             15, 14); }
1090   static int l15(      int         x)  { return  opp_u_field(x,             15, 15); }
1091   static int l910(     int         x)  { return  opp_u_field(x,             10,  9); }
1092   static int e1215(    int         x)  { return  opp_u_field(x,             15, 12); }
1093   static int lev(      int         x)  { return  opp_u_field(x,             26, 20); }
1094   static int li(       int         x)  { return  opp_s_field(x,             29,  6); }
1095   static int lk(       int         x)  { return  opp_u_field(x,             31, 31); }
1096   static int mb2125(   int         x)  { return  opp_u_field(x,             25, 21); }
1097   static int me2630(   int         x)  { return  opp_u_field(x,             30, 26); }
1098   static int mb2126(   int         x)  { return  opp_u_field(((x &amp; 0x1f) &lt;&lt; 1) | ((x &amp; 0x20) &gt;&gt; 5), 26, 21); }
1099   static int me2126(   int         x)  { return  mb2126(x); }
1100   static int nb(       int         x)  { return  opp_u_field(x,             20, 16); }
1101   //static int opcd(   int         x)  { return  opp_u_field(x,              5,  0); } // is contained in our opcodes
1102   static int oe(       int         x)  { return  opp_u_field(x,             21, 21); }
1103   static int ra(       Register    r)  { return  ra(r-&gt;encoding()); }
1104   static int ra(       int         x)  { return  opp_u_field(x,             15, 11); }
1105   static int rb(       Register    r)  { return  rb(r-&gt;encoding()); }
1106   static int rb(       int         x)  { return  opp_u_field(x,             20, 16); }
1107   static int rc(       int         x)  { return  opp_u_field(x,             31, 31); }
1108   static int rs(       Register    r)  { return  rs(r-&gt;encoding()); }
1109   static int rs(       int         x)  { return  opp_u_field(x,             10,  6); }
1110   // we don&#39;t want to use R0 in memory accesses, because it has value `0&#39; then
1111   static int ra0mem(   Register    r)  { assert(r != R0, &quot;cannot use register R0 in memory access&quot;); return ra(r); }
1112   static int ra0mem(   int         x)  { assert(x != 0,  &quot;cannot use register 0 in memory access&quot;);  return ra(x); }
1113 
1114   // register r is target
1115   static int rt(       Register    r)  { return rs(r); }
1116   static int rt(       int         x)  { return rs(x); }
1117   static int rta(      Register    r)  { return ra(r); }
1118   static int rta0mem(  Register    r)  { rta(r); return ra0mem(r); }
1119 
1120   static int sh1620(   int         x)  { return  opp_u_field(x,             20, 16); }
1121   static int sh30(     int         x)  { return  opp_u_field(x,             30, 30); }
1122   static int sh162030( int         x)  { return  sh1620(x &amp; 0x1f) | sh30((x &amp; 0x20) &gt;&gt; 5); }
1123   static int si(       int         x)  { return  opp_s_field(x,             31, 16); }
1124   static int spr(      int         x)  { return  opp_u_field(x,             20, 11); }
1125   static int sr(       int         x)  { return  opp_u_field(x,             15, 12); }
1126   static int tbr(      int         x)  { return  opp_u_field(x,             20, 11); }
1127   static int th(       int         x)  { return  opp_u_field(x,             10,  7); }
1128   static int thct(     int         x)  { assert((x&amp;8) == 0, &quot;must be valid cache specification&quot;);  return th(x); }
1129   static int thds(     int         x)  { assert((x&amp;8) == 8, &quot;must be valid stream specification&quot;); return th(x); }
1130   static int to(       int         x)  { return  opp_u_field(x,             10,  6); }
1131   static int u(        int         x)  { return  opp_u_field(x,             19, 16); }
1132   static int ui(       int         x)  { return  opp_u_field(x,             31, 16); }
1133 
1134   // Support vector instructions for &gt;= Power6.
1135   static int vra(      int         x)  { return  opp_u_field(x,             15, 11); }
1136   static int vrb(      int         x)  { return  opp_u_field(x,             20, 16); }
1137   static int vrc(      int         x)  { return  opp_u_field(x,             25, 21); }
1138   static int vrs(      int         x)  { return  opp_u_field(x,             10,  6); }
1139   static int vrt(      int         x)  { return  opp_u_field(x,             10,  6); }
1140 
1141   static int vra(   VectorRegister r)  { return  vra(r-&gt;encoding());}
1142   static int vrb(   VectorRegister r)  { return  vrb(r-&gt;encoding());}
1143   static int vrc(   VectorRegister r)  { return  vrc(r-&gt;encoding());}
1144   static int vrs(   VectorRegister r)  { return  vrs(r-&gt;encoding());}
1145   static int vrt(   VectorRegister r)  { return  vrt(r-&gt;encoding());}
1146 
1147   // Only used on SHA sigma instructions (VX-form)
1148   static int vst(      int         x)  { return  opp_u_field(x,             16, 16); }
1149   static int vsix(     int         x)  { return  opp_u_field(x,             20, 17); }
1150 
1151   // Support Vector-Scalar (VSX) instructions.
1152   static int vsra(      int         x)  { return  opp_u_field(x &amp; 0x1F,     15, 11) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 29, 29); }
1153   static int vsrb(      int         x)  { return  opp_u_field(x &amp; 0x1F,     20, 16) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 30, 30); }
1154   static int vsrs(      int         x)  { return  opp_u_field(x &amp; 0x1F,     10,  6) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 31, 31); }
1155   static int vsrt(      int         x)  { return  vsrs(x); }
1156   static int vsdm(      int         x)  { return  opp_u_field(x,            23, 22); }
1157 
1158   static int vsra(   VectorSRegister r)  { return  vsra(r-&gt;encoding());}
1159   static int vsrb(   VectorSRegister r)  { return  vsrb(r-&gt;encoding());}
1160   static int vsrs(   VectorSRegister r)  { return  vsrs(r-&gt;encoding());}
1161   static int vsrt(   VectorSRegister r)  { return  vsrt(r-&gt;encoding());}
1162 
1163   static int vsplt_uim( int        x)  { return  opp_u_field(x,             15, 12); } // for vsplt* instructions
1164   static int vsplti_sim(int        x)  { return  opp_u_field(x,             15, 11); } // for vsplti* instructions
1165   static int vsldoi_shb(int        x)  { return  opp_u_field(x,             25, 22); } // for vsldoi instruction
1166   static int vcmp_rc(   int        x)  { return  opp_u_field(x,             21, 21); } // for vcmp* instructions
1167   static int xxsplt_uim(int        x)  { return  opp_u_field(x,             15, 14); } // for xxsplt* instructions
1168 
1169   //static int xo1(     int        x)  { return  opp_u_field(x,             29, 21); }// is contained in our opcodes
1170   //static int xo2(     int        x)  { return  opp_u_field(x,             30, 21); }// is contained in our opcodes
1171   //static int xo3(     int        x)  { return  opp_u_field(x,             30, 22); }// is contained in our opcodes
1172   //static int xo4(     int        x)  { return  opp_u_field(x,             30, 26); }// is contained in our opcodes
1173   //static int xo5(     int        x)  { return  opp_u_field(x,             29, 27); }// is contained in our opcodes
1174   //static int xo6(     int        x)  { return  opp_u_field(x,             30, 27); }// is contained in our opcodes
1175   //static int xo7(     int        x)  { return  opp_u_field(x,             31, 30); }// is contained in our opcodes
1176 
1177  protected:
1178   // Compute relative address for branch.
1179   static intptr_t disp(intptr_t x, intptr_t off) {
1180     int xx = x - off;
1181     xx = xx &gt;&gt; 2;
1182     return xx;
1183   }
1184 
1185  public:
1186   // signed immediate, in low bits, nbits long
1187   static int simm(int x, int nbits) {
1188     assert_signed_range(x, nbits);
1189     return x &amp; ((1 &lt;&lt; nbits) - 1);
1190   }
1191 
1192   // unsigned immediate, in low bits, nbits long
1193   static int uimm(int x, int nbits) {
1194     assert_unsigned_const(x, nbits);
1195     return x &amp; ((1 &lt;&lt; nbits) - 1);
1196   }
1197 
1198   static void set_imm(int* instr, short s) {
1199     // imm is always in the lower 16 bits of the instruction,
1200     // so this is endian-neutral. Same for the get_imm below.
1201     uint32_t w = *(uint32_t *)instr;
1202     *instr = (int)((w &amp; ~0x0000FFFF) | (s &amp; 0x0000FFFF));
1203   }
1204 
1205   static int get_imm(address a, int instruction_number) {
1206     return (short)((int *)a)[instruction_number];
1207   }
1208 
1209   static inline int hi16_signed(  int x) { return (int)(int16_t)(x &gt;&gt; 16); }
1210   static inline int lo16_unsigned(int x) { return x &amp; 0xffff; }
1211 
1212  protected:
1213 
1214   // Extract the top 32 bits in a 64 bit word.
1215   static int32_t hi32(int64_t x) {
1216     int32_t r = int32_t((uint64_t)x &gt;&gt; 32);
1217     return r;
1218   }
1219 
1220  public:
1221 
1222   static inline unsigned int align_addr(unsigned int addr, unsigned int a) {
1223     return ((addr + (a - 1)) &amp; ~(a - 1));
1224   }
1225 
1226   static inline bool is_aligned(unsigned int addr, unsigned int a) {
1227     return (0 == addr % a);
1228   }
1229 
1230   void flush() {
1231     AbstractAssembler::flush();
1232   }
1233 
1234   inline void emit_int32(int);  // shadows AbstractAssembler::emit_int32
1235   inline void emit_data(int);
1236   inline void emit_data(int, RelocationHolder const&amp;);
1237   inline void emit_data(int, relocInfo::relocType rtype);
1238 
1239   // Emit an address.
1240   inline address emit_addr(const address addr = NULL);
1241 
1242 #if !defined(ABI_ELFv2)
1243   // Emit a function descriptor with the specified entry point, TOC,
1244   // and ENV. If the entry point is NULL, the descriptor will point
1245   // just past the descriptor.
1246   // Use values from friend functions as defaults.
1247   inline address emit_fd(address entry = NULL,
1248                          address toc = (address) FunctionDescriptor::friend_toc,
1249                          address env = (address) FunctionDescriptor::friend_env);
1250 #endif
1251 
1252   /////////////////////////////////////////////////////////////////////////////////////
1253   // PPC instructions
1254   /////////////////////////////////////////////////////////////////////////////////////
1255 
1256   // Memory instructions use r0 as hard coded 0, e.g. to simulate loading
1257   // immediates. The normal instruction encoders enforce that r0 is not
1258   // passed to them. Use either extended mnemonics encoders or the special ra0
1259   // versions.
1260 
1261   // Issue an illegal instruction.
1262   inline void illtrap();
1263   static inline bool is_illtrap(int x);
1264 
1265   // PPC 1, section 3.3.8, Fixed-Point Arithmetic Instructions
1266   inline void addi( Register d, Register a, int si16);
1267   inline void addis(Register d, Register a, int si16);
1268  private:
1269   inline void addi_r0ok( Register d, Register a, int si16);
1270   inline void addis_r0ok(Register d, Register a, int si16);
1271  public:
1272   inline void addic_( Register d, Register a, int si16);
1273   inline void subfic( Register d, Register a, int si16);
1274   inline void add(    Register d, Register a, Register b);
1275   inline void add_(   Register d, Register a, Register b);
1276   inline void subf(   Register d, Register a, Register b);  // d = b - a    &quot;Sub_from&quot;, as in ppc spec.
1277   inline void sub(    Register d, Register a, Register b);  // d = a - b    Swap operands of subf for readability.
1278   inline void subf_(  Register d, Register a, Register b);
1279   inline void addc(   Register d, Register a, Register b);
1280   inline void addc_(  Register d, Register a, Register b);
1281   inline void subfc(  Register d, Register a, Register b);
1282   inline void subfc_( Register d, Register a, Register b);
1283   inline void adde(   Register d, Register a, Register b);
1284   inline void adde_(  Register d, Register a, Register b);
1285   inline void subfe(  Register d, Register a, Register b);
1286   inline void subfe_( Register d, Register a, Register b);
1287   inline void addme(  Register d, Register a);
1288   inline void addme_( Register d, Register a);
1289   inline void subfme( Register d, Register a);
1290   inline void subfme_(Register d, Register a);
1291   inline void addze(  Register d, Register a);
1292   inline void addze_( Register d, Register a);
1293   inline void subfze( Register d, Register a);
1294   inline void subfze_(Register d, Register a);
1295   inline void neg(    Register d, Register a);
1296   inline void neg_(   Register d, Register a);
1297   inline void mulli(  Register d, Register a, int si16);
1298   inline void mulld(  Register d, Register a, Register b);
1299   inline void mulld_( Register d, Register a, Register b);
1300   inline void mullw(  Register d, Register a, Register b);
1301   inline void mullw_( Register d, Register a, Register b);
1302   inline void mulhw(  Register d, Register a, Register b);
1303   inline void mulhw_( Register d, Register a, Register b);
1304   inline void mulhwu( Register d, Register a, Register b);
1305   inline void mulhwu_(Register d, Register a, Register b);
1306   inline void mulhd(  Register d, Register a, Register b);
1307   inline void mulhd_( Register d, Register a, Register b);
1308   inline void mulhdu( Register d, Register a, Register b);
1309   inline void mulhdu_(Register d, Register a, Register b);
1310   inline void divd(   Register d, Register a, Register b);
1311   inline void divd_(  Register d, Register a, Register b);
1312   inline void divw(   Register d, Register a, Register b);
1313   inline void divw_(  Register d, Register a, Register b);
1314 
1315   // Fixed-Point Arithmetic Instructions with Overflow detection
1316   inline void addo(    Register d, Register a, Register b);
1317   inline void addo_(   Register d, Register a, Register b);
1318   inline void subfo(   Register d, Register a, Register b);
1319   inline void subfo_(  Register d, Register a, Register b);
1320   inline void addco(   Register d, Register a, Register b);
1321   inline void addco_(  Register d, Register a, Register b);
1322   inline void subfco(  Register d, Register a, Register b);
1323   inline void subfco_( Register d, Register a, Register b);
1324   inline void addeo(   Register d, Register a, Register b);
1325   inline void addeo_(  Register d, Register a, Register b);
1326   inline void subfeo(  Register d, Register a, Register b);
1327   inline void subfeo_( Register d, Register a, Register b);
1328   inline void addmeo(  Register d, Register a);
1329   inline void addmeo_( Register d, Register a);
1330   inline void subfmeo( Register d, Register a);
1331   inline void subfmeo_(Register d, Register a);
1332   inline void addzeo(  Register d, Register a);
1333   inline void addzeo_( Register d, Register a);
1334   inline void subfzeo( Register d, Register a);
1335   inline void subfzeo_(Register d, Register a);
1336   inline void nego(    Register d, Register a);
1337   inline void nego_(   Register d, Register a);
1338   inline void mulldo(  Register d, Register a, Register b);
1339   inline void mulldo_( Register d, Register a, Register b);
1340   inline void mullwo(  Register d, Register a, Register b);
1341   inline void mullwo_( Register d, Register a, Register b);
1342   inline void divdo(   Register d, Register a, Register b);
1343   inline void divdo_(  Register d, Register a, Register b);
1344   inline void divwo(   Register d, Register a, Register b);
1345   inline void divwo_(  Register d, Register a, Register b);
1346 
1347   // extended mnemonics
1348   inline void li(   Register d, int si16);
1349   inline void lis(  Register d, int si16);
1350   inline void addir(Register d, int si16, Register a);
1351   inline void subi( Register d, Register a, int si16);
1352 
1353   static bool is_addi(int x) {
1354      return ADDI_OPCODE == (x &amp; ADDI_OPCODE_MASK);
1355   }
1356   static bool is_addis(int x) {
1357      return ADDIS_OPCODE == (x &amp; ADDIS_OPCODE_MASK);
1358   }
1359   static bool is_bxx(int x) {
1360      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK);
1361   }
1362   static bool is_b(int x) {
1363      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 0;
1364   }
1365   static bool is_bl(int x) {
1366      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 1;
1367   }
1368   static bool is_bcxx(int x) {
1369      return BCXX_OPCODE == (x &amp; BCXX_OPCODE_MASK);
1370   }
1371   static bool is_bxx_or_bcxx(int x) {
1372      return is_bxx(x) || is_bcxx(x);
1373   }
1374   static bool is_bctrl(int x) {
1375      return x == 0x4e800421;
1376   }
1377   static bool is_bctr(int x) {
1378      return x == 0x4e800420;
1379   }
1380   static bool is_bclr(int x) {
1381      return BCLR_OPCODE == (x &amp; XL_FORM_OPCODE_MASK);
1382   }
1383   static bool is_li(int x) {
1384      return is_addi(x) &amp;&amp; inv_ra_field(x)==0;
1385   }
1386   static bool is_lis(int x) {
1387      return is_addis(x) &amp;&amp; inv_ra_field(x)==0;
1388   }
1389   static bool is_mtctr(int x) {
1390      return MTCTR_OPCODE == (x &amp; MTCTR_OPCODE_MASK);
1391   }
1392   static bool is_ld(int x) {
1393      return LD_OPCODE == (x &amp; LD_OPCODE_MASK);
1394   }
1395   static bool is_std(int x) {
1396      return STD_OPCODE == (x &amp; STD_OPCODE_MASK);
1397   }
1398   static bool is_stdu(int x) {
1399      return STDU_OPCODE == (x &amp; STDU_OPCODE_MASK);
1400   }
1401   static bool is_stdx(int x) {
1402      return STDX_OPCODE == (x &amp; STDX_OPCODE_MASK);
1403   }
1404   static bool is_stdux(int x) {
1405      return STDUX_OPCODE == (x &amp; STDUX_OPCODE_MASK);
1406   }
1407   static bool is_stwx(int x) {
1408      return STWX_OPCODE == (x &amp; STWX_OPCODE_MASK);
1409   }
1410   static bool is_stwux(int x) {
1411      return STWUX_OPCODE == (x &amp; STWUX_OPCODE_MASK);
1412   }
1413   static bool is_stw(int x) {
1414      return STW_OPCODE == (x &amp; STW_OPCODE_MASK);
1415   }
1416   static bool is_stwu(int x) {
1417      return STWU_OPCODE == (x &amp; STWU_OPCODE_MASK);
1418   }
1419   static bool is_ori(int x) {
1420      return ORI_OPCODE == (x &amp; ORI_OPCODE_MASK);
1421   };
1422   static bool is_oris(int x) {
1423      return ORIS_OPCODE == (x &amp; ORIS_OPCODE_MASK);
1424   };
1425   static bool is_rldicr(int x) {
1426      return (RLDICR_OPCODE == (x &amp; RLDICR_OPCODE_MASK));
1427   };
1428   static bool is_nop(int x) {
1429     return x == 0x60000000;
1430   }
1431   // endgroup opcode for Power6
1432   static bool is_endgroup(int x) {
1433     return is_ori(x) &amp;&amp; inv_ra_field(x) == 1 &amp;&amp; inv_rs_field(x) == 1 &amp;&amp; inv_d1_field(x) == 0;
1434   }
1435 
1436 
1437  private:
1438   // PPC 1, section 3.3.9, Fixed-Point Compare Instructions
1439   inline void cmpi( ConditionRegister bf, int l, Register a, int si16);
1440   inline void cmp(  ConditionRegister bf, int l, Register a, Register b);
1441   inline void cmpli(ConditionRegister bf, int l, Register a, int ui16);
1442   inline void cmpl( ConditionRegister bf, int l, Register a, Register b);
1443 
1444  public:
1445   // extended mnemonics of Compare Instructions
1446   inline void cmpwi( ConditionRegister crx, Register a, int si16);
1447   inline void cmpdi( ConditionRegister crx, Register a, int si16);
1448   inline void cmpw(  ConditionRegister crx, Register a, Register b);
1449   inline void cmpd(  ConditionRegister crx, Register a, Register b);
1450   inline void cmplwi(ConditionRegister crx, Register a, int ui16);
1451   inline void cmpldi(ConditionRegister crx, Register a, int ui16);
1452   inline void cmplw( ConditionRegister crx, Register a, Register b);
1453   inline void cmpld( ConditionRegister crx, Register a, Register b);
1454 
1455   // &gt;= Power9
1456   inline void cmprb( ConditionRegister bf, int l, Register a, Register b);
1457   inline void cmpeqb(ConditionRegister bf, Register a, Register b);
1458 
1459   inline void isel(   Register d, Register a, Register b, int bc);
1460   // Convenient version which takes: Condition register, Condition code and invert flag. Omit b to keep old value.
1461   inline void isel(   Register d, ConditionRegister cr, Condition cc, bool inv, Register a, Register b = noreg);
1462   // Set d = 0 if (cr.cc) equals 1, otherwise b.
1463   inline void isel_0( Register d, ConditionRegister cr, Condition cc, Register b = noreg);
1464 
1465   // PPC 1, section 3.3.11, Fixed-Point Logical Instructions
1466          void andi(   Register a, Register s, long ui16);   // optimized version
1467   inline void andi_(  Register a, Register s, int ui16);
1468   inline void andis_( Register a, Register s, int ui16);
1469   inline void ori(    Register a, Register s, int ui16);
1470   inline void oris(   Register a, Register s, int ui16);
1471   inline void xori(   Register a, Register s, int ui16);
1472   inline void xoris(  Register a, Register s, int ui16);
1473   inline void andr(   Register a, Register s, Register b);  // suffixed by &#39;r&#39; as &#39;and&#39; is C++ keyword
1474   inline void and_(   Register a, Register s, Register b);
1475   // Turn or0(rx,rx,rx) into a nop and avoid that we accidently emit a
1476   // SMT-priority change instruction (see SMT instructions below).
1477   inline void or_unchecked(Register a, Register s, Register b);
1478   inline void orr(    Register a, Register s, Register b);  // suffixed by &#39;r&#39; as &#39;or&#39; is C++ keyword
1479   inline void or_(    Register a, Register s, Register b);
1480   inline void xorr(   Register a, Register s, Register b);  // suffixed by &#39;r&#39; as &#39;xor&#39; is C++ keyword
1481   inline void xor_(   Register a, Register s, Register b);
1482   inline void nand(   Register a, Register s, Register b);
1483   inline void nand_(  Register a, Register s, Register b);
1484   inline void nor(    Register a, Register s, Register b);
1485   inline void nor_(   Register a, Register s, Register b);
1486   inline void andc(   Register a, Register s, Register b);
1487   inline void andc_(  Register a, Register s, Register b);
1488   inline void orc(    Register a, Register s, Register b);
1489   inline void orc_(   Register a, Register s, Register b);
1490   inline void extsb(  Register a, Register s);
1491   inline void extsb_( Register a, Register s);
1492   inline void extsh(  Register a, Register s);
1493   inline void extsh_( Register a, Register s);
1494   inline void extsw(  Register a, Register s);
1495   inline void extsw_( Register a, Register s);
1496 
1497   // extended mnemonics
1498   inline void nop();
1499   // NOP for FP and BR units (different versions to allow them to be in one group)
1500   inline void fpnop0();
1501   inline void fpnop1();
1502   inline void brnop0();
1503   inline void brnop1();
1504   inline void brnop2();
1505 
1506   inline void mr(      Register d, Register s);
1507   inline void ori_opt( Register d, int ui16);
1508   inline void oris_opt(Register d, int ui16);
1509 
1510   // endgroup opcode for Power6
1511   inline void endgroup();
1512 
1513   // count instructions
1514   inline void cntlzw(  Register a, Register s);
1515   inline void cntlzw_( Register a, Register s);
1516   inline void cntlzd(  Register a, Register s);
1517   inline void cntlzd_( Register a, Register s);
1518   inline void cnttzw(  Register a, Register s);
1519   inline void cnttzw_( Register a, Register s);
1520   inline void cnttzd(  Register a, Register s);
1521   inline void cnttzd_( Register a, Register s);
1522 
1523   // PPC 1, section 3.3.12, Fixed-Point Rotate and Shift Instructions
1524   inline void sld(     Register a, Register s, Register b);
1525   inline void sld_(    Register a, Register s, Register b);
1526   inline void slw(     Register a, Register s, Register b);
1527   inline void slw_(    Register a, Register s, Register b);
1528   inline void srd(     Register a, Register s, Register b);
1529   inline void srd_(    Register a, Register s, Register b);
1530   inline void srw(     Register a, Register s, Register b);
1531   inline void srw_(    Register a, Register s, Register b);
1532   inline void srad(    Register a, Register s, Register b);
1533   inline void srad_(   Register a, Register s, Register b);
1534   inline void sraw(    Register a, Register s, Register b);
1535   inline void sraw_(   Register a, Register s, Register b);
1536   inline void sradi(   Register a, Register s, int sh6);
1537   inline void sradi_(  Register a, Register s, int sh6);
1538   inline void srawi(   Register a, Register s, int sh5);
1539   inline void srawi_(  Register a, Register s, int sh5);
1540 
1541   // extended mnemonics for Shift Instructions
1542   inline void sldi(    Register a, Register s, int sh6);
1543   inline void sldi_(   Register a, Register s, int sh6);
1544   inline void slwi(    Register a, Register s, int sh5);
1545   inline void slwi_(   Register a, Register s, int sh5);
1546   inline void srdi(    Register a, Register s, int sh6);
1547   inline void srdi_(   Register a, Register s, int sh6);
1548   inline void srwi(    Register a, Register s, int sh5);
1549   inline void srwi_(   Register a, Register s, int sh5);
1550 
1551   inline void clrrdi(  Register a, Register s, int ui6);
1552   inline void clrrdi_( Register a, Register s, int ui6);
1553   inline void clrldi(  Register a, Register s, int ui6);
1554   inline void clrldi_( Register a, Register s, int ui6);
1555   inline void clrlsldi(Register a, Register s, int clrl6, int shl6);
1556   inline void clrlsldi_(Register a, Register s, int clrl6, int shl6);
1557   inline void extrdi(  Register a, Register s, int n, int b);
1558   // testbit with condition register
1559   inline void testbitdi(ConditionRegister cr, Register a, Register s, int ui6);
1560 
1561   // rotate instructions
1562   inline void rotldi(  Register a, Register s, int n);
1563   inline void rotrdi(  Register a, Register s, int n);
1564   inline void rotlwi(  Register a, Register s, int n);
1565   inline void rotrwi(  Register a, Register s, int n);
1566 
1567   // Rotate Instructions
1568   inline void rldic(   Register a, Register s, int sh6, int mb6);
1569   inline void rldic_(  Register a, Register s, int sh6, int mb6);
1570   inline void rldicr(  Register a, Register s, int sh6, int mb6);
1571   inline void rldicr_( Register a, Register s, int sh6, int mb6);
1572   inline void rldicl(  Register a, Register s, int sh6, int mb6);
1573   inline void rldicl_( Register a, Register s, int sh6, int mb6);
1574   inline void rlwinm(  Register a, Register s, int sh5, int mb5, int me5);
1575   inline void rlwinm_( Register a, Register s, int sh5, int mb5, int me5);
1576   inline void rldimi(  Register a, Register s, int sh6, int mb6);
1577   inline void rldimi_( Register a, Register s, int sh6, int mb6);
1578   inline void rlwimi(  Register a, Register s, int sh5, int mb5, int me5);
1579   inline void insrdi(  Register a, Register s, int n,   int b);
1580   inline void insrwi(  Register a, Register s, int n,   int b);
1581 
1582   // PPC 1, section 3.3.2 Fixed-Point Load Instructions
1583   // 4 bytes
1584   inline void lwzx( Register d, Register s1, Register s2);
1585   inline void lwz(  Register d, int si16,    Register s1);
1586   inline void lwzu( Register d, int si16,    Register s1);
1587 
1588   // 4 bytes
1589   inline void lwax( Register d, Register s1, Register s2);
1590   inline void lwa(  Register d, int si16,    Register s1);
1591 
1592   // 4 bytes reversed
1593   inline void lwbrx( Register d, Register s1, Register s2);
1594 
1595   // 2 bytes
1596   inline void lhzx( Register d, Register s1, Register s2);
1597   inline void lhz(  Register d, int si16,    Register s1);
1598   inline void lhzu( Register d, int si16,    Register s1);
1599 
1600   // 2 bytes reversed
1601   inline void lhbrx( Register d, Register s1, Register s2);
1602 
1603   // 2 bytes
1604   inline void lhax( Register d, Register s1, Register s2);
1605   inline void lha(  Register d, int si16,    Register s1);
1606   inline void lhau( Register d, int si16,    Register s1);
1607 
1608   // 1 byte
1609   inline void lbzx( Register d, Register s1, Register s2);
1610   inline void lbz(  Register d, int si16,    Register s1);
1611   inline void lbzu( Register d, int si16,    Register s1);
1612 
1613   // 8 bytes
1614   inline void ldx(  Register d, Register s1, Register s2);
1615   inline void ld(   Register d, int si16,    Register s1);
1616   inline void ldu(  Register d, int si16,    Register s1);
1617 
1618   // 8 bytes reversed
1619   inline void ldbrx( Register d, Register s1, Register s2);
1620 
1621   // For convenience. Load pointer into d from b+s1.
1622   inline void ld_ptr(Register d, int b, Register s1);
1623   DEBUG_ONLY(inline void ld_ptr(Register d, ByteSize b, Register s1);)
1624 
1625   //  PPC 1, section 3.3.3 Fixed-Point Store Instructions
1626   inline void stwx( Register d, Register s1, Register s2);
1627   inline void stw(  Register d, int si16,    Register s1);
1628   inline void stwu( Register d, int si16,    Register s1);
1629   inline void stwbrx( Register d, Register s1, Register s2);
1630 
1631   inline void sthx( Register d, Register s1, Register s2);
1632   inline void sth(  Register d, int si16,    Register s1);
1633   inline void sthu( Register d, int si16,    Register s1);
1634   inline void sthbrx( Register d, Register s1, Register s2);
1635 
1636   inline void stbx( Register d, Register s1, Register s2);
1637   inline void stb(  Register d, int si16,    Register s1);
1638   inline void stbu( Register d, int si16,    Register s1);
1639 
1640   inline void stdx( Register d, Register s1, Register s2);
1641   inline void std(  Register d, int si16,    Register s1);
1642   inline void stdu( Register d, int si16,    Register s1);
1643   inline void stdux(Register s, Register a,  Register b);
1644   inline void stdbrx( Register d, Register s1, Register s2);
1645 
1646   inline void st_ptr(Register d, int si16,    Register s1);
1647   DEBUG_ONLY(inline void st_ptr(Register d, ByteSize b, Register s1);)
1648 
1649   // PPC 1, section 3.3.13 Move To/From System Register Instructions
1650   inline void mtlr( Register s1);
1651   inline void mflr( Register d);
1652   inline void mtctr(Register s1);
1653   inline void mfctr(Register d);
1654   inline void mtcrf(int fxm, Register s);
1655   inline void mfcr( Register d);
1656   inline void mcrf( ConditionRegister crd, ConditionRegister cra);
1657   inline void mtcr( Register s);
1658   // &gt;= Power9
1659   inline void setb( Register d, ConditionRegister cra);
1660 
1661   // Special purpose registers
1662   // Exception Register
1663   inline void mtxer(Register s1);
1664   inline void mfxer(Register d);
1665   // Vector Register Save Register
1666   inline void mtvrsave(Register s1);
1667   inline void mfvrsave(Register d);
1668   // Timebase
1669   inline void mftb(Register d);
1670   // Introduced with Power 8:
1671   // Data Stream Control Register
1672   inline void mtdscr(Register s1);
1673   inline void mfdscr(Register d );
1674   // Transactional Memory Registers
1675   inline void mftfhar(Register d);
1676   inline void mftfiar(Register d);
1677   inline void mftexasr(Register d);
1678   inline void mftexasru(Register d);
1679 
1680   // TEXASR bit description
1681   enum transaction_failure_reason {
1682     // Upper half (TEXASRU):
1683     tm_failure_code       =  0, // The Failure Code is copied from tabort or treclaim operand.
1684     tm_failure_persistent =  7, // The failure is likely to recur on each execution.
1685     tm_disallowed         =  8, // The instruction is not permitted.
1686     tm_nesting_of         =  9, // The maximum transaction level was exceeded.
1687     tm_footprint_of       = 10, // The tracking limit for transactional storage accesses was exceeded.
1688     tm_self_induced_cf    = 11, // A self-induced conflict occurred in Suspended state.
1689     tm_non_trans_cf       = 12, // A conflict occurred with a non-transactional access by another processor.
1690     tm_trans_cf           = 13, // A conflict occurred with another transaction.
1691     tm_translation_cf     = 14, // A conflict occurred with a TLB invalidation.
1692     tm_inst_fetch_cf      = 16, // An instruction fetch was performed from a block that was previously written transactionally.
1693     tm_tabort             = 31, // Termination was caused by the execution of an abort instruction.
1694     // Lower half:
1695     tm_suspended          = 32, // Failure was recorded in Suspended state.
1696     tm_failure_summary    = 36, // Failure has been detected and recorded.
1697     tm_tfiar_exact        = 37, // Value in the TFIAR is exact.
1698     tm_rot                = 38, // Rollback-only transaction.
1699     tm_transaction_level  = 52, // Transaction level (nesting depth + 1).
1700   };
1701 
1702   // PPC 1, section 2.4.1 Branch Instructions
1703   inline void b(  address a, relocInfo::relocType rt = relocInfo::none);
1704   inline void b(  Label&amp; L);
1705   inline void bl( address a, relocInfo::relocType rt = relocInfo::none);
1706   inline void bl( Label&amp; L);
1707   inline void bc( int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1708   inline void bc( int boint, int biint, Label&amp; L);
1709   inline void bcl(int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1710   inline void bcl(int boint, int biint, Label&amp; L);
1711 
1712   inline void bclr(  int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1713   inline void bclrl( int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1714   inline void bcctr( int boint, int biint, int bhint = bhintbhBCCTRisNotReturnButSame,
1715                          relocInfo::relocType rt = relocInfo::none);
1716   inline void bcctrl(int boint, int biint, int bhint = bhintbhBCLRisReturn,
1717                          relocInfo::relocType rt = relocInfo::none);
1718 
1719   // helper function for b, bcxx
1720   inline bool is_within_range_of_b(address a, address pc);
1721   inline bool is_within_range_of_bcxx(address a, address pc);
1722 
1723   // get the destination of a bxx branch (b, bl, ba, bla)
1724   static inline address  bxx_destination(address baddr);
1725   static inline address  bxx_destination(int instr, address pc);
1726   static inline intptr_t bxx_destination_offset(int instr, intptr_t bxx_pos);
1727 
1728   // extended mnemonics for branch instructions
1729   inline void blt(ConditionRegister crx, Label&amp; L);
1730   inline void bgt(ConditionRegister crx, Label&amp; L);
1731   inline void beq(ConditionRegister crx, Label&amp; L);
1732   inline void bso(ConditionRegister crx, Label&amp; L);
1733   inline void bge(ConditionRegister crx, Label&amp; L);
1734   inline void ble(ConditionRegister crx, Label&amp; L);
1735   inline void bne(ConditionRegister crx, Label&amp; L);
1736   inline void bns(ConditionRegister crx, Label&amp; L);
1737 
1738   // Branch instructions with static prediction hints.
1739   inline void blt_predict_taken(    ConditionRegister crx, Label&amp; L);
1740   inline void bgt_predict_taken(    ConditionRegister crx, Label&amp; L);
1741   inline void beq_predict_taken(    ConditionRegister crx, Label&amp; L);
1742   inline void bso_predict_taken(    ConditionRegister crx, Label&amp; L);
1743   inline void bge_predict_taken(    ConditionRegister crx, Label&amp; L);
1744   inline void ble_predict_taken(    ConditionRegister crx, Label&amp; L);
1745   inline void bne_predict_taken(    ConditionRegister crx, Label&amp; L);
1746   inline void bns_predict_taken(    ConditionRegister crx, Label&amp; L);
1747   inline void blt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1748   inline void bgt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1749   inline void beq_predict_not_taken(ConditionRegister crx, Label&amp; L);
1750   inline void bso_predict_not_taken(ConditionRegister crx, Label&amp; L);
1751   inline void bge_predict_not_taken(ConditionRegister crx, Label&amp; L);
1752   inline void ble_predict_not_taken(ConditionRegister crx, Label&amp; L);
1753   inline void bne_predict_not_taken(ConditionRegister crx, Label&amp; L);
1754   inline void bns_predict_not_taken(ConditionRegister crx, Label&amp; L);
1755 
1756   // for use in conjunction with testbitdi:
1757   inline void btrue( ConditionRegister crx, Label&amp; L);
1758   inline void bfalse(ConditionRegister crx, Label&amp; L);
1759 
1760   inline void bltl(ConditionRegister crx, Label&amp; L);
1761   inline void bgtl(ConditionRegister crx, Label&amp; L);
1762   inline void beql(ConditionRegister crx, Label&amp; L);
1763   inline void bsol(ConditionRegister crx, Label&amp; L);
1764   inline void bgel(ConditionRegister crx, Label&amp; L);
1765   inline void blel(ConditionRegister crx, Label&amp; L);
1766   inline void bnel(ConditionRegister crx, Label&amp; L);
1767   inline void bnsl(ConditionRegister crx, Label&amp; L);
1768 
1769   // extended mnemonics for Branch Instructions via LR
1770   // We use `blr&#39; for returns.
1771   inline void blr(relocInfo::relocType rt = relocInfo::none);
1772 
1773   // extended mnemonics for Branch Instructions with CTR
1774   // bdnz means `decrement CTR and jump to L if CTR is not zero&#39;
1775   inline void bdnz(Label&amp; L);
1776   // Decrement and branch if result is zero.
1777   inline void bdz(Label&amp; L);
1778   // we use `bctr[l]&#39; for jumps/calls in function descriptor glue
1779   // code, e.g. calls to runtime functions
1780   inline void bctr( relocInfo::relocType rt = relocInfo::none);
1781   inline void bctrl(relocInfo::relocType rt = relocInfo::none);
1782   // conditional jumps/branches via CTR
1783   inline void beqctr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1784   inline void beqctrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1785   inline void bnectr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1786   inline void bnectrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1787 
1788   // condition register logic instructions
1789   // NOTE: There&#39;s a preferred form: d and s2 should point into the same condition register.
1790   inline void crand( int d, int s1, int s2);
1791   inline void crnand(int d, int s1, int s2);
1792   inline void cror(  int d, int s1, int s2);
1793   inline void crxor( int d, int s1, int s2);
1794   inline void crnor( int d, int s1, int s2);
1795   inline void creqv( int d, int s1, int s2);
1796   inline void crandc(int d, int s1, int s2);
1797   inline void crorc( int d, int s1, int s2);
1798 
1799   // More convenient version.
1800   int condition_register_bit(ConditionRegister cr, Condition c) {
1801     return 4 * (int)(intptr_t)cr + c;
1802   }
1803   void crand( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1804   void crnand(ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1805   void cror(  ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1806   void crxor( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1807   void crnor( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1808   void creqv( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1809   void crandc(ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1810   void crorc( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1811 
1812   // icache and dcache related instructions
1813   inline void icbi(  Register s1, Register s2);
1814   //inline void dcba(Register s1, Register s2); // Instruction for embedded processor only.
1815   inline void dcbz(  Register s1, Register s2);
1816   inline void dcbst( Register s1, Register s2);
1817   inline void dcbf(  Register s1, Register s2);
1818 
1819   enum ct_cache_specification {
1820     ct_primary_cache   = 0,
1821     ct_secondary_cache = 2
1822   };
1823   // dcache read hint
1824   inline void dcbt(    Register s1, Register s2);
1825   inline void dcbtct(  Register s1, Register s2, int ct);
1826   inline void dcbtds(  Register s1, Register s2, int ds);
1827   // dcache write hint
1828   inline void dcbtst(  Register s1, Register s2);
1829   inline void dcbtstct(Register s1, Register s2, int ct);
1830 
1831   //  machine barrier instructions:
1832   //
1833   //  - sync    two-way memory barrier, aka fence
1834   //  - lwsync  orders  Store|Store,
1835   //                     Load|Store,
1836   //                     Load|Load,
1837   //            but not Store|Load
1838   //  - eieio   orders memory accesses for device memory (only)
1839   //  - isync   invalidates speculatively executed instructions
1840   //            From the Power ISA 2.06 documentation:
1841   //             &quot;[...] an isync instruction prevents the execution of
1842   //            instructions following the isync until instructions
1843   //            preceding the isync have completed, [...]&quot;
1844   //            From IBM&#39;s AIX assembler reference:
1845   //             &quot;The isync [...] instructions causes the processor to
1846   //            refetch any instructions that might have been fetched
1847   //            prior to the isync instruction. The instruction isync
1848   //            causes the processor to wait for all previous instructions
1849   //            to complete. Then any instructions already fetched are
1850   //            discarded and instruction processing continues in the
1851   //            environment established by the previous instructions.&quot;
1852   //
1853   //  semantic barrier instructions:
1854   //  (as defined in orderAccess.hpp)
1855   //
1856   //  - release  orders Store|Store,       (maps to lwsync)
1857   //                     Load|Store
1858   //  - acquire  orders  Load|Store,       (maps to lwsync)
1859   //                     Load|Load
1860   //  - fence    orders Store|Store,       (maps to sync)
1861   //                     Load|Store,
1862   //                     Load|Load,
1863   //                    Store|Load
1864   //
1865  private:
1866   inline void sync(int l);
1867  public:
1868   inline void sync();
1869   inline void lwsync();
1870   inline void ptesync();
1871   inline void eieio();
1872   inline void isync();
1873   inline void elemental_membar(int e); // Elemental Memory Barriers (&gt;=Power 8)
1874 
1875   // Wait instructions for polling. Attention: May result in SIGILL.
1876   inline void wait();
1877   inline void waitrsv(); // &gt;=Power7
1878 
1879   // atomics
1880   inline void lbarx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1881   inline void lharx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1882   inline void lwarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1883   inline void ldarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1884   inline void lqarx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1885   inline bool lxarx_hint_exclusive_access();
1886   inline void lbarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1887   inline void lharx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1888   inline void lwarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1889   inline void ldarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1890   inline void lqarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1891   inline void stbcx_( Register s, Register a, Register b);
1892   inline void sthcx_( Register s, Register a, Register b);
1893   inline void stwcx_( Register s, Register a, Register b);
1894   inline void stdcx_( Register s, Register a, Register b);
1895   inline void stqcx_( Register s, Register a, Register b);
1896 
1897   // Instructions for adjusting thread priority for simultaneous
1898   // multithreading (SMT) on Power5.
1899  private:
1900   inline void smt_prio_very_low();
1901   inline void smt_prio_medium_high();
1902   inline void smt_prio_high();
1903 
1904  public:
1905   inline void smt_prio_low();
1906   inline void smt_prio_medium_low();
1907   inline void smt_prio_medium();
1908   // &gt;= Power7
1909   inline void smt_yield();
1910   inline void smt_mdoio();
1911   inline void smt_mdoom();
1912   // &gt;= Power8
1913   inline void smt_miso();
1914 
1915   // trap instructions
1916   inline void twi_0(Register a); // for load with acquire semantics use load+twi_0+isync (trap can&#39;t occur)
1917   // NOT FOR DIRECT USE!!
1918  protected:
1919   inline void tdi_unchecked(int tobits, Register a, int si16);
1920   inline void twi_unchecked(int tobits, Register a, int si16);
1921   inline void tdi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1922   inline void twi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1923   inline void td(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1924   inline void tw(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1925 
1926   static bool is_tdi(int x, int tobits, int ra, int si16) {
1927      return (TDI_OPCODE == (x &amp; TDI_OPCODE_MASK))
1928          &amp;&amp; (tobits == inv_to_field(x))
1929          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1930          &amp;&amp; (si16 == inv_si_field(x));
1931   }
1932 
1933   static bool is_twi(int x, int tobits, int ra, int si16) {
1934      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1935          &amp;&amp; (tobits == inv_to_field(x))
1936          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1937          &amp;&amp; (si16 == inv_si_field(x));
1938   }
1939 
1940   static bool is_twi(int x, int tobits, int ra) {
1941      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1942          &amp;&amp; (tobits == inv_to_field(x))
1943          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x));
1944   }
1945 
1946   static bool is_td(int x, int tobits, int ra, int rb) {
1947      return (TD_OPCODE == (x &amp; TD_OPCODE_MASK))
1948          &amp;&amp; (tobits == inv_to_field(x))
1949          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1950          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1951   }
1952 
1953   static bool is_tw(int x, int tobits, int ra, int rb) {
1954      return (TW_OPCODE == (x &amp; TW_OPCODE_MASK))
1955          &amp;&amp; (tobits == inv_to_field(x))
1956          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1957          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1958   }
1959 
1960  public:
1961   // PPC floating point instructions
1962   // PPC 1, section 4.6.2 Floating-Point Load Instructions
1963   inline void lfs(  FloatRegister d, int si16,   Register a);
1964   inline void lfsu( FloatRegister d, int si16,   Register a);
1965   inline void lfsx( FloatRegister d, Register a, Register b);
1966   inline void lfd(  FloatRegister d, int si16,   Register a);
1967   inline void lfdu( FloatRegister d, int si16,   Register a);
1968   inline void lfdx( FloatRegister d, Register a, Register b);
1969 
1970   // PPC 1, section 4.6.3 Floating-Point Store Instructions
1971   inline void stfs(  FloatRegister s, int si16,   Register a);
1972   inline void stfsu( FloatRegister s, int si16,   Register a);
1973   inline void stfsx( FloatRegister s, Register a, Register b);
1974   inline void stfd(  FloatRegister s, int si16,   Register a);
1975   inline void stfdu( FloatRegister s, int si16,   Register a);
1976   inline void stfdx( FloatRegister s, Register a, Register b);
1977 
1978   // PPC 1, section 4.6.4 Floating-Point Move Instructions
1979   inline void fmr(  FloatRegister d, FloatRegister b);
1980   inline void fmr_( FloatRegister d, FloatRegister b);
1981 
1982   //  inline void mffgpr( FloatRegister d, Register b);
1983   //  inline void mftgpr( Register d, FloatRegister b);
1984   inline void cmpb(   Register a, Register s, Register b);
1985   inline void popcntb(Register a, Register s);
1986   inline void popcntw(Register a, Register s);
1987   inline void popcntd(Register a, Register s);
1988 
1989   inline void fneg(  FloatRegister d, FloatRegister b);
1990   inline void fneg_( FloatRegister d, FloatRegister b);
1991   inline void fabs(  FloatRegister d, FloatRegister b);
1992   inline void fabs_( FloatRegister d, FloatRegister b);
1993   inline void fnabs( FloatRegister d, FloatRegister b);
1994   inline void fnabs_(FloatRegister d, FloatRegister b);
1995 
1996   // PPC 1, section 4.6.5.1 Floating-Point Elementary Arithmetic Instructions
1997   inline void fadd(  FloatRegister d, FloatRegister a, FloatRegister b);
1998   inline void fadd_( FloatRegister d, FloatRegister a, FloatRegister b);
1999   inline void fadds( FloatRegister d, FloatRegister a, FloatRegister b);
2000   inline void fadds_(FloatRegister d, FloatRegister a, FloatRegister b);
2001   inline void fsub(  FloatRegister d, FloatRegister a, FloatRegister b);
2002   inline void fsub_( FloatRegister d, FloatRegister a, FloatRegister b);
2003   inline void fsubs( FloatRegister d, FloatRegister a, FloatRegister b);
2004   inline void fsubs_(FloatRegister d, FloatRegister a, FloatRegister b);
2005   inline void fmul(  FloatRegister d, FloatRegister a, FloatRegister c);
2006   inline void fmul_( FloatRegister d, FloatRegister a, FloatRegister c);
2007   inline void fmuls( FloatRegister d, FloatRegister a, FloatRegister c);
2008   inline void fmuls_(FloatRegister d, FloatRegister a, FloatRegister c);
2009   inline void fdiv(  FloatRegister d, FloatRegister a, FloatRegister b);
2010   inline void fdiv_( FloatRegister d, FloatRegister a, FloatRegister b);
2011   inline void fdivs( FloatRegister d, FloatRegister a, FloatRegister b);
2012   inline void fdivs_(FloatRegister d, FloatRegister a, FloatRegister b);
2013 
2014   // Fused multiply-accumulate instructions.
2015   // WARNING: Use only when rounding between the 2 parts is not desired.
2016   // Some floating point tck tests will fail if used incorrectly.
2017   inline void fmadd(   FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2018   inline void fmadd_(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2019   inline void fmadds(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2020   inline void fmadds_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2021   inline void fmsub(   FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2022   inline void fmsub_(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2023   inline void fmsubs(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2024   inline void fmsubs_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2025   inline void fnmadd(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2026   inline void fnmadd_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2027   inline void fnmadds( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2028   inline void fnmadds_(FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2029   inline void fnmsub(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2030   inline void fnmsub_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2031   inline void fnmsubs( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2032   inline void fnmsubs_(FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2033 
2034   // PPC 1, section 4.6.6 Floating-Point Rounding and Conversion Instructions
2035   inline void frsp(  FloatRegister d, FloatRegister b);
2036   inline void fctid( FloatRegister d, FloatRegister b);
2037   inline void fctidz(FloatRegister d, FloatRegister b);
2038   inline void fctiw( FloatRegister d, FloatRegister b);
2039   inline void fctiwz(FloatRegister d, FloatRegister b);
2040   inline void fcfid( FloatRegister d, FloatRegister b);
2041   inline void fcfids(FloatRegister d, FloatRegister b);
2042 
2043   // PPC 1, section 4.6.7 Floating-Point Compare Instructions
2044   inline void fcmpu( ConditionRegister crx, FloatRegister a, FloatRegister b);
2045 
2046   inline void fsqrt( FloatRegister d, FloatRegister b);
2047   inline void fsqrts(FloatRegister d, FloatRegister b);
2048 
2049   // Vector instructions for &gt;= Power6.
2050   inline void lvebx(    VectorRegister d, Register s1, Register s2);
2051   inline void lvehx(    VectorRegister d, Register s1, Register s2);
2052   inline void lvewx(    VectorRegister d, Register s1, Register s2);
2053   inline void lvx(      VectorRegister d, Register s1, Register s2);
2054   inline void lvxl(     VectorRegister d, Register s1, Register s2);
2055   inline void stvebx(   VectorRegister d, Register s1, Register s2);
2056   inline void stvehx(   VectorRegister d, Register s1, Register s2);
2057   inline void stvewx(   VectorRegister d, Register s1, Register s2);
2058   inline void stvx(     VectorRegister d, Register s1, Register s2);
2059   inline void stvxl(    VectorRegister d, Register s1, Register s2);
2060   inline void lvsl(     VectorRegister d, Register s1, Register s2);
2061   inline void lvsr(     VectorRegister d, Register s1, Register s2);
2062   inline void vpkpx(    VectorRegister d, VectorRegister a, VectorRegister b);
2063   inline void vpkshss(  VectorRegister d, VectorRegister a, VectorRegister b);
2064   inline void vpkswss(  VectorRegister d, VectorRegister a, VectorRegister b);
2065   inline void vpkshus(  VectorRegister d, VectorRegister a, VectorRegister b);
2066   inline void vpkswus(  VectorRegister d, VectorRegister a, VectorRegister b);
2067   inline void vpkuhum(  VectorRegister d, VectorRegister a, VectorRegister b);
2068   inline void vpkuwum(  VectorRegister d, VectorRegister a, VectorRegister b);
2069   inline void vpkuhus(  VectorRegister d, VectorRegister a, VectorRegister b);
2070   inline void vpkuwus(  VectorRegister d, VectorRegister a, VectorRegister b);
2071   inline void vupkhpx(  VectorRegister d, VectorRegister b);
2072   inline void vupkhsb(  VectorRegister d, VectorRegister b);
2073   inline void vupkhsh(  VectorRegister d, VectorRegister b);
2074   inline void vupklpx(  VectorRegister d, VectorRegister b);
2075   inline void vupklsb(  VectorRegister d, VectorRegister b);
2076   inline void vupklsh(  VectorRegister d, VectorRegister b);
2077   inline void vmrghb(   VectorRegister d, VectorRegister a, VectorRegister b);
2078   inline void vmrghw(   VectorRegister d, VectorRegister a, VectorRegister b);
2079   inline void vmrghh(   VectorRegister d, VectorRegister a, VectorRegister b);
2080   inline void vmrglb(   VectorRegister d, VectorRegister a, VectorRegister b);
2081   inline void vmrglw(   VectorRegister d, VectorRegister a, VectorRegister b);
2082   inline void vmrglh(   VectorRegister d, VectorRegister a, VectorRegister b);
2083   inline void vsplt(    VectorRegister d, int ui4,          VectorRegister b);
2084   inline void vsplth(   VectorRegister d, int ui3,          VectorRegister b);
2085   inline void vspltw(   VectorRegister d, int ui2,          VectorRegister b);
2086   inline void vspltisb( VectorRegister d, int si5);
2087   inline void vspltish( VectorRegister d, int si5);
2088   inline void vspltisw( VectorRegister d, int si5);
2089   inline void vperm(    VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2090   inline void vsel(     VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2091   inline void vsl(      VectorRegister d, VectorRegister a, VectorRegister b);
2092   inline void vsldoi(   VectorRegister d, VectorRegister a, VectorRegister b, int ui4);
2093   inline void vslo(     VectorRegister d, VectorRegister a, VectorRegister b);
2094   inline void vsr(      VectorRegister d, VectorRegister a, VectorRegister b);
2095   inline void vsro(     VectorRegister d, VectorRegister a, VectorRegister b);
2096   inline void vaddcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
2097   inline void vaddshs(  VectorRegister d, VectorRegister a, VectorRegister b);
2098   inline void vaddsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
2099   inline void vaddsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2100   inline void vaddubm(  VectorRegister d, VectorRegister a, VectorRegister b);
2101   inline void vadduwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2102   inline void vadduhm(  VectorRegister d, VectorRegister a, VectorRegister b);
2103   inline void vaddudm(  VectorRegister d, VectorRegister a, VectorRegister b);
2104   inline void vaddubs(  VectorRegister d, VectorRegister a, VectorRegister b);
2105   inline void vadduws(  VectorRegister d, VectorRegister a, VectorRegister b);
2106   inline void vadduhs(  VectorRegister d, VectorRegister a, VectorRegister b);
2107   inline void vaddfp(   VectorRegister d, VectorRegister a, VectorRegister b);
2108   inline void vsubcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
2109   inline void vsubshs(  VectorRegister d, VectorRegister a, VectorRegister b);
2110   inline void vsubsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
2111   inline void vsubsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2112   inline void vsububm(  VectorRegister d, VectorRegister a, VectorRegister b);
2113   inline void vsubuwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2114   inline void vsubuhm(  VectorRegister d, VectorRegister a, VectorRegister b);
2115   inline void vsubudm(  VectorRegister d, VectorRegister a, VectorRegister b);
2116   inline void vsububs(  VectorRegister d, VectorRegister a, VectorRegister b);
2117   inline void vsubuws(  VectorRegister d, VectorRegister a, VectorRegister b);
2118   inline void vsubuhs(  VectorRegister d, VectorRegister a, VectorRegister b);
2119   inline void vsubfp(   VectorRegister d, VectorRegister a, VectorRegister b);
2120   inline void vmulesb(  VectorRegister d, VectorRegister a, VectorRegister b);
2121   inline void vmuleub(  VectorRegister d, VectorRegister a, VectorRegister b);
2122   inline void vmulesh(  VectorRegister d, VectorRegister a, VectorRegister b);
2123   inline void vmuleuh(  VectorRegister d, VectorRegister a, VectorRegister b);
2124   inline void vmulosb(  VectorRegister d, VectorRegister a, VectorRegister b);
2125   inline void vmuloub(  VectorRegister d, VectorRegister a, VectorRegister b);
2126   inline void vmulosh(  VectorRegister d, VectorRegister a, VectorRegister b);
2127   inline void vmulosw(  VectorRegister d, VectorRegister a, VectorRegister b);
2128   inline void vmulouh(  VectorRegister d, VectorRegister a, VectorRegister b);
2129   inline void vmuluwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2130   inline void vmhaddshs(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2131   inline void vmhraddshs(VectorRegister d,VectorRegister a, VectorRegister b, VectorRegister c);
2132   inline void vmladduhm(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2133   inline void vmsubuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2134   inline void vmsummbm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2135   inline void vmsumshm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2136   inline void vmsumshs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2137   inline void vmsumuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2138   inline void vmsumuhs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2139   inline void vmaddfp(  VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2140   inline void vsumsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2141   inline void vsum2sws( VectorRegister d, VectorRegister a, VectorRegister b);
2142   inline void vsum4sbs( VectorRegister d, VectorRegister a, VectorRegister b);
2143   inline void vsum4ubs( VectorRegister d, VectorRegister a, VectorRegister b);
2144   inline void vsum4shs( VectorRegister d, VectorRegister a, VectorRegister b);
2145   inline void vavgsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2146   inline void vavgsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2147   inline void vavgsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2148   inline void vavgub(   VectorRegister d, VectorRegister a, VectorRegister b);
2149   inline void vavguw(   VectorRegister d, VectorRegister a, VectorRegister b);
2150   inline void vavguh(   VectorRegister d, VectorRegister a, VectorRegister b);
2151   inline void vmaxsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2152   inline void vmaxsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2153   inline void vmaxsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2154   inline void vmaxub(   VectorRegister d, VectorRegister a, VectorRegister b);
2155   inline void vmaxuw(   VectorRegister d, VectorRegister a, VectorRegister b);
2156   inline void vmaxuh(   VectorRegister d, VectorRegister a, VectorRegister b);
2157   inline void vminsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2158   inline void vminsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2159   inline void vminsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2160   inline void vminub(   VectorRegister d, VectorRegister a, VectorRegister b);
2161   inline void vminuw(   VectorRegister d, VectorRegister a, VectorRegister b);
2162   inline void vminuh(   VectorRegister d, VectorRegister a, VectorRegister b);
2163   inline void vcmpequb( VectorRegister d, VectorRegister a, VectorRegister b);
2164   inline void vcmpequh( VectorRegister d, VectorRegister a, VectorRegister b);
2165   inline void vcmpequw( VectorRegister d, VectorRegister a, VectorRegister b);
2166   inline void vcmpgtsh( VectorRegister d, VectorRegister a, VectorRegister b);
2167   inline void vcmpgtsb( VectorRegister d, VectorRegister a, VectorRegister b);
2168   inline void vcmpgtsw( VectorRegister d, VectorRegister a, VectorRegister b);
2169   inline void vcmpgtub( VectorRegister d, VectorRegister a, VectorRegister b);
2170   inline void vcmpgtuh( VectorRegister d, VectorRegister a, VectorRegister b);
2171   inline void vcmpgtuw( VectorRegister d, VectorRegister a, VectorRegister b);
2172   inline void vcmpequb_(VectorRegister d, VectorRegister a, VectorRegister b);
2173   inline void vcmpequh_(VectorRegister d, VectorRegister a, VectorRegister b);
2174   inline void vcmpequw_(VectorRegister d, VectorRegister a, VectorRegister b);
2175   inline void vcmpgtsh_(VectorRegister d, VectorRegister a, VectorRegister b);
2176   inline void vcmpgtsb_(VectorRegister d, VectorRegister a, VectorRegister b);
2177   inline void vcmpgtsw_(VectorRegister d, VectorRegister a, VectorRegister b);
2178   inline void vcmpgtub_(VectorRegister d, VectorRegister a, VectorRegister b);
2179   inline void vcmpgtuh_(VectorRegister d, VectorRegister a, VectorRegister b);
2180   inline void vcmpgtuw_(VectorRegister d, VectorRegister a, VectorRegister b);
2181   inline void vand(     VectorRegister d, VectorRegister a, VectorRegister b);
2182   inline void vandc(    VectorRegister d, VectorRegister a, VectorRegister b);
2183   inline void vnor(     VectorRegister d, VectorRegister a, VectorRegister b);
2184   inline void vor(      VectorRegister d, VectorRegister a, VectorRegister b);
2185   inline void vmr(      VectorRegister d, VectorRegister a);
2186   inline void vxor(     VectorRegister d, VectorRegister a, VectorRegister b);
2187   inline void vrld(     VectorRegister d, VectorRegister a, VectorRegister b);
2188   inline void vrlb(     VectorRegister d, VectorRegister a, VectorRegister b);
2189   inline void vrlw(     VectorRegister d, VectorRegister a, VectorRegister b);
2190   inline void vrlh(     VectorRegister d, VectorRegister a, VectorRegister b);
2191   inline void vslb(     VectorRegister d, VectorRegister a, VectorRegister b);
2192   inline void vskw(     VectorRegister d, VectorRegister a, VectorRegister b);
2193   inline void vslh(     VectorRegister d, VectorRegister a, VectorRegister b);
2194   inline void vsrb(     VectorRegister d, VectorRegister a, VectorRegister b);
2195   inline void vsrw(     VectorRegister d, VectorRegister a, VectorRegister b);
2196   inline void vsrh(     VectorRegister d, VectorRegister a, VectorRegister b);
2197   inline void vsrab(    VectorRegister d, VectorRegister a, VectorRegister b);
2198   inline void vsraw(    VectorRegister d, VectorRegister a, VectorRegister b);
2199   inline void vsrah(    VectorRegister d, VectorRegister a, VectorRegister b);
2200   inline void vpopcntw( VectorRegister d, VectorRegister b);
2201   // Vector Floating-Point not implemented yet
2202   inline void mtvscr(   VectorRegister b);
2203   inline void mfvscr(   VectorRegister d);
2204 
2205   // Vector-Scalar (VSX) instructions.
2206   inline void lxvd2x(   VectorSRegister d, Register a);
2207   inline void lxvd2x(   VectorSRegister d, Register a, Register b);
2208   inline void stxvd2x(  VectorSRegister d, Register a);
2209   inline void stxvd2x(  VectorSRegister d, Register a, Register b);
2210   inline void mtvrwz(   VectorRegister  d, Register a);
2211   inline void mfvrwz(   Register        a, VectorRegister d);
2212   inline void mtvrd(    VectorRegister  d, Register a);
2213   inline void mfvrd(    Register        a, VectorRegister d);
2214   inline void xxpermdi( VectorSRegister d, VectorSRegister a, VectorSRegister b, int dm);
2215   inline void xxmrghw(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2216   inline void xxmrglw(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2217   inline void mtvsrd(   VectorSRegister d, Register a);
2218   inline void mtvsrwz(  VectorSRegister d, Register a);
2219   inline void xxspltw(  VectorSRegister d, VectorSRegister b, int ui2);
2220   inline void xxlor(    VectorSRegister d, VectorSRegister a, VectorSRegister b);
2221   inline void xxlxor(   VectorSRegister d, VectorSRegister a, VectorSRegister b);
2222   inline void xxleqv(   VectorSRegister d, VectorSRegister a, VectorSRegister b);
2223   inline void xvdivsp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2224   inline void xvdivdp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2225   inline void xvabssp(  VectorSRegister d, VectorSRegister b);
2226   inline void xvabsdp(  VectorSRegister d, VectorSRegister b);
2227   inline void xvnegsp(  VectorSRegister d, VectorSRegister b);
2228   inline void xvnegdp(  VectorSRegister d, VectorSRegister b);
2229   inline void xvsqrtsp( VectorSRegister d, VectorSRegister b);
2230   inline void xvsqrtdp( VectorSRegister d, VectorSRegister b);
2231   inline void xscvdpspn(VectorSRegister d, VectorSRegister b);
2232   inline void xvadddp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2233   inline void xvsubdp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2234   inline void xvmulsp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2235   inline void xvmuldp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2236   inline void xvmaddasp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2237   inline void xvmaddadp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2238   inline void xvmsubasp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2239   inline void xvmsubadp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2240   inline void xvnmsubasp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2241   inline void xvnmsubadp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2242 
2243   // VSX Extended Mnemonics
2244   inline void xxspltd(  VectorSRegister d, VectorSRegister a, int x);
2245   inline void xxmrghd(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2246   inline void xxmrgld(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2247   inline void xxswapd(  VectorSRegister d, VectorSRegister a);
2248 
2249   // Vector-Scalar (VSX) instructions.
2250   inline void mtfprd(   FloatRegister   d, Register a);
2251   inline void mtfprwa(  FloatRegister   d, Register a);
2252   inline void mffprd(   Register        a, FloatRegister d);
2253 
2254   // Deliver A Random Number (introduced with POWER9)
2255   inline void darn( Register d, int l = 1 /*L=CRN*/);
2256 
2257   // AES (introduced with Power 8)
2258   inline void vcipher(     VectorRegister d, VectorRegister a, VectorRegister b);
2259   inline void vcipherlast( VectorRegister d, VectorRegister a, VectorRegister b);
2260   inline void vncipher(    VectorRegister d, VectorRegister a, VectorRegister b);
2261   inline void vncipherlast(VectorRegister d, VectorRegister a, VectorRegister b);
2262   inline void vsbox(       VectorRegister d, VectorRegister a);
2263 
2264   // SHA (introduced with Power 8)
2265   inline void vshasigmad(VectorRegister d, VectorRegister a, bool st, int six);
2266   inline void vshasigmaw(VectorRegister d, VectorRegister a, bool st, int six);
2267 
2268   // Vector Binary Polynomial Multiplication (introduced with Power 8)
2269   inline void vpmsumb(  VectorRegister d, VectorRegister a, VectorRegister b);
2270   inline void vpmsumd(  VectorRegister d, VectorRegister a, VectorRegister b);
2271   inline void vpmsumh(  VectorRegister d, VectorRegister a, VectorRegister b);
2272   inline void vpmsumw(  VectorRegister d, VectorRegister a, VectorRegister b);
2273 
2274   // Vector Permute and Xor (introduced with Power 8)
2275   inline void vpermxor( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2276 
2277   // Transactional Memory instructions (introduced with Power 8)
2278   inline void tbegin_();    // R=0
2279   inline void tbeginrot_(); // R=1 Rollback-Only Transaction
2280   inline void tend_();    // A=0
2281   inline void tendall_(); // A=1
2282   inline void tabort_();
2283   inline void tabort_(Register a);
2284   inline void tabortwc_(int t, Register a, Register b);
2285   inline void tabortwci_(int t, Register a, int si);
2286   inline void tabortdc_(int t, Register a, Register b);
2287   inline void tabortdci_(int t, Register a, int si);
2288   inline void tsuspend_(); // tsr with L=0
2289   inline void tresume_();  // tsr with L=1
2290   inline void tcheck(int f);
2291 
2292   static bool is_tbegin(int x) {
2293     return TBEGIN_OPCODE == (x &amp; (0x3f &lt;&lt; OPCODE_SHIFT | 0x3ff &lt;&lt; 1));
2294   }
2295 
2296   // The following encoders use r0 as second operand. These instructions
2297   // read r0 as &#39;0&#39;.
2298   inline void lwzx( Register d, Register s2);
2299   inline void lwz(  Register d, int si16);
2300   inline void lwax( Register d, Register s2);
2301   inline void lwa(  Register d, int si16);
2302   inline void lwbrx(Register d, Register s2);
2303   inline void lhzx( Register d, Register s2);
2304   inline void lhz(  Register d, int si16);
2305   inline void lhax( Register d, Register s2);
2306   inline void lha(  Register d, int si16);
2307   inline void lhbrx(Register d, Register s2);
2308   inline void lbzx( Register d, Register s2);
2309   inline void lbz(  Register d, int si16);
2310   inline void ldx(  Register d, Register s2);
2311   inline void ld(   Register d, int si16);
2312   inline void ldbrx(Register d, Register s2);
2313   inline void stwx( Register d, Register s2);
2314   inline void stw(  Register d, int si16);
2315   inline void stwbrx( Register d, Register s2);
2316   inline void sthx( Register d, Register s2);
2317   inline void sth(  Register d, int si16);
2318   inline void sthbrx( Register d, Register s2);
2319   inline void stbx( Register d, Register s2);
2320   inline void stb(  Register d, int si16);
2321   inline void stdx( Register d, Register s2);
2322   inline void std(  Register d, int si16);
2323   inline void stdbrx( Register d, Register s2);
2324 
2325   // PPC 2, section 3.2.1 Instruction Cache Instructions
2326   inline void icbi(    Register s2);
2327   // PPC 2, section 3.2.2 Data Cache Instructions
2328   //inlinevoid dcba(   Register s2); // Instruction for embedded processor only.
2329   inline void dcbz(    Register s2);
2330   inline void dcbst(   Register s2);
2331   inline void dcbf(    Register s2);
2332   // dcache read hint
2333   inline void dcbt(    Register s2);
2334   inline void dcbtct(  Register s2, int ct);
2335   inline void dcbtds(  Register s2, int ds);
2336   // dcache write hint
2337   inline void dcbtst(  Register s2);
2338   inline void dcbtstct(Register s2, int ct);
2339 
2340   // Atomics: use ra0mem to disallow R0 as base.
2341   inline void lbarx_unchecked(Register d, Register b, int eh1);
2342   inline void lharx_unchecked(Register d, Register b, int eh1);
2343   inline void lwarx_unchecked(Register d, Register b, int eh1);
2344   inline void ldarx_unchecked(Register d, Register b, int eh1);
2345   inline void lqarx_unchecked(Register d, Register b, int eh1);
2346   inline void lbarx( Register d, Register b, bool hint_exclusive_access);
2347   inline void lharx( Register d, Register b, bool hint_exclusive_access);
2348   inline void lwarx( Register d, Register b, bool hint_exclusive_access);
2349   inline void ldarx( Register d, Register b, bool hint_exclusive_access);
2350   inline void lqarx( Register d, Register b, bool hint_exclusive_access);
2351   inline void stbcx_(Register s, Register b);
2352   inline void sthcx_(Register s, Register b);
2353   inline void stwcx_(Register s, Register b);
2354   inline void stdcx_(Register s, Register b);
2355   inline void stqcx_(Register s, Register b);
2356   inline void lfs(   FloatRegister d, int si16);
2357   inline void lfsx(  FloatRegister d, Register b);
2358   inline void lfd(   FloatRegister d, int si16);
2359   inline void lfdx(  FloatRegister d, Register b);
2360   inline void stfs(  FloatRegister s, int si16);
2361   inline void stfsx( FloatRegister s, Register b);
2362   inline void stfd(  FloatRegister s, int si16);
2363   inline void stfdx( FloatRegister s, Register b);
2364   inline void lvebx( VectorRegister d, Register s2);
2365   inline void lvehx( VectorRegister d, Register s2);
2366   inline void lvewx( VectorRegister d, Register s2);
2367   inline void lvx(   VectorRegister d, Register s2);
2368   inline void lvxl(  VectorRegister d, Register s2);
2369   inline void stvebx(VectorRegister d, Register s2);
2370   inline void stvehx(VectorRegister d, Register s2);
2371   inline void stvewx(VectorRegister d, Register s2);
2372   inline void stvx(  VectorRegister d, Register s2);
2373   inline void stvxl( VectorRegister d, Register s2);
2374   inline void lvsl(  VectorRegister d, Register s2);
2375   inline void lvsr(  VectorRegister d, Register s2);
2376 
2377   // Endianess specific concatenation of 2 loaded vectors.
2378   inline void load_perm(VectorRegister perm, Register addr);
2379   inline void vec_perm(VectorRegister first_dest, VectorRegister second, VectorRegister perm);
2380   inline void vec_perm(VectorRegister dest, VectorRegister first, VectorRegister second, VectorRegister perm);
2381 
2382   // RegisterOrConstant versions.
2383   // These emitters choose between the versions using two registers and
2384   // those with register and immediate, depending on the content of roc.
2385   // If the constant is not encodable as immediate, instructions to
2386   // load the constant are emitted beforehand. Store instructions need a
2387   // tmp reg if the constant is not encodable as immediate.
2388   // Size unpredictable.
2389   void ld(  Register d, RegisterOrConstant roc, Register s1 = noreg);
2390   void lwa( Register d, RegisterOrConstant roc, Register s1 = noreg);
2391   void lwz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2392   void lha( Register d, RegisterOrConstant roc, Register s1 = noreg);
2393   void lhz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2394   void lbz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2395   void std( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2396   void stw( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2397   void sth( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2398   void stb( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2399   void add( Register d, RegisterOrConstant roc, Register s1);
2400   void subf(Register d, RegisterOrConstant roc, Register s1);
2401   void cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1);
2402   // Load pointer d from s1+roc.
2403   void ld_ptr(Register d, RegisterOrConstant roc, Register s1 = noreg) { ld(d, roc, s1); }
2404 
2405   // Emit several instructions to load a 64 bit constant. This issues a fixed
2406   // instruction pattern so that the constant can be patched later on.
2407   enum {
2408     load_const_size = 5 * BytesPerInstWord
2409   };
2410          void load_const(Register d, long a,            Register tmp = noreg);
2411   inline void load_const(Register d, void* a,           Register tmp = noreg);
2412   inline void load_const(Register d, Label&amp; L,          Register tmp = noreg);
2413   inline void load_const(Register d, AddressLiteral&amp; a, Register tmp = noreg);
2414   inline void load_const32(Register d, int i); // load signed int (patchable)
2415 
2416   // Load a 64 bit constant, optimized, not identifyable.
2417   // Tmp can be used to increase ILP. Set return_simm16_rest = true to get a
2418   // 16 bit immediate offset. This is useful if the offset can be encoded in
2419   // a succeeding instruction.
2420          int load_const_optimized(Register d, long a,  Register tmp = noreg, bool return_simm16_rest = false);
2421   inline int load_const_optimized(Register d, void* a, Register tmp = noreg, bool return_simm16_rest = false) {
2422     return load_const_optimized(d, (long)(unsigned long)a, tmp, return_simm16_rest);
2423   }
2424 
2425   // If return_simm16_rest, the return value needs to get added afterwards.
2426          int add_const_optimized(Register d, Register s, long x, Register tmp = R0, bool return_simm16_rest = false);
2427   inline int add_const_optimized(Register d, Register s, void* a, Register tmp = R0, bool return_simm16_rest = false) {
2428     return add_const_optimized(d, s, (long)(unsigned long)a, tmp, return_simm16_rest);
2429   }
2430 
2431   // If return_simm16_rest, the return value needs to get added afterwards.
2432   inline int sub_const_optimized(Register d, Register s, long x, Register tmp = R0, bool return_simm16_rest = false) {
2433     return add_const_optimized(d, s, -x, tmp, return_simm16_rest);
2434   }
2435   inline int sub_const_optimized(Register d, Register s, void* a, Register tmp = R0, bool return_simm16_rest = false) {
2436     return sub_const_optimized(d, s, (long)(unsigned long)a, tmp, return_simm16_rest);
2437   }
2438 
2439   // Creation
2440   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
2441 #ifdef CHECK_DELAY
2442     delay_state = no_delay;
2443 #endif
2444   }
2445 
2446   // Testing
2447 #ifndef PRODUCT
2448   void test_asm();
2449 #endif
2450 };
2451 
2452 
2453 #endif // CPU_PPC_ASSEMBLER_PPC_HPP
    </pre>
  </body>
</html>
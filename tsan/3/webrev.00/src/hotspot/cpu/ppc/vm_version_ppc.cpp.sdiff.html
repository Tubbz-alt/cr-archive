<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/vm_version_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vm_version_ext_ppc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_ppc.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/vm_version_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2012, 2018, SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;asm/macroAssembler.inline.hpp&quot;
  30 #include &quot;compiler/disassembler.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;runtime/java.hpp&quot;
  33 #include &quot;runtime/os.hpp&quot;
  34 #include &quot;runtime/stubCodeGenerator.hpp&quot;

  35 #include &quot;utilities/align.hpp&quot;
  36 #include &quot;utilities/defaultStream.hpp&quot;
  37 #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-modified">  38 #include &quot;vm_version_ppc.hpp&quot;</span>
  39 
  40 #include &lt;sys/sysinfo.h&gt;



  41 
  42 #if defined(LINUX) &amp;&amp; defined(VM_LITTLE_ENDIAN)
  43 #include &lt;sys/auxv.h&gt;
  44 
  45 #ifndef PPC_FEATURE2_HTM_NOSC
  46 #define PPC_FEATURE2_HTM_NOSC (1 &lt;&lt; 24)
  47 #endif
  48 #endif
  49 
  50 bool VM_Version::_is_determine_features_test_running = false;
  51 uint64_t VM_Version::_dscr_val = 0;
  52 
  53 #define MSG(flag)   \
  54   if (flag &amp;&amp; !FLAG_IS_DEFAULT(flag))                                  \
  55       jio_fprintf(defaultStream::error_stream(),                       \
  56                   &quot;warning: -XX:+&quot; #flag &quot; requires -XX:+UseSIGTRAP\n&quot; \
  57                   &quot;         -XX:+&quot; #flag &quot; will be disabled!\n&quot;);
  58 
  59 void VM_Version::initialize() {
  60 
  61   // Test which instructions are supported and measure cache line size.
  62   determine_features();
  63 
  64   // If PowerArchitecturePPC64 hasn&#39;t been specified explicitly determine from features.
  65   if (FLAG_IS_DEFAULT(PowerArchitecturePPC64)) {
  66     if (VM_Version::has_darn()) {
<span class="line-modified">  67       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 9);</span>
  68     } else if (VM_Version::has_lqarx()) {
<span class="line-modified">  69       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 8);</span>
  70     } else if (VM_Version::has_popcntw()) {
<span class="line-modified">  71       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 7);</span>
  72     } else if (VM_Version::has_cmpb()) {
<span class="line-modified">  73       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 6);</span>
  74     } else if (VM_Version::has_popcntb()) {
<span class="line-modified">  75       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 5);</span>
  76     } else {
<span class="line-modified">  77       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 0);</span>
  78     }
  79   }
  80 
  81   bool PowerArchitecturePPC64_ok = false;
  82   switch (PowerArchitecturePPC64) {
  83     case 9: if (!VM_Version::has_darn()   ) break;
  84     case 8: if (!VM_Version::has_lqarx()  ) break;
  85     case 7: if (!VM_Version::has_popcntw()) break;
  86     case 6: if (!VM_Version::has_cmpb()   ) break;
  87     case 5: if (!VM_Version::has_popcntb()) break;
  88     case 0: PowerArchitecturePPC64_ok = true; break;
  89     default: break;
  90   }
  91   guarantee(PowerArchitecturePPC64_ok, &quot;PowerArchitecturePPC64 cannot be set to &quot;
  92             UINTX_FORMAT &quot; on this machine&quot;, PowerArchitecturePPC64);
  93 
  94   // Power 8: Configure Data Stream Control Register.
  95   if (PowerArchitecturePPC64 &gt;= 8 &amp;&amp; has_mfdscr()) {
  96     config_dscr();
  97   }
  98 
  99   if (!UseSIGTRAP) {
 100     MSG(TrapBasedICMissChecks);
 101     MSG(TrapBasedNotEntrantChecks);
 102     MSG(TrapBasedNullChecks);
<span class="line-modified"> 103     FLAG_SET_ERGO(bool, TrapBasedNotEntrantChecks, false);</span>
<span class="line-modified"> 104     FLAG_SET_ERGO(bool, TrapBasedNullChecks,       false);</span>
<span class="line-modified"> 105     FLAG_SET_ERGO(bool, TrapBasedICMissChecks,     false);</span>
 106   }
 107 
 108 #ifdef COMPILER2
 109   if (!UseSIGTRAP) {
 110     MSG(TrapBasedRangeChecks);
<span class="line-modified"> 111     FLAG_SET_ERGO(bool, TrapBasedRangeChecks, false);</span>
 112   }
 113 
 114   // On Power6 test for section size.
 115   if (PowerArchitecturePPC64 == 6) {
 116     determine_section_size();
 117   // TODO: PPC port } else {
 118   // TODO: PPC port PdScheduling::power6SectorSize = 0x20;
 119   }
 120 
 121   if (PowerArchitecturePPC64 &gt;= 8) {
 122     if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {
<span class="line-modified"> 123       FLAG_SET_ERGO(bool, SuperwordUseVSX, true);</span>
 124     }
 125   } else {
 126     if (SuperwordUseVSX) {
 127       warning(&quot;SuperwordUseVSX specified, but needs at least Power8.&quot;);
 128       FLAG_SET_DEFAULT(SuperwordUseVSX, false);
 129     }
 130   }
 131   MaxVectorSize = SuperwordUseVSX ? 16 : 8;
 132 
 133   if (PowerArchitecturePPC64 &gt;= 9) {
 134     if (FLAG_IS_DEFAULT(UseCountTrailingZerosInstructionsPPC64)) {
<span class="line-modified"> 135       FLAG_SET_ERGO(bool, UseCountTrailingZerosInstructionsPPC64, true);</span>
 136     }
 137     if (FLAG_IS_DEFAULT(UseCharacterCompareIntrinsics)) {
<span class="line-modified"> 138       FLAG_SET_ERGO(bool, UseCharacterCompareIntrinsics, true);</span>
 139     }
 140   } else {
 141     if (UseCountTrailingZerosInstructionsPPC64) {
 142       warning(&quot;UseCountTrailingZerosInstructionsPPC64 specified, but needs at least Power9.&quot;);
 143       FLAG_SET_DEFAULT(UseCountTrailingZerosInstructionsPPC64, false);
 144     }
 145     if (UseCharacterCompareIntrinsics) {
 146       warning(&quot;UseCharacterCompareIntrinsics specified, but needs at least Power9.&quot;);
 147       FLAG_SET_DEFAULT(UseCharacterCompareIntrinsics, false);
 148     }
 149   }
 150 #endif
 151 
 152   // Create and print feature-string.
 153   char buf[(num_features+1) * 16]; // Max 16 chars per feature.
 154   jio_snprintf(buf, sizeof(buf),
 155                &quot;ppc64%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;,
 156                (has_fsqrt()   ? &quot; fsqrt&quot;   : &quot;&quot;),
 157                (has_isel()    ? &quot; isel&quot;    : &quot;&quot;),
 158                (has_lxarxeh() ? &quot; lxarxeh&quot; : &quot;&quot;),
</pre>
<hr />
<pre>
 175               );
 176   _features_string = os::strdup(buf);
 177   if (Verbose) {
 178     print_features();
 179   }
 180 
 181   // PPC64 supports 8-byte compare-exchange operations (see Atomic::cmpxchg)
 182   // and &#39;atomic long memory ops&#39; (see Unsafe_GetLongVolatile).
 183   _supports_cx8 = true;
 184 
 185   // Used by C1.
 186   _supports_atomic_getset4 = true;
 187   _supports_atomic_getadd4 = true;
 188   _supports_atomic_getset8 = true;
 189   _supports_atomic_getadd8 = true;
 190 
 191   UseSSE = 0; // Only on x86 and x64
 192 
 193   intx cache_line_size = L1_data_cache_line_size();
 194 






 195   if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) AllocatePrefetchStyle = 1;
 196 
 197   if (AllocatePrefetchStyle == 4) {
 198     AllocatePrefetchStepSize = cache_line_size; // Need exact value.
 199     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 12; // Use larger blocks by default.
 200     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 2*cache_line_size; // Default is not defined?
 201   } else {
 202     if (cache_line_size &gt; AllocatePrefetchStepSize) AllocatePrefetchStepSize = cache_line_size;
 203     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 3; // Optimistic value.
 204     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 3*cache_line_size; // Default is not defined?
 205   }
 206 
 207   assert(AllocatePrefetchLines &gt; 0, &quot;invalid value&quot;);
 208   if (AllocatePrefetchLines &lt; 1) { // Set valid value in product VM.
 209     AllocatePrefetchLines = 1; // Conservative value.
 210   }
 211 
 212   if (AllocatePrefetchStyle == 3 &amp;&amp; AllocatePrefetchDistance &lt; cache_line_size) {
 213     AllocatePrefetchStyle = 1; // Fall back if inappropriate.
 214   }
 215 
 216   assert(AllocatePrefetchStyle &gt;= 0, &quot;AllocatePrefetchStyle should be positive&quot;);
 217 




 218   // If running on Power8 or newer hardware, the implementation uses the available vector instructions.
 219   // In all other cases, the implementation uses only generally available instructions.
 220   if (!UseCRC32Intrinsics) {
 221     if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
 222       FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);
 223     }
 224   }
 225 
 226   // Implementation does not use any of the vector instructions available with Power8.
 227   // Their exploitation is still pending (aka &quot;work in progress&quot;).
 228   if (!UseCRC32CIntrinsics) {
 229     if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 230       FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
 231     }
 232   }
 233 
 234   // TODO: Provide implementation.
 235   if (UseAdler32Intrinsics) {
 236     warning(&quot;Adler32Intrinsics not available on this CPU.&quot;);
 237     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
</pre>
<hr />
<pre>
 292       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
 293     }
 294   } else if (UseSHA256Intrinsics) {
 295     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
 296     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 297   }
 298 
 299   if (UseSHA &amp;&amp; has_vshasig()) {
 300     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
 301       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
 302     }
 303   } else if (UseSHA512Intrinsics) {
 304     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
 305     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 306   }
 307 
 308   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
 309     FLAG_SET_DEFAULT(UseSHA, false);
 310   }
 311 

 312   if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {
 313     UseSquareToLenIntrinsic = true;
 314   }
 315   if (FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {
 316     UseMulAddIntrinsic = true;
 317   }
 318   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
 319     UseMultiplyToLenIntrinsic = true;
 320   }
 321   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
 322     UseMontgomeryMultiplyIntrinsic = true;
 323   }
 324   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
 325     UseMontgomerySquareIntrinsic = true;
 326   }

 327 
 328   if (UseVectorizedMismatchIntrinsic) {
 329     warning(&quot;UseVectorizedMismatchIntrinsic specified, but not available on this CPU.&quot;);
 330     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
 331   }
 332 
 333 
 334   // Adjust RTM (Restricted Transactional Memory) flags.
 335   if (UseRTMLocking) {
 336     // If CPU or OS do not support TM:
 337     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
 338     // setting during arguments processing. See use_biased_locking().
 339     // VM_Version_init() is executed after UseBiasedLocking is used
 340     // in Thread::allocate().
 341     if (PowerArchitecturePPC64 &lt; 8) {
 342       vm_exit_during_initialization(&quot;RTM instructions are not available on this CPU.&quot;);
 343     }
 344 
 345     if (!has_tm()) {
 346       vm_exit_during_initialization(&quot;RTM is not supported on this OS version.&quot;);
</pre>
<hr />
<pre>
 353       // RTM locking should be used only for applications with
 354       // high lock contention. For now we do not use it by default.
 355       vm_exit_during_initialization(&quot;UseRTMLocking flag should be only set on command line&quot;);
 356     }
 357 #else
 358     // Only C2 does RTM locking optimization.
 359     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
 360     // setting during arguments processing. See use_biased_locking().
 361     vm_exit_during_initialization(&quot;RTM locking optimization is not supported in this VM&quot;);
 362 #endif
 363   } else { // !UseRTMLocking
 364     if (UseRTMForStackLocks) {
 365       if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {
 366         warning(&quot;UseRTMForStackLocks flag should be off when UseRTMLocking flag is off&quot;);
 367       }
 368       FLAG_SET_DEFAULT(UseRTMForStackLocks, false);
 369     }
 370     if (UseRTMDeopt) {
 371       FLAG_SET_DEFAULT(UseRTMDeopt, false);
 372     }

 373     if (PrintPreciseRTMLockingStatistics) {
 374       FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);
 375     }

 376   }
 377 
 378   // This machine allows unaligned memory accesses
 379   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
 380     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
 381   }






















































































































 382 }
 383 
 384 bool VM_Version::use_biased_locking() {
 385 #if INCLUDE_RTM_OPT
 386   // RTM locking is most useful when there is high lock contention and
 387   // low data contention. With high lock contention the lock is usually
 388   // inflated and biased locking is not suitable for that case.
 389   // RTM locking code requires that biased locking is off.
 390   // Note: we can&#39;t switch off UseBiasedLocking in get_processor_features()
 391   // because it is used by Thread::allocate() which is called before
 392   // VM_Version::initialize().
 393   if (UseRTMLocking &amp;&amp; UseBiasedLocking) {
 394     if (FLAG_IS_DEFAULT(UseBiasedLocking)) {
 395       FLAG_SET_DEFAULT(UseBiasedLocking, false);
 396     } else {
 397       warning(&quot;Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.&quot; );
 398       UseBiasedLocking = false;
 399     }
 400   }
 401 #endif
 402   return UseBiasedLocking;
 403 }
 404 
 405 void VM_Version::print_features() {
 406   tty-&gt;print_cr(&quot;Version: %s L1_data_cache_line_size=%d&quot;, features_string(), L1_data_cache_line_size());







 407 }
 408 
 409 #ifdef COMPILER2
 410 // Determine section size on power6: If section size is 8 instructions,
 411 // there should be a difference between the two testloops of ~15 %. If
 412 // no difference is detected the section is assumed to be 32 instructions.
 413 void VM_Version::determine_section_size() {
 414 
 415   int unroll = 80;
 416 
 417   const int code_size = (2* unroll * 32 + 100)*BytesPerInstWord;
 418 
 419   // Allocate space for the code.
 420   ResourceMark rm;
 421   CodeBuffer cb(&quot;detect_section_size&quot;, code_size, 0);
 422   MacroAssembler* a = new MacroAssembler(&amp;cb);
 423 
 424   uint32_t *code = (uint32_t *)a-&gt;pc();
 425   // Emit code.
 426   void (*test1)() = (void(*)())(void *)a-&gt;function_entry();
</pre>
<hr />
<pre>
 570     a-&gt;fmr(F19, F19);             // 28
 571 
 572     // ;; 12
 573     a-&gt;fmr(F20, F20);             // 29
 574     a-&gt;nop();                     // 30
 575     a-&gt;fmr(F21, F21);             // 31
 576 
 577     // ;; 13
 578     a-&gt;fmr(F22, F22);             // 32
 579   }
 580 
 581   // -------- sector 32 -------------
 582   // ;; 14
 583   a-&gt;cmpdi(CCR0, R4, unroll); // 33
 584   a-&gt;bge(CCR0, l2);           // 34
 585 
 586   a-&gt;blr();
 587   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 588   a-&gt;flush();
 589 


 590   double loop1_seconds,loop2_seconds, rel_diff;
 591   uint64_t start1, stop1;
 592 
 593   start1 = os::current_thread_cpu_time(false);
 594   (*test1)();
 595   stop1 = os::current_thread_cpu_time(false);
 596   loop1_seconds = (stop1- start1) / (1000 *1000 *1000.0);
 597 
 598 
 599   start1 = os::current_thread_cpu_time(false);
 600   (*test2)();
 601   stop1 = os::current_thread_cpu_time(false);
 602 
 603   loop2_seconds = (stop1 - start1) / (1000 *1000 *1000.0);
 604 
 605   rel_diff = (loop2_seconds - loop1_seconds) / loop1_seconds *100;
 606 
<span class="line-modified"> 607   if (PrintAssembly) {</span>
 608     ttyLocker ttyl;
 609     tty-&gt;print_cr(&quot;Decoding section size detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
<span class="line-modified"> 610     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);</span>

 611     tty-&gt;print_cr(&quot;Time loop1 :%f&quot;, loop1_seconds);
 612     tty-&gt;print_cr(&quot;Time loop2 :%f&quot;, loop2_seconds);
 613     tty-&gt;print_cr(&quot;(time2 - time1) / time1 = %f %%&quot;, rel_diff);
 614 
 615     if (rel_diff &gt; 12.0) {
 616       tty-&gt;print_cr(&quot;Section Size 8 Instructions&quot;);
 617     } else{
 618       tty-&gt;print_cr(&quot;Section Size 32 Instructions or Power5&quot;);
 619     }
 620   }
 621 
 622 #if 0 // TODO: PPC port
 623   // Set sector size (if not set explicitly).
 624   if (FLAG_IS_DEFAULT(Power6SectorSize128PPC64)) {
 625     if (rel_diff &gt; 12.0) {
 626       PdScheduling::power6SectorSize = 0x20;
 627     } else {
 628       PdScheduling::power6SectorSize = 0x80;
 629     }
 630   } else if (Power6SectorSize128PPC64) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2012, 2019 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;asm/macroAssembler.inline.hpp&quot;
  30 #include &quot;compiler/disassembler.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;runtime/java.hpp&quot;
  33 #include &quot;runtime/os.hpp&quot;
  34 #include &quot;runtime/stubCodeGenerator.hpp&quot;
<span class="line-added">  35 #include &quot;runtime/vm_version.hpp&quot;</span>
  36 #include &quot;utilities/align.hpp&quot;
  37 #include &quot;utilities/defaultStream.hpp&quot;
  38 #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-modified">  39 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  40 
  41 #include &lt;sys/sysinfo.h&gt;
<span class="line-added">  42 #if defined(_AIX)</span>
<span class="line-added">  43 #include &lt;libperfstat.h&gt;</span>
<span class="line-added">  44 #endif</span>
  45 
  46 #if defined(LINUX) &amp;&amp; defined(VM_LITTLE_ENDIAN)
  47 #include &lt;sys/auxv.h&gt;
  48 
  49 #ifndef PPC_FEATURE2_HTM_NOSC
  50 #define PPC_FEATURE2_HTM_NOSC (1 &lt;&lt; 24)
  51 #endif
  52 #endif
  53 
  54 bool VM_Version::_is_determine_features_test_running = false;
  55 uint64_t VM_Version::_dscr_val = 0;
  56 
  57 #define MSG(flag)   \
  58   if (flag &amp;&amp; !FLAG_IS_DEFAULT(flag))                                  \
  59       jio_fprintf(defaultStream::error_stream(),                       \
  60                   &quot;warning: -XX:+&quot; #flag &quot; requires -XX:+UseSIGTRAP\n&quot; \
  61                   &quot;         -XX:+&quot; #flag &quot; will be disabled!\n&quot;);
  62 
  63 void VM_Version::initialize() {
  64 
  65   // Test which instructions are supported and measure cache line size.
  66   determine_features();
  67 
  68   // If PowerArchitecturePPC64 hasn&#39;t been specified explicitly determine from features.
  69   if (FLAG_IS_DEFAULT(PowerArchitecturePPC64)) {
  70     if (VM_Version::has_darn()) {
<span class="line-modified">  71       FLAG_SET_ERGO(PowerArchitecturePPC64, 9);</span>
  72     } else if (VM_Version::has_lqarx()) {
<span class="line-modified">  73       FLAG_SET_ERGO(PowerArchitecturePPC64, 8);</span>
  74     } else if (VM_Version::has_popcntw()) {
<span class="line-modified">  75       FLAG_SET_ERGO(PowerArchitecturePPC64, 7);</span>
  76     } else if (VM_Version::has_cmpb()) {
<span class="line-modified">  77       FLAG_SET_ERGO(PowerArchitecturePPC64, 6);</span>
  78     } else if (VM_Version::has_popcntb()) {
<span class="line-modified">  79       FLAG_SET_ERGO(PowerArchitecturePPC64, 5);</span>
  80     } else {
<span class="line-modified">  81       FLAG_SET_ERGO(PowerArchitecturePPC64, 0);</span>
  82     }
  83   }
  84 
  85   bool PowerArchitecturePPC64_ok = false;
  86   switch (PowerArchitecturePPC64) {
  87     case 9: if (!VM_Version::has_darn()   ) break;
  88     case 8: if (!VM_Version::has_lqarx()  ) break;
  89     case 7: if (!VM_Version::has_popcntw()) break;
  90     case 6: if (!VM_Version::has_cmpb()   ) break;
  91     case 5: if (!VM_Version::has_popcntb()) break;
  92     case 0: PowerArchitecturePPC64_ok = true; break;
  93     default: break;
  94   }
  95   guarantee(PowerArchitecturePPC64_ok, &quot;PowerArchitecturePPC64 cannot be set to &quot;
  96             UINTX_FORMAT &quot; on this machine&quot;, PowerArchitecturePPC64);
  97 
  98   // Power 8: Configure Data Stream Control Register.
  99   if (PowerArchitecturePPC64 &gt;= 8 &amp;&amp; has_mfdscr()) {
 100     config_dscr();
 101   }
 102 
 103   if (!UseSIGTRAP) {
 104     MSG(TrapBasedICMissChecks);
 105     MSG(TrapBasedNotEntrantChecks);
 106     MSG(TrapBasedNullChecks);
<span class="line-modified"> 107     FLAG_SET_ERGO(TrapBasedNotEntrantChecks, false);</span>
<span class="line-modified"> 108     FLAG_SET_ERGO(TrapBasedNullChecks,       false);</span>
<span class="line-modified"> 109     FLAG_SET_ERGO(TrapBasedICMissChecks,     false);</span>
 110   }
 111 
 112 #ifdef COMPILER2
 113   if (!UseSIGTRAP) {
 114     MSG(TrapBasedRangeChecks);
<span class="line-modified"> 115     FLAG_SET_ERGO(TrapBasedRangeChecks, false);</span>
 116   }
 117 
 118   // On Power6 test for section size.
 119   if (PowerArchitecturePPC64 == 6) {
 120     determine_section_size();
 121   // TODO: PPC port } else {
 122   // TODO: PPC port PdScheduling::power6SectorSize = 0x20;
 123   }
 124 
 125   if (PowerArchitecturePPC64 &gt;= 8) {
 126     if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {
<span class="line-modified"> 127       FLAG_SET_ERGO(SuperwordUseVSX, true);</span>
 128     }
 129   } else {
 130     if (SuperwordUseVSX) {
 131       warning(&quot;SuperwordUseVSX specified, but needs at least Power8.&quot;);
 132       FLAG_SET_DEFAULT(SuperwordUseVSX, false);
 133     }
 134   }
 135   MaxVectorSize = SuperwordUseVSX ? 16 : 8;
 136 
 137   if (PowerArchitecturePPC64 &gt;= 9) {
 138     if (FLAG_IS_DEFAULT(UseCountTrailingZerosInstructionsPPC64)) {
<span class="line-modified"> 139       FLAG_SET_ERGO(UseCountTrailingZerosInstructionsPPC64, true);</span>
 140     }
 141     if (FLAG_IS_DEFAULT(UseCharacterCompareIntrinsics)) {
<span class="line-modified"> 142       FLAG_SET_ERGO(UseCharacterCompareIntrinsics, true);</span>
 143     }
 144   } else {
 145     if (UseCountTrailingZerosInstructionsPPC64) {
 146       warning(&quot;UseCountTrailingZerosInstructionsPPC64 specified, but needs at least Power9.&quot;);
 147       FLAG_SET_DEFAULT(UseCountTrailingZerosInstructionsPPC64, false);
 148     }
 149     if (UseCharacterCompareIntrinsics) {
 150       warning(&quot;UseCharacterCompareIntrinsics specified, but needs at least Power9.&quot;);
 151       FLAG_SET_DEFAULT(UseCharacterCompareIntrinsics, false);
 152     }
 153   }
 154 #endif
 155 
 156   // Create and print feature-string.
 157   char buf[(num_features+1) * 16]; // Max 16 chars per feature.
 158   jio_snprintf(buf, sizeof(buf),
 159                &quot;ppc64%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;,
 160                (has_fsqrt()   ? &quot; fsqrt&quot;   : &quot;&quot;),
 161                (has_isel()    ? &quot; isel&quot;    : &quot;&quot;),
 162                (has_lxarxeh() ? &quot; lxarxeh&quot; : &quot;&quot;),
</pre>
<hr />
<pre>
 179               );
 180   _features_string = os::strdup(buf);
 181   if (Verbose) {
 182     print_features();
 183   }
 184 
 185   // PPC64 supports 8-byte compare-exchange operations (see Atomic::cmpxchg)
 186   // and &#39;atomic long memory ops&#39; (see Unsafe_GetLongVolatile).
 187   _supports_cx8 = true;
 188 
 189   // Used by C1.
 190   _supports_atomic_getset4 = true;
 191   _supports_atomic_getadd4 = true;
 192   _supports_atomic_getset8 = true;
 193   _supports_atomic_getadd8 = true;
 194 
 195   UseSSE = 0; // Only on x86 and x64
 196 
 197   intx cache_line_size = L1_data_cache_line_size();
 198 
<span class="line-added"> 199   if (PowerArchitecturePPC64 &gt;= 9) {</span>
<span class="line-added"> 200     if (os::supports_map_sync() == true) {</span>
<span class="line-added"> 201       _data_cache_line_flush_size = cache_line_size;</span>
<span class="line-added"> 202     }</span>
<span class="line-added"> 203   }</span>
<span class="line-added"> 204 </span>
 205   if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) AllocatePrefetchStyle = 1;
 206 
 207   if (AllocatePrefetchStyle == 4) {
 208     AllocatePrefetchStepSize = cache_line_size; // Need exact value.
 209     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 12; // Use larger blocks by default.
 210     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 2*cache_line_size; // Default is not defined?
 211   } else {
 212     if (cache_line_size &gt; AllocatePrefetchStepSize) AllocatePrefetchStepSize = cache_line_size;
 213     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 3; // Optimistic value.
 214     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 3*cache_line_size; // Default is not defined?
 215   }
 216 
 217   assert(AllocatePrefetchLines &gt; 0, &quot;invalid value&quot;);
 218   if (AllocatePrefetchLines &lt; 1) { // Set valid value in product VM.
 219     AllocatePrefetchLines = 1; // Conservative value.
 220   }
 221 
 222   if (AllocatePrefetchStyle == 3 &amp;&amp; AllocatePrefetchDistance &lt; cache_line_size) {
 223     AllocatePrefetchStyle = 1; // Fall back if inappropriate.
 224   }
 225 
 226   assert(AllocatePrefetchStyle &gt;= 0, &quot;AllocatePrefetchStyle should be positive&quot;);
 227 
<span class="line-added"> 228   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp; (cache_line_size &gt; ContendedPaddingWidth)) {</span>
<span class="line-added"> 229     ContendedPaddingWidth = cache_line_size;</span>
<span class="line-added"> 230   }</span>
<span class="line-added"> 231 </span>
 232   // If running on Power8 or newer hardware, the implementation uses the available vector instructions.
 233   // In all other cases, the implementation uses only generally available instructions.
 234   if (!UseCRC32Intrinsics) {
 235     if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
 236       FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);
 237     }
 238   }
 239 
 240   // Implementation does not use any of the vector instructions available with Power8.
 241   // Their exploitation is still pending (aka &quot;work in progress&quot;).
 242   if (!UseCRC32CIntrinsics) {
 243     if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 244       FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
 245     }
 246   }
 247 
 248   // TODO: Provide implementation.
 249   if (UseAdler32Intrinsics) {
 250     warning(&quot;Adler32Intrinsics not available on this CPU.&quot;);
 251     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
</pre>
<hr />
<pre>
 306       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
 307     }
 308   } else if (UseSHA256Intrinsics) {
 309     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
 310     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 311   }
 312 
 313   if (UseSHA &amp;&amp; has_vshasig()) {
 314     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
 315       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
 316     }
 317   } else if (UseSHA512Intrinsics) {
 318     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
 319     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 320   }
 321 
 322   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
 323     FLAG_SET_DEFAULT(UseSHA, false);
 324   }
 325 
<span class="line-added"> 326 #ifdef COMPILER2</span>
 327   if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {
 328     UseSquareToLenIntrinsic = true;
 329   }
 330   if (FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {
 331     UseMulAddIntrinsic = true;
 332   }
 333   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
 334     UseMultiplyToLenIntrinsic = true;
 335   }
 336   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
 337     UseMontgomeryMultiplyIntrinsic = true;
 338   }
 339   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
 340     UseMontgomerySquareIntrinsic = true;
 341   }
<span class="line-added"> 342 #endif</span>
 343 
 344   if (UseVectorizedMismatchIntrinsic) {
 345     warning(&quot;UseVectorizedMismatchIntrinsic specified, but not available on this CPU.&quot;);
 346     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
 347   }
 348 
 349 
 350   // Adjust RTM (Restricted Transactional Memory) flags.
 351   if (UseRTMLocking) {
 352     // If CPU or OS do not support TM:
 353     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
 354     // setting during arguments processing. See use_biased_locking().
 355     // VM_Version_init() is executed after UseBiasedLocking is used
 356     // in Thread::allocate().
 357     if (PowerArchitecturePPC64 &lt; 8) {
 358       vm_exit_during_initialization(&quot;RTM instructions are not available on this CPU.&quot;);
 359     }
 360 
 361     if (!has_tm()) {
 362       vm_exit_during_initialization(&quot;RTM is not supported on this OS version.&quot;);
</pre>
<hr />
<pre>
 369       // RTM locking should be used only for applications with
 370       // high lock contention. For now we do not use it by default.
 371       vm_exit_during_initialization(&quot;UseRTMLocking flag should be only set on command line&quot;);
 372     }
 373 #else
 374     // Only C2 does RTM locking optimization.
 375     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
 376     // setting during arguments processing. See use_biased_locking().
 377     vm_exit_during_initialization(&quot;RTM locking optimization is not supported in this VM&quot;);
 378 #endif
 379   } else { // !UseRTMLocking
 380     if (UseRTMForStackLocks) {
 381       if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {
 382         warning(&quot;UseRTMForStackLocks flag should be off when UseRTMLocking flag is off&quot;);
 383       }
 384       FLAG_SET_DEFAULT(UseRTMForStackLocks, false);
 385     }
 386     if (UseRTMDeopt) {
 387       FLAG_SET_DEFAULT(UseRTMDeopt, false);
 388     }
<span class="line-added"> 389 #ifdef COMPILER2</span>
 390     if (PrintPreciseRTMLockingStatistics) {
 391       FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);
 392     }
<span class="line-added"> 393 #endif</span>
 394   }
 395 
 396   // This machine allows unaligned memory accesses
 397   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
 398     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
 399   }
<span class="line-added"> 400 </span>
<span class="line-added"> 401   check_virtualizations();</span>
<span class="line-added"> 402 }</span>
<span class="line-added"> 403 </span>
<span class="line-added"> 404 void VM_Version::check_virtualizations() {</span>
<span class="line-added"> 405 #if defined(_AIX)</span>
<span class="line-added"> 406   int rc = 0;</span>
<span class="line-added"> 407   perfstat_partition_total_t pinfo;</span>
<span class="line-added"> 408   rc = perfstat_partition_total(NULL, &amp;pinfo, sizeof(perfstat_partition_total_t), 1);</span>
<span class="line-added"> 409   if (rc == 1) {</span>
<span class="line-added"> 410     Abstract_VM_Version::_detected_virtualization = PowerVM;</span>
<span class="line-added"> 411   }</span>
<span class="line-added"> 412 #else</span>
<span class="line-added"> 413   const char* info_file = &quot;/proc/ppc64/lparcfg&quot;;</span>
<span class="line-added"> 414   // system_type=...qemu indicates PowerKVM</span>
<span class="line-added"> 415   // e.g. system_type=IBM pSeries (emulated by qemu)</span>
<span class="line-added"> 416   char line[500];</span>
<span class="line-added"> 417   FILE* fp = fopen(info_file, &quot;r&quot;);</span>
<span class="line-added"> 418   if (fp == NULL) {</span>
<span class="line-added"> 419     return;</span>
<span class="line-added"> 420   }</span>
<span class="line-added"> 421   const char* system_type=&quot;system_type=&quot;;  // in case this line contains qemu, it is KVM</span>
<span class="line-added"> 422   const char* num_lpars=&quot;NumLpars=&quot;; // in case of non-KVM : if this line is found it is PowerVM</span>
<span class="line-added"> 423   bool num_lpars_found = false;</span>
<span class="line-added"> 424 </span>
<span class="line-added"> 425   while (fgets(line, sizeof(line), fp) != NULL) {</span>
<span class="line-added"> 426     if (strncmp(line, system_type, strlen(system_type)) == 0) {</span>
<span class="line-added"> 427       if (strstr(line, &quot;qemu&quot;) != 0) {</span>
<span class="line-added"> 428         Abstract_VM_Version::_detected_virtualization = PowerKVM;</span>
<span class="line-added"> 429         fclose(fp);</span>
<span class="line-added"> 430         return;</span>
<span class="line-added"> 431       }</span>
<span class="line-added"> 432     }</span>
<span class="line-added"> 433     if (strncmp(line, num_lpars, strlen(num_lpars)) == 0) {</span>
<span class="line-added"> 434       num_lpars_found = true;</span>
<span class="line-added"> 435     }</span>
<span class="line-added"> 436   }</span>
<span class="line-added"> 437   if (num_lpars_found) {</span>
<span class="line-added"> 438     Abstract_VM_Version::_detected_virtualization = PowerVM;</span>
<span class="line-added"> 439   } else {</span>
<span class="line-added"> 440     Abstract_VM_Version::_detected_virtualization = PowerFullPartitionMode;</span>
<span class="line-added"> 441   }</span>
<span class="line-added"> 442   fclose(fp);</span>
<span class="line-added"> 443 #endif</span>
<span class="line-added"> 444 }</span>
<span class="line-added"> 445 </span>
<span class="line-added"> 446 void VM_Version::print_platform_virtualization_info(outputStream* st) {</span>
<span class="line-added"> 447 #if defined(_AIX)</span>
<span class="line-added"> 448   // more info about perfstat API see</span>
<span class="line-added"> 449   // https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/com.ibm.aix.prftools/idprftools_perfstat_glob_partition.htm</span>
<span class="line-added"> 450   int rc = 0;</span>
<span class="line-added"> 451   perfstat_partition_total_t pinfo;</span>
<span class="line-added"> 452   memset(&amp;pinfo, 0, sizeof(perfstat_partition_total_t));</span>
<span class="line-added"> 453   rc = perfstat_partition_total(NULL, &amp;pinfo, sizeof(perfstat_partition_total_t), 1);</span>
<span class="line-added"> 454   if (rc != 1) {</span>
<span class="line-added"> 455     return;</span>
<span class="line-added"> 456   } else {</span>
<span class="line-added"> 457     st-&gt;print_cr(&quot;Virtualization type   : PowerVM&quot;);</span>
<span class="line-added"> 458   }</span>
<span class="line-added"> 459   // CPU information</span>
<span class="line-added"> 460   perfstat_cpu_total_t cpuinfo;</span>
<span class="line-added"> 461   memset(&amp;cpuinfo, 0, sizeof(perfstat_cpu_total_t));</span>
<span class="line-added"> 462   rc = perfstat_cpu_total(NULL, &amp;cpuinfo, sizeof(perfstat_cpu_total_t), 1);</span>
<span class="line-added"> 463   if (rc != 1) {</span>
<span class="line-added"> 464     return;</span>
<span class="line-added"> 465   }</span>
<span class="line-added"> 466 </span>
<span class="line-added"> 467   st-&gt;print_cr(&quot;Processor description : %s&quot;, cpuinfo.description);</span>
<span class="line-added"> 468   st-&gt;print_cr(&quot;Processor speed       : %llu Hz&quot;, cpuinfo.processorHZ);</span>
<span class="line-added"> 469 </span>
<span class="line-added"> 470   st-&gt;print_cr(&quot;LPAR partition name           : %s&quot;, pinfo.name);</span>
<span class="line-added"> 471   st-&gt;print_cr(&quot;LPAR partition number         : %u&quot;, pinfo.lpar_id);</span>
<span class="line-added"> 472   st-&gt;print_cr(&quot;LPAR partition type           : %s&quot;, pinfo.type.b.shared_enabled ? &quot;shared&quot; : &quot;dedicated&quot;);</span>
<span class="line-added"> 473   st-&gt;print_cr(&quot;LPAR mode                     : %s&quot;, pinfo.type.b.donate_enabled ? &quot;donating&quot; : pinfo.type.b.capped ? &quot;capped&quot; : &quot;uncapped&quot;);</span>
<span class="line-added"> 474   st-&gt;print_cr(&quot;LPAR partition group ID       : %u&quot;, pinfo.group_id);</span>
<span class="line-added"> 475   st-&gt;print_cr(&quot;LPAR shared pool ID           : %u&quot;, pinfo.pool_id);</span>
<span class="line-added"> 476 </span>
<span class="line-added"> 477   st-&gt;print_cr(&quot;AMS (active memory sharing)   : %s&quot;, pinfo.type.b.ams_capable ? &quot;capable&quot; : &quot;not capable&quot;);</span>
<span class="line-added"> 478   st-&gt;print_cr(&quot;AMS (active memory sharing)   : %s&quot;, pinfo.type.b.ams_enabled ? &quot;on&quot; : &quot;off&quot;);</span>
<span class="line-added"> 479   st-&gt;print_cr(&quot;AME (active memory expansion) : %s&quot;, pinfo.type.b.ame_enabled ? &quot;on&quot; : &quot;off&quot;);</span>
<span class="line-added"> 480 </span>
<span class="line-added"> 481   if (pinfo.type.b.ame_enabled) {</span>
<span class="line-added"> 482     st-&gt;print_cr(&quot;AME true memory in bytes      : %llu&quot;, pinfo.true_memory);</span>
<span class="line-added"> 483     st-&gt;print_cr(&quot;AME expanded memory in bytes  : %llu&quot;, pinfo.expanded_memory);</span>
<span class="line-added"> 484   }</span>
<span class="line-added"> 485 </span>
<span class="line-added"> 486   st-&gt;print_cr(&quot;SMT : %s&quot;, pinfo.type.b.smt_capable ? &quot;capable&quot; : &quot;not capable&quot;);</span>
<span class="line-added"> 487   st-&gt;print_cr(&quot;SMT : %s&quot;, pinfo.type.b.smt_enabled ? &quot;on&quot; : &quot;off&quot;);</span>
<span class="line-added"> 488   int ocpus = pinfo.online_cpus &gt; 0 ?  pinfo.online_cpus : 1;</span>
<span class="line-added"> 489   st-&gt;print_cr(&quot;LPAR threads              : %d&quot;, cpuinfo.ncpus/ocpus);</span>
<span class="line-added"> 490   st-&gt;print_cr(&quot;LPAR online virtual cpus  : %d&quot;, pinfo.online_cpus);</span>
<span class="line-added"> 491   st-&gt;print_cr(&quot;LPAR logical cpus         : %d&quot;, cpuinfo.ncpus);</span>
<span class="line-added"> 492   st-&gt;print_cr(&quot;LPAR maximum virtual cpus : %u&quot;, pinfo.max_cpus);</span>
<span class="line-added"> 493   st-&gt;print_cr(&quot;LPAR minimum virtual cpus : %u&quot;, pinfo.min_cpus);</span>
<span class="line-added"> 494   st-&gt;print_cr(&quot;LPAR entitled capacity    : %4.2f&quot;, (double) (pinfo.entitled_proc_capacity/100.0));</span>
<span class="line-added"> 495   st-&gt;print_cr(&quot;LPAR online memory        : %llu MB&quot;, pinfo.online_memory);</span>
<span class="line-added"> 496   st-&gt;print_cr(&quot;LPAR maximum memory       : %llu MB&quot;, pinfo.max_memory);</span>
<span class="line-added"> 497   st-&gt;print_cr(&quot;LPAR minimum memory       : %llu MB&quot;, pinfo.min_memory);</span>
<span class="line-added"> 498 #else</span>
<span class="line-added"> 499   const char* info_file = &quot;/proc/ppc64/lparcfg&quot;;</span>
<span class="line-added"> 500   const char* kw[] = { &quot;system_type=&quot;, // qemu indicates PowerKVM</span>
<span class="line-added"> 501                        &quot;partition_entitled_capacity=&quot;, // entitled processor capacity percentage</span>
<span class="line-added"> 502                        &quot;partition_max_entitled_capacity=&quot;,</span>
<span class="line-added"> 503                        &quot;capacity_weight=&quot;, // partition CPU weight</span>
<span class="line-added"> 504                        &quot;partition_active_processors=&quot;,</span>
<span class="line-added"> 505                        &quot;partition_potential_processors=&quot;,</span>
<span class="line-added"> 506                        &quot;entitled_proc_capacity_available=&quot;,</span>
<span class="line-added"> 507                        &quot;capped=&quot;, // 0 - uncapped, 1 - vcpus capped at entitled processor capacity percentage</span>
<span class="line-added"> 508                        &quot;shared_processor_mode=&quot;, // (non)dedicated partition</span>
<span class="line-added"> 509                        &quot;system_potential_processors=&quot;,</span>
<span class="line-added"> 510                        &quot;pool=&quot;, // CPU-pool number</span>
<span class="line-added"> 511                        &quot;pool_capacity=&quot;,</span>
<span class="line-added"> 512                        &quot;NumLpars=&quot;, // on non-KVM machines, NumLpars is not found for full partition mode machines</span>
<span class="line-added"> 513                        NULL };</span>
<span class="line-added"> 514   if (!print_matching_lines_from_file(info_file, st, kw)) {</span>
<span class="line-added"> 515     st-&gt;print_cr(&quot;  &lt;%s Not Available&gt;&quot;, info_file);</span>
<span class="line-added"> 516   }</span>
<span class="line-added"> 517 #endif</span>
 518 }
 519 
 520 bool VM_Version::use_biased_locking() {
 521 #if INCLUDE_RTM_OPT
 522   // RTM locking is most useful when there is high lock contention and
 523   // low data contention. With high lock contention the lock is usually
 524   // inflated and biased locking is not suitable for that case.
 525   // RTM locking code requires that biased locking is off.
 526   // Note: we can&#39;t switch off UseBiasedLocking in get_processor_features()
 527   // because it is used by Thread::allocate() which is called before
 528   // VM_Version::initialize().
 529   if (UseRTMLocking &amp;&amp; UseBiasedLocking) {
 530     if (FLAG_IS_DEFAULT(UseBiasedLocking)) {
 531       FLAG_SET_DEFAULT(UseBiasedLocking, false);
 532     } else {
 533       warning(&quot;Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.&quot; );
 534       UseBiasedLocking = false;
 535     }
 536   }
 537 #endif
 538   return UseBiasedLocking;
 539 }
 540 
 541 void VM_Version::print_features() {
 542   tty-&gt;print_cr(&quot;Version: %s L1_data_cache_line_size=%d&quot;, features_string(), L1_data_cache_line_size());
<span class="line-added"> 543 </span>
<span class="line-added"> 544   if (Verbose) {</span>
<span class="line-added"> 545     if (ContendedPaddingWidth &gt; 0) {</span>
<span class="line-added"> 546       tty-&gt;cr();</span>
<span class="line-added"> 547       tty-&gt;print_cr(&quot;ContendedPaddingWidth &quot; INTX_FORMAT, ContendedPaddingWidth);</span>
<span class="line-added"> 548     }</span>
<span class="line-added"> 549   }</span>
 550 }
 551 
 552 #ifdef COMPILER2
 553 // Determine section size on power6: If section size is 8 instructions,
 554 // there should be a difference between the two testloops of ~15 %. If
 555 // no difference is detected the section is assumed to be 32 instructions.
 556 void VM_Version::determine_section_size() {
 557 
 558   int unroll = 80;
 559 
 560   const int code_size = (2* unroll * 32 + 100)*BytesPerInstWord;
 561 
 562   // Allocate space for the code.
 563   ResourceMark rm;
 564   CodeBuffer cb(&quot;detect_section_size&quot;, code_size, 0);
 565   MacroAssembler* a = new MacroAssembler(&amp;cb);
 566 
 567   uint32_t *code = (uint32_t *)a-&gt;pc();
 568   // Emit code.
 569   void (*test1)() = (void(*)())(void *)a-&gt;function_entry();
</pre>
<hr />
<pre>
 713     a-&gt;fmr(F19, F19);             // 28
 714 
 715     // ;; 12
 716     a-&gt;fmr(F20, F20);             // 29
 717     a-&gt;nop();                     // 30
 718     a-&gt;fmr(F21, F21);             // 31
 719 
 720     // ;; 13
 721     a-&gt;fmr(F22, F22);             // 32
 722   }
 723 
 724   // -------- sector 32 -------------
 725   // ;; 14
 726   a-&gt;cmpdi(CCR0, R4, unroll); // 33
 727   a-&gt;bge(CCR0, l2);           // 34
 728 
 729   a-&gt;blr();
 730   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 731   a-&gt;flush();
 732 
<span class="line-added"> 733   cb.insts()-&gt;set_end((u_char*)code_end);</span>
<span class="line-added"> 734 </span>
 735   double loop1_seconds,loop2_seconds, rel_diff;
 736   uint64_t start1, stop1;
 737 
 738   start1 = os::current_thread_cpu_time(false);
 739   (*test1)();
 740   stop1 = os::current_thread_cpu_time(false);
 741   loop1_seconds = (stop1- start1) / (1000 *1000 *1000.0);
 742 
 743 
 744   start1 = os::current_thread_cpu_time(false);
 745   (*test2)();
 746   stop1 = os::current_thread_cpu_time(false);
 747 
 748   loop2_seconds = (stop1 - start1) / (1000 *1000 *1000.0);
 749 
 750   rel_diff = (loop2_seconds - loop1_seconds) / loop1_seconds *100;
 751 
<span class="line-modified"> 752   if (PrintAssembly || PrintStubCode) {</span>
 753     ttyLocker ttyl;
 754     tty-&gt;print_cr(&quot;Decoding section size detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
<span class="line-modified"> 755     // Use existing decode function. This enables the [MachCode] format which is needed to DecodeErrorFile.</span>
<span class="line-added"> 756     Disassembler::decode(&amp;cb, (u_char*)code, (u_char*)code_end, tty);</span>
 757     tty-&gt;print_cr(&quot;Time loop1 :%f&quot;, loop1_seconds);
 758     tty-&gt;print_cr(&quot;Time loop2 :%f&quot;, loop2_seconds);
 759     tty-&gt;print_cr(&quot;(time2 - time1) / time1 = %f %%&quot;, rel_diff);
 760 
 761     if (rel_diff &gt; 12.0) {
 762       tty-&gt;print_cr(&quot;Section Size 8 Instructions&quot;);
 763     } else{
 764       tty-&gt;print_cr(&quot;Section Size 32 Instructions or Power5&quot;);
 765     }
 766   }
 767 
 768 #if 0 // TODO: PPC port
 769   // Set sector size (if not set explicitly).
 770   if (FLAG_IS_DEFAULT(Power6SectorSize128PPC64)) {
 771     if (rel_diff &gt; 12.0) {
 772       PdScheduling::power6SectorSize = 0x20;
 773     } else {
 774       PdScheduling::power6SectorSize = 0x80;
 775     }
 776   } else if (Power6SectorSize128PPC64) {
</pre>
</td>
</tr>
</table>
<center><a href="vm_version_ext_ppc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_ppc.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
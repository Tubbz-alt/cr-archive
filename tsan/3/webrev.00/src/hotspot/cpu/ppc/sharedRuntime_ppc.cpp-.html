<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/ppc/sharedRuntime_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/debugInfoRec.hpp&quot;
  29 #include &quot;code/icBuffer.hpp&quot;
  30 #include &quot;code/vtableStubs.hpp&quot;
  31 #include &quot;frame_ppc.hpp&quot;
  32 #include &quot;gc/shared/gcLocker.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;interpreter/interp_masm.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;oops/compiledICHolder.hpp&quot;
  37 #include &quot;runtime/safepointMechanism.hpp&quot;
  38 #include &quot;runtime/sharedRuntime.hpp&quot;
  39 #include &quot;runtime/vframeArray.hpp&quot;
  40 #include &quot;utilities/align.hpp&quot;
  41 #include &quot;vmreg_ppc.inline.hpp&quot;
  42 #ifdef COMPILER1
  43 #include &quot;c1/c1_Runtime1.hpp&quot;
  44 #endif
  45 #ifdef COMPILER2
  46 #include &quot;opto/ad.hpp&quot;
  47 #include &quot;opto/runtime.hpp&quot;
  48 #endif
  49 
  50 #include &lt;alloca.h&gt;
  51 
  52 #define __ masm-&gt;
  53 
  54 #ifdef PRODUCT
  55 #define BLOCK_COMMENT(str) // nothing
  56 #else
  57 #define BLOCK_COMMENT(str) __ block_comment(str)
  58 #endif
  59 
  60 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  61 
  62 
  63 class RegisterSaver {
  64  // Used for saving volatile registers.
  65  public:
  66 
  67   // Support different return pc locations.
  68   enum ReturnPCLocation {
  69     return_pc_is_lr,
  70     return_pc_is_pre_saved,
  71     return_pc_is_thread_saved_exception_pc
  72   };
  73 
  74   static OopMap* push_frame_reg_args_and_save_live_registers(MacroAssembler* masm,
  75                          int* out_frame_size_in_bytes,
  76                          bool generate_oop_map,
  77                          int return_pc_adjustment,
  78                          ReturnPCLocation return_pc_location,
  79                          bool save_vectors = false);
  80   static void    restore_live_registers_and_pop_frame(MacroAssembler* masm,
  81                          int frame_size_in_bytes,
  82                          bool restore_ctr,
  83                          bool save_vectors = false);
  84 
  85   static void push_frame_and_save_argument_registers(MacroAssembler* masm,
  86                          Register r_temp,
  87                          int frame_size,
  88                          int total_args,
  89                          const VMRegPair *regs, const VMRegPair *regs2 = NULL);
  90   static void restore_argument_registers_and_pop_frame(MacroAssembler*masm,
  91                          int frame_size,
  92                          int total_args,
  93                          const VMRegPair *regs, const VMRegPair *regs2 = NULL);
  94 
  95   // During deoptimization only the result registers need to be restored
  96   // all the other values have already been extracted.
  97   static void restore_result_registers(MacroAssembler* masm, int frame_size_in_bytes);
  98 
  99   // Constants and data structures:
 100 
 101   typedef enum {
 102     int_reg,
 103     float_reg,
 104     special_reg,
 105     vs_reg
 106   } RegisterType;
 107 
 108   typedef enum {
 109     reg_size          = 8,
 110     half_reg_size     = reg_size / 2,
 111     vs_reg_size       = 16
 112   } RegisterConstants;
 113 
 114   typedef struct {
 115     RegisterType        reg_type;
 116     int                 reg_num;
 117     VMReg               vmreg;
 118   } LiveRegType;
 119 };
 120 
 121 
 122 #define RegisterSaver_LiveIntReg(regname) \
 123   { RegisterSaver::int_reg,     regname-&gt;encoding(), regname-&gt;as_VMReg() }
 124 
 125 #define RegisterSaver_LiveFloatReg(regname) \
 126   { RegisterSaver::float_reg,   regname-&gt;encoding(), regname-&gt;as_VMReg() }
 127 
 128 #define RegisterSaver_LiveSpecialReg(regname) \
 129   { RegisterSaver::special_reg, regname-&gt;encoding(), regname-&gt;as_VMReg() }
 130 
 131 #define RegisterSaver_LiveVSReg(regname) \
 132   { RegisterSaver::vs_reg,      regname-&gt;encoding(), regname-&gt;as_VMReg() }
 133 
 134 static const RegisterSaver::LiveRegType RegisterSaver_LiveRegs[] = {
 135   // Live registers which get spilled to the stack. Register
 136   // positions in this array correspond directly to the stack layout.
 137 
 138   //
 139   // live special registers:
 140   //
 141   RegisterSaver_LiveSpecialReg(SR_CTR),
 142   //
 143   // live float registers:
 144   //
 145   RegisterSaver_LiveFloatReg( F0  ),
 146   RegisterSaver_LiveFloatReg( F1  ),
 147   RegisterSaver_LiveFloatReg( F2  ),
 148   RegisterSaver_LiveFloatReg( F3  ),
 149   RegisterSaver_LiveFloatReg( F4  ),
 150   RegisterSaver_LiveFloatReg( F5  ),
 151   RegisterSaver_LiveFloatReg( F6  ),
 152   RegisterSaver_LiveFloatReg( F7  ),
 153   RegisterSaver_LiveFloatReg( F8  ),
 154   RegisterSaver_LiveFloatReg( F9  ),
 155   RegisterSaver_LiveFloatReg( F10 ),
 156   RegisterSaver_LiveFloatReg( F11 ),
 157   RegisterSaver_LiveFloatReg( F12 ),
 158   RegisterSaver_LiveFloatReg( F13 ),
 159   RegisterSaver_LiveFloatReg( F14 ),
 160   RegisterSaver_LiveFloatReg( F15 ),
 161   RegisterSaver_LiveFloatReg( F16 ),
 162   RegisterSaver_LiveFloatReg( F17 ),
 163   RegisterSaver_LiveFloatReg( F18 ),
 164   RegisterSaver_LiveFloatReg( F19 ),
 165   RegisterSaver_LiveFloatReg( F20 ),
 166   RegisterSaver_LiveFloatReg( F21 ),
 167   RegisterSaver_LiveFloatReg( F22 ),
 168   RegisterSaver_LiveFloatReg( F23 ),
 169   RegisterSaver_LiveFloatReg( F24 ),
 170   RegisterSaver_LiveFloatReg( F25 ),
 171   RegisterSaver_LiveFloatReg( F26 ),
 172   RegisterSaver_LiveFloatReg( F27 ),
 173   RegisterSaver_LiveFloatReg( F28 ),
 174   RegisterSaver_LiveFloatReg( F29 ),
 175   RegisterSaver_LiveFloatReg( F30 ),
 176   RegisterSaver_LiveFloatReg( F31 ),
 177   //
 178   // live integer registers:
 179   //
 180   RegisterSaver_LiveIntReg(   R0  ),
 181   //RegisterSaver_LiveIntReg( R1  ), // stack pointer
 182   RegisterSaver_LiveIntReg(   R2  ),
 183   RegisterSaver_LiveIntReg(   R3  ),
 184   RegisterSaver_LiveIntReg(   R4  ),
 185   RegisterSaver_LiveIntReg(   R5  ),
 186   RegisterSaver_LiveIntReg(   R6  ),
 187   RegisterSaver_LiveIntReg(   R7  ),
 188   RegisterSaver_LiveIntReg(   R8  ),
 189   RegisterSaver_LiveIntReg(   R9  ),
 190   RegisterSaver_LiveIntReg(   R10 ),
 191   RegisterSaver_LiveIntReg(   R11 ),
 192   RegisterSaver_LiveIntReg(   R12 ),
 193   //RegisterSaver_LiveIntReg( R13 ), // system thread id
 194   RegisterSaver_LiveIntReg(   R14 ),
 195   RegisterSaver_LiveIntReg(   R15 ),
 196   RegisterSaver_LiveIntReg(   R16 ),
 197   RegisterSaver_LiveIntReg(   R17 ),
 198   RegisterSaver_LiveIntReg(   R18 ),
 199   RegisterSaver_LiveIntReg(   R19 ),
 200   RegisterSaver_LiveIntReg(   R20 ),
 201   RegisterSaver_LiveIntReg(   R21 ),
 202   RegisterSaver_LiveIntReg(   R22 ),
 203   RegisterSaver_LiveIntReg(   R23 ),
 204   RegisterSaver_LiveIntReg(   R24 ),
 205   RegisterSaver_LiveIntReg(   R25 ),
 206   RegisterSaver_LiveIntReg(   R26 ),
 207   RegisterSaver_LiveIntReg(   R27 ),
 208   RegisterSaver_LiveIntReg(   R28 ),
 209   RegisterSaver_LiveIntReg(   R29 ),
 210   RegisterSaver_LiveIntReg(   R30 ),
 211   RegisterSaver_LiveIntReg(   R31 )  // must be the last register (see save/restore functions below)
 212 };
 213 
 214 static const RegisterSaver::LiveRegType RegisterSaver_LiveVSRegs[] = {
 215   //
 216   // live vector scalar registers (optional, only these ones are used by C2):
 217   //
 218   RegisterSaver_LiveVSReg( VSR32 ),
 219   RegisterSaver_LiveVSReg( VSR33 ),
 220   RegisterSaver_LiveVSReg( VSR34 ),
 221   RegisterSaver_LiveVSReg( VSR35 ),
 222   RegisterSaver_LiveVSReg( VSR36 ),
 223   RegisterSaver_LiveVSReg( VSR37 ),
 224   RegisterSaver_LiveVSReg( VSR38 ),
 225   RegisterSaver_LiveVSReg( VSR39 ),
 226   RegisterSaver_LiveVSReg( VSR40 ),
 227   RegisterSaver_LiveVSReg( VSR41 ),
 228   RegisterSaver_LiveVSReg( VSR42 ),
 229   RegisterSaver_LiveVSReg( VSR43 ),
 230   RegisterSaver_LiveVSReg( VSR44 ),
 231   RegisterSaver_LiveVSReg( VSR45 ),
 232   RegisterSaver_LiveVSReg( VSR46 ),
 233   RegisterSaver_LiveVSReg( VSR47 ),
 234   RegisterSaver_LiveVSReg( VSR48 ),
 235   RegisterSaver_LiveVSReg( VSR49 ),
 236   RegisterSaver_LiveVSReg( VSR50 ),
 237   RegisterSaver_LiveVSReg( VSR51 )
 238 };
 239 
 240 
 241 OopMap* RegisterSaver::push_frame_reg_args_and_save_live_registers(MacroAssembler* masm,
 242                          int* out_frame_size_in_bytes,
 243                          bool generate_oop_map,
 244                          int return_pc_adjustment,
 245                          ReturnPCLocation return_pc_location,
 246                          bool save_vectors) {
 247   // Push an abi_reg_args-frame and store all registers which may be live.
 248   // If requested, create an OopMap: Record volatile registers as
 249   // callee-save values in an OopMap so their save locations will be
 250   // propagated to the RegisterMap of the caller frame during
 251   // StackFrameStream construction (needed for deoptimization; see
 252   // compiledVFrame::create_stack_value).
 253   // If return_pc_adjustment != 0 adjust the return pc by return_pc_adjustment.
 254   // Updated return pc is returned in R31 (if not return_pc_is_pre_saved).
 255 
 256   // calcualte frame size
 257   const int regstosave_num       = sizeof(RegisterSaver_LiveRegs) /
 258                                    sizeof(RegisterSaver::LiveRegType);
 259   const int vsregstosave_num     = save_vectors ? (sizeof(RegisterSaver_LiveVSRegs) /
 260                                                    sizeof(RegisterSaver::LiveRegType))
 261                                                 : 0;
 262   const int register_save_size   = regstosave_num * reg_size + vsregstosave_num * vs_reg_size;
 263   const int frame_size_in_bytes  = align_up(register_save_size, frame::alignment_in_bytes)
 264                                    + frame::abi_reg_args_size;
 265 
 266   *out_frame_size_in_bytes       = frame_size_in_bytes;
 267   const int frame_size_in_slots  = frame_size_in_bytes / sizeof(jint);
 268   const int register_save_offset = frame_size_in_bytes - register_save_size;
 269 
 270   // OopMap frame size is in c2 stack slots (sizeof(jint)) not bytes or words.
 271   OopMap* map = generate_oop_map ? new OopMap(frame_size_in_slots, 0) : NULL;
 272 
 273   BLOCK_COMMENT(&quot;push_frame_reg_args_and_save_live_registers {&quot;);
 274 
 275   // push a new frame
 276   __ push_frame(frame_size_in_bytes, noreg);
 277 
 278   // Save some registers in the last (non-vector) slots of the new frame so we
 279   // can use them as scratch regs or to determine the return pc.
 280   __ std(R31, frame_size_in_bytes -   reg_size - vsregstosave_num * vs_reg_size, R1_SP);
 281   __ std(R30, frame_size_in_bytes - 2*reg_size - vsregstosave_num * vs_reg_size, R1_SP);
 282 
 283   // save the flags
 284   // Do the save_LR_CR by hand and adjust the return pc if requested.
 285   __ mfcr(R30);
 286   __ std(R30, frame_size_in_bytes + _abi(cr), R1_SP);
 287   switch (return_pc_location) {
 288     case return_pc_is_lr: __ mflr(R31); break;
 289     case return_pc_is_pre_saved: assert(return_pc_adjustment == 0, &quot;unsupported&quot;); break;
 290     case return_pc_is_thread_saved_exception_pc: __ ld(R31, thread_(saved_exception_pc)); break;
 291     default: ShouldNotReachHere();
 292   }
 293   if (return_pc_location != return_pc_is_pre_saved) {
 294     if (return_pc_adjustment != 0) {
 295       __ addi(R31, R31, return_pc_adjustment);
 296     }
 297     __ std(R31, frame_size_in_bytes + _abi(lr), R1_SP);
 298   }
 299 
 300   // save all registers (ints and floats)
 301   int offset = register_save_offset;
 302 
 303   for (int i = 0; i &lt; regstosave_num; i++) {
 304     int reg_num  = RegisterSaver_LiveRegs[i].reg_num;
 305     int reg_type = RegisterSaver_LiveRegs[i].reg_type;
 306 
 307     switch (reg_type) {
 308       case RegisterSaver::int_reg: {
 309         if (reg_num &lt; 30) { // We spilled R30-31 right at the beginning.
 310           __ std(as_Register(reg_num), offset, R1_SP);
 311         }
 312         break;
 313       }
 314       case RegisterSaver::float_reg: {
 315         __ stfd(as_FloatRegister(reg_num), offset, R1_SP);
 316         break;
 317       }
 318       case RegisterSaver::special_reg: {
 319         if (reg_num == SR_CTR_SpecialRegisterEnumValue) {
 320           __ mfctr(R30);
 321           __ std(R30, offset, R1_SP);
 322         } else {
 323           Unimplemented();
 324         }
 325         break;
 326       }
 327       default:
 328         ShouldNotReachHere();
 329     }
 330 
 331     if (generate_oop_map) {
 332       map-&gt;set_callee_saved(VMRegImpl::stack2reg(offset&gt;&gt;2),
 333                             RegisterSaver_LiveRegs[i].vmreg);
 334       map-&gt;set_callee_saved(VMRegImpl::stack2reg((offset + half_reg_size)&gt;&gt;2),
 335                             RegisterSaver_LiveRegs[i].vmreg-&gt;next());
 336     }
 337     offset += reg_size;
 338   }
 339 
 340   for (int i = 0; i &lt; vsregstosave_num; i++) {
 341     int reg_num  = RegisterSaver_LiveVSRegs[i].reg_num;
 342     int reg_type = RegisterSaver_LiveVSRegs[i].reg_type;
 343 
 344     __ li(R30, offset);
 345     __ stxvd2x(as_VectorSRegister(reg_num), R30, R1_SP);
 346 
 347     if (generate_oop_map) {
 348       map-&gt;set_callee_saved(VMRegImpl::stack2reg(offset&gt;&gt;2),
 349                             RegisterSaver_LiveVSRegs[i].vmreg);
 350     }
 351     offset += vs_reg_size;
 352   }
 353 
 354   assert(offset == frame_size_in_bytes, &quot;consistency check&quot;);
 355 
 356   BLOCK_COMMENT(&quot;} push_frame_reg_args_and_save_live_registers&quot;);
 357 
 358   // And we&#39;re done.
 359   return map;
 360 }
 361 
 362 
 363 // Pop the current frame and restore all the registers that we
 364 // saved.
 365 void RegisterSaver::restore_live_registers_and_pop_frame(MacroAssembler* masm,
 366                                                          int frame_size_in_bytes,
 367                                                          bool restore_ctr,
 368                                                          bool save_vectors) {
 369   const int regstosave_num       = sizeof(RegisterSaver_LiveRegs) /
 370                                    sizeof(RegisterSaver::LiveRegType);
 371   const int vsregstosave_num     = save_vectors ? (sizeof(RegisterSaver_LiveVSRegs) /
 372                                                    sizeof(RegisterSaver::LiveRegType))
 373                                                 : 0;
 374   const int register_save_size   = regstosave_num * reg_size + vsregstosave_num * vs_reg_size;
 375 
 376   const int register_save_offset = frame_size_in_bytes - register_save_size;
 377 
 378   BLOCK_COMMENT(&quot;restore_live_registers_and_pop_frame {&quot;);
 379 
 380   // restore all registers (ints and floats)
 381   int offset = register_save_offset;
 382 
 383   for (int i = 0; i &lt; regstosave_num; i++) {
 384     int reg_num  = RegisterSaver_LiveRegs[i].reg_num;
 385     int reg_type = RegisterSaver_LiveRegs[i].reg_type;
 386 
 387     switch (reg_type) {
 388       case RegisterSaver::int_reg: {
 389         if (reg_num != 31) // R31 restored at the end, it&#39;s the tmp reg!
 390           __ ld(as_Register(reg_num), offset, R1_SP);
 391         break;
 392       }
 393       case RegisterSaver::float_reg: {
 394         __ lfd(as_FloatRegister(reg_num), offset, R1_SP);
 395         break;
 396       }
 397       case RegisterSaver::special_reg: {
 398         if (reg_num == SR_CTR_SpecialRegisterEnumValue) {
 399           if (restore_ctr) { // Nothing to do here if ctr already contains the next address.
 400             __ ld(R31, offset, R1_SP);
 401             __ mtctr(R31);
 402           }
 403         } else {
 404           Unimplemented();
 405         }
 406         break;
 407       }
 408       default:
 409         ShouldNotReachHere();
 410     }
 411     offset += reg_size;
 412   }
 413 
 414   for (int i = 0; i &lt; vsregstosave_num; i++) {
 415     int reg_num  = RegisterSaver_LiveVSRegs[i].reg_num;
 416     int reg_type = RegisterSaver_LiveVSRegs[i].reg_type;
 417 
 418     __ li(R31, offset);
 419     __ lxvd2x(as_VectorSRegister(reg_num), R31, R1_SP);
 420 
 421     offset += vs_reg_size;
 422   }
 423 
 424   assert(offset == frame_size_in_bytes, &quot;consistency check&quot;);
 425 
 426   // restore link and the flags
 427   __ ld(R31, frame_size_in_bytes + _abi(lr), R1_SP);
 428   __ mtlr(R31);
 429 
 430   __ ld(R31, frame_size_in_bytes + _abi(cr), R1_SP);
 431   __ mtcr(R31);
 432 
 433   // restore scratch register&#39;s value
 434   __ ld(R31, frame_size_in_bytes - reg_size - vsregstosave_num * vs_reg_size, R1_SP);
 435 
 436   // pop the frame
 437   __ addi(R1_SP, R1_SP, frame_size_in_bytes);
 438 
 439   BLOCK_COMMENT(&quot;} restore_live_registers_and_pop_frame&quot;);
 440 }
 441 
 442 void RegisterSaver::push_frame_and_save_argument_registers(MacroAssembler* masm, Register r_temp,
 443                                                            int frame_size,int total_args, const VMRegPair *regs,
 444                                                            const VMRegPair *regs2) {
 445   __ push_frame(frame_size, r_temp);
 446   int st_off = frame_size - wordSize;
 447   for (int i = 0; i &lt; total_args; i++) {
 448     VMReg r_1 = regs[i].first();
 449     VMReg r_2 = regs[i].second();
 450     if (!r_1-&gt;is_valid()) {
 451       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 452       continue;
 453     }
 454     if (r_1-&gt;is_Register()) {
 455       Register r = r_1-&gt;as_Register();
 456       __ std(r, st_off, R1_SP);
 457       st_off -= wordSize;
 458     } else if (r_1-&gt;is_FloatRegister()) {
 459       FloatRegister f = r_1-&gt;as_FloatRegister();
 460       __ stfd(f, st_off, R1_SP);
 461       st_off -= wordSize;
 462     }
 463   }
 464   if (regs2 != NULL) {
 465     for (int i = 0; i &lt; total_args; i++) {
 466       VMReg r_1 = regs2[i].first();
 467       VMReg r_2 = regs2[i].second();
 468       if (!r_1-&gt;is_valid()) {
 469         assert(!r_2-&gt;is_valid(), &quot;&quot;);
 470         continue;
 471       }
 472       if (r_1-&gt;is_Register()) {
 473         Register r = r_1-&gt;as_Register();
 474         __ std(r, st_off, R1_SP);
 475         st_off -= wordSize;
 476       } else if (r_1-&gt;is_FloatRegister()) {
 477         FloatRegister f = r_1-&gt;as_FloatRegister();
 478         __ stfd(f, st_off, R1_SP);
 479         st_off -= wordSize;
 480       }
 481     }
 482   }
 483 }
 484 
 485 void RegisterSaver::restore_argument_registers_and_pop_frame(MacroAssembler*masm, int frame_size,
 486                                                              int total_args, const VMRegPair *regs,
 487                                                              const VMRegPair *regs2) {
 488   int st_off = frame_size - wordSize;
 489   for (int i = 0; i &lt; total_args; i++) {
 490     VMReg r_1 = regs[i].first();
 491     VMReg r_2 = regs[i].second();
 492     if (r_1-&gt;is_Register()) {
 493       Register r = r_1-&gt;as_Register();
 494       __ ld(r, st_off, R1_SP);
 495       st_off -= wordSize;
 496     } else if (r_1-&gt;is_FloatRegister()) {
 497       FloatRegister f = r_1-&gt;as_FloatRegister();
 498       __ lfd(f, st_off, R1_SP);
 499       st_off -= wordSize;
 500     }
 501   }
 502   if (regs2 != NULL)
 503     for (int i = 0; i &lt; total_args; i++) {
 504       VMReg r_1 = regs2[i].first();
 505       VMReg r_2 = regs2[i].second();
 506       if (r_1-&gt;is_Register()) {
 507         Register r = r_1-&gt;as_Register();
 508         __ ld(r, st_off, R1_SP);
 509         st_off -= wordSize;
 510       } else if (r_1-&gt;is_FloatRegister()) {
 511         FloatRegister f = r_1-&gt;as_FloatRegister();
 512         __ lfd(f, st_off, R1_SP);
 513         st_off -= wordSize;
 514       }
 515     }
 516   __ pop_frame();
 517 }
 518 
 519 // Restore the registers that might be holding a result.
 520 void RegisterSaver::restore_result_registers(MacroAssembler* masm, int frame_size_in_bytes) {
 521   const int regstosave_num       = sizeof(RegisterSaver_LiveRegs) /
 522                                    sizeof(RegisterSaver::LiveRegType);
 523   const int register_save_size   = regstosave_num * reg_size; // VS registers not relevant here.
 524   const int register_save_offset = frame_size_in_bytes - register_save_size;
 525 
 526   // restore all result registers (ints and floats)
 527   int offset = register_save_offset;
 528   for (int i = 0; i &lt; regstosave_num; i++) {
 529     int reg_num  = RegisterSaver_LiveRegs[i].reg_num;
 530     int reg_type = RegisterSaver_LiveRegs[i].reg_type;
 531     switch (reg_type) {
 532       case RegisterSaver::int_reg: {
 533         if (as_Register(reg_num)==R3_RET) // int result_reg
 534           __ ld(as_Register(reg_num), offset, R1_SP);
 535         break;
 536       }
 537       case RegisterSaver::float_reg: {
 538         if (as_FloatRegister(reg_num)==F1_RET) // float result_reg
 539           __ lfd(as_FloatRegister(reg_num), offset, R1_SP);
 540         break;
 541       }
 542       case RegisterSaver::special_reg: {
 543         // Special registers don&#39;t hold a result.
 544         break;
 545       }
 546       default:
 547         ShouldNotReachHere();
 548     }
 549     offset += reg_size;
 550   }
 551 
 552   assert(offset == frame_size_in_bytes, &quot;consistency check&quot;);
 553 }
 554 
 555 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
 556 bool SharedRuntime::is_wide_vector(int size) {
 557   // Note, MaxVectorSize == 8/16 on PPC64.
 558   assert(size &lt;= (SuperwordUseVSX ? 16 : 8), &quot;%d bytes vectors are not supported&quot;, size);
 559   return size &gt; 8;
 560 }
 561 
 562 size_t SharedRuntime::trampoline_size() {
 563   return Assembler::load_const_size + 8;
 564 }
 565 
 566 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 567   Register Rtemp = R12;
 568   __ load_const(Rtemp, destination);
 569   __ mtctr(Rtemp);
 570   __ bctr();
 571 }
 572 
 573 #ifdef COMPILER2
 574 static int reg2slot(VMReg r) {
 575   return r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
 576 }
 577 
 578 static int reg2offset(VMReg r) {
 579   return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 580 }
 581 #endif
 582 
 583 // ---------------------------------------------------------------------------
 584 // Read the array of BasicTypes from a signature, and compute where the
 585 // arguments should go. Values in the VMRegPair regs array refer to 4-byte
 586 // quantities. Values less than VMRegImpl::stack0 are registers, those above
 587 // refer to 4-byte stack slots. All stack slots are based off of the stack pointer
 588 // as framesizes are fixed.
 589 // VMRegImpl::stack0 refers to the first slot 0(sp).
 590 // and VMRegImpl::stack0+1 refers to the memory word 4-bytes higher. Register
 591 // up to RegisterImpl::number_of_registers) are the 64-bit
 592 // integer registers.
 593 
 594 // Note: the INPUTS in sig_bt are in units of Java argument words, which are
 595 // either 32-bit or 64-bit depending on the build. The OUTPUTS are in 32-bit
 596 // units regardless of build. Of course for i486 there is no 64 bit build
 597 
 598 // The Java calling convention is a &quot;shifted&quot; version of the C ABI.
 599 // By skipping the first C ABI register we can call non-static jni methods
 600 // with small numbers of arguments without having to shuffle the arguments
 601 // at all. Since we control the java ABI we ought to at least get some
 602 // advantage out of it.
 603 
 604 const VMReg java_iarg_reg[8] = {
 605   R3-&gt;as_VMReg(),
 606   R4-&gt;as_VMReg(),
 607   R5-&gt;as_VMReg(),
 608   R6-&gt;as_VMReg(),
 609   R7-&gt;as_VMReg(),
 610   R8-&gt;as_VMReg(),
 611   R9-&gt;as_VMReg(),
 612   R10-&gt;as_VMReg()
 613 };
 614 
 615 const VMReg java_farg_reg[13] = {
 616   F1-&gt;as_VMReg(),
 617   F2-&gt;as_VMReg(),
 618   F3-&gt;as_VMReg(),
 619   F4-&gt;as_VMReg(),
 620   F5-&gt;as_VMReg(),
 621   F6-&gt;as_VMReg(),
 622   F7-&gt;as_VMReg(),
 623   F8-&gt;as_VMReg(),
 624   F9-&gt;as_VMReg(),
 625   F10-&gt;as_VMReg(),
 626   F11-&gt;as_VMReg(),
 627   F12-&gt;as_VMReg(),
 628   F13-&gt;as_VMReg()
 629 };
 630 
 631 const int num_java_iarg_registers = sizeof(java_iarg_reg) / sizeof(java_iarg_reg[0]);
 632 const int num_java_farg_registers = sizeof(java_farg_reg) / sizeof(java_farg_reg[0]);
 633 
 634 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 635                                            VMRegPair *regs,
 636                                            int total_args_passed,
 637                                            int is_outgoing) {
 638   // C2c calling conventions for compiled-compiled calls.
 639   // Put 8 ints/longs into registers _AND_ 13 float/doubles into
 640   // registers _AND_ put the rest on the stack.
 641 
 642   const int inc_stk_for_intfloat   = 1; // 1 slots for ints and floats
 643   const int inc_stk_for_longdouble = 2; // 2 slots for longs and doubles
 644 
 645   int i;
 646   VMReg reg;
 647   int stk = 0;
 648   int ireg = 0;
 649   int freg = 0;
 650 
 651   // We put the first 8 arguments into registers and the rest on the
 652   // stack, float arguments are already in their argument registers
 653   // due to c2c calling conventions (see calling_convention).
 654   for (int i = 0; i &lt; total_args_passed; ++i) {
 655     switch(sig_bt[i]) {
 656     case T_BOOLEAN:
 657     case T_CHAR:
 658     case T_BYTE:
 659     case T_SHORT:
 660     case T_INT:
 661       if (ireg &lt; num_java_iarg_registers) {
 662         // Put int/ptr in register
 663         reg = java_iarg_reg[ireg];
 664         ++ireg;
 665       } else {
 666         // Put int/ptr on stack.
 667         reg = VMRegImpl::stack2reg(stk);
 668         stk += inc_stk_for_intfloat;
 669       }
 670       regs[i].set1(reg);
 671       break;
 672     case T_LONG:
 673       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;expecting half&quot;);
 674       if (ireg &lt; num_java_iarg_registers) {
 675         // Put long in register.
 676         reg = java_iarg_reg[ireg];
 677         ++ireg;
 678       } else {
 679         // Put long on stack. They must be aligned to 2 slots.
 680         if (stk &amp; 0x1) ++stk;
 681         reg = VMRegImpl::stack2reg(stk);
 682         stk += inc_stk_for_longdouble;
 683       }
 684       regs[i].set2(reg);
 685       break;
 686     case T_OBJECT:
 687     case T_ARRAY:
 688     case T_ADDRESS:
 689       if (ireg &lt; num_java_iarg_registers) {
 690         // Put ptr in register.
 691         reg = java_iarg_reg[ireg];
 692         ++ireg;
 693       } else {
 694         // Put ptr on stack. Objects must be aligned to 2 slots too,
 695         // because &quot;64-bit pointers record oop-ishness on 2 aligned
 696         // adjacent registers.&quot; (see OopFlow::build_oop_map).
 697         if (stk &amp; 0x1) ++stk;
 698         reg = VMRegImpl::stack2reg(stk);
 699         stk += inc_stk_for_longdouble;
 700       }
 701       regs[i].set2(reg);
 702       break;
 703     case T_FLOAT:
 704       if (freg &lt; num_java_farg_registers) {
 705         // Put float in register.
 706         reg = java_farg_reg[freg];
 707         ++freg;
 708       } else {
 709         // Put float on stack.
 710         reg = VMRegImpl::stack2reg(stk);
 711         stk += inc_stk_for_intfloat;
 712       }
 713       regs[i].set1(reg);
 714       break;
 715     case T_DOUBLE:
 716       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;expecting half&quot;);
 717       if (freg &lt; num_java_farg_registers) {
 718         // Put double in register.
 719         reg = java_farg_reg[freg];
 720         ++freg;
 721       } else {
 722         // Put double on stack. They must be aligned to 2 slots.
 723         if (stk &amp; 0x1) ++stk;
 724         reg = VMRegImpl::stack2reg(stk);
 725         stk += inc_stk_for_longdouble;
 726       }
 727       regs[i].set2(reg);
 728       break;
 729     case T_VOID:
 730       // Do not count halves.
 731       regs[i].set_bad();
 732       break;
 733     default:
 734       ShouldNotReachHere();
 735     }
 736   }
 737   return align_up(stk, 2);
 738 }
 739 
 740 #if defined(COMPILER1) || defined(COMPILER2)
 741 // Calling convention for calling C code.
 742 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 743                                         VMRegPair *regs,
 744                                         VMRegPair *regs2,
 745                                         int total_args_passed) {
 746   // Calling conventions for C runtime calls and calls to JNI native methods.
 747   //
 748   // PPC64 convention: Hoist the first 8 int/ptr/long&#39;s in the first 8
 749   // int regs, leaving int regs undefined if the arg is flt/dbl. Hoist
 750   // the first 13 flt/dbl&#39;s in the first 13 fp regs but additionally
 751   // copy flt/dbl to the stack if they are beyond the 8th argument.
 752 
 753   const VMReg iarg_reg[8] = {
 754     R3-&gt;as_VMReg(),
 755     R4-&gt;as_VMReg(),
 756     R5-&gt;as_VMReg(),
 757     R6-&gt;as_VMReg(),
 758     R7-&gt;as_VMReg(),
 759     R8-&gt;as_VMReg(),
 760     R9-&gt;as_VMReg(),
 761     R10-&gt;as_VMReg()
 762   };
 763 
 764   const VMReg farg_reg[13] = {
 765     F1-&gt;as_VMReg(),
 766     F2-&gt;as_VMReg(),
 767     F3-&gt;as_VMReg(),
 768     F4-&gt;as_VMReg(),
 769     F5-&gt;as_VMReg(),
 770     F6-&gt;as_VMReg(),
 771     F7-&gt;as_VMReg(),
 772     F8-&gt;as_VMReg(),
 773     F9-&gt;as_VMReg(),
 774     F10-&gt;as_VMReg(),
 775     F11-&gt;as_VMReg(),
 776     F12-&gt;as_VMReg(),
 777     F13-&gt;as_VMReg()
 778   };
 779 
 780   // Check calling conventions consistency.
 781   assert(sizeof(iarg_reg) / sizeof(iarg_reg[0]) == Argument::n_int_register_parameters_c &amp;&amp;
 782          sizeof(farg_reg) / sizeof(farg_reg[0]) == Argument::n_float_register_parameters_c,
 783          &quot;consistency&quot;);
 784 
 785   // `Stk&#39; counts stack slots. Due to alignment, 32 bit values occupy
 786   // 2 such slots, like 64 bit values do.
 787   const int inc_stk_for_intfloat   = 2; // 2 slots for ints and floats
 788   const int inc_stk_for_longdouble = 2; // 2 slots for longs and doubles
 789 
 790   int i;
 791   VMReg reg;
 792   // Leave room for C-compatible ABI_REG_ARGS.
 793   int stk = (frame::abi_reg_args_size - frame::jit_out_preserve_size) / VMRegImpl::stack_slot_size;
 794   int arg = 0;
 795   int freg = 0;
 796 
 797   // Avoid passing C arguments in the wrong stack slots.
 798 #if defined(ABI_ELFv2)
 799   assert((SharedRuntime::out_preserve_stack_slots() + stk) * VMRegImpl::stack_slot_size == 96,
 800          &quot;passing C arguments in wrong stack slots&quot;);
 801 #else
 802   assert((SharedRuntime::out_preserve_stack_slots() + stk) * VMRegImpl::stack_slot_size == 112,
 803          &quot;passing C arguments in wrong stack slots&quot;);
 804 #endif
 805   // We fill-out regs AND regs2 if an argument must be passed in a
 806   // register AND in a stack slot. If regs2 is NULL in such a
 807   // situation, we bail-out with a fatal error.
 808   for (int i = 0; i &lt; total_args_passed; ++i, ++arg) {
 809     // Initialize regs2 to BAD.
 810     if (regs2 != NULL) regs2[i].set_bad();
 811 
 812     switch(sig_bt[i]) {
 813 
 814     //
 815     // If arguments 0-7 are integers, they are passed in integer registers.
 816     // Argument i is placed in iarg_reg[i].
 817     //
 818     case T_BOOLEAN:
 819     case T_CHAR:
 820     case T_BYTE:
 821     case T_SHORT:
 822     case T_INT:
 823       // We must cast ints to longs and use full 64 bit stack slots
 824       // here.  Thus fall through, handle as long.
 825     case T_LONG:
 826     case T_OBJECT:
 827     case T_ARRAY:
 828     case T_ADDRESS:
 829     case T_METADATA:
 830       // Oops are already boxed if required (JNI).
 831       if (arg &lt; Argument::n_int_register_parameters_c) {
 832         reg = iarg_reg[arg];
 833       } else {
 834         reg = VMRegImpl::stack2reg(stk);
 835         stk += inc_stk_for_longdouble;
 836       }
 837       regs[i].set2(reg);
 838       break;
 839 
 840     //
 841     // Floats are treated differently from int regs:  The first 13 float arguments
 842     // are passed in registers (not the float args among the first 13 args).
 843     // Thus argument i is NOT passed in farg_reg[i] if it is float.  It is passed
 844     // in farg_reg[j] if argument i is the j-th float argument of this call.
 845     //
 846     case T_FLOAT:
 847 #if defined(LINUX)
 848       // Linux uses ELF ABI. Both original ELF and ELFv2 ABIs have float
 849       // in the least significant word of an argument slot.
 850 #if defined(VM_LITTLE_ENDIAN)
 851 #define FLOAT_WORD_OFFSET_IN_SLOT 0
 852 #else
 853 #define FLOAT_WORD_OFFSET_IN_SLOT 1
 854 #endif
 855 #elif defined(AIX)
 856       // Although AIX runs on big endian CPU, float is in the most
 857       // significant word of an argument slot.
 858 #define FLOAT_WORD_OFFSET_IN_SLOT 0
 859 #else
 860 #error &quot;unknown OS&quot;
 861 #endif
 862       if (freg &lt; Argument::n_float_register_parameters_c) {
 863         // Put float in register ...
 864         reg = farg_reg[freg];
 865         ++freg;
 866 
 867         // Argument i for i &gt; 8 is placed on the stack even if it&#39;s
 868         // placed in a register (if it&#39;s a float arg). Aix disassembly
 869         // shows that xlC places these float args on the stack AND in
 870         // a register. This is not documented, but we follow this
 871         // convention, too.
 872         if (arg &gt;= Argument::n_regs_not_on_stack_c) {
 873           // ... and on the stack.
 874           guarantee(regs2 != NULL, &quot;must pass float in register and stack slot&quot;);
 875           VMReg reg2 = VMRegImpl::stack2reg(stk + FLOAT_WORD_OFFSET_IN_SLOT);
 876           regs2[i].set1(reg2);
 877           stk += inc_stk_for_intfloat;
 878         }
 879 
 880       } else {
 881         // Put float on stack.
 882         reg = VMRegImpl::stack2reg(stk + FLOAT_WORD_OFFSET_IN_SLOT);
 883         stk += inc_stk_for_intfloat;
 884       }
 885       regs[i].set1(reg);
 886       break;
 887     case T_DOUBLE:
 888       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;expecting half&quot;);
 889       if (freg &lt; Argument::n_float_register_parameters_c) {
 890         // Put double in register ...
 891         reg = farg_reg[freg];
 892         ++freg;
 893 
 894         // Argument i for i &gt; 8 is placed on the stack even if it&#39;s
 895         // placed in a register (if it&#39;s a double arg). Aix disassembly
 896         // shows that xlC places these float args on the stack AND in
 897         // a register. This is not documented, but we follow this
 898         // convention, too.
 899         if (arg &gt;= Argument::n_regs_not_on_stack_c) {
 900           // ... and on the stack.
 901           guarantee(regs2 != NULL, &quot;must pass float in register and stack slot&quot;);
 902           VMReg reg2 = VMRegImpl::stack2reg(stk);
 903           regs2[i].set2(reg2);
 904           stk += inc_stk_for_longdouble;
 905         }
 906       } else {
 907         // Put double on stack.
 908         reg = VMRegImpl::stack2reg(stk);
 909         stk += inc_stk_for_longdouble;
 910       }
 911       regs[i].set2(reg);
 912       break;
 913 
 914     case T_VOID:
 915       // Do not count halves.
 916       regs[i].set_bad();
 917       --arg;
 918       break;
 919     default:
 920       ShouldNotReachHere();
 921     }
 922   }
 923 
 924   return align_up(stk, 2);
 925 }
 926 #endif // COMPILER2
 927 
 928 static address gen_c2i_adapter(MacroAssembler *masm,
 929                             int total_args_passed,
 930                             int comp_args_on_stack,
 931                             const BasicType *sig_bt,
 932                             const VMRegPair *regs,
 933                             Label&amp; call_interpreter,
 934                             const Register&amp; ientry) {
 935 
 936   address c2i_entrypoint;
 937 
 938   const Register sender_SP = R21_sender_SP; // == R21_tmp1
 939   const Register code      = R22_tmp2;
 940   //const Register ientry  = R23_tmp3;
 941   const Register value_regs[] = { R24_tmp4, R25_tmp5, R26_tmp6 };
 942   const int num_value_regs = sizeof(value_regs) / sizeof(Register);
 943   int value_regs_index = 0;
 944 
 945   const Register return_pc = R27_tmp7;
 946   const Register tmp       = R28_tmp8;
 947 
 948   assert_different_registers(sender_SP, code, ientry, return_pc, tmp);
 949 
 950   // Adapter needs TOP_IJAVA_FRAME_ABI.
 951   const int adapter_size = frame::top_ijava_frame_abi_size +
 952                            align_up(total_args_passed * wordSize, frame::alignment_in_bytes);
 953 
 954   // regular (verified) c2i entry point
 955   c2i_entrypoint = __ pc();
 956 
 957   // Does compiled code exists? If yes, patch the caller&#39;s callsite.
 958   __ ld(code, method_(code));
 959   __ cmpdi(CCR0, code, 0);
 960   __ ld(ientry, method_(interpreter_entry)); // preloaded
 961   __ beq(CCR0, call_interpreter);
 962 
 963 
 964   // Patch caller&#39;s callsite, method_(code) was not NULL which means that
 965   // compiled code exists.
 966   __ mflr(return_pc);
 967   __ std(return_pc, _abi(lr), R1_SP);
 968   RegisterSaver::push_frame_and_save_argument_registers(masm, tmp, adapter_size, total_args_passed, regs);
 969 
 970   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite), R19_method, return_pc);
 971 
 972   RegisterSaver::restore_argument_registers_and_pop_frame(masm, adapter_size, total_args_passed, regs);
 973   __ ld(return_pc, _abi(lr), R1_SP);
 974   __ ld(ientry, method_(interpreter_entry)); // preloaded
 975   __ mtlr(return_pc);
 976 
 977 
 978   // Call the interpreter.
 979   __ BIND(call_interpreter);
 980   __ mtctr(ientry);
 981 
 982   // Get a copy of the current SP for loading caller&#39;s arguments.
 983   __ mr(sender_SP, R1_SP);
 984 
 985   // Add space for the adapter.
 986   __ resize_frame(-adapter_size, R12_scratch2);
 987 
 988   int st_off = adapter_size - wordSize;
 989 
 990   // Write the args into the outgoing interpreter space.
 991   for (int i = 0; i &lt; total_args_passed; i++) {
 992     VMReg r_1 = regs[i].first();
 993     VMReg r_2 = regs[i].second();
 994     if (!r_1-&gt;is_valid()) {
 995       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 996       continue;
 997     }
 998     if (r_1-&gt;is_stack()) {
 999       Register tmp_reg = value_regs[value_regs_index];
1000       value_regs_index = (value_regs_index + 1) % num_value_regs;
1001       // The calling convention produces OptoRegs that ignore the out
1002       // preserve area (JIT&#39;s ABI). We must account for it here.
1003       int ld_off = (r_1-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
1004       if (!r_2-&gt;is_valid()) {
1005         __ lwz(tmp_reg, ld_off, sender_SP);
1006       } else {
1007         __ ld(tmp_reg, ld_off, sender_SP);
1008       }
1009       // Pretend stack targets were loaded into tmp_reg.
1010       r_1 = tmp_reg-&gt;as_VMReg();
1011     }
1012 
1013     if (r_1-&gt;is_Register()) {
1014       Register r = r_1-&gt;as_Register();
1015       if (!r_2-&gt;is_valid()) {
1016         __ stw(r, st_off, R1_SP);
1017         st_off-=wordSize;
1018       } else {
1019         // Longs are given 2 64-bit slots in the interpreter, but the
1020         // data is passed in only 1 slot.
1021         if (sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
1022           DEBUG_ONLY( __ li(tmp, 0); __ std(tmp, st_off, R1_SP); )
1023           st_off-=wordSize;
1024         }
1025         __ std(r, st_off, R1_SP);
1026         st_off-=wordSize;
1027       }
1028     } else {
1029       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
1030       FloatRegister f = r_1-&gt;as_FloatRegister();
1031       if (!r_2-&gt;is_valid()) {
1032         __ stfs(f, st_off, R1_SP);
1033         st_off-=wordSize;
1034       } else {
1035         // In 64bit, doubles are given 2 64-bit slots in the interpreter, but the
1036         // data is passed in only 1 slot.
1037         // One of these should get known junk...
1038         DEBUG_ONLY( __ li(tmp, 0); __ std(tmp, st_off, R1_SP); )
1039         st_off-=wordSize;
1040         __ stfd(f, st_off, R1_SP);
1041         st_off-=wordSize;
1042       }
1043     }
1044   }
1045 
1046   // Jump to the interpreter just as if interpreter was doing it.
1047 
1048   __ load_const_optimized(R25_templateTableBase, (address)Interpreter::dispatch_table((TosState)0), R11_scratch1);
1049 
1050   // load TOS
1051   __ addi(R15_esp, R1_SP, st_off);
1052 
1053   // Frame_manager expects initial_caller_sp (= SP without resize by c2i) in R21_tmp1.
1054   assert(sender_SP == R21_sender_SP, &quot;passing initial caller&#39;s SP in wrong register&quot;);
1055   __ bctr();
1056 
1057   return c2i_entrypoint;
1058 }
1059 
1060 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,
1061                                     int total_args_passed,
1062                                     int comp_args_on_stack,
1063                                     const BasicType *sig_bt,
1064                                     const VMRegPair *regs) {
1065 
1066   // Load method&#39;s entry-point from method.
1067   __ ld(R12_scratch2, in_bytes(Method::from_compiled_offset()), R19_method);
1068   __ mtctr(R12_scratch2);
1069 
1070   // We will only enter here from an interpreted frame and never from after
1071   // passing thru a c2i. Azul allowed this but we do not. If we lose the
1072   // race and use a c2i we will remain interpreted for the race loser(s).
1073   // This removes all sorts of headaches on the x86 side and also eliminates
1074   // the possibility of having c2i -&gt; i2c -&gt; c2i -&gt; ... endless transitions.
1075 
1076   // Note: r13 contains the senderSP on entry. We must preserve it since
1077   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
1078   // code goes non-entrant while we get args ready.
1079   // In addition we use r13 to locate all the interpreter args as
1080   // we must align the stack to 16 bytes on an i2c entry else we
1081   // lose alignment we expect in all compiled code and register
1082   // save code can segv when fxsave instructions find improperly
1083   // aligned stack pointer.
1084 
1085   const Register ld_ptr = R15_esp;
1086   const Register value_regs[] = { R22_tmp2, R23_tmp3, R24_tmp4, R25_tmp5, R26_tmp6 };
1087   const int num_value_regs = sizeof(value_regs) / sizeof(Register);
1088   int value_regs_index = 0;
1089 
1090   int ld_offset = total_args_passed*wordSize;
1091 
1092   // Cut-out for having no stack args. Since up to 2 int/oop args are passed
1093   // in registers, we will occasionally have no stack args.
1094   int comp_words_on_stack = 0;
1095   if (comp_args_on_stack) {
1096     // Sig words on the stack are greater-than VMRegImpl::stack0. Those in
1097     // registers are below. By subtracting stack0, we either get a negative
1098     // number (all values in registers) or the maximum stack slot accessed.
1099 
1100     // Convert 4-byte c2 stack slots to words.
1101     comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;
1102     // Round up to miminum stack alignment, in wordSize.
1103     comp_words_on_stack = align_up(comp_words_on_stack, 2);
1104     __ resize_frame(-comp_words_on_stack * wordSize, R11_scratch1);
1105   }
1106 
1107   // Now generate the shuffle code.  Pick up all register args and move the
1108   // rest through register value=Z_R12.
1109   BLOCK_COMMENT(&quot;Shuffle arguments&quot;);
1110   for (int i = 0; i &lt; total_args_passed; i++) {
1111     if (sig_bt[i] == T_VOID) {
1112       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
1113       continue;
1114     }
1115 
1116     // Pick up 0, 1 or 2 words from ld_ptr.
1117     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
1118             &quot;scrambled load targets?&quot;);
1119     VMReg r_1 = regs[i].first();
1120     VMReg r_2 = regs[i].second();
1121     if (!r_1-&gt;is_valid()) {
1122       assert(!r_2-&gt;is_valid(), &quot;&quot;);
1123       continue;
1124     }
1125     if (r_1-&gt;is_FloatRegister()) {
1126       if (!r_2-&gt;is_valid()) {
1127         __ lfs(r_1-&gt;as_FloatRegister(), ld_offset, ld_ptr);
1128         ld_offset-=wordSize;
1129       } else {
1130         // Skip the unused interpreter slot.
1131         __ lfd(r_1-&gt;as_FloatRegister(), ld_offset-wordSize, ld_ptr);
1132         ld_offset-=2*wordSize;
1133       }
1134     } else {
1135       Register r;
1136       if (r_1-&gt;is_stack()) {
1137         // Must do a memory to memory move thru &quot;value&quot;.
1138         r = value_regs[value_regs_index];
1139         value_regs_index = (value_regs_index + 1) % num_value_regs;
1140       } else {
1141         r = r_1-&gt;as_Register();
1142       }
1143       if (!r_2-&gt;is_valid()) {
1144         // Not sure we need to do this but it shouldn&#39;t hurt.
1145         if (sig_bt[i] == T_OBJECT || sig_bt[i] == T_ADDRESS || sig_bt[i] == T_ARRAY) {
1146           __ ld(r, ld_offset, ld_ptr);
1147           ld_offset-=wordSize;
1148         } else {
1149           __ lwz(r, ld_offset, ld_ptr);
1150           ld_offset-=wordSize;
1151         }
1152       } else {
1153         // In 64bit, longs are given 2 64-bit slots in the interpreter, but the
1154         // data is passed in only 1 slot.
1155         if (sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
1156           ld_offset-=wordSize;
1157         }
1158         __ ld(r, ld_offset, ld_ptr);
1159         ld_offset-=wordSize;
1160       }
1161 
1162       if (r_1-&gt;is_stack()) {
1163         // Now store value where the compiler expects it
1164         int st_off = (r_1-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots())*VMRegImpl::stack_slot_size;
1165 
1166         if (sig_bt[i] == T_INT   || sig_bt[i] == T_FLOAT ||sig_bt[i] == T_BOOLEAN ||
1167             sig_bt[i] == T_SHORT || sig_bt[i] == T_CHAR  || sig_bt[i] == T_BYTE) {
1168           __ stw(r, st_off, R1_SP);
1169         } else {
1170           __ std(r, st_off, R1_SP);
1171         }
1172       }
1173     }
1174   }
1175 
1176   BLOCK_COMMENT(&quot;Store method&quot;);
1177   // Store method into thread-&gt;callee_target.
1178   // We might end up in handle_wrong_method if the callee is
1179   // deoptimized as we race thru here. If that happens we don&#39;t want
1180   // to take a safepoint because the caller frame will look
1181   // interpreted and arguments are now &quot;compiled&quot; so it is much better
1182   // to make this transition invisible to the stack walking
1183   // code. Unfortunately if we try and find the callee by normal means
1184   // a safepoint is possible. So we stash the desired callee in the
1185   // thread and the vm will find there should this case occur.
1186   __ std(R19_method, thread_(callee_target));
1187 
1188   // Jump to the compiled code just as if compiled code was doing it.
1189   __ bctr();
1190 }
1191 
1192 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
1193                                                             int total_args_passed,
1194                                                             int comp_args_on_stack,
1195                                                             const BasicType *sig_bt,
1196                                                             const VMRegPair *regs,
1197                                                             AdapterFingerPrint* fingerprint) {
1198   address i2c_entry;
1199   address c2i_unverified_entry;
1200   address c2i_entry;
1201 
1202 
1203   // entry: i2c
1204 
1205   __ align(CodeEntryAlignment);
1206   i2c_entry = __ pc();
1207   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
1208 
1209 
1210   // entry: c2i unverified
1211 
1212   __ align(CodeEntryAlignment);
1213   BLOCK_COMMENT(&quot;c2i unverified entry&quot;);
1214   c2i_unverified_entry = __ pc();
1215 
1216   // inline_cache contains a compiledICHolder
1217   const Register ic             = R19_method;
1218   const Register ic_klass       = R11_scratch1;
1219   const Register receiver_klass = R12_scratch2;
1220   const Register code           = R21_tmp1;
1221   const Register ientry         = R23_tmp3;
1222 
1223   assert_different_registers(ic, ic_klass, receiver_klass, R3_ARG1, code, ientry);
1224   assert(R11_scratch1 == R11, &quot;need prologue scratch register&quot;);
1225 
1226   Label call_interpreter;
1227 
1228   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()),
1229          &quot;klass offset should reach into any page&quot;);
1230   // Check for NULL argument if we don&#39;t have implicit null checks.
1231   if (!ImplicitNullChecks || !os::zero_page_read_protected()) {
1232     if (TrapBasedNullChecks) {
1233       __ trap_null_check(R3_ARG1);
1234     } else {
1235       Label valid;
1236       __ cmpdi(CCR0, R3_ARG1, 0);
1237       __ bne_predict_taken(CCR0, valid);
1238       // We have a null argument, branch to ic_miss_stub.
1239       __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
1240                        relocInfo::runtime_call_type);
1241       __ BIND(valid);
1242     }
1243   }
1244   // Assume argument is not NULL, load klass from receiver.
1245   __ load_klass(receiver_klass, R3_ARG1);
1246 
1247   __ ld(ic_klass, CompiledICHolder::holder_klass_offset(), ic);
1248 
1249   if (TrapBasedICMissChecks) {
1250     __ trap_ic_miss_check(receiver_klass, ic_klass);
1251   } else {
1252     Label valid;
1253     __ cmpd(CCR0, receiver_klass, ic_klass);
1254     __ beq_predict_taken(CCR0, valid);
1255     // We have an unexpected klass, branch to ic_miss_stub.
1256     __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
1257                      relocInfo::runtime_call_type);
1258     __ BIND(valid);
1259   }
1260 
1261   // Argument is valid and klass is as expected, continue.
1262 
1263   // Extract method from inline cache, verified entry point needs it.
1264   __ ld(R19_method, CompiledICHolder::holder_metadata_offset(), ic);
1265   assert(R19_method == ic, &quot;the inline cache register is dead here&quot;);
1266 
1267   __ ld(code, method_(code));
1268   __ cmpdi(CCR0, code, 0);
1269   __ ld(ientry, method_(interpreter_entry)); // preloaded
1270   __ beq_predict_taken(CCR0, call_interpreter);
1271 
1272   // Branch to ic_miss_stub.
1273   __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type);
1274 
1275   // entry: c2i
1276 
1277   c2i_entry = gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, call_interpreter, ientry);
1278 
1279   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);
1280 }
1281 
1282 #ifdef COMPILER2
1283 // An oop arg. Must pass a handle not the oop itself.
1284 static void object_move(MacroAssembler* masm,
1285                         int frame_size_in_slots,
1286                         OopMap* oop_map, int oop_handle_offset,
1287                         bool is_receiver, int* receiver_offset,
1288                         VMRegPair src, VMRegPair dst,
1289                         Register r_caller_sp, Register r_temp_1, Register r_temp_2) {
1290   assert(!is_receiver || (is_receiver &amp;&amp; (*receiver_offset == -1)),
1291          &quot;receiver has already been moved&quot;);
1292 
1293   // We must pass a handle. First figure out the location we use as a handle.
1294 
1295   if (src.first()-&gt;is_stack()) {
1296     // stack to stack or reg
1297 
1298     const Register r_handle = dst.first()-&gt;is_stack() ? r_temp_1 : dst.first()-&gt;as_Register();
1299     Label skip;
1300     const int oop_slot_in_callers_frame = reg2slot(src.first());
1301 
1302     guarantee(!is_receiver, &quot;expecting receiver in register&quot;);
1303     oop_map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot_in_callers_frame + frame_size_in_slots));
1304 
1305     __ addi(r_handle, r_caller_sp, reg2offset(src.first()));
1306     __ ld(  r_temp_2, reg2offset(src.first()), r_caller_sp);
1307     __ cmpdi(CCR0, r_temp_2, 0);
1308     __ bne(CCR0, skip);
1309     // Use a NULL handle if oop is NULL.
1310     __ li(r_handle, 0);
1311     __ bind(skip);
1312 
1313     if (dst.first()-&gt;is_stack()) {
1314       // stack to stack
1315       __ std(r_handle, reg2offset(dst.first()), R1_SP);
1316     } else {
1317       // stack to reg
1318       // Nothing to do, r_handle is already the dst register.
1319     }
1320   } else {
1321     // reg to stack or reg
1322     const Register r_oop      = src.first()-&gt;as_Register();
1323     const Register r_handle   = dst.first()-&gt;is_stack() ? r_temp_1 : dst.first()-&gt;as_Register();
1324     const int oop_slot        = (r_oop-&gt;encoding()-R3_ARG1-&gt;encoding()) * VMRegImpl::slots_per_word
1325                                 + oop_handle_offset; // in slots
1326     const int oop_offset = oop_slot * VMRegImpl::stack_slot_size;
1327     Label skip;
1328 
1329     if (is_receiver) {
1330       *receiver_offset = oop_offset;
1331     }
1332     oop_map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot));
1333 
1334     __ std( r_oop,    oop_offset, R1_SP);
1335     __ addi(r_handle, R1_SP, oop_offset);
1336 
1337     __ cmpdi(CCR0, r_oop, 0);
1338     __ bne(CCR0, skip);
1339     // Use a NULL handle if oop is NULL.
1340     __ li(r_handle, 0);
1341     __ bind(skip);
1342 
1343     if (dst.first()-&gt;is_stack()) {
1344       // reg to stack
1345       __ std(r_handle, reg2offset(dst.first()), R1_SP);
1346     } else {
1347       // reg to reg
1348       // Nothing to do, r_handle is already the dst register.
1349     }
1350   }
1351 }
1352 
1353 static void int_move(MacroAssembler*masm,
1354                      VMRegPair src, VMRegPair dst,
1355                      Register r_caller_sp, Register r_temp) {
1356   assert(src.first()-&gt;is_valid(), &quot;incoming must be int&quot;);
1357   assert(dst.first()-&gt;is_valid() &amp;&amp; dst.second() == dst.first()-&gt;next(), &quot;outgoing must be long&quot;);
1358 
1359   if (src.first()-&gt;is_stack()) {
1360     if (dst.first()-&gt;is_stack()) {
1361       // stack to stack
1362       __ lwa(r_temp, reg2offset(src.first()), r_caller_sp);
1363       __ std(r_temp, reg2offset(dst.first()), R1_SP);
1364     } else {
1365       // stack to reg
1366       __ lwa(dst.first()-&gt;as_Register(), reg2offset(src.first()), r_caller_sp);
1367     }
1368   } else if (dst.first()-&gt;is_stack()) {
1369     // reg to stack
1370     __ extsw(r_temp, src.first()-&gt;as_Register());
1371     __ std(r_temp, reg2offset(dst.first()), R1_SP);
1372   } else {
1373     // reg to reg
1374     __ extsw(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1375   }
1376 }
1377 
1378 static void long_move(MacroAssembler*masm,
1379                       VMRegPair src, VMRegPair dst,
1380                       Register r_caller_sp, Register r_temp) {
1381   assert(src.first()-&gt;is_valid() &amp;&amp; src.second() == src.first()-&gt;next(), &quot;incoming must be long&quot;);
1382   assert(dst.first()-&gt;is_valid() &amp;&amp; dst.second() == dst.first()-&gt;next(), &quot;outgoing must be long&quot;);
1383 
1384   if (src.first()-&gt;is_stack()) {
1385     if (dst.first()-&gt;is_stack()) {
1386       // stack to stack
1387       __ ld( r_temp, reg2offset(src.first()), r_caller_sp);
1388       __ std(r_temp, reg2offset(dst.first()), R1_SP);
1389     } else {
1390       // stack to reg
1391       __ ld(dst.first()-&gt;as_Register(), reg2offset(src.first()), r_caller_sp);
1392     }
1393   } else if (dst.first()-&gt;is_stack()) {
1394     // reg to stack
1395     __ std(src.first()-&gt;as_Register(), reg2offset(dst.first()), R1_SP);
1396   } else {
1397     // reg to reg
1398     if (dst.first()-&gt;as_Register() != src.first()-&gt;as_Register())
1399       __ mr(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1400   }
1401 }
1402 
1403 static void float_move(MacroAssembler*masm,
1404                        VMRegPair src, VMRegPair dst,
1405                        Register r_caller_sp, Register r_temp) {
1406   assert(src.first()-&gt;is_valid() &amp;&amp; !src.second()-&gt;is_valid(), &quot;incoming must be float&quot;);
1407   assert(dst.first()-&gt;is_valid() &amp;&amp; !dst.second()-&gt;is_valid(), &quot;outgoing must be float&quot;);
1408 
1409   if (src.first()-&gt;is_stack()) {
1410     if (dst.first()-&gt;is_stack()) {
1411       // stack to stack
1412       __ lwz(r_temp, reg2offset(src.first()), r_caller_sp);
1413       __ stw(r_temp, reg2offset(dst.first()), R1_SP);
1414     } else {
1415       // stack to reg
1416       __ lfs(dst.first()-&gt;as_FloatRegister(), reg2offset(src.first()), r_caller_sp);
1417     }
1418   } else if (dst.first()-&gt;is_stack()) {
1419     // reg to stack
1420     __ stfs(src.first()-&gt;as_FloatRegister(), reg2offset(dst.first()), R1_SP);
1421   } else {
1422     // reg to reg
1423     if (dst.first()-&gt;as_FloatRegister() != src.first()-&gt;as_FloatRegister())
1424       __ fmr(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
1425   }
1426 }
1427 
1428 static void double_move(MacroAssembler*masm,
1429                         VMRegPair src, VMRegPair dst,
1430                         Register r_caller_sp, Register r_temp) {
1431   assert(src.first()-&gt;is_valid() &amp;&amp; src.second() == src.first()-&gt;next(), &quot;incoming must be double&quot;);
1432   assert(dst.first()-&gt;is_valid() &amp;&amp; dst.second() == dst.first()-&gt;next(), &quot;outgoing must be double&quot;);
1433 
1434   if (src.first()-&gt;is_stack()) {
1435     if (dst.first()-&gt;is_stack()) {
1436       // stack to stack
1437       __ ld( r_temp, reg2offset(src.first()), r_caller_sp);
1438       __ std(r_temp, reg2offset(dst.first()), R1_SP);
1439     } else {
1440       // stack to reg
1441       __ lfd(dst.first()-&gt;as_FloatRegister(), reg2offset(src.first()), r_caller_sp);
1442     }
1443   } else if (dst.first()-&gt;is_stack()) {
1444     // reg to stack
1445     __ stfd(src.first()-&gt;as_FloatRegister(), reg2offset(dst.first()), R1_SP);
1446   } else {
1447     // reg to reg
1448     if (dst.first()-&gt;as_FloatRegister() != src.first()-&gt;as_FloatRegister())
1449       __ fmr(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
1450   }
1451 }
1452 
1453 void SharedRuntime::save_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1454   switch (ret_type) {
1455     case T_BOOLEAN:
1456     case T_CHAR:
1457     case T_BYTE:
1458     case T_SHORT:
1459     case T_INT:
1460       __ stw (R3_RET,  frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1461       break;
1462     case T_ARRAY:
1463     case T_OBJECT:
1464     case T_LONG:
1465       __ std (R3_RET,  frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1466       break;
1467     case T_FLOAT:
1468       __ stfs(F1_RET, frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1469       break;
1470     case T_DOUBLE:
1471       __ stfd(F1_RET, frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1472       break;
1473     case T_VOID:
1474       break;
1475     default:
1476       ShouldNotReachHere();
1477       break;
1478   }
1479 }
1480 
1481 void SharedRuntime::restore_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1482   switch (ret_type) {
1483     case T_BOOLEAN:
1484     case T_CHAR:
1485     case T_BYTE:
1486     case T_SHORT:
1487     case T_INT:
1488       __ lwz(R3_RET,  frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1489       break;
1490     case T_ARRAY:
1491     case T_OBJECT:
1492     case T_LONG:
1493       __ ld (R3_RET,  frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1494       break;
1495     case T_FLOAT:
1496       __ lfs(F1_RET, frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1497       break;
1498     case T_DOUBLE:
1499       __ lfd(F1_RET, frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1500       break;
1501     case T_VOID:
1502       break;
1503     default:
1504       ShouldNotReachHere();
1505       break;
1506   }
1507 }
1508 
1509 static void save_or_restore_arguments(MacroAssembler* masm,
1510                                       const int stack_slots,
1511                                       const int total_in_args,
1512                                       const int arg_save_area,
1513                                       OopMap* map,
1514                                       VMRegPair* in_regs,
1515                                       BasicType* in_sig_bt) {
1516   // If map is non-NULL then the code should store the values,
1517   // otherwise it should load them.
1518   int slot = arg_save_area;
1519   // Save down double word first.
1520   for (int i = 0; i &lt; total_in_args; i++) {
1521     if (in_regs[i].first()-&gt;is_FloatRegister() &amp;&amp; in_sig_bt[i] == T_DOUBLE) {
1522       int offset = slot * VMRegImpl::stack_slot_size;
1523       slot += VMRegImpl::slots_per_word;
1524       assert(slot &lt;= stack_slots, &quot;overflow (after DOUBLE stack slot)&quot;);
1525       if (map != NULL) {
1526         __ stfd(in_regs[i].first()-&gt;as_FloatRegister(), offset, R1_SP);
1527       } else {
1528         __ lfd(in_regs[i].first()-&gt;as_FloatRegister(), offset, R1_SP);
1529       }
1530     } else if (in_regs[i].first()-&gt;is_Register() &amp;&amp;
1531         (in_sig_bt[i] == T_LONG || in_sig_bt[i] == T_ARRAY)) {
1532       int offset = slot * VMRegImpl::stack_slot_size;
1533       if (map != NULL) {
1534         __ std(in_regs[i].first()-&gt;as_Register(), offset, R1_SP);
1535         if (in_sig_bt[i] == T_ARRAY) {
1536           map-&gt;set_oop(VMRegImpl::stack2reg(slot));
1537         }
1538       } else {
1539         __ ld(in_regs[i].first()-&gt;as_Register(), offset, R1_SP);
1540       }
1541       slot += VMRegImpl::slots_per_word;
1542       assert(slot &lt;= stack_slots, &quot;overflow (after LONG/ARRAY stack slot)&quot;);
1543     }
1544   }
1545   // Save or restore single word registers.
1546   for (int i = 0; i &lt; total_in_args; i++) {
1547     if (in_regs[i].first()-&gt;is_Register()) {
1548       int offset = slot * VMRegImpl::stack_slot_size;
1549       // Value lives in an input register. Save it on stack.
1550       switch (in_sig_bt[i]) {
1551         case T_BOOLEAN:
1552         case T_CHAR:
1553         case T_BYTE:
1554         case T_SHORT:
1555         case T_INT:
1556           if (map != NULL) {
1557             __ stw(in_regs[i].first()-&gt;as_Register(), offset, R1_SP);
1558           } else {
1559             __ lwa(in_regs[i].first()-&gt;as_Register(), offset, R1_SP);
1560           }
1561           slot++;
1562           assert(slot &lt;= stack_slots, &quot;overflow (after INT or smaller stack slot)&quot;);
1563           break;
1564         case T_ARRAY:
1565         case T_LONG:
1566           // handled above
1567           break;
1568         case T_OBJECT:
1569         default: ShouldNotReachHere();
1570       }
1571     } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1572       if (in_sig_bt[i] == T_FLOAT) {
1573         int offset = slot * VMRegImpl::stack_slot_size;
1574         slot++;
1575         assert(slot &lt;= stack_slots, &quot;overflow (after FLOAT stack slot)&quot;);
1576         if (map != NULL) {
1577           __ stfs(in_regs[i].first()-&gt;as_FloatRegister(), offset, R1_SP);
1578         } else {
1579           __ lfs(in_regs[i].first()-&gt;as_FloatRegister(), offset, R1_SP);
1580         }
1581       }
1582     } else if (in_regs[i].first()-&gt;is_stack()) {
1583       if (in_sig_bt[i] == T_ARRAY &amp;&amp; map != NULL) {
1584         int offset_in_older_frame = in_regs[i].first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1585         map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + stack_slots));
1586       }
1587     }
1588   }
1589 }
1590 
1591 // Check GCLocker::needs_gc and enter the runtime if it&#39;s true. This
1592 // keeps a new JNI critical region from starting until a GC has been
1593 // forced. Save down any oops in registers and describe them in an
1594 // OopMap.
1595 static void check_needs_gc_for_critical_native(MacroAssembler* masm,
1596                                                const int stack_slots,
1597                                                const int total_in_args,
1598                                                const int arg_save_area,
1599                                                OopMapSet* oop_maps,
1600                                                VMRegPair* in_regs,
1601                                                BasicType* in_sig_bt,
1602                                                Register tmp_reg ) {
1603   __ block_comment(&quot;check GCLocker::needs_gc&quot;);
1604   Label cont;
1605   __ lbz(tmp_reg, (RegisterOrConstant)(intptr_t)GCLocker::needs_gc_address());
1606   __ cmplwi(CCR0, tmp_reg, 0);
1607   __ beq(CCR0, cont);
1608 
1609   // Save down any values that are live in registers and call into the
1610   // runtime to halt for a GC.
1611   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1612   save_or_restore_arguments(masm, stack_slots, total_in_args,
1613                             arg_save_area, map, in_regs, in_sig_bt);
1614 
1615   __ mr(R3_ARG1, R16_thread);
1616   __ set_last_Java_frame(R1_SP, noreg);
1617 
1618   __ block_comment(&quot;block_for_jni_critical&quot;);
1619   address entry_point = CAST_FROM_FN_PTR(address, SharedRuntime::block_for_jni_critical);
1620 #if defined(ABI_ELFv2)
1621   __ call_c(entry_point, relocInfo::runtime_call_type);
1622 #else
1623   __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, entry_point), relocInfo::runtime_call_type);
1624 #endif
1625   address start           = __ pc() - __ offset(),
1626           calls_return_pc = __ last_calls_return_pc();
1627   oop_maps-&gt;add_gc_map(calls_return_pc - start, map);
1628 
1629   __ reset_last_Java_frame();
1630 
1631   // Reload all the register arguments.
1632   save_or_restore_arguments(masm, stack_slots, total_in_args,
1633                             arg_save_area, NULL, in_regs, in_sig_bt);
1634 
1635   __ BIND(cont);
1636 
1637 #ifdef ASSERT
1638   if (StressCriticalJNINatives) {
1639     // Stress register saving.
1640     OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1641     save_or_restore_arguments(masm, stack_slots, total_in_args,
1642                               arg_save_area, map, in_regs, in_sig_bt);
1643     // Destroy argument registers.
1644     for (int i = 0; i &lt; total_in_args; i++) {
1645       if (in_regs[i].first()-&gt;is_Register()) {
1646         const Register reg = in_regs[i].first()-&gt;as_Register();
1647         __ neg(reg, reg);
1648       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1649         __ fneg(in_regs[i].first()-&gt;as_FloatRegister(), in_regs[i].first()-&gt;as_FloatRegister());
1650       }
1651     }
1652 
1653     save_or_restore_arguments(masm, stack_slots, total_in_args,
1654                               arg_save_area, NULL, in_regs, in_sig_bt);
1655   }
1656 #endif
1657 }
1658 
1659 static void move_ptr(MacroAssembler* masm, VMRegPair src, VMRegPair dst, Register r_caller_sp, Register r_temp) {
1660   if (src.first()-&gt;is_stack()) {
1661     if (dst.first()-&gt;is_stack()) {
1662       // stack to stack
1663       __ ld(r_temp, reg2offset(src.first()), r_caller_sp);
1664       __ std(r_temp, reg2offset(dst.first()), R1_SP);
1665     } else {
1666       // stack to reg
1667       __ ld(dst.first()-&gt;as_Register(), reg2offset(src.first()), r_caller_sp);
1668     }
1669   } else if (dst.first()-&gt;is_stack()) {
1670     // reg to stack
1671     __ std(src.first()-&gt;as_Register(), reg2offset(dst.first()), R1_SP);
1672   } else {
1673     if (dst.first() != src.first()) {
1674       __ mr(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1675     }
1676   }
1677 }
1678 
1679 // Unpack an array argument into a pointer to the body and the length
1680 // if the array is non-null, otherwise pass 0 for both.
1681 static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type,
1682                                   VMRegPair body_arg, VMRegPair length_arg, Register r_caller_sp,
1683                                   Register tmp_reg, Register tmp2_reg) {
1684   assert(!body_arg.first()-&gt;is_Register() || body_arg.first()-&gt;as_Register() != tmp_reg,
1685          &quot;possible collision&quot;);
1686   assert(!length_arg.first()-&gt;is_Register() || length_arg.first()-&gt;as_Register() != tmp_reg,
1687          &quot;possible collision&quot;);
1688 
1689   // Pass the length, ptr pair.
1690   Label set_out_args;
1691   VMRegPair tmp, tmp2;
1692   tmp.set_ptr(tmp_reg-&gt;as_VMReg());
1693   tmp2.set_ptr(tmp2_reg-&gt;as_VMReg());
1694   if (reg.first()-&gt;is_stack()) {
1695     // Load the arg up from the stack.
1696     move_ptr(masm, reg, tmp, r_caller_sp, /*unused*/ R0);
1697     reg = tmp;
1698   }
1699   __ li(tmp2_reg, 0); // Pass zeros if Array=null.
1700   if (tmp_reg != reg.first()-&gt;as_Register()) __ li(tmp_reg, 0);
1701   __ cmpdi(CCR0, reg.first()-&gt;as_Register(), 0);
1702   __ beq(CCR0, set_out_args);
1703   __ lwa(tmp2_reg, arrayOopDesc::length_offset_in_bytes(), reg.first()-&gt;as_Register());
1704   __ addi(tmp_reg, reg.first()-&gt;as_Register(), arrayOopDesc::base_offset_in_bytes(in_elem_type));
1705   __ bind(set_out_args);
1706   move_ptr(masm, tmp, body_arg, r_caller_sp, /*unused*/ R0);
1707   move_ptr(masm, tmp2, length_arg, r_caller_sp, /*unused*/ R0); // Same as move32_64 on PPC64.
1708 }
1709 
1710 static void verify_oop_args(MacroAssembler* masm,
1711                             const methodHandle&amp; method,
1712                             const BasicType* sig_bt,
1713                             const VMRegPair* regs) {
1714   Register temp_reg = R19_method;  // not part of any compiled calling seq
1715   if (VerifyOops) {
1716     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
1717       if (sig_bt[i] == T_OBJECT ||
1718           sig_bt[i] == T_ARRAY) {
1719         VMReg r = regs[i].first();
1720         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
1721         if (r-&gt;is_stack()) {
1722           __ ld(temp_reg, reg2offset(r), R1_SP);
1723           __ verify_oop(temp_reg);
1724         } else {
1725           __ verify_oop(r-&gt;as_Register());
1726         }
1727       }
1728     }
1729   }
1730 }
1731 
1732 static void gen_special_dispatch(MacroAssembler* masm,
1733                                  const methodHandle&amp; method,
1734                                  const BasicType* sig_bt,
1735                                  const VMRegPair* regs) {
1736   verify_oop_args(masm, method, sig_bt, regs);
1737   vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1738 
1739   // Now write the args into the outgoing interpreter space
1740   bool     has_receiver   = false;
1741   Register receiver_reg   = noreg;
1742   int      member_arg_pos = -1;
1743   Register member_reg     = noreg;
1744   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
1745   if (ref_kind != 0) {
1746     member_arg_pos = method-&gt;size_of_parameters() - 1;  // trailing MemberName argument
1747     member_reg = R19_method;  // known to be free at this point
1748     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
1749   } else if (iid == vmIntrinsics::_invokeBasic) {
1750     has_receiver = true;
1751   } else {
1752     fatal(&quot;unexpected intrinsic id %d&quot;, iid);
1753   }
1754 
1755   if (member_reg != noreg) {
1756     // Load the member_arg into register, if necessary.
1757     SharedRuntime::check_member_name_argument_is_last_argument(method, sig_bt, regs);
1758     VMReg r = regs[member_arg_pos].first();
1759     if (r-&gt;is_stack()) {
1760       __ ld(member_reg, reg2offset(r), R1_SP);
1761     } else {
1762       // no data motion is needed
1763       member_reg = r-&gt;as_Register();
1764     }
1765   }
1766 
1767   if (has_receiver) {
1768     // Make sure the receiver is loaded into a register.
1769     assert(method-&gt;size_of_parameters() &gt; 0, &quot;oob&quot;);
1770     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
1771     VMReg r = regs[0].first();
1772     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
1773     if (r-&gt;is_stack()) {
1774       // Porting note:  This assumes that compiled calling conventions always
1775       // pass the receiver oop in a register.  If this is not true on some
1776       // platform, pick a temp and load the receiver from stack.
1777       fatal(&quot;receiver always in a register&quot;);
1778       receiver_reg = R11_scratch1;  // TODO (hs24): is R11_scratch1 really free at this point?
1779       __ ld(receiver_reg, reg2offset(r), R1_SP);
1780     } else {
1781       // no data motion is needed
1782       receiver_reg = r-&gt;as_Register();
1783     }
1784   }
1785 
1786   // Figure out which address we are really jumping to:
1787   MethodHandles::generate_method_handle_dispatch(masm, iid,
1788                                                  receiver_reg, member_reg, /*for_compiler_entry:*/ true);
1789 }
1790 
1791 #endif // COMPILER2
1792 
1793 // ---------------------------------------------------------------------------
1794 // Generate a native wrapper for a given method. The method takes arguments
1795 // in the Java compiled code convention, marshals them to the native
1796 // convention (handlizes oops, etc), transitions to native, makes the call,
1797 // returns to java state (possibly blocking), unhandlizes any result and
1798 // returns.
1799 //
1800 // Critical native functions are a shorthand for the use of
1801 // GetPrimtiveArrayCritical and disallow the use of any other JNI
1802 // functions.  The wrapper is expected to unpack the arguments before
1803 // passing them to the callee and perform checks before and after the
1804 // native call to ensure that they GCLocker
1805 // lock_critical/unlock_critical semantics are followed.  Some other
1806 // parts of JNI setup are skipped like the tear down of the JNI handle
1807 // block and the check for pending exceptions it&#39;s impossible for them
1808 // to be thrown.
1809 //
1810 // They are roughly structured like this:
1811 //   if (GCLocker::needs_gc())
1812 //     SharedRuntime::block_for_jni_critical();
1813 //   tranistion to thread_in_native
1814 //   unpack arrray arguments and call native entry point
1815 //   check for safepoint in progress
1816 //   check if any thread suspend flags are set
1817 //     call into JVM and possible unlock the JNI critical
1818 //     if a GC was suppressed while in the critical native.
1819 //   transition back to thread_in_Java
1820 //   return to caller
1821 //
1822 nmethod *SharedRuntime::generate_native_wrapper(MacroAssembler *masm,
1823                                                 const methodHandle&amp; method,
1824                                                 int compile_id,
1825                                                 BasicType *in_sig_bt,
1826                                                 VMRegPair *in_regs,
1827                                                 BasicType ret_type) {
1828 #ifdef COMPILER2
1829   if (method-&gt;is_method_handle_intrinsic()) {
1830     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1831     intptr_t start = (intptr_t)__ pc();
1832     int vep_offset = ((intptr_t)__ pc()) - start;
1833     gen_special_dispatch(masm,
1834                          method,
1835                          in_sig_bt,
1836                          in_regs);
1837     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
1838     __ flush();
1839     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
1840     return nmethod::new_native_nmethod(method,
1841                                        compile_id,
1842                                        masm-&gt;code(),
1843                                        vep_offset,
1844                                        frame_complete,
1845                                        stack_slots / VMRegImpl::slots_per_word,
1846                                        in_ByteSize(-1),
1847                                        in_ByteSize(-1),
1848                                        (OopMapSet*)NULL);
1849   }
1850 
1851   bool is_critical_native = true;
1852   address native_func = method-&gt;critical_native_function();
1853   if (native_func == NULL) {
1854     native_func = method-&gt;native_function();
1855     is_critical_native = false;
1856   }
1857   assert(native_func != NULL, &quot;must have function&quot;);
1858 
1859   // First, create signature for outgoing C call
1860   // --------------------------------------------------------------------------
1861 
1862   int total_in_args = method-&gt;size_of_parameters();
1863   // We have received a description of where all the java args are located
1864   // on entry to the wrapper. We need to convert these args to where
1865   // the jni function will expect them. To figure out where they go
1866   // we convert the java signature to a C signature by inserting
1867   // the hidden arguments as arg[0] and possibly arg[1] (static method)
1868 
1869   // Calculate the total number of C arguments and create arrays for the
1870   // signature and the outgoing registers.
1871   // On ppc64, we have two arrays for the outgoing registers, because
1872   // some floating-point arguments must be passed in registers _and_
1873   // in stack locations.
1874   bool method_is_static = method-&gt;is_static();
1875   int  total_c_args     = total_in_args;
1876 
1877   if (!is_critical_native) {
1878     int n_hidden_args = method_is_static ? 2 : 1;
1879     total_c_args += n_hidden_args;
1880   } else {
1881     // No JNIEnv*, no this*, but unpacked arrays (base+length).
1882     for (int i = 0; i &lt; total_in_args; i++) {
1883       if (in_sig_bt[i] == T_ARRAY) {
1884         total_c_args++;
1885       }
1886     }
1887   }
1888 
1889   BasicType *out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1890   VMRegPair *out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1891   VMRegPair *out_regs2  = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1892   BasicType* in_elem_bt = NULL;
1893 
1894   // Create the signature for the C call:
1895   //   1) add the JNIEnv*
1896   //   2) add the class if the method is static
1897   //   3) copy the rest of the incoming signature (shifted by the number of
1898   //      hidden arguments).
1899 
1900   int argc = 0;
1901   if (!is_critical_native) {
1902     out_sig_bt[argc++] = T_ADDRESS;
1903     if (method-&gt;is_static()) {
1904       out_sig_bt[argc++] = T_OBJECT;
1905     }
1906 
1907     for (int i = 0; i &lt; total_in_args ; i++ ) {
1908       out_sig_bt[argc++] = in_sig_bt[i];
1909     }
1910   } else {
1911     Thread* THREAD = Thread::current();
1912     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1913     SignatureStream ss(method-&gt;signature());
1914     int o = 0;
1915     for (int i = 0; i &lt; total_in_args ; i++, o++) {
1916       if (in_sig_bt[i] == T_ARRAY) {
1917         // Arrays are passed as int, elem* pair
1918         Symbol* atype = ss.as_symbol(CHECK_NULL);
1919         const char* at = atype-&gt;as_C_string();
1920         if (strlen(at) == 2) {
1921           assert(at[0] == &#39;[&#39;, &quot;must be&quot;);
1922           switch (at[1]) {
1923             case &#39;B&#39;: in_elem_bt[o] = T_BYTE; break;
1924             case &#39;C&#39;: in_elem_bt[o] = T_CHAR; break;
1925             case &#39;D&#39;: in_elem_bt[o] = T_DOUBLE; break;
1926             case &#39;F&#39;: in_elem_bt[o] = T_FLOAT; break;
1927             case &#39;I&#39;: in_elem_bt[o] = T_INT; break;
1928             case &#39;J&#39;: in_elem_bt[o] = T_LONG; break;
1929             case &#39;S&#39;: in_elem_bt[o] = T_SHORT; break;
1930             case &#39;Z&#39;: in_elem_bt[o] = T_BOOLEAN; break;
1931             default: ShouldNotReachHere();
1932           }
1933         }
1934       } else {
1935         in_elem_bt[o] = T_VOID;
1936       }
1937       if (in_sig_bt[i] != T_VOID) {
1938         assert(in_sig_bt[i] == ss.type(), &quot;must match&quot;);
1939         ss.next();
1940       }
1941     }
1942 
1943     for (int i = 0; i &lt; total_in_args ; i++ ) {
1944       if (in_sig_bt[i] == T_ARRAY) {
1945         // Arrays are passed as int, elem* pair.
1946         out_sig_bt[argc++] = T_INT;
1947         out_sig_bt[argc++] = T_ADDRESS;
1948       } else {
1949         out_sig_bt[argc++] = in_sig_bt[i];
1950       }
1951     }
1952   }
1953 
1954 
1955   // Compute the wrapper&#39;s frame size.
1956   // --------------------------------------------------------------------------
1957 
1958   // Now figure out where the args must be stored and how much stack space
1959   // they require.
1960   //
1961   // Compute framesize for the wrapper. We need to handlize all oops in
1962   // incoming registers.
1963   //
1964   // Calculate the total number of stack slots we will need:
1965   //   1) abi requirements
1966   //   2) outgoing arguments
1967   //   3) space for inbound oop handle area
1968   //   4) space for handlizing a klass if static method
1969   //   5) space for a lock if synchronized method
1970   //   6) workspace for saving return values, int &lt;-&gt; float reg moves, etc.
1971   //   7) alignment
1972   //
1973   // Layout of the native wrapper frame:
1974   // (stack grows upwards, memory grows downwards)
1975   //
1976   // NW     [ABI_REG_ARGS]             &lt;-- 1) R1_SP
1977   //        [outgoing arguments]       &lt;-- 2) R1_SP + out_arg_slot_offset
1978   //        [oopHandle area]           &lt;-- 3) R1_SP + oop_handle_offset (save area for critical natives)
1979   //        klass                      &lt;-- 4) R1_SP + klass_offset
1980   //        lock                       &lt;-- 5) R1_SP + lock_offset
1981   //        [workspace]                &lt;-- 6) R1_SP + workspace_offset
1982   //        [alignment] (optional)     &lt;-- 7)
1983   // caller [JIT_TOP_ABI_48]           &lt;-- r_callers_sp
1984   //
1985   // - *_slot_offset Indicates offset from SP in number of stack slots.
1986   // - *_offset      Indicates offset from SP in bytes.
1987 
1988   int stack_slots = c_calling_convention(out_sig_bt, out_regs, out_regs2, total_c_args) + // 1+2)
1989                     SharedRuntime::out_preserve_stack_slots(); // See c_calling_convention.
1990 
1991   // Now the space for the inbound oop handle area.
1992   int total_save_slots = num_java_iarg_registers * VMRegImpl::slots_per_word;
1993   if (is_critical_native) {
1994     // Critical natives may have to call out so they need a save area
1995     // for register arguments.
1996     int double_slots = 0;
1997     int single_slots = 0;
1998     for (int i = 0; i &lt; total_in_args; i++) {
1999       if (in_regs[i].first()-&gt;is_Register()) {
2000         const Register reg = in_regs[i].first()-&gt;as_Register();
2001         switch (in_sig_bt[i]) {
2002           case T_BOOLEAN:
2003           case T_BYTE:
2004           case T_SHORT:
2005           case T_CHAR:
2006           case T_INT:
2007           // Fall through.
2008           case T_ARRAY:
2009           case T_LONG: double_slots++; break;
2010           default:  ShouldNotReachHere();
2011         }
2012       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
2013         switch (in_sig_bt[i]) {
2014           case T_FLOAT:  single_slots++; break;
2015           case T_DOUBLE: double_slots++; break;
2016           default:  ShouldNotReachHere();
2017         }
2018       }
2019     }
2020     total_save_slots = double_slots * 2 + align_up(single_slots, 2); // round to even
2021   }
2022 
2023   int oop_handle_slot_offset = stack_slots;
2024   stack_slots += total_save_slots;                                                // 3)
2025 
2026   int klass_slot_offset = 0;
2027   int klass_offset      = -1;
2028   if (method_is_static &amp;&amp; !is_critical_native) {                                  // 4)
2029     klass_slot_offset  = stack_slots;
2030     klass_offset       = klass_slot_offset * VMRegImpl::stack_slot_size;
2031     stack_slots       += VMRegImpl::slots_per_word;
2032   }
2033 
2034   int lock_slot_offset = 0;
2035   int lock_offset      = -1;
2036   if (method-&gt;is_synchronized()) {                                                // 5)
2037     lock_slot_offset   = stack_slots;
2038     lock_offset        = lock_slot_offset * VMRegImpl::stack_slot_size;
2039     stack_slots       += VMRegImpl::slots_per_word;
2040   }
2041 
2042   int workspace_slot_offset = stack_slots;                                        // 6)
2043   stack_slots         += 2;
2044 
2045   // Now compute actual number of stack words we need.
2046   // Rounding to make stack properly aligned.
2047   stack_slots = align_up(stack_slots,                                             // 7)
2048                          frame::alignment_in_bytes / VMRegImpl::stack_slot_size);
2049   int frame_size_in_bytes = stack_slots * VMRegImpl::stack_slot_size;
2050 
2051 
2052   // Now we can start generating code.
2053   // --------------------------------------------------------------------------
2054 
2055   intptr_t start_pc = (intptr_t)__ pc();
2056   intptr_t vep_start_pc;
2057   intptr_t frame_done_pc;
2058   intptr_t oopmap_pc;
2059 
2060   Label    ic_miss;
2061   Label    handle_pending_exception;
2062 
2063   Register r_callers_sp = R21;
2064   Register r_temp_1     = R22;
2065   Register r_temp_2     = R23;
2066   Register r_temp_3     = R24;
2067   Register r_temp_4     = R25;
2068   Register r_temp_5     = R26;
2069   Register r_temp_6     = R27;
2070   Register r_return_pc  = R28;
2071 
2072   Register r_carg1_jnienv        = noreg;
2073   Register r_carg2_classorobject = noreg;
2074   if (!is_critical_native) {
2075     r_carg1_jnienv        = out_regs[0].first()-&gt;as_Register();
2076     r_carg2_classorobject = out_regs[1].first()-&gt;as_Register();
2077   }
2078 
2079 
2080   // Generate the Unverified Entry Point (UEP).
2081   // --------------------------------------------------------------------------
2082   assert(start_pc == (intptr_t)__ pc(), &quot;uep must be at start&quot;);
2083 
2084   // Check ic: object class == cached class?
2085   if (!method_is_static) {
2086   Register ic = as_Register(Matcher::inline_cache_reg_encode());
2087   Register receiver_klass = r_temp_1;
2088 
2089   __ cmpdi(CCR0, R3_ARG1, 0);
2090   __ beq(CCR0, ic_miss);
2091   __ verify_oop(R3_ARG1);
2092   __ load_klass(receiver_klass, R3_ARG1);
2093 
2094   __ cmpd(CCR0, receiver_klass, ic);
2095   __ bne(CCR0, ic_miss);
2096   }
2097 
2098 
2099   // Generate the Verified Entry Point (VEP).
2100   // --------------------------------------------------------------------------
2101   vep_start_pc = (intptr_t)__ pc();
2102 
2103   if (UseRTMLocking) {
2104     // Abort RTM transaction before calling JNI
2105     // because critical section can be large and
2106     // abort anyway. Also nmethod can be deoptimized.
2107     __ tabort_();
2108   }
2109 
2110   __ save_LR_CR(r_temp_1);
2111   __ generate_stack_overflow_check(frame_size_in_bytes); // Check before creating frame.
2112   __ mr(r_callers_sp, R1_SP);                            // Remember frame pointer.
2113   __ push_frame(frame_size_in_bytes, r_temp_1);          // Push the c2n adapter&#39;s frame.
2114   frame_done_pc = (intptr_t)__ pc();
2115 
2116   __ verify_thread();
2117 
2118   // Native nmethod wrappers never take possesion of the oop arguments.
2119   // So the caller will gc the arguments.
2120   // The only thing we need an oopMap for is if the call is static.
2121   //
2122   // An OopMap for lock (and class if static), and one for the VM call itself.
2123   OopMapSet *oop_maps = new OopMapSet();
2124   OopMap    *oop_map  = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
2125 
2126   if (is_critical_native) {
2127     check_needs_gc_for_critical_native(masm, stack_slots, total_in_args, oop_handle_slot_offset,
2128                                        oop_maps, in_regs, in_sig_bt, r_temp_1);
2129   }
2130 
2131   // Move arguments from register/stack to register/stack.
2132   // --------------------------------------------------------------------------
2133   //
2134   // We immediately shuffle the arguments so that for any vm call we have
2135   // to make from here on out (sync slow path, jvmti, etc.) we will have
2136   // captured the oops from our caller and have a valid oopMap for them.
2137   //
2138   // Natives require 1 or 2 extra arguments over the normal ones: the JNIEnv*
2139   // (derived from JavaThread* which is in R16_thread) and, if static,
2140   // the class mirror instead of a receiver. This pretty much guarantees that
2141   // register layout will not match. We ignore these extra arguments during
2142   // the shuffle. The shuffle is described by the two calling convention
2143   // vectors we have in our possession. We simply walk the java vector to
2144   // get the source locations and the c vector to get the destinations.
2145 
2146   // Record sp-based slot for receiver on stack for non-static methods.
2147   int receiver_offset = -1;
2148 
2149   // We move the arguments backward because the floating point registers
2150   // destination will always be to a register with a greater or equal
2151   // register number or the stack.
2152   //   in  is the index of the incoming Java arguments
2153   //   out is the index of the outgoing C arguments
2154 
2155 #ifdef ASSERT
2156   bool reg_destroyed[RegisterImpl::number_of_registers];
2157   bool freg_destroyed[FloatRegisterImpl::number_of_registers];
2158   for (int r = 0 ; r &lt; RegisterImpl::number_of_registers ; r++) {
2159     reg_destroyed[r] = false;
2160   }
2161   for (int f = 0 ; f &lt; FloatRegisterImpl::number_of_registers ; f++) {
2162     freg_destroyed[f] = false;
2163   }
2164 #endif // ASSERT
2165 
2166   for (int in = total_in_args - 1, out = total_c_args - 1; in &gt;= 0 ; in--, out--) {
2167 
2168 #ifdef ASSERT
2169     if (in_regs[in].first()-&gt;is_Register()) {
2170       assert(!reg_destroyed[in_regs[in].first()-&gt;as_Register()-&gt;encoding()], &quot;ack!&quot;);
2171     } else if (in_regs[in].first()-&gt;is_FloatRegister()) {
2172       assert(!freg_destroyed[in_regs[in].first()-&gt;as_FloatRegister()-&gt;encoding()], &quot;ack!&quot;);
2173     }
2174     if (out_regs[out].first()-&gt;is_Register()) {
2175       reg_destroyed[out_regs[out].first()-&gt;as_Register()-&gt;encoding()] = true;
2176     } else if (out_regs[out].first()-&gt;is_FloatRegister()) {
2177       freg_destroyed[out_regs[out].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
2178     }
2179     if (out_regs2[out].first()-&gt;is_Register()) {
2180       reg_destroyed[out_regs2[out].first()-&gt;as_Register()-&gt;encoding()] = true;
2181     } else if (out_regs2[out].first()-&gt;is_FloatRegister()) {
2182       freg_destroyed[out_regs2[out].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
2183     }
2184 #endif // ASSERT
2185 
2186     switch (in_sig_bt[in]) {
2187       case T_BOOLEAN:
2188       case T_CHAR:
2189       case T_BYTE:
2190       case T_SHORT:
2191       case T_INT:
2192         // Move int and do sign extension.
2193         int_move(masm, in_regs[in], out_regs[out], r_callers_sp, r_temp_1);
2194         break;
2195       case T_LONG:
2196         long_move(masm, in_regs[in], out_regs[out], r_callers_sp, r_temp_1);
2197         break;
2198       case T_ARRAY:
2199         if (is_critical_native) {
2200           int body_arg = out;
2201           out -= 1; // Point to length arg.
2202           unpack_array_argument(masm, in_regs[in], in_elem_bt[in], out_regs[body_arg], out_regs[out],
2203                                 r_callers_sp, r_temp_1, r_temp_2);
2204           break;
2205         }
2206       case T_OBJECT:
2207         assert(!is_critical_native, &quot;no oop arguments&quot;);
2208         object_move(masm, stack_slots,
2209                     oop_map, oop_handle_slot_offset,
2210                     ((in == 0) &amp;&amp; (!method_is_static)), &amp;receiver_offset,
2211                     in_regs[in], out_regs[out],
2212                     r_callers_sp, r_temp_1, r_temp_2);
2213         break;
2214       case T_VOID:
2215         break;
2216       case T_FLOAT:
2217         float_move(masm, in_regs[in], out_regs[out], r_callers_sp, r_temp_1);
2218         if (out_regs2[out].first()-&gt;is_valid()) {
2219           float_move(masm, in_regs[in], out_regs2[out], r_callers_sp, r_temp_1);
2220         }
2221         break;
2222       case T_DOUBLE:
2223         double_move(masm, in_regs[in], out_regs[out], r_callers_sp, r_temp_1);
2224         if (out_regs2[out].first()-&gt;is_valid()) {
2225           double_move(masm, in_regs[in], out_regs2[out], r_callers_sp, r_temp_1);
2226         }
2227         break;
2228       case T_ADDRESS:
2229         fatal(&quot;found type (T_ADDRESS) in java args&quot;);
2230         break;
2231       default:
2232         ShouldNotReachHere();
2233         break;
2234     }
2235   }
2236 
2237   // Pre-load a static method&#39;s oop into ARG2.
2238   // Used both by locking code and the normal JNI call code.
2239   if (method_is_static &amp;&amp; !is_critical_native) {
2240     __ set_oop_constant(JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()),
2241                         r_carg2_classorobject);
2242 
2243     // Now handlize the static class mirror in carg2. It&#39;s known not-null.
2244     __ std(r_carg2_classorobject, klass_offset, R1_SP);
2245     oop_map-&gt;set_oop(VMRegImpl::stack2reg(klass_slot_offset));
2246     __ addi(r_carg2_classorobject, R1_SP, klass_offset);
2247   }
2248 
2249   // Get JNIEnv* which is first argument to native.
2250   if (!is_critical_native) {
2251     __ addi(r_carg1_jnienv, R16_thread, in_bytes(JavaThread::jni_environment_offset()));
2252   }
2253 
2254   // NOTE:
2255   //
2256   // We have all of the arguments setup at this point.
2257   // We MUST NOT touch any outgoing regs from this point on.
2258   // So if we must call out we must push a new frame.
2259 
2260   // Get current pc for oopmap, and load it patchable relative to global toc.
2261   oopmap_pc = (intptr_t) __ pc();
2262   __ calculate_address_from_global_toc(r_return_pc, (address)oopmap_pc, true, true, true, true);
2263 
2264   // We use the same pc/oopMap repeatedly when we call out.
2265   oop_maps-&gt;add_gc_map(oopmap_pc - start_pc, oop_map);
2266 
2267   // r_return_pc now has the pc loaded that we will use when we finally call
2268   // to native.
2269 
2270   // Make sure that thread is non-volatile; it crosses a bunch of VM calls below.
2271   assert(R16_thread-&gt;is_nonvolatile(), &quot;thread must be in non-volatile register&quot;);
2272 
2273 # if 0
2274   // DTrace method entry
2275 # endif
2276 
2277   // Lock a synchronized method.
2278   // --------------------------------------------------------------------------
2279 
2280   if (method-&gt;is_synchronized()) {
2281     assert(!is_critical_native, &quot;unhandled&quot;);
2282     ConditionRegister r_flag = CCR1;
2283     Register          r_oop  = r_temp_4;
2284     const Register    r_box  = r_temp_5;
2285     Label             done, locked;
2286 
2287     // Load the oop for the object or class. r_carg2_classorobject contains
2288     // either the handlized oop from the incoming arguments or the handlized
2289     // class mirror (if the method is static).
2290     __ ld(r_oop, 0, r_carg2_classorobject);
2291 
2292     // Get the lock box slot&#39;s address.
2293     __ addi(r_box, R1_SP, lock_offset);
2294 
2295 #   ifdef ASSERT
2296     if (UseBiasedLocking) {
2297       // Making the box point to itself will make it clear it went unused
2298       // but also be obviously invalid.
2299       __ std(r_box, 0, r_box);
2300     }
2301 #   endif // ASSERT
2302 
2303     // Try fastpath for locking.
2304     // fast_lock kills r_temp_1, r_temp_2, r_temp_3.
2305     __ compiler_fast_lock_object(r_flag, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);
2306     __ beq(r_flag, locked);
2307 
2308     // None of the above fast optimizations worked so we have to get into the
2309     // slow case of monitor enter. Inline a special case of call_VM that
2310     // disallows any pending_exception.
2311 
2312     // Save argument registers and leave room for C-compatible ABI_REG_ARGS.
2313     int frame_size = frame::abi_reg_args_size + align_up(total_c_args * wordSize, frame::alignment_in_bytes);
2314     __ mr(R11_scratch1, R1_SP);
2315     RegisterSaver::push_frame_and_save_argument_registers(masm, R12_scratch2, frame_size, total_c_args, out_regs, out_regs2);
2316 
2317     // Do the call.
2318     __ set_last_Java_frame(R11_scratch1, r_return_pc);
2319     assert(r_return_pc-&gt;is_nonvolatile(), &quot;expecting return pc to be in non-volatile register&quot;);
2320     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C), r_oop, r_box, R16_thread);
2321     __ reset_last_Java_frame();
2322 
2323     RegisterSaver::restore_argument_registers_and_pop_frame(masm, frame_size, total_c_args, out_regs, out_regs2);
2324 
2325     __ asm_assert_mem8_is_zero(thread_(pending_exception),
2326        &quot;no pending exception allowed on exit from SharedRuntime::complete_monitor_locking_C&quot;, 0);
2327 
2328     __ bind(locked);
2329   }
2330 
2331 
2332   // Publish thread state
2333   // --------------------------------------------------------------------------
2334 
2335   // Use that pc we placed in r_return_pc a while back as the current frame anchor.
2336   __ set_last_Java_frame(R1_SP, r_return_pc);
2337 
2338   // Transition from _thread_in_Java to _thread_in_native.
2339   __ li(R0, _thread_in_native);
2340   __ release();
2341   // TODO: PPC port assert(4 == JavaThread::sz_thread_state(), &quot;unexpected field size&quot;);
2342   __ stw(R0, thread_(thread_state));
2343 
2344 
2345   // The JNI call
2346   // --------------------------------------------------------------------------
2347 #if defined(ABI_ELFv2)
2348   __ call_c(native_func, relocInfo::runtime_call_type);
2349 #else
2350   FunctionDescriptor* fd_native_method = (FunctionDescriptor*) native_func;
2351   __ call_c(fd_native_method, relocInfo::runtime_call_type);
2352 #endif
2353 
2354 
2355   // Now, we are back from the native code.
2356 
2357 
2358   // Unpack the native result.
2359   // --------------------------------------------------------------------------
2360 
2361   // For int-types, we do any needed sign-extension required.
2362   // Care must be taken that the return values (R3_RET and F1_RET)
2363   // will survive any VM calls for blocking or unlocking.
2364   // An OOP result (handle) is done specially in the slow-path code.
2365 
2366   switch (ret_type) {
2367     case T_VOID:    break;        // Nothing to do!
2368     case T_FLOAT:   break;        // Got it where we want it (unless slow-path).
2369     case T_DOUBLE:  break;        // Got it where we want it (unless slow-path).
2370     case T_LONG:    break;        // Got it where we want it (unless slow-path).
2371     case T_OBJECT:  break;        // Really a handle.
2372                                   // Cannot de-handlize until after reclaiming jvm_lock.
2373     case T_ARRAY:   break;
2374 
2375     case T_BOOLEAN: {             // 0 -&gt; false(0); !0 -&gt; true(1)
2376       Label skip_modify;
2377       __ cmpwi(CCR0, R3_RET, 0);
2378       __ beq(CCR0, skip_modify);
2379       __ li(R3_RET, 1);
2380       __ bind(skip_modify);
2381       break;
2382       }
2383     case T_BYTE: {                // sign extension
2384       __ extsb(R3_RET, R3_RET);
2385       break;
2386       }
2387     case T_CHAR: {                // unsigned result
2388       __ andi(R3_RET, R3_RET, 0xffff);
2389       break;
2390       }
2391     case T_SHORT: {               // sign extension
2392       __ extsh(R3_RET, R3_RET);
2393       break;
2394       }
2395     case T_INT:                   // nothing to do
2396       break;
2397     default:
2398       ShouldNotReachHere();
2399       break;
2400   }
2401 
2402 
2403   // Publish thread state
2404   // --------------------------------------------------------------------------
2405 
2406   // Switch thread to &quot;native transition&quot; state before reading the
2407   // synchronization state. This additional state is necessary because reading
2408   // and testing the synchronization state is not atomic w.r.t. GC, as this
2409   // scenario demonstrates:
2410   //   - Java thread A, in _thread_in_native state, loads _not_synchronized
2411   //     and is preempted.
2412   //   - VM thread changes sync state to synchronizing and suspends threads
2413   //     for GC.
2414   //   - Thread A is resumed to finish this native method, but doesn&#39;t block
2415   //     here since it didn&#39;t see any synchronization in progress, and escapes.
2416 
2417   // Transition from _thread_in_native to _thread_in_native_trans.
2418   __ li(R0, _thread_in_native_trans);
2419   __ release();
2420   // TODO: PPC port assert(4 == JavaThread::sz_thread_state(), &quot;unexpected field size&quot;);
2421   __ stw(R0, thread_(thread_state));
2422 
2423 
2424   // Must we block?
2425   // --------------------------------------------------------------------------
2426 
2427   // Block, if necessary, before resuming in _thread_in_Java state.
2428   // In order for GC to work, don&#39;t clear the last_Java_sp until after blocking.
2429   Label after_transition;
2430   {
2431     Label no_block, sync;
2432 
2433     // Force this write out before the read below.
2434     __ fence();
2435 
2436     Register sync_state_addr = r_temp_4;
2437     Register sync_state      = r_temp_5;
2438     Register suspend_flags   = r_temp_6;
2439 
2440     // No synchronization in progress nor yet synchronized
2441     // (cmp-br-isync on one path, release (same as acquire on PPC64) on the other path).
2442     __ safepoint_poll(sync, sync_state);
2443 
2444     // Not suspended.
2445     // TODO: PPC port assert(4 == Thread::sz_suspend_flags(), &quot;unexpected field size&quot;);
2446     __ lwz(suspend_flags, thread_(suspend_flags));
2447     __ cmpwi(CCR1, suspend_flags, 0);
2448     __ beq(CCR1, no_block);
2449 
2450     // Block. Save any potential method result value before the operation and
2451     // use a leaf call to leave the last_Java_frame setup undisturbed. Doing this
2452     // lets us share the oopMap we used when we went native rather than create
2453     // a distinct one for this pc.
2454     __ bind(sync);
2455     __ isync();
2456 
2457     address entry_point = is_critical_native
2458       ? CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)
2459       : CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans);
2460     save_native_result(masm, ret_type, workspace_slot_offset);
2461     __ call_VM_leaf(entry_point, R16_thread);
2462     restore_native_result(masm, ret_type, workspace_slot_offset);
2463 
2464     if (is_critical_native) {
2465       __ b(after_transition); // No thread state transition here.
2466     }
2467     __ bind(no_block);
2468   }
2469 
2470   // Publish thread state.
2471   // --------------------------------------------------------------------------
2472 
2473   // Thread state is thread_in_native_trans. Any safepoint blocking has
2474   // already happened so we can now change state to _thread_in_Java.
2475 
2476   // Transition from _thread_in_native_trans to _thread_in_Java.
2477   __ li(R0, _thread_in_Java);
2478   __ lwsync(); // Acquire safepoint and suspend state, release thread state.
2479   // TODO: PPC port assert(4 == JavaThread::sz_thread_state(), &quot;unexpected field size&quot;);
2480   __ stw(R0, thread_(thread_state));
2481   __ bind(after_transition);
2482 
2483   // Reguard any pages if necessary.
2484   // --------------------------------------------------------------------------
2485 
2486   Label no_reguard;
2487   __ lwz(r_temp_1, thread_(stack_guard_state));
2488   __ cmpwi(CCR0, r_temp_1, JavaThread::stack_guard_yellow_reserved_disabled);
2489   __ bne(CCR0, no_reguard);
2490 
2491   save_native_result(masm, ret_type, workspace_slot_offset);
2492   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));
2493   restore_native_result(masm, ret_type, workspace_slot_offset);
2494 
2495   __ bind(no_reguard);
2496 
2497 
2498   // Unlock
2499   // --------------------------------------------------------------------------
2500 
2501   if (method-&gt;is_synchronized()) {
2502 
2503     ConditionRegister r_flag   = CCR1;
2504     const Register r_oop       = r_temp_4;
2505     const Register r_box       = r_temp_5;
2506     const Register r_exception = r_temp_6;
2507     Label done;
2508 
2509     // Get oop and address of lock object box.
2510     if (method_is_static) {
2511       assert(klass_offset != -1, &quot;&quot;);
2512       __ ld(r_oop, klass_offset, R1_SP);
2513     } else {
2514       assert(receiver_offset != -1, &quot;&quot;);
2515       __ ld(r_oop, receiver_offset, R1_SP);
2516     }
2517     __ addi(r_box, R1_SP, lock_offset);
2518 
2519     // Try fastpath for unlocking.
2520     __ compiler_fast_unlock_object(r_flag, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);
2521     __ beq(r_flag, done);
2522 
2523     // Save and restore any potential method result value around the unlocking operation.
2524     save_native_result(masm, ret_type, workspace_slot_offset);
2525 
2526     // Must save pending exception around the slow-path VM call. Since it&#39;s a
2527     // leaf call, the pending exception (if any) can be kept in a register.
2528     __ ld(r_exception, thread_(pending_exception));
2529     assert(r_exception-&gt;is_nonvolatile(), &quot;exception register must be non-volatile&quot;);
2530     __ li(R0, 0);
2531     __ std(R0, thread_(pending_exception));
2532 
2533     // Slow case of monitor enter.
2534     // Inline a special case of call_VM that disallows any pending_exception.
2535     // Arguments are (oop obj, BasicLock* lock, JavaThread* thread).
2536     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C), r_oop, r_box, R16_thread);
2537 
2538     __ asm_assert_mem8_is_zero(thread_(pending_exception),
2539        &quot;no pending exception allowed on exit from SharedRuntime::complete_monitor_unlocking_C&quot;, 0);
2540 
2541     restore_native_result(masm, ret_type, workspace_slot_offset);
2542 
2543     // Check_forward_pending_exception jump to forward_exception if any pending
2544     // exception is set. The forward_exception routine expects to see the
2545     // exception in pending_exception and not in a register. Kind of clumsy,
2546     // since all folks who branch to forward_exception must have tested
2547     // pending_exception first and hence have it in a register already.
2548     __ std(r_exception, thread_(pending_exception));
2549 
2550     __ bind(done);
2551   }
2552 
2553 # if 0
2554   // DTrace method exit
2555 # endif
2556 
2557   // Clear &quot;last Java frame&quot; SP and PC.
2558   // --------------------------------------------------------------------------
2559 
2560   __ reset_last_Java_frame();
2561 
2562   // Unbox oop result, e.g. JNIHandles::resolve value.
2563   // --------------------------------------------------------------------------
2564 
2565   if (ret_type == T_OBJECT || ret_type == T_ARRAY) {
2566     __ resolve_jobject(R3_RET, r_temp_1, r_temp_2, /* needs_frame */ false);
2567   }
2568 
2569   if (CheckJNICalls) {
2570     // clear_pending_jni_exception_check
2571     __ load_const_optimized(R0, 0L);
2572     __ st_ptr(R0, JavaThread::pending_jni_exception_check_fn_offset(), R16_thread);
2573   }
2574 
2575   // Reset handle block.
2576   // --------------------------------------------------------------------------
2577   if (!is_critical_native) {
2578   __ ld(r_temp_1, thread_(active_handles));
2579   // TODO: PPC port assert(4 == JNIHandleBlock::top_size_in_bytes(), &quot;unexpected field size&quot;);
2580   __ li(r_temp_2, 0);
2581   __ stw(r_temp_2, JNIHandleBlock::top_offset_in_bytes(), r_temp_1);
2582 
2583 
2584   // Check for pending exceptions.
2585   // --------------------------------------------------------------------------
2586   __ ld(r_temp_2, thread_(pending_exception));
2587   __ cmpdi(CCR0, r_temp_2, 0);
2588   __ bne(CCR0, handle_pending_exception);
2589   }
2590 
2591   // Return
2592   // --------------------------------------------------------------------------
2593 
2594   __ pop_frame();
2595   __ restore_LR_CR(R11);
2596   __ blr();
2597 
2598 
2599   // Handler for pending exceptions (out-of-line).
2600   // --------------------------------------------------------------------------
2601 
2602   // Since this is a native call, we know the proper exception handler
2603   // is the empty function. We just pop this frame and then jump to
2604   // forward_exception_entry.
2605   if (!is_critical_native) {
2606   __ align(InteriorEntryAlignment);
2607   __ bind(handle_pending_exception);
2608 
2609   __ pop_frame();
2610   __ restore_LR_CR(R11);
2611   __ b64_patchable((address)StubRoutines::forward_exception_entry(),
2612                        relocInfo::runtime_call_type);
2613   }
2614 
2615   // Handler for a cache miss (out-of-line).
2616   // --------------------------------------------------------------------------
2617 
2618   if (!method_is_static) {
2619   __ align(InteriorEntryAlignment);
2620   __ bind(ic_miss);
2621 
2622   __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
2623                        relocInfo::runtime_call_type);
2624   }
2625 
2626   // Done.
2627   // --------------------------------------------------------------------------
2628 
2629   __ flush();
2630 
2631   nmethod *nm = nmethod::new_native_nmethod(method,
2632                                             compile_id,
2633                                             masm-&gt;code(),
2634                                             vep_start_pc-start_pc,
2635                                             frame_done_pc-start_pc,
2636                                             stack_slots / VMRegImpl::slots_per_word,
2637                                             (method_is_static ? in_ByteSize(klass_offset) : in_ByteSize(receiver_offset)),
2638                                             in_ByteSize(lock_offset),
2639                                             oop_maps);
2640 
2641   if (is_critical_native) {
2642     nm-&gt;set_lazy_critical_native(true);
2643   }
2644 
2645   return nm;
2646 #else
2647   ShouldNotReachHere();
2648   return NULL;
2649 #endif // COMPILER2
2650 }
2651 
2652 // This function returns the adjust size (in number of words) to a c2i adapter
2653 // activation for use during deoptimization.
2654 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals) {
2655   return align_up((callee_locals - callee_parameters) * Interpreter::stackElementWords, frame::alignment_in_bytes);
2656 }
2657 
2658 uint SharedRuntime::out_preserve_stack_slots() {
2659 #if defined(COMPILER1) || defined(COMPILER2)
2660   return frame::jit_out_preserve_size / VMRegImpl::stack_slot_size;
2661 #else
2662   return 0;
2663 #endif
2664 }
2665 
2666 #if defined(COMPILER1) || defined(COMPILER2)
2667 // Frame generation for deopt and uncommon trap blobs.
2668 static void push_skeleton_frame(MacroAssembler* masm, bool deopt,
2669                                 /* Read */
2670                                 Register unroll_block_reg,
2671                                 /* Update */
2672                                 Register frame_sizes_reg,
2673                                 Register number_of_frames_reg,
2674                                 Register pcs_reg,
2675                                 /* Invalidate */
2676                                 Register frame_size_reg,
2677                                 Register pc_reg) {
2678 
2679   __ ld(pc_reg, 0, pcs_reg);
2680   __ ld(frame_size_reg, 0, frame_sizes_reg);
2681   __ std(pc_reg, _abi(lr), R1_SP);
2682   __ push_frame(frame_size_reg, R0/*tmp*/);
2683 #ifdef ASSERT
2684   __ load_const_optimized(pc_reg, 0x5afe);
2685   __ std(pc_reg, _ijava_state_neg(ijava_reserved), R1_SP);
2686 #endif
2687   __ std(R1_SP, _ijava_state_neg(sender_sp), R1_SP);
2688   __ addi(number_of_frames_reg, number_of_frames_reg, -1);
2689   __ addi(frame_sizes_reg, frame_sizes_reg, wordSize);
2690   __ addi(pcs_reg, pcs_reg, wordSize);
2691 }
2692 
2693 // Loop through the UnrollBlock info and create new frames.
2694 static void push_skeleton_frames(MacroAssembler* masm, bool deopt,
2695                                  /* read */
2696                                  Register unroll_block_reg,
2697                                  /* invalidate */
2698                                  Register frame_sizes_reg,
2699                                  Register number_of_frames_reg,
2700                                  Register pcs_reg,
2701                                  Register frame_size_reg,
2702                                  Register pc_reg) {
2703   Label loop;
2704 
2705  // _number_of_frames is of type int (deoptimization.hpp)
2706   __ lwa(number_of_frames_reg,
2707              Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes(),
2708              unroll_block_reg);
2709   __ ld(pcs_reg,
2710             Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes(),
2711             unroll_block_reg);
2712   __ ld(frame_sizes_reg,
2713             Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes(),
2714             unroll_block_reg);
2715 
2716   // stack: (caller_of_deoptee, ...).
2717 
2718   // At this point we either have an interpreter frame or a compiled
2719   // frame on top of stack. If it is a compiled frame we push a new c2i
2720   // adapter here
2721 
2722   // Memorize top-frame stack-pointer.
2723   __ mr(frame_size_reg/*old_sp*/, R1_SP);
2724 
2725   // Resize interpreter top frame OR C2I adapter.
2726 
2727   // At this moment, the top frame (which is the caller of the deoptee) is
2728   // an interpreter frame or a newly pushed C2I adapter or an entry frame.
2729   // The top frame has a TOP_IJAVA_FRAME_ABI and the frame contains the
2730   // outgoing arguments.
2731   //
2732   // In order to push the interpreter frame for the deoptee, we need to
2733   // resize the top frame such that we are able to place the deoptee&#39;s
2734   // locals in the frame.
2735   // Additionally, we have to turn the top frame&#39;s TOP_IJAVA_FRAME_ABI
2736   // into a valid PARENT_IJAVA_FRAME_ABI.
2737 
2738   __ lwa(R11_scratch1,
2739              Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes(),
2740              unroll_block_reg);
2741   __ neg(R11_scratch1, R11_scratch1);
2742 
2743   // R11_scratch1 contains size of locals for frame resizing.
2744   // R12_scratch2 contains top frame&#39;s lr.
2745 
2746   // Resize frame by complete frame size prevents TOC from being
2747   // overwritten by locals. A more stack space saving way would be
2748   // to copy the TOC to its location in the new abi.
2749   __ addi(R11_scratch1, R11_scratch1, - frame::parent_ijava_frame_abi_size);
2750 
2751   // now, resize the frame
2752   __ resize_frame(R11_scratch1, pc_reg/*tmp*/);
2753 
2754   // In the case where we have resized a c2i frame above, the optional
2755   // alignment below the locals has size 32 (why?).
2756   __ std(R12_scratch2, _abi(lr), R1_SP);
2757 
2758   // Initialize initial_caller_sp.
2759 #ifdef ASSERT
2760  __ load_const_optimized(pc_reg, 0x5afe);
2761  __ std(pc_reg, _ijava_state_neg(ijava_reserved), R1_SP);
2762 #endif
2763  __ std(frame_size_reg, _ijava_state_neg(sender_sp), R1_SP);
2764 
2765 #ifdef ASSERT
2766   // Make sure that there is at least one entry in the array.
2767   __ cmpdi(CCR0, number_of_frames_reg, 0);
2768   __ asm_assert_ne(&quot;array_size must be &gt; 0&quot;, 0x205);
2769 #endif
2770 
2771   // Now push the new interpreter frames.
2772   //
2773   __ bind(loop);
2774   // Allocate a new frame, fill in the pc.
2775   push_skeleton_frame(masm, deopt,
2776                       unroll_block_reg,
2777                       frame_sizes_reg,
2778                       number_of_frames_reg,
2779                       pcs_reg,
2780                       frame_size_reg,
2781                       pc_reg);
2782   __ cmpdi(CCR0, number_of_frames_reg, 0);
2783   __ bne(CCR0, loop);
2784 
2785   // Get the return address pointing into the frame manager.
2786   __ ld(R0, 0, pcs_reg);
2787   // Store it in the top interpreter frame.
2788   __ std(R0, _abi(lr), R1_SP);
2789   // Initialize frame_manager_lr of interpreter top frame.
2790 }
2791 #endif
2792 
2793 void SharedRuntime::generate_deopt_blob() {
2794   // Allocate space for the code
2795   ResourceMark rm;
2796   // Setup code generation tools
2797   CodeBuffer buffer(&quot;deopt_blob&quot;, 2048, 1024);
2798   InterpreterMacroAssembler* masm = new InterpreterMacroAssembler(&amp;buffer);
2799   Label exec_mode_initialized;
2800   int frame_size_in_words;
2801   OopMap* map = NULL;
2802   OopMapSet *oop_maps = new OopMapSet();
2803 
2804   // size of ABI112 plus spill slots for R3_RET and F1_RET.
2805   const int frame_size_in_bytes = frame::abi_reg_args_spill_size;
2806   const int frame_size_in_slots = frame_size_in_bytes / sizeof(jint);
2807   int first_frame_size_in_bytes = 0; // frame size of &quot;unpack frame&quot; for call to fetch_unroll_info.
2808 
2809   const Register exec_mode_reg = R21_tmp1;
2810 
2811   const address start = __ pc();
2812 
2813 #if defined(COMPILER1) || defined(COMPILER2)
2814   // --------------------------------------------------------------------------
2815   // Prolog for non exception case!
2816 
2817   // We have been called from the deopt handler of the deoptee.
2818   //
2819   // deoptee:
2820   //                      ...
2821   //                      call X
2822   //                      ...
2823   //  deopt_handler:      call_deopt_stub
2824   //  cur. return pc  --&gt; ...
2825   //
2826   // So currently SR_LR points behind the call in the deopt handler.
2827   // We adjust it such that it points to the start of the deopt handler.
2828   // The return_pc has been stored in the frame of the deoptee and
2829   // will replace the address of the deopt_handler in the call
2830   // to Deoptimization::fetch_unroll_info below.
2831   // We can&#39;t grab a free register here, because all registers may
2832   // contain live values, so let the RegisterSaver do the adjustment
2833   // of the return pc.
2834   const int return_pc_adjustment_no_exception = -HandlerImpl::size_deopt_handler();
2835 
2836   // Push the &quot;unpack frame&quot;
2837   // Save everything in sight.
2838   map = RegisterSaver::push_frame_reg_args_and_save_live_registers(masm,
2839                                                                    &amp;first_frame_size_in_bytes,
2840                                                                    /*generate_oop_map=*/ true,
2841                                                                    return_pc_adjustment_no_exception,
2842                                                                    RegisterSaver::return_pc_is_lr);
2843   assert(map != NULL, &quot;OopMap must have been created&quot;);
2844 
2845   __ li(exec_mode_reg, Deoptimization::Unpack_deopt);
2846   // Save exec mode for unpack_frames.
2847   __ b(exec_mode_initialized);
2848 
2849   // --------------------------------------------------------------------------
2850   // Prolog for exception case
2851 
2852   // An exception is pending.
2853   // We have been called with a return (interpreter) or a jump (exception blob).
2854   //
2855   // - R3_ARG1: exception oop
2856   // - R4_ARG2: exception pc
2857 
2858   int exception_offset = __ pc() - start;
2859 
2860   BLOCK_COMMENT(&quot;Prolog for exception case&quot;);
2861 
2862   // Store exception oop and pc in thread (location known to GC).
2863   // This is needed since the call to &quot;fetch_unroll_info()&quot; may safepoint.
2864   __ std(R3_ARG1, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
2865   __ std(R4_ARG2, in_bytes(JavaThread::exception_pc_offset()),  R16_thread);
2866   __ std(R4_ARG2, _abi(lr), R1_SP);
2867 
2868   // Vanilla deoptimization with an exception pending in exception_oop.
2869   int exception_in_tls_offset = __ pc() - start;
2870 
2871   // Push the &quot;unpack frame&quot;.
2872   // Save everything in sight.
2873   RegisterSaver::push_frame_reg_args_and_save_live_registers(masm,
2874                                                              &amp;first_frame_size_in_bytes,
2875                                                              /*generate_oop_map=*/ false,
2876                                                              /*return_pc_adjustment_exception=*/ 0,
2877                                                              RegisterSaver::return_pc_is_pre_saved);
2878 
2879   // Deopt during an exception. Save exec mode for unpack_frames.
2880   __ li(exec_mode_reg, Deoptimization::Unpack_exception);
2881 
2882   // fall through
2883 
2884   int reexecute_offset = 0;
2885 #ifdef COMPILER1
2886   __ b(exec_mode_initialized);
2887 
2888   // Reexecute entry, similar to c2 uncommon trap
2889   reexecute_offset = __ pc() - start;
2890 
2891   RegisterSaver::push_frame_reg_args_and_save_live_registers(masm,
2892                                                              &amp;first_frame_size_in_bytes,
2893                                                              /*generate_oop_map=*/ false,
2894                                                              /*return_pc_adjustment_reexecute=*/ 0,
2895                                                              RegisterSaver::return_pc_is_pre_saved);
2896   __ li(exec_mode_reg, Deoptimization::Unpack_reexecute);
2897 #endif
2898 
2899   // --------------------------------------------------------------------------
2900   __ BIND(exec_mode_initialized);
2901 
2902   {
2903   const Register unroll_block_reg = R22_tmp2;
2904 
2905   // We need to set `last_Java_frame&#39; because `fetch_unroll_info&#39; will
2906   // call `last_Java_frame()&#39;. The value of the pc in the frame is not
2907   // particularly important. It just needs to identify this blob.
2908   __ set_last_Java_frame(R1_SP, noreg);
2909 
2910   // With EscapeAnalysis turned on, this call may safepoint!
2911   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info), R16_thread, exec_mode_reg);
2912   address calls_return_pc = __ last_calls_return_pc();
2913   // Set an oopmap for the call site that describes all our saved registers.
2914   oop_maps-&gt;add_gc_map(calls_return_pc - start, map);
2915 
2916   __ reset_last_Java_frame();
2917   // Save the return value.
2918   __ mr(unroll_block_reg, R3_RET);
2919 
2920   // Restore only the result registers that have been saved
2921   // by save_volatile_registers(...).
2922   RegisterSaver::restore_result_registers(masm, first_frame_size_in_bytes);
2923 
2924   // reload the exec mode from the UnrollBlock (it might have changed)
2925   __ lwz(exec_mode_reg, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes(), unroll_block_reg);
2926   // In excp_deopt_mode, restore and clear exception oop which we
2927   // stored in the thread during exception entry above. The exception
2928   // oop will be the return value of this stub.
2929   Label skip_restore_excp;
2930   __ cmpdi(CCR0, exec_mode_reg, Deoptimization::Unpack_exception);
2931   __ bne(CCR0, skip_restore_excp);
2932   __ ld(R3_RET, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
2933   __ ld(R4_ARG2, in_bytes(JavaThread::exception_pc_offset()), R16_thread);
2934   __ li(R0, 0);
2935   __ std(R0, in_bytes(JavaThread::exception_pc_offset()),  R16_thread);
2936   __ std(R0, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
2937   __ BIND(skip_restore_excp);
2938 
2939   __ pop_frame();
2940 
2941   // stack: (deoptee, optional i2c, caller of deoptee, ...).
2942 
2943   // pop the deoptee&#39;s frame
2944   __ pop_frame();
2945 
2946   // stack: (caller_of_deoptee, ...).
2947 
2948   // Loop through the `UnrollBlock&#39; info and create interpreter frames.
2949   push_skeleton_frames(masm, true/*deopt*/,
2950                        unroll_block_reg,
2951                        R23_tmp3,
2952                        R24_tmp4,
2953                        R25_tmp5,
2954                        R26_tmp6,
2955                        R27_tmp7);
2956 
2957   // stack: (skeletal interpreter frame, ..., optional skeletal
2958   // interpreter frame, optional c2i, caller of deoptee, ...).
2959   }
2960 
2961   // push an `unpack_frame&#39; taking care of float / int return values.
2962   __ push_frame(frame_size_in_bytes, R0/*tmp*/);
2963 
2964   // stack: (unpack frame, skeletal interpreter frame, ..., optional
2965   // skeletal interpreter frame, optional c2i, caller of deoptee,
2966   // ...).
2967 
2968   // Spill live volatile registers since we&#39;ll do a call.
2969   __ std( R3_RET, _abi_reg_args_spill(spill_ret),  R1_SP);
2970   __ stfd(F1_RET, _abi_reg_args_spill(spill_fret), R1_SP);
2971 
2972   // Let the unpacker layout information in the skeletal frames just
2973   // allocated.
2974   __ get_PC_trash_LR(R3_RET);
2975   __ set_last_Java_frame(/*sp*/R1_SP, /*pc*/R3_RET);
2976   // This is a call to a LEAF method, so no oop map is required.
2977   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames),
2978                   R16_thread/*thread*/, exec_mode_reg/*exec_mode*/);
2979   __ reset_last_Java_frame();
2980 
2981   // Restore the volatiles saved above.
2982   __ ld( R3_RET, _abi_reg_args_spill(spill_ret),  R1_SP);
2983   __ lfd(F1_RET, _abi_reg_args_spill(spill_fret), R1_SP);
2984 
2985   // Pop the unpack frame.
2986   __ pop_frame();
2987   __ restore_LR_CR(R0);
2988 
2989   // stack: (top interpreter frame, ..., optional interpreter frame,
2990   // optional c2i, caller of deoptee, ...).
2991 
2992   // Initialize R14_state.
2993   __ restore_interpreter_state(R11_scratch1);
2994   __ load_const_optimized(R25_templateTableBase, (address)Interpreter::dispatch_table((TosState)0), R11_scratch1);
2995 
2996   // Return to the interpreter entry point.
2997   __ blr();
2998   __ flush();
2999 #else // COMPILER2
3000   __ unimplemented(&quot;deopt blob needed only with compiler&quot;);
3001   int exception_offset = __ pc() - start;
3002 #endif // COMPILER2
3003 
3004   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset,
3005                                            reexecute_offset, first_frame_size_in_bytes / wordSize);
3006   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
3007 }
3008 
3009 #ifdef COMPILER2
3010 void SharedRuntime::generate_uncommon_trap_blob() {
3011   // Allocate space for the code.
3012   ResourceMark rm;
3013   // Setup code generation tools.
3014   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
3015   InterpreterMacroAssembler* masm = new InterpreterMacroAssembler(&amp;buffer);
3016   address start = __ pc();
3017 
3018   if (UseRTMLocking) {
3019     // Abort RTM transaction before possible nmethod deoptimization.
3020     __ tabort_();
3021   }
3022 
3023   Register unroll_block_reg = R21_tmp1;
3024   Register klass_index_reg  = R22_tmp2;
3025   Register unc_trap_reg     = R23_tmp3;
3026 
3027   OopMapSet* oop_maps = new OopMapSet();
3028   int frame_size_in_bytes = frame::abi_reg_args_size;
3029   OopMap* map = new OopMap(frame_size_in_bytes / sizeof(jint), 0);
3030 
3031   // stack: (deoptee, optional i2c, caller_of_deoptee, ...).
3032 
3033   // Push a dummy `unpack_frame&#39; and call
3034   // `Deoptimization::uncommon_trap&#39; to pack the compiled frame into a
3035   // vframe array and return the `UnrollBlock&#39; information.
3036 
3037   // Save LR to compiled frame.
3038   __ save_LR_CR(R11_scratch1);
3039 
3040   // Push an &quot;uncommon_trap&quot; frame.
3041   __ push_frame_reg_args(0, R11_scratch1);
3042 
3043   // stack: (unpack frame, deoptee, optional i2c, caller_of_deoptee, ...).
3044 
3045   // Set the `unpack_frame&#39; as last_Java_frame.
3046   // `Deoptimization::uncommon_trap&#39; expects it and considers its
3047   // sender frame as the deoptee frame.
3048   // Remember the offset of the instruction whose address will be
3049   // moved to R11_scratch1.
3050   address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);
3051 
3052   __ set_last_Java_frame(/*sp*/R1_SP, /*pc*/R11_scratch1);
3053 
3054   __ mr(klass_index_reg, R3);
3055   __ li(R5_ARG3, Deoptimization::Unpack_uncommon_trap);
3056   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap),
3057                   R16_thread, klass_index_reg, R5_ARG3);
3058 
3059   // Set an oopmap for the call site.
3060   oop_maps-&gt;add_gc_map(gc_map_pc - start, map);
3061 
3062   __ reset_last_Java_frame();
3063 
3064   // Pop the `unpack frame&#39;.
3065   __ pop_frame();
3066 
3067   // stack: (deoptee, optional i2c, caller_of_deoptee, ...).
3068 
3069   // Save the return value.
3070   __ mr(unroll_block_reg, R3_RET);
3071 
3072   // Pop the uncommon_trap frame.
3073   __ pop_frame();
3074 
3075   // stack: (caller_of_deoptee, ...).
3076 
3077 #ifdef ASSERT
3078   __ lwz(R22_tmp2, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes(), unroll_block_reg);
3079   __ cmpdi(CCR0, R22_tmp2, (unsigned)Deoptimization::Unpack_uncommon_trap);
3080   __ asm_assert_eq(&quot;SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap&quot;, 0);
3081 #endif
3082 
3083   // Allocate new interpreter frame(s) and possibly a c2i adapter
3084   // frame.
3085   push_skeleton_frames(masm, false/*deopt*/,
3086                        unroll_block_reg,
3087                        R22_tmp2,
3088                        R23_tmp3,
3089                        R24_tmp4,
3090                        R25_tmp5,
3091                        R26_tmp6);
3092 
3093   // stack: (skeletal interpreter frame, ..., optional skeletal
3094   // interpreter frame, optional c2i, caller of deoptee, ...).
3095 
3096   // Push a dummy `unpack_frame&#39; taking care of float return values.
3097   // Call `Deoptimization::unpack_frames&#39; to layout information in the
3098   // interpreter frames just created.
3099 
3100   // Push a simple &quot;unpack frame&quot; here.
3101   __ push_frame_reg_args(0, R11_scratch1);
3102 
3103   // stack: (unpack frame, skeletal interpreter frame, ..., optional
3104   // skeletal interpreter frame, optional c2i, caller of deoptee,
3105   // ...).
3106 
3107   // Set the &quot;unpack_frame&quot; as last_Java_frame.
3108   __ get_PC_trash_LR(R11_scratch1);
3109   __ set_last_Java_frame(/*sp*/R1_SP, /*pc*/R11_scratch1);
3110 
3111   // Indicate it is the uncommon trap case.
3112   __ li(unc_trap_reg, Deoptimization::Unpack_uncommon_trap);
3113   // Let the unpacker layout information in the skeletal frames just
3114   // allocated.
3115   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames),
3116                   R16_thread, unc_trap_reg);
3117 
3118   __ reset_last_Java_frame();
3119   // Pop the `unpack frame&#39;.
3120   __ pop_frame();
3121   // Restore LR from top interpreter frame.
3122   __ restore_LR_CR(R11_scratch1);
3123 
3124   // stack: (top interpreter frame, ..., optional interpreter frame,
3125   // optional c2i, caller of deoptee, ...).
3126 
3127   __ restore_interpreter_state(R11_scratch1);
3128   __ load_const_optimized(R25_templateTableBase, (address)Interpreter::dispatch_table((TosState)0), R11_scratch1);
3129 
3130   // Return to the interpreter entry point.
3131   __ blr();
3132 
3133   masm-&gt;flush();
3134 
3135   _uncommon_trap_blob = UncommonTrapBlob::create(&amp;buffer, oop_maps, frame_size_in_bytes/wordSize);
3136 }
3137 #endif // COMPILER2
3138 
3139 // Generate a special Compile2Runtime blob that saves all registers, and setup oopmap.
3140 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
3141   assert(StubRoutines::forward_exception_entry() != NULL,
3142          &quot;must be generated before&quot;);
3143 
3144   ResourceMark rm;
3145   OopMapSet *oop_maps = new OopMapSet();
3146   OopMap* map;
3147 
3148   // Allocate space for the code. Setup code generation tools.
3149   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
3150   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3151 
3152   address start = __ pc();
3153   int frame_size_in_bytes = 0;
3154 
3155   RegisterSaver::ReturnPCLocation return_pc_location;
3156   bool cause_return = (poll_type == POLL_AT_RETURN);
3157   if (cause_return) {
3158     // Nothing to do here. The frame has already been popped in MachEpilogNode.
3159     // Register LR already contains the return pc.
3160     return_pc_location = RegisterSaver::return_pc_is_lr;
3161   } else {
3162     // Use thread()-&gt;saved_exception_pc() as return pc.
3163     return_pc_location = RegisterSaver::return_pc_is_thread_saved_exception_pc;
3164   }
3165 
3166   if (UseRTMLocking) {
3167     // Abort RTM transaction before calling runtime
3168     // because critical section can be large and so
3169     // will abort anyway. Also nmethod can be deoptimized.
3170     __ tabort_();
3171   }
3172 
3173   bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
3174 
3175   // Save registers, fpu state, and flags. Set R31 = return pc.
3176   map = RegisterSaver::push_frame_reg_args_and_save_live_registers(masm,
3177                                                                    &amp;frame_size_in_bytes,
3178                                                                    /*generate_oop_map=*/ true,
3179                                                                    /*return_pc_adjustment=*/0,
3180                                                                    return_pc_location, save_vectors);
3181 
3182   // The following is basically a call_VM. However, we need the precise
3183   // address of the call in order to generate an oopmap. Hence, we do all the
3184   // work outselves.
3185   __ set_last_Java_frame(/*sp=*/R1_SP, /*pc=*/noreg);
3186 
3187   // The return address must always be correct so that the frame constructor
3188   // never sees an invalid pc.
3189 
3190   // Do the call
3191   __ call_VM_leaf(call_ptr, R16_thread);
3192   address calls_return_pc = __ last_calls_return_pc();
3193 
3194   // Set an oopmap for the call site. This oopmap will map all
3195   // oop-registers and debug-info registers as callee-saved. This
3196   // will allow deoptimization at this safepoint to find all possible
3197   // debug-info recordings, as well as let GC find all oops.
3198   oop_maps-&gt;add_gc_map(calls_return_pc - start, map);
3199 
3200   Label noException;
3201 
3202   // Clear the last Java frame.
3203   __ reset_last_Java_frame();
3204 
3205   BLOCK_COMMENT(&quot;  Check pending exception.&quot;);
3206   const Register pending_exception = R0;
3207   __ ld(pending_exception, thread_(pending_exception));
3208   __ cmpdi(CCR0, pending_exception, 0);
3209   __ beq(CCR0, noException);
3210 
3211   // Exception pending
3212   RegisterSaver::restore_live_registers_and_pop_frame(masm,
3213                                                       frame_size_in_bytes,
3214                                                       /*restore_ctr=*/true, save_vectors);
3215 
3216   BLOCK_COMMENT(&quot;  Jump to forward_exception_entry.&quot;);
3217   // Jump to forward_exception_entry, with the issuing PC in LR
3218   // so it looks like the original nmethod called forward_exception_entry.
3219   __ b64_patchable(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type);
3220 
3221   // No exception case.
3222   __ BIND(noException);
3223 
3224   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; !cause_return) {
3225     Label no_adjust;
3226     // If our stashed return pc was modified by the runtime we avoid touching it
3227     __ ld(R0, frame_size_in_bytes + _abi(lr), R1_SP);
3228     __ cmpd(CCR0, R0, R31);
3229     __ bne(CCR0, no_adjust);
3230 
3231     // Adjust return pc forward to step over the safepoint poll instruction
3232     __ addi(R31, R31, 4);
3233     __ std(R31, frame_size_in_bytes + _abi(lr), R1_SP);
3234 
3235     __ bind(no_adjust);
3236   }
3237 
3238   // Normal exit, restore registers and exit.
3239   RegisterSaver::restore_live_registers_and_pop_frame(masm,
3240                                                       frame_size_in_bytes,
3241                                                       /*restore_ctr=*/true, save_vectors);
3242 
3243   __ blr();
3244 
3245   // Make sure all code is generated
3246   masm-&gt;flush();
3247 
3248   // Fill-out other meta info
3249   // CodeBlob frame size is in words.
3250   return SafepointBlob::create(&amp;buffer, oop_maps, frame_size_in_bytes / wordSize);
3251 }
3252 
3253 // generate_resolve_blob - call resolution (static/virtual/opt-virtual/ic-miss)
3254 //
3255 // Generate a stub that calls into the vm to find out the proper destination
3256 // of a java call. All the argument registers are live at this point
3257 // but since this is generic code we don&#39;t know what they are and the caller
3258 // must do any gc of the args.
3259 //
3260 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
3261 
3262   // allocate space for the code
3263   ResourceMark rm;
3264 
3265   CodeBuffer buffer(name, 1000, 512);
3266   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3267 
3268   int frame_size_in_bytes;
3269 
3270   OopMapSet *oop_maps = new OopMapSet();
3271   OopMap* map = NULL;
3272 
3273   address start = __ pc();
3274 
3275   map = RegisterSaver::push_frame_reg_args_and_save_live_registers(masm,
3276                                                                    &amp;frame_size_in_bytes,
3277                                                                    /*generate_oop_map*/ true,
3278                                                                    /*return_pc_adjustment*/ 0,
3279                                                                    RegisterSaver::return_pc_is_lr);
3280 
3281   // Use noreg as last_Java_pc, the return pc will be reconstructed
3282   // from the physical frame.
3283   __ set_last_Java_frame(/*sp*/R1_SP, noreg);
3284 
3285   int frame_complete = __ offset();
3286 
3287   // Pass R19_method as 2nd (optional) argument, used by
3288   // counter_overflow_stub.
3289   __ call_VM_leaf(destination, R16_thread, R19_method);
3290   address calls_return_pc = __ last_calls_return_pc();
3291   // Set an oopmap for the call site.
3292   // We need this not only for callee-saved registers, but also for volatile
3293   // registers that the compiler might be keeping live across a safepoint.
3294   // Create the oopmap for the call&#39;s return pc.
3295   oop_maps-&gt;add_gc_map(calls_return_pc - start, map);
3296 
3297   // R3_RET contains the address we are going to jump to assuming no exception got installed.
3298 
3299   // clear last_Java_sp
3300   __ reset_last_Java_frame();
3301 
3302   // Check for pending exceptions.
3303   BLOCK_COMMENT(&quot;Check for pending exceptions.&quot;);
3304   Label pending;
3305   __ ld(R11_scratch1, thread_(pending_exception));
3306   __ cmpdi(CCR0, R11_scratch1, 0);
3307   __ bne(CCR0, pending);
3308 
3309   __ mtctr(R3_RET); // Ctr will not be touched by restore_live_registers_and_pop_frame.
3310 
3311   RegisterSaver::restore_live_registers_and_pop_frame(masm, frame_size_in_bytes, /*restore_ctr*/ false);
3312 
3313   // Get the returned method.
3314   __ get_vm_result_2(R19_method);
3315 
3316   __ bctr();
3317 
3318 
3319   // Pending exception after the safepoint.
3320   __ BIND(pending);
3321 
3322   RegisterSaver::restore_live_registers_and_pop_frame(masm, frame_size_in_bytes, /*restore_ctr*/ true);
3323 
3324   // exception pending =&gt; remove activation and forward to exception handler
3325 
3326   __ li(R11_scratch1, 0);
3327   __ ld(R3_ARG1, thread_(pending_exception));
3328   __ std(R11_scratch1, in_bytes(JavaThread::vm_result_offset()), R16_thread);
3329   __ b64_patchable(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type);
3330 
3331   // -------------
3332   // Make sure all code is generated.
3333   masm-&gt;flush();
3334 
3335   // return the blob
3336   // frame_size_words or bytes??
3337   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_in_bytes/wordSize,
3338                                        oop_maps, true);
3339 }
3340 
3341 
3342 //------------------------------Montgomery multiplication------------------------
3343 //
3344 
3345 // Subtract 0:b from carry:a. Return carry.
3346 static unsigned long
3347 sub(unsigned long a[], unsigned long b[], unsigned long carry, long len) {
3348   long i = 0;
3349   unsigned long tmp, tmp2;
3350   __asm__ __volatile__ (
3351     &quot;subfc  %[tmp], %[tmp], %[tmp]   \n&quot; // pre-set CA
3352     &quot;mtctr  %[len]                   \n&quot;
3353     &quot;0:                              \n&quot;
3354     &quot;ldx    %[tmp], %[i], %[a]       \n&quot;
3355     &quot;ldx    %[tmp2], %[i], %[b]      \n&quot;
3356     &quot;subfe  %[tmp], %[tmp2], %[tmp]  \n&quot; // subtract extended
3357     &quot;stdx   %[tmp], %[i], %[a]       \n&quot;
3358     &quot;addi   %[i], %[i], 8            \n&quot;
3359     &quot;bdnz   0b                       \n&quot;
3360     &quot;addme  %[tmp], %[carry]         \n&quot; // carry + CA - 1
3361     : [i]&quot;+b&quot;(i), [tmp]&quot;=&amp;r&quot;(tmp), [tmp2]&quot;=&amp;r&quot;(tmp2)
3362     : [a]&quot;r&quot;(a), [b]&quot;r&quot;(b), [carry]&quot;r&quot;(carry), [len]&quot;r&quot;(len)
3363     : &quot;ctr&quot;, &quot;xer&quot;, &quot;memory&quot;
3364   );
3365   return tmp;
3366 }
3367 
3368 // Multiply (unsigned) Long A by Long B, accumulating the double-
3369 // length result into the accumulator formed of T0, T1, and T2.
3370 inline void MACC(unsigned long A, unsigned long B, unsigned long &amp;T0, unsigned long &amp;T1, unsigned long &amp;T2) {
3371   unsigned long hi, lo;
3372   __asm__ __volatile__ (
3373     &quot;mulld  %[lo], %[A], %[B]    \n&quot;
3374     &quot;mulhdu %[hi], %[A], %[B]    \n&quot;
3375     &quot;addc   %[T0], %[T0], %[lo]  \n&quot;
3376     &quot;adde   %[T1], %[T1], %[hi]  \n&quot;
3377     &quot;addze  %[T2], %[T2]         \n&quot;
3378     : [hi]&quot;=&amp;r&quot;(hi), [lo]&quot;=&amp;r&quot;(lo), [T0]&quot;+r&quot;(T0), [T1]&quot;+r&quot;(T1), [T2]&quot;+r&quot;(T2)
3379     : [A]&quot;r&quot;(A), [B]&quot;r&quot;(B)
3380     : &quot;xer&quot;
3381   );
3382 }
3383 
3384 // As above, but add twice the double-length result into the
3385 // accumulator.
3386 inline void MACC2(unsigned long A, unsigned long B, unsigned long &amp;T0, unsigned long &amp;T1, unsigned long &amp;T2) {
3387   unsigned long hi, lo;
3388   __asm__ __volatile__ (
3389     &quot;mulld  %[lo], %[A], %[B]    \n&quot;
3390     &quot;mulhdu %[hi], %[A], %[B]    \n&quot;
3391     &quot;addc   %[T0], %[T0], %[lo]  \n&quot;
3392     &quot;adde   %[T1], %[T1], %[hi]  \n&quot;
3393     &quot;addze  %[T2], %[T2]         \n&quot;
3394     &quot;addc   %[T0], %[T0], %[lo]  \n&quot;
3395     &quot;adde   %[T1], %[T1], %[hi]  \n&quot;
3396     &quot;addze  %[T2], %[T2]         \n&quot;
3397     : [hi]&quot;=&amp;r&quot;(hi), [lo]&quot;=&amp;r&quot;(lo), [T0]&quot;+r&quot;(T0), [T1]&quot;+r&quot;(T1), [T2]&quot;+r&quot;(T2)
3398     : [A]&quot;r&quot;(A), [B]&quot;r&quot;(B)
3399     : &quot;xer&quot;
3400   );
3401 }
3402 
3403 // Fast Montgomery multiplication. The derivation of the algorithm is
3404 // in &quot;A Cryptographic Library for the Motorola DSP56000,
3405 // Dusse and Kaliski, Proc. EUROCRYPT 90, pp. 230-237&quot;.
3406 static void
3407 montgomery_multiply(unsigned long a[], unsigned long b[], unsigned long n[],
3408                     unsigned long m[], unsigned long inv, int len) {
3409   unsigned long t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
3410   int i;
3411 
3412   assert(inv * n[0] == -1UL, &quot;broken inverse in Montgomery multiply&quot;);
3413 
3414   for (i = 0; i &lt; len; i++) {
3415     int j;
3416     for (j = 0; j &lt; i; j++) {
3417       MACC(a[j], b[i-j], t0, t1, t2);
3418       MACC(m[j], n[i-j], t0, t1, t2);
3419     }
3420     MACC(a[i], b[0], t0, t1, t2);
3421     m[i] = t0 * inv;
3422     MACC(m[i], n[0], t0, t1, t2);
3423 
3424     assert(t0 == 0, &quot;broken Montgomery multiply&quot;);
3425 
3426     t0 = t1; t1 = t2; t2 = 0;
3427   }
3428 
3429   for (i = len; i &lt; 2*len; i++) {
3430     int j;
3431     for (j = i-len+1; j &lt; len; j++) {
3432       MACC(a[j], b[i-j], t0, t1, t2);
3433       MACC(m[j], n[i-j], t0, t1, t2);
3434     }
3435     m[i-len] = t0;
3436     t0 = t1; t1 = t2; t2 = 0;
3437   }
3438 
3439   while (t0) {
3440     t0 = sub(m, n, t0, len);
3441   }
3442 }
3443 
3444 // Fast Montgomery squaring. This uses asymptotically 25% fewer
3445 // multiplies so it should be up to 25% faster than Montgomery
3446 // multiplication. However, its loop control is more complex and it
3447 // may actually run slower on some machines.
3448 static void
3449 montgomery_square(unsigned long a[], unsigned long n[],
3450                   unsigned long m[], unsigned long inv, int len) {
3451   unsigned long t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
3452   int i;
3453 
3454   assert(inv * n[0] == -1UL, &quot;broken inverse in Montgomery multiply&quot;);
3455 
3456   for (i = 0; i &lt; len; i++) {
3457     int j;
3458     int end = (i+1)/2;
3459     for (j = 0; j &lt; end; j++) {
3460       MACC2(a[j], a[i-j], t0, t1, t2);
3461       MACC(m[j], n[i-j], t0, t1, t2);
3462     }
3463     if ((i &amp; 1) == 0) {
3464       MACC(a[j], a[j], t0, t1, t2);
3465     }
3466     for (; j &lt; i; j++) {
3467       MACC(m[j], n[i-j], t0, t1, t2);
3468     }
3469     m[i] = t0 * inv;
3470     MACC(m[i], n[0], t0, t1, t2);
3471 
3472     assert(t0 == 0, &quot;broken Montgomery square&quot;);
3473 
3474     t0 = t1; t1 = t2; t2 = 0;
3475   }
3476 
3477   for (i = len; i &lt; 2*len; i++) {
3478     int start = i-len+1;
3479     int end = start + (len - start)/2;
3480     int j;
3481     for (j = start; j &lt; end; j++) {
3482       MACC2(a[j], a[i-j], t0, t1, t2);
3483       MACC(m[j], n[i-j], t0, t1, t2);
3484     }
3485     if ((i &amp; 1) == 0) {
3486       MACC(a[j], a[j], t0, t1, t2);
3487     }
3488     for (; j &lt; len; j++) {
3489       MACC(m[j], n[i-j], t0, t1, t2);
3490     }
3491     m[i-len] = t0;
3492     t0 = t1; t1 = t2; t2 = 0;
3493   }
3494 
3495   while (t0) {
3496     t0 = sub(m, n, t0, len);
3497   }
3498 }
3499 
3500 // The threshold at which squaring is advantageous was determined
3501 // experimentally on an i7-3930K (Ivy Bridge) CPU @ 3.5GHz.
3502 // Doesn&#39;t seem to be relevant for Power8 so we use the same value.
3503 #define MONTGOMERY_SQUARING_THRESHOLD 64
3504 
3505 // Copy len longwords from s to d, word-swapping as we go. The
3506 // destination array is reversed.
3507 static void reverse_words(unsigned long *s, unsigned long *d, int len) {
3508   d += len;
3509   while(len-- &gt; 0) {
3510     d--;
3511     unsigned long s_val = *s;
3512     // Swap words in a longword on little endian machines.
3513 #ifdef VM_LITTLE_ENDIAN
3514      s_val = (s_val &lt;&lt; 32) | (s_val &gt;&gt; 32);
3515 #endif
3516     *d = s_val;
3517     s++;
3518   }
3519 }
3520 
3521 void SharedRuntime::montgomery_multiply(jint *a_ints, jint *b_ints, jint *n_ints,
3522                                         jint len, jlong inv,
3523                                         jint *m_ints) {
3524   len = len &amp; 0x7fffFFFF; // C2 does not respect int to long conversion for stub calls.
3525   assert(len % 2 == 0, &quot;array length in montgomery_multiply must be even&quot;);
3526   int longwords = len/2;
3527 
3528   // Make very sure we don&#39;t use so much space that the stack might
3529   // overflow. 512 jints corresponds to an 16384-bit integer and
3530   // will use here a total of 8k bytes of stack space.
3531   int total_allocation = longwords * sizeof (unsigned long) * 4;
3532   guarantee(total_allocation &lt;= 8192, &quot;must be&quot;);
3533   unsigned long *scratch = (unsigned long *)alloca(total_allocation);
3534 
3535   // Local scratch arrays
3536   unsigned long
3537     *a = scratch + 0 * longwords,
3538     *b = scratch + 1 * longwords,
3539     *n = scratch + 2 * longwords,
3540     *m = scratch + 3 * longwords;
3541 
3542   reverse_words((unsigned long *)a_ints, a, longwords);
3543   reverse_words((unsigned long *)b_ints, b, longwords);
3544   reverse_words((unsigned long *)n_ints, n, longwords);
3545 
3546   ::montgomery_multiply(a, b, n, m, (unsigned long)inv, longwords);
3547 
3548   reverse_words(m, (unsigned long *)m_ints, longwords);
3549 }
3550 
3551 void SharedRuntime::montgomery_square(jint *a_ints, jint *n_ints,
3552                                       jint len, jlong inv,
3553                                       jint *m_ints) {
3554   len = len &amp; 0x7fffFFFF; // C2 does not respect int to long conversion for stub calls.
3555   assert(len % 2 == 0, &quot;array length in montgomery_square must be even&quot;);
3556   int longwords = len/2;
3557 
3558   // Make very sure we don&#39;t use so much space that the stack might
3559   // overflow. 512 jints corresponds to an 16384-bit integer and
3560   // will use here a total of 6k bytes of stack space.
3561   int total_allocation = longwords * sizeof (unsigned long) * 3;
3562   guarantee(total_allocation &lt;= 8192, &quot;must be&quot;);
3563   unsigned long *scratch = (unsigned long *)alloca(total_allocation);
3564 
3565   // Local scratch arrays
3566   unsigned long
3567     *a = scratch + 0 * longwords,
3568     *n = scratch + 1 * longwords,
3569     *m = scratch + 2 * longwords;
3570 
3571   reverse_words((unsigned long *)a_ints, a, longwords);
3572   reverse_words((unsigned long *)n_ints, n, longwords);
3573 
3574   if (len &gt;= MONTGOMERY_SQUARING_THRESHOLD) {
3575     ::montgomery_square(a, n, m, (unsigned long)inv, longwords);
3576   } else {
3577     ::montgomery_multiply(a, a, n, m, (unsigned long)inv, longwords);
3578   }
3579 
3580   reverse_words(m, (unsigned long *)m_ints, longwords);
3581 }
    </pre>
  </body>
</html>
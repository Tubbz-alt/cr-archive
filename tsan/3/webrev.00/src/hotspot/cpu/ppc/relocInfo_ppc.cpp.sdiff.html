<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/relocInfo_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ppc.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/relocInfo_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41   //   share set-hi instructions between addresses that differ by a small
 42   //   offset (e.g., different static variables in the same class).
 43   //   On such machines, the &quot;x&quot; argument to set_value on all set-lo
 44   //   instructions must be the same as the &quot;x&quot; argument for the
 45   //   corresponding set-hi instructions.  The &quot;o&quot; arguments for the
 46   //   set-hi instructions are ignored, and must not affect the high-half
 47   //   immediate constant.  The &quot;o&quot; arguments for the set-lo instructions are
 48   //   added into the low-half immediate constant, and must not overflow it.&quot;
 49   //
 50   // Currently we don&#39;t support splitting of relocations, so o must be
 51   // zero:
 52   assert(o == 0, &quot;tried to split relocations&quot;);
 53 
 54   if (!verify_only) {
 55     if (format() != 1) {
 56       nativeMovConstReg_at(addr())-&gt;set_data_plain(((intptr_t)x), code());
 57     } else {
 58       assert(type() == relocInfo::oop_type || type() == relocInfo::metadata_type,
 59              &quot;how to encode else?&quot;);
 60       narrowOop no = (type() == relocInfo::oop_type) ?
<span class="line-modified"> 61           CompressedOops::encode((oop)x) : Klass::encode_klass((Klass*)x);</span>
 62       nativeMovConstReg_at(addr())-&gt;set_narrow_oop(no, code());
 63     }
 64   } else {
 65     guarantee((address) (nativeMovConstReg_at(addr())-&gt;data()) == x, &quot;data must match&quot;);
 66   }
 67 }
 68 
 69 address Relocation::pd_call_destination(address orig_addr) {
 70   intptr_t adj = 0;
 71   address inst_loc = addr();
 72 
 73   if (orig_addr != NULL) {
 74     // We just moved this call instruction from orig_addr to addr().
 75     // This means its target will appear to have grown by addr() - orig_addr.
 76     adj = -(inst_loc - orig_addr);
 77   }
 78   if (NativeFarCall::is_far_call_at(inst_loc)) {
 79     NativeFarCall* call = nativeFarCall_at(inst_loc);
 80     return call-&gt;destination() + (intptr_t)(call-&gt;is_pcrelative() ? adj : 0);
 81   } else if (NativeJump::is_jump_at(inst_loc)) {
</pre>
</td>
<td>
<hr />
<pre>
 41   //   share set-hi instructions between addresses that differ by a small
 42   //   offset (e.g., different static variables in the same class).
 43   //   On such machines, the &quot;x&quot; argument to set_value on all set-lo
 44   //   instructions must be the same as the &quot;x&quot; argument for the
 45   //   corresponding set-hi instructions.  The &quot;o&quot; arguments for the
 46   //   set-hi instructions are ignored, and must not affect the high-half
 47   //   immediate constant.  The &quot;o&quot; arguments for the set-lo instructions are
 48   //   added into the low-half immediate constant, and must not overflow it.&quot;
 49   //
 50   // Currently we don&#39;t support splitting of relocations, so o must be
 51   // zero:
 52   assert(o == 0, &quot;tried to split relocations&quot;);
 53 
 54   if (!verify_only) {
 55     if (format() != 1) {
 56       nativeMovConstReg_at(addr())-&gt;set_data_plain(((intptr_t)x), code());
 57     } else {
 58       assert(type() == relocInfo::oop_type || type() == relocInfo::metadata_type,
 59              &quot;how to encode else?&quot;);
 60       narrowOop no = (type() == relocInfo::oop_type) ?
<span class="line-modified"> 61           CompressedOops::encode((oop)x) : CompressedKlassPointers::encode((Klass*)x);</span>
 62       nativeMovConstReg_at(addr())-&gt;set_narrow_oop(no, code());
 63     }
 64   } else {
 65     guarantee((address) (nativeMovConstReg_at(addr())-&gt;data()) == x, &quot;data must match&quot;);
 66   }
 67 }
 68 
 69 address Relocation::pd_call_destination(address orig_addr) {
 70   intptr_t adj = 0;
 71   address inst_loc = addr();
 72 
 73   if (orig_addr != NULL) {
 74     // We just moved this call instruction from orig_addr to addr().
 75     // This means its target will appear to have grown by addr() - orig_addr.
 76     adj = -(inst_loc - orig_addr);
 77   }
 78   if (NativeFarCall::is_far_call_at(inst_loc)) {
 79     NativeFarCall* call = nativeFarCall_at(inst_loc);
 80     return call-&gt;destination() + (intptr_t)(call-&gt;is_pcrelative() ? adj : 0);
 81   } else if (NativeJump::is_jump_at(inst_loc)) {
</pre>
</td>
</tr>
</table>
<center><a href="ppc.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/cpu/sparc/interp_masm_sparc.cpp b/src/hotspot/cpu/sparc/interp_masm_sparc.cpp
--- a/src/hotspot/cpu/sparc/interp_masm_sparc.cpp
+++ b/src/hotspot/cpu/sparc/interp_masm_sparc.cpp
@@ -27,11 +27,11 @@
 #include "interp_masm_sparc.hpp"
 #include "interpreter/interpreter.hpp"
 #include "interpreter/interpreterRuntime.hpp"
 #include "logging/log.hpp"
 #include "oops/arrayOop.hpp"
-#include "oops/markOop.hpp"
+#include "oops/markWord.hpp"
 #include "oops/methodData.hpp"
 #include "oops/method.hpp"
 #include "oops/methodCounters.hpp"
 #include "prims/jvmtiExport.hpp"
 #include "prims/jvmtiThreadState.hpp"
@@ -40,10 +40,11 @@
 #include "runtime/frame.inline.hpp"
 #include "runtime/safepointMechanism.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/thread.inline.hpp"
 #include "utilities/align.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 // Implementation of InterpreterMacroAssembler
 
 // This file specializes the assember with interpreter-specific macros
 
@@ -89,11 +90,10 @@
 // Dispatch code executed in the epilog of a bytecode which does not do it's
 // own dispatch. The dispatch address in IdispatchAddress is used for the
 // dispatch.
 void InterpreterMacroAssembler::dispatch_epilog(TosState state, int bcp_incr) {
   assert_not_delayed();
-  verify_FPU(1, state);
   interp_verify_oop(Otos_i, state, __FILE__, __LINE__);
   jmp( IdispatchAddress, 0 );
   if (bcp_incr != 0)  delayed()->inc(Lbcp, bcp_incr);
   else                delayed()->nop();
 }
@@ -262,11 +262,10 @@
 
 // common code to dispatch and dispatch_only
 // dispatch value in Lbyte_code and increment Lbcp
 
 void InterpreterMacroAssembler::dispatch_Lbyte_code(TosState state, address* table, int bcp_incr, bool verify, bool generate_poll) {
-  verify_FPU(1, state);
   // %%%%% maybe implement +VerifyActivationFrameSize here
   //verify_thread(); //too slow; we will just verify on method entry & exit
   if (verify) interp_verify_oop(Otos_i, state, __FILE__, __LINE__);
   // dispatch table to use
   AddressLiteral tbl(table);
@@ -1198,45 +1197,45 @@
 
     Label slow_case;
 
     assert_different_registers(lock_reg, obj_reg, mark_reg, temp_reg);
 
-    // load markOop from object into mark_reg
+    // load markWord from object into mark_reg
     ld_ptr(mark_addr, mark_reg);
 
     if (UseBiasedLocking) {
       biased_locking_enter(obj_reg, mark_reg, temp_reg, done, &slow_case);
     }
 
     // get the address of basicLock on stack that will be stored in the object
     // we need a temporary register here as we do not want to clobber lock_reg
     // (cas clobbers the destination register)
     mov(lock_reg, temp_reg);
-    // set mark reg to be (markOop of object | UNLOCK_VALUE)
-    or3(mark_reg, markOopDesc::unlocked_value, mark_reg);
+    // set mark reg to be (markWord of object | UNLOCK_VALUE)
+    or3(mark_reg, markWord::unlocked_value, mark_reg);
     // initialize the box  (Must happen before we update the object mark!)
     st_ptr(mark_reg, lock_addr, BasicLock::displaced_header_offset_in_bytes());
-    // compare and exchange object_addr, markOop | 1, stack address of basicLock
+    // compare and exchange object_addr, markWord | 1, stack address of basicLock
     assert(mark_addr.disp() == 0, "cas must take a zero displacement");
     cas_ptr(mark_addr.base(), mark_reg, temp_reg);
 
     // if the compare and exchange succeeded we are done (we saw an unlocked object)
     cmp_and_brx_short(mark_reg, temp_reg, Assembler::equal, Assembler::pt, done);
 
     // We did not see an unlocked object so try the fast recursive case
 
-    // Check if owner is self by comparing the value in the markOop of object
+    // Check if owner is self by comparing the value in the markWord of object
     // with the stack pointer
     sub(temp_reg, SP, temp_reg);
     sub(temp_reg, STACK_BIAS, temp_reg);
     assert(os::vm_page_size() > 0xfff, "page size too small - change the constant");
 
     // Composite "andcc" test:
     // (a) %sp -vs- markword proximity check, and,
     // (b) verify mark word LSBs == 0 (Stack-locked).
     //
-    // FFFFF003/FFFFFFFFFFFF003 is (markOopDesc::lock_mask_in_place | -os::vm_page_size())
+    // FFFFF003/FFFFFFFFFFFF003 is (markWord::lock_mask_in_place | -os::vm_page_size())
     // Note that the page size used for %sp proximity testing is arbitrary and is
     // unrelated to the actual MMU page size.  We use a 'logical' page size of
     // 4096 bytes.   F..FFF003 is designed to fit conveniently in the SIMM13 immediate
     // field of the andcc instruction.
     andcc (temp_reg, 0xFFFFF003, G0) ;
@@ -2543,15 +2542,10 @@
   verify_oop(reg);
   bind(skip);
 }
 
 
-void InterpreterMacroAssembler::verify_FPU(int stack_depth, TosState state) {
-  if (state == ftos || state == dtos) MacroAssembler::verify_FPU(stack_depth);
-}
-
-
 // Jump if ((*counter_addr += increment) & mask) satisfies the condition.
 void InterpreterMacroAssembler::increment_mask_and_jump(Address counter_addr,
                                                         int increment, Address mask_addr,
                                                         Register scratch1, Register scratch2,
                                                         Condition cond, Label *where) {

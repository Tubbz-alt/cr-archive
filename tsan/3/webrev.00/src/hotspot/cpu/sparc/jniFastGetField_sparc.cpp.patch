diff a/src/hotspot/cpu/sparc/jniFastGetField_sparc.cpp b/src/hotspot/cpu/sparc/jniFastGetField_sparc.cpp
--- a/src/hotspot/cpu/sparc/jniFastGetField_sparc.cpp
+++ b/src/hotspot/cpu/sparc/jniFastGetField_sparc.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2004, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -68,10 +68,19 @@
   Address cnt_addr(O3, cnt_addrlit.low10());
   __ ld (cnt_addr, G4);
   __ andcc (G4, 1, G0);
   __ br (Assembler::notZero, false, Assembler::pn, label1);
   __ delayed()->srl (O2, 2, O4);
+
+  if (JvmtiExport::can_post_field_access()) {
+    // Check to see if a field access watch has been set before we
+    // take the fast path.
+    AddressLiteral get_field_access_count_addr(JvmtiExport::get_field_access_count_addr());
+    __ load_contents(get_field_access_count_addr, O5);
+    __ cmp_and_br_short(O5, 0, Assembler::notEqual, Assembler::pn, label1);
+  }
+
   __ mov(O1, O5);
 
   // Both O5 and G3 are clobbered by try_resolve_jobject_in_native.
   BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();
   bs->try_resolve_jobject_in_native(masm, /* jni_env */ O0, /* obj */ O5, /* tmp */ G3, label1);
@@ -151,10 +160,19 @@
   Address cnt_addr(G3, cnt_addrlit.low10());
   __ ld (cnt_addr, G4);
   __ andcc (G4, 1, G0);
   __ br (Assembler::notZero, false, Assembler::pn, label1);
   __ delayed()->srl (O2, 2, O4);
+
+  if (JvmtiExport::can_post_field_access()) {
+    // Check to see if a field access watch has been set before we
+    // take the fast path.
+    AddressLiteral get_field_access_count_addr(JvmtiExport::get_field_access_count_addr());
+    __ load_contents(get_field_access_count_addr, O5);
+    __ cmp_and_br_short(O5, 0, Assembler::notEqual, Assembler::pn, label1);
+  }
+
   __ mov(O1, O5);
 
   // Both O5 and G1 are clobbered by try_resolve_jobject_in_native.
   BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();
   bs->try_resolve_jobject_in_native(masm, /* jni_env */ O0, /* obj */ O5, /* tmp */ G1, label1);
@@ -209,10 +227,19 @@
   Address cnt_addr(O3, cnt_addrlit.low10());
   __ ld (cnt_addr, G4);
   __ andcc (G4, 1, G0);
   __ br (Assembler::notZero, false, Assembler::pn, label1);
   __ delayed()->srl (O2, 2, O4);
+
+  if (JvmtiExport::can_post_field_access()) {
+    // Check to see if a field access watch has been set before we
+    // take the fast path.
+    AddressLiteral get_field_access_count_addr(JvmtiExport::get_field_access_count_addr());
+    __ load_contents(get_field_access_count_addr, O5);
+    __ cmp_and_br_short(O5, 0, Assembler::notEqual, Assembler::pn, label1);
+  }
+
   __ mov(O1, O5);
 
   // Both O5 and G3 are clobbered by try_resolve_jobject_in_native.
   BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();
   bs->try_resolve_jobject_in_native(masm, /* jni_env */ O0, /* obj */ O5, /* tmp */ G3, label1);

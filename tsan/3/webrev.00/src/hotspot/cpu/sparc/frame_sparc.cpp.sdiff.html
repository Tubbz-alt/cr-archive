<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/frame_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="disassembler_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/g1/g1BarrierSetAssembler_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/frame_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified"> 29 #include &quot;oops/markOop.hpp&quot;</span>

 30 #include &quot;oops/method.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;prims/methodHandles.hpp&quot;
 33 #include &quot;runtime/frame.inline.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/javaCalls.hpp&quot;
 36 #include &quot;runtime/monitorChunk.hpp&quot;
 37 #include &quot;runtime/signature.hpp&quot;
 38 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 39 #include &quot;runtime/stubRoutines.hpp&quot;
 40 #include &quot;vmreg_sparc.inline.hpp&quot;
 41 #ifdef COMPILER1
 42 #include &quot;c1/c1_Runtime1.hpp&quot;
 43 #include &quot;runtime/vframeArray.hpp&quot;
 44 #endif
 45 
 46 void RegisterMap::pd_clear() {
 47   if (_thread-&gt;has_last_Java_frame()) {
 48     frame fr = _thread-&gt;last_frame();
 49     _window = fr.sp();
</pre>
<hr />
<pre>
159     // copy %i0-%i5 to %o0-%o5, if they have special locations
160     // This can happen in within stubs which spill argument registers
161     // around a dynamic link operation, such as resolve_opt_virtual_call.
162     for (int i = 0; i &lt; 8; i++) {
163       if (lv0 &amp; (1LL &lt;&lt; R_I_nums[i])) {
164         _location[R_O_nums[i]] = _location[R_I_nums[i]];
165         lv |=  (1LL &lt;&lt; R_O_nums[i]);
166       }
167     }
168   }
169 
170   _location_valid[0] = lv;
171   check_location_valid();
172 }
173 
174 bool frame::safe_for_sender(JavaThread *thread) {
175 
176   address _SP = (address) sp();
177   address _FP = (address) fp();
178   address _UNEXTENDED_SP = (address) unextended_sp();
<span class="line-removed">179   // sp must be within the stack</span>
<span class="line-removed">180   bool sp_safe = (_SP &lt;= thread-&gt;stack_base()) &amp;&amp;</span>
<span class="line-removed">181                  (_SP &gt;= thread-&gt;stack_base() - thread-&gt;stack_size());</span>
182 
<span class="line-modified">183   if (!sp_safe) {</span>


184     return false;
185   }
186 
187   // unextended sp must be within the stack and above or equal sp
<span class="line-modified">188   bool unextended_sp_safe = (_UNEXTENDED_SP &lt;= thread-&gt;stack_base()) &amp;&amp;</span>
189                             (_UNEXTENDED_SP &gt;= _SP);
190 
191   if (!unextended_sp_safe) return false;
192 
193   // an fp must be within the stack and above (but not equal) sp
<span class="line-modified">194   bool fp_safe = (_FP &lt;= thread-&gt;stack_base()) &amp;&amp;</span>
195                  (_FP &gt; _SP);
196 
197   // We know sp/unextended_sp are safe only fp is questionable here
198 
199   // If the current frame is known to the code cache then we can attempt to
200   // to construct the sender and do some validation of it. This goes a long way
201   // toward eliminating issues when we get in frame construction code
202 
203   if (_cb != NULL ) {
204 
205     // First check if frame is complete and tester is reliable
206     // Unfortunately we can only check frame complete for runtime stubs and nmethod
207     // other generic buffer blobs are more problematic so we just assume they are
208     // ok. adapter blobs never have a frame complete and are never ok.
209 
210     if (!_cb-&gt;is_frame_complete_at(_pc)) {
211       if (_cb-&gt;is_compiled() || _cb-&gt;is_adapter_blob() || _cb-&gt;is_runtime_stub()) {
212         return false;
213       }
214     }
</pre>
<hr />
<pre>
234     // We must always be able to find a recognizable pc
235     CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);
236     if (sender_pc == NULL ||  sender_blob == NULL) {
237       return false;
238     }
239 
240     // Could be a zombie method
241     if (sender_blob-&gt;is_zombie() || sender_blob-&gt;is_unloaded()) {
242       return false;
243     }
244 
245     // It should be safe to construct the sender though it might not be valid
246 
247     frame sender(_SENDER_SP, younger_sp, adjusted_stack);
248 
249     // Do we have a valid fp?
250     address sender_fp = (address) sender.fp();
251 
252     // an fp must be within the stack and above (but not equal) current frame&#39;s _FP
253 
<span class="line-modified">254     bool sender_fp_safe = (sender_fp &lt;= thread-&gt;stack_base()) &amp;&amp;</span>
255                    (sender_fp &gt; _FP);
256 
257     if (!sender_fp_safe) {
258       return false;
259     }
260 
261 
262     // If the potential sender is the interpreter then we can do some more checking
263     if (Interpreter::contains(sender_pc)) {
264       return sender.is_interpreted_frame_valid(thread);
265     }
266 
267     // Could just be some random pointer within the codeBlob
268     if (!sender.cb()-&gt;code_contains(sender_pc)) {
269       return false;
270     }
271 
272     // We should never be able to see an adapter if the current frame is something from code cache
273     if (sender_blob-&gt;is_adapter_blob()) {
274       return false;
275     }
276 
277     if (sender.is_entry_frame()) {
278       // Validate the JavaCallWrapper an entry frame must have
279 
280       address jcw = (address)sender.entry_frame_call_wrapper();
281 
<span class="line-modified">282       bool jcw_safe = (jcw &lt;= thread-&gt;stack_base()) &amp;&amp; (jcw &gt; sender_fp);</span>
283 
284       return jcw_safe;
285     }
286 
287     // If the frame size is 0 something (or less) is bad because every nmethod has a non-zero frame size
288     // because you must allocate window space
289 
290     if (sender_blob-&gt;frame_size() &lt;= 0) {
291       assert(!sender_blob-&gt;is_compiled(), &quot;should count return address at least&quot;);
292       return false;
293     }
294 
295     // The sender should positively be an nmethod or call_stub. On sparc we might in fact see something else.
296     // The cause of this is because at a save instruction the O7 we get is a leftover from an earlier
297     // window use. So if a runtime stub creates two frames (common in fastdebug/debug) then we see the
298     // stale pc. So if the sender blob is not something we&#39;d expect we have little choice but to declare
299     // the stack unwalkable. pd_get_top_frame_for_signal_handler tries to recover from this by unwinding
300     // that initial frame and retrying.
301 
302     if (!sender_blob-&gt;is_compiled()) {
</pre>
<hr />
<pre>
648   Method* m = *interpreter_frame_method_addr();
649 
650   // validate the method we&#39;d find in this potential sender
651   if (!Method::is_valid_method(m)) return false;
652 
653   // stack frames shouldn&#39;t be much larger than max_stack elements
654 
655   if (fp() - unextended_sp() &gt; 1024 + m-&gt;max_stack()*Interpreter::stackElementSize) {
656     return false;
657   }
658 
659   // validate bci/bcp
660 
661   address bcp = interpreter_frame_bcp();
662   if (m-&gt;validate_bci_from_bcp(bcp) &lt; 0) {
663     return false;
664   }
665 
666   // validate ConstantPoolCache*
667   ConstantPoolCache* cp = *interpreter_frame_cache_addr();
<span class="line-modified">668   if (cp == NULL || !cp-&gt;is_metaspace_object()) return false;</span>
669 
670   // validate locals
671 
672   address locals =  (address) *interpreter_frame_locals_addr();
673 
<span class="line-modified">674   if (locals &gt; thread-&gt;stack_base() || locals &lt; (address) fp()) return false;</span>
675 
676   // We&#39;d have to be pretty unlucky to be mislead at this point
677   return true;
678 }
679 
680 
681 // Windows have been flushed on entry (but not marked). Capture the pc that
682 // is the return address to the frame that contains &quot;sp&quot; as its stack pointer.
683 // This pc resides in the called of the frame corresponding to &quot;sp&quot;.
684 // As a side effect we mark this JavaFrameAnchor as having flushed the windows.
685 // This side effect lets us mark stacked JavaFrameAnchors (stacked in the
686 // call_helper) as flushed when we have flushed the windows for the most
687 // recent (i.e. current) JavaFrameAnchor. This saves useless flushing calls
688 // and lets us find the pc just once rather than multiple times as it did
689 // in the bad old _post_Java_state days.
690 //
691 void JavaFrameAnchor::capture_last_Java_pc(intptr_t* sp) {
692   if (last_Java_sp() != NULL &amp;&amp; last_Java_pc() == NULL) {
693     // try and find the sp just younger than _last_Java_sp
694     intptr_t* _post_Java_sp = frame::next_younger_sp_or_null(last_Java_sp(), sp);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified"> 29 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added"> 30 #include &quot;oops/markWord.hpp&quot;</span>
 31 #include &quot;oops/method.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;prims/methodHandles.hpp&quot;
 34 #include &quot;runtime/frame.inline.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 #include &quot;runtime/javaCalls.hpp&quot;
 37 #include &quot;runtime/monitorChunk.hpp&quot;
 38 #include &quot;runtime/signature.hpp&quot;
 39 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 40 #include &quot;runtime/stubRoutines.hpp&quot;
 41 #include &quot;vmreg_sparc.inline.hpp&quot;
 42 #ifdef COMPILER1
 43 #include &quot;c1/c1_Runtime1.hpp&quot;
 44 #include &quot;runtime/vframeArray.hpp&quot;
 45 #endif
 46 
 47 void RegisterMap::pd_clear() {
 48   if (_thread-&gt;has_last_Java_frame()) {
 49     frame fr = _thread-&gt;last_frame();
 50     _window = fr.sp();
</pre>
<hr />
<pre>
160     // copy %i0-%i5 to %o0-%o5, if they have special locations
161     // This can happen in within stubs which spill argument registers
162     // around a dynamic link operation, such as resolve_opt_virtual_call.
163     for (int i = 0; i &lt; 8; i++) {
164       if (lv0 &amp; (1LL &lt;&lt; R_I_nums[i])) {
165         _location[R_O_nums[i]] = _location[R_I_nums[i]];
166         lv |=  (1LL &lt;&lt; R_O_nums[i]);
167       }
168     }
169   }
170 
171   _location_valid[0] = lv;
172   check_location_valid();
173 }
174 
175 bool frame::safe_for_sender(JavaThread *thread) {
176 
177   address _SP = (address) sp();
178   address _FP = (address) fp();
179   address _UNEXTENDED_SP = (address) unextended_sp();



180 
<span class="line-modified">181   // consider stack guards when trying to determine &quot;safe&quot; stack pointers</span>
<span class="line-added">182   // sp must be within the usable part of the stack (not in guards)</span>
<span class="line-added">183   if (!thread-&gt;is_in_usable_stack(_SP)) {</span>
184     return false;
185   }
186 
187   // unextended sp must be within the stack and above or equal sp
<span class="line-modified">188   bool unextended_sp_safe = (_UNEXTENDED_SP &lt; thread-&gt;stack_base()) &amp;&amp;</span>
189                             (_UNEXTENDED_SP &gt;= _SP);
190 
191   if (!unextended_sp_safe) return false;
192 
193   // an fp must be within the stack and above (but not equal) sp
<span class="line-modified">194   bool fp_safe = (_FP &lt; thread-&gt;stack_base()) &amp;&amp;</span>
195                  (_FP &gt; _SP);
196 
197   // We know sp/unextended_sp are safe only fp is questionable here
198 
199   // If the current frame is known to the code cache then we can attempt to
200   // to construct the sender and do some validation of it. This goes a long way
201   // toward eliminating issues when we get in frame construction code
202 
203   if (_cb != NULL ) {
204 
205     // First check if frame is complete and tester is reliable
206     // Unfortunately we can only check frame complete for runtime stubs and nmethod
207     // other generic buffer blobs are more problematic so we just assume they are
208     // ok. adapter blobs never have a frame complete and are never ok.
209 
210     if (!_cb-&gt;is_frame_complete_at(_pc)) {
211       if (_cb-&gt;is_compiled() || _cb-&gt;is_adapter_blob() || _cb-&gt;is_runtime_stub()) {
212         return false;
213       }
214     }
</pre>
<hr />
<pre>
234     // We must always be able to find a recognizable pc
235     CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);
236     if (sender_pc == NULL ||  sender_blob == NULL) {
237       return false;
238     }
239 
240     // Could be a zombie method
241     if (sender_blob-&gt;is_zombie() || sender_blob-&gt;is_unloaded()) {
242       return false;
243     }
244 
245     // It should be safe to construct the sender though it might not be valid
246 
247     frame sender(_SENDER_SP, younger_sp, adjusted_stack);
248 
249     // Do we have a valid fp?
250     address sender_fp = (address) sender.fp();
251 
252     // an fp must be within the stack and above (but not equal) current frame&#39;s _FP
253 
<span class="line-modified">254     bool sender_fp_safe = (sender_fp &lt; thread-&gt;stack_base()) &amp;&amp;</span>
255                    (sender_fp &gt; _FP);
256 
257     if (!sender_fp_safe) {
258       return false;
259     }
260 
261 
262     // If the potential sender is the interpreter then we can do some more checking
263     if (Interpreter::contains(sender_pc)) {
264       return sender.is_interpreted_frame_valid(thread);
265     }
266 
267     // Could just be some random pointer within the codeBlob
268     if (!sender.cb()-&gt;code_contains(sender_pc)) {
269       return false;
270     }
271 
272     // We should never be able to see an adapter if the current frame is something from code cache
273     if (sender_blob-&gt;is_adapter_blob()) {
274       return false;
275     }
276 
277     if (sender.is_entry_frame()) {
278       // Validate the JavaCallWrapper an entry frame must have
279 
280       address jcw = (address)sender.entry_frame_call_wrapper();
281 
<span class="line-modified">282       bool jcw_safe = (jcw &lt; thread-&gt;stack_base()) &amp;&amp; (jcw &gt; sender_fp);</span>
283 
284       return jcw_safe;
285     }
286 
287     // If the frame size is 0 something (or less) is bad because every nmethod has a non-zero frame size
288     // because you must allocate window space
289 
290     if (sender_blob-&gt;frame_size() &lt;= 0) {
291       assert(!sender_blob-&gt;is_compiled(), &quot;should count return address at least&quot;);
292       return false;
293     }
294 
295     // The sender should positively be an nmethod or call_stub. On sparc we might in fact see something else.
296     // The cause of this is because at a save instruction the O7 we get is a leftover from an earlier
297     // window use. So if a runtime stub creates two frames (common in fastdebug/debug) then we see the
298     // stale pc. So if the sender blob is not something we&#39;d expect we have little choice but to declare
299     // the stack unwalkable. pd_get_top_frame_for_signal_handler tries to recover from this by unwinding
300     // that initial frame and retrying.
301 
302     if (!sender_blob-&gt;is_compiled()) {
</pre>
<hr />
<pre>
648   Method* m = *interpreter_frame_method_addr();
649 
650   // validate the method we&#39;d find in this potential sender
651   if (!Method::is_valid_method(m)) return false;
652 
653   // stack frames shouldn&#39;t be much larger than max_stack elements
654 
655   if (fp() - unextended_sp() &gt; 1024 + m-&gt;max_stack()*Interpreter::stackElementSize) {
656     return false;
657   }
658 
659   // validate bci/bcp
660 
661   address bcp = interpreter_frame_bcp();
662   if (m-&gt;validate_bci_from_bcp(bcp) &lt; 0) {
663     return false;
664   }
665 
666   // validate ConstantPoolCache*
667   ConstantPoolCache* cp = *interpreter_frame_cache_addr();
<span class="line-modified">668   if (MetaspaceObj::is_valid(cp) == false) return false;</span>
669 
670   // validate locals
671 
672   address locals =  (address) *interpreter_frame_locals_addr();
673 
<span class="line-modified">674   if (locals &gt;= thread-&gt;stack_base() || locals &lt; (address) fp()) return false;</span>
675 
676   // We&#39;d have to be pretty unlucky to be mislead at this point
677   return true;
678 }
679 
680 
681 // Windows have been flushed on entry (but not marked). Capture the pc that
682 // is the return address to the frame that contains &quot;sp&quot; as its stack pointer.
683 // This pc resides in the called of the frame corresponding to &quot;sp&quot;.
684 // As a side effect we mark this JavaFrameAnchor as having flushed the windows.
685 // This side effect lets us mark stacked JavaFrameAnchors (stacked in the
686 // call_helper) as flushed when we have flushed the windows for the most
687 // recent (i.e. current) JavaFrameAnchor. This saves useless flushing calls
688 // and lets us find the pc just once rather than multiple times as it did
689 // in the bad old _post_Java_state days.
690 //
691 void JavaFrameAnchor::capture_last_Java_pc(intptr_t* sp) {
692   if (last_Java_sp() != NULL &amp;&amp; last_Java_pc() == NULL) {
693     // try and find the sp just younger than _last_Java_sp
694     intptr_t* _post_Java_sp = frame::next_younger_sp_or_null(last_Java_sp(), sp);
</pre>
</td>
</tr>
</table>
<center><a href="disassembler_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/g1/g1BarrierSetAssembler_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
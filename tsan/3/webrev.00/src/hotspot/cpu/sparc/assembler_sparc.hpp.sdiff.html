<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/assembler_sparc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="abstractInterpreter_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_FrameMap_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/assembler_sparc.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 318   enum PrefetchFcn {
 319     severalReads = 0, oneRead = 1, severalWritesAndPossiblyReads = 2, oneWrite = 3, page = 4
 320   };
 321 
 322  public:
 323   // Helper functions for groups of instructions
 324 
 325   enum Predict { pt = 1, pn = 0 }; // pt = predict taken
 326 
 327   enum Membar_mask_bits { // page 184, v9
 328     StoreStore = 1 &lt;&lt; 3,
 329     LoadStore  = 1 &lt;&lt; 2,
 330     StoreLoad  = 1 &lt;&lt; 1,
 331     LoadLoad   = 1 &lt;&lt; 0,
 332 
 333     Sync       = 1 &lt;&lt; 6,
 334     MemIssue   = 1 &lt;&lt; 5,
 335     Lookaside  = 1 &lt;&lt; 4
 336   };
 337 








 338   static bool is_in_wdisp_range(address a, address b, int nbits) {
 339     intptr_t d = intptr_t(b) - intptr_t(a);
 340     return is_simm(d, nbits + 2);
 341   }
 342 
 343   address target_distance(Label &amp;L) {
 344     // Assembler::target(L) should be called only when
 345     // a branch instruction is emitted since non-bound
 346     // labels record current pc() as a branch address.
 347     if (L.is_bound()) return target(L);
 348     // Return current address for non-bound labels.
 349     return pc();
 350   }
 351 
 352   // test if label is in simm16 range in words (wdisp16).
 353   bool is_in_wdisp16_range(Label &amp;L) {
 354     return is_in_wdisp_range(target_distance(L), pc(), 16);
 355   }
 356   // test if the distance between two addresses fits in simm30 range in words
 357   static bool is_in_wdisp30_range(address a, address b) {
</pre>
</td>
<td>
<hr />
<pre>
 318   enum PrefetchFcn {
 319     severalReads = 0, oneRead = 1, severalWritesAndPossiblyReads = 2, oneWrite = 3, page = 4
 320   };
 321 
 322  public:
 323   // Helper functions for groups of instructions
 324 
 325   enum Predict { pt = 1, pn = 0 }; // pt = predict taken
 326 
 327   enum Membar_mask_bits { // page 184, v9
 328     StoreStore = 1 &lt;&lt; 3,
 329     LoadStore  = 1 &lt;&lt; 2,
 330     StoreLoad  = 1 &lt;&lt; 1,
 331     LoadLoad   = 1 &lt;&lt; 0,
 332 
 333     Sync       = 1 &lt;&lt; 6,
 334     MemIssue   = 1 &lt;&lt; 5,
 335     Lookaside  = 1 &lt;&lt; 4
 336   };
 337 
<span class="line-added"> 338   //---&lt;  calculate length of instruction  &gt;---</span>
<span class="line-added"> 339   // With SPARC being a RISC architecture, this always is BytesPerInstWord</span>
<span class="line-added"> 340   // instruction must start at passed address</span>
<span class="line-added"> 341   static unsigned int instr_len(unsigned char *instr) { return BytesPerInstWord; }</span>
<span class="line-added"> 342 </span>
<span class="line-added"> 343   //---&lt;  longest instructions  &gt;---</span>
<span class="line-added"> 344   static unsigned int instr_maxlen() { return BytesPerInstWord; }</span>
<span class="line-added"> 345 </span>
 346   static bool is_in_wdisp_range(address a, address b, int nbits) {
 347     intptr_t d = intptr_t(b) - intptr_t(a);
 348     return is_simm(d, nbits + 2);
 349   }
 350 
 351   address target_distance(Label &amp;L) {
 352     // Assembler::target(L) should be called only when
 353     // a branch instruction is emitted since non-bound
 354     // labels record current pc() as a branch address.
 355     if (L.is_bound()) return target(L);
 356     // Return current address for non-bound labels.
 357     return pc();
 358   }
 359 
 360   // test if label is in simm16 range in words (wdisp16).
 361   bool is_in_wdisp16_range(Label &amp;L) {
 362     return is_in_wdisp_range(target_distance(L), pc(), 16);
 363   }
 364   // test if the distance between two addresses fits in simm30 range in words
 365   static bool is_in_wdisp30_range(address a, address b) {
</pre>
</td>
</tr>
</table>
<center><a href="abstractInterpreter_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_FrameMap_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
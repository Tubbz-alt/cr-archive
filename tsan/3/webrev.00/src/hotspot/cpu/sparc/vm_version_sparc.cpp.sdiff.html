<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/vm_version_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vm_version_ext_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_sparc.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/vm_version_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;logging/logStream.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;

 31 #include &quot;runtime/java.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;runtime/stubCodeGenerator.hpp&quot;
<span class="line-modified"> 34 #include &quot;vm_version_sparc.hpp&quot;</span>
 35 
 36 #include &lt;sys/mman.h&gt;
 37 
 38 uint VM_Version::_L2_data_cache_line_size = 0;
 39 
 40 void VM_Version::initialize() {
 41   assert(_features != 0, &quot;System pre-initialization is not complete.&quot;);
 42   guarantee(VM_Version::has_v9(), &quot;only SPARC v9 is supported&quot;);
 43 
 44   PrefetchCopyIntervalInBytes = prefetch_copy_interval_in_bytes();
 45   PrefetchScanIntervalInBytes = prefetch_scan_interval_in_bytes();
 46   PrefetchFieldsAhead         = prefetch_fields_ahead();
 47 
 48   // Allocation prefetch settings
 49 
 50   AllocatePrefetchDistance = allocate_prefetch_distance();
 51   AllocatePrefetchStyle    = allocate_prefetch_style();
 52 
 53   intx cache_line_size = prefetch_data_size();
 54 
</pre>
<hr />
<pre>
 67     }
 68   }
 69 
 70   UseSSE = false;                   // Only used on x86 and x64.
 71 
 72   _supports_cx8 = true;             // All SPARC V9 implementations.
 73   _supports_atomic_getset4 = true;  // Using the &#39;swap&#39; instruction.
 74 
 75   if (has_fast_ind_br() &amp;&amp; FLAG_IS_DEFAULT(UseInlineCaches)) {
 76     // Indirect and direct branches are cost equivalent.
 77     FLAG_SET_DEFAULT(UseInlineCaches, false);
 78   }
 79   // Align loops on the proper instruction boundary to fill the instruction
 80   // fetch buffer.
 81   if (FLAG_IS_DEFAULT(OptoLoopAlignment)) {
 82     FLAG_SET_DEFAULT(OptoLoopAlignment, VM_Version::insn_fetch_alignment);
 83   }
 84 
 85   // 32-bit oops don&#39;t make sense for the 64-bit VM on SPARC since the 32-bit
 86   // VM has the same registers and smaller objects.
<span class="line-modified"> 87   Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes);</span>
<span class="line-modified"> 88   Universe::set_narrow_klass_shift(LogKlassAlignmentInBytes);</span>
 89 
 90 #ifdef COMPILER2
 91   if (has_fast_ind_br() &amp;&amp; FLAG_IS_DEFAULT(UseJumpTables)) {
 92     // Indirect and direct branches are cost equivalent.
 93     FLAG_SET_DEFAULT(UseJumpTables, true);
 94   }
 95   // Entry and loop tops are aligned to fill the instruction fetch buffer.
 96   if (FLAG_IS_DEFAULT(InteriorEntryAlignment)) {
 97     FLAG_SET_DEFAULT(InteriorEntryAlignment, VM_Version::insn_fetch_alignment);
 98   }
 99   if (UseTLAB &amp;&amp; cache_line_size &gt; 0 &amp;&amp;
100       FLAG_IS_DEFAULT(AllocatePrefetchInstr)) {
101     if (has_fast_bis()) {
102       // Use BIS instruction for TLAB allocation prefetch.
103       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 1);
104     }
105     else if (has_sparc5()) {
106       // Use prefetch instruction to avoid partial RAW issue on Core C4 processors,
107       // also use prefetch style 3.
108       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 0);
</pre>
<hr />
<pre>
121       // Use different prefetch distance without BIS
122       FLAG_SET_DEFAULT(AllocatePrefetchDistance, 256);
123     } else {
124       // Use smaller prefetch distance with BIS
125       FLAG_SET_DEFAULT(AllocatePrefetchDistance, 64);
126     }
127   }
128 
129   // We increase the number of prefetched cache lines, to use just a bit more
130   // aggressive approach, when the L2-cache line size is small (32 bytes), or
131   // when running on newer processor implementations, such as the Core C4.
132   bool inc_prefetch = cache_line_size &gt; 0 &amp;&amp; (cache_line_size &lt; 64 || has_sparc5());
133 
134   if (inc_prefetch) {
135     // We use a factor two for small cache line sizes (as before) but a slightly
136     // more conservative increase when running on more recent hardware that will
137     // benefit from just a bit more aggressive prefetching.
138     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) {
139       const int ap_lns = AllocatePrefetchLines;
140       const int ap_inc = cache_line_size &lt; 64 ? ap_lns : (ap_lns + 1) / 2;
<span class="line-modified">141       FLAG_SET_ERGO(intx, AllocatePrefetchLines, ap_lns + ap_inc);</span>
142     }
143     if (FLAG_IS_DEFAULT(AllocateInstancePrefetchLines)) {
144       const int ip_lns = AllocateInstancePrefetchLines;
145       const int ip_inc = cache_line_size &lt; 64 ? ip_lns : (ip_lns + 1) / 2;
<span class="line-modified">146       FLAG_SET_ERGO(intx, AllocateInstancePrefetchLines, ip_lns + ip_inc);</span>
147     }
148   }
149 #endif /* COMPILER2 */
150 
151   // Use hardware population count instruction if available.
152   if (has_popc()) {
153     if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
154       FLAG_SET_DEFAULT(UsePopCountInstruction, true);
155     }
156   } else if (UsePopCountInstruction) {
157     warning(&quot;POPC instruction is not available on this CPU&quot;);
158     FLAG_SET_DEFAULT(UsePopCountInstruction, false);
159   }
160 
161   // Use compare and branch instructions if available.
162   if (has_cbcond()) {
163     if (FLAG_IS_DEFAULT(UseCBCond)) {
164       FLAG_SET_DEFAULT(UseCBCond, true);
165     }
166   } else if (UseCBCond) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;logging/logStream.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 31 #include &quot;oops/compressedOops.hpp&quot;</span>
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;runtime/os.hpp&quot;
 34 #include &quot;runtime/stubCodeGenerator.hpp&quot;
<span class="line-modified"> 35 #include &quot;runtime/vm_version.hpp&quot;</span>
 36 
 37 #include &lt;sys/mman.h&gt;
 38 
 39 uint VM_Version::_L2_data_cache_line_size = 0;
 40 
 41 void VM_Version::initialize() {
 42   assert(_features != 0, &quot;System pre-initialization is not complete.&quot;);
 43   guarantee(VM_Version::has_v9(), &quot;only SPARC v9 is supported&quot;);
 44 
 45   PrefetchCopyIntervalInBytes = prefetch_copy_interval_in_bytes();
 46   PrefetchScanIntervalInBytes = prefetch_scan_interval_in_bytes();
 47   PrefetchFieldsAhead         = prefetch_fields_ahead();
 48 
 49   // Allocation prefetch settings
 50 
 51   AllocatePrefetchDistance = allocate_prefetch_distance();
 52   AllocatePrefetchStyle    = allocate_prefetch_style();
 53 
 54   intx cache_line_size = prefetch_data_size();
 55 
</pre>
<hr />
<pre>
 68     }
 69   }
 70 
 71   UseSSE = false;                   // Only used on x86 and x64.
 72 
 73   _supports_cx8 = true;             // All SPARC V9 implementations.
 74   _supports_atomic_getset4 = true;  // Using the &#39;swap&#39; instruction.
 75 
 76   if (has_fast_ind_br() &amp;&amp; FLAG_IS_DEFAULT(UseInlineCaches)) {
 77     // Indirect and direct branches are cost equivalent.
 78     FLAG_SET_DEFAULT(UseInlineCaches, false);
 79   }
 80   // Align loops on the proper instruction boundary to fill the instruction
 81   // fetch buffer.
 82   if (FLAG_IS_DEFAULT(OptoLoopAlignment)) {
 83     FLAG_SET_DEFAULT(OptoLoopAlignment, VM_Version::insn_fetch_alignment);
 84   }
 85 
 86   // 32-bit oops don&#39;t make sense for the 64-bit VM on SPARC since the 32-bit
 87   // VM has the same registers and smaller objects.
<span class="line-modified"> 88   CompressedOops::set_shift(LogMinObjAlignmentInBytes);</span>
<span class="line-modified"> 89   CompressedKlassPointers::set_shift(LogKlassAlignmentInBytes);</span>
 90 
 91 #ifdef COMPILER2
 92   if (has_fast_ind_br() &amp;&amp; FLAG_IS_DEFAULT(UseJumpTables)) {
 93     // Indirect and direct branches are cost equivalent.
 94     FLAG_SET_DEFAULT(UseJumpTables, true);
 95   }
 96   // Entry and loop tops are aligned to fill the instruction fetch buffer.
 97   if (FLAG_IS_DEFAULT(InteriorEntryAlignment)) {
 98     FLAG_SET_DEFAULT(InteriorEntryAlignment, VM_Version::insn_fetch_alignment);
 99   }
100   if (UseTLAB &amp;&amp; cache_line_size &gt; 0 &amp;&amp;
101       FLAG_IS_DEFAULT(AllocatePrefetchInstr)) {
102     if (has_fast_bis()) {
103       // Use BIS instruction for TLAB allocation prefetch.
104       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 1);
105     }
106     else if (has_sparc5()) {
107       // Use prefetch instruction to avoid partial RAW issue on Core C4 processors,
108       // also use prefetch style 3.
109       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 0);
</pre>
<hr />
<pre>
122       // Use different prefetch distance without BIS
123       FLAG_SET_DEFAULT(AllocatePrefetchDistance, 256);
124     } else {
125       // Use smaller prefetch distance with BIS
126       FLAG_SET_DEFAULT(AllocatePrefetchDistance, 64);
127     }
128   }
129 
130   // We increase the number of prefetched cache lines, to use just a bit more
131   // aggressive approach, when the L2-cache line size is small (32 bytes), or
132   // when running on newer processor implementations, such as the Core C4.
133   bool inc_prefetch = cache_line_size &gt; 0 &amp;&amp; (cache_line_size &lt; 64 || has_sparc5());
134 
135   if (inc_prefetch) {
136     // We use a factor two for small cache line sizes (as before) but a slightly
137     // more conservative increase when running on more recent hardware that will
138     // benefit from just a bit more aggressive prefetching.
139     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) {
140       const int ap_lns = AllocatePrefetchLines;
141       const int ap_inc = cache_line_size &lt; 64 ? ap_lns : (ap_lns + 1) / 2;
<span class="line-modified">142       FLAG_SET_ERGO(AllocatePrefetchLines, ap_lns + ap_inc);</span>
143     }
144     if (FLAG_IS_DEFAULT(AllocateInstancePrefetchLines)) {
145       const int ip_lns = AllocateInstancePrefetchLines;
146       const int ip_inc = cache_line_size &lt; 64 ? ip_lns : (ip_lns + 1) / 2;
<span class="line-modified">147       FLAG_SET_ERGO(AllocateInstancePrefetchLines, ip_lns + ip_inc);</span>
148     }
149   }
150 #endif /* COMPILER2 */
151 
152   // Use hardware population count instruction if available.
153   if (has_popc()) {
154     if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
155       FLAG_SET_DEFAULT(UsePopCountInstruction, true);
156     }
157   } else if (UsePopCountInstruction) {
158     warning(&quot;POPC instruction is not available on this CPU&quot;);
159     FLAG_SET_DEFAULT(UsePopCountInstruction, false);
160   }
161 
162   // Use compare and branch instructions if available.
163   if (has_cbcond()) {
164     if (FLAG_IS_DEFAULT(UseCBCond)) {
165       FLAG_SET_DEFAULT(UseCBCond, true);
166     }
167   } else if (UseCBCond) {
</pre>
</td>
</tr>
</table>
<center><a href="vm_version_ext_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_sparc.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
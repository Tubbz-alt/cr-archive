<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/abstractInterpreter_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/interpreter.hpp&quot;
 27 #include &quot;oops/constMethod.hpp&quot;
<a name="1" id="anc1"></a>
 28 #include &quot;oops/method.hpp&quot;
 29 #include &quot;runtime/arguments.hpp&quot;
 30 #include &quot;runtime/frame.inline.hpp&quot;
 31 #include &quot;runtime/synchronizer.hpp&quot;
 32 #include &quot;utilities/align.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 
 35 
 36 int AbstractInterpreter::BasicType_as_index(BasicType type) {
 37   int i = 0;
 38   switch (type) {
 39     case T_BOOLEAN: i = 0; break;
 40     case T_CHAR   : i = 1; break;
 41     case T_BYTE   : i = 2; break;
 42     case T_SHORT  : i = 3; break;
 43     case T_INT    : i = 4; break;
 44     case T_LONG   : i = 5; break;
 45     case T_VOID   : i = 6; break;
 46     case T_FLOAT  : i = 7; break;
 47     case T_DOUBLE : i = 8; break;
 48     case T_OBJECT : i = 9; break;
 49     case T_ARRAY  : i = 9; break;
 50     default       : ShouldNotReachHere();
 51   }
 52   assert(0 &lt;= i &amp;&amp; i &lt; AbstractInterpreter::number_of_result_handlers, &quot;index out of bounds&quot;);
 53   return i;
 54 }
 55 
 56 static int size_activation_helper(int callee_extra_locals, int max_stack, int monitor_size) {
 57 
 58   // Figure out the size of an interpreter frame (in words) given that we have a fully allocated
 59   // expression stack, the callee will have callee_extra_locals (so we can account for
 60   // frame extension) and monitor_size for monitors. Basically we need to calculate
 61   // this exactly like generate_fixed_frame/generate_compute_interpreter_state.
 62   //
 63   //
 64   // The big complicating thing here is that we must ensure that the stack stays properly
 65   // aligned. This would be even uglier if monitor size wasn&#39;t modulo what the stack
 66   // needs to be aligned for). We are given that the sp (fp) is already aligned by
 67   // the caller so we must ensure that it is properly aligned for our callee.
 68   //
 69   const int rounded_vm_local_words =
 70       align_up((int)frame::interpreter_frame_vm_local_words,WordsPerLong);
 71   // callee_locals and max_stack are counts, not the size in frame.
 72   const int locals_size =
 73       align_up(callee_extra_locals * Interpreter::stackElementWords, WordsPerLong);
 74   const int max_stack_words = max_stack * Interpreter::stackElementWords;
 75   return (align_up((max_stack_words
 76                    + rounded_vm_local_words
 77                    + frame::memory_parameter_word_sp_offset), WordsPerLong)
 78                    // already rounded
 79                    + locals_size + monitor_size);
 80 }
 81 
 82 // How much stack a method top interpreter activation needs in words.
 83 int AbstractInterpreter::size_top_interpreter_activation(Method* method) {
 84 
 85   // See call_stub code
 86   int call_stub_size  = align_up(7 + frame::memory_parameter_word_sp_offset,
 87                                  WordsPerLong);    // 7 + register save area
 88 
 89   // Save space for one monitor to get into the interpreted method in case
 90   // the method is synchronized
 91   int monitor_size    = method-&gt;is_synchronized() ?
 92                                 1*frame::interpreter_frame_monitor_size() : 0;
 93   return size_activation_helper(method-&gt;max_locals(), method-&gt;max_stack(),
 94                                 monitor_size) + call_stub_size;
 95 }
 96 
 97 int AbstractInterpreter::size_activation(int max_stack,
 98                                          int temps,
 99                                          int extra_args,
100                                          int monitors,
101                                          int callee_params,
102                                          int callee_locals,
103                                          bool is_top_frame) {
104   // Note: This calculation must exactly parallel the frame setup
105   // in TemplateInterpreterGenerator::generate_fixed_frame.
106 
107   int monitor_size           = monitors * frame::interpreter_frame_monitor_size();
108 
109   assert(is_aligned(monitor_size, WordsPerLong), &quot;must align&quot;);
110 
111   //
112   // Note: if you look closely this appears to be doing something much different
113   // than generate_fixed_frame. What is happening is this. On sparc we have to do
114   // this dance with interpreter_sp_adjustment because the window save area would
115   // appear just below the bottom (tos) of the caller&#39;s java expression stack. Because
116   // the interpreter want to have the locals completely contiguous generate_fixed_frame
117   // will adjust the caller&#39;s sp for the &quot;extra locals&quot; (max_locals - parameter_size).
118   // Now in generate_fixed_frame the extension of the caller&#39;s sp happens in the callee.
119   // In this code the opposite occurs the caller adjusts it&#39;s own stack base on the callee.
120   // This is mostly ok but it does cause a problem when we get to the initial frame (the oldest)
121   // because the oldest frame would have adjust its callers frame and yet that frame
122   // already exists and isn&#39;t part of this array of frames we are unpacking. So at first
123   // glance this would seem to mess up that frame. However Deoptimization::fetch_unroll_info_helper()
124   // will after it calculates all of the frame&#39;s on_stack_size()&#39;s will then figure out the
125   // amount to adjust the caller of the initial (oldest) frame and the calculation will all
126   // add up. It does seem like it simpler to account for the adjustment here (and remove the
127   // callee... parameters here). However this would mean that this routine would have to take
128   // the caller frame as input so we could adjust its sp (and set it&#39;s interpreter_sp_adjustment)
129   // and run the calling loop in the reverse order. This would also would appear to mean making
130   // this code aware of what the interactions are when that initial caller fram was an osr or
131   // other adapter frame. deoptimization is complicated enough and  hard enough to debug that
132   // there is no sense in messing working code.
133   //
134 
135   int rounded_cls = align_up((callee_locals - callee_params), WordsPerLong);
136   assert(is_aligned(rounded_cls, WordsPerLong), &quot;must align&quot;);
137 
138   int raw_frame_size = size_activation_helper(rounded_cls, max_stack, monitor_size);
139 
140   return raw_frame_size;
141 }
142 
143 void AbstractInterpreter::layout_activation(Method* method,
144                                             int tempcount,
145                                             int popframe_extra_args,
146                                             int moncount,
147                                             int caller_actual_parameters,
148                                             int callee_param_count,
149                                             int callee_local_count,
150                                             frame* caller,
151                                             frame* interpreter_frame,
152                                             bool is_top_frame,
153                                             bool is_bottom_frame) {
154   // Set up the following variables:
155   //   - Lmethod
156   //   - Llocals
157   //   - Lmonitors (to the indicated number of monitors)
158   //   - Lesp (to the indicated number of temps)
159   // The frame caller on entry is a description of the caller of the
160   // frame we are about to layout. We are guaranteed that we will be
161   // able to fill in a new interpreter frame as its callee (i.e. the
162   // stack space is allocated and the amount was determined by an
163   // earlier call to the size_activation() method).  On return caller
164   // while describe the interpreter frame we just layed out.
165 
166   // The skeleton frame must already look like an interpreter frame
167   // even if not fully filled out.
168   assert(interpreter_frame-&gt;is_interpreted_frame(), &quot;Must be interpreted frame&quot;);
169 
170   int rounded_vm_local_words = align_up((int)frame::interpreter_frame_vm_local_words,WordsPerLong);
171   int monitor_size           = moncount * frame::interpreter_frame_monitor_size();
172   assert(is_aligned(monitor_size, WordsPerLong), &quot;must align&quot;);
173 
174   intptr_t* fp = interpreter_frame-&gt;fp();
175 
176   JavaThread* thread = JavaThread::current();
177   RegisterMap map(thread, false);
178   // More verification that skeleton frame is properly walkable
179   assert(fp == caller-&gt;sp(), &quot;fp must match&quot;);
180 
181   intptr_t* montop     = fp - rounded_vm_local_words;
182 
183   // preallocate monitors (cf. __ add_monitor_to_stack)
184   intptr_t* monitors = montop - monitor_size;
185 
186   // preallocate stack space
187   intptr_t*  esp = monitors - 1 -
188     (tempcount * Interpreter::stackElementWords) -
189     popframe_extra_args;
190 
191   int local_words = method-&gt;max_locals() * Interpreter::stackElementWords;
192   NEEDS_CLEANUP;
193   intptr_t* locals;
194   if (caller-&gt;is_interpreted_frame()) {
195     // Can force the locals area to end up properly overlapping the top of the expression stack.
196     intptr_t* Lesp_ptr = caller-&gt;interpreter_frame_tos_address() - 1;
197     // Note that this computation means we replace size_of_parameters() values from the caller
198     // interpreter frame&#39;s expression stack with our argument locals
199     int parm_words  = caller_actual_parameters * Interpreter::stackElementWords;
200     locals = Lesp_ptr + parm_words;
201     int delta = local_words - parm_words;
202     int computed_sp_adjustment = (delta &gt; 0) ? align_up(delta, WordsPerLong) : 0;
203     *interpreter_frame-&gt;register_addr(I5_savedSP)    = (intptr_t) (fp + computed_sp_adjustment) - STACK_BIAS;
204     if (!is_bottom_frame) {
205       // Llast_SP is set below for the current frame to SP (with the
206       // extra space for the callee&#39;s locals). Here we adjust
207       // Llast_SP for the caller&#39;s frame, removing the extra space
208       // for the current method&#39;s locals.
209       *caller-&gt;register_addr(Llast_SP) = *interpreter_frame-&gt;register_addr(I5_savedSP);
210     } else {
211       assert(*caller-&gt;register_addr(Llast_SP) &gt;= *interpreter_frame-&gt;register_addr(I5_savedSP), &quot;strange Llast_SP&quot;);
212     }
213   } else {
214     assert(caller-&gt;is_compiled_frame() || caller-&gt;is_entry_frame(), &quot;only possible cases&quot;);
215     // Don&#39;t have Lesp available; lay out locals block in the caller
216     // adjacent to the register window save area.
217     //
218     // Compiled frames do not allocate a varargs area which is why this if
219     // statement is needed.
220     //
221     if (caller-&gt;is_compiled_frame()) {
222       locals = fp + frame::register_save_words + local_words - 1;
223     } else {
224       locals = fp + frame::memory_parameter_word_sp_offset + local_words - 1;
225     }
226     if (!caller-&gt;is_entry_frame()) {
227       // Caller wants his own SP back
228       int caller_frame_size = caller-&gt;cb()-&gt;frame_size();
229       *interpreter_frame-&gt;register_addr(I5_savedSP) = (intptr_t)(caller-&gt;fp() - caller_frame_size) - STACK_BIAS;
230     }
231   }
232   if (TraceDeoptimization) {
233     if (caller-&gt;is_entry_frame()) {
234       // make sure I5_savedSP and the entry frames notion of saved SP
235       // agree.  This assertion duplicate a check in entry frame code
236       // but catches the failure earlier.
237       assert(*caller-&gt;register_addr(Lscratch) == *interpreter_frame-&gt;register_addr(I5_savedSP),
238              &quot;would change callers SP&quot;);
239     }
240     if (caller-&gt;is_entry_frame()) {
241       tty-&gt;print(&quot;entry &quot;);
242     }
243     if (caller-&gt;is_compiled_frame()) {
244       tty-&gt;print(&quot;compiled &quot;);
245       if (caller-&gt;is_deoptimized_frame()) {
246         tty-&gt;print(&quot;(deopt) &quot;);
247       }
248     }
249     if (caller-&gt;is_interpreted_frame()) {
250       tty-&gt;print(&quot;interpreted &quot;);
251     }
252     tty-&gt;print_cr(&quot;caller fp=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(caller-&gt;fp()), p2i(caller-&gt;sp()));
253     tty-&gt;print_cr(&quot;save area = &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT, p2i(caller-&gt;sp()), p2i(caller-&gt;sp() + 16));
254     tty-&gt;print_cr(&quot;save area = &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT, p2i(caller-&gt;fp()), p2i(caller-&gt;fp() + 16));
255     tty-&gt;print_cr(&quot;interpreter fp=&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT, p2i(interpreter_frame-&gt;fp()), p2i(interpreter_frame-&gt;sp()));
256     tty-&gt;print_cr(&quot;save area = &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT, p2i(interpreter_frame-&gt;sp()), p2i(interpreter_frame-&gt;sp() + 16));
257     tty-&gt;print_cr(&quot;save area = &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT, p2i(interpreter_frame-&gt;fp()), p2i(interpreter_frame-&gt;fp() + 16));
258     tty-&gt;print_cr(&quot;Llocals = &quot; INTPTR_FORMAT, p2i(locals));
259     tty-&gt;print_cr(&quot;Lesp = &quot; INTPTR_FORMAT, p2i(esp));
260     tty-&gt;print_cr(&quot;Lmonitors = &quot; INTPTR_FORMAT, p2i(monitors));
261   }
262 
263   if (method-&gt;max_locals() &gt; 0) {
264     assert(locals &lt; caller-&gt;sp() || locals &gt;= (caller-&gt;sp() + 16), &quot;locals in save area&quot;);
265     assert(locals &lt; caller-&gt;fp() || locals &gt; (caller-&gt;fp() + 16), &quot;locals in save area&quot;);
266     assert(locals &lt; interpreter_frame-&gt;sp() || locals &gt; (interpreter_frame-&gt;sp() + 16), &quot;locals in save area&quot;);
267     assert(locals &lt; interpreter_frame-&gt;fp() || locals &gt;= (interpreter_frame-&gt;fp() + 16), &quot;locals in save area&quot;);
268   }
269   assert(*interpreter_frame-&gt;register_addr(I5_savedSP) &amp; 1, &quot;must be odd&quot;);
270 
271   *interpreter_frame-&gt;register_addr(Lmethod)     = (intptr_t) method;
272   *interpreter_frame-&gt;register_addr(Llocals)     = (intptr_t) locals;
273   *interpreter_frame-&gt;register_addr(Lmonitors)   = (intptr_t) monitors;
274   *interpreter_frame-&gt;register_addr(Lesp)        = (intptr_t) esp;
275   // Llast_SP will be same as SP as there is no adapter space
276   *interpreter_frame-&gt;register_addr(Llast_SP)    = (intptr_t) interpreter_frame-&gt;sp() - STACK_BIAS;
277   *interpreter_frame-&gt;register_addr(LcpoolCache) = (intptr_t) method-&gt;constants()-&gt;cache();
278   // save the mirror in the interpreter frame
279   *interpreter_frame-&gt;interpreter_frame_mirror_addr() = method-&gt;method_holder()-&gt;java_mirror();
280 
281 #ifdef ASSERT
282   BasicObjectLock* mp = (BasicObjectLock*)monitors;
283 
284   assert(interpreter_frame-&gt;interpreter_frame_method() == method, &quot;method matches&quot;);
285   assert(interpreter_frame-&gt;interpreter_frame_local_at(9) == (intptr_t *)((intptr_t)locals - (9 * Interpreter::stackElementSize)), &quot;locals match&quot;);
286   assert(interpreter_frame-&gt;interpreter_frame_monitor_end()   == mp, &quot;monitor_end matches&quot;);
287   assert(((intptr_t *)interpreter_frame-&gt;interpreter_frame_monitor_begin()) == ((intptr_t *)mp)+monitor_size, &quot;monitor_begin matches&quot;);
288   assert(interpreter_frame-&gt;interpreter_frame_tos_address()-1 == esp, &quot;esp matches&quot;);
289 
290   // check bounds
291   intptr_t* lo = interpreter_frame-&gt;sp() + (frame::memory_parameter_word_sp_offset - 1);
292   intptr_t* hi = interpreter_frame-&gt;fp() - rounded_vm_local_words;
293   assert(lo &lt; monitors &amp;&amp; montop &lt;= hi, &quot;monitors in bounds&quot;);
294   assert(lo &lt;= esp &amp;&amp; esp &lt; monitors, &quot;esp in bounds&quot;);
295 #endif // ASSERT
296 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
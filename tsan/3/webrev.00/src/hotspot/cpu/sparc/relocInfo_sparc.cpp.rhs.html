<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/relocInfo_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.inline.hpp&quot;
 27 #include &quot;code/relocInfo.hpp&quot;
 28 #include &quot;nativeInst_sparc.hpp&quot;
 29 #include &quot;oops/compressedOops.inline.hpp&quot;
 30 #include &quot;oops/klass.inline.hpp&quot;
 31 #include &quot;oops/oop.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 
 34 void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {
 35   NativeInstruction* ip = nativeInstruction_at(addr());
 36   jint inst = ip-&gt;long_at(0);
 37   assert(inst != NativeInstruction::illegal_instruction(), &quot;no breakpoint&quot;);
 38   switch (Assembler::inv_op(inst)) {
 39 
 40   case Assembler::ldst_op:
 41     #ifdef ASSERT
 42       switch (Assembler::inv_op3(inst)) {
 43         case Assembler::lduw_op3:
 44         case Assembler::ldub_op3:
 45         case Assembler::lduh_op3:
 46         case Assembler::ldd_op3:
 47         case Assembler::ldsw_op3:
 48         case Assembler::ldsb_op3:
 49         case Assembler::ldsh_op3:
 50         case Assembler::ldx_op3:
 51         case Assembler::ldf_op3:
 52         case Assembler::lddf_op3:
 53         case Assembler::stw_op3:
 54         case Assembler::stb_op3:
 55         case Assembler::sth_op3:
 56         case Assembler::std_op3:
 57         case Assembler::stx_op3:
 58         case Assembler::stf_op3:
 59         case Assembler::stdf_op3:
 60         case Assembler::casa_op3:
 61         case Assembler::casxa_op3:
 62           break;
 63         default:
 64           ShouldNotReachHere();
 65       }
 66       goto do_non_sethi;
 67     #endif
 68 
 69   case Assembler::arith_op:
 70     #ifdef ASSERT
 71       switch (Assembler::inv_op3(inst)) {
 72         case Assembler::or_op3:
 73         case Assembler::add_op3:
 74         case Assembler::jmpl_op3:
 75           break;
 76         default:
 77           ShouldNotReachHere();
 78       }
 79     do_non_sethi:;
 80     #endif
 81     {
 82     guarantee(Assembler::inv_immed(inst), &quot;must have a simm13 field&quot;);
 83     int simm13 = Assembler::low10((intptr_t)x) + o;
 84     guarantee(Assembler::is_simm13(simm13), &quot;offset can&#39;t overflow simm13&quot;);
 85     inst &amp;= ~Assembler::simm(    -1, 13);
 86     inst |=  Assembler::simm(simm13, 13);
 87     if (verify_only) {
 88       guarantee(ip-&gt;long_at(0) == inst, &quot;instructions must match&quot;);
 89     } else {
 90       ip-&gt;set_long_at(0, inst);
 91     }
 92     }
 93     break;
 94 
 95   case Assembler::branch_op:
 96     {
 97     jint inst2;
 98     guarantee(Assembler::inv_op2(inst)==Assembler::sethi_op2, &quot;must be sethi&quot;);
 99     if (format() != 0) {
100       assert(type() == relocInfo::oop_type || type() == relocInfo::metadata_type, &quot;only narrow oops or klasses case&quot;);
<a name="1" id="anc1"></a><span class="line-modified">101       jint np = type() == relocInfo::oop_type ? CompressedOops::encode((oop)x) : CompressedKlassPointers::encode((Klass*)x);</span>
102       inst &amp;= ~Assembler::hi22(-1);
103       inst |=  Assembler::hi22((intptr_t)np);
104       if (verify_only) {
105         guarantee(ip-&gt;long_at(0) == inst, &quot;instructions must match&quot;);
106       } else {
107         ip-&gt;set_long_at(0, inst);
108       }
109       inst2 = ip-&gt;long_at( NativeInstruction::nop_instruction_size );
110       guarantee(Assembler::inv_op(inst2)==Assembler::arith_op, &quot;arith op&quot;);
111       if (verify_only) {
112         guarantee(ip-&gt;long_at(NativeInstruction::nop_instruction_size) == NativeInstruction::set_data32_simm13( inst2, (intptr_t)np),
113                   &quot;instructions must match&quot;);
114       } else {
115         ip-&gt;set_long_at(NativeInstruction::nop_instruction_size, NativeInstruction::set_data32_simm13( inst2, (intptr_t)np));
116       }
117       break;
118     }
119     if (verify_only) {
120       ip-&gt;verify_data64_sethi( ip-&gt;addr_at(0), (intptr_t)x );
121     } else {
122       ip-&gt;set_data64_sethi( ip-&gt;addr_at(0), (intptr_t)x );
123     }
124     }
125     break;
126 
127   default:
128     guarantee(false, &quot;instruction must perform arithmetic or memory access&quot;);
129   }
130 }
131 
132 
133 address Relocation::pd_call_destination(address orig_addr) {
134   intptr_t adj = 0;
135   if (orig_addr != NULL) {
136     // We just moved this call instruction from orig_addr to addr().
137     // This means its target will appear to have grown by addr() - orig_addr.
138     adj = -( addr() - orig_addr );
139   }
140   if (NativeCall::is_call_at(addr())) {
141     NativeCall* call = nativeCall_at(addr());
142     return call-&gt;destination() + adj;
143   }
144   if (NativeFarCall::is_call_at(addr())) {
145     NativeFarCall* call = nativeFarCall_at(addr());
146     return call-&gt;destination() + adj;
147   }
148   // Special case:  Patchable branch local to the code cache.
149   // This will break badly if the code cache grows larger than a few Mb.
150   NativeGeneralJump* br = nativeGeneralJump_at(addr());
151   return br-&gt;jump_destination() + adj;
152 }
153 
154 
155 void Relocation::pd_set_call_destination(address x) {
156   if (NativeCall::is_call_at(addr())) {
157     NativeCall* call = nativeCall_at(addr());
158     call-&gt;set_destination(x);
159     return;
160   }
161   if (NativeFarCall::is_call_at(addr())) {
162     NativeFarCall* call = nativeFarCall_at(addr());
163     call-&gt;set_destination(x);
164     return;
165   }
166   // Special case:  Patchable branch local to the code cache.
167   // This will break badly if the code cache grows larger than a few Mb.
168   NativeGeneralJump* br = nativeGeneralJump_at(addr());
169   br-&gt;set_jump_destination(x);
170 }
171 
172 
173 address* Relocation::pd_address_in_code() {
174   // SPARC never embeds addresses in code, at present.
175   //assert(type() == relocInfo::oop_type, &quot;only oops are inlined at present&quot;);
176   return (address*)addr();
177 }
178 
179 
180 address Relocation::pd_get_address_from_code() {
181   // SPARC never embeds addresses in code, at present.
182   //assert(type() == relocInfo::oop_type, &quot;only oops are inlined at present&quot;);
183   return *(address*)addr();
184 }
185 
186 void poll_Relocation::fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) {
187 }
188 
189 void metadata_Relocation::pd_fix_value(address x) {
190 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
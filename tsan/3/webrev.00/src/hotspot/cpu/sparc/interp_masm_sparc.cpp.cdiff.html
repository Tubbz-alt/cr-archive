<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/sparc/interp_masm_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals_sparc.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_sparc.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/interp_masm_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,11 ***</span>
  #include &quot;interp_masm_sparc.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/interpreterRuntime.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;oops/arrayOop.hpp&quot;
<span class="line-modified">! #include &quot;oops/markOop.hpp&quot;</span>
  #include &quot;oops/methodData.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/methodCounters.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
<span class="line-new-header">--- 27,11 ---</span>
  #include &quot;interp_masm_sparc.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/interpreterRuntime.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;oops/arrayOop.hpp&quot;
<span class="line-modified">! #include &quot;oops/markWord.hpp&quot;</span>
  #include &quot;oops/methodData.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/methodCounters.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,10 ***</span>
<span class="line-new-header">--- 40,11 ---</span>
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  // Implementation of InterpreterMacroAssembler
  
  // This file specializes the assember with interpreter-specific macros
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,11 ***</span>
  // Dispatch code executed in the epilog of a bytecode which does not do it&#39;s
  // own dispatch. The dispatch address in IdispatchAddress is used for the
  // dispatch.
  void InterpreterMacroAssembler::dispatch_epilog(TosState state, int bcp_incr) {
    assert_not_delayed();
<span class="line-removed">-   verify_FPU(1, state);</span>
    interp_verify_oop(Otos_i, state, __FILE__, __LINE__);
    jmp( IdispatchAddress, 0 );
    if (bcp_incr != 0)  delayed()-&gt;inc(Lbcp, bcp_incr);
    else                delayed()-&gt;nop();
  }
<span class="line-new-header">--- 90,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,11 ***</span>
  
  // common code to dispatch and dispatch_only
  // dispatch value in Lbyte_code and increment Lbcp
  
  void InterpreterMacroAssembler::dispatch_Lbyte_code(TosState state, address* table, int bcp_incr, bool verify, bool generate_poll) {
<span class="line-removed">-   verify_FPU(1, state);</span>
    // %%%%% maybe implement +VerifyActivationFrameSize here
    //verify_thread(); //too slow; we will just verify on method entry &amp; exit
    if (verify) interp_verify_oop(Otos_i, state, __FILE__, __LINE__);
    // dispatch table to use
    AddressLiteral tbl(table);
<span class="line-new-header">--- 262,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1198,45 ***</span>
  
      Label slow_case;
  
      assert_different_registers(lock_reg, obj_reg, mark_reg, temp_reg);
  
<span class="line-modified">!     // load markOop from object into mark_reg</span>
      ld_ptr(mark_addr, mark_reg);
  
      if (UseBiasedLocking) {
        biased_locking_enter(obj_reg, mark_reg, temp_reg, done, &amp;slow_case);
      }
  
      // get the address of basicLock on stack that will be stored in the object
      // we need a temporary register here as we do not want to clobber lock_reg
      // (cas clobbers the destination register)
      mov(lock_reg, temp_reg);
<span class="line-modified">!     // set mark reg to be (markOop of object | UNLOCK_VALUE)</span>
<span class="line-modified">!     or3(mark_reg, markOopDesc::unlocked_value, mark_reg);</span>
      // initialize the box  (Must happen before we update the object mark!)
      st_ptr(mark_reg, lock_addr, BasicLock::displaced_header_offset_in_bytes());
<span class="line-modified">!     // compare and exchange object_addr, markOop | 1, stack address of basicLock</span>
      assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
      cas_ptr(mark_addr.base(), mark_reg, temp_reg);
  
      // if the compare and exchange succeeded we are done (we saw an unlocked object)
      cmp_and_brx_short(mark_reg, temp_reg, Assembler::equal, Assembler::pt, done);
  
      // We did not see an unlocked object so try the fast recursive case
  
<span class="line-modified">!     // Check if owner is self by comparing the value in the markOop of object</span>
      // with the stack pointer
      sub(temp_reg, SP, temp_reg);
      sub(temp_reg, STACK_BIAS, temp_reg);
      assert(os::vm_page_size() &gt; 0xfff, &quot;page size too small - change the constant&quot;);
  
      // Composite &quot;andcc&quot; test:
      // (a) %sp -vs- markword proximity check, and,
      // (b) verify mark word LSBs == 0 (Stack-locked).
      //
<span class="line-modified">!     // FFFFF003/FFFFFFFFFFFF003 is (markOopDesc::lock_mask_in_place | -os::vm_page_size())</span>
      // Note that the page size used for %sp proximity testing is arbitrary and is
      // unrelated to the actual MMU page size.  We use a &#39;logical&#39; page size of
      // 4096 bytes.   F..FFF003 is designed to fit conveniently in the SIMM13 immediate
      // field of the andcc instruction.
      andcc (temp_reg, 0xFFFFF003, G0) ;
<span class="line-new-header">--- 1197,45 ---</span>
  
      Label slow_case;
  
      assert_different_registers(lock_reg, obj_reg, mark_reg, temp_reg);
  
<span class="line-modified">!     // load markWord from object into mark_reg</span>
      ld_ptr(mark_addr, mark_reg);
  
      if (UseBiasedLocking) {
        biased_locking_enter(obj_reg, mark_reg, temp_reg, done, &amp;slow_case);
      }
  
      // get the address of basicLock on stack that will be stored in the object
      // we need a temporary register here as we do not want to clobber lock_reg
      // (cas clobbers the destination register)
      mov(lock_reg, temp_reg);
<span class="line-modified">!     // set mark reg to be (markWord of object | UNLOCK_VALUE)</span>
<span class="line-modified">!     or3(mark_reg, markWord::unlocked_value, mark_reg);</span>
      // initialize the box  (Must happen before we update the object mark!)
      st_ptr(mark_reg, lock_addr, BasicLock::displaced_header_offset_in_bytes());
<span class="line-modified">!     // compare and exchange object_addr, markWord | 1, stack address of basicLock</span>
      assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
      cas_ptr(mark_addr.base(), mark_reg, temp_reg);
  
      // if the compare and exchange succeeded we are done (we saw an unlocked object)
      cmp_and_brx_short(mark_reg, temp_reg, Assembler::equal, Assembler::pt, done);
  
      // We did not see an unlocked object so try the fast recursive case
  
<span class="line-modified">!     // Check if owner is self by comparing the value in the markWord of object</span>
      // with the stack pointer
      sub(temp_reg, SP, temp_reg);
      sub(temp_reg, STACK_BIAS, temp_reg);
      assert(os::vm_page_size() &gt; 0xfff, &quot;page size too small - change the constant&quot;);
  
      // Composite &quot;andcc&quot; test:
      // (a) %sp -vs- markword proximity check, and,
      // (b) verify mark word LSBs == 0 (Stack-locked).
      //
<span class="line-modified">!     // FFFFF003/FFFFFFFFFFFF003 is (markWord::lock_mask_in_place | -os::vm_page_size())</span>
      // Note that the page size used for %sp proximity testing is arbitrary and is
      // unrelated to the actual MMU page size.  We use a &#39;logical&#39; page size of
      // 4096 bytes.   F..FFF003 is designed to fit conveniently in the SIMM13 immediate
      // field of the andcc instruction.
      andcc (temp_reg, 0xFFFFF003, G0) ;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2543,15 ***</span>
    verify_oop(reg);
    bind(skip);
  }
  
  
<span class="line-removed">- void InterpreterMacroAssembler::verify_FPU(int stack_depth, TosState state) {</span>
<span class="line-removed">-   if (state == ftos || state == dtos) MacroAssembler::verify_FPU(stack_depth);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  // Jump if ((*counter_addr += increment) &amp; mask) satisfies the condition.
  void InterpreterMacroAssembler::increment_mask_and_jump(Address counter_addr,
                                                          int increment, Address mask_addr,
                                                          Register scratch1, Register scratch2,
                                                          Condition cond, Label *where) {
<span class="line-new-header">--- 2542,10 ---</span>
</pre>
<center><a href="globals_sparc.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_sparc.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
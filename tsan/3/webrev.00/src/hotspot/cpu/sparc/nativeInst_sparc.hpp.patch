diff a/src/hotspot/cpu/sparc/nativeInst_sparc.hpp b/src/hotspot/cpu/sparc/nativeInst_sparc.hpp
--- a/src/hotspot/cpu/sparc/nativeInst_sparc.hpp
+++ b/src/hotspot/cpu/sparc/nativeInst_sparc.hpp
@@ -313,11 +313,11 @@
 // (used to manipulate inline caches, primitive & dll calls, etc.)
 class NativeCall;
 
 inline NativeCall* nativeCall_at(address instr);
 inline NativeCall* nativeCall_overwriting_at(address instr,
-                                             address destination);
+                                             address destination = NULL);
 inline NativeCall* nativeCall_before(address return_address);
 class NativeCall: public NativeInstruction {
  public:
   enum Sparc_specific_constants {
     instruction_size                   = 8,
@@ -342,11 +342,11 @@
   // unit test stuff
   static void  test();
 
   // Creation
   friend inline NativeCall* nativeCall_at(address instr);
-  friend NativeCall* nativeCall_overwriting_at(address instr, address destination = NULL) {
+  friend NativeCall* nativeCall_overwriting_at(address instr, address destination) {
     // insert a "blank" call:
     NativeCall* call = (NativeCall*)instr;
     call->set_long_at(0 * BytesPerInstWord, call_instruction(destination, instr));
     call->set_long_at(1 * BytesPerInstWord, nop_instruction());
     assert(call->addr_at(2 * BytesPerInstWord) - instr == instruction_size, "instruction size");
@@ -411,11 +411,11 @@
 // The format of this extended-range call is:
 //      jumpl_to addr, lreg
 //      == sethi %hi54(addr), O7 ;  jumpl O7, %lo10(addr), O7 ;  <delay>
 // That is, it is essentially the same as a NativeJump.
 class NativeFarCall;
-inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination);
+inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination = NULL);
 inline NativeFarCall* nativeFarCall_at(address instr);
 class NativeFarCall: public NativeInstruction {
  public:
   enum Sparc_specific_constants {
     // instruction_size includes the delay slot instruction.
@@ -450,11 +450,11 @@
       call->verify();
     #endif
     return call;
   }
 
-  friend inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination = NULL) {
+  friend inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination) {
     Unimplemented();
     NativeFarCall* call = (NativeFarCall*)instr;
     return call;
   }
 
@@ -574,11 +574,12 @@
 //
 // Note that it is identical to NativeMovConstReg with the exception of a nop between the
 // sethi and the add.  The nop is required to be in the delay slot of the call instruction
 // which overwrites the sethi during patching.
 class NativeMovConstRegPatching;
-inline NativeMovConstRegPatching* nativeMovConstRegPatching_at(address address);class NativeMovConstRegPatching: public NativeInstruction {
+inline NativeMovConstRegPatching* nativeMovConstRegPatching_at(address address);
+class NativeMovConstRegPatching: public NativeInstruction {
  public:
   enum Sparc_specific_constants {
     sethi_offset           = 0,
     nop_offset             = 7 * BytesPerInstWord,
     add_offset             = nop_offset   + BytesPerInstWord,
@@ -662,14 +663,17 @@
     // check if instruction is ld* [reg + offset], reg or st* reg, [reg + offset]
     int i0 = long_at(0);
     return (is_op(i0, Assembler::ldst_op));
   }
 
-  address instruction_address() const           { return addr_at(0); }
-  address next_instruction_address() const      {
-    return addr_at(is_immediate() ? 4 : (7 * BytesPerInstWord));
+  address instruction_address() const { return addr_at(0); }
+
+  int num_bytes_to_end_of_patch() const {
+    return is_immediate()? BytesPerInstWord :
+                           NativeMovConstReg::instruction_size;
   }
+
   intptr_t   offset() const                             {
      return is_immediate()? inv_simm(long_at(0), offset_width) :
                             nativeMovConstReg_at(addr_at(0))->data();
   }
   void  set_offset(intptr_t x) {
@@ -682,12 +686,10 @@
 
   void  add_offset_in_bytes(intptr_t radd_offset)     {
       set_offset (offset() + radd_offset);
   }
 
-  void  copy_instruction_to(address new_instruction_address);
-
   void verify();
   void print ();
 
   // unit test stuff
   static void test();

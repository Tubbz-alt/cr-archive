<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/vm_version_sparc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef CPU_SPARC_VM_VERSION_SPARC_HPP
 26 #define CPU_SPARC_VM_VERSION_SPARC_HPP
 27 
<a name="1" id="anc1"></a>
 28 #include &quot;runtime/globals_extension.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 29 #include &quot;runtime/vm_version.hpp&quot;</span>
 30 
 31 class VM_Version: public Abstract_VM_Version {
 32   friend class VMStructs;
 33   friend class JVMCIVMStructs;
 34 
 35 protected:
 36   enum {
 37     ISA_V9,
 38     ISA_POPC,
 39     ISA_VIS1,
 40     ISA_VIS2,
 41     ISA_BLK_INIT,
 42     ISA_FMAF,
 43     ISA_VIS3,
 44     ISA_HPC,
 45     ISA_IMA,
 46     ISA_AES,
 47     ISA_DES,
 48     ISA_KASUMI,
 49     ISA_CAMELLIA,
 50     ISA_MD5,
 51     ISA_SHA1,
 52     ISA_SHA256,
 53     ISA_SHA512,
 54     ISA_MPMUL,
 55     ISA_MONT,
 56     ISA_PAUSE,
 57     ISA_CBCOND,
 58     ISA_CRC32C,
 59 
 60     ISA_FJATHPLUS,
 61     ISA_VIS3B,
 62     ISA_ADI,
 63     ISA_SPARC5,
 64     ISA_MWAIT,
 65     ISA_XMPMUL,
 66     ISA_XMONT,
 67     ISA_PAUSE_NSEC,
 68     ISA_VAMASK,
 69 
 70     ISA_SPARC6,
 71     ISA_DICTUNP,
 72     ISA_FPCMPSHL,
 73     ISA_RLE,
 74     ISA_SHA3,
 75     ISA_FJATHPLUS2,
 76     ISA_VIS3C,
 77     ISA_SPARC5B,
 78     ISA_MME,
 79 
 80     // Synthesised properties:
 81 
 82     CPU_FAST_IDIV,
 83     CPU_FAST_RDPC,
 84     CPU_FAST_BIS,
 85     CPU_FAST_LD,
 86     CPU_FAST_CMOVE,
 87     CPU_FAST_IND_BR,
 88     CPU_BLK_ZEROING
 89   };
 90 
 91 private:
 92   enum { ISA_last_feature = ISA_MME,
 93          CPU_last_feature = CPU_BLK_ZEROING };
 94 
 95   enum {
 96     ISA_unknown_msk     = 0,
 97 
 98     ISA_v9_msk          = UINT64_C(1) &lt;&lt; ISA_V9,
 99 
100     ISA_popc_msk        = UINT64_C(1) &lt;&lt; ISA_POPC,
101     ISA_vis1_msk        = UINT64_C(1) &lt;&lt; ISA_VIS1,
102     ISA_vis2_msk        = UINT64_C(1) &lt;&lt; ISA_VIS2,
103     ISA_blk_init_msk    = UINT64_C(1) &lt;&lt; ISA_BLK_INIT,
104     ISA_fmaf_msk        = UINT64_C(1) &lt;&lt; ISA_FMAF,
105     ISA_vis3_msk        = UINT64_C(1) &lt;&lt; ISA_VIS3,
106     ISA_hpc_msk         = UINT64_C(1) &lt;&lt; ISA_HPC,
107     ISA_ima_msk         = UINT64_C(1) &lt;&lt; ISA_IMA,
108     ISA_aes_msk         = UINT64_C(1) &lt;&lt; ISA_AES,
109     ISA_des_msk         = UINT64_C(1) &lt;&lt; ISA_DES,
110     ISA_kasumi_msk      = UINT64_C(1) &lt;&lt; ISA_KASUMI,
111     ISA_camellia_msk    = UINT64_C(1) &lt;&lt; ISA_CAMELLIA,
112     ISA_md5_msk         = UINT64_C(1) &lt;&lt; ISA_MD5,
113     ISA_sha1_msk        = UINT64_C(1) &lt;&lt; ISA_SHA1,
114     ISA_sha256_msk      = UINT64_C(1) &lt;&lt; ISA_SHA256,
115     ISA_sha512_msk      = UINT64_C(1) &lt;&lt; ISA_SHA512,
116     ISA_mpmul_msk       = UINT64_C(1) &lt;&lt; ISA_MPMUL,
117     ISA_mont_msk        = UINT64_C(1) &lt;&lt; ISA_MONT,
118     ISA_pause_msk       = UINT64_C(1) &lt;&lt; ISA_PAUSE,
119     ISA_cbcond_msk      = UINT64_C(1) &lt;&lt; ISA_CBCOND,
120     ISA_crc32c_msk      = UINT64_C(1) &lt;&lt; ISA_CRC32C,
121 
122     ISA_fjathplus_msk   = UINT64_C(1) &lt;&lt; ISA_FJATHPLUS,
123     ISA_vis3b_msk       = UINT64_C(1) &lt;&lt; ISA_VIS3B,
124     ISA_adi_msk         = UINT64_C(1) &lt;&lt; ISA_ADI,
125     ISA_sparc5_msk      = UINT64_C(1) &lt;&lt; ISA_SPARC5,
126     ISA_mwait_msk       = UINT64_C(1) &lt;&lt; ISA_MWAIT,
127     ISA_xmpmul_msk      = UINT64_C(1) &lt;&lt; ISA_XMPMUL,
128     ISA_xmont_msk       = UINT64_C(1) &lt;&lt; ISA_XMONT,
129     ISA_pause_nsec_msk  = UINT64_C(1) &lt;&lt; ISA_PAUSE_NSEC,
130     ISA_vamask_msk      = UINT64_C(1) &lt;&lt; ISA_VAMASK,
131 
132     ISA_sparc6_msk      = UINT64_C(1) &lt;&lt; ISA_SPARC6,
133     ISA_dictunp_msk     = UINT64_C(1) &lt;&lt; ISA_DICTUNP,
134     ISA_fpcmpshl_msk    = UINT64_C(1) &lt;&lt; ISA_FPCMPSHL,
135     ISA_rle_msk         = UINT64_C(1) &lt;&lt; ISA_RLE,
136     ISA_sha3_msk        = UINT64_C(1) &lt;&lt; ISA_SHA3,
137     ISA_fjathplus2_msk  = UINT64_C(1) &lt;&lt; ISA_FJATHPLUS2,
138     ISA_vis3c_msk       = UINT64_C(1) &lt;&lt; ISA_VIS3C,
139     ISA_sparc5b_msk     = UINT64_C(1) &lt;&lt; ISA_SPARC5B,
140     ISA_mme_msk         = UINT64_C(1) &lt;&lt; ISA_MME,
141 
142     CPU_fast_idiv_msk   = UINT64_C(1) &lt;&lt; CPU_FAST_IDIV,
143     CPU_fast_rdpc_msk   = UINT64_C(1) &lt;&lt; CPU_FAST_RDPC,
144     CPU_fast_bis_msk    = UINT64_C(1) &lt;&lt; CPU_FAST_BIS,
145     CPU_fast_ld_msk     = UINT64_C(1) &lt;&lt; CPU_FAST_LD,
146     CPU_fast_cmove_msk  = UINT64_C(1) &lt;&lt; CPU_FAST_CMOVE,
147     CPU_fast_ind_br_msk = UINT64_C(1) &lt;&lt; CPU_FAST_IND_BR,
148     CPU_blk_zeroing_msk = UINT64_C(1) &lt;&lt; CPU_BLK_ZEROING,
149 
150     last_feature_msk    = CPU_blk_zeroing_msk,
151     full_feature_msk    = (last_feature_msk &lt;&lt; 1) - 1
152   };
153 
154 /* The following, previously supported, SPARC implementations are no longer
155  * supported.
156  *
157  *  UltraSPARC I/II:
158  *    SPARC-V9, VIS
159  *  UltraSPARC III/+:  (Cheetah/+)
160  *    SPARC-V9, VIS
161  *  UltraSPARC IV:     (Jaguar)
162  *    SPARC-V9, VIS
163  *  UltraSPARC IV+:    (Panther)
164  *    SPARC-V9, VIS, POPC
165  *
166  * The currently supported SPARC implementations are listed below (including
167  * generic V9 support).
168  *
169  *  UltraSPARC T1:     (Niagara)
170  *    SPARC-V9, VIS, ASI_BIS                (Crypto/hash in SPU)
171  *  UltraSPARC T2:     (Niagara-2)
172  *    SPARC-V9, VIS, ASI_BIS, POPC          (Crypto/hash in SPU)
173  *  UltraSPARC T2+:    (Victoria Falls, etc.)
174  *    SPARC-V9, VIS, VIS2, ASI_BIS, POPC    (Crypto/hash in SPU)
175  *
176  *  UltraSPARC T3:     (Rainbow Falls/C2)
177  *    SPARC-V9, VIS, VIS2, ASI_BIS, POPC    (Crypto/hash in SPU)
178  *
179  *  Oracle SPARC T4/T5/M5:  (Core C3)
180  *    SPARC-V9, VIS, VIS2, VIS3, ASI_BIS, HPC, POPC, FMAF, IMA, PAUSE, CBCOND,
181  *    AES, DES, Kasumi, Camellia, MD5, SHA1, SHA256, SHA512, CRC32C, MONT, MPMUL
182  *
183  *  Oracle SPARC M7:   (Core C4)
184  *    SPARC-V9, VIS, VIS2, VIS3, ASI_BIS, HPC, POPC, FMAF, IMA, PAUSE, CBCOND,
185  *    AES, DES, Camellia, MD5, SHA1, SHA256, SHA512, CRC32C, MONT, MPMUL, VIS3b,
186  *    ADI, SPARC5, MWAIT, XMPMUL, XMONT, PAUSE_NSEC, VAMASK
187  *
188  *  Oracle SPARC M8:   (Core C5)
189  *    SPARC-V9, VIS, VIS2, VIS3, ASI_BIS, HPC, POPC, FMAF, IMA, PAUSE, CBCOND,
190  *    AES, DES, Camellia, MD5, SHA1, SHA256, SHA512, CRC32C, MONT, MPMUL, VIS3b,
191  *    ADI, SPARC5, MWAIT, XMPMUL, XMONT, PAUSE_NSEC, VAMASK, SPARC6, FPCMPSHL,
192  *    DICTUNP, RLE, SHA3, MME
193  *
194  *    NOTE: Oracle Number support ignored.
195  */
196   enum {
197     niagara1_msk = ISA_v9_msk | ISA_vis1_msk | ISA_blk_init_msk,
198     niagara2_msk = niagara1_msk | ISA_popc_msk,
199 
200     core_C2_msk  = niagara2_msk | ISA_vis2_msk,
201 
202     core_C3_msk  = core_C2_msk | ISA_fmaf_msk | ISA_vis3_msk | ISA_hpc_msk |
203         ISA_ima_msk | ISA_aes_msk | ISA_des_msk | ISA_kasumi_msk |
204         ISA_camellia_msk | ISA_md5_msk | ISA_sha1_msk | ISA_sha256_msk |
205         ISA_sha512_msk | ISA_mpmul_msk | ISA_mont_msk | ISA_pause_msk |
206         ISA_cbcond_msk | ISA_crc32c_msk,
207 
208     core_C4_msk  = core_C3_msk - ISA_kasumi_msk |
209         ISA_vis3b_msk | ISA_adi_msk | ISA_sparc5_msk | ISA_mwait_msk |
210         ISA_xmpmul_msk | ISA_xmont_msk | ISA_pause_nsec_msk | ISA_vamask_msk,
211 
212     core_C5_msk = core_C4_msk | ISA_sparc6_msk | ISA_dictunp_msk |
213         ISA_fpcmpshl_msk | ISA_rle_msk | ISA_sha3_msk | ISA_mme_msk,
214 
215     ultra_sparc_t1_msk = niagara1_msk,
216     ultra_sparc_t2_msk = niagara2_msk,
217     ultra_sparc_t3_msk = core_C2_msk,
218     ultra_sparc_m5_msk = core_C3_msk,   // NOTE: First out-of-order pipeline.
219     ultra_sparc_m7_msk = core_C4_msk,
220     ultra_sparc_m8_msk = core_C5_msk
221   };
222 
223   static uint _L2_data_cache_line_size;
224   static uint L2_data_cache_line_size() { return _L2_data_cache_line_size; }
225 
226   static void determine_features();
227   static void platform_features();
228   static void print_features();
229 
230 public:
231   enum {
232     // Adopt a conservative behaviour (modelling single-insn-fetch-n-issue) for
233     // Niagara (and SPARC64). While there are at least two entries/slots in the
234     // instruction fetch buffer on any Niagara core (and as many as eight on a
235     // SPARC64), the performance improvement from keeping hot branch targets on
236     // optimally aligned addresses is such a small one (if any) that we choose
237     // not to use the extra code space required.
238 
239     insn_fetch_alignment = 4    // Byte alignment in L1 insn. cache.
240   };
241 
242   static void initialize();
243 
244   static void init_before_ergo() { determine_features(); }
245 
246   // Instruction feature support:
247 
248   static bool has_v9()           { return (_features &amp; ISA_v9_msk) != 0; }
249   static bool has_popc()         { return (_features &amp; ISA_popc_msk) != 0; }
250   static bool has_vis1()         { return (_features &amp; ISA_vis1_msk) != 0; }
251   static bool has_vis2()         { return (_features &amp; ISA_vis2_msk) != 0; }
252   static bool has_blk_init()     { return (_features &amp; ISA_blk_init_msk) != 0; }
253   static bool has_fmaf()         { return (_features &amp; ISA_fmaf_msk) != 0; }
254   static bool has_vis3()         { return (_features &amp; ISA_vis3_msk) != 0; }
255   static bool has_hpc()          { return (_features &amp; ISA_hpc_msk) != 0; }
256   static bool has_ima()          { return (_features &amp; ISA_ima_msk) != 0; }
257   static bool has_aes()          { return (_features &amp; ISA_aes_msk) != 0; }
258   static bool has_des()          { return (_features &amp; ISA_des_msk) != 0; }
259   static bool has_kasumi()       { return (_features &amp; ISA_kasumi_msk) != 0; }
260   static bool has_camellia()     { return (_features &amp; ISA_camellia_msk) != 0; }
261   static bool has_md5()          { return (_features &amp; ISA_md5_msk) != 0; }
262   static bool has_sha1()         { return (_features &amp; ISA_sha1_msk) != 0; }
263   static bool has_sha256()       { return (_features &amp; ISA_sha256_msk) != 0; }
264   static bool has_sha512()       { return (_features &amp; ISA_sha512_msk) != 0; }
265   static bool has_mpmul()        { return (_features &amp; ISA_mpmul_msk) != 0; }
266   static bool has_mont()         { return (_features &amp; ISA_mont_msk) != 0; }
267   static bool has_pause()        { return (_features &amp; ISA_pause_msk) != 0; }
268   static bool has_cbcond()       { return (_features &amp; ISA_cbcond_msk) != 0; }
269   static bool has_crc32c()       { return (_features &amp; ISA_crc32c_msk) != 0; }
270 
271   static bool has_athena_plus()  { return (_features &amp; ISA_fjathplus_msk) != 0; }
272   static bool has_vis3b()        { return (_features &amp; ISA_vis3b_msk) != 0; }
273   static bool has_adi()          { return (_features &amp; ISA_adi_msk) != 0; }
274   static bool has_sparc5()       { return (_features &amp; ISA_sparc5_msk) != 0; }
275   static bool has_mwait()        { return (_features &amp; ISA_mwait_msk) != 0; }
276   static bool has_xmpmul()       { return (_features &amp; ISA_xmpmul_msk) != 0; }
277   static bool has_xmont()        { return (_features &amp; ISA_xmont_msk) != 0; }
278   static bool has_pause_nsec()   { return (_features &amp; ISA_pause_nsec_msk) != 0; }
279   static bool has_vamask()       { return (_features &amp; ISA_vamask_msk) != 0; }
280 
281   static bool has_sparc6()       { return (_features &amp; ISA_sparc6_msk) != 0; }
282   static bool has_dictunp()      { return (_features &amp; ISA_dictunp_msk) != 0; }
283   static bool has_fpcmpshl()     { return (_features &amp; ISA_fpcmpshl_msk) != 0; }
284   static bool has_rle()          { return (_features &amp; ISA_rle_msk) != 0; }
285   static bool has_sha3()         { return (_features &amp; ISA_sha3_msk) != 0; }
286   static bool has_athena_plus2() { return (_features &amp; ISA_fjathplus2_msk) != 0; }
287   static bool has_vis3c()        { return (_features &amp; ISA_vis3c_msk) != 0; }
288   static bool has_sparc5b()      { return (_features &amp; ISA_sparc5b_msk) != 0; }
289   static bool has_mme()          { return (_features &amp; ISA_mme_msk) != 0; }
290 
291   static bool has_fast_idiv()    { return (_features &amp; CPU_fast_idiv_msk) != 0; }
292   static bool has_fast_rdpc()    { return (_features &amp; CPU_fast_rdpc_msk) != 0; }
293   static bool has_fast_bis()     { return (_features &amp; CPU_fast_bis_msk) != 0; }
294   static bool has_fast_ld()      { return (_features &amp; CPU_fast_ld_msk) != 0; }
295   static bool has_fast_cmove()   { return (_features &amp; CPU_fast_cmove_msk) != 0; }
296 
297   // If indirect and direct branching is equally fast.
298   static bool has_fast_ind_br()  { return (_features &amp; CPU_fast_ind_br_msk) != 0; }
299   // If SPARC BIS to the beginning of cache line always zeros it.
300   static bool has_blk_zeroing()  { return (_features &amp; CPU_blk_zeroing_msk) != 0; }
301 
302   static bool supports_compare_and_exchange() { return true; }
303 
304   // FIXME: To be removed.
305   static bool is_post_niagara()  {
306     return (_features &amp; niagara2_msk) == niagara2_msk;
307   }
308 
309   // Default prefetch block size on SPARC.
310   static uint prefetch_data_size() { return L2_data_cache_line_size(); }
311 
312  private:
313   // Prefetch policy and characteristics:
314   //
315   // These support routines are used in order to isolate any CPU/core specific
316   // logic from the actual flag/option processing.  They should reflect the HW
317   // characteristics for the associated options on the current platform.
318   //
319   // The three Prefetch* options below (assigned -1 in the configuration) are
320   // treated according to (given the accepted range [-1..&lt;maxint&gt;]):
321   //  -1: Determine a proper HW-specific value for the current HW.
322   //   0: Off
323   //  &gt;0: Command-line supplied value to use.
324   //
325   // FIXME: The documentation string in the configuration is wrong, saying that
326   //        -1 is also interpreted as off.
327   //
328   static intx prefetch_copy_interval_in_bytes() {
329     intx bytes = PrefetchCopyIntervalInBytes;
330     return bytes &lt; 0 ? 512 : bytes;
331   }
332   static intx prefetch_scan_interval_in_bytes() {
333     intx bytes = PrefetchScanIntervalInBytes;
334     return bytes &lt; 0 ? 512 : bytes;
335   }
336   static intx prefetch_fields_ahead() {
337     intx count = PrefetchFieldsAhead;
338     return count &lt; 0 ? 0 : count;
339   }
340 
341   // AllocatePrefetchDistance is treated under the same interpretation as the
342   // Prefetch* options above (i.e., -1, 0, &gt;0).
343   static intx allocate_prefetch_distance() {
344     intx count = AllocatePrefetchDistance;
345     return count &lt; 0 ? 512 : count;
346   }
347 
348   // AllocatePrefetchStyle is guaranteed to be in range [0..3] defined by the
349   // configuration.
350   static intx allocate_prefetch_style() {
351     intx distance = allocate_prefetch_distance();
352     // Return 0 (off/none) if AllocatePrefetchDistance was not defined.
353     return distance &gt; 0 ? AllocatePrefetchStyle : 0;
354   }
355 
356  public:
357   // Assembler testing
358   static void allow_all();
359   static void revert();
360 
361   // Override the Abstract_VM_Version implementation.
362   //
363   // FIXME: Removed broken test on sun4v (always false when invoked prior to the
364   //        proper capability setup), thus always returning 2. Still need to fix
365   //        this properly in order to enable complete page size support.
366   static uint page_size_count() { return 2; }
367 
368   // Override default denominator for ParallelGCThreads.
369   //
370   // FIXME: Simply checking the processor family is insufficient.
371   static uint parallel_worker_threads_denominator() {
372     return is_post_niagara() ? 16 : 8;
373   }
374 };
375 
376 #endif // CPU_SPARC_VM_VERSION_SPARC_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
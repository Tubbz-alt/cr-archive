<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/nativeInst_sparc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nativeInst_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="relocInfo_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/nativeInst_sparc.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
298 };
299 
300 inline NativeInstruction* nativeInstruction_at(address address) {
301     NativeInstruction* inst = (NativeInstruction*)address;
302 #ifdef ASSERT
303       inst-&gt;verify();
304 #endif
305     return inst;
306 }
307 
308 
309 
310 //-----------------------------------------------------------------------------
311 
312 // The NativeCall is an abstraction for accessing/manipulating native call imm32 instructions.
313 // (used to manipulate inline caches, primitive &amp; dll calls, etc.)
314 class NativeCall;
315 
316 inline NativeCall* nativeCall_at(address instr);
317 inline NativeCall* nativeCall_overwriting_at(address instr,
<span class="line-modified">318                                              address destination);</span>
319 inline NativeCall* nativeCall_before(address return_address);
320 class NativeCall: public NativeInstruction {
321  public:
322   enum Sparc_specific_constants {
323     instruction_size                   = 8,
324     return_address_offset              = 8,
325     call_displacement_width            = 30,
326     displacement_offset                = 0,
327     instruction_offset                 = 0
328   };
329   address instruction_address() const       { return addr_at(0); }
330   address next_instruction_address() const  { return addr_at(instruction_size); }
331   address return_address() const            { return addr_at(return_address_offset); }
332 
333   address destination() const               { return inv_wdisp(long_at(0), call_displacement_width) + instruction_address(); }
334   address displacement_address() const      { return addr_at(displacement_offset); }
335   void  set_destination(address dest)       { set_long_at(0, set_wdisp(long_at(0), dest - instruction_address(), call_displacement_width)); }
336   void  set_destination_mt_safe(address dest);
337 
338   void  verify_alignment() {} // do nothing on sparc
339   void  verify();
340   void  print();
341 
342   // unit test stuff
343   static void  test();
344 
345   // Creation
346   friend inline NativeCall* nativeCall_at(address instr);
<span class="line-modified">347   friend NativeCall* nativeCall_overwriting_at(address instr, address destination = NULL) {</span>
348     // insert a &quot;blank&quot; call:
349     NativeCall* call = (NativeCall*)instr;
350     call-&gt;set_long_at(0 * BytesPerInstWord, call_instruction(destination, instr));
351     call-&gt;set_long_at(1 * BytesPerInstWord, nop_instruction());
352     assert(call-&gt;addr_at(2 * BytesPerInstWord) - instr == instruction_size, &quot;instruction size&quot;);
353     // check its structure now:
354     assert(nativeCall_at(instr)-&gt;destination() == destination, &quot;correct call destination&quot;);
355     return call;
356   }
357 
358   friend inline NativeCall* nativeCall_before(address return_address) {
359     NativeCall* call = (NativeCall*)(return_address - return_address_offset);
360     #ifdef ASSERT
361       call-&gt;verify();
362     #endif
363     return call;
364   }
365 
366   static bool is_call_at(address instr) {
367     return nativeInstruction_at(instr)-&gt;is_call();
</pre>
<hr />
<pre>
396   enum Sparc_specific_constants {
397     instruction_size      = 8,
398     return_address_offset = 8,
399     instruction_offset    = 0
400   };
401 
402   address next_instruction_address() const {
403     return addr_at(instruction_size);
404   }
405 };
406 
407 // The NativeFarCall is an abstraction for accessing/manipulating native call-anywhere
408 // instructions in the sparcv9 vm.  Used to call native methods which may be loaded
409 // anywhere in the address space, possibly out of reach of a call instruction.
410 
411 // The format of this extended-range call is:
412 //      jumpl_to addr, lreg
413 //      == sethi %hi54(addr), O7 ;  jumpl O7, %lo10(addr), O7 ;  &lt;delay&gt;
414 // That is, it is essentially the same as a NativeJump.
415 class NativeFarCall;
<span class="line-modified">416 inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination);</span>
417 inline NativeFarCall* nativeFarCall_at(address instr);
418 class NativeFarCall: public NativeInstruction {
419  public:
420   enum Sparc_specific_constants {
421     // instruction_size includes the delay slot instruction.
422     instruction_size                   = 9 * BytesPerInstWord,
423     return_address_offset              = 9 * BytesPerInstWord,
424     jmpl_offset                        = 7 * BytesPerInstWord,
425     displacement_offset                = 0,
426     instruction_offset                 = 0
427   };
428   address instruction_address() const       { return addr_at(0); }
429   address next_instruction_address() const  { return addr_at(instruction_size); }
430   address return_address() const            { return addr_at(return_address_offset); }
431 
432   address destination() const {
433     return (address) data64(addr_at(0), long_at(jmpl_offset));
434   }
435   address displacement_address() const      { return addr_at(displacement_offset); }
436   void set_destination(address dest);
437 
438   bool destination_is_compiled_verified_entry_point();
439 
440   void  verify();
441   void  print();
442 
443   // unit test stuff
444   static void  test();
445 
446   // Creation
447   friend inline NativeFarCall* nativeFarCall_at(address instr) {
448     NativeFarCall* call = (NativeFarCall*)instr;
449     #ifdef ASSERT
450       call-&gt;verify();
451     #endif
452     return call;
453   }
454 
<span class="line-modified">455   friend inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination = NULL) {</span>
456     Unimplemented();
457     NativeFarCall* call = (NativeFarCall*)instr;
458     return call;
459   }
460 
461   friend NativeFarCall* nativeFarCall_before(address return_address) {
462     NativeFarCall* call = (NativeFarCall*)(return_address - return_address_offset);
463     #ifdef ASSERT
464       call-&gt;verify();
465     #endif
466     return call;
467   }
468 
469   static bool is_call_at(address instr);
470 
471   // MT-safe patching of a call instruction.
472   static void insert(address code_pos, address entry) {
473     (void)nativeFarCall_overwriting_at(code_pos, entry);
474   }
475   static void replace_mt_safe(address instr_addr, address code_buffer);
</pre>
<hr />
<pre>
559   friend NativeMovConstReg* nativeMovConstReg_before(address address) {
560     NativeMovConstReg* test = (NativeMovConstReg*)(address - instruction_size);
561     #ifdef ASSERT
562       test-&gt;verify();
563     #endif
564     return test;
565   }
566 
567 };
568 
569 
570 // An interface for accessing/manipulating native set_metadata imm, reg instructions.
571 // (used to manipulate inlined data references, etc.)
572 //      set_metadata imm, reg
573 //      == sethi %hi22(imm), reg; nop; add reg, %lo10(imm), reg
574 //
575 // Note that it is identical to NativeMovConstReg with the exception of a nop between the
576 // sethi and the add.  The nop is required to be in the delay slot of the call instruction
577 // which overwrites the sethi during patching.
578 class NativeMovConstRegPatching;
<span class="line-modified">579 inline NativeMovConstRegPatching* nativeMovConstRegPatching_at(address address);class NativeMovConstRegPatching: public NativeInstruction {</span>

580  public:
581   enum Sparc_specific_constants {
582     sethi_offset           = 0,
583     nop_offset             = 7 * BytesPerInstWord,
584     add_offset             = nop_offset   + BytesPerInstWord,
585     instruction_size       = add_offset   + BytesPerInstWord
586   };
587 
588   address instruction_address() const       { return addr_at(0); }
589   address next_instruction_address() const  { return addr_at(instruction_size); }
590 
591   // (The [set_]data accessor respects oop_type relocs also.)
592   int data() const;
593   void  set_data(int x);
594 
595   // report the destination register
596   Register destination() { return inv_rd(long_at(sethi_offset)); }
597 
598   void  verify();
599   void  print();
</pre>
<hr />
<pre>
647                   1 &lt;&lt; Assembler::sth_op3 |
648                   1 &lt;&lt; Assembler::std_op3 |
649                   1 &lt;&lt; Assembler::stx_op3,
650     op3_ldst_int_limit = Assembler::ldf_op3,
651     op3_mask_ldf = 1 &lt;&lt; (Assembler::ldf_op3  - op3_ldst_int_limit) |
652                    1 &lt;&lt; (Assembler::lddf_op3 - op3_ldst_int_limit),
653     op3_mask_stf = 1 &lt;&lt; (Assembler::stf_op3  - op3_ldst_int_limit) |
654                    1 &lt;&lt; (Assembler::stdf_op3 - op3_ldst_int_limit),
655 
656     offset_width    = 13,
657     sethi_offset    = 0,
658     add_offset      = 7 * BytesPerInstWord,
659     ldst_offset     = add_offset + BytesPerInstWord
660   };
661   bool is_immediate() const {
662     // check if instruction is ld* [reg + offset], reg or st* reg, [reg + offset]
663     int i0 = long_at(0);
664     return (is_op(i0, Assembler::ldst_op));
665   }
666 
<span class="line-modified">667   address instruction_address() const           { return addr_at(0); }</span>
<span class="line-modified">668   address next_instruction_address() const      {</span>
<span class="line-modified">669     return addr_at(is_immediate() ? 4 : (7 * BytesPerInstWord));</span>


670   }

671   intptr_t   offset() const                             {
672      return is_immediate()? inv_simm(long_at(0), offset_width) :
673                             nativeMovConstReg_at(addr_at(0))-&gt;data();
674   }
675   void  set_offset(intptr_t x) {
676     if (is_immediate()) {
677       guarantee(fits_in_simm(x, offset_width), &quot;data block offset overflow&quot;);
678       set_long_at(0, set_simm(long_at(0), x, offset_width));
679     } else
680       nativeMovConstReg_at(addr_at(0))-&gt;set_data(x);
681   }
682 
683   void  add_offset_in_bytes(intptr_t radd_offset)     {
684       set_offset (offset() + radd_offset);
685   }
686 
<span class="line-removed">687   void  copy_instruction_to(address new_instruction_address);</span>
<span class="line-removed">688 </span>
689   void verify();
690   void print ();
691 
692   // unit test stuff
693   static void test();
694 
695  private:
696   friend inline NativeMovRegMem* nativeMovRegMem_at (address address) {
697     NativeMovRegMem* test = (NativeMovRegMem*)address;
698     #ifdef ASSERT
699       test-&gt;verify();
700     #endif
701     return test;
702   }
703 };
704 
705 
706 // An interface for accessing/manipulating native jumps
707 //      jump_to addr
708 //      == sethi %hi22(addr), temp ;  jumpl reg, %lo10(addr), G0 ;  &lt;delay&gt;
</pre>
</td>
<td>
<hr />
<pre>
298 };
299 
300 inline NativeInstruction* nativeInstruction_at(address address) {
301     NativeInstruction* inst = (NativeInstruction*)address;
302 #ifdef ASSERT
303       inst-&gt;verify();
304 #endif
305     return inst;
306 }
307 
308 
309 
310 //-----------------------------------------------------------------------------
311 
312 // The NativeCall is an abstraction for accessing/manipulating native call imm32 instructions.
313 // (used to manipulate inline caches, primitive &amp; dll calls, etc.)
314 class NativeCall;
315 
316 inline NativeCall* nativeCall_at(address instr);
317 inline NativeCall* nativeCall_overwriting_at(address instr,
<span class="line-modified">318                                              address destination = NULL);</span>
319 inline NativeCall* nativeCall_before(address return_address);
320 class NativeCall: public NativeInstruction {
321  public:
322   enum Sparc_specific_constants {
323     instruction_size                   = 8,
324     return_address_offset              = 8,
325     call_displacement_width            = 30,
326     displacement_offset                = 0,
327     instruction_offset                 = 0
328   };
329   address instruction_address() const       { return addr_at(0); }
330   address next_instruction_address() const  { return addr_at(instruction_size); }
331   address return_address() const            { return addr_at(return_address_offset); }
332 
333   address destination() const               { return inv_wdisp(long_at(0), call_displacement_width) + instruction_address(); }
334   address displacement_address() const      { return addr_at(displacement_offset); }
335   void  set_destination(address dest)       { set_long_at(0, set_wdisp(long_at(0), dest - instruction_address(), call_displacement_width)); }
336   void  set_destination_mt_safe(address dest);
337 
338   void  verify_alignment() {} // do nothing on sparc
339   void  verify();
340   void  print();
341 
342   // unit test stuff
343   static void  test();
344 
345   // Creation
346   friend inline NativeCall* nativeCall_at(address instr);
<span class="line-modified">347   friend NativeCall* nativeCall_overwriting_at(address instr, address destination) {</span>
348     // insert a &quot;blank&quot; call:
349     NativeCall* call = (NativeCall*)instr;
350     call-&gt;set_long_at(0 * BytesPerInstWord, call_instruction(destination, instr));
351     call-&gt;set_long_at(1 * BytesPerInstWord, nop_instruction());
352     assert(call-&gt;addr_at(2 * BytesPerInstWord) - instr == instruction_size, &quot;instruction size&quot;);
353     // check its structure now:
354     assert(nativeCall_at(instr)-&gt;destination() == destination, &quot;correct call destination&quot;);
355     return call;
356   }
357 
358   friend inline NativeCall* nativeCall_before(address return_address) {
359     NativeCall* call = (NativeCall*)(return_address - return_address_offset);
360     #ifdef ASSERT
361       call-&gt;verify();
362     #endif
363     return call;
364   }
365 
366   static bool is_call_at(address instr) {
367     return nativeInstruction_at(instr)-&gt;is_call();
</pre>
<hr />
<pre>
396   enum Sparc_specific_constants {
397     instruction_size      = 8,
398     return_address_offset = 8,
399     instruction_offset    = 0
400   };
401 
402   address next_instruction_address() const {
403     return addr_at(instruction_size);
404   }
405 };
406 
407 // The NativeFarCall is an abstraction for accessing/manipulating native call-anywhere
408 // instructions in the sparcv9 vm.  Used to call native methods which may be loaded
409 // anywhere in the address space, possibly out of reach of a call instruction.
410 
411 // The format of this extended-range call is:
412 //      jumpl_to addr, lreg
413 //      == sethi %hi54(addr), O7 ;  jumpl O7, %lo10(addr), O7 ;  &lt;delay&gt;
414 // That is, it is essentially the same as a NativeJump.
415 class NativeFarCall;
<span class="line-modified">416 inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination = NULL);</span>
417 inline NativeFarCall* nativeFarCall_at(address instr);
418 class NativeFarCall: public NativeInstruction {
419  public:
420   enum Sparc_specific_constants {
421     // instruction_size includes the delay slot instruction.
422     instruction_size                   = 9 * BytesPerInstWord,
423     return_address_offset              = 9 * BytesPerInstWord,
424     jmpl_offset                        = 7 * BytesPerInstWord,
425     displacement_offset                = 0,
426     instruction_offset                 = 0
427   };
428   address instruction_address() const       { return addr_at(0); }
429   address next_instruction_address() const  { return addr_at(instruction_size); }
430   address return_address() const            { return addr_at(return_address_offset); }
431 
432   address destination() const {
433     return (address) data64(addr_at(0), long_at(jmpl_offset));
434   }
435   address displacement_address() const      { return addr_at(displacement_offset); }
436   void set_destination(address dest);
437 
438   bool destination_is_compiled_verified_entry_point();
439 
440   void  verify();
441   void  print();
442 
443   // unit test stuff
444   static void  test();
445 
446   // Creation
447   friend inline NativeFarCall* nativeFarCall_at(address instr) {
448     NativeFarCall* call = (NativeFarCall*)instr;
449     #ifdef ASSERT
450       call-&gt;verify();
451     #endif
452     return call;
453   }
454 
<span class="line-modified">455   friend inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination) {</span>
456     Unimplemented();
457     NativeFarCall* call = (NativeFarCall*)instr;
458     return call;
459   }
460 
461   friend NativeFarCall* nativeFarCall_before(address return_address) {
462     NativeFarCall* call = (NativeFarCall*)(return_address - return_address_offset);
463     #ifdef ASSERT
464       call-&gt;verify();
465     #endif
466     return call;
467   }
468 
469   static bool is_call_at(address instr);
470 
471   // MT-safe patching of a call instruction.
472   static void insert(address code_pos, address entry) {
473     (void)nativeFarCall_overwriting_at(code_pos, entry);
474   }
475   static void replace_mt_safe(address instr_addr, address code_buffer);
</pre>
<hr />
<pre>
559   friend NativeMovConstReg* nativeMovConstReg_before(address address) {
560     NativeMovConstReg* test = (NativeMovConstReg*)(address - instruction_size);
561     #ifdef ASSERT
562       test-&gt;verify();
563     #endif
564     return test;
565   }
566 
567 };
568 
569 
570 // An interface for accessing/manipulating native set_metadata imm, reg instructions.
571 // (used to manipulate inlined data references, etc.)
572 //      set_metadata imm, reg
573 //      == sethi %hi22(imm), reg; nop; add reg, %lo10(imm), reg
574 //
575 // Note that it is identical to NativeMovConstReg with the exception of a nop between the
576 // sethi and the add.  The nop is required to be in the delay slot of the call instruction
577 // which overwrites the sethi during patching.
578 class NativeMovConstRegPatching;
<span class="line-modified">579 inline NativeMovConstRegPatching* nativeMovConstRegPatching_at(address address);</span>
<span class="line-added">580 class NativeMovConstRegPatching: public NativeInstruction {</span>
581  public:
582   enum Sparc_specific_constants {
583     sethi_offset           = 0,
584     nop_offset             = 7 * BytesPerInstWord,
585     add_offset             = nop_offset   + BytesPerInstWord,
586     instruction_size       = add_offset   + BytesPerInstWord
587   };
588 
589   address instruction_address() const       { return addr_at(0); }
590   address next_instruction_address() const  { return addr_at(instruction_size); }
591 
592   // (The [set_]data accessor respects oop_type relocs also.)
593   int data() const;
594   void  set_data(int x);
595 
596   // report the destination register
597   Register destination() { return inv_rd(long_at(sethi_offset)); }
598 
599   void  verify();
600   void  print();
</pre>
<hr />
<pre>
648                   1 &lt;&lt; Assembler::sth_op3 |
649                   1 &lt;&lt; Assembler::std_op3 |
650                   1 &lt;&lt; Assembler::stx_op3,
651     op3_ldst_int_limit = Assembler::ldf_op3,
652     op3_mask_ldf = 1 &lt;&lt; (Assembler::ldf_op3  - op3_ldst_int_limit) |
653                    1 &lt;&lt; (Assembler::lddf_op3 - op3_ldst_int_limit),
654     op3_mask_stf = 1 &lt;&lt; (Assembler::stf_op3  - op3_ldst_int_limit) |
655                    1 &lt;&lt; (Assembler::stdf_op3 - op3_ldst_int_limit),
656 
657     offset_width    = 13,
658     sethi_offset    = 0,
659     add_offset      = 7 * BytesPerInstWord,
660     ldst_offset     = add_offset + BytesPerInstWord
661   };
662   bool is_immediate() const {
663     // check if instruction is ld* [reg + offset], reg or st* reg, [reg + offset]
664     int i0 = long_at(0);
665     return (is_op(i0, Assembler::ldst_op));
666   }
667 
<span class="line-modified">668   address instruction_address() const { return addr_at(0); }</span>
<span class="line-modified">669 </span>
<span class="line-modified">670   int num_bytes_to_end_of_patch() const {</span>
<span class="line-added">671     return is_immediate()? BytesPerInstWord :</span>
<span class="line-added">672                            NativeMovConstReg::instruction_size;</span>
673   }
<span class="line-added">674 </span>
675   intptr_t   offset() const                             {
676      return is_immediate()? inv_simm(long_at(0), offset_width) :
677                             nativeMovConstReg_at(addr_at(0))-&gt;data();
678   }
679   void  set_offset(intptr_t x) {
680     if (is_immediate()) {
681       guarantee(fits_in_simm(x, offset_width), &quot;data block offset overflow&quot;);
682       set_long_at(0, set_simm(long_at(0), x, offset_width));
683     } else
684       nativeMovConstReg_at(addr_at(0))-&gt;set_data(x);
685   }
686 
687   void  add_offset_in_bytes(intptr_t radd_offset)     {
688       set_offset (offset() + radd_offset);
689   }
690 


691   void verify();
692   void print ();
693 
694   // unit test stuff
695   static void test();
696 
697  private:
698   friend inline NativeMovRegMem* nativeMovRegMem_at (address address) {
699     NativeMovRegMem* test = (NativeMovRegMem*)address;
700     #ifdef ASSERT
701       test-&gt;verify();
702     #endif
703     return test;
704   }
705 };
706 
707 
708 // An interface for accessing/manipulating native jumps
709 //      jump_to addr
710 //      == sethi %hi22(addr), temp ;  jumpl reg, %lo10(addr), G0 ;  &lt;delay&gt;
</pre>
</td>
</tr>
</table>
<center><a href="nativeInst_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="relocInfo_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
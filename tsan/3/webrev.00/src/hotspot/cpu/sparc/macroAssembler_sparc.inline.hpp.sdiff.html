<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/macroAssembler_sparc.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/macroAssembler_sparc.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
261   // Is this address within range of the call instruction?
262   // If not, use the expensive instruction sequence
263   if (is_far_target(d)) {
264     relocate(rspec);
265     AddressLiteral dest(d);
266     jumpl_to(dest, O7, O7);
267   } else {
268     Assembler::call(d, rspec);
269   }
270 }
271 
272 inline void MacroAssembler::call( Label&amp; L, relocInfo::relocType rt ) {
273   avoid_pipeline_stall();
274   MacroAssembler::call(target(L), rt);
275 }
276 
277 
278 inline void MacroAssembler::callr( Register s1, Register s2 ) { jmpl( s1, s2, O7 ); }
279 inline void MacroAssembler::callr( Register s1, int simm13a, RelocationHolder const&amp; rspec ) { jmpl( s1, simm13a, O7, rspec); }
280 
<span class="line-removed">281 // prefetch instruction</span>
<span class="line-removed">282 inline void MacroAssembler::iprefetch( address d, relocInfo::relocType rt ) {</span>
<span class="line-removed">283   Assembler::bp( never, true, xcc, pt, d, rt );</span>
<span class="line-removed">284     Assembler::bp( never, true, xcc, pt, d, rt );</span>
<span class="line-removed">285 }</span>
<span class="line-removed">286 inline void MacroAssembler::iprefetch( Label&amp; L) { iprefetch( target(L) ); }</span>
<span class="line-removed">287 </span>
288 inline void MacroAssembler::tst( Register s ) { orcc( G0, s, G0 ); }
289 
290 inline void MacroAssembler::ret( bool trace ) {
291   if (trace) {
292     mov(I7, O7); // traceable register
293     JMP(O7, 2 * BytesPerInstWord);
294   } else {
295     jmpl( I7, 2 * BytesPerInstWord, G0 );
296   }
297 }
298 
299 inline void MacroAssembler::retl( bool trace ) {
300   if (trace) {
301     JMP(O7, 2 * BytesPerInstWord);
302   } else {
303     jmpl( O7, 2 * BytesPerInstWord, G0 );
304   }
305 }
306 
307 
</pre>
</td>
<td>
<hr />
<pre>
261   // Is this address within range of the call instruction?
262   // If not, use the expensive instruction sequence
263   if (is_far_target(d)) {
264     relocate(rspec);
265     AddressLiteral dest(d);
266     jumpl_to(dest, O7, O7);
267   } else {
268     Assembler::call(d, rspec);
269   }
270 }
271 
272 inline void MacroAssembler::call( Label&amp; L, relocInfo::relocType rt ) {
273   avoid_pipeline_stall();
274   MacroAssembler::call(target(L), rt);
275 }
276 
277 
278 inline void MacroAssembler::callr( Register s1, Register s2 ) { jmpl( s1, s2, O7 ); }
279 inline void MacroAssembler::callr( Register s1, int simm13a, RelocationHolder const&amp; rspec ) { jmpl( s1, simm13a, O7, rspec); }
280 







281 inline void MacroAssembler::tst( Register s ) { orcc( G0, s, G0 ); }
282 
283 inline void MacroAssembler::ret( bool trace ) {
284   if (trace) {
285     mov(I7, O7); // traceable register
286     JMP(O7, 2 * BytesPerInstWord);
287   } else {
288     jmpl( I7, 2 * BytesPerInstWord, G0 );
289   }
290 }
291 
292 inline void MacroAssembler::retl( bool trace ) {
293   if (trace) {
294     JMP(O7, 2 * BytesPerInstWord);
295   } else {
296     jmpl( O7, 2 * BytesPerInstWord, G0 );
297   }
298 }
299 
300 
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/sparc/c1_LIRAssembler_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.inline.hpp&quot;
  27 #include &quot;c1/c1_Compilation.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  30 #include &quot;c1/c1_Runtime1.hpp&quot;
  31 #include &quot;c1/c1_ValueStack.hpp&quot;
  32 #include &quot;ci/ciArrayKlass.hpp&quot;
  33 #include &quot;ci/ciInstance.hpp&quot;
  34 #include &quot;gc/shared/barrierSet.hpp&quot;
  35 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  36 #include &quot;gc/shared/collectedHeap.hpp&quot;
  37 #include &quot;nativeInst_sparc.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  41 #include &quot;runtime/jniHandles.inline.hpp&quot;
  42 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  43 #include &quot;runtime/sharedRuntime.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 
  48 //------------------------------------------------------------
  49 
  50 
  51 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  52   if (opr-&gt;is_constant()) {
  53     LIR_Const* constant = opr-&gt;as_constant_ptr();
  54     switch (constant-&gt;type()) {
  55       case T_INT: {
  56         jint value = constant-&gt;as_jint();
  57         return Assembler::is_simm13(value);
  58       }
  59 
  60       default:
  61         return false;
  62     }
  63   }
  64   return false;
  65 }
  66 
  67 
  68 bool LIR_Assembler::is_single_instruction(LIR_Op* op) {
  69   switch (op-&gt;code()) {
  70     case lir_null_check:
  71     return true;
  72 
  73 
  74     case lir_add:
  75     case lir_ushr:
  76     case lir_shr:
  77     case lir_shl:
  78       // integer shifts and adds are always one instruction
  79       return op-&gt;result_opr()-&gt;is_single_cpu();
  80 
  81 
  82     case lir_move: {
  83       LIR_Op1* op1 = op-&gt;as_Op1();
  84       LIR_Opr src = op1-&gt;in_opr();
  85       LIR_Opr dst = op1-&gt;result_opr();
  86 
  87       if (src == dst) {
  88         NEEDS_CLEANUP;
  89         // this works around a problem where moves with the same src and dst
  90         // end up in the delay slot and then the assembler swallows the mov
  91         // since it has no effect and then it complains because the delay slot
  92         // is empty.  returning false stops the optimizer from putting this in
  93         // the delay slot
  94         return false;
  95       }
  96 
  97       // don&#39;t put moves involving oops into the delay slot since the VerifyOops code
  98       // will make it much larger than a single instruction.
  99       if (VerifyOops) {
 100         return false;
 101       }
 102 
 103       if (src-&gt;is_double_cpu() || dst-&gt;is_double_cpu() || op1-&gt;patch_code() != lir_patch_none ||
 104           ((src-&gt;is_double_fpu() || dst-&gt;is_double_fpu()) &amp;&amp; op1-&gt;move_kind() != lir_move_normal)) {
 105         return false;
 106       }
 107 
 108       if (UseCompressedOops) {
 109         if (dst-&gt;is_address() &amp;&amp; !dst-&gt;is_stack() &amp;&amp; (dst-&gt;type() == T_OBJECT || dst-&gt;type() == T_ARRAY)) return false;
 110         if (src-&gt;is_address() &amp;&amp; !src-&gt;is_stack() &amp;&amp; (src-&gt;type() == T_OBJECT || src-&gt;type() == T_ARRAY)) return false;
 111       }
 112 
 113       if (UseCompressedClassPointers) {
 114         if (src-&gt;is_address() &amp;&amp; !src-&gt;is_stack() &amp;&amp; src-&gt;type() == T_ADDRESS &amp;&amp;
 115             src-&gt;as_address_ptr()-&gt;disp() == oopDesc::klass_offset_in_bytes()) return false;
 116       }
 117 
 118       if (dst-&gt;is_register()) {
 119         if (src-&gt;is_address() &amp;&amp; Assembler::is_simm13(src-&gt;as_address_ptr()-&gt;disp())) {
 120           return !PatchALot;
 121         } else if (src-&gt;is_single_stack()) {
 122           return true;
 123         }
 124       }
 125 
 126       if (src-&gt;is_register()) {
 127         if (dst-&gt;is_address() &amp;&amp; Assembler::is_simm13(dst-&gt;as_address_ptr()-&gt;disp())) {
 128           return !PatchALot;
 129         } else if (dst-&gt;is_single_stack()) {
 130           return true;
 131         }
 132       }
 133 
 134       if (dst-&gt;is_register() &amp;&amp;
 135           ((src-&gt;is_register() &amp;&amp; src-&gt;is_single_word() &amp;&amp; src-&gt;is_same_type(dst)) ||
 136            (src-&gt;is_constant() &amp;&amp; LIR_Assembler::is_small_constant(op-&gt;as_Op1()-&gt;in_opr())))) {
 137         return true;
 138       }
 139 
 140       return false;
 141     }
 142 
 143     default:
 144       return false;
 145   }
 146   ShouldNotReachHere();
 147 }
 148 
 149 
 150 LIR_Opr LIR_Assembler::receiverOpr() {
 151   return FrameMap::O0_oop_opr;
 152 }
 153 
 154 
 155 LIR_Opr LIR_Assembler::osrBufferPointer() {
 156   return FrameMap::I0_opr;
 157 }
 158 
 159 
 160 int LIR_Assembler::initial_frame_size_in_bytes() const {
 161   return in_bytes(frame_map()-&gt;framesize_in_bytes());
 162 }
 163 
 164 
 165 // inline cache check: the inline cached class is in G5_inline_cache_reg(G5);
 166 // we fetch the class of the receiver (O0) and compare it with the cached class.
 167 // If they do not match we jump to slow case.
 168 int LIR_Assembler::check_icache() {
 169   int offset = __ offset();
 170   __ inline_cache_check(O0, G5_inline_cache_reg);
 171   return offset;
 172 }
 173 
 174 
 175 void LIR_Assembler::osr_entry() {
 176   // On-stack-replacement entry sequence (interpreter frame layout described in interpreter_sparc.cpp):
 177   //
 178   //   1. Create a new compiled activation.
 179   //   2. Initialize local variables in the compiled activation.  The expression stack must be empty
 180   //      at the osr_bci; it is not initialized.
 181   //   3. Jump to the continuation address in compiled code to resume execution.
 182 
 183   // OSR entry point
 184   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 185   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 186   ValueStack* entry_state = osr_entry-&gt;end()-&gt;state();
 187   int number_of_locks = entry_state-&gt;locks_size();
 188 
 189   // Create a frame for the compiled activation.
 190   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 191 
 192   // OSR buffer is
 193   //
 194   // locals[nlocals-1..0]
 195   // monitors[number_of_locks-1..0]
 196   //
 197   // locals is a direct copy of the interpreter frame so in the osr buffer
 198   // so first slot in the local array is the last local from the interpreter
 199   // and last slot is local[0] (receiver) from the interpreter
 200   //
 201   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 202   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 203   // in the interpreter frame (the method lock if a sync method)
 204 
 205   // Initialize monitors in the compiled activation.
 206   //   I0: pointer to osr buffer
 207   //
 208   // All other registers are dead at this point and the locals will be
 209   // copied into place by code emitted in the IR.
 210 
 211   Register OSR_buf = osrBufferPointer()-&gt;as_register();
 212   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 213     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 214       (2 * BytesPerWord) * (number_of_locks - 1);
 215     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 216     // the OSR buffer using 2 word entries: first the lock and then
 217     // the oop.
 218     for (int i = 0; i &lt; number_of_locks; i++) {
 219       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 220 #ifdef ASSERT
 221       // verify the interpreter&#39;s monitor has a non-null object
 222       {
 223         Label L;
 224         __ ld_ptr(OSR_buf, slot_offset + 1*BytesPerWord, O7);
 225         __ cmp_and_br_short(O7, G0, Assembler::notEqual, Assembler::pt, L);
 226         __ stop(&quot;locked object is NULL&quot;);
 227         __ bind(L);
 228       }
 229 #endif // ASSERT
 230       // Copy the lock field into the compiled activation.
 231       __ ld_ptr(OSR_buf, slot_offset + 0, O7);
 232       __ st_ptr(O7, frame_map()-&gt;address_for_monitor_lock(i));
 233       __ ld_ptr(OSR_buf, slot_offset + 1*BytesPerWord, O7);
 234       __ st_ptr(O7, frame_map()-&gt;address_for_monitor_object(i));
 235     }
 236   }
 237 }
 238 
 239 
 240 // --------------------------------------------------------------------------------------------
 241 
 242 void LIR_Assembler::monitorexit(LIR_Opr obj_opr, LIR_Opr lock_opr, Register hdr, int monitor_no) {
 243   if (!GenerateSynchronizationCode) return;
 244 
 245   Register obj_reg = obj_opr-&gt;as_register();
 246   Register lock_reg = lock_opr-&gt;as_register();
 247 
 248   Address mon_addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
 249   Register reg = mon_addr.base();
 250   int offset = mon_addr.disp();
 251   // compute pointer to BasicLock
 252   if (mon_addr.is_simm13()) {
 253     __ add(reg, offset, lock_reg);
 254   }
 255   else {
 256     __ set(offset, lock_reg);
 257     __ add(reg, lock_reg, lock_reg);
 258   }
 259   // unlock object
 260   MonitorAccessStub* slow_case = new MonitorExitStub(lock_opr, UseFastLocking, monitor_no);
 261   // _slow_case_stubs-&gt;append(slow_case);
 262   // temporary fix: must be created after exceptionhandler, therefore as call stub
 263   _slow_case_stubs-&gt;append(slow_case);
 264   if (UseFastLocking) {
 265     // try inlined fast unlocking first, revert to slow locking if it fails
 266     // note: lock_reg points to the displaced header since the displaced header offset is 0!
 267     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
 268     __ unlock_object(hdr, obj_reg, lock_reg, *slow_case-&gt;entry());
 269   } else {
 270     // always do slow unlocking
 271     // note: the slow unlocking code could be inlined here, however if we use
 272     //       slow unlocking, speed doesn&#39;t matter anyway and this solution is
 273     //       simpler and requires less duplicated code - additionally, the
 274     //       slow unlocking code is the same in either case which simplifies
 275     //       debugging
 276     __ br(Assembler::always, false, Assembler::pt, *slow_case-&gt;entry());
 277     __ delayed()-&gt;nop();
 278   }
 279   // done
 280   __ bind(*slow_case-&gt;continuation());
 281 }
 282 
 283 
 284 int LIR_Assembler::emit_exception_handler() {
 285   // if the last instruction is a call (typically to do a throw which
 286   // is coming at the end after block reordering) the return address
 287   // must still point into the code area in order to avoid assertion
 288   // failures when searching for the corresponding bci =&gt; add a nop
 289   // (was bug 5/14/1999 - gri)
 290   __ nop();
 291 
 292   // generate code for exception handler
 293   ciMethod* method = compilation()-&gt;method();
 294 
 295   address handler_base = __ start_a_stub(exception_handler_size());
 296 
 297   if (handler_base == NULL) {
 298     // not enough space left for the handler
 299     bailout(&quot;exception handler overflow&quot;);
 300     return -1;
 301   }
 302 
 303   int offset = code_offset();
 304 
 305   __ call(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id), relocInfo::runtime_call_type);
 306   __ delayed()-&gt;nop();
 307   __ should_not_reach_here();
 308   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 309   __ end_a_stub();
 310 
 311   return offset;
 312 }
 313 
 314 
 315 // Emit the code to remove the frame from the stack in the exception
 316 // unwind path.
 317 int LIR_Assembler::emit_unwind_handler() {
 318 #ifndef PRODUCT
 319   if (CommentedAssembly) {
 320     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 321   }
 322 #endif
 323 
 324   int offset = code_offset();
 325 
 326   // Fetch the exception from TLS and clear out exception related thread state
 327   __ ld_ptr(G2_thread, in_bytes(JavaThread::exception_oop_offset()), O0);
 328   __ st_ptr(G0, G2_thread, in_bytes(JavaThread::exception_oop_offset()));
 329   __ st_ptr(G0, G2_thread, in_bytes(JavaThread::exception_pc_offset()));
 330 
 331   __ bind(_unwind_handler_entry);
 332   __ verify_not_null_oop(O0);
 333   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 334     __ mov(O0, I0);  // Preserve the exception
 335   }
 336 
 337   // Preform needed unlocking
 338   MonitorExitStub* stub = NULL;
 339   if (method()-&gt;is_synchronized()) {
 340     monitor_address(0, FrameMap::I1_opr);
 341     stub = new MonitorExitStub(FrameMap::I1_opr, true, 0);
 342     __ unlock_object(I3, I2, I1, *stub-&gt;entry());
 343     __ bind(*stub-&gt;continuation());
 344   }
 345 
 346   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 347     __ mov(G2_thread, O0);
 348     __ save_thread(I1); // need to preserve thread in G2 across
 349                         // runtime call
 350     metadata2reg(method()-&gt;constant_encoding(), O1);
 351     __ call(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), relocInfo::runtime_call_type);
 352     __ delayed()-&gt;nop();
 353     __ restore_thread(I1);
 354   }
 355 
 356   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 357     __ mov(I0, O0);  // Restore the exception
 358   }
 359 
 360   // dispatch to the unwind logic
 361   __ call(Runtime1::entry_for(Runtime1::unwind_exception_id), relocInfo::runtime_call_type);
 362   __ delayed()-&gt;nop();
 363 
 364   // Emit the slow path assembly
 365   if (stub != NULL) {
 366     stub-&gt;emit_code(this);
 367   }
 368 
 369   return offset;
 370 }
 371 
 372 
 373 int LIR_Assembler::emit_deopt_handler() {
 374   // if the last instruction is a call (typically to do a throw which
 375   // is coming at the end after block reordering) the return address
 376   // must still point into the code area in order to avoid assertion
 377   // failures when searching for the corresponding bci =&gt; add a nop
 378   // (was bug 5/14/1999 - gri)
 379   __ nop();
 380 
 381   // generate code for deopt handler
 382   ciMethod* method = compilation()-&gt;method();
 383   address handler_base = __ start_a_stub(deopt_handler_size());
 384   if (handler_base == NULL) {
 385     // not enough space left for the handler
 386     bailout(&quot;deopt handler overflow&quot;);
 387     return -1;
 388   }
 389 
 390   int offset = code_offset();
 391   AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
 392   __ JUMP(deopt_blob, G3_scratch, 0); // sethi;jmp
 393   __ delayed()-&gt;nop();
 394   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 395   __ end_a_stub();
 396 
 397   return offset;
 398 }
 399 
 400 
 401 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 402   if (o == NULL) {
 403     __ set(NULL_WORD, reg);
 404   } else {
 405 #ifdef ASSERT
 406     {
 407       ThreadInVMfromNative tiv(JavaThread::current());
 408       assert(Universe::heap()-&gt;is_in_reserved(JNIHandles::resolve(o)), &quot;should be real oop&quot;);
 409     }
 410 #endif
 411     int oop_index = __ oop_recorder()-&gt;find_index(o);
 412     RelocationHolder rspec = oop_Relocation::spec(oop_index);
 413     __ set(NULL_WORD, reg, rspec); // Will be set when the nmethod is created
 414   }
 415 }
 416 
 417 
 418 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 419   // Allocate a new index in table to hold the object once it&#39;s been patched
 420   int oop_index = __ oop_recorder()-&gt;allocate_oop_index(NULL);
 421   PatchingStub* patch = new PatchingStub(_masm, patching_id(info), oop_index);
 422 
 423   AddressLiteral addrlit(NULL, oop_Relocation::spec(oop_index));
 424   assert(addrlit.rspec().type() == relocInfo::oop_type, &quot;must be an oop reloc&quot;);
 425   // It may not seem necessary to use a sethi/add pair to load a NULL into dest, but the
 426   // NULL will be dynamically patched later and the patched value may be large.  We must
 427   // therefore generate the sethi/add as a placeholders
 428   __ patchable_set(addrlit, reg);
 429 
 430   patching_epilog(patch, lir_patch_normal, reg, info);
 431 }
 432 
 433 
 434 void LIR_Assembler::metadata2reg(Metadata* o, Register reg) {
 435   __ set_metadata_constant(o, reg);
 436 }
 437 
 438 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo *info) {
 439   // Allocate a new index in table to hold the klass once it&#39;s been patched
 440   int index = __ oop_recorder()-&gt;allocate_metadata_index(NULL);
 441   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id, index);
 442   AddressLiteral addrlit(NULL, metadata_Relocation::spec(index));
 443   assert(addrlit.rspec().type() == relocInfo::metadata_type, &quot;must be an metadata reloc&quot;);
 444   // It may not seem necessary to use a sethi/add pair to load a NULL into dest, but the
 445   // NULL will be dynamically patched later and the patched value may be large.  We must
 446   // therefore generate the sethi/add as a placeholders
 447   __ patchable_set(addrlit, reg);
 448 
 449   patching_epilog(patch, lir_patch_normal, reg, info);
 450 }
 451 
 452 void LIR_Assembler::emit_op3(LIR_Op3* op) {
 453   switch (op-&gt;code()) {
 454     case lir_idiv:
 455     case lir_irem:  // Both idiv &amp; irem are handled after the switch (below).
 456       break;
 457     case lir_fmaf:
 458       __ fmadd(FloatRegisterImpl::S,
 459                op-&gt;in_opr1()-&gt;as_float_reg(),
 460                op-&gt;in_opr2()-&gt;as_float_reg(),
 461                op-&gt;in_opr3()-&gt;as_float_reg(),
 462                op-&gt;result_opr()-&gt;as_float_reg());
 463       return;
 464     case lir_fmad:
 465       __ fmadd(FloatRegisterImpl::D,
 466                op-&gt;in_opr1()-&gt;as_double_reg(),
 467                op-&gt;in_opr2()-&gt;as_double_reg(),
 468                op-&gt;in_opr3()-&gt;as_double_reg(),
 469                op-&gt;result_opr()-&gt;as_double_reg());
 470       return;
 471     default:
 472       ShouldNotReachHere();
 473       break;
 474   }
 475 
 476   // Handle idiv &amp; irem:
 477 
 478   Register Rdividend = op-&gt;in_opr1()-&gt;as_register();
 479   Register Rdivisor  = noreg;
 480   Register Rscratch  = op-&gt;in_opr3()-&gt;as_register();
 481   Register Rresult   = op-&gt;result_opr()-&gt;as_register();
 482   int divisor = -1;
 483 
 484   if (op-&gt;in_opr2()-&gt;is_register()) {
 485     Rdivisor = op-&gt;in_opr2()-&gt;as_register();
 486   } else {
 487     divisor = op-&gt;in_opr2()-&gt;as_constant_ptr()-&gt;as_jint();
 488     assert(Assembler::is_simm13(divisor), &quot;can only handle simm13&quot;);
 489   }
 490 
 491   assert(Rdividend != Rscratch, &quot;&quot;);
 492   assert(Rdivisor  != Rscratch, &quot;&quot;);
 493   assert(op-&gt;code() == lir_idiv || op-&gt;code() == lir_irem, &quot;Must be irem or idiv&quot;);
 494 
 495   if (Rdivisor == noreg &amp;&amp; is_power_of_2(divisor)) {
 496     // convert division by a power of two into some shifts and logical operations
 497     if (op-&gt;code() == lir_idiv) {
 498       if (divisor == 2) {
 499         __ srl(Rdividend, 31, Rscratch);
 500       } else {
 501         __ sra(Rdividend, 31, Rscratch);
 502         __ and3(Rscratch, divisor - 1, Rscratch);
 503       }
 504       __ add(Rdividend, Rscratch, Rscratch);
 505       __ sra(Rscratch, log2_int(divisor), Rresult);
 506       return;
 507     } else {
 508       if (divisor == 2) {
 509         __ srl(Rdividend, 31, Rscratch);
 510       } else {
 511         __ sra(Rdividend, 31, Rscratch);
 512         __ and3(Rscratch, divisor - 1,Rscratch);
 513       }
 514       __ add(Rdividend, Rscratch, Rscratch);
 515       __ andn(Rscratch, divisor - 1,Rscratch);
 516       __ sub(Rdividend, Rscratch, Rresult);
 517       return;
 518     }
 519   }
 520 
 521   __ sra(Rdividend, 31, Rscratch);
 522   __ wry(Rscratch);
 523 
 524   add_debug_info_for_div0_here(op-&gt;info());
 525 
 526   if (Rdivisor != noreg) {
 527     __ sdivcc(Rdividend, Rdivisor, (op-&gt;code() == lir_idiv ? Rresult : Rscratch));
 528   } else {
 529     assert(Assembler::is_simm13(divisor), &quot;can only handle simm13&quot;);
 530     __ sdivcc(Rdividend, divisor, (op-&gt;code() == lir_idiv ? Rresult : Rscratch));
 531   }
 532 
 533   Label skip;
 534   __ br(Assembler::overflowSet, true, Assembler::pn, skip);
 535   __ delayed()-&gt;Assembler::sethi(0x80000000, (op-&gt;code() == lir_idiv ? Rresult : Rscratch));
 536   __ bind(skip);
 537 
 538   if (op-&gt;code() == lir_irem) {
 539     if (Rdivisor != noreg) {
 540       __ smul(Rscratch, Rdivisor, Rscratch);
 541     } else {
 542       __ smul(Rscratch, divisor, Rscratch);
 543     }
 544     __ sub(Rdividend, Rscratch, Rresult);
 545   }
 546 }
 547 
 548 
 549 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
 550 #ifdef ASSERT
 551   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
 552   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
 553   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
 554 #endif
 555   assert(op-&gt;info() == NULL, &quot;shouldn&#39;t have CodeEmitInfo&quot;);
 556 
 557   if (op-&gt;cond() == lir_cond_always) {
 558     __ br(Assembler::always, false, Assembler::pt, *(op-&gt;label()));
 559   } else if (op-&gt;code() == lir_cond_float_branch) {
 560     assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
 561     bool is_unordered = (op-&gt;ublock() == op-&gt;block());
 562     Assembler::Condition acond;
 563     switch (op-&gt;cond()) {
 564       case lir_cond_equal:         acond = Assembler::f_equal;    break;
 565       case lir_cond_notEqual:      acond = Assembler::f_notEqual; break;
 566       case lir_cond_less:          acond = (is_unordered ? Assembler::f_unorderedOrLess          : Assembler::f_less);           break;
 567       case lir_cond_greater:       acond = (is_unordered ? Assembler::f_unorderedOrGreater       : Assembler::f_greater);        break;
 568       case lir_cond_lessEqual:     acond = (is_unordered ? Assembler::f_unorderedOrLessOrEqual   : Assembler::f_lessOrEqual);    break;
 569       case lir_cond_greaterEqual:  acond = (is_unordered ? Assembler::f_unorderedOrGreaterOrEqual: Assembler::f_greaterOrEqual); break;
 570       default :                         ShouldNotReachHere();
 571     }
 572     __ fb( acond, false, Assembler::pn, *(op-&gt;label()));
 573   } else {
 574     assert (op-&gt;code() == lir_branch, &quot;just checking&quot;);
 575 
 576     Assembler::Condition acond;
 577     switch (op-&gt;cond()) {
 578       case lir_cond_equal:        acond = Assembler::equal;                break;
 579       case lir_cond_notEqual:     acond = Assembler::notEqual;             break;
 580       case lir_cond_less:         acond = Assembler::less;                 break;
 581       case lir_cond_lessEqual:    acond = Assembler::lessEqual;            break;
 582       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;         break;
 583       case lir_cond_greater:      acond = Assembler::greater;              break;
 584       case lir_cond_aboveEqual:   acond = Assembler::greaterEqualUnsigned; break;
 585       case lir_cond_belowEqual:   acond = Assembler::lessEqualUnsigned;    break;
 586       default:                         ShouldNotReachHere();
 587     };
 588 
 589     // sparc has different condition codes for testing 32-bit
 590     // vs. 64-bit values.  We could always test xcc is we could
 591     // guarantee that 32-bit loads always sign extended but that isn&#39;t
 592     // true and since sign extension isn&#39;t free, it would impose a
 593     // slight cost.
 594     if  (op-&gt;type() == T_INT) {
 595       __ br(acond, false, Assembler::pn, *(op-&gt;label()));
 596     } else
 597       __ brx(acond, false, Assembler::pn, *(op-&gt;label()));
 598   }
 599   // The peephole pass fills the delay slot
 600 }
 601 
 602 
 603 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
 604   Bytecodes::Code code = op-&gt;bytecode();
 605   LIR_Opr dst = op-&gt;result_opr();
 606 
 607   switch(code) {
 608     case Bytecodes::_i2l: {
 609       Register rlo  = dst-&gt;as_register_lo();
 610       Register rhi  = dst-&gt;as_register_hi();
 611       Register rval = op-&gt;in_opr()-&gt;as_register();
 612       __ sra(rval, 0, rlo);
 613       break;
 614     }
 615     case Bytecodes::_i2d:
 616     case Bytecodes::_i2f: {
 617       bool is_double = (code == Bytecodes::_i2d);
 618       FloatRegister rdst = is_double ? dst-&gt;as_double_reg() : dst-&gt;as_float_reg();
 619       FloatRegisterImpl::Width w = is_double ? FloatRegisterImpl::D : FloatRegisterImpl::S;
 620       FloatRegister rsrc = op-&gt;in_opr()-&gt;as_float_reg();
 621       if (rsrc != rdst) {
 622         __ fmov(FloatRegisterImpl::S, rsrc, rdst);
 623       }
 624       __ fitof(w, rdst, rdst);
 625       break;
 626     }
 627     case Bytecodes::_f2i:{
 628       FloatRegister rsrc = op-&gt;in_opr()-&gt;as_float_reg();
 629       Address       addr = frame_map()-&gt;address_for_slot(dst-&gt;single_stack_ix());
 630       Label L;
 631       // result must be 0 if value is NaN; test by comparing value to itself
 632       __ fcmp(FloatRegisterImpl::S, Assembler::fcc0, rsrc, rsrc);
 633       __ fb(Assembler::f_unordered, true, Assembler::pn, L);
 634       __ delayed()-&gt;st(G0, addr); // annuled if contents of rsrc is not NaN
 635       __ ftoi(FloatRegisterImpl::S, rsrc, rsrc);
 636       // move integer result from float register to int register
 637       __ stf(FloatRegisterImpl::S, rsrc, addr.base(), addr.disp());
 638       __ bind (L);
 639       break;
 640     }
 641     case Bytecodes::_l2i: {
 642       Register rlo  = op-&gt;in_opr()-&gt;as_register_lo();
 643       Register rhi  = op-&gt;in_opr()-&gt;as_register_hi();
 644       Register rdst = dst-&gt;as_register();
 645       __ sra(rlo, 0, rdst);
 646       break;
 647     }
 648     case Bytecodes::_d2f:
 649     case Bytecodes::_f2d: {
 650       bool is_double = (code == Bytecodes::_f2d);
 651       assert((!is_double &amp;&amp; dst-&gt;is_single_fpu()) || (is_double &amp;&amp; dst-&gt;is_double_fpu()), &quot;check&quot;);
 652       LIR_Opr val = op-&gt;in_opr();
 653       FloatRegister rval = (code == Bytecodes::_d2f) ? val-&gt;as_double_reg() : val-&gt;as_float_reg();
 654       FloatRegister rdst = is_double ? dst-&gt;as_double_reg() : dst-&gt;as_float_reg();
 655       FloatRegisterImpl::Width vw = is_double ? FloatRegisterImpl::S : FloatRegisterImpl::D;
 656       FloatRegisterImpl::Width dw = is_double ? FloatRegisterImpl::D : FloatRegisterImpl::S;
 657       __ ftof(vw, dw, rval, rdst);
 658       break;
 659     }
 660     case Bytecodes::_i2s:
 661     case Bytecodes::_i2b: {
 662       Register rval = op-&gt;in_opr()-&gt;as_register();
 663       Register rdst = dst-&gt;as_register();
 664       int shift = (code == Bytecodes::_i2b) ? (BitsPerInt - T_BYTE_aelem_bytes * BitsPerByte) : (BitsPerInt - BitsPerShort);
 665       __ sll (rval, shift, rdst);
 666       __ sra (rdst, shift, rdst);
 667       break;
 668     }
 669     case Bytecodes::_i2c: {
 670       Register rval = op-&gt;in_opr()-&gt;as_register();
 671       Register rdst = dst-&gt;as_register();
 672       int shift = BitsPerInt - T_CHAR_aelem_bytes * BitsPerByte;
 673       __ sll (rval, shift, rdst);
 674       __ srl (rdst, shift, rdst);
 675       break;
 676     }
 677 
 678     default: ShouldNotReachHere();
 679   }
 680 }
 681 
 682 
 683 void LIR_Assembler::align_call(LIR_Code) {
 684   // do nothing since all instructions are word aligned on sparc
 685 }
 686 
 687 
 688 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
 689   __ call(op-&gt;addr(), rtype);
 690   // The peephole pass fills the delay slot, add_call_info is done in
 691   // LIR_Assembler::emit_delay.
 692 }
 693 
 694 
 695 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
 696   __ ic_call(op-&gt;addr(), false);
 697   // The peephole pass fills the delay slot, add_call_info is done in
 698   // LIR_Assembler::emit_delay.
 699 }
 700 
 701 
 702 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
 703   add_debug_info_for_null_check_here(op-&gt;info());
 704   __ load_klass(O0, G3_scratch);
 705   if (Assembler::is_simm13(op-&gt;vtable_offset())) {
 706     __ ld_ptr(G3_scratch, op-&gt;vtable_offset(), G5_method);
 707   } else {
 708     // This will generate 2 instructions
 709     __ set(op-&gt;vtable_offset(), G5_method);
 710     // ld_ptr, set_hi, set
 711     __ ld_ptr(G3_scratch, G5_method, G5_method);
 712   }
 713   __ ld_ptr(G5_method, Method::from_compiled_offset(), G3_scratch);
 714   __ callr(G3_scratch, G0);
 715   // the peephole pass fills the delay slot
 716 }
 717 
 718 int LIR_Assembler::store(LIR_Opr from_reg, Register base, int offset, BasicType type, bool wide, bool unaligned) {
 719   int store_offset;
 720   if (!Assembler::is_simm13(offset + (type == T_LONG) ? wordSize : 0)) {
 721     assert(base != O7, &quot;destroying register&quot;);
 722     assert(!unaligned, &quot;can&#39;t handle this&quot;);
 723     // for offsets larger than a simm13 we setup the offset in O7
 724     __ set(offset, O7);
 725     store_offset = store(from_reg, base, O7, type, wide);
 726   } else {
 727     if (type == T_ARRAY || type == T_OBJECT) {
 728       __ verify_oop(from_reg-&gt;as_register());
 729     }
 730     store_offset = code_offset();
 731     switch (type) {
 732       case T_BOOLEAN: // fall through
 733       case T_BYTE  : __ stb(from_reg-&gt;as_register(), base, offset); break;
 734       case T_CHAR  : __ sth(from_reg-&gt;as_register(), base, offset); break;
 735       case T_SHORT : __ sth(from_reg-&gt;as_register(), base, offset); break;
 736       case T_INT   : __ stw(from_reg-&gt;as_register(), base, offset); break;
 737       case T_LONG  :
 738         if (unaligned || PatchALot) {
 739           // Don&#39;t use O7 here because it may be equal to &#39;base&#39; (see LIR_Assembler::reg2mem)
 740           assert(G3_scratch != base, &quot;can&#39;t handle this&quot;);
 741           assert(G3_scratch != from_reg-&gt;as_register_lo(), &quot;can&#39;t handle this&quot;);
 742           __ srax(from_reg-&gt;as_register_lo(), 32, G3_scratch);
 743           __ stw(from_reg-&gt;as_register_lo(), base, offset + lo_word_offset_in_bytes);
 744           __ stw(G3_scratch,                 base, offset + hi_word_offset_in_bytes);
 745         } else {
 746           __ stx(from_reg-&gt;as_register_lo(), base, offset);
 747         }
 748         break;
 749       case T_ADDRESS:
 750       case T_METADATA:
 751         __ st_ptr(from_reg-&gt;as_register(), base, offset);
 752         break;
 753       case T_ARRAY : // fall through
 754       case T_OBJECT:
 755         {
 756           if (UseCompressedOops &amp;&amp; !wide) {
 757             __ encode_heap_oop(from_reg-&gt;as_register(), G3_scratch);
 758             store_offset = code_offset();
 759             __ stw(G3_scratch, base, offset);
 760           } else {
 761             __ st_ptr(from_reg-&gt;as_register(), base, offset);
 762           }
 763           break;
 764         }
 765 
 766       case T_FLOAT : __ stf(FloatRegisterImpl::S, from_reg-&gt;as_float_reg(), base, offset); break;
 767       case T_DOUBLE:
 768         {
 769           FloatRegister reg = from_reg-&gt;as_double_reg();
 770           // split unaligned stores
 771           if (unaligned || PatchALot) {
 772             assert(Assembler::is_simm13(offset + 4), &quot;must be&quot;);
 773             __ stf(FloatRegisterImpl::S, reg-&gt;successor(), base, offset + 4);
 774             __ stf(FloatRegisterImpl::S, reg,              base, offset);
 775           } else {
 776             __ stf(FloatRegisterImpl::D, reg, base, offset);
 777           }
 778           break;
 779         }
 780       default      : ShouldNotReachHere();
 781     }
 782   }
 783   return store_offset;
 784 }
 785 
 786 
 787 int LIR_Assembler::store(LIR_Opr from_reg, Register base, Register disp, BasicType type, bool wide) {
 788   if (type == T_ARRAY || type == T_OBJECT) {
 789     __ verify_oop(from_reg-&gt;as_register());
 790   }
 791   int store_offset = code_offset();
 792   switch (type) {
 793     case T_BOOLEAN: // fall through
 794     case T_BYTE  : __ stb(from_reg-&gt;as_register(), base, disp); break;
 795     case T_CHAR  : __ sth(from_reg-&gt;as_register(), base, disp); break;
 796     case T_SHORT : __ sth(from_reg-&gt;as_register(), base, disp); break;
 797     case T_INT   : __ stw(from_reg-&gt;as_register(), base, disp); break;
 798     case T_LONG  :
 799       __ stx(from_reg-&gt;as_register_lo(), base, disp);
 800       break;
 801     case T_ADDRESS:
 802       __ st_ptr(from_reg-&gt;as_register(), base, disp);
 803       break;
 804     case T_ARRAY : // fall through
 805     case T_OBJECT:
 806       {
 807         if (UseCompressedOops &amp;&amp; !wide) {
 808           __ encode_heap_oop(from_reg-&gt;as_register(), G3_scratch);
 809           store_offset = code_offset();
 810           __ stw(G3_scratch, base, disp);
 811         } else {
 812           __ st_ptr(from_reg-&gt;as_register(), base, disp);
 813         }
 814         break;
 815       }
 816     case T_FLOAT : __ stf(FloatRegisterImpl::S, from_reg-&gt;as_float_reg(), base, disp); break;
 817     case T_DOUBLE: __ stf(FloatRegisterImpl::D, from_reg-&gt;as_double_reg(), base, disp); break;
 818     default      : ShouldNotReachHere();
 819   }
 820   return store_offset;
 821 }
 822 
 823 
 824 int LIR_Assembler::load(Register base, int offset, LIR_Opr to_reg, BasicType type, bool wide, bool unaligned) {
 825   int load_offset;
 826   if (!Assembler::is_simm13(offset + (type == T_LONG) ? wordSize : 0)) {
 827     assert(base != O7, &quot;destroying register&quot;);
 828     assert(!unaligned, &quot;can&#39;t handle this&quot;);
 829     // for offsets larger than a simm13 we setup the offset in O7
 830     __ set(offset, O7);
 831     load_offset = load(base, O7, to_reg, type, wide);
 832   } else {
 833     load_offset = code_offset();
 834     switch(type) {
 835       case T_BOOLEAN: // fall through
 836       case T_BYTE  : __ ldsb(base, offset, to_reg-&gt;as_register()); break;
 837       case T_CHAR  : __ lduh(base, offset, to_reg-&gt;as_register()); break;
 838       case T_SHORT : __ ldsh(base, offset, to_reg-&gt;as_register()); break;
 839       case T_INT   : __ ld(base, offset, to_reg-&gt;as_register()); break;
 840       case T_LONG  :
 841         if (!unaligned &amp;&amp; !PatchALot) {
 842           __ ldx(base, offset, to_reg-&gt;as_register_lo());
 843         } else {
 844           assert(base != to_reg-&gt;as_register_lo(), &quot;can&#39;t handle this&quot;);
 845           assert(O7 != to_reg-&gt;as_register_lo(), &quot;can&#39;t handle this&quot;);
 846           __ ld(base, offset + hi_word_offset_in_bytes, to_reg-&gt;as_register_lo());
 847           __ lduw(base, offset + lo_word_offset_in_bytes, O7); // in case O7 is base or offset, use it last
 848           __ sllx(to_reg-&gt;as_register_lo(), 32, to_reg-&gt;as_register_lo());
 849           __ or3(to_reg-&gt;as_register_lo(), O7, to_reg-&gt;as_register_lo());
 850         }
 851         break;
 852       case T_METADATA:  __ ld_ptr(base, offset, to_reg-&gt;as_register()); break;
 853       case T_ADDRESS:
 854         if (offset == oopDesc::klass_offset_in_bytes() &amp;&amp; UseCompressedClassPointers) {
 855           __ lduw(base, offset, to_reg-&gt;as_register());
 856           __ decode_klass_not_null(to_reg-&gt;as_register());
 857         } else
 858         {
 859           __ ld_ptr(base, offset, to_reg-&gt;as_register());
 860         }
 861         break;
 862       case T_ARRAY : // fall through
 863       case T_OBJECT:
 864         {
 865           if (UseCompressedOops &amp;&amp; !wide) {
 866             __ lduw(base, offset, to_reg-&gt;as_register());
 867             __ decode_heap_oop(to_reg-&gt;as_register());
 868           } else {
 869             __ ld_ptr(base, offset, to_reg-&gt;as_register());
 870           }
 871           break;
 872         }
 873       case T_FLOAT:  __ ldf(FloatRegisterImpl::S, base, offset, to_reg-&gt;as_float_reg()); break;
 874       case T_DOUBLE:
 875         {
 876           FloatRegister reg = to_reg-&gt;as_double_reg();
 877           // split unaligned loads
 878           if (unaligned || PatchALot) {
 879             __ ldf(FloatRegisterImpl::S, base, offset + 4, reg-&gt;successor());
 880             __ ldf(FloatRegisterImpl::S, base, offset,     reg);
 881           } else {
 882             __ ldf(FloatRegisterImpl::D, base, offset, to_reg-&gt;as_double_reg());
 883           }
 884           break;
 885         }
 886       default      : ShouldNotReachHere();
 887     }
 888     if (type == T_ARRAY || type == T_OBJECT) {
 889       __ verify_oop(to_reg-&gt;as_register());
 890     }
 891   }
 892   return load_offset;
 893 }
 894 
 895 
 896 int LIR_Assembler::load(Register base, Register disp, LIR_Opr to_reg, BasicType type, bool wide) {
 897   int load_offset = code_offset();
 898   switch(type) {
 899     case T_BOOLEAN: // fall through
 900     case T_BYTE  :  __ ldsb(base, disp, to_reg-&gt;as_register()); break;
 901     case T_CHAR  :  __ lduh(base, disp, to_reg-&gt;as_register()); break;
 902     case T_SHORT :  __ ldsh(base, disp, to_reg-&gt;as_register()); break;
 903     case T_INT   :  __ ld(base, disp, to_reg-&gt;as_register()); break;
 904     case T_ADDRESS: __ ld_ptr(base, disp, to_reg-&gt;as_register()); break;
 905     case T_ARRAY : // fall through
 906     case T_OBJECT:
 907       {
 908           if (UseCompressedOops &amp;&amp; !wide) {
 909             __ lduw(base, disp, to_reg-&gt;as_register());
 910             __ decode_heap_oop(to_reg-&gt;as_register());
 911           } else {
 912             __ ld_ptr(base, disp, to_reg-&gt;as_register());
 913           }
 914           break;
 915       }
 916     case T_FLOAT:  __ ldf(FloatRegisterImpl::S, base, disp, to_reg-&gt;as_float_reg()); break;
 917     case T_DOUBLE: __ ldf(FloatRegisterImpl::D, base, disp, to_reg-&gt;as_double_reg()); break;
 918     case T_LONG  :
 919       __ ldx(base, disp, to_reg-&gt;as_register_lo());
 920       break;
 921     default      : ShouldNotReachHere();
 922   }
 923   if (type == T_ARRAY || type == T_OBJECT) {
 924     __ verify_oop(to_reg-&gt;as_register());
 925   }
 926   return load_offset;
 927 }
 928 
 929 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 930   LIR_Const* c = src-&gt;as_constant_ptr();
 931   switch (c-&gt;type()) {
 932     case T_INT:
 933     case T_FLOAT: {
 934       Register src_reg = O7;
 935       int value = c-&gt;as_jint_bits();
 936       if (value == 0) {
 937         src_reg = G0;
 938       } else {
 939         __ set(value, O7);
 940       }
 941       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 942       __ stw(src_reg, addr.base(), addr.disp());
 943       break;
 944     }
 945     case T_ADDRESS: {
 946       Register src_reg = O7;
 947       int value = c-&gt;as_jint_bits();
 948       if (value == 0) {
 949         src_reg = G0;
 950       } else {
 951         __ set(value, O7);
 952       }
 953       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 954       __ st_ptr(src_reg, addr.base(), addr.disp());
 955       break;
 956     }
 957     case T_OBJECT: {
 958       Register src_reg = O7;
 959       jobject2reg(c-&gt;as_jobject(), src_reg);
 960       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 961       __ st_ptr(src_reg, addr.base(), addr.disp());
 962       break;
 963     }
 964     case T_LONG:
 965     case T_DOUBLE: {
 966       Address addr = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
 967 
 968       Register tmp = O7;
 969       int value_lo = c-&gt;as_jint_lo_bits();
 970       if (value_lo == 0) {
 971         tmp = G0;
 972       } else {
 973         __ set(value_lo, O7);
 974       }
 975       __ stw(tmp, addr.base(), addr.disp() + lo_word_offset_in_bytes);
 976       int value_hi = c-&gt;as_jint_hi_bits();
 977       if (value_hi == 0) {
 978         tmp = G0;
 979       } else {
 980         __ set(value_hi, O7);
 981       }
 982       __ stw(tmp, addr.base(), addr.disp() + hi_word_offset_in_bytes);
 983       break;
 984     }
 985     default:
 986       Unimplemented();
 987   }
 988 }
 989 
 990 
 991 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 992   LIR_Const* c = src-&gt;as_constant_ptr();
 993   LIR_Address* addr     = dest-&gt;as_address_ptr();
 994   Register base = addr-&gt;base()-&gt;as_pointer_register();
 995   int offset = -1;
 996 
 997   switch (c-&gt;type()) {
 998     case T_FLOAT: type = T_INT; // Float constants are stored by int store instructions.
 999     case T_INT:
1000     case T_ADDRESS: {
1001       LIR_Opr tmp = FrameMap::O7_opr;
1002       int value = c-&gt;as_jint_bits();
1003       if (value == 0) {
1004         tmp = FrameMap::G0_opr;
1005       } else if (Assembler::is_simm13(value)) {
1006         __ set(value, O7);
1007       }
1008       if (addr-&gt;index()-&gt;is_valid()) {
1009         assert(addr-&gt;disp() == 0, &quot;must be zero&quot;);
1010         offset = store(tmp, base, addr-&gt;index()-&gt;as_pointer_register(), type, wide);
1011       } else {
1012         assert(Assembler::is_simm13(addr-&gt;disp()), &quot;can&#39;t handle larger addresses&quot;);
1013         offset = store(tmp, base, addr-&gt;disp(), type, wide, false);
1014       }
1015       break;
1016     }
1017     case T_LONG:
1018     case T_DOUBLE: {
1019       assert(!addr-&gt;index()-&gt;is_valid(), &quot;can&#39;t handle reg reg address here&quot;);
1020       assert(Assembler::is_simm13(addr-&gt;disp()) &amp;&amp;
1021              Assembler::is_simm13(addr-&gt;disp() + 4), &quot;can&#39;t handle larger addresses&quot;);
1022 
1023       LIR_Opr tmp = FrameMap::O7_opr;
1024       int value_lo = c-&gt;as_jint_lo_bits();
1025       if (value_lo == 0) {
1026         tmp = FrameMap::G0_opr;
1027       } else {
1028         __ set(value_lo, O7);
1029       }
1030       offset = store(tmp, base, addr-&gt;disp() + lo_word_offset_in_bytes, T_INT, wide, false);
1031       int value_hi = c-&gt;as_jint_hi_bits();
1032       if (value_hi == 0) {
1033         tmp = FrameMap::G0_opr;
1034       } else {
1035         __ set(value_hi, O7);
1036       }
1037       store(tmp, base, addr-&gt;disp() + hi_word_offset_in_bytes, T_INT, wide, false);
1038       break;
1039     }
1040     case T_OBJECT: {
1041       jobject obj = c-&gt;as_jobject();
1042       LIR_Opr tmp;
1043       if (obj == NULL) {
1044         tmp = FrameMap::G0_opr;
1045       } else {
1046         tmp = FrameMap::O7_opr;
1047         jobject2reg(c-&gt;as_jobject(), O7);
1048       }
1049       // handle either reg+reg or reg+disp address
1050       if (addr-&gt;index()-&gt;is_valid()) {
1051         assert(addr-&gt;disp() == 0, &quot;must be zero&quot;);
1052         offset = store(tmp, base, addr-&gt;index()-&gt;as_pointer_register(), type, wide);
1053       } else {
1054         assert(Assembler::is_simm13(addr-&gt;disp()), &quot;can&#39;t handle larger addresses&quot;);
1055         offset = store(tmp, base, addr-&gt;disp(), type, wide, false);
1056       }
1057 
1058       break;
1059     }
1060     default:
1061       Unimplemented();
1062   }
1063   if (info != NULL) {
1064     assert(offset != -1, &quot;offset should&#39;ve been set&quot;);
1065     add_debug_info_for_null_check(offset, info);
1066   }
1067 }
1068 
1069 
1070 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
1071   LIR_Const* c = src-&gt;as_constant_ptr();
1072   LIR_Opr to_reg = dest;
1073 
1074   switch (c-&gt;type()) {
1075     case T_INT:
1076     case T_ADDRESS:
1077       {
1078         jint con = c-&gt;as_jint();
1079         if (to_reg-&gt;is_single_cpu()) {
1080           assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
1081           __ set(con, to_reg-&gt;as_register());
1082         } else {
1083           ShouldNotReachHere();
1084           assert(to_reg-&gt;is_single_fpu(), &quot;wrong register kind&quot;);
1085 
1086           __ set(con, O7);
1087           Address temp_slot(SP, (frame::register_save_words * wordSize) + STACK_BIAS);
1088           __ st(O7, temp_slot);
1089           __ ldf(FloatRegisterImpl::S, temp_slot, to_reg-&gt;as_float_reg());
1090         }
1091       }
1092       break;
1093 
1094     case T_LONG:
1095       {
1096         jlong con = c-&gt;as_jlong();
1097 
1098         if (to_reg-&gt;is_double_cpu()) {
1099           __ set(con,  to_reg-&gt;as_register_lo());
1100         } else if (to_reg-&gt;is_single_cpu()) {
1101           __ set(con, to_reg-&gt;as_register());
1102         } else {
1103           ShouldNotReachHere();
1104           assert(to_reg-&gt;is_double_fpu(), &quot;wrong register kind&quot;);
1105           Address temp_slot_lo(SP, ((frame::register_save_words  ) * wordSize) + STACK_BIAS);
1106           Address temp_slot_hi(SP, ((frame::register_save_words) * wordSize) + (longSize/2) + STACK_BIAS);
1107           __ set(low(con),  O7);
1108           __ st(O7, temp_slot_lo);
1109           __ set(high(con), O7);
1110           __ st(O7, temp_slot_hi);
1111           __ ldf(FloatRegisterImpl::D, temp_slot_lo, to_reg-&gt;as_double_reg());
1112         }
1113       }
1114       break;
1115 
1116     case T_OBJECT:
1117       {
1118         if (patch_code == lir_patch_none) {
1119           jobject2reg(c-&gt;as_jobject(), to_reg-&gt;as_register());
1120         } else {
1121           jobject2reg_with_patching(to_reg-&gt;as_register(), info);
1122         }
1123       }
1124       break;
1125 
1126     case T_METADATA:
1127       {
1128         if (patch_code == lir_patch_none) {
1129           metadata2reg(c-&gt;as_metadata(), to_reg-&gt;as_register());
1130         } else {
1131           klass2reg_with_patching(to_reg-&gt;as_register(), info);
1132         }
1133       }
1134       break;
1135 
1136     case T_FLOAT:
1137       {
1138         address const_addr = __ float_constant(c-&gt;as_jfloat());
1139         if (const_addr == NULL) {
1140           bailout(&quot;const section overflow&quot;);
1141           break;
1142         }
1143         RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1144         AddressLiteral const_addrlit(const_addr, rspec);
1145         if (to_reg-&gt;is_single_fpu()) {
1146           __ patchable_sethi(const_addrlit, O7);
1147           __ relocate(rspec);
1148           __ ldf(FloatRegisterImpl::S, O7, const_addrlit.low10(), to_reg-&gt;as_float_reg());
1149 
1150         } else {
1151           assert(to_reg-&gt;is_single_cpu(), &quot;Must be a cpu register.&quot;);
1152 
1153           __ set(const_addrlit, O7);
1154           __ ld(O7, 0, to_reg-&gt;as_register());
1155         }
1156       }
1157       break;
1158 
1159     case T_DOUBLE:
1160       {
1161         address const_addr = __ double_constant(c-&gt;as_jdouble());
1162         if (const_addr == NULL) {
1163           bailout(&quot;const section overflow&quot;);
1164           break;
1165         }
1166         RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1167 
1168         if (to_reg-&gt;is_double_fpu()) {
1169           AddressLiteral const_addrlit(const_addr, rspec);
1170           __ patchable_sethi(const_addrlit, O7);
1171           __ relocate(rspec);
1172           __ ldf (FloatRegisterImpl::D, O7, const_addrlit.low10(), to_reg-&gt;as_double_reg());
1173         } else {
1174           assert(to_reg-&gt;is_double_cpu(), &quot;Must be a long register.&quot;);
1175           __ set(jlong_cast(c-&gt;as_jdouble()), to_reg-&gt;as_register_lo());
1176         }
1177 
1178       }
1179       break;
1180 
1181     default:
1182       ShouldNotReachHere();
1183   }
1184 }
1185 
1186 Address LIR_Assembler::as_Address(LIR_Address* addr) {
1187   Register reg = addr-&gt;base()-&gt;as_pointer_register();
1188   LIR_Opr index = addr-&gt;index();
1189   if (index-&gt;is_illegal()) {
1190     return Address(reg, addr-&gt;disp());
1191   } else {
1192     assert (addr-&gt;disp() == 0, &quot;unsupported address mode&quot;);
1193     return Address(reg, index-&gt;as_pointer_register());
1194   }
1195 }
1196 
1197 
1198 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1199   switch (type) {
1200     case T_INT:
1201     case T_FLOAT: {
1202       Register tmp = O7;
1203       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1204       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1205       __ lduw(from.base(), from.disp(), tmp);
1206       __ stw(tmp, to.base(), to.disp());
1207       break;
1208     }
1209     case T_ADDRESS:
1210     case T_OBJECT: {
1211       Register tmp = O7;
1212       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1213       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1214       __ ld_ptr(from.base(), from.disp(), tmp);
1215       __ st_ptr(tmp, to.base(), to.disp());
1216       break;
1217     }
1218     case T_LONG:
1219     case T_DOUBLE: {
1220       Register tmp = O7;
1221       Address from = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1222       Address to   = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
1223       __ lduw(from.base(), from.disp(), tmp);
1224       __ stw(tmp, to.base(), to.disp());
1225       __ lduw(from.base(), from.disp() + 4, tmp);
1226       __ stw(tmp, to.base(), to.disp() + 4);
1227       break;
1228     }
1229 
1230     default:
1231       ShouldNotReachHere();
1232   }
1233 }
1234 
1235 
1236 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
1237   Address base = as_Address(addr);
1238   return Address(base.base(), base.disp() + hi_word_offset_in_bytes);
1239 }
1240 
1241 
1242 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
1243   Address base = as_Address(addr);
1244   return Address(base.base(), base.disp() + lo_word_offset_in_bytes);
1245 }
1246 
1247 
1248 void LIR_Assembler::mem2reg(LIR_Opr src_opr, LIR_Opr dest, BasicType type,
1249                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool unaligned) {
1250 
1251   assert(type != T_METADATA, &quot;load of metadata ptr not supported&quot;);
1252   LIR_Address* addr = src_opr-&gt;as_address_ptr();
1253   LIR_Opr to_reg = dest;
1254 
1255   Register src = addr-&gt;base()-&gt;as_pointer_register();
1256   Register disp_reg = noreg;
1257   int disp_value = addr-&gt;disp();
1258   bool needs_patching = (patch_code != lir_patch_none);
1259 
1260   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
1261     __ verify_oop(src);
1262   }
1263 
1264   PatchingStub* patch = NULL;
1265   if (needs_patching) {
1266     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1267     assert(!to_reg-&gt;is_double_cpu() ||
1268            patch_code == lir_patch_none ||
1269            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1270   }
1271 
1272   if (addr-&gt;index()-&gt;is_illegal()) {
1273     if (!Assembler::is_simm13(disp_value) &amp;&amp; (!unaligned || Assembler::is_simm13(disp_value + 4))) {
1274       if (needs_patching) {
1275         __ patchable_set(0, O7);
1276       } else {
1277         __ set(disp_value, O7);
1278       }
1279       disp_reg = O7;
1280     }
1281   } else if (unaligned || PatchALot) {
1282     __ add(src, addr-&gt;index()-&gt;as_pointer_register(), O7);
1283     src = O7;
1284   } else {
1285     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1286     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1287   }
1288 
1289   // remember the offset of the load.  The patching_epilog must be done
1290   // before the call to add_debug_info, otherwise the PcDescs don&#39;t get
1291   // entered in increasing order.
1292   int offset = code_offset();
1293 
1294   assert(disp_reg != noreg || Assembler::is_simm13(disp_value), &quot;should have set this up&quot;);
1295   if (disp_reg == noreg) {
1296     offset = load(src, disp_value, to_reg, type, wide, unaligned);
1297   } else {
1298     assert(!unaligned, &quot;can&#39;t handle this&quot;);
1299     offset = load(src, disp_reg, to_reg, type, wide);
1300   }
1301 
1302   if (patch != NULL) {
1303     patching_epilog(patch, patch_code, src, info);
1304   }
1305   if (info != NULL) add_debug_info_for_null_check(offset, info);
1306 }
1307 
1308 
1309 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1310   Address addr;
1311   if (src-&gt;is_single_word()) {
1312     addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1313   } else if (src-&gt;is_double_word())  {
1314     addr = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1315   }
1316 
1317   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1318   load(addr.base(), addr.disp(), dest, dest-&gt;type(), true /*wide*/, unaligned);
1319 }
1320 
1321 
1322 void LIR_Assembler::reg2stack(LIR_Opr from_reg, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
1323   Address addr;
1324   if (dest-&gt;is_single_word()) {
1325     addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1326   } else if (dest-&gt;is_double_word())  {
1327     addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1328   }
1329   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1330   store(from_reg, addr.base(), addr.disp(), from_reg-&gt;type(), true /*wide*/, unaligned);
1331 }
1332 
1333 
1334 void LIR_Assembler::reg2reg(LIR_Opr from_reg, LIR_Opr to_reg) {
1335   if (from_reg-&gt;is_float_kind() &amp;&amp; to_reg-&gt;is_float_kind()) {
1336     if (from_reg-&gt;is_double_fpu()) {
1337       // double to double moves
1338       assert(to_reg-&gt;is_double_fpu(), &quot;should match&quot;);
1339       __ fmov(FloatRegisterImpl::D, from_reg-&gt;as_double_reg(), to_reg-&gt;as_double_reg());
1340     } else {
1341       // float to float moves
1342       assert(to_reg-&gt;is_single_fpu(), &quot;should match&quot;);
1343       __ fmov(FloatRegisterImpl::S, from_reg-&gt;as_float_reg(), to_reg-&gt;as_float_reg());
1344     }
1345   } else if (!from_reg-&gt;is_float_kind() &amp;&amp; !to_reg-&gt;is_float_kind()) {
1346     if (from_reg-&gt;is_double_cpu()) {
1347       __ mov(from_reg-&gt;as_pointer_register(), to_reg-&gt;as_pointer_register());
1348     } else if (to_reg-&gt;is_double_cpu()) {
1349       // int to int moves
1350       __ mov(from_reg-&gt;as_register(), to_reg-&gt;as_register_lo());
1351     } else {
1352       // int to int moves
1353       __ mov(from_reg-&gt;as_register(), to_reg-&gt;as_register());
1354     }
1355   } else {
1356     ShouldNotReachHere();
1357   }
1358   if (to_reg-&gt;type() == T_OBJECT || to_reg-&gt;type() == T_ARRAY) {
1359     __ verify_oop(to_reg-&gt;as_register());
1360   }
1361 }
1362 
1363 void LIR_Assembler::reg2mem(LIR_Opr from_reg, LIR_Opr dest, BasicType type,
1364                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
1365                             bool wide, bool unaligned) {
1366   assert(type != T_METADATA, &quot;store of metadata ptr not supported&quot;);
1367   LIR_Address* addr = dest-&gt;as_address_ptr();
1368 
1369   Register src = addr-&gt;base()-&gt;as_pointer_register();
1370   Register disp_reg = noreg;
1371   int disp_value = addr-&gt;disp();
1372   bool needs_patching = (patch_code != lir_patch_none);
1373 
1374   if (addr-&gt;base()-&gt;is_oop_register()) {
1375     __ verify_oop(src);
1376   }
1377 
1378   PatchingStub* patch = NULL;
1379   if (needs_patching) {
1380     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1381     assert(!from_reg-&gt;is_double_cpu() ||
1382            patch_code == lir_patch_none ||
1383            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1384   }
1385 
1386   if (addr-&gt;index()-&gt;is_illegal()) {
1387     if (!Assembler::is_simm13(disp_value) &amp;&amp; (!unaligned || Assembler::is_simm13(disp_value + 4))) {
1388       if (needs_patching) {
1389         __ patchable_set(0, O7);
1390       } else {
1391         __ set(disp_value, O7);
1392       }
1393       disp_reg = O7;
1394     }
1395   } else if (unaligned || PatchALot) {
1396     __ add(src, addr-&gt;index()-&gt;as_pointer_register(), O7);
1397     src = O7;
1398   } else {
1399     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1400     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1401   }
1402 
1403   // remember the offset of the store.  The patching_epilog must be done
1404   // before the call to add_debug_info_for_null_check, otherwise the PcDescs don&#39;t get
1405   // entered in increasing order.
1406   int offset;
1407 
1408   assert(disp_reg != noreg || Assembler::is_simm13(disp_value), &quot;should have set this up&quot;);
1409   if (disp_reg == noreg) {
1410     offset = store(from_reg, src, disp_value, type, wide, unaligned);
1411   } else {
1412     assert(!unaligned, &quot;can&#39;t handle this&quot;);
1413     offset = store(from_reg, src, disp_reg, type, wide);
1414   }
1415 
1416   if (patch != NULL) {
1417     patching_epilog(patch, patch_code, src, info);
1418   }
1419 
1420   if (info != NULL) add_debug_info_for_null_check(offset, info);
1421 }
1422 
1423 
1424 void LIR_Assembler::return_op(LIR_Opr result) {
1425   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
1426     __ reserved_stack_check();
1427   }
1428   if (SafepointMechanism::uses_thread_local_poll()) {
1429     __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);
1430   } else {
1431     __ set((intptr_t)os::get_polling_page(), L0);
1432   }
1433   __ relocate(relocInfo::poll_return_type);
1434   __ ld_ptr(L0, 0, G0);
1435   __ ret();
1436   __ delayed()-&gt;restore();
1437 }
1438 
1439 
1440 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
1441   if (SafepointMechanism::uses_thread_local_poll()) {
1442     __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), tmp-&gt;as_register());
1443   } else {
1444     __ set((intptr_t)os::get_polling_page(), tmp-&gt;as_register());
1445   }
1446   if (info != NULL) {
1447     add_debug_info_for_branch(info);
1448   }
1449   int offset = __ offset();
1450 
1451   __ relocate(relocInfo::poll_type);
1452   __ ld_ptr(tmp-&gt;as_register(), 0, G0);
1453   return offset;
1454 }
1455 
1456 
1457 void LIR_Assembler::emit_static_call_stub() {
1458   address call_pc = __ pc();
1459   address stub = __ start_a_stub(call_stub_size());
1460   if (stub == NULL) {
1461     bailout(&quot;static call stub overflow&quot;);
1462     return;
1463   }
1464 
1465   int start = __ offset();
1466   __ relocate(static_stub_Relocation::spec(call_pc));
1467 
1468   __ set_metadata(NULL, G5);
1469   // must be set to -1 at code generation time
1470   AddressLiteral addrlit(-1);
1471   __ jump_to(addrlit, G3);
1472   __ delayed()-&gt;nop();
1473 
1474   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
1475   __ end_a_stub();
1476 }
1477 
1478 
1479 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1480   if (opr1-&gt;is_single_fpu()) {
1481     __ fcmp(FloatRegisterImpl::S, Assembler::fcc0, opr1-&gt;as_float_reg(), opr2-&gt;as_float_reg());
1482   } else if (opr1-&gt;is_double_fpu()) {
1483     __ fcmp(FloatRegisterImpl::D, Assembler::fcc0, opr1-&gt;as_double_reg(), opr2-&gt;as_double_reg());
1484   } else if (opr1-&gt;is_single_cpu()) {
1485     if (opr2-&gt;is_constant()) {
1486       switch (opr2-&gt;as_constant_ptr()-&gt;type()) {
1487         case T_INT:
1488           { jint con = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1489             if (Assembler::is_simm13(con)) {
1490               __ cmp(opr1-&gt;as_register(), con);
1491             } else {
1492               __ set(con, O7);
1493               __ cmp(opr1-&gt;as_register(), O7);
1494             }
1495           }
1496           break;
1497 
1498         case T_OBJECT:
1499           // there are only equal/notequal comparisions on objects
1500           { jobject con = opr2-&gt;as_constant_ptr()-&gt;as_jobject();
1501             if (con == NULL) {
1502               __ cmp(opr1-&gt;as_register(), 0);
1503             } else {
1504               jobject2reg(con, O7);
1505               __ cmp(opr1-&gt;as_register(), O7);
1506             }
1507           }
1508           break;
1509 
1510         default:
1511           ShouldNotReachHere();
1512           break;
1513       }
1514     } else {
1515       if (opr2-&gt;is_address()) {
1516         LIR_Address * addr = opr2-&gt;as_address_ptr();
1517         BasicType type = addr-&gt;type();
1518         if ( type == T_OBJECT ) __ ld_ptr(as_Address(addr), O7);
1519         else                    __ ld(as_Address(addr), O7);
1520         __ cmp(opr1-&gt;as_register(), O7);
1521       } else {
1522         __ cmp(opr1-&gt;as_register(), opr2-&gt;as_register());
1523       }
1524     }
1525   } else if (opr1-&gt;is_double_cpu()) {
1526     Register xlo = opr1-&gt;as_register_lo();
1527     Register xhi = opr1-&gt;as_register_hi();
1528     if (opr2-&gt;is_constant() &amp;&amp; opr2-&gt;as_jlong() == 0) {
1529       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles these cases&quot;);
1530       __ orcc(xhi, G0, G0);
1531     } else if (opr2-&gt;is_register()) {
1532       Register ylo = opr2-&gt;as_register_lo();
1533       Register yhi = opr2-&gt;as_register_hi();
1534       __ cmp(xlo, ylo);
1535     } else {
1536       ShouldNotReachHere();
1537     }
1538   } else if (opr1-&gt;is_address()) {
1539     LIR_Address * addr = opr1-&gt;as_address_ptr();
1540     BasicType type = addr-&gt;type();
1541     assert (opr2-&gt;is_constant(), &quot;Checking&quot;);
1542     if ( type == T_OBJECT ) __ ld_ptr(as_Address(addr), O7);
1543     else                    __ ld(as_Address(addr), O7);
1544     __ cmp(O7, opr2-&gt;as_constant_ptr()-&gt;as_jint());
1545   } else {
1546     ShouldNotReachHere();
1547   }
1548 }
1549 
1550 
1551 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
1552   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
1553     bool is_unordered_less = (code == lir_ucmp_fd2i);
1554     if (left-&gt;is_single_fpu()) {
1555       __ float_cmp(true, is_unordered_less ? -1 : 1, left-&gt;as_float_reg(), right-&gt;as_float_reg(), dst-&gt;as_register());
1556     } else if (left-&gt;is_double_fpu()) {
1557       __ float_cmp(false, is_unordered_less ? -1 : 1, left-&gt;as_double_reg(), right-&gt;as_double_reg(), dst-&gt;as_register());
1558     } else {
1559       ShouldNotReachHere();
1560     }
1561   } else if (code == lir_cmp_l2i) {
1562     __ lcmp(left-&gt;as_register_lo(), right-&gt;as_register_lo(), dst-&gt;as_register());
1563   } else {
1564     ShouldNotReachHere();
1565   }
1566 }
1567 
1568 
1569 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1570   Assembler::Condition acond;
1571   switch (condition) {
1572     case lir_cond_equal:        acond = Assembler::equal;        break;
1573     case lir_cond_notEqual:     acond = Assembler::notEqual;     break;
1574     case lir_cond_less:         acond = Assembler::less;         break;
1575     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    break;
1576     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; break;
1577     case lir_cond_greater:      acond = Assembler::greater;      break;
1578     case lir_cond_aboveEqual:   acond = Assembler::greaterEqualUnsigned;      break;
1579     case lir_cond_belowEqual:   acond = Assembler::lessEqualUnsigned;      break;
1580     default:                         ShouldNotReachHere();
1581   };
1582 
1583   if (opr1-&gt;is_constant() &amp;&amp; opr1-&gt;type() == T_INT) {
1584     Register dest = result-&gt;as_register();
1585     // load up first part of constant before branch
1586     // and do the rest in the delay slot.
1587     if (!Assembler::is_simm13(opr1-&gt;as_jint())) {
1588       __ sethi(opr1-&gt;as_jint(), dest);
1589     }
1590   } else if (opr1-&gt;is_constant()) {
1591     const2reg(opr1, result, lir_patch_none, NULL);
1592   } else if (opr1-&gt;is_register()) {
1593     reg2reg(opr1, result);
1594   } else if (opr1-&gt;is_stack()) {
1595     stack2reg(opr1, result, result-&gt;type());
1596   } else {
1597     ShouldNotReachHere();
1598   }
1599   Label skip;
1600     if  (type == T_INT) {
1601       __ br(acond, false, Assembler::pt, skip);
1602     } else {
1603       __ brx(acond, false, Assembler::pt, skip); // checks icc on 32bit and xcc on 64bit
1604     }
1605   if (opr1-&gt;is_constant() &amp;&amp; opr1-&gt;type() == T_INT) {
1606     Register dest = result-&gt;as_register();
1607     if (Assembler::is_simm13(opr1-&gt;as_jint())) {
1608       __ delayed()-&gt;or3(G0, opr1-&gt;as_jint(), dest);
1609     } else {
1610       // the sethi has been done above, so just put in the low 10 bits
1611       __ delayed()-&gt;or3(dest, opr1-&gt;as_jint() &amp; 0x3ff, dest);
1612     }
1613   } else {
1614     // can&#39;t do anything useful in the delay slot
1615     __ delayed()-&gt;nop();
1616   }
1617   if (opr2-&gt;is_constant()) {
1618     const2reg(opr2, result, lir_patch_none, NULL);
1619   } else if (opr2-&gt;is_register()) {
1620     reg2reg(opr2, result);
1621   } else if (opr2-&gt;is_stack()) {
1622     stack2reg(opr2, result, result-&gt;type());
1623   } else {
1624     ShouldNotReachHere();
1625   }
1626   __ bind(skip);
1627 }
1628 
1629 
1630 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
1631   assert(info == NULL, &quot;unused on this code path&quot;);
1632   assert(left-&gt;is_register(), &quot;wrong items state&quot;);
1633   assert(dest-&gt;is_register(), &quot;wrong items state&quot;);
1634 
1635   if (right-&gt;is_register()) {
1636     if (dest-&gt;is_float_kind()) {
1637 
1638       FloatRegister lreg, rreg, res;
1639       FloatRegisterImpl::Width w;
1640       if (right-&gt;is_single_fpu()) {
1641         w = FloatRegisterImpl::S;
1642         lreg = left-&gt;as_float_reg();
1643         rreg = right-&gt;as_float_reg();
1644         res  = dest-&gt;as_float_reg();
1645       } else {
1646         w = FloatRegisterImpl::D;
1647         lreg = left-&gt;as_double_reg();
1648         rreg = right-&gt;as_double_reg();
1649         res  = dest-&gt;as_double_reg();
1650       }
1651 
1652       switch (code) {
1653         case lir_add: __ fadd(w, lreg, rreg, res); break;
1654         case lir_sub: __ fsub(w, lreg, rreg, res); break;
1655         case lir_mul: // fall through
1656         case lir_mul_strictfp: __ fmul(w, lreg, rreg, res); break;
1657         case lir_div: // fall through
1658         case lir_div_strictfp: __ fdiv(w, lreg, rreg, res); break;
1659         default: ShouldNotReachHere();
1660       }
1661 
1662     } else if (dest-&gt;is_double_cpu()) {
1663       Register dst_lo = dest-&gt;as_register_lo();
1664       Register op1_lo = left-&gt;as_pointer_register();
1665       Register op2_lo = right-&gt;as_pointer_register();
1666 
1667       switch (code) {
1668         case lir_add:
1669           __ add(op1_lo, op2_lo, dst_lo);
1670           break;
1671 
1672         case lir_sub:
1673           __ sub(op1_lo, op2_lo, dst_lo);
1674           break;
1675 
1676         default: ShouldNotReachHere();
1677       }
1678     } else {
1679       assert (right-&gt;is_single_cpu(), &quot;Just Checking&quot;);
1680 
1681       Register lreg = left-&gt;as_register();
1682       Register res  = dest-&gt;as_register();
1683       Register rreg = right-&gt;as_register();
1684       switch (code) {
1685         case lir_add:  __ add  (lreg, rreg, res); break;
1686         case lir_sub:  __ sub  (lreg, rreg, res); break;
1687         case lir_mul:  __ mulx (lreg, rreg, res); break;
1688         default: ShouldNotReachHere();
1689       }
1690     }
1691   } else {
1692     assert (right-&gt;is_constant(), &quot;must be constant&quot;);
1693 
1694     if (dest-&gt;is_single_cpu()) {
1695       Register lreg = left-&gt;as_register();
1696       Register res  = dest-&gt;as_register();
1697       int    simm13 = right-&gt;as_constant_ptr()-&gt;as_jint();
1698 
1699       switch (code) {
1700         case lir_add:  __ add  (lreg, simm13, res); break;
1701         case lir_sub:  __ sub  (lreg, simm13, res); break;
1702         case lir_mul:  __ mulx (lreg, simm13, res); break;
1703         default: ShouldNotReachHere();
1704       }
1705     } else {
1706       Register lreg = left-&gt;as_pointer_register();
1707       Register res  = dest-&gt;as_register_lo();
1708       long con = right-&gt;as_constant_ptr()-&gt;as_jlong();
1709       assert(Assembler::is_simm13(con), &quot;must be simm13&quot;);
1710 
1711       switch (code) {
1712         case lir_add:  __ add  (lreg, (int)con, res); break;
1713         case lir_sub:  __ sub  (lreg, (int)con, res); break;
1714         case lir_mul:  __ mulx (lreg, (int)con, res); break;
1715         default: ShouldNotReachHere();
1716       }
1717     }
1718   }
1719 }
1720 
1721 
1722 void LIR_Assembler::fpop() {
1723   // do nothing
1724 }
1725 
1726 
1727 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
1728   switch (code) {
1729     case lir_tan: {
1730       assert(thread-&gt;is_valid(), &quot;preserve the thread object for performance reasons&quot;);
1731       assert(dest-&gt;as_double_reg() == F0, &quot;the result will be in f0/f1&quot;);
1732       break;
1733     }
1734     case lir_sqrt: {
1735       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for dsqrt&quot;);
1736       FloatRegister src_reg = value-&gt;as_double_reg();
1737       FloatRegister dst_reg = dest-&gt;as_double_reg();
1738       __ fsqrt(FloatRegisterImpl::D, src_reg, dst_reg);
1739       break;
1740     }
1741     case lir_abs: {
1742       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for fabs&quot;);
1743       FloatRegister src_reg = value-&gt;as_double_reg();
1744       FloatRegister dst_reg = dest-&gt;as_double_reg();
1745       __ fabs(FloatRegisterImpl::D, src_reg, dst_reg);
1746       break;
1747     }
1748     default: {
1749       ShouldNotReachHere();
1750       break;
1751     }
1752   }
1753 }
1754 
1755 
1756 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest) {
1757   if (right-&gt;is_constant()) {
1758     if (dest-&gt;is_single_cpu()) {
1759       int simm13 = right-&gt;as_constant_ptr()-&gt;as_jint();
1760       switch (code) {
1761         case lir_logic_and:   __ and3 (left-&gt;as_register(), simm13, dest-&gt;as_register()); break;
1762         case lir_logic_or:    __ or3  (left-&gt;as_register(), simm13, dest-&gt;as_register()); break;
1763         case lir_logic_xor:   __ xor3 (left-&gt;as_register(), simm13, dest-&gt;as_register()); break;
1764         default: ShouldNotReachHere();
1765       }
1766     } else {
1767       long c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1768       assert(c == (int)c &amp;&amp; Assembler::is_simm13(c), &quot;out of range&quot;);
1769       int simm13 = (int)c;
1770       switch (code) {
1771         case lir_logic_and:
1772           __ and3 (left-&gt;as_register_lo(), simm13, dest-&gt;as_register_lo());
1773           break;
1774 
1775         case lir_logic_or:
1776           __ or3 (left-&gt;as_register_lo(), simm13, dest-&gt;as_register_lo());
1777           break;
1778 
1779         case lir_logic_xor:
1780           __ xor3 (left-&gt;as_register_lo(), simm13, dest-&gt;as_register_lo());
1781           break;
1782 
1783         default: ShouldNotReachHere();
1784       }
1785     }
1786   } else {
1787     assert(right-&gt;is_register(), &quot;right should be in register&quot;);
1788 
1789     if (dest-&gt;is_single_cpu()) {
1790       switch (code) {
1791         case lir_logic_and:   __ and3 (left-&gt;as_register(), right-&gt;as_register(), dest-&gt;as_register()); break;
1792         case lir_logic_or:    __ or3  (left-&gt;as_register(), right-&gt;as_register(), dest-&gt;as_register()); break;
1793         case lir_logic_xor:   __ xor3 (left-&gt;as_register(), right-&gt;as_register(), dest-&gt;as_register()); break;
1794         default: ShouldNotReachHere();
1795       }
1796     } else {
1797       Register l = (left-&gt;is_single_cpu() &amp;&amp; left-&gt;is_oop_register()) ? left-&gt;as_register() :
1798                                                                         left-&gt;as_register_lo();
1799       Register r = (right-&gt;is_single_cpu() &amp;&amp; right-&gt;is_oop_register()) ? right-&gt;as_register() :
1800                                                                           right-&gt;as_register_lo();
1801 
1802       switch (code) {
1803         case lir_logic_and: __ and3 (l, r, dest-&gt;as_register_lo()); break;
1804         case lir_logic_or:  __ or3  (l, r, dest-&gt;as_register_lo()); break;
1805         case lir_logic_xor: __ xor3 (l, r, dest-&gt;as_register_lo()); break;
1806         default: ShouldNotReachHere();
1807       }
1808     }
1809   }
1810 }
1811 
1812 
1813 int LIR_Assembler::shift_amount(BasicType t) {
1814   int elem_size = type2aelembytes(t);
1815   switch (elem_size) {
1816     case 1 : return 0;
1817     case 2 : return 1;
1818     case 4 : return 2;
1819     case 8 : return 3;
1820   }
1821   ShouldNotReachHere();
1822   return -1;
1823 }
1824 
1825 
1826 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
1827   assert(exceptionOop-&gt;as_register() == Oexception, &quot;should match&quot;);
1828   assert(exceptionPC-&gt;as_register() == Oissuing_pc, &quot;should match&quot;);
1829 
1830   info-&gt;add_register_oop(exceptionOop);
1831 
1832   // reuse the debug info from the safepoint poll for the throw op itself
1833   address pc_for_athrow  = __ pc();
1834   int pc_for_athrow_offset = __ offset();
1835   RelocationHolder rspec = internal_word_Relocation::spec(pc_for_athrow);
1836   __ set(pc_for_athrow, Oissuing_pc, rspec);
1837   add_call_info(pc_for_athrow_offset, info); // for exception handler
1838 
1839   __ call(Runtime1::entry_for(Runtime1::handle_exception_id), relocInfo::runtime_call_type);
1840   __ delayed()-&gt;nop();
1841 }
1842 
1843 
1844 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
1845   assert(exceptionOop-&gt;as_register() == Oexception, &quot;should match&quot;);
1846 
1847   __ br(Assembler::always, false, Assembler::pt, _unwind_handler_entry);
1848   __ delayed()-&gt;nop();
1849 }
1850 
1851 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
1852   Register src = op-&gt;src()-&gt;as_register();
1853   Register dst = op-&gt;dst()-&gt;as_register();
1854   Register src_pos = op-&gt;src_pos()-&gt;as_register();
1855   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
1856   Register length  = op-&gt;length()-&gt;as_register();
1857   Register tmp = op-&gt;tmp()-&gt;as_register();
1858   Register tmp2 = O7;
1859 
1860   int flags = op-&gt;flags();
1861   ciArrayKlass* default_type = op-&gt;expected_type();
1862   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
1863   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
1864 
1865   // higher 32bits must be null
1866   __ sra(dst_pos, 0, dst_pos);
1867   __ sra(src_pos, 0, src_pos);
1868   __ sra(length, 0, length);
1869 
1870   // set up the arraycopy stub information
1871   ArrayCopyStub* stub = op-&gt;stub();
1872 
1873   // always do stub if no type information is available.  it&#39;s ok if
1874   // the known type isn&#39;t loaded since the code sanity checks
1875   // in debug mode and the type isn&#39;t required when we know the exact type
1876   // also check that the type is an array type.
1877   if (op-&gt;expected_type() == NULL) {
1878     __ mov(src,     O0);
1879     __ mov(src_pos, O1);
1880     __ mov(dst,     O2);
1881     __ mov(dst_pos, O3);
1882     __ mov(length,  O4);
1883     address copyfunc_addr = StubRoutines::generic_arraycopy();
1884     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
1885 
1886 #ifndef PRODUCT
1887     if (PrintC1Statistics) {
1888       address counter = (address)&amp;Runtime1::_generic_arraycopystub_cnt;
1889       __ inc_counter(counter, G1, G3);
1890     }
1891 #endif
1892     __ call_VM_leaf(tmp, copyfunc_addr);
1893 
1894     __ xor3(O0, -1, tmp);
1895     __ sub(length, tmp, length);
1896     __ add(src_pos, tmp, src_pos);
1897     __ cmp_zero_and_br(Assembler::less, O0, *stub-&gt;entry());
1898     __ delayed()-&gt;add(dst_pos, tmp, dst_pos);
1899     __ bind(*stub-&gt;continuation());
1900     return;
1901   }
1902 
1903   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass(), &quot;must be true at this point&quot;);
1904 
1905   // make sure src and dst are non-null and load array length
1906   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
1907     __ tst(src);
1908     __ brx(Assembler::equal, false, Assembler::pn, *stub-&gt;entry());
1909     __ delayed()-&gt;nop();
1910   }
1911 
1912   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
1913     __ tst(dst);
1914     __ brx(Assembler::equal, false, Assembler::pn, *stub-&gt;entry());
1915     __ delayed()-&gt;nop();
1916   }
1917 
1918   // If the compiler was not able to prove that exact type of the source or the destination
1919   // of the arraycopy is an array type, check at runtime if the source or the destination is
1920   // an instance type.
1921   if (flags &amp; LIR_OpArrayCopy::type_check) {
1922     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::dst_objarray)) {
1923       __ load_klass(dst, tmp);
1924       __ lduw(tmp, in_bytes(Klass::layout_helper_offset()), tmp2);
1925       __ cmp(tmp2, Klass::_lh_neutral_value);
1926       __ br(Assembler::greaterEqual, false, Assembler::pn, *stub-&gt;entry());
1927       __ delayed()-&gt;nop();
1928     }
1929 
1930     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::src_objarray)) {
1931       __ load_klass(src, tmp);
1932       __ lduw(tmp, in_bytes(Klass::layout_helper_offset()), tmp2);
1933       __ cmp(tmp2, Klass::_lh_neutral_value);
1934       __ br(Assembler::greaterEqual, false, Assembler::pn, *stub-&gt;entry());
1935       __ delayed()-&gt;nop();
1936     }
1937   }
1938 
1939   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
1940     // test src_pos register
1941     __ cmp_zero_and_br(Assembler::less, src_pos, *stub-&gt;entry());
1942     __ delayed()-&gt;nop();
1943   }
1944 
1945   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
1946     // test dst_pos register
1947     __ cmp_zero_and_br(Assembler::less, dst_pos, *stub-&gt;entry());
1948     __ delayed()-&gt;nop();
1949   }
1950 
1951   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
1952     // make sure length isn&#39;t negative
1953     __ cmp_zero_and_br(Assembler::less, length, *stub-&gt;entry());
1954     __ delayed()-&gt;nop();
1955   }
1956 
1957   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
1958     __ ld(src, arrayOopDesc::length_offset_in_bytes(), tmp2);
1959     __ add(length, src_pos, tmp);
1960     __ cmp(tmp2, tmp);
1961     __ br(Assembler::carrySet, false, Assembler::pn, *stub-&gt;entry());
1962     __ delayed()-&gt;nop();
1963   }
1964 
1965   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
1966     __ ld(dst, arrayOopDesc::length_offset_in_bytes(), tmp2);
1967     __ add(length, dst_pos, tmp);
1968     __ cmp(tmp2, tmp);
1969     __ br(Assembler::carrySet, false, Assembler::pn, *stub-&gt;entry());
1970     __ delayed()-&gt;nop();
1971   }
1972 
1973   int shift = shift_amount(basic_type);
1974 
1975   if (flags &amp; LIR_OpArrayCopy::type_check) {
1976     // We don&#39;t know the array types are compatible
1977     if (basic_type != T_OBJECT) {
1978       // Simple test for basic type arrays
1979       if (UseCompressedClassPointers) {
1980         // We don&#39;t need decode because we just need to compare
1981         __ lduw(src, oopDesc::klass_offset_in_bytes(), tmp);
1982         __ lduw(dst, oopDesc::klass_offset_in_bytes(), tmp2);
1983         __ cmp(tmp, tmp2);
1984         __ br(Assembler::notEqual, false, Assembler::pt, *stub-&gt;entry());
1985       } else {
1986         __ ld_ptr(src, oopDesc::klass_offset_in_bytes(), tmp);
1987         __ ld_ptr(dst, oopDesc::klass_offset_in_bytes(), tmp2);
1988         __ cmp(tmp, tmp2);
1989         __ brx(Assembler::notEqual, false, Assembler::pt, *stub-&gt;entry());
1990       }
1991       __ delayed()-&gt;nop();
1992     } else {
1993       // For object arrays, if src is a sub class of dst then we can
1994       // safely do the copy.
1995       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
1996 
1997       Label cont, slow;
1998       assert_different_registers(tmp, tmp2, G3, G1);
1999 
2000       __ load_klass(src, G3);
2001       __ load_klass(dst, G1);
2002 
2003       __ check_klass_subtype_fast_path(G3, G1, tmp, tmp2, &amp;cont, copyfunc_addr == NULL ? stub-&gt;entry() : &amp;slow, NULL);
2004 
2005       __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);
2006       __ delayed()-&gt;nop();
2007 
2008       __ cmp(G3, 0);
2009       if (copyfunc_addr != NULL) { // use stub if available
2010         // src is not a sub class of dst so we have to do a
2011         // per-element check.
2012         __ br(Assembler::notEqual, false, Assembler::pt, cont);
2013         __ delayed()-&gt;nop();
2014 
2015         __ bind(slow);
2016 
2017         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2018         if ((flags &amp; mask) != mask) {
2019           // Check that at least both of them object arrays.
2020           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2021 
2022           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2023             __ load_klass(src, tmp);
2024           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2025             __ load_klass(dst, tmp);
2026           }
2027           int lh_offset = in_bytes(Klass::layout_helper_offset());
2028 
2029           __ lduw(tmp, lh_offset, tmp2);
2030 
2031           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2032           __ set(objArray_lh, tmp);
2033           __ cmp(tmp, tmp2);
2034           __ br(Assembler::notEqual, false, Assembler::pt,  *stub-&gt;entry());
2035           __ delayed()-&gt;nop();
2036         }
2037 
2038         Register src_ptr = O0;
2039         Register dst_ptr = O1;
2040         Register len     = O2;
2041         Register chk_off = O3;
2042         Register super_k = O4;
2043 
2044         __ add(src, arrayOopDesc::base_offset_in_bytes(basic_type), src_ptr);
2045         if (shift == 0) {
2046           __ add(src_ptr, src_pos, src_ptr);
2047         } else {
2048           __ sll(src_pos, shift, tmp);
2049           __ add(src_ptr, tmp, src_ptr);
2050         }
2051 
2052         __ add(dst, arrayOopDesc::base_offset_in_bytes(basic_type), dst_ptr);
2053         if (shift == 0) {
2054           __ add(dst_ptr, dst_pos, dst_ptr);
2055         } else {
2056           __ sll(dst_pos, shift, tmp);
2057           __ add(dst_ptr, tmp, dst_ptr);
2058         }
2059         __ mov(length, len);
2060         __ load_klass(dst, tmp);
2061 
2062         int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
2063         __ ld_ptr(tmp, ek_offset, super_k);
2064 
2065         int sco_offset = in_bytes(Klass::super_check_offset_offset());
2066         __ lduw(super_k, sco_offset, chk_off);
2067 
2068         __ call_VM_leaf(tmp, copyfunc_addr);
2069 
2070 #ifndef PRODUCT
2071         if (PrintC1Statistics) {
2072           Label failed;
2073           __ br_notnull_short(O0, Assembler::pn, failed);
2074           __ inc_counter((address)&amp;Runtime1::_arraycopy_checkcast_cnt, G1, G3);
2075           __ bind(failed);
2076         }
2077 #endif
2078 
2079         __ br_null(O0, false, Assembler::pt,  *stub-&gt;continuation());
2080         __ delayed()-&gt;xor3(O0, -1, tmp);
2081 
2082 #ifndef PRODUCT
2083         if (PrintC1Statistics) {
2084           __ inc_counter((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt, G1, G3);
2085         }
2086 #endif
2087 
2088         __ sub(length, tmp, length);
2089         __ add(src_pos, tmp, src_pos);
2090         __ br(Assembler::always, false, Assembler::pt, *stub-&gt;entry());
2091         __ delayed()-&gt;add(dst_pos, tmp, dst_pos);
2092 
2093         __ bind(cont);
2094       } else {
2095         __ br(Assembler::equal, false, Assembler::pn, *stub-&gt;entry());
2096         __ delayed()-&gt;nop();
2097         __ bind(cont);
2098       }
2099     }
2100   }
2101 
2102 #ifdef ASSERT
2103   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2104     // Sanity check the known type with the incoming class.  For the
2105     // primitive case the types must match exactly with src.klass and
2106     // dst.klass each exactly matching the default type.  For the
2107     // object array case, if no type check is needed then either the
2108     // dst type is exactly the expected type and the src type is a
2109     // subtype which we can&#39;t check or src is the same array as dst
2110     // but not necessarily exactly of type default_type.
2111     Label known_ok, halt;
2112     metadata2reg(op-&gt;expected_type()-&gt;constant_encoding(), tmp);
2113     if (UseCompressedClassPointers) {
2114       // tmp holds the default type. It currently comes uncompressed after the
2115       // load of a constant, so encode it.
2116       __ encode_klass_not_null(tmp);
2117       // load the raw value of the dst klass, since we will be comparing
2118       // uncompressed values directly.
2119       __ lduw(dst, oopDesc::klass_offset_in_bytes(), tmp2);
2120       if (basic_type != T_OBJECT) {
2121         __ cmp(tmp, tmp2);
2122         __ br(Assembler::notEqual, false, Assembler::pn, halt);
2123         // load the raw value of the src klass.
2124         __ delayed()-&gt;lduw(src, oopDesc::klass_offset_in_bytes(), tmp2);
2125         __ cmp_and_br_short(tmp, tmp2, Assembler::equal, Assembler::pn, known_ok);
2126       } else {
2127         __ cmp(tmp, tmp2);
2128         __ br(Assembler::equal, false, Assembler::pn, known_ok);
2129         __ delayed()-&gt;cmp(src, dst);
2130         __ brx(Assembler::equal, false, Assembler::pn, known_ok);
2131         __ delayed()-&gt;nop();
2132       }
2133     } else {
2134       __ ld_ptr(dst, oopDesc::klass_offset_in_bytes(), tmp2);
2135       if (basic_type != T_OBJECT) {
2136         __ cmp(tmp, tmp2);
2137         __ brx(Assembler::notEqual, false, Assembler::pn, halt);
2138         __ delayed()-&gt;ld_ptr(src, oopDesc::klass_offset_in_bytes(), tmp2);
2139         __ cmp_and_brx_short(tmp, tmp2, Assembler::equal, Assembler::pn, known_ok);
2140       } else {
2141         __ cmp(tmp, tmp2);
2142         __ brx(Assembler::equal, false, Assembler::pn, known_ok);
2143         __ delayed()-&gt;cmp(src, dst);
2144         __ brx(Assembler::equal, false, Assembler::pn, known_ok);
2145         __ delayed()-&gt;nop();
2146       }
2147     }
2148     __ bind(halt);
2149     __ stop(&quot;incorrect type information in arraycopy&quot;);
2150     __ bind(known_ok);
2151   }
2152 #endif
2153 
2154 #ifndef PRODUCT
2155   if (PrintC1Statistics) {
2156     address counter = Runtime1::arraycopy_count_address(basic_type);
2157     __ inc_counter(counter, G1, G3);
2158   }
2159 #endif
2160 
2161   Register src_ptr = O0;
2162   Register dst_ptr = O1;
2163   Register len     = O2;
2164 
2165   __ add(src, arrayOopDesc::base_offset_in_bytes(basic_type), src_ptr);
2166   if (shift == 0) {
2167     __ add(src_ptr, src_pos, src_ptr);
2168   } else {
2169     __ sll(src_pos, shift, tmp);
2170     __ add(src_ptr, tmp, src_ptr);
2171   }
2172 
2173   __ add(dst, arrayOopDesc::base_offset_in_bytes(basic_type), dst_ptr);
2174   if (shift == 0) {
2175     __ add(dst_ptr, dst_pos, dst_ptr);
2176   } else {
2177     __ sll(dst_pos, shift, tmp);
2178     __ add(dst_ptr, tmp, dst_ptr);
2179   }
2180 
2181   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2182   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2183   const char *name;
2184   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2185 
2186   // arraycopy stubs takes a length in number of elements, so don&#39;t scale it.
2187   __ mov(length, len);
2188   __ call_VM_leaf(tmp, entry);
2189 
2190   __ bind(*stub-&gt;continuation());
2191 }
2192 
2193 
2194 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2195   if (dest-&gt;is_single_cpu()) {
2196     if (left-&gt;type() == T_OBJECT) {
2197       switch (code) {
2198         case lir_shl:  __ sllx  (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2199         case lir_shr:  __ srax  (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2200         case lir_ushr: __ srl   (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2201         default: ShouldNotReachHere();
2202       }
2203     } else
2204       switch (code) {
2205         case lir_shl:  __ sll   (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2206         case lir_shr:  __ sra   (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2207         case lir_ushr: __ srl   (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2208         default: ShouldNotReachHere();
2209       }
2210   } else {
2211     switch (code) {
2212       case lir_shl:  __ sllx  (left-&gt;as_register_lo(), count-&gt;as_register(), dest-&gt;as_register_lo()); break;
2213       case lir_shr:  __ srax  (left-&gt;as_register_lo(), count-&gt;as_register(), dest-&gt;as_register_lo()); break;
2214       case lir_ushr: __ srlx  (left-&gt;as_register_lo(), count-&gt;as_register(), dest-&gt;as_register_lo()); break;
2215       default: ShouldNotReachHere();
2216     }
2217   }
2218 }
2219 
2220 
2221 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2222   if (left-&gt;type() == T_OBJECT) {
2223     count = count &amp; 63;  // shouldn&#39;t shift by more than sizeof(intptr_t)
2224     Register l = left-&gt;as_register();
2225     Register d = dest-&gt;as_register_lo();
2226     switch (code) {
2227       case lir_shl:  __ sllx  (l, count, d); break;
2228       case lir_shr:  __ srax  (l, count, d); break;
2229       case lir_ushr: __ srlx  (l, count, d); break;
2230       default: ShouldNotReachHere();
2231     }
2232     return;
2233   }
2234 
2235   if (dest-&gt;is_single_cpu()) {
2236     count = count &amp; 0x1F; // Java spec
2237     switch (code) {
2238       case lir_shl:  __ sll   (left-&gt;as_register(), count, dest-&gt;as_register()); break;
2239       case lir_shr:  __ sra   (left-&gt;as_register(), count, dest-&gt;as_register()); break;
2240       case lir_ushr: __ srl   (left-&gt;as_register(), count, dest-&gt;as_register()); break;
2241       default: ShouldNotReachHere();
2242     }
2243   } else if (dest-&gt;is_double_cpu()) {
2244     count = count &amp; 63; // Java spec
2245     switch (code) {
2246       case lir_shl:  __ sllx  (left-&gt;as_pointer_register(), count, dest-&gt;as_pointer_register()); break;
2247       case lir_shr:  __ srax  (left-&gt;as_pointer_register(), count, dest-&gt;as_pointer_register()); break;
2248       case lir_ushr: __ srlx  (left-&gt;as_pointer_register(), count, dest-&gt;as_pointer_register()); break;
2249       default: ShouldNotReachHere();
2250     }
2251   } else {
2252     ShouldNotReachHere();
2253   }
2254 }
2255 
2256 
2257 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
2258   assert(op-&gt;tmp1()-&gt;as_register()  == G1 &amp;&amp;
2259          op-&gt;tmp2()-&gt;as_register()  == G3 &amp;&amp;
2260          op-&gt;tmp3()-&gt;as_register()  == G4 &amp;&amp;
2261          op-&gt;obj()-&gt;as_register()   == O0 &amp;&amp;
2262          op-&gt;klass()-&gt;as_register() == G5, &quot;must be&quot;);
2263   if (op-&gt;init_check()) {
2264     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
2265     __ ldub(op-&gt;klass()-&gt;as_register(),
2266           in_bytes(InstanceKlass::init_state_offset()),
2267           op-&gt;tmp1()-&gt;as_register());
2268     __ cmp(op-&gt;tmp1()-&gt;as_register(), InstanceKlass::fully_initialized);
2269     __ br(Assembler::notEqual, false, Assembler::pn, *op-&gt;stub()-&gt;entry());
2270     __ delayed()-&gt;nop();
2271   }
2272   __ allocate_object(op-&gt;obj()-&gt;as_register(),
2273                      op-&gt;tmp1()-&gt;as_register(),
2274                      op-&gt;tmp2()-&gt;as_register(),
2275                      op-&gt;tmp3()-&gt;as_register(),
2276                      op-&gt;header_size(),
2277                      op-&gt;object_size(),
2278                      op-&gt;klass()-&gt;as_register(),
2279                      *op-&gt;stub()-&gt;entry());
2280   __ bind(*op-&gt;stub()-&gt;continuation());
2281   __ verify_oop(op-&gt;obj()-&gt;as_register());
2282 }
2283 
2284 
2285 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
2286   assert(op-&gt;tmp1()-&gt;as_register()  == G1 &amp;&amp;
2287          op-&gt;tmp2()-&gt;as_register()  == G3 &amp;&amp;
2288          op-&gt;tmp3()-&gt;as_register()  == G4 &amp;&amp;
2289          op-&gt;tmp4()-&gt;as_register()  == O1 &amp;&amp;
2290          op-&gt;klass()-&gt;as_register() == G5, &quot;must be&quot;);
2291 
2292   __ signx(op-&gt;len()-&gt;as_register());
2293   if (UseSlowPath ||
2294       (!UseFastNewObjectArray &amp;&amp; (op-&gt;type() == T_OBJECT || op-&gt;type() == T_ARRAY)) ||
2295       (!UseFastNewTypeArray   &amp;&amp; (op-&gt;type() != T_OBJECT &amp;&amp; op-&gt;type() != T_ARRAY))) {
2296     __ br(Assembler::always, false, Assembler::pt, *op-&gt;stub()-&gt;entry());
2297     __ delayed()-&gt;nop();
2298   } else {
2299     __ allocate_array(op-&gt;obj()-&gt;as_register(),
2300                       op-&gt;len()-&gt;as_register(),
2301                       op-&gt;tmp1()-&gt;as_register(),
2302                       op-&gt;tmp2()-&gt;as_register(),
2303                       op-&gt;tmp3()-&gt;as_register(),
2304                       arrayOopDesc::header_size(op-&gt;type()),
2305                       type2aelembytes(op-&gt;type()),
2306                       op-&gt;klass()-&gt;as_register(),
2307                       *op-&gt;stub()-&gt;entry());
2308   }
2309   __ bind(*op-&gt;stub()-&gt;continuation());
2310 }
2311 
2312 
2313 void LIR_Assembler::type_profile_helper(Register mdo, int mdo_offset_bias,
2314                                         ciMethodData *md, ciProfileData *data,
2315                                         Register recv, Register tmp1, Label* update_done) {
2316   uint i;
2317   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2318     Label next_test;
2319     // See if the receiver is receiver[n].
2320     Address receiver_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) -
2321                           mdo_offset_bias);
2322     __ ld_ptr(receiver_addr, tmp1);
2323     __ verify_klass_ptr(tmp1);
2324     __ cmp_and_brx_short(recv, tmp1, Assembler::notEqual, Assembler::pt, next_test);
2325     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) -
2326                       mdo_offset_bias);
2327     __ ld_ptr(data_addr, tmp1);
2328     __ add(tmp1, DataLayout::counter_increment, tmp1);
2329     __ st_ptr(tmp1, data_addr);
2330     __ ba(*update_done);
2331     __ delayed()-&gt;nop();
2332     __ bind(next_test);
2333   }
2334 
2335   // Didn&#39;t find receiver; find next empty slot and fill it in
2336   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2337     Label next_test;
2338     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) -
2339                       mdo_offset_bias);
2340     __ ld_ptr(recv_addr, tmp1);
2341     __ br_notnull_short(tmp1, Assembler::pt, next_test);
2342     __ st_ptr(recv, recv_addr);
2343     __ set(DataLayout::counter_increment, tmp1);
2344     __ st_ptr(tmp1, mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) -
2345               mdo_offset_bias);
2346     __ ba(*update_done);
2347     __ delayed()-&gt;nop();
2348     __ bind(next_test);
2349   }
2350 }
2351 
2352 
2353 void LIR_Assembler::setup_md_access(ciMethod* method, int bci,
2354                                     ciMethodData*&amp; md, ciProfileData*&amp; data, int&amp; mdo_offset_bias) {
2355   md = method-&gt;method_data_or_null();
2356   assert(md != NULL, &quot;Sanity&quot;);
2357   data = md-&gt;bci_to_data(bci);
2358   assert(data != NULL,       &quot;need data for checkcast&quot;);
2359   assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
2360   if (!Assembler::is_simm13(md-&gt;byte_offset_of_slot(data, DataLayout::header_offset()) + data-&gt;size_in_bytes())) {
2361     // The offset is large so bias the mdo by the base of the slot so
2362     // that the ld can use simm13s to reference the slots of the data
2363     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, DataLayout::header_offset());
2364   }
2365 }
2366 
2367 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
2368   // we always need a stub for the failure case.
2369   CodeStub* stub = op-&gt;stub();
2370   Register obj = op-&gt;object()-&gt;as_register();
2371   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2372   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2373   Register dst = op-&gt;result_opr()-&gt;as_register();
2374   Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2375   ciKlass* k = op-&gt;klass();
2376 
2377 
2378   if (obj == k_RInfo) {
2379     k_RInfo = klass_RInfo;
2380     klass_RInfo = obj;
2381   }
2382 
2383   ciMethodData* md;
2384   ciProfileData* data;
2385   int mdo_offset_bias = 0;
2386   if (op-&gt;should_profile()) {
2387     ciMethod* method = op-&gt;profiled_method();
2388     assert(method != NULL, &quot;Should have method&quot;);
2389     setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2390 
2391     Label not_null;
2392     __ br_notnull_short(obj, Assembler::pn, not_null);
2393     Register mdo      = k_RInfo;
2394     Register data_val = Rtmp1;
2395     metadata2reg(md-&gt;constant_encoding(), mdo);
2396     if (mdo_offset_bias &gt; 0) {
2397       __ set(mdo_offset_bias, data_val);
2398       __ add(mdo, data_val, mdo);
2399     }
2400     Address flags_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias);
2401     __ ldub(flags_addr, data_val);
2402     __ or3(data_val, BitData::null_seen_byte_constant(), data_val);
2403     __ stb(data_val, flags_addr);
2404     __ ba(*obj_is_null);
2405     __ delayed()-&gt;nop();
2406     __ bind(not_null);
2407   } else {
2408     __ br_null(obj, false, Assembler::pn, *obj_is_null);
2409     __ delayed()-&gt;nop();
2410   }
2411 
2412   Label profile_cast_failure, profile_cast_success;
2413   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
2414   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
2415 
2416   // patching may screw with our temporaries on sparc,
2417   // so let&#39;s do it before loading the class
2418   if (k-&gt;is_loaded()) {
2419     metadata2reg(k-&gt;constant_encoding(), k_RInfo);
2420   } else {
2421     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
2422   }
2423   assert(obj != k_RInfo, &quot;must be different&quot;);
2424 
2425   // get object class
2426   // not a safepoint as obj null check happens earlier
2427   __ load_klass(obj, klass_RInfo);
2428   if (op-&gt;fast_check()) {
2429     assert_different_registers(klass_RInfo, k_RInfo);
2430     __ cmp(k_RInfo, klass_RInfo);
2431     __ brx(Assembler::notEqual, false, Assembler::pt, *failure_target);
2432     __ delayed()-&gt;nop();
2433   } else {
2434     bool need_slow_path = true;
2435     if (k-&gt;is_loaded()) {
2436       if ((int) k-&gt;super_check_offset() != in_bytes(Klass::secondary_super_cache_offset()))
2437         need_slow_path = false;
2438       // perform the fast part of the checking logic
2439       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, noreg,
2440                                        (need_slow_path ? success_target : NULL),
2441                                        failure_target, NULL,
2442                                        RegisterOrConstant(k-&gt;super_check_offset()));
2443     } else {
2444       // perform the fast part of the checking logic
2445       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, O7, success_target,
2446                                        failure_target, NULL);
2447     }
2448     if (need_slow_path) {
2449       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
2450       assert(klass_RInfo == G3 &amp;&amp; k_RInfo == G1, &quot;incorrect call setup&quot;);
2451       __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);
2452       __ delayed()-&gt;nop();
2453       __ cmp(G3, 0);
2454       __ br(Assembler::equal, false, Assembler::pn, *failure_target);
2455       __ delayed()-&gt;nop();
2456       // Fall through to success case
2457     }
2458   }
2459 
2460   if (op-&gt;should_profile()) {
2461     Register mdo  = klass_RInfo, recv = k_RInfo, tmp1 = Rtmp1;
2462     assert_different_registers(obj, mdo, recv, tmp1);
2463     __ bind(profile_cast_success);
2464     metadata2reg(md-&gt;constant_encoding(), mdo);
2465     if (mdo_offset_bias &gt; 0) {
2466       __ set(mdo_offset_bias, tmp1);
2467       __ add(mdo, tmp1, mdo);
2468     }
2469     __ load_klass(obj, recv);
2470     type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, success);
2471     // Jump over the failure case
2472     __ ba(*success);
2473     __ delayed()-&gt;nop();
2474     // Cast failure case
2475     __ bind(profile_cast_failure);
2476     metadata2reg(md-&gt;constant_encoding(), mdo);
2477     if (mdo_offset_bias &gt; 0) {
2478       __ set(mdo_offset_bias, tmp1);
2479       __ add(mdo, tmp1, mdo);
2480     }
2481     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2482     __ ld_ptr(data_addr, tmp1);
2483     __ sub(tmp1, DataLayout::counter_increment, tmp1);
2484     __ st_ptr(tmp1, data_addr);
2485     __ ba(*failure);
2486     __ delayed()-&gt;nop();
2487   }
2488   __ ba(*success);
2489   __ delayed()-&gt;nop();
2490 }
2491 
2492 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
2493   LIR_Code code = op-&gt;code();
2494   if (code == lir_store_check) {
2495     Register value = op-&gt;object()-&gt;as_register();
2496     Register array = op-&gt;array()-&gt;as_register();
2497     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2498     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2499     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2500 
2501     __ verify_oop(value);
2502     CodeStub* stub = op-&gt;stub();
2503     // check if it needs to be profiled
2504     ciMethodData* md;
2505     ciProfileData* data;
2506     int mdo_offset_bias = 0;
2507     if (op-&gt;should_profile()) {
2508       ciMethod* method = op-&gt;profiled_method();
2509       assert(method != NULL, &quot;Should have method&quot;);
2510       setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2511     }
2512     Label profile_cast_success, profile_cast_failure, done;
2513     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
2514     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
2515 
2516     if (op-&gt;should_profile()) {
2517       Label not_null;
2518       __ br_notnull_short(value, Assembler::pn, not_null);
2519       Register mdo      = k_RInfo;
2520       Register data_val = Rtmp1;
2521       metadata2reg(md-&gt;constant_encoding(), mdo);
2522       if (mdo_offset_bias &gt; 0) {
2523         __ set(mdo_offset_bias, data_val);
2524         __ add(mdo, data_val, mdo);
2525       }
2526       Address flags_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias);
2527       __ ldub(flags_addr, data_val);
2528       __ or3(data_val, BitData::null_seen_byte_constant(), data_val);
2529       __ stb(data_val, flags_addr);
2530       __ ba_short(done);
2531       __ bind(not_null);
2532     } else {
2533       __ br_null_short(value, Assembler::pn, done);
2534     }
2535     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
2536     __ load_klass(array, k_RInfo);
2537     __ load_klass(value, klass_RInfo);
2538 
2539     // get instance klass
2540     __ ld_ptr(Address(k_RInfo, ObjArrayKlass::element_klass_offset()), k_RInfo);
2541     // perform the fast part of the checking logic
2542     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, O7, success_target, failure_target, NULL);
2543 
2544     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
2545     assert(klass_RInfo == G3 &amp;&amp; k_RInfo == G1, &quot;incorrect call setup&quot;);
2546     __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);
2547     __ delayed()-&gt;nop();
2548     __ cmp(G3, 0);
2549     __ br(Assembler::equal, false, Assembler::pn, *failure_target);
2550     __ delayed()-&gt;nop();
2551     // fall through to the success case
2552 
2553     if (op-&gt;should_profile()) {
2554       Register mdo  = klass_RInfo, recv = k_RInfo, tmp1 = Rtmp1;
2555       assert_different_registers(value, mdo, recv, tmp1);
2556       __ bind(profile_cast_success);
2557       metadata2reg(md-&gt;constant_encoding(), mdo);
2558       if (mdo_offset_bias &gt; 0) {
2559         __ set(mdo_offset_bias, tmp1);
2560         __ add(mdo, tmp1, mdo);
2561       }
2562       __ load_klass(value, recv);
2563       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;done);
2564       __ ba_short(done);
2565       // Cast failure case
2566       __ bind(profile_cast_failure);
2567       metadata2reg(md-&gt;constant_encoding(), mdo);
2568       if (mdo_offset_bias &gt; 0) {
2569         __ set(mdo_offset_bias, tmp1);
2570         __ add(mdo, tmp1, mdo);
2571       }
2572       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2573       __ ld_ptr(data_addr, tmp1);
2574       __ sub(tmp1, DataLayout::counter_increment, tmp1);
2575       __ st_ptr(tmp1, data_addr);
2576       __ ba(*stub-&gt;entry());
2577       __ delayed()-&gt;nop();
2578     }
2579     __ bind(done);
2580   } else if (code == lir_checkcast) {
2581     Register obj = op-&gt;object()-&gt;as_register();
2582     Register dst = op-&gt;result_opr()-&gt;as_register();
2583     Label success;
2584     emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
2585     __ bind(success);
2586     __ mov(obj, dst);
2587   } else if (code == lir_instanceof) {
2588     Register obj = op-&gt;object()-&gt;as_register();
2589     Register dst = op-&gt;result_opr()-&gt;as_register();
2590     Label success, failure, done;
2591     emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
2592     __ bind(failure);
2593     __ set(0, dst);
2594     __ ba_short(done);
2595     __ bind(success);
2596     __ set(1, dst);
2597     __ bind(done);
2598   } else {
2599     ShouldNotReachHere();
2600   }
2601 
2602 }
2603 
2604 
2605 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2606   if (op-&gt;code() == lir_cas_long) {
2607     assert(VM_Version::supports_cx8(), &quot;wrong machine&quot;);
2608     Register addr = op-&gt;addr()-&gt;as_pointer_register();
2609     Register cmp_value_lo = op-&gt;cmp_value()-&gt;as_register_lo();
2610     Register cmp_value_hi = op-&gt;cmp_value()-&gt;as_register_hi();
2611     Register new_value_lo = op-&gt;new_value()-&gt;as_register_lo();
2612     Register new_value_hi = op-&gt;new_value()-&gt;as_register_hi();
2613     Register t1 = op-&gt;tmp1()-&gt;as_register();
2614     Register t2 = op-&gt;tmp2()-&gt;as_register();
2615     __ mov(cmp_value_lo, t1);
2616     __ mov(new_value_lo, t2);
2617     // perform the compare and swap operation
2618     __ casx(addr, t1, t2);
2619     // generate condition code - if the swap succeeded, t2 (&quot;new value&quot; reg) was
2620     // overwritten with the original value in &quot;addr&quot; and will be equal to t1.
2621     __ cmp(t1, t2);
2622   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj) {
2623     Register addr = op-&gt;addr()-&gt;as_pointer_register();
2624     Register cmp_value = op-&gt;cmp_value()-&gt;as_register();
2625     Register new_value = op-&gt;new_value()-&gt;as_register();
2626     Register t1 = op-&gt;tmp1()-&gt;as_register();
2627     Register t2 = op-&gt;tmp2()-&gt;as_register();
2628     __ mov(cmp_value, t1);
2629     __ mov(new_value, t2);
2630     if (op-&gt;code() == lir_cas_obj) {
2631       if (UseCompressedOops) {
2632         __ encode_heap_oop(t1);
2633         __ encode_heap_oop(t2);
2634         __ cas(addr, t1, t2);
2635       } else {
2636         __ cas_ptr(addr, t1, t2);
2637       }
2638     } else {
2639       __ cas(addr, t1, t2);
2640     }
2641     __ cmp(t1, t2);
2642   } else {
2643     Unimplemented();
2644   }
2645 }
2646 
2647 void LIR_Assembler::set_24bit_FPU() {
2648   Unimplemented();
2649 }
2650 
2651 
2652 void LIR_Assembler::reset_FPU() {
2653   Unimplemented();
2654 }
2655 
2656 
2657 void LIR_Assembler::breakpoint() {
2658   __ breakpoint_trap();
2659 }
2660 
2661 
2662 void LIR_Assembler::push(LIR_Opr opr) {
2663   Unimplemented();
2664 }
2665 
2666 
2667 void LIR_Assembler::pop(LIR_Opr opr) {
2668   Unimplemented();
2669 }
2670 
2671 
2672 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst_opr) {
2673   Address mon_addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
2674   Register dst = dst_opr-&gt;as_register();
2675   Register reg = mon_addr.base();
2676   int offset = mon_addr.disp();
2677   // compute pointer to BasicLock
2678   if (mon_addr.is_simm13()) {
2679     __ add(reg, offset, dst);
2680   } else {
2681     __ set(offset, dst);
2682     __ add(dst, reg, dst);
2683   }
2684 }
2685 
2686 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
2687   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
2688   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
2689   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
2690   Register crc = op-&gt;crc()-&gt;as_register();
2691   Register val = op-&gt;val()-&gt;as_register();
2692   Register table = op-&gt;result_opr()-&gt;as_register();
2693   Register res   = op-&gt;result_opr()-&gt;as_register();
2694 
2695   assert_different_registers(val, crc, table);
2696 
2697   __ set(ExternalAddress(StubRoutines::crc_table_addr()), table);
2698   __ not1(crc);
2699   __ clruwu(crc);
2700   __ update_byte_crc32(crc, val, table);
2701   __ not1(crc);
2702 
2703   __ mov(crc, res);
2704 }
2705 
2706 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2707   Register obj = op-&gt;obj_opr()-&gt;as_register();
2708   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2709   Register lock = op-&gt;lock_opr()-&gt;as_register();
2710 
2711   // obj may not be an oop
2712   if (op-&gt;code() == lir_lock) {
2713     MonitorEnterStub* stub = (MonitorEnterStub*)op-&gt;stub();
2714     if (UseFastLocking) {
2715       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2716       // add debug info for NullPointerException only if one is possible
2717       if (op-&gt;info() != NULL) {
2718         add_debug_info_for_null_check_here(op-&gt;info());
2719       }
2720       __ lock_object(hdr, obj, lock, op-&gt;scratch_opr()-&gt;as_register(), *op-&gt;stub()-&gt;entry());
2721     } else {
2722       // always do slow locking
2723       // note: the slow locking code could be inlined here, however if we use
2724       //       slow locking, speed doesn&#39;t matter anyway and this solution is
2725       //       simpler and requires less duplicated code - additionally, the
2726       //       slow locking code is the same in either case which simplifies
2727       //       debugging
2728       __ br(Assembler::always, false, Assembler::pt, *op-&gt;stub()-&gt;entry());
2729       __ delayed()-&gt;nop();
2730     }
2731   } else {
2732     assert (op-&gt;code() == lir_unlock, &quot;Invalid code, expected lir_unlock&quot;);
2733     if (UseFastLocking) {
2734       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2735       __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2736     } else {
2737       // always do slow unlocking
2738       // note: the slow unlocking code could be inlined here, however if we use
2739       //       slow unlocking, speed doesn&#39;t matter anyway and this solution is
2740       //       simpler and requires less duplicated code - additionally, the
2741       //       slow unlocking code is the same in either case which simplifies
2742       //       debugging
2743       __ br(Assembler::always, false, Assembler::pt, *op-&gt;stub()-&gt;entry());
2744       __ delayed()-&gt;nop();
2745     }
2746   }
2747   __ bind(*op-&gt;stub()-&gt;continuation());
2748 }
2749 
2750 
2751 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2752   ciMethod* method = op-&gt;profiled_method();
2753   int bci          = op-&gt;profiled_bci();
2754   ciMethod* callee = op-&gt;profiled_callee();
2755 
2756   // Update counter for all call types
2757   ciMethodData* md = method-&gt;method_data_or_null();
2758   assert(md != NULL, &quot;Sanity&quot;);
2759   ciProfileData* data = md-&gt;bci_to_data(bci);
2760   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2761   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2762   Register mdo  = op-&gt;mdo()-&gt;as_register();
2763   assert(op-&gt;tmp1()-&gt;is_double_cpu(), &quot;tmp1 must be allocated&quot;);
2764   Register tmp1 = op-&gt;tmp1()-&gt;as_register_lo();
2765   metadata2reg(md-&gt;constant_encoding(), mdo);
2766   int mdo_offset_bias = 0;
2767   if (!Assembler::is_simm13(md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) +
2768                             data-&gt;size_in_bytes())) {
2769     // The offset is large so bias the mdo by the base of the slot so
2770     // that the ld can use simm13s to reference the slots of the data
2771     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, CounterData::count_offset());
2772     __ set(mdo_offset_bias, O7);
2773     __ add(mdo, O7, mdo);
2774   }
2775 
2776   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2777   // Perform additional virtual call profiling for invokevirtual and
2778   // invokeinterface bytecodes
2779   if (op-&gt;should_profile_receiver_type()) {
2780     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2781     Register recv = op-&gt;recv()-&gt;as_register();
2782     assert_different_registers(mdo, tmp1, recv);
2783     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2784     ciKlass* known_klass = op-&gt;known_holder();
2785     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2786       // We know the type that will be seen at this call site; we can
2787       // statically update the MethodData* rather than needing to do
2788       // dynamic tests on the receiver type
2789 
2790       // NOTE: we should probably put a lock around this search to
2791       // avoid collisions by concurrent compilations
2792       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2793       uint i;
2794       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2795         ciKlass* receiver = vc_data-&gt;receiver(i);
2796         if (known_klass-&gt;equals(receiver)) {
2797           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data,
2798                                                          VirtualCallData::receiver_count_offset(i)) -
2799                             mdo_offset_bias);
2800           __ ld_ptr(data_addr, tmp1);
2801           __ add(tmp1, DataLayout::counter_increment, tmp1);
2802           __ st_ptr(tmp1, data_addr);
2803           return;
2804         }
2805       }
2806 
2807       // Receiver type not found in profile data; select an empty slot
2808 
2809       // Note that this is less efficient than it should be because it
2810       // always does a write to the receiver part of the
2811       // VirtualCallData rather than just the first time
2812       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2813         ciKlass* receiver = vc_data-&gt;receiver(i);
2814         if (receiver == NULL) {
2815           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)) -
2816                             mdo_offset_bias);
2817           metadata2reg(known_klass-&gt;constant_encoding(), tmp1);
2818           __ st_ptr(tmp1, recv_addr);
2819           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) -
2820                             mdo_offset_bias);
2821           __ ld_ptr(data_addr, tmp1);
2822           __ add(tmp1, DataLayout::counter_increment, tmp1);
2823           __ st_ptr(tmp1, data_addr);
2824           return;
2825         }
2826       }
2827     } else {
2828       __ load_klass(recv, recv);
2829       Label update_done;
2830       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;update_done);
2831       // Receiver did not match any saved receiver and there is no empty row for it.
2832       // Increment total counter to indicate polymorphic case.
2833       __ ld_ptr(counter_addr, tmp1);
2834       __ add(tmp1, DataLayout::counter_increment, tmp1);
2835       __ st_ptr(tmp1, counter_addr);
2836 
2837       __ bind(update_done);
2838     }
2839   } else {
2840     // Static call
2841     __ ld_ptr(counter_addr, tmp1);
2842     __ add(tmp1, DataLayout::counter_increment, tmp1);
2843     __ st_ptr(tmp1, counter_addr);
2844   }
2845 }
2846 
2847 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2848   Register obj = op-&gt;obj()-&gt;as_register();
2849   Register tmp1 = op-&gt;tmp()-&gt;as_pointer_register();
2850   Register tmp2 = G1;
2851   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2852   ciKlass* exact_klass = op-&gt;exact_klass();
2853   intptr_t current_klass = op-&gt;current_klass();
2854   bool not_null = op-&gt;not_null();
2855   bool no_conflict = op-&gt;no_conflict();
2856 
2857   Label update, next, none;
2858 
2859   bool do_null = !not_null;
2860   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2861   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2862 
2863   assert(do_null || do_update, &quot;why are we here?&quot;);
2864   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2865 
2866   __ verify_oop(obj);
2867 
2868   if (tmp1 != obj) {
2869     __ mov(obj, tmp1);
2870   }
2871   if (do_null) {
2872     __ br_notnull_short(tmp1, Assembler::pt, update);
2873     if (!TypeEntries::was_null_seen(current_klass)) {
2874       __ ld_ptr(mdo_addr, tmp1);
2875       __ or3(tmp1, TypeEntries::null_seen, tmp1);
2876       __ st_ptr(tmp1, mdo_addr);
2877     }
2878     if (do_update) {
2879       __ ba(next);
2880       __ delayed()-&gt;nop();
2881     }
2882 #ifdef ASSERT
2883   } else {
2884     __ br_notnull_short(tmp1, Assembler::pt, update);
2885     __ stop(&quot;unexpect null obj&quot;);
2886 #endif
2887   }
2888 
2889   __ bind(update);
2890 
2891   if (do_update) {
2892 #ifdef ASSERT
2893     if (exact_klass != NULL) {
2894       Label ok;
2895       __ load_klass(tmp1, tmp1);
2896       metadata2reg(exact_klass-&gt;constant_encoding(), tmp2);
2897       __ cmp_and_br_short(tmp1, tmp2, Assembler::equal, Assembler::pt, ok);
2898       __ stop(&quot;exact klass and actual klass differ&quot;);
2899       __ bind(ok);
2900     }
2901 #endif
2902 
2903     Label do_update;
2904     __ ld_ptr(mdo_addr, tmp2);
2905 
2906     if (!no_conflict) {
2907       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
2908         if (exact_klass != NULL) {
2909           metadata2reg(exact_klass-&gt;constant_encoding(), tmp1);
2910         } else {
2911           __ load_klass(tmp1, tmp1);
2912         }
2913 
2914         __ xor3(tmp1, tmp2, tmp1);
2915         __ btst(TypeEntries::type_klass_mask, tmp1);
2916         // klass seen before, nothing to do. The unknown bit may have been
2917         // set already but no need to check.
2918         __ brx(Assembler::zero, false, Assembler::pt, next);
2919         __ delayed()-&gt;
2920 
2921            btst(TypeEntries::type_unknown, tmp1);
2922         // already unknown. Nothing to do anymore.
2923         __ brx(Assembler::notZero, false, Assembler::pt, next);
2924 
2925         if (TypeEntries::is_type_none(current_klass)) {
2926           __ delayed()-&gt;btst(TypeEntries::type_mask, tmp2);
2927           __ brx(Assembler::zero, true, Assembler::pt, do_update);
2928           // first time here. Set profile type.
2929           __ delayed()-&gt;or3(tmp2, tmp1, tmp2);
2930         } else {
2931           __ delayed()-&gt;nop();
2932         }
2933       } else {
2934         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2935                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
2936 
2937         __ btst(TypeEntries::type_unknown, tmp2);
2938         // already unknown. Nothing to do anymore.
2939         __ brx(Assembler::notZero, false, Assembler::pt, next);
2940         __ delayed()-&gt;nop();
2941       }
2942 
2943       // different than before. Cannot keep accurate profile.
2944       __ or3(tmp2, TypeEntries::type_unknown, tmp2);
2945     } else {
2946       // There&#39;s a single possible klass at this profile point
2947       assert(exact_klass != NULL, &quot;should be&quot;);
2948       if (TypeEntries::is_type_none(current_klass)) {
2949         metadata2reg(exact_klass-&gt;constant_encoding(), tmp1);
2950         __ xor3(tmp1, tmp2, tmp1);
2951         __ btst(TypeEntries::type_klass_mask, tmp1);
2952         __ brx(Assembler::zero, false, Assembler::pt, next);
2953 #ifdef ASSERT
2954 
2955         {
2956           Label ok;
2957           __ delayed()-&gt;btst(TypeEntries::type_mask, tmp2);
2958           __ brx(Assembler::zero, true, Assembler::pt, ok);
2959           __ delayed()-&gt;nop();
2960 
2961           __ stop(&quot;unexpected profiling mismatch&quot;);
2962           __ bind(ok);
2963         }
2964         // first time here. Set profile type.
2965         __ or3(tmp2, tmp1, tmp2);
2966 #else
2967         // first time here. Set profile type.
2968         __ delayed()-&gt;or3(tmp2, tmp1, tmp2);
2969 #endif
2970 
2971       } else {
2972         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2973                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
2974 
2975         // already unknown. Nothing to do anymore.
2976         __ btst(TypeEntries::type_unknown, tmp2);
2977         __ brx(Assembler::notZero, false, Assembler::pt, next);
2978         __ delayed()-&gt;or3(tmp2, TypeEntries::type_unknown, tmp2);
2979       }
2980     }
2981 
2982     __ bind(do_update);
2983     __ st_ptr(tmp2, mdo_addr);
2984 
2985     __ bind(next);
2986   }
2987 }
2988 
2989 void LIR_Assembler::align_backward_branch_target() {
2990   __ align(OptoLoopAlignment);
2991 }
2992 
2993 
2994 void LIR_Assembler::emit_delay(LIR_OpDelay* op) {
2995   // make sure we are expecting a delay
2996   // this has the side effect of clearing the delay state
2997   // so we can use _masm instead of _masm-&gt;delayed() to do the
2998   // code generation.
2999   __ delayed();
3000 
3001   // make sure we only emit one instruction
3002   int offset = code_offset();
3003   op-&gt;delay_op()-&gt;emit_code(this);
3004 #ifdef ASSERT
3005   if (code_offset() - offset != NativeInstruction::nop_instruction_size) {
3006     op-&gt;delay_op()-&gt;print();
3007   }
3008   assert(code_offset() - offset == NativeInstruction::nop_instruction_size,
3009          &quot;only one instruction can go in a delay slot&quot;);
3010 #endif
3011 
3012   // we may also be emitting the call info for the instruction
3013   // which we are the delay slot of.
3014   CodeEmitInfo* call_info = op-&gt;call_info();
3015   if (call_info) {
3016     add_call_info(code_offset(), call_info);
3017   }
3018 
3019   if (VerifyStackAtCalls) {
3020     _masm-&gt;sub(FP, SP, O7);
3021     _masm-&gt;cmp(O7, initial_frame_size_in_bytes());
3022     _masm-&gt;trap(Assembler::notEqual, Assembler::ptr_cc, G0, ST_RESERVED_FOR_USER_0+2 );
3023   }
3024 }
3025 
3026 
3027 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
3028   // tmp must be unused
3029   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
3030   assert(left-&gt;is_register(), &quot;can only handle registers&quot;);
3031 
3032   if (left-&gt;is_single_cpu()) {
3033     __ neg(left-&gt;as_register(), dest-&gt;as_register());
3034   } else if (left-&gt;is_single_fpu()) {
3035     __ fneg(FloatRegisterImpl::S, left-&gt;as_float_reg(), dest-&gt;as_float_reg());
3036   } else if (left-&gt;is_double_fpu()) {
3037     __ fneg(FloatRegisterImpl::D, left-&gt;as_double_reg(), dest-&gt;as_double_reg());
3038   } else {
3039     assert (left-&gt;is_double_cpu(), &quot;Must be a long&quot;);
3040     Register Rlow = left-&gt;as_register_lo();
3041     Register Rhi = left-&gt;as_register_hi();
3042     __ sub(G0, Rlow, dest-&gt;as_register_lo());
3043   }
3044 }
3045 
3046 
3047 void LIR_Assembler::fxch(int i) {
3048   Unimplemented();
3049 }
3050 
3051 void LIR_Assembler::fld(int i) {
3052   Unimplemented();
3053 }
3054 
3055 void LIR_Assembler::ffree(int i) {
3056   Unimplemented();
3057 }
3058 
3059 void LIR_Assembler::rt_call(LIR_Opr result, address dest,
3060                             const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
3061 
3062   // if tmp is invalid, then the function being called doesn&#39;t destroy the thread
3063   if (tmp-&gt;is_valid()) {
3064     __ save_thread(tmp-&gt;as_pointer_register());
3065   }
3066   __ call(dest, relocInfo::runtime_call_type);
3067   __ delayed()-&gt;nop();
3068   if (info != NULL) {
3069     add_call_info_here(info);
3070   }
3071   if (tmp-&gt;is_valid()) {
3072     __ restore_thread(tmp-&gt;as_pointer_register());
3073   }
3074 
3075 #ifdef ASSERT
3076   __ verify_thread();
3077 #endif // ASSERT
3078 }
3079 
3080 
3081 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
3082   ShouldNotReachHere();
3083 
3084   NEEDS_CLEANUP;
3085   if (type == T_LONG) {
3086     LIR_Address* mem_addr = dest-&gt;is_address() ? dest-&gt;as_address_ptr() : src-&gt;as_address_ptr();
3087 
3088     // (extended to allow indexed as well as constant displaced for JSR-166)
3089     Register idx = noreg; // contains either constant offset or index
3090 
3091     int disp = mem_addr-&gt;disp();
3092     if (mem_addr-&gt;index() == LIR_OprFact::illegalOpr) {
3093       if (!Assembler::is_simm13(disp)) {
3094         idx = O7;
3095         __ set(disp, idx);
3096       }
3097     } else {
3098       assert(disp == 0, &quot;not both indexed and disp&quot;);
3099       idx = mem_addr-&gt;index()-&gt;as_register();
3100     }
3101 
3102     int null_check_offset = -1;
3103 
3104     Register base = mem_addr-&gt;base()-&gt;as_register();
3105     if (src-&gt;is_register() &amp;&amp; dest-&gt;is_address()) {
3106       // G4 is high half, G5 is low half
3107       // clear the top bits of G5, and scale up G4
3108       __ srl (src-&gt;as_register_lo(),  0, G5);
3109       __ sllx(src-&gt;as_register_hi(), 32, G4);
3110       // combine the two halves into the 64 bits of G4
3111       __ or3(G4, G5, G4);
3112       null_check_offset = __ offset();
3113       if (idx == noreg) {
3114         __ stx(G4, base, disp);
3115       } else {
3116         __ stx(G4, base, idx);
3117       }
3118     } else if (src-&gt;is_address() &amp;&amp; dest-&gt;is_register()) {
3119       null_check_offset = __ offset();
3120       if (idx == noreg) {
3121         __ ldx(base, disp, G5);
3122       } else {
3123         __ ldx(base, idx, G5);
3124       }
3125       __ srax(G5, 32, dest-&gt;as_register_hi()); // fetch the high half into hi
3126       __ mov (G5, dest-&gt;as_register_lo());     // copy low half into lo
3127     } else {
3128       Unimplemented();
3129     }
3130     if (info != NULL) {
3131       add_debug_info_for_null_check(null_check_offset, info);
3132     }
3133 
3134   } else {
3135     // use normal move for all other volatiles since they don&#39;t need
3136     // special handling to remain atomic.
3137     move_op(src, dest, type, lir_patch_none, info, false, false, false);
3138   }
3139 }
3140 
3141 void LIR_Assembler::membar() {
3142   // only StoreLoad membars are ever explicitly needed on sparcs in TSO mode
3143   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
3144 }
3145 
3146 void LIR_Assembler::membar_acquire() {
3147   // no-op on TSO
3148 }
3149 
3150 void LIR_Assembler::membar_release() {
3151   // no-op on TSO
3152 }
3153 
3154 void LIR_Assembler::membar_loadload() {
3155   // no-op
3156   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
3157 }
3158 
3159 void LIR_Assembler::membar_storestore() {
3160   // no-op
3161   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
3162 }
3163 
3164 void LIR_Assembler::membar_loadstore() {
3165   // no-op
3166   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
3167 }
3168 
3169 void LIR_Assembler::membar_storeload() {
3170   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
3171 }
3172 
3173 void LIR_Assembler::on_spin_wait() {
3174   Unimplemented();
3175 }
3176 
3177 // Pack two sequential registers containing 32 bit values
3178 // into a single 64 bit register.
3179 // src and src-&gt;successor() are packed into dst
3180 // src and dst may be the same register.
3181 // Note: src is destroyed
3182 void LIR_Assembler::pack64(LIR_Opr src, LIR_Opr dst) {
3183   Register rs = src-&gt;as_register();
3184   Register rd = dst-&gt;as_register_lo();
3185   __ sllx(rs, 32, rs);
3186   __ srl(rs-&gt;successor(), 0, rs-&gt;successor());
3187   __ or3(rs, rs-&gt;successor(), rd);
3188 }
3189 
3190 // Unpack a 64 bit value in a register into
3191 // two sequential registers.
3192 // src is unpacked into dst and dst-&gt;successor()
3193 void LIR_Assembler::unpack64(LIR_Opr src, LIR_Opr dst) {
3194   Register rs = src-&gt;as_register_lo();
3195   Register rd = dst-&gt;as_register_hi();
3196   assert_different_registers(rs, rd, rd-&gt;successor());
3197   __ srlx(rs, 32, rd);
3198   __ srl (rs,  0, rd-&gt;successor());
3199 }
3200 
3201 void LIR_Assembler::leal(LIR_Opr addr_opr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
3202   const LIR_Address* addr = addr_opr-&gt;as_address_ptr();
3203   assert(addr-&gt;scale() == LIR_Address::times_1, &quot;can&#39;t handle complex addresses yet&quot;);
3204   const Register dest_reg = dest-&gt;as_pointer_register();
3205   const Register base_reg = addr-&gt;base()-&gt;as_pointer_register();
3206 
3207   if (patch_code != lir_patch_none) {
3208     PatchingStub* patch = new PatchingStub(_masm, PatchingStub::access_field_id);
3209     assert(addr-&gt;disp() != 0, &quot;must have&quot;);
3210     assert(base_reg != G3_scratch, &quot;invariant&quot;);
3211     __ patchable_set(0, G3_scratch);
3212     patching_epilog(patch, patch_code, base_reg, info);
3213     assert(dest_reg != G3_scratch, &quot;invariant&quot;);
3214     if (addr-&gt;index()-&gt;is_valid()) {
3215       const Register index_reg = addr-&gt;index()-&gt;as_pointer_register();
3216       assert(index_reg != G3_scratch, &quot;invariant&quot;);
3217       __ add(index_reg, G3_scratch, G3_scratch);
3218     }
3219     __ add(base_reg, G3_scratch, dest_reg);
3220   } else {
3221     if (Assembler::is_simm13(addr-&gt;disp())) {
3222       if (addr-&gt;index()-&gt;is_valid()) {
3223         const Register index_reg = addr-&gt;index()-&gt;as_pointer_register();
3224         assert(index_reg != G3_scratch, &quot;invariant&quot;);
3225         __ add(base_reg, addr-&gt;disp(), G3_scratch);
3226         __ add(index_reg, G3_scratch, dest_reg);
3227       } else {
3228         __ add(base_reg, addr-&gt;disp(), dest_reg);
3229       }
3230     } else {
3231       __ set(addr-&gt;disp(), G3_scratch);
3232       if (addr-&gt;index()-&gt;is_valid()) {
3233         const Register index_reg = addr-&gt;index()-&gt;as_pointer_register();
3234         assert(index_reg != G3_scratch, &quot;invariant&quot;);
3235         __ add(index_reg, G3_scratch, G3_scratch);
3236       }
3237       __ add(base_reg, G3_scratch, dest_reg);
3238     }
3239   }
3240 }
3241 
3242 
3243 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
3244   assert(result_reg-&gt;is_register(), &quot;check&quot;);
3245   __ mov(G2_thread, result_reg-&gt;as_register());
3246 }
3247 
3248 #ifdef ASSERT
3249 // emit run-time assertion
3250 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
3251   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
3252 
3253   if (op-&gt;in_opr1()-&gt;is_valid()) {
3254     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
3255     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
3256   } else {
3257     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
3258     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
3259   }
3260 
3261   Label ok;
3262   if (op-&gt;condition() != lir_cond_always) {
3263     Assembler::Condition acond;
3264     switch (op-&gt;condition()) {
3265       case lir_cond_equal:        acond = Assembler::equal;                break;
3266       case lir_cond_notEqual:     acond = Assembler::notEqual;             break;
3267       case lir_cond_less:         acond = Assembler::less;                 break;
3268       case lir_cond_lessEqual:    acond = Assembler::lessEqual;            break;
3269       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;         break;
3270       case lir_cond_greater:      acond = Assembler::greater;              break;
3271       case lir_cond_aboveEqual:   acond = Assembler::greaterEqualUnsigned; break;
3272       case lir_cond_belowEqual:   acond = Assembler::lessEqualUnsigned;    break;
3273       default:                         ShouldNotReachHere();
3274     };
3275     __ br(acond, false, Assembler::pt, ok);
3276     __ delayed()-&gt;nop();
3277   }
3278   if (op-&gt;halt()) {
3279     const char* str = __ code_string(op-&gt;msg());
3280     __ stop(str);
3281   } else {
3282     breakpoint();
3283   }
3284   __ bind(ok);
3285 }
3286 #endif
3287 
3288 void LIR_Assembler::peephole(LIR_List* lir) {
3289   LIR_OpList* inst = lir-&gt;instructions_list();
3290   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3291     LIR_Op* op = inst-&gt;at(i);
3292     switch (op-&gt;code()) {
3293       case lir_cond_float_branch:
3294       case lir_branch: {
3295         LIR_OpBranch* branch = op-&gt;as_OpBranch();
3296         assert(branch-&gt;info() == NULL, &quot;shouldn&#39;t be state on branches anymore&quot;);
3297         LIR_Op* delay_op = NULL;
3298         // we&#39;d like to be able to pull following instructions into
3299         // this slot but we don&#39;t know enough to do it safely yet so
3300         // only optimize block to block control flow.
3301         if (LIRFillDelaySlots &amp;&amp; branch-&gt;block()) {
3302           LIR_Op* prev = inst-&gt;at(i - 1);
3303           if (prev &amp;&amp; LIR_Assembler::is_single_instruction(prev) &amp;&amp; prev-&gt;info() == NULL) {
3304             // swap previous instruction into delay slot
3305             inst-&gt;at_put(i - 1, op);
3306             inst-&gt;at_put(i, new LIR_OpDelay(prev, op-&gt;info()));
3307 #ifndef PRODUCT
3308             if (LIRTracePeephole) {
3309               tty-&gt;print_cr(&quot;delayed&quot;);
3310               inst-&gt;at(i - 1)-&gt;print();
3311               inst-&gt;at(i)-&gt;print();
3312               tty-&gt;cr();
3313             }
3314 #endif
3315             continue;
3316           }
3317         }
3318 
3319         if (!delay_op) {
3320           delay_op = new LIR_OpDelay(new LIR_Op0(lir_nop), NULL);
3321         }
3322         inst-&gt;insert_before(i + 1, delay_op);
3323         break;
3324       }
3325       case lir_static_call:
3326       case lir_virtual_call:
3327       case lir_icvirtual_call:
3328       case lir_optvirtual_call:
3329       case lir_dynamic_call: {
3330         LIR_Op* prev = inst-&gt;at(i - 1);
3331         if (LIRFillDelaySlots &amp;&amp; prev &amp;&amp; prev-&gt;code() == lir_move &amp;&amp; prev-&gt;info() == NULL &amp;&amp;
3332             (op-&gt;code() != lir_virtual_call ||
3333              !prev-&gt;result_opr()-&gt;is_single_cpu() ||
3334              prev-&gt;result_opr()-&gt;as_register() != O0) &amp;&amp;
3335             LIR_Assembler::is_single_instruction(prev)) {
3336           // Only moves without info can be put into the delay slot.
3337           // Also don&#39;t allow the setup of the receiver in the delay
3338           // slot for vtable calls.
3339           inst-&gt;at_put(i - 1, op);
3340           inst-&gt;at_put(i, new LIR_OpDelay(prev, op-&gt;info()));
3341 #ifndef PRODUCT
3342           if (LIRTracePeephole) {
3343             tty-&gt;print_cr(&quot;delayed&quot;);
3344             inst-&gt;at(i - 1)-&gt;print();
3345             inst-&gt;at(i)-&gt;print();
3346             tty-&gt;cr();
3347           }
3348 #endif
3349         } else {
3350           LIR_Op* delay_op = new LIR_OpDelay(new LIR_Op0(lir_nop), op-&gt;as_OpJavaCall()-&gt;info());
3351           inst-&gt;insert_before(i + 1, delay_op);
3352           i++;
3353         }
3354         break;
3355       }
3356     }
3357   }
3358 }
3359 
3360 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
3361   LIR_Address* addr = src-&gt;as_address_ptr();
3362 
3363   assert(data == dest, &quot;swap uses only 2 operands&quot;);
3364   assert (code == lir_xchg, &quot;no xadd on sparc&quot;);
3365 
3366   if (data-&gt;type() == T_INT) {
3367     __ swap(as_Address(addr), data-&gt;as_register());
3368   } else if (data-&gt;is_oop()) {
3369     Register obj = data-&gt;as_register();
3370     Register narrow = tmp-&gt;as_register();
3371     assert(UseCompressedOops, &quot;swap is 32bit only&quot;);
3372     __ encode_heap_oop(obj, narrow);
3373     __ swap(as_Address(addr), narrow);
3374     __ decode_heap_oop(narrow, obj);
3375   } else {
3376     ShouldNotReachHere();
3377   }
3378 }
3379 
3380 #undef __
    </pre>
  </body>
</html>
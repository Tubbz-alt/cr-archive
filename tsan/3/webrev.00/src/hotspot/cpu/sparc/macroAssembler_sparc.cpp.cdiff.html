<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/sparc/macroAssembler_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCodeInstaller_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_sparc.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/macroAssembler_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,10 ***</span>
<span class="line-new-header">--- 31,11 ---</span>
  #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/accessDecorators.hpp&quot;
<span class="line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/flags/flagSetting.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,10 ***</span>
<span class="line-new-header">--- 46,11 ---</span>
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #ifdef COMPILER2
  #include &quot;opto/intrinsicnode.hpp&quot;
  #endif
  
  #ifdef PRODUCT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 987,11 ***</span>
  AddressLiteral MacroAssembler::constant_oop_address(jobject obj) {
  #ifdef ASSERT
    {
      ThreadInVMfromUnknown tiv;
      assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
<span class="line-modified">!     assert(Universe::heap()-&gt;is_in_reserved(JNIHandles::resolve(obj)), &quot;not an oop&quot;);</span>
    }
  #endif
    int oop_index = oop_recorder()-&gt;find_index(obj);
    return AddressLiteral(obj, oop_Relocation::spec(oop_index));
  }
<span class="line-new-header">--- 989,11 ---</span>
  AddressLiteral MacroAssembler::constant_oop_address(jobject obj) {
  #ifdef ASSERT
    {
      ThreadInVMfromUnknown tiv;
      assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
<span class="line-modified">!     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);</span>
    }
  #endif
    int oop_index = oop_recorder()-&gt;find_index(obj);
    return AddressLiteral(obj, oop_Relocation::spec(oop_index));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1013,11 ***</span>
  
  void  MacroAssembler::set_narrow_klass(Klass* k, Register d) {
    assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
    int klass_index = oop_recorder()-&gt;find_index(k);
    RelocationHolder rspec = metadata_Relocation::spec(klass_index);
<span class="line-modified">!   narrowOop encoded_k = Klass::encode_klass(k);</span>
  
    assert_not_delayed();
    // Relocation with special format (see relocInfo_sparc.hpp).
    relocate(rspec, 1);
    // Assembler::sethi(encoded_k, d);
<span class="line-new-header">--- 1015,11 ---</span>
  
  void  MacroAssembler::set_narrow_klass(Klass* k, Register d) {
    assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
    int klass_index = oop_recorder()-&gt;find_index(k);
    RelocationHolder rspec = metadata_Relocation::spec(klass_index);
<span class="line-modified">!   narrowOop encoded_k = CompressedKlassPointers::encode(k);</span>
  
    assert_not_delayed();
    // Relocation with special format (see relocInfo_sparc.hpp).
    relocate(rspec, 1);
    // Assembler::sethi(encoded_k, d);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1127,25 ***</span>
    for (int k = 0; k &lt; 64; k += 2) {
      a-&gt;ldf(FloatRegisterImpl::D, O0, d_offset(k), as_FloatRegister(k));
    }
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- // pushes double TOS element of FPU stack on CPU stack; pops from FPU stack</span>
<span class="line-removed">- void MacroAssembler::push_fTOS() {</span>
<span class="line-removed">-   // %%%%%% need to implement this</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // pops double TOS element from CPU stack and pushes on FPU stack</span>
<span class="line-removed">- void MacroAssembler::pop_fTOS() {</span>
<span class="line-removed">-   // %%%%%% need to implement this</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::empty_FPU_stack() {</span>
<span class="line-removed">-   // %%%%%% need to implement this</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void MacroAssembler::_verify_oop(Register reg, const char* msg, const char * file, int line) {
    // plausibility check for oops
    if (!VerifyOops) return;
  
    if (reg == G0)  return;       // always NULL, which is always an oop
<span class="line-new-header">--- 1129,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2449,19 ***</span>
    // Biased locking
    // See whether the lock is currently biased toward our thread and
    // whether the epoch is still valid
    // Note that the runtime guarantees sufficient alignment of JavaThread
    // pointers to allow age to be placed into low bits
<span class="line-modified">!   assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);</span>
<span class="line-modified">!   and3(mark_reg, markOopDesc::biased_lock_mask_in_place, temp_reg);</span>
<span class="line-modified">!   cmp_and_brx_short(temp_reg, markOopDesc::biased_lock_pattern, Assembler::notEqual, Assembler::pn, cas_label);</span>
  
    load_klass(obj_reg, temp_reg);
    ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
    or3(G2_thread, temp_reg, temp_reg);
    xor3(mark_reg, temp_reg, temp_reg);
<span class="line-modified">!   andcc(temp_reg, ~((int) markOopDesc::age_mask_in_place), temp_reg);</span>
    if (counters != NULL) {
      cond_inc(Assembler::equal, (address) counters-&gt;biased_lock_entry_count_addr(), mark_reg, temp_reg);
      // Reload mark_reg as we may need it later
      ld_ptr(Address(obj_reg, oopDesc::mark_offset_in_bytes()), mark_reg);
    }
<span class="line-new-header">--- 2436,19 ---</span>
    // Biased locking
    // See whether the lock is currently biased toward our thread and
    // whether the epoch is still valid
    // Note that the runtime guarantees sufficient alignment of JavaThread
    // pointers to allow age to be placed into low bits
<span class="line-modified">!   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);</span>
<span class="line-modified">!   and3(mark_reg, markWord::biased_lock_mask_in_place, temp_reg);</span>
<span class="line-modified">!   cmp_and_brx_short(temp_reg, markWord::biased_lock_pattern, Assembler::notEqual, Assembler::pn, cas_label);</span>
  
    load_klass(obj_reg, temp_reg);
    ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
    or3(G2_thread, temp_reg, temp_reg);
    xor3(mark_reg, temp_reg, temp_reg);
<span class="line-modified">!   andcc(temp_reg, ~((int) markWord::age_mask_in_place), temp_reg);</span>
    if (counters != NULL) {
      cond_inc(Assembler::equal, (address) counters-&gt;biased_lock_entry_count_addr(), mark_reg, temp_reg);
      // Reload mark_reg as we may need it later
      ld_ptr(Address(obj_reg, oopDesc::mark_offset_in_bytes()), mark_reg);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2480,11 ***</span>
    // header.
  
    // If the low three bits in the xor result aren&#39;t clear, that means
    // the prototype header is no longer biased and we have to revoke
    // the bias on this object.
<span class="line-modified">!   btst(markOopDesc::biased_lock_mask_in_place, temp_reg);</span>
    brx(Assembler::notZero, false, Assembler::pn, try_revoke_bias);
  
    // Biasing is still enabled for this data type. See whether the
    // epoch of the current bias is still valid, meaning that the epoch
    // bits of the mark word are equal to the epoch bits of the
<span class="line-new-header">--- 2467,11 ---</span>
    // header.
  
    // If the low three bits in the xor result aren&#39;t clear, that means
    // the prototype header is no longer biased and we have to revoke
    // the bias on this object.
<span class="line-modified">!   btst(markWord::biased_lock_mask_in_place, temp_reg);</span>
    brx(Assembler::notZero, false, Assembler::pn, try_revoke_bias);
  
    // Biasing is still enabled for this data type. See whether the
    // epoch of the current bias is still valid, meaning that the epoch
    // bits of the mark word are equal to the epoch bits of the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2492,21 ***</span>
    // only change at a safepoint.) If not, attempt to rebias the object
    // toward the current thread. Note that we must be absolutely sure
    // that the current epoch is invalid in order to do this because
    // otherwise the manipulations it performs on the mark word are
    // illegal.
<span class="line-modified">!   delayed()-&gt;btst(markOopDesc::epoch_mask_in_place, temp_reg);</span>
    brx(Assembler::notZero, false, Assembler::pn, try_rebias);
  
    // The epoch of the current bias is still valid but we know nothing
    // about the owner; it might be set or it might be clear. Try to
    // acquire the bias of the object using an atomic operation. If this
    // fails we will go in to the runtime to revoke the object&#39;s bias.
    // Note that we first construct the presumed unbiased header so we
    // don&#39;t accidentally blow away another thread&#39;s valid bias.
    delayed()-&gt;and3(mark_reg,
<span class="line-modified">!                   markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place,</span>
                    mark_reg);
    or3(G2_thread, mark_reg, temp_reg);
    cas_ptr(mark_addr.base(), mark_reg, temp_reg);
    // If the biasing toward our thread failed, this means that
    // another thread succeeded in biasing it toward itself and we
<span class="line-new-header">--- 2479,21 ---</span>
    // only change at a safepoint.) If not, attempt to rebias the object
    // toward the current thread. Note that we must be absolutely sure
    // that the current epoch is invalid in order to do this because
    // otherwise the manipulations it performs on the mark word are
    // illegal.
<span class="line-modified">!   delayed()-&gt;btst(markWord::epoch_mask_in_place, temp_reg);</span>
    brx(Assembler::notZero, false, Assembler::pn, try_rebias);
  
    // The epoch of the current bias is still valid but we know nothing
    // about the owner; it might be set or it might be clear. Try to
    // acquire the bias of the object using an atomic operation. If this
    // fails we will go in to the runtime to revoke the object&#39;s bias.
    // Note that we first construct the presumed unbiased header so we
    // don&#39;t accidentally blow away another thread&#39;s valid bias.
    delayed()-&gt;and3(mark_reg,
<span class="line-modified">!                   markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place,</span>
                    mark_reg);
    or3(G2_thread, mark_reg, temp_reg);
    cas_ptr(mark_addr.base(), mark_reg, temp_reg);
    // If the biasing toward our thread failed, this means that
    // another thread succeeded in biasing it toward itself and we
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2583,12 ***</span>
    // First, the interpreter checks for IllegalMonitorStateException at
    // a higher level. Second, if the bias was revoked while we held the
    // lock, the object could not be rebiased toward another thread, so
    // the bias bit would be clear.
    ld_ptr(mark_addr, temp_reg);
<span class="line-modified">!   and3(temp_reg, markOopDesc::biased_lock_mask_in_place, temp_reg);</span>
<span class="line-modified">!   cmp(temp_reg, markOopDesc::biased_lock_pattern);</span>
    brx(Assembler::equal, allow_delay_slot_filling, Assembler::pt, done);
    delayed();
    if (!allow_delay_slot_filling) {
      nop();
    }
<span class="line-new-header">--- 2570,12 ---</span>
    // First, the interpreter checks for IllegalMonitorStateException at
    // a higher level. Second, if the bias was revoked while we held the
    // lock, the object could not be rebiased toward another thread, so
    // the bias bit would be clear.
    ld_ptr(mark_addr, temp_reg);
<span class="line-modified">!   and3(temp_reg, markWord::biased_lock_mask_in_place, temp_reg);</span>
<span class="line-modified">!   cmp(temp_reg, markWord::biased_lock_pattern);</span>
    brx(Assembler::equal, allow_delay_slot_filling, Assembler::pt, done);
    delayed();
    if (!allow_delay_slot_filling) {
      nop();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2600,16 ***</span>
  // The code could be tightened up considerably.
  //
  // box-&gt;dhw disposition - post-conditions at DONE_LABEL.
  // -   Successful inflated lock:  box-&gt;dhw != 0.
  //     Any non-zero value suffices.
<span class="line-modified">! //     Consider G2_thread, rsp, boxReg, or markOopDesc::unused_mark()</span>
  // -   Successful Stack-lock: box-&gt;dhw == mark.
  //     box-&gt;dhw must contain the displaced mark word value
  // -   Failure -- icc.ZFlag == 0 and box-&gt;dhw is undefined.
<span class="line-modified">! //     The slow-path fast_enter() and slow_enter() operators</span>
<span class="line-modified">! //     are responsible for setting box-&gt;dhw = NonZero (typically markOopDesc::unused_mark()).</span>
  // -   Biased: box-&gt;dhw is undefined
  //
  // SPARC refworkload performance - specifically jetstream and scimark - are
  // extremely sensitive to the size of the code emitted by compiler_lock_object
  // and compiler_unlock_object.  Critically, the key factor is code size, not path
<span class="line-new-header">--- 2587,16 ---</span>
  // The code could be tightened up considerably.
  //
  // box-&gt;dhw disposition - post-conditions at DONE_LABEL.
  // -   Successful inflated lock:  box-&gt;dhw != 0.
  //     Any non-zero value suffices.
<span class="line-modified">! //     Consider G2_thread, rsp, boxReg, or markWord::unused_mark()</span>
  // -   Successful Stack-lock: box-&gt;dhw == mark.
  //     box-&gt;dhw must contain the displaced mark word value
  // -   Failure -- icc.ZFlag == 0 and box-&gt;dhw is undefined.
<span class="line-modified">! //     The slow-path enter() is responsible for setting</span>
<span class="line-modified">! //     box-&gt;dhw = NonZero (typically markWord::unused_mark()).</span>
  // -   Biased: box-&gt;dhw is undefined
  //
  // SPARC refworkload performance - specifically jetstream and scimark - are
  // extremely sensitive to the size of the code emitted by compiler_lock_object
  // and compiler_unlock_object.  Critically, the key factor is code size, not path
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2655,11 ***</span>
     //   ST box-&gt;dhw  = mark   -- save fetched mark in on-stack basiclock box
     //   ST obj-&gt;mark = box    -- overwrite transient 0 value
     // This presumes TSO, of course.
  
     mov(0, Rscratch);
<span class="line-modified">!    or3(Rmark, markOopDesc::unlocked_value, Rmark);</span>
     assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
     cas_ptr(mark_addr.base(), Rmark, Rscratch);
  // prefetch (mark_addr, Assembler::severalWritesAndPossiblyReads);
     cmp(Rscratch, Rmark);
     brx(Assembler::notZero, false, Assembler::pn, Recursive);
<span class="line-new-header">--- 2642,11 ---</span>
     //   ST box-&gt;dhw  = mark   -- save fetched mark in on-stack basiclock box
     //   ST obj-&gt;mark = box    -- overwrite transient 0 value
     // This presumes TSO, of course.
  
     mov(0, Rscratch);
<span class="line-modified">!    or3(Rmark, markWord::unlocked_value, Rmark);</span>
     assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
     cas_ptr(mark_addr.base(), Rmark, Rscratch);
  // prefetch (mark_addr, Assembler::severalWritesAndPossiblyReads);
     cmp(Rscratch, Rmark);
     brx(Assembler::notZero, false, Assembler::pn, Recursive);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2709,11 ***</span>
     cas_ptr(Rmark, G0, Rscratch);
     andcc(Rscratch, Rscratch, G0);             // set ICCs for done: icc.zf iff success
     // set icc.zf : 1=success 0=failure
     // ST box-&gt;displaced_header = NonZero.
     // Any non-zero value suffices:
<span class="line-modified">!    //    markOopDesc::unused_mark(), G2_thread, RBox, RScratch, rsp, etc.</span>
     st_ptr(Rbox, Rbox, BasicLock::displaced_header_offset_in_bytes());
     // Intentional fall-through into done
  
     bind   (done);
  }
<span class="line-new-header">--- 2696,11 ---</span>
     cas_ptr(Rmark, G0, Rscratch);
     andcc(Rscratch, Rscratch, G0);             // set ICCs for done: icc.zf iff success
     // set icc.zf : 1=success 0=failure
     // ST box-&gt;displaced_header = NonZero.
     // Any non-zero value suffices:
<span class="line-modified">!    //    markWord::unused_mark(), G2_thread, RBox, RScratch, rsp, etc.</span>
     st_ptr(Rbox, Rbox, BasicLock::displaced_header_offset_in_bytes());
     // Intentional fall-through into done
  
     bind   (done);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2823,51 ***</span>
     // Intentional fall through into done ...
  
     bind(done);
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::print_CPU_state() {</span>
<span class="line-removed">-   // %%%%% need to implement this</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::verify_FPU(int stack_depth, const char* s) {</span>
<span class="line-removed">-   // %%%%% need to implement this</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::push_IU_state() {</span>
<span class="line-removed">-   // %%%%% need to implement this</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::pop_IU_state() {</span>
<span class="line-removed">-   // %%%%% need to implement this</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::push_FPU_state() {</span>
<span class="line-removed">-   // %%%%% need to implement this</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::pop_FPU_state() {</span>
<span class="line-removed">-   // %%%%% need to implement this</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::push_CPU_state() {</span>
<span class="line-removed">-   // %%%%% need to implement this</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::pop_CPU_state() {</span>
<span class="line-removed">-   // %%%%% need to implement this</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  void MacroAssembler::verify_tlab() {
  #ifdef ASSERT
    if (UseTLAB &amp;&amp; VerifyOops) {
      Label next, next2, ok;
      Register t1 = L0;
<span class="line-new-header">--- 2810,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3293,13 ***</span>
  
  
  void MacroAssembler::encode_heap_oop(Register src, Register dst) {
    assert (UseCompressedOops, &quot;must be compressed&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<span class="line-modified">!   assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
    verify_oop(src);
<span class="line-modified">!   if (Universe::narrow_oop_base() == NULL) {</span>
      srlx(src, LogMinObjAlignmentInBytes, dst);
      return;
    }
    Label done;
    if (src == dst) {
<span class="line-new-header">--- 3239,13 ---</span>
  
  
  void MacroAssembler::encode_heap_oop(Register src, Register dst) {
    assert (UseCompressedOops, &quot;must be compressed&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<span class="line-modified">!   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);</span>
    verify_oop(src);
<span class="line-modified">!   if (CompressedOops::base() == NULL) {</span>
      srlx(src, LogMinObjAlignmentInBytes, dst);
      return;
    }
    Label done;
    if (src == dst) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3321,23 ***</span>
  
  
  void MacroAssembler::encode_heap_oop_not_null(Register r) {
    assert (UseCompressedOops, &quot;must be compressed&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<span class="line-modified">!   assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
    verify_oop(r);
<span class="line-modified">!   if (Universe::narrow_oop_base() != NULL)</span>
      sub(r, G6_heapbase, r);
    srlx(r, LogMinObjAlignmentInBytes, r);
  }
  
  void MacroAssembler::encode_heap_oop_not_null(Register src, Register dst) {
    assert (UseCompressedOops, &quot;must be compressed&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<span class="line-modified">!   assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
    verify_oop(src);
<span class="line-modified">!   if (Universe::narrow_oop_base() == NULL) {</span>
      srlx(src, LogMinObjAlignmentInBytes, dst);
    } else {
      sub(src, G6_heapbase, dst);
      srlx(dst, LogMinObjAlignmentInBytes, dst);
    }
<span class="line-new-header">--- 3267,23 ---</span>
  
  
  void MacroAssembler::encode_heap_oop_not_null(Register r) {
    assert (UseCompressedOops, &quot;must be compressed&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<span class="line-modified">!   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);</span>
    verify_oop(r);
<span class="line-modified">!   if (CompressedOops::base() != NULL)</span>
      sub(r, G6_heapbase, r);
    srlx(r, LogMinObjAlignmentInBytes, r);
  }
  
  void MacroAssembler::encode_heap_oop_not_null(Register src, Register dst) {
    assert (UseCompressedOops, &quot;must be compressed&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<span class="line-modified">!   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);</span>
    verify_oop(src);
<span class="line-modified">!   if (CompressedOops::base() == NULL) {</span>
      srlx(src, LogMinObjAlignmentInBytes, dst);
    } else {
      sub(src, G6_heapbase, dst);
      srlx(dst, LogMinObjAlignmentInBytes, dst);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3345,13 ***</span>
  
  // Same algorithm as oops.inline.hpp decode_heap_oop.
  void  MacroAssembler::decode_heap_oop(Register src, Register dst) {
    assert (UseCompressedOops, &quot;must be compressed&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<span class="line-modified">!   assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
    sllx(src, LogMinObjAlignmentInBytes, dst);
<span class="line-modified">!   if (Universe::narrow_oop_base() != NULL) {</span>
      Label done;
      bpr(rc_nz, true, Assembler::pt, dst, done);
      delayed() -&gt; add(dst, G6_heapbase, dst); // annuled if not taken
      bind(done);
    }
<span class="line-new-header">--- 3291,13 ---</span>
  
  // Same algorithm as oops.inline.hpp decode_heap_oop.
  void  MacroAssembler::decode_heap_oop(Register src, Register dst) {
    assert (UseCompressedOops, &quot;must be compressed&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<span class="line-modified">!   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);</span>
    sllx(src, LogMinObjAlignmentInBytes, dst);
<span class="line-modified">!   if (CompressedOops::base() != NULL) {</span>
      Label done;
      bpr(rc_nz, true, Assembler::pt, dst, done);
      delayed() -&gt; add(dst, G6_heapbase, dst); // annuled if not taken
      bind(done);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3362,74 ***</span>
    // Do not add assert code to this unless you change vtableStubs_sparc.cpp
    // pd_code_size_limit.
    // Also do not verify_oop as this is called by verify_oop.
    assert (UseCompressedOops, &quot;must be compressed&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<span class="line-modified">!   assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
    sllx(r, LogMinObjAlignmentInBytes, r);
<span class="line-modified">!   if (Universe::narrow_oop_base() != NULL)</span>
      add(r, G6_heapbase, r);
  }
  
  void  MacroAssembler::decode_heap_oop_not_null(Register src, Register dst) {
    // Do not add assert code to this unless you change vtableStubs_sparc.cpp
    // pd_code_size_limit.
    // Also do not verify_oop as this is called by verify_oop.
    assert (UseCompressedOops, &quot;must be compressed&quot;);
<span class="line-modified">!   assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
    sllx(src, LogMinObjAlignmentInBytes, dst);
<span class="line-modified">!   if (Universe::narrow_oop_base() != NULL)</span>
      add(dst, G6_heapbase, dst);
  }
  
  void MacroAssembler::encode_klass_not_null(Register r) {
    assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
<span class="line-modified">!   if (Universe::narrow_klass_base() != NULL) {</span>
      assert(r != G6_heapbase, &quot;bad register choice&quot;);
<span class="line-modified">!     set((intptr_t)Universe::narrow_klass_base(), G6_heapbase);</span>
      sub(r, G6_heapbase, r);
<span class="line-modified">!     if (Universe::narrow_klass_shift() != 0) {</span>
<span class="line-modified">!       assert (LogKlassAlignmentInBytes == Universe::narrow_klass_shift(), &quot;decode alg wrong&quot;);</span>
        srlx(r, LogKlassAlignmentInBytes, r);
      }
      reinit_heapbase();
    } else {
<span class="line-modified">!     assert (LogKlassAlignmentInBytes == Universe::narrow_klass_shift() || Universe::narrow_klass_shift() == 0, &quot;decode alg wrong&quot;);</span>
<span class="line-modified">!     srlx(r, Universe::narrow_klass_shift(), r);</span>
    }
  }
  
  void MacroAssembler::encode_klass_not_null(Register src, Register dst) {
    if (src == dst) {
      encode_klass_not_null(src);
    } else {
      assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
<span class="line-modified">!     if (Universe::narrow_klass_base() != NULL) {</span>
<span class="line-modified">!       set((intptr_t)Universe::narrow_klass_base(), dst);</span>
        sub(src, dst, dst);
<span class="line-modified">!       if (Universe::narrow_klass_shift() != 0) {</span>
          srlx(dst, LogKlassAlignmentInBytes, dst);
        }
      } else {
        // shift src into dst
<span class="line-modified">!       assert (LogKlassAlignmentInBytes == Universe::narrow_klass_shift() || Universe::narrow_klass_shift() == 0, &quot;decode alg wrong&quot;);</span>
<span class="line-modified">!       srlx(src, Universe::narrow_klass_shift(), dst);</span>
      }
    }
  }
  
  // Function instr_size_for_decode_klass_not_null() counts the instructions
  // generated by decode_klass_not_null() and reinit_heapbase().  Hence, if
  // the instructions they generate change, then this method needs to be updated.
  int MacroAssembler::instr_size_for_decode_klass_not_null() {
    assert (UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
    int num_instrs = 1;  // shift src,dst or add
<span class="line-modified">!   if (Universe::narrow_klass_base() != NULL) {</span>
      // set + add + set
<span class="line-modified">!     num_instrs += insts_for_internal_set((intptr_t)Universe::narrow_klass_base()) +</span>
<span class="line-modified">!                   insts_for_internal_set((intptr_t)Universe::narrow_ptrs_base());</span>
<span class="line-modified">!     if (Universe::narrow_klass_shift() != 0) {</span>
        num_instrs += 1;  // sllx
      }
    }
    return num_instrs * BytesPerInstWord;
  }
<span class="line-new-header">--- 3308,74 ---</span>
    // Do not add assert code to this unless you change vtableStubs_sparc.cpp
    // pd_code_size_limit.
    // Also do not verify_oop as this is called by verify_oop.
    assert (UseCompressedOops, &quot;must be compressed&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<span class="line-modified">!   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);</span>
    sllx(r, LogMinObjAlignmentInBytes, r);
<span class="line-modified">!   if (CompressedOops::base() != NULL)</span>
      add(r, G6_heapbase, r);
  }
  
  void  MacroAssembler::decode_heap_oop_not_null(Register src, Register dst) {
    // Do not add assert code to this unless you change vtableStubs_sparc.cpp
    // pd_code_size_limit.
    // Also do not verify_oop as this is called by verify_oop.
    assert (UseCompressedOops, &quot;must be compressed&quot;);
<span class="line-modified">!   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);</span>
    sllx(src, LogMinObjAlignmentInBytes, dst);
<span class="line-modified">!   if (CompressedOops::base() != NULL)</span>
      add(dst, G6_heapbase, dst);
  }
  
  void MacroAssembler::encode_klass_not_null(Register r) {
    assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
<span class="line-modified">!   if (CompressedKlassPointers::base() != NULL) {</span>
      assert(r != G6_heapbase, &quot;bad register choice&quot;);
<span class="line-modified">!     set((intptr_t)CompressedKlassPointers::base(), G6_heapbase);</span>
      sub(r, G6_heapbase, r);
<span class="line-modified">!     if (CompressedKlassPointers::shift() != 0) {</span>
<span class="line-modified">!       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);</span>
        srlx(r, LogKlassAlignmentInBytes, r);
      }
      reinit_heapbase();
    } else {
<span class="line-modified">!     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);</span>
<span class="line-modified">!     srlx(r, CompressedKlassPointers::shift(), r);</span>
    }
  }
  
  void MacroAssembler::encode_klass_not_null(Register src, Register dst) {
    if (src == dst) {
      encode_klass_not_null(src);
    } else {
      assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
<span class="line-modified">!     if (CompressedKlassPointers::base() != NULL) {</span>
<span class="line-modified">!       set((intptr_t)CompressedKlassPointers::base(), dst);</span>
        sub(src, dst, dst);
<span class="line-modified">!       if (CompressedKlassPointers::shift() != 0) {</span>
          srlx(dst, LogKlassAlignmentInBytes, dst);
        }
      } else {
        // shift src into dst
<span class="line-modified">!       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);</span>
<span class="line-modified">!       srlx(src, CompressedKlassPointers::shift(), dst);</span>
      }
    }
  }
  
  // Function instr_size_for_decode_klass_not_null() counts the instructions
  // generated by decode_klass_not_null() and reinit_heapbase().  Hence, if
  // the instructions they generate change, then this method needs to be updated.
  int MacroAssembler::instr_size_for_decode_klass_not_null() {
    assert (UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
    int num_instrs = 1;  // shift src,dst or add
<span class="line-modified">!   if (CompressedKlassPointers::base() != NULL) {</span>
      // set + add + set
<span class="line-modified">!     num_instrs += insts_for_internal_set((intptr_t)CompressedKlassPointers::base()) +</span>
<span class="line-modified">!                   insts_for_internal_set((intptr_t)CompressedOops::ptrs_base());</span>
<span class="line-modified">!     if (CompressedKlassPointers::shift() != 0) {</span>
        num_instrs += 1;  // sllx
      }
    }
    return num_instrs * BytesPerInstWord;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3438,55 ***</span>
  // instr_size_for_decode_klass_not_null() needs to get updated.
  void  MacroAssembler::decode_klass_not_null(Register r) {
    // Do not add assert code to this unless you change vtableStubs_sparc.cpp
    // pd_code_size_limit.
    assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
<span class="line-modified">!   if (Universe::narrow_klass_base() != NULL) {</span>
      assert(r != G6_heapbase, &quot;bad register choice&quot;);
<span class="line-modified">!     set((intptr_t)Universe::narrow_klass_base(), G6_heapbase);</span>
<span class="line-modified">!     if (Universe::narrow_klass_shift() != 0)</span>
        sllx(r, LogKlassAlignmentInBytes, r);
      add(r, G6_heapbase, r);
      reinit_heapbase();
    } else {
<span class="line-modified">!     assert (LogKlassAlignmentInBytes == Universe::narrow_klass_shift() || Universe::narrow_klass_shift() == 0, &quot;decode alg wrong&quot;);</span>
<span class="line-modified">!     sllx(r, Universe::narrow_klass_shift(), r);</span>
    }
  }
  
  void  MacroAssembler::decode_klass_not_null(Register src, Register dst) {
    if (src == dst) {
      decode_klass_not_null(src);
    } else {
      // Do not add assert code to this unless you change vtableStubs_sparc.cpp
      // pd_code_size_limit.
      assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
<span class="line-modified">!     if (Universe::narrow_klass_base() != NULL) {</span>
<span class="line-modified">!       if (Universe::narrow_klass_shift() != 0) {</span>
          assert((src != G6_heapbase) &amp;&amp; (dst != G6_heapbase), &quot;bad register choice&quot;);
<span class="line-modified">!         set((intptr_t)Universe::narrow_klass_base(), G6_heapbase);</span>
          sllx(src, LogKlassAlignmentInBytes, dst);
          add(dst, G6_heapbase, dst);
          reinit_heapbase();
        } else {
<span class="line-modified">!         set((intptr_t)Universe::narrow_klass_base(), dst);</span>
          add(src, dst, dst);
        }
      } else {
        // shift/mov src into dst.
<span class="line-modified">!       assert (LogKlassAlignmentInBytes == Universe::narrow_klass_shift() || Universe::narrow_klass_shift() == 0, &quot;decode alg wrong&quot;);</span>
<span class="line-modified">!       sllx(src, Universe::narrow_klass_shift(), dst);</span>
      }
    }
  }
  
  void MacroAssembler::reinit_heapbase() {
    if (UseCompressedOops || UseCompressedClassPointers) {
      if (Universe::heap() != NULL) {
<span class="line-modified">!       set((intptr_t)Universe::narrow_ptrs_base(), G6_heapbase);</span>
      } else {
<span class="line-modified">!       AddressLiteral base(Universe::narrow_ptrs_base_addr());</span>
        load_ptr_contents(base, G6_heapbase);
      }
    }
  }
  
<span class="line-new-header">--- 3384,55 ---</span>
  // instr_size_for_decode_klass_not_null() needs to get updated.
  void  MacroAssembler::decode_klass_not_null(Register r) {
    // Do not add assert code to this unless you change vtableStubs_sparc.cpp
    // pd_code_size_limit.
    assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
<span class="line-modified">!   if (CompressedKlassPointers::base() != NULL) {</span>
      assert(r != G6_heapbase, &quot;bad register choice&quot;);
<span class="line-modified">!     set((intptr_t)CompressedKlassPointers::base(), G6_heapbase);</span>
<span class="line-modified">!     if (CompressedKlassPointers::shift() != 0)</span>
        sllx(r, LogKlassAlignmentInBytes, r);
      add(r, G6_heapbase, r);
      reinit_heapbase();
    } else {
<span class="line-modified">!     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);</span>
<span class="line-modified">!     sllx(r, CompressedKlassPointers::shift(), r);</span>
    }
  }
  
  void  MacroAssembler::decode_klass_not_null(Register src, Register dst) {
    if (src == dst) {
      decode_klass_not_null(src);
    } else {
      // Do not add assert code to this unless you change vtableStubs_sparc.cpp
      // pd_code_size_limit.
      assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
<span class="line-modified">!     if (CompressedKlassPointers::base() != NULL) {</span>
<span class="line-modified">!       if (CompressedKlassPointers::shift() != 0) {</span>
          assert((src != G6_heapbase) &amp;&amp; (dst != G6_heapbase), &quot;bad register choice&quot;);
<span class="line-modified">!         set((intptr_t)CompressedKlassPointers::base(), G6_heapbase);</span>
          sllx(src, LogKlassAlignmentInBytes, dst);
          add(dst, G6_heapbase, dst);
          reinit_heapbase();
        } else {
<span class="line-modified">!         set((intptr_t)CompressedKlassPointers::base(), dst);</span>
          add(src, dst, dst);
        }
      } else {
        // shift/mov src into dst.
<span class="line-modified">!       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);</span>
<span class="line-modified">!       sllx(src, CompressedKlassPointers::shift(), dst);</span>
      }
    }
  }
  
  void MacroAssembler::reinit_heapbase() {
    if (UseCompressedOops || UseCompressedClassPointers) {
      if (Universe::heap() != NULL) {
<span class="line-modified">!       set((intptr_t)CompressedOops::ptrs_base(), G6_heapbase);</span>
      } else {
<span class="line-modified">!       AddressLiteral base(CompressedOops::ptrs_base_addr());</span>
        load_ptr_contents(base, G6_heapbase);
      }
    }
  }
  
</pre>
<center><a href="jvmciCodeInstaller_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_sparc.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/sparc/assembler_sparc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_SPARC_ASSEMBLER_SPARC_HPP
  26 #define CPU_SPARC_ASSEMBLER_SPARC_HPP
  27 
  28 #include &quot;asm/register.hpp&quot;
  29 
  30 // The SPARC Assembler: Pure assembler doing NO optimizations on the instruction
  31 // level; i.e., what you write is what you get. The Assembler is generating code
  32 // into a CodeBuffer.
  33 
  34 class Assembler : public AbstractAssembler {
  35   friend class AbstractAssembler;
  36   friend class AddressLiteral;
  37 
  38   // code patchers need various routines like inv_wdisp()
  39   friend class NativeInstruction;
  40   friend class NativeGeneralJump;
  41   friend class Relocation;
  42   friend class Label;
  43 
  44  public:
  45   // op carries format info; see page 62 &amp; 267
  46 
  47   enum ops {
  48     call_op   = 1, // fmt 1
  49     branch_op = 0, // also sethi (fmt2)
  50     arith_op  = 2, // fmt 3, arith &amp; misc
  51     ldst_op   = 3  // fmt 3, load/store
  52   };
  53 
  54   enum op2s {
  55     bpr_op2   = 3,
  56     fb_op2    = 6,
  57     fbp_op2   = 5,
  58     br_op2    = 2,
  59     bp_op2    = 1,
  60     sethi_op2 = 4
  61   };
  62 
  63   enum op3s {
  64     // selected op3s
  65     add_op3      = 0x00,
  66     and_op3      = 0x01,
  67     or_op3       = 0x02,
  68     xor_op3      = 0x03,
  69     sub_op3      = 0x04,
  70     andn_op3     = 0x05,
  71     orn_op3      = 0x06,
  72     xnor_op3     = 0x07,
  73     addc_op3     = 0x08,
  74     mulx_op3     = 0x09,
  75     umul_op3     = 0x0a,
  76     smul_op3     = 0x0b,
  77     subc_op3     = 0x0c,
  78     udivx_op3    = 0x0d,
  79     udiv_op3     = 0x0e,
  80     sdiv_op3     = 0x0f,
  81 
  82     addcc_op3    = 0x10,
  83     andcc_op3    = 0x11,
  84     orcc_op3     = 0x12,
  85     xorcc_op3    = 0x13,
  86     subcc_op3    = 0x14,
  87     andncc_op3   = 0x15,
  88     orncc_op3    = 0x16,
  89     xnorcc_op3   = 0x17,
  90     addccc_op3   = 0x18,
  91     aes4_op3     = 0x19,
  92     umulcc_op3   = 0x1a,
  93     smulcc_op3   = 0x1b,
  94     subccc_op3   = 0x1c,
  95     udivcc_op3   = 0x1e,
  96     sdivcc_op3   = 0x1f,
  97 
  98     taddcc_op3   = 0x20,
  99     tsubcc_op3   = 0x21,
 100     taddcctv_op3 = 0x22,
 101     tsubcctv_op3 = 0x23,
 102     mulscc_op3   = 0x24,
 103     sll_op3      = 0x25,
 104     sllx_op3     = 0x25,
 105     srl_op3      = 0x26,
 106     srlx_op3     = 0x26,
 107     sra_op3      = 0x27,
 108     srax_op3     = 0x27,
 109     rdreg_op3    = 0x28,
 110     membar_op3   = 0x28,
 111 
 112     flushw_op3   = 0x2b,
 113     movcc_op3    = 0x2c,
 114     sdivx_op3    = 0x2d,
 115     popc_op3     = 0x2e,
 116     movr_op3     = 0x2f,
 117 
 118     sir_op3      = 0x30,
 119     wrreg_op3    = 0x30,
 120     saved_op3    = 0x31,
 121 
 122     fpop1_op3    = 0x34,
 123     fpop2_op3    = 0x35,
 124     impdep1_op3  = 0x36,
 125     addx_op3     = 0x36,
 126     aes3_op3     = 0x36,
 127     sha_op3      = 0x36,
 128     bmask_op3    = 0x36,
 129     bshuffle_op3   = 0x36,
 130     alignaddr_op3  = 0x36,
 131     faligndata_op3 = 0x36,
 132     flog3_op3    = 0x36,
 133     edge_op3     = 0x36,
 134     fzero_op3    = 0x36,
 135     fsrc_op3     = 0x36,
 136     fnot_op3     = 0x36,
 137     mpmul_op3    = 0x36,
 138     umulx_op3    = 0x36,
 139     xmulx_op3    = 0x36,
 140     crc32c_op3   = 0x36,
 141     impdep2_op3  = 0x37,
 142     stpartialf_op3 = 0x37,
 143     jmpl_op3     = 0x38,
 144     rett_op3     = 0x39,
 145     trap_op3     = 0x3a,
 146     flush_op3    = 0x3b,
 147     save_op3     = 0x3c,
 148     restore_op3  = 0x3d,
 149     done_op3     = 0x3e,
 150     retry_op3    = 0x3e,
 151 
 152     lduw_op3     = 0x00,
 153     ldub_op3     = 0x01,
 154     lduh_op3     = 0x02,
 155     ldd_op3      = 0x03,
 156     stw_op3      = 0x04,
 157     stb_op3      = 0x05,
 158     sth_op3      = 0x06,
 159     std_op3      = 0x07,
 160     ldsw_op3     = 0x08,
 161     ldsb_op3     = 0x09,
 162     ldsh_op3     = 0x0a,
 163     ldx_op3      = 0x0b,
 164 
 165     stx_op3      = 0x0e,
 166     swap_op3     = 0x0f,
 167 
 168     stwa_op3     = 0x14,
 169     stxa_op3     = 0x1e,
 170 
 171     ldf_op3      = 0x20,
 172     ldfsr_op3    = 0x21,
 173     ldqf_op3     = 0x22,
 174     lddf_op3     = 0x23,
 175     stf_op3      = 0x24,
 176     stfsr_op3    = 0x25,
 177     stqf_op3     = 0x26,
 178     stdf_op3     = 0x27,
 179 
 180     prefetch_op3 = 0x2d,
 181 
 182     casa_op3     = 0x3c,
 183     casxa_op3    = 0x3e,
 184 
 185     mftoi_op3    = 0x36,
 186 
 187     alt_bit_op3  = 0x10,
 188      cc_bit_op3  = 0x10
 189   };
 190 
 191   enum opfs {
 192     // selected opfs
 193     edge8n_opf         = 0x01,
 194 
 195     fmovs_opf          = 0x01,
 196     fmovd_opf          = 0x02,
 197 
 198     fnegs_opf          = 0x05,
 199     fnegd_opf          = 0x06,
 200 
 201     addxc_opf          = 0x11,
 202     addxccc_opf        = 0x13,
 203     umulxhi_opf        = 0x16,
 204     alignaddr_opf      = 0x18,
 205     bmask_opf          = 0x19,
 206 
 207     fadds_opf          = 0x41,
 208     faddd_opf          = 0x42,
 209     fsubs_opf          = 0x45,
 210     fsubd_opf          = 0x46,
 211 
 212     faligndata_opf     = 0x48,
 213 
 214     fmuls_opf          = 0x49,
 215     fmuld_opf          = 0x4a,
 216     bshuffle_opf       = 0x4c,
 217     fdivs_opf          = 0x4d,
 218     fdivd_opf          = 0x4e,
 219 
 220     fcmps_opf          = 0x51,
 221     fcmpd_opf          = 0x52,
 222 
 223     fstox_opf          = 0x81,
 224     fdtox_opf          = 0x82,
 225     fxtos_opf          = 0x84,
 226     fxtod_opf          = 0x88,
 227     fitos_opf          = 0xc4,
 228     fdtos_opf          = 0xc6,
 229     fitod_opf          = 0xc8,
 230     fstod_opf          = 0xc9,
 231     fstoi_opf          = 0xd1,
 232     fdtoi_opf          = 0xd2,
 233 
 234     mdtox_opf          = 0x110,
 235     mstouw_opf         = 0x111,
 236     mstosw_opf         = 0x113,
 237     xmulx_opf          = 0x115,
 238     xmulxhi_opf        = 0x116,
 239     mxtod_opf          = 0x118,
 240     mwtos_opf          = 0x119,
 241 
 242     aes_kexpand0_opf   = 0x130,
 243     aes_kexpand2_opf   = 0x131,
 244 
 245     sha1_opf           = 0x141,
 246     sha256_opf         = 0x142,
 247     sha512_opf         = 0x143,
 248 
 249     crc32c_opf         = 0x147,
 250     mpmul_opf          = 0x148
 251   };
 252 
 253   enum op5s {
 254     aes_eround01_op5   = 0x00,
 255     aes_eround23_op5   = 0x01,
 256     aes_dround01_op5   = 0x02,
 257     aes_dround23_op5   = 0x03,
 258     aes_eround01_l_op5 = 0x04,
 259     aes_eround23_l_op5 = 0x05,
 260     aes_dround01_l_op5 = 0x06,
 261     aes_dround23_l_op5 = 0x07,
 262     aes_kexpand1_op5   = 0x08
 263   };
 264 
 265   enum RCondition { rc_z = 1, rc_lez = 2, rc_lz = 3, rc_nz = 5, rc_gz = 6, rc_gez = 7, rc_last = rc_gez };
 266 
 267   enum Condition {
 268      // for FBfcc &amp; FBPfcc instruction
 269     f_never                     = 0,
 270     f_notEqual                  = 1,
 271     f_notZero                   = 1,
 272     f_lessOrGreater             = 2,
 273     f_unorderedOrLess           = 3,
 274     f_less                      = 4,
 275     f_unorderedOrGreater        = 5,
 276     f_greater                   = 6,
 277     f_unordered                 = 7,
 278     f_always                    = 8,
 279     f_equal                     = 9,
 280     f_zero                      = 9,
 281     f_unorderedOrEqual          = 10,
 282     f_greaterOrEqual            = 11,
 283     f_unorderedOrGreaterOrEqual = 12,
 284     f_lessOrEqual               = 13,
 285     f_unorderedOrLessOrEqual    = 14,
 286     f_ordered                   = 15,
 287 
 288     // for integers
 289 
 290     never                = 0,
 291     equal                = 1,
 292     zero                 = 1,
 293     lessEqual            = 2,
 294     less                 = 3,
 295     lessEqualUnsigned    = 4,
 296     lessUnsigned         = 5,
 297     carrySet             = 5,
 298     negative             = 6,
 299     overflowSet          = 7,
 300     always               = 8,
 301     notEqual             = 9,
 302     notZero              = 9,
 303     greater              = 10,
 304     greaterEqual         = 11,
 305     greaterUnsigned      = 12,
 306     greaterEqualUnsigned = 13,
 307     carryClear           = 13,
 308     positive             = 14,
 309     overflowClear        = 15
 310   };
 311 
 312   enum CC {
 313     // ptr_cc is the correct condition code for a pointer or intptr_t:
 314     icc  = 0, xcc  = 2, ptr_cc = xcc,
 315     fcc0 = 0, fcc1 = 1, fcc2 = 2, fcc3 = 3
 316   };
 317 
 318   enum PrefetchFcn {
 319     severalReads = 0, oneRead = 1, severalWritesAndPossiblyReads = 2, oneWrite = 3, page = 4
 320   };
 321 
 322  public:
 323   // Helper functions for groups of instructions
 324 
 325   enum Predict { pt = 1, pn = 0 }; // pt = predict taken
 326 
 327   enum Membar_mask_bits { // page 184, v9
 328     StoreStore = 1 &lt;&lt; 3,
 329     LoadStore  = 1 &lt;&lt; 2,
 330     StoreLoad  = 1 &lt;&lt; 1,
 331     LoadLoad   = 1 &lt;&lt; 0,
 332 
 333     Sync       = 1 &lt;&lt; 6,
 334     MemIssue   = 1 &lt;&lt; 5,
 335     Lookaside  = 1 &lt;&lt; 4
 336   };
 337 
 338   static bool is_in_wdisp_range(address a, address b, int nbits) {
 339     intptr_t d = intptr_t(b) - intptr_t(a);
 340     return is_simm(d, nbits + 2);
 341   }
 342 
 343   address target_distance(Label &amp;L) {
 344     // Assembler::target(L) should be called only when
 345     // a branch instruction is emitted since non-bound
 346     // labels record current pc() as a branch address.
 347     if (L.is_bound()) return target(L);
 348     // Return current address for non-bound labels.
 349     return pc();
 350   }
 351 
 352   // test if label is in simm16 range in words (wdisp16).
 353   bool is_in_wdisp16_range(Label &amp;L) {
 354     return is_in_wdisp_range(target_distance(L), pc(), 16);
 355   }
 356   // test if the distance between two addresses fits in simm30 range in words
 357   static bool is_in_wdisp30_range(address a, address b) {
 358     return is_in_wdisp_range(a, b, 30);
 359   }
 360 
 361   enum ASIs { // page 72, v9
 362     ASI_PRIMARY            = 0x80,
 363     ASI_PRIMARY_NOFAULT    = 0x82,
 364     ASI_PRIMARY_LITTLE     = 0x88,
 365     // 8x8-bit partial store
 366     ASI_PST8_PRIMARY       = 0xC0,
 367     // Block initializing store
 368     ASI_ST_BLKINIT_PRIMARY = 0xE2,
 369     // Most-Recently-Used (MRU) BIS variant
 370     ASI_ST_BLKINIT_MRU_PRIMARY = 0xF2
 371     // add more from book as needed
 372   };
 373 
 374  protected:
 375   // helpers
 376 
 377   // x is supposed to fit in a field &quot;nbits&quot; wide
 378   // and be sign-extended. Check the range.
 379 
 380   static void assert_signed_range(intptr_t x, int nbits) {
 381     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 382            &quot;value out of range: x=&quot; INTPTR_FORMAT &quot;, nbits=%d&quot;, x, nbits);
 383   }
 384 
 385   static void assert_signed_word_disp_range(intptr_t x, int nbits) {
 386     assert((x &amp; 3) == 0, &quot;not word aligned&quot;);
 387     assert_signed_range(x, nbits + 2);
 388   }
 389 
 390   static void assert_unsigned_range(int x, int nbits) {
 391     assert(juint(x) &lt; juint(1 &lt;&lt; nbits), &quot;unsigned constant out of range&quot;);
 392   }
 393 
 394   // fields: note bits numbered from LSB = 0, fields known by inclusive bit range
 395 
 396   static int fmask(juint hi_bit, juint lo_bit) {
 397     assert(hi_bit &gt;= lo_bit &amp;&amp; 0 &lt;= lo_bit &amp;&amp; hi_bit &lt; 32, &quot;bad bits&quot;);
 398     return (1 &lt;&lt; (hi_bit-lo_bit + 1)) - 1;
 399   }
 400 
 401   // inverse of u_field
 402 
 403   static int inv_u_field(int x, int hi_bit, int lo_bit) {
 404     juint r = juint(x) &gt;&gt; lo_bit;
 405     r &amp;= fmask(hi_bit, lo_bit);
 406     return int(r);
 407   }
 408 
 409   // signed version: extract from field and sign-extend
 410 
 411   static int inv_s_field(int x, int hi_bit, int lo_bit) {
 412     int sign_shift = 31 - hi_bit;
 413     return inv_u_field(((x &lt;&lt; sign_shift) &gt;&gt; sign_shift), hi_bit, lo_bit);
 414   }
 415 
 416   // given a field that ranges from hi_bit to lo_bit (inclusive,
 417   // LSB = 0), and an unsigned value for the field,
 418   // shift it into the field
 419 
 420 #ifdef ASSERT
 421   static int u_field(int x, int hi_bit, int lo_bit) {
 422     assert((x &amp; ~fmask(hi_bit, lo_bit)) == 0,
 423             &quot;value out of range&quot;);
 424     int r = x &lt;&lt; lo_bit;
 425     assert(inv_u_field(r, hi_bit, lo_bit) == x, &quot;just checking&quot;);
 426     return r;
 427   }
 428 #else
 429   // make sure this is inlined as it will reduce code size significantly
 430   #define u_field(x, hi_bit, lo_bit) ((x) &lt;&lt; (lo_bit))
 431 #endif
 432 
 433   static int inv_op(int x)   { return inv_u_field(x, 31, 30); }
 434   static int inv_op2(int x)  { return inv_u_field(x, 24, 22); }
 435   static int inv_op3(int x)  { return inv_u_field(x, 24, 19); }
 436   static int inv_cond(int x) { return inv_u_field(x, 28, 25); }
 437 
 438   static bool inv_immed(int x)   { return (x &amp; Assembler::immed(true)) != 0; }
 439 
 440   static Register inv_rd(int x)  { return as_Register(inv_u_field(x, 29, 25)); }
 441   static Register inv_rs1(int x) { return as_Register(inv_u_field(x, 18, 14)); }
 442   static Register inv_rs2(int x) { return as_Register(inv_u_field(x,  4,  0)); }
 443 
 444   static int op(int x)           { return u_field(x,             31, 30); }
 445   static int rd(Register r)      { return u_field(r-&gt;encoding(), 29, 25); }
 446   static int fcn(int x)          { return u_field(x,             29, 25); }
 447   static int op3(int x)          { return u_field(x,             24, 19); }
 448   static int rs1(Register r)     { return u_field(r-&gt;encoding(), 18, 14); }
 449   static int rs2(Register r)     { return u_field(r-&gt;encoding(),  4,  0); }
 450   static int annul(bool a)       { return u_field(a ? 1 : 0,     29, 29); }
 451   static int cond(int x)         { return u_field(x,             28, 25); }
 452   static int cond_mov(int x)     { return u_field(x,             17, 14); }
 453   static int rcond(RCondition x) { return u_field(x,             12, 10); }
 454   static int op2(int x)          { return u_field(x,             24, 22); }
 455   static int predict(bool p)     { return u_field(p ? 1 : 0,     19, 19); }
 456   static int branchcc(CC fcca)   { return u_field(fcca,          21, 20); }
 457   static int cmpcc(CC fcca)      { return u_field(fcca,          26, 25); }
 458   static int imm_asi(int x)      { return u_field(x,             12,  5); }
 459   static int immed(bool i)       { return u_field(i ? 1 : 0,     13, 13); }
 460   static int opf_low6(int w)     { return u_field(w,             10,  5); }
 461   static int opf_low5(int w)     { return u_field(w,              9,  5); }
 462   static int op5(int x)          { return u_field(x,              8,  5); }
 463   static int trapcc(CC cc)       { return u_field(cc,            12, 11); }
 464   static int sx(int i)           { return u_field(i,             12, 12); } // shift x=1 means 64-bit
 465   static int opf(int x)          { return u_field(x,             13,  5); }
 466 
 467   static bool is_cbcond(int x) {
 468     return (VM_Version::has_cbcond() &amp;&amp; (inv_cond(x) &gt; rc_last) &amp;&amp;
 469             inv_op(x) == branch_op &amp;&amp; inv_op2(x) == bpr_op2);
 470   }
 471   static bool is_cxb(int x) {
 472     assert(is_cbcond(x), &quot;wrong instruction&quot;);
 473     return (x &amp; (1 &lt;&lt; 21)) != 0;
 474   }
 475   static bool is_branch(int x) {
 476     if (inv_op(x) != Assembler::branch_op) return false;
 477 
 478     bool is_bpr = inv_op2(x) == Assembler::bpr_op2;
 479     bool is_bp  = inv_op2(x) == Assembler::bp_op2;
 480     bool is_br  = inv_op2(x) == Assembler::br_op2;
 481     bool is_fp  = inv_op2(x) == Assembler::fb_op2;
 482     bool is_fbp = inv_op2(x) == Assembler::fbp_op2;
 483 
 484     return is_bpr || is_bp || is_br || is_fp || is_fbp;
 485   }
 486   static bool is_call(int x) {
 487     return inv_op(x) == Assembler::call_op;
 488   }
 489   static bool is_jump(int x) {
 490     if (inv_op(x) != Assembler::arith_op) return false;
 491 
 492     bool is_jmpl = inv_op3(x) == Assembler::jmpl_op3;
 493     bool is_rett = inv_op3(x) == Assembler::rett_op3;
 494 
 495     return is_jmpl || is_rett;
 496   }
 497   static bool is_rdpc(int x) {
 498     return (inv_op(x) == Assembler::arith_op &amp;&amp; inv_op3(x) == Assembler::rdreg_op3 &amp;&amp;
 499             inv_u_field(x, 18, 14) == 5);
 500   }
 501   static bool is_cti(int x) {
 502       return is_branch(x) || is_call(x) || is_jump(x); // Ignoring done/retry
 503   }
 504 
 505   static int cond_cbcond(int x) { return  u_field((((x &amp; 8) &lt;&lt; 1) + 8 + (x &amp; 7)), 29, 25); }
 506   static int inv_cond_cbcond(int x) {
 507     assert(is_cbcond(x), &quot;wrong instruction&quot;);
 508     return inv_u_field(x, 27, 25) | (inv_u_field(x, 29, 29) &lt;&lt; 3);
 509   }
 510 
 511   static int opf_cc(CC c, bool useFloat) { return u_field((useFloat ? 0 : 4) + c, 13, 11); }
 512   static int mov_cc(CC c, bool useFloat) { return u_field(useFloat ? 0 : 1, 18, 18) | u_field(c, 12, 11); }
 513 
 514   static int fd(FloatRegister r, FloatRegisterImpl::Width fwa)  { return u_field(r-&gt;encoding(fwa), 29, 25); };
 515   static int fs1(FloatRegister r, FloatRegisterImpl::Width fwa) { return u_field(r-&gt;encoding(fwa), 18, 14); };
 516   static int fs2(FloatRegister r, FloatRegisterImpl::Width fwa) { return u_field(r-&gt;encoding(fwa),  4,  0); };
 517   static int fs3(FloatRegister r, FloatRegisterImpl::Width fwa) { return u_field(r-&gt;encoding(fwa), 13,  9); };
 518 
 519   // some float instructions use this encoding on the op3 field
 520   static int alt_op3(int op, FloatRegisterImpl::Width w) {
 521     int r;
 522     switch(w) {
 523      case FloatRegisterImpl::S: r = op + 0;  break;
 524      case FloatRegisterImpl::D: r = op + 3;  break;
 525      case FloatRegisterImpl::Q: r = op + 2;  break;
 526      default: ShouldNotReachHere(); break;
 527     }
 528     return op3(r);
 529   }
 530 
 531   // compute inverse of simm
 532   static int inv_simm(int x, int nbits) {
 533     return (int)(x &lt;&lt; (32 - nbits)) &gt;&gt; (32 - nbits);
 534   }
 535 
 536   static int inv_simm13(int x) { return inv_simm(x, 13); }
 537 
 538   // signed immediate, in low bits, nbits long
 539   static int simm(int x, int nbits) {
 540     assert_signed_range(x, nbits);
 541     return x &amp; ((1 &lt;&lt; nbits) - 1);
 542   }
 543 
 544   // unsigned immediate, in low bits, at most nbits long.
 545   static int uimm(int x, int nbits) {
 546     assert_unsigned_range(x, nbits);
 547     return x &amp; ((1 &lt;&lt; nbits) - 1);
 548   }
 549 
 550   // compute inverse of wdisp16
 551   static intptr_t inv_wdisp16(int x, intptr_t pos) {
 552     int lo = x &amp; ((1 &lt;&lt; 14) - 1);
 553     int hi = (x &gt;&gt; 20) &amp; 3;
 554     if (hi &gt;= 2) hi |= ~1;
 555     return (((hi &lt;&lt; 14) | lo) &lt;&lt; 2) + pos;
 556   }
 557 
 558   // word offset, 14 bits at LSend, 2 bits at B21, B20
 559   static int wdisp16(intptr_t x, intptr_t off) {
 560     intptr_t xx = x - off;
 561     assert_signed_word_disp_range(xx, 16);
 562     int r = (xx &gt;&gt; 2) &amp; ((1 &lt;&lt; 14) - 1) | (((xx &gt;&gt; (2+14)) &amp; 3) &lt;&lt; 20);
 563     assert(inv_wdisp16(r, off) == x, &quot;inverse is not inverse&quot;);
 564     return r;
 565   }
 566 
 567   // compute inverse of wdisp10
 568   static intptr_t inv_wdisp10(int x, intptr_t pos) {
 569     assert(is_cbcond(x), &quot;wrong instruction&quot;);
 570     int lo = inv_u_field(x, 12, 5);
 571     int hi = (x &gt;&gt; 19) &amp; 3;
 572     if (hi &gt;= 2) hi |= ~1;
 573     return (((hi &lt;&lt; 8) | lo) &lt;&lt; 2) + pos;
 574   }
 575 
 576   // word offset for cbcond, 8 bits at [B12,B5], 2 bits at [B20,B19]
 577   static int wdisp10(intptr_t x, intptr_t off) {
 578     assert(VM_Version::has_cbcond(), &quot;This CPU does not have CBCOND instruction&quot;);
 579     intptr_t xx = x - off;
 580     assert_signed_word_disp_range(xx, 10);
 581     int r = (((xx &gt;&gt; 2) &amp; ((1 &lt;&lt; 8) - 1)) &lt;&lt; 5) | (((xx &gt;&gt; (2+8)) &amp; 3) &lt;&lt; 19);
 582     // Have to fake cbcond instruction to pass assert in inv_wdisp10()
 583     assert(inv_wdisp10((r | op(branch_op) | cond_cbcond(rc_last+1) | op2(bpr_op2)), off) == x, &quot;inverse is not inverse&quot;);
 584     return r;
 585   }
 586 
 587   // word displacement in low-order nbits bits
 588 
 589   static intptr_t inv_wdisp(int x, intptr_t pos, int nbits) {
 590     int pre_sign_extend = x &amp; ((1 &lt;&lt; nbits) - 1);
 591     int r = (pre_sign_extend &gt;= (1 &lt;&lt; (nbits - 1)) ?
 592              pre_sign_extend | ~((1 &lt;&lt; nbits) - 1) : pre_sign_extend);
 593     return (r &lt;&lt; 2) + pos;
 594   }
 595 
 596   static int wdisp(intptr_t x, intptr_t off, int nbits) {
 597     intptr_t xx = x - off;
 598     assert_signed_word_disp_range(xx, nbits);
 599     int r = (xx &gt;&gt; 2) &amp; ((1 &lt;&lt; nbits) - 1);
 600     assert(inv_wdisp(r, off, nbits) == x, &quot;inverse not inverse&quot;);
 601     return r;
 602   }
 603 
 604 
 605   // Extract the top 32 bits in a 64 bit word
 606   static int32_t hi32(int64_t x) {
 607     int32_t r = int32_t((uint64_t)x &gt;&gt; 32);
 608     return r;
 609   }
 610 
 611   // given a sethi instruction, extract the constant, left-justified
 612   static int inv_hi22(int x) {
 613     return x &lt;&lt; 10;
 614   }
 615 
 616   // create an imm22 field, given a 32-bit left-justified constant
 617   static int hi22(int x) {
 618     int r = int(juint(x) &gt;&gt; 10);
 619     assert((r &amp; ~((1 &lt;&lt; 22) - 1)) == 0, &quot;just checkin&#39;&quot;);
 620     return r;
 621   }
 622 
 623   // create a low10 __value__ (not a field) for a given a 32-bit constant
 624   static int low10(int x) {
 625     return x &amp; ((1 &lt;&lt; 10) - 1);
 626   }
 627 
 628   // create a low12 __value__ (not a field) for a given a 32-bit constant
 629   static int low12(int x) {
 630     return x &amp; ((1 &lt;&lt; 12) - 1);
 631   }
 632 
 633   // AES crypto instructions supported only on certain processors
 634   static void aes_only() { assert(VM_Version::has_aes(), &quot;This instruction only works on SPARC with AES instructions support&quot;); }
 635 
 636   // SHA crypto instructions supported only on certain processors
 637   static void sha1_only()   { assert(VM_Version::has_sha1(),   &quot;This instruction only works on SPARC with SHA1&quot;); }
 638   static void sha256_only() { assert(VM_Version::has_sha256(), &quot;This instruction only works on SPARC with SHA256&quot;); }
 639   static void sha512_only() { assert(VM_Version::has_sha512(), &quot;This instruction only works on SPARC with SHA512&quot;); }
 640 
 641   // CRC32C instruction supported only on certain processors
 642   static void crc32c_only() { assert(VM_Version::has_crc32c(), &quot;This instruction only works on SPARC with CRC32C&quot;); }
 643 
 644   // FMAf instructions supported only on certain processors
 645   static void fmaf_only() { assert(VM_Version::has_fmaf(), &quot;This instruction only works on SPARC with FMAf&quot;); }
 646 
 647   // MPMUL instruction supported only on certain processors
 648   static void mpmul_only() { assert(VM_Version::has_mpmul(), &quot;This instruction only works on SPARC with MPMUL&quot;); }
 649 
 650   // instruction only in VIS1
 651   static void vis1_only() { assert(VM_Version::has_vis1(), &quot;This instruction only works on SPARC with VIS1&quot;); }
 652 
 653   // instruction only in VIS2
 654   static void vis2_only() { assert(VM_Version::has_vis2(), &quot;This instruction only works on SPARC with VIS2&quot;); }
 655 
 656   // instruction only in VIS3
 657   static void vis3_only() { assert(VM_Version::has_vis3(), &quot;This instruction only works on SPARC with VIS3&quot;); }
 658 
 659   // instruction deprecated in v9
 660   static void v9_dep() { } // do nothing for now
 661 
 662  protected:
 663 #ifdef ASSERT
 664 #define VALIDATE_PIPELINE
 665 #endif
 666 
 667 #ifdef VALIDATE_PIPELINE
 668   // A simple delay-slot scheme:
 669   // In order to check the programmer, the assembler keeps track of delay-slots.
 670   // It forbids CTIs in delay-slots (conservative, but should be OK). Also, when
 671   // emitting an instruction into a delay-slot, you must do so using delayed(),
 672   // e.g. asm-&gt;delayed()-&gt;add(...), in order to check that you do not omit the
 673   // delay-slot instruction. To implement this, we use a simple FSA.
 674   enum { NoDelay, AtDelay, FillDelay } _delay_state;
 675 
 676   // A simple hazard scheme:
 677   // In order to avoid pipeline stalls, due to single cycle pipeline hazards, we
 678   // adopt a simplistic state tracking mechanism that will enforce an additional
 679   // &#39;nop&#39; instruction to be inserted prior to emitting an instruction that can
 680   // expose a given hazard (currently, PC-related hazards only).
 681   enum { NoHazard, PcHazard } _hazard_state;
 682 #endif
 683 
 684  public:
 685   // Tell the assembler that the next instruction must NOT be in delay-slot.
 686   // Use at start of multi-instruction macros.
 687   void assert_not_delayed() {
 688     // This is a separate entry to avoid the creation of string constants in
 689     // non-asserted code, with some compilers this pollutes the object code.
 690 #ifdef VALIDATE_PIPELINE
 691     assert_no_delay(&quot;Next instruction should not be in a delay-slot.&quot;);
 692 #endif
 693   }
 694 
 695  protected:
 696   void assert_no_delay(const char* msg) {
 697 #ifdef VALIDATE_PIPELINE
 698     assert(_delay_state == NoDelay, msg);
 699 #endif
 700   }
 701 
 702   void assert_no_hazard() {
 703 #ifdef VALIDATE_PIPELINE
 704     assert(_hazard_state == NoHazard, &quot;Unsolicited pipeline hazard.&quot;);
 705 #endif
 706   }
 707 
 708  private:
 709   inline int32_t prev_insn() {
 710     assert(offset() &gt; 0, &quot;Interface violation.&quot;);
 711     int32_t* addr = (int32_t*)pc() - 1;
 712     return *addr;
 713   }
 714 
 715 #ifdef VALIDATE_PIPELINE
 716   void validate_no_pipeline_hazards();
 717 #endif
 718 
 719  protected:
 720   // Avoid possible pipeline stall by inserting an additional &#39;nop&#39; instruction,
 721   // if the previous instruction is a &#39;cbcond&#39; or a &#39;rdpc&#39;.
 722   inline void avoid_pipeline_stall();
 723 
 724   // A call to cti() is made before emitting a control-transfer instruction (CTI)
 725   // in order to assert a CTI is not emitted right after a &#39;cbcond&#39;, nor in the
 726   // delay-slot of another CTI. Only effective when assertions are enabled.
 727   void cti() {
 728     // A &#39;cbcond&#39; or &#39;rdpc&#39; instruction immediately followed by a CTI introduces
 729     // a pipeline stall, which we make sure to prohibit.
 730     assert_no_cbcond_before();
 731     assert_no_rdpc_before();
 732 #ifdef VALIDATE_PIPELINE
 733     assert_no_hazard();
 734     assert_no_delay(&quot;CTI in delay-slot.&quot;);
 735 #endif
 736   }
 737 
 738   // Called when emitting CTI with a delay-slot, AFTER emitting.
 739   inline void induce_delay_slot() {
 740 #ifdef VALIDATE_PIPELINE
 741     assert_no_delay(&quot;Already in delay-slot.&quot;);
 742     _delay_state = AtDelay;
 743 #endif
 744   }
 745 
 746   inline void induce_pc_hazard() {
 747 #ifdef VALIDATE_PIPELINE
 748     assert_no_hazard();
 749     _hazard_state = PcHazard;
 750 #endif
 751   }
 752 
 753   bool is_cbcond_before() { return offset() &gt; 0 ? is_cbcond(prev_insn()) : false; }
 754 
 755   bool is_rdpc_before() { return offset() &gt; 0 ? is_rdpc(prev_insn()) : false; }
 756 
 757   void assert_no_cbcond_before() {
 758     assert(offset() == 0 || !is_cbcond_before(), &quot;CBCOND should not be followed by CTI.&quot;);
 759   }
 760 
 761   void assert_no_rdpc_before() {
 762     assert(offset() == 0 || !is_rdpc_before(), &quot;RDPC should not be followed by CTI.&quot;);
 763   }
 764 
 765  public:
 766 
 767   bool use_cbcond(Label &amp;L) {
 768     if (!UseCBCond || is_cbcond_before()) return false;
 769     intptr_t x = intptr_t(target_distance(L)) - intptr_t(pc());
 770     assert((x &amp; 3) == 0, &quot;not word aligned&quot;);
 771     return is_simm12(x);
 772   }
 773 
 774   // Tells assembler you know that next instruction is delayed
 775   Assembler* delayed() {
 776 #ifdef VALIDATE_PIPELINE
 777     assert(_delay_state == AtDelay, &quot;Delayed instruction not in delay-slot.&quot;);
 778     _delay_state = FillDelay;
 779 #endif
 780     return this;
 781   }
 782 
 783   void flush() {
 784 #ifdef VALIDATE_PIPELINE
 785     assert(_delay_state == NoDelay, &quot;Ending code with a delay-slot.&quot;);
 786 #ifdef COMPILER2
 787     validate_no_pipeline_hazards();
 788 #endif
 789 #endif
 790     AbstractAssembler::flush();
 791   }
 792 
 793   inline void emit_int32(int32_t);  // shadows AbstractAssembler::emit_int32
 794   inline void emit_data(int32_t);
 795   inline void emit_data(int32_t, RelocationHolder const&amp;);
 796   inline void emit_data(int32_t, relocInfo::relocType rtype);
 797 
 798   // Helper for the above functions.
 799   inline void check_delay();
 800 
 801 
 802  public:
 803   // instructions, refer to page numbers in the SPARC Architecture Manual, V9
 804 
 805   // pp 135
 806 
 807   inline void add(Register s1, Register s2, Register d);
 808   inline void add(Register s1, int simm13a, Register d);
 809 
 810   inline void addcc(Register s1, Register s2, Register d);
 811   inline void addcc(Register s1, int simm13a, Register d);
 812   inline void addc(Register s1, Register s2, Register d);
 813   inline void addc(Register s1, int simm13a, Register d);
 814   inline void addccc(Register s1, Register s2, Register d);
 815   inline void addccc(Register s1, int simm13a, Register d);
 816 
 817 
 818   // 4-operand AES instructions
 819 
 820   inline void aes_eround01(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 821   inline void aes_eround23(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 822   inline void aes_dround01(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 823   inline void aes_dround23(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 824   inline void aes_eround01_l(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 825   inline void aes_eround23_l(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 826   inline void aes_dround01_l(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 827   inline void aes_dround23_l(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 828   inline void aes_kexpand1(FloatRegister s1, FloatRegister s2, int imm5a, FloatRegister d);
 829 
 830 
 831   // 3-operand AES instructions
 832 
 833   inline void aes_kexpand0(FloatRegister s1, FloatRegister s2, FloatRegister d);
 834   inline void aes_kexpand2(FloatRegister s1, FloatRegister s2, FloatRegister d);
 835 
 836   // pp 136
 837 
 838   inline void bpr(RCondition c, bool a, Predict p, Register s1, address d, relocInfo::relocType rt = relocInfo::none);
 839   inline void bpr(RCondition c, bool a, Predict p, Register s1, Label &amp;L);
 840 
 841   // compare and branch
 842   inline void cbcond(Condition c, CC cc, Register s1, Register s2, Label &amp;L);
 843   inline void cbcond(Condition c, CC cc, Register s1, int simm5, Label &amp;L);
 844 
 845  protected: // use MacroAssembler::br instead
 846 
 847   // pp 138
 848 
 849   inline void fb(Condition c, bool a, address d, relocInfo::relocType rt = relocInfo::none);
 850   inline void fb(Condition c, bool a, Label &amp;L);
 851 
 852   // pp 141
 853 
 854   inline void fbp(Condition c, bool a, CC cc, Predict p, address d, relocInfo::relocType rt = relocInfo::none);
 855   inline void fbp(Condition c, bool a, CC cc, Predict p, Label &amp;L);
 856 
 857   // pp 144
 858 
 859   inline void br(Condition c, bool a, address d, relocInfo::relocType rt = relocInfo::none);
 860   inline void br(Condition c, bool a, Label &amp;L);
 861 
 862   // pp 146
 863 
 864   inline void bp(Condition c, bool a, CC cc, Predict p, address d, relocInfo::relocType rt = relocInfo::none);
 865   inline void bp(Condition c, bool a, CC cc, Predict p, Label &amp;L);
 866 
 867   // pp 149
 868 
 869   inline void call(address d, relocInfo::relocType rt = relocInfo::runtime_call_type);
 870   inline void call(Label &amp;L,  relocInfo::relocType rt = relocInfo::runtime_call_type);
 871 
 872   inline void call(address d, RelocationHolder const &amp;rspec);
 873 
 874  public:
 875 
 876   // pp 150
 877 
 878   // These instructions compare the contents of s2 with the contents of
 879   // memory at address in s1. If the values are equal, the contents of memory
 880   // at address s1 is swapped with the data in d. If the values are not equal,
 881   // the the contents of memory at s1 is loaded into d, without the swap.
 882 
 883   inline void casa(Register s1, Register s2, Register d, int ia = -1);
 884   inline void casxa(Register s1, Register s2, Register d, int ia = -1);
 885 
 886   // pp 152
 887 
 888   inline void udiv(Register s1, Register s2, Register d);
 889   inline void udiv(Register s1, int simm13a, Register d);
 890   inline void sdiv(Register s1, Register s2, Register d);
 891   inline void sdiv(Register s1, int simm13a, Register d);
 892   inline void udivcc(Register s1, Register s2, Register d);
 893   inline void udivcc(Register s1, int simm13a, Register d);
 894   inline void sdivcc(Register s1, Register s2, Register d);
 895   inline void sdivcc(Register s1, int simm13a, Register d);
 896 
 897   // pp 155
 898 
 899   inline void done();
 900   inline void retry();
 901 
 902   // pp 156
 903 
 904   inline void fadd(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister d);
 905   inline void fsub(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister d);
 906 
 907   // pp 157
 908 
 909   inline void fcmp(FloatRegisterImpl::Width w, CC cc, FloatRegister s1, FloatRegister s2);
 910   inline void fcmpe(FloatRegisterImpl::Width w, CC cc, FloatRegister s1, FloatRegister s2);
 911 
 912   // pp 159
 913 
 914   inline void ftox(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 915   inline void ftoi(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 916 
 917   // pp 160
 918 
 919   inline void ftof(FloatRegisterImpl::Width sw, FloatRegisterImpl::Width dw, FloatRegister s, FloatRegister d);
 920 
 921   // pp 161
 922 
 923   inline void fxtof(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 924   inline void fitof(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 925 
 926   // pp 162
 927 
 928   inline void fmov(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 929 
 930   inline void fneg(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 931 
 932   inline void fabs(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 933 
 934   // pp 163
 935 
 936   inline void fmul(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister d);
 937   inline void fmul(FloatRegisterImpl::Width sw, FloatRegisterImpl::Width dw, FloatRegister s1, FloatRegister s2, FloatRegister d);
 938   inline void fdiv(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister d);
 939 
 940   // FXORs/FXORd instructions
 941 
 942   inline void fxor(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister d);
 943 
 944   // pp 164
 945 
 946   inline void fsqrt(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 947 
 948   // fmaf instructions.
 949 
 950   inline void fmadd(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 951   inline void fmsub(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 952 
 953   inline void fnmadd(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 954   inline void fnmsub(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 955 
 956   // pp 165
 957 
 958   inline void flush(Register s1, Register s2);
 959   inline void flush(Register s1, int simm13a);
 960 
 961   // pp 167
 962 
 963   void flushw();
 964 
 965   // pp 168
 966 
 967   void illtrap(int const22a);
 968 
 969   // pp 169
 970 
 971   void impdep1(int id1, int const19a);
 972   void impdep2(int id1, int const19a);
 973 
 974   // pp 170
 975 
 976   void jmpl(Register s1, Register s2, Register d);
 977   void jmpl(Register s1, int simm13a, Register d,
 978             RelocationHolder const &amp;rspec = RelocationHolder());
 979 
 980   // 171
 981 
 982   inline void ldf(FloatRegisterImpl::Width w, Register s1, Register s2, FloatRegister d);
 983   inline void ldf(FloatRegisterImpl::Width w, Register s1, int simm13a, FloatRegister d,
 984                   RelocationHolder const &amp;rspec = RelocationHolder());
 985 
 986   inline void ldd(Register s1, Register s2, FloatRegister d);
 987   inline void ldd(Register s1, int simm13a, FloatRegister d);
 988 
 989   inline void ldfsr(Register s1, Register s2);
 990   inline void ldfsr(Register s1, int simm13a);
 991   inline void ldxfsr(Register s1, Register s2);
 992   inline void ldxfsr(Register s1, int simm13a);
 993 
 994   // 173
 995 
 996   inline void ldfa(FloatRegisterImpl::Width w, Register s1, Register s2, int ia, FloatRegister d);
 997   inline void ldfa(FloatRegisterImpl::Width w, Register s1, int simm13a,         FloatRegister d);
 998 
 999   // pp 175
1000 
1001   inline void ldsb(Register s1, Register s2, Register d);
1002   inline void ldsb(Register s1, int simm13a, Register d);
1003   inline void ldsh(Register s1, Register s2, Register d);
1004   inline void ldsh(Register s1, int simm13a, Register d);
1005   inline void ldsw(Register s1, Register s2, Register d);
1006   inline void ldsw(Register s1, int simm13a, Register d);
1007   inline void ldub(Register s1, Register s2, Register d);
1008   inline void ldub(Register s1, int simm13a, Register d);
1009   inline void lduh(Register s1, Register s2, Register d);
1010   inline void lduh(Register s1, int simm13a, Register d);
1011   inline void lduw(Register s1, Register s2, Register d);
1012   inline void lduw(Register s1, int simm13a, Register d);
1013   inline void ldx(Register s1, Register s2, Register d);
1014   inline void ldx(Register s1, int simm13a, Register d);
1015 
1016   // pp 177
1017 
1018   inline void ldsba(Register s1, Register s2, int ia, Register d);
1019   inline void ldsba(Register s1, int simm13a,         Register d);
1020   inline void ldsha(Register s1, Register s2, int ia, Register d);
1021   inline void ldsha(Register s1, int simm13a,         Register d);
1022   inline void ldswa(Register s1, Register s2, int ia, Register d);
1023   inline void ldswa(Register s1, int simm13a,         Register d);
1024   inline void lduba(Register s1, Register s2, int ia, Register d);
1025   inline void lduba(Register s1, int simm13a,         Register d);
1026   inline void lduha(Register s1, Register s2, int ia, Register d);
1027   inline void lduha(Register s1, int simm13a,         Register d);
1028   inline void lduwa(Register s1, Register s2, int ia, Register d);
1029   inline void lduwa(Register s1, int simm13a,         Register d);
1030   inline void ldxa(Register s1, Register s2, int ia, Register d);
1031   inline void ldxa(Register s1, int simm13a,         Register d);
1032 
1033   // pp 181
1034 
1035   inline void and3(Register s1, Register s2, Register d);
1036   inline void and3(Register s1, int simm13a, Register d);
1037   inline void andcc(Register s1, Register s2, Register d);
1038   inline void andcc(Register s1, int simm13a, Register d);
1039   inline void andn(Register s1, Register s2, Register d);
1040   inline void andn(Register s1, int simm13a, Register d);
1041   inline void andncc(Register s1, Register s2, Register d);
1042   inline void andncc(Register s1, int simm13a, Register d);
1043   inline void or3(Register s1, Register s2, Register d);
1044   inline void or3(Register s1, int simm13a, Register d);
1045   inline void orcc(Register s1, Register s2, Register d);
1046   inline void orcc(Register s1, int simm13a, Register d);
1047   inline void orn(Register s1, Register s2, Register d);
1048   inline void orn(Register s1, int simm13a, Register d);
1049   inline void orncc(Register s1, Register s2, Register d);
1050   inline void orncc(Register s1, int simm13a, Register d);
1051   inline void xor3(Register s1, Register s2, Register d);
1052   inline void xor3(Register s1, int simm13a, Register d);
1053   inline void xorcc(Register s1, Register s2, Register d);
1054   inline void xorcc(Register s1, int simm13a, Register d);
1055   inline void xnor(Register s1, Register s2, Register d);
1056   inline void xnor(Register s1, int simm13a, Register d);
1057   inline void xnorcc(Register s1, Register s2, Register d);
1058   inline void xnorcc(Register s1, int simm13a, Register d);
1059 
1060   // pp 183
1061 
1062   inline void membar(Membar_mask_bits const7a);
1063 
1064   // pp 185
1065 
1066   inline void fmov(FloatRegisterImpl::Width w, Condition c,  bool floatCC, CC cca, FloatRegister s2, FloatRegister d);
1067 
1068   // pp 189
1069 
1070   inline void fmov(FloatRegisterImpl::Width w, RCondition c, Register s1,  FloatRegister s2, FloatRegister d);
1071 
1072   // pp 191
1073 
1074   inline void movcc(Condition c, bool floatCC, CC cca, Register s2, Register d);
1075   inline void movcc(Condition c, bool floatCC, CC cca, int simm11a, Register d);
1076 
1077   // pp 195
1078 
1079   inline void movr(RCondition c, Register s1, Register s2,  Register d);
1080   inline void movr(RCondition c, Register s1, int simm10a,  Register d);
1081 
1082   // pp 196
1083 
1084   inline void mulx(Register s1, Register s2, Register d);
1085   inline void mulx(Register s1, int simm13a, Register d);
1086   inline void sdivx(Register s1, Register s2, Register d);
1087   inline void sdivx(Register s1, int simm13a, Register d);
1088   inline void udivx(Register s1, Register s2, Register d);
1089   inline void udivx(Register s1, int simm13a, Register d);
1090 
1091   // pp 197
1092 
1093   inline void umul(Register s1, Register s2, Register d);
1094   inline void umul(Register s1, int simm13a, Register d);
1095   inline void smul(Register s1, Register s2, Register d);
1096   inline void smul(Register s1, int simm13a, Register d);
1097   inline void umulcc(Register s1, Register s2, Register d);
1098   inline void umulcc(Register s1, int simm13a, Register d);
1099   inline void smulcc(Register s1, Register s2, Register d);
1100   inline void smulcc(Register s1, int simm13a, Register d);
1101 
1102   // pp 201
1103 
1104   inline void nop();
1105 
1106   inline void sw_count();
1107 
1108   // pp 202
1109 
1110   inline void popc(Register s,  Register d);
1111   inline void popc(int simm13a, Register d);
1112 
1113   // pp 203
1114 
1115   inline void prefetch(Register s1, Register s2, PrefetchFcn f);
1116   inline void prefetch(Register s1, int simm13a, PrefetchFcn f);
1117 
1118   inline void prefetcha(Register s1, Register s2, int ia, PrefetchFcn f);
1119   inline void prefetcha(Register s1, int simm13a,         PrefetchFcn f);
1120 
1121   // pp 208
1122 
1123   // not implementing read privileged register
1124 
1125   inline void rdy(Register d);
1126   inline void rdccr(Register d);
1127   inline void rdasi(Register d);
1128   inline void rdtick(Register d);
1129   inline void rdpc(Register d);
1130   inline void rdfprs(Register d);
1131 
1132   // pp 213
1133 
1134   inline void rett(Register s1, Register s2);
1135   inline void rett(Register s1, int simm13a, relocInfo::relocType rt = relocInfo::none);
1136 
1137   // pp 214
1138 
1139   inline void save(Register s1, Register s2, Register d);
1140   inline void save(Register s1, int simm13a, Register d);
1141 
1142   inline void restore(Register s1 = G0, Register s2 = G0, Register d = G0);
1143   inline void restore(Register s1,      int simm13a,      Register d);
1144 
1145   // pp 216
1146 
1147   inline void saved();
1148   inline void restored();
1149 
1150   // pp 217
1151 
1152   inline void sethi(int imm22a, Register d, RelocationHolder const &amp;rspec = RelocationHolder());
1153 
1154   // pp 218
1155 
1156   inline void sll(Register s1, Register s2, Register d);
1157   inline void sll(Register s1, int imm5a,   Register d);
1158   inline void srl(Register s1, Register s2, Register d);
1159   inline void srl(Register s1, int imm5a,   Register d);
1160   inline void sra(Register s1, Register s2, Register d);
1161   inline void sra(Register s1, int imm5a,   Register d);
1162 
1163   inline void sllx(Register s1, Register s2, Register d);
1164   inline void sllx(Register s1, int imm6a,   Register d);
1165   inline void srlx(Register s1, Register s2, Register d);
1166   inline void srlx(Register s1, int imm6a,   Register d);
1167   inline void srax(Register s1, Register s2, Register d);
1168   inline void srax(Register s1, int imm6a,   Register d);
1169 
1170   // pp 220
1171 
1172   inline void sir(int simm13a);
1173 
1174   // pp 221
1175 
1176   inline void stbar();
1177 
1178   // pp 222
1179 
1180   inline void stf(FloatRegisterImpl::Width w, FloatRegister d, Register s1, Register s2);
1181   inline void stf(FloatRegisterImpl::Width w, FloatRegister d, Register s1, int simm13a);
1182 
1183   inline void std(FloatRegister d, Register s1, Register s2);
1184   inline void std(FloatRegister d, Register s1, int simm13a);
1185 
1186   inline void stfsr(Register s1, Register s2);
1187   inline void stfsr(Register s1, int simm13a);
1188   inline void stxfsr(Register s1, Register s2);
1189   inline void stxfsr(Register s1, int simm13a);
1190 
1191   // pp 224
1192 
1193   inline void stfa(FloatRegisterImpl::Width w, FloatRegister d, Register s1, Register s2, int ia);
1194   inline void stfa(FloatRegisterImpl::Width w, FloatRegister d, Register s1, int simm13a);
1195 
1196   // pp 226
1197 
1198   inline void stb(Register d, Register s1, Register s2);
1199   inline void stb(Register d, Register s1, int simm13a);
1200   inline void sth(Register d, Register s1, Register s2);
1201   inline void sth(Register d, Register s1, int simm13a);
1202   inline void stw(Register d, Register s1, Register s2);
1203   inline void stw(Register d, Register s1, int simm13a);
1204   inline void stx(Register d, Register s1, Register s2);
1205   inline void stx(Register d, Register s1, int simm13a);
1206 
1207   // pp 177
1208 
1209   inline void stba(Register d, Register s1, Register s2, int ia);
1210   inline void stba(Register d, Register s1, int simm13a);
1211   inline void stha(Register d, Register s1, Register s2, int ia);
1212   inline void stha(Register d, Register s1, int simm13a);
1213   inline void stwa(Register d, Register s1, Register s2, int ia);
1214   inline void stwa(Register d, Register s1, int simm13a);
1215   inline void stxa(Register d, Register s1, Register s2, int ia);
1216   inline void stxa(Register d, Register s1, int simm13a);
1217   inline void stda(Register d, Register s1, Register s2, int ia);
1218   inline void stda(Register d, Register s1, int simm13a);
1219 
1220   // pp 230
1221 
1222   inline void sub(Register s1, Register s2, Register d);
1223   inline void sub(Register s1, int simm13a, Register d);
1224 
1225   inline void subcc(Register s1, Register s2, Register d);
1226   inline void subcc(Register s1, int simm13a, Register d);
1227   inline void subc(Register s1, Register s2, Register d);
1228   inline void subc(Register s1, int simm13a, Register d);
1229   inline void subccc(Register s1, Register s2, Register d);
1230   inline void subccc(Register s1, int simm13a, Register d);
1231 
1232   // pp 231
1233 
1234   inline void swap(Register s1, Register s2, Register d);
1235   inline void swap(Register s1, int simm13a, Register d);
1236 
1237   // pp 232
1238 
1239   inline void swapa(Register s1, Register s2, int ia, Register d);
1240   inline void swapa(Register s1, int simm13a,         Register d);
1241 
1242   // pp 234, note op in book is wrong, see pp 268
1243 
1244   inline void taddcc(Register s1, Register s2, Register d);
1245   inline void taddcc(Register s1, int simm13a, Register d);
1246 
1247   // pp 235
1248 
1249   inline void tsubcc(Register s1, Register s2, Register d);
1250   inline void tsubcc(Register s1, int simm13a, Register d);
1251 
1252   // pp 237
1253 
1254   inline void trap(Condition c, CC cc, Register s1, Register s2);
1255   inline void trap(Condition c, CC cc, Register s1, int trapa);
1256   // simple uncond. trap
1257   inline void trap(int trapa);
1258 
1259   // pp 239 omit write priv register for now
1260 
1261   inline void wry(Register d);
1262   inline void wrccr(Register s);
1263   inline void wrccr(Register s, int simm13a);
1264   inline void wrasi(Register d);
1265   // wrasi(d, imm) stores (d xor imm) to asi
1266   inline void wrasi(Register d, int simm13a);
1267   inline void wrfprs(Register d);
1268 
1269   // VIS1 instructions
1270 
1271   inline void alignaddr(Register s1, Register s2, Register d);
1272 
1273   inline void faligndata(FloatRegister s1, FloatRegister s2, FloatRegister d);
1274 
1275   inline void fzero(FloatRegisterImpl::Width w, FloatRegister d);
1276 
1277   inline void fsrc2(FloatRegisterImpl::Width w, FloatRegister s2, FloatRegister d);
1278 
1279   inline void fnot1(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister d);
1280 
1281   inline void fpmerge(FloatRegister s1, FloatRegister s2, FloatRegister d);
1282 
1283   inline void stpartialf(Register s1, Register s2, FloatRegister d, int ia = -1);
1284 
1285   // VIS2 instructions
1286 
1287   inline void edge8n(Register s1, Register s2, Register d);
1288 
1289   inline void bmask(Register s1, Register s2, Register d);
1290   inline void bshuffle(FloatRegister s1, FloatRegister s2, FloatRegister d);
1291 
1292   // VIS3 instructions
1293 
1294   inline void addxc(Register s1, Register s2, Register d);
1295   inline void addxccc(Register s1, Register s2, Register d);
1296 
1297   inline void movstosw(FloatRegister s, Register d);
1298   inline void movstouw(FloatRegister s, Register d);
1299   inline void movdtox(FloatRegister s, Register d);
1300 
1301   inline void movwtos(Register s, FloatRegister d);
1302   inline void movxtod(Register s, FloatRegister d);
1303 
1304   inline void xmulx(Register s1, Register s2, Register d);
1305   inline void xmulxhi(Register s1, Register s2, Register d);
1306   inline void umulxhi(Register s1, Register s2, Register d);
1307 
1308   // Crypto SHA instructions
1309 
1310   inline void sha1();
1311   inline void sha256();
1312   inline void sha512();
1313 
1314   // CRC32C instruction
1315 
1316   inline void crc32c(FloatRegister s1, FloatRegister s2, FloatRegister d);
1317 
1318   // MPMUL instruction
1319 
1320   inline void mpmul(int uimm5);
1321 
1322   // Creation
1323   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
1324 #ifdef VALIDATE_PIPELINE
1325     _delay_state  = NoDelay;
1326     _hazard_state = NoHazard;
1327 #endif
1328   }
1329 };
1330 
1331 #endif // CPU_SPARC_ASSEMBLER_SPARC_HPP
    </pre>
  </body>
</html>
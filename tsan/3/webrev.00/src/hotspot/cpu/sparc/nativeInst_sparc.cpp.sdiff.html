<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/nativeInst_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_sparc.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_sparc.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/nativeInst_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
557 
558   nm = nativeMovConstRegPatching_at( cb.insts_begin() );
559   nm-&gt;print();
560 
561   nm = nativeMovConstRegPatching_at( nm-&gt;next_instruction_address() );
562   for (idx = 0; idx &lt; ARRAY_SIZE(offsets); idx++) {
563     nm-&gt;set_data( offsets[idx] );
564     assert(nm-&gt;data() == offsets[idx], &quot;check unit test&quot;);
565   }
566   nm-&gt;print();
567 
568   VM_Version::revert();
569 #endif // ASSERT
570 }
571 // End code for unit testing implementation of NativeMovConstRegPatching class
572 
573 
574 //-------------------------------------------------------------------
575 
576 
<span class="line-removed">577 void NativeMovRegMem::copy_instruction_to(address new_instruction_address) {</span>
<span class="line-removed">578   Untested(&quot;copy_instruction_to&quot;);</span>
<span class="line-removed">579   int instruction_size = next_instruction_address() - instruction_address();</span>
<span class="line-removed">580   for (int i = 0; i &lt; instruction_size; i += BytesPerInstWord) {</span>
<span class="line-removed">581     *(int*)(new_instruction_address + i) = *(int*)(address(this) + i);</span>
<span class="line-removed">582   }</span>
<span class="line-removed">583 }</span>
<span class="line-removed">584 </span>
<span class="line-removed">585 </span>
586 void NativeMovRegMem::verify() {
587   NativeInstruction::verify();
588   // make sure code pattern is actually a &quot;ld&quot; or &quot;st&quot; of some sort.
589   int i0 = long_at(0);
590   int op3 = inv_op3(i0);
591 
592   assert((int)add_offset == NativeMovConstReg::add_offset, &quot;sethi size ok&quot;);
593 
594   if (!(is_op(i0, Assembler::ldst_op) &amp;&amp;
595         inv_immed(i0) &amp;&amp;
596         0 != (op3 &lt; op3_ldst_int_limit
597          ? (1 &lt;&lt;  op3                      ) &amp; (op3_mask_ld  | op3_mask_st)
598          : (1 &lt;&lt; (op3 - op3_ldst_int_limit)) &amp; (op3_mask_ldf | op3_mask_stf))))
599   {
600     int i1 = long_at(ldst_offset);
601     Register rd = inv_rd(i0);
602 
603     op3 = inv_op3(i1);
604     if (!is_op(i1, Assembler::ldst_op) &amp;&amp; rd == inv_rs2(i1) &amp;&amp;
605          0 != (op3 &lt; op3_ldst_int_limit
</pre>
</td>
<td>
<hr />
<pre>
557 
558   nm = nativeMovConstRegPatching_at( cb.insts_begin() );
559   nm-&gt;print();
560 
561   nm = nativeMovConstRegPatching_at( nm-&gt;next_instruction_address() );
562   for (idx = 0; idx &lt; ARRAY_SIZE(offsets); idx++) {
563     nm-&gt;set_data( offsets[idx] );
564     assert(nm-&gt;data() == offsets[idx], &quot;check unit test&quot;);
565   }
566   nm-&gt;print();
567 
568   VM_Version::revert();
569 #endif // ASSERT
570 }
571 // End code for unit testing implementation of NativeMovConstRegPatching class
572 
573 
574 //-------------------------------------------------------------------
575 
576 









577 void NativeMovRegMem::verify() {
578   NativeInstruction::verify();
579   // make sure code pattern is actually a &quot;ld&quot; or &quot;st&quot; of some sort.
580   int i0 = long_at(0);
581   int op3 = inv_op3(i0);
582 
583   assert((int)add_offset == NativeMovConstReg::add_offset, &quot;sethi size ok&quot;);
584 
585   if (!(is_op(i0, Assembler::ldst_op) &amp;&amp;
586         inv_immed(i0) &amp;&amp;
587         0 != (op3 &lt; op3_ldst_int_limit
588          ? (1 &lt;&lt;  op3                      ) &amp; (op3_mask_ld  | op3_mask_st)
589          : (1 &lt;&lt; (op3 - op3_ldst_int_limit)) &amp; (op3_mask_ldf | op3_mask_stf))))
590   {
591     int i1 = long_at(ldst_offset);
592     Register rd = inv_rd(i0);
593 
594     op3 = inv_op3(i1);
595     if (!is_op(i1, Assembler::ldst_op) &amp;&amp; rd == inv_rs2(i1) &amp;&amp;
596          0 != (op3 &lt; op3_ldst_int_limit
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_sparc.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_sparc.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
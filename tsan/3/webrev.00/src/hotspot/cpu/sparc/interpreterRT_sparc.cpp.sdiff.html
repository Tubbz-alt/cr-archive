<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/interpreterRT_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniFastGetField_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/interpreterRT_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.inline.hpp&quot;
 27 #include &quot;interpreter/interp_masm.hpp&quot;
 28 #include &quot;interpreter/interpreter.hpp&quot;
 29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-removed"> 31 #include &quot;memory/universe.hpp&quot;</span>
 32 #include &quot;oops/method.hpp&quot;
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/icache.hpp&quot;
 36 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 37 #include &quot;runtime/signature.hpp&quot;
 38 
 39 
 40 #define __ _masm-&gt;
 41 
 42 
 43 // Implementation of SignatureHandlerGenerator
 44 InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 45     const methodHandle&amp; method, CodeBuffer* buffer) : NativeSignatureIterator(method) {
 46   _masm = new MacroAssembler(buffer);
 47 }
 48 
 49 void InterpreterRuntime::SignatureHandlerGenerator::pass_word(int size_of_arg, int offset_in_arg) {
 50   Argument  jni_arg(jni_offset() + offset_in_arg, false);
 51   Register     Rtmp = O0;
</pre>
<hr />
<pre>
174 
175   virtual void add_signature( intptr_t sig_type ) {
176     if ( _argcount &lt; (sizeof (intptr_t))*4 ) {
177       *_RegArgSignature |= (sig_type &lt;&lt; (_argcount*2) );
178       _argcount++;
179     }
180   }
181 
182 
183  public:
184   SlowSignatureHandler(const methodHandle&amp; method, address from, intptr_t* to, intptr_t *RegArgSig) : NativeSignatureIterator(method) {
185     _from = from;
186     _to   = to;
187     _RegArgSignature = RegArgSig;
188     *_RegArgSignature = 0;
189     _argcount = method-&gt;is_static() ? 2 : 1;
190   }
191 };
192 
193 
<span class="line-modified">194 IRT_ENTRY(address, InterpreterRuntime::slow_signature_handler(</span>
195                                                     JavaThread* thread,
196                                                     Method* method,
197                                                     intptr_t* from,
198                                                     intptr_t* to ))
199   methodHandle m(thread, method);
200   assert(m-&gt;is_native(), &quot;sanity check&quot;);
201   // handle arguments
202   // Warning: We use reg arg slot 00 temporarily to return the RegArgSignature
203   // back to the code that pops the arguments into the CPU registers
204   SlowSignatureHandler(m, (address)from, m-&gt;is_static() ? to+2 : to+1, to).iterate((uint64_t)CONST64(-1));
205   // return result handler
206   return Interpreter::result_handler(m-&gt;result_type());
<span class="line-modified">207 IRT_END</span>
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.inline.hpp&quot;
 27 #include &quot;interpreter/interp_masm.hpp&quot;
 28 #include &quot;interpreter/interpreter.hpp&quot;
 29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;

 31 #include &quot;oops/method.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/icache.hpp&quot;
 35 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 36 #include &quot;runtime/signature.hpp&quot;
 37 
 38 
 39 #define __ _masm-&gt;
 40 
 41 
 42 // Implementation of SignatureHandlerGenerator
 43 InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 44     const methodHandle&amp; method, CodeBuffer* buffer) : NativeSignatureIterator(method) {
 45   _masm = new MacroAssembler(buffer);
 46 }
 47 
 48 void InterpreterRuntime::SignatureHandlerGenerator::pass_word(int size_of_arg, int offset_in_arg) {
 49   Argument  jni_arg(jni_offset() + offset_in_arg, false);
 50   Register     Rtmp = O0;
</pre>
<hr />
<pre>
173 
174   virtual void add_signature( intptr_t sig_type ) {
175     if ( _argcount &lt; (sizeof (intptr_t))*4 ) {
176       *_RegArgSignature |= (sig_type &lt;&lt; (_argcount*2) );
177       _argcount++;
178     }
179   }
180 
181 
182  public:
183   SlowSignatureHandler(const methodHandle&amp; method, address from, intptr_t* to, intptr_t *RegArgSig) : NativeSignatureIterator(method) {
184     _from = from;
185     _to   = to;
186     _RegArgSignature = RegArgSig;
187     *_RegArgSignature = 0;
188     _argcount = method-&gt;is_static() ? 2 : 1;
189   }
190 };
191 
192 
<span class="line-modified">193 JRT_ENTRY(address, InterpreterRuntime::slow_signature_handler(</span>
194                                                     JavaThread* thread,
195                                                     Method* method,
196                                                     intptr_t* from,
197                                                     intptr_t* to ))
198   methodHandle m(thread, method);
199   assert(m-&gt;is_native(), &quot;sanity check&quot;);
200   // handle arguments
201   // Warning: We use reg arg slot 00 temporarily to return the RegArgSignature
202   // back to the code that pops the arguments into the CPU registers
203   SlowSignatureHandler(m, (address)from, m-&gt;is_static() ? to+2 : to+1, to).iterate((uint64_t)CONST64(-1));
204   // return result handler
205   return Interpreter::result_handler(m-&gt;result_type());
<span class="line-modified">206 JRT_END</span>
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniFastGetField_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
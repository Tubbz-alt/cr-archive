<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/macroAssembler_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;compiler/disassembler.hpp&quot;
  29 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
  35 #include &quot;oops/accessDecorators.hpp&quot;
<a name="1" id="anc1"></a>
  36 #include &quot;oops/klass.inline.hpp&quot;
  37 #include &quot;prims/methodHandles.hpp&quot;
  38 #include &quot;runtime/biasedLocking.hpp&quot;
  39 #include &quot;runtime/flags/flagSetting.hpp&quot;
  40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  41 #include &quot;runtime/jniHandles.inline.hpp&quot;
  42 #include &quot;runtime/objectMonitor.hpp&quot;
  43 #include &quot;runtime/os.inline.hpp&quot;
  44 #include &quot;runtime/safepoint.hpp&quot;
  45 #include &quot;runtime/safepointMechanism.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;runtime/stubRoutines.hpp&quot;
  48 #include &quot;utilities/align.hpp&quot;
  49 #include &quot;utilities/macros.hpp&quot;
<a name="2" id="anc2"></a>
  50 #ifdef COMPILER2
  51 #include &quot;opto/intrinsicnode.hpp&quot;
  52 #endif
  53 
  54 #ifdef PRODUCT
  55 #define BLOCK_COMMENT(str) /* nothing */
  56 #define STOP(error) stop(error)
  57 #else
  58 #define BLOCK_COMMENT(str) block_comment(str)
  59 #define STOP(error) block_comment(error); stop(error)
  60 #endif
  61 
  62 // Convert the raw encoding form into the form expected by the
  63 // constructor for Address.
  64 Address Address::make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc) {
  65   assert(scale == 0, &quot;not supported&quot;);
  66   RelocationHolder rspec;
  67   if (disp_reloc != relocInfo::none) {
  68     rspec = Relocation::spec_simple(disp_reloc);
  69   }
  70 
  71   Register rindex = as_Register(index);
  72   if (rindex != G0) {
  73     Address madr(as_Register(base), rindex);
  74     madr._rspec = rspec;
  75     return madr;
  76   } else {
  77     Address madr(as_Register(base), disp);
  78     madr._rspec = rspec;
  79     return madr;
  80   }
  81 }
  82 
  83 Address Argument::address_in_frame() const {
  84   // Warning: In LP64 mode disp will occupy more than 10 bits, but
  85   //          op codes such as ld or ldx, only access disp() to get
  86   //          their simm13 argument.
  87   int disp = ((_number - Argument::n_register_parameters + frame::memory_parameter_word_sp_offset) * BytesPerWord) + STACK_BIAS;
  88   if (is_in())
  89     return Address(FP, disp); // In argument.
  90   else
  91     return Address(SP, disp); // Out argument.
  92 }
  93 
  94 static const char* argumentNames[][2] = {
  95   {&quot;A0&quot;,&quot;P0&quot;}, {&quot;A1&quot;,&quot;P1&quot;}, {&quot;A2&quot;,&quot;P2&quot;}, {&quot;A3&quot;,&quot;P3&quot;}, {&quot;A4&quot;,&quot;P4&quot;},
  96   {&quot;A5&quot;,&quot;P5&quot;}, {&quot;A6&quot;,&quot;P6&quot;}, {&quot;A7&quot;,&quot;P7&quot;}, {&quot;A8&quot;,&quot;P8&quot;}, {&quot;A9&quot;,&quot;P9&quot;},
  97   {&quot;A(n&gt;9)&quot;,&quot;P(n&gt;9)&quot;}
  98 };
  99 
 100 const char* Argument::name() const {
 101   int nofArgs = sizeof argumentNames / sizeof argumentNames[0];
 102   int num = number();
 103   if (num &gt;= nofArgs)  num = nofArgs - 1;
 104   return argumentNames[num][is_in() ? 1 : 0];
 105 }
 106 
 107 #ifdef ASSERT
 108 // On RISC, there&#39;s no benefit to verifying instruction boundaries.
 109 bool AbstractAssembler::pd_check_instruction_mark() { return false; }
 110 #endif
 111 
 112 // Patch instruction inst at offset inst_pos to refer to dest_pos
 113 // and return the resulting instruction.
 114 // We should have pcs, not offsets, but since all is relative, it will work out
 115 // OK.
 116 int MacroAssembler::patched_branch(int dest_pos, int inst, int inst_pos) {
 117   int m; // mask for displacement field
 118   int v; // new value for displacement field
 119   const int word_aligned_ones = -4;
 120   switch (inv_op(inst)) {
 121   default: ShouldNotReachHere();
 122   case call_op:    m = wdisp(word_aligned_ones, 0, 30);  v = wdisp(dest_pos, inst_pos, 30); break;
 123   case branch_op:
 124     switch (inv_op2(inst)) {
 125       case fbp_op2:    m = wdisp(  word_aligned_ones, 0, 19);  v = wdisp(  dest_pos, inst_pos, 19); break;
 126       case bp_op2:     m = wdisp(  word_aligned_ones, 0, 19);  v = wdisp(  dest_pos, inst_pos, 19); break;
 127       case fb_op2:     m = wdisp(  word_aligned_ones, 0, 22);  v = wdisp(  dest_pos, inst_pos, 22); break;
 128       case br_op2:     m = wdisp(  word_aligned_ones, 0, 22);  v = wdisp(  dest_pos, inst_pos, 22); break;
 129       case bpr_op2: {
 130         if (is_cbcond(inst)) {
 131           m = wdisp10(word_aligned_ones, 0);
 132           v = wdisp10(dest_pos, inst_pos);
 133         } else {
 134           m = wdisp16(word_aligned_ones, 0);
 135           v = wdisp16(dest_pos, inst_pos);
 136         }
 137         break;
 138       }
 139       default: ShouldNotReachHere();
 140     }
 141   }
 142   return  inst &amp; ~m  |  v;
 143 }
 144 
 145 // Return the offset of the branch destionation of instruction inst
 146 // at offset pos.
 147 // Should have pcs, but since all is relative, it works out.
 148 int MacroAssembler::branch_destination(int inst, int pos) {
 149   int r;
 150   switch (inv_op(inst)) {
 151   default: ShouldNotReachHere();
 152   case call_op:        r = inv_wdisp(inst, pos, 30);  break;
 153   case branch_op:
 154     switch (inv_op2(inst)) {
 155       case fbp_op2:    r = inv_wdisp(  inst, pos, 19);  break;
 156       case bp_op2:     r = inv_wdisp(  inst, pos, 19);  break;
 157       case fb_op2:     r = inv_wdisp(  inst, pos, 22);  break;
 158       case br_op2:     r = inv_wdisp(  inst, pos, 22);  break;
 159       case bpr_op2: {
 160         if (is_cbcond(inst)) {
 161           r = inv_wdisp10(inst, pos);
 162         } else {
 163           r = inv_wdisp16(inst, pos);
 164         }
 165         break;
 166       }
 167       default: ShouldNotReachHere();
 168     }
 169   }
 170   return r;
 171 }
 172 
 173 void MacroAssembler::resolve_jobject(Register value, Register tmp) {
 174   Label done, not_weak;
 175   br_null(value, false, Assembler::pn, done); // Use NULL as-is.
 176   delayed()-&gt;andcc(value, JNIHandles::weak_tag_mask, G0); // Test for jweak
 177   brx(Assembler::zero, true, Assembler::pt, not_weak);
 178   delayed()-&gt;nop();
 179   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
 180                  Address(value, -JNIHandles::weak_tag_value), value, tmp);
 181   verify_oop(value);
 182   br (Assembler::always, true, Assembler::pt, done);
 183   delayed()-&gt;nop();
 184   bind(not_weak);
 185   access_load_at(T_OBJECT, IN_NATIVE, Address(value, 0), value, tmp);
 186   verify_oop(value);
 187   bind(done);
 188 }
 189 
 190 void MacroAssembler::null_check(Register reg, int offset) {
 191   if (needs_explicit_null_check((intptr_t)offset)) {
 192     // provoke OS NULL exception if reg = NULL by
 193     // accessing M[reg] w/o changing any registers
 194     ld_ptr(reg, 0, G0);
 195   }
 196   else {
 197     // nothing to do, (later) access of M[reg + offset]
 198     // will provoke OS NULL exception if reg = NULL
 199   }
 200 }
 201 
 202 // Ring buffer jumps
 203 
 204 
 205 void MacroAssembler::jmp2(Register r1, Register r2, const char* file, int line ) {
 206   assert_not_delayed();
 207   jmpl(r1, r2, G0);
 208 }
 209 void MacroAssembler::jmp(Register r1, int offset, const char* file, int line ) {
 210   assert_not_delayed();
 211   jmp(r1, offset);
 212 }
 213 
 214 // This code sequence is relocatable to any address, even on LP64.
 215 void MacroAssembler::jumpl(const AddressLiteral&amp; addrlit, Register temp, Register d, int offset, const char* file, int line) {
 216   assert_not_delayed();
 217   // Force fixed length sethi because NativeJump and NativeFarCall don&#39;t handle
 218   // variable length instruction streams.
 219   patchable_sethi(addrlit, temp);
 220   Address a(temp, addrlit.low10() + offset);  // Add the offset to the displacement.
 221   jmpl(a.base(), a.disp(), d);
 222 }
 223 
 224 void MacroAssembler::jump(const AddressLiteral&amp; addrlit, Register temp, int offset, const char* file, int line) {
 225   jumpl(addrlit, temp, G0, offset, file, line);
 226 }
 227 
 228 
 229 // Conditional breakpoint (for assertion checks in assembly code)
 230 void MacroAssembler::breakpoint_trap(Condition c, CC cc) {
 231   trap(c, cc, G0, ST_RESERVED_FOR_USER_0);
 232 }
 233 
 234 // We want to use ST_BREAKPOINT here, but the debugger is confused by it.
 235 void MacroAssembler::breakpoint_trap() {
 236   trap(ST_RESERVED_FOR_USER_0);
 237 }
 238 
 239 void MacroAssembler::safepoint_poll(Label&amp; slow_path, bool a, Register thread_reg, Register temp_reg) {
 240   if (SafepointMechanism::uses_thread_local_poll()) {
 241     ldx(Address(thread_reg, Thread::polling_page_offset()), temp_reg, 0);
 242     // Armed page has poll bit set.
 243     and3(temp_reg, SafepointMechanism::poll_bit(), temp_reg);
 244     br_notnull(temp_reg, a, Assembler::pn, slow_path);
 245   } else {
 246     AddressLiteral sync_state(SafepointSynchronize::address_of_state());
 247 
 248     load_contents(sync_state, temp_reg);
 249     cmp(temp_reg, SafepointSynchronize::_not_synchronized);
 250     br(Assembler::notEqual, a, Assembler::pn, slow_path);
 251   }
 252 }
 253 
 254 void MacroAssembler::enter() {
 255   Unimplemented();
 256 }
 257 
 258 void MacroAssembler::leave() {
 259   Unimplemented();
 260 }
 261 
 262 // Calls to C land
 263 
 264 #ifdef ASSERT
 265 // a hook for debugging
 266 static Thread* reinitialize_thread() {
 267   return Thread::current();
 268 }
 269 #else
 270 #define reinitialize_thread Thread::current
 271 #endif
 272 
 273 #ifdef ASSERT
 274 address last_get_thread = NULL;
 275 #endif
 276 
 277 // call this when G2_thread is not known to be valid
 278 void MacroAssembler::get_thread() {
 279   save_frame(0);                // to avoid clobbering O0
 280   mov(G1, L0);                  // avoid clobbering G1
 281   mov(G5_method, L1);           // avoid clobbering G5
 282   mov(G3, L2);                  // avoid clobbering G3 also
 283   mov(G4, L5);                  // avoid clobbering G4
 284 #ifdef ASSERT
 285   AddressLiteral last_get_thread_addrlit(&amp;last_get_thread);
 286   set(last_get_thread_addrlit, L3);
 287   rdpc(L4);
 288   inc(L4, 3 * BytesPerInstWord); // skip rdpc + inc + st_ptr to point L4 at call  st_ptr(L4, L3, 0);
 289 #endif
 290   call(CAST_FROM_FN_PTR(address, reinitialize_thread), relocInfo::runtime_call_type);
 291   delayed()-&gt;nop();
 292   mov(L0, G1);
 293   mov(L1, G5_method);
 294   mov(L2, G3);
 295   mov(L5, G4);
 296   restore(O0, 0, G2_thread);
 297 }
 298 
 299 static Thread* verify_thread_subroutine(Thread* gthread_value) {
 300   Thread* correct_value = Thread::current();
 301   guarantee(gthread_value == correct_value, &quot;G2_thread value must be the thread&quot;);
 302   return correct_value;
 303 }
 304 
 305 void MacroAssembler::verify_thread() {
 306   if (VerifyThread) {
 307     // NOTE: this chops off the heads of the 64-bit O registers.
 308     // make sure G2_thread contains the right value
 309     save_frame_and_mov(0, Lmethod, Lmethod);   // to avoid clobbering O0 (and propagate Lmethod)
 310     mov(G1, L1);                // avoid clobbering G1
 311     // G2 saved below
 312     mov(G3, L3);                // avoid clobbering G3
 313     mov(G4, L4);                // avoid clobbering G4
 314     mov(G5_method, L5);         // avoid clobbering G5_method
 315     call(CAST_FROM_FN_PTR(address,verify_thread_subroutine), relocInfo::runtime_call_type);
 316     delayed()-&gt;mov(G2_thread, O0);
 317 
 318     mov(L1, G1);                // Restore G1
 319     // G2 restored below
 320     mov(L3, G3);                // restore G3
 321     mov(L4, G4);                // restore G4
 322     mov(L5, G5_method);         // restore G5_method
 323     restore(O0, 0, G2_thread);
 324   }
 325 }
 326 
 327 
 328 void MacroAssembler::save_thread(const Register thread_cache) {
 329   verify_thread();
 330   if (thread_cache-&gt;is_valid()) {
 331     assert(thread_cache-&gt;is_local() || thread_cache-&gt;is_in(), &quot;bad volatile&quot;);
 332     mov(G2_thread, thread_cache);
 333   }
 334   if (VerifyThread) {
 335     // smash G2_thread, as if the VM were about to anyway
 336     set(0x67676767, G2_thread);
 337   }
 338 }
 339 
 340 
 341 void MacroAssembler::restore_thread(const Register thread_cache) {
 342   if (thread_cache-&gt;is_valid()) {
 343     assert(thread_cache-&gt;is_local() || thread_cache-&gt;is_in(), &quot;bad volatile&quot;);
 344     mov(thread_cache, G2_thread);
 345     verify_thread();
 346   } else {
 347     // do it the slow way
 348     get_thread();
 349   }
 350 }
 351 
 352 
 353 // %%% maybe get rid of [re]set_last_Java_frame
 354 void MacroAssembler::set_last_Java_frame(Register last_java_sp, Register last_Java_pc) {
 355   assert_not_delayed();
 356   Address flags(G2_thread, JavaThread::frame_anchor_offset() +
 357                            JavaFrameAnchor::flags_offset());
 358   Address pc_addr(G2_thread, JavaThread::last_Java_pc_offset());
 359 
 360   // Always set last_Java_pc and flags first because once last_Java_sp is visible
 361   // has_last_Java_frame is true and users will look at the rest of the fields.
 362   // (Note: flags should always be zero before we get here so doesn&#39;t need to be set.)
 363 
 364 #ifdef ASSERT
 365   // Verify that flags was zeroed on return to Java
 366   Label PcOk;
 367   save_frame(0);                // to avoid clobbering O0
 368   ld_ptr(pc_addr, L0);
 369   br_null_short(L0, Assembler::pt, PcOk);
 370   STOP(&quot;last_Java_pc not zeroed before leaving Java&quot;);
 371   bind(PcOk);
 372 
 373   // Verify that flags was zeroed on return to Java
 374   Label FlagsOk;
 375   ld(flags, L0);
 376   tst(L0);
 377   br(Assembler::zero, false, Assembler::pt, FlagsOk);
 378   delayed() -&gt; restore();
 379   STOP(&quot;flags not zeroed before leaving Java&quot;);
 380   bind(FlagsOk);
 381 #endif /* ASSERT */
 382   //
 383   // When returning from calling out from Java mode the frame anchor&#39;s last_Java_pc
 384   // will always be set to NULL. It is set here so that if we are doing a call to
 385   // native (not VM) that we capture the known pc and don&#39;t have to rely on the
 386   // native call having a standard frame linkage where we can find the pc.
 387 
 388   if (last_Java_pc-&gt;is_valid()) {
 389     st_ptr(last_Java_pc, pc_addr);
 390   }
 391 
 392 #ifdef ASSERT
 393   // Make sure that we have an odd stack
 394   Label StackOk;
 395   andcc(last_java_sp, 0x01, G0);
 396   br(Assembler::notZero, false, Assembler::pt, StackOk);
 397   delayed()-&gt;nop();
 398   STOP(&quot;Stack Not Biased in set_last_Java_frame&quot;);
 399   bind(StackOk);
 400 #endif // ASSERT
 401   assert( last_java_sp != G4_scratch, &quot;bad register usage in set_last_Java_frame&quot;);
 402   add( last_java_sp, STACK_BIAS, G4_scratch );
 403   st_ptr(G4_scratch, G2_thread, JavaThread::last_Java_sp_offset());
 404 }
 405 
 406 void MacroAssembler::reset_last_Java_frame(void) {
 407   assert_not_delayed();
 408 
 409   Address sp_addr(G2_thread, JavaThread::last_Java_sp_offset());
 410   Address pc_addr(G2_thread, JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
 411   Address flags  (G2_thread, JavaThread::frame_anchor_offset() + JavaFrameAnchor::flags_offset());
 412 
 413 #ifdef ASSERT
 414   // check that it WAS previously set
 415     save_frame_and_mov(0, Lmethod, Lmethod);     // Propagate Lmethod to helper frame
 416     ld_ptr(sp_addr, L0);
 417     tst(L0);
 418     breakpoint_trap(Assembler::zero, Assembler::ptr_cc);
 419     restore();
 420 #endif // ASSERT
 421 
 422   st_ptr(G0, sp_addr);
 423   // Always return last_Java_pc to zero
 424   st_ptr(G0, pc_addr);
 425   // Always null flags after return to Java
 426   st(G0, flags);
 427 }
 428 
 429 
 430 void MacroAssembler::call_VM_base(
 431   Register        oop_result,
 432   Register        thread_cache,
 433   Register        last_java_sp,
 434   address         entry_point,
 435   int             number_of_arguments,
 436   bool            check_exceptions)
 437 {
 438   assert_not_delayed();
 439 
 440   // determine last_java_sp register
 441   if (!last_java_sp-&gt;is_valid()) {
 442     last_java_sp = SP;
 443   }
 444   // debugging support
 445   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
 446 
 447   // 64-bit last_java_sp is biased!
 448   set_last_Java_frame(last_java_sp, noreg);
 449   if (VerifyThread)  mov(G2_thread, O0); // about to be smashed; pass early
 450   save_thread(thread_cache);
 451   // do the call
 452   call(entry_point, relocInfo::runtime_call_type);
 453   if (!VerifyThread)
 454     delayed()-&gt;mov(G2_thread, O0);  // pass thread as first argument
 455   else
 456     delayed()-&gt;nop();             // (thread already passed)
 457   restore_thread(thread_cache);
 458   reset_last_Java_frame();
 459 
 460   // check for pending exceptions. use Gtemp as scratch register.
 461   if (check_exceptions) {
 462     check_and_forward_exception(Gtemp);
 463   }
 464 
 465 #ifdef ASSERT
 466   set(badHeapWordVal, G3);
 467   set(badHeapWordVal, G4);
 468   set(badHeapWordVal, G5);
 469 #endif
 470 
 471   // get oop result if there is one and reset the value in the thread
 472   if (oop_result-&gt;is_valid()) {
 473     get_vm_result(oop_result);
 474   }
 475 }
 476 
 477 void MacroAssembler::check_and_forward_exception(Register scratch_reg)
 478 {
 479   Label L;
 480 
 481   check_and_handle_popframe(scratch_reg);
 482   check_and_handle_earlyret(scratch_reg);
 483 
 484   Address exception_addr(G2_thread, Thread::pending_exception_offset());
 485   ld_ptr(exception_addr, scratch_reg);
 486   br_null_short(scratch_reg, pt, L);
 487   // we use O7 linkage so that forward_exception_entry has the issuing PC
 488   call(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type);
 489   delayed()-&gt;nop();
 490   bind(L);
 491 }
 492 
 493 
 494 void MacroAssembler::check_and_handle_popframe(Register scratch_reg) {
 495 }
 496 
 497 
 498 void MacroAssembler::check_and_handle_earlyret(Register scratch_reg) {
 499 }
 500 
 501 
 502 void MacroAssembler::call_VM(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
 503   call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);
 504 }
 505 
 506 
 507 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, bool check_exceptions) {
 508   // O0 is reserved for the thread
 509   mov(arg_1, O1);
 510   call_VM(oop_result, entry_point, 1, check_exceptions);
 511 }
 512 
 513 
 514 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, bool check_exceptions) {
 515   // O0 is reserved for the thread
 516   mov(arg_1, O1);
 517   mov(arg_2, O2); assert(arg_2 != O1, &quot;smashed argument&quot;);
 518   call_VM(oop_result, entry_point, 2, check_exceptions);
 519 }
 520 
 521 
 522 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions) {
 523   // O0 is reserved for the thread
 524   mov(arg_1, O1);
 525   mov(arg_2, O2); assert(arg_2 != O1,                &quot;smashed argument&quot;);
 526   mov(arg_3, O3); assert(arg_3 != O1 &amp;&amp; arg_3 != O2, &quot;smashed argument&quot;);
 527   call_VM(oop_result, entry_point, 3, check_exceptions);
 528 }
 529 
 530 
 531 
 532 // Note: The following call_VM overloadings are useful when a &quot;save&quot;
 533 // has already been performed by a stub, and the last Java frame is
 534 // the previous one.  In that case, last_java_sp must be passed as FP
 535 // instead of SP.
 536 
 537 
 538 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments, bool check_exceptions) {
 539   call_VM_base(oop_result, noreg, last_java_sp, entry_point, number_of_arguments, check_exceptions);
 540 }
 541 
 542 
 543 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions) {
 544   // O0 is reserved for the thread
 545   mov(arg_1, O1);
 546   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
 547 }
 548 
 549 
 550 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions) {
 551   // O0 is reserved for the thread
 552   mov(arg_1, O1);
 553   mov(arg_2, O2); assert(arg_2 != O1, &quot;smashed argument&quot;);
 554   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
 555 }
 556 
 557 
 558 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions) {
 559   // O0 is reserved for the thread
 560   mov(arg_1, O1);
 561   mov(arg_2, O2); assert(arg_2 != O1,                &quot;smashed argument&quot;);
 562   mov(arg_3, O3); assert(arg_3 != O1 &amp;&amp; arg_3 != O2, &quot;smashed argument&quot;);
 563   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
 564 }
 565 
 566 
 567 
 568 void MacroAssembler::call_VM_leaf_base(Register thread_cache, address entry_point, int number_of_arguments) {
 569   assert_not_delayed();
 570   save_thread(thread_cache);
 571   // do the call
 572   call(entry_point, relocInfo::runtime_call_type);
 573   delayed()-&gt;nop();
 574   restore_thread(thread_cache);
 575 #ifdef ASSERT
 576   set(badHeapWordVal, G3);
 577   set(badHeapWordVal, G4);
 578   set(badHeapWordVal, G5);
 579 #endif
 580 }
 581 
 582 
 583 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, int number_of_arguments) {
 584   call_VM_leaf_base(thread_cache, entry_point, number_of_arguments);
 585 }
 586 
 587 
 588 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, Register arg_1) {
 589   mov(arg_1, O0);
 590   call_VM_leaf(thread_cache, entry_point, 1);
 591 }
 592 
 593 
 594 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, Register arg_1, Register arg_2) {
 595   mov(arg_1, O0);
 596   mov(arg_2, O1); assert(arg_2 != O0, &quot;smashed argument&quot;);
 597   call_VM_leaf(thread_cache, entry_point, 2);
 598 }
 599 
 600 
 601 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, Register arg_1, Register arg_2, Register arg_3) {
 602   mov(arg_1, O0);
 603   mov(arg_2, O1); assert(arg_2 != O0,                &quot;smashed argument&quot;);
 604   mov(arg_3, O2); assert(arg_3 != O0 &amp;&amp; arg_3 != O1, &quot;smashed argument&quot;);
 605   call_VM_leaf(thread_cache, entry_point, 3);
 606 }
 607 
 608 
 609 void MacroAssembler::get_vm_result(Register oop_result) {
 610   verify_thread();
 611   Address vm_result_addr(G2_thread, JavaThread::vm_result_offset());
 612   ld_ptr(    vm_result_addr, oop_result);
 613   st_ptr(G0, vm_result_addr);
 614   verify_oop(oop_result);
 615 }
 616 
 617 
 618 void MacroAssembler::get_vm_result_2(Register metadata_result) {
 619   verify_thread();
 620   Address vm_result_addr_2(G2_thread, JavaThread::vm_result_2_offset());
 621   ld_ptr(vm_result_addr_2, metadata_result);
 622   st_ptr(G0, vm_result_addr_2);
 623 }
 624 
 625 
 626 // We require that C code which does not return a value in vm_result will
 627 // leave it undisturbed.
 628 void MacroAssembler::set_vm_result(Register oop_result) {
 629   verify_thread();
 630   Address vm_result_addr(G2_thread, JavaThread::vm_result_offset());
 631   verify_oop(oop_result);
 632 
 633 # ifdef ASSERT
 634     // Check that we are not overwriting any other oop.
 635     save_frame_and_mov(0, Lmethod, Lmethod);     // Propagate Lmethod
 636     ld_ptr(vm_result_addr, L0);
 637     tst(L0);
 638     restore();
 639     breakpoint_trap(notZero, Assembler::ptr_cc);
 640     // }
 641 # endif
 642 
 643   st_ptr(oop_result, vm_result_addr);
 644 }
 645 
 646 
 647 void MacroAssembler::ic_call(address entry, bool emit_delay, jint method_index) {
 648   RelocationHolder rspec = virtual_call_Relocation::spec(pc(), method_index);
 649   patchable_set((intptr_t)Universe::non_oop_word(), G5_inline_cache_reg);
 650   relocate(rspec);
 651   call(entry, relocInfo::none);
 652   if (emit_delay) {
 653     delayed()-&gt;nop();
 654   }
 655 }
 656 
 657 
 658 void MacroAssembler::internal_sethi(const AddressLiteral&amp; addrlit, Register d, bool ForceRelocatable) {
 659   address save_pc;
 660   int shiftcnt;
 661 #ifdef VALIDATE_PIPELINE
 662   assert_no_delay(&quot;Cannot put two instructions in delay-slot.&quot;);
 663 #endif
 664   v9_dep();
 665   save_pc = pc();
 666 
 667   int msb32 = (int) (addrlit.value() &gt;&gt; 32);
 668   int lsb32 = (int) (addrlit.value());
 669 
 670   if (msb32 == 0 &amp;&amp; lsb32 &gt;= 0) {
 671     Assembler::sethi(lsb32, d, addrlit.rspec());
 672   }
 673   else if (msb32 == -1) {
 674     Assembler::sethi(~lsb32, d, addrlit.rspec());
 675     xor3(d, ~low10(~0), d);
 676   }
 677   else {
 678     Assembler::sethi(msb32, d, addrlit.rspec());  // msb 22-bits
 679     if (msb32 &amp; 0x3ff)                            // Any bits?
 680       or3(d, msb32 &amp; 0x3ff, d);                   // msb 32-bits are now in lsb 32
 681     if (lsb32 &amp; 0xFFFFFC00) {                     // done?
 682       if ((lsb32 &gt;&gt; 20) &amp; 0xfff) {                // Any bits set?
 683         sllx(d, 12, d);                           // Make room for next 12 bits
 684         or3(d, (lsb32 &gt;&gt; 20) &amp; 0xfff, d);         // Or in next 12
 685         shiftcnt = 0;                             // We already shifted
 686       }
 687       else
 688         shiftcnt = 12;
 689       if ((lsb32 &gt;&gt; 10) &amp; 0x3ff) {
 690         sllx(d, shiftcnt + 10, d);                // Make room for last 10 bits
 691         or3(d, (lsb32 &gt;&gt; 10) &amp; 0x3ff, d);         // Or in next 10
 692         shiftcnt = 0;
 693       }
 694       else
 695         shiftcnt = 10;
 696       sllx(d, shiftcnt + 10, d);                  // Shift leaving disp field 0&#39;d
 697     }
 698     else
 699       sllx(d, 32, d);
 700   }
 701   // Pad out the instruction sequence so it can be patched later.
 702   if (ForceRelocatable || (addrlit.rtype() != relocInfo::none &amp;&amp;
 703                            addrlit.rtype() != relocInfo::runtime_call_type)) {
 704     while (pc() &lt; (save_pc + (7 * BytesPerInstWord)))
 705       nop();
 706   }
 707 }
 708 
 709 
 710 void MacroAssembler::sethi(const AddressLiteral&amp; addrlit, Register d) {
 711   internal_sethi(addrlit, d, false);
 712 }
 713 
 714 
 715 void MacroAssembler::patchable_sethi(const AddressLiteral&amp; addrlit, Register d) {
 716   internal_sethi(addrlit, d, true);
 717 }
 718 
 719 
 720 int MacroAssembler::insts_for_sethi(address a, bool worst_case) {
 721   if (worst_case)  return 7;
 722   intptr_t iaddr = (intptr_t) a;
 723   int msb32 = (int) (iaddr &gt;&gt; 32);
 724   int lsb32 = (int) (iaddr);
 725   int count;
 726   if (msb32 == 0 &amp;&amp; lsb32 &gt;= 0)
 727     count = 1;
 728   else if (msb32 == -1)
 729     count = 2;
 730   else {
 731     count = 2;
 732     if (msb32 &amp; 0x3ff)
 733       count++;
 734     if (lsb32 &amp; 0xFFFFFC00 ) {
 735       if ((lsb32 &gt;&gt; 20) &amp; 0xfff)  count += 2;
 736       if ((lsb32 &gt;&gt; 10) &amp; 0x3ff)  count += 2;
 737     }
 738   }
 739   return count;
 740 }
 741 
 742 int MacroAssembler::worst_case_insts_for_set() {
 743   return insts_for_sethi(NULL, true) + 1;
 744 }
 745 
 746 
 747 // Keep in sync with MacroAssembler::insts_for_internal_set
 748 void MacroAssembler::internal_set(const AddressLiteral&amp; addrlit, Register d, bool ForceRelocatable) {
 749   intptr_t value = addrlit.value();
 750 
 751   if (!ForceRelocatable &amp;&amp; addrlit.rspec().type() == relocInfo::none) {
 752     // can optimize
 753     if (-4096 &lt;= value &amp;&amp; value &lt;= 4095) {
 754       or3(G0, value, d); // setsw (this leaves upper 32 bits sign-extended)
 755       return;
 756     }
 757     if (inv_hi22(hi22(value)) == value) {
 758       sethi(addrlit, d);
 759       return;
 760     }
 761   }
 762   assert_no_delay(&quot;Cannot put two instructions in delay-slot.&quot;);
 763   internal_sethi(addrlit, d, ForceRelocatable);
 764   if (ForceRelocatable || addrlit.rspec().type() != relocInfo::none || addrlit.low10() != 0) {
 765     add(d, addrlit.low10(), d, addrlit.rspec());
 766   }
 767 }
 768 
 769 // Keep in sync with MacroAssembler::internal_set
 770 int MacroAssembler::insts_for_internal_set(intptr_t value) {
 771   // can optimize
 772   if (-4096 &lt;= value &amp;&amp; value &lt;= 4095) {
 773     return 1;
 774   }
 775   if (inv_hi22(hi22(value)) == value) {
 776     return insts_for_sethi((address) value);
 777   }
 778   int count = insts_for_sethi((address) value);
 779   AddressLiteral al(value);
 780   if (al.low10() != 0) {
 781     count++;
 782   }
 783   return count;
 784 }
 785 
 786 void MacroAssembler::set(const AddressLiteral&amp; al, Register d) {
 787   internal_set(al, d, false);
 788 }
 789 
 790 void MacroAssembler::set(intptr_t value, Register d) {
 791   AddressLiteral al(value);
 792   internal_set(al, d, false);
 793 }
 794 
 795 void MacroAssembler::set(address addr, Register d, RelocationHolder const&amp; rspec) {
 796   AddressLiteral al(addr, rspec);
 797   internal_set(al, d, false);
 798 }
 799 
 800 void MacroAssembler::patchable_set(const AddressLiteral&amp; al, Register d) {
 801   internal_set(al, d, true);
 802 }
 803 
 804 void MacroAssembler::patchable_set(intptr_t value, Register d) {
 805   AddressLiteral al(value);
 806   internal_set(al, d, true);
 807 }
 808 
 809 
 810 void MacroAssembler::set64(jlong value, Register d, Register tmp) {
 811   assert_not_delayed();
 812   v9_dep();
 813 
 814   int hi = (int)(value &gt;&gt; 32);
 815   int lo = (int)(value &amp; ~0);
 816   int bits_33to2 = (int)((value &gt;&gt; 2) &amp; ~0);
 817   // (Matcher::isSimpleConstant64 knows about the following optimizations.)
 818   if (Assembler::is_simm13(lo) &amp;&amp; value == lo) {
 819     or3(G0, lo, d);
 820   } else if (hi == 0) {
 821     Assembler::sethi(lo, d);   // hardware version zero-extends to upper 32
 822     if (low10(lo) != 0)
 823       or3(d, low10(lo), d);
 824   }
 825   else if ((hi &gt;&gt; 2) == 0) {
 826     Assembler::sethi(bits_33to2, d);  // hardware version zero-extends to upper 32
 827     sllx(d, 2, d);
 828     if (low12(lo) != 0)
 829       or3(d, low12(lo), d);
 830   }
 831   else if (hi == -1) {
 832     Assembler::sethi(~lo, d);  // hardware version zero-extends to upper 32
 833     xor3(d, low10(lo) ^ ~low10(~0), d);
 834   }
 835   else if (lo == 0) {
 836     if (Assembler::is_simm13(hi)) {
 837       or3(G0, hi, d);
 838     } else {
 839       Assembler::sethi(hi, d);   // hardware version zero-extends to upper 32
 840       if (low10(hi) != 0)
 841         or3(d, low10(hi), d);
 842     }
 843     sllx(d, 32, d);
 844   }
 845   else {
 846     Assembler::sethi(hi, tmp);
 847     Assembler::sethi(lo,   d); // macro assembler version sign-extends
 848     if (low10(hi) != 0)
 849       or3 (tmp, low10(hi), tmp);
 850     if (low10(lo) != 0)
 851       or3 (  d, low10(lo),   d);
 852     sllx(tmp, 32, tmp);
 853     or3 (d, tmp, d);
 854   }
 855 }
 856 
 857 int MacroAssembler::insts_for_set64(jlong value) {
 858   v9_dep();
 859 
 860   int hi = (int) (value &gt;&gt; 32);
 861   int lo = (int) (value &amp; ~0);
 862   int count = 0;
 863 
 864   // (Matcher::isSimpleConstant64 knows about the following optimizations.)
 865   if (Assembler::is_simm13(lo) &amp;&amp; value == lo) {
 866     count++;
 867   } else if (hi == 0) {
 868     count++;
 869     if (low10(lo) != 0)
 870       count++;
 871   }
 872   else if (hi == -1) {
 873     count += 2;
 874   }
 875   else if (lo == 0) {
 876     if (Assembler::is_simm13(hi)) {
 877       count++;
 878     } else {
 879       count++;
 880       if (low10(hi) != 0)
 881         count++;
 882     }
 883     count++;
 884   }
 885   else {
 886     count += 2;
 887     if (low10(hi) != 0)
 888       count++;
 889     if (low10(lo) != 0)
 890       count++;
 891     count += 2;
 892   }
 893   return count;
 894 }
 895 
 896 // compute size in bytes of sparc frame, given
 897 // number of extraWords
 898 int MacroAssembler::total_frame_size_in_bytes(int extraWords) {
 899 
 900   int nWords = frame::memory_parameter_word_sp_offset;
 901 
 902   nWords += extraWords;
 903 
 904   if (nWords &amp; 1) ++nWords; // round up to double-word
 905 
 906   return nWords * BytesPerWord;
 907 }
 908 
 909 
 910 // save_frame: given number of &quot;extra&quot; words in frame,
 911 // issue approp. save instruction (p 200, v8 manual)
 912 
 913 void MacroAssembler::save_frame(int extraWords) {
 914   int delta = -total_frame_size_in_bytes(extraWords);
 915   if (is_simm13(delta)) {
 916     save(SP, delta, SP);
 917   } else {
 918     set(delta, G3_scratch);
 919     save(SP, G3_scratch, SP);
 920   }
 921 }
 922 
 923 
 924 void MacroAssembler::save_frame_c1(int size_in_bytes) {
 925   if (is_simm13(-size_in_bytes)) {
 926     save(SP, -size_in_bytes, SP);
 927   } else {
 928     set(-size_in_bytes, G3_scratch);
 929     save(SP, G3_scratch, SP);
 930   }
 931 }
 932 
 933 
 934 void MacroAssembler::save_frame_and_mov(int extraWords,
 935                                         Register s1, Register d1,
 936                                         Register s2, Register d2) {
 937   assert_not_delayed();
 938 
 939   // The trick here is to use precisely the same memory word
 940   // that trap handlers also use to save the register.
 941   // This word cannot be used for any other purpose, but
 942   // it works fine to save the register&#39;s value, whether or not
 943   // an interrupt flushes register windows at any given moment!
 944   Address s1_addr;
 945   if (s1-&gt;is_valid() &amp;&amp; (s1-&gt;is_in() || s1-&gt;is_local())) {
 946     s1_addr = s1-&gt;address_in_saved_window();
 947     st_ptr(s1, s1_addr);
 948   }
 949 
 950   Address s2_addr;
 951   if (s2-&gt;is_valid() &amp;&amp; (s2-&gt;is_in() || s2-&gt;is_local())) {
 952     s2_addr = s2-&gt;address_in_saved_window();
 953     st_ptr(s2, s2_addr);
 954   }
 955 
 956   save_frame(extraWords);
 957 
 958   if (s1_addr.base() == SP) {
 959     ld_ptr(s1_addr.after_save(), d1);
 960   } else if (s1-&gt;is_valid()) {
 961     mov(s1-&gt;after_save(), d1);
 962   }
 963 
 964   if (s2_addr.base() == SP) {
 965     ld_ptr(s2_addr.after_save(), d2);
 966   } else if (s2-&gt;is_valid()) {
 967     mov(s2-&gt;after_save(), d2);
 968   }
 969 }
 970 
 971 
 972 AddressLiteral MacroAssembler::allocate_metadata_address(Metadata* obj) {
 973   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
 974   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
 975   RelocationHolder rspec = metadata_Relocation::spec(index);
 976   return AddressLiteral((address)obj, rspec);
 977 }
 978 
 979 AddressLiteral MacroAssembler::constant_metadata_address(Metadata* obj) {
 980   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
 981   int index = oop_recorder()-&gt;find_index(obj);
 982   RelocationHolder rspec = metadata_Relocation::spec(index);
 983   return AddressLiteral((address)obj, rspec);
 984 }
 985 
 986 
 987 AddressLiteral MacroAssembler::constant_oop_address(jobject obj) {
 988 #ifdef ASSERT
 989   {
 990     ThreadInVMfromUnknown tiv;
 991     assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
<a name="3" id="anc3"></a><span class="line-modified"> 992     assert(Universe::heap()-&gt;is_in_reserved(JNIHandles::resolve(obj)), &quot;not an oop&quot;);</span>
 993   }
 994 #endif
 995   int oop_index = oop_recorder()-&gt;find_index(obj);
 996   return AddressLiteral(obj, oop_Relocation::spec(oop_index));
 997 }
 998 
 999 void  MacroAssembler::set_narrow_oop(jobject obj, Register d) {
1000   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1001   int oop_index = oop_recorder()-&gt;find_index(obj);
1002   RelocationHolder rspec = oop_Relocation::spec(oop_index);
1003 
1004   assert_not_delayed();
1005   // Relocation with special format (see relocInfo_sparc.hpp).
1006   relocate(rspec, 1);
1007   // Assembler::sethi(0x3fffff, d);
1008   emit_int32( op(branch_op) | rd(d) | op2(sethi_op2) | hi22(0x3fffff) );
1009   // Don&#39;t add relocation for &#39;add&#39;. Do patching during &#39;sethi&#39; processing.
1010   add(d, 0x3ff, d);
1011 
1012 }
1013 
1014 void  MacroAssembler::set_narrow_klass(Klass* k, Register d) {
1015   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1016   int klass_index = oop_recorder()-&gt;find_index(k);
1017   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
<a name="4" id="anc4"></a><span class="line-modified">1018   narrowOop encoded_k = Klass::encode_klass(k);</span>
1019 
1020   assert_not_delayed();
1021   // Relocation with special format (see relocInfo_sparc.hpp).
1022   relocate(rspec, 1);
1023   // Assembler::sethi(encoded_k, d);
1024   emit_int32( op(branch_op) | rd(d) | op2(sethi_op2) | hi22(encoded_k) );
1025   // Don&#39;t add relocation for &#39;add&#39;. Do patching during &#39;sethi&#39; processing.
1026   add(d, low10(encoded_k), d);
1027 
1028 }
1029 
1030 void MacroAssembler::align(int modulus) {
1031   while (offset() % modulus != 0) nop();
1032 }
1033 
1034 void RegistersForDebugging::print(outputStream* s) {
1035   FlagSetting fs(Debugging, true);
1036   int j;
1037   for (j = 0; j &lt; 8; ++j) {
1038     if (j != 6) { s-&gt;print(&quot;i%d = &quot;, j); os::print_location(s, i[j]); }
1039     else        { s-&gt;print( &quot;fp = &quot;   ); os::print_location(s, i[j]); }
1040   }
1041   s-&gt;cr();
1042 
1043   for (j = 0;  j &lt; 8;  ++j) {
1044     s-&gt;print(&quot;l%d = &quot;, j); os::print_location(s, l[j]);
1045   }
1046   s-&gt;cr();
1047 
1048   for (j = 0; j &lt; 8; ++j) {
1049     if (j != 6) { s-&gt;print(&quot;o%d = &quot;, j); os::print_location(s, o[j]); }
1050     else        { s-&gt;print( &quot;sp = &quot;   ); os::print_location(s, o[j]); }
1051   }
1052   s-&gt;cr();
1053 
1054   for (j = 0; j &lt; 8; ++j) {
1055     s-&gt;print(&quot;g%d = &quot;, j); os::print_location(s, g[j]);
1056   }
1057   s-&gt;cr();
1058 
1059   // print out floats with compression
1060   for (j = 0; j &lt; 32; ) {
1061     jfloat val = f[j];
1062     int last = j;
1063     for ( ;  last+1 &lt; 32;  ++last ) {
1064       char b1[1024], b2[1024];
1065       sprintf(b1, &quot;%f&quot;, val);
1066       sprintf(b2, &quot;%f&quot;, f[last+1]);
1067       if (strcmp(b1, b2))
1068         break;
1069     }
1070     s-&gt;print(&quot;f%d&quot;, j);
1071     if ( j != last )  s-&gt;print(&quot; - f%d&quot;, last);
1072     s-&gt;print(&quot; = %f&quot;, val);
1073     s-&gt;fill_to(25);
1074     s-&gt;print_cr(&quot; (0x%x)&quot;, *(int*)&amp;val);
1075     j = last + 1;
1076   }
1077   s-&gt;cr();
1078 
1079   // and doubles (evens only)
1080   for (j = 0; j &lt; 32; ) {
1081     jdouble val = d[j];
1082     int last = j;
1083     for ( ;  last+1 &lt; 32;  ++last ) {
1084       char b1[1024], b2[1024];
1085       sprintf(b1, &quot;%f&quot;, val);
1086       sprintf(b2, &quot;%f&quot;, d[last+1]);
1087       if (strcmp(b1, b2))
1088         break;
1089     }
1090     s-&gt;print(&quot;d%d&quot;, 2 * j);
1091     if ( j != last )  s-&gt;print(&quot; - d%d&quot;, last);
1092     s-&gt;print(&quot; = %f&quot;, val);
1093     s-&gt;fill_to(30);
1094     s-&gt;print(&quot;(0x%x)&quot;, *(int*)&amp;val);
1095     s-&gt;fill_to(42);
1096     s-&gt;print_cr(&quot;(0x%x)&quot;, *(1 + (int*)&amp;val));
1097     j = last + 1;
1098   }
1099   s-&gt;cr();
1100 }
1101 
1102 void RegistersForDebugging::save_registers(MacroAssembler* a) {
1103   a-&gt;sub(FP, align_up(sizeof(RegistersForDebugging), sizeof(jdouble)) - STACK_BIAS, O0);
1104   a-&gt;flushw();
1105   int i;
1106   for (i = 0; i &lt; 8; ++i) {
1107     a-&gt;ld_ptr(as_iRegister(i)-&gt;address_in_saved_window().after_save(), L1);  a-&gt;st_ptr( L1, O0, i_offset(i));
1108     a-&gt;ld_ptr(as_lRegister(i)-&gt;address_in_saved_window().after_save(), L1);  a-&gt;st_ptr( L1, O0, l_offset(i));
1109     a-&gt;st_ptr(as_oRegister(i)-&gt;after_save(), O0, o_offset(i));
1110     a-&gt;st_ptr(as_gRegister(i)-&gt;after_save(), O0, g_offset(i));
1111   }
1112   for (i = 0;  i &lt; 32; ++i) {
1113     a-&gt;stf(FloatRegisterImpl::S, as_FloatRegister(i), O0, f_offset(i));
1114   }
1115   for (i = 0; i &lt; 64; i += 2) {
1116     a-&gt;stf(FloatRegisterImpl::D, as_FloatRegister(i), O0, d_offset(i));
1117   }
1118 }
1119 
1120 void RegistersForDebugging::restore_registers(MacroAssembler* a, Register r) {
1121   for (int i = 1; i &lt; 8;  ++i) {
1122     a-&gt;ld_ptr(r, g_offset(i), as_gRegister(i));
1123   }
1124   for (int j = 0; j &lt; 32; ++j) {
1125     a-&gt;ldf(FloatRegisterImpl::S, O0, f_offset(j), as_FloatRegister(j));
1126   }
1127   for (int k = 0; k &lt; 64; k += 2) {
1128     a-&gt;ldf(FloatRegisterImpl::D, O0, d_offset(k), as_FloatRegister(k));
1129   }
1130 }
1131 
<a name="5" id="anc5"></a><span class="line-removed">1132 </span>
<span class="line-removed">1133 // pushes double TOS element of FPU stack on CPU stack; pops from FPU stack</span>
<span class="line-removed">1134 void MacroAssembler::push_fTOS() {</span>
<span class="line-removed">1135   // %%%%%% need to implement this</span>
<span class="line-removed">1136 }</span>
<span class="line-removed">1137 </span>
<span class="line-removed">1138 // pops double TOS element from CPU stack and pushes on FPU stack</span>
<span class="line-removed">1139 void MacroAssembler::pop_fTOS() {</span>
<span class="line-removed">1140   // %%%%%% need to implement this</span>
<span class="line-removed">1141 }</span>
<span class="line-removed">1142 </span>
<span class="line-removed">1143 void MacroAssembler::empty_FPU_stack() {</span>
<span class="line-removed">1144   // %%%%%% need to implement this</span>
<span class="line-removed">1145 }</span>
<span class="line-removed">1146 </span>
1147 void MacroAssembler::_verify_oop(Register reg, const char* msg, const char * file, int line) {
1148   // plausibility check for oops
1149   if (!VerifyOops) return;
1150 
1151   if (reg == G0)  return;       // always NULL, which is always an oop
1152 
1153   BLOCK_COMMENT(&quot;verify_oop {&quot;);
1154   char buffer[64];
1155 #ifdef COMPILER1
1156   if (CommentedAssembly) {
1157     snprintf(buffer, sizeof(buffer), &quot;verify_oop at %d&quot;, offset());
1158     block_comment(buffer);
1159   }
1160 #endif
1161 
1162   const char* real_msg = NULL;
1163   {
1164     ResourceMark rm;
1165     stringStream ss;
1166     ss.print(&quot;%s at offset %d (%s:%d)&quot;, msg, offset(), file, line);
1167     real_msg = code_string(ss.as_string());
1168   }
1169 
1170   // Call indirectly to solve generation ordering problem
1171   AddressLiteral a(StubRoutines::verify_oop_subroutine_entry_address());
1172 
1173   // Make some space on stack above the current register window.
1174   // Enough to hold 8 64-bit registers.
1175   add(SP,-8*8,SP);
1176 
1177   // Save some 64-bit registers; a normal &#39;save&#39; chops the heads off
1178   // of 64-bit longs in the 32-bit build.
1179   stx(O0,SP,frame::register_save_words*wordSize+STACK_BIAS+0*8);
1180   stx(O1,SP,frame::register_save_words*wordSize+STACK_BIAS+1*8);
1181   mov(reg,O0); // Move arg into O0; arg might be in O7 which is about to be crushed
1182   stx(O7,SP,frame::register_save_words*wordSize+STACK_BIAS+7*8);
1183 
1184   // Size of set() should stay the same
1185   patchable_set((intptr_t)real_msg, O1);
1186   // Load address to call to into O7
1187   load_ptr_contents(a, O7);
1188   // Register call to verify_oop_subroutine
1189   callr(O7, G0);
1190   delayed()-&gt;nop();
1191   // recover frame size
1192   add(SP, 8*8,SP);
1193   BLOCK_COMMENT(&quot;} verify_oop&quot;);
1194 }
1195 
1196 void MacroAssembler::_verify_oop_addr(Address addr, const char* msg, const char * file, int line) {
1197   // plausibility check for oops
1198   if (!VerifyOops) return;
1199 
1200   const char* real_msg = NULL;
1201   {
1202     ResourceMark rm;
1203     stringStream ss;
1204     ss.print(&quot;%s at SP+%d (%s:%d)&quot;, msg, addr.disp(), file, line);
1205     real_msg = code_string(ss.as_string());
1206   }
1207 
1208   // Call indirectly to solve generation ordering problem
1209   AddressLiteral a(StubRoutines::verify_oop_subroutine_entry_address());
1210 
1211   // Make some space on stack above the current register window.
1212   // Enough to hold 8 64-bit registers.
1213   add(SP,-8*8,SP);
1214 
1215   // Save some 64-bit registers; a normal &#39;save&#39; chops the heads off
1216   // of 64-bit longs in the 32-bit build.
1217   stx(O0,SP,frame::register_save_words*wordSize+STACK_BIAS+0*8);
1218   stx(O1,SP,frame::register_save_words*wordSize+STACK_BIAS+1*8);
1219   ld_ptr(addr.base(), addr.disp() + 8*8, O0); // Load arg into O0; arg might be in O7 which is about to be crushed
1220   stx(O7,SP,frame::register_save_words*wordSize+STACK_BIAS+7*8);
1221 
1222   // Size of set() should stay the same
1223   patchable_set((intptr_t)real_msg, O1);
1224   // Load address to call to into O7
1225   load_ptr_contents(a, O7);
1226   // Register call to verify_oop_subroutine
1227   callr(O7, G0);
1228   delayed()-&gt;nop();
1229   // recover frame size
1230   add(SP, 8*8,SP);
1231 }
1232 
1233 // side-door communication with signalHandler in os_solaris.cpp
1234 address MacroAssembler::_verify_oop_implicit_branch[3] = { NULL };
1235 
1236 // This macro is expanded just once; it creates shared code.  Contract:
1237 // receives an oop in O0.  Must restore O0 &amp; O7 from TLS.  Must not smash ANY
1238 // registers, including flags.  May not use a register &#39;save&#39;, as this blows
1239 // the high bits of the O-regs if they contain Long values.  Acts as a &#39;leaf&#39;
1240 // call.
1241 void MacroAssembler::verify_oop_subroutine() {
1242   // Leaf call; no frame.
1243   Label succeed, fail, null_or_fail;
1244 
1245   // O0 and O7 were saved already (O0 in O0&#39;s TLS home, O7 in O5&#39;s TLS home).
1246   // O0 is now the oop to be checked.  O7 is the return address.
1247   Register O0_obj = O0;
1248 
1249   // Save some more registers for temps.
1250   stx(O2,SP,frame::register_save_words*wordSize+STACK_BIAS+2*8);
1251   stx(O3,SP,frame::register_save_words*wordSize+STACK_BIAS+3*8);
1252   stx(O4,SP,frame::register_save_words*wordSize+STACK_BIAS+4*8);
1253   stx(O5,SP,frame::register_save_words*wordSize+STACK_BIAS+5*8);
1254 
1255   // Save flags
1256   Register O5_save_flags = O5;
1257   rdccr( O5_save_flags );
1258 
1259   { // count number of verifies
1260     Register O2_adr   = O2;
1261     Register O3_accum = O3;
1262     inc_counter(StubRoutines::verify_oop_count_addr(), O2_adr, O3_accum);
1263   }
1264 
1265   Register O2_mask = O2;
1266   Register O3_bits = O3;
1267   Register O4_temp = O4;
1268 
1269   // mark lower end of faulting range
1270   assert(_verify_oop_implicit_branch[0] == NULL, &quot;set once&quot;);
1271   _verify_oop_implicit_branch[0] = pc();
1272 
1273   // We can&#39;t check the mark oop because it could be in the process of
1274   // locking or unlocking while this is running.
1275   set(Universe::verify_oop_mask (), O2_mask);
1276   set(Universe::verify_oop_bits (), O3_bits);
1277 
1278   // assert((obj &amp; oop_mask) == oop_bits);
1279   and3(O0_obj, O2_mask, O4_temp);
1280   cmp_and_brx_short(O4_temp, O3_bits, notEqual, pn, null_or_fail);
1281 
1282   if ((NULL_WORD &amp; Universe::verify_oop_mask()) == Universe::verify_oop_bits()) {
1283     // the null_or_fail case is useless; must test for null separately
1284     br_null_short(O0_obj, pn, succeed);
1285   }
1286 
1287   // Check the Klass* of this object for being in the right area of memory.
1288   // Cannot do the load in the delay above slot in case O0 is null
1289   load_klass(O0_obj, O0_obj);
1290   // assert((klass != NULL)
1291   br_null_short(O0_obj, pn, fail);
1292 
1293   wrccr( O5_save_flags ); // Restore CCR&#39;s
1294 
1295   // mark upper end of faulting range
1296   _verify_oop_implicit_branch[1] = pc();
1297 
1298   //-----------------------
1299   // all tests pass
1300   bind(succeed);
1301 
1302   // Restore prior 64-bit registers
1303   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+0*8,O0);
1304   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+1*8,O1);
1305   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+2*8,O2);
1306   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+3*8,O3);
1307   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+4*8,O4);
1308   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+5*8,O5);
1309 
1310   retl();                       // Leaf return; restore prior O7 in delay slot
1311   delayed()-&gt;ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+7*8,O7);
1312 
1313   //-----------------------
1314   bind(null_or_fail);           // nulls are less common but OK
1315   br_null(O0_obj, false, pt, succeed);
1316   delayed()-&gt;wrccr( O5_save_flags ); // Restore CCR&#39;s
1317 
1318   //-----------------------
1319   // report failure:
1320   bind(fail);
1321   _verify_oop_implicit_branch[2] = pc();
1322 
1323   wrccr( O5_save_flags ); // Restore CCR&#39;s
1324 
1325   save_frame(align_up(sizeof(RegistersForDebugging) / BytesPerWord, 2));
1326 
1327   // stop_subroutine expects message pointer in I1.
1328   mov(I1, O1);
1329 
1330   // Restore prior 64-bit registers
1331   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+0*8,I0);
1332   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+1*8,I1);
1333   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+2*8,I2);
1334   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+3*8,I3);
1335   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+4*8,I4);
1336   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+5*8,I5);
1337 
1338   // factor long stop-sequence into subroutine to save space
1339   assert(StubRoutines::Sparc::stop_subroutine_entry_address(), &quot;hasn&#39;t been generated yet&quot;);
1340 
1341   // call indirectly to solve generation ordering problem
1342   AddressLiteral al(StubRoutines::Sparc::stop_subroutine_entry_address());
1343   load_ptr_contents(al, O5);
1344   jmpl(O5, 0, O7);
1345   delayed()-&gt;nop();
1346 }
1347 
1348 
1349 void MacroAssembler::stop(const char* msg) {
1350   // save frame first to get O7 for return address
1351   // add one word to size in case struct is odd number of words long
1352   // It must be doubleword-aligned for storing doubles into it.
1353 
1354     save_frame(align_up(sizeof(RegistersForDebugging) / BytesPerWord, 2));
1355 
1356     // stop_subroutine expects message pointer in I1.
1357     // Size of set() should stay the same
1358     patchable_set((intptr_t)msg, O1);
1359 
1360     // factor long stop-sequence into subroutine to save space
1361     assert(StubRoutines::Sparc::stop_subroutine_entry_address(), &quot;hasn&#39;t been generated yet&quot;);
1362 
1363     // call indirectly to solve generation ordering problem
1364     AddressLiteral a(StubRoutines::Sparc::stop_subroutine_entry_address());
1365     load_ptr_contents(a, O5);
1366     jmpl(O5, 0, O7);
1367     delayed()-&gt;nop();
1368 
1369     breakpoint_trap();   // make stop actually stop rather than writing
1370                          // unnoticeable results in the output files.
1371 
1372     // restore(); done in callee to save space!
1373 }
1374 
1375 
1376 void MacroAssembler::warn(const char* msg) {
1377   save_frame(align_up(sizeof(RegistersForDebugging) / BytesPerWord, 2));
1378   RegistersForDebugging::save_registers(this);
1379   mov(O0, L0);
1380   // Size of set() should stay the same
1381   patchable_set((intptr_t)msg, O0);
1382   call( CAST_FROM_FN_PTR(address, warning) );
1383   delayed()-&gt;nop();
1384 //  ret();
1385 //  delayed()-&gt;restore();
1386   RegistersForDebugging::restore_registers(this, L0);
1387   restore();
1388 }
1389 
1390 
1391 void MacroAssembler::untested(const char* what) {
1392   // We must be able to turn interactive prompting off
1393   // in order to run automated test scripts on the VM
1394   // Use the flag ShowMessageBoxOnError
1395 
1396   const char* b = NULL;
1397   {
1398     ResourceMark rm;
1399     stringStream ss;
1400     ss.print(&quot;untested: %s&quot;, what);
1401     b = code_string(ss.as_string());
1402   }
1403   if (ShowMessageBoxOnError) { STOP(b); }
1404   else                       { warn(b); }
1405 }
1406 
1407 
1408 void MacroAssembler::unimplemented(const char* what) {
1409   const char* buf = NULL;
1410   {
1411     ResourceMark rm;
1412     stringStream ss;
1413     ss.print(&quot;unimplemented: %s&quot;, what);
1414     buf = code_string(ss.as_string());
1415   }
1416   stop(buf);
1417 }
1418 
1419 
1420 void MacroAssembler::stop_subroutine() {
1421   RegistersForDebugging::save_registers(this);
1422 
1423   // for the sake of the debugger, stick a PC on the current frame
1424   // (this assumes that the caller has performed an extra &quot;save&quot;)
1425   mov(I7, L7);
1426   add(O7, -7 * BytesPerInt, I7);
1427 
1428   save_frame(); // one more save to free up another O7 register
1429   mov(I0, O1); // addr of reg save area
1430 
1431   // We expect pointer to message in I1. Caller must set it up in O1
1432   mov(I1, O0); // get msg
1433   call (CAST_FROM_FN_PTR(address, MacroAssembler::debug), relocInfo::runtime_call_type);
1434   delayed()-&gt;nop();
1435 
1436   restore();
1437 
1438   RegistersForDebugging::restore_registers(this, O0);
1439 
1440   save_frame(0);
1441   call(CAST_FROM_FN_PTR(address,breakpoint));
1442   delayed()-&gt;nop();
1443   restore();
1444 
1445   mov(L7, I7);
1446   retl();
1447   delayed()-&gt;restore(); // see stop above
1448 }
1449 
1450 
1451 void MacroAssembler::debug(char* msg, RegistersForDebugging* regs) {
1452   if ( ShowMessageBoxOnError ) {
1453     JavaThread* thread = JavaThread::current();
1454     JavaThreadState saved_state = thread-&gt;thread_state();
1455     thread-&gt;set_thread_state(_thread_in_vm);
1456       {
1457         // In order to get locks work, we need to fake a in_VM state
1458         ttyLocker ttyl;
1459         ::tty-&gt;print_cr(&quot;EXECUTION STOPPED: %s\n&quot;, msg);
1460         if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
1461         BytecodeCounter::print();
1462         }
1463         if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;))
1464           regs-&gt;print(::tty);
1465       }
1466     BREAKPOINT;
1467       ThreadStateTransition::transition(JavaThread::current(), _thread_in_vm, saved_state);
1468   }
1469   else {
1470      ::tty-&gt;print_cr(&quot;=============== DEBUG MESSAGE: %s ================\n&quot;, msg);
1471   }
1472   assert(false, &quot;DEBUG MESSAGE: %s&quot;, msg);
1473 }
1474 
1475 
1476 void MacroAssembler::calc_mem_param_words(Register Rparam_words, Register Rresult) {
1477   subcc( Rparam_words, Argument::n_register_parameters, Rresult); // how many mem words?
1478   Label no_extras;
1479   br( negative, true, pt, no_extras ); // if neg, clear reg
1480   delayed()-&gt;set(0, Rresult);          // annuled, so only if taken
1481   bind( no_extras );
1482 }
1483 
1484 
1485 void MacroAssembler::calc_frame_size(Register Rextra_words, Register Rresult) {
1486   add(Rextra_words, frame::memory_parameter_word_sp_offset, Rresult);
1487   bclr(1, Rresult);
1488   sll(Rresult, LogBytesPerWord, Rresult);  // Rresult has total frame bytes
1489 }
1490 
1491 
1492 void MacroAssembler::calc_frame_size_and_save(Register Rextra_words, Register Rresult) {
1493   calc_frame_size(Rextra_words, Rresult);
1494   neg(Rresult);
1495   save(SP, Rresult, SP);
1496 }
1497 
1498 
1499 // ---------------------------------------------------------
1500 Assembler::RCondition cond2rcond(Assembler::Condition c) {
1501   switch (c) {
1502     /*case zero: */
1503     case Assembler::equal:        return Assembler::rc_z;
1504     case Assembler::lessEqual:    return Assembler::rc_lez;
1505     case Assembler::less:         return Assembler::rc_lz;
1506     /*case notZero:*/
1507     case Assembler::notEqual:     return Assembler::rc_nz;
1508     case Assembler::greater:      return Assembler::rc_gz;
1509     case Assembler::greaterEqual: return Assembler::rc_gez;
1510   }
1511   ShouldNotReachHere();
1512   return Assembler::rc_z;
1513 }
1514 
1515 // compares (32 bit) register with zero and branches.  NOT FOR USE WITH 64-bit POINTERS
1516 void MacroAssembler::cmp_zero_and_br(Condition c, Register s1, Label&amp; L, bool a, Predict p) {
1517   tst(s1);
1518   br (c, a, p, L);
1519 }
1520 
1521 // Compares a pointer register with zero and branches on null.
1522 // Does a test &amp; branch on 32-bit systems and a register-branch on 64-bit.
1523 void MacroAssembler::br_null( Register s1, bool a, Predict p, Label&amp; L ) {
1524   assert_not_delayed();
1525   bpr( rc_z, a, p, s1, L );
1526 }
1527 
1528 void MacroAssembler::br_notnull( Register s1, bool a, Predict p, Label&amp; L ) {
1529   assert_not_delayed();
1530   bpr( rc_nz, a, p, s1, L );
1531 }
1532 
1533 // Compare registers and branch with nop in delay slot or cbcond without delay slot.
1534 
1535 // Compare integer (32 bit) values (icc only).
1536 void MacroAssembler::cmp_and_br_short(Register s1, Register s2, Condition c,
1537                                       Predict p, Label&amp; L) {
1538   assert_not_delayed();
1539   if (use_cbcond(L)) {
1540     Assembler::cbcond(c, icc, s1, s2, L);
1541   } else {
1542     cmp(s1, s2);
1543     br(c, false, p, L);
1544     delayed()-&gt;nop();
1545   }
1546 }
1547 
1548 // Compare integer (32 bit) values (icc only).
1549 void MacroAssembler::cmp_and_br_short(Register s1, int simm13a, Condition c,
1550                                       Predict p, Label&amp; L) {
1551   assert_not_delayed();
1552   if (is_simm(simm13a,5) &amp;&amp; use_cbcond(L)) {
1553     Assembler::cbcond(c, icc, s1, simm13a, L);
1554   } else {
1555     cmp(s1, simm13a);
1556     br(c, false, p, L);
1557     delayed()-&gt;nop();
1558   }
1559 }
1560 
1561 // Branch that tests xcc in LP64 and icc in !LP64
1562 void MacroAssembler::cmp_and_brx_short(Register s1, Register s2, Condition c,
1563                                        Predict p, Label&amp; L) {
1564   assert_not_delayed();
1565   if (use_cbcond(L)) {
1566     Assembler::cbcond(c, ptr_cc, s1, s2, L);
1567   } else {
1568     cmp(s1, s2);
1569     brx(c, false, p, L);
1570     delayed()-&gt;nop();
1571   }
1572 }
1573 
1574 // Branch that tests xcc in LP64 and icc in !LP64
1575 void MacroAssembler::cmp_and_brx_short(Register s1, int simm13a, Condition c,
1576                                        Predict p, Label&amp; L) {
1577   assert_not_delayed();
1578   if (is_simm(simm13a,5) &amp;&amp; use_cbcond(L)) {
1579     Assembler::cbcond(c, ptr_cc, s1, simm13a, L);
1580   } else {
1581     cmp(s1, simm13a);
1582     brx(c, false, p, L);
1583     delayed()-&gt;nop();
1584   }
1585 }
1586 
1587 // Short branch version for compares a pointer with zero.
1588 
1589 void MacroAssembler::br_null_short(Register s1, Predict p, Label&amp; L) {
1590   assert_not_delayed();
1591   if (use_cbcond(L)) {
1592     Assembler::cbcond(zero, ptr_cc, s1, 0, L);
1593   } else {
1594     br_null(s1, false, p, L);
1595     delayed()-&gt;nop();
1596   }
1597 }
1598 
1599 void MacroAssembler::br_notnull_short(Register s1, Predict p, Label&amp; L) {
1600   assert_not_delayed();
1601   if (use_cbcond(L)) {
1602     Assembler::cbcond(notZero, ptr_cc, s1, 0, L);
1603   } else {
1604     br_notnull(s1, false, p, L);
1605     delayed()-&gt;nop();
1606   }
1607 }
1608 
1609 // Unconditional short branch
1610 void MacroAssembler::ba_short(Label&amp; L) {
1611   assert_not_delayed();
1612   if (use_cbcond(L)) {
1613     Assembler::cbcond(equal, icc, G0, G0, L);
1614   } else {
1615     br(always, false, pt, L);
1616     delayed()-&gt;nop();
1617   }
1618 }
1619 
1620 // Branch if &#39;icc&#39; says zero or not (i.e. icc.z == 1|0).
1621 
1622 void MacroAssembler::br_icc_zero(bool iszero, Predict p, Label &amp;L) {
1623   assert_not_delayed();
1624   Condition cf = (iszero ? Assembler::zero : Assembler::notZero);
1625   br(cf, false, p, L);
1626   delayed()-&gt;nop();
1627 }
1628 
1629 // instruction sequences factored across compiler &amp; interpreter
1630 
1631 
1632 void MacroAssembler::lcmp( Register Ra_hi, Register Ra_low,
1633                            Register Rb_hi, Register Rb_low,
1634                            Register Rresult) {
1635 
1636   Label check_low_parts, done;
1637 
1638   cmp(Ra_hi, Rb_hi );  // compare hi parts
1639   br(equal, true, pt, check_low_parts);
1640   delayed()-&gt;cmp(Ra_low, Rb_low); // test low parts
1641 
1642   // And, with an unsigned comparison, it does not matter if the numbers
1643   // are negative or not.
1644   // E.g., -2 cmp -1: the low parts are 0xfffffffe and 0xffffffff.
1645   // The second one is bigger (unsignedly).
1646 
1647   // Other notes:  The first move in each triplet can be unconditional
1648   // (and therefore probably prefetchable).
1649   // And the equals case for the high part does not need testing,
1650   // since that triplet is reached only after finding the high halves differ.
1651 
1652   mov(-1, Rresult);
1653   ba(done);
1654   delayed()-&gt;movcc(greater, false, icc,  1, Rresult);
1655 
1656   bind(check_low_parts);
1657 
1658   mov(                               -1, Rresult);
1659   movcc(equal,           false, icc,  0, Rresult);
1660   movcc(greaterUnsigned, false, icc,  1, Rresult);
1661 
1662   bind(done);
1663 }
1664 
1665 void MacroAssembler::lneg( Register Rhi, Register Rlow ) {
1666   subcc(  G0, Rlow, Rlow );
1667   subc(   G0, Rhi,  Rhi  );
1668 }
1669 
1670 void MacroAssembler::lshl( Register Rin_high,  Register Rin_low,
1671                            Register Rcount,
1672                            Register Rout_high, Register Rout_low,
1673                            Register Rtemp ) {
1674 
1675 
1676   Register Ralt_count = Rtemp;
1677   Register Rxfer_bits = Rtemp;
1678 
1679   assert( Ralt_count != Rin_high
1680       &amp;&amp;  Ralt_count != Rin_low
1681       &amp;&amp;  Ralt_count != Rcount
1682       &amp;&amp;  Rxfer_bits != Rin_low
1683       &amp;&amp;  Rxfer_bits != Rin_high
1684       &amp;&amp;  Rxfer_bits != Rcount
1685       &amp;&amp;  Rxfer_bits != Rout_low
1686       &amp;&amp;  Rout_low   != Rin_high,
1687         &quot;register alias checks&quot;);
1688 
1689   Label big_shift, done;
1690 
1691   // This code can be optimized to use the 64 bit shifts in V9.
1692   // Here we use the 32 bit shifts.
1693 
1694   and3( Rcount, 0x3f, Rcount);     // take least significant 6 bits
1695   subcc(Rcount,   31, Ralt_count);
1696   br(greater, true, pn, big_shift);
1697   delayed()-&gt;dec(Ralt_count);
1698 
1699   // shift &lt; 32 bits, Ralt_count = Rcount-31
1700 
1701   // We get the transfer bits by shifting right by 32-count the low
1702   // register. This is done by shifting right by 31-count and then by one
1703   // more to take care of the special (rare) case where count is zero
1704   // (shifting by 32 would not work).
1705 
1706   neg(Ralt_count);
1707 
1708   // The order of the next two instructions is critical in the case where
1709   // Rin and Rout are the same and should not be reversed.
1710 
1711   srl(Rin_low, Ralt_count, Rxfer_bits); // shift right by 31-count
1712   if (Rcount != Rout_low) {
1713     sll(Rin_low, Rcount, Rout_low); // low half
1714   }
1715   sll(Rin_high, Rcount, Rout_high);
1716   if (Rcount == Rout_low) {
1717     sll(Rin_low, Rcount, Rout_low); // low half
1718   }
1719   srl(Rxfer_bits, 1, Rxfer_bits ); // shift right by one more
1720   ba(done);
1721   delayed()-&gt;or3(Rout_high, Rxfer_bits, Rout_high);   // new hi value: or in shifted old hi part and xfer from low
1722 
1723   // shift &gt;= 32 bits, Ralt_count = Rcount-32
1724   bind(big_shift);
1725   sll(Rin_low, Ralt_count, Rout_high  );
1726   clr(Rout_low);
1727 
1728   bind(done);
1729 }
1730 
1731 
1732 void MacroAssembler::lshr( Register Rin_high,  Register Rin_low,
1733                            Register Rcount,
1734                            Register Rout_high, Register Rout_low,
1735                            Register Rtemp ) {
1736 
1737   Register Ralt_count = Rtemp;
1738   Register Rxfer_bits = Rtemp;
1739 
1740   assert( Ralt_count != Rin_high
1741       &amp;&amp;  Ralt_count != Rin_low
1742       &amp;&amp;  Ralt_count != Rcount
1743       &amp;&amp;  Rxfer_bits != Rin_low
1744       &amp;&amp;  Rxfer_bits != Rin_high
1745       &amp;&amp;  Rxfer_bits != Rcount
1746       &amp;&amp;  Rxfer_bits != Rout_high
1747       &amp;&amp;  Rout_high  != Rin_low,
1748         &quot;register alias checks&quot;);
1749 
1750   Label big_shift, done;
1751 
1752   // This code can be optimized to use the 64 bit shifts in V9.
1753   // Here we use the 32 bit shifts.
1754 
1755   and3( Rcount, 0x3f, Rcount);     // take least significant 6 bits
1756   subcc(Rcount,   31, Ralt_count);
1757   br(greater, true, pn, big_shift);
1758   delayed()-&gt;dec(Ralt_count);
1759 
1760   // shift &lt; 32 bits, Ralt_count = Rcount-31
1761 
1762   // We get the transfer bits by shifting left by 32-count the high
1763   // register. This is done by shifting left by 31-count and then by one
1764   // more to take care of the special (rare) case where count is zero
1765   // (shifting by 32 would not work).
1766 
1767   neg(Ralt_count);
1768   if (Rcount != Rout_low) {
1769     srl(Rin_low, Rcount, Rout_low);
1770   }
1771 
1772   // The order of the next two instructions is critical in the case where
1773   // Rin and Rout are the same and should not be reversed.
1774 
1775   sll(Rin_high, Ralt_count, Rxfer_bits); // shift left by 31-count
1776   sra(Rin_high,     Rcount, Rout_high ); // high half
1777   sll(Rxfer_bits,        1, Rxfer_bits); // shift left by one more
1778   if (Rcount == Rout_low) {
1779     srl(Rin_low, Rcount, Rout_low);
1780   }
1781   ba(done);
1782   delayed()-&gt;or3(Rout_low, Rxfer_bits, Rout_low); // new low value: or shifted old low part and xfer from high
1783 
1784   // shift &gt;= 32 bits, Ralt_count = Rcount-32
1785   bind(big_shift);
1786 
1787   sra(Rin_high, Ralt_count, Rout_low);
1788   sra(Rin_high,         31, Rout_high); // sign into hi
1789 
1790   bind( done );
1791 }
1792 
1793 
1794 
1795 void MacroAssembler::lushr( Register Rin_high,  Register Rin_low,
1796                             Register Rcount,
1797                             Register Rout_high, Register Rout_low,
1798                             Register Rtemp ) {
1799 
1800   Register Ralt_count = Rtemp;
1801   Register Rxfer_bits = Rtemp;
1802 
1803   assert( Ralt_count != Rin_high
1804       &amp;&amp;  Ralt_count != Rin_low
1805       &amp;&amp;  Ralt_count != Rcount
1806       &amp;&amp;  Rxfer_bits != Rin_low
1807       &amp;&amp;  Rxfer_bits != Rin_high
1808       &amp;&amp;  Rxfer_bits != Rcount
1809       &amp;&amp;  Rxfer_bits != Rout_high
1810       &amp;&amp;  Rout_high  != Rin_low,
1811         &quot;register alias checks&quot;);
1812 
1813   Label big_shift, done;
1814 
1815   // This code can be optimized to use the 64 bit shifts in V9.
1816   // Here we use the 32 bit shifts.
1817 
1818   and3( Rcount, 0x3f, Rcount);     // take least significant 6 bits
1819   subcc(Rcount,   31, Ralt_count);
1820   br(greater, true, pn, big_shift);
1821   delayed()-&gt;dec(Ralt_count);
1822 
1823   // shift &lt; 32 bits, Ralt_count = Rcount-31
1824 
1825   // We get the transfer bits by shifting left by 32-count the high
1826   // register. This is done by shifting left by 31-count and then by one
1827   // more to take care of the special (rare) case where count is zero
1828   // (shifting by 32 would not work).
1829 
1830   neg(Ralt_count);
1831   if (Rcount != Rout_low) {
1832     srl(Rin_low, Rcount, Rout_low);
1833   }
1834 
1835   // The order of the next two instructions is critical in the case where
1836   // Rin and Rout are the same and should not be reversed.
1837 
1838   sll(Rin_high, Ralt_count, Rxfer_bits); // shift left by 31-count
1839   srl(Rin_high,     Rcount, Rout_high ); // high half
1840   sll(Rxfer_bits,        1, Rxfer_bits); // shift left by one more
1841   if (Rcount == Rout_low) {
1842     srl(Rin_low, Rcount, Rout_low);
1843   }
1844   ba(done);
1845   delayed()-&gt;or3(Rout_low, Rxfer_bits, Rout_low); // new low value: or shifted old low part and xfer from high
1846 
1847   // shift &gt;= 32 bits, Ralt_count = Rcount-32
1848   bind(big_shift);
1849 
1850   srl(Rin_high, Ralt_count, Rout_low);
1851   clr(Rout_high);
1852 
1853   bind( done );
1854 }
1855 
1856 void MacroAssembler::lcmp( Register Ra, Register Rb, Register Rresult) {
1857   cmp(Ra, Rb);
1858   mov(-1, Rresult);
1859   movcc(equal,   false, xcc,  0, Rresult);
1860   movcc(greater, false, xcc,  1, Rresult);
1861 }
1862 
1863 
1864 void MacroAssembler::load_sized_value(Address src, Register dst, size_t size_in_bytes, bool is_signed) {
1865   switch (size_in_bytes) {
1866   case  8:  ld_long(src, dst); break;
1867   case  4:  ld(     src, dst); break;
1868   case  2:  is_signed ? ldsh(src, dst) : lduh(src, dst); break;
1869   case  1:  is_signed ? ldsb(src, dst) : ldub(src, dst); break;
1870   default:  ShouldNotReachHere();
1871   }
1872 }
1873 
1874 void MacroAssembler::store_sized_value(Register src, Address dst, size_t size_in_bytes) {
1875   switch (size_in_bytes) {
1876   case  8:  st_long(src, dst); break;
1877   case  4:  st(     src, dst); break;
1878   case  2:  sth(    src, dst); break;
1879   case  1:  stb(    src, dst); break;
1880   default:  ShouldNotReachHere();
1881   }
1882 }
1883 
1884 
1885 void MacroAssembler::float_cmp( bool is_float, int unordered_result,
1886                                 FloatRegister Fa, FloatRegister Fb,
1887                                 Register Rresult) {
1888   if (is_float) {
1889     fcmp(FloatRegisterImpl::S, fcc0, Fa, Fb);
1890   } else {
1891     fcmp(FloatRegisterImpl::D, fcc0, Fa, Fb);
1892   }
1893 
1894   if (unordered_result == 1) {
1895     mov(                                    -1, Rresult);
1896     movcc(f_equal,              true, fcc0,  0, Rresult);
1897     movcc(f_unorderedOrGreater, true, fcc0,  1, Rresult);
1898   } else {
1899     mov(                                    -1, Rresult);
1900     movcc(f_equal,              true, fcc0,  0, Rresult);
1901     movcc(f_greater,            true, fcc0,  1, Rresult);
1902   }
1903 }
1904 
1905 
1906 void MacroAssembler::save_all_globals_into_locals() {
1907   mov(G1,L1);
1908   mov(G2,L2);
1909   mov(G3,L3);
1910   mov(G4,L4);
1911   mov(G5,L5);
1912   mov(G6,L6);
1913   mov(G7,L7);
1914 }
1915 
1916 void MacroAssembler::restore_globals_from_locals() {
1917   mov(L1,G1);
1918   mov(L2,G2);
1919   mov(L3,G3);
1920   mov(L4,G4);
1921   mov(L5,G5);
1922   mov(L6,G6);
1923   mov(L7,G7);
1924 }
1925 
1926 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
1927                                                       Register tmp,
1928                                                       int offset) {
1929   intptr_t value = *delayed_value_addr;
1930   if (value != 0)
1931     return RegisterOrConstant(value + offset);
1932 
1933   // load indirectly to solve generation ordering problem
1934   AddressLiteral a(delayed_value_addr);
1935   load_ptr_contents(a, tmp);
1936 
1937 #ifdef ASSERT
1938   tst(tmp);
1939   breakpoint_trap(zero, xcc);
1940 #endif
1941 
1942   if (offset != 0)
1943     add(tmp, offset, tmp);
1944 
1945   return RegisterOrConstant(tmp);
1946 }
1947 
1948 
1949 RegisterOrConstant MacroAssembler::regcon_andn_ptr(RegisterOrConstant s1, RegisterOrConstant s2, RegisterOrConstant d, Register temp) {
1950   assert(d.register_or_noreg() != G0, &quot;lost side effect&quot;);
1951   if ((s2.is_constant() &amp;&amp; s2.as_constant() == 0) ||
1952       (s2.is_register() &amp;&amp; s2.as_register() == G0)) {
1953     // Do nothing, just move value.
1954     if (s1.is_register()) {
1955       if (d.is_constant())  d = temp;
1956       mov(s1.as_register(), d.as_register());
1957       return d;
1958     } else {
1959       return s1;
1960     }
1961   }
1962 
1963   if (s1.is_register()) {
1964     assert_different_registers(s1.as_register(), temp);
1965     if (d.is_constant())  d = temp;
1966     andn(s1.as_register(), ensure_simm13_or_reg(s2, temp), d.as_register());
1967     return d;
1968   } else {
1969     if (s2.is_register()) {
1970       assert_different_registers(s2.as_register(), temp);
1971       if (d.is_constant())  d = temp;
1972       set(s1.as_constant(), temp);
1973       andn(temp, s2.as_register(), d.as_register());
1974       return d;
1975     } else {
1976       intptr_t res = s1.as_constant() &amp; ~s2.as_constant();
1977       return res;
1978     }
1979   }
1980 }
1981 
1982 RegisterOrConstant MacroAssembler::regcon_inc_ptr(RegisterOrConstant s1, RegisterOrConstant s2, RegisterOrConstant d, Register temp) {
1983   assert(d.register_or_noreg() != G0, &quot;lost side effect&quot;);
1984   if ((s2.is_constant() &amp;&amp; s2.as_constant() == 0) ||
1985       (s2.is_register() &amp;&amp; s2.as_register() == G0)) {
1986     // Do nothing, just move value.
1987     if (s1.is_register()) {
1988       if (d.is_constant())  d = temp;
1989       mov(s1.as_register(), d.as_register());
1990       return d;
1991     } else {
1992       return s1;
1993     }
1994   }
1995 
1996   if (s1.is_register()) {
1997     assert_different_registers(s1.as_register(), temp);
1998     if (d.is_constant())  d = temp;
1999     add(s1.as_register(), ensure_simm13_or_reg(s2, temp), d.as_register());
2000     return d;
2001   } else {
2002     if (s2.is_register()) {
2003       assert_different_registers(s2.as_register(), temp);
2004       if (d.is_constant())  d = temp;
2005       add(s2.as_register(), ensure_simm13_or_reg(s1, temp), d.as_register());
2006       return d;
2007     } else {
2008       intptr_t res = s1.as_constant() + s2.as_constant();
2009       return res;
2010     }
2011   }
2012 }
2013 
2014 RegisterOrConstant MacroAssembler::regcon_sll_ptr(RegisterOrConstant s1, RegisterOrConstant s2, RegisterOrConstant d, Register temp) {
2015   assert(d.register_or_noreg() != G0, &quot;lost side effect&quot;);
2016   if (!is_simm13(s2.constant_or_zero()))
2017     s2 = (s2.as_constant() &amp; 0xFF);
2018   if ((s2.is_constant() &amp;&amp; s2.as_constant() == 0) ||
2019       (s2.is_register() &amp;&amp; s2.as_register() == G0)) {
2020     // Do nothing, just move value.
2021     if (s1.is_register()) {
2022       if (d.is_constant())  d = temp;
2023       mov(s1.as_register(), d.as_register());
2024       return d;
2025     } else {
2026       return s1;
2027     }
2028   }
2029 
2030   if (s1.is_register()) {
2031     assert_different_registers(s1.as_register(), temp);
2032     if (d.is_constant())  d = temp;
2033     sll_ptr(s1.as_register(), ensure_simm13_or_reg(s2, temp), d.as_register());
2034     return d;
2035   } else {
2036     if (s2.is_register()) {
2037       assert_different_registers(s2.as_register(), temp);
2038       if (d.is_constant())  d = temp;
2039       set(s1.as_constant(), temp);
2040       sll_ptr(temp, s2.as_register(), d.as_register());
2041       return d;
2042     } else {
2043       intptr_t res = s1.as_constant() &lt;&lt; s2.as_constant();
2044       return res;
2045     }
2046   }
2047 }
2048 
2049 
2050 // Look up the method for a megamorphic invokeinterface call.
2051 // The target method is determined by &lt;intf_klass, itable_index&gt;.
2052 // The receiver klass is in recv_klass.
2053 // On success, the result will be in method_result, and execution falls through.
2054 // On failure, execution transfers to the given label.
2055 void MacroAssembler::lookup_interface_method(Register recv_klass,
2056                                              Register intf_klass,
2057                                              RegisterOrConstant itable_index,
2058                                              Register method_result,
2059                                              Register scan_temp,
2060                                              Register sethi_temp,
2061                                              Label&amp; L_no_such_interface,
2062                                              bool return_method) {
2063   assert_different_registers(recv_klass, intf_klass, method_result, scan_temp);
2064   assert(!return_method || itable_index.is_constant() || itable_index.as_register() == method_result,
2065          &quot;caller must use same register for non-constant itable index as for method&quot;);
2066 
2067   Label L_no_such_interface_restore;
2068   bool did_save = false;
2069   if (scan_temp == noreg || sethi_temp == noreg) {
2070     Register recv_2 = recv_klass-&gt;is_global() ? recv_klass : L0;
2071     Register intf_2 = intf_klass-&gt;is_global() ? intf_klass : L1;
2072     assert(method_result-&gt;is_global(), &quot;must be able to return value&quot;);
2073     scan_temp  = L2;
2074     sethi_temp = L3;
2075     save_frame_and_mov(0, recv_klass, recv_2, intf_klass, intf_2);
2076     recv_klass = recv_2;
2077     intf_klass = intf_2;
2078     did_save = true;
2079   }
2080 
2081   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
2082   int vtable_base = in_bytes(Klass::vtable_start_offset());
2083   int scan_step   = itableOffsetEntry::size() * wordSize;
2084   int vte_size    = vtableEntry::size_in_bytes();
2085 
2086   lduw(recv_klass, in_bytes(Klass::vtable_length_offset()), scan_temp);
2087   // %%% We should store the aligned, prescaled offset in the klassoop.
2088   // Then the next several instructions would fold away.
2089 
2090   int itb_offset = vtable_base;
2091   int itb_scale = exact_log2(vtableEntry::size_in_bytes());
2092   sll(scan_temp, itb_scale,  scan_temp);
2093   add(scan_temp, itb_offset, scan_temp);
2094   add(recv_klass, scan_temp, scan_temp);
2095 
2096   if (return_method) {
2097     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
2098     RegisterOrConstant itable_offset = itable_index;
2099     itable_offset = regcon_sll_ptr(itable_index, exact_log2(itableMethodEntry::size() * wordSize), itable_offset);
2100     itable_offset = regcon_inc_ptr(itable_offset, itableMethodEntry::method_offset_in_bytes(), itable_offset);
2101     add(recv_klass, ensure_simm13_or_reg(itable_offset, sethi_temp), recv_klass);
2102   }
2103 
2104   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
2105   //   if (scan-&gt;interface() == intf) {
2106   //     result = (klass + scan-&gt;offset() + itable_index);
2107   //   }
2108   // }
2109   Label L_search, L_found_method;
2110 
2111   for (int peel = 1; peel &gt;= 0; peel--) {
2112     // %%%% Could load both offset and interface in one ldx, if they were
2113     // in the opposite order.  This would save a load.
2114     ld_ptr(scan_temp, itableOffsetEntry::interface_offset_in_bytes(), method_result);
2115 
2116     // Check that this entry is non-null.  A null entry means that
2117     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
2118     // same as when the caller was compiled.
2119     bpr(Assembler::rc_z, false, Assembler::pn, method_result, did_save ? L_no_such_interface_restore : L_no_such_interface);
2120     delayed()-&gt;cmp(method_result, intf_klass);
2121 
2122     if (peel) {
2123       brx(Assembler::equal,    false, Assembler::pt, L_found_method);
2124     } else {
2125       brx(Assembler::notEqual, false, Assembler::pn, L_search);
2126       // (invert the test to fall through to found_method...)
2127     }
2128     delayed()-&gt;add(scan_temp, scan_step, scan_temp);
2129 
2130     if (!peel)  break;
2131 
2132     bind(L_search);
2133   }
2134 
2135   bind(L_found_method);
2136 
2137   if (return_method) {
2138     // Got a hit.
2139     int ito_offset = itableOffsetEntry::offset_offset_in_bytes();
2140     // scan_temp[-scan_step] points to the vtable offset we need
2141     ito_offset -= scan_step;
2142     lduw(scan_temp, ito_offset, scan_temp);
2143     ld_ptr(recv_klass, scan_temp, method_result);
2144   }
2145 
2146   if (did_save) {
2147     Label L_done;
2148     ba(L_done);
2149     delayed()-&gt;restore();
2150 
2151     bind(L_no_such_interface_restore);
2152     ba(L_no_such_interface);
2153     delayed()-&gt;restore();
2154 
2155     bind(L_done);
2156   }
2157 }
2158 
2159 
2160 // virtual method calling
2161 void MacroAssembler::lookup_virtual_method(Register recv_klass,
2162                                            RegisterOrConstant vtable_index,
2163                                            Register method_result) {
2164   assert_different_registers(recv_klass, method_result, vtable_index.register_or_noreg());
2165   Register sethi_temp = method_result;
2166   const int base = in_bytes(Klass::vtable_start_offset()) +
2167                    // method pointer offset within the vtable entry:
2168                    vtableEntry::method_offset_in_bytes();
2169   RegisterOrConstant vtable_offset = vtable_index;
2170   // Each of the following three lines potentially generates an instruction.
2171   // But the total number of address formation instructions will always be
2172   // at most two, and will often be zero.  In any case, it will be optimal.
2173   // If vtable_index is a register, we will have (sll_ptr N,x; inc_ptr B,x; ld_ptr k,x).
2174   // If vtable_index is a constant, we will have at most (set B+X&lt;&lt;N,t; ld_ptr k,t).
2175   vtable_offset = regcon_sll_ptr(vtable_index, exact_log2(vtableEntry::size_in_bytes()), vtable_offset);
2176   vtable_offset = regcon_inc_ptr(vtable_offset, base, vtable_offset, sethi_temp);
2177   Address vtable_entry_addr(recv_klass, ensure_simm13_or_reg(vtable_offset, sethi_temp));
2178   ld_ptr(vtable_entry_addr, method_result);
2179 }
2180 
2181 
2182 void MacroAssembler::check_klass_subtype(Register sub_klass,
2183                                          Register super_klass,
2184                                          Register temp_reg,
2185                                          Register temp2_reg,
2186                                          Label&amp; L_success) {
2187   Register sub_2 = sub_klass;
2188   Register sup_2 = super_klass;
2189   if (!sub_2-&gt;is_global())  sub_2 = L0;
2190   if (!sup_2-&gt;is_global())  sup_2 = L1;
2191   bool did_save = false;
2192   if (temp_reg == noreg || temp2_reg == noreg) {
2193     temp_reg = L2;
2194     temp2_reg = L3;
2195     save_frame_and_mov(0, sub_klass, sub_2, super_klass, sup_2);
2196     sub_klass = sub_2;
2197     super_klass = sup_2;
2198     did_save = true;
2199   }
2200   Label L_failure, L_pop_to_failure, L_pop_to_success;
2201   check_klass_subtype_fast_path(sub_klass, super_klass,
2202                                 temp_reg, temp2_reg,
2203                                 (did_save ? &amp;L_pop_to_success : &amp;L_success),
2204                                 (did_save ? &amp;L_pop_to_failure : &amp;L_failure), NULL);
2205 
2206   if (!did_save)
2207     save_frame_and_mov(0, sub_klass, sub_2, super_klass, sup_2);
2208   check_klass_subtype_slow_path(sub_2, sup_2,
2209                                 L2, L3, L4, L5,
2210                                 NULL, &amp;L_pop_to_failure);
2211 
2212   // on success:
2213   bind(L_pop_to_success);
2214   restore();
2215   ba_short(L_success);
2216 
2217   // on failure:
2218   bind(L_pop_to_failure);
2219   restore();
2220   bind(L_failure);
2221 }
2222 
2223 
2224 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
2225                                                    Register super_klass,
2226                                                    Register temp_reg,
2227                                                    Register temp2_reg,
2228                                                    Label* L_success,
2229                                                    Label* L_failure,
2230                                                    Label* L_slow_path,
2231                                         RegisterOrConstant super_check_offset) {
2232   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
2233   int sco_offset = in_bytes(Klass::super_check_offset_offset());
2234 
2235   bool must_load_sco  = (super_check_offset.constant_or_zero() == -1);
2236   bool need_slow_path = (must_load_sco ||
2237                          super_check_offset.constant_or_zero() == sco_offset);
2238 
2239   assert_different_registers(sub_klass, super_klass, temp_reg);
2240   if (super_check_offset.is_register()) {
2241     assert_different_registers(sub_klass, super_klass, temp_reg,
2242                                super_check_offset.as_register());
2243   } else if (must_load_sco) {
2244     assert(temp2_reg != noreg, &quot;supply either a temp or a register offset&quot;);
2245   }
2246 
2247   Label L_fallthrough;
2248   int label_nulls = 0;
2249   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
2250   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
2251   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
2252   assert(label_nulls &lt;= 1 ||
2253          (L_slow_path == &amp;L_fallthrough &amp;&amp; label_nulls &lt;= 2 &amp;&amp; !need_slow_path),
2254          &quot;at most one NULL in the batch, usually&quot;);
2255 
2256   // If the pointers are equal, we are done (e.g., String[] elements).
2257   // This self-check enables sharing of secondary supertype arrays among
2258   // non-primary types such as array-of-interface.  Otherwise, each such
2259   // type would need its own customized SSA.
2260   // We move this check to the front of the fast path because many
2261   // type checks are in fact trivially successful in this manner,
2262   // so we get a nicely predicted branch right at the start of the check.
2263   cmp(super_klass, sub_klass);
2264   brx(Assembler::equal, false, Assembler::pn, *L_success);
2265   delayed()-&gt;nop();
2266 
2267   // Check the supertype display:
2268   if (must_load_sco) {
2269     // The super check offset is always positive...
2270     lduw(super_klass, sco_offset, temp2_reg);
2271     super_check_offset = RegisterOrConstant(temp2_reg);
2272     // super_check_offset is register.
2273     assert_different_registers(sub_klass, super_klass, temp_reg, super_check_offset.as_register());
2274   }
2275   ld_ptr(sub_klass, super_check_offset, temp_reg);
2276   cmp(super_klass, temp_reg);
2277 
2278   // This check has worked decisively for primary supers.
2279   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
2280   // (Secondary supers are interfaces and very deeply nested subtypes.)
2281   // This works in the same check above because of a tricky aliasing
2282   // between the super_cache and the primary super display elements.
2283   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
2284   // Note that the cache is updated below if it does not help us find
2285   // what we need immediately.
2286   // So if it was a primary super, we can just fail immediately.
2287   // Otherwise, it&#39;s the slow path for us (no success at this point).
2288 
2289   // Hacked ba(), which may only be used just before L_fallthrough.
2290 #define FINAL_JUMP(label)            \
2291   if (&amp;(label) != &amp;L_fallthrough) {  \
2292     ba(label);  delayed()-&gt;nop();    \
2293   }
2294 
2295   if (super_check_offset.is_register()) {
2296     brx(Assembler::equal, false, Assembler::pn, *L_success);
2297     delayed()-&gt;cmp(super_check_offset.as_register(), sc_offset);
2298 
2299     if (L_failure == &amp;L_fallthrough) {
2300       brx(Assembler::equal, false, Assembler::pt, *L_slow_path);
2301       delayed()-&gt;nop();
2302     } else {
2303       brx(Assembler::notEqual, false, Assembler::pn, *L_failure);
2304       delayed()-&gt;nop();
2305       FINAL_JUMP(*L_slow_path);
2306     }
2307   } else if (super_check_offset.as_constant() == sc_offset) {
2308     // Need a slow path; fast failure is impossible.
2309     if (L_slow_path == &amp;L_fallthrough) {
2310       brx(Assembler::equal, false, Assembler::pt, *L_success);
2311       delayed()-&gt;nop();
2312     } else {
2313       brx(Assembler::notEqual, false, Assembler::pn, *L_slow_path);
2314       delayed()-&gt;nop();
2315       FINAL_JUMP(*L_success);
2316     }
2317   } else {
2318     // No slow path; it&#39;s a fast decision.
2319     if (L_failure == &amp;L_fallthrough) {
2320       brx(Assembler::equal, false, Assembler::pt, *L_success);
2321       delayed()-&gt;nop();
2322     } else {
2323       brx(Assembler::notEqual, false, Assembler::pn, *L_failure);
2324       delayed()-&gt;nop();
2325       FINAL_JUMP(*L_success);
2326     }
2327   }
2328 
2329   bind(L_fallthrough);
2330 
2331 #undef FINAL_JUMP
2332 }
2333 
2334 
2335 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
2336                                                    Register super_klass,
2337                                                    Register count_temp,
2338                                                    Register scan_temp,
2339                                                    Register scratch_reg,
2340                                                    Register coop_reg,
2341                                                    Label* L_success,
2342                                                    Label* L_failure) {
2343   assert_different_registers(sub_klass, super_klass,
2344                              count_temp, scan_temp, scratch_reg, coop_reg);
2345 
2346   Label L_fallthrough, L_loop;
2347   int label_nulls = 0;
2348   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
2349   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
2350   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
2351 
2352   // a couple of useful fields in sub_klass:
2353   int ss_offset = in_bytes(Klass::secondary_supers_offset());
2354   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
2355 
2356   // Do a linear scan of the secondary super-klass chain.
2357   // This code is rarely used, so simplicity is a virtue here.
2358 
2359 #ifndef PRODUCT
2360   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
2361   inc_counter((address) pst_counter, count_temp, scan_temp);
2362 #endif
2363 
2364   // We will consult the secondary-super array.
2365   ld_ptr(sub_klass, ss_offset, scan_temp);
2366 
2367   Register search_key = super_klass;
2368 
2369   // Load the array length.  (Positive movl does right thing on LP64.)
2370   lduw(scan_temp, Array&lt;Klass*&gt;::length_offset_in_bytes(), count_temp);
2371 
2372   // Check for empty secondary super list
2373   tst(count_temp);
2374 
2375   // In the array of super classes elements are pointer sized.
2376   int element_size = wordSize;
2377 
2378   // Top of search loop
2379   bind(L_loop);
2380   br(Assembler::equal, false, Assembler::pn, *L_failure);
2381   delayed()-&gt;add(scan_temp, element_size, scan_temp);
2382 
2383   // Skip the array header in all array accesses.
2384   int elem_offset = Array&lt;Klass*&gt;::base_offset_in_bytes();
2385   elem_offset -= element_size;   // the scan pointer was pre-incremented also
2386 
2387   // Load next super to check
2388     ld_ptr( scan_temp, elem_offset, scratch_reg );
2389 
2390   // Look for Rsuper_klass on Rsub_klass&#39;s secondary super-class-overflow list
2391   cmp(scratch_reg, search_key);
2392 
2393   // A miss means we are NOT a subtype and need to keep looping
2394   brx(Assembler::notEqual, false, Assembler::pn, L_loop);
2395   delayed()-&gt;deccc(count_temp); // decrement trip counter in delay slot
2396 
2397   // Success.  Cache the super we found and proceed in triumph.
2398   st_ptr(super_klass, sub_klass, sc_offset);
2399 
2400   if (L_success != &amp;L_fallthrough) {
2401     ba(*L_success);
2402     delayed()-&gt;nop();
2403   }
2404 
2405   bind(L_fallthrough);
2406 }
2407 
2408 
2409 RegisterOrConstant MacroAssembler::argument_offset(RegisterOrConstant arg_slot,
2410                                                    Register temp_reg,
2411                                                    int extra_slot_offset) {
2412   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
2413   int stackElementSize = Interpreter::stackElementSize;
2414   int offset = extra_slot_offset * stackElementSize;
2415   if (arg_slot.is_constant()) {
2416     offset += arg_slot.as_constant() * stackElementSize;
2417     return offset;
2418   } else {
2419     assert(temp_reg != noreg, &quot;must specify&quot;);
2420     sll_ptr(arg_slot.as_register(), exact_log2(stackElementSize), temp_reg);
2421     if (offset != 0)
2422       add(temp_reg, offset, temp_reg);
2423     return temp_reg;
2424   }
2425 }
2426 
2427 
2428 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
2429                                          Register temp_reg,
2430                                          int extra_slot_offset) {
2431   return Address(Gargs, argument_offset(arg_slot, temp_reg, extra_slot_offset));
2432 }
2433 
2434 
2435 void MacroAssembler::biased_locking_enter(Register obj_reg, Register mark_reg,
2436                                           Register temp_reg,
2437                                           Label&amp; done, Label* slow_case,
2438                                           BiasedLockingCounters* counters) {
2439   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
2440 
2441   if (PrintBiasedLockingStatistics) {
2442     assert_different_registers(obj_reg, mark_reg, temp_reg, O7);
2443     if (counters == NULL)
2444       counters = BiasedLocking::counters();
2445   }
2446 
2447   Label cas_label;
2448 
2449   // Biased locking
2450   // See whether the lock is currently biased toward our thread and
2451   // whether the epoch is still valid
2452   // Note that the runtime guarantees sufficient alignment of JavaThread
2453   // pointers to allow age to be placed into low bits
<a name="6" id="anc6"></a><span class="line-modified">2454   assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);</span>
<span class="line-modified">2455   and3(mark_reg, markOopDesc::biased_lock_mask_in_place, temp_reg);</span>
<span class="line-modified">2456   cmp_and_brx_short(temp_reg, markOopDesc::biased_lock_pattern, Assembler::notEqual, Assembler::pn, cas_label);</span>
2457 
2458   load_klass(obj_reg, temp_reg);
2459   ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
2460   or3(G2_thread, temp_reg, temp_reg);
2461   xor3(mark_reg, temp_reg, temp_reg);
<a name="7" id="anc7"></a><span class="line-modified">2462   andcc(temp_reg, ~((int) markOopDesc::age_mask_in_place), temp_reg);</span>
2463   if (counters != NULL) {
2464     cond_inc(Assembler::equal, (address) counters-&gt;biased_lock_entry_count_addr(), mark_reg, temp_reg);
2465     // Reload mark_reg as we may need it later
2466     ld_ptr(Address(obj_reg, oopDesc::mark_offset_in_bytes()), mark_reg);
2467   }
2468   brx(Assembler::equal, true, Assembler::pt, done);
2469   delayed()-&gt;nop();
2470 
2471   Label try_revoke_bias;
2472   Label try_rebias;
2473   Address mark_addr = Address(obj_reg, oopDesc::mark_offset_in_bytes());
2474   assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
2475 
2476   // At this point we know that the header has the bias pattern and
2477   // that we are not the bias owner in the current epoch. We need to
2478   // figure out more details about the state of the header in order to
2479   // know what operations can be legally performed on the object&#39;s
2480   // header.
2481 
2482   // If the low three bits in the xor result aren&#39;t clear, that means
2483   // the prototype header is no longer biased and we have to revoke
2484   // the bias on this object.
<a name="8" id="anc8"></a><span class="line-modified">2485   btst(markOopDesc::biased_lock_mask_in_place, temp_reg);</span>
2486   brx(Assembler::notZero, false, Assembler::pn, try_revoke_bias);
2487 
2488   // Biasing is still enabled for this data type. See whether the
2489   // epoch of the current bias is still valid, meaning that the epoch
2490   // bits of the mark word are equal to the epoch bits of the
2491   // prototype header. (Note that the prototype header&#39;s epoch bits
2492   // only change at a safepoint.) If not, attempt to rebias the object
2493   // toward the current thread. Note that we must be absolutely sure
2494   // that the current epoch is invalid in order to do this because
2495   // otherwise the manipulations it performs on the mark word are
2496   // illegal.
<a name="9" id="anc9"></a><span class="line-modified">2497   delayed()-&gt;btst(markOopDesc::epoch_mask_in_place, temp_reg);</span>
2498   brx(Assembler::notZero, false, Assembler::pn, try_rebias);
2499 
2500   // The epoch of the current bias is still valid but we know nothing
2501   // about the owner; it might be set or it might be clear. Try to
2502   // acquire the bias of the object using an atomic operation. If this
2503   // fails we will go in to the runtime to revoke the object&#39;s bias.
2504   // Note that we first construct the presumed unbiased header so we
2505   // don&#39;t accidentally blow away another thread&#39;s valid bias.
2506   delayed()-&gt;and3(mark_reg,
<a name="10" id="anc10"></a><span class="line-modified">2507                   markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place,</span>
2508                   mark_reg);
2509   or3(G2_thread, mark_reg, temp_reg);
2510   cas_ptr(mark_addr.base(), mark_reg, temp_reg);
2511   // If the biasing toward our thread failed, this means that
2512   // another thread succeeded in biasing it toward itself and we
2513   // need to revoke that bias. The revocation will occur in the
2514   // interpreter runtime in the slow case.
2515   cmp(mark_reg, temp_reg);
2516   if (counters != NULL) {
2517     cond_inc(Assembler::zero, (address) counters-&gt;anonymously_biased_lock_entry_count_addr(), mark_reg, temp_reg);
2518   }
2519   if (slow_case != NULL) {
2520     brx(Assembler::notEqual, true, Assembler::pn, *slow_case);
2521     delayed()-&gt;nop();
2522   }
2523   ba_short(done);
2524 
2525   bind(try_rebias);
2526   // At this point we know the epoch has expired, meaning that the
2527   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
2528   // circumstances _only_, we are allowed to use the current header&#39;s
2529   // value as the comparison value when doing the cas to acquire the
2530   // bias in the current epoch. In other words, we allow transfer of
2531   // the bias from one thread to another directly in this situation.
2532   //
2533   // FIXME: due to a lack of registers we currently blow away the age
2534   // bits in this situation. Should attempt to preserve them.
2535   load_klass(obj_reg, temp_reg);
2536   ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
2537   or3(G2_thread, temp_reg, temp_reg);
2538   cas_ptr(mark_addr.base(), mark_reg, temp_reg);
2539   // If the biasing toward our thread failed, this means that
2540   // another thread succeeded in biasing it toward itself and we
2541   // need to revoke that bias. The revocation will occur in the
2542   // interpreter runtime in the slow case.
2543   cmp(mark_reg, temp_reg);
2544   if (counters != NULL) {
2545     cond_inc(Assembler::zero, (address) counters-&gt;rebiased_lock_entry_count_addr(), mark_reg, temp_reg);
2546   }
2547   if (slow_case != NULL) {
2548     brx(Assembler::notEqual, true, Assembler::pn, *slow_case);
2549     delayed()-&gt;nop();
2550   }
2551   ba_short(done);
2552 
2553   bind(try_revoke_bias);
2554   // The prototype mark in the klass doesn&#39;t have the bias bit set any
2555   // more, indicating that objects of this data type are not supposed
2556   // to be biased any more. We are going to try to reset the mark of
2557   // this object to the prototype value and fall through to the
2558   // CAS-based locking scheme. Note that if our CAS fails, it means
2559   // that another thread raced us for the privilege of revoking the
2560   // bias of this particular object, so it&#39;s okay to continue in the
2561   // normal locking code.
2562   //
2563   // FIXME: due to a lack of registers we currently blow away the age
2564   // bits in this situation. Should attempt to preserve them.
2565   load_klass(obj_reg, temp_reg);
2566   ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
2567   cas_ptr(mark_addr.base(), mark_reg, temp_reg);
2568   // Fall through to the normal CAS-based lock, because no matter what
2569   // the result of the above CAS, some thread must have succeeded in
2570   // removing the bias bit from the object&#39;s header.
2571   if (counters != NULL) {
2572     cmp(mark_reg, temp_reg);
2573     cond_inc(Assembler::zero, (address) counters-&gt;revoked_lock_entry_count_addr(), mark_reg, temp_reg);
2574   }
2575 
2576   bind(cas_label);
2577 }
2578 
2579 void MacroAssembler::biased_locking_exit (Address mark_addr, Register temp_reg, Label&amp; done,
2580                                           bool allow_delay_slot_filling) {
2581   // Check for biased locking unlock case, which is a no-op
2582   // Note: we do not have to check the thread ID for two reasons.
2583   // First, the interpreter checks for IllegalMonitorStateException at
2584   // a higher level. Second, if the bias was revoked while we held the
2585   // lock, the object could not be rebiased toward another thread, so
2586   // the bias bit would be clear.
2587   ld_ptr(mark_addr, temp_reg);
<a name="11" id="anc11"></a><span class="line-modified">2588   and3(temp_reg, markOopDesc::biased_lock_mask_in_place, temp_reg);</span>
<span class="line-modified">2589   cmp(temp_reg, markOopDesc::biased_lock_pattern);</span>
2590   brx(Assembler::equal, allow_delay_slot_filling, Assembler::pt, done);
2591   delayed();
2592   if (!allow_delay_slot_filling) {
2593     nop();
2594   }
2595 }
2596 
2597 
2598 // compiler_lock_object() and compiler_unlock_object() are direct transliterations
2599 // of i486.ad fast_lock() and fast_unlock().  See those methods for detailed comments.
2600 // The code could be tightened up considerably.
2601 //
2602 // box-&gt;dhw disposition - post-conditions at DONE_LABEL.
2603 // -   Successful inflated lock:  box-&gt;dhw != 0.
2604 //     Any non-zero value suffices.
<a name="12" id="anc12"></a><span class="line-modified">2605 //     Consider G2_thread, rsp, boxReg, or markOopDesc::unused_mark()</span>
2606 // -   Successful Stack-lock: box-&gt;dhw == mark.
2607 //     box-&gt;dhw must contain the displaced mark word value
2608 // -   Failure -- icc.ZFlag == 0 and box-&gt;dhw is undefined.
<a name="13" id="anc13"></a><span class="line-modified">2609 //     The slow-path fast_enter() and slow_enter() operators</span>
<span class="line-modified">2610 //     are responsible for setting box-&gt;dhw = NonZero (typically markOopDesc::unused_mark()).</span>
2611 // -   Biased: box-&gt;dhw is undefined
2612 //
2613 // SPARC refworkload performance - specifically jetstream and scimark - are
2614 // extremely sensitive to the size of the code emitted by compiler_lock_object
2615 // and compiler_unlock_object.  Critically, the key factor is code size, not path
2616 // length.  (Simply experiments to pad CLO with unexecuted NOPs demonstrte the
2617 // effect).
2618 
2619 
2620 void MacroAssembler::compiler_lock_object(Register Roop, Register Rmark,
2621                                           Register Rbox, Register Rscratch,
2622                                           BiasedLockingCounters* counters,
2623                                           bool try_bias) {
2624    Address mark_addr(Roop, oopDesc::mark_offset_in_bytes());
2625 
2626    verify_oop(Roop);
2627    Label done ;
2628 
2629    if (counters != NULL) {
2630      inc_counter((address) counters-&gt;total_entry_count_addr(), Rmark, Rscratch);
2631    }
2632 
2633    // Aggressively avoid the Store-before-CAS penalty
2634    // Defer the store into box-&gt;dhw until after the CAS
2635    Label IsInflated, Recursive ;
2636 
2637 // Anticipate CAS -- Avoid RTS-&gt;RTO upgrade
2638 // prefetch (mark_addr, Assembler::severalWritesAndPossiblyReads);
2639 
2640    ld_ptr(mark_addr, Rmark);           // fetch obj-&gt;mark
2641    // Triage: biased, stack-locked, neutral, inflated
2642 
2643    if (try_bias) {
2644      biased_locking_enter(Roop, Rmark, Rscratch, done, NULL, counters);
2645      // Invariant: if control reaches this point in the emitted stream
2646      // then Rmark has not been modified.
2647    }
2648    andcc(Rmark, 2, G0);
2649    brx(Assembler::notZero, false, Assembler::pn, IsInflated);
2650    delayed()-&gt;                         // Beware - dangling delay-slot
2651 
2652    // Try stack-lock acquisition.
2653    // Transiently install BUSY (0) encoding in the mark word.
2654    // if the CAS of 0 into the mark was successful then we execute:
2655    //   ST box-&gt;dhw  = mark   -- save fetched mark in on-stack basiclock box
2656    //   ST obj-&gt;mark = box    -- overwrite transient 0 value
2657    // This presumes TSO, of course.
2658 
2659    mov(0, Rscratch);
<a name="14" id="anc14"></a><span class="line-modified">2660    or3(Rmark, markOopDesc::unlocked_value, Rmark);</span>
2661    assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
2662    cas_ptr(mark_addr.base(), Rmark, Rscratch);
2663 // prefetch (mark_addr, Assembler::severalWritesAndPossiblyReads);
2664    cmp(Rscratch, Rmark);
2665    brx(Assembler::notZero, false, Assembler::pn, Recursive);
2666    delayed()-&gt;st_ptr(Rmark, Rbox, BasicLock::displaced_header_offset_in_bytes());
2667    if (counters != NULL) {
2668      cond_inc(Assembler::equal, (address) counters-&gt;fast_path_entry_count_addr(), Rmark, Rscratch);
2669    }
2670    ba(done);
2671    delayed()-&gt;st_ptr(Rbox, mark_addr);
2672 
2673    bind(Recursive);
2674    // Stack-lock attempt failed - check for recursive stack-lock.
2675    // Tests show that we can remove the recursive case with no impact
2676    // on refworkload 0.83.  If we need to reduce the size of the code
2677    // emitted by compiler_lock_object() the recursive case is perfect
2678    // candidate.
2679    //
2680    // A more extreme idea is to always inflate on stack-lock recursion.
2681    // This lets us eliminate the recursive checks in compiler_lock_object
2682    // and compiler_unlock_object and the (box-&gt;dhw == 0) encoding.
2683    // A brief experiment - requiring changes to synchronizer.cpp, interpreter,
2684    // and showed a performance *increase*.  In the same experiment I eliminated
2685    // the fast-path stack-lock code from the interpreter and always passed
2686    // control to the &quot;slow&quot; operators in synchronizer.cpp.
2687 
2688    // RScratch contains the fetched obj-&gt;mark value from the failed CAS.
2689    sub(Rscratch, STACK_BIAS, Rscratch);
2690    sub(Rscratch, SP, Rscratch);
2691    assert(os::vm_page_size() &gt; 0xfff, &quot;page size too small - change the constant&quot;);
2692    andcc(Rscratch, 0xfffff003, Rscratch);
2693    if (counters != NULL) {
2694      // Accounting needs the Rscratch register
2695      st_ptr(Rscratch, Rbox, BasicLock::displaced_header_offset_in_bytes());
2696      cond_inc(Assembler::equal, (address) counters-&gt;fast_path_entry_count_addr(), Rmark, Rscratch);
2697      ba_short(done);
2698    } else {
2699      ba(done);
2700      delayed()-&gt;st_ptr(Rscratch, Rbox, BasicLock::displaced_header_offset_in_bytes());
2701    }
2702 
2703    bind   (IsInflated);
2704 
2705    // Try to CAS m-&gt;owner from null to Self
2706    // Invariant: if we acquire the lock then _recursions should be 0.
2707    add(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), Rmark);
2708    mov(G2_thread, Rscratch);
2709    cas_ptr(Rmark, G0, Rscratch);
2710    andcc(Rscratch, Rscratch, G0);             // set ICCs for done: icc.zf iff success
2711    // set icc.zf : 1=success 0=failure
2712    // ST box-&gt;displaced_header = NonZero.
2713    // Any non-zero value suffices:
<a name="15" id="anc15"></a><span class="line-modified">2714    //    markOopDesc::unused_mark(), G2_thread, RBox, RScratch, rsp, etc.</span>
2715    st_ptr(Rbox, Rbox, BasicLock::displaced_header_offset_in_bytes());
2716    // Intentional fall-through into done
2717 
2718    bind   (done);
2719 }
2720 
2721 void MacroAssembler::compiler_unlock_object(Register Roop, Register Rmark,
2722                                             Register Rbox, Register Rscratch,
2723                                             bool try_bias) {
2724    Address mark_addr(Roop, oopDesc::mark_offset_in_bytes());
2725 
2726    Label done ;
2727 
2728    // Beware ... If the aggregate size of the code emitted by CLO and CUO is
2729    // is too large performance rolls abruptly off a cliff.
2730    // This could be related to inlining policies, code cache management, or
2731    // I$ effects.
2732    Label LStacked ;
2733 
2734    if (try_bias) {
2735       // TODO: eliminate redundant LDs of obj-&gt;mark
2736       biased_locking_exit(mark_addr, Rscratch, done);
2737    }
2738 
2739    ld_ptr(Roop, oopDesc::mark_offset_in_bytes(), Rmark);
2740    ld_ptr(Rbox, BasicLock::displaced_header_offset_in_bytes(), Rscratch);
2741    andcc(Rscratch, Rscratch, G0);
2742    brx(Assembler::zero, false, Assembler::pn, done);
2743    delayed()-&gt;nop();      // consider: relocate fetch of mark, above, into this DS
2744    andcc(Rmark, 2, G0);
2745    brx(Assembler::zero, false, Assembler::pt, LStacked);
2746    delayed()-&gt;nop();
2747 
2748    // It&#39;s inflated
2749    // Conceptually we need a #loadstore|#storestore &quot;release&quot; MEMBAR before
2750    // the ST of 0 into _owner which releases the lock.  This prevents loads
2751    // and stores within the critical section from reordering (floating)
2752    // past the store that releases the lock.  But TSO is a strong memory model
2753    // and that particular flavor of barrier is a noop, so we can safely elide it.
2754    // Note that we use 1-0 locking by default for the inflated case.  We
2755    // close the resultant (and rare) race by having contended threads in
2756    // monitorenter periodically poll _owner.
2757 
2758    // 1-0 form : avoids CAS and MEMBAR in the common case
2759    // Do not bother to ratify that m-&gt;Owner == Self.
2760    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), Rbox);
2761    orcc(Rbox, G0, G0);
2762    brx(Assembler::notZero, false, Assembler::pn, done);
2763    delayed()-&gt;
2764    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)), Rscratch);
2765    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)), Rbox);
2766    orcc(Rbox, Rscratch, G0);
2767    brx(Assembler::zero, false, Assembler::pt, done);
2768    delayed()-&gt;
2769    st_ptr(G0, Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
2770 
2771    membar(StoreLoad);
2772    // Check that _succ is (or remains) non-zero
2773    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), Rscratch);
2774    andcc(Rscratch, Rscratch, G0);
2775    brx(Assembler::notZero, false, Assembler::pt, done);
2776    delayed()-&gt;andcc(G0, G0, G0);
2777    add(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), Rmark);
2778    mov(G2_thread, Rscratch);
2779    cas_ptr(Rmark, G0, Rscratch);
2780    cmp(Rscratch, G0);
2781    // invert icc.zf and goto done
2782    // A slightly better v8+/v9 idiom would be the following:
2783    //   movrnz Rscratch,1,Rscratch
2784    //   ba done
2785    //   xorcc Rscratch,1,G0
2786    // In v8+ mode the idiom would be valid IFF Rscratch was a G or O register
2787    brx(Assembler::notZero, false, Assembler::pt, done);
2788    delayed()-&gt;cmp(G0, G0);
2789    br(Assembler::always, false, Assembler::pt, done);
2790    delayed()-&gt;cmp(G0, 1);
2791 
2792    bind   (LStacked);
2793    // Consider: we could replace the expensive CAS in the exit
2794    // path with a simple ST of the displaced mark value fetched from
2795    // the on-stack basiclock box.  That admits a race where a thread T2
2796    // in the slow lock path -- inflating with monitor M -- could race a
2797    // thread T1 in the fast unlock path, resulting in a missed wakeup for T2.
2798    // More precisely T1 in the stack-lock unlock path could &quot;stomp&quot; the
2799    // inflated mark value M installed by T2, resulting in an orphan
2800    // object monitor M and T2 becoming stranded.  We can remedy that situation
2801    // by having T2 periodically poll the object&#39;s mark word using timed wait
2802    // operations.  If T2 discovers that a stomp has occurred it vacates
2803    // the monitor M and wakes any other threads stranded on the now-orphan M.
2804    // In addition the monitor scavenger, which performs deflation,
2805    // would also need to check for orpan monitors and stranded threads.
2806    //
2807    // Finally, inflation is also used when T2 needs to assign a hashCode
2808    // to O and O is stack-locked by T1.  The &quot;stomp&quot; race could cause
2809    // an assigned hashCode value to be lost.  We can avoid that condition
2810    // and provide the necessary hashCode stability invariants by ensuring
2811    // that hashCode generation is idempotent between copying GCs.
2812    // For example we could compute the hashCode of an object O as
2813    // O&#39;s heap address XOR some high quality RNG value that is refreshed
2814    // at GC-time.  The monitor scavenger would install the hashCode
2815    // found in any orphan monitors.  Again, the mechanism admits a
2816    // lost-update &quot;stomp&quot; WAW race but detects and recovers as needed.
2817    //
2818    // A prototype implementation showed excellent results, although
2819    // the scavenger and timeout code was rather involved.
2820 
2821    cas_ptr(mark_addr.base(), Rbox, Rscratch);
2822    cmp(Rbox, Rscratch);
2823    // Intentional fall through into done ...
2824 
2825    bind(done);
2826 }
2827 
<a name="16" id="anc16"></a><span class="line-removed">2828 </span>
<span class="line-removed">2829 </span>
<span class="line-removed">2830 void MacroAssembler::print_CPU_state() {</span>
<span class="line-removed">2831   // %%%%% need to implement this</span>
<span class="line-removed">2832 }</span>
<span class="line-removed">2833 </span>
<span class="line-removed">2834 void MacroAssembler::verify_FPU(int stack_depth, const char* s) {</span>
<span class="line-removed">2835   // %%%%% need to implement this</span>
<span class="line-removed">2836 }</span>
<span class="line-removed">2837 </span>
<span class="line-removed">2838 void MacroAssembler::push_IU_state() {</span>
<span class="line-removed">2839   // %%%%% need to implement this</span>
<span class="line-removed">2840 }</span>
<span class="line-removed">2841 </span>
<span class="line-removed">2842 </span>
<span class="line-removed">2843 void MacroAssembler::pop_IU_state() {</span>
<span class="line-removed">2844   // %%%%% need to implement this</span>
<span class="line-removed">2845 }</span>
<span class="line-removed">2846 </span>
<span class="line-removed">2847 </span>
<span class="line-removed">2848 void MacroAssembler::push_FPU_state() {</span>
<span class="line-removed">2849   // %%%%% need to implement this</span>
<span class="line-removed">2850 }</span>
<span class="line-removed">2851 </span>
<span class="line-removed">2852 </span>
<span class="line-removed">2853 void MacroAssembler::pop_FPU_state() {</span>
<span class="line-removed">2854   // %%%%% need to implement this</span>
<span class="line-removed">2855 }</span>
<span class="line-removed">2856 </span>
<span class="line-removed">2857 </span>
<span class="line-removed">2858 void MacroAssembler::push_CPU_state() {</span>
<span class="line-removed">2859   // %%%%% need to implement this</span>
<span class="line-removed">2860 }</span>
<span class="line-removed">2861 </span>
<span class="line-removed">2862 </span>
<span class="line-removed">2863 void MacroAssembler::pop_CPU_state() {</span>
<span class="line-removed">2864   // %%%%% need to implement this</span>
<span class="line-removed">2865 }</span>
<span class="line-removed">2866 </span>
<span class="line-removed">2867 </span>
<span class="line-removed">2868 </span>
2869 void MacroAssembler::verify_tlab() {
2870 #ifdef ASSERT
2871   if (UseTLAB &amp;&amp; VerifyOops) {
2872     Label next, next2, ok;
2873     Register t1 = L0;
2874     Register t2 = L1;
2875     Register t3 = L2;
2876 
2877     save_frame(0);
2878     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_top_offset()), t1);
2879     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_start_offset()), t2);
2880     or3(t1, t2, t3);
2881     cmp_and_br_short(t1, t2, Assembler::greaterEqual, Assembler::pn, next);
2882     STOP(&quot;assert(top &gt;= start)&quot;);
2883     should_not_reach_here();
2884 
2885     bind(next);
2886     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_top_offset()), t1);
2887     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_end_offset()), t2);
2888     or3(t3, t2, t3);
2889     cmp_and_br_short(t1, t2, Assembler::lessEqual, Assembler::pn, next2);
2890     STOP(&quot;assert(top &lt;= end)&quot;);
2891     should_not_reach_here();
2892 
2893     bind(next2);
2894     and3(t3, MinObjAlignmentInBytesMask, t3);
2895     cmp_and_br_short(t3, 0, Assembler::lessEqual, Assembler::pn, ok);
2896     STOP(&quot;assert(aligned)&quot;);
2897     should_not_reach_here();
2898 
2899     bind(ok);
2900     restore();
2901   }
2902 #endif
2903 }
2904 
2905 
2906 void MacroAssembler::eden_allocate(
2907   Register obj,                        // result: pointer to object after successful allocation
2908   Register var_size_in_bytes,          // object size in bytes if unknown at compile time; invalid otherwise
2909   int      con_size_in_bytes,          // object size in bytes if   known at compile time
2910   Register t1,                         // temp register
2911   Register t2,                         // temp register
2912   Label&amp;   slow_case                   // continuation point if fast allocation fails
2913 ){
2914   // make sure arguments make sense
2915   assert_different_registers(obj, var_size_in_bytes, t1, t2);
2916   assert(0 &lt;= con_size_in_bytes &amp;&amp; Assembler::is_simm13(con_size_in_bytes), &quot;illegal object size&quot;);
2917   assert((con_size_in_bytes &amp; MinObjAlignmentInBytesMask) == 0, &quot;object size is not multiple of alignment&quot;);
2918 
2919   if (!Universe::heap()-&gt;supports_inline_contig_alloc()) {
2920     // No allocation in the shared eden.
2921     ba(slow_case);
2922     delayed()-&gt;nop();
2923   } else {
2924     // get eden boundaries
2925     // note: we need both top &amp; top_addr!
2926     const Register top_addr = t1;
2927     const Register end      = t2;
2928 
2929     CollectedHeap* ch = Universe::heap();
2930     set((intx)ch-&gt;top_addr(), top_addr);
2931     intx delta = (intx)ch-&gt;end_addr() - (intx)ch-&gt;top_addr();
2932     ld_ptr(top_addr, delta, end);
2933     ld_ptr(top_addr, 0, obj);
2934 
2935     // try to allocate
2936     Label retry;
2937     bind(retry);
2938 #ifdef ASSERT
2939     // make sure eden top is properly aligned
2940     {
2941       Label L;
2942       btst(MinObjAlignmentInBytesMask, obj);
2943       br(Assembler::zero, false, Assembler::pt, L);
2944       delayed()-&gt;nop();
2945       STOP(&quot;eden top is not properly aligned&quot;);
2946       bind(L);
2947     }
2948 #endif // ASSERT
2949     const Register free = end;
2950     sub(end, obj, free);                                   // compute amount of free space
2951     if (var_size_in_bytes-&gt;is_valid()) {
2952       // size is unknown at compile time
2953       cmp(free, var_size_in_bytes);
2954       brx(Assembler::lessUnsigned, false, Assembler::pn, slow_case); // if there is not enough space go the slow case
2955       delayed()-&gt;add(obj, var_size_in_bytes, end);
2956     } else {
2957       // size is known at compile time
2958       cmp(free, con_size_in_bytes);
2959       brx(Assembler::lessUnsigned, false, Assembler::pn, slow_case); // if there is not enough space go the slow case
2960       delayed()-&gt;add(obj, con_size_in_bytes, end);
2961     }
2962     // Compare obj with the value at top_addr; if still equal, swap the value of
2963     // end with the value at top_addr. If not equal, read the value at top_addr
2964     // into end.
2965     cas_ptr(top_addr, obj, end);
2966     // if someone beat us on the allocation, try again, otherwise continue
2967     cmp(obj, end);
2968     brx(Assembler::notEqual, false, Assembler::pn, retry);
2969     delayed()-&gt;mov(end, obj);                              // nop if successfull since obj == end
2970 
2971 #ifdef ASSERT
2972     // make sure eden top is properly aligned
2973     {
2974       Label L;
2975       const Register top_addr = t1;
2976 
2977       set((intx)ch-&gt;top_addr(), top_addr);
2978       ld_ptr(top_addr, 0, top_addr);
2979       btst(MinObjAlignmentInBytesMask, top_addr);
2980       br(Assembler::zero, false, Assembler::pt, L);
2981       delayed()-&gt;nop();
2982       STOP(&quot;eden top is not properly aligned&quot;);
2983       bind(L);
2984     }
2985 #endif // ASSERT
2986   }
2987 }
2988 
2989 
2990 void MacroAssembler::tlab_allocate(
2991   Register obj,                        // result: pointer to object after successful allocation
2992   Register var_size_in_bytes,          // object size in bytes if unknown at compile time; invalid otherwise
2993   int      con_size_in_bytes,          // object size in bytes if   known at compile time
2994   Register t1,                         // temp register
2995   Label&amp;   slow_case                   // continuation point if fast allocation fails
2996 ){
2997   // make sure arguments make sense
2998   assert_different_registers(obj, var_size_in_bytes, t1);
2999   assert(0 &lt;= con_size_in_bytes &amp;&amp; is_simm13(con_size_in_bytes), &quot;illegal object size&quot;);
3000   assert((con_size_in_bytes &amp; MinObjAlignmentInBytesMask) == 0, &quot;object size is not multiple of alignment&quot;);
3001 
3002   const Register free  = t1;
3003 
3004   verify_tlab();
3005 
3006   ld_ptr(G2_thread, in_bytes(JavaThread::tlab_top_offset()), obj);
3007 
3008   // calculate amount of free space
3009   ld_ptr(G2_thread, in_bytes(JavaThread::tlab_end_offset()), free);
3010   sub(free, obj, free);
3011 
3012   Label done;
3013   if (var_size_in_bytes == noreg) {
3014     cmp(free, con_size_in_bytes);
3015   } else {
3016     cmp(free, var_size_in_bytes);
3017   }
3018   br(Assembler::less, false, Assembler::pn, slow_case);
3019   // calculate the new top pointer
3020   if (var_size_in_bytes == noreg) {
3021     delayed()-&gt;add(obj, con_size_in_bytes, free);
3022   } else {
3023     delayed()-&gt;add(obj, var_size_in_bytes, free);
3024   }
3025 
3026   bind(done);
3027 
3028 #ifdef ASSERT
3029   // make sure new free pointer is properly aligned
3030   {
3031     Label L;
3032     btst(MinObjAlignmentInBytesMask, free);
3033     br(Assembler::zero, false, Assembler::pt, L);
3034     delayed()-&gt;nop();
3035     STOP(&quot;updated TLAB free is not properly aligned&quot;);
3036     bind(L);
3037   }
3038 #endif // ASSERT
3039 
3040   // update the tlab top pointer
3041   st_ptr(free, G2_thread, in_bytes(JavaThread::tlab_top_offset()));
3042   verify_tlab();
3043 }
3044 
3045 void MacroAssembler::zero_memory(Register base, Register index) {
3046   assert_different_registers(base, index);
3047   Label loop;
3048   bind(loop);
3049   subcc(index, HeapWordSize, index);
3050   brx(Assembler::greaterEqual, true, Assembler::pt, loop);
3051   delayed()-&gt;st_ptr(G0, base, index);
3052 }
3053 
3054 void MacroAssembler::incr_allocated_bytes(RegisterOrConstant size_in_bytes,
3055                                           Register t1, Register t2) {
3056   // Bump total bytes allocated by this thread
3057   assert(t1-&gt;is_global(), &quot;must be global reg&quot;); // so all 64 bits are saved on a context switch
3058   assert_different_registers(size_in_bytes.register_or_noreg(), t1, t2);
3059   // v8 support has gone the way of the dodo
3060   ldx(G2_thread, in_bytes(JavaThread::allocated_bytes_offset()), t1);
3061   add(t1, ensure_simm13_or_reg(size_in_bytes, t2), t1);
3062   stx(t1, G2_thread, in_bytes(JavaThread::allocated_bytes_offset()));
3063 }
3064 
3065 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
3066   switch (cond) {
3067     // Note some conditions are synonyms for others
3068     case Assembler::never:                return Assembler::always;
3069     case Assembler::zero:                 return Assembler::notZero;
3070     case Assembler::lessEqual:            return Assembler::greater;
3071     case Assembler::less:                 return Assembler::greaterEqual;
3072     case Assembler::lessEqualUnsigned:    return Assembler::greaterUnsigned;
3073     case Assembler::lessUnsigned:         return Assembler::greaterEqualUnsigned;
3074     case Assembler::negative:             return Assembler::positive;
3075     case Assembler::overflowSet:          return Assembler::overflowClear;
3076     case Assembler::always:               return Assembler::never;
3077     case Assembler::notZero:              return Assembler::zero;
3078     case Assembler::greater:              return Assembler::lessEqual;
3079     case Assembler::greaterEqual:         return Assembler::less;
3080     case Assembler::greaterUnsigned:      return Assembler::lessEqualUnsigned;
3081     case Assembler::greaterEqualUnsigned: return Assembler::lessUnsigned;
3082     case Assembler::positive:             return Assembler::negative;
3083     case Assembler::overflowClear:        return Assembler::overflowSet;
3084   }
3085 
3086   ShouldNotReachHere(); return Assembler::overflowClear;
3087 }
3088 
3089 void MacroAssembler::cond_inc(Assembler::Condition cond, address counter_ptr,
3090                               Register Rtmp1, Register Rtmp2 /*, Register Rtmp3, Register Rtmp4 */) {
3091   Condition negated_cond = negate_condition(cond);
3092   Label L;
3093   brx(negated_cond, false, Assembler::pt, L);
3094   delayed()-&gt;nop();
3095   inc_counter(counter_ptr, Rtmp1, Rtmp2);
3096   bind(L);
3097 }
3098 
3099 void MacroAssembler::inc_counter(address counter_addr, Register Rtmp1, Register Rtmp2) {
3100   AddressLiteral addrlit(counter_addr);
3101   sethi(addrlit, Rtmp1);                 // Move hi22 bits into temporary register.
3102   Address addr(Rtmp1, addrlit.low10());  // Build an address with low10 bits.
3103   ld(addr, Rtmp2);
3104   inc(Rtmp2);
3105   st(Rtmp2, addr);
3106 }
3107 
3108 void MacroAssembler::inc_counter(int* counter_addr, Register Rtmp1, Register Rtmp2) {
3109   inc_counter((address) counter_addr, Rtmp1, Rtmp2);
3110 }
3111 
3112 SkipIfEqual::SkipIfEqual(
3113     MacroAssembler* masm, Register temp, const bool* flag_addr,
3114     Assembler::Condition condition) {
3115   _masm = masm;
3116   AddressLiteral flag(flag_addr);
3117   _masm-&gt;sethi(flag, temp);
3118   _masm-&gt;ldub(temp, flag.low10(), temp);
3119   _masm-&gt;tst(temp);
3120   _masm-&gt;br(condition, false, Assembler::pt, _label);
3121   _masm-&gt;delayed()-&gt;nop();
3122 }
3123 
3124 SkipIfEqual::~SkipIfEqual() {
3125   _masm-&gt;bind(_label);
3126 }
3127 
3128 void MacroAssembler::bang_stack_with_offset(int offset) {
3129   // stack grows down, caller passes positive offset
3130   assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
3131   set((-offset)+STACK_BIAS, G3_scratch);
3132   st(G0, SP, G3_scratch);
3133 }
3134 
3135 // Writes to stack successive pages until offset reached to check for
3136 // stack overflow + shadow pages.  This clobbers tsp and scratch.
3137 void MacroAssembler::bang_stack_size(Register Rsize, Register Rtsp,
3138                                      Register Rscratch) {
3139   // Use stack pointer in temp stack pointer
3140   mov(SP, Rtsp);
3141 
3142   // Bang stack for total size given plus stack shadow page size.
3143   // Bang one page at a time because a large size can overflow yellow and
3144   // red zones (the bang will fail but stack overflow handling can&#39;t tell that
3145   // it was a stack overflow bang vs a regular segv).
3146   int offset = os::vm_page_size();
3147   Register Roffset = Rscratch;
3148 
3149   Label loop;
3150   bind(loop);
3151   set((-offset)+STACK_BIAS, Rscratch);
3152   st(G0, Rtsp, Rscratch);
3153   set(offset, Roffset);
3154   sub(Rsize, Roffset, Rsize);
3155   cmp(Rsize, G0);
3156   br(Assembler::greater, false, Assembler::pn, loop);
3157   delayed()-&gt;sub(Rtsp, Roffset, Rtsp);
3158 
3159   // Bang down shadow pages too.
3160   // At this point, (tmp-0) is the last address touched, so don&#39;t
3161   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
3162   // was post-decremented.)  Skip this address by starting at i=1, and
3163   // touch a few more pages below.  N.B.  It is important to touch all
3164   // the way down to and including i=StackShadowPages.
3165   for (int i = 1; i &lt; JavaThread::stack_shadow_zone_size() / os::vm_page_size(); i++) {
3166     set((-i*offset)+STACK_BIAS, Rscratch);
3167     st(G0, Rtsp, Rscratch);
3168   }
3169 }
3170 
3171 void MacroAssembler::reserved_stack_check() {
3172   // testing if reserved zone needs to be enabled
3173   Label no_reserved_zone_enabling;
3174 
3175   ld_ptr(G2_thread, JavaThread::reserved_stack_activation_offset(), G4_scratch);
3176   cmp_and_brx_short(SP, G4_scratch, Assembler::lessUnsigned, Assembler::pt, no_reserved_zone_enabling);
3177 
3178   call_VM_leaf(L0, CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), G2_thread);
3179 
3180   AddressLiteral stub(StubRoutines::throw_delayed_StackOverflowError_entry());
3181   jump_to(stub, G4_scratch);
3182   delayed()-&gt;restore();
3183 
3184   should_not_reach_here();
3185 
3186   bind(no_reserved_zone_enabling);
3187 }
3188 // ((OopHandle)result).resolve();
3189 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
3190   // OopHandle::resolve is an indirection.
3191   access_load_at(T_OBJECT, IN_NATIVE, Address(result, 0), result, tmp);
3192 }
3193 
3194 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
3195   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
3196   ld_ptr(method, in_bytes(Method::const_offset()), mirror);
3197   ld_ptr(mirror, in_bytes(ConstMethod::constants_offset()), mirror);
3198   ld_ptr(mirror, ConstantPool::pool_holder_offset_in_bytes(), mirror);
3199   ld_ptr(mirror, mirror_offset, mirror);
3200   resolve_oop_handle(mirror, tmp);
3201 }
3202 
3203 void MacroAssembler::load_klass(Register src_oop, Register klass) {
3204   // The number of bytes in this code is used by
3205   // MachCallDynamicJavaNode::ret_addr_offset()
3206   // if this changes, change that.
3207   if (UseCompressedClassPointers) {
3208     lduw(src_oop, oopDesc::klass_offset_in_bytes(), klass);
3209     decode_klass_not_null(klass);
3210   } else {
3211     ld_ptr(src_oop, oopDesc::klass_offset_in_bytes(), klass);
3212   }
3213 }
3214 
3215 void MacroAssembler::store_klass(Register klass, Register dst_oop) {
3216   if (UseCompressedClassPointers) {
3217     assert(dst_oop != klass, &quot;not enough registers&quot;);
3218     encode_klass_not_null(klass);
3219     st(klass, dst_oop, oopDesc::klass_offset_in_bytes());
3220   } else {
3221     st_ptr(klass, dst_oop, oopDesc::klass_offset_in_bytes());
3222   }
3223 }
3224 
3225 void MacroAssembler::store_klass_gap(Register s, Register d) {
3226   if (UseCompressedClassPointers) {
3227     assert(s != d, &quot;not enough registers&quot;);
3228     st(s, d, oopDesc::klass_gap_offset_in_bytes());
3229   }
3230 }
3231 
3232 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators,
3233                                      Register src, Address dst, Register tmp) {
3234   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3235   decorators = AccessInternal::decorator_fixup(decorators);
3236   bool as_raw = (decorators &amp; AS_RAW) != 0;
3237   if (as_raw) {
3238     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, src, dst, tmp);
3239   } else {
3240     bs-&gt;store_at(this, decorators, type, src, dst, tmp);
3241   }
3242 }
3243 
3244 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators,
3245                                     Address src, Register dst, Register tmp) {
3246   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3247   decorators = AccessInternal::decorator_fixup(decorators);
3248   bool as_raw = (decorators &amp; AS_RAW) != 0;
3249   if (as_raw) {
3250     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, src, dst, tmp);
3251   } else {
3252     bs-&gt;load_at(this, decorators, type, src, dst, tmp);
3253   }
3254 }
3255 
3256 void MacroAssembler::load_heap_oop(const Address&amp; s, Register d, Register tmp, DecoratorSet decorators) {
3257   access_load_at(T_OBJECT, IN_HEAP | decorators, s, d, tmp);
3258 }
3259 
3260 void MacroAssembler::load_heap_oop(Register s1, Register s2, Register d, Register tmp, DecoratorSet decorators) {
3261   access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, s2), d, tmp);
3262 }
3263 
3264 void MacroAssembler::load_heap_oop(Register s1, int simm13a, Register d, Register tmp, DecoratorSet decorators) {
3265   access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, simm13a), d, tmp);
3266 }
3267 
3268 void MacroAssembler::load_heap_oop(Register s1, RegisterOrConstant s2, Register d, Register tmp, DecoratorSet decorators) {
3269   if (s2.is_constant()) {
3270     access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, s2.as_constant()), d, tmp);
3271   } else {
3272     access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, s2.as_register()), d, tmp);
3273   }
3274 }
3275 
3276 void MacroAssembler::store_heap_oop(Register d, Register s1, Register s2, Register tmp, DecoratorSet decorators) {
3277   access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(s1, s2), tmp);
3278 }
3279 
3280 void MacroAssembler::store_heap_oop(Register d, Register s1, int simm13a, Register tmp, DecoratorSet decorators) {
3281   access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(s1, simm13a), tmp);
3282 }
3283 
3284 void MacroAssembler::store_heap_oop(Register d, const Address&amp; a, int offset, Register tmp, DecoratorSet decorators) {
3285   if (a.has_index()) {
3286     assert(!a.has_disp(), &quot;not supported yet&quot;);
3287     assert(offset == 0, &quot;not supported yet&quot;);
3288     access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(a.base(), a.index()), tmp);
3289   } else {
3290     access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(a.base(), a.disp() + offset), tmp);
3291   }
3292 }
3293 
3294 
3295 void MacroAssembler::encode_heap_oop(Register src, Register dst) {
3296   assert (UseCompressedOops, &quot;must be compressed&quot;);
3297   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<a name="17" id="anc17"></a><span class="line-modified">3298   assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
3299   verify_oop(src);
<a name="18" id="anc18"></a><span class="line-modified">3300   if (Universe::narrow_oop_base() == NULL) {</span>
3301     srlx(src, LogMinObjAlignmentInBytes, dst);
3302     return;
3303   }
3304   Label done;
3305   if (src == dst) {
3306     // optimize for frequent case src == dst
3307     bpr(rc_nz, true, Assembler::pt, src, done);
3308     delayed() -&gt; sub(src, G6_heapbase, dst); // annuled if not taken
3309     bind(done);
3310     srlx(src, LogMinObjAlignmentInBytes, dst);
3311   } else {
3312     bpr(rc_z, false, Assembler::pn, src, done);
3313     delayed() -&gt; mov(G0, dst);
3314     // could be moved before branch, and annulate delay,
3315     // but may add some unneeded work decoding null
3316     sub(src, G6_heapbase, dst);
3317     srlx(dst, LogMinObjAlignmentInBytes, dst);
3318     bind(done);
3319   }
3320 }
3321 
3322 
3323 void MacroAssembler::encode_heap_oop_not_null(Register r) {
3324   assert (UseCompressedOops, &quot;must be compressed&quot;);
3325   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<a name="19" id="anc19"></a><span class="line-modified">3326   assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
3327   verify_oop(r);
<a name="20" id="anc20"></a><span class="line-modified">3328   if (Universe::narrow_oop_base() != NULL)</span>
3329     sub(r, G6_heapbase, r);
3330   srlx(r, LogMinObjAlignmentInBytes, r);
3331 }
3332 
3333 void MacroAssembler::encode_heap_oop_not_null(Register src, Register dst) {
3334   assert (UseCompressedOops, &quot;must be compressed&quot;);
3335   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<a name="21" id="anc21"></a><span class="line-modified">3336   assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
3337   verify_oop(src);
<a name="22" id="anc22"></a><span class="line-modified">3338   if (Universe::narrow_oop_base() == NULL) {</span>
3339     srlx(src, LogMinObjAlignmentInBytes, dst);
3340   } else {
3341     sub(src, G6_heapbase, dst);
3342     srlx(dst, LogMinObjAlignmentInBytes, dst);
3343   }
3344 }
3345 
3346 // Same algorithm as oops.inline.hpp decode_heap_oop.
3347 void  MacroAssembler::decode_heap_oop(Register src, Register dst) {
3348   assert (UseCompressedOops, &quot;must be compressed&quot;);
3349   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<a name="23" id="anc23"></a><span class="line-modified">3350   assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
3351   sllx(src, LogMinObjAlignmentInBytes, dst);
<a name="24" id="anc24"></a><span class="line-modified">3352   if (Universe::narrow_oop_base() != NULL) {</span>
3353     Label done;
3354     bpr(rc_nz, true, Assembler::pt, dst, done);
3355     delayed() -&gt; add(dst, G6_heapbase, dst); // annuled if not taken
3356     bind(done);
3357   }
3358   verify_oop(dst);
3359 }
3360 
3361 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
3362   // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3363   // pd_code_size_limit.
3364   // Also do not verify_oop as this is called by verify_oop.
3365   assert (UseCompressedOops, &quot;must be compressed&quot;);
3366   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
<a name="25" id="anc25"></a><span class="line-modified">3367   assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
3368   sllx(r, LogMinObjAlignmentInBytes, r);
<a name="26" id="anc26"></a><span class="line-modified">3369   if (Universe::narrow_oop_base() != NULL)</span>
3370     add(r, G6_heapbase, r);
3371 }
3372 
3373 void  MacroAssembler::decode_heap_oop_not_null(Register src, Register dst) {
3374   // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3375   // pd_code_size_limit.
3376   // Also do not verify_oop as this is called by verify_oop.
3377   assert (UseCompressedOops, &quot;must be compressed&quot;);
<a name="27" id="anc27"></a><span class="line-modified">3378   assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
3379   sllx(src, LogMinObjAlignmentInBytes, dst);
<a name="28" id="anc28"></a><span class="line-modified">3380   if (Universe::narrow_oop_base() != NULL)</span>
3381     add(dst, G6_heapbase, dst);
3382 }
3383 
3384 void MacroAssembler::encode_klass_not_null(Register r) {
3385   assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
<a name="29" id="anc29"></a><span class="line-modified">3386   if (Universe::narrow_klass_base() != NULL) {</span>
3387     assert(r != G6_heapbase, &quot;bad register choice&quot;);
<a name="30" id="anc30"></a><span class="line-modified">3388     set((intptr_t)Universe::narrow_klass_base(), G6_heapbase);</span>
3389     sub(r, G6_heapbase, r);
<a name="31" id="anc31"></a><span class="line-modified">3390     if (Universe::narrow_klass_shift() != 0) {</span>
<span class="line-modified">3391       assert (LogKlassAlignmentInBytes == Universe::narrow_klass_shift(), &quot;decode alg wrong&quot;);</span>
3392       srlx(r, LogKlassAlignmentInBytes, r);
3393     }
3394     reinit_heapbase();
3395   } else {
<a name="32" id="anc32"></a><span class="line-modified">3396     assert (LogKlassAlignmentInBytes == Universe::narrow_klass_shift() || Universe::narrow_klass_shift() == 0, &quot;decode alg wrong&quot;);</span>
<span class="line-modified">3397     srlx(r, Universe::narrow_klass_shift(), r);</span>
3398   }
3399 }
3400 
3401 void MacroAssembler::encode_klass_not_null(Register src, Register dst) {
3402   if (src == dst) {
3403     encode_klass_not_null(src);
3404   } else {
3405     assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
<a name="33" id="anc33"></a><span class="line-modified">3406     if (Universe::narrow_klass_base() != NULL) {</span>
<span class="line-modified">3407       set((intptr_t)Universe::narrow_klass_base(), dst);</span>
3408       sub(src, dst, dst);
<a name="34" id="anc34"></a><span class="line-modified">3409       if (Universe::narrow_klass_shift() != 0) {</span>
3410         srlx(dst, LogKlassAlignmentInBytes, dst);
3411       }
3412     } else {
3413       // shift src into dst
<a name="35" id="anc35"></a><span class="line-modified">3414       assert (LogKlassAlignmentInBytes == Universe::narrow_klass_shift() || Universe::narrow_klass_shift() == 0, &quot;decode alg wrong&quot;);</span>
<span class="line-modified">3415       srlx(src, Universe::narrow_klass_shift(), dst);</span>
3416     }
3417   }
3418 }
3419 
3420 // Function instr_size_for_decode_klass_not_null() counts the instructions
3421 // generated by decode_klass_not_null() and reinit_heapbase().  Hence, if
3422 // the instructions they generate change, then this method needs to be updated.
3423 int MacroAssembler::instr_size_for_decode_klass_not_null() {
3424   assert (UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3425   int num_instrs = 1;  // shift src,dst or add
<a name="36" id="anc36"></a><span class="line-modified">3426   if (Universe::narrow_klass_base() != NULL) {</span>
3427     // set + add + set
<a name="37" id="anc37"></a><span class="line-modified">3428     num_instrs += insts_for_internal_set((intptr_t)Universe::narrow_klass_base()) +</span>
<span class="line-modified">3429                   insts_for_internal_set((intptr_t)Universe::narrow_ptrs_base());</span>
<span class="line-modified">3430     if (Universe::narrow_klass_shift() != 0) {</span>
3431       num_instrs += 1;  // sllx
3432     }
3433   }
3434   return num_instrs * BytesPerInstWord;
3435 }
3436 
3437 // !!! If the instructions that get generated here change then function
3438 // instr_size_for_decode_klass_not_null() needs to get updated.
3439 void  MacroAssembler::decode_klass_not_null(Register r) {
3440   // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3441   // pd_code_size_limit.
3442   assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
<a name="38" id="anc38"></a><span class="line-modified">3443   if (Universe::narrow_klass_base() != NULL) {</span>
3444     assert(r != G6_heapbase, &quot;bad register choice&quot;);
<a name="39" id="anc39"></a><span class="line-modified">3445     set((intptr_t)Universe::narrow_klass_base(), G6_heapbase);</span>
<span class="line-modified">3446     if (Universe::narrow_klass_shift() != 0)</span>
3447       sllx(r, LogKlassAlignmentInBytes, r);
3448     add(r, G6_heapbase, r);
3449     reinit_heapbase();
3450   } else {
<a name="40" id="anc40"></a><span class="line-modified">3451     assert (LogKlassAlignmentInBytes == Universe::narrow_klass_shift() || Universe::narrow_klass_shift() == 0, &quot;decode alg wrong&quot;);</span>
<span class="line-modified">3452     sllx(r, Universe::narrow_klass_shift(), r);</span>
3453   }
3454 }
3455 
3456 void  MacroAssembler::decode_klass_not_null(Register src, Register dst) {
3457   if (src == dst) {
3458     decode_klass_not_null(src);
3459   } else {
3460     // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3461     // pd_code_size_limit.
3462     assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
<a name="41" id="anc41"></a><span class="line-modified">3463     if (Universe::narrow_klass_base() != NULL) {</span>
<span class="line-modified">3464       if (Universe::narrow_klass_shift() != 0) {</span>
3465         assert((src != G6_heapbase) &amp;&amp; (dst != G6_heapbase), &quot;bad register choice&quot;);
<a name="42" id="anc42"></a><span class="line-modified">3466         set((intptr_t)Universe::narrow_klass_base(), G6_heapbase);</span>
3467         sllx(src, LogKlassAlignmentInBytes, dst);
3468         add(dst, G6_heapbase, dst);
3469         reinit_heapbase();
3470       } else {
<a name="43" id="anc43"></a><span class="line-modified">3471         set((intptr_t)Universe::narrow_klass_base(), dst);</span>
3472         add(src, dst, dst);
3473       }
3474     } else {
3475       // shift/mov src into dst.
<a name="44" id="anc44"></a><span class="line-modified">3476       assert (LogKlassAlignmentInBytes == Universe::narrow_klass_shift() || Universe::narrow_klass_shift() == 0, &quot;decode alg wrong&quot;);</span>
<span class="line-modified">3477       sllx(src, Universe::narrow_klass_shift(), dst);</span>
3478     }
3479   }
3480 }
3481 
3482 void MacroAssembler::reinit_heapbase() {
3483   if (UseCompressedOops || UseCompressedClassPointers) {
3484     if (Universe::heap() != NULL) {
<a name="45" id="anc45"></a><span class="line-modified">3485       set((intptr_t)Universe::narrow_ptrs_base(), G6_heapbase);</span>
3486     } else {
<a name="46" id="anc46"></a><span class="line-modified">3487       AddressLiteral base(Universe::narrow_ptrs_base_addr());</span>
3488       load_ptr_contents(base, G6_heapbase);
3489     }
3490   }
3491 }
3492 
3493 #ifdef COMPILER2
3494 
3495 // Compress char[] to byte[] by compressing 16 bytes at once. Return 0 on failure.
3496 void MacroAssembler::string_compress_16(Register src, Register dst, Register cnt, Register result,
3497                                         Register tmp1, Register tmp2, Register tmp3, Register tmp4,
3498                                         FloatRegister ftmp1, FloatRegister ftmp2, FloatRegister ftmp3, Label&amp; Ldone) {
3499   Label Lloop, Lslow;
3500   assert(UseVIS &gt;= 3, &quot;VIS3 is required&quot;);
3501   assert_different_registers(src, dst, cnt, tmp1, tmp2, tmp3, tmp4, result);
3502   assert_different_registers(ftmp1, ftmp2, ftmp3);
3503 
3504   // Check if cnt &gt;= 8 (= 16 bytes)
3505   cmp(cnt, 8);
3506   br(Assembler::less, false, Assembler::pn, Lslow);
3507   delayed()-&gt;mov(cnt, result); // copy count
3508 
3509   // Check for 8-byte alignment of src and dst
3510   or3(src, dst, tmp1);
3511   andcc(tmp1, 7, G0);
3512   br(Assembler::notZero, false, Assembler::pn, Lslow);
3513   delayed()-&gt;nop();
3514 
3515   // Set mask for bshuffle instruction
3516   Register mask = tmp4;
3517   set(0x13579bdf, mask);
3518   bmask(mask, G0, G0);
3519 
3520   // Set mask to 0xff00 ff00 ff00 ff00 to check for non-latin1 characters
3521   Assembler::sethi(0xff00fc00, mask); // mask = 0x0000 0000 ff00 fc00
3522   add(mask, 0x300, mask);             // mask = 0x0000 0000 ff00 ff00
3523   sllx(mask, 32, tmp1);               // tmp1 = 0xff00 ff00 0000 0000
3524   or3(mask, tmp1, mask);              // mask = 0xff00 ff00 ff00 ff00
3525 
3526   // Load first 8 bytes
3527   ldx(src, 0, tmp1);
3528 
3529   bind(Lloop);
3530   // Load next 8 bytes
3531   ldx(src, 8, tmp2);
3532 
3533   // Check for non-latin1 character by testing if the most significant byte of a char is set.
3534   // Although we have to move the data between integer and floating point registers, this is
3535   // still faster than the corresponding VIS instructions (ford/fand/fcmpd).
3536   or3(tmp1, tmp2, tmp3);
3537   btst(tmp3, mask);
3538   // annul zeroing if branch is not taken to preserve original count
3539   brx(Assembler::notZero, true, Assembler::pn, Ldone);
3540   delayed()-&gt;mov(G0, result); // 0 - failed
3541 
3542   // Move bytes into float register
3543   movxtod(tmp1, ftmp1);
3544   movxtod(tmp2, ftmp2);
3545 
3546   // Compress by copying one byte per char from ftmp1 and ftmp2 to ftmp3
3547   bshuffle(ftmp1, ftmp2, ftmp3);
3548   stf(FloatRegisterImpl::D, ftmp3, dst, 0);
3549 
3550   // Increment addresses and decrement count
3551   inc(src, 16);
3552   inc(dst, 8);
3553   dec(cnt, 8);
3554 
3555   cmp(cnt, 8);
3556   // annul LDX if branch is not taken to prevent access past end of string
3557   br(Assembler::greaterEqual, true, Assembler::pt, Lloop);
3558   delayed()-&gt;ldx(src, 0, tmp1);
3559 
3560   // Fallback to slow version
3561   bind(Lslow);
3562 }
3563 
3564 // Compress char[] to byte[]. Return 0 on failure.
3565 void MacroAssembler::string_compress(Register src, Register dst, Register cnt, Register result, Register tmp, Label&amp; Ldone) {
3566   Label Lloop;
3567   assert_different_registers(src, dst, cnt, tmp, result);
3568 
3569   lduh(src, 0, tmp);
3570 
3571   bind(Lloop);
3572   inc(src, sizeof(jchar));
3573   cmp(tmp, 0xff);
3574   // annul zeroing if branch is not taken to preserve original count
3575   br(Assembler::greater, true, Assembler::pn, Ldone); // don&#39;t check xcc
3576   delayed()-&gt;mov(G0, result); // 0 - failed
3577   deccc(cnt);
3578   stb(tmp, dst, 0);
3579   inc(dst);
3580   // annul LDUH if branch is not taken to prevent access past end of string
3581   br(Assembler::notZero, true, Assembler::pt, Lloop);
3582   delayed()-&gt;lduh(src, 0, tmp); // hoisted
3583 }
3584 
3585 // Inflate byte[] to char[] by inflating 16 bytes at once.
3586 void MacroAssembler::string_inflate_16(Register src, Register dst, Register cnt, Register tmp,
3587                                        FloatRegister ftmp1, FloatRegister ftmp2, FloatRegister ftmp3, FloatRegister ftmp4, Label&amp; Ldone) {
3588   Label Lloop, Lslow;
3589   assert(UseVIS &gt;= 3, &quot;VIS3 is required&quot;);
3590   assert_different_registers(src, dst, cnt, tmp);
3591   assert_different_registers(ftmp1, ftmp2, ftmp3, ftmp4);
3592 
3593   // Check if cnt &gt;= 8 (= 16 bytes)
3594   cmp(cnt, 8);
3595   br(Assembler::less, false, Assembler::pn, Lslow);
3596   delayed()-&gt;nop();
3597 
3598   // Check for 8-byte alignment of src and dst
3599   or3(src, dst, tmp);
3600   andcc(tmp, 7, G0);
3601   br(Assembler::notZero, false, Assembler::pn, Lslow);
3602   // Initialize float register to zero
3603   FloatRegister zerof = ftmp4;
3604   delayed()-&gt;fzero(FloatRegisterImpl::D, zerof);
3605 
3606   // Load first 8 bytes
3607   ldf(FloatRegisterImpl::D, src, 0, ftmp1);
3608 
3609   bind(Lloop);
3610   inc(src, 8);
3611   dec(cnt, 8);
3612 
3613   // Inflate the string by interleaving each byte from the source array
3614   // with a zero byte and storing the result in the destination array.
3615   fpmerge(zerof, ftmp1-&gt;successor(), ftmp2);
3616   stf(FloatRegisterImpl::D, ftmp2, dst, 8);
3617   fpmerge(zerof, ftmp1, ftmp3);
3618   stf(FloatRegisterImpl::D, ftmp3, dst, 0);
3619 
3620   inc(dst, 16);
3621 
3622   cmp(cnt, 8);
3623   // annul LDX if branch is not taken to prevent access past end of string
3624   br(Assembler::greaterEqual, true, Assembler::pt, Lloop);
3625   delayed()-&gt;ldf(FloatRegisterImpl::D, src, 0, ftmp1);
3626 
3627   // Fallback to slow version
3628   bind(Lslow);
3629 }
3630 
3631 // Inflate byte[] to char[].
3632 void MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp, Label&amp; Ldone) {
3633   Label Loop;
3634   assert_different_registers(src, dst, cnt, tmp);
3635 
3636   ldub(src, 0, tmp);
3637   bind(Loop);
3638   inc(src);
3639   deccc(cnt);
3640   sth(tmp, dst, 0);
3641   inc(dst, sizeof(jchar));
3642   // annul LDUB if branch is not taken to prevent access past end of string
3643   br(Assembler::notZero, true, Assembler::pt, Loop);
3644   delayed()-&gt;ldub(src, 0, tmp); // hoisted
3645 }
3646 
3647 void MacroAssembler::string_compare(Register str1, Register str2,
3648                                     Register cnt1, Register cnt2,
3649                                     Register tmp1, Register tmp2,
3650                                     Register result, int ae) {
3651   Label Ldone, Lloop;
3652   assert_different_registers(str1, str2, cnt1, cnt2, tmp1, result);
3653   int stride1, stride2;
3654 
3655   // Note: Making use of the fact that compareTo(a, b) == -compareTo(b, a)
3656   // we interchange str1 and str2 in the UL case and negate the result.
3657   // Like this, str1 is always latin1 encoded, expect for the UU case.
3658 
3659   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3660     srl(cnt2, 1, cnt2);
3661   }
3662 
3663   // See if the lengths are different, and calculate min in cnt1.
3664   // Save diff in case we need it for a tie-breaker.
3665   Label Lskip;
3666   Register diff = tmp1;
3667   subcc(cnt1, cnt2, diff);
3668   br(Assembler::greater, true, Assembler::pt, Lskip);
3669   // cnt2 is shorter, so use its count:
3670   delayed()-&gt;mov(cnt2, cnt1);
3671   bind(Lskip);
3672 
3673   // Rename registers
3674   Register limit1 = cnt1;
3675   Register limit2 = limit1;
3676   Register chr1   = result;
3677   Register chr2   = cnt2;
3678   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3679     // We need an additional register to keep track of two limits
3680     assert_different_registers(str1, str2, cnt1, cnt2, tmp1, tmp2, result);
3681     limit2 = tmp2;
3682   }
3683 
3684   // Is the minimum length zero?
3685   cmp(limit1, (int)0); // use cast to resolve overloading ambiguity
3686   br(Assembler::equal, true, Assembler::pn, Ldone);
3687   // result is difference in lengths
3688   if (ae == StrIntrinsicNode::UU) {
3689     delayed()-&gt;sra(diff, 1, result);  // Divide by 2 to get number of chars
3690   } else {
3691     delayed()-&gt;mov(diff, result);
3692   }
3693 
3694   // Load first characters
3695   if (ae == StrIntrinsicNode::LL) {
3696     stride1 = stride2 = sizeof(jbyte);
3697     ldub(str1, 0, chr1);
3698     ldub(str2, 0, chr2);
3699   } else if (ae == StrIntrinsicNode::UU) {
3700     stride1 = stride2 = sizeof(jchar);
3701     lduh(str1, 0, chr1);
3702     lduh(str2, 0, chr2);
3703   } else {
3704     stride1 = sizeof(jbyte);
3705     stride2 = sizeof(jchar);
3706     ldub(str1, 0, chr1);
3707     lduh(str2, 0, chr2);
3708   }
3709 
3710   // Compare first characters
3711   subcc(chr1, chr2, chr1);
3712   br(Assembler::notZero, false, Assembler::pt, Ldone);
3713   assert(chr1 == result, &quot;result must be pre-placed&quot;);
3714   delayed()-&gt;nop();
3715 
3716   // Check if the strings start at same location
3717   cmp(str1, str2);
3718   brx(Assembler::equal, true, Assembler::pn, Ldone);
3719   delayed()-&gt;mov(G0, result);  // result is zero
3720 
3721   // We have no guarantee that on 64 bit the higher half of limit is 0
3722   signx(limit1);
3723 
3724   // Get limit
3725   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3726     sll(limit1, 1, limit2);
3727     subcc(limit2, stride2, chr2);
3728   }
3729   subcc(limit1, stride1, chr1);
3730   br(Assembler::zero, true, Assembler::pn, Ldone);
3731   // result is difference in lengths
3732   if (ae == StrIntrinsicNode::UU) {
3733     delayed()-&gt;sra(diff, 1, result);  // Divide by 2 to get number of chars
3734   } else {
3735     delayed()-&gt;mov(diff, result);
3736   }
3737 
3738   // Shift str1 and str2 to the end of the arrays, negate limit
3739   add(str1, limit1, str1);
3740   add(str2, limit2, str2);
3741   neg(chr1, limit1);  // limit1 = -(limit1-stride1)
3742   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3743     neg(chr2, limit2);  // limit2 = -(limit2-stride2)
3744   }
3745 
3746   // Compare the rest of the characters
3747   load_sized_value(Address(str1, limit1), chr1, (ae == StrIntrinsicNode::UU) ? 2 : 1, false);
3748 
3749   bind(Lloop);
3750   load_sized_value(Address(str2, limit2), chr2, (ae == StrIntrinsicNode::LL) ? 1 : 2, false);
3751 
3752   subcc(chr1, chr2, chr1);
3753   br(Assembler::notZero, false, Assembler::pt, Ldone);
3754   assert(chr1 == result, &quot;result must be pre-placed&quot;);
3755   delayed()-&gt;inccc(limit1, stride1);
3756   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3757     inccc(limit2, stride2);
3758   }
3759 
3760   // annul LDUB if branch is not taken to prevent access past end of string
3761   br(Assembler::notZero, true, Assembler::pt, Lloop);
3762   delayed()-&gt;load_sized_value(Address(str1, limit1), chr1, (ae == StrIntrinsicNode::UU) ? 2 : 1, false);
3763 
3764   // If strings are equal up to min length, return the length difference.
3765   if (ae == StrIntrinsicNode::UU) {
3766     // Divide by 2 to get number of chars
3767     sra(diff, 1, result);
3768   } else {
3769     mov(diff, result);
3770   }
3771 
3772   // Otherwise, return the difference between the first mismatched chars.
3773   bind(Ldone);
3774   if(ae == StrIntrinsicNode::UL) {
3775     // Negate result (see note above)
3776     neg(result);
3777   }
3778 }
3779 
3780 void MacroAssembler::array_equals(bool is_array_equ, Register ary1, Register ary2,
3781                                   Register limit, Register tmp, Register result, bool is_byte) {
3782   Label Ldone, Lloop, Lremaining;
3783   assert_different_registers(ary1, ary2, limit, tmp, result);
3784 
3785   int length_offset  = arrayOopDesc::length_offset_in_bytes();
3786   int base_offset    = arrayOopDesc::base_offset_in_bytes(is_byte ? T_BYTE : T_CHAR);
3787   assert(base_offset % 8 == 0, &quot;Base offset must be 8-byte aligned&quot;);
3788 
3789   if (is_array_equ) {
3790     // return true if the same array
3791     cmp(ary1, ary2);
3792     brx(Assembler::equal, true, Assembler::pn, Ldone);
3793     delayed()-&gt;mov(1, result);  // equal
3794 
3795     br_null(ary1, true, Assembler::pn, Ldone);
3796     delayed()-&gt;clr(result);     // not equal
3797 
3798     br_null(ary2, true, Assembler::pn, Ldone);
3799     delayed()-&gt;clr(result);     // not equal
3800 
3801     // load the lengths of arrays
3802     ld(Address(ary1, length_offset), limit);
3803     ld(Address(ary2, length_offset), tmp);
3804 
3805     // return false if the two arrays are not equal length
3806     cmp(limit, tmp);
3807     br(Assembler::notEqual, true, Assembler::pn, Ldone);
3808     delayed()-&gt;clr(result);     // not equal
3809   }
3810 
3811   cmp_zero_and_br(Assembler::zero, limit, Ldone, true, Assembler::pn);
3812   delayed()-&gt;mov(1, result); // zero-length arrays are equal
3813 
3814   if (is_array_equ) {
3815     // load array addresses
3816     add(ary1, base_offset, ary1);
3817     add(ary2, base_offset, ary2);
3818     // set byte count
3819     if (!is_byte) {
3820       sll(limit, exact_log2(sizeof(jchar)), limit);
3821     }
3822   } else {
3823     // We have no guarantee that on 64 bit the higher half of limit is 0
3824     signx(limit);
3825   }
3826 
3827 #ifdef ASSERT
3828   // Sanity check for doubleword (8-byte) alignment of ary1 and ary2.
3829   // Guaranteed on 64-bit systems (see arrayOopDesc::header_size_in_bytes()).
3830   Label Laligned;
3831   or3(ary1, ary2, tmp);
3832   andcc(tmp, 7, tmp);
3833   br_null_short(tmp, Assembler::pn, Laligned);
3834   STOP(&quot;First array element is not 8-byte aligned.&quot;);
3835   should_not_reach_here();
3836   bind(Laligned);
3837 #endif
3838 
3839   // Shift ary1 and ary2 to the end of the arrays, negate limit
3840   add(ary1, limit, ary1);
3841   add(ary2, limit, ary2);
3842   neg(limit, limit);
3843 
3844   // MAIN LOOP
3845   // Load and compare array elements of size &#39;byte_width&#39; until the elements are not
3846   // equal or we reached the end of the arrays. If the size of the arrays is not a
3847   // multiple of &#39;byte_width&#39;, we simply read over the end of the array, bail out and
3848   // compare the remaining bytes below by skipping the garbage bytes.
3849   ldx(ary1, limit, result);
3850   bind(Lloop);
3851   ldx(ary2, limit, tmp);
3852   inccc(limit, 8);
3853   // Bail out if we reached the end (but still do the comparison)
3854   br(Assembler::positive, false, Assembler::pn, Lremaining);
3855   delayed()-&gt;cmp(result, tmp);
3856   // Check equality of elements
3857   brx(Assembler::equal, false, Assembler::pt, target(Lloop));
3858   delayed()-&gt;ldx(ary1, limit, result);
3859 
3860   ba(Ldone);
3861   delayed()-&gt;clr(result); // not equal
3862 
3863   // TAIL COMPARISON
3864   // We got here because we reached the end of the arrays. &#39;limit&#39; is the number of
3865   // garbage bytes we may have compared by reading over the end of the arrays. Shift
3866   // out the garbage and compare the remaining elements.
3867   bind(Lremaining);
3868   // Optimistic shortcut: elements potentially including garbage are equal
3869   brx(Assembler::equal, true, Assembler::pt, target(Ldone));
3870   delayed()-&gt;mov(1, result); // equal
3871   // Shift &#39;limit&#39; bytes to the right and compare
3872   sll(limit, 3, limit); // bytes to bits
3873   srlx(result, limit, result);
3874   srlx(tmp, limit, tmp);
3875   cmp(result, tmp);
3876   clr(result);
3877   movcc(Assembler::equal, false, xcc, 1, result);
3878 
3879   bind(Ldone);
3880 }
3881 
3882 void MacroAssembler::has_negatives(Register inp, Register size, Register result, Register t2, Register t3, Register t4, Register t5) {
3883 
3884   // test for negative bytes in input string of a given size
3885   // result 1 if found, 0 otherwise.
3886 
3887   Label Lcore, Ltail, Lreturn, Lcore_rpt;
3888 
3889   assert_different_registers(inp, size, t2, t3, t4, t5, result);
3890 
3891   Register i     = result;  // result used as integer index i until very end
3892   Register lmask = t2;      // t2 is aliased to lmask
3893 
3894   // INITIALIZATION
3895   // ===========================================================
3896   // initialize highbits mask -&gt; lmask = 0x8080808080808080  (8B/64b)
3897   // compute unaligned offset -&gt; i
3898   // compute core end index   -&gt; t5
3899   Assembler::sethi(0x80808000, t2);   //! sethi macro fails to emit optimal
3900   add(t2, 0x80, t2);
3901   sllx(t2, 32, t3);
3902   or3(t3, t2, lmask);                 // 0x8080808080808080 -&gt; lmask
3903   sra(size,0,size);
3904   andcc(inp, 0x7, i);                 // unaligned offset -&gt; i
3905   br(Assembler::zero, true, Assembler::pn, Lcore); // starts 8B aligned?
3906   delayed()-&gt;add(size, -8, t5);       // (annuled) core end index -&gt; t5
3907 
3908   // ===========================================================
3909 
3910   // UNALIGNED HEAD
3911   // ===========================================================
3912   // * unaligned head handling: grab aligned 8B containing unaligned inp(ut)
3913   // * obliterate (ignore) bytes outside string by shifting off reg ends
3914   // * compare with bitmask, short circuit return true if one or more high
3915   //   bits set.
3916   cmp(size, 0);
3917   br(Assembler::zero, true, Assembler::pn, Lreturn); // short-circuit?
3918   delayed()-&gt;mov(0,result);      // annuled so i not clobbered for following
3919   neg(i, t4);
3920   add(i, size, t5);
3921   ldx(inp, t4, t3);  // raw aligned 8B containing unaligned head -&gt; t3
3922   mov(8, t4);
3923   sub(t4, t5, t4);
3924   sra(t4, 31, t5);
3925   andn(t4, t5, t5);
3926   add(i, t5, t4);
3927   sll(t5, 3, t5);
3928   sll(t4, 3, t4);   // # bits to shift right, left -&gt; t5,t4
3929   srlx(t3, t5, t3);
3930   sllx(t3, t4, t3); // bytes outside string in 8B header obliterated -&gt; t3
3931   andcc(lmask, t3, G0);
3932   brx(Assembler::notZero, true, Assembler::pn, Lreturn); // short circuit?
3933   delayed()-&gt;mov(1,result);      // annuled so i not clobbered for following
3934   add(size, -8, t5);             // core end index -&gt; t5
3935   mov(8, t4);
3936   sub(t4, i, i);                 // # bytes examined in unalgn head (&lt;8) -&gt; i
3937   // ===========================================================
3938 
3939   // ALIGNED CORE
3940   // ===========================================================
3941   // * iterate index i over aligned 8B sections of core, comparing with
3942   //   bitmask, short circuit return true if one or more high bits set
3943   // t5 contains core end index/loop limit which is the index
3944   //     of the MSB of last (unaligned) 8B fully contained in the string.
3945   // inp   contains address of first byte in string/array
3946   // lmask contains 8B high bit mask for comparison
3947   // i     contains next index to be processed (adr. inp+i is on 8B boundary)
3948   bind(Lcore);
3949   cmp_and_br_short(i, t5, Assembler::greater, Assembler::pn, Ltail);
3950   bind(Lcore_rpt);
3951   ldx(inp, i, t3);
3952   andcc(t3, lmask, G0);
3953   brx(Assembler::notZero, true, Assembler::pn, Lreturn);
3954   delayed()-&gt;mov(1, result);    // annuled so i not clobbered for following
3955   add(i, 8, i);
3956   cmp_and_br_short(i, t5, Assembler::lessEqual, Assembler::pn, Lcore_rpt);
3957   // ===========================================================
3958 
3959   // ALIGNED TAIL (&lt;8B)
3960   // ===========================================================
3961   // handle aligned tail of 7B or less as complete 8B, obliterating end of
3962   // string bytes by shifting them off end, compare what&#39;s left with bitmask
3963   // inp   contains address of first byte in string/array
3964   // lmask contains 8B high bit mask for comparison
3965   // i     contains next index to be processed (adr. inp+i is on 8B boundary)
3966   bind(Ltail);
3967   subcc(size, i, t4);   // # of remaining bytes in string -&gt; t4
3968   // return 0 if no more remaining bytes
3969   br(Assembler::lessEqual, true, Assembler::pn, Lreturn);
3970   delayed()-&gt;mov(0, result); // annuled so i not clobbered for following
3971   ldx(inp, i, t3);       // load final 8B (aligned) containing tail -&gt; t3
3972   mov(8, t5);
3973   sub(t5, t4, t4);
3974   mov(0, result);        // ** i clobbered at this point
3975   sll(t4, 3, t4);        // bits beyond end of string          -&gt; t4
3976   srlx(t3, t4, t3);      // bytes beyond end now obliterated   -&gt; t3
3977   andcc(lmask, t3, G0);
3978   movcc(Assembler::notZero, false, xcc,  1, result);
3979   bind(Lreturn);
3980 }
3981 
3982 #endif
3983 
3984 
3985 // Use BIS for zeroing (count is in bytes).
3986 void MacroAssembler::bis_zeroing(Register to, Register count, Register temp, Label&amp; Ldone) {
3987   assert(UseBlockZeroing &amp;&amp; VM_Version::has_blk_zeroing(), &quot;only works with BIS zeroing&quot;);
3988   Register end = count;
3989   int cache_line_size = VM_Version::prefetch_data_size();
3990   assert(cache_line_size &gt; 0, &quot;cache line size should be known for this code&quot;);
3991   // Minimum count when BIS zeroing can be used since
3992   // it needs membar which is expensive.
3993   int block_zero_size  = MAX2(cache_line_size*3, (int)BlockZeroingLowLimit);
3994 
3995   Label small_loop;
3996   // Check if count is negative (dead code) or zero.
3997   // Note, count uses 64bit in 64 bit VM.
3998   cmp_and_brx_short(count, 0, Assembler::lessEqual, Assembler::pn, Ldone);
3999 
4000   // Use BIS zeroing only for big arrays since it requires membar.
4001   if (Assembler::is_simm13(block_zero_size)) { // &lt; 4096
4002     cmp(count, block_zero_size);
4003   } else {
4004     set(block_zero_size, temp);
4005     cmp(count, temp);
4006   }
4007   br(Assembler::lessUnsigned, false, Assembler::pt, small_loop);
4008   delayed()-&gt;add(to, count, end);
4009 
4010   // Note: size is &gt;= three (32 bytes) cache lines.
4011 
4012   // Clean the beginning of space up to next cache line.
4013   for (int offs = 0; offs &lt; cache_line_size; offs += 8) {
4014     stx(G0, to, offs);
4015   }
4016 
4017   // align to next cache line
4018   add(to, cache_line_size, to);
4019   and3(to, -cache_line_size, to);
4020 
4021   // Note: size left &gt;= two (32 bytes) cache lines.
4022 
4023   // BIS should not be used to zero tail (64 bytes)
4024   // to avoid zeroing a header of the following object.
4025   sub(end, (cache_line_size*2)-8, end);
4026 
4027   Label bis_loop;
4028   bind(bis_loop);
4029   stxa(G0, to, G0, Assembler::ASI_ST_BLKINIT_PRIMARY);
4030   add(to, cache_line_size, to);
4031   cmp_and_brx_short(to, end, Assembler::lessUnsigned, Assembler::pt, bis_loop);
4032 
4033   // BIS needs membar.
4034   membar(Assembler::StoreLoad);
4035 
4036   add(end, (cache_line_size*2)-8, end); // restore end
4037   cmp_and_brx_short(to, end, Assembler::greaterEqualUnsigned, Assembler::pn, Ldone);
4038 
4039   // Clean the tail.
4040   bind(small_loop);
4041   stx(G0, to, 0);
4042   add(to, 8, to);
4043   cmp_and_brx_short(to, end, Assembler::lessUnsigned, Assembler::pt, small_loop);
4044   nop(); // Separate short branches
4045 }
4046 
4047 /**
4048  * Update CRC-32[C] with a byte value according to constants in table
4049  *
4050  * @param [in,out]crc   Register containing the crc.
4051  * @param [in]val       Register containing the byte to fold into the CRC.
4052  * @param [in]table     Register containing the table of crc constants.
4053  *
4054  * uint32_t crc;
4055  * val = crc_table[(val ^ crc) &amp; 0xFF];
4056  * crc = val ^ (crc &gt;&gt; 8);
4057  */
4058 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
4059   xor3(val, crc, val);
4060   and3(val, 0xFF, val);
4061   sllx(val, 2, val);
4062   lduw(table, val, val);
4063   srlx(crc, 8, crc);
4064   xor3(val, crc, crc);
4065 }
4066 
4067 // Reverse byte order of lower 32 bits, assuming upper 32 bits all zeros
4068 void MacroAssembler::reverse_bytes_32(Register src, Register dst, Register tmp) {
4069     srlx(src, 24, dst);
4070 
4071     sllx(src, 32+8, tmp);
4072     srlx(tmp, 32+24, tmp);
4073     sllx(tmp, 8, tmp);
4074     or3(dst, tmp, dst);
4075 
4076     sllx(src, 32+16, tmp);
4077     srlx(tmp, 32+24, tmp);
4078     sllx(tmp, 16, tmp);
4079     or3(dst, tmp, dst);
4080 
4081     sllx(src, 32+24, tmp);
4082     srlx(tmp, 32, tmp);
4083     or3(dst, tmp, dst);
4084 }
4085 
4086 void MacroAssembler::movitof_revbytes(Register src, FloatRegister dst, Register tmp1, Register tmp2) {
4087   reverse_bytes_32(src, tmp1, tmp2);
4088   movxtod(tmp1, dst);
4089 }
4090 
4091 void MacroAssembler::movftoi_revbytes(FloatRegister src, Register dst, Register tmp1, Register tmp2) {
4092   movdtox(src, tmp1);
4093   reverse_bytes_32(tmp1, dst, tmp2);
4094 }
4095 
4096 void MacroAssembler::fold_128bit_crc32(Register xcrc_hi, Register xcrc_lo, Register xK_hi, Register xK_lo, Register xtmp_hi, Register xtmp_lo, Register buf, int offset) {
4097   xmulx(xcrc_hi, xK_hi, xtmp_lo);
4098   xmulxhi(xcrc_hi, xK_hi, xtmp_hi);
4099   xmulxhi(xcrc_lo, xK_lo, xcrc_hi);
4100   xmulx(xcrc_lo, xK_lo, xcrc_lo);
4101   xor3(xcrc_lo, xtmp_lo, xcrc_lo);
4102   xor3(xcrc_hi, xtmp_hi, xcrc_hi);
4103   ldxl(buf, G0, xtmp_lo);
4104   inc(buf, 8);
4105   ldxl(buf, G0, xtmp_hi);
4106   inc(buf, 8);
4107   xor3(xcrc_lo, xtmp_lo, xcrc_lo);
4108   xor3(xcrc_hi, xtmp_hi, xcrc_hi);
4109 }
4110 
4111 void MacroAssembler::fold_128bit_crc32(Register xcrc_hi, Register xcrc_lo, Register xK_hi, Register xK_lo, Register xtmp_hi, Register xtmp_lo, Register xbuf_hi, Register xbuf_lo) {
4112   mov(xcrc_lo, xtmp_lo);
4113   mov(xcrc_hi, xtmp_hi);
4114   xmulx(xtmp_hi, xK_hi, xtmp_lo);
4115   xmulxhi(xtmp_hi, xK_hi, xtmp_hi);
4116   xmulxhi(xcrc_lo, xK_lo, xcrc_hi);
4117   xmulx(xcrc_lo, xK_lo, xcrc_lo);
4118   xor3(xcrc_lo, xbuf_lo, xcrc_lo);
4119   xor3(xcrc_hi, xbuf_hi, xcrc_hi);
4120   xor3(xcrc_lo, xtmp_lo, xcrc_lo);
4121   xor3(xcrc_hi, xtmp_hi, xcrc_hi);
4122 }
4123 
4124 void MacroAssembler::fold_8bit_crc32(Register xcrc, Register table, Register xtmp, Register tmp) {
4125   and3(xcrc, 0xFF, tmp);
4126   sllx(tmp, 2, tmp);
4127   lduw(table, tmp, xtmp);
4128   srlx(xcrc, 8, xcrc);
4129   xor3(xtmp, xcrc, xcrc);
4130 }
4131 
4132 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
4133   and3(crc, 0xFF, tmp);
4134   srlx(crc, 8, crc);
4135   sllx(tmp, 2, tmp);
4136   lduw(table, tmp, tmp);
4137   xor3(tmp, crc, crc);
4138 }
4139 
4140 #define CRC32_TMP_REG_NUM 18
4141 
4142 #define CRC32_CONST_64  0x163cd6124
4143 #define CRC32_CONST_96  0x0ccaa009e
4144 #define CRC32_CONST_160 0x1751997d0
4145 #define CRC32_CONST_480 0x1c6e41596
4146 #define CRC32_CONST_544 0x154442bd4
4147 
4148 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table) {
4149 
4150   Label L_cleanup_loop, L_cleanup_check, L_align_loop, L_align_check;
4151   Label L_main_loop_prologue;
4152   Label L_fold_512b, L_fold_512b_loop, L_fold_128b;
4153   Label L_fold_tail, L_fold_tail_loop;
4154   Label L_8byte_fold_check;
4155 
4156   const Register tmp[CRC32_TMP_REG_NUM] = {L0, L1, L2, L3, L4, L5, L6, G1, I0, I1, I2, I3, I4, I5, I7, O4, O5, G3};
4157 
4158   Register const_64  = tmp[CRC32_TMP_REG_NUM-1];
4159   Register const_96  = tmp[CRC32_TMP_REG_NUM-1];
4160   Register const_160 = tmp[CRC32_TMP_REG_NUM-2];
4161   Register const_480 = tmp[CRC32_TMP_REG_NUM-1];
4162   Register const_544 = tmp[CRC32_TMP_REG_NUM-2];
4163 
4164   set(ExternalAddress(StubRoutines::crc_table_addr()), table);
4165 
4166   not1(crc); // ~c
4167   clruwu(crc); // clear upper 32 bits of crc
4168 
4169   // Check if below cutoff, proceed directly to cleanup code
4170   mov(31, G4);
4171   cmp_and_br_short(len, G4, Assembler::lessEqualUnsigned, Assembler::pt, L_cleanup_check);
4172 
4173   // Align buffer to 8 byte boundry
4174   mov(8, O5);
4175   and3(buf, 0x7, O4);
4176   sub(O5, O4, O5);
4177   and3(O5, 0x7, O5);
4178   sub(len, O5, len);
4179   ba(L_align_check);
4180   delayed()-&gt;nop();
4181 
4182   // Alignment loop, table look up method for up to 7 bytes
4183   bind(L_align_loop);
4184   ldub(buf, 0, O4);
4185   inc(buf);
4186   dec(O5);
4187   xor3(O4, crc, O4);
4188   and3(O4, 0xFF, O4);
4189   sllx(O4, 2, O4);
4190   lduw(table, O4, O4);
4191   srlx(crc, 8, crc);
4192   xor3(O4, crc, crc);
4193   bind(L_align_check);
4194   nop();
4195   cmp_and_br_short(O5, 0, Assembler::notEqual, Assembler::pt, L_align_loop);
4196 
4197   // Aligned on 64-bit (8-byte) boundry at this point
4198   // Check if still above cutoff (31-bytes)
4199   mov(31, G4);
4200   cmp_and_br_short(len, G4, Assembler::lessEqualUnsigned, Assembler::pt, L_cleanup_check);
4201   // At least 32 bytes left to process
4202 
4203   // Free up registers by storing them to FP registers
4204   for (int i = 0; i &lt; CRC32_TMP_REG_NUM; i++) {
4205     movxtod(tmp[i], as_FloatRegister(2*i));
4206   }
4207 
4208   // Determine which loop to enter
4209   // Shared prologue
4210   ldxl(buf, G0, tmp[0]);
4211   inc(buf, 8);
4212   ldxl(buf, G0, tmp[1]);
4213   inc(buf, 8);
4214   xor3(tmp[0], crc, tmp[0]); // Fold CRC into first few bytes
4215   and3(crc, 0, crc); // Clear out the crc register
4216   // Main loop needs 128-bytes at least
4217   mov(128, G4);
4218   mov(64, tmp[2]);
4219   cmp_and_br_short(len, G4, Assembler::greaterEqualUnsigned, Assembler::pt, L_main_loop_prologue);
4220   // Less than 64 bytes
4221   nop();
4222   cmp_and_br_short(len, tmp[2], Assembler::lessUnsigned, Assembler::pt, L_fold_tail);
4223   // Between 64 and 127 bytes
4224   set64(CRC32_CONST_96,  const_96,  tmp[8]);
4225   set64(CRC32_CONST_160, const_160, tmp[9]);
4226   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[2], tmp[3], buf, 0);
4227   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[4], tmp[5], buf, 16);
4228   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[6], tmp[7], buf, 32);
4229   dec(len, 48);
4230   ba(L_fold_tail);
4231   delayed()-&gt;nop();
4232 
4233   bind(L_main_loop_prologue);
4234   for (int i = 2; i &lt; 8; i++) {
4235     ldxl(buf, G0, tmp[i]);
4236     inc(buf, 8);
4237   }
4238 
4239   // Fold total 512 bits of polynomial on each iteration,
4240   // 128 bits per each of 4 parallel streams
4241   set64(CRC32_CONST_480, const_480, tmp[8]);
4242   set64(CRC32_CONST_544, const_544, tmp[9]);
4243 
4244   mov(128, G4);
4245   bind(L_fold_512b_loop);
4246   fold_128bit_crc32(tmp[1], tmp[0], const_480, const_544, tmp[9],  tmp[8],  buf,  0);
4247   fold_128bit_crc32(tmp[3], tmp[2], const_480, const_544, tmp[11], tmp[10], buf, 16);
4248   fold_128bit_crc32(tmp[5], tmp[4], const_480, const_544, tmp[13], tmp[12], buf, 32);
4249   fold_128bit_crc32(tmp[7], tmp[6], const_480, const_544, tmp[15], tmp[14], buf, 64);
4250   dec(len, 64);
4251   cmp_and_br_short(len, G4, Assembler::greaterEqualUnsigned, Assembler::pt, L_fold_512b_loop);
4252 
4253   // Fold 512 bits to 128 bits
4254   bind(L_fold_512b);
4255   set64(CRC32_CONST_96,  const_96,  tmp[8]);
4256   set64(CRC32_CONST_160, const_160, tmp[9]);
4257 
4258   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[8], tmp[9], tmp[3], tmp[2]);
4259   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[8], tmp[9], tmp[5], tmp[4]);
4260   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[8], tmp[9], tmp[7], tmp[6]);
4261   dec(len, 48);
4262 
4263   // Fold the rest of 128 bits data chunks
4264   bind(L_fold_tail);
4265   mov(32, G4);
4266   cmp_and_br_short(len, G4, Assembler::lessEqualUnsigned, Assembler::pt, L_fold_128b);
4267 
4268   set64(CRC32_CONST_96,  const_96,  tmp[8]);
4269   set64(CRC32_CONST_160, const_160, tmp[9]);
4270 
4271   bind(L_fold_tail_loop);
4272   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[2], tmp[3], buf, 0);
4273   sub(len, 16, len);
4274   cmp_and_br_short(len, G4, Assembler::greaterEqualUnsigned, Assembler::pt, L_fold_tail_loop);
4275 
4276   // Fold the 128 bits in tmps 0 - 1 into tmp 1
4277   bind(L_fold_128b);
4278 
4279   set64(CRC32_CONST_64, const_64, tmp[4]);
4280 
4281   xmulx(const_64, tmp[0], tmp[2]);
4282   xmulxhi(const_64, tmp[0], tmp[3]);
4283 
4284   srl(tmp[2], G0, tmp[4]);
4285   xmulx(const_64, tmp[4], tmp[4]);
4286 
4287   srlx(tmp[2], 32, tmp[2]);
4288   sllx(tmp[3], 32, tmp[3]);
4289   or3(tmp[2], tmp[3], tmp[2]);
4290 
4291   xor3(tmp[4], tmp[1], tmp[4]);
4292   xor3(tmp[4], tmp[2], tmp[1]);
4293   dec(len, 8);
4294 
4295   // Use table lookup for the 8 bytes left in tmp[1]
4296   dec(len, 8);
4297 
4298   // 8 8-bit folds to compute 32-bit CRC.
4299   for (int j = 0; j &lt; 4; j++) {
4300     fold_8bit_crc32(tmp[1], table, tmp[2], tmp[3]);
4301   }
4302   srl(tmp[1], G0, crc); // move 32 bits to general register
4303   for (int j = 0; j &lt; 4; j++) {
4304     fold_8bit_crc32(crc, table, tmp[3]);
4305   }
4306 
4307   bind(L_8byte_fold_check);
4308 
4309   // Restore int registers saved in FP registers
4310   for (int i = 0; i &lt; CRC32_TMP_REG_NUM; i++) {
4311     movdtox(as_FloatRegister(2*i), tmp[i]);
4312   }
4313 
4314   ba(L_cleanup_check);
4315   delayed()-&gt;nop();
4316 
4317   // Table look-up method for the remaining few bytes
4318   bind(L_cleanup_loop);
4319   ldub(buf, 0, O4);
4320   inc(buf);
4321   dec(len);
4322   xor3(O4, crc, O4);
4323   and3(O4, 0xFF, O4);
4324   sllx(O4, 2, O4);
4325   lduw(table, O4, O4);
4326   srlx(crc, 8, crc);
4327   xor3(O4, crc, crc);
4328   bind(L_cleanup_check);
4329   nop();
4330   cmp_and_br_short(len, 0, Assembler::greaterUnsigned, Assembler::pt, L_cleanup_loop);
4331 
4332   not1(crc);
4333 }
4334 
4335 #define CHUNK_LEN   128          /* 128 x 8B = 1KB */
4336 #define CHUNK_K1    0x1307a0206  /* reverseBits(pow(x, CHUNK_LEN*8*8*3 - 32) mod P(x)) &lt;&lt; 1 */
4337 #define CHUNK_K2    0x1a0f717c4  /* reverseBits(pow(x, CHUNK_LEN*8*8*2 - 32) mod P(x)) &lt;&lt; 1 */
4338 #define CHUNK_K3    0x0170076fa  /* reverseBits(pow(x, CHUNK_LEN*8*8*1 - 32) mod P(x)) &lt;&lt; 1 */
4339 
4340 void MacroAssembler::kernel_crc32c(Register crc, Register buf, Register len, Register table) {
4341 
4342   Label L_crc32c_head, L_crc32c_aligned;
4343   Label L_crc32c_parallel, L_crc32c_parallel_loop;
4344   Label L_crc32c_serial, L_crc32c_x32_loop, L_crc32c_x8, L_crc32c_x8_loop;
4345   Label L_crc32c_done, L_crc32c_tail, L_crc32c_return;
4346 
4347   set(ExternalAddress(StubRoutines::crc32c_table_addr()), table);
4348 
4349   cmp_and_br_short(len, 0, Assembler::lessEqual, Assembler::pn, L_crc32c_return);
4350 
4351   // clear upper 32 bits of crc
4352   clruwu(crc);
4353 
4354   and3(buf, 7, G4);
4355   cmp_and_brx_short(G4, 0, Assembler::equal, Assembler::pt, L_crc32c_aligned);
4356 
4357   mov(8, G1);
4358   sub(G1, G4, G4);
4359 
4360   // ------ process the misaligned head (7 bytes or less) ------
4361   bind(L_crc32c_head);
4362 
4363   // crc = (crc &gt;&gt;&gt; 8) ^ byteTable[(crc ^ b) &amp; 0xFF];
4364   ldub(buf, 0, G1);
4365   update_byte_crc32(crc, G1, table);
4366 
4367   inc(buf);
4368   dec(len);
4369   cmp_and_br_short(len, 0, Assembler::equal, Assembler::pn, L_crc32c_return);
4370   dec(G4);
4371   cmp_and_br_short(G4, 0, Assembler::greater, Assembler::pt, L_crc32c_head);
4372 
4373   // ------ process the 8-byte-aligned body ------
4374   bind(L_crc32c_aligned);
4375   nop();
4376   cmp_and_br_short(len, 8, Assembler::less, Assembler::pn, L_crc32c_tail);
4377 
4378   // reverse the byte order of lower 32 bits to big endian, and move to FP side
4379   movitof_revbytes(crc, F0, G1, G3);
4380 
4381   set(CHUNK_LEN*8*4, G4);
4382   cmp_and_br_short(len, G4, Assembler::less, Assembler::pt, L_crc32c_serial);
4383 
4384   // ------ process four 1KB chunks in parallel ------
4385   bind(L_crc32c_parallel);
4386 
4387   fzero(FloatRegisterImpl::D, F2);
4388   fzero(FloatRegisterImpl::D, F4);
4389   fzero(FloatRegisterImpl::D, F6);
4390 
4391   mov(CHUNK_LEN - 1, G4);
4392   bind(L_crc32c_parallel_loop);
4393   // schedule ldf&#39;s ahead of crc32c&#39;s to hide the load-use latency
4394   ldf(FloatRegisterImpl::D, buf, 0,            F8);
4395   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*8,  F10);
4396   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*16, F12);
4397   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*24, F14);
4398   crc32c(F0, F8,  F0);
4399   crc32c(F2, F10, F2);
4400   crc32c(F4, F12, F4);
4401   crc32c(F6, F14, F6);
4402   inc(buf, 8);
4403   dec(G4);
4404   cmp_and_br_short(G4, 0, Assembler::greater, Assembler::pt, L_crc32c_parallel_loop);
4405 
4406   ldf(FloatRegisterImpl::D, buf, 0,            F8);
4407   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*8,  F10);
4408   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*16, F12);
4409   crc32c(F0, F8,  F0);
4410   crc32c(F2, F10, F2);
4411   crc32c(F4, F12, F4);
4412 
4413   inc(buf, CHUNK_LEN*24);
4414   ldfl(FloatRegisterImpl::D, buf, G0, F14);  // load in little endian
4415   inc(buf, 8);
4416 
4417   prefetch(buf, 0,            Assembler::severalReads);
4418   prefetch(buf, CHUNK_LEN*8,  Assembler::severalReads);
4419   prefetch(buf, CHUNK_LEN*16, Assembler::severalReads);
4420   prefetch(buf, CHUNK_LEN*24, Assembler::severalReads);
4421 
4422   // move to INT side, and reverse the byte order of lower 32 bits to little endian
4423   movftoi_revbytes(F0, O4, G1, G4);
4424   movftoi_revbytes(F2, O5, G1, G4);
4425   movftoi_revbytes(F4, G5, G1, G4);
4426 
4427   // combine the results of 4 chunks
4428   set64(CHUNK_K1, G3, G1);
4429   xmulx(O4, G3, O4);
4430   set64(CHUNK_K2, G3, G1);
4431   xmulx(O5, G3, O5);
4432   set64(CHUNK_K3, G3, G1);
4433   xmulx(G5, G3, G5);
4434 
4435   movdtox(F14, G4);
4436   xor3(O4, O5, O5);
4437   xor3(G5, O5, O5);
4438   xor3(G4, O5, O5);
4439 
4440   // reverse the byte order to big endian, via stack, and move to FP side
4441   // TODO: use new revb instruction
4442   add(SP, -8, G1);
4443   srlx(G1, 3, G1);
4444   sllx(G1, 3, G1);
4445   stx(O5, G1, G0);
4446   ldfl(FloatRegisterImpl::D, G1, G0, F2);  // load in little endian
4447 
4448   crc32c(F6, F2, F0);
4449 
4450   set(CHUNK_LEN*8*4, G4);
4451   sub(len, G4, len);
4452   cmp_and_br_short(len, G4, Assembler::greaterEqual, Assembler::pt, L_crc32c_parallel);
4453   nop();
4454   cmp_and_br_short(len, 0, Assembler::equal, Assembler::pt, L_crc32c_done);
4455 
4456   bind(L_crc32c_serial);
4457 
4458   mov(32, G4);
4459   cmp_and_br_short(len, G4, Assembler::less, Assembler::pn, L_crc32c_x8);
4460 
4461   // ------ process 32B chunks ------
4462   bind(L_crc32c_x32_loop);
4463   ldf(FloatRegisterImpl::D, buf, 0, F2);
4464   crc32c(F0, F2, F0);
4465   ldf(FloatRegisterImpl::D, buf, 8, F2);
4466   crc32c(F0, F2, F0);
4467   ldf(FloatRegisterImpl::D, buf, 16, F2);
4468   crc32c(F0, F2, F0);
4469   ldf(FloatRegisterImpl::D, buf, 24, F2);
4470   inc(buf, 32);
4471   crc32c(F0, F2, F0);
4472   dec(len, 32);
4473   cmp_and_br_short(len, G4, Assembler::greaterEqual, Assembler::pt, L_crc32c_x32_loop);
4474 
4475   bind(L_crc32c_x8);
4476   nop();
4477   cmp_and_br_short(len, 8, Assembler::less, Assembler::pt, L_crc32c_done);
4478 
4479   // ------ process 8B chunks ------
4480   bind(L_crc32c_x8_loop);
4481   ldf(FloatRegisterImpl::D, buf, 0, F2);
4482   inc(buf, 8);
4483   crc32c(F0, F2, F0);
4484   dec(len, 8);
4485   cmp_and_br_short(len, 8, Assembler::greaterEqual, Assembler::pt, L_crc32c_x8_loop);
4486 
4487   bind(L_crc32c_done);
4488 
4489   // move to INT side, and reverse the byte order of lower 32 bits to little endian
4490   movftoi_revbytes(F0, crc, G1, G3);
4491 
4492   cmp_and_br_short(len, 0, Assembler::equal, Assembler::pt, L_crc32c_return);
4493 
4494   // ------ process the misaligned tail (7 bytes or less) ------
4495   bind(L_crc32c_tail);
4496 
4497   // crc = (crc &gt;&gt;&gt; 8) ^ byteTable[(crc ^ b) &amp; 0xFF];
4498   ldub(buf, 0, G1);
4499   update_byte_crc32(crc, G1, table);
4500 
4501   inc(buf);
4502   dec(len);
4503   cmp_and_br_short(len, 0, Assembler::greater, Assembler::pt, L_crc32c_tail);
4504 
4505   bind(L_crc32c_return);
4506   nop();
4507 }
<a name="47" id="anc47"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="47" type="hidden" />
</body>
</html>
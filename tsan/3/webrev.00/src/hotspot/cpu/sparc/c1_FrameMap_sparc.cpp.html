<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/sparc/c1_FrameMap_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;c1/c1_FrameMap.hpp&quot;
 27 #include &quot;c1/c1_LIR.hpp&quot;
 28 #include &quot;runtime/sharedRuntime.hpp&quot;
 29 #include &quot;vmreg_sparc.inline.hpp&quot;
 30 
 31 
 32 const int FrameMap::pd_c_runtime_reserved_arg_size = 7;
 33 
 34 
 35 LIR_Opr FrameMap::map_to_opr(BasicType type, VMRegPair* reg, bool outgoing) {
 36   LIR_Opr opr = LIR_OprFact::illegalOpr;
 37   VMReg r_1 = reg-&gt;first();
 38   VMReg r_2 = reg-&gt;second();
 39   if (r_1-&gt;is_stack()) {
 40     // Convert stack slot to an SP offset
 41     // The calling convention does not count the SharedRuntime::out_preserve_stack_slots() value
 42     // so we must add it in here.
 43     int st_off = (r_1-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 44     opr = LIR_OprFact::address(new LIR_Address(SP_opr, st_off + STACK_BIAS, type));
 45   } else if (r_1-&gt;is_Register()) {
 46     Register reg = r_1-&gt;as_Register();
 47     if (outgoing) {
 48       assert(!reg-&gt;is_in(), &quot;should be using I regs&quot;);
 49     } else {
 50       assert(!reg-&gt;is_out(), &quot;should be using O regs&quot;);
 51     }
 52     if (r_2-&gt;is_Register() &amp;&amp; (type == T_LONG || type == T_DOUBLE)) {
 53       opr = as_long_opr(reg);
 54     } else if (is_reference_type(type)) {
 55       opr = as_oop_opr(reg);
 56     } else if (type == T_METADATA) {
 57       opr = as_metadata_opr(reg);
 58     } else if (type == T_ADDRESS) {
 59       opr = as_address_opr(reg);
 60     } else {
 61       opr = as_opr(reg);
 62     }
 63   } else if (r_1-&gt;is_FloatRegister()) {
 64     assert(type == T_DOUBLE || type == T_FLOAT, &quot;wrong type&quot;);
 65     FloatRegister f = r_1-&gt;as_FloatRegister();
 66     if (type == T_DOUBLE) {
 67       opr = as_double_opr(f);
 68     } else {
 69       opr = as_float_opr(f);
 70     }
 71   }
 72   return opr;
 73 }
 74 
 75 //               FrameMap
 76 //--------------------------------------------------------
 77 
 78 FloatRegister FrameMap::_fpu_regs [FrameMap::nof_fpu_regs];
 79 
 80 // some useful constant RInfo&#39;s:
 81 LIR_Opr FrameMap::in_long_opr;
 82 LIR_Opr FrameMap::out_long_opr;
 83 LIR_Opr FrameMap::g1_long_single_opr;
 84 
 85 LIR_Opr FrameMap::F0_opr;
 86 LIR_Opr FrameMap::F0_double_opr;
 87 
 88 LIR_Opr FrameMap::G0_opr;
 89 LIR_Opr FrameMap::G1_opr;
 90 LIR_Opr FrameMap::G2_opr;
 91 LIR_Opr FrameMap::G3_opr;
 92 LIR_Opr FrameMap::G4_opr;
 93 LIR_Opr FrameMap::G5_opr;
 94 LIR_Opr FrameMap::G6_opr;
 95 LIR_Opr FrameMap::G7_opr;
 96 LIR_Opr FrameMap::O0_opr;
 97 LIR_Opr FrameMap::O1_opr;
 98 LIR_Opr FrameMap::O2_opr;
 99 LIR_Opr FrameMap::O3_opr;
100 LIR_Opr FrameMap::O4_opr;
101 LIR_Opr FrameMap::O5_opr;
102 LIR_Opr FrameMap::O6_opr;
103 LIR_Opr FrameMap::O7_opr;
104 LIR_Opr FrameMap::L0_opr;
105 LIR_Opr FrameMap::L1_opr;
106 LIR_Opr FrameMap::L2_opr;
107 LIR_Opr FrameMap::L3_opr;
108 LIR_Opr FrameMap::L4_opr;
109 LIR_Opr FrameMap::L5_opr;
110 LIR_Opr FrameMap::L6_opr;
111 LIR_Opr FrameMap::L7_opr;
112 LIR_Opr FrameMap::I0_opr;
113 LIR_Opr FrameMap::I1_opr;
114 LIR_Opr FrameMap::I2_opr;
115 LIR_Opr FrameMap::I3_opr;
116 LIR_Opr FrameMap::I4_opr;
117 LIR_Opr FrameMap::I5_opr;
118 LIR_Opr FrameMap::I6_opr;
119 LIR_Opr FrameMap::I7_opr;
120 
121 LIR_Opr FrameMap::G0_oop_opr;
122 LIR_Opr FrameMap::G1_oop_opr;
123 LIR_Opr FrameMap::G2_oop_opr;
124 LIR_Opr FrameMap::G3_oop_opr;
125 LIR_Opr FrameMap::G4_oop_opr;
126 LIR_Opr FrameMap::G5_oop_opr;
127 LIR_Opr FrameMap::G6_oop_opr;
128 LIR_Opr FrameMap::G7_oop_opr;
129 LIR_Opr FrameMap::O0_oop_opr;
130 LIR_Opr FrameMap::O1_oop_opr;
131 LIR_Opr FrameMap::O2_oop_opr;
132 LIR_Opr FrameMap::O3_oop_opr;
133 LIR_Opr FrameMap::O4_oop_opr;
134 LIR_Opr FrameMap::O5_oop_opr;
135 LIR_Opr FrameMap::O6_oop_opr;
136 LIR_Opr FrameMap::O7_oop_opr;
137 LIR_Opr FrameMap::L0_oop_opr;
138 LIR_Opr FrameMap::L1_oop_opr;
139 LIR_Opr FrameMap::L2_oop_opr;
140 LIR_Opr FrameMap::L3_oop_opr;
141 LIR_Opr FrameMap::L4_oop_opr;
142 LIR_Opr FrameMap::L5_oop_opr;
143 LIR_Opr FrameMap::L6_oop_opr;
144 LIR_Opr FrameMap::L7_oop_opr;
145 LIR_Opr FrameMap::I0_oop_opr;
146 LIR_Opr FrameMap::I1_oop_opr;
147 LIR_Opr FrameMap::I2_oop_opr;
148 LIR_Opr FrameMap::I3_oop_opr;
149 LIR_Opr FrameMap::I4_oop_opr;
150 LIR_Opr FrameMap::I5_oop_opr;
151 LIR_Opr FrameMap::I6_oop_opr;
152 LIR_Opr FrameMap::I7_oop_opr;
153 
154 LIR_Opr FrameMap::G0_metadata_opr;
155 LIR_Opr FrameMap::G1_metadata_opr;
156 LIR_Opr FrameMap::G2_metadata_opr;
157 LIR_Opr FrameMap::G3_metadata_opr;
158 LIR_Opr FrameMap::G4_metadata_opr;
159 LIR_Opr FrameMap::G5_metadata_opr;
160 LIR_Opr FrameMap::G6_metadata_opr;
161 LIR_Opr FrameMap::G7_metadata_opr;
162 LIR_Opr FrameMap::O0_metadata_opr;
163 LIR_Opr FrameMap::O1_metadata_opr;
164 LIR_Opr FrameMap::O2_metadata_opr;
165 LIR_Opr FrameMap::O3_metadata_opr;
166 LIR_Opr FrameMap::O4_metadata_opr;
167 LIR_Opr FrameMap::O5_metadata_opr;
168 LIR_Opr FrameMap::O6_metadata_opr;
169 LIR_Opr FrameMap::O7_metadata_opr;
170 LIR_Opr FrameMap::L0_metadata_opr;
171 LIR_Opr FrameMap::L1_metadata_opr;
172 LIR_Opr FrameMap::L2_metadata_opr;
173 LIR_Opr FrameMap::L3_metadata_opr;
174 LIR_Opr FrameMap::L4_metadata_opr;
175 LIR_Opr FrameMap::L5_metadata_opr;
176 LIR_Opr FrameMap::L6_metadata_opr;
177 LIR_Opr FrameMap::L7_metadata_opr;
178 LIR_Opr FrameMap::I0_metadata_opr;
179 LIR_Opr FrameMap::I1_metadata_opr;
180 LIR_Opr FrameMap::I2_metadata_opr;
181 LIR_Opr FrameMap::I3_metadata_opr;
182 LIR_Opr FrameMap::I4_metadata_opr;
183 LIR_Opr FrameMap::I5_metadata_opr;
184 LIR_Opr FrameMap::I6_metadata_opr;
185 LIR_Opr FrameMap::I7_metadata_opr;
186 
187 LIR_Opr FrameMap::SP_opr;
188 LIR_Opr FrameMap::FP_opr;
189 
190 LIR_Opr FrameMap::Oexception_opr;
191 LIR_Opr FrameMap::Oissuing_pc_opr;
192 
193 LIR_Opr FrameMap::_caller_save_cpu_regs[] = { 0, };
194 LIR_Opr FrameMap::_caller_save_fpu_regs[] = { 0, };
195 
196 
197 FloatRegister FrameMap::nr2floatreg (int rnr) {
198   assert(_init_done, &quot;tables not initialized&quot;);
199   debug_only(fpu_range_check(rnr);)
200   return _fpu_regs[rnr];
201 }
202 
203 
204 // returns true if reg could be smashed by a callee.
205 bool FrameMap::is_caller_save_register (LIR_Opr reg) {
206   if (reg-&gt;is_single_fpu() || reg-&gt;is_double_fpu()) { return true; }
207   if (reg-&gt;is_double_cpu()) {
208     return is_caller_save_register(reg-&gt;as_register_lo()) ||
209            is_caller_save_register(reg-&gt;as_register_hi());
210   }
211   return is_caller_save_register(reg-&gt;as_register());
212 }
213 
214 
215 NEEDS_CLEANUP   // once the new calling convention is enabled, we no
216                 // longer need to treat I5, I4 and L0 specially
217 // Because the interpreter destroys caller&#39;s I5, I4 and L0,
218 // we must spill them before doing a Java call as we may land in
219 // interpreter.
220 bool FrameMap::is_caller_save_register (Register r) {
221   return (r-&gt;is_global() &amp;&amp; (r != G0)) || r-&gt;is_out();
222 }
223 
224 
225 void FrameMap::initialize() {
226   assert(!_init_done, &quot;once&quot;);
227 
228   int i=0;
229   // Register usage:
230   //  O6: sp
231   //  I6: fp
232   //  I7: return address
233   //  G0: zero
234   //  G2: thread
235   //  G7: not available
236   //  G6: not available
237   /*  0 */ map_register(i++, L0);
238   /*  1 */ map_register(i++, L1);
239   /*  2 */ map_register(i++, L2);
240   /*  3 */ map_register(i++, L3);
241   /*  4 */ map_register(i++, L4);
242   /*  5 */ map_register(i++, L5);
243   /*  6 */ map_register(i++, L6);
244   /*  7 */ map_register(i++, L7);
245 
246   /*  8 */ map_register(i++, I0);
247   /*  9 */ map_register(i++, I1);
248   /* 10 */ map_register(i++, I2);
249   /* 11 */ map_register(i++, I3);
250   /* 12 */ map_register(i++, I4);
251   /* 13 */ map_register(i++, I5);
252   /* 14 */ map_register(i++, O0);
253   /* 15 */ map_register(i++, O1);
254   /* 16 */ map_register(i++, O2);
255   /* 17 */ map_register(i++, O3);
256   /* 18 */ map_register(i++, O4);
257   /* 19 */ map_register(i++, O5); // &lt;- last register visible in RegAlloc (RegAlloc::nof+cpu_regs)
258   /* 20 */ map_register(i++, G1);
259   /* 21 */ map_register(i++, G3);
260   /* 22 */ map_register(i++, G4);
261   /* 23 */ map_register(i++, G5);
262   /* 24 */ map_register(i++, G0);
263 
264   // the following registers are not normally available
265   /* 25 */ map_register(i++, O7);
266   /* 26 */ map_register(i++, G2);
267   /* 27 */ map_register(i++, O6);
268   /* 28 */ map_register(i++, I6);
269   /* 29 */ map_register(i++, I7);
270   /* 30 */ map_register(i++, G6);
271   /* 31 */ map_register(i++, G7);
272   assert(i == nof_cpu_regs, &quot;number of CPU registers&quot;);
273 
274   for (i = 0; i &lt; nof_fpu_regs; i++) {
275     _fpu_regs[i] = as_FloatRegister(i);
276   }
277 
278   _init_done = true;
279 
280   in_long_opr    = as_long_opr(I0);
281   out_long_opr   = as_long_opr(O0);
282   g1_long_single_opr    = as_long_single_opr(G1);
283 
284   G0_opr = as_opr(G0);
285   G1_opr = as_opr(G1);
286   G2_opr = as_opr(G2);
287   G3_opr = as_opr(G3);
288   G4_opr = as_opr(G4);
289   G5_opr = as_opr(G5);
290   G6_opr = as_opr(G6);
291   G7_opr = as_opr(G7);
292   O0_opr = as_opr(O0);
293   O1_opr = as_opr(O1);
294   O2_opr = as_opr(O2);
295   O3_opr = as_opr(O3);
296   O4_opr = as_opr(O4);
297   O5_opr = as_opr(O5);
298   O6_opr = as_opr(O6);
299   O7_opr = as_opr(O7);
300   L0_opr = as_opr(L0);
301   L1_opr = as_opr(L1);
302   L2_opr = as_opr(L2);
303   L3_opr = as_opr(L3);
304   L4_opr = as_opr(L4);
305   L5_opr = as_opr(L5);
306   L6_opr = as_opr(L6);
307   L7_opr = as_opr(L7);
308   I0_opr = as_opr(I0);
309   I1_opr = as_opr(I1);
310   I2_opr = as_opr(I2);
311   I3_opr = as_opr(I3);
312   I4_opr = as_opr(I4);
313   I5_opr = as_opr(I5);
314   I6_opr = as_opr(I6);
315   I7_opr = as_opr(I7);
316 
317   G0_oop_opr = as_oop_opr(G0);
318   G1_oop_opr = as_oop_opr(G1);
319   G2_oop_opr = as_oop_opr(G2);
320   G3_oop_opr = as_oop_opr(G3);
321   G4_oop_opr = as_oop_opr(G4);
322   G5_oop_opr = as_oop_opr(G5);
323   G6_oop_opr = as_oop_opr(G6);
324   G7_oop_opr = as_oop_opr(G7);
325   O0_oop_opr = as_oop_opr(O0);
326   O1_oop_opr = as_oop_opr(O1);
327   O2_oop_opr = as_oop_opr(O2);
328   O3_oop_opr = as_oop_opr(O3);
329   O4_oop_opr = as_oop_opr(O4);
330   O5_oop_opr = as_oop_opr(O5);
331   O6_oop_opr = as_oop_opr(O6);
332   O7_oop_opr = as_oop_opr(O7);
333   L0_oop_opr = as_oop_opr(L0);
334   L1_oop_opr = as_oop_opr(L1);
335   L2_oop_opr = as_oop_opr(L2);
336   L3_oop_opr = as_oop_opr(L3);
337   L4_oop_opr = as_oop_opr(L4);
338   L5_oop_opr = as_oop_opr(L5);
339   L6_oop_opr = as_oop_opr(L6);
340   L7_oop_opr = as_oop_opr(L7);
341   I0_oop_opr = as_oop_opr(I0);
342   I1_oop_opr = as_oop_opr(I1);
343   I2_oop_opr = as_oop_opr(I2);
344   I3_oop_opr = as_oop_opr(I3);
345   I4_oop_opr = as_oop_opr(I4);
346   I5_oop_opr = as_oop_opr(I5);
347   I6_oop_opr = as_oop_opr(I6);
348   I7_oop_opr = as_oop_opr(I7);
349 
350   G0_metadata_opr = as_metadata_opr(G0);
351   G1_metadata_opr = as_metadata_opr(G1);
352   G2_metadata_opr = as_metadata_opr(G2);
353   G3_metadata_opr = as_metadata_opr(G3);
354   G4_metadata_opr = as_metadata_opr(G4);
355   G5_metadata_opr = as_metadata_opr(G5);
356   G6_metadata_opr = as_metadata_opr(G6);
357   G7_metadata_opr = as_metadata_opr(G7);
358   O0_metadata_opr = as_metadata_opr(O0);
359   O1_metadata_opr = as_metadata_opr(O1);
360   O2_metadata_opr = as_metadata_opr(O2);
361   O3_metadata_opr = as_metadata_opr(O3);
362   O4_metadata_opr = as_metadata_opr(O4);
363   O5_metadata_opr = as_metadata_opr(O5);
364   O6_metadata_opr = as_metadata_opr(O6);
365   O7_metadata_opr = as_metadata_opr(O7);
366   L0_metadata_opr = as_metadata_opr(L0);
367   L1_metadata_opr = as_metadata_opr(L1);
368   L2_metadata_opr = as_metadata_opr(L2);
369   L3_metadata_opr = as_metadata_opr(L3);
370   L4_metadata_opr = as_metadata_opr(L4);
371   L5_metadata_opr = as_metadata_opr(L5);
372   L6_metadata_opr = as_metadata_opr(L6);
373   L7_metadata_opr = as_metadata_opr(L7);
374   I0_metadata_opr = as_metadata_opr(I0);
375   I1_metadata_opr = as_metadata_opr(I1);
376   I2_metadata_opr = as_metadata_opr(I2);
377   I3_metadata_opr = as_metadata_opr(I3);
378   I4_metadata_opr = as_metadata_opr(I4);
379   I5_metadata_opr = as_metadata_opr(I5);
380   I6_metadata_opr = as_metadata_opr(I6);
381   I7_metadata_opr = as_metadata_opr(I7);
382 
383   FP_opr = as_pointer_opr(FP);
384   SP_opr = as_pointer_opr(SP);
385 
386   F0_opr = as_float_opr(F0);
387   F0_double_opr = as_double_opr(F0);
388 
389   Oexception_opr = as_oop_opr(Oexception);
390   Oissuing_pc_opr = as_opr(Oissuing_pc);
391 
392   _caller_save_cpu_regs[0] = FrameMap::O0_opr;
393   _caller_save_cpu_regs[1] = FrameMap::O1_opr;
394   _caller_save_cpu_regs[2] = FrameMap::O2_opr;
395   _caller_save_cpu_regs[3] = FrameMap::O3_opr;
396   _caller_save_cpu_regs[4] = FrameMap::O4_opr;
397   _caller_save_cpu_regs[5] = FrameMap::O5_opr;
398   _caller_save_cpu_regs[6] = FrameMap::G1_opr;
399   _caller_save_cpu_regs[7] = FrameMap::G3_opr;
400   _caller_save_cpu_regs[8] = FrameMap::G4_opr;
401   _caller_save_cpu_regs[9] = FrameMap::G5_opr;
402   for (int i = 0; i &lt; nof_caller_save_fpu_regs; i++) {
403     _caller_save_fpu_regs[i] = LIR_OprFact::single_fpu(i);
404   }
405 }
406 
407 
408 Address FrameMap::make_new_address(ByteSize sp_offset) const {
409   return Address(SP, STACK_BIAS + in_bytes(sp_offset));
410 }
411 
412 
413 VMReg FrameMap::fpu_regname (int n) {
414   return as_FloatRegister(n)-&gt;as_VMReg();
415 }
416 
417 
418 LIR_Opr FrameMap::stack_pointer() {
419   return SP_opr;
420 }
421 
422 
423 // JSR 292
424 LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {
425   assert(L7 == L7_mh_SP_save, &quot;must be same register&quot;);
426   return L7_opr;
427 }
428 
429 
430 bool FrameMap::validate_frame() {
431   int max_offset = in_bytes(framesize_in_bytes());
432   int java_index = 0;
433   for (int i = 0; i &lt; _incoming_arguments-&gt;length(); i++) {
434     LIR_Opr opr = _incoming_arguments-&gt;at(i);
435     if (opr-&gt;is_stack()) {
436       max_offset = MAX2(_argument_locations-&gt;at(java_index), max_offset);
437     }
438     java_index += type2size[opr-&gt;type()];
439   }
440   return Assembler::is_simm13(max_offset + STACK_BIAS);
441 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/sparc/c1_LIRAssembler_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap_sparc.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_sparc.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/c1_LIRAssembler_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -29,20 +29,20 @@</span>
  #include &quot;c1/c1_MacroAssembler.hpp&quot;
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;c1/c1_ValueStack.hpp&quot;
  #include &quot;ci/ciArrayKlass.hpp&quot;
  #include &quot;ci/ciInstance.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;</span>
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;nativeInst_sparc.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  #define __ _masm-&gt;
  
  
  //------------------------------------------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104,12 +104,12 @@</span>
            ((src-&gt;is_double_fpu() || dst-&gt;is_double_fpu()) &amp;&amp; op1-&gt;move_kind() != lir_move_normal)) {
          return false;
        }
  
        if (UseCompressedOops) {
<span class="udiff-line-modified-removed">-         if (dst-&gt;is_address() &amp;&amp; !dst-&gt;is_stack() &amp;&amp; (dst-&gt;type() == T_OBJECT || dst-&gt;type() == T_ARRAY)) return false;</span>
<span class="udiff-line-modified-removed">-         if (src-&gt;is_address() &amp;&amp; !src-&gt;is_stack() &amp;&amp; (src-&gt;type() == T_OBJECT || src-&gt;type() == T_ARRAY)) return false;</span>
<span class="udiff-line-modified-added">+         if (dst-&gt;is_address() &amp;&amp; !dst-&gt;is_stack() &amp;&amp; is_reference_type(dst-&gt;type())) return false;</span>
<span class="udiff-line-modified-added">+         if (src-&gt;is_address() &amp;&amp; !src-&gt;is_stack() &amp;&amp; is_reference_type(src-&gt;type())) return false;</span>
        }
  
        if (UseCompressedClassPointers) {
          if (src-&gt;is_address() &amp;&amp; !src-&gt;is_stack() &amp;&amp; src-&gt;type() == T_ADDRESS &amp;&amp;
              src-&gt;as_address_ptr()-&gt;disp() == oopDesc::klass_offset_in_bytes()) return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -169,10 +169,13 @@</span>
    int offset = __ offset();
    __ inline_cache_check(O0, G5_inline_cache_reg);
    return offset;
  }
  
<span class="udiff-line-added">+ void LIR_Assembler::clinit_barrier(ciMethod* method) {</span>
<span class="udiff-line-added">+   ShouldNotReachHere(); // not implemented</span>
<span class="udiff-line-added">+ }</span>
  
  void LIR_Assembler::osr_entry() {
    // On-stack-replacement entry sequence (interpreter frame layout described in interpreter_sparc.cpp):
    //
    //   1. Create a new compiled activation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -403,11 +406,11 @@</span>
      __ set(NULL_WORD, reg);
    } else {
  #ifdef ASSERT
      {
        ThreadInVMfromNative tiv(JavaThread::current());
<span class="udiff-line-modified-removed">-       assert(Universe::heap()-&gt;is_in_reserved(JNIHandles::resolve(o)), &quot;should be real oop&quot;);</span>
<span class="udiff-line-modified-added">+       assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(o)), &quot;should be real oop&quot;);</span>
      }
  #endif
      int oop_index = __ oop_recorder()-&gt;find_index(o);
      RelocationHolder rspec = oop_Relocation::spec(oop_index);
      __ set(NULL_WORD, reg, rspec); // Will be set when the nmethod is created
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -722,11 +725,11 @@</span>
      assert(!unaligned, &quot;can&#39;t handle this&quot;);
      // for offsets larger than a simm13 we setup the offset in O7
      __ set(offset, O7);
      store_offset = store(from_reg, base, O7, type, wide);
    } else {
<span class="udiff-line-modified-removed">-     if (type == T_ARRAY || type == T_OBJECT) {</span>
<span class="udiff-line-modified-added">+     if (is_reference_type(type)) {</span>
        __ verify_oop(from_reg-&gt;as_register());
      }
      store_offset = code_offset();
      switch (type) {
        case T_BOOLEAN: // fall through
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -783,11 +786,11 @@</span>
    return store_offset;
  }
  
  
  int LIR_Assembler::store(LIR_Opr from_reg, Register base, Register disp, BasicType type, bool wide) {
<span class="udiff-line-modified-removed">-   if (type == T_ARRAY || type == T_OBJECT) {</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(type)) {</span>
      __ verify_oop(from_reg-&gt;as_register());
    }
    int store_offset = code_offset();
    switch (type) {
      case T_BOOLEAN: // fall through
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -883,11 +886,11 @@</span>
            }
            break;
          }
        default      : ShouldNotReachHere();
      }
<span class="udiff-line-modified-removed">-     if (type == T_ARRAY || type == T_OBJECT) {</span>
<span class="udiff-line-modified-added">+     if (is_reference_type(type)) {</span>
        __ verify_oop(to_reg-&gt;as_register());
      }
    }
    return load_offset;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -918,11 +921,11 @@</span>
      case T_LONG  :
        __ ldx(base, disp, to_reg-&gt;as_register_lo());
        break;
      default      : ShouldNotReachHere();
    }
<span class="udiff-line-modified-removed">-   if (type == T_ARRAY || type == T_OBJECT) {</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(type)) {</span>
      __ verify_oop(to_reg-&gt;as_register());
    }
    return load_offset;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1353,11 +1356,11 @@</span>
        __ mov(from_reg-&gt;as_register(), to_reg-&gt;as_register());
      }
    } else {
      ShouldNotReachHere();
    }
<span class="udiff-line-modified-removed">-   if (to_reg-&gt;type() == T_OBJECT || to_reg-&gt;type() == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(to_reg-&gt;type())) {</span>
      __ verify_oop(to_reg-&gt;as_register());
    }
  }
  
  void LIR_Assembler::reg2mem(LIR_Opr from_reg, LIR_Opr dest, BasicType type,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1505,10 +1508,22 @@</span>
                __ cmp(opr1-&gt;as_register(), O7);
              }
            }
            break;
  
<span class="udiff-line-added">+         case T_METADATA:</span>
<span class="udiff-line-added">+           // We only need, for now, comparison with NULL for metadata.</span>
<span class="udiff-line-added">+           { assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);</span>
<span class="udiff-line-added">+             Metadata* m = opr2-&gt;as_constant_ptr()-&gt;as_metadata();</span>
<span class="udiff-line-added">+             if (m == NULL) {</span>
<span class="udiff-line-added">+               __ cmp(opr1-&gt;as_register(), 0);</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+               ShouldNotReachHere();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           break;</span>
<span class="udiff-line-added">+ </span>
          default:
            ShouldNotReachHere();
            break;
        }
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1716,16 +1731,10 @@</span>
        }
      }
    }
  }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void LIR_Assembler::fpop() {</span>
<span class="udiff-line-removed">-   // do nothing</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
    switch (code) {
      case lir_tan: {
        assert(thread-&gt;is_valid(), &quot;preserve the thread object for performance reasons&quot;);
        assert(dest-&gt;as_double_reg() == F0, &quot;the result will be in f0/f1&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2289,12 +2298,12 @@</span>
           op-&gt;tmp4()-&gt;as_register()  == O1 &amp;&amp;
           op-&gt;klass()-&gt;as_register() == G5, &quot;must be&quot;);
  
    __ signx(op-&gt;len()-&gt;as_register());
    if (UseSlowPath ||
<span class="udiff-line-modified-removed">-       (!UseFastNewObjectArray &amp;&amp; (op-&gt;type() == T_OBJECT || op-&gt;type() == T_ARRAY)) ||</span>
<span class="udiff-line-modified-removed">-       (!UseFastNewTypeArray   &amp;&amp; (op-&gt;type() != T_OBJECT &amp;&amp; op-&gt;type() != T_ARRAY))) {</span>
<span class="udiff-line-modified-added">+       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||</span>
<span class="udiff-line-modified-added">+       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {</span>
      __ br(Assembler::always, false, Assembler::pt, *op-&gt;stub()-&gt;entry());
      __ delayed()-&gt;nop();
    } else {
      __ allocate_array(op-&gt;obj()-&gt;as_register(),
                        op-&gt;len()-&gt;as_register(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2642,20 +2651,10 @@</span>
    } else {
      Unimplemented();
    }
  }
  
<span class="udiff-line-removed">- void LIR_Assembler::set_24bit_FPU() {</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void LIR_Assembler::reset_FPU() {</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  void LIR_Assembler::breakpoint() {
    __ breakpoint_trap();
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3041,23 +3040,10 @@</span>
      Register Rhi = left-&gt;as_register_hi();
      __ sub(G0, Rlow, dest-&gt;as_register_lo());
    }
  }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void LIR_Assembler::fxch(int i) {</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void LIR_Assembler::fld(int i) {</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void LIR_Assembler::ffree(int i) {</span>
<span class="udiff-line-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void LIR_Assembler::rt_call(LIR_Opr result, address dest,
                              const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
  
    // if tmp is invalid, then the function being called doesn&#39;t destroy the thread
    if (tmp-&gt;is_valid()) {
</pre>
<center><a href="c1_FrameMap_sparc.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_sparc.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
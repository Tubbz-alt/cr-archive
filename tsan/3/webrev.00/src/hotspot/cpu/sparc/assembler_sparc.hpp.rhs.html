<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/assembler_sparc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_SPARC_ASSEMBLER_SPARC_HPP
  26 #define CPU_SPARC_ASSEMBLER_SPARC_HPP
  27 
  28 #include &quot;asm/register.hpp&quot;
  29 
  30 // The SPARC Assembler: Pure assembler doing NO optimizations on the instruction
  31 // level; i.e., what you write is what you get. The Assembler is generating code
  32 // into a CodeBuffer.
  33 
  34 class Assembler : public AbstractAssembler {
  35   friend class AbstractAssembler;
  36   friend class AddressLiteral;
  37 
  38   // code patchers need various routines like inv_wdisp()
  39   friend class NativeInstruction;
  40   friend class NativeGeneralJump;
  41   friend class Relocation;
  42   friend class Label;
  43 
  44  public:
  45   // op carries format info; see page 62 &amp; 267
  46 
  47   enum ops {
  48     call_op   = 1, // fmt 1
  49     branch_op = 0, // also sethi (fmt2)
  50     arith_op  = 2, // fmt 3, arith &amp; misc
  51     ldst_op   = 3  // fmt 3, load/store
  52   };
  53 
  54   enum op2s {
  55     bpr_op2   = 3,
  56     fb_op2    = 6,
  57     fbp_op2   = 5,
  58     br_op2    = 2,
  59     bp_op2    = 1,
  60     sethi_op2 = 4
  61   };
  62 
  63   enum op3s {
  64     // selected op3s
  65     add_op3      = 0x00,
  66     and_op3      = 0x01,
  67     or_op3       = 0x02,
  68     xor_op3      = 0x03,
  69     sub_op3      = 0x04,
  70     andn_op3     = 0x05,
  71     orn_op3      = 0x06,
  72     xnor_op3     = 0x07,
  73     addc_op3     = 0x08,
  74     mulx_op3     = 0x09,
  75     umul_op3     = 0x0a,
  76     smul_op3     = 0x0b,
  77     subc_op3     = 0x0c,
  78     udivx_op3    = 0x0d,
  79     udiv_op3     = 0x0e,
  80     sdiv_op3     = 0x0f,
  81 
  82     addcc_op3    = 0x10,
  83     andcc_op3    = 0x11,
  84     orcc_op3     = 0x12,
  85     xorcc_op3    = 0x13,
  86     subcc_op3    = 0x14,
  87     andncc_op3   = 0x15,
  88     orncc_op3    = 0x16,
  89     xnorcc_op3   = 0x17,
  90     addccc_op3   = 0x18,
  91     aes4_op3     = 0x19,
  92     umulcc_op3   = 0x1a,
  93     smulcc_op3   = 0x1b,
  94     subccc_op3   = 0x1c,
  95     udivcc_op3   = 0x1e,
  96     sdivcc_op3   = 0x1f,
  97 
  98     taddcc_op3   = 0x20,
  99     tsubcc_op3   = 0x21,
 100     taddcctv_op3 = 0x22,
 101     tsubcctv_op3 = 0x23,
 102     mulscc_op3   = 0x24,
 103     sll_op3      = 0x25,
 104     sllx_op3     = 0x25,
 105     srl_op3      = 0x26,
 106     srlx_op3     = 0x26,
 107     sra_op3      = 0x27,
 108     srax_op3     = 0x27,
 109     rdreg_op3    = 0x28,
 110     membar_op3   = 0x28,
 111 
 112     flushw_op3   = 0x2b,
 113     movcc_op3    = 0x2c,
 114     sdivx_op3    = 0x2d,
 115     popc_op3     = 0x2e,
 116     movr_op3     = 0x2f,
 117 
 118     sir_op3      = 0x30,
 119     wrreg_op3    = 0x30,
 120     saved_op3    = 0x31,
 121 
 122     fpop1_op3    = 0x34,
 123     fpop2_op3    = 0x35,
 124     impdep1_op3  = 0x36,
 125     addx_op3     = 0x36,
 126     aes3_op3     = 0x36,
 127     sha_op3      = 0x36,
 128     bmask_op3    = 0x36,
 129     bshuffle_op3   = 0x36,
 130     alignaddr_op3  = 0x36,
 131     faligndata_op3 = 0x36,
 132     flog3_op3    = 0x36,
 133     edge_op3     = 0x36,
 134     fzero_op3    = 0x36,
 135     fsrc_op3     = 0x36,
 136     fnot_op3     = 0x36,
 137     mpmul_op3    = 0x36,
 138     umulx_op3    = 0x36,
 139     xmulx_op3    = 0x36,
 140     crc32c_op3   = 0x36,
 141     impdep2_op3  = 0x37,
 142     stpartialf_op3 = 0x37,
 143     jmpl_op3     = 0x38,
 144     rett_op3     = 0x39,
 145     trap_op3     = 0x3a,
 146     flush_op3    = 0x3b,
 147     save_op3     = 0x3c,
 148     restore_op3  = 0x3d,
 149     done_op3     = 0x3e,
 150     retry_op3    = 0x3e,
 151 
 152     lduw_op3     = 0x00,
 153     ldub_op3     = 0x01,
 154     lduh_op3     = 0x02,
 155     ldd_op3      = 0x03,
 156     stw_op3      = 0x04,
 157     stb_op3      = 0x05,
 158     sth_op3      = 0x06,
 159     std_op3      = 0x07,
 160     ldsw_op3     = 0x08,
 161     ldsb_op3     = 0x09,
 162     ldsh_op3     = 0x0a,
 163     ldx_op3      = 0x0b,
 164 
 165     stx_op3      = 0x0e,
 166     swap_op3     = 0x0f,
 167 
 168     stwa_op3     = 0x14,
 169     stxa_op3     = 0x1e,
 170 
 171     ldf_op3      = 0x20,
 172     ldfsr_op3    = 0x21,
 173     ldqf_op3     = 0x22,
 174     lddf_op3     = 0x23,
 175     stf_op3      = 0x24,
 176     stfsr_op3    = 0x25,
 177     stqf_op3     = 0x26,
 178     stdf_op3     = 0x27,
 179 
 180     prefetch_op3 = 0x2d,
 181 
 182     casa_op3     = 0x3c,
 183     casxa_op3    = 0x3e,
 184 
 185     mftoi_op3    = 0x36,
 186 
 187     alt_bit_op3  = 0x10,
 188      cc_bit_op3  = 0x10
 189   };
 190 
 191   enum opfs {
 192     // selected opfs
 193     edge8n_opf         = 0x01,
 194 
 195     fmovs_opf          = 0x01,
 196     fmovd_opf          = 0x02,
 197 
 198     fnegs_opf          = 0x05,
 199     fnegd_opf          = 0x06,
 200 
 201     addxc_opf          = 0x11,
 202     addxccc_opf        = 0x13,
 203     umulxhi_opf        = 0x16,
 204     alignaddr_opf      = 0x18,
 205     bmask_opf          = 0x19,
 206 
 207     fadds_opf          = 0x41,
 208     faddd_opf          = 0x42,
 209     fsubs_opf          = 0x45,
 210     fsubd_opf          = 0x46,
 211 
 212     faligndata_opf     = 0x48,
 213 
 214     fmuls_opf          = 0x49,
 215     fmuld_opf          = 0x4a,
 216     bshuffle_opf       = 0x4c,
 217     fdivs_opf          = 0x4d,
 218     fdivd_opf          = 0x4e,
 219 
 220     fcmps_opf          = 0x51,
 221     fcmpd_opf          = 0x52,
 222 
 223     fstox_opf          = 0x81,
 224     fdtox_opf          = 0x82,
 225     fxtos_opf          = 0x84,
 226     fxtod_opf          = 0x88,
 227     fitos_opf          = 0xc4,
 228     fdtos_opf          = 0xc6,
 229     fitod_opf          = 0xc8,
 230     fstod_opf          = 0xc9,
 231     fstoi_opf          = 0xd1,
 232     fdtoi_opf          = 0xd2,
 233 
 234     mdtox_opf          = 0x110,
 235     mstouw_opf         = 0x111,
 236     mstosw_opf         = 0x113,
 237     xmulx_opf          = 0x115,
 238     xmulxhi_opf        = 0x116,
 239     mxtod_opf          = 0x118,
 240     mwtos_opf          = 0x119,
 241 
 242     aes_kexpand0_opf   = 0x130,
 243     aes_kexpand2_opf   = 0x131,
 244 
 245     sha1_opf           = 0x141,
 246     sha256_opf         = 0x142,
 247     sha512_opf         = 0x143,
 248 
 249     crc32c_opf         = 0x147,
 250     mpmul_opf          = 0x148
 251   };
 252 
 253   enum op5s {
 254     aes_eround01_op5   = 0x00,
 255     aes_eround23_op5   = 0x01,
 256     aes_dround01_op5   = 0x02,
 257     aes_dround23_op5   = 0x03,
 258     aes_eround01_l_op5 = 0x04,
 259     aes_eround23_l_op5 = 0x05,
 260     aes_dround01_l_op5 = 0x06,
 261     aes_dround23_l_op5 = 0x07,
 262     aes_kexpand1_op5   = 0x08
 263   };
 264 
 265   enum RCondition { rc_z = 1, rc_lez = 2, rc_lz = 3, rc_nz = 5, rc_gz = 6, rc_gez = 7, rc_last = rc_gez };
 266 
 267   enum Condition {
 268      // for FBfcc &amp; FBPfcc instruction
 269     f_never                     = 0,
 270     f_notEqual                  = 1,
 271     f_notZero                   = 1,
 272     f_lessOrGreater             = 2,
 273     f_unorderedOrLess           = 3,
 274     f_less                      = 4,
 275     f_unorderedOrGreater        = 5,
 276     f_greater                   = 6,
 277     f_unordered                 = 7,
 278     f_always                    = 8,
 279     f_equal                     = 9,
 280     f_zero                      = 9,
 281     f_unorderedOrEqual          = 10,
 282     f_greaterOrEqual            = 11,
 283     f_unorderedOrGreaterOrEqual = 12,
 284     f_lessOrEqual               = 13,
 285     f_unorderedOrLessOrEqual    = 14,
 286     f_ordered                   = 15,
 287 
 288     // for integers
 289 
 290     never                = 0,
 291     equal                = 1,
 292     zero                 = 1,
 293     lessEqual            = 2,
 294     less                 = 3,
 295     lessEqualUnsigned    = 4,
 296     lessUnsigned         = 5,
 297     carrySet             = 5,
 298     negative             = 6,
 299     overflowSet          = 7,
 300     always               = 8,
 301     notEqual             = 9,
 302     notZero              = 9,
 303     greater              = 10,
 304     greaterEqual         = 11,
 305     greaterUnsigned      = 12,
 306     greaterEqualUnsigned = 13,
 307     carryClear           = 13,
 308     positive             = 14,
 309     overflowClear        = 15
 310   };
 311 
 312   enum CC {
 313     // ptr_cc is the correct condition code for a pointer or intptr_t:
 314     icc  = 0, xcc  = 2, ptr_cc = xcc,
 315     fcc0 = 0, fcc1 = 1, fcc2 = 2, fcc3 = 3
 316   };
 317 
 318   enum PrefetchFcn {
 319     severalReads = 0, oneRead = 1, severalWritesAndPossiblyReads = 2, oneWrite = 3, page = 4
 320   };
 321 
 322  public:
 323   // Helper functions for groups of instructions
 324 
 325   enum Predict { pt = 1, pn = 0 }; // pt = predict taken
 326 
 327   enum Membar_mask_bits { // page 184, v9
 328     StoreStore = 1 &lt;&lt; 3,
 329     LoadStore  = 1 &lt;&lt; 2,
 330     StoreLoad  = 1 &lt;&lt; 1,
 331     LoadLoad   = 1 &lt;&lt; 0,
 332 
 333     Sync       = 1 &lt;&lt; 6,
 334     MemIssue   = 1 &lt;&lt; 5,
 335     Lookaside  = 1 &lt;&lt; 4
 336   };
 337 
<a name="1" id="anc1"></a><span class="line-added"> 338   //---&lt;  calculate length of instruction  &gt;---</span>
<span class="line-added"> 339   // With SPARC being a RISC architecture, this always is BytesPerInstWord</span>
<span class="line-added"> 340   // instruction must start at passed address</span>
<span class="line-added"> 341   static unsigned int instr_len(unsigned char *instr) { return BytesPerInstWord; }</span>
<span class="line-added"> 342 </span>
<span class="line-added"> 343   //---&lt;  longest instructions  &gt;---</span>
<span class="line-added"> 344   static unsigned int instr_maxlen() { return BytesPerInstWord; }</span>
<span class="line-added"> 345 </span>
 346   static bool is_in_wdisp_range(address a, address b, int nbits) {
 347     intptr_t d = intptr_t(b) - intptr_t(a);
 348     return is_simm(d, nbits + 2);
 349   }
 350 
 351   address target_distance(Label &amp;L) {
 352     // Assembler::target(L) should be called only when
 353     // a branch instruction is emitted since non-bound
 354     // labels record current pc() as a branch address.
 355     if (L.is_bound()) return target(L);
 356     // Return current address for non-bound labels.
 357     return pc();
 358   }
 359 
 360   // test if label is in simm16 range in words (wdisp16).
 361   bool is_in_wdisp16_range(Label &amp;L) {
 362     return is_in_wdisp_range(target_distance(L), pc(), 16);
 363   }
 364   // test if the distance between two addresses fits in simm30 range in words
 365   static bool is_in_wdisp30_range(address a, address b) {
 366     return is_in_wdisp_range(a, b, 30);
 367   }
 368 
 369   enum ASIs { // page 72, v9
 370     ASI_PRIMARY            = 0x80,
 371     ASI_PRIMARY_NOFAULT    = 0x82,
 372     ASI_PRIMARY_LITTLE     = 0x88,
 373     // 8x8-bit partial store
 374     ASI_PST8_PRIMARY       = 0xC0,
 375     // Block initializing store
 376     ASI_ST_BLKINIT_PRIMARY = 0xE2,
 377     // Most-Recently-Used (MRU) BIS variant
 378     ASI_ST_BLKINIT_MRU_PRIMARY = 0xF2
 379     // add more from book as needed
 380   };
 381 
 382  protected:
 383   // helpers
 384 
 385   // x is supposed to fit in a field &quot;nbits&quot; wide
 386   // and be sign-extended. Check the range.
 387 
 388   static void assert_signed_range(intptr_t x, int nbits) {
 389     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 390            &quot;value out of range: x=&quot; INTPTR_FORMAT &quot;, nbits=%d&quot;, x, nbits);
 391   }
 392 
 393   static void assert_signed_word_disp_range(intptr_t x, int nbits) {
 394     assert((x &amp; 3) == 0, &quot;not word aligned&quot;);
 395     assert_signed_range(x, nbits + 2);
 396   }
 397 
 398   static void assert_unsigned_range(int x, int nbits) {
 399     assert(juint(x) &lt; juint(1 &lt;&lt; nbits), &quot;unsigned constant out of range&quot;);
 400   }
 401 
 402   // fields: note bits numbered from LSB = 0, fields known by inclusive bit range
 403 
 404   static int fmask(juint hi_bit, juint lo_bit) {
 405     assert(hi_bit &gt;= lo_bit &amp;&amp; 0 &lt;= lo_bit &amp;&amp; hi_bit &lt; 32, &quot;bad bits&quot;);
 406     return (1 &lt;&lt; (hi_bit-lo_bit + 1)) - 1;
 407   }
 408 
 409   // inverse of u_field
 410 
 411   static int inv_u_field(int x, int hi_bit, int lo_bit) {
 412     juint r = juint(x) &gt;&gt; lo_bit;
 413     r &amp;= fmask(hi_bit, lo_bit);
 414     return int(r);
 415   }
 416 
 417   // signed version: extract from field and sign-extend
 418 
 419   static int inv_s_field(int x, int hi_bit, int lo_bit) {
 420     int sign_shift = 31 - hi_bit;
 421     return inv_u_field(((x &lt;&lt; sign_shift) &gt;&gt; sign_shift), hi_bit, lo_bit);
 422   }
 423 
 424   // given a field that ranges from hi_bit to lo_bit (inclusive,
 425   // LSB = 0), and an unsigned value for the field,
 426   // shift it into the field
 427 
 428 #ifdef ASSERT
 429   static int u_field(int x, int hi_bit, int lo_bit) {
 430     assert((x &amp; ~fmask(hi_bit, lo_bit)) == 0,
 431             &quot;value out of range&quot;);
 432     int r = x &lt;&lt; lo_bit;
 433     assert(inv_u_field(r, hi_bit, lo_bit) == x, &quot;just checking&quot;);
 434     return r;
 435   }
 436 #else
 437   // make sure this is inlined as it will reduce code size significantly
 438   #define u_field(x, hi_bit, lo_bit) ((x) &lt;&lt; (lo_bit))
 439 #endif
 440 
 441   static int inv_op(int x)   { return inv_u_field(x, 31, 30); }
 442   static int inv_op2(int x)  { return inv_u_field(x, 24, 22); }
 443   static int inv_op3(int x)  { return inv_u_field(x, 24, 19); }
 444   static int inv_cond(int x) { return inv_u_field(x, 28, 25); }
 445 
 446   static bool inv_immed(int x)   { return (x &amp; Assembler::immed(true)) != 0; }
 447 
 448   static Register inv_rd(int x)  { return as_Register(inv_u_field(x, 29, 25)); }
 449   static Register inv_rs1(int x) { return as_Register(inv_u_field(x, 18, 14)); }
 450   static Register inv_rs2(int x) { return as_Register(inv_u_field(x,  4,  0)); }
 451 
 452   static int op(int x)           { return u_field(x,             31, 30); }
 453   static int rd(Register r)      { return u_field(r-&gt;encoding(), 29, 25); }
 454   static int fcn(int x)          { return u_field(x,             29, 25); }
 455   static int op3(int x)          { return u_field(x,             24, 19); }
 456   static int rs1(Register r)     { return u_field(r-&gt;encoding(), 18, 14); }
 457   static int rs2(Register r)     { return u_field(r-&gt;encoding(),  4,  0); }
 458   static int annul(bool a)       { return u_field(a ? 1 : 0,     29, 29); }
 459   static int cond(int x)         { return u_field(x,             28, 25); }
 460   static int cond_mov(int x)     { return u_field(x,             17, 14); }
 461   static int rcond(RCondition x) { return u_field(x,             12, 10); }
 462   static int op2(int x)          { return u_field(x,             24, 22); }
 463   static int predict(bool p)     { return u_field(p ? 1 : 0,     19, 19); }
 464   static int branchcc(CC fcca)   { return u_field(fcca,          21, 20); }
 465   static int cmpcc(CC fcca)      { return u_field(fcca,          26, 25); }
 466   static int imm_asi(int x)      { return u_field(x,             12,  5); }
 467   static int immed(bool i)       { return u_field(i ? 1 : 0,     13, 13); }
 468   static int opf_low6(int w)     { return u_field(w,             10,  5); }
 469   static int opf_low5(int w)     { return u_field(w,              9,  5); }
 470   static int op5(int x)          { return u_field(x,              8,  5); }
 471   static int trapcc(CC cc)       { return u_field(cc,            12, 11); }
 472   static int sx(int i)           { return u_field(i,             12, 12); } // shift x=1 means 64-bit
 473   static int opf(int x)          { return u_field(x,             13,  5); }
 474 
 475   static bool is_cbcond(int x) {
 476     return (VM_Version::has_cbcond() &amp;&amp; (inv_cond(x) &gt; rc_last) &amp;&amp;
 477             inv_op(x) == branch_op &amp;&amp; inv_op2(x) == bpr_op2);
 478   }
 479   static bool is_cxb(int x) {
 480     assert(is_cbcond(x), &quot;wrong instruction&quot;);
 481     return (x &amp; (1 &lt;&lt; 21)) != 0;
 482   }
 483   static bool is_branch(int x) {
 484     if (inv_op(x) != Assembler::branch_op) return false;
 485 
 486     bool is_bpr = inv_op2(x) == Assembler::bpr_op2;
 487     bool is_bp  = inv_op2(x) == Assembler::bp_op2;
 488     bool is_br  = inv_op2(x) == Assembler::br_op2;
 489     bool is_fp  = inv_op2(x) == Assembler::fb_op2;
 490     bool is_fbp = inv_op2(x) == Assembler::fbp_op2;
 491 
 492     return is_bpr || is_bp || is_br || is_fp || is_fbp;
 493   }
 494   static bool is_call(int x) {
 495     return inv_op(x) == Assembler::call_op;
 496   }
 497   static bool is_jump(int x) {
 498     if (inv_op(x) != Assembler::arith_op) return false;
 499 
 500     bool is_jmpl = inv_op3(x) == Assembler::jmpl_op3;
 501     bool is_rett = inv_op3(x) == Assembler::rett_op3;
 502 
 503     return is_jmpl || is_rett;
 504   }
 505   static bool is_rdpc(int x) {
 506     return (inv_op(x) == Assembler::arith_op &amp;&amp; inv_op3(x) == Assembler::rdreg_op3 &amp;&amp;
 507             inv_u_field(x, 18, 14) == 5);
 508   }
 509   static bool is_cti(int x) {
 510       return is_branch(x) || is_call(x) || is_jump(x); // Ignoring done/retry
 511   }
 512 
 513   static int cond_cbcond(int x) { return  u_field((((x &amp; 8) &lt;&lt; 1) + 8 + (x &amp; 7)), 29, 25); }
 514   static int inv_cond_cbcond(int x) {
 515     assert(is_cbcond(x), &quot;wrong instruction&quot;);
 516     return inv_u_field(x, 27, 25) | (inv_u_field(x, 29, 29) &lt;&lt; 3);
 517   }
 518 
 519   static int opf_cc(CC c, bool useFloat) { return u_field((useFloat ? 0 : 4) + c, 13, 11); }
 520   static int mov_cc(CC c, bool useFloat) { return u_field(useFloat ? 0 : 1, 18, 18) | u_field(c, 12, 11); }
 521 
 522   static int fd(FloatRegister r, FloatRegisterImpl::Width fwa)  { return u_field(r-&gt;encoding(fwa), 29, 25); };
 523   static int fs1(FloatRegister r, FloatRegisterImpl::Width fwa) { return u_field(r-&gt;encoding(fwa), 18, 14); };
 524   static int fs2(FloatRegister r, FloatRegisterImpl::Width fwa) { return u_field(r-&gt;encoding(fwa),  4,  0); };
 525   static int fs3(FloatRegister r, FloatRegisterImpl::Width fwa) { return u_field(r-&gt;encoding(fwa), 13,  9); };
 526 
 527   // some float instructions use this encoding on the op3 field
 528   static int alt_op3(int op, FloatRegisterImpl::Width w) {
 529     int r;
 530     switch(w) {
 531      case FloatRegisterImpl::S: r = op + 0;  break;
 532      case FloatRegisterImpl::D: r = op + 3;  break;
 533      case FloatRegisterImpl::Q: r = op + 2;  break;
 534      default: ShouldNotReachHere(); break;
 535     }
 536     return op3(r);
 537   }
 538 
 539   // compute inverse of simm
 540   static int inv_simm(int x, int nbits) {
 541     return (int)(x &lt;&lt; (32 - nbits)) &gt;&gt; (32 - nbits);
 542   }
 543 
 544   static int inv_simm13(int x) { return inv_simm(x, 13); }
 545 
 546   // signed immediate, in low bits, nbits long
 547   static int simm(int x, int nbits) {
 548     assert_signed_range(x, nbits);
 549     return x &amp; ((1 &lt;&lt; nbits) - 1);
 550   }
 551 
 552   // unsigned immediate, in low bits, at most nbits long.
 553   static int uimm(int x, int nbits) {
 554     assert_unsigned_range(x, nbits);
 555     return x &amp; ((1 &lt;&lt; nbits) - 1);
 556   }
 557 
 558   // compute inverse of wdisp16
 559   static intptr_t inv_wdisp16(int x, intptr_t pos) {
 560     int lo = x &amp; ((1 &lt;&lt; 14) - 1);
 561     int hi = (x &gt;&gt; 20) &amp; 3;
 562     if (hi &gt;= 2) hi |= ~1;
 563     return (((hi &lt;&lt; 14) | lo) &lt;&lt; 2) + pos;
 564   }
 565 
 566   // word offset, 14 bits at LSend, 2 bits at B21, B20
 567   static int wdisp16(intptr_t x, intptr_t off) {
 568     intptr_t xx = x - off;
 569     assert_signed_word_disp_range(xx, 16);
 570     int r = (xx &gt;&gt; 2) &amp; ((1 &lt;&lt; 14) - 1) | (((xx &gt;&gt; (2+14)) &amp; 3) &lt;&lt; 20);
 571     assert(inv_wdisp16(r, off) == x, &quot;inverse is not inverse&quot;);
 572     return r;
 573   }
 574 
 575   // compute inverse of wdisp10
 576   static intptr_t inv_wdisp10(int x, intptr_t pos) {
 577     assert(is_cbcond(x), &quot;wrong instruction&quot;);
 578     int lo = inv_u_field(x, 12, 5);
 579     int hi = (x &gt;&gt; 19) &amp; 3;
 580     if (hi &gt;= 2) hi |= ~1;
 581     return (((hi &lt;&lt; 8) | lo) &lt;&lt; 2) + pos;
 582   }
 583 
 584   // word offset for cbcond, 8 bits at [B12,B5], 2 bits at [B20,B19]
 585   static int wdisp10(intptr_t x, intptr_t off) {
 586     assert(VM_Version::has_cbcond(), &quot;This CPU does not have CBCOND instruction&quot;);
 587     intptr_t xx = x - off;
 588     assert_signed_word_disp_range(xx, 10);
 589     int r = (((xx &gt;&gt; 2) &amp; ((1 &lt;&lt; 8) - 1)) &lt;&lt; 5) | (((xx &gt;&gt; (2+8)) &amp; 3) &lt;&lt; 19);
 590     // Have to fake cbcond instruction to pass assert in inv_wdisp10()
 591     assert(inv_wdisp10((r | op(branch_op) | cond_cbcond(rc_last+1) | op2(bpr_op2)), off) == x, &quot;inverse is not inverse&quot;);
 592     return r;
 593   }
 594 
 595   // word displacement in low-order nbits bits
 596 
 597   static intptr_t inv_wdisp(int x, intptr_t pos, int nbits) {
 598     int pre_sign_extend = x &amp; ((1 &lt;&lt; nbits) - 1);
 599     int r = (pre_sign_extend &gt;= (1 &lt;&lt; (nbits - 1)) ?
 600              pre_sign_extend | ~((1 &lt;&lt; nbits) - 1) : pre_sign_extend);
 601     return (r &lt;&lt; 2) + pos;
 602   }
 603 
 604   static int wdisp(intptr_t x, intptr_t off, int nbits) {
 605     intptr_t xx = x - off;
 606     assert_signed_word_disp_range(xx, nbits);
 607     int r = (xx &gt;&gt; 2) &amp; ((1 &lt;&lt; nbits) - 1);
 608     assert(inv_wdisp(r, off, nbits) == x, &quot;inverse not inverse&quot;);
 609     return r;
 610   }
 611 
 612 
 613   // Extract the top 32 bits in a 64 bit word
 614   static int32_t hi32(int64_t x) {
 615     int32_t r = int32_t((uint64_t)x &gt;&gt; 32);
 616     return r;
 617   }
 618 
 619   // given a sethi instruction, extract the constant, left-justified
 620   static int inv_hi22(int x) {
 621     return x &lt;&lt; 10;
 622   }
 623 
 624   // create an imm22 field, given a 32-bit left-justified constant
 625   static int hi22(int x) {
 626     int r = int(juint(x) &gt;&gt; 10);
 627     assert((r &amp; ~((1 &lt;&lt; 22) - 1)) == 0, &quot;just checkin&#39;&quot;);
 628     return r;
 629   }
 630 
 631   // create a low10 __value__ (not a field) for a given a 32-bit constant
 632   static int low10(int x) {
 633     return x &amp; ((1 &lt;&lt; 10) - 1);
 634   }
 635 
 636   // create a low12 __value__ (not a field) for a given a 32-bit constant
 637   static int low12(int x) {
 638     return x &amp; ((1 &lt;&lt; 12) - 1);
 639   }
 640 
 641   // AES crypto instructions supported only on certain processors
 642   static void aes_only() { assert(VM_Version::has_aes(), &quot;This instruction only works on SPARC with AES instructions support&quot;); }
 643 
 644   // SHA crypto instructions supported only on certain processors
 645   static void sha1_only()   { assert(VM_Version::has_sha1(),   &quot;This instruction only works on SPARC with SHA1&quot;); }
 646   static void sha256_only() { assert(VM_Version::has_sha256(), &quot;This instruction only works on SPARC with SHA256&quot;); }
 647   static void sha512_only() { assert(VM_Version::has_sha512(), &quot;This instruction only works on SPARC with SHA512&quot;); }
 648 
 649   // CRC32C instruction supported only on certain processors
 650   static void crc32c_only() { assert(VM_Version::has_crc32c(), &quot;This instruction only works on SPARC with CRC32C&quot;); }
 651 
 652   // FMAf instructions supported only on certain processors
 653   static void fmaf_only() { assert(VM_Version::has_fmaf(), &quot;This instruction only works on SPARC with FMAf&quot;); }
 654 
 655   // MPMUL instruction supported only on certain processors
 656   static void mpmul_only() { assert(VM_Version::has_mpmul(), &quot;This instruction only works on SPARC with MPMUL&quot;); }
 657 
 658   // instruction only in VIS1
 659   static void vis1_only() { assert(VM_Version::has_vis1(), &quot;This instruction only works on SPARC with VIS1&quot;); }
 660 
 661   // instruction only in VIS2
 662   static void vis2_only() { assert(VM_Version::has_vis2(), &quot;This instruction only works on SPARC with VIS2&quot;); }
 663 
 664   // instruction only in VIS3
 665   static void vis3_only() { assert(VM_Version::has_vis3(), &quot;This instruction only works on SPARC with VIS3&quot;); }
 666 
 667   // instruction deprecated in v9
 668   static void v9_dep() { } // do nothing for now
 669 
 670  protected:
 671 #ifdef ASSERT
 672 #define VALIDATE_PIPELINE
 673 #endif
 674 
 675 #ifdef VALIDATE_PIPELINE
 676   // A simple delay-slot scheme:
 677   // In order to check the programmer, the assembler keeps track of delay-slots.
 678   // It forbids CTIs in delay-slots (conservative, but should be OK). Also, when
 679   // emitting an instruction into a delay-slot, you must do so using delayed(),
 680   // e.g. asm-&gt;delayed()-&gt;add(...), in order to check that you do not omit the
 681   // delay-slot instruction. To implement this, we use a simple FSA.
 682   enum { NoDelay, AtDelay, FillDelay } _delay_state;
 683 
 684   // A simple hazard scheme:
 685   // In order to avoid pipeline stalls, due to single cycle pipeline hazards, we
 686   // adopt a simplistic state tracking mechanism that will enforce an additional
 687   // &#39;nop&#39; instruction to be inserted prior to emitting an instruction that can
 688   // expose a given hazard (currently, PC-related hazards only).
 689   enum { NoHazard, PcHazard } _hazard_state;
 690 #endif
 691 
 692  public:
 693   // Tell the assembler that the next instruction must NOT be in delay-slot.
 694   // Use at start of multi-instruction macros.
 695   void assert_not_delayed() {
 696     // This is a separate entry to avoid the creation of string constants in
 697     // non-asserted code, with some compilers this pollutes the object code.
 698 #ifdef VALIDATE_PIPELINE
 699     assert_no_delay(&quot;Next instruction should not be in a delay-slot.&quot;);
 700 #endif
 701   }
 702 
 703  protected:
 704   void assert_no_delay(const char* msg) {
 705 #ifdef VALIDATE_PIPELINE
 706     assert(_delay_state == NoDelay, msg);
 707 #endif
 708   }
 709 
 710   void assert_no_hazard() {
 711 #ifdef VALIDATE_PIPELINE
 712     assert(_hazard_state == NoHazard, &quot;Unsolicited pipeline hazard.&quot;);
 713 #endif
 714   }
 715 
 716  private:
 717   inline int32_t prev_insn() {
 718     assert(offset() &gt; 0, &quot;Interface violation.&quot;);
 719     int32_t* addr = (int32_t*)pc() - 1;
 720     return *addr;
 721   }
 722 
 723 #ifdef VALIDATE_PIPELINE
 724   void validate_no_pipeline_hazards();
 725 #endif
 726 
 727  protected:
 728   // Avoid possible pipeline stall by inserting an additional &#39;nop&#39; instruction,
 729   // if the previous instruction is a &#39;cbcond&#39; or a &#39;rdpc&#39;.
 730   inline void avoid_pipeline_stall();
 731 
 732   // A call to cti() is made before emitting a control-transfer instruction (CTI)
 733   // in order to assert a CTI is not emitted right after a &#39;cbcond&#39;, nor in the
 734   // delay-slot of another CTI. Only effective when assertions are enabled.
 735   void cti() {
 736     // A &#39;cbcond&#39; or &#39;rdpc&#39; instruction immediately followed by a CTI introduces
 737     // a pipeline stall, which we make sure to prohibit.
 738     assert_no_cbcond_before();
 739     assert_no_rdpc_before();
 740 #ifdef VALIDATE_PIPELINE
 741     assert_no_hazard();
 742     assert_no_delay(&quot;CTI in delay-slot.&quot;);
 743 #endif
 744   }
 745 
 746   // Called when emitting CTI with a delay-slot, AFTER emitting.
 747   inline void induce_delay_slot() {
 748 #ifdef VALIDATE_PIPELINE
 749     assert_no_delay(&quot;Already in delay-slot.&quot;);
 750     _delay_state = AtDelay;
 751 #endif
 752   }
 753 
 754   inline void induce_pc_hazard() {
 755 #ifdef VALIDATE_PIPELINE
 756     assert_no_hazard();
 757     _hazard_state = PcHazard;
 758 #endif
 759   }
 760 
 761   bool is_cbcond_before() { return offset() &gt; 0 ? is_cbcond(prev_insn()) : false; }
 762 
 763   bool is_rdpc_before() { return offset() &gt; 0 ? is_rdpc(prev_insn()) : false; }
 764 
 765   void assert_no_cbcond_before() {
 766     assert(offset() == 0 || !is_cbcond_before(), &quot;CBCOND should not be followed by CTI.&quot;);
 767   }
 768 
 769   void assert_no_rdpc_before() {
 770     assert(offset() == 0 || !is_rdpc_before(), &quot;RDPC should not be followed by CTI.&quot;);
 771   }
 772 
 773  public:
 774 
 775   bool use_cbcond(Label &amp;L) {
 776     if (!UseCBCond || is_cbcond_before()) return false;
 777     intptr_t x = intptr_t(target_distance(L)) - intptr_t(pc());
 778     assert((x &amp; 3) == 0, &quot;not word aligned&quot;);
 779     return is_simm12(x);
 780   }
 781 
 782   // Tells assembler you know that next instruction is delayed
 783   Assembler* delayed() {
 784 #ifdef VALIDATE_PIPELINE
 785     assert(_delay_state == AtDelay, &quot;Delayed instruction not in delay-slot.&quot;);
 786     _delay_state = FillDelay;
 787 #endif
 788     return this;
 789   }
 790 
 791   void flush() {
 792 #ifdef VALIDATE_PIPELINE
 793     assert(_delay_state == NoDelay, &quot;Ending code with a delay-slot.&quot;);
 794 #ifdef COMPILER2
 795     validate_no_pipeline_hazards();
 796 #endif
 797 #endif
 798     AbstractAssembler::flush();
 799   }
 800 
 801   inline void emit_int32(int32_t);  // shadows AbstractAssembler::emit_int32
 802   inline void emit_data(int32_t);
 803   inline void emit_data(int32_t, RelocationHolder const&amp;);
 804   inline void emit_data(int32_t, relocInfo::relocType rtype);
 805 
 806   // Helper for the above functions.
 807   inline void check_delay();
 808 
 809 
 810  public:
 811   // instructions, refer to page numbers in the SPARC Architecture Manual, V9
 812 
 813   // pp 135
 814 
 815   inline void add(Register s1, Register s2, Register d);
 816   inline void add(Register s1, int simm13a, Register d);
 817 
 818   inline void addcc(Register s1, Register s2, Register d);
 819   inline void addcc(Register s1, int simm13a, Register d);
 820   inline void addc(Register s1, Register s2, Register d);
 821   inline void addc(Register s1, int simm13a, Register d);
 822   inline void addccc(Register s1, Register s2, Register d);
 823   inline void addccc(Register s1, int simm13a, Register d);
 824 
 825 
 826   // 4-operand AES instructions
 827 
 828   inline void aes_eround01(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 829   inline void aes_eround23(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 830   inline void aes_dround01(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 831   inline void aes_dround23(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 832   inline void aes_eround01_l(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 833   inline void aes_eround23_l(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 834   inline void aes_dround01_l(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 835   inline void aes_dround23_l(FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 836   inline void aes_kexpand1(FloatRegister s1, FloatRegister s2, int imm5a, FloatRegister d);
 837 
 838 
 839   // 3-operand AES instructions
 840 
 841   inline void aes_kexpand0(FloatRegister s1, FloatRegister s2, FloatRegister d);
 842   inline void aes_kexpand2(FloatRegister s1, FloatRegister s2, FloatRegister d);
 843 
 844   // pp 136
 845 
 846   inline void bpr(RCondition c, bool a, Predict p, Register s1, address d, relocInfo::relocType rt = relocInfo::none);
 847   inline void bpr(RCondition c, bool a, Predict p, Register s1, Label &amp;L);
 848 
 849   // compare and branch
 850   inline void cbcond(Condition c, CC cc, Register s1, Register s2, Label &amp;L);
 851   inline void cbcond(Condition c, CC cc, Register s1, int simm5, Label &amp;L);
 852 
 853  protected: // use MacroAssembler::br instead
 854 
 855   // pp 138
 856 
 857   inline void fb(Condition c, bool a, address d, relocInfo::relocType rt = relocInfo::none);
 858   inline void fb(Condition c, bool a, Label &amp;L);
 859 
 860   // pp 141
 861 
 862   inline void fbp(Condition c, bool a, CC cc, Predict p, address d, relocInfo::relocType rt = relocInfo::none);
 863   inline void fbp(Condition c, bool a, CC cc, Predict p, Label &amp;L);
 864 
 865   // pp 144
 866 
 867   inline void br(Condition c, bool a, address d, relocInfo::relocType rt = relocInfo::none);
 868   inline void br(Condition c, bool a, Label &amp;L);
 869 
 870   // pp 146
 871 
 872   inline void bp(Condition c, bool a, CC cc, Predict p, address d, relocInfo::relocType rt = relocInfo::none);
 873   inline void bp(Condition c, bool a, CC cc, Predict p, Label &amp;L);
 874 
 875   // pp 149
 876 
 877   inline void call(address d, relocInfo::relocType rt = relocInfo::runtime_call_type);
 878   inline void call(Label &amp;L,  relocInfo::relocType rt = relocInfo::runtime_call_type);
 879 
 880   inline void call(address d, RelocationHolder const &amp;rspec);
 881 
 882  public:
 883 
 884   // pp 150
 885 
 886   // These instructions compare the contents of s2 with the contents of
 887   // memory at address in s1. If the values are equal, the contents of memory
 888   // at address s1 is swapped with the data in d. If the values are not equal,
 889   // the the contents of memory at s1 is loaded into d, without the swap.
 890 
 891   inline void casa(Register s1, Register s2, Register d, int ia = -1);
 892   inline void casxa(Register s1, Register s2, Register d, int ia = -1);
 893 
 894   // pp 152
 895 
 896   inline void udiv(Register s1, Register s2, Register d);
 897   inline void udiv(Register s1, int simm13a, Register d);
 898   inline void sdiv(Register s1, Register s2, Register d);
 899   inline void sdiv(Register s1, int simm13a, Register d);
 900   inline void udivcc(Register s1, Register s2, Register d);
 901   inline void udivcc(Register s1, int simm13a, Register d);
 902   inline void sdivcc(Register s1, Register s2, Register d);
 903   inline void sdivcc(Register s1, int simm13a, Register d);
 904 
 905   // pp 155
 906 
 907   inline void done();
 908   inline void retry();
 909 
 910   // pp 156
 911 
 912   inline void fadd(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister d);
 913   inline void fsub(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister d);
 914 
 915   // pp 157
 916 
 917   inline void fcmp(FloatRegisterImpl::Width w, CC cc, FloatRegister s1, FloatRegister s2);
 918   inline void fcmpe(FloatRegisterImpl::Width w, CC cc, FloatRegister s1, FloatRegister s2);
 919 
 920   // pp 159
 921 
 922   inline void ftox(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 923   inline void ftoi(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 924 
 925   // pp 160
 926 
 927   inline void ftof(FloatRegisterImpl::Width sw, FloatRegisterImpl::Width dw, FloatRegister s, FloatRegister d);
 928 
 929   // pp 161
 930 
 931   inline void fxtof(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 932   inline void fitof(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 933 
 934   // pp 162
 935 
 936   inline void fmov(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 937 
 938   inline void fneg(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 939 
 940   inline void fabs(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 941 
 942   // pp 163
 943 
 944   inline void fmul(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister d);
 945   inline void fmul(FloatRegisterImpl::Width sw, FloatRegisterImpl::Width dw, FloatRegister s1, FloatRegister s2, FloatRegister d);
 946   inline void fdiv(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister d);
 947 
 948   // FXORs/FXORd instructions
 949 
 950   inline void fxor(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister d);
 951 
 952   // pp 164
 953 
 954   inline void fsqrt(FloatRegisterImpl::Width w, FloatRegister s, FloatRegister d);
 955 
 956   // fmaf instructions.
 957 
 958   inline void fmadd(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 959   inline void fmsub(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 960 
 961   inline void fnmadd(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 962   inline void fnmsub(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister s2, FloatRegister s3, FloatRegister d);
 963 
 964   // pp 165
 965 
 966   inline void flush(Register s1, Register s2);
 967   inline void flush(Register s1, int simm13a);
 968 
 969   // pp 167
 970 
 971   void flushw();
 972 
 973   // pp 168
 974 
 975   void illtrap(int const22a);
 976 
 977   // pp 169
 978 
 979   void impdep1(int id1, int const19a);
 980   void impdep2(int id1, int const19a);
 981 
 982   // pp 170
 983 
 984   void jmpl(Register s1, Register s2, Register d);
 985   void jmpl(Register s1, int simm13a, Register d,
 986             RelocationHolder const &amp;rspec = RelocationHolder());
 987 
 988   // 171
 989 
 990   inline void ldf(FloatRegisterImpl::Width w, Register s1, Register s2, FloatRegister d);
 991   inline void ldf(FloatRegisterImpl::Width w, Register s1, int simm13a, FloatRegister d,
 992                   RelocationHolder const &amp;rspec = RelocationHolder());
 993 
 994   inline void ldd(Register s1, Register s2, FloatRegister d);
 995   inline void ldd(Register s1, int simm13a, FloatRegister d);
 996 
 997   inline void ldfsr(Register s1, Register s2);
 998   inline void ldfsr(Register s1, int simm13a);
 999   inline void ldxfsr(Register s1, Register s2);
1000   inline void ldxfsr(Register s1, int simm13a);
1001 
1002   // 173
1003 
1004   inline void ldfa(FloatRegisterImpl::Width w, Register s1, Register s2, int ia, FloatRegister d);
1005   inline void ldfa(FloatRegisterImpl::Width w, Register s1, int simm13a,         FloatRegister d);
1006 
1007   // pp 175
1008 
1009   inline void ldsb(Register s1, Register s2, Register d);
1010   inline void ldsb(Register s1, int simm13a, Register d);
1011   inline void ldsh(Register s1, Register s2, Register d);
1012   inline void ldsh(Register s1, int simm13a, Register d);
1013   inline void ldsw(Register s1, Register s2, Register d);
1014   inline void ldsw(Register s1, int simm13a, Register d);
1015   inline void ldub(Register s1, Register s2, Register d);
1016   inline void ldub(Register s1, int simm13a, Register d);
1017   inline void lduh(Register s1, Register s2, Register d);
1018   inline void lduh(Register s1, int simm13a, Register d);
1019   inline void lduw(Register s1, Register s2, Register d);
1020   inline void lduw(Register s1, int simm13a, Register d);
1021   inline void ldx(Register s1, Register s2, Register d);
1022   inline void ldx(Register s1, int simm13a, Register d);
1023 
1024   // pp 177
1025 
1026   inline void ldsba(Register s1, Register s2, int ia, Register d);
1027   inline void ldsba(Register s1, int simm13a,         Register d);
1028   inline void ldsha(Register s1, Register s2, int ia, Register d);
1029   inline void ldsha(Register s1, int simm13a,         Register d);
1030   inline void ldswa(Register s1, Register s2, int ia, Register d);
1031   inline void ldswa(Register s1, int simm13a,         Register d);
1032   inline void lduba(Register s1, Register s2, int ia, Register d);
1033   inline void lduba(Register s1, int simm13a,         Register d);
1034   inline void lduha(Register s1, Register s2, int ia, Register d);
1035   inline void lduha(Register s1, int simm13a,         Register d);
1036   inline void lduwa(Register s1, Register s2, int ia, Register d);
1037   inline void lduwa(Register s1, int simm13a,         Register d);
1038   inline void ldxa(Register s1, Register s2, int ia, Register d);
1039   inline void ldxa(Register s1, int simm13a,         Register d);
1040 
1041   // pp 181
1042 
1043   inline void and3(Register s1, Register s2, Register d);
1044   inline void and3(Register s1, int simm13a, Register d);
1045   inline void andcc(Register s1, Register s2, Register d);
1046   inline void andcc(Register s1, int simm13a, Register d);
1047   inline void andn(Register s1, Register s2, Register d);
1048   inline void andn(Register s1, int simm13a, Register d);
1049   inline void andncc(Register s1, Register s2, Register d);
1050   inline void andncc(Register s1, int simm13a, Register d);
1051   inline void or3(Register s1, Register s2, Register d);
1052   inline void or3(Register s1, int simm13a, Register d);
1053   inline void orcc(Register s1, Register s2, Register d);
1054   inline void orcc(Register s1, int simm13a, Register d);
1055   inline void orn(Register s1, Register s2, Register d);
1056   inline void orn(Register s1, int simm13a, Register d);
1057   inline void orncc(Register s1, Register s2, Register d);
1058   inline void orncc(Register s1, int simm13a, Register d);
1059   inline void xor3(Register s1, Register s2, Register d);
1060   inline void xor3(Register s1, int simm13a, Register d);
1061   inline void xorcc(Register s1, Register s2, Register d);
1062   inline void xorcc(Register s1, int simm13a, Register d);
1063   inline void xnor(Register s1, Register s2, Register d);
1064   inline void xnor(Register s1, int simm13a, Register d);
1065   inline void xnorcc(Register s1, Register s2, Register d);
1066   inline void xnorcc(Register s1, int simm13a, Register d);
1067 
1068   // pp 183
1069 
1070   inline void membar(Membar_mask_bits const7a);
1071 
1072   // pp 185
1073 
1074   inline void fmov(FloatRegisterImpl::Width w, Condition c,  bool floatCC, CC cca, FloatRegister s2, FloatRegister d);
1075 
1076   // pp 189
1077 
1078   inline void fmov(FloatRegisterImpl::Width w, RCondition c, Register s1,  FloatRegister s2, FloatRegister d);
1079 
1080   // pp 191
1081 
1082   inline void movcc(Condition c, bool floatCC, CC cca, Register s2, Register d);
1083   inline void movcc(Condition c, bool floatCC, CC cca, int simm11a, Register d);
1084 
1085   // pp 195
1086 
1087   inline void movr(RCondition c, Register s1, Register s2,  Register d);
1088   inline void movr(RCondition c, Register s1, int simm10a,  Register d);
1089 
1090   // pp 196
1091 
1092   inline void mulx(Register s1, Register s2, Register d);
1093   inline void mulx(Register s1, int simm13a, Register d);
1094   inline void sdivx(Register s1, Register s2, Register d);
1095   inline void sdivx(Register s1, int simm13a, Register d);
1096   inline void udivx(Register s1, Register s2, Register d);
1097   inline void udivx(Register s1, int simm13a, Register d);
1098 
1099   // pp 197
1100 
1101   inline void umul(Register s1, Register s2, Register d);
1102   inline void umul(Register s1, int simm13a, Register d);
1103   inline void smul(Register s1, Register s2, Register d);
1104   inline void smul(Register s1, int simm13a, Register d);
1105   inline void umulcc(Register s1, Register s2, Register d);
1106   inline void umulcc(Register s1, int simm13a, Register d);
1107   inline void smulcc(Register s1, Register s2, Register d);
1108   inline void smulcc(Register s1, int simm13a, Register d);
1109 
1110   // pp 201
1111 
1112   inline void nop();
1113 
1114   inline void sw_count();
1115 
1116   // pp 202
1117 
1118   inline void popc(Register s,  Register d);
1119   inline void popc(int simm13a, Register d);
1120 
1121   // pp 203
1122 
1123   inline void prefetch(Register s1, Register s2, PrefetchFcn f);
1124   inline void prefetch(Register s1, int simm13a, PrefetchFcn f);
1125 
1126   inline void prefetcha(Register s1, Register s2, int ia, PrefetchFcn f);
1127   inline void prefetcha(Register s1, int simm13a,         PrefetchFcn f);
1128 
1129   // pp 208
1130 
1131   // not implementing read privileged register
1132 
1133   inline void rdy(Register d);
1134   inline void rdccr(Register d);
1135   inline void rdasi(Register d);
1136   inline void rdtick(Register d);
1137   inline void rdpc(Register d);
1138   inline void rdfprs(Register d);
1139 
1140   // pp 213
1141 
1142   inline void rett(Register s1, Register s2);
1143   inline void rett(Register s1, int simm13a, relocInfo::relocType rt = relocInfo::none);
1144 
1145   // pp 214
1146 
1147   inline void save(Register s1, Register s2, Register d);
1148   inline void save(Register s1, int simm13a, Register d);
1149 
1150   inline void restore(Register s1 = G0, Register s2 = G0, Register d = G0);
1151   inline void restore(Register s1,      int simm13a,      Register d);
1152 
1153   // pp 216
1154 
1155   inline void saved();
1156   inline void restored();
1157 
1158   // pp 217
1159 
1160   inline void sethi(int imm22a, Register d, RelocationHolder const &amp;rspec = RelocationHolder());
1161 
1162   // pp 218
1163 
1164   inline void sll(Register s1, Register s2, Register d);
1165   inline void sll(Register s1, int imm5a,   Register d);
1166   inline void srl(Register s1, Register s2, Register d);
1167   inline void srl(Register s1, int imm5a,   Register d);
1168   inline void sra(Register s1, Register s2, Register d);
1169   inline void sra(Register s1, int imm5a,   Register d);
1170 
1171   inline void sllx(Register s1, Register s2, Register d);
1172   inline void sllx(Register s1, int imm6a,   Register d);
1173   inline void srlx(Register s1, Register s2, Register d);
1174   inline void srlx(Register s1, int imm6a,   Register d);
1175   inline void srax(Register s1, Register s2, Register d);
1176   inline void srax(Register s1, int imm6a,   Register d);
1177 
1178   // pp 220
1179 
1180   inline void sir(int simm13a);
1181 
1182   // pp 221
1183 
1184   inline void stbar();
1185 
1186   // pp 222
1187 
1188   inline void stf(FloatRegisterImpl::Width w, FloatRegister d, Register s1, Register s2);
1189   inline void stf(FloatRegisterImpl::Width w, FloatRegister d, Register s1, int simm13a);
1190 
1191   inline void std(FloatRegister d, Register s1, Register s2);
1192   inline void std(FloatRegister d, Register s1, int simm13a);
1193 
1194   inline void stfsr(Register s1, Register s2);
1195   inline void stfsr(Register s1, int simm13a);
1196   inline void stxfsr(Register s1, Register s2);
1197   inline void stxfsr(Register s1, int simm13a);
1198 
1199   // pp 224
1200 
1201   inline void stfa(FloatRegisterImpl::Width w, FloatRegister d, Register s1, Register s2, int ia);
1202   inline void stfa(FloatRegisterImpl::Width w, FloatRegister d, Register s1, int simm13a);
1203 
1204   // pp 226
1205 
1206   inline void stb(Register d, Register s1, Register s2);
1207   inline void stb(Register d, Register s1, int simm13a);
1208   inline void sth(Register d, Register s1, Register s2);
1209   inline void sth(Register d, Register s1, int simm13a);
1210   inline void stw(Register d, Register s1, Register s2);
1211   inline void stw(Register d, Register s1, int simm13a);
1212   inline void stx(Register d, Register s1, Register s2);
1213   inline void stx(Register d, Register s1, int simm13a);
1214 
1215   // pp 177
1216 
1217   inline void stba(Register d, Register s1, Register s2, int ia);
1218   inline void stba(Register d, Register s1, int simm13a);
1219   inline void stha(Register d, Register s1, Register s2, int ia);
1220   inline void stha(Register d, Register s1, int simm13a);
1221   inline void stwa(Register d, Register s1, Register s2, int ia);
1222   inline void stwa(Register d, Register s1, int simm13a);
1223   inline void stxa(Register d, Register s1, Register s2, int ia);
1224   inline void stxa(Register d, Register s1, int simm13a);
1225   inline void stda(Register d, Register s1, Register s2, int ia);
1226   inline void stda(Register d, Register s1, int simm13a);
1227 
1228   // pp 230
1229 
1230   inline void sub(Register s1, Register s2, Register d);
1231   inline void sub(Register s1, int simm13a, Register d);
1232 
1233   inline void subcc(Register s1, Register s2, Register d);
1234   inline void subcc(Register s1, int simm13a, Register d);
1235   inline void subc(Register s1, Register s2, Register d);
1236   inline void subc(Register s1, int simm13a, Register d);
1237   inline void subccc(Register s1, Register s2, Register d);
1238   inline void subccc(Register s1, int simm13a, Register d);
1239 
1240   // pp 231
1241 
1242   inline void swap(Register s1, Register s2, Register d);
1243   inline void swap(Register s1, int simm13a, Register d);
1244 
1245   // pp 232
1246 
1247   inline void swapa(Register s1, Register s2, int ia, Register d);
1248   inline void swapa(Register s1, int simm13a,         Register d);
1249 
1250   // pp 234, note op in book is wrong, see pp 268
1251 
1252   inline void taddcc(Register s1, Register s2, Register d);
1253   inline void taddcc(Register s1, int simm13a, Register d);
1254 
1255   // pp 235
1256 
1257   inline void tsubcc(Register s1, Register s2, Register d);
1258   inline void tsubcc(Register s1, int simm13a, Register d);
1259 
1260   // pp 237
1261 
1262   inline void trap(Condition c, CC cc, Register s1, Register s2);
1263   inline void trap(Condition c, CC cc, Register s1, int trapa);
1264   // simple uncond. trap
1265   inline void trap(int trapa);
1266 
1267   // pp 239 omit write priv register for now
1268 
1269   inline void wry(Register d);
1270   inline void wrccr(Register s);
1271   inline void wrccr(Register s, int simm13a);
1272   inline void wrasi(Register d);
1273   // wrasi(d, imm) stores (d xor imm) to asi
1274   inline void wrasi(Register d, int simm13a);
1275   inline void wrfprs(Register d);
1276 
1277   // VIS1 instructions
1278 
1279   inline void alignaddr(Register s1, Register s2, Register d);
1280 
1281   inline void faligndata(FloatRegister s1, FloatRegister s2, FloatRegister d);
1282 
1283   inline void fzero(FloatRegisterImpl::Width w, FloatRegister d);
1284 
1285   inline void fsrc2(FloatRegisterImpl::Width w, FloatRegister s2, FloatRegister d);
1286 
1287   inline void fnot1(FloatRegisterImpl::Width w, FloatRegister s1, FloatRegister d);
1288 
1289   inline void fpmerge(FloatRegister s1, FloatRegister s2, FloatRegister d);
1290 
1291   inline void stpartialf(Register s1, Register s2, FloatRegister d, int ia = -1);
1292 
1293   // VIS2 instructions
1294 
1295   inline void edge8n(Register s1, Register s2, Register d);
1296 
1297   inline void bmask(Register s1, Register s2, Register d);
1298   inline void bshuffle(FloatRegister s1, FloatRegister s2, FloatRegister d);
1299 
1300   // VIS3 instructions
1301 
1302   inline void addxc(Register s1, Register s2, Register d);
1303   inline void addxccc(Register s1, Register s2, Register d);
1304 
1305   inline void movstosw(FloatRegister s, Register d);
1306   inline void movstouw(FloatRegister s, Register d);
1307   inline void movdtox(FloatRegister s, Register d);
1308 
1309   inline void movwtos(Register s, FloatRegister d);
1310   inline void movxtod(Register s, FloatRegister d);
1311 
1312   inline void xmulx(Register s1, Register s2, Register d);
1313   inline void xmulxhi(Register s1, Register s2, Register d);
1314   inline void umulxhi(Register s1, Register s2, Register d);
1315 
1316   // Crypto SHA instructions
1317 
1318   inline void sha1();
1319   inline void sha256();
1320   inline void sha512();
1321 
1322   // CRC32C instruction
1323 
1324   inline void crc32c(FloatRegister s1, FloatRegister s2, FloatRegister d);
1325 
1326   // MPMUL instruction
1327 
1328   inline void mpmul(int uimm5);
1329 
1330   // Creation
1331   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
1332 #ifdef VALIDATE_PIPELINE
1333     _delay_state  = NoDelay;
1334     _hazard_state = NoHazard;
1335 #endif
1336   }
1337 };
1338 
1339 #endif // CPU_SPARC_ASSEMBLER_SPARC_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/vm_version_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;logging/logStream.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a>
 31 #include &quot;runtime/java.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;runtime/stubCodeGenerator.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 34 #include &quot;vm_version_sparc.hpp&quot;</span>
 35 
 36 #include &lt;sys/mman.h&gt;
 37 
 38 uint VM_Version::_L2_data_cache_line_size = 0;
 39 
 40 void VM_Version::initialize() {
 41   assert(_features != 0, &quot;System pre-initialization is not complete.&quot;);
 42   guarantee(VM_Version::has_v9(), &quot;only SPARC v9 is supported&quot;);
 43 
 44   PrefetchCopyIntervalInBytes = prefetch_copy_interval_in_bytes();
 45   PrefetchScanIntervalInBytes = prefetch_scan_interval_in_bytes();
 46   PrefetchFieldsAhead         = prefetch_fields_ahead();
 47 
 48   // Allocation prefetch settings
 49 
 50   AllocatePrefetchDistance = allocate_prefetch_distance();
 51   AllocatePrefetchStyle    = allocate_prefetch_style();
 52 
 53   intx cache_line_size = prefetch_data_size();
 54 
 55   if (FLAG_IS_DEFAULT(AllocatePrefetchStepSize)) {
 56     AllocatePrefetchStepSize = MAX2(AllocatePrefetchStepSize, cache_line_size);
 57   }
 58 
 59   if (AllocatePrefetchInstr == 1) {
 60     if (!has_blk_init()) {
 61       warning(&quot;BIS instructions required for AllocatePrefetchInstr 1 unavailable&quot;);
 62       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 0);
 63     }
 64     if (cache_line_size &lt;= 0) {
 65       warning(&quot;Cache-line size must be known for AllocatePrefetchInstr 1 to work&quot;);
 66       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 0);
 67     }
 68   }
 69 
 70   UseSSE = false;                   // Only used on x86 and x64.
 71 
 72   _supports_cx8 = true;             // All SPARC V9 implementations.
 73   _supports_atomic_getset4 = true;  // Using the &#39;swap&#39; instruction.
 74 
 75   if (has_fast_ind_br() &amp;&amp; FLAG_IS_DEFAULT(UseInlineCaches)) {
 76     // Indirect and direct branches are cost equivalent.
 77     FLAG_SET_DEFAULT(UseInlineCaches, false);
 78   }
 79   // Align loops on the proper instruction boundary to fill the instruction
 80   // fetch buffer.
 81   if (FLAG_IS_DEFAULT(OptoLoopAlignment)) {
 82     FLAG_SET_DEFAULT(OptoLoopAlignment, VM_Version::insn_fetch_alignment);
 83   }
 84 
 85   // 32-bit oops don&#39;t make sense for the 64-bit VM on SPARC since the 32-bit
 86   // VM has the same registers and smaller objects.
<a name="4" id="anc4"></a><span class="line-modified"> 87   Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes);</span>
<span class="line-modified"> 88   Universe::set_narrow_klass_shift(LogKlassAlignmentInBytes);</span>
 89 
 90 #ifdef COMPILER2
 91   if (has_fast_ind_br() &amp;&amp; FLAG_IS_DEFAULT(UseJumpTables)) {
 92     // Indirect and direct branches are cost equivalent.
 93     FLAG_SET_DEFAULT(UseJumpTables, true);
 94   }
 95   // Entry and loop tops are aligned to fill the instruction fetch buffer.
 96   if (FLAG_IS_DEFAULT(InteriorEntryAlignment)) {
 97     FLAG_SET_DEFAULT(InteriorEntryAlignment, VM_Version::insn_fetch_alignment);
 98   }
 99   if (UseTLAB &amp;&amp; cache_line_size &gt; 0 &amp;&amp;
100       FLAG_IS_DEFAULT(AllocatePrefetchInstr)) {
101     if (has_fast_bis()) {
102       // Use BIS instruction for TLAB allocation prefetch.
103       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 1);
104     }
105     else if (has_sparc5()) {
106       // Use prefetch instruction to avoid partial RAW issue on Core C4 processors,
107       // also use prefetch style 3.
108       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 0);
109       if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {
110         FLAG_SET_DEFAULT(AllocatePrefetchStyle, 3);
111       }
112     }
113   }
114   if (AllocatePrefetchInstr == 1) {
115     // Use allocation prefetch style 3 because BIS instructions require
116     // aligned memory addresses.
117     FLAG_SET_DEFAULT(AllocatePrefetchStyle, 3);
118   }
119   if (FLAG_IS_DEFAULT(AllocatePrefetchDistance)) {
120     if (AllocatePrefetchInstr == 0) {
121       // Use different prefetch distance without BIS
122       FLAG_SET_DEFAULT(AllocatePrefetchDistance, 256);
123     } else {
124       // Use smaller prefetch distance with BIS
125       FLAG_SET_DEFAULT(AllocatePrefetchDistance, 64);
126     }
127   }
128 
129   // We increase the number of prefetched cache lines, to use just a bit more
130   // aggressive approach, when the L2-cache line size is small (32 bytes), or
131   // when running on newer processor implementations, such as the Core C4.
132   bool inc_prefetch = cache_line_size &gt; 0 &amp;&amp; (cache_line_size &lt; 64 || has_sparc5());
133 
134   if (inc_prefetch) {
135     // We use a factor two for small cache line sizes (as before) but a slightly
136     // more conservative increase when running on more recent hardware that will
137     // benefit from just a bit more aggressive prefetching.
138     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) {
139       const int ap_lns = AllocatePrefetchLines;
140       const int ap_inc = cache_line_size &lt; 64 ? ap_lns : (ap_lns + 1) / 2;
<a name="5" id="anc5"></a><span class="line-modified">141       FLAG_SET_ERGO(intx, AllocatePrefetchLines, ap_lns + ap_inc);</span>
142     }
143     if (FLAG_IS_DEFAULT(AllocateInstancePrefetchLines)) {
144       const int ip_lns = AllocateInstancePrefetchLines;
145       const int ip_inc = cache_line_size &lt; 64 ? ip_lns : (ip_lns + 1) / 2;
<a name="6" id="anc6"></a><span class="line-modified">146       FLAG_SET_ERGO(intx, AllocateInstancePrefetchLines, ip_lns + ip_inc);</span>
147     }
148   }
149 #endif /* COMPILER2 */
150 
151   // Use hardware population count instruction if available.
152   if (has_popc()) {
153     if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
154       FLAG_SET_DEFAULT(UsePopCountInstruction, true);
155     }
156   } else if (UsePopCountInstruction) {
157     warning(&quot;POPC instruction is not available on this CPU&quot;);
158     FLAG_SET_DEFAULT(UsePopCountInstruction, false);
159   }
160 
161   // Use compare and branch instructions if available.
162   if (has_cbcond()) {
163     if (FLAG_IS_DEFAULT(UseCBCond)) {
164       FLAG_SET_DEFAULT(UseCBCond, true);
165     }
166   } else if (UseCBCond) {
167     warning(&quot;CBCOND instruction is not available on this CPU&quot;);
168     FLAG_SET_DEFAULT(UseCBCond, false);
169   }
170 
171   // Use &#39;mpmul&#39; instruction if available.
172   if (has_mpmul()) {
173     if (FLAG_IS_DEFAULT(UseMPMUL)) {
174       FLAG_SET_DEFAULT(UseMPMUL, true);
175     }
176   } else if (UseMPMUL) {
177     warning(&quot;MPMUL instruction is not available on this CPU&quot;);
178     FLAG_SET_DEFAULT(UseMPMUL, false);
179   }
180 
181   assert(BlockZeroingLowLimit &gt; 0, &quot;invalid value&quot;);
182 
183   if (has_blk_zeroing() &amp;&amp; cache_line_size &gt; 0) {
184     if (FLAG_IS_DEFAULT(UseBlockZeroing)) {
185       FLAG_SET_DEFAULT(UseBlockZeroing, true);
186     }
187   } else if (UseBlockZeroing) {
188     warning(&quot;BIS zeroing instructions are not available on this CPU&quot;);
189     FLAG_SET_DEFAULT(UseBlockZeroing, false);
190   }
191 
192   assert(BlockCopyLowLimit &gt; 0, &quot;invalid value&quot;);
193 
194   if (has_blk_zeroing() &amp;&amp; cache_line_size &gt; 0) {
195     if (FLAG_IS_DEFAULT(UseBlockCopy)) {
196       FLAG_SET_DEFAULT(UseBlockCopy, true);
197     }
198   } else if (UseBlockCopy) {
199     warning(&quot;BIS instructions are not available or expensive on this CPU&quot;);
200     FLAG_SET_DEFAULT(UseBlockCopy, false);
201   }
202 
203 #ifdef COMPILER2
204   if (has_fast_rdpc() &amp;&amp; FLAG_IS_DEFAULT(UseRDPCForConstantTableBase)) {
205     FLAG_SET_DEFAULT(UseRDPCForConstantTableBase, true);
206   }
207 
208   // Currently not supported anywhere.
209   FLAG_SET_DEFAULT(UseFPUForSpilling, false);
210 
211   MaxVectorSize = 8;
212 
213   assert((InteriorEntryAlignment % relocInfo::addr_unit()) == 0, &quot;alignment is not a multiple of NOP size&quot;);
214 #endif
215 
216   assert((CodeEntryAlignment % relocInfo::addr_unit()) == 0, &quot;alignment is not a multiple of NOP size&quot;);
217   assert((OptoLoopAlignment % relocInfo::addr_unit()) == 0, &quot;alignment is not a multiple of NOP size&quot;);
218 
219   char buf[512];
220   jio_snprintf(buf, sizeof(buf),
221                &quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;
222                &quot;%s%s%s%s%s%s%s%s%s&quot; &quot;%s%s%s%s%s%s%s%s%s&quot;
223                &quot;%s%s%s%s%s%s%s&quot;,
224                (has_v9()          ? &quot;v9&quot; : &quot;&quot;),
225                (has_popc()        ? &quot;, popc&quot; : &quot;&quot;),
226                (has_vis1()        ? &quot;, vis1&quot; : &quot;&quot;),
227                (has_vis2()        ? &quot;, vis2&quot; : &quot;&quot;),
228                (has_blk_init()    ? &quot;, blk_init&quot; : &quot;&quot;),
229                (has_fmaf()        ? &quot;, fmaf&quot; : &quot;&quot;),
230                (has_hpc()         ? &quot;, hpc&quot; : &quot;&quot;),
231                (has_ima()         ? &quot;, ima&quot; : &quot;&quot;),
232                (has_aes()         ? &quot;, aes&quot; : &quot;&quot;),
233                (has_des()         ? &quot;, des&quot; : &quot;&quot;),
234                (has_kasumi()      ? &quot;, kas&quot; : &quot;&quot;),
235                (has_camellia()    ? &quot;, cam&quot; : &quot;&quot;),
236                (has_md5()         ? &quot;, md5&quot; : &quot;&quot;),
237                (has_sha1()        ? &quot;, sha1&quot; : &quot;&quot;),
238                (has_sha256()      ? &quot;, sha256&quot; : &quot;&quot;),
239                (has_sha512()      ? &quot;, sha512&quot; : &quot;&quot;),
240                (has_mpmul()       ? &quot;, mpmul&quot; : &quot;&quot;),
241                (has_mont()        ? &quot;, mont&quot; : &quot;&quot;),
242                (has_pause()       ? &quot;, pause&quot; : &quot;&quot;),
243                (has_cbcond()      ? &quot;, cbcond&quot; : &quot;&quot;),
244                (has_crc32c()      ? &quot;, crc32c&quot; : &quot;&quot;),
245 
246                (has_athena_plus() ? &quot;, athena_plus&quot; : &quot;&quot;),
247                (has_vis3b()       ? &quot;, vis3b&quot; : &quot;&quot;),
248                (has_adi()         ? &quot;, adi&quot; : &quot;&quot;),
249                (has_sparc5()      ? &quot;, sparc5&quot; : &quot;&quot;),
250                (has_mwait()       ? &quot;, mwait&quot; : &quot;&quot;),
251                (has_xmpmul()      ? &quot;, xmpmul&quot; : &quot;&quot;),
252                (has_xmont()       ? &quot;, xmont&quot; : &quot;&quot;),
253                (has_pause_nsec()  ? &quot;, pause_nsec&quot; : &quot;&quot;),
254                (has_vamask()      ? &quot;, vamask&quot; : &quot;&quot;),
255 
256                (has_sparc6()      ? &quot;, sparc6&quot; : &quot;&quot;),
257                (has_dictunp()     ? &quot;, dictunp&quot; : &quot;&quot;),
258                (has_fpcmpshl()    ? &quot;, fpcmpshl&quot; : &quot;&quot;),
259                (has_rle()         ? &quot;, rle&quot; : &quot;&quot;),
260                (has_sha3()        ? &quot;, sha3&quot; : &quot;&quot;),
261                (has_athena_plus2()? &quot;, athena_plus2&quot; : &quot;&quot;),
262                (has_vis3c()       ? &quot;, vis3c&quot; : &quot;&quot;),
263                (has_sparc5b()     ? &quot;, sparc5b&quot; : &quot;&quot;),
264                (has_mme()         ? &quot;, mme&quot; : &quot;&quot;),
265 
266                (has_fast_idiv()   ? &quot;, *idiv&quot; : &quot;&quot;),
267                (has_fast_rdpc()   ? &quot;, *rdpc&quot; : &quot;&quot;),
268                (has_fast_bis()    ? &quot;, *bis&quot; : &quot;&quot;),
269                (has_fast_ld()     ? &quot;, *ld&quot; : &quot;&quot;),
270                (has_fast_cmove()  ? &quot;, *cmove&quot; : &quot;&quot;),
271                (has_fast_ind_br() ? &quot;, *ind_br&quot; : &quot;&quot;),
272                (has_blk_zeroing() ? &quot;, *blk_zeroing&quot; : &quot;&quot;));
273 
274   assert(strlen(buf) &gt;= 2, &quot;must be&quot;);
275 
276   _features_string = os::strdup(buf);
277 
278   log_info(os, cpu)(&quot;SPARC features detected: %s&quot;, _features_string);
279 
280   // UseVIS is set to the smallest of what hardware supports and what the command
281   // line requires, i.e. you cannot set UseVIS to 3 on older UltraSparc which do
282   // not support it.
283 
284   if (UseVIS &gt; 3) UseVIS = 3;
285   if (UseVIS &lt; 0) UseVIS = 0;
286   if (!has_vis3()) // Drop to 2 if no VIS3 support
287     UseVIS = MIN2((intx)2, UseVIS);
288   if (!has_vis2()) // Drop to 1 if no VIS2 support
289     UseVIS = MIN2((intx)1, UseVIS);
290   if (!has_vis1()) // Drop to 0 if no VIS1 support
291     UseVIS = 0;
292 
293   if (has_aes()) {
294     if (FLAG_IS_DEFAULT(UseAES)) {
295       FLAG_SET_DEFAULT(UseAES, true);
296     }
297     if (!UseAES) {
298       if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
299         warning(&quot;AES intrinsics require UseAES flag to be enabled. Intrinsics will be disabled.&quot;);
300       }
301       FLAG_SET_DEFAULT(UseAESIntrinsics, false);
302     } else {
303       // The AES intrinsic stubs require AES instruction support (of course)
304       // but also require VIS3 mode or higher for instructions it use.
305       if (UseVIS &gt; 2) {
306         if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
307           FLAG_SET_DEFAULT(UseAESIntrinsics, true);
308         }
309       } else {
310         if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
311           warning(&quot;SPARC AES intrinsics require VIS3 instructions. Intrinsics will be disabled.&quot;);
312         }
313         FLAG_SET_DEFAULT(UseAESIntrinsics, false);
314       }
315     }
316   } else if (UseAES || UseAESIntrinsics) {
317     if (UseAES &amp;&amp; !FLAG_IS_DEFAULT(UseAES)) {
318       warning(&quot;AES instructions are not available on this CPU&quot;);
319       FLAG_SET_DEFAULT(UseAES, false);
320     }
321     if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
322       warning(&quot;AES intrinsics are not available on this CPU&quot;);
323       FLAG_SET_DEFAULT(UseAESIntrinsics, false);
324     }
325   }
326 
327   if (UseAESCTRIntrinsics) {
328     warning(&quot;AES/CTR intrinsics are not available on this CPU&quot;);
329     FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
330   }
331 
332   // GHASH/GCM intrinsics
333   if (has_vis3() &amp;&amp; (UseVIS &gt; 2)) {
334     if (FLAG_IS_DEFAULT(UseGHASHIntrinsics)) {
335       UseGHASHIntrinsics = true;
336     }
337   } else if (UseGHASHIntrinsics) {
338     if (!FLAG_IS_DEFAULT(UseGHASHIntrinsics))
339       warning(&quot;GHASH intrinsics require VIS3 instruction support. Intrinsics will be disabled&quot;);
340     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
341   }
342 
343   if (has_fmaf()) {
344     if (FLAG_IS_DEFAULT(UseFMA)) {
345       UseFMA = true;
346     }
347   } else if (UseFMA) {
348     warning(&quot;FMA instructions are not available on this CPU&quot;);
349     FLAG_SET_DEFAULT(UseFMA, false);
350   }
351 
352   // SHA1, SHA256, and SHA512 instructions were added to SPARC at different times
353   if (has_sha1() || has_sha256() || has_sha512()) {
354     if (UseVIS &gt; 0) { // SHA intrinsics use VIS1 instructions
355       if (FLAG_IS_DEFAULT(UseSHA)) {
356         FLAG_SET_DEFAULT(UseSHA, true);
357       }
358     } else {
359       if (UseSHA) {
360         warning(&quot;SPARC SHA intrinsics require VIS1 instruction support. Intrinsics will be disabled.&quot;);
361         FLAG_SET_DEFAULT(UseSHA, false);
362       }
363     }
364   } else if (UseSHA) {
365     warning(&quot;SHA instructions are not available on this CPU&quot;);
366     FLAG_SET_DEFAULT(UseSHA, false);
367   }
368 
369   if (UseSHA &amp;&amp; has_sha1()) {
370     if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {
371       FLAG_SET_DEFAULT(UseSHA1Intrinsics, true);
372     }
373   } else if (UseSHA1Intrinsics) {
374     warning(&quot;Intrinsics for SHA-1 crypto hash functions not available on this CPU.&quot;);
375     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
376   }
377 
378   if (UseSHA &amp;&amp; has_sha256()) {
379     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
380       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
381     }
382   } else if (UseSHA256Intrinsics) {
383     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
384     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
385   }
386 
387   if (UseSHA &amp;&amp; has_sha512()) {
388     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
389       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
390     }
391   } else if (UseSHA512Intrinsics) {
392     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
393     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
394   }
395 
396   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
397     FLAG_SET_DEFAULT(UseSHA, false);
398   }
399 
400   if (has_crc32c()) {
401     if (UseVIS &gt; 2) { // CRC32C intrinsics use VIS3 instructions
402       if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
403         FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
404       }
405     } else {
406       if (UseCRC32CIntrinsics) {
407         warning(&quot;SPARC CRC32C intrinsics require VIS3 instruction support. Intrinsics will be disabled.&quot;);
408         FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
409       }
410     }
411   } else if (UseCRC32CIntrinsics) {
412     warning(&quot;CRC32C instruction is not available on this CPU&quot;);
413     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
414   }
415 
416   if (UseVIS &gt; 2) {
417     if (FLAG_IS_DEFAULT(UseAdler32Intrinsics)) {
418       FLAG_SET_DEFAULT(UseAdler32Intrinsics, true);
419     }
420   } else if (UseAdler32Intrinsics) {
421     warning(&quot;SPARC Adler32 intrinsics require VIS3 instruction support. Intrinsics will be disabled.&quot;);
422     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
423   }
424 
425   if (UseVIS &gt; 2) {
426     if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
427       FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);
428     }
429   } else if (UseCRC32Intrinsics) {
430     warning(&quot;SPARC CRC32 intrinsics require VIS3 instructions support. Intrinsics will be disabled&quot;);
431     FLAG_SET_DEFAULT(UseCRC32Intrinsics, false);
432   }
433 
434   if (UseVIS &gt; 2) {
435     if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
436       FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);
437     }
438   } else if (UseMultiplyToLenIntrinsic) {
439     warning(&quot;SPARC multiplyToLen intrinsics require VIS3 instructions support. Intrinsics will be disabled&quot;);
440     FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, false);
441   }
442 
443   if (UseVectorizedMismatchIntrinsic) {
444     warning(&quot;UseVectorizedMismatchIntrinsic specified, but not available on this CPU.&quot;);
445     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
446   }
447 
448   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp;
449     (cache_line_size &gt; ContendedPaddingWidth))
450     ContendedPaddingWidth = cache_line_size;
451 
452   // This machine does not allow unaligned memory accesses
453   if (UseUnalignedAccesses) {
454     if (!FLAG_IS_DEFAULT(UseUnalignedAccesses))
455       warning(&quot;Unaligned memory access is not available on this CPU&quot;);
456     FLAG_SET_DEFAULT(UseUnalignedAccesses, false);
457   }
458 
459   if (log_is_enabled(Info, os, cpu)) {
460     ResourceMark rm;
461     LogStream ls(Log(os, cpu)::info());
462     outputStream* log = &amp;ls;
463     log-&gt;print_cr(&quot;L1 data cache line size: %u&quot;, L1_data_cache_line_size());
464     log-&gt;print_cr(&quot;L2 data cache line size: %u&quot;, L2_data_cache_line_size());
465     log-&gt;print(&quot;Allocation&quot;);
466     if (AllocatePrefetchStyle &lt;= 0) {
467       log-&gt;print(&quot;: no prefetching&quot;);
468     } else {
469       log-&gt;print(&quot; prefetching: &quot;);
470       if (AllocatePrefetchInstr == 0) {
471           log-&gt;print(&quot;PREFETCH&quot;);
472       } else if (AllocatePrefetchInstr == 1) {
473           log-&gt;print(&quot;BIS&quot;);
474       }
475       if (AllocatePrefetchLines &gt; 1) {
476         log-&gt;print_cr(&quot; at distance %d, %d lines of %d bytes&quot;, (int) AllocatePrefetchDistance, (int) AllocatePrefetchLines, (int) AllocatePrefetchStepSize);
477       } else {
478         log-&gt;print_cr(&quot; at distance %d, one line of %d bytes&quot;, (int) AllocatePrefetchDistance, (int) AllocatePrefetchStepSize);
479       }
480     }
481     if (PrefetchCopyIntervalInBytes &gt; 0) {
482       log-&gt;print_cr(&quot;PrefetchCopyIntervalInBytes %d&quot;, (int) PrefetchCopyIntervalInBytes);
483     }
484     if (PrefetchScanIntervalInBytes &gt; 0) {
485       log-&gt;print_cr(&quot;PrefetchScanIntervalInBytes %d&quot;, (int) PrefetchScanIntervalInBytes);
486     }
487     if (PrefetchFieldsAhead &gt; 0) {
488       log-&gt;print_cr(&quot;PrefetchFieldsAhead %d&quot;, (int) PrefetchFieldsAhead);
489     }
490     if (ContendedPaddingWidth &gt; 0) {
491       log-&gt;print_cr(&quot;ContendedPaddingWidth %d&quot;, (int) ContendedPaddingWidth);
492     }
493   }
494 }
495 
496 void VM_Version::print_features() {
497   tty-&gt;print(&quot;ISA features [0x%0&quot; PRIx64 &quot;]:&quot;, _features);
498   if (_features_string != NULL) {
499     tty-&gt;print(&quot; %s&quot;, _features_string);
500   }
501   tty-&gt;cr();
502 }
503 
504 void VM_Version::determine_features() {
505   platform_features();      // platform_features() is os_arch specific.
506 
507   assert(has_v9(), &quot;must be&quot;);
508 
509   if (UseNiagaraInstrs) {   // Limit code generation to Niagara.
510     _features &amp;= niagara1_msk;
511   }
512 }
513 
514 static uint64_t saved_features = 0;
515 
516 void VM_Version::allow_all() {
517   saved_features = _features;
518   _features      = full_feature_msk;
519 }
520 
521 void VM_Version::revert() {
522   _features = saved_features;
523 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/sparc/sharedRuntime_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="relocInfo_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sparc.ad.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/sharedRuntime_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 30,11 ---</span>
  #include &quot;gc/shared/gcLocker.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/compiledICHolder.hpp&quot;
<span class="line-added">+ #include &quot;oops/klass.inline.hpp&quot;</span>
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/vframeArray.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;vmreg_sparc.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 559,11 ***</span>
        else                  __ ldx(base, ld_off, G1_scratch);
      }
  
      if (r_1-&gt;is_Register()) {
        Register r = r_1-&gt;as_Register()-&gt;after_restore();
<span class="line-modified">!       if (sig_bt[i] == T_OBJECT || sig_bt[i] == T_ARRAY) {</span>
          store_c2i_object(r, base, st_off);
        } else if (sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
          store_c2i_long(r, base, st_off, r_2-&gt;is_stack());
        } else {
          store_c2i_int(r, base, st_off);
<span class="line-new-header">--- 560,11 ---</span>
        else                  __ ldx(base, ld_off, G1_scratch);
      }
  
      if (r_1-&gt;is_Register()) {
        Register r = r_1-&gt;as_Register()-&gt;after_restore();
<span class="line-modified">!       if (is_reference_type(sig_bt[i])) {</span>
          store_c2i_object(r, base, st_off);
        } else if (sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
          store_c2i_long(r, base, st_off, r_2-&gt;is_stack());
        } else {
          store_c2i_int(r, base, st_off);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1635,12 ***</span>
                              const BasicType* sig_bt,
                              const VMRegPair* regs) {
    Register temp_reg = G5_method;  // not part of any compiled calling seq
    if (VerifyOops) {
      for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
<span class="line-modified">!       if (sig_bt[i] == T_OBJECT ||</span>
<span class="line-removed">-           sig_bt[i] == T_ARRAY) {</span>
          VMReg r = regs[i].first();
          assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
          if (r-&gt;is_stack()) {
            RegisterOrConstant ld_off = reg2offset(r) + STACK_BIAS;
            ld_off = __ ensure_simm13_or_reg(ld_off, temp_reg);
<span class="line-new-header">--- 1636,11 ---</span>
                              const BasicType* sig_bt,
                              const VMRegPair* regs) {
    Register temp_reg = G5_method;  // not part of any compiled calling seq
    if (VerifyOops) {
      for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
<span class="line-modified">!       if (is_reference_type(sig_bt[i])) {</span>
          VMReg r = regs[i].first();
          assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
          if (r-&gt;is_stack()) {
            RegisterOrConstant ld_off = reg2offset(r) + STACK_BIAS;
            ld_off = __ ensure_simm13_or_reg(ld_off, temp_reg);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1749,11 ***</span>
  nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
                                                  const methodHandle&amp; method,
                                                  int compile_id,
                                                  BasicType* in_sig_bt,
                                                  VMRegPair* in_regs,
<span class="line-modified">!                                                 BasicType ret_type) {</span>
    if (method-&gt;is_method_handle_intrinsic()) {
      vmIntrinsics::ID iid = method-&gt;intrinsic_id();
      intptr_t start = (intptr_t)__ pc();
      int vep_offset = ((intptr_t)__ pc()) - start;
      gen_special_dispatch(masm,
<span class="line-new-header">--- 1749,12 ---</span>
  nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
                                                  const methodHandle&amp; method,
                                                  int compile_id,
                                                  BasicType* in_sig_bt,
                                                  VMRegPair* in_regs,
<span class="line-modified">!                                                 BasicType ret_type,</span>
<span class="line-added">+                                                 address critical_entry) {</span>
    if (method-&gt;is_method_handle_intrinsic()) {
      vmIntrinsics::ID iid = method-&gt;intrinsic_id();
      intptr_t start = (intptr_t)__ pc();
      int vep_offset = ((intptr_t)__ pc()) - start;
      gen_special_dispatch(masm,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1772,11 ***</span>
                                         in_ByteSize(-1),
                                         in_ByteSize(-1),
                                         (OopMapSet*)NULL);
    }
    bool is_critical_native = true;
<span class="line-modified">!   address native_func = method-&gt;critical_native_function();</span>
    if (native_func == NULL) {
      native_func = method-&gt;native_function();
      is_critical_native = false;
    }
    assert(native_func != NULL, &quot;must have function&quot;);
<span class="line-new-header">--- 1773,11 ---</span>
                                         in_ByteSize(-1),
                                         in_ByteSize(-1),
                                         (OopMapSet*)NULL);
    }
    bool is_critical_native = true;
<span class="line-modified">!   address native_func = critical_entry;</span>
    if (native_func == NULL) {
      native_func = method-&gt;native_function();
      is_critical_native = false;
    }
    assert(native_func != NULL, &quot;must have function&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1830,25 ***</span>
      }
  
      // Read the header and build a mask to get its hash field.  Give up if the object is not unlocked.
      // We depend on hash_mask being at most 32 bits and avoid the use of
      // hash_mask_in_place because it could be larger than 32 bits in a 64-bit
<span class="line-modified">!     // vm: see markOop.hpp.</span>
      __ ld_ptr(obj_reg, oopDesc::mark_offset_in_bytes(), header);
<span class="line-modified">!     __ sethi(markOopDesc::hash_mask, mask);</span>
<span class="line-modified">!     __ btst(markOopDesc::unlocked_value, header);</span>
      __ br(Assembler::zero, false, Assembler::pn, slowCase);
      if (UseBiasedLocking) {
        // Check if biased and fall through to runtime if so
        __ delayed()-&gt;nop();
<span class="line-modified">!       __ btst(markOopDesc::biased_lock_bit_in_place, header);</span>
        __ br(Assembler::notZero, false, Assembler::pn, slowCase);
      }
<span class="line-modified">!     __ delayed()-&gt;or3(mask, markOopDesc::hash_mask &amp; 0x3ff, mask);</span>
  
      // Check for a valid (non-zero) hash code and get its value.
<span class="line-modified">!     __ srlx(header, markOopDesc::hash_shift, hash);</span>
      __ andcc(hash, mask, hash);
      __ br(Assembler::equal, false, Assembler::pn, slowCase);
      __ delayed()-&gt;nop();
  
      // leaf return.
<span class="line-new-header">--- 1831,25 ---</span>
      }
  
      // Read the header and build a mask to get its hash field.  Give up if the object is not unlocked.
      // We depend on hash_mask being at most 32 bits and avoid the use of
      // hash_mask_in_place because it could be larger than 32 bits in a 64-bit
<span class="line-modified">!     // vm: see markWord.hpp.</span>
      __ ld_ptr(obj_reg, oopDesc::mark_offset_in_bytes(), header);
<span class="line-modified">!     __ sethi(markWord::hash_mask, mask);</span>
<span class="line-modified">!     __ btst(markWord::unlocked_value, header);</span>
      __ br(Assembler::zero, false, Assembler::pn, slowCase);
      if (UseBiasedLocking) {
        // Check if biased and fall through to runtime if so
        __ delayed()-&gt;nop();
<span class="line-modified">!       __ btst(markWord::biased_lock_bit_in_place, header);</span>
        __ br(Assembler::notZero, false, Assembler::pn, slowCase);
      }
<span class="line-modified">!     __ delayed()-&gt;or3(mask, markWord::hash_mask &amp; 0x3ff, mask);</span>
  
      // Check for a valid (non-zero) hash code and get its value.
<span class="line-modified">!     __ srlx(header, markWord::hash_shift, hash);</span>
      __ andcc(hash, mask, hash);
      __ br(Assembler::equal, false, Assembler::pn, slowCase);
      __ delayed()-&gt;nop();
  
      // leaf return.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1904,32 ***</span>
      for (int i = 0; i &lt; total_in_args ; i++ ) {
        if (in_sig_bt[i] == T_ARRAY) {
          // Arrays are passed as int, elem* pair
          out_sig_bt[argc++] = T_INT;
          out_sig_bt[argc++] = T_ADDRESS;
<span class="line-modified">!         Symbol* atype = ss.as_symbol(CHECK_NULL);</span>
<span class="line-modified">!         const char* at = atype-&gt;as_C_string();</span>
<span class="line-modified">!         if (strlen(at) == 2) {</span>
<span class="line-removed">-           assert(at[0] == &#39;[&#39;, &quot;must be&quot;);</span>
<span class="line-removed">-           switch (at[1]) {</span>
<span class="line-removed">-             case &#39;B&#39;: in_elem_bt[i]  = T_BYTE; break;</span>
<span class="line-removed">-             case &#39;C&#39;: in_elem_bt[i]  = T_CHAR; break;</span>
<span class="line-removed">-             case &#39;D&#39;: in_elem_bt[i]  = T_DOUBLE; break;</span>
<span class="line-removed">-             case &#39;F&#39;: in_elem_bt[i]  = T_FLOAT; break;</span>
<span class="line-removed">-             case &#39;I&#39;: in_elem_bt[i]  = T_INT; break;</span>
<span class="line-removed">-             case &#39;J&#39;: in_elem_bt[i]  = T_LONG; break;</span>
<span class="line-removed">-             case &#39;S&#39;: in_elem_bt[i]  = T_SHORT; break;</span>
<span class="line-removed">-             case &#39;Z&#39;: in_elem_bt[i]  = T_BOOLEAN; break;</span>
<span class="line-removed">-             default: ShouldNotReachHere();</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         }</span>
        } else {
          out_sig_bt[argc++] = in_sig_bt[i];
          in_elem_bt[i] = T_VOID;
        }
        if (in_sig_bt[i] != T_VOID) {
<span class="line-modified">!         assert(in_sig_bt[i] == ss.type(), &quot;must match&quot;);</span>
          ss.next();
        }
      }
    }
  
<span class="line-new-header">--- 1905,20 ---</span>
      for (int i = 0; i &lt; total_in_args ; i++ ) {
        if (in_sig_bt[i] == T_ARRAY) {
          // Arrays are passed as int, elem* pair
          out_sig_bt[argc++] = T_INT;
          out_sig_bt[argc++] = T_ADDRESS;
<span class="line-modified">!         ss.skip_array_prefix(1);  // skip one &#39;[&#39;</span>
<span class="line-modified">!         assert(ss.is_primitive(), &quot;primitive type expected&quot;);</span>
<span class="line-modified">!         in_elem_bt[i] = ss.type();</span>
        } else {
          out_sig_bt[argc++] = in_sig_bt[i];
          in_elem_bt[i] = T_VOID;
        }
        if (in_sig_bt[i] != T_VOID) {
<span class="line-modified">!         assert(in_sig_bt[i] == ss.type() ||</span>
<span class="line-added">+                in_sig_bt[i] == T_ARRAY, &quot;must match&quot;);</span>
          ss.next();
        }
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2504,11 ***</span>
    // Clear &quot;last Java frame&quot; SP and PC.
    __ verify_thread(); // G2_thread must be correct
    __ reset_last_Java_frame();
  
    // Unbox oop result, e.g. JNIHandles::resolve value in I0.
<span class="line-modified">!   if (ret_type == T_OBJECT || ret_type == T_ARRAY) {</span>
      __ resolve_jobject(I0, G3_scratch);
    }
  
    if (CheckJNICalls) {
      // clear_pending_jni_exception_check
<span class="line-new-header">--- 2493,11 ---</span>
    // Clear &quot;last Java frame&quot; SP and PC.
    __ verify_thread(); // G2_thread must be correct
    __ reset_last_Java_frame();
  
    // Unbox oop result, e.g. JNIHandles::resolve value in I0.
<span class="line-modified">!   if (is_reference_type(ret_type)) {</span>
      __ resolve_jobject(I0, G3_scratch);
    }
  
    if (CheckJNICalls) {
      // clear_pending_jni_exception_check
</pre>
<center><a href="relocInfo_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sparc.ad.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
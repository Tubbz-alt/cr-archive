<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/c1_Runtime1_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.inline.hpp&quot;
 27 #include &quot;c1/c1_Defs.hpp&quot;
 28 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 29 #include &quot;c1/c1_Runtime1.hpp&quot;
 30 #include &quot;ci/ciUtilities.hpp&quot;
 31 #include &quot;gc/shared/cardTable.hpp&quot;
 32 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 33 #include &quot;interpreter/interpreter.hpp&quot;
<a name="1" id="anc1"></a>
 34 #include &quot;nativeInst_sparc.hpp&quot;
 35 #include &quot;oops/compiledICHolder.hpp&quot;
 36 #include &quot;oops/oop.inline.hpp&quot;
 37 #include &quot;prims/jvmtiExport.hpp&quot;
 38 #include &quot;runtime/sharedRuntime.hpp&quot;
 39 #include &quot;runtime/signature.hpp&quot;
 40 #include &quot;runtime/vframeArray.hpp&quot;
 41 #include &quot;utilities/macros.hpp&quot;
 42 #include &quot;utilities/align.hpp&quot;
 43 #include &quot;vmreg_sparc.inline.hpp&quot;
 44 
 45 // Implementation of StubAssembler
 46 
 47 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry_point, int number_of_arguments) {
 48   // for sparc changing the number of arguments doesn&#39;t change
 49   // anything about the frame size so we&#39;ll always lie and claim that
 50   // we are only passing 1 argument.
 51   set_num_rt_args(1);
 52 
 53   assert_not_delayed();
 54   // bang stack before going to runtime
 55   set(-os::vm_page_size() + STACK_BIAS, G3_scratch);
 56   st(G0, SP, G3_scratch);
 57 
 58   // debugging support
 59   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
 60 
 61   set_last_Java_frame(SP, noreg);
 62   if (VerifyThread)  mov(G2_thread, O0); // about to be smashed; pass early
 63   save_thread(L7_thread_cache);
 64   // do the call
 65   call(entry_point, relocInfo::runtime_call_type);
 66   if (!VerifyThread) {
 67     delayed()-&gt;mov(G2_thread, O0);  // pass thread as first argument
 68   } else {
 69     delayed()-&gt;nop();             // (thread already passed)
 70   }
 71   int call_offset = offset();  // offset of return address
 72   restore_thread(L7_thread_cache);
 73   reset_last_Java_frame();
 74 
 75   // check for pending exceptions
 76   { Label L;
 77     Address exception_addr(G2_thread, Thread::pending_exception_offset());
 78     ld_ptr(exception_addr, Gtemp);
 79     br_null_short(Gtemp, pt, L);
 80     Address vm_result_addr(G2_thread, JavaThread::vm_result_offset());
 81     st_ptr(G0, vm_result_addr);
 82     Address vm_result_addr_2(G2_thread, JavaThread::vm_result_2_offset());
 83     st_ptr(G0, vm_result_addr_2);
 84 
 85     if (frame_size() == no_frame_size) {
 86       // we use O7 linkage so that forward_exception_entry has the issuing PC
 87       call(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type);
 88       delayed()-&gt;restore();
 89     } else if (_stub_id == Runtime1::forward_exception_id) {
 90       should_not_reach_here();
 91     } else {
 92       AddressLiteral exc(Runtime1::entry_for(Runtime1::forward_exception_id));
 93       jump_to(exc, G4);
 94       delayed()-&gt;nop();
 95     }
 96     bind(L);
 97   }
 98 
 99   // get oop result if there is one and reset the value in the thread
100   if (oop_result1-&gt;is_valid()) {                    // get oop result if there is one and reset it in the thread
101     get_vm_result  (oop_result1);
102   } else {
103     // be a little paranoid and clear the result
104     Address vm_result_addr(G2_thread, JavaThread::vm_result_offset());
105     st_ptr(G0, vm_result_addr);
106   }
107 
108   // get second result if there is one and reset the value in the thread
109   if (metadata_result-&gt;is_valid()) {
110     get_vm_result_2  (metadata_result);
111   } else {
112     // be a little paranoid and clear the result
113     Address vm_result_addr_2(G2_thread, JavaThread::vm_result_2_offset());
114     st_ptr(G0, vm_result_addr_2);
115   }
116 
117   return call_offset;
118 }
119 
120 
121 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, Register arg1) {
122   // O0 is reserved for the thread
123   mov(arg1, O1);
124   return call_RT(oop_result1, metadata_result, entry, 1);
125 }
126 
127 
128 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, Register arg1, Register arg2) {
129   // O0 is reserved for the thread
130   mov(arg1, O1);
131   mov(arg2, O2); assert(arg2 != O1, &quot;smashed argument&quot;);
132   return call_RT(oop_result1, metadata_result, entry, 2);
133 }
134 
135 
136 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, Register arg1, Register arg2, Register arg3) {
137   // O0 is reserved for the thread
138   mov(arg1, O1);
139   mov(arg2, O2); assert(arg2 != O1,               &quot;smashed argument&quot;);
140   mov(arg3, O3); assert(arg3 != O1 &amp;&amp; arg3 != O2, &quot;smashed argument&quot;);
141   return call_RT(oop_result1, metadata_result, entry, 3);
142 }
143 
144 void StubAssembler::prologue(const char* name, bool must_gc_arguments) {
145   set_info(name, must_gc_arguments);
146 }
147 
148 void StubAssembler::epilogue() {
149   delayed()-&gt;restore();
150 }
151 
152 // Implementation of Runtime1
153 
154 
155 static int cpu_reg_save_offsets[FrameMap::nof_cpu_regs];
156 static int fpu_reg_save_offsets[FrameMap::nof_fpu_regs];
157 static int reg_save_size_in_words;
158 static int frame_size_in_bytes = -1;
159 
160 static OopMap* generate_oop_map(StubAssembler* sasm, bool save_fpu_registers) {
161   assert(frame_size_in_bytes == sasm-&gt;total_frame_size_in_bytes(reg_save_size_in_words),
162          &quot;mismatch in calculation&quot;);
163   sasm-&gt;set_frame_size(frame_size_in_bytes / BytesPerWord);
164   int frame_size_in_slots = frame_size_in_bytes / sizeof(jint);
165   OopMap* oop_map = new OopMap(frame_size_in_slots, 0);
166 
167   int i;
168   for (i = 0; i &lt; FrameMap::nof_cpu_regs; i++) {
169     Register r = as_Register(i);
170     if (r == G1 || r == G3 || r == G4 || r == G5) {
171       int sp_offset = cpu_reg_save_offsets[i];
172       oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
173                                 r-&gt;as_VMReg());
174     }
175   }
176 
177   if (save_fpu_registers) {
178     for (i = 0; i &lt; FrameMap::nof_fpu_regs; i++) {
179       FloatRegister r = as_FloatRegister(i);
180       int sp_offset = fpu_reg_save_offsets[i];
181       oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
182                                 r-&gt;as_VMReg());
183     }
184   }
185   return oop_map;
186 }
187 
188 #define __ this-&gt;
189 
190 void C1_MacroAssembler::save_live_registers_no_oop_map(bool save_fpu_registers) {
191   assert(frame_size_in_bytes == __ total_frame_size_in_bytes(reg_save_size_in_words),
192          &quot;mismatch in calculation&quot;);
193   __ save_frame_c1(frame_size_in_bytes);
194 
195   // Record volatile registers as callee-save values in an OopMap so their save locations will be
196   // propagated to the caller frame&#39;s RegisterMap during StackFrameStream construction (needed for
197   // deoptimization; see compiledVFrame::create_stack_value).  The caller&#39;s I, L and O registers
198   // are saved in register windows - I&#39;s and L&#39;s in the caller&#39;s frame and O&#39;s in the stub frame
199   // (as the stub&#39;s I&#39;s) when the runtime routine called by the stub creates its frame.
200   // OopMap frame sizes are in c2 stack slot sizes (sizeof(jint))
201 
202   int i;
203   for (i = 0; i &lt; FrameMap::nof_cpu_regs; i++) {
204     Register r = as_Register(i);
205     if (r == G1 || r == G3 || r == G4 || r == G5) {
206       int sp_offset = cpu_reg_save_offsets[i];
207       __ st_ptr(r, SP, (sp_offset * BytesPerWord) + STACK_BIAS);
208     }
209   }
210 
211   if (save_fpu_registers) {
212     for (i = 0; i &lt; FrameMap::nof_fpu_regs; i++) {
213       FloatRegister r = as_FloatRegister(i);
214       int sp_offset = fpu_reg_save_offsets[i];
215       __ stf(FloatRegisterImpl::S, r, SP, (sp_offset * BytesPerWord) + STACK_BIAS);
216     }
217   }
218 }
219 
220 void C1_MacroAssembler::restore_live_registers(bool restore_fpu_registers) {
221   for (int i = 0; i &lt; FrameMap::nof_cpu_regs; i++) {
222     Register r = as_Register(i);
223     if (r == G1 || r == G3 || r == G4 || r == G5) {
224       __ ld_ptr(SP, (cpu_reg_save_offsets[i] * BytesPerWord) + STACK_BIAS, r);
225     }
226   }
227 
228   if (restore_fpu_registers) {
229     for (int i = 0; i &lt; FrameMap::nof_fpu_regs; i++) {
230       FloatRegister r = as_FloatRegister(i);
231       __ ldf(FloatRegisterImpl::S, SP, (fpu_reg_save_offsets[i] * BytesPerWord) + STACK_BIAS, r);
232     }
233   }
234 }
235 
236 #undef __
237 #define __ sasm-&gt;
238 
239 static OopMap* save_live_registers(StubAssembler* sasm, bool save_fpu_registers = true) {
240   __ save_live_registers_no_oop_map(save_fpu_registers);
241   return generate_oop_map(sasm, save_fpu_registers);
242 }
243 
244 static void restore_live_registers(StubAssembler* sasm, bool restore_fpu_registers = true) {
245   __ restore_live_registers(restore_fpu_registers);
246 }
247 
248 
249 void Runtime1::initialize_pd() {
250   // compute word offsets from SP at which live (non-windowed) registers are captured by stub routines
251   //
252   // A stub routine will have a frame that is at least large enough to hold
253   // a register window save area (obviously) and the volatile g registers
254   // and floating registers. A user of save_live_registers can have a frame
255   // that has more scratch area in it (although typically they will use L-regs).
256   // in that case the frame will look like this (stack growing down)
257   //
258   // FP -&gt; |             |
259   //       | scratch mem |
260   //       |   &quot;      &quot;  |
261   //       --------------
262   //       | float regs  |
263   //       |   &quot;    &quot;    |
264   //       ---------------
265   //       | G regs      |
266   //       | &quot;  &quot;        |
267   //       ---------------
268   //       | abi reg.    |
269   //       | window save |
270   //       | area        |
271   // SP -&gt; ---------------
272   //
273   int i;
274   int sp_offset = align_up((int)frame::register_save_words, 2); //  start doubleword aligned
275 
276   // only G int registers are saved explicitly; others are found in register windows
277   for (i = 0; i &lt; FrameMap::nof_cpu_regs; i++) {
278     Register r = as_Register(i);
279     if (r == G1 || r == G3 || r == G4 || r == G5) {
280       cpu_reg_save_offsets[i] = sp_offset;
281       sp_offset++;
282     }
283   }
284 
285   // all float registers are saved explicitly
286   assert(FrameMap::nof_fpu_regs == 32, &quot;double registers not handled here&quot;);
287   for (i = 0; i &lt; FrameMap::nof_fpu_regs; i++) {
288     fpu_reg_save_offsets[i] = sp_offset;
289     sp_offset++;
290   }
291   reg_save_size_in_words = sp_offset - frame::memory_parameter_word_sp_offset;
292   // this should match assembler::total_frame_size_in_bytes, which
293   // isn&#39;t callable from this context.  It&#39;s checked by an assert when
294   // it&#39;s used though.
295   frame_size_in_bytes = align_up(sp_offset * wordSize, 8);
296 }
297 
298 
299 OopMapSet* Runtime1::generate_exception_throw(StubAssembler* sasm, address target, bool has_argument) {
300   // make a frame and preserve the caller&#39;s caller-save registers
301   OopMap* oop_map = save_live_registers(sasm);
302   int call_offset;
303   if (!has_argument) {
304     call_offset = __ call_RT(noreg, noreg, target);
305   } else {
306     call_offset = __ call_RT(noreg, noreg, target, G4, G5);
307   }
308   OopMapSet* oop_maps = new OopMapSet();
309   oop_maps-&gt;add_gc_map(call_offset, oop_map);
310 
311   __ should_not_reach_here();
312   return oop_maps;
313 }
314 
315 
316 OopMapSet* Runtime1::generate_stub_call(StubAssembler* sasm, Register result, address target,
317                                         Register arg1, Register arg2, Register arg3) {
318   // make a frame and preserve the caller&#39;s caller-save registers
319   OopMap* oop_map = save_live_registers(sasm);
320 
321   int call_offset;
322   if (arg1 == noreg) {
323     call_offset = __ call_RT(result, noreg, target);
324   } else if (arg2 == noreg) {
325     call_offset = __ call_RT(result, noreg, target, arg1);
326   } else if (arg3 == noreg) {
327     call_offset = __ call_RT(result, noreg, target, arg1, arg2);
328   } else {
329     call_offset = __ call_RT(result, noreg, target, arg1, arg2, arg3);
330   }
331   OopMapSet* oop_maps = NULL;
332 
333   oop_maps = new OopMapSet();
334   oop_maps-&gt;add_gc_map(call_offset, oop_map);
335   restore_live_registers(sasm);
336 
337   __ ret();
338   __ delayed()-&gt;restore();
339 
340   return oop_maps;
341 }
342 
343 
344 OopMapSet* Runtime1::generate_patching(StubAssembler* sasm, address target) {
345   // make a frame and preserve the caller&#39;s caller-save registers
346   OopMap* oop_map = save_live_registers(sasm);
347 
348   // call the runtime patching routine, returns non-zero if nmethod got deopted.
349   int call_offset = __ call_RT(noreg, noreg, target);
350   OopMapSet* oop_maps = new OopMapSet();
351   oop_maps-&gt;add_gc_map(call_offset, oop_map);
352 
353   // re-execute the patched instruction or, if the nmethod was deoptmized, return to the
354   // deoptimization handler entry that will cause re-execution of the current bytecode
355   DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
356   assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
357 
358   Label no_deopt;
359   __ br_null_short(O0, Assembler::pt, no_deopt);
360 
361   // return to the deoptimization handler entry for unpacking and rexecute
362   // if we simply returned the we&#39;d deopt as if any call we patched had just
363   // returned.
364 
365   restore_live_registers(sasm);
366 
367   AddressLiteral dest(deopt_blob-&gt;unpack_with_reexecution());
368   __ jump_to(dest, O0);
369   __ delayed()-&gt;restore();
370 
371   __ bind(no_deopt);
372   restore_live_registers(sasm);
373   __ ret();
374   __ delayed()-&gt;restore();
375 
376   return oop_maps;
377 }
378 
379 OopMapSet* Runtime1::generate_code_for(StubID id, StubAssembler* sasm) {
380 
381   OopMapSet* oop_maps = NULL;
382   // for better readability
383   const bool must_gc_arguments = true;
384   const bool dont_gc_arguments = false;
385 
386   // stub code &amp; info for the different stubs
387   switch (id) {
388     case forward_exception_id:
389       {
390         oop_maps = generate_handle_exception(id, sasm);
391       }
392       break;
393 
394     case new_instance_id:
395     case fast_new_instance_id:
396     case fast_new_instance_init_check_id:
397       {
398         Register G5_klass = G5; // Incoming
399         Register O0_obj   = O0; // Outgoing
400 
401         if (id == new_instance_id) {
402           __ set_info(&quot;new_instance&quot;, dont_gc_arguments);
403         } else if (id == fast_new_instance_id) {
404           __ set_info(&quot;fast new_instance&quot;, dont_gc_arguments);
405         } else {
406           assert(id == fast_new_instance_init_check_id, &quot;bad StubID&quot;);
407           __ set_info(&quot;fast new_instance init check&quot;, dont_gc_arguments);
408         }
409 
410         // If TLAB is disabled, see if there is support for inlining contiguous
411         // allocations.
412         // Otherwise, just go to the slow path.
413         if ((id == fast_new_instance_id || id == fast_new_instance_init_check_id) &amp;&amp;
414             !UseTLAB &amp;&amp; Universe::heap()-&gt;supports_inline_contig_alloc()) {
415           Label slow_path;
416           Register G1_obj_size = G1;
417           Register G3_t1 = G3;
418           Register G4_t2 = G4;
419           assert_different_registers(G5_klass, G1_obj_size, G3_t1, G4_t2);
420 
421           // Push a frame since we may do dtrace notification for the
422           // allocation which requires calling out and we don&#39;t want
423           // to stomp the real return address.
424           __ save_frame(0);
425 
426           if (id == fast_new_instance_init_check_id) {
427             // make sure the klass is initialized
428             __ ldub(G5_klass, in_bytes(InstanceKlass::init_state_offset()), G3_t1);
429             __ cmp(G3_t1, InstanceKlass::fully_initialized);
430             __ br(Assembler::notEqual, false, Assembler::pn, slow_path);
431             __ delayed()-&gt;nop();
432           }
433 #ifdef ASSERT
434           // assert object can be fast path allocated
435           {
436             Label ok, not_ok;
437           __ ld(G5_klass, in_bytes(Klass::layout_helper_offset()), G1_obj_size);
438           // make sure it&#39;s an instance (LH &gt; 0)
439           __ cmp_and_br_short(G1_obj_size, 0, Assembler::lessEqual, Assembler::pn, not_ok);
440           __ btst(Klass::_lh_instance_slow_path_bit, G1_obj_size);
441           __ br(Assembler::zero, false, Assembler::pn, ok);
442           __ delayed()-&gt;nop();
443           __ bind(not_ok);
444           __ stop(&quot;assert(can be fast path allocated)&quot;);
445           __ should_not_reach_here();
446           __ bind(ok);
447           }
448 #endif // ASSERT
449 
450           // If we got here then the TLAB allocation failed, so try allocating directly from eden.
451           // get the instance size
452           __ ld(G5_klass, in_bytes(Klass::layout_helper_offset()), G1_obj_size);
453           __ eden_allocate(O0_obj, G1_obj_size, 0, G3_t1, G4_t2, slow_path);
454           __ incr_allocated_bytes(G1_obj_size, G3_t1, G4_t2);
455 
456           __ initialize_object(O0_obj, G5_klass, G1_obj_size, 0, G3_t1, G4_t2, /* is_tlab_allocated */ false);
457           __ verify_oop(O0_obj);
458           __ mov(O0, I0);
459           __ ret();
460           __ delayed()-&gt;restore();
461 
462           __ bind(slow_path);
463 
464           // pop this frame so generate_stub_call can push it&#39;s own
465           __ restore();
466         }
467 
468         oop_maps = generate_stub_call(sasm, I0, CAST_FROM_FN_PTR(address, new_instance), G5_klass);
469         // I0-&gt;O0: new instance
470       }
471 
472       break;
473 
474     case counter_overflow_id:
475         // G4 contains bci, G5 contains method
476       oop_maps = generate_stub_call(sasm, noreg, CAST_FROM_FN_PTR(address, counter_overflow), G4, G5);
477       break;
478 
479     case new_type_array_id:
480     case new_object_array_id:
481       {
482         Register G5_klass = G5; // Incoming
483         Register G4_length = G4; // Incoming
484         Register O0_obj   = O0; // Outgoing
485 
486         Address klass_lh(G5_klass, Klass::layout_helper_offset());
487         assert(Klass::_lh_header_size_shift % BitsPerByte == 0, &quot;bytewise&quot;);
488         assert(Klass::_lh_header_size_mask == 0xFF, &quot;bytewise&quot;);
489         // Use this offset to pick out an individual byte of the layout_helper:
490         const int klass_lh_header_size_offset = ((BytesPerInt - 1)  // 3 - 2 selects byte {0,1,0,0}
491                                                  - Klass::_lh_header_size_shift / BitsPerByte);
492 
493         if (id == new_type_array_id) {
494           __ set_info(&quot;new_type_array&quot;, dont_gc_arguments);
495         } else {
496           __ set_info(&quot;new_object_array&quot;, dont_gc_arguments);
497         }
498 
499 #ifdef ASSERT
500         // assert object type is really an array of the proper kind
501         {
502           Label ok;
503           Register G3_t1 = G3;
504           __ ld(klass_lh, G3_t1);
505           __ sra(G3_t1, Klass::_lh_array_tag_shift, G3_t1);
506           int tag = ((id == new_type_array_id)
507                      ? Klass::_lh_array_tag_type_value
508                      : Klass::_lh_array_tag_obj_value);
509           __ cmp_and_brx_short(G3_t1, tag, Assembler::equal, Assembler::pt, ok);
510           __ stop(&quot;assert(is an array klass)&quot;);
511           __ should_not_reach_here();
512           __ bind(ok);
513         }
514 #endif // ASSERT
515 
516         if (id == new_type_array_id) {
517           oop_maps = generate_stub_call(sasm, I0, CAST_FROM_FN_PTR(address, new_type_array), G5_klass, G4_length);
518         } else {
519           oop_maps = generate_stub_call(sasm, I0, CAST_FROM_FN_PTR(address, new_object_array), G5_klass, G4_length);
520         }
521         // I0 -&gt; O0: new array
522       }
523       break;
524 
525     case new_multi_array_id:
526       { // O0: klass
527         // O1: rank
528         // O2: address of 1st dimension
529         __ set_info(&quot;new_multi_array&quot;, dont_gc_arguments);
530         oop_maps = generate_stub_call(sasm, I0, CAST_FROM_FN_PTR(address, new_multi_array), I0, I1, I2);
531         // I0 -&gt; O0: new multi array
532       }
533       break;
534 
535     case register_finalizer_id:
536       {
537         __ set_info(&quot;register_finalizer&quot;, dont_gc_arguments);
538 
539         // load the klass and check the has finalizer flag
540         Label register_finalizer;
541         Register t = O1;
542         __ load_klass(O0, t);
543         __ ld(t, in_bytes(Klass::access_flags_offset()), t);
544         __ set(JVM_ACC_HAS_FINALIZER, G3);
545         __ andcc(G3, t, G0);
546         __ br(Assembler::notZero, false, Assembler::pt, register_finalizer);
547         __ delayed()-&gt;nop();
548 
549         // do a leaf return
550         __ retl();
551         __ delayed()-&gt;nop();
552 
553         __ bind(register_finalizer);
554         OopMap* oop_map = save_live_registers(sasm);
555         int call_offset = __ call_RT(noreg, noreg,
556                                      CAST_FROM_FN_PTR(address, SharedRuntime::register_finalizer), I0);
557         oop_maps = new OopMapSet();
558         oop_maps-&gt;add_gc_map(call_offset, oop_map);
559 
560         // Now restore all the live registers
561         restore_live_registers(sasm);
562 
563         __ ret();
564         __ delayed()-&gt;restore();
565       }
566       break;
567 
568     case throw_range_check_failed_id:
569       { __ set_info(&quot;range_check_failed&quot;, dont_gc_arguments); // arguments will be discarded
570         // G4: index
571         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_range_check_exception), true);
572       }
573       break;
574 
575     case throw_index_exception_id:
576       { __ set_info(&quot;index_range_check_failed&quot;, dont_gc_arguments); // arguments will be discarded
577         // G4: index
578         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_index_exception), true);
579       }
580       break;
581 
582     case throw_div0_exception_id:
583       { __ set_info(&quot;throw_div0_exception&quot;, dont_gc_arguments);
584         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_div0_exception), false);
585       }
586       break;
587 
588     case throw_null_pointer_exception_id:
589       { __ set_info(&quot;throw_null_pointer_exception&quot;, dont_gc_arguments);
590         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_null_pointer_exception), false);
591       }
592       break;
593 
594     case handle_exception_id:
595       { __ set_info(&quot;handle_exception&quot;, dont_gc_arguments);
596         oop_maps = generate_handle_exception(id, sasm);
597       }
598       break;
599 
600     case handle_exception_from_callee_id:
601       { __ set_info(&quot;handle_exception_from_callee&quot;, dont_gc_arguments);
602         oop_maps = generate_handle_exception(id, sasm);
603       }
604       break;
605 
606     case unwind_exception_id:
607       {
608         // O0: exception
609         // I7: address of call to this method
610 
611         __ set_info(&quot;unwind_exception&quot;, dont_gc_arguments);
612         __ mov(Oexception, Oexception-&gt;after_save());
613         __ add(I7, frame::pc_return_offset, Oissuing_pc-&gt;after_save());
614 
615         __ call_VM_leaf(L7_thread_cache, CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address),
616                         G2_thread, Oissuing_pc-&gt;after_save());
617         __ verify_not_null_oop(Oexception-&gt;after_save());
618 
619         // Restore SP from L7 if the exception PC is a method handle call site.
620         __ mov(O0, G5);  // Save the target address.
621         __ lduw(Address(G2_thread, JavaThread::is_method_handle_return_offset()), L0);
622         __ tst(L0);  // Condition codes are preserved over the restore.
623         __ restore();
624 
625         __ jmp(G5, 0);
626         __ delayed()-&gt;movcc(Assembler::notZero, false, Assembler::icc, L7_mh_SP_save, SP);  // Restore SP if required.
627       }
628       break;
629 
630     case throw_array_store_exception_id:
631       {
632         __ set_info(&quot;throw_array_store_exception&quot;, dont_gc_arguments);
633         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_array_store_exception), true);
634       }
635       break;
636 
637     case throw_class_cast_exception_id:
638       {
639         // G4: object
640         __ set_info(&quot;throw_class_cast_exception&quot;, dont_gc_arguments);
641         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_class_cast_exception), true);
642       }
643       break;
644 
645     case throw_incompatible_class_change_error_id:
646       {
647         __ set_info(&quot;throw_incompatible_class_cast_exception&quot;, dont_gc_arguments);
648         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_incompatible_class_change_error), false);
649       }
650       break;
651 
652     case slow_subtype_check_id:
653       { // Support for uint StubRoutine::partial_subtype_check( Klass sub, Klass super );
654         // Arguments :
655         //
656         //      ret  : G3
657         //      sub  : G3, argument, destroyed
658         //      super: G1, argument, not changed
659         //      raddr: O7, blown by call
660         Label miss;
661 
662         __ save_frame(0);               // Blow no registers!
663 
664         __ check_klass_subtype_slow_path(G3, G1, L0, L1, L2, L4, NULL, &amp;miss);
665 
666         __ mov(1, G3);
667         __ ret();                       // Result in G5 is &#39;true&#39;
668         __ delayed()-&gt;restore();        // free copy or add can go here
669 
670         __ bind(miss);
671         __ mov(0, G3);
672         __ ret();                       // Result in G5 is &#39;false&#39;
673         __ delayed()-&gt;restore();        // free copy or add can go here
674       }
675 
676     case monitorenter_nofpu_id:
677     case monitorenter_id:
678       { // G4: object
679         // G5: lock address
680         __ set_info(&quot;monitorenter&quot;, dont_gc_arguments);
681 
682         int save_fpu_registers = (id == monitorenter_id);
683         // make a frame and preserve the caller&#39;s caller-save registers
684         OopMap* oop_map = save_live_registers(sasm, save_fpu_registers);
685 
686         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, monitorenter), G4, G5);
687 
688         oop_maps = new OopMapSet();
689         oop_maps-&gt;add_gc_map(call_offset, oop_map);
690         restore_live_registers(sasm, save_fpu_registers);
691 
692         __ ret();
693         __ delayed()-&gt;restore();
694       }
695       break;
696 
697     case monitorexit_nofpu_id:
698     case monitorexit_id:
699       { // G4: lock address
700         // note: really a leaf routine but must setup last java sp
701         //       =&gt; use call_RT for now (speed can be improved by
702         //       doing last java sp setup manually)
703         __ set_info(&quot;monitorexit&quot;, dont_gc_arguments);
704 
705         int save_fpu_registers = (id == monitorexit_id);
706         // make a frame and preserve the caller&#39;s caller-save registers
707         OopMap* oop_map = save_live_registers(sasm, save_fpu_registers);
708 
709         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, monitorexit), G4);
710 
711         oop_maps = new OopMapSet();
712         oop_maps-&gt;add_gc_map(call_offset, oop_map);
713         restore_live_registers(sasm, save_fpu_registers);
714 
715         __ ret();
716         __ delayed()-&gt;restore();
717       }
718       break;
719 
720     case deoptimize_id:
721       {
722         __ set_info(&quot;deoptimize&quot;, dont_gc_arguments);
723         OopMap* oop_map = save_live_registers(sasm);
724         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, deoptimize), G4);
725         oop_maps = new OopMapSet();
726         oop_maps-&gt;add_gc_map(call_offset, oop_map);
727         restore_live_registers(sasm);
728         DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
729         assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
730         AddressLiteral dest(deopt_blob-&gt;unpack_with_reexecution());
731         __ jump_to(dest, O0);
732         __ delayed()-&gt;restore();
733       }
734       break;
735 
736     case access_field_patching_id:
737       { __ set_info(&quot;access_field_patching&quot;, dont_gc_arguments);
738         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, access_field_patching));
739       }
740       break;
741 
742     case load_klass_patching_id:
743       { __ set_info(&quot;load_klass_patching&quot;, dont_gc_arguments);
744         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, move_klass_patching));
745       }
746       break;
747 
748     case load_mirror_patching_id:
749       { __ set_info(&quot;load_mirror_patching&quot;, dont_gc_arguments);
750         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, move_mirror_patching));
751       }
752       break;
753 
754     case load_appendix_patching_id:
755       { __ set_info(&quot;load_appendix_patching&quot;, dont_gc_arguments);
756         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, move_appendix_patching));
757       }
758       break;
759 
760     case dtrace_object_alloc_id:
761       { // O0: object
762         __ set_info(&quot;dtrace_object_alloc&quot;, dont_gc_arguments);
763         // we can&#39;t gc here so skip the oopmap but make sure that all
764         // the live registers get saved.
765         save_live_registers(sasm);
766 
767         __ save_thread(L7_thread_cache);
768         __ call(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc),
769                 relocInfo::runtime_call_type);
770         __ delayed()-&gt;mov(I0, O0);
771         __ restore_thread(L7_thread_cache);
772 
773         restore_live_registers(sasm);
774         __ ret();
775         __ delayed()-&gt;restore();
776       }
777       break;
778 
779     case predicate_failed_trap_id:
780       {
781         __ set_info(&quot;predicate_failed_trap&quot;, dont_gc_arguments);
782         OopMap* oop_map = save_live_registers(sasm);
783 
784         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, predicate_failed_trap));
785 
786         oop_maps = new OopMapSet();
787         oop_maps-&gt;add_gc_map(call_offset, oop_map);
788 
789         DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
790         assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
791         restore_live_registers(sasm);
792 
793         AddressLiteral dest(deopt_blob-&gt;unpack_with_reexecution());
794         __ jump_to(dest, O0);
795         __ delayed()-&gt;restore();
796       }
797       break;
798 
799     default:
800       { __ set_info(&quot;unimplemented entry&quot;, dont_gc_arguments);
801         __ save_frame(0);
802         __ set((int)id, O1);
803         __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, unimplemented_entry), O1);
804         __ should_not_reach_here();
805       }
806       break;
807   }
808   return oop_maps;
809 }
810 
811 
812 OopMapSet* Runtime1::generate_handle_exception(StubID id, StubAssembler* sasm) {
813   __ block_comment(&quot;generate_handle_exception&quot;);
814 
815   // Save registers, if required.
816   OopMapSet* oop_maps = new OopMapSet();
817   OopMap* oop_map = NULL;
818   switch (id) {
819   case forward_exception_id:
820     // We&#39;re handling an exception in the context of a compiled frame.
821     // The registers have been saved in the standard places.  Perform
822     // an exception lookup in the caller and dispatch to the handler
823     // if found.  Otherwise unwind and dispatch to the callers
824     // exception handler.
825      oop_map = generate_oop_map(sasm, true);
826 
827      // transfer the pending exception to the exception_oop
828      __ ld_ptr(G2_thread, in_bytes(JavaThread::pending_exception_offset()), Oexception);
829      __ ld_ptr(Oexception, 0, G0);
830      __ st_ptr(G0, G2_thread, in_bytes(JavaThread::pending_exception_offset()));
831      __ add(I7, frame::pc_return_offset, Oissuing_pc);
832     break;
833   case handle_exception_id:
834     // At this point all registers MAY be live.
835     oop_map = save_live_registers(sasm);
836     __ mov(Oexception-&gt;after_save(),  Oexception);
837     __ mov(Oissuing_pc-&gt;after_save(), Oissuing_pc);
838     break;
839   case handle_exception_from_callee_id:
840     // At this point all registers except exception oop (Oexception)
841     // and exception pc (Oissuing_pc) are dead.
842     oop_map = new OopMap(frame_size_in_bytes / sizeof(jint), 0);
843     sasm-&gt;set_frame_size(frame_size_in_bytes / BytesPerWord);
844     __ save_frame_c1(frame_size_in_bytes);
845     __ mov(Oexception-&gt;after_save(),  Oexception);
846     __ mov(Oissuing_pc-&gt;after_save(), Oissuing_pc);
847     break;
848   default:  ShouldNotReachHere();
849   }
850 
851   __ verify_not_null_oop(Oexception);
852 
853 #ifdef ASSERT
854   // check that fields in JavaThread for exception oop and issuing pc are
855   // empty before writing to them
856   Label oop_empty;
857   Register scratch = I7;  // We can use I7 here because it&#39;s overwritten later anyway.
858   __ ld_ptr(Address(G2_thread, JavaThread::exception_oop_offset()), scratch);
859   __ br_null(scratch, false, Assembler::pt, oop_empty);
860   __ delayed()-&gt;nop();
861   __ stop(&quot;exception oop already set&quot;);
862   __ bind(oop_empty);
863 
864   Label pc_empty;
865   __ ld_ptr(Address(G2_thread, JavaThread::exception_pc_offset()), scratch);
866   __ br_null(scratch, false, Assembler::pt, pc_empty);
867   __ delayed()-&gt;nop();
868   __ stop(&quot;exception pc already set&quot;);
869   __ bind(pc_empty);
870 #endif
871 
872   // save the exception and issuing pc in the thread
873   __ st_ptr(Oexception,  G2_thread, in_bytes(JavaThread::exception_oop_offset()));
874   __ st_ptr(Oissuing_pc, G2_thread, in_bytes(JavaThread::exception_pc_offset()));
875 
876   // use the throwing pc as the return address to lookup (has bci &amp; oop map)
877   __ mov(Oissuing_pc, I7);
878   __ sub(I7, frame::pc_return_offset, I7);
879   int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, exception_handler_for_pc));
880   oop_maps-&gt;add_gc_map(call_offset, oop_map);
881 
882   // Note: if nmethod has been deoptimized then regardless of
883   // whether it had a handler or not we will deoptimize
884   // by entering the deopt blob with a pending exception.
885 
886   // Restore the registers that were saved at the beginning, remove
887   // the frame and jump to the exception handler.
888   switch (id) {
889   case forward_exception_id:
890   case handle_exception_id:
891     restore_live_registers(sasm);
892     __ jmp(O0, 0);
893     __ delayed()-&gt;restore();
894     break;
895   case handle_exception_from_callee_id:
896     // Restore SP from L7 if the exception PC is a method handle call site.
897     __ mov(O0, G5);  // Save the target address.
898     __ lduw(Address(G2_thread, JavaThread::is_method_handle_return_offset()), L0);
899     __ tst(L0);  // Condition codes are preserved over the restore.
900     __ restore();
901 
902     __ jmp(G5, 0);  // jump to the exception handler
903     __ delayed()-&gt;movcc(Assembler::notZero, false, Assembler::icc, L7_mh_SP_save, SP);  // Restore SP if required.
904     break;
905   default:  ShouldNotReachHere();
906   }
907 
908   return oop_maps;
909 }
910 
911 
912 #undef __
913 
914 const char *Runtime1::pd_name_for_address(address entry) {
915   return &quot;&lt;unknown function&gt;&quot;;
916 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
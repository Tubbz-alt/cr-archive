<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/sparc/sparc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_sparc.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/sparc.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  //
<span class="line-modified">! // Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  //
  // This code is free software; you can redistribute it and/or modify it
  // under the terms of the GNU General Public License version 2 only, as
  // published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  //
<span class="line-modified">! // Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  //
  // This code is free software; you can redistribute it and/or modify it
  // under the terms of the GNU General Public License version 2 only, as
  // published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1293,11 ***</span>
  }
  
  #ifndef PRODUCT
  ATTRIBUTE_PRINTF(2, 3)
  static void print_helper(outputStream* st, const char* format, ...) {
<span class="line-modified">!   if (st-&gt;position() &gt; 0) {</span>
      st-&gt;cr();
      st-&gt;sp();
    }
    va_list ap;
    va_start(ap, format);
<span class="line-new-header">--- 1293,12 ---</span>
  }
  
  #ifndef PRODUCT
  ATTRIBUTE_PRINTF(2, 3)
  static void print_helper(outputStream* st, const char* format, ...) {
<span class="line-modified">!   const int tab_size = 8;</span>
<span class="line-added">+   if (st-&gt;position() &gt; tab_size) {</span>
      st-&gt;cr();
      st-&gt;sp();
    }
    va_list ap;
    va_start(ap, format);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1577,19 ***</span>
  void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
    st-&gt;print_cr(&quot;\nUEP:&quot;);
    if (UseCompressedClassPointers) {
      assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
      st-&gt;print_cr(&quot;\tLDUW   [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check - compressed klass&quot;);
<span class="line-modified">!     if (Universe::narrow_klass_base() != 0) {</span>
<span class="line-modified">!       st-&gt;print_cr(&quot;\tSET    Universe::narrow_klass_base,R_G6_heap_base&quot;);</span>
<span class="line-modified">!       if (Universe::narrow_klass_shift() != 0) {</span>
<span class="line-modified">!         st-&gt;print_cr(&quot;\tSLL    R_G5,Universe::narrow_klass_shift,R_G5&quot;);</span>
        }
        st-&gt;print_cr(&quot;\tADD    R_G5,R_G6_heap_base,R_G5&quot;);
<span class="line-modified">!       st-&gt;print_cr(&quot;\tSET    Universe::narrow_ptrs_base,R_G6_heap_base&quot;);</span>
      } else {
<span class="line-modified">!       st-&gt;print_cr(&quot;\tSLL    R_G5,Universe::narrow_klass_shift,R_G5&quot;);</span>
      }
    } else {
      st-&gt;print_cr(&quot;\tLDX    [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check&quot;);
    }
    st-&gt;print_cr(&quot;\tCMP    R_G5,R_G3&quot; );
<span class="line-new-header">--- 1578,19 ---</span>
  void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
    st-&gt;print_cr(&quot;\nUEP:&quot;);
    if (UseCompressedClassPointers) {
      assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
      st-&gt;print_cr(&quot;\tLDUW   [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check - compressed klass&quot;);
<span class="line-modified">!     if (CompressedKlassPointers::base() != 0) {</span>
<span class="line-modified">!       st-&gt;print_cr(&quot;\tSET    CompressedKlassPointers::base,R_G6_heap_base&quot;);</span>
<span class="line-modified">!       if (CompressedKlassPointers::shift() != 0) {</span>
<span class="line-modified">!         st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);</span>
        }
        st-&gt;print_cr(&quot;\tADD    R_G5,R_G6_heap_base,R_G5&quot;);
<span class="line-modified">!       st-&gt;print_cr(&quot;\tSET    CompressedOops::ptrs_base,R_G6_heap_base&quot;);</span>
      } else {
<span class="line-modified">!       st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);</span>
      }
    } else {
      st-&gt;print_cr(&quot;\tLDX    [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check&quot;);
    }
    st-&gt;print_cr(&quot;\tCMP    R_G5,R_G3&quot; );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1708,11 ***</span>
    }
  
    return true;  // Per default match rules are supported.
  }
  
<span class="line-modified">! const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {</span>
  
    // TODO
    // identify extra cases that we might want to provide match rules for
    // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
    bool ret_value = match_rule_supported(opcode);
<span class="line-new-header">--- 1709,11 ---</span>
    }
  
    return true;  // Per default match rules are supported.
  }
  
<span class="line-modified">! const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {</span>
  
    // TODO
    // identify extra cases that we might want to provide match rules for
    // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
    bool ret_value = match_rule_supported(opcode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1812,10 ***</span>
<span class="line-new-header">--- 1813,28 ---</span>
  
  // Do we need to mask the count passed to shift instructions or does
  // the cpu only look at the lower 5/6 bits anyway?
  const bool Matcher::need_masked_shift_count = false;
  
<span class="line-added">+ // No support for generic vector operands.</span>
<span class="line-added">+ const bool Matcher::supports_generic_vector_operands  = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+ MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {</span>
<span class="line-added">+   ShouldNotReachHere(); // generic vector operands not supported</span>
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Matcher::is_generic_reg2reg_move(MachNode* m) {</span>
<span class="line-added">+   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Matcher::is_generic_vector(MachOper* opnd)  {</span>
<span class="line-added">+   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool Matcher::narrow_oop_use_complex_address() {
    assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
    return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1825,18 ***</span>
  }
  
  bool Matcher::const_oop_prefer_decode() {
    // TODO: Check if loading ConP from TOC in heap-based mode is better:
    // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="line-modified">!   // return Universe::narrow_oop_base() == NULL;</span>
    return true;
  }
  
  bool Matcher::const_klass_prefer_decode() {
    // TODO: Check if loading ConP from TOC in heap-based mode is better:
    // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified">!   // return Universe::narrow_klass_base() == NULL;</span>
    return true;
  }
  
  // Is it better to copy float constants, or load them directly from memory?
  // Intel can load a float constant from a direct address, requiring no
<span class="line-new-header">--- 1844,18 ---</span>
  }
  
  bool Matcher::const_oop_prefer_decode() {
    // TODO: Check if loading ConP from TOC in heap-based mode is better:
    // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="line-modified">!   // return CompressedOops::base() == NULL;</span>
    return true;
  }
  
  bool Matcher::const_klass_prefer_decode() {
    // TODO: Check if loading ConP from TOC in heap-based mode is better:
    // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified">!   // return CompressedKlassPointers::base() == NULL;</span>
    return true;
  }
  
  // Is it better to copy float constants, or load them directly from memory?
  // Intel can load a float constant from a direct address, requiring no
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1852,12 ***</span>
  
  // No-op on SPARC.
  void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
  }
  
<span class="line-modified">! // Advertise here if the CPU requires explicit rounding operations</span>
<span class="line-removed">- // to implement the UseStrictFP mode.</span>
  const bool Matcher::strict_fp_requires_explicit_rounding = false;
  
  // Are floats converted to double when stored to stack during deoptimization?
  // Sparc does not handle callee-save floats.
  bool Matcher::float_in_double() { return false; }
<span class="line-new-header">--- 1871,11 ---</span>
  
  // No-op on SPARC.
  void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
  }
  
<span class="line-modified">! // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>
  const bool Matcher::strict_fp_requires_explicit_rounding = false;
  
  // Are floats converted to double when stored to stack during deoptimization?
  // Sparc does not handle callee-save floats.
  bool Matcher::float_in_double() { return false; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6249,11 ***</span>
    match(Set dst (EncodeP src));
    format %{ &quot;encode_heap_oop $src, $dst&quot; %}
    ins_encode %{
      __ encode_heap_oop($src$$Register, $dst$$Register);
    %}
<span class="line-modified">!   ins_avoid_back_to_back(Universe::narrow_oop_base() == NULL ? AVOID_NONE : AVOID_BEFORE);</span>
    ins_pipe(ialu_reg);
  %}
  
  instruct encodeHeapOop_not_null(iRegN dst, iRegP src) %{
    predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
<span class="line-new-header">--- 6267,11 ---</span>
    match(Set dst (EncodeP src));
    format %{ &quot;encode_heap_oop $src, $dst&quot; %}
    ins_encode %{
      __ encode_heap_oop($src$$Register, $dst$$Register);
    %}
<span class="line-modified">!   ins_avoid_back_to_back(CompressedOops::base() == NULL ? AVOID_NONE : AVOID_BEFORE);</span>
    ins_pipe(ialu_reg);
  %}
  
  instruct encodeHeapOop_not_null(iRegN dst, iRegP src) %{
    predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6810,10 ***</span>
<span class="line-new-header">--- 6828,18 ---</span>
    ins_encode( /*empty encoding*/ );
    ins_cost(0);
    ins_pipe(empty);
  %}
  
<span class="line-added">+ instruct castLL( iRegL dst ) %{</span>
<span class="line-added">+   match(Set dst (CastLL dst));</span>
<span class="line-added">+   format %{ &quot;# castLL of $dst&quot; %}</span>
<span class="line-added">+   ins_encode( /*empty encoding*/ );</span>
<span class="line-added">+   ins_cost(0);</span>
<span class="line-added">+   ins_pipe(empty);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  //----------Arithmetic Instructions--------------------------------------------
  // Addition Instructions
  // Register Addition
  instruct addI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
    match(Set dst (AddI src1 src2));
</pre>
<center><a href="sharedRuntime_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_sparc.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
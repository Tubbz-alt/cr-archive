<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/interp_masm_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_sparc.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/interp_masm_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.inline.hpp&quot;
  27 #include &quot;interp_masm_sparc.hpp&quot;
  28 #include &quot;interpreter/interpreter.hpp&quot;
  29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  30 #include &quot;logging/log.hpp&quot;
  31 #include &quot;oops/arrayOop.hpp&quot;
<span class="line-modified">  32 #include &quot;oops/markOop.hpp&quot;</span>
  33 #include &quot;oops/methodData.hpp&quot;
  34 #include &quot;oops/method.hpp&quot;
  35 #include &quot;oops/methodCounters.hpp&quot;
  36 #include &quot;prims/jvmtiExport.hpp&quot;
  37 #include &quot;prims/jvmtiThreadState.hpp&quot;
  38 #include &quot;runtime/basicLock.hpp&quot;
  39 #include &quot;runtime/biasedLocking.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;runtime/thread.inline.hpp&quot;
  44 #include &quot;utilities/align.hpp&quot;

  45 
  46 // Implementation of InterpreterMacroAssembler
  47 
  48 // This file specializes the assember with interpreter-specific macros
  49 
  50 const Address InterpreterMacroAssembler::l_tmp(FP, (frame::interpreter_frame_l_scratch_fp_offset * wordSize) + STACK_BIAS);
  51 const Address InterpreterMacroAssembler::d_tmp(FP, (frame::interpreter_frame_d_scratch_fp_offset * wordSize) + STACK_BIAS);
  52 
  53 void InterpreterMacroAssembler::jump_to_entry(address entry) {
  54   assert(entry, &quot;Entry must have been generated by now&quot;);
  55   AddressLiteral al(entry);
  56   jump_to(al, G3_scratch);
  57   delayed()-&gt;nop();
  58 }
  59 
  60 void InterpreterMacroAssembler::compute_extra_locals_size_in_bytes(Register args_size, Register locals_size, Register delta) {
  61   // Note: this algorithm is also used by C1&#39;s OSR entry sequence.
  62   // Any changes should also be applied to CodeEmitter::emit_osr_entry().
  63   assert_different_registers(args_size, locals_size);
  64   // max_locals*2 for TAGS.  Assumes that args_size has already been adjusted.
</pre>
<hr />
<pre>
  74 }
  75 
  76 // Dispatch code executed in the prolog of a bytecode which does not do it&#39;s
  77 // own dispatch. The dispatch address is computed and placed in IdispatchAddress
  78 void InterpreterMacroAssembler::dispatch_prolog(TosState state, int bcp_incr) {
  79   assert_not_delayed();
  80   ldub( Lbcp, bcp_incr, Lbyte_code);                    // load next bytecode
  81   // dispatch table to use
  82   AddressLiteral tbl(Interpreter::dispatch_table(state));
  83   sll(Lbyte_code, LogBytesPerWord, Lbyte_code);         // multiply by wordSize
  84   set(tbl, G3_scratch);                                 // compute addr of table
  85   ld_ptr(G3_scratch, Lbyte_code, IdispatchAddress);     // get entry addr
  86 }
  87 
  88 
  89 // Dispatch code executed in the epilog of a bytecode which does not do it&#39;s
  90 // own dispatch. The dispatch address in IdispatchAddress is used for the
  91 // dispatch.
  92 void InterpreterMacroAssembler::dispatch_epilog(TosState state, int bcp_incr) {
  93   assert_not_delayed();
<span class="line-removed">  94   verify_FPU(1, state);</span>
  95   interp_verify_oop(Otos_i, state, __FILE__, __LINE__);
  96   jmp( IdispatchAddress, 0 );
  97   if (bcp_incr != 0)  delayed()-&gt;inc(Lbcp, bcp_incr);
  98   else                delayed()-&gt;nop();
  99 }
 100 
 101 void InterpreterMacroAssembler::dispatch_next(TosState state, int bcp_incr, bool generate_poll) {
 102   // %%%% consider branching to a single shared dispatch stub (for each bcp_incr)
 103   assert_not_delayed();
 104   ldub( Lbcp, bcp_incr, Lbyte_code);               // load next bytecode
 105   dispatch_Lbyte_code(state, Interpreter::dispatch_table(state), bcp_incr, true, generate_poll);
 106 }
 107 
 108 
 109 void InterpreterMacroAssembler::dispatch_next_noverify_oop(TosState state, int bcp_incr) {
 110   // %%%% consider branching to a single shared dispatch stub (for each bcp_incr)
 111   assert_not_delayed();
 112   ldub( Lbcp, bcp_incr, Lbyte_code);               // load next bytecode
 113   dispatch_Lbyte_code(state, Interpreter::dispatch_table(state), bcp_incr, false);
 114 }
</pre>
<hr />
<pre>
 247 void InterpreterMacroAssembler::dispatch_base(TosState state, address* table) {
 248   assert_not_delayed();
 249   dispatch_Lbyte_code(state, table);
 250 }
 251 
 252 
 253 void InterpreterMacroAssembler::dispatch_normal(TosState state) {
 254   dispatch_base(state, Interpreter::normal_table(state));
 255 }
 256 
 257 
 258 void InterpreterMacroAssembler::dispatch_only(TosState state) {
 259   dispatch_base(state, Interpreter::dispatch_table(state));
 260 }
 261 
 262 
 263 // common code to dispatch and dispatch_only
 264 // dispatch value in Lbyte_code and increment Lbcp
 265 
 266 void InterpreterMacroAssembler::dispatch_Lbyte_code(TosState state, address* table, int bcp_incr, bool verify, bool generate_poll) {
<span class="line-removed"> 267   verify_FPU(1, state);</span>
 268   // %%%%% maybe implement +VerifyActivationFrameSize here
 269   //verify_thread(); //too slow; we will just verify on method entry &amp; exit
 270   if (verify) interp_verify_oop(Otos_i, state, __FILE__, __LINE__);
 271   // dispatch table to use
 272   AddressLiteral tbl(table);
 273   Label dispatch;
 274 
 275   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; generate_poll) {
 276     AddressLiteral sfpt_tbl(Interpreter::safept_table(state));
 277     Label no_safepoint;
 278 
 279     if (tbl.value() != sfpt_tbl.value()) {
 280       ldx(Address(G2_thread, Thread::polling_page_offset()), G3_scratch, 0);
 281       // Armed page has poll_bit set, if poll bit is cleared just continue.
 282       and3(G3_scratch, SafepointMechanism::poll_bit(), G3_scratch);
 283 
 284       br_null_short(G3_scratch, Assembler::pt, no_safepoint);
 285       set(sfpt_tbl, G3_scratch);
 286       ba_short(dispatch);
 287     }
</pre>
<hr />
<pre>
1183 // Lock object
1184 //
1185 // Argument - lock_reg points to the BasicObjectLock to be used for locking,
1186 //            it must be initialized with the object to lock
1187 void InterpreterMacroAssembler::lock_object(Register lock_reg, Register Object) {
1188   if (UseHeavyMonitors) {
1189     call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), lock_reg);
1190   }
1191   else {
1192     Register obj_reg = Object;
1193     Register mark_reg = G4_scratch;
1194     Register temp_reg = G1_scratch;
1195     Address  lock_addr(lock_reg, BasicObjectLock::lock_offset_in_bytes());
1196     Address  mark_addr(obj_reg, oopDesc::mark_offset_in_bytes());
1197     Label    done;
1198 
1199     Label slow_case;
1200 
1201     assert_different_registers(lock_reg, obj_reg, mark_reg, temp_reg);
1202 
<span class="line-modified">1203     // load markOop from object into mark_reg</span>
1204     ld_ptr(mark_addr, mark_reg);
1205 
1206     if (UseBiasedLocking) {
1207       biased_locking_enter(obj_reg, mark_reg, temp_reg, done, &amp;slow_case);
1208     }
1209 
1210     // get the address of basicLock on stack that will be stored in the object
1211     // we need a temporary register here as we do not want to clobber lock_reg
1212     // (cas clobbers the destination register)
1213     mov(lock_reg, temp_reg);
<span class="line-modified">1214     // set mark reg to be (markOop of object | UNLOCK_VALUE)</span>
<span class="line-modified">1215     or3(mark_reg, markOopDesc::unlocked_value, mark_reg);</span>
1216     // initialize the box  (Must happen before we update the object mark!)
1217     st_ptr(mark_reg, lock_addr, BasicLock::displaced_header_offset_in_bytes());
<span class="line-modified">1218     // compare and exchange object_addr, markOop | 1, stack address of basicLock</span>
1219     assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
1220     cas_ptr(mark_addr.base(), mark_reg, temp_reg);
1221 
1222     // if the compare and exchange succeeded we are done (we saw an unlocked object)
1223     cmp_and_brx_short(mark_reg, temp_reg, Assembler::equal, Assembler::pt, done);
1224 
1225     // We did not see an unlocked object so try the fast recursive case
1226 
<span class="line-modified">1227     // Check if owner is self by comparing the value in the markOop of object</span>
1228     // with the stack pointer
1229     sub(temp_reg, SP, temp_reg);
1230     sub(temp_reg, STACK_BIAS, temp_reg);
1231     assert(os::vm_page_size() &gt; 0xfff, &quot;page size too small - change the constant&quot;);
1232 
1233     // Composite &quot;andcc&quot; test:
1234     // (a) %sp -vs- markword proximity check, and,
1235     // (b) verify mark word LSBs == 0 (Stack-locked).
1236     //
<span class="line-modified">1237     // FFFFF003/FFFFFFFFFFFF003 is (markOopDesc::lock_mask_in_place | -os::vm_page_size())</span>
1238     // Note that the page size used for %sp proximity testing is arbitrary and is
1239     // unrelated to the actual MMU page size.  We use a &#39;logical&#39; page size of
1240     // 4096 bytes.   F..FFF003 is designed to fit conveniently in the SIMM13 immediate
1241     // field of the andcc instruction.
1242     andcc (temp_reg, 0xFFFFF003, G0) ;
1243 
1244     // if condition is true we are done and hence we can store 0 in the displaced
1245     // header indicating it is a recursive lock and be done
1246     brx(Assembler::zero, true, Assembler::pt, done);
1247     delayed()-&gt;st_ptr(G0, lock_addr, BasicLock::displaced_header_offset_in_bytes());
1248 
1249     // none of the above fast optimizations worked so we have to get into the
1250     // slow case of monitor enter
1251     bind(slow_case);
1252     call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), lock_reg);
1253 
1254     bind(done);
1255   }
1256 }
1257 
</pre>
<hr />
<pre>
2528   srl(Rtmp, log2_bytecode_size_limit, Rtmp);
2529   br_notnull_short( Rtmp, pt, test );
2530 
2531   // %%% should use call_VM_leaf here?
2532   save_frame_and_mov(0, Lmethod, O0, reg, O1);
2533   save_thread(L7_thread_cache);
2534   call(CAST_FROM_FN_PTR(address,verify_return_address), relocInfo::none);
2535   delayed()-&gt;nop();
2536   restore_thread(L7_thread_cache);
2537   br_notnull( O0, false, pt, skip );
2538   delayed()-&gt;restore();
2539 
2540   // Perform a more elaborate out-of-line call
2541   // Not an address; verify it:
2542   bind(test);
2543   verify_oop(reg);
2544   bind(skip);
2545 }
2546 
2547 
<span class="line-removed">2548 void InterpreterMacroAssembler::verify_FPU(int stack_depth, TosState state) {</span>
<span class="line-removed">2549   if (state == ftos || state == dtos) MacroAssembler::verify_FPU(stack_depth);</span>
<span class="line-removed">2550 }</span>
<span class="line-removed">2551 </span>
<span class="line-removed">2552 </span>
2553 // Jump if ((*counter_addr += increment) &amp; mask) satisfies the condition.
2554 void InterpreterMacroAssembler::increment_mask_and_jump(Address counter_addr,
2555                                                         int increment, Address mask_addr,
2556                                                         Register scratch1, Register scratch2,
2557                                                         Condition cond, Label *where) {
2558   ld(counter_addr, scratch1);
2559   add(scratch1, increment, scratch1);
2560   ld(mask_addr, scratch2);
2561   andcc(scratch1, scratch2,  G0);
2562   br(cond, false, Assembler::pn, *where);
2563   delayed()-&gt;st(scratch1, counter_addr);
2564 }
2565 
2566 // Inline assembly for:
2567 //
2568 // if (thread is in interp_only_mode) {
2569 //   InterpreterRuntime::post_method_entry();
2570 // }
2571 // if (DTraceMethodProbes) {
2572 //   SharedRuntime::dtrace_method_entry(method, receiver);
</pre>
</td>
<td>
<hr />
<pre>
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.inline.hpp&quot;
  27 #include &quot;interp_masm_sparc.hpp&quot;
  28 #include &quot;interpreter/interpreter.hpp&quot;
  29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  30 #include &quot;logging/log.hpp&quot;
  31 #include &quot;oops/arrayOop.hpp&quot;
<span class="line-modified">  32 #include &quot;oops/markWord.hpp&quot;</span>
  33 #include &quot;oops/methodData.hpp&quot;
  34 #include &quot;oops/method.hpp&quot;
  35 #include &quot;oops/methodCounters.hpp&quot;
  36 #include &quot;prims/jvmtiExport.hpp&quot;
  37 #include &quot;prims/jvmtiThreadState.hpp&quot;
  38 #include &quot;runtime/basicLock.hpp&quot;
  39 #include &quot;runtime/biasedLocking.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;runtime/thread.inline.hpp&quot;
  44 #include &quot;utilities/align.hpp&quot;
<span class="line-added">  45 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  46 
  47 // Implementation of InterpreterMacroAssembler
  48 
  49 // This file specializes the assember with interpreter-specific macros
  50 
  51 const Address InterpreterMacroAssembler::l_tmp(FP, (frame::interpreter_frame_l_scratch_fp_offset * wordSize) + STACK_BIAS);
  52 const Address InterpreterMacroAssembler::d_tmp(FP, (frame::interpreter_frame_d_scratch_fp_offset * wordSize) + STACK_BIAS);
  53 
  54 void InterpreterMacroAssembler::jump_to_entry(address entry) {
  55   assert(entry, &quot;Entry must have been generated by now&quot;);
  56   AddressLiteral al(entry);
  57   jump_to(al, G3_scratch);
  58   delayed()-&gt;nop();
  59 }
  60 
  61 void InterpreterMacroAssembler::compute_extra_locals_size_in_bytes(Register args_size, Register locals_size, Register delta) {
  62   // Note: this algorithm is also used by C1&#39;s OSR entry sequence.
  63   // Any changes should also be applied to CodeEmitter::emit_osr_entry().
  64   assert_different_registers(args_size, locals_size);
  65   // max_locals*2 for TAGS.  Assumes that args_size has already been adjusted.
</pre>
<hr />
<pre>
  75 }
  76 
  77 // Dispatch code executed in the prolog of a bytecode which does not do it&#39;s
  78 // own dispatch. The dispatch address is computed and placed in IdispatchAddress
  79 void InterpreterMacroAssembler::dispatch_prolog(TosState state, int bcp_incr) {
  80   assert_not_delayed();
  81   ldub( Lbcp, bcp_incr, Lbyte_code);                    // load next bytecode
  82   // dispatch table to use
  83   AddressLiteral tbl(Interpreter::dispatch_table(state));
  84   sll(Lbyte_code, LogBytesPerWord, Lbyte_code);         // multiply by wordSize
  85   set(tbl, G3_scratch);                                 // compute addr of table
  86   ld_ptr(G3_scratch, Lbyte_code, IdispatchAddress);     // get entry addr
  87 }
  88 
  89 
  90 // Dispatch code executed in the epilog of a bytecode which does not do it&#39;s
  91 // own dispatch. The dispatch address in IdispatchAddress is used for the
  92 // dispatch.
  93 void InterpreterMacroAssembler::dispatch_epilog(TosState state, int bcp_incr) {
  94   assert_not_delayed();

  95   interp_verify_oop(Otos_i, state, __FILE__, __LINE__);
  96   jmp( IdispatchAddress, 0 );
  97   if (bcp_incr != 0)  delayed()-&gt;inc(Lbcp, bcp_incr);
  98   else                delayed()-&gt;nop();
  99 }
 100 
 101 void InterpreterMacroAssembler::dispatch_next(TosState state, int bcp_incr, bool generate_poll) {
 102   // %%%% consider branching to a single shared dispatch stub (for each bcp_incr)
 103   assert_not_delayed();
 104   ldub( Lbcp, bcp_incr, Lbyte_code);               // load next bytecode
 105   dispatch_Lbyte_code(state, Interpreter::dispatch_table(state), bcp_incr, true, generate_poll);
 106 }
 107 
 108 
 109 void InterpreterMacroAssembler::dispatch_next_noverify_oop(TosState state, int bcp_incr) {
 110   // %%%% consider branching to a single shared dispatch stub (for each bcp_incr)
 111   assert_not_delayed();
 112   ldub( Lbcp, bcp_incr, Lbyte_code);               // load next bytecode
 113   dispatch_Lbyte_code(state, Interpreter::dispatch_table(state), bcp_incr, false);
 114 }
</pre>
<hr />
<pre>
 247 void InterpreterMacroAssembler::dispatch_base(TosState state, address* table) {
 248   assert_not_delayed();
 249   dispatch_Lbyte_code(state, table);
 250 }
 251 
 252 
 253 void InterpreterMacroAssembler::dispatch_normal(TosState state) {
 254   dispatch_base(state, Interpreter::normal_table(state));
 255 }
 256 
 257 
 258 void InterpreterMacroAssembler::dispatch_only(TosState state) {
 259   dispatch_base(state, Interpreter::dispatch_table(state));
 260 }
 261 
 262 
 263 // common code to dispatch and dispatch_only
 264 // dispatch value in Lbyte_code and increment Lbcp
 265 
 266 void InterpreterMacroAssembler::dispatch_Lbyte_code(TosState state, address* table, int bcp_incr, bool verify, bool generate_poll) {

 267   // %%%%% maybe implement +VerifyActivationFrameSize here
 268   //verify_thread(); //too slow; we will just verify on method entry &amp; exit
 269   if (verify) interp_verify_oop(Otos_i, state, __FILE__, __LINE__);
 270   // dispatch table to use
 271   AddressLiteral tbl(table);
 272   Label dispatch;
 273 
 274   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; generate_poll) {
 275     AddressLiteral sfpt_tbl(Interpreter::safept_table(state));
 276     Label no_safepoint;
 277 
 278     if (tbl.value() != sfpt_tbl.value()) {
 279       ldx(Address(G2_thread, Thread::polling_page_offset()), G3_scratch, 0);
 280       // Armed page has poll_bit set, if poll bit is cleared just continue.
 281       and3(G3_scratch, SafepointMechanism::poll_bit(), G3_scratch);
 282 
 283       br_null_short(G3_scratch, Assembler::pt, no_safepoint);
 284       set(sfpt_tbl, G3_scratch);
 285       ba_short(dispatch);
 286     }
</pre>
<hr />
<pre>
1182 // Lock object
1183 //
1184 // Argument - lock_reg points to the BasicObjectLock to be used for locking,
1185 //            it must be initialized with the object to lock
1186 void InterpreterMacroAssembler::lock_object(Register lock_reg, Register Object) {
1187   if (UseHeavyMonitors) {
1188     call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), lock_reg);
1189   }
1190   else {
1191     Register obj_reg = Object;
1192     Register mark_reg = G4_scratch;
1193     Register temp_reg = G1_scratch;
1194     Address  lock_addr(lock_reg, BasicObjectLock::lock_offset_in_bytes());
1195     Address  mark_addr(obj_reg, oopDesc::mark_offset_in_bytes());
1196     Label    done;
1197 
1198     Label slow_case;
1199 
1200     assert_different_registers(lock_reg, obj_reg, mark_reg, temp_reg);
1201 
<span class="line-modified">1202     // load markWord from object into mark_reg</span>
1203     ld_ptr(mark_addr, mark_reg);
1204 
1205     if (UseBiasedLocking) {
1206       biased_locking_enter(obj_reg, mark_reg, temp_reg, done, &amp;slow_case);
1207     }
1208 
1209     // get the address of basicLock on stack that will be stored in the object
1210     // we need a temporary register here as we do not want to clobber lock_reg
1211     // (cas clobbers the destination register)
1212     mov(lock_reg, temp_reg);
<span class="line-modified">1213     // set mark reg to be (markWord of object | UNLOCK_VALUE)</span>
<span class="line-modified">1214     or3(mark_reg, markWord::unlocked_value, mark_reg);</span>
1215     // initialize the box  (Must happen before we update the object mark!)
1216     st_ptr(mark_reg, lock_addr, BasicLock::displaced_header_offset_in_bytes());
<span class="line-modified">1217     // compare and exchange object_addr, markWord | 1, stack address of basicLock</span>
1218     assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
1219     cas_ptr(mark_addr.base(), mark_reg, temp_reg);
1220 
1221     // if the compare and exchange succeeded we are done (we saw an unlocked object)
1222     cmp_and_brx_short(mark_reg, temp_reg, Assembler::equal, Assembler::pt, done);
1223 
1224     // We did not see an unlocked object so try the fast recursive case
1225 
<span class="line-modified">1226     // Check if owner is self by comparing the value in the markWord of object</span>
1227     // with the stack pointer
1228     sub(temp_reg, SP, temp_reg);
1229     sub(temp_reg, STACK_BIAS, temp_reg);
1230     assert(os::vm_page_size() &gt; 0xfff, &quot;page size too small - change the constant&quot;);
1231 
1232     // Composite &quot;andcc&quot; test:
1233     // (a) %sp -vs- markword proximity check, and,
1234     // (b) verify mark word LSBs == 0 (Stack-locked).
1235     //
<span class="line-modified">1236     // FFFFF003/FFFFFFFFFFFF003 is (markWord::lock_mask_in_place | -os::vm_page_size())</span>
1237     // Note that the page size used for %sp proximity testing is arbitrary and is
1238     // unrelated to the actual MMU page size.  We use a &#39;logical&#39; page size of
1239     // 4096 bytes.   F..FFF003 is designed to fit conveniently in the SIMM13 immediate
1240     // field of the andcc instruction.
1241     andcc (temp_reg, 0xFFFFF003, G0) ;
1242 
1243     // if condition is true we are done and hence we can store 0 in the displaced
1244     // header indicating it is a recursive lock and be done
1245     brx(Assembler::zero, true, Assembler::pt, done);
1246     delayed()-&gt;st_ptr(G0, lock_addr, BasicLock::displaced_header_offset_in_bytes());
1247 
1248     // none of the above fast optimizations worked so we have to get into the
1249     // slow case of monitor enter
1250     bind(slow_case);
1251     call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), lock_reg);
1252 
1253     bind(done);
1254   }
1255 }
1256 
</pre>
<hr />
<pre>
2527   srl(Rtmp, log2_bytecode_size_limit, Rtmp);
2528   br_notnull_short( Rtmp, pt, test );
2529 
2530   // %%% should use call_VM_leaf here?
2531   save_frame_and_mov(0, Lmethod, O0, reg, O1);
2532   save_thread(L7_thread_cache);
2533   call(CAST_FROM_FN_PTR(address,verify_return_address), relocInfo::none);
2534   delayed()-&gt;nop();
2535   restore_thread(L7_thread_cache);
2536   br_notnull( O0, false, pt, skip );
2537   delayed()-&gt;restore();
2538 
2539   // Perform a more elaborate out-of-line call
2540   // Not an address; verify it:
2541   bind(test);
2542   verify_oop(reg);
2543   bind(skip);
2544 }
2545 
2546 





2547 // Jump if ((*counter_addr += increment) &amp; mask) satisfies the condition.
2548 void InterpreterMacroAssembler::increment_mask_and_jump(Address counter_addr,
2549                                                         int increment, Address mask_addr,
2550                                                         Register scratch1, Register scratch2,
2551                                                         Condition cond, Label *where) {
2552   ld(counter_addr, scratch1);
2553   add(scratch1, increment, scratch1);
2554   ld(mask_addr, scratch2);
2555   andcc(scratch1, scratch2,  G0);
2556   br(cond, false, Assembler::pn, *where);
2557   delayed()-&gt;st(scratch1, counter_addr);
2558 }
2559 
2560 // Inline assembly for:
2561 //
2562 // if (thread is in interp_only_mode) {
2563 //   InterpreterRuntime::post_method_entry();
2564 // }
2565 // if (DTraceMethodProbes) {
2566 //   SharedRuntime::dtrace_method_entry(method, receiver);
</pre>
</td>
</tr>
</table>
<center><a href="globals_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_sparc.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
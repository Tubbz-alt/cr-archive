<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/c1_FrameMap_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;c1/c1_FrameMap.hpp&quot;
 27 #include &quot;c1/c1_LIR.hpp&quot;
 28 #include &quot;runtime/sharedRuntime.hpp&quot;
 29 #include &quot;vmreg_sparc.inline.hpp&quot;
 30 
 31 
 32 const int FrameMap::pd_c_runtime_reserved_arg_size = 7;
 33 
 34 
 35 LIR_Opr FrameMap::map_to_opr(BasicType type, VMRegPair* reg, bool outgoing) {
 36   LIR_Opr opr = LIR_OprFact::illegalOpr;
 37   VMReg r_1 = reg-&gt;first();
 38   VMReg r_2 = reg-&gt;second();
 39   if (r_1-&gt;is_stack()) {
 40     // Convert stack slot to an SP offset
 41     // The calling convention does not count the SharedRuntime::out_preserve_stack_slots() value
 42     // so we must add it in here.
 43     int st_off = (r_1-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 44     opr = LIR_OprFact::address(new LIR_Address(SP_opr, st_off + STACK_BIAS, type));
 45   } else if (r_1-&gt;is_Register()) {
 46     Register reg = r_1-&gt;as_Register();
 47     if (outgoing) {
 48       assert(!reg-&gt;is_in(), &quot;should be using I regs&quot;);
 49     } else {
 50       assert(!reg-&gt;is_out(), &quot;should be using O regs&quot;);
 51     }
 52     if (r_2-&gt;is_Register() &amp;&amp; (type == T_LONG || type == T_DOUBLE)) {
 53       opr = as_long_opr(reg);
<a name="2" id="anc2"></a><span class="line-modified"> 54     } else if (type == T_OBJECT || type == T_ARRAY) {</span>
 55       opr = as_oop_opr(reg);
 56     } else if (type == T_METADATA) {
 57       opr = as_metadata_opr(reg);
<a name="3" id="anc3"></a>

 58     } else {
 59       opr = as_opr(reg);
 60     }
 61   } else if (r_1-&gt;is_FloatRegister()) {
 62     assert(type == T_DOUBLE || type == T_FLOAT, &quot;wrong type&quot;);
 63     FloatRegister f = r_1-&gt;as_FloatRegister();
 64     if (type == T_DOUBLE) {
 65       opr = as_double_opr(f);
 66     } else {
 67       opr = as_float_opr(f);
 68     }
 69   }
 70   return opr;
 71 }
 72 
 73 //               FrameMap
 74 //--------------------------------------------------------
 75 
 76 FloatRegister FrameMap::_fpu_regs [FrameMap::nof_fpu_regs];
 77 
 78 // some useful constant RInfo&#39;s:
 79 LIR_Opr FrameMap::in_long_opr;
 80 LIR_Opr FrameMap::out_long_opr;
 81 LIR_Opr FrameMap::g1_long_single_opr;
 82 
 83 LIR_Opr FrameMap::F0_opr;
 84 LIR_Opr FrameMap::F0_double_opr;
 85 
 86 LIR_Opr FrameMap::G0_opr;
 87 LIR_Opr FrameMap::G1_opr;
 88 LIR_Opr FrameMap::G2_opr;
 89 LIR_Opr FrameMap::G3_opr;
 90 LIR_Opr FrameMap::G4_opr;
 91 LIR_Opr FrameMap::G5_opr;
 92 LIR_Opr FrameMap::G6_opr;
 93 LIR_Opr FrameMap::G7_opr;
 94 LIR_Opr FrameMap::O0_opr;
 95 LIR_Opr FrameMap::O1_opr;
 96 LIR_Opr FrameMap::O2_opr;
 97 LIR_Opr FrameMap::O3_opr;
 98 LIR_Opr FrameMap::O4_opr;
 99 LIR_Opr FrameMap::O5_opr;
100 LIR_Opr FrameMap::O6_opr;
101 LIR_Opr FrameMap::O7_opr;
102 LIR_Opr FrameMap::L0_opr;
103 LIR_Opr FrameMap::L1_opr;
104 LIR_Opr FrameMap::L2_opr;
105 LIR_Opr FrameMap::L3_opr;
106 LIR_Opr FrameMap::L4_opr;
107 LIR_Opr FrameMap::L5_opr;
108 LIR_Opr FrameMap::L6_opr;
109 LIR_Opr FrameMap::L7_opr;
110 LIR_Opr FrameMap::I0_opr;
111 LIR_Opr FrameMap::I1_opr;
112 LIR_Opr FrameMap::I2_opr;
113 LIR_Opr FrameMap::I3_opr;
114 LIR_Opr FrameMap::I4_opr;
115 LIR_Opr FrameMap::I5_opr;
116 LIR_Opr FrameMap::I6_opr;
117 LIR_Opr FrameMap::I7_opr;
118 
119 LIR_Opr FrameMap::G0_oop_opr;
120 LIR_Opr FrameMap::G1_oop_opr;
121 LIR_Opr FrameMap::G2_oop_opr;
122 LIR_Opr FrameMap::G3_oop_opr;
123 LIR_Opr FrameMap::G4_oop_opr;
124 LIR_Opr FrameMap::G5_oop_opr;
125 LIR_Opr FrameMap::G6_oop_opr;
126 LIR_Opr FrameMap::G7_oop_opr;
127 LIR_Opr FrameMap::O0_oop_opr;
128 LIR_Opr FrameMap::O1_oop_opr;
129 LIR_Opr FrameMap::O2_oop_opr;
130 LIR_Opr FrameMap::O3_oop_opr;
131 LIR_Opr FrameMap::O4_oop_opr;
132 LIR_Opr FrameMap::O5_oop_opr;
133 LIR_Opr FrameMap::O6_oop_opr;
134 LIR_Opr FrameMap::O7_oop_opr;
135 LIR_Opr FrameMap::L0_oop_opr;
136 LIR_Opr FrameMap::L1_oop_opr;
137 LIR_Opr FrameMap::L2_oop_opr;
138 LIR_Opr FrameMap::L3_oop_opr;
139 LIR_Opr FrameMap::L4_oop_opr;
140 LIR_Opr FrameMap::L5_oop_opr;
141 LIR_Opr FrameMap::L6_oop_opr;
142 LIR_Opr FrameMap::L7_oop_opr;
143 LIR_Opr FrameMap::I0_oop_opr;
144 LIR_Opr FrameMap::I1_oop_opr;
145 LIR_Opr FrameMap::I2_oop_opr;
146 LIR_Opr FrameMap::I3_oop_opr;
147 LIR_Opr FrameMap::I4_oop_opr;
148 LIR_Opr FrameMap::I5_oop_opr;
149 LIR_Opr FrameMap::I6_oop_opr;
150 LIR_Opr FrameMap::I7_oop_opr;
151 
152 LIR_Opr FrameMap::G0_metadata_opr;
153 LIR_Opr FrameMap::G1_metadata_opr;
154 LIR_Opr FrameMap::G2_metadata_opr;
155 LIR_Opr FrameMap::G3_metadata_opr;
156 LIR_Opr FrameMap::G4_metadata_opr;
157 LIR_Opr FrameMap::G5_metadata_opr;
158 LIR_Opr FrameMap::G6_metadata_opr;
159 LIR_Opr FrameMap::G7_metadata_opr;
160 LIR_Opr FrameMap::O0_metadata_opr;
161 LIR_Opr FrameMap::O1_metadata_opr;
162 LIR_Opr FrameMap::O2_metadata_opr;
163 LIR_Opr FrameMap::O3_metadata_opr;
164 LIR_Opr FrameMap::O4_metadata_opr;
165 LIR_Opr FrameMap::O5_metadata_opr;
166 LIR_Opr FrameMap::O6_metadata_opr;
167 LIR_Opr FrameMap::O7_metadata_opr;
168 LIR_Opr FrameMap::L0_metadata_opr;
169 LIR_Opr FrameMap::L1_metadata_opr;
170 LIR_Opr FrameMap::L2_metadata_opr;
171 LIR_Opr FrameMap::L3_metadata_opr;
172 LIR_Opr FrameMap::L4_metadata_opr;
173 LIR_Opr FrameMap::L5_metadata_opr;
174 LIR_Opr FrameMap::L6_metadata_opr;
175 LIR_Opr FrameMap::L7_metadata_opr;
176 LIR_Opr FrameMap::I0_metadata_opr;
177 LIR_Opr FrameMap::I1_metadata_opr;
178 LIR_Opr FrameMap::I2_metadata_opr;
179 LIR_Opr FrameMap::I3_metadata_opr;
180 LIR_Opr FrameMap::I4_metadata_opr;
181 LIR_Opr FrameMap::I5_metadata_opr;
182 LIR_Opr FrameMap::I6_metadata_opr;
183 LIR_Opr FrameMap::I7_metadata_opr;
184 
185 LIR_Opr FrameMap::SP_opr;
186 LIR_Opr FrameMap::FP_opr;
187 
188 LIR_Opr FrameMap::Oexception_opr;
189 LIR_Opr FrameMap::Oissuing_pc_opr;
190 
191 LIR_Opr FrameMap::_caller_save_cpu_regs[] = { 0, };
192 LIR_Opr FrameMap::_caller_save_fpu_regs[] = { 0, };
193 
194 
195 FloatRegister FrameMap::nr2floatreg (int rnr) {
196   assert(_init_done, &quot;tables not initialized&quot;);
197   debug_only(fpu_range_check(rnr);)
198   return _fpu_regs[rnr];
199 }
200 
201 
202 // returns true if reg could be smashed by a callee.
203 bool FrameMap::is_caller_save_register (LIR_Opr reg) {
204   if (reg-&gt;is_single_fpu() || reg-&gt;is_double_fpu()) { return true; }
205   if (reg-&gt;is_double_cpu()) {
206     return is_caller_save_register(reg-&gt;as_register_lo()) ||
207            is_caller_save_register(reg-&gt;as_register_hi());
208   }
209   return is_caller_save_register(reg-&gt;as_register());
210 }
211 
212 
213 NEEDS_CLEANUP   // once the new calling convention is enabled, we no
214                 // longer need to treat I5, I4 and L0 specially
215 // Because the interpreter destroys caller&#39;s I5, I4 and L0,
216 // we must spill them before doing a Java call as we may land in
217 // interpreter.
218 bool FrameMap::is_caller_save_register (Register r) {
219   return (r-&gt;is_global() &amp;&amp; (r != G0)) || r-&gt;is_out();
220 }
221 
222 
223 void FrameMap::initialize() {
224   assert(!_init_done, &quot;once&quot;);
225 
226   int i=0;
227   // Register usage:
228   //  O6: sp
229   //  I6: fp
230   //  I7: return address
231   //  G0: zero
232   //  G2: thread
233   //  G7: not available
234   //  G6: not available
235   /*  0 */ map_register(i++, L0);
236   /*  1 */ map_register(i++, L1);
237   /*  2 */ map_register(i++, L2);
238   /*  3 */ map_register(i++, L3);
239   /*  4 */ map_register(i++, L4);
240   /*  5 */ map_register(i++, L5);
241   /*  6 */ map_register(i++, L6);
242   /*  7 */ map_register(i++, L7);
243 
244   /*  8 */ map_register(i++, I0);
245   /*  9 */ map_register(i++, I1);
246   /* 10 */ map_register(i++, I2);
247   /* 11 */ map_register(i++, I3);
248   /* 12 */ map_register(i++, I4);
249   /* 13 */ map_register(i++, I5);
250   /* 14 */ map_register(i++, O0);
251   /* 15 */ map_register(i++, O1);
252   /* 16 */ map_register(i++, O2);
253   /* 17 */ map_register(i++, O3);
254   /* 18 */ map_register(i++, O4);
255   /* 19 */ map_register(i++, O5); // &lt;- last register visible in RegAlloc (RegAlloc::nof+cpu_regs)
256   /* 20 */ map_register(i++, G1);
257   /* 21 */ map_register(i++, G3);
258   /* 22 */ map_register(i++, G4);
259   /* 23 */ map_register(i++, G5);
260   /* 24 */ map_register(i++, G0);
261 
262   // the following registers are not normally available
263   /* 25 */ map_register(i++, O7);
264   /* 26 */ map_register(i++, G2);
265   /* 27 */ map_register(i++, O6);
266   /* 28 */ map_register(i++, I6);
267   /* 29 */ map_register(i++, I7);
268   /* 30 */ map_register(i++, G6);
269   /* 31 */ map_register(i++, G7);
270   assert(i == nof_cpu_regs, &quot;number of CPU registers&quot;);
271 
272   for (i = 0; i &lt; nof_fpu_regs; i++) {
273     _fpu_regs[i] = as_FloatRegister(i);
274   }
275 
276   _init_done = true;
277 
278   in_long_opr    = as_long_opr(I0);
279   out_long_opr   = as_long_opr(O0);
280   g1_long_single_opr    = as_long_single_opr(G1);
281 
282   G0_opr = as_opr(G0);
283   G1_opr = as_opr(G1);
284   G2_opr = as_opr(G2);
285   G3_opr = as_opr(G3);
286   G4_opr = as_opr(G4);
287   G5_opr = as_opr(G5);
288   G6_opr = as_opr(G6);
289   G7_opr = as_opr(G7);
290   O0_opr = as_opr(O0);
291   O1_opr = as_opr(O1);
292   O2_opr = as_opr(O2);
293   O3_opr = as_opr(O3);
294   O4_opr = as_opr(O4);
295   O5_opr = as_opr(O5);
296   O6_opr = as_opr(O6);
297   O7_opr = as_opr(O7);
298   L0_opr = as_opr(L0);
299   L1_opr = as_opr(L1);
300   L2_opr = as_opr(L2);
301   L3_opr = as_opr(L3);
302   L4_opr = as_opr(L4);
303   L5_opr = as_opr(L5);
304   L6_opr = as_opr(L6);
305   L7_opr = as_opr(L7);
306   I0_opr = as_opr(I0);
307   I1_opr = as_opr(I1);
308   I2_opr = as_opr(I2);
309   I3_opr = as_opr(I3);
310   I4_opr = as_opr(I4);
311   I5_opr = as_opr(I5);
312   I6_opr = as_opr(I6);
313   I7_opr = as_opr(I7);
314 
315   G0_oop_opr = as_oop_opr(G0);
316   G1_oop_opr = as_oop_opr(G1);
317   G2_oop_opr = as_oop_opr(G2);
318   G3_oop_opr = as_oop_opr(G3);
319   G4_oop_opr = as_oop_opr(G4);
320   G5_oop_opr = as_oop_opr(G5);
321   G6_oop_opr = as_oop_opr(G6);
322   G7_oop_opr = as_oop_opr(G7);
323   O0_oop_opr = as_oop_opr(O0);
324   O1_oop_opr = as_oop_opr(O1);
325   O2_oop_opr = as_oop_opr(O2);
326   O3_oop_opr = as_oop_opr(O3);
327   O4_oop_opr = as_oop_opr(O4);
328   O5_oop_opr = as_oop_opr(O5);
329   O6_oop_opr = as_oop_opr(O6);
330   O7_oop_opr = as_oop_opr(O7);
331   L0_oop_opr = as_oop_opr(L0);
332   L1_oop_opr = as_oop_opr(L1);
333   L2_oop_opr = as_oop_opr(L2);
334   L3_oop_opr = as_oop_opr(L3);
335   L4_oop_opr = as_oop_opr(L4);
336   L5_oop_opr = as_oop_opr(L5);
337   L6_oop_opr = as_oop_opr(L6);
338   L7_oop_opr = as_oop_opr(L7);
339   I0_oop_opr = as_oop_opr(I0);
340   I1_oop_opr = as_oop_opr(I1);
341   I2_oop_opr = as_oop_opr(I2);
342   I3_oop_opr = as_oop_opr(I3);
343   I4_oop_opr = as_oop_opr(I4);
344   I5_oop_opr = as_oop_opr(I5);
345   I6_oop_opr = as_oop_opr(I6);
346   I7_oop_opr = as_oop_opr(I7);
347 
348   G0_metadata_opr = as_metadata_opr(G0);
349   G1_metadata_opr = as_metadata_opr(G1);
350   G2_metadata_opr = as_metadata_opr(G2);
351   G3_metadata_opr = as_metadata_opr(G3);
352   G4_metadata_opr = as_metadata_opr(G4);
353   G5_metadata_opr = as_metadata_opr(G5);
354   G6_metadata_opr = as_metadata_opr(G6);
355   G7_metadata_opr = as_metadata_opr(G7);
356   O0_metadata_opr = as_metadata_opr(O0);
357   O1_metadata_opr = as_metadata_opr(O1);
358   O2_metadata_opr = as_metadata_opr(O2);
359   O3_metadata_opr = as_metadata_opr(O3);
360   O4_metadata_opr = as_metadata_opr(O4);
361   O5_metadata_opr = as_metadata_opr(O5);
362   O6_metadata_opr = as_metadata_opr(O6);
363   O7_metadata_opr = as_metadata_opr(O7);
364   L0_metadata_opr = as_metadata_opr(L0);
365   L1_metadata_opr = as_metadata_opr(L1);
366   L2_metadata_opr = as_metadata_opr(L2);
367   L3_metadata_opr = as_metadata_opr(L3);
368   L4_metadata_opr = as_metadata_opr(L4);
369   L5_metadata_opr = as_metadata_opr(L5);
370   L6_metadata_opr = as_metadata_opr(L6);
371   L7_metadata_opr = as_metadata_opr(L7);
372   I0_metadata_opr = as_metadata_opr(I0);
373   I1_metadata_opr = as_metadata_opr(I1);
374   I2_metadata_opr = as_metadata_opr(I2);
375   I3_metadata_opr = as_metadata_opr(I3);
376   I4_metadata_opr = as_metadata_opr(I4);
377   I5_metadata_opr = as_metadata_opr(I5);
378   I6_metadata_opr = as_metadata_opr(I6);
379   I7_metadata_opr = as_metadata_opr(I7);
380 
381   FP_opr = as_pointer_opr(FP);
382   SP_opr = as_pointer_opr(SP);
383 
384   F0_opr = as_float_opr(F0);
385   F0_double_opr = as_double_opr(F0);
386 
387   Oexception_opr = as_oop_opr(Oexception);
388   Oissuing_pc_opr = as_opr(Oissuing_pc);
389 
390   _caller_save_cpu_regs[0] = FrameMap::O0_opr;
391   _caller_save_cpu_regs[1] = FrameMap::O1_opr;
392   _caller_save_cpu_regs[2] = FrameMap::O2_opr;
393   _caller_save_cpu_regs[3] = FrameMap::O3_opr;
394   _caller_save_cpu_regs[4] = FrameMap::O4_opr;
395   _caller_save_cpu_regs[5] = FrameMap::O5_opr;
396   _caller_save_cpu_regs[6] = FrameMap::G1_opr;
397   _caller_save_cpu_regs[7] = FrameMap::G3_opr;
398   _caller_save_cpu_regs[8] = FrameMap::G4_opr;
399   _caller_save_cpu_regs[9] = FrameMap::G5_opr;
400   for (int i = 0; i &lt; nof_caller_save_fpu_regs; i++) {
401     _caller_save_fpu_regs[i] = LIR_OprFact::single_fpu(i);
402   }
403 }
404 
405 
406 Address FrameMap::make_new_address(ByteSize sp_offset) const {
407   return Address(SP, STACK_BIAS + in_bytes(sp_offset));
408 }
409 
410 
411 VMReg FrameMap::fpu_regname (int n) {
412   return as_FloatRegister(n)-&gt;as_VMReg();
413 }
414 
415 
416 LIR_Opr FrameMap::stack_pointer() {
417   return SP_opr;
418 }
419 
420 
421 // JSR 292
422 LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {
423   assert(L7 == L7_mh_SP_save, &quot;must be same register&quot;);
424   return L7_opr;
425 }
426 
427 
428 bool FrameMap::validate_frame() {
429   int max_offset = in_bytes(framesize_in_bytes());
430   int java_index = 0;
431   for (int i = 0; i &lt; _incoming_arguments-&gt;length(); i++) {
432     LIR_Opr opr = _incoming_arguments-&gt;at(i);
433     if (opr-&gt;is_stack()) {
434       max_offset = MAX2(_argument_locations-&gt;at(java_index), max_offset);
435     }
436     java_index += type2size[opr-&gt;type()];
437   }
438   return Assembler::is_simm13(max_offset + STACK_BIAS);
439 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
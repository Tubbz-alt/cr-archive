<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/sparc/c1_LIRGenerator_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.inline.hpp&quot;
  27 #include &quot;c1/c1_Compilation.hpp&quot;
  28 #include &quot;c1/c1_FrameMap.hpp&quot;
  29 #include &quot;c1/c1_Instruction.hpp&quot;
  30 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_Runtime1.hpp&quot;
  33 #include &quot;c1/c1_ValueStack.hpp&quot;
  34 #include &quot;ci/ciArray.hpp&quot;
  35 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  36 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  37 #include &quot;runtime/safepointMechanism.hpp&quot;
  38 #include &quot;runtime/sharedRuntime.hpp&quot;
  39 #include &quot;runtime/stubRoutines.hpp&quot;
  40 #include &quot;vmreg_sparc.inline.hpp&quot;
  41 
  42 #ifdef ASSERT
  43 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  44 #else
  45 #define __ gen()-&gt;lir()-&gt;
  46 #endif
  47 
  48 void LIRItem::load_byte_item() {
  49   // byte loads use same registers as other loads
  50   load_item();
  51 }
  52 
  53 
  54 void LIRItem::load_nonconstant() {
  55   LIR_Opr r = value()-&gt;operand();
  56   if (_gen-&gt;can_inline_as_constant(value())) {
  57     if (!r-&gt;is_constant()) {
  58       r = LIR_OprFact::value_type(value()-&gt;type());
  59     }
  60     _result = r;
  61   } else {
  62     load_item();
  63   }
  64 }
  65 
  66 
  67 //--------------------------------------------------------------
  68 //               LIRGenerator
  69 //--------------------------------------------------------------
  70 
  71 LIR_Opr LIRGenerator::exceptionOopOpr()              { return FrameMap::Oexception_opr;  }
  72 LIR_Opr LIRGenerator::exceptionPcOpr()               { return FrameMap::Oissuing_pc_opr; }
  73 LIR_Opr LIRGenerator::syncLockOpr()                  { return new_register(T_INT); }
  74 LIR_Opr LIRGenerator::syncTempOpr()                  { return new_register(T_OBJECT); }
  75 LIR_Opr LIRGenerator::getThreadTemp()                { return rlock_callee_saved(T_LONG); }
  76 
  77 LIR_Opr LIRGenerator::result_register_for(ValueType* type, bool callee) {
  78   LIR_Opr opr;
  79   switch (type-&gt;tag()) {
  80   case intTag:     opr = callee ? FrameMap::I0_opr      : FrameMap::O0_opr;       break;
  81   case objectTag:  opr = callee ? FrameMap::I0_oop_opr  : FrameMap::O0_oop_opr;   break;
  82   case longTag:    opr = callee ? FrameMap::in_long_opr : FrameMap::out_long_opr; break;
  83   case floatTag:   opr = FrameMap::F0_opr;                                        break;
  84   case doubleTag:  opr = FrameMap::F0_double_opr;                                 break;
  85 
  86   case addressTag:
  87   default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
  88   }
  89 
  90   assert(opr-&gt;type_field() == as_OprType(as_BasicType(type)), &quot;type mismatch&quot;);
  91   return opr;
  92 }
  93 
  94 LIR_Opr LIRGenerator::rlock_callee_saved(BasicType type) {
  95   LIR_Opr reg = new_register(type);
  96   set_vreg_flag(reg, callee_saved);
  97   return reg;
  98 }
  99 
 100 
 101 LIR_Opr LIRGenerator::rlock_byte(BasicType type) {
 102   return new_register(T_INT);
 103 }
 104 
 105 
 106 
 107 
 108 
 109 //--------- loading items into registers --------------------------------
 110 
 111 // SPARC cannot inline all constants
 112 bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {
 113   if (v-&gt;type()-&gt;as_IntConstant() != NULL) {
 114     return v-&gt;type()-&gt;as_IntConstant()-&gt;value() == 0;
 115   } else if (v-&gt;type()-&gt;as_LongConstant() != NULL) {
 116     return v-&gt;type()-&gt;as_LongConstant()-&gt;value() == 0L;
 117   } else if (v-&gt;type()-&gt;as_ObjectConstant() != NULL) {
 118     return v-&gt;type()-&gt;as_ObjectConstant()-&gt;value()-&gt;is_null_object();
 119   } else {
 120     return false;
 121   }
 122 }
 123 
 124 
 125 // only simm13 constants can be inlined
 126 bool LIRGenerator:: can_inline_as_constant(Value i) const {
 127   if (i-&gt;type()-&gt;as_IntConstant() != NULL) {
 128     return Assembler::is_simm13(i-&gt;type()-&gt;as_IntConstant()-&gt;value());
 129   } else {
 130     return can_store_as_constant(i, as_BasicType(i-&gt;type()));
 131   }
 132 }
 133 
 134 
 135 bool LIRGenerator:: can_inline_as_constant(LIR_Const* c) const {
 136   if (c-&gt;type() == T_INT) {
 137     return Assembler::is_simm13(c-&gt;as_jint());
 138   }
 139   return false;
 140 }
 141 
 142 
 143 LIR_Opr LIRGenerator::safepoint_poll_register() {
 144   return new_register(T_INT);
 145 }
 146 
 147 
 148 
 149 LIR_Address* LIRGenerator::generate_address(LIR_Opr base, LIR_Opr index,
 150                                             int shift, int disp, BasicType type) {
 151   assert(base-&gt;is_register(), &quot;must be&quot;);
 152   intx large_disp = disp;
 153 
 154   // accumulate fixed displacements
 155   if (index-&gt;is_constant()) {
 156     large_disp += (intx)(index-&gt;as_constant_ptr()-&gt;as_jint()) &lt;&lt; shift;
 157     index = LIR_OprFact::illegalOpr;
 158   }
 159 
 160   if (index-&gt;is_register()) {
 161     // apply the shift and accumulate the displacement
 162     if (shift &gt; 0) {
 163       LIR_Opr tmp = new_pointer_register();
 164       __ shift_left(index, shift, tmp);
 165       index = tmp;
 166     }
 167     if (large_disp != 0) {
 168       LIR_Opr tmp = new_pointer_register();
 169       if (Assembler::is_simm13(large_disp)) {
 170         __ add(tmp, LIR_OprFact::intptrConst(large_disp), tmp);
 171         index = tmp;
 172       } else {
 173         __ move(LIR_OprFact::intptrConst(large_disp), tmp);
 174         __ add(tmp, index, tmp);
 175         index = tmp;
 176       }
 177       large_disp = 0;
 178     }
 179   } else if (large_disp != 0 &amp;&amp; !Assembler::is_simm13(large_disp)) {
 180     // index is illegal so replace it with the displacement loaded into a register
 181     index = new_pointer_register();
 182     __ move(LIR_OprFact::intptrConst(large_disp), index);
 183     large_disp = 0;
 184   }
 185 
 186   // at this point we either have base + index or base + displacement
 187   if (large_disp == 0) {
 188     return new LIR_Address(base, index, type);
 189   } else {
 190     assert(Assembler::is_simm13(large_disp), &quot;must be&quot;);
 191     return new LIR_Address(base, large_disp, type);
 192   }
 193 }
 194 
 195 
 196 LIR_Address* LIRGenerator::emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr,
 197                                               BasicType type) {
 198   int elem_size = type2aelembytes(type);
 199   int shift = exact_log2(elem_size);
 200 
 201   LIR_Opr base_opr;
 202   intx offset = arrayOopDesc::base_offset_in_bytes(type);
 203 
 204   if (index_opr-&gt;is_constant()) {
 205     intx i = index_opr-&gt;as_constant_ptr()-&gt;as_jint();
 206     intx array_offset = i * elem_size;
 207     if (Assembler::is_simm13(array_offset + offset)) {
 208       base_opr = array_opr;
 209       offset = array_offset + offset;
 210     } else {
 211       base_opr = new_pointer_register();
 212       if (Assembler::is_simm13(array_offset)) {
 213         __ add(array_opr, LIR_OprFact::intptrConst(array_offset), base_opr);
 214       } else {
 215         __ move(LIR_OprFact::intptrConst(array_offset), base_opr);
 216         __ add(base_opr, array_opr, base_opr);
 217       }
 218     }
 219   } else {
 220     if (index_opr-&gt;type() == T_INT) {
 221       LIR_Opr tmp = new_register(T_LONG);
 222       __ convert(Bytecodes::_i2l, index_opr, tmp);
 223       index_opr = tmp;
 224     }
 225 
 226     base_opr = new_pointer_register();
 227     assert (index_opr-&gt;is_register(), &quot;Must be register&quot;);
 228     if (shift &gt; 0) {
 229       __ shift_left(index_opr, shift, base_opr);
 230       __ add(base_opr, array_opr, base_opr);
 231     } else {
 232       __ add(index_opr, array_opr, base_opr);
 233     }
 234   }
 235 
 236   return new LIR_Address(base_opr, offset, type);
 237 }
 238 
 239 LIR_Opr LIRGenerator::load_immediate(int x, BasicType type) {
 240   LIR_Opr r;
 241   if (type == T_LONG) {
 242     r = LIR_OprFact::longConst(x);
 243   } else if (type == T_INT) {
 244     r = LIR_OprFact::intConst(x);
 245   } else {
 246     ShouldNotReachHere();
 247   }
 248   if (!Assembler::is_simm13(x)) {
 249     LIR_Opr tmp = new_register(type);
 250     __ move(r, tmp);
 251     return tmp;
 252   }
 253   return r;
 254 }
 255 
 256 void LIRGenerator::increment_counter(address counter, BasicType type, int step) {
 257   LIR_Opr pointer = new_pointer_register();
 258   __ move(LIR_OprFact::intptrConst(counter), pointer);
 259   LIR_Address* addr = new LIR_Address(pointer, type);
 260   increment_counter(addr, step);
 261 }
 262 
 263 void LIRGenerator::increment_counter(LIR_Address* addr, int step) {
 264   LIR_Opr temp = new_register(addr-&gt;type());
 265   __ move(addr, temp);
 266   __ add(temp, load_immediate(step, addr-&gt;type()), temp);
 267   __ move(temp, addr);
 268 }
 269 
 270 void LIRGenerator::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
 271   LIR_Opr o7opr = FrameMap::O7_opr;
 272   __ load(new LIR_Address(base, disp, T_INT), o7opr, info);
 273   __ cmp(condition, o7opr, c);
 274 }
 275 
 276 
 277 void LIRGenerator::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Opr base, int disp, BasicType type, CodeEmitInfo* info) {
 278   LIR_Opr o7opr = FrameMap::O7_opr;
 279   __ load(new LIR_Address(base, disp, type), o7opr, info);
 280   __ cmp(condition, reg, o7opr);
 281 }
 282 
 283 
 284 bool LIRGenerator::strength_reduce_multiply(LIR_Opr left, int c, LIR_Opr result, LIR_Opr tmp) {
 285   assert(left != result, &quot;should be different registers&quot;);
 286   if (is_power_of_2(c + 1)) {
 287     __ shift_left(left, log2_int(c + 1), result);
 288     __ sub(result, left, result);
 289     return true;
 290   } else if (is_power_of_2(c - 1)) {
 291     __ shift_left(left, log2_int(c - 1), result);
 292     __ add(result, left, result);
 293     return true;
 294   }
 295   return false;
 296 }
 297 
 298 
 299 void LIRGenerator::store_stack_parameter (LIR_Opr item, ByteSize offset_from_sp) {
 300   BasicType t = item-&gt;type();
 301   LIR_Opr sp_opr = FrameMap::SP_opr;
 302   if ((t == T_LONG || t == T_DOUBLE) &amp;&amp;
 303       ((in_bytes(offset_from_sp) - STACK_BIAS) % 8 != 0)) {
 304     __ unaligned_move(item, new LIR_Address(sp_opr, in_bytes(offset_from_sp), t));
 305   } else {
 306     __ move(item, new LIR_Address(sp_opr, in_bytes(offset_from_sp), t));
 307   }
 308 }
 309 
 310 void LIRGenerator::array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci) {
 311   LIR_Opr tmp1 = FrameMap::G1_opr;
 312   LIR_Opr tmp2 = FrameMap::G3_opr;
 313   LIR_Opr tmp3 = FrameMap::G5_opr;
 314   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 315 }
 316 
 317 //----------------------------------------------------------------------
 318 //             visitor functions
 319 //----------------------------------------------------------------------
 320 
 321 void LIRGenerator::do_MonitorEnter(MonitorEnter* x) {
 322   assert(x-&gt;is_pinned(),&quot;&quot;);
 323   LIRItem obj(x-&gt;obj(), this);
 324   obj.load_item();
 325 
 326   set_no_result(x);
 327 
 328   LIR_Opr lock    = FrameMap::G1_opr;
 329   LIR_Opr scratch = FrameMap::G3_opr;
 330   LIR_Opr hdr     = FrameMap::G4_opr;
 331 
 332   CodeEmitInfo* info_for_exception = NULL;
 333   if (x-&gt;needs_null_check()) {
 334     info_for_exception = state_for(x);
 335   }
 336 
 337   // this CodeEmitInfo must not have the xhandlers because here the
 338   // object is already locked (xhandlers expects object to be unlocked)
 339   CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
 340   monitor_enter(obj.result(), lock, hdr, scratch, x-&gt;monitor_no(), info_for_exception, info);
 341 }
 342 
 343 
 344 void LIRGenerator::do_MonitorExit(MonitorExit* x) {
 345   assert(x-&gt;is_pinned(),&quot;&quot;);
 346   LIRItem obj(x-&gt;obj(), this);
 347   obj.dont_load_item();
 348 
 349   set_no_result(x);
 350   LIR_Opr lock      = FrameMap::G1_opr;
 351   LIR_Opr hdr       = FrameMap::G3_opr;
 352   LIR_Opr obj_temp  = FrameMap::G4_opr;
 353   monitor_exit(obj_temp, lock, hdr, LIR_OprFact::illegalOpr, x-&gt;monitor_no());
 354 }
 355 
 356 
 357 // _ineg, _lneg, _fneg, _dneg
 358 void LIRGenerator::do_NegateOp(NegateOp* x) {
 359   LIRItem value(x-&gt;x(), this);
 360   value.load_item();
 361   LIR_Opr reg = rlock_result(x);
 362   __ negate(value.result(), reg);
 363 }
 364 
 365 
 366 
 367 // for  _fadd, _fmul, _fsub, _fdiv, _frem
 368 //      _dadd, _dmul, _dsub, _ddiv, _drem
 369 void LIRGenerator::do_ArithmeticOp_FPU(ArithmeticOp* x) {
 370   switch (x-&gt;op()) {
 371   case Bytecodes::_fadd:
 372   case Bytecodes::_fmul:
 373   case Bytecodes::_fsub:
 374   case Bytecodes::_fdiv:
 375   case Bytecodes::_dadd:
 376   case Bytecodes::_dmul:
 377   case Bytecodes::_dsub:
 378   case Bytecodes::_ddiv: {
 379     LIRItem left(x-&gt;x(), this);
 380     LIRItem right(x-&gt;y(), this);
 381     left.load_item();
 382     right.load_item();
 383     rlock_result(x);
 384     arithmetic_op_fpu(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), x-&gt;is_strictfp());
 385   }
 386   break;
 387 
 388   case Bytecodes::_frem:
 389   case Bytecodes::_drem: {
 390     address entry;
 391     switch (x-&gt;op()) {
 392     case Bytecodes::_frem:
 393       entry = CAST_FROM_FN_PTR(address, SharedRuntime::frem);
 394       break;
 395     case Bytecodes::_drem:
 396       entry = CAST_FROM_FN_PTR(address, SharedRuntime::drem);
 397       break;
 398     default:
 399       ShouldNotReachHere();
 400     }
 401     LIR_Opr result = call_runtime(x-&gt;x(), x-&gt;y(), entry, x-&gt;type(), NULL);
 402     set_result(x, result);
 403   }
 404   break;
 405 
 406   default: ShouldNotReachHere();
 407   }
 408 }
 409 
 410 
 411 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 412 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 413   switch (x-&gt;op()) {
 414   case Bytecodes::_lrem:
 415   case Bytecodes::_lmul:
 416   case Bytecodes::_ldiv: {
 417 
 418     if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 419       LIRItem right(x-&gt;y(), this);
 420       right.load_item();
 421 
 422       CodeEmitInfo* info = state_for(x);
 423       LIR_Opr item = right.result();
 424       assert(item-&gt;is_register(), &quot;must be&quot;);
 425       __ cmp(lir_cond_equal, item, LIR_OprFact::longConst(0));
 426       __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));
 427     }
 428 
 429     address entry;
 430     switch (x-&gt;op()) {
 431     case Bytecodes::_lrem:
 432       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
 433       break; // check if dividend is 0 is done elsewhere
 434     case Bytecodes::_ldiv:
 435       entry = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
 436       break; // check if dividend is 0 is done elsewhere
 437     case Bytecodes::_lmul:
 438       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lmul);
 439       break;
 440     default:
 441       ShouldNotReachHere();
 442     }
 443 
 444     // order of arguments to runtime call is reversed.
 445     LIR_Opr result = call_runtime(x-&gt;y(), x-&gt;x(), entry, x-&gt;type(), NULL);
 446     set_result(x, result);
 447     break;
 448   }
 449   case Bytecodes::_ladd:
 450   case Bytecodes::_lsub: {
 451     LIRItem left(x-&gt;x(), this);
 452     LIRItem right(x-&gt;y(), this);
 453     left.load_item();
 454     right.load_item();
 455     rlock_result(x);
 456 
 457     arithmetic_op_long(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), NULL);
 458     break;
 459   }
 460   default: ShouldNotReachHere();
 461   }
 462 }
 463 
 464 
 465 // Returns if item is an int constant that can be represented by a simm13
 466 static bool is_simm13(LIR_Opr item) {
 467   if (item-&gt;is_constant() &amp;&amp; item-&gt;type() == T_INT) {
 468     return Assembler::is_simm13(item-&gt;as_constant_ptr()-&gt;as_jint());
 469   } else {
 470     return false;
 471   }
 472 }
 473 
 474 
 475 // for: _iadd, _imul, _isub, _idiv, _irem
 476 void LIRGenerator::do_ArithmeticOp_Int(ArithmeticOp* x) {
 477   bool is_div_rem = x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem;
 478   LIRItem left(x-&gt;x(), this);
 479   LIRItem right(x-&gt;y(), this);
 480   // missing test if instr is commutative and if we should swap
 481   right.load_nonconstant();
 482   assert(right.is_constant() || right.is_register(), &quot;wrong state of right&quot;);
 483   left.load_item();
 484   rlock_result(x);
 485   if (is_div_rem) {
 486     CodeEmitInfo* info = state_for(x);
 487     LIR_Opr tmp = FrameMap::G1_opr;
 488     if (x-&gt;op() == Bytecodes::_irem) {
 489       __ irem(left.result(), right.result(), x-&gt;operand(), tmp, info);
 490     } else if (x-&gt;op() == Bytecodes::_idiv) {
 491       __ idiv(left.result(), right.result(), x-&gt;operand(), tmp, info);
 492     }
 493   } else {
 494     arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), FrameMap::G1_opr);
 495   }
 496 }
 497 
 498 
 499 void LIRGenerator::do_ArithmeticOp(ArithmeticOp* x) {
 500   ValueTag tag = x-&gt;type()-&gt;tag();
 501   assert(x-&gt;x()-&gt;type()-&gt;tag() == tag &amp;&amp; x-&gt;y()-&gt;type()-&gt;tag() == tag, &quot;wrong parameters&quot;);
 502   switch (tag) {
 503     case floatTag:
 504     case doubleTag:  do_ArithmeticOp_FPU(x);  return;
 505     case longTag:    do_ArithmeticOp_Long(x); return;
 506     case intTag:     do_ArithmeticOp_Int(x);  return;
 507   }
 508   ShouldNotReachHere();
 509 }
 510 
 511 
 512 // _ishl, _lshl, _ishr, _lshr, _iushr, _lushr
 513 void LIRGenerator::do_ShiftOp(ShiftOp* x) {
 514   LIRItem value(x-&gt;x(), this);
 515   LIRItem count(x-&gt;y(), this);
 516   // Long shift destroys count register
 517   if (value.type()-&gt;is_long()) {
 518     count.set_destroys_register();
 519   }
 520   value.load_item();
 521   // the old backend doesn&#39;t support this
 522   if (count.is_constant() &amp;&amp; count.type()-&gt;as_IntConstant() != NULL &amp;&amp; value.type()-&gt;is_int()) {
 523     jint c = count.get_jint_constant() &amp; 0x1f;
 524     assert(c &gt;= 0 &amp;&amp; c &lt; 32, &quot;should be small&quot;);
 525     count.dont_load_item();
 526   } else {
 527     count.load_item();
 528   }
 529   LIR_Opr reg = rlock_result(x);
 530   shift_op(x-&gt;op(), reg, value.result(), count.result(), LIR_OprFact::illegalOpr);
 531 }
 532 
 533 
 534 // _iand, _land, _ior, _lor, _ixor, _lxor
 535 void LIRGenerator::do_LogicOp(LogicOp* x) {
 536   LIRItem left(x-&gt;x(), this);
 537   LIRItem right(x-&gt;y(), this);
 538 
 539   left.load_item();
 540   right.load_nonconstant();
 541   LIR_Opr reg = rlock_result(x);
 542 
 543   logic_op(x-&gt;op(), reg, left.result(), right.result());
 544 }
 545 
 546 
 547 
 548 // _lcmp, _fcmpl, _fcmpg, _dcmpl, _dcmpg
 549 void LIRGenerator::do_CompareOp(CompareOp* x) {
 550   LIRItem left(x-&gt;x(), this);
 551   LIRItem right(x-&gt;y(), this);
 552   left.load_item();
 553   right.load_item();
 554   LIR_Opr reg = rlock_result(x);
 555   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 556     Bytecodes::Code code = x-&gt;op();
 557     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 558   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 559     __ lcmp2int(left.result(), right.result(), reg);
 560   } else {
 561     Unimplemented();
 562   }
 563 }
 564 
 565 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 566   LIR_Opr result = new_register(T_INT);
 567   LIR_Opr t1 = FrameMap::G1_opr;
 568   LIR_Opr t2 = FrameMap::G3_opr;
 569   cmp_value.load_item();
 570   new_value.load_item();
 571   if (type == T_OBJECT || type == T_ARRAY) {
 572     __ cas_obj(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), t1, t2);
 573   } else if (type == T_INT) {
 574     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), t1, t2);
 575   } else if (type == T_LONG) {
 576     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), t1, t2);
 577   } else {
 578     Unimplemented();
 579   }
 580   __ cmove(lir_cond_equal, LIR_OprFact::intConst(1), LIR_OprFact::intConst(0),
 581            result, type);
 582   return result;
 583 }
 584 
 585 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 586   bool is_obj = type == T_OBJECT || type == T_ARRAY;
 587   LIR_Opr result = new_register(type);
 588   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 589 
 590   value.load_item();
 591 
 592   if (is_obj) {
 593     tmp = FrameMap::G3_opr;
 594   }
 595 
 596   // Because we want a 2-arg form of xchg
 597   __ move(value.result(), result);
 598   __ xchg(addr, result, result, tmp);
 599   return result;
 600 }
 601 
 602 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 603   Unimplemented();
 604   return LIR_OprFact::illegalOpr;
 605 }
 606 
 607 void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {
 608   switch (x-&gt;id()) {
 609     case vmIntrinsics::_dabs:
 610     case vmIntrinsics::_dsqrt: {
 611       assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 612       LIRItem value(x-&gt;argument_at(0), this);
 613       value.load_item();
 614       LIR_Opr dst = rlock_result(x);
 615 
 616       switch (x-&gt;id()) {
 617       case vmIntrinsics::_dsqrt: {
 618         __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);
 619         break;
 620       }
 621       case vmIntrinsics::_dabs: {
 622         __ abs(value.result(), dst, LIR_OprFact::illegalOpr);
 623         break;
 624       }
 625       }
 626       break;
 627     }
 628     case vmIntrinsics::_dlog10: // fall through
 629     case vmIntrinsics::_dlog: // fall through
 630     case vmIntrinsics::_dsin: // fall through
 631     case vmIntrinsics::_dtan: // fall through
 632     case vmIntrinsics::_dcos: // fall through
 633     case vmIntrinsics::_dexp: {
 634       assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 635 
 636       address runtime_entry = NULL;
 637       switch (x-&gt;id()) {
 638       case vmIntrinsics::_dsin:
 639         runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dsin);
 640         break;
 641       case vmIntrinsics::_dcos:
 642         runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dcos);
 643         break;
 644       case vmIntrinsics::_dtan:
 645         runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dtan);
 646         break;
 647       case vmIntrinsics::_dlog:
 648         runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dlog);
 649         break;
 650       case vmIntrinsics::_dlog10:
 651         runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dlog10);
 652         break;
 653       case vmIntrinsics::_dexp:
 654         runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dexp);
 655         break;
 656       default:
 657         ShouldNotReachHere();
 658       }
 659 
 660       LIR_Opr result = call_runtime(x-&gt;argument_at(0), runtime_entry, x-&gt;type(), NULL);
 661       set_result(x, result);
 662       break;
 663     }
 664     case vmIntrinsics::_dpow: {
 665       assert(x-&gt;number_of_arguments() == 2, &quot;wrong type&quot;);
 666       address runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dpow);
 667       LIR_Opr result = call_runtime(x-&gt;argument_at(0), x-&gt;argument_at(1), runtime_entry, x-&gt;type(), NULL);
 668       set_result(x, result);
 669       break;
 670     }
 671   }
 672 }
 673 
 674 
 675 void LIRGenerator::do_ArrayCopy(Intrinsic* x) {
 676   assert(x-&gt;number_of_arguments() == 5, &quot;wrong type&quot;);
 677 
 678   // Make all state_for calls early since they can emit code
 679   CodeEmitInfo* info = state_for(x, x-&gt;state());
 680 
 681   // Note: spill caller save before setting the item
 682   LIRItem src     (x-&gt;argument_at(0), this);
 683   LIRItem src_pos (x-&gt;argument_at(1), this);
 684   LIRItem dst     (x-&gt;argument_at(2), this);
 685   LIRItem dst_pos (x-&gt;argument_at(3), this);
 686   LIRItem length  (x-&gt;argument_at(4), this);
 687   // load all values in callee_save_registers, as this makes the
 688   // parameter passing to the fast case simpler
 689   src.load_item_force     (rlock_callee_saved(T_OBJECT));
 690   src_pos.load_item_force (rlock_callee_saved(T_INT));
 691   dst.load_item_force     (rlock_callee_saved(T_OBJECT));
 692   dst_pos.load_item_force (rlock_callee_saved(T_INT));
 693   length.load_item_force  (rlock_callee_saved(T_INT));
 694 
 695   int flags;
 696   ciArrayKlass* expected_type;
 697   arraycopy_helper(x, &amp;flags, &amp;expected_type);
 698 
 699   __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(),
 700                length.result(), rlock_callee_saved(T_INT),
 701                expected_type, flags, info);
 702   set_no_result(x);
 703 }
 704 
 705 void LIRGenerator::do_update_CRC32(Intrinsic* x) {
 706   // Make all state_for calls early since they can emit code
 707   LIR_Opr result = rlock_result(x);
 708   int flags = 0;
 709   switch (x-&gt;id()) {
 710     case vmIntrinsics::_updateCRC32: {
 711       LIRItem crc(x-&gt;argument_at(0), this);
 712       LIRItem val(x-&gt;argument_at(1), this);
 713       // val is destroyed by update_crc32
 714       val.set_destroys_register();
 715       crc.load_item();
 716       val.load_item();
 717       __ update_crc32(crc.result(), val.result(), result);
 718       break;
 719     }
 720     case vmIntrinsics::_updateBytesCRC32:
 721     case vmIntrinsics::_updateByteBufferCRC32: {
 722 
 723       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32);
 724 
 725       LIRItem crc(x-&gt;argument_at(0), this);
 726       LIRItem buf(x-&gt;argument_at(1), this);
 727       LIRItem off(x-&gt;argument_at(2), this);
 728       LIRItem len(x-&gt;argument_at(3), this);
 729 
 730       buf.load_item();
 731       off.load_nonconstant();
 732 
 733       LIR_Opr index = off.result();
 734       int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
 735       if(off.result()-&gt;is_constant()) {
 736         index = LIR_OprFact::illegalOpr;
 737         offset += off.result()-&gt;as_jint();
 738       }
 739 
 740       LIR_Opr base_op = buf.result();
 741 
 742       if (index-&gt;is_valid()) {
 743         LIR_Opr tmp = new_register(T_LONG);
 744         __ convert(Bytecodes::_i2l, index, tmp);
 745         index = tmp;
 746         if (index-&gt;is_constant()) {
 747           offset += index-&gt;as_constant_ptr()-&gt;as_jint();
 748           index = LIR_OprFact::illegalOpr;
 749         } else if (index-&gt;is_register()) {
 750           LIR_Opr tmp2 = new_register(T_LONG);
 751           LIR_Opr tmp3 = new_register(T_LONG);
 752           __ move(base_op, tmp2);
 753           __ move(index, tmp3);
 754           __ add(tmp2, tmp3, tmp2);
 755           base_op = tmp2;
 756         } else {
 757           ShouldNotReachHere();
 758         }
 759       }
 760 
 761       LIR_Address* a = new LIR_Address(base_op, offset, T_BYTE);
 762 
 763       BasicTypeList signature(3);
 764       signature.append(T_INT);
 765       signature.append(T_ADDRESS);
 766       signature.append(T_INT);
 767       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 768       const LIR_Opr result_reg = result_register_for(x-&gt;type());
 769 
 770       LIR_Opr addr = new_pointer_register();
 771       __ leal(LIR_OprFact::address(a), addr);
 772 
 773       crc.load_item_force(cc-&gt;at(0));
 774       __ move(addr, cc-&gt;at(1));
 775       len.load_item_force(cc-&gt;at(2));
 776 
 777       __ call_runtime_leaf(StubRoutines::updateBytesCRC32(), getThreadTemp(), result_reg, cc-&gt;args());
 778       __ move(result_reg, result);
 779 
 780       break;
 781     }
 782     default: {
 783       ShouldNotReachHere();
 784     }
 785   }
 786 }
 787 
 788 void LIRGenerator::do_update_CRC32C(Intrinsic* x) {
 789   // Make all state_for calls early since they can emit code
 790   LIR_Opr result = rlock_result(x);
 791   int flags = 0;
 792   switch (x-&gt;id()) {
 793     case vmIntrinsics::_updateBytesCRC32C:
 794     case vmIntrinsics::_updateDirectByteBufferCRC32C: {
 795 
 796       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32C);
 797       int array_offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
 798 
 799       LIRItem crc(x-&gt;argument_at(0), this);
 800       LIRItem buf(x-&gt;argument_at(1), this);
 801       LIRItem off(x-&gt;argument_at(2), this);
 802       LIRItem end(x-&gt;argument_at(3), this);
 803 
 804       buf.load_item();
 805       off.load_nonconstant();
 806       end.load_nonconstant();
 807 
 808       // len = end - off
 809       LIR_Opr len  = end.result();
 810       LIR_Opr tmpA = new_register(T_INT);
 811       LIR_Opr tmpB = new_register(T_INT);
 812       __ move(end.result(), tmpA);
 813       __ move(off.result(), tmpB);
 814       __ sub(tmpA, tmpB, tmpA);
 815       len = tmpA;
 816 
 817       LIR_Opr index = off.result();
 818 
 819       if(off.result()-&gt;is_constant()) {
 820         index = LIR_OprFact::illegalOpr;
 821         array_offset += off.result()-&gt;as_jint();
 822       }
 823 
 824       LIR_Opr base_op = buf.result();
 825 
 826       if (index-&gt;is_valid()) {
 827         LIR_Opr tmp = new_register(T_LONG);
 828         __ convert(Bytecodes::_i2l, index, tmp);
 829         index = tmp;
 830         if (index-&gt;is_constant()) {
 831           array_offset += index-&gt;as_constant_ptr()-&gt;as_jint();
 832           index = LIR_OprFact::illegalOpr;
 833         } else if (index-&gt;is_register()) {
 834           LIR_Opr tmp2 = new_register(T_LONG);
 835           LIR_Opr tmp3 = new_register(T_LONG);
 836           __ move(base_op, tmp2);
 837           __ move(index, tmp3);
 838           __ add(tmp2, tmp3, tmp2);
 839           base_op = tmp2;
 840         } else {
 841           ShouldNotReachHere();
 842         }
 843       }
 844 
 845       LIR_Address* a = new LIR_Address(base_op, array_offset, T_BYTE);
 846 
 847       BasicTypeList signature(3);
 848       signature.append(T_INT);
 849       signature.append(T_ADDRESS);
 850       signature.append(T_INT);
 851       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 852       const LIR_Opr result_reg = result_register_for(x-&gt;type());
 853 
 854       LIR_Opr addr = new_pointer_register();
 855       __ leal(LIR_OprFact::address(a), addr);
 856 
 857       crc.load_item_force(cc-&gt;at(0));
 858       __ move(addr, cc-&gt;at(1));
 859       __ move(len, cc-&gt;at(2));
 860 
 861       __ call_runtime_leaf(StubRoutines::updateBytesCRC32C(), getThreadTemp(), result_reg, cc-&gt;args());
 862       __ move(result_reg, result);
 863 
 864       break;
 865     }
 866     default: {
 867       ShouldNotReachHere();
 868     }
 869   }
 870 }
 871 
 872 void LIRGenerator::do_FmaIntrinsic(Intrinsic* x) {
 873   assert(x-&gt;number_of_arguments() == 3, &quot;wrong type&quot;);
 874   assert(UseFMA, &quot;Needs FMA instructions support.&quot;);
 875 
 876   LIRItem a(x-&gt;argument_at(0), this);
 877   LIRItem b(x-&gt;argument_at(1), this);
 878   LIRItem c(x-&gt;argument_at(2), this);
 879 
 880   a.load_item();
 881   b.load_item();
 882   c.load_item();
 883 
 884   LIR_Opr ina = a.result();
 885   LIR_Opr inb = b.result();
 886   LIR_Opr inc = c.result();
 887   LIR_Opr res = rlock_result(x);
 888 
 889   switch (x-&gt;id()) {
 890     case vmIntrinsics::_fmaF: __ fmaf(ina, inb, inc, res); break;
 891     case vmIntrinsics::_fmaD: __ fmad(ina, inb, inc, res); break;
 892     default:
 893       ShouldNotReachHere();
 894       break;
 895   }
 896 }
 897 
 898 void LIRGenerator::do_vectorizedMismatch(Intrinsic* x) {
 899   fatal(&quot;vectorizedMismatch intrinsic is not implemented on this platform&quot;);
 900 }
 901 
 902 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
 903 // _i2b, _i2c, _i2s
 904 void LIRGenerator::do_Convert(Convert* x) {
 905 
 906   switch (x-&gt;op()) {
 907     case Bytecodes::_f2l:
 908     case Bytecodes::_d2l:
 909     case Bytecodes::_d2i:
 910     case Bytecodes::_l2f:
 911     case Bytecodes::_l2d: {
 912 
 913       address entry;
 914       switch (x-&gt;op()) {
 915       case Bytecodes::_l2f:
 916         entry = CAST_FROM_FN_PTR(address, SharedRuntime::l2f);
 917         break;
 918       case Bytecodes::_l2d:
 919         entry = CAST_FROM_FN_PTR(address, SharedRuntime::l2d);
 920         break;
 921       case Bytecodes::_f2l:
 922         entry = CAST_FROM_FN_PTR(address, SharedRuntime::f2l);
 923         break;
 924       case Bytecodes::_d2l:
 925         entry = CAST_FROM_FN_PTR(address, SharedRuntime::d2l);
 926         break;
 927       case Bytecodes::_d2i:
 928         entry = CAST_FROM_FN_PTR(address, SharedRuntime::d2i);
 929         break;
 930       default:
 931         ShouldNotReachHere();
 932       }
 933       LIR_Opr result = call_runtime(x-&gt;value(), entry, x-&gt;type(), NULL);
 934       set_result(x, result);
 935       break;
 936     }
 937 
 938     case Bytecodes::_i2f:
 939     case Bytecodes::_i2d: {
 940       LIRItem value(x-&gt;value(), this);
 941 
 942       LIR_Opr reg = rlock_result(x);
 943       // To convert an int to double, we need to load the 32-bit int
 944       // from memory into a single precision floating point register
 945       // (even numbered). Then the sparc fitod instruction takes care
 946       // of the conversion. This is a bit ugly, but is the best way to
 947       // get the int value in a single precision floating point register
 948       value.load_item();
 949       LIR_Opr tmp = force_to_spill(value.result(), T_FLOAT);
 950       __ convert(x-&gt;op(), tmp, reg);
 951       break;
 952     }
 953     break;
 954 
 955     case Bytecodes::_i2l:
 956     case Bytecodes::_i2b:
 957     case Bytecodes::_i2c:
 958     case Bytecodes::_i2s:
 959     case Bytecodes::_l2i:
 960     case Bytecodes::_f2d:
 961     case Bytecodes::_d2f: { // inline code
 962       LIRItem value(x-&gt;value(), this);
 963 
 964       value.load_item();
 965       LIR_Opr reg = rlock_result(x);
 966       __ convert(x-&gt;op(), value.result(), reg, false);
 967     }
 968     break;
 969 
 970     case Bytecodes::_f2i: {
 971       LIRItem value (x-&gt;value(), this);
 972       value.set_destroys_register();
 973       value.load_item();
 974       LIR_Opr reg = rlock_result(x);
 975       set_vreg_flag(reg, must_start_in_memory);
 976       __ convert(x-&gt;op(), value.result(), reg, false);
 977     }
 978     break;
 979 
 980     default: ShouldNotReachHere();
 981   }
 982 }
 983 
 984 
 985 void LIRGenerator::do_NewInstance(NewInstance* x) {
 986   print_if_not_loaded(x);
 987 
 988   // This instruction can be deoptimized in the slow path : use
 989   // O0 as result register.
 990   const LIR_Opr reg = result_register_for(x-&gt;type());
 991 
 992   CodeEmitInfo* info = state_for(x, x-&gt;state());
 993   LIR_Opr tmp1 = FrameMap::G1_oop_opr;
 994   LIR_Opr tmp2 = FrameMap::G3_oop_opr;
 995   LIR_Opr tmp3 = FrameMap::G4_oop_opr;
 996   LIR_Opr tmp4 = FrameMap::O1_oop_opr;
 997   LIR_Opr klass_reg = FrameMap::G5_metadata_opr;
 998   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(), tmp1, tmp2, tmp3, tmp4, klass_reg, info);
 999   LIR_Opr result = rlock_result(x);
1000   __ move(reg, result);
1001 }
1002 
1003 
1004 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
1005   // Evaluate state_for early since it may emit code
1006   CodeEmitInfo* info = state_for(x, x-&gt;state());
1007 
1008   LIRItem length(x-&gt;length(), this);
1009   length.load_item();
1010 
1011   LIR_Opr reg = result_register_for(x-&gt;type());
1012   LIR_Opr tmp1 = FrameMap::G1_oop_opr;
1013   LIR_Opr tmp2 = FrameMap::G3_oop_opr;
1014   LIR_Opr tmp3 = FrameMap::G4_oop_opr;
1015   LIR_Opr tmp4 = FrameMap::O1_oop_opr;
1016   LIR_Opr klass_reg = FrameMap::G5_metadata_opr;
1017   LIR_Opr len = length.result();
1018   BasicType elem_type = x-&gt;elt_type();
1019 
1020   __ metadata2reg(ciTypeArrayKlass::make(elem_type)-&gt;constant_encoding(), klass_reg);
1021 
1022   CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len, reg, info);
1023   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);
1024 
1025   LIR_Opr result = rlock_result(x);
1026   __ move(reg, result);
1027 }
1028 
1029 
1030 void LIRGenerator::do_NewObjectArray(NewObjectArray* x) {
1031   // Evaluate state_for early since it may emit code.
1032   CodeEmitInfo* info = state_for(x, x-&gt;state());
1033   // in case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
1034   // and therefore provide the state before the parameters have been consumed
1035   CodeEmitInfo* patching_info = NULL;
1036   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1037     patching_info = state_for(x, x-&gt;state_before());
1038   }
1039 
1040   LIRItem length(x-&gt;length(), this);
1041   length.load_item();
1042 
1043   const LIR_Opr reg = result_register_for(x-&gt;type());
1044   LIR_Opr tmp1 = FrameMap::G1_oop_opr;
1045   LIR_Opr tmp2 = FrameMap::G3_oop_opr;
1046   LIR_Opr tmp3 = FrameMap::G4_oop_opr;
1047   LIR_Opr tmp4 = FrameMap::O1_oop_opr;
1048   LIR_Opr klass_reg = FrameMap::G5_metadata_opr;
1049   LIR_Opr len = length.result();
1050 
1051   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info);
1052   ciMetadata* obj = ciObjArrayKlass::make(x-&gt;klass());
1053   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
1054     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
1055   }
1056   klass2reg_with_patching(klass_reg, obj, patching_info);
1057   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);
1058 
1059   LIR_Opr result = rlock_result(x);
1060   __ move(reg, result);
1061 }
1062 
1063 
1064 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
1065   Values* dims = x-&gt;dims();
1066   int i = dims-&gt;length();
1067   LIRItemList* items = new LIRItemList(i, i, NULL);
1068   while (i-- &gt; 0) {
1069     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
1070     items-&gt;at_put(i, size);
1071   }
1072 
1073   // Evaluate state_for early since it may emit code.
1074   CodeEmitInfo* patching_info = NULL;
1075   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1076     patching_info = state_for(x, x-&gt;state_before());
1077 
1078     // Cannot re-use same xhandlers for multiple CodeEmitInfos, so
1079     // clone all handlers (NOTE: Usually this is handled transparently
1080     // by the CodeEmitInfo cloning logic in CodeStub constructors but
1081     // is done explicitly here because a stub isn&#39;t being used).
1082     x-&gt;set_exception_handlers(new XHandlers(x-&gt;exception_handlers()));
1083   }
1084   CodeEmitInfo* info = state_for(x, x-&gt;state());
1085 
1086   i = dims-&gt;length();
1087   while (i-- &gt; 0) {
1088     LIRItem* size = items-&gt;at(i);
1089     size-&gt;load_item();
1090     store_stack_parameter (size-&gt;result(),
1091                            in_ByteSize(STACK_BIAS +
1092                                        frame::memory_parameter_word_sp_offset * wordSize +
1093                                        i * sizeof(jint)));
1094   }
1095 
1096   // This instruction can be deoptimized in the slow path : use
1097   // O0 as result register.
1098   const LIR_Opr klass_reg = FrameMap::O0_metadata_opr;
1099   klass2reg_with_patching(klass_reg, x-&gt;klass(), patching_info);
1100   LIR_Opr rank = FrameMap::O1_opr;
1101   __ move(LIR_OprFact::intConst(x-&gt;rank()), rank);
1102   LIR_Opr varargs = FrameMap::as_pointer_opr(O2);
1103   int offset_from_sp = (frame::memory_parameter_word_sp_offset * wordSize) + STACK_BIAS;
1104   __ add(FrameMap::SP_opr,
1105          LIR_OprFact::intptrConst(offset_from_sp),
1106          varargs);
1107   LIR_OprList* args = new LIR_OprList(3);
1108   args-&gt;append(klass_reg);
1109   args-&gt;append(rank);
1110   args-&gt;append(varargs);
1111   const LIR_Opr reg = result_register_for(x-&gt;type());
1112   __ call_runtime(Runtime1::entry_for(Runtime1::new_multi_array_id),
1113                   LIR_OprFact::illegalOpr,
1114                   reg, args, info);
1115 
1116   LIR_Opr result = rlock_result(x);
1117   __ move(reg, result);
1118 }
1119 
1120 
1121 void LIRGenerator::do_BlockBegin(BlockBegin* x) {
1122 }
1123 
1124 
1125 void LIRGenerator::do_CheckCast(CheckCast* x) {
1126   LIRItem obj(x-&gt;obj(), this);
1127   CodeEmitInfo* patching_info = NULL;
1128   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
1129     // must do this before locking the destination register as an oop register,
1130     // and before the obj is loaded (so x-&gt;obj()-&gt;item() is valid for creating a debug info location)
1131     patching_info = state_for(x, x-&gt;state_before());
1132   }
1133   obj.load_item();
1134   LIR_Opr out_reg = rlock_result(x);
1135   CodeStub* stub;
1136   CodeEmitInfo* info_for_exception =
1137       (x-&gt;needs_exception_state() ? state_for(x) :
1138                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
1139 
1140   if (x-&gt;is_incompatible_class_change_check()) {
1141     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1142     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
1143   } else if (x-&gt;is_invokespecial_receiver_check()) {
1144     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1145     stub = new DeoptimizeStub(info_for_exception,
1146                               Deoptimization::Reason_class_check,
1147                               Deoptimization::Action_none);
1148   } else {
1149     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
1150   }
1151   LIR_Opr tmp1 = FrameMap::G1_oop_opr;
1152   LIR_Opr tmp2 = FrameMap::G3_oop_opr;
1153   LIR_Opr tmp3 = FrameMap::G4_oop_opr;
1154   __ checkcast(out_reg, obj.result(), x-&gt;klass(), tmp1, tmp2, tmp3,
1155                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
1156                x-&gt;profiled_method(), x-&gt;profiled_bci());
1157 }
1158 
1159 
1160 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
1161   LIRItem obj(x-&gt;obj(), this);
1162   CodeEmitInfo* patching_info = NULL;
1163   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1164     patching_info = state_for(x, x-&gt;state_before());
1165   }
1166   // ensure the result register is not the input register because the result is initialized before the patching safepoint
1167   obj.load_item();
1168   LIR_Opr out_reg = rlock_result(x);
1169   LIR_Opr tmp1 = FrameMap::G1_oop_opr;
1170   LIR_Opr tmp2 = FrameMap::G3_oop_opr;
1171   LIR_Opr tmp3 = FrameMap::G4_oop_opr;
1172   __ instanceof(out_reg, obj.result(), x-&gt;klass(), tmp1, tmp2, tmp3,
1173                 x-&gt;direct_compare(), patching_info,
1174                 x-&gt;profiled_method(), x-&gt;profiled_bci());
1175 }
1176 
1177 
1178 void LIRGenerator::do_If(If* x) {
1179   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
1180   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
1181   LIRItem xitem(x-&gt;x(), this);
1182   LIRItem yitem(x-&gt;y(), this);
1183   LIRItem* xin = &amp;xitem;
1184   LIRItem* yin = &amp;yitem;
1185   If::Condition cond = x-&gt;cond();
1186 
1187   if (tag == longTag) {
1188     // for longs, only conditions &quot;eql&quot;, &quot;neq&quot;, &quot;lss&quot;, &quot;geq&quot; are valid;
1189     // mirror for other conditions
1190     if (cond == If::gtr || cond == If::leq) {
1191       // swap inputs
1192       cond = Instruction::mirror(cond);
1193       xin = &amp;yitem;
1194       yin = &amp;xitem;
1195     }
1196     xin-&gt;set_destroys_register();
1197   }
1198 
1199   LIR_Opr left = LIR_OprFact::illegalOpr;
1200   LIR_Opr right = LIR_OprFact::illegalOpr;
1201 
1202   xin-&gt;load_item();
1203   left = xin-&gt;result();
1204 
1205   if (is_simm13(yin-&gt;result())) {
1206     // inline int constants which are small enough to be immediate operands
1207     right = LIR_OprFact::value_type(yin-&gt;value()-&gt;type());
1208   } else if (tag == longTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; yin-&gt;get_jlong_constant() == 0 &amp;&amp;
1209              (cond == If::eql || cond == If::neq)) {
1210     // inline long zero
1211     right = LIR_OprFact::value_type(yin-&gt;value()-&gt;type());
1212   } else if (tag == objectTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; (yin-&gt;get_jobject_constant()-&gt;is_null_object())) {
1213     right = LIR_OprFact::value_type(yin-&gt;value()-&gt;type());
1214   } else {
1215     yin-&gt;load_item();
1216     right = yin-&gt;result();
1217   }
1218   set_no_result(x);
1219 
1220   // add safepoint before generating condition code so it can be recomputed
1221   if (x-&gt;is_safepoint()) {
1222     // increment backedge counter if needed
1223     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1224         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1225     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
1226   }
1227 
1228   __ cmp(lir_cond(cond), left, right);
1229   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1230   profile_branch(x, cond);
1231   move_to_phi(x-&gt;state());
1232   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
1233     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());
1234   } else {
1235     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());
1236   }
1237   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1238   __ jump(x-&gt;default_sux());
1239 }
1240 
1241 
1242 LIR_Opr LIRGenerator::getThreadPointer() {
1243   return FrameMap::as_pointer_opr(G2);
1244 }
1245 
1246 
1247 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1248   __ move(LIR_OprFact::intConst(block-&gt;block_id()), FrameMap::O0_opr);
1249   LIR_OprList* args = new LIR_OprList(1);
1250   args-&gt;append(FrameMap::O0_opr);
1251   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1252   __ call_runtime_leaf(func, rlock_callee_saved(T_INT), LIR_OprFact::illegalOpr, args);
1253 }
1254 
1255 
1256 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1257                                         CodeEmitInfo* info) {
1258   __ store(value, address, info);
1259 }
1260 
1261 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1262                                        CodeEmitInfo* info) {
1263   __ load(address, result, info);
1264 }
    </pre>
  </body>
</html>
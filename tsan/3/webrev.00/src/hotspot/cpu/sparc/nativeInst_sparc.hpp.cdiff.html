<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/sparc/nativeInst_sparc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nativeInst_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="relocInfo_sparc.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/nativeInst_sparc.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 313,11 ***</span>
  // (used to manipulate inline caches, primitive &amp; dll calls, etc.)
  class NativeCall;
  
  inline NativeCall* nativeCall_at(address instr);
  inline NativeCall* nativeCall_overwriting_at(address instr,
<span class="line-modified">!                                              address destination);</span>
  inline NativeCall* nativeCall_before(address return_address);
  class NativeCall: public NativeInstruction {
   public:
    enum Sparc_specific_constants {
      instruction_size                   = 8,
<span class="line-new-header">--- 313,11 ---</span>
  // (used to manipulate inline caches, primitive &amp; dll calls, etc.)
  class NativeCall;
  
  inline NativeCall* nativeCall_at(address instr);
  inline NativeCall* nativeCall_overwriting_at(address instr,
<span class="line-modified">!                                              address destination = NULL);</span>
  inline NativeCall* nativeCall_before(address return_address);
  class NativeCall: public NativeInstruction {
   public:
    enum Sparc_specific_constants {
      instruction_size                   = 8,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 342,11 ***</span>
    // unit test stuff
    static void  test();
  
    // Creation
    friend inline NativeCall* nativeCall_at(address instr);
<span class="line-modified">!   friend NativeCall* nativeCall_overwriting_at(address instr, address destination = NULL) {</span>
      // insert a &quot;blank&quot; call:
      NativeCall* call = (NativeCall*)instr;
      call-&gt;set_long_at(0 * BytesPerInstWord, call_instruction(destination, instr));
      call-&gt;set_long_at(1 * BytesPerInstWord, nop_instruction());
      assert(call-&gt;addr_at(2 * BytesPerInstWord) - instr == instruction_size, &quot;instruction size&quot;);
<span class="line-new-header">--- 342,11 ---</span>
    // unit test stuff
    static void  test();
  
    // Creation
    friend inline NativeCall* nativeCall_at(address instr);
<span class="line-modified">!   friend NativeCall* nativeCall_overwriting_at(address instr, address destination) {</span>
      // insert a &quot;blank&quot; call:
      NativeCall* call = (NativeCall*)instr;
      call-&gt;set_long_at(0 * BytesPerInstWord, call_instruction(destination, instr));
      call-&gt;set_long_at(1 * BytesPerInstWord, nop_instruction());
      assert(call-&gt;addr_at(2 * BytesPerInstWord) - instr == instruction_size, &quot;instruction size&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,11 ***</span>
  // The format of this extended-range call is:
  //      jumpl_to addr, lreg
  //      == sethi %hi54(addr), O7 ;  jumpl O7, %lo10(addr), O7 ;  &lt;delay&gt;
  // That is, it is essentially the same as a NativeJump.
  class NativeFarCall;
<span class="line-modified">! inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination);</span>
  inline NativeFarCall* nativeFarCall_at(address instr);
  class NativeFarCall: public NativeInstruction {
   public:
    enum Sparc_specific_constants {
      // instruction_size includes the delay slot instruction.
<span class="line-new-header">--- 411,11 ---</span>
  // The format of this extended-range call is:
  //      jumpl_to addr, lreg
  //      == sethi %hi54(addr), O7 ;  jumpl O7, %lo10(addr), O7 ;  &lt;delay&gt;
  // That is, it is essentially the same as a NativeJump.
  class NativeFarCall;
<span class="line-modified">! inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination = NULL);</span>
  inline NativeFarCall* nativeFarCall_at(address instr);
  class NativeFarCall: public NativeInstruction {
   public:
    enum Sparc_specific_constants {
      // instruction_size includes the delay slot instruction.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,11 ***</span>
        call-&gt;verify();
      #endif
      return call;
    }
  
<span class="line-modified">!   friend inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination = NULL) {</span>
      Unimplemented();
      NativeFarCall* call = (NativeFarCall*)instr;
      return call;
    }
  
<span class="line-new-header">--- 450,11 ---</span>
        call-&gt;verify();
      #endif
      return call;
    }
  
<span class="line-modified">!   friend inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination) {</span>
      Unimplemented();
      NativeFarCall* call = (NativeFarCall*)instr;
      return call;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 574,11 ***</span>
  //
  // Note that it is identical to NativeMovConstReg with the exception of a nop between the
  // sethi and the add.  The nop is required to be in the delay slot of the call instruction
  // which overwrites the sethi during patching.
  class NativeMovConstRegPatching;
<span class="line-modified">! inline NativeMovConstRegPatching* nativeMovConstRegPatching_at(address address);class NativeMovConstRegPatching: public NativeInstruction {</span>
   public:
    enum Sparc_specific_constants {
      sethi_offset           = 0,
      nop_offset             = 7 * BytesPerInstWord,
      add_offset             = nop_offset   + BytesPerInstWord,
<span class="line-new-header">--- 574,12 ---</span>
  //
  // Note that it is identical to NativeMovConstReg with the exception of a nop between the
  // sethi and the add.  The nop is required to be in the delay slot of the call instruction
  // which overwrites the sethi during patching.
  class NativeMovConstRegPatching;
<span class="line-modified">! inline NativeMovConstRegPatching* nativeMovConstRegPatching_at(address address);</span>
<span class="line-added">+ class NativeMovConstRegPatching: public NativeInstruction {</span>
   public:
    enum Sparc_specific_constants {
      sethi_offset           = 0,
      nop_offset             = 7 * BytesPerInstWord,
      add_offset             = nop_offset   + BytesPerInstWord,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 662,14 ***</span>
      // check if instruction is ld* [reg + offset], reg or st* reg, [reg + offset]
      int i0 = long_at(0);
      return (is_op(i0, Assembler::ldst_op));
    }
  
<span class="line-modified">!   address instruction_address() const           { return addr_at(0); }</span>
<span class="line-modified">!   address next_instruction_address() const      {</span>
<span class="line-modified">!     return addr_at(is_immediate() ? 4 : (7 * BytesPerInstWord));</span>
    }
    intptr_t   offset() const                             {
       return is_immediate()? inv_simm(long_at(0), offset_width) :
                              nativeMovConstReg_at(addr_at(0))-&gt;data();
    }
    void  set_offset(intptr_t x) {
<span class="line-new-header">--- 663,17 ---</span>
      // check if instruction is ld* [reg + offset], reg or st* reg, [reg + offset]
      int i0 = long_at(0);
      return (is_op(i0, Assembler::ldst_op));
    }
  
<span class="line-modified">!   address instruction_address() const { return addr_at(0); }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   int num_bytes_to_end_of_patch() const {</span>
<span class="line-added">+     return is_immediate()? BytesPerInstWord :</span>
<span class="line-added">+                            NativeMovConstReg::instruction_size;</span>
    }
<span class="line-added">+ </span>
    intptr_t   offset() const                             {
       return is_immediate()? inv_simm(long_at(0), offset_width) :
                              nativeMovConstReg_at(addr_at(0))-&gt;data();
    }
    void  set_offset(intptr_t x) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 682,12 ***</span>
  
    void  add_offset_in_bytes(intptr_t radd_offset)     {
        set_offset (offset() + radd_offset);
    }
  
<span class="line-removed">-   void  copy_instruction_to(address new_instruction_address);</span>
<span class="line-removed">- </span>
    void verify();
    void print ();
  
    // unit test stuff
    static void test();
<span class="line-new-header">--- 686,10 ---</span>
</pre>
<center><a href="nativeInst_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="relocInfo_sparc.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
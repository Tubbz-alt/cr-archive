<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/frame_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 29 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added"> 30 #include &quot;oops/markWord.hpp&quot;</span>
 31 #include &quot;oops/method.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;prims/methodHandles.hpp&quot;
 34 #include &quot;runtime/frame.inline.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 #include &quot;runtime/javaCalls.hpp&quot;
 37 #include &quot;runtime/monitorChunk.hpp&quot;
 38 #include &quot;runtime/signature.hpp&quot;
 39 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 40 #include &quot;runtime/stubRoutines.hpp&quot;
 41 #include &quot;vmreg_sparc.inline.hpp&quot;
 42 #ifdef COMPILER1
 43 #include &quot;c1/c1_Runtime1.hpp&quot;
 44 #include &quot;runtime/vframeArray.hpp&quot;
 45 #endif
 46 
 47 void RegisterMap::pd_clear() {
 48   if (_thread-&gt;has_last_Java_frame()) {
 49     frame fr = _thread-&gt;last_frame();
 50     _window = fr.sp();
 51   } else {
 52     _window = NULL;
 53   }
 54   _younger_window = NULL;
 55 }
 56 
 57 
 58 // Unified register numbering scheme: each 32-bits counts as a register
 59 // number, so all the V9 registers take 2 slots.
 60 const static int R_L_nums[] = {0+040,2+040,4+040,6+040,8+040,10+040,12+040,14+040};
 61 const static int R_I_nums[] = {0+060,2+060,4+060,6+060,8+060,10+060,12+060,14+060};
 62 const static int R_O_nums[] = {0+020,2+020,4+020,6+020,8+020,10+020,12+020,14+020};
 63 const static int R_G_nums[] = {0+000,2+000,4+000,6+000,8+000,10+000,12+000,14+000};
 64 static RegisterMap::LocationValidType bad_mask = 0;
 65 static RegisterMap::LocationValidType R_LIO_mask = 0;
 66 static bool register_map_inited = false;
 67 
 68 static void register_map_init() {
 69   if (!register_map_inited) {
 70     register_map_inited = true;
 71     int i;
 72     for (i = 0; i &lt; 8; i++) {
 73       assert(R_L_nums[i] &lt; RegisterMap::location_valid_type_size, &quot;in first chunk&quot;);
 74       assert(R_I_nums[i] &lt; RegisterMap::location_valid_type_size, &quot;in first chunk&quot;);
 75       assert(R_O_nums[i] &lt; RegisterMap::location_valid_type_size, &quot;in first chunk&quot;);
 76       assert(R_G_nums[i] &lt; RegisterMap::location_valid_type_size, &quot;in first chunk&quot;);
 77     }
 78 
 79     bad_mask |= (1LL &lt;&lt; R_O_nums[6]); // SP
 80     bad_mask |= (1LL &lt;&lt; R_O_nums[7]); // cPC
 81     bad_mask |= (1LL &lt;&lt; R_I_nums[6]); // FP
 82     bad_mask |= (1LL &lt;&lt; R_I_nums[7]); // rPC
 83     bad_mask |= (1LL &lt;&lt; R_G_nums[2]); // TLS
 84     bad_mask |= (1LL &lt;&lt; R_G_nums[7]); // reserved by libthread
 85 
 86     for (i = 0; i &lt; 8; i++) {
 87       R_LIO_mask |= (1LL &lt;&lt; R_L_nums[i]);
 88       R_LIO_mask |= (1LL &lt;&lt; R_I_nums[i]);
 89       R_LIO_mask |= (1LL &lt;&lt; R_O_nums[i]);
 90     }
 91   }
 92 }
 93 
 94 
 95 address RegisterMap::pd_location(VMReg regname) const {
 96   register_map_init();
 97 
 98   assert(regname-&gt;is_reg(), &quot;sanity check&quot;);
 99   // Only the GPRs get handled this way
100   if( !regname-&gt;is_Register())
101     return NULL;
102 
103   // don&#39;t talk about bad registers
104   if ((bad_mask &amp; ((LocationValidType)1 &lt;&lt; regname-&gt;value())) != 0) {
105     return NULL;
106   }
107 
108   // Convert to a GPR
109   Register reg;
110   int second_word = 0;
111   // 32-bit registers for in, out and local
112   if (!regname-&gt;is_concrete()) {
113     // HMM ought to return NULL for any non-concrete (odd) vmreg
114     // this all tied up in the fact we put out double oopMaps for
115     // register locations. When that is fixed we&#39;d will return NULL
116     // (or assert here).
117     reg = regname-&gt;prev()-&gt;as_Register();
118     second_word = sizeof(jint);
119   } else {
120     reg = regname-&gt;as_Register();
121   }
122   if (reg-&gt;is_out()) {
123     return _younger_window == NULL ? NULL :
124       second_word + (address)&amp;_younger_window[reg-&gt;after_save()-&gt;sp_offset_in_saved_window()];
125   }
126   if (reg-&gt;is_local() || reg-&gt;is_in()) {
127     assert(_window != NULL, &quot;Window should be available&quot;);
128     return second_word + (address)&amp;_window[reg-&gt;sp_offset_in_saved_window()];
129   }
130   // Only the window&#39;d GPRs get handled this way; not the globals.
131   return NULL;
132 }
133 
134 
135 #ifdef ASSERT
136 void RegisterMap::check_location_valid() {
137   register_map_init();
138   assert((_location_valid[0] &amp; bad_mask) == 0, &quot;cannot have special locations for SP,FP,TLS,etc.&quot;);
139 }
140 #endif
141 
142 // We are shifting windows.  That means we are moving all %i to %o,
143 // getting rid of all current %l, and keeping all %g.  This is only
144 // complicated if any of the location pointers for these are valid.
145 // The normal case is that everything is in its standard register window
146 // home, and _location_valid[0] is zero.  In that case, this routine
147 // does exactly nothing.
148 void RegisterMap::shift_individual_registers() {
149   if (!update_map())  return;  // this only applies to maps with locations
150   register_map_init();
151   check_location_valid();
152 
153   LocationValidType lv = _location_valid[0];
154   LocationValidType lv0 = lv;
155 
156   lv &amp;= ~R_LIO_mask;  // clear %l, %o, %i regs
157 
158   // if we cleared some non-%g locations, we may have to do some shifting
159   if (lv != lv0) {
160     // copy %i0-%i5 to %o0-%o5, if they have special locations
161     // This can happen in within stubs which spill argument registers
162     // around a dynamic link operation, such as resolve_opt_virtual_call.
163     for (int i = 0; i &lt; 8; i++) {
164       if (lv0 &amp; (1LL &lt;&lt; R_I_nums[i])) {
165         _location[R_O_nums[i]] = _location[R_I_nums[i]];
166         lv |=  (1LL &lt;&lt; R_O_nums[i]);
167       }
168     }
169   }
170 
171   _location_valid[0] = lv;
172   check_location_valid();
173 }
174 
175 bool frame::safe_for_sender(JavaThread *thread) {
176 
177   address _SP = (address) sp();
178   address _FP = (address) fp();
179   address _UNEXTENDED_SP = (address) unextended_sp();
<a name="3" id="anc3"></a>


180 
<a name="4" id="anc4"></a><span class="line-modified">181   // consider stack guards when trying to determine &quot;safe&quot; stack pointers</span>
<span class="line-added">182   // sp must be within the usable part of the stack (not in guards)</span>
<span class="line-added">183   if (!thread-&gt;is_in_usable_stack(_SP)) {</span>
184     return false;
185   }
186 
187   // unextended sp must be within the stack and above or equal sp
<a name="5" id="anc5"></a><span class="line-modified">188   bool unextended_sp_safe = (_UNEXTENDED_SP &lt; thread-&gt;stack_base()) &amp;&amp;</span>
189                             (_UNEXTENDED_SP &gt;= _SP);
190 
191   if (!unextended_sp_safe) return false;
192 
193   // an fp must be within the stack and above (but not equal) sp
<a name="6" id="anc6"></a><span class="line-modified">194   bool fp_safe = (_FP &lt; thread-&gt;stack_base()) &amp;&amp;</span>
195                  (_FP &gt; _SP);
196 
197   // We know sp/unextended_sp are safe only fp is questionable here
198 
199   // If the current frame is known to the code cache then we can attempt to
200   // to construct the sender and do some validation of it. This goes a long way
201   // toward eliminating issues when we get in frame construction code
202 
203   if (_cb != NULL ) {
204 
205     // First check if frame is complete and tester is reliable
206     // Unfortunately we can only check frame complete for runtime stubs and nmethod
207     // other generic buffer blobs are more problematic so we just assume they are
208     // ok. adapter blobs never have a frame complete and are never ok.
209 
210     if (!_cb-&gt;is_frame_complete_at(_pc)) {
211       if (_cb-&gt;is_compiled() || _cb-&gt;is_adapter_blob() || _cb-&gt;is_runtime_stub()) {
212         return false;
213       }
214     }
215 
216     // Could just be some random pointer within the codeBlob
217     if (!_cb-&gt;code_contains(_pc)) {
218       return false;
219     }
220 
221     // Entry frame checks
222     if (is_entry_frame()) {
223       // an entry frame must have a valid fp.
224       return fp_safe &amp;&amp; is_entry_frame_valid(thread);
225     }
226 
227     intptr_t* younger_sp = sp();
228     intptr_t* _SENDER_SP = sender_sp(); // sender is actually just _FP
229     bool adjusted_stack = is_interpreted_frame();
230 
231     address   sender_pc = (address)younger_sp[I7-&gt;sp_offset_in_saved_window()] + pc_return_offset;
232 
233 
234     // We must always be able to find a recognizable pc
235     CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);
236     if (sender_pc == NULL ||  sender_blob == NULL) {
237       return false;
238     }
239 
240     // Could be a zombie method
241     if (sender_blob-&gt;is_zombie() || sender_blob-&gt;is_unloaded()) {
242       return false;
243     }
244 
245     // It should be safe to construct the sender though it might not be valid
246 
247     frame sender(_SENDER_SP, younger_sp, adjusted_stack);
248 
249     // Do we have a valid fp?
250     address sender_fp = (address) sender.fp();
251 
252     // an fp must be within the stack and above (but not equal) current frame&#39;s _FP
253 
<a name="7" id="anc7"></a><span class="line-modified">254     bool sender_fp_safe = (sender_fp &lt; thread-&gt;stack_base()) &amp;&amp;</span>
255                    (sender_fp &gt; _FP);
256 
257     if (!sender_fp_safe) {
258       return false;
259     }
260 
261 
262     // If the potential sender is the interpreter then we can do some more checking
263     if (Interpreter::contains(sender_pc)) {
264       return sender.is_interpreted_frame_valid(thread);
265     }
266 
267     // Could just be some random pointer within the codeBlob
268     if (!sender.cb()-&gt;code_contains(sender_pc)) {
269       return false;
270     }
271 
272     // We should never be able to see an adapter if the current frame is something from code cache
273     if (sender_blob-&gt;is_adapter_blob()) {
274       return false;
275     }
276 
277     if (sender.is_entry_frame()) {
278       // Validate the JavaCallWrapper an entry frame must have
279 
280       address jcw = (address)sender.entry_frame_call_wrapper();
281 
<a name="8" id="anc8"></a><span class="line-modified">282       bool jcw_safe = (jcw &lt; thread-&gt;stack_base()) &amp;&amp; (jcw &gt; sender_fp);</span>
283 
284       return jcw_safe;
285     }
286 
287     // If the frame size is 0 something (or less) is bad because every nmethod has a non-zero frame size
288     // because you must allocate window space
289 
290     if (sender_blob-&gt;frame_size() &lt;= 0) {
291       assert(!sender_blob-&gt;is_compiled(), &quot;should count return address at least&quot;);
292       return false;
293     }
294 
295     // The sender should positively be an nmethod or call_stub. On sparc we might in fact see something else.
296     // The cause of this is because at a save instruction the O7 we get is a leftover from an earlier
297     // window use. So if a runtime stub creates two frames (common in fastdebug/debug) then we see the
298     // stale pc. So if the sender blob is not something we&#39;d expect we have little choice but to declare
299     // the stack unwalkable. pd_get_top_frame_for_signal_handler tries to recover from this by unwinding
300     // that initial frame and retrying.
301 
302     if (!sender_blob-&gt;is_compiled()) {
303       return false;
304     }
305 
306     // Could put some more validation for the potential non-interpreted sender
307     // frame we&#39;d create by calling sender if I could think of any. Wait for next crash in forte...
308 
309     // One idea is seeing if the sender_pc we have is one that we&#39;d expect to call to current cb
310 
311     // We&#39;ve validated the potential sender that would be created
312 
313     return true;
314 
315   }
316 
317   // Must be native-compiled frame. Since sender will try and use fp to find
318   // linkages it must be safe
319 
320   if (!fp_safe) return false;
321 
322   // could try and do some more potential verification of native frame if we could think of some...
323 
324   return true;
325 }
326 
327 // constructors
328 
329 // Construct an unpatchable, deficient frame
330 void frame::init(intptr_t* sp, address pc, CodeBlob* cb) {
331   assert( (((intptr_t)sp &amp; (wordSize-1)) == 0), &quot;frame constructor passed an invalid sp&quot;);
332   _sp = sp;
333   _younger_sp = NULL;
334   _pc = pc;
335   _cb = cb;
336   _sp_adjustment_by_callee = 0;
337   assert(pc == NULL &amp;&amp; cb == NULL || pc != NULL, &quot;can&#39;t have a cb and no pc!&quot;);
338   if (_cb == NULL &amp;&amp; _pc != NULL ) {
339     _cb = CodeCache::find_blob(_pc);
340   }
341   _deopt_state = unknown;
342 }
343 
344 frame::frame(intptr_t* sp, unpatchable_t, address pc, CodeBlob* cb) {
345   init(sp, pc, cb);
346 }
347 
348 frame::frame(intptr_t* sp, intptr_t* younger_sp, bool younger_frame_is_interpreted) :
349   _sp(sp),
350   _younger_sp(younger_sp),
351   _deopt_state(unknown),
352   _sp_adjustment_by_callee(0) {
353   if (younger_sp == NULL) {
354     // make a deficient frame which doesn&#39;t know where its PC is
355     _pc = NULL;
356     _cb = NULL;
357   } else {
358     _pc = (address)younger_sp[I7-&gt;sp_offset_in_saved_window()] + pc_return_offset;
359     assert( (intptr_t*)younger_sp[FP-&gt;sp_offset_in_saved_window()] == (intptr_t*)((intptr_t)sp - STACK_BIAS), &quot;younger_sp must be valid&quot;);
360     // Any frame we ever build should always &quot;safe&quot; therefore we should not have to call
361     // find_blob_unsafe
362     // In case of native stubs, the pc retrieved here might be
363     // wrong.  (the _last_native_pc will have the right value)
364     // So do not put add any asserts on the _pc here.
365   }
366 
367   if (_pc != NULL)
368     _cb = CodeCache::find_blob(_pc);
369 
370   // Check for MethodHandle call sites.
371   if (_cb != NULL) {
372     CompiledMethod* nm = _cb-&gt;as_compiled_method_or_null();
373     if (nm != NULL) {
374       if (nm-&gt;is_deopt_mh_entry(_pc) || nm-&gt;is_method_handle_return(_pc)) {
375         _sp_adjustment_by_callee = (intptr_t*) ((intptr_t) sp[L7_mh_SP_save-&gt;sp_offset_in_saved_window()] + STACK_BIAS) - sp;
376         // The SP is already adjusted by this MH call site, don&#39;t
377         // overwrite this value with the wrong interpreter value.
378         younger_frame_is_interpreted = false;
379       }
380     }
381   }
382 
383   if (younger_frame_is_interpreted) {
384     // compute adjustment to this frame&#39;s SP made by its interpreted callee
385     _sp_adjustment_by_callee = (intptr_t*) ((intptr_t) younger_sp[I5_savedSP-&gt;sp_offset_in_saved_window()] + STACK_BIAS) - sp;
386   }
387 
388   // It is important that the frame is fully constructed when we do
389   // this lookup as get_deopt_original_pc() needs a correct value for
390   // unextended_sp() which uses _sp_adjustment_by_callee.
391   if (_pc != NULL) {
392     address original_pc = CompiledMethod::get_deopt_original_pc(this);
393     if (original_pc != NULL) {
394       _pc = original_pc;
395       _deopt_state = is_deoptimized;
396     } else {
397       _deopt_state = not_deoptimized;
398     }
399   }
400 }
401 
402 #ifndef PRODUCT
403 // This is a generic constructor which is only used by pns() in debug.cpp.
404 frame::frame(void* sp, void* fp, void* pc) {
405   init((intptr_t*)sp, (address)pc, NULL);
406 }
407 
408 extern &quot;C&quot; void findpc(intptr_t x);
409 
410 void frame::pd_ps() {
411   intptr_t* curr_sp = sp();
412   intptr_t* prev_sp = curr_sp - 1;
413   intptr_t *pc = NULL;
414   intptr_t *next_pc = NULL;
415   int count = 0;
416   tty-&gt;print_cr(&quot;register window backtrace from &quot; INTPTR_FORMAT &quot;:&quot;, p2i(curr_sp));
417   while (curr_sp != NULL &amp;&amp; ((intptr_t)curr_sp &amp; 7) == 0 &amp;&amp; curr_sp &gt; prev_sp &amp;&amp; curr_sp &lt; prev_sp+1000) {
418     pc      = next_pc;
419     next_pc = (intptr_t*) curr_sp[I7-&gt;sp_offset_in_saved_window()];
420     tty-&gt;print(&quot;[%d] curr_sp=&quot; INTPTR_FORMAT &quot; pc=&quot;, count, p2i(curr_sp));
421     findpc((intptr_t)pc);
422     if (WizardMode &amp;&amp; Verbose) {
423       // print register window contents also
424       tty-&gt;print_cr(&quot;    L0..L7: {&quot;
425                     INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; &quot;
426                     INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; &quot;,
427                     curr_sp[0+0], curr_sp[0+1], curr_sp[0+2], curr_sp[0+3],
428                     curr_sp[0+4], curr_sp[0+5], curr_sp[0+6], curr_sp[0+7]);
429       tty-&gt;print_cr(&quot;    I0..I7: {&quot;
430                     INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; &quot;
431                     INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; &quot; INTPTR_FORMAT &quot; &quot;,
432                     curr_sp[8+0], curr_sp[8+1], curr_sp[8+2], curr_sp[8+3],
433                     curr_sp[8+4], curr_sp[8+5], curr_sp[8+6], curr_sp[8+7]);
434       // (and print stack frame contents too??)
435 
436       CodeBlob *b = CodeCache::find_blob((address) pc);
437       if (b != NULL) {
438         if (b-&gt;is_nmethod()) {
439           Method* m = ((nmethod*)b)-&gt;method();
440           int nlocals = m-&gt;max_locals();
441           int nparams  = m-&gt;size_of_parameters();
442           tty-&gt;print_cr(&quot;compiled java method (locals = %d, params = %d)&quot;, nlocals, nparams);
443         }
444       }
445     }
446     prev_sp = curr_sp;
447     curr_sp = (intptr_t *)curr_sp[FP-&gt;sp_offset_in_saved_window()];
448     curr_sp = (intptr_t *)((intptr_t)curr_sp + STACK_BIAS);
449     count += 1;
450   }
451   if (curr_sp != NULL)
452     tty-&gt;print(&quot;[%d] curr_sp=&quot; INTPTR_FORMAT &quot; [bogus sp!]&quot;, count, p2i(curr_sp));
453 }
454 
455 #endif // PRODUCT
456 
457 bool frame::is_interpreted_frame() const  {
458   return Interpreter::contains(pc());
459 }
460 
461 // sender_sp
462 
463 intptr_t* frame::interpreter_frame_sender_sp() const {
464   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
465   return fp();
466 }
467 
468 void frame::set_interpreter_frame_sender_sp(intptr_t* sender_sp) {
469   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
470   Unimplemented();
471 }
472 
473 frame frame::sender_for_entry_frame(RegisterMap *map) const {
474   assert(map != NULL, &quot;map must be set&quot;);
475   // Java frame called from C; skip all C frames and return top C
476   // frame of that chunk as the sender
477   JavaFrameAnchor* jfa = entry_frame_call_wrapper()-&gt;anchor();
478   assert(!entry_frame_is_first(), &quot;next Java fp must be non zero&quot;);
479   assert(jfa-&gt;last_Java_sp() &gt; _sp, &quot;must be above this frame on stack&quot;);
480   intptr_t* last_Java_sp = jfa-&gt;last_Java_sp();
481   // Since we are walking the stack now this nested anchor is obviously walkable
482   // even if it wasn&#39;t when it was stacked.
483   if (!jfa-&gt;walkable()) {
484     // Capture _last_Java_pc (if needed) and mark anchor walkable.
485     jfa-&gt;capture_last_Java_pc(_sp);
486   }
487   assert(jfa-&gt;last_Java_pc() != NULL, &quot;No captured pc!&quot;);
488   map-&gt;clear();
489   map-&gt;make_integer_regs_unsaved();
490   map-&gt;shift_window(last_Java_sp, NULL);
491   assert(map-&gt;include_argument_oops(), &quot;should be set by clear&quot;);
492   return frame(last_Java_sp, frame::unpatchable, jfa-&gt;last_Java_pc());
493 }
494 
495 frame frame::sender_for_interpreter_frame(RegisterMap *map) const {
496   ShouldNotCallThis();
497   return sender(map);
498 }
499 
500 frame frame::sender_for_compiled_frame(RegisterMap *map) const {
501   ShouldNotCallThis();
502   return sender(map);
503 }
504 
505 frame frame::sender(RegisterMap* map) const {
506   assert(map != NULL, &quot;map must be set&quot;);
507 
508   assert(CodeCache::find_blob_unsafe(_pc) == _cb, &quot;inconsistent&quot;);
509 
510   // Default is not to follow arguments; update it accordingly below
511   map-&gt;set_include_argument_oops(false);
512 
513   if (is_entry_frame()) return sender_for_entry_frame(map);
514 
515   intptr_t* younger_sp = sp();
516   intptr_t* sp         = sender_sp();
517 
518   // Note:  The version of this operation on any platform with callee-save
519   //        registers must update the register map (if not null).
520   //        In order to do this correctly, the various subtypes of
521   //        of frame (interpreted, compiled, glue, native),
522   //        must be distinguished.  There is no need on SPARC for
523   //        such distinctions, because all callee-save registers are
524   //        preserved for all frames via SPARC-specific mechanisms.
525   //
526   //        *** HOWEVER, *** if and when we make any floating-point
527   //        registers callee-saved, then we will have to copy over
528   //        the RegisterMap update logic from the Intel code.
529 
530   // The constructor of the sender must know whether this frame is interpreted so it can set the
531   // sender&#39;s _sp_adjustment_by_callee field.  An osr adapter frame was originally
532   // interpreted but its pc is in the code cache (for c1 -&gt; osr_frame_return_id stub), so it must be
533   // explicitly recognized.
534 
535 
536   bool frame_is_interpreted = is_interpreted_frame();
537   if (frame_is_interpreted) {
538     map-&gt;make_integer_regs_unsaved();
539     map-&gt;shift_window(sp, younger_sp);
540   } else if (_cb != NULL) {
541     // Update the locations of implicitly saved registers to be their
542     // addresses in the register save area.
543     // For %o registers, the addresses of %i registers in the next younger
544     // frame are used.
545     map-&gt;shift_window(sp, younger_sp);
546     if (map-&gt;update_map()) {
547       // Tell GC to use argument oopmaps for some runtime stubs that need it.
548       // For C1, the runtime stub might not have oop maps, so set this flag
549       // outside of update_register_map.
550       map-&gt;set_include_argument_oops(_cb-&gt;caller_must_gc_arguments(map-&gt;thread()));
551       if (_cb-&gt;oop_maps() != NULL) {
552         OopMapSet::update_register_map(this, map);
553       }
554     }
555   }
556   return frame(sp, younger_sp, frame_is_interpreted);
557 }
558 
559 
560 void frame::patch_pc(Thread* thread, address pc) {
561   vmassert(_deopt_state != unknown, &quot;frame is unpatchable&quot;);
562   if(thread == Thread::current()) {
563    StubRoutines::Sparc::flush_callers_register_windows_func()();
564   }
565   if (TracePcPatching) {
566     // QQQ this assert is invalid (or too strong anyway) sice _pc could
567     // be original pc and frame could have the deopt pc.
568     // assert(_pc == *O7_addr() + pc_return_offset, &quot;frame has wrong pc&quot;);
569     tty-&gt;print_cr(&quot;patch_pc at address &quot; INTPTR_FORMAT &quot; [&quot; INTPTR_FORMAT &quot; -&gt; &quot; INTPTR_FORMAT &quot;]&quot;,
570                   p2i(O7_addr()), p2i(_pc), p2i(pc));
571   }
572   _cb = CodeCache::find_blob(pc);
573   *O7_addr() = pc - pc_return_offset;
574   _cb = CodeCache::find_blob(_pc);
575   address original_pc = CompiledMethod::get_deopt_original_pc(this);
576   if (original_pc != NULL) {
577     assert(original_pc == _pc, &quot;expected original to be stored before patching&quot;);
578     _deopt_state = is_deoptimized;
579   } else {
580     _deopt_state = not_deoptimized;
581   }
582 }
583 
584 
585 static bool sp_is_valid(intptr_t* old_sp, intptr_t* young_sp, intptr_t* sp) {
586   return (((intptr_t)sp &amp; (2*wordSize-1)) == 0 &amp;&amp;
587           sp &lt;= old_sp &amp;&amp;
588           sp &gt;= young_sp);
589 }
590 
591 
592 /*
593   Find the (biased) sp that is just younger than old_sp starting at sp.
594   If not found return NULL. Register windows are assumed to be flushed.
595 */
596 intptr_t* frame::next_younger_sp_or_null(intptr_t* old_sp, intptr_t* sp) {
597 
598   intptr_t* previous_sp = NULL;
599   intptr_t* orig_sp = sp;
600 
601   int max_frames = (old_sp - sp) / 16; // Minimum frame size is 16
602   int max_frame2 = max_frames;
603   while(sp != old_sp &amp;&amp; sp_is_valid(old_sp, orig_sp, sp)) {
604     if (max_frames-- &lt;= 0)
605       // too many frames have gone by; invalid parameters given to this function
606       break;
607     previous_sp = sp;
608     sp = (intptr_t*)sp[FP-&gt;sp_offset_in_saved_window()];
609     sp = (intptr_t*)((intptr_t)sp + STACK_BIAS);
610   }
611 
612   return (sp == old_sp ? previous_sp : NULL);
613 }
614 
615 /*
616   Determine if &quot;sp&quot; is a valid stack pointer. &quot;sp&quot; is assumed to be younger than
617   &quot;valid_sp&quot;. So if &quot;sp&quot; is valid itself then it should be possible to walk frames
618   from &quot;sp&quot; to &quot;valid_sp&quot;. The assumption is that the registers windows for the
619   thread stack in question are flushed.
620 */
621 bool frame::is_valid_stack_pointer(intptr_t* valid_sp, intptr_t* sp) {
622   return next_younger_sp_or_null(valid_sp, sp) != NULL;
623 }
624 
625 bool frame::is_interpreted_frame_valid(JavaThread* thread) const {
626   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
627   // These are reasonable sanity checks
628   if (fp() == 0 || (intptr_t(fp()) &amp; (2*wordSize-1)) != 0) {
629     return false;
630   }
631   if (sp() == 0 || (intptr_t(sp()) &amp; (2*wordSize-1)) != 0) {
632     return false;
633   }
634 
635   const intptr_t interpreter_frame_initial_sp_offset = interpreter_frame_vm_local_words;
636   if (fp() + interpreter_frame_initial_sp_offset &lt; sp()) {
637     return false;
638   }
639   // These are hacks to keep us out of trouble.
640   // The problem with these is that they mask other problems
641   if (fp() &lt;= sp()) {        // this attempts to deal with unsigned comparison above
642     return false;
643   }
644   // do some validation of frame elements
645 
646   // first the method
647 
648   Method* m = *interpreter_frame_method_addr();
649 
650   // validate the method we&#39;d find in this potential sender
651   if (!Method::is_valid_method(m)) return false;
652 
653   // stack frames shouldn&#39;t be much larger than max_stack elements
654 
655   if (fp() - unextended_sp() &gt; 1024 + m-&gt;max_stack()*Interpreter::stackElementSize) {
656     return false;
657   }
658 
659   // validate bci/bcp
660 
661   address bcp = interpreter_frame_bcp();
662   if (m-&gt;validate_bci_from_bcp(bcp) &lt; 0) {
663     return false;
664   }
665 
666   // validate ConstantPoolCache*
667   ConstantPoolCache* cp = *interpreter_frame_cache_addr();
<a name="9" id="anc9"></a><span class="line-modified">668   if (MetaspaceObj::is_valid(cp) == false) return false;</span>
669 
670   // validate locals
671 
672   address locals =  (address) *interpreter_frame_locals_addr();
673 
<a name="10" id="anc10"></a><span class="line-modified">674   if (locals &gt;= thread-&gt;stack_base() || locals &lt; (address) fp()) return false;</span>
675 
676   // We&#39;d have to be pretty unlucky to be mislead at this point
677   return true;
678 }
679 
680 
681 // Windows have been flushed on entry (but not marked). Capture the pc that
682 // is the return address to the frame that contains &quot;sp&quot; as its stack pointer.
683 // This pc resides in the called of the frame corresponding to &quot;sp&quot;.
684 // As a side effect we mark this JavaFrameAnchor as having flushed the windows.
685 // This side effect lets us mark stacked JavaFrameAnchors (stacked in the
686 // call_helper) as flushed when we have flushed the windows for the most
687 // recent (i.e. current) JavaFrameAnchor. This saves useless flushing calls
688 // and lets us find the pc just once rather than multiple times as it did
689 // in the bad old _post_Java_state days.
690 //
691 void JavaFrameAnchor::capture_last_Java_pc(intptr_t* sp) {
692   if (last_Java_sp() != NULL &amp;&amp; last_Java_pc() == NULL) {
693     // try and find the sp just younger than _last_Java_sp
694     intptr_t* _post_Java_sp = frame::next_younger_sp_or_null(last_Java_sp(), sp);
695     // Really this should never fail otherwise VM call must have non-standard
696     // frame linkage (bad) or stack is not properly flushed (worse).
697     guarantee(_post_Java_sp != NULL, &quot;bad stack!&quot;);
698     _last_Java_pc = (address) _post_Java_sp[ I7-&gt;sp_offset_in_saved_window()] + frame::pc_return_offset;
699 
700   }
701   set_window_flushed();
702 }
703 
704 void JavaFrameAnchor::make_walkable(JavaThread* thread) {
705   if (walkable()) return;
706   // Eventually make an assert
707   guarantee(Thread::current() == (Thread*)thread, &quot;only current thread can flush its registers&quot;);
708   // We always flush in case the profiler wants it but we won&#39;t mark
709   // the windows as flushed unless we have a last_Java_frame
710   intptr_t* sp = StubRoutines::Sparc::flush_callers_register_windows_func()();
711   if (last_Java_sp() != NULL ) {
712     capture_last_Java_pc(sp);
713   }
714 }
715 
716 intptr_t* frame::entry_frame_argument_at(int offset) const {
717   // convert offset to index to deal with tsi
718   int index = (Interpreter::expr_offset_in_bytes(offset)/wordSize);
719 
720   intptr_t* LSP = (intptr_t*) sp()[Lentry_args-&gt;sp_offset_in_saved_window()];
721   return &amp;LSP[index+1];
722 }
723 
724 
725 BasicType frame::interpreter_frame_result(oop* oop_result, jvalue* value_result) {
726   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
727   Method* method = interpreter_frame_method();
728   BasicType type = method-&gt;result_type();
729 
730   if (method-&gt;is_native()) {
731     // Prior to notifying the runtime of the method_exit the possible result
732     // value is saved to l_scratch and d_scratch.
733 
734     intptr_t* l_scratch = fp() + interpreter_frame_l_scratch_fp_offset;
735     intptr_t* d_scratch = fp() + interpreter_frame_d_scratch_fp_offset;
736 
737     address l_addr = (address)l_scratch;
738     // On 64-bit the result for 1/8/16/32-bit result types is in the other
739     // word half
740     l_addr += wordSize/2;
741 
742     switch (type) {
743       case T_OBJECT:
744       case T_ARRAY: {
745         oop obj = cast_to_oop(at(interpreter_frame_oop_temp_offset));
746         assert(obj == NULL || Universe::heap()-&gt;is_in(obj), &quot;sanity check&quot;);
747         *oop_result = obj;
748         break;
749       }
750 
751       case T_BOOLEAN : { jint* p = (jint*)l_addr; value_result-&gt;z = (jboolean)((*p) &amp; 0x1); break; }
752       case T_BYTE    : { jint* p = (jint*)l_addr; value_result-&gt;b = (jbyte)((*p) &amp; 0xff); break; }
753       case T_CHAR    : { jint* p = (jint*)l_addr; value_result-&gt;c = (jchar)((*p) &amp; 0xffff); break; }
754       case T_SHORT   : { jint* p = (jint*)l_addr; value_result-&gt;s = (jshort)((*p) &amp; 0xffff); break; }
755       case T_INT     : value_result-&gt;i = *(jint*)l_addr; break;
756       case T_LONG    : value_result-&gt;j = *(jlong*)l_scratch; break;
757       case T_FLOAT   : value_result-&gt;f = *(jfloat*)d_scratch; break;
758       case T_DOUBLE  : value_result-&gt;d = *(jdouble*)d_scratch; break;
759       case T_VOID    : /* Nothing to do */ break;
760       default        : ShouldNotReachHere();
761     }
762   } else {
763     intptr_t* tos_addr = interpreter_frame_tos_address();
764 
765     switch(type) {
766       case T_OBJECT:
767       case T_ARRAY: {
768         oop obj = cast_to_oop(*tos_addr);
769         assert(obj == NULL || Universe::heap()-&gt;is_in(obj), &quot;sanity check&quot;);
770         *oop_result = obj;
771         break;
772       }
773       case T_BOOLEAN : { jint* p = (jint*)tos_addr; value_result-&gt;z = (jboolean)((*p) &amp; 0x1); break; }
774       case T_BYTE    : { jint* p = (jint*)tos_addr; value_result-&gt;b = (jbyte)((*p) &amp; 0xff); break; }
775       case T_CHAR    : { jint* p = (jint*)tos_addr; value_result-&gt;c = (jchar)((*p) &amp; 0xffff); break; }
776       case T_SHORT   : { jint* p = (jint*)tos_addr; value_result-&gt;s = (jshort)((*p) &amp; 0xffff); break; }
777       case T_INT     : value_result-&gt;i = *(jint*)tos_addr; break;
778       case T_LONG    : value_result-&gt;j = *(jlong*)tos_addr; break;
779       case T_FLOAT   : value_result-&gt;f = *(jfloat*)tos_addr; break;
780       case T_DOUBLE  : value_result-&gt;d = *(jdouble*)tos_addr; break;
781       case T_VOID    : /* Nothing to do */ break;
782       default        : ShouldNotReachHere();
783     }
784   };
785 
786   return type;
787 }
788 
789 // Lesp pointer is one word lower than the top item on the stack.
790 intptr_t* frame::interpreter_frame_tos_at(jint offset) const {
791   int index = (Interpreter::expr_offset_in_bytes(offset)/wordSize) - 1;
792   return &amp;interpreter_frame_tos_address()[index];
793 }
794 
795 
796 #ifndef PRODUCT
797 
798 #define DESCRIBE_FP_OFFSET(name) \
799   values.describe(frame_no, fp() + frame::name##_offset, #name)
800 
801 void frame::describe_pd(FrameValues&amp; values, int frame_no) {
802   for (int w = 0; w &lt; frame::register_save_words; w++) {
803     values.describe(frame_no, sp() + w, err_msg(&quot;register save area word %d&quot;, w), 1);
804   }
805 
806   if (is_interpreted_frame()) {
807     DESCRIBE_FP_OFFSET(interpreter_frame_d_scratch_fp);
808     DESCRIBE_FP_OFFSET(interpreter_frame_l_scratch_fp);
809     DESCRIBE_FP_OFFSET(interpreter_frame_mirror);
810     DESCRIBE_FP_OFFSET(interpreter_frame_oop_temp);
811 
812     // esp, according to Lesp (e.g. not depending on bci), if seems valid
813     intptr_t* esp = *interpreter_frame_esp_addr();
814     if ((esp &gt;= sp()) &amp;&amp; (esp &lt; fp())) {
815       values.describe(-1, esp, &quot;*Lesp&quot;);
816     }
817   }
818 
819   if (!is_compiled_frame()) {
820     if (frame::callee_aggregate_return_pointer_words != 0) {
821       values.describe(frame_no, sp() + frame::callee_aggregate_return_pointer_sp_offset, &quot;callee_aggregate_return_pointer_word&quot;);
822     }
823     for (int w = 0; w &lt; frame::callee_register_argument_save_area_words; w++) {
824       values.describe(frame_no, sp() + frame::callee_register_argument_save_area_sp_offset + w,
825                       err_msg(&quot;callee_register_argument_save_area_words %d&quot;, w));
826     }
827   }
828 }
829 
830 #endif
831 
832 intptr_t *frame::initial_deoptimization_info() {
833   // unused... but returns fp() to minimize changes introduced by 7087445
834   return fp();
835 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
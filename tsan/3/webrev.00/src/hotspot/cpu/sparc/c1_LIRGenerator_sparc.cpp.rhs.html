<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/c1_LIRGenerator_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.inline.hpp&quot;
  27 #include &quot;c1/c1_Compilation.hpp&quot;
  28 #include &quot;c1/c1_FrameMap.hpp&quot;
  29 #include &quot;c1/c1_Instruction.hpp&quot;
  30 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_Runtime1.hpp&quot;
  33 #include &quot;c1/c1_ValueStack.hpp&quot;
  34 #include &quot;ci/ciArray.hpp&quot;
  35 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  36 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  37 #include &quot;runtime/safepointMechanism.hpp&quot;
  38 #include &quot;runtime/sharedRuntime.hpp&quot;
  39 #include &quot;runtime/stubRoutines.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  40 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  41 #include &quot;vmreg_sparc.inline.hpp&quot;
  42 
  43 #ifdef ASSERT
  44 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  45 #else
  46 #define __ gen()-&gt;lir()-&gt;
  47 #endif
  48 
  49 void LIRItem::load_byte_item() {
  50   // byte loads use same registers as other loads
  51   load_item();
  52 }
  53 
  54 
  55 void LIRItem::load_nonconstant() {
  56   LIR_Opr r = value()-&gt;operand();
  57   if (_gen-&gt;can_inline_as_constant(value())) {
  58     if (!r-&gt;is_constant()) {
  59       r = LIR_OprFact::value_type(value()-&gt;type());
  60     }
  61     _result = r;
  62   } else {
  63     load_item();
  64   }
  65 }
  66 
  67 
  68 //--------------------------------------------------------------
  69 //               LIRGenerator
  70 //--------------------------------------------------------------
  71 
  72 LIR_Opr LIRGenerator::exceptionOopOpr()              { return FrameMap::Oexception_opr;  }
  73 LIR_Opr LIRGenerator::exceptionPcOpr()               { return FrameMap::Oissuing_pc_opr; }
  74 LIR_Opr LIRGenerator::syncLockOpr()                  { return new_register(T_INT); }
  75 LIR_Opr LIRGenerator::syncTempOpr()                  { return new_register(T_OBJECT); }
  76 LIR_Opr LIRGenerator::getThreadTemp()                { return rlock_callee_saved(T_LONG); }
  77 
  78 LIR_Opr LIRGenerator::result_register_for(ValueType* type, bool callee) {
  79   LIR_Opr opr;
  80   switch (type-&gt;tag()) {
  81   case intTag:     opr = callee ? FrameMap::I0_opr      : FrameMap::O0_opr;       break;
  82   case objectTag:  opr = callee ? FrameMap::I0_oop_opr  : FrameMap::O0_oop_opr;   break;
  83   case longTag:    opr = callee ? FrameMap::in_long_opr : FrameMap::out_long_opr; break;
  84   case floatTag:   opr = FrameMap::F0_opr;                                        break;
  85   case doubleTag:  opr = FrameMap::F0_double_opr;                                 break;
  86 
  87   case addressTag:
  88   default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
  89   }
  90 
  91   assert(opr-&gt;type_field() == as_OprType(as_BasicType(type)), &quot;type mismatch&quot;);
  92   return opr;
  93 }
  94 
  95 LIR_Opr LIRGenerator::rlock_callee_saved(BasicType type) {
  96   LIR_Opr reg = new_register(type);
  97   set_vreg_flag(reg, callee_saved);
  98   return reg;
  99 }
 100 
 101 
 102 LIR_Opr LIRGenerator::rlock_byte(BasicType type) {
 103   return new_register(T_INT);
 104 }
 105 
 106 
 107 
 108 
 109 
 110 //--------- loading items into registers --------------------------------
 111 
 112 // SPARC cannot inline all constants
 113 bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {
 114   if (v-&gt;type()-&gt;as_IntConstant() != NULL) {
 115     return v-&gt;type()-&gt;as_IntConstant()-&gt;value() == 0;
 116   } else if (v-&gt;type()-&gt;as_LongConstant() != NULL) {
 117     return v-&gt;type()-&gt;as_LongConstant()-&gt;value() == 0L;
 118   } else if (v-&gt;type()-&gt;as_ObjectConstant() != NULL) {
 119     return v-&gt;type()-&gt;as_ObjectConstant()-&gt;value()-&gt;is_null_object();
 120   } else {
 121     return false;
 122   }
 123 }
 124 
 125 
 126 // only simm13 constants can be inlined
 127 bool LIRGenerator:: can_inline_as_constant(Value i) const {
 128   if (i-&gt;type()-&gt;as_IntConstant() != NULL) {
 129     return Assembler::is_simm13(i-&gt;type()-&gt;as_IntConstant()-&gt;value());
 130   } else {
 131     return can_store_as_constant(i, as_BasicType(i-&gt;type()));
 132   }
 133 }
 134 
 135 
 136 bool LIRGenerator:: can_inline_as_constant(LIR_Const* c) const {
 137   if (c-&gt;type() == T_INT) {
 138     return Assembler::is_simm13(c-&gt;as_jint());
 139   }
 140   return false;
 141 }
 142 
 143 
 144 LIR_Opr LIRGenerator::safepoint_poll_register() {
 145   return new_register(T_INT);
 146 }
 147 
 148 
 149 
 150 LIR_Address* LIRGenerator::generate_address(LIR_Opr base, LIR_Opr index,
 151                                             int shift, int disp, BasicType type) {
 152   assert(base-&gt;is_register(), &quot;must be&quot;);
 153   intx large_disp = disp;
 154 
 155   // accumulate fixed displacements
 156   if (index-&gt;is_constant()) {
 157     large_disp += (intx)(index-&gt;as_constant_ptr()-&gt;as_jint()) &lt;&lt; shift;
 158     index = LIR_OprFact::illegalOpr;
 159   }
 160 
 161   if (index-&gt;is_register()) {
 162     // apply the shift and accumulate the displacement
 163     if (shift &gt; 0) {
 164       LIR_Opr tmp = new_pointer_register();
 165       __ shift_left(index, shift, tmp);
 166       index = tmp;
 167     }
 168     if (large_disp != 0) {
 169       LIR_Opr tmp = new_pointer_register();
 170       if (Assembler::is_simm13(large_disp)) {
 171         __ add(tmp, LIR_OprFact::intptrConst(large_disp), tmp);
 172         index = tmp;
 173       } else {
 174         __ move(LIR_OprFact::intptrConst(large_disp), tmp);
 175         __ add(tmp, index, tmp);
 176         index = tmp;
 177       }
 178       large_disp = 0;
 179     }
 180   } else if (large_disp != 0 &amp;&amp; !Assembler::is_simm13(large_disp)) {
 181     // index is illegal so replace it with the displacement loaded into a register
 182     index = new_pointer_register();
 183     __ move(LIR_OprFact::intptrConst(large_disp), index);
 184     large_disp = 0;
 185   }
 186 
 187   // at this point we either have base + index or base + displacement
 188   if (large_disp == 0) {
 189     return new LIR_Address(base, index, type);
 190   } else {
 191     assert(Assembler::is_simm13(large_disp), &quot;must be&quot;);
 192     return new LIR_Address(base, large_disp, type);
 193   }
 194 }
 195 
 196 
 197 LIR_Address* LIRGenerator::emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr,
 198                                               BasicType type) {
 199   int elem_size = type2aelembytes(type);
 200   int shift = exact_log2(elem_size);
 201 
 202   LIR_Opr base_opr;
 203   intx offset = arrayOopDesc::base_offset_in_bytes(type);
 204 
 205   if (index_opr-&gt;is_constant()) {
 206     intx i = index_opr-&gt;as_constant_ptr()-&gt;as_jint();
 207     intx array_offset = i * elem_size;
 208     if (Assembler::is_simm13(array_offset + offset)) {
 209       base_opr = array_opr;
 210       offset = array_offset + offset;
 211     } else {
 212       base_opr = new_pointer_register();
 213       if (Assembler::is_simm13(array_offset)) {
 214         __ add(array_opr, LIR_OprFact::intptrConst(array_offset), base_opr);
 215       } else {
 216         __ move(LIR_OprFact::intptrConst(array_offset), base_opr);
 217         __ add(base_opr, array_opr, base_opr);
 218       }
 219     }
 220   } else {
 221     if (index_opr-&gt;type() == T_INT) {
 222       LIR_Opr tmp = new_register(T_LONG);
 223       __ convert(Bytecodes::_i2l, index_opr, tmp);
 224       index_opr = tmp;
 225     }
 226 
 227     base_opr = new_pointer_register();
 228     assert (index_opr-&gt;is_register(), &quot;Must be register&quot;);
 229     if (shift &gt; 0) {
 230       __ shift_left(index_opr, shift, base_opr);
 231       __ add(base_opr, array_opr, base_opr);
 232     } else {
 233       __ add(index_opr, array_opr, base_opr);
 234     }
 235   }
 236 
 237   return new LIR_Address(base_opr, offset, type);
 238 }
 239 
 240 LIR_Opr LIRGenerator::load_immediate(int x, BasicType type) {
 241   LIR_Opr r;
 242   if (type == T_LONG) {
 243     r = LIR_OprFact::longConst(x);
 244   } else if (type == T_INT) {
 245     r = LIR_OprFact::intConst(x);
 246   } else {
 247     ShouldNotReachHere();
 248   }
 249   if (!Assembler::is_simm13(x)) {
 250     LIR_Opr tmp = new_register(type);
 251     __ move(r, tmp);
 252     return tmp;
 253   }
 254   return r;
 255 }
 256 
 257 void LIRGenerator::increment_counter(address counter, BasicType type, int step) {
 258   LIR_Opr pointer = new_pointer_register();
 259   __ move(LIR_OprFact::intptrConst(counter), pointer);
 260   LIR_Address* addr = new LIR_Address(pointer, type);
 261   increment_counter(addr, step);
 262 }
 263 
 264 void LIRGenerator::increment_counter(LIR_Address* addr, int step) {
 265   LIR_Opr temp = new_register(addr-&gt;type());
 266   __ move(addr, temp);
 267   __ add(temp, load_immediate(step, addr-&gt;type()), temp);
 268   __ move(temp, addr);
 269 }
 270 
 271 void LIRGenerator::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
 272   LIR_Opr o7opr = FrameMap::O7_opr;
 273   __ load(new LIR_Address(base, disp, T_INT), o7opr, info);
 274   __ cmp(condition, o7opr, c);
 275 }
 276 
 277 
 278 void LIRGenerator::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Opr base, int disp, BasicType type, CodeEmitInfo* info) {
 279   LIR_Opr o7opr = FrameMap::O7_opr;
 280   __ load(new LIR_Address(base, disp, type), o7opr, info);
 281   __ cmp(condition, reg, o7opr);
 282 }
 283 
 284 
 285 bool LIRGenerator::strength_reduce_multiply(LIR_Opr left, int c, LIR_Opr result, LIR_Opr tmp) {
 286   assert(left != result, &quot;should be different registers&quot;);
 287   if (is_power_of_2(c + 1)) {
 288     __ shift_left(left, log2_int(c + 1), result);
 289     __ sub(result, left, result);
 290     return true;
 291   } else if (is_power_of_2(c - 1)) {
 292     __ shift_left(left, log2_int(c - 1), result);
 293     __ add(result, left, result);
 294     return true;
 295   }
 296   return false;
 297 }
 298 
 299 
 300 void LIRGenerator::store_stack_parameter (LIR_Opr item, ByteSize offset_from_sp) {
 301   BasicType t = item-&gt;type();
 302   LIR_Opr sp_opr = FrameMap::SP_opr;
 303   if ((t == T_LONG || t == T_DOUBLE) &amp;&amp;
 304       ((in_bytes(offset_from_sp) - STACK_BIAS) % 8 != 0)) {
 305     __ unaligned_move(item, new LIR_Address(sp_opr, in_bytes(offset_from_sp), t));
 306   } else {
 307     __ move(item, new LIR_Address(sp_opr, in_bytes(offset_from_sp), t));
 308   }
 309 }
 310 
 311 void LIRGenerator::array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci) {
 312   LIR_Opr tmp1 = FrameMap::G1_opr;
 313   LIR_Opr tmp2 = FrameMap::G3_opr;
 314   LIR_Opr tmp3 = FrameMap::G5_opr;
 315   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 316 }
 317 
 318 //----------------------------------------------------------------------
 319 //             visitor functions
 320 //----------------------------------------------------------------------
 321 
 322 void LIRGenerator::do_MonitorEnter(MonitorEnter* x) {
 323   assert(x-&gt;is_pinned(),&quot;&quot;);
 324   LIRItem obj(x-&gt;obj(), this);
 325   obj.load_item();
 326 
 327   set_no_result(x);
 328 
 329   LIR_Opr lock    = FrameMap::G1_opr;
 330   LIR_Opr scratch = FrameMap::G3_opr;
 331   LIR_Opr hdr     = FrameMap::G4_opr;
 332 
 333   CodeEmitInfo* info_for_exception = NULL;
 334   if (x-&gt;needs_null_check()) {
 335     info_for_exception = state_for(x);
 336   }
 337 
 338   // this CodeEmitInfo must not have the xhandlers because here the
 339   // object is already locked (xhandlers expects object to be unlocked)
 340   CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
 341   monitor_enter(obj.result(), lock, hdr, scratch, x-&gt;monitor_no(), info_for_exception, info);
 342 }
 343 
 344 
 345 void LIRGenerator::do_MonitorExit(MonitorExit* x) {
 346   assert(x-&gt;is_pinned(),&quot;&quot;);
 347   LIRItem obj(x-&gt;obj(), this);
 348   obj.dont_load_item();
 349 
 350   set_no_result(x);
 351   LIR_Opr lock      = FrameMap::G1_opr;
 352   LIR_Opr hdr       = FrameMap::G3_opr;
 353   LIR_Opr obj_temp  = FrameMap::G4_opr;
 354   monitor_exit(obj_temp, lock, hdr, LIR_OprFact::illegalOpr, x-&gt;monitor_no());
 355 }
 356 
 357 
 358 // _ineg, _lneg, _fneg, _dneg
 359 void LIRGenerator::do_NegateOp(NegateOp* x) {
 360   LIRItem value(x-&gt;x(), this);
 361   value.load_item();
 362   LIR_Opr reg = rlock_result(x);
 363   __ negate(value.result(), reg);
 364 }
 365 
 366 
 367 
 368 // for  _fadd, _fmul, _fsub, _fdiv, _frem
 369 //      _dadd, _dmul, _dsub, _ddiv, _drem
 370 void LIRGenerator::do_ArithmeticOp_FPU(ArithmeticOp* x) {
 371   switch (x-&gt;op()) {
 372   case Bytecodes::_fadd:
 373   case Bytecodes::_fmul:
 374   case Bytecodes::_fsub:
 375   case Bytecodes::_fdiv:
 376   case Bytecodes::_dadd:
 377   case Bytecodes::_dmul:
 378   case Bytecodes::_dsub:
 379   case Bytecodes::_ddiv: {
 380     LIRItem left(x-&gt;x(), this);
 381     LIRItem right(x-&gt;y(), this);
 382     left.load_item();
 383     right.load_item();
 384     rlock_result(x);
 385     arithmetic_op_fpu(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), x-&gt;is_strictfp());
 386   }
 387   break;
 388 
 389   case Bytecodes::_frem:
 390   case Bytecodes::_drem: {
 391     address entry;
 392     switch (x-&gt;op()) {
 393     case Bytecodes::_frem:
 394       entry = CAST_FROM_FN_PTR(address, SharedRuntime::frem);
 395       break;
 396     case Bytecodes::_drem:
 397       entry = CAST_FROM_FN_PTR(address, SharedRuntime::drem);
 398       break;
 399     default:
 400       ShouldNotReachHere();
 401     }
 402     LIR_Opr result = call_runtime(x-&gt;x(), x-&gt;y(), entry, x-&gt;type(), NULL);
 403     set_result(x, result);
 404   }
 405   break;
 406 
 407   default: ShouldNotReachHere();
 408   }
 409 }
 410 
 411 
 412 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 413 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 414   switch (x-&gt;op()) {
 415   case Bytecodes::_lrem:
 416   case Bytecodes::_lmul:
 417   case Bytecodes::_ldiv: {
 418 
 419     if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 420       LIRItem right(x-&gt;y(), this);
 421       right.load_item();
 422 
 423       CodeEmitInfo* info = state_for(x);
 424       LIR_Opr item = right.result();
 425       assert(item-&gt;is_register(), &quot;must be&quot;);
 426       __ cmp(lir_cond_equal, item, LIR_OprFact::longConst(0));
 427       __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));
 428     }
 429 
 430     address entry;
 431     switch (x-&gt;op()) {
 432     case Bytecodes::_lrem:
 433       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
 434       break; // check if dividend is 0 is done elsewhere
 435     case Bytecodes::_ldiv:
 436       entry = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
 437       break; // check if dividend is 0 is done elsewhere
 438     case Bytecodes::_lmul:
 439       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lmul);
 440       break;
 441     default:
 442       ShouldNotReachHere();
 443     }
 444 
 445     // order of arguments to runtime call is reversed.
 446     LIR_Opr result = call_runtime(x-&gt;y(), x-&gt;x(), entry, x-&gt;type(), NULL);
 447     set_result(x, result);
 448     break;
 449   }
 450   case Bytecodes::_ladd:
 451   case Bytecodes::_lsub: {
 452     LIRItem left(x-&gt;x(), this);
 453     LIRItem right(x-&gt;y(), this);
 454     left.load_item();
 455     right.load_item();
 456     rlock_result(x);
 457 
 458     arithmetic_op_long(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), NULL);
 459     break;
 460   }
 461   default: ShouldNotReachHere();
 462   }
 463 }
 464 
 465 
 466 // Returns if item is an int constant that can be represented by a simm13
 467 static bool is_simm13(LIR_Opr item) {
 468   if (item-&gt;is_constant() &amp;&amp; item-&gt;type() == T_INT) {
 469     return Assembler::is_simm13(item-&gt;as_constant_ptr()-&gt;as_jint());
 470   } else {
 471     return false;
 472   }
 473 }
 474 
 475 
 476 // for: _iadd, _imul, _isub, _idiv, _irem
 477 void LIRGenerator::do_ArithmeticOp_Int(ArithmeticOp* x) {
 478   bool is_div_rem = x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem;
 479   LIRItem left(x-&gt;x(), this);
 480   LIRItem right(x-&gt;y(), this);
 481   // missing test if instr is commutative and if we should swap
 482   right.load_nonconstant();
 483   assert(right.is_constant() || right.is_register(), &quot;wrong state of right&quot;);
 484   left.load_item();
 485   rlock_result(x);
 486   if (is_div_rem) {
 487     CodeEmitInfo* info = state_for(x);
 488     LIR_Opr tmp = FrameMap::G1_opr;
 489     if (x-&gt;op() == Bytecodes::_irem) {
 490       __ irem(left.result(), right.result(), x-&gt;operand(), tmp, info);
 491     } else if (x-&gt;op() == Bytecodes::_idiv) {
 492       __ idiv(left.result(), right.result(), x-&gt;operand(), tmp, info);
 493     }
 494   } else {
 495     arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), FrameMap::G1_opr);
 496   }
 497 }
 498 
 499 
 500 void LIRGenerator::do_ArithmeticOp(ArithmeticOp* x) {
 501   ValueTag tag = x-&gt;type()-&gt;tag();
 502   assert(x-&gt;x()-&gt;type()-&gt;tag() == tag &amp;&amp; x-&gt;y()-&gt;type()-&gt;tag() == tag, &quot;wrong parameters&quot;);
 503   switch (tag) {
 504     case floatTag:
 505     case doubleTag:  do_ArithmeticOp_FPU(x);  return;
 506     case longTag:    do_ArithmeticOp_Long(x); return;
 507     case intTag:     do_ArithmeticOp_Int(x);  return;
 508   }
 509   ShouldNotReachHere();
 510 }
 511 
 512 
 513 // _ishl, _lshl, _ishr, _lshr, _iushr, _lushr
 514 void LIRGenerator::do_ShiftOp(ShiftOp* x) {
 515   LIRItem value(x-&gt;x(), this);
 516   LIRItem count(x-&gt;y(), this);
 517   // Long shift destroys count register
 518   if (value.type()-&gt;is_long()) {
 519     count.set_destroys_register();
 520   }
 521   value.load_item();
 522   // the old backend doesn&#39;t support this
 523   if (count.is_constant() &amp;&amp; count.type()-&gt;as_IntConstant() != NULL &amp;&amp; value.type()-&gt;is_int()) {
 524     jint c = count.get_jint_constant() &amp; 0x1f;
 525     assert(c &gt;= 0 &amp;&amp; c &lt; 32, &quot;should be small&quot;);
 526     count.dont_load_item();
 527   } else {
 528     count.load_item();
 529   }
 530   LIR_Opr reg = rlock_result(x);
 531   shift_op(x-&gt;op(), reg, value.result(), count.result(), LIR_OprFact::illegalOpr);
 532 }
 533 
 534 
 535 // _iand, _land, _ior, _lor, _ixor, _lxor
 536 void LIRGenerator::do_LogicOp(LogicOp* x) {
 537   LIRItem left(x-&gt;x(), this);
 538   LIRItem right(x-&gt;y(), this);
 539 
 540   left.load_item();
 541   right.load_nonconstant();
 542   LIR_Opr reg = rlock_result(x);
 543 
 544   logic_op(x-&gt;op(), reg, left.result(), right.result());
 545 }
 546 
 547 
 548 
 549 // _lcmp, _fcmpl, _fcmpg, _dcmpl, _dcmpg
 550 void LIRGenerator::do_CompareOp(CompareOp* x) {
 551   LIRItem left(x-&gt;x(), this);
 552   LIRItem right(x-&gt;y(), this);
 553   left.load_item();
 554   right.load_item();
 555   LIR_Opr reg = rlock_result(x);
 556   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 557     Bytecodes::Code code = x-&gt;op();
 558     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 559   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 560     __ lcmp2int(left.result(), right.result(), reg);
 561   } else {
 562     Unimplemented();
 563   }
 564 }
 565 
 566 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 567   LIR_Opr result = new_register(T_INT);
 568   LIR_Opr t1 = FrameMap::G1_opr;
 569   LIR_Opr t2 = FrameMap::G3_opr;
 570   cmp_value.load_item();
 571   new_value.load_item();
<a name="3" id="anc3"></a><span class="line-modified"> 572   if (is_reference_type(type)) {</span>
 573     __ cas_obj(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), t1, t2);
 574   } else if (type == T_INT) {
 575     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), t1, t2);
 576   } else if (type == T_LONG) {
 577     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), t1, t2);
 578   } else {
 579     Unimplemented();
 580   }
 581   __ cmove(lir_cond_equal, LIR_OprFact::intConst(1), LIR_OprFact::intConst(0),
 582            result, type);
 583   return result;
 584 }
 585 
 586 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
<a name="4" id="anc4"></a><span class="line-modified"> 587   bool is_obj = is_reference_type(type);</span>
 588   LIR_Opr result = new_register(type);
 589   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 590 
 591   value.load_item();
 592 
 593   if (is_obj) {
 594     tmp = FrameMap::G3_opr;
 595   }
 596 
 597   // Because we want a 2-arg form of xchg
 598   __ move(value.result(), result);
 599   __ xchg(addr, result, result, tmp);
 600   return result;
 601 }
 602 
 603 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 604   Unimplemented();
 605   return LIR_OprFact::illegalOpr;
 606 }
 607 
 608 void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {
 609   switch (x-&gt;id()) {
 610     case vmIntrinsics::_dabs:
 611     case vmIntrinsics::_dsqrt: {
 612       assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 613       LIRItem value(x-&gt;argument_at(0), this);
 614       value.load_item();
 615       LIR_Opr dst = rlock_result(x);
 616 
 617       switch (x-&gt;id()) {
 618       case vmIntrinsics::_dsqrt: {
 619         __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);
 620         break;
 621       }
 622       case vmIntrinsics::_dabs: {
 623         __ abs(value.result(), dst, LIR_OprFact::illegalOpr);
 624         break;
 625       }
 626       }
 627       break;
 628     }
 629     case vmIntrinsics::_dlog10: // fall through
 630     case vmIntrinsics::_dlog: // fall through
 631     case vmIntrinsics::_dsin: // fall through
 632     case vmIntrinsics::_dtan: // fall through
 633     case vmIntrinsics::_dcos: // fall through
 634     case vmIntrinsics::_dexp: {
 635       assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 636 
 637       address runtime_entry = NULL;
 638       switch (x-&gt;id()) {
 639       case vmIntrinsics::_dsin:
 640         runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dsin);
 641         break;
 642       case vmIntrinsics::_dcos:
 643         runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dcos);
 644         break;
 645       case vmIntrinsics::_dtan:
 646         runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dtan);
 647         break;
 648       case vmIntrinsics::_dlog:
 649         runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dlog);
 650         break;
 651       case vmIntrinsics::_dlog10:
 652         runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dlog10);
 653         break;
 654       case vmIntrinsics::_dexp:
 655         runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dexp);
 656         break;
 657       default:
 658         ShouldNotReachHere();
 659       }
 660 
 661       LIR_Opr result = call_runtime(x-&gt;argument_at(0), runtime_entry, x-&gt;type(), NULL);
 662       set_result(x, result);
 663       break;
 664     }
 665     case vmIntrinsics::_dpow: {
 666       assert(x-&gt;number_of_arguments() == 2, &quot;wrong type&quot;);
 667       address runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dpow);
 668       LIR_Opr result = call_runtime(x-&gt;argument_at(0), x-&gt;argument_at(1), runtime_entry, x-&gt;type(), NULL);
 669       set_result(x, result);
 670       break;
 671     }
 672   }
 673 }
 674 
 675 
 676 void LIRGenerator::do_ArrayCopy(Intrinsic* x) {
 677   assert(x-&gt;number_of_arguments() == 5, &quot;wrong type&quot;);
 678 
 679   // Make all state_for calls early since they can emit code
 680   CodeEmitInfo* info = state_for(x, x-&gt;state());
 681 
 682   // Note: spill caller save before setting the item
 683   LIRItem src     (x-&gt;argument_at(0), this);
 684   LIRItem src_pos (x-&gt;argument_at(1), this);
 685   LIRItem dst     (x-&gt;argument_at(2), this);
 686   LIRItem dst_pos (x-&gt;argument_at(3), this);
 687   LIRItem length  (x-&gt;argument_at(4), this);
 688   // load all values in callee_save_registers, as this makes the
 689   // parameter passing to the fast case simpler
 690   src.load_item_force     (rlock_callee_saved(T_OBJECT));
 691   src_pos.load_item_force (rlock_callee_saved(T_INT));
 692   dst.load_item_force     (rlock_callee_saved(T_OBJECT));
 693   dst_pos.load_item_force (rlock_callee_saved(T_INT));
 694   length.load_item_force  (rlock_callee_saved(T_INT));
 695 
 696   int flags;
 697   ciArrayKlass* expected_type;
 698   arraycopy_helper(x, &amp;flags, &amp;expected_type);
 699 
 700   __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(),
 701                length.result(), rlock_callee_saved(T_INT),
 702                expected_type, flags, info);
 703   set_no_result(x);
 704 }
 705 
 706 void LIRGenerator::do_update_CRC32(Intrinsic* x) {
 707   // Make all state_for calls early since they can emit code
 708   LIR_Opr result = rlock_result(x);
 709   int flags = 0;
 710   switch (x-&gt;id()) {
 711     case vmIntrinsics::_updateCRC32: {
 712       LIRItem crc(x-&gt;argument_at(0), this);
 713       LIRItem val(x-&gt;argument_at(1), this);
 714       // val is destroyed by update_crc32
 715       val.set_destroys_register();
 716       crc.load_item();
 717       val.load_item();
 718       __ update_crc32(crc.result(), val.result(), result);
 719       break;
 720     }
 721     case vmIntrinsics::_updateBytesCRC32:
 722     case vmIntrinsics::_updateByteBufferCRC32: {
 723 
 724       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32);
 725 
 726       LIRItem crc(x-&gt;argument_at(0), this);
 727       LIRItem buf(x-&gt;argument_at(1), this);
 728       LIRItem off(x-&gt;argument_at(2), this);
 729       LIRItem len(x-&gt;argument_at(3), this);
 730 
 731       buf.load_item();
 732       off.load_nonconstant();
 733 
 734       LIR_Opr index = off.result();
 735       int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
 736       if(off.result()-&gt;is_constant()) {
 737         index = LIR_OprFact::illegalOpr;
 738         offset += off.result()-&gt;as_jint();
 739       }
 740 
 741       LIR_Opr base_op = buf.result();
 742 
 743       if (index-&gt;is_valid()) {
 744         LIR_Opr tmp = new_register(T_LONG);
 745         __ convert(Bytecodes::_i2l, index, tmp);
 746         index = tmp;
 747         if (index-&gt;is_constant()) {
 748           offset += index-&gt;as_constant_ptr()-&gt;as_jint();
 749           index = LIR_OprFact::illegalOpr;
 750         } else if (index-&gt;is_register()) {
 751           LIR_Opr tmp2 = new_register(T_LONG);
 752           LIR_Opr tmp3 = new_register(T_LONG);
 753           __ move(base_op, tmp2);
 754           __ move(index, tmp3);
 755           __ add(tmp2, tmp3, tmp2);
 756           base_op = tmp2;
 757         } else {
 758           ShouldNotReachHere();
 759         }
 760       }
 761 
 762       LIR_Address* a = new LIR_Address(base_op, offset, T_BYTE);
 763 
 764       BasicTypeList signature(3);
 765       signature.append(T_INT);
 766       signature.append(T_ADDRESS);
 767       signature.append(T_INT);
 768       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 769       const LIR_Opr result_reg = result_register_for(x-&gt;type());
 770 
 771       LIR_Opr addr = new_pointer_register();
 772       __ leal(LIR_OprFact::address(a), addr);
 773 
 774       crc.load_item_force(cc-&gt;at(0));
 775       __ move(addr, cc-&gt;at(1));
 776       len.load_item_force(cc-&gt;at(2));
 777 
 778       __ call_runtime_leaf(StubRoutines::updateBytesCRC32(), getThreadTemp(), result_reg, cc-&gt;args());
 779       __ move(result_reg, result);
 780 
 781       break;
 782     }
 783     default: {
 784       ShouldNotReachHere();
 785     }
 786   }
 787 }
 788 
 789 void LIRGenerator::do_update_CRC32C(Intrinsic* x) {
 790   // Make all state_for calls early since they can emit code
 791   LIR_Opr result = rlock_result(x);
 792   int flags = 0;
 793   switch (x-&gt;id()) {
 794     case vmIntrinsics::_updateBytesCRC32C:
 795     case vmIntrinsics::_updateDirectByteBufferCRC32C: {
 796 
 797       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32C);
 798       int array_offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
 799 
 800       LIRItem crc(x-&gt;argument_at(0), this);
 801       LIRItem buf(x-&gt;argument_at(1), this);
 802       LIRItem off(x-&gt;argument_at(2), this);
 803       LIRItem end(x-&gt;argument_at(3), this);
 804 
 805       buf.load_item();
 806       off.load_nonconstant();
 807       end.load_nonconstant();
 808 
 809       // len = end - off
 810       LIR_Opr len  = end.result();
 811       LIR_Opr tmpA = new_register(T_INT);
 812       LIR_Opr tmpB = new_register(T_INT);
 813       __ move(end.result(), tmpA);
 814       __ move(off.result(), tmpB);
 815       __ sub(tmpA, tmpB, tmpA);
 816       len = tmpA;
 817 
 818       LIR_Opr index = off.result();
 819 
 820       if(off.result()-&gt;is_constant()) {
 821         index = LIR_OprFact::illegalOpr;
 822         array_offset += off.result()-&gt;as_jint();
 823       }
 824 
 825       LIR_Opr base_op = buf.result();
 826 
 827       if (index-&gt;is_valid()) {
 828         LIR_Opr tmp = new_register(T_LONG);
 829         __ convert(Bytecodes::_i2l, index, tmp);
 830         index = tmp;
 831         if (index-&gt;is_constant()) {
 832           array_offset += index-&gt;as_constant_ptr()-&gt;as_jint();
 833           index = LIR_OprFact::illegalOpr;
 834         } else if (index-&gt;is_register()) {
 835           LIR_Opr tmp2 = new_register(T_LONG);
 836           LIR_Opr tmp3 = new_register(T_LONG);
 837           __ move(base_op, tmp2);
 838           __ move(index, tmp3);
 839           __ add(tmp2, tmp3, tmp2);
 840           base_op = tmp2;
 841         } else {
 842           ShouldNotReachHere();
 843         }
 844       }
 845 
 846       LIR_Address* a = new LIR_Address(base_op, array_offset, T_BYTE);
 847 
 848       BasicTypeList signature(3);
 849       signature.append(T_INT);
 850       signature.append(T_ADDRESS);
 851       signature.append(T_INT);
 852       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 853       const LIR_Opr result_reg = result_register_for(x-&gt;type());
 854 
 855       LIR_Opr addr = new_pointer_register();
 856       __ leal(LIR_OprFact::address(a), addr);
 857 
 858       crc.load_item_force(cc-&gt;at(0));
 859       __ move(addr, cc-&gt;at(1));
 860       __ move(len, cc-&gt;at(2));
 861 
 862       __ call_runtime_leaf(StubRoutines::updateBytesCRC32C(), getThreadTemp(), result_reg, cc-&gt;args());
 863       __ move(result_reg, result);
 864 
 865       break;
 866     }
 867     default: {
 868       ShouldNotReachHere();
 869     }
 870   }
 871 }
 872 
 873 void LIRGenerator::do_FmaIntrinsic(Intrinsic* x) {
 874   assert(x-&gt;number_of_arguments() == 3, &quot;wrong type&quot;);
 875   assert(UseFMA, &quot;Needs FMA instructions support.&quot;);
 876 
 877   LIRItem a(x-&gt;argument_at(0), this);
 878   LIRItem b(x-&gt;argument_at(1), this);
 879   LIRItem c(x-&gt;argument_at(2), this);
 880 
 881   a.load_item();
 882   b.load_item();
 883   c.load_item();
 884 
 885   LIR_Opr ina = a.result();
 886   LIR_Opr inb = b.result();
 887   LIR_Opr inc = c.result();
 888   LIR_Opr res = rlock_result(x);
 889 
 890   switch (x-&gt;id()) {
 891     case vmIntrinsics::_fmaF: __ fmaf(ina, inb, inc, res); break;
 892     case vmIntrinsics::_fmaD: __ fmad(ina, inb, inc, res); break;
 893     default:
 894       ShouldNotReachHere();
 895       break;
 896   }
 897 }
 898 
 899 void LIRGenerator::do_vectorizedMismatch(Intrinsic* x) {
 900   fatal(&quot;vectorizedMismatch intrinsic is not implemented on this platform&quot;);
 901 }
 902 
 903 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
 904 // _i2b, _i2c, _i2s
 905 void LIRGenerator::do_Convert(Convert* x) {
 906 
 907   switch (x-&gt;op()) {
 908     case Bytecodes::_f2l:
 909     case Bytecodes::_d2l:
 910     case Bytecodes::_d2i:
 911     case Bytecodes::_l2f:
 912     case Bytecodes::_l2d: {
 913 
 914       address entry;
 915       switch (x-&gt;op()) {
 916       case Bytecodes::_l2f:
 917         entry = CAST_FROM_FN_PTR(address, SharedRuntime::l2f);
 918         break;
 919       case Bytecodes::_l2d:
 920         entry = CAST_FROM_FN_PTR(address, SharedRuntime::l2d);
 921         break;
 922       case Bytecodes::_f2l:
 923         entry = CAST_FROM_FN_PTR(address, SharedRuntime::f2l);
 924         break;
 925       case Bytecodes::_d2l:
 926         entry = CAST_FROM_FN_PTR(address, SharedRuntime::d2l);
 927         break;
 928       case Bytecodes::_d2i:
 929         entry = CAST_FROM_FN_PTR(address, SharedRuntime::d2i);
 930         break;
 931       default:
 932         ShouldNotReachHere();
 933       }
 934       LIR_Opr result = call_runtime(x-&gt;value(), entry, x-&gt;type(), NULL);
 935       set_result(x, result);
 936       break;
 937     }
 938 
 939     case Bytecodes::_i2f:
 940     case Bytecodes::_i2d: {
 941       LIRItem value(x-&gt;value(), this);
 942 
 943       LIR_Opr reg = rlock_result(x);
 944       // To convert an int to double, we need to load the 32-bit int
 945       // from memory into a single precision floating point register
 946       // (even numbered). Then the sparc fitod instruction takes care
 947       // of the conversion. This is a bit ugly, but is the best way to
 948       // get the int value in a single precision floating point register
 949       value.load_item();
 950       LIR_Opr tmp = force_to_spill(value.result(), T_FLOAT);
 951       __ convert(x-&gt;op(), tmp, reg);
 952       break;
 953     }
 954     break;
 955 
 956     case Bytecodes::_i2l:
 957     case Bytecodes::_i2b:
 958     case Bytecodes::_i2c:
 959     case Bytecodes::_i2s:
 960     case Bytecodes::_l2i:
 961     case Bytecodes::_f2d:
 962     case Bytecodes::_d2f: { // inline code
 963       LIRItem value(x-&gt;value(), this);
 964 
 965       value.load_item();
 966       LIR_Opr reg = rlock_result(x);
 967       __ convert(x-&gt;op(), value.result(), reg, false);
 968     }
 969     break;
 970 
 971     case Bytecodes::_f2i: {
 972       LIRItem value (x-&gt;value(), this);
 973       value.set_destroys_register();
 974       value.load_item();
 975       LIR_Opr reg = rlock_result(x);
 976       set_vreg_flag(reg, must_start_in_memory);
 977       __ convert(x-&gt;op(), value.result(), reg, false);
 978     }
 979     break;
 980 
 981     default: ShouldNotReachHere();
 982   }
 983 }
 984 
 985 
 986 void LIRGenerator::do_NewInstance(NewInstance* x) {
 987   print_if_not_loaded(x);
 988 
 989   // This instruction can be deoptimized in the slow path : use
 990   // O0 as result register.
 991   const LIR_Opr reg = result_register_for(x-&gt;type());
 992 
 993   CodeEmitInfo* info = state_for(x, x-&gt;state());
 994   LIR_Opr tmp1 = FrameMap::G1_oop_opr;
 995   LIR_Opr tmp2 = FrameMap::G3_oop_opr;
 996   LIR_Opr tmp3 = FrameMap::G4_oop_opr;
 997   LIR_Opr tmp4 = FrameMap::O1_oop_opr;
 998   LIR_Opr klass_reg = FrameMap::G5_metadata_opr;
 999   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(), tmp1, tmp2, tmp3, tmp4, klass_reg, info);
1000   LIR_Opr result = rlock_result(x);
1001   __ move(reg, result);
1002 }
1003 
1004 
1005 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
1006   // Evaluate state_for early since it may emit code
1007   CodeEmitInfo* info = state_for(x, x-&gt;state());
1008 
1009   LIRItem length(x-&gt;length(), this);
1010   length.load_item();
1011 
1012   LIR_Opr reg = result_register_for(x-&gt;type());
1013   LIR_Opr tmp1 = FrameMap::G1_oop_opr;
1014   LIR_Opr tmp2 = FrameMap::G3_oop_opr;
1015   LIR_Opr tmp3 = FrameMap::G4_oop_opr;
1016   LIR_Opr tmp4 = FrameMap::O1_oop_opr;
1017   LIR_Opr klass_reg = FrameMap::G5_metadata_opr;
1018   LIR_Opr len = length.result();
1019   BasicType elem_type = x-&gt;elt_type();
1020 
1021   __ metadata2reg(ciTypeArrayKlass::make(elem_type)-&gt;constant_encoding(), klass_reg);
1022 
1023   CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len, reg, info);
1024   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);
1025 
1026   LIR_Opr result = rlock_result(x);
1027   __ move(reg, result);
1028 }
1029 
1030 
1031 void LIRGenerator::do_NewObjectArray(NewObjectArray* x) {
1032   // Evaluate state_for early since it may emit code.
1033   CodeEmitInfo* info = state_for(x, x-&gt;state());
1034   // in case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
1035   // and therefore provide the state before the parameters have been consumed
1036   CodeEmitInfo* patching_info = NULL;
1037   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1038     patching_info = state_for(x, x-&gt;state_before());
1039   }
1040 
1041   LIRItem length(x-&gt;length(), this);
1042   length.load_item();
1043 
1044   const LIR_Opr reg = result_register_for(x-&gt;type());
1045   LIR_Opr tmp1 = FrameMap::G1_oop_opr;
1046   LIR_Opr tmp2 = FrameMap::G3_oop_opr;
1047   LIR_Opr tmp3 = FrameMap::G4_oop_opr;
1048   LIR_Opr tmp4 = FrameMap::O1_oop_opr;
1049   LIR_Opr klass_reg = FrameMap::G5_metadata_opr;
1050   LIR_Opr len = length.result();
1051 
1052   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info);
1053   ciMetadata* obj = ciObjArrayKlass::make(x-&gt;klass());
1054   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
1055     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
1056   }
1057   klass2reg_with_patching(klass_reg, obj, patching_info);
1058   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);
1059 
1060   LIR_Opr result = rlock_result(x);
1061   __ move(reg, result);
1062 }
1063 
1064 
1065 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
1066   Values* dims = x-&gt;dims();
1067   int i = dims-&gt;length();
1068   LIRItemList* items = new LIRItemList(i, i, NULL);
1069   while (i-- &gt; 0) {
1070     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
1071     items-&gt;at_put(i, size);
1072   }
1073 
1074   // Evaluate state_for early since it may emit code.
1075   CodeEmitInfo* patching_info = NULL;
1076   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1077     patching_info = state_for(x, x-&gt;state_before());
1078 
1079     // Cannot re-use same xhandlers for multiple CodeEmitInfos, so
1080     // clone all handlers (NOTE: Usually this is handled transparently
1081     // by the CodeEmitInfo cloning logic in CodeStub constructors but
1082     // is done explicitly here because a stub isn&#39;t being used).
1083     x-&gt;set_exception_handlers(new XHandlers(x-&gt;exception_handlers()));
1084   }
1085   CodeEmitInfo* info = state_for(x, x-&gt;state());
1086 
1087   i = dims-&gt;length();
1088   while (i-- &gt; 0) {
1089     LIRItem* size = items-&gt;at(i);
1090     size-&gt;load_item();
1091     store_stack_parameter (size-&gt;result(),
1092                            in_ByteSize(STACK_BIAS +
1093                                        frame::memory_parameter_word_sp_offset * wordSize +
1094                                        i * sizeof(jint)));
1095   }
1096 
1097   // This instruction can be deoptimized in the slow path : use
1098   // O0 as result register.
1099   const LIR_Opr klass_reg = FrameMap::O0_metadata_opr;
1100   klass2reg_with_patching(klass_reg, x-&gt;klass(), patching_info);
1101   LIR_Opr rank = FrameMap::O1_opr;
1102   __ move(LIR_OprFact::intConst(x-&gt;rank()), rank);
1103   LIR_Opr varargs = FrameMap::as_pointer_opr(O2);
1104   int offset_from_sp = (frame::memory_parameter_word_sp_offset * wordSize) + STACK_BIAS;
1105   __ add(FrameMap::SP_opr,
1106          LIR_OprFact::intptrConst(offset_from_sp),
1107          varargs);
1108   LIR_OprList* args = new LIR_OprList(3);
1109   args-&gt;append(klass_reg);
1110   args-&gt;append(rank);
1111   args-&gt;append(varargs);
1112   const LIR_Opr reg = result_register_for(x-&gt;type());
1113   __ call_runtime(Runtime1::entry_for(Runtime1::new_multi_array_id),
1114                   LIR_OprFact::illegalOpr,
1115                   reg, args, info);
1116 
1117   LIR_Opr result = rlock_result(x);
1118   __ move(reg, result);
1119 }
1120 
1121 
1122 void LIRGenerator::do_BlockBegin(BlockBegin* x) {
1123 }
1124 
1125 
1126 void LIRGenerator::do_CheckCast(CheckCast* x) {
1127   LIRItem obj(x-&gt;obj(), this);
1128   CodeEmitInfo* patching_info = NULL;
1129   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
1130     // must do this before locking the destination register as an oop register,
1131     // and before the obj is loaded (so x-&gt;obj()-&gt;item() is valid for creating a debug info location)
1132     patching_info = state_for(x, x-&gt;state_before());
1133   }
1134   obj.load_item();
1135   LIR_Opr out_reg = rlock_result(x);
1136   CodeStub* stub;
1137   CodeEmitInfo* info_for_exception =
1138       (x-&gt;needs_exception_state() ? state_for(x) :
1139                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
1140 
1141   if (x-&gt;is_incompatible_class_change_check()) {
1142     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1143     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
1144   } else if (x-&gt;is_invokespecial_receiver_check()) {
1145     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1146     stub = new DeoptimizeStub(info_for_exception,
1147                               Deoptimization::Reason_class_check,
1148                               Deoptimization::Action_none);
1149   } else {
1150     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
1151   }
1152   LIR_Opr tmp1 = FrameMap::G1_oop_opr;
1153   LIR_Opr tmp2 = FrameMap::G3_oop_opr;
1154   LIR_Opr tmp3 = FrameMap::G4_oop_opr;
1155   __ checkcast(out_reg, obj.result(), x-&gt;klass(), tmp1, tmp2, tmp3,
1156                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
1157                x-&gt;profiled_method(), x-&gt;profiled_bci());
1158 }
1159 
1160 
1161 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
1162   LIRItem obj(x-&gt;obj(), this);
1163   CodeEmitInfo* patching_info = NULL;
1164   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1165     patching_info = state_for(x, x-&gt;state_before());
1166   }
1167   // ensure the result register is not the input register because the result is initialized before the patching safepoint
1168   obj.load_item();
1169   LIR_Opr out_reg = rlock_result(x);
1170   LIR_Opr tmp1 = FrameMap::G1_oop_opr;
1171   LIR_Opr tmp2 = FrameMap::G3_oop_opr;
1172   LIR_Opr tmp3 = FrameMap::G4_oop_opr;
1173   __ instanceof(out_reg, obj.result(), x-&gt;klass(), tmp1, tmp2, tmp3,
1174                 x-&gt;direct_compare(), patching_info,
1175                 x-&gt;profiled_method(), x-&gt;profiled_bci());
1176 }
1177 
1178 
1179 void LIRGenerator::do_If(If* x) {
1180   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
1181   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
1182   LIRItem xitem(x-&gt;x(), this);
1183   LIRItem yitem(x-&gt;y(), this);
1184   LIRItem* xin = &amp;xitem;
1185   LIRItem* yin = &amp;yitem;
1186   If::Condition cond = x-&gt;cond();
1187 
1188   if (tag == longTag) {
1189     // for longs, only conditions &quot;eql&quot;, &quot;neq&quot;, &quot;lss&quot;, &quot;geq&quot; are valid;
1190     // mirror for other conditions
1191     if (cond == If::gtr || cond == If::leq) {
1192       // swap inputs
1193       cond = Instruction::mirror(cond);
1194       xin = &amp;yitem;
1195       yin = &amp;xitem;
1196     }
1197     xin-&gt;set_destroys_register();
1198   }
1199 
1200   LIR_Opr left = LIR_OprFact::illegalOpr;
1201   LIR_Opr right = LIR_OprFact::illegalOpr;
1202 
1203   xin-&gt;load_item();
1204   left = xin-&gt;result();
1205 
1206   if (is_simm13(yin-&gt;result())) {
1207     // inline int constants which are small enough to be immediate operands
1208     right = LIR_OprFact::value_type(yin-&gt;value()-&gt;type());
1209   } else if (tag == longTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; yin-&gt;get_jlong_constant() == 0 &amp;&amp;
1210              (cond == If::eql || cond == If::neq)) {
1211     // inline long zero
1212     right = LIR_OprFact::value_type(yin-&gt;value()-&gt;type());
1213   } else if (tag == objectTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; (yin-&gt;get_jobject_constant()-&gt;is_null_object())) {
1214     right = LIR_OprFact::value_type(yin-&gt;value()-&gt;type());
1215   } else {
1216     yin-&gt;load_item();
1217     right = yin-&gt;result();
1218   }
1219   set_no_result(x);
1220 
1221   // add safepoint before generating condition code so it can be recomputed
1222   if (x-&gt;is_safepoint()) {
1223     // increment backedge counter if needed
1224     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1225         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1226     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
1227   }
1228 
1229   __ cmp(lir_cond(cond), left, right);
1230   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1231   profile_branch(x, cond);
1232   move_to_phi(x-&gt;state());
1233   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
1234     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());
1235   } else {
1236     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());
1237   }
1238   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1239   __ jump(x-&gt;default_sux());
1240 }
1241 
1242 
1243 LIR_Opr LIRGenerator::getThreadPointer() {
1244   return FrameMap::as_pointer_opr(G2);
1245 }
1246 
1247 
1248 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1249   __ move(LIR_OprFact::intConst(block-&gt;block_id()), FrameMap::O0_opr);
1250   LIR_OprList* args = new LIR_OprList(1);
1251   args-&gt;append(FrameMap::O0_opr);
1252   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1253   __ call_runtime_leaf(func, rlock_callee_saved(T_INT), LIR_OprFact::illegalOpr, args);
1254 }
1255 
1256 
1257 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1258                                         CodeEmitInfo* info) {
1259   __ store(value, address, info);
1260 }
1261 
1262 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1263                                        CodeEmitInfo* info) {
1264   __ load(address, result, info);
1265 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
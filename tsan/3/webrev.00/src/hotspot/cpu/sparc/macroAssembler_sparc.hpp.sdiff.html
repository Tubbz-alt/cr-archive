<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/macroAssembler_sparc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_sparc.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/macroAssembler_sparc.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 461 
 462   // locating memory-based arguments
 463   Address as_address() const {
 464     assert(!is_register(), &quot;must be a memory argument&quot;);
 465     return address_in_frame();
 466   }
 467 
 468   // When applied to a register-based argument, give the corresponding address
 469   // into the 6-word area &quot;into which callee may store register arguments&quot;
 470   // (This is a different place than the corresponding register-save area location.)
 471   Address address_in_frame() const;
 472 
 473   // debugging
 474   const char* name() const;
 475 
 476   friend class Assembler;
 477 };
 478 
 479 
 480 class RegistersForDebugging : public StackObj {



 481  public:
 482   intptr_t i[8], l[8], o[8], g[8];
 483   float    f[32];
 484   double   d[32];
 485 
 486   void print(outputStream* s);
 487 
<span class="line-modified"> 488   static int i_offset(int j) { return offset_of(RegistersForDebugging, i[j]); }</span>
<span class="line-modified"> 489   static int l_offset(int j) { return offset_of(RegistersForDebugging, l[j]); }</span>
<span class="line-modified"> 490   static int o_offset(int j) { return offset_of(RegistersForDebugging, o[j]); }</span>
<span class="line-modified"> 491   static int g_offset(int j) { return offset_of(RegistersForDebugging, g[j]); }</span>
<span class="line-modified"> 492   static int f_offset(int j) { return offset_of(RegistersForDebugging, f[j]); }</span>
<span class="line-modified"> 493   static int d_offset(int j) { return offset_of(RegistersForDebugging, d[j / 2]); }</span>
 494 
 495   // gen asm code to save regs
 496   static void save_registers(MacroAssembler* a);
 497 
 498   // restore global registers in case C code disturbed them
 499   static void restore_registers(MacroAssembler* a, Register r);
 500 };
 501 
 502 
 503 // MacroAssembler extends Assembler by a few frequently used macros.
 504 //
 505 // Most of the standard SPARC synthetic ops are defined here.
 506 // Instructions for which a &#39;better&#39; code sequence exists depending
 507 // on arguments should also go in here.
 508 
 509 #define JMP2(r1, r2) jmp(r1, r2, __FILE__, __LINE__)
 510 #define JMP(r1, off) jmp(r1, off, __FILE__, __LINE__)
 511 #define JUMP(a, temp, off)     jump(a, temp, off, __FILE__, __LINE__)
 512 #define JUMPL(a, temp, d, off) jumpl(a, temp, d, off, __FILE__, __LINE__)
 513 
</pre>
<hr />
<pre>
 632   inline void fbp( Condition c, bool a, CC cc, Predict p, Label&amp; L );
 633 
 634   // Sparc shorthands(pp 85, V8 manual, pp 289 V9 manual)
 635   inline void cmp( Register s1, Register s2 );
 636   inline void cmp( Register s1, int simm13a );
 637 
 638   inline void jmp( Register s1, Register s2 );
 639   inline void jmp( Register s1, int simm13a, RelocationHolder const&amp; rspec = RelocationHolder() );
 640 
 641   // Check if the call target is out of wdisp30 range (relative to the code cache)
 642   static inline bool is_far_target(address d);
 643   inline void call( address d, relocInfo::relocType rt = relocInfo::runtime_call_type );
 644   inline void call( address d, RelocationHolder const&amp; rspec);
 645 
 646   inline void call( Label&amp; L, relocInfo::relocType rt = relocInfo::runtime_call_type );
 647   inline void call( Label&amp; L, RelocationHolder const&amp; rspec);
 648 
 649   inline void callr( Register s1, Register s2 );
 650   inline void callr( Register s1, int simm13a, RelocationHolder const&amp; rspec = RelocationHolder() );
 651 
<span class="line-removed"> 652   // Emits nothing on V8</span>
<span class="line-removed"> 653   inline void iprefetch( address d, relocInfo::relocType rt = relocInfo::none );</span>
<span class="line-removed"> 654   inline void iprefetch( Label&amp; L);</span>
<span class="line-removed"> 655 </span>
 656   inline void tst( Register s );
 657 
 658   inline void ret(  bool trace = false );
 659   inline void retl( bool trace = false );
 660 
 661   // Required platform-specific helpers for Label::patch_instructions.
 662   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 663   void pd_patch_instruction(address branch, address target, const char* file, int line);
 664 
 665   // sethi Macro handles optimizations and relocations
 666 private:
 667   void internal_sethi(const AddressLiteral&amp; addrlit, Register d, bool ForceRelocatable);
 668 public:
 669   void sethi(const AddressLiteral&amp; addrlit, Register d);
 670   void patchable_sethi(const AddressLiteral&amp; addrlit, Register d);
 671 
 672   // compute the number of instructions for a sethi/set
 673   static int  insts_for_sethi( address a, bool worst_case = false );
 674   static int  worst_case_insts_for_set();
 675 
</pre>
<hr />
<pre>
1039   void call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
1040 
1041   void call_VM_leaf(Register thread_cache, address entry_point, int number_of_arguments = 0);
1042   void call_VM_leaf(Register thread_cache, address entry_point, Register arg_1);
1043   void call_VM_leaf(Register thread_cache, address entry_point, Register arg_1, Register arg_2);
1044   void call_VM_leaf(Register thread_cache, address entry_point, Register arg_1, Register arg_2, Register arg_3);
1045 
1046   void get_vm_result  (Register oop_result);
1047   void get_vm_result_2(Register metadata_result);
1048 
1049   // vm result is currently getting hijacked to for oop preservation
1050   void set_vm_result(Register oop_result);
1051 
1052   // Emit the CompiledIC call idiom
1053   void ic_call(address entry, bool emit_delay = true, jint method_index = 0);
1054 
1055   // if call_VM_base was called with check_exceptions=false, then call
1056   // check_and_forward_exception to handle exceptions when it is safe
1057   void check_and_forward_exception(Register scratch_reg);
1058 
<span class="line-removed">1059   // pushes double TOS element of FPU stack on CPU stack; pops from FPU stack</span>
<span class="line-removed">1060   void push_fTOS();</span>
<span class="line-removed">1061 </span>
<span class="line-removed">1062   // pops double TOS element from CPU stack and pushes on FPU stack</span>
<span class="line-removed">1063   void pop_fTOS();</span>
<span class="line-removed">1064 </span>
<span class="line-removed">1065   void empty_FPU_stack();</span>
<span class="line-removed">1066 </span>
<span class="line-removed">1067   void push_IU_state();</span>
<span class="line-removed">1068   void pop_IU_state();</span>
<span class="line-removed">1069 </span>
<span class="line-removed">1070   void push_FPU_state();</span>
<span class="line-removed">1071   void pop_FPU_state();</span>
<span class="line-removed">1072 </span>
<span class="line-removed">1073   void push_CPU_state();</span>
<span class="line-removed">1074   void pop_CPU_state();</span>
<span class="line-removed">1075 </span>
1076   // Returns the byte size of the instructions generated by decode_klass_not_null().
1077   static int instr_size_for_decode_klass_not_null();
1078 
1079   // if heap base register is used - reinit it with the correct value
1080   void reinit_heapbase();
1081 
1082   // Debugging
1083   void _verify_oop(Register reg, const char * msg, const char * file, int line);
1084   void _verify_oop_addr(Address addr, const char * msg, const char * file, int line);
1085 
1086   // TODO: verify_method and klass metadata (compare against vptr?)
1087   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
1088   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
1089 
1090 #define verify_oop(reg) _verify_oop(reg, &quot;broken oop &quot; #reg, __FILE__, __LINE__)
1091 #define verify_oop_addr(addr) _verify_oop_addr(addr, &quot;broken oop addr &quot;, __FILE__, __LINE__)
1092 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
1093 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
1094 
<span class="line-removed">1095         // only if +VerifyOops</span>
<span class="line-removed">1096   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);</span>
<span class="line-removed">1097         // only if +VerifyFPU</span>
1098   void stop(const char* msg);                          // prints msg, dumps registers and stops execution
1099   void warn(const char* msg);                          // prints msg, but don&#39;t stop
1100   void untested(const char* what = &quot;&quot;);
1101   void unimplemented(const char* what = &quot;&quot;);
1102   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
<span class="line-removed">1103   void print_CPU_state();</span>
1104 
1105   // oops in code
1106   AddressLiteral allocate_oop_address(jobject obj);                          // allocate_index
1107   AddressLiteral constant_oop_address(jobject obj);                          // find_index
1108   inline void    set_oop             (jobject obj, Register d);              // uses allocate_oop_address
1109   inline void    set_oop_constant    (jobject obj, Register d);              // uses constant_oop_address
1110   inline void    set_oop             (const AddressLiteral&amp; obj_addr, Register d); // same as load_address
1111 
1112   // metadata in code that we have to keep track of
1113   AddressLiteral allocate_metadata_address(Metadata* obj); // allocate_index
1114   AddressLiteral constant_metadata_address(Metadata* obj); // find_index
1115   inline void    set_metadata             (Metadata* obj, Register d);              // uses allocate_metadata_address
1116   inline void    set_metadata_constant    (Metadata* obj, Register d);              // uses constant_metadata_address
1117   inline void    set_metadata             (const AddressLiteral&amp; obj_addr, Register d); // same as load_address
1118 
1119   void set_narrow_oop( jobject obj, Register d );
1120   void set_narrow_klass( Klass* k, Register d );
1121 
1122   // nop padding
1123   void align(int modulus);
</pre>
</td>
<td>
<hr />
<pre>
 461 
 462   // locating memory-based arguments
 463   Address as_address() const {
 464     assert(!is_register(), &quot;must be a memory argument&quot;);
 465     return address_in_frame();
 466   }
 467 
 468   // When applied to a register-based argument, give the corresponding address
 469   // into the 6-word area &quot;into which callee may store register arguments&quot;
 470   // (This is a different place than the corresponding register-save area location.)
 471   Address address_in_frame() const;
 472 
 473   // debugging
 474   const char* name() const;
 475 
 476   friend class Assembler;
 477 };
 478 
 479 
 480 class RegistersForDebugging : public StackObj {
<span class="line-added"> 481  private:</span>
<span class="line-added"> 482   static const RegistersForDebugging&amp; _dummy; // not ODR-used so not defined</span>
<span class="line-added"> 483 </span>
 484  public:
 485   intptr_t i[8], l[8], o[8], g[8];
 486   float    f[32];
 487   double   d[32];
 488 
 489   void print(outputStream* s);
 490 
<span class="line-modified"> 491   static int i_offset(int j) { return offset_of(RegistersForDebugging, i) + j * sizeof(_dummy.i[0]); }</span>
<span class="line-modified"> 492   static int l_offset(int j) { return offset_of(RegistersForDebugging, l) + j * sizeof(_dummy.l[0]); }</span>
<span class="line-modified"> 493   static int o_offset(int j) { return offset_of(RegistersForDebugging, o) + j * sizeof(_dummy.o[0]); }</span>
<span class="line-modified"> 494   static int g_offset(int j) { return offset_of(RegistersForDebugging, g) + j * sizeof(_dummy.g[0]); }</span>
<span class="line-modified"> 495   static int f_offset(int j) { return offset_of(RegistersForDebugging, f) + j * sizeof(_dummy.f[0]); }</span>
<span class="line-modified"> 496   static int d_offset(int j) { return offset_of(RegistersForDebugging, d) + (j / 2) * sizeof(_dummy.d[0]); }</span>
 497 
 498   // gen asm code to save regs
 499   static void save_registers(MacroAssembler* a);
 500 
 501   // restore global registers in case C code disturbed them
 502   static void restore_registers(MacroAssembler* a, Register r);
 503 };
 504 
 505 
 506 // MacroAssembler extends Assembler by a few frequently used macros.
 507 //
 508 // Most of the standard SPARC synthetic ops are defined here.
 509 // Instructions for which a &#39;better&#39; code sequence exists depending
 510 // on arguments should also go in here.
 511 
 512 #define JMP2(r1, r2) jmp(r1, r2, __FILE__, __LINE__)
 513 #define JMP(r1, off) jmp(r1, off, __FILE__, __LINE__)
 514 #define JUMP(a, temp, off)     jump(a, temp, off, __FILE__, __LINE__)
 515 #define JUMPL(a, temp, d, off) jumpl(a, temp, d, off, __FILE__, __LINE__)
 516 
</pre>
<hr />
<pre>
 635   inline void fbp( Condition c, bool a, CC cc, Predict p, Label&amp; L );
 636 
 637   // Sparc shorthands(pp 85, V8 manual, pp 289 V9 manual)
 638   inline void cmp( Register s1, Register s2 );
 639   inline void cmp( Register s1, int simm13a );
 640 
 641   inline void jmp( Register s1, Register s2 );
 642   inline void jmp( Register s1, int simm13a, RelocationHolder const&amp; rspec = RelocationHolder() );
 643 
 644   // Check if the call target is out of wdisp30 range (relative to the code cache)
 645   static inline bool is_far_target(address d);
 646   inline void call( address d, relocInfo::relocType rt = relocInfo::runtime_call_type );
 647   inline void call( address d, RelocationHolder const&amp; rspec);
 648 
 649   inline void call( Label&amp; L, relocInfo::relocType rt = relocInfo::runtime_call_type );
 650   inline void call( Label&amp; L, RelocationHolder const&amp; rspec);
 651 
 652   inline void callr( Register s1, Register s2 );
 653   inline void callr( Register s1, int simm13a, RelocationHolder const&amp; rspec = RelocationHolder() );
 654 




 655   inline void tst( Register s );
 656 
 657   inline void ret(  bool trace = false );
 658   inline void retl( bool trace = false );
 659 
 660   // Required platform-specific helpers for Label::patch_instructions.
 661   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 662   void pd_patch_instruction(address branch, address target, const char* file, int line);
 663 
 664   // sethi Macro handles optimizations and relocations
 665 private:
 666   void internal_sethi(const AddressLiteral&amp; addrlit, Register d, bool ForceRelocatable);
 667 public:
 668   void sethi(const AddressLiteral&amp; addrlit, Register d);
 669   void patchable_sethi(const AddressLiteral&amp; addrlit, Register d);
 670 
 671   // compute the number of instructions for a sethi/set
 672   static int  insts_for_sethi( address a, bool worst_case = false );
 673   static int  worst_case_insts_for_set();
 674 
</pre>
<hr />
<pre>
1038   void call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
1039 
1040   void call_VM_leaf(Register thread_cache, address entry_point, int number_of_arguments = 0);
1041   void call_VM_leaf(Register thread_cache, address entry_point, Register arg_1);
1042   void call_VM_leaf(Register thread_cache, address entry_point, Register arg_1, Register arg_2);
1043   void call_VM_leaf(Register thread_cache, address entry_point, Register arg_1, Register arg_2, Register arg_3);
1044 
1045   void get_vm_result  (Register oop_result);
1046   void get_vm_result_2(Register metadata_result);
1047 
1048   // vm result is currently getting hijacked to for oop preservation
1049   void set_vm_result(Register oop_result);
1050 
1051   // Emit the CompiledIC call idiom
1052   void ic_call(address entry, bool emit_delay = true, jint method_index = 0);
1053 
1054   // if call_VM_base was called with check_exceptions=false, then call
1055   // check_and_forward_exception to handle exceptions when it is safe
1056   void check_and_forward_exception(Register scratch_reg);
1057 

















1058   // Returns the byte size of the instructions generated by decode_klass_not_null().
1059   static int instr_size_for_decode_klass_not_null();
1060 
1061   // if heap base register is used - reinit it with the correct value
1062   void reinit_heapbase();
1063 
1064   // Debugging
1065   void _verify_oop(Register reg, const char * msg, const char * file, int line);
1066   void _verify_oop_addr(Address addr, const char * msg, const char * file, int line);
1067 
1068   // TODO: verify_method and klass metadata (compare against vptr?)
1069   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
1070   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
1071 
1072 #define verify_oop(reg) _verify_oop(reg, &quot;broken oop &quot; #reg, __FILE__, __LINE__)
1073 #define verify_oop_addr(addr) _verify_oop_addr(addr, &quot;broken oop addr &quot;, __FILE__, __LINE__)
1074 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
1075 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
1076 



1077   void stop(const char* msg);                          // prints msg, dumps registers and stops execution
1078   void warn(const char* msg);                          // prints msg, but don&#39;t stop
1079   void untested(const char* what = &quot;&quot;);
1080   void unimplemented(const char* what = &quot;&quot;);
1081   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }

1082 
1083   // oops in code
1084   AddressLiteral allocate_oop_address(jobject obj);                          // allocate_index
1085   AddressLiteral constant_oop_address(jobject obj);                          // find_index
1086   inline void    set_oop             (jobject obj, Register d);              // uses allocate_oop_address
1087   inline void    set_oop_constant    (jobject obj, Register d);              // uses constant_oop_address
1088   inline void    set_oop             (const AddressLiteral&amp; obj_addr, Register d); // same as load_address
1089 
1090   // metadata in code that we have to keep track of
1091   AddressLiteral allocate_metadata_address(Metadata* obj); // allocate_index
1092   AddressLiteral constant_metadata_address(Metadata* obj); // find_index
1093   inline void    set_metadata             (Metadata* obj, Register d);              // uses allocate_metadata_address
1094   inline void    set_metadata_constant    (Metadata* obj, Register d);              // uses constant_metadata_address
1095   inline void    set_metadata             (const AddressLiteral&amp; obj_addr, Register d); // same as load_address
1096 
1097   void set_narrow_oop( jobject obj, Register d );
1098   void set_narrow_klass( Klass* k, Register d );
1099 
1100   // nop padding
1101   void align(int modulus);
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_sparc.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
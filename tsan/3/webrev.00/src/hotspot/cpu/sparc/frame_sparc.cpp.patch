diff a/src/hotspot/cpu/sparc/frame_sparc.cpp b/src/hotspot/cpu/sparc/frame_sparc.cpp
--- a/src/hotspot/cpu/sparc/frame_sparc.cpp
+++ b/src/hotspot/cpu/sparc/frame_sparc.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,11 +24,12 @@
 
 #include "precompiled.hpp"
 #include "code/codeCache.hpp"
 #include "interpreter/interpreter.hpp"
 #include "memory/resourceArea.hpp"
-#include "oops/markOop.hpp"
+#include "memory/universe.hpp"
+#include "oops/markWord.hpp"
 #include "oops/method.hpp"
 #include "oops/oop.inline.hpp"
 #include "prims/methodHandles.hpp"
 #include "runtime/frame.inline.hpp"
 #include "runtime/handles.inline.hpp"
@@ -174,26 +175,25 @@
 bool frame::safe_for_sender(JavaThread *thread) {
 
   address _SP = (address) sp();
   address _FP = (address) fp();
   address _UNEXTENDED_SP = (address) unextended_sp();
-  // sp must be within the stack
-  bool sp_safe = (_SP <= thread->stack_base()) &&
-                 (_SP >= thread->stack_base() - thread->stack_size());
 
-  if (!sp_safe) {
+  // consider stack guards when trying to determine "safe" stack pointers
+  // sp must be within the usable part of the stack (not in guards)
+  if (!thread->is_in_usable_stack(_SP)) {
     return false;
   }
 
   // unextended sp must be within the stack and above or equal sp
-  bool unextended_sp_safe = (_UNEXTENDED_SP <= thread->stack_base()) &&
+  bool unextended_sp_safe = (_UNEXTENDED_SP < thread->stack_base()) &&
                             (_UNEXTENDED_SP >= _SP);
 
   if (!unextended_sp_safe) return false;
 
   // an fp must be within the stack and above (but not equal) sp
-  bool fp_safe = (_FP <= thread->stack_base()) &&
+  bool fp_safe = (_FP < thread->stack_base()) &&
                  (_FP > _SP);
 
   // We know sp/unextended_sp are safe only fp is questionable here
 
   // If the current frame is known to the code cache then we can attempt to
@@ -249,11 +249,11 @@
     // Do we have a valid fp?
     address sender_fp = (address) sender.fp();
 
     // an fp must be within the stack and above (but not equal) current frame's _FP
 
-    bool sender_fp_safe = (sender_fp <= thread->stack_base()) &&
+    bool sender_fp_safe = (sender_fp < thread->stack_base()) &&
                    (sender_fp > _FP);
 
     if (!sender_fp_safe) {
       return false;
     }
@@ -277,11 +277,11 @@
     if (sender.is_entry_frame()) {
       // Validate the JavaCallWrapper an entry frame must have
 
       address jcw = (address)sender.entry_frame_call_wrapper();
 
-      bool jcw_safe = (jcw <= thread->stack_base()) && (jcw > sender_fp);
+      bool jcw_safe = (jcw < thread->stack_base()) && (jcw > sender_fp);
 
       return jcw_safe;
     }
 
     // If the frame size is 0 something (or less) is bad because every nmethod has a non-zero frame size
@@ -663,17 +663,17 @@
     return false;
   }
 
   // validate ConstantPoolCache*
   ConstantPoolCache* cp = *interpreter_frame_cache_addr();
-  if (cp == NULL || !cp->is_metaspace_object()) return false;
+  if (MetaspaceObj::is_valid(cp) == false) return false;
 
   // validate locals
 
   address locals =  (address) *interpreter_frame_locals_addr();
 
-  if (locals > thread->stack_base() || locals < (address) fp()) return false;
+  if (locals >= thread->stack_base() || locals < (address) fp()) return false;
 
   // We'd have to be pretty unlucky to be mislead at this point
   return true;
 }
 

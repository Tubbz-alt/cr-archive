<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/arm/relocInfo_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/assembler.inline.hpp&quot;
 27 #include &quot;assembler_arm.inline.hpp&quot;
 28 #include &quot;code/relocInfo.hpp&quot;
 29 #include &quot;nativeInst_arm.hpp&quot;
 30 #include &quot;oops/compressedOops.inline.hpp&quot;
 31 #include &quot;oops/oop.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 32 #include &quot;runtime/orderAccess.hpp&quot;</span>
 33 #include &quot;runtime/safepoint.hpp&quot;
 34 
 35 void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {
 36 
 37   NativeMovConstReg* ni = nativeMovConstReg_at(addr());
 38   if (verify_only) {
 39     guarantee(ni-&gt;data() == (intptr_t)(x + o), &quot;instructions must match&quot;);
 40   } else {
 41     ni-&gt;set_data((intptr_t)(x + o));
 42   }
 43 }
 44 
 45 address Relocation::pd_call_destination(address orig_addr) {
 46   address pc = addr();
 47 
 48   int adj = 0;
 49   if (orig_addr != NULL) {
 50     // We just moved this call instruction from orig_addr to addr().
 51     // This means that, when relative, its target will appear to have grown by addr() - orig_addr.
 52     adj = orig_addr - pc;
 53   }
 54 
 55   RawNativeInstruction* ni = rawNativeInstruction_at(pc);
 56 
 57   if (ni-&gt;is_add_lr()) {
 58     // Skip the optional &#39;add LR, PC, #offset&#39;
 59     // (Allowing the jump support code to handle fat_call)
 60     pc = ni-&gt;next_raw_instruction_address();
 61     ni = nativeInstruction_at(pc);
 62   }
 63 
 64   if (ni-&gt;is_bl()) {
 65     // Fat_call are handled by is_jump for the new &#39;ni&#39;,
 66     // requiring only to support is_bl.
 67     return rawNativeCall_at(pc)-&gt;destination(adj);
 68   }
 69 
 70   if (ni-&gt;is_jump()) {
 71     return rawNativeJump_at(pc)-&gt;jump_destination(adj);
 72   }
 73   ShouldNotReachHere();
 74   return NULL;
 75 }
 76 
 77 void Relocation::pd_set_call_destination(address x) {
 78   address pc = addr();
 79   NativeInstruction* ni = nativeInstruction_at(pc);
 80 
 81   if (ni-&gt;is_add_lr()) {
 82     // Skip the optional &#39;add LR, PC, #offset&#39;
 83     // (Allowing the jump support code to handle fat_call)
 84     pc = ni-&gt;next_raw_instruction_address();
 85     ni = nativeInstruction_at(pc);
 86   }
 87 
 88   if (ni-&gt;is_bl()) {
 89     // Fat_call are handled by is_jump for the new &#39;ni&#39;,
 90     // requiring only to support is_bl.
 91     rawNativeCall_at(pc)-&gt;set_destination(x);
 92     return;
 93   }
 94 
 95   if (ni-&gt;is_jump()) { // raw jump
 96     rawNativeJump_at(pc)-&gt;set_jump_destination(x);
 97     return;
 98   }
 99   ShouldNotReachHere();
100 }
101 
102 
103 address* Relocation::pd_address_in_code() {
104   return (address*)addr();
105 }
106 
107 address Relocation::pd_get_address_from_code() {
108   return *pd_address_in_code();
109 }
110 
111 void poll_Relocation::fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) {
112 }
113 
114 void metadata_Relocation::pd_fix_value(address x) {
115   assert(! addr_in_const(), &quot;Do not use&quot;);
116   if (!VM_Version::supports_movw()) {
117     set_value(x);
118 #ifdef ASSERT
119   } else {
120     // the movw/movt data should be correct
121     NativeMovConstReg* ni = nativeMovConstReg_at(addr());
122     assert(ni-&gt;is_movw(), &quot;not a movw&quot;);
123     // The following assert should be correct but the shared code
124     // currently &#39;fixes&#39; the metadata instructions before the
125     // metadata_table is copied in the new method (see
126     // JDK-8042845). This means that &#39;x&#39; (which comes from the table)
127     // does not match the value inlined in the code (which is
128     // correct). Failure can be temporarily ignored since the code is
129     // correct and the table is copied shortly afterward.
130     //
131     // assert(ni-&gt;data() == (int)x, &quot;metadata relocation mismatch&quot;);
132 #endif
133   }
134 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
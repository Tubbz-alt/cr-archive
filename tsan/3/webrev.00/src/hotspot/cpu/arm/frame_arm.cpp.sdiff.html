<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/frame_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="disassembler_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/shared/barrierSetAssembler_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/frame_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/interpreter.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified"> 28 #include &quot;oops/markOop.hpp&quot;</span>

 29 #include &quot;oops/method.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/frame.inline.hpp&quot;
 32 #include &quot;runtime/handles.inline.hpp&quot;
 33 #include &quot;runtime/javaCalls.hpp&quot;
 34 #include &quot;runtime/monitorChunk.hpp&quot;
 35 #include &quot;runtime/os.inline.hpp&quot;
 36 #include &quot;runtime/signature.hpp&quot;
 37 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 38 #include &quot;runtime/stubRoutines.hpp&quot;
 39 #include &quot;vmreg_arm.inline.hpp&quot;
 40 #ifdef COMPILER1
 41 #include &quot;c1/c1_Runtime1.hpp&quot;
 42 #include &quot;runtime/vframeArray.hpp&quot;
 43 #endif
 44 #include &quot;prims/methodHandles.hpp&quot;
 45 
 46 #ifdef ASSERT
 47 void RegisterMap::check_location_valid() {
 48 }
 49 #endif
 50 
 51 
 52 // Profiling/safepoint support
 53 
 54 bool frame::safe_for_sender(JavaThread *thread) {
 55   address   sp = (address)_sp;
 56   address   fp = (address)_fp;
 57   address   unextended_sp = (address)_unextended_sp;
 58 
<span class="line-modified"> 59   static size_t stack_guard_size = os::uses_stack_guard_pages() ?</span>
<span class="line-removed"> 60     (JavaThread::stack_red_zone_size() + JavaThread::stack_yellow_zone_size()) : 0;</span>
<span class="line-removed"> 61   size_t usable_stack_size = thread-&gt;stack_size() - stack_guard_size;</span>
<span class="line-removed"> 62 </span>
 63   // sp must be within the usable part of the stack (not in guards)
<span class="line-modified"> 64   bool sp_safe = (sp != NULL &amp;&amp;</span>
<span class="line-removed"> 65                  (sp &lt;= thread-&gt;stack_base()) &amp;&amp;</span>
<span class="line-removed"> 66                  (sp &gt;= thread-&gt;stack_base() - usable_stack_size));</span>
<span class="line-removed"> 67 </span>
<span class="line-removed"> 68   if (!sp_safe) {</span>
 69     return false;
 70   }
 71 
 72   bool unextended_sp_safe = (unextended_sp != NULL &amp;&amp;
<span class="line-modified"> 73                              (unextended_sp &lt;= thread-&gt;stack_base()) &amp;&amp;</span>
 74                              (unextended_sp &gt;= sp));
 75   if (!unextended_sp_safe) {
 76     return false;
 77   }
 78 
 79   // We know sp/unextended_sp are safe. Only fp is questionable here.
 80 
 81   bool fp_safe = (fp != NULL &amp;&amp;
<span class="line-modified"> 82                   (fp &lt;= thread-&gt;stack_base()) &amp;&amp;</span>
 83                   fp &gt;= sp);
 84 
 85   if (_cb != NULL ) {
 86 
 87     // First check if frame is complete and tester is reliable
 88     // Unfortunately we can only check frame complete for runtime stubs and nmethod
 89     // other generic buffer blobs are more problematic so we just assume they are
 90     // ok. adapter blobs never have a frame complete and are never ok.
 91 
 92     if (!_cb-&gt;is_frame_complete_at(_pc)) {
 93       if (_cb-&gt;is_compiled() || _cb-&gt;is_adapter_blob() || _cb-&gt;is_runtime_stub()) {
 94         return false;
 95       }
 96     }
 97 
 98     // Could just be some random pointer within the codeBlob
 99     if (!_cb-&gt;code_contains(_pc)) {
100       return false;
101     }
102 
</pre>
<hr />
<pre>
130       // With our calling conventions, the return_address should
131       // end up being the word on the stack
132       sender_pc = (address) *(sender_sp - sender_sp_offset + return_addr_offset);
133     }
134 
135     // We must always be able to find a recognizable pc
136     CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);
137     if (sender_pc == NULL || sender_blob == NULL) {
138       return false;
139     }
140 
141 
142     // If the potential sender is the interpreter then we can do some more checking
143     if (Interpreter::contains(sender_pc)) {
144 
145       // FP is always saved in a recognizable place in any code we generate. However
146       // only if the sender is interpreted/call_stub (c1 too?) are we certain that the saved FP
147       // is really a frame pointer.
148 
149       intptr_t *saved_fp = (intptr_t*)*(sender_sp - frame::sender_sp_offset + link_offset);
<span class="line-modified">150       bool saved_fp_safe = ((address)saved_fp &lt;= thread-&gt;stack_base()) &amp;&amp; (saved_fp &gt; sender_sp);</span>
151 
152       if (!saved_fp_safe) {
153         return false;
154       }
155 
156       // construct the potential sender
157 
158       frame sender(sender_sp, saved_fp, sender_pc);
159 
160       return sender.is_interpreted_frame_valid(thread);
161     }
162 
163     if (sender_blob-&gt;is_zombie() || sender_blob-&gt;is_unloaded()) {
164       return false;
165     }
166 
167     // Could just be some random pointer within the codeBlob
168     if (!sender_blob-&gt;code_contains(sender_pc)) {
169       return false;
170     }
171 
172     // We should never be able to see an adapter if the current frame is something from code cache
173     if (sender_blob-&gt;is_adapter_blob()) {
174       return false;
175     }
176 
177     // Could be the call_stub
178     if (StubRoutines::returns_to_call_stub(sender_pc)) {
179       intptr_t *saved_fp = (intptr_t*)*(sender_sp - frame::sender_sp_offset + link_offset);
<span class="line-modified">180       bool saved_fp_safe = ((address)saved_fp &lt;= thread-&gt;stack_base()) &amp;&amp; (saved_fp &gt;= sender_sp);</span>
181 
182       if (!saved_fp_safe) {
183         return false;
184       }
185 
186       // construct the potential sender
187 
188       frame sender(sender_sp, saved_fp, sender_pc);
189 
190       // Validate the JavaCallWrapper an entry frame must have
191       address jcw = (address)sender.entry_frame_call_wrapper();
192 
<span class="line-modified">193       bool jcw_safe = (jcw &lt;= thread-&gt;stack_base()) &amp;&amp; (jcw &gt; (address)sender.fp());</span>
194 
195       return jcw_safe;
196     }
197 
198     // If the frame size is 0 something (or less) is bad because every nmethod has a non-zero frame size
199     // because the return address counts against the callee&#39;s frame.
200 
201     if (sender_blob-&gt;frame_size() &lt;= 0) {
202       assert(!sender_blob-&gt;is_compiled(), &quot;should count return address at least&quot;);
203       return false;
204     }
205 
206     // We should never be able to see anything here except an nmethod. If something in the
207     // code cache (current frame) is called by an entity within the code cache that entity
208     // should not be anything but the call stub (already covered), the interpreter (already covered)
209     // or an nmethod.
210 
211     if (!sender_blob-&gt;is_compiled()) {
212       return false;
213     }
</pre>
<hr />
<pre>
477   Method* m = *interpreter_frame_method_addr();
478 
479   // validate the method we&#39;d find in this potential sender
480   if (!Method::is_valid_method(m)) return false;
481 
482   // stack frames shouldn&#39;t be much larger than max_stack elements
483 
484   if (fp() - sp() &gt; 1024 + m-&gt;max_stack()*Interpreter::stackElementSize) {
485     return false;
486   }
487 
488   // validate bci/bcp
489 
490   address bcp = interpreter_frame_bcp();
491   if (m-&gt;validate_bci_from_bcp(bcp) &lt; 0) {
492     return false;
493   }
494 
495   // validate ConstantPoolCache*
496   ConstantPoolCache* cp = *interpreter_frame_cache_addr();
<span class="line-modified">497   if (cp == NULL || !cp-&gt;is_metaspace_object()) return false;</span>
498 
499   // validate locals
500 
501   address locals =  (address) *interpreter_frame_locals_addr();
502 
<span class="line-modified">503   if (locals &gt; thread-&gt;stack_base() || locals &lt; (address) fp()) return false;</span>
504 
505   // We&#39;d have to be pretty unlucky to be mislead at this point
506 
507   return true;
508 }
509 
510 BasicType frame::interpreter_frame_result(oop* oop_result, jvalue* value_result) {
511   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
512   Method* method = interpreter_frame_method();
513   BasicType type = method-&gt;result_type();
514 
515   intptr_t* res_addr;
516   if (method-&gt;is_native()) {
517     // Prior to calling into the runtime to report the method_exit both of
518     // the possible return value registers are saved.
519     // Return value registers are pushed to the native stack
520     res_addr = (intptr_t*)sp();
521 #ifdef __ABI_HARD__
522     // FP result is pushed onto a stack along with integer result registers
523     if (type == T_FLOAT || type == T_DOUBLE) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/interpreter.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified"> 28 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added"> 29 #include &quot;oops/markWord.hpp&quot;</span>
 30 #include &quot;oops/method.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/frame.inline.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/javaCalls.hpp&quot;
 35 #include &quot;runtime/monitorChunk.hpp&quot;
 36 #include &quot;runtime/os.inline.hpp&quot;
 37 #include &quot;runtime/signature.hpp&quot;
 38 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 39 #include &quot;runtime/stubRoutines.hpp&quot;
 40 #include &quot;vmreg_arm.inline.hpp&quot;
 41 #ifdef COMPILER1
 42 #include &quot;c1/c1_Runtime1.hpp&quot;
 43 #include &quot;runtime/vframeArray.hpp&quot;
 44 #endif
 45 #include &quot;prims/methodHandles.hpp&quot;
 46 
 47 #ifdef ASSERT
 48 void RegisterMap::check_location_valid() {
 49 }
 50 #endif
 51 
 52 
 53 // Profiling/safepoint support
 54 
 55 bool frame::safe_for_sender(JavaThread *thread) {
 56   address   sp = (address)_sp;
 57   address   fp = (address)_fp;
 58   address   unextended_sp = (address)_unextended_sp;
 59 
<span class="line-modified"> 60   // consider stack guards when trying to determine &quot;safe&quot; stack pointers</span>



 61   // sp must be within the usable part of the stack (not in guards)
<span class="line-modified"> 62   if (!thread-&gt;is_in_usable_stack(sp)) {</span>




 63     return false;
 64   }
 65 
 66   bool unextended_sp_safe = (unextended_sp != NULL &amp;&amp;
<span class="line-modified"> 67                              (unextended_sp &lt; thread-&gt;stack_base()) &amp;&amp;</span>
 68                              (unextended_sp &gt;= sp));
 69   if (!unextended_sp_safe) {
 70     return false;
 71   }
 72 
 73   // We know sp/unextended_sp are safe. Only fp is questionable here.
 74 
 75   bool fp_safe = (fp != NULL &amp;&amp;
<span class="line-modified"> 76                   (fp &lt; thread-&gt;stack_base()) &amp;&amp;</span>
 77                   fp &gt;= sp);
 78 
 79   if (_cb != NULL ) {
 80 
 81     // First check if frame is complete and tester is reliable
 82     // Unfortunately we can only check frame complete for runtime stubs and nmethod
 83     // other generic buffer blobs are more problematic so we just assume they are
 84     // ok. adapter blobs never have a frame complete and are never ok.
 85 
 86     if (!_cb-&gt;is_frame_complete_at(_pc)) {
 87       if (_cb-&gt;is_compiled() || _cb-&gt;is_adapter_blob() || _cb-&gt;is_runtime_stub()) {
 88         return false;
 89       }
 90     }
 91 
 92     // Could just be some random pointer within the codeBlob
 93     if (!_cb-&gt;code_contains(_pc)) {
 94       return false;
 95     }
 96 
</pre>
<hr />
<pre>
124       // With our calling conventions, the return_address should
125       // end up being the word on the stack
126       sender_pc = (address) *(sender_sp - sender_sp_offset + return_addr_offset);
127     }
128 
129     // We must always be able to find a recognizable pc
130     CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);
131     if (sender_pc == NULL || sender_blob == NULL) {
132       return false;
133     }
134 
135 
136     // If the potential sender is the interpreter then we can do some more checking
137     if (Interpreter::contains(sender_pc)) {
138 
139       // FP is always saved in a recognizable place in any code we generate. However
140       // only if the sender is interpreted/call_stub (c1 too?) are we certain that the saved FP
141       // is really a frame pointer.
142 
143       intptr_t *saved_fp = (intptr_t*)*(sender_sp - frame::sender_sp_offset + link_offset);
<span class="line-modified">144       bool saved_fp_safe = ((address)saved_fp &lt; thread-&gt;stack_base()) &amp;&amp; (saved_fp &gt; sender_sp);</span>
145 
146       if (!saved_fp_safe) {
147         return false;
148       }
149 
150       // construct the potential sender
151 
152       frame sender(sender_sp, saved_fp, sender_pc);
153 
154       return sender.is_interpreted_frame_valid(thread);
155     }
156 
157     if (sender_blob-&gt;is_zombie() || sender_blob-&gt;is_unloaded()) {
158       return false;
159     }
160 
161     // Could just be some random pointer within the codeBlob
162     if (!sender_blob-&gt;code_contains(sender_pc)) {
163       return false;
164     }
165 
166     // We should never be able to see an adapter if the current frame is something from code cache
167     if (sender_blob-&gt;is_adapter_blob()) {
168       return false;
169     }
170 
171     // Could be the call_stub
172     if (StubRoutines::returns_to_call_stub(sender_pc)) {
173       intptr_t *saved_fp = (intptr_t*)*(sender_sp - frame::sender_sp_offset + link_offset);
<span class="line-modified">174       bool saved_fp_safe = ((address)saved_fp &lt; thread-&gt;stack_base()) &amp;&amp; (saved_fp &gt; sender_sp);</span>
175 
176       if (!saved_fp_safe) {
177         return false;
178       }
179 
180       // construct the potential sender
181 
182       frame sender(sender_sp, saved_fp, sender_pc);
183 
184       // Validate the JavaCallWrapper an entry frame must have
185       address jcw = (address)sender.entry_frame_call_wrapper();
186 
<span class="line-modified">187       bool jcw_safe = (jcw &lt; thread-&gt;stack_base()) &amp;&amp; (jcw &gt; (address)sender.fp());</span>
188 
189       return jcw_safe;
190     }
191 
192     // If the frame size is 0 something (or less) is bad because every nmethod has a non-zero frame size
193     // because the return address counts against the callee&#39;s frame.
194 
195     if (sender_blob-&gt;frame_size() &lt;= 0) {
196       assert(!sender_blob-&gt;is_compiled(), &quot;should count return address at least&quot;);
197       return false;
198     }
199 
200     // We should never be able to see anything here except an nmethod. If something in the
201     // code cache (current frame) is called by an entity within the code cache that entity
202     // should not be anything but the call stub (already covered), the interpreter (already covered)
203     // or an nmethod.
204 
205     if (!sender_blob-&gt;is_compiled()) {
206       return false;
207     }
</pre>
<hr />
<pre>
471   Method* m = *interpreter_frame_method_addr();
472 
473   // validate the method we&#39;d find in this potential sender
474   if (!Method::is_valid_method(m)) return false;
475 
476   // stack frames shouldn&#39;t be much larger than max_stack elements
477 
478   if (fp() - sp() &gt; 1024 + m-&gt;max_stack()*Interpreter::stackElementSize) {
479     return false;
480   }
481 
482   // validate bci/bcp
483 
484   address bcp = interpreter_frame_bcp();
485   if (m-&gt;validate_bci_from_bcp(bcp) &lt; 0) {
486     return false;
487   }
488 
489   // validate ConstantPoolCache*
490   ConstantPoolCache* cp = *interpreter_frame_cache_addr();
<span class="line-modified">491   if (MetaspaceObj::is_valid(cp) == false) return false;</span>
492 
493   // validate locals
494 
495   address locals =  (address) *interpreter_frame_locals_addr();
496 
<span class="line-modified">497   if (locals &gt;= thread-&gt;stack_base() || locals &lt; (address) fp()) return false;</span>
498 
499   // We&#39;d have to be pretty unlucky to be mislead at this point
500 
501   return true;
502 }
503 
504 BasicType frame::interpreter_frame_result(oop* oop_result, jvalue* value_result) {
505   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
506   Method* method = interpreter_frame_method();
507   BasicType type = method-&gt;result_type();
508 
509   intptr_t* res_addr;
510   if (method-&gt;is_native()) {
511     // Prior to calling into the runtime to report the method_exit both of
512     // the possible return value registers are saved.
513     // Return value registers are pushed to the native stack
514     res_addr = (intptr_t*)sp();
515 #ifdef __ABI_HARD__
516     // FP result is pushed onto a stack along with integer result registers
517     if (type == T_FLOAT || type == T_DOUBLE) {
</pre>
</td>
</tr>
</table>
<center><a href="disassembler_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/shared/barrierSetAssembler_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
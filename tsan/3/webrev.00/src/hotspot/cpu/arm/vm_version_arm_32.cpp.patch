diff a/src/hotspot/cpu/arm/vm_version_arm_32.cpp b/src/hotspot/cpu/arm/vm_version_arm_32.cpp
--- a/src/hotspot/cpu/arm/vm_version_arm_32.cpp
+++ b/src/hotspot/cpu/arm/vm_version_arm_32.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -27,21 +27,22 @@
 #include "asm/macroAssembler.inline.hpp"
 #include "memory/resourceArea.hpp"
 #include "runtime/java.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/stubCodeGenerator.hpp"
-#include "vm_version_arm.hpp"
+#include "runtime/vm_version.hpp"
 
 int  VM_Version::_stored_pc_adjustment = 4;
 int  VM_Version::_arm_arch             = 5;
 bool VM_Version::_is_initialized       = false;
 int VM_Version::_kuser_helper_version  = 0;
 
 extern "C" {
   typedef int (*get_cpu_info_t)();
   typedef bool (*check_vfp_t)(double *d);
   typedef bool (*check_simd_t)();
+  typedef bool (*check_mp_ext_t)(int *addr);
 }
 
 #define __ _masm->
 
 class VM_Version_StubGenerator: public StubCodeGenerator {
@@ -93,18 +94,33 @@
     __ mov(R0, 1);
     __ bx(LR);
 
     return start;
   };
+
+  address generate_check_mp_ext() {
+    StubCodeMark mark(this, "VM_Version", "check_mp_ext");
+    address start = __ pc();
+
+    // PLDW is available with Multiprocessing Extensions only
+    __ pldw(Address(R0));
+    // Return true if instruction caused no signals
+    __ mov(R0, 1);
+    // JVM_handle_linux_signal moves PC here if SIGILL happens
+    __ bx(LR);
+
+    return start;
+  };
 };
 
 #undef __
 
 
 extern "C" address check_vfp3_32_fault_instr;
 extern "C" address check_vfp_fault_instr;
 extern "C" address check_simd_fault_instr;
+extern "C" address check_mp_ext_fault_instr;
 
 void VM_Version::early_initialize() {
 
   // Make sure that _arm_arch is initialized so that any calls to OrderAccess will
   // use proper dmb instruction
@@ -163,10 +179,17 @@
     }
   }
 #endif
 #endif
 
+  address check_mp_ext_pc = g.generate_check_mp_ext();
+  check_mp_ext_t check_mp_ext = CAST_TO_FN_PTR(check_mp_ext_t, check_mp_ext_pc);
+  check_mp_ext_fault_instr = (address)check_mp_ext;
+  int dummy_local_variable;
+  if (check_mp_ext(&dummy_local_variable)) {
+    _features |= mp_ext_m;
+  }
 
   if (UseAESIntrinsics && !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
     warning("AES intrinsics are not available on this CPU");
     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
   }
@@ -245,15 +268,16 @@
 #ifdef COMPILER2
   assert(_supports_cx8 && _supports_atomic_getset4 && _supports_atomic_getadd4
          && _supports_atomic_getset8 && _supports_atomic_getadd8, "C2: atomic operations must be supported");
 #endif
   char buf[512];
-  jio_snprintf(buf, sizeof(buf), "(ARMv%d)%s%s%s",
+  jio_snprintf(buf, sizeof(buf), "(ARMv%d)%s%s%s%s",
                _arm_arch,
                (has_vfp() ? ", vfp" : ""),
                (has_vfp3_32() ? ", vfp3-32" : ""),
-               (has_simd() ? ", simd" : ""));
+               (has_simd() ? ", simd" : ""),
+               (has_multiprocessing_extensions() ? ", mp_ext" : ""));
 
   // buf is started with ", " or is empty
   _features_string = os::strdup(buf);
 
   if (has_simd()) {
@@ -274,14 +298,16 @@
   if (FLAG_IS_DEFAULT(MaxVectorSize)) {
     // FLAG_SET_DEFAULT(MaxVectorSize, has_simd() ? 16 : 8);
     // SIMD/NEON can use 16, but default is 8 because currently
     // larger than 8 will disable instruction scheduling
     FLAG_SET_DEFAULT(MaxVectorSize, 8);
-  }
-
-  if (MaxVectorSize > 16) {
-    FLAG_SET_DEFAULT(MaxVectorSize, 8);
+  } else {
+    int max_vector_size = has_simd() ? 16 : 8;
+    if (MaxVectorSize > max_vector_size) {
+      warning("MaxVectorSize must be at most %i on this platform", max_vector_size);
+      FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);
+    }
   }
 #endif
 
   if (FLAG_IS_DEFAULT(Tier4CompileThreshold)) {
     Tier4CompileThreshold = 10000;

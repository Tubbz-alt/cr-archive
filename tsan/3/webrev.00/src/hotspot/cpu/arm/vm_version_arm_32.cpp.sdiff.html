<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/vm_version_arm_32.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vm_version_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_ext_arm.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/vm_version_arm_32.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
 29 #include &quot;runtime/java.hpp&quot;
 30 #include &quot;runtime/os.inline.hpp&quot;
 31 #include &quot;runtime/stubCodeGenerator.hpp&quot;
<span class="line-modified"> 32 #include &quot;vm_version_arm.hpp&quot;</span>
 33 
 34 int  VM_Version::_stored_pc_adjustment = 4;
 35 int  VM_Version::_arm_arch             = 5;
 36 bool VM_Version::_is_initialized       = false;
 37 int VM_Version::_kuser_helper_version  = 0;
 38 
 39 extern &quot;C&quot; {
 40   typedef int (*get_cpu_info_t)();
 41   typedef bool (*check_vfp_t)(double *d);
 42   typedef bool (*check_simd_t)();

 43 }
 44 
 45 #define __ _masm-&gt;
 46 
 47 class VM_Version_StubGenerator: public StubCodeGenerator {
 48  public:
 49 
 50   VM_Version_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}
 51 
 52   address generate_get_cpu_info() {
 53     StubCodeMark mark(this, &quot;VM_Version&quot;, &quot;get_cpu_info&quot;);
 54     address start = __ pc();
 55 
 56     __ mov(R0, PC);
 57     __ push(PC);
 58     __ pop(R1);
 59     __ sub(R0, R1, R0);
 60     // return the result in R0
 61     __ bx(LR);
 62 
</pre>
<hr />
<pre>
 78     StubCodeMark mark(this, &quot;VM_Version&quot;, &quot;check_vfp3_32&quot;);
 79     address start = __ pc();
 80 
 81     __ fstd(D16, Address(R0));
 82     __ mov(R0, 1);
 83     __ bx(LR);
 84 
 85     return start;
 86   };
 87 
 88   address generate_check_simd() {
 89     StubCodeMark mark(this, &quot;VM_Version&quot;, &quot;check_simd&quot;);
 90     address start = __ pc();
 91 
 92     __ vcnt(Stemp, Stemp);
 93     __ mov(R0, 1);
 94     __ bx(LR);
 95 
 96     return start;
 97   };














 98 };
 99 
100 #undef __
101 
102 
103 extern &quot;C&quot; address check_vfp3_32_fault_instr;
104 extern &quot;C&quot; address check_vfp_fault_instr;
105 extern &quot;C&quot; address check_simd_fault_instr;

106 
107 void VM_Version::early_initialize() {
108 
109   // Make sure that _arm_arch is initialized so that any calls to OrderAccess will
110   // use proper dmb instruction
111   get_os_cpu_info();
112 
113   _kuser_helper_version = *(int*)KUSER_HELPER_VERSION_ADDR;
114   // armv7 has the ldrexd instruction that can be used to implement cx8
115   // armv5 with linux &gt;= 3.1 can use kernel helper routine
116   _supports_cx8 = (supports_ldrexd() || supports_kuser_cmpxchg64());
117 }
118 
119 void VM_Version::initialize() {
120   ResourceMark rm;
121 
122   // Making this stub must be FIRST use of assembler
123   const int stub_size = 128;
124   BufferBlob* stub_blob = BufferBlob::create(&quot;get_cpu_info&quot;, stub_size);
125   if (stub_blob == NULL) {
</pre>
<hr />
<pre>
148 #ifdef COMPILER2
149   if (has_vfp()) {
150     address check_vfp3_32_pc = g.generate_check_vfp3_32();
151     check_vfp_t check_vfp3_32 = CAST_TO_FN_PTR(check_vfp_t, check_vfp3_32_pc);
152     check_vfp3_32_fault_instr = (address)check_vfp3_32;
153     double dummy;
154     if (check_vfp3_32(&amp;dummy)) {
155       _features |= vfp3_32_m;
156     }
157 
158     address check_simd_pc =g.generate_check_simd();
159     check_simd_t check_simd = CAST_TO_FN_PTR(check_simd_t, check_simd_pc);
160     check_simd_fault_instr = (address)check_simd;
161     if (check_simd()) {
162       _features |= simd_m;
163     }
164   }
165 #endif
166 #endif
167 







168 
169   if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
170     warning(&quot;AES intrinsics are not available on this CPU&quot;);
171     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
172   }
173 
174   if (UseAES &amp;&amp; !FLAG_IS_DEFAULT(UseAES)) {
175     warning(&quot;AES instructions are not available on this CPU&quot;);
176     FLAG_SET_DEFAULT(UseAES, false);
177   }
178 
179   if (UseAESCTRIntrinsics) {
180     warning(&quot;AES/CTR intrinsics are not available on this CPU&quot;);
181     FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
182   }
183 
184   if (UseFMA) {
185     warning(&quot;FMA instructions are not available on this CPU&quot;);
186     FLAG_SET_DEFAULT(UseFMA, false);
187   }
</pre>
<hr />
<pre>
230 
231 #ifdef COMPILER2
232   // C2 is only supported on v7+ VFP at this time
233   if (_arm_arch &lt; 7 || !has_vfp()) {
234     vm_exit_during_initialization(&quot;Server VM is only supported on ARMv7+ VFP&quot;);
235   }
236 #endif
237 
238   // ARM doesn&#39;t have special instructions for these but ldrex/ldrexd
239   // enable shorter instruction sequences that the ones based on cas.
240   _supports_atomic_getset4 = supports_ldrex();
241   _supports_atomic_getadd4 = supports_ldrex();
242   _supports_atomic_getset8 = supports_ldrexd();
243   _supports_atomic_getadd8 = supports_ldrexd();
244 
245 #ifdef COMPILER2
246   assert(_supports_cx8 &amp;&amp; _supports_atomic_getset4 &amp;&amp; _supports_atomic_getadd4
247          &amp;&amp; _supports_atomic_getset8 &amp;&amp; _supports_atomic_getadd8, &quot;C2: atomic operations must be supported&quot;);
248 #endif
249   char buf[512];
<span class="line-modified">250   jio_snprintf(buf, sizeof(buf), &quot;(ARMv%d)%s%s%s&quot;,</span>
251                _arm_arch,
252                (has_vfp() ? &quot;, vfp&quot; : &quot;&quot;),
253                (has_vfp3_32() ? &quot;, vfp3-32&quot; : &quot;&quot;),
<span class="line-modified">254                (has_simd() ? &quot;, simd&quot; : &quot;&quot;));</span>

255 
256   // buf is started with &quot;, &quot; or is empty
257   _features_string = os::strdup(buf);
258 
259   if (has_simd()) {
260     if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
261       FLAG_SET_DEFAULT(UsePopCountInstruction, true);
262     }
263   } else {
264     FLAG_SET_DEFAULT(UsePopCountInstruction, false);
265   }
266 
267   if (FLAG_IS_DEFAULT(AllocatePrefetchDistance)) {
268     FLAG_SET_DEFAULT(AllocatePrefetchDistance, 128);
269   }
270 
271 #ifdef COMPILER2
272   FLAG_SET_DEFAULT(UseFPUForSpilling, true);
273 
274   if (FLAG_IS_DEFAULT(MaxVectorSize)) {
275     // FLAG_SET_DEFAULT(MaxVectorSize, has_simd() ? 16 : 8);
276     // SIMD/NEON can use 16, but default is 8 because currently
277     // larger than 8 will disable instruction scheduling
278     FLAG_SET_DEFAULT(MaxVectorSize, 8);
<span class="line-modified">279   }</span>
<span class="line-modified">280 </span>
<span class="line-modified">281   if (MaxVectorSize &gt; 16) {</span>
<span class="line-modified">282     FLAG_SET_DEFAULT(MaxVectorSize, 8);</span>


283   }
284 #endif
285 
286   if (FLAG_IS_DEFAULT(Tier4CompileThreshold)) {
287     Tier4CompileThreshold = 10000;
288   }
289   if (FLAG_IS_DEFAULT(Tier3InvocationThreshold)) {
290     Tier3InvocationThreshold = 1000;
291   }
292   if (FLAG_IS_DEFAULT(Tier3CompileThreshold)) {
293     Tier3CompileThreshold = 5000;
294   }
295   if (FLAG_IS_DEFAULT(Tier3MinInvocationThreshold)) {
296     Tier3MinInvocationThreshold = 500;
297   }
298 
299   UNSUPPORTED_OPTION(TypeProfileLevel);
300   UNSUPPORTED_OPTION(CriticalJNINatives);
301 
302   FLAG_SET_DEFAULT(TypeProfileLevel, 0); // unsupported
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
 29 #include &quot;runtime/java.hpp&quot;
 30 #include &quot;runtime/os.inline.hpp&quot;
 31 #include &quot;runtime/stubCodeGenerator.hpp&quot;
<span class="line-modified"> 32 #include &quot;runtime/vm_version.hpp&quot;</span>
 33 
 34 int  VM_Version::_stored_pc_adjustment = 4;
 35 int  VM_Version::_arm_arch             = 5;
 36 bool VM_Version::_is_initialized       = false;
 37 int VM_Version::_kuser_helper_version  = 0;
 38 
 39 extern &quot;C&quot; {
 40   typedef int (*get_cpu_info_t)();
 41   typedef bool (*check_vfp_t)(double *d);
 42   typedef bool (*check_simd_t)();
<span class="line-added"> 43   typedef bool (*check_mp_ext_t)(int *addr);</span>
 44 }
 45 
 46 #define __ _masm-&gt;
 47 
 48 class VM_Version_StubGenerator: public StubCodeGenerator {
 49  public:
 50 
 51   VM_Version_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}
 52 
 53   address generate_get_cpu_info() {
 54     StubCodeMark mark(this, &quot;VM_Version&quot;, &quot;get_cpu_info&quot;);
 55     address start = __ pc();
 56 
 57     __ mov(R0, PC);
 58     __ push(PC);
 59     __ pop(R1);
 60     __ sub(R0, R1, R0);
 61     // return the result in R0
 62     __ bx(LR);
 63 
</pre>
<hr />
<pre>
 79     StubCodeMark mark(this, &quot;VM_Version&quot;, &quot;check_vfp3_32&quot;);
 80     address start = __ pc();
 81 
 82     __ fstd(D16, Address(R0));
 83     __ mov(R0, 1);
 84     __ bx(LR);
 85 
 86     return start;
 87   };
 88 
 89   address generate_check_simd() {
 90     StubCodeMark mark(this, &quot;VM_Version&quot;, &quot;check_simd&quot;);
 91     address start = __ pc();
 92 
 93     __ vcnt(Stemp, Stemp);
 94     __ mov(R0, 1);
 95     __ bx(LR);
 96 
 97     return start;
 98   };
<span class="line-added"> 99 </span>
<span class="line-added">100   address generate_check_mp_ext() {</span>
<span class="line-added">101     StubCodeMark mark(this, &quot;VM_Version&quot;, &quot;check_mp_ext&quot;);</span>
<span class="line-added">102     address start = __ pc();</span>
<span class="line-added">103 </span>
<span class="line-added">104     // PLDW is available with Multiprocessing Extensions only</span>
<span class="line-added">105     __ pldw(Address(R0));</span>
<span class="line-added">106     // Return true if instruction caused no signals</span>
<span class="line-added">107     __ mov(R0, 1);</span>
<span class="line-added">108     // JVM_handle_linux_signal moves PC here if SIGILL happens</span>
<span class="line-added">109     __ bx(LR);</span>
<span class="line-added">110 </span>
<span class="line-added">111     return start;</span>
<span class="line-added">112   };</span>
113 };
114 
115 #undef __
116 
117 
118 extern &quot;C&quot; address check_vfp3_32_fault_instr;
119 extern &quot;C&quot; address check_vfp_fault_instr;
120 extern &quot;C&quot; address check_simd_fault_instr;
<span class="line-added">121 extern &quot;C&quot; address check_mp_ext_fault_instr;</span>
122 
123 void VM_Version::early_initialize() {
124 
125   // Make sure that _arm_arch is initialized so that any calls to OrderAccess will
126   // use proper dmb instruction
127   get_os_cpu_info();
128 
129   _kuser_helper_version = *(int*)KUSER_HELPER_VERSION_ADDR;
130   // armv7 has the ldrexd instruction that can be used to implement cx8
131   // armv5 with linux &gt;= 3.1 can use kernel helper routine
132   _supports_cx8 = (supports_ldrexd() || supports_kuser_cmpxchg64());
133 }
134 
135 void VM_Version::initialize() {
136   ResourceMark rm;
137 
138   // Making this stub must be FIRST use of assembler
139   const int stub_size = 128;
140   BufferBlob* stub_blob = BufferBlob::create(&quot;get_cpu_info&quot;, stub_size);
141   if (stub_blob == NULL) {
</pre>
<hr />
<pre>
164 #ifdef COMPILER2
165   if (has_vfp()) {
166     address check_vfp3_32_pc = g.generate_check_vfp3_32();
167     check_vfp_t check_vfp3_32 = CAST_TO_FN_PTR(check_vfp_t, check_vfp3_32_pc);
168     check_vfp3_32_fault_instr = (address)check_vfp3_32;
169     double dummy;
170     if (check_vfp3_32(&amp;dummy)) {
171       _features |= vfp3_32_m;
172     }
173 
174     address check_simd_pc =g.generate_check_simd();
175     check_simd_t check_simd = CAST_TO_FN_PTR(check_simd_t, check_simd_pc);
176     check_simd_fault_instr = (address)check_simd;
177     if (check_simd()) {
178       _features |= simd_m;
179     }
180   }
181 #endif
182 #endif
183 
<span class="line-added">184   address check_mp_ext_pc = g.generate_check_mp_ext();</span>
<span class="line-added">185   check_mp_ext_t check_mp_ext = CAST_TO_FN_PTR(check_mp_ext_t, check_mp_ext_pc);</span>
<span class="line-added">186   check_mp_ext_fault_instr = (address)check_mp_ext;</span>
<span class="line-added">187   int dummy_local_variable;</span>
<span class="line-added">188   if (check_mp_ext(&amp;dummy_local_variable)) {</span>
<span class="line-added">189     _features |= mp_ext_m;</span>
<span class="line-added">190   }</span>
191 
192   if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
193     warning(&quot;AES intrinsics are not available on this CPU&quot;);
194     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
195   }
196 
197   if (UseAES &amp;&amp; !FLAG_IS_DEFAULT(UseAES)) {
198     warning(&quot;AES instructions are not available on this CPU&quot;);
199     FLAG_SET_DEFAULT(UseAES, false);
200   }
201 
202   if (UseAESCTRIntrinsics) {
203     warning(&quot;AES/CTR intrinsics are not available on this CPU&quot;);
204     FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
205   }
206 
207   if (UseFMA) {
208     warning(&quot;FMA instructions are not available on this CPU&quot;);
209     FLAG_SET_DEFAULT(UseFMA, false);
210   }
</pre>
<hr />
<pre>
253 
254 #ifdef COMPILER2
255   // C2 is only supported on v7+ VFP at this time
256   if (_arm_arch &lt; 7 || !has_vfp()) {
257     vm_exit_during_initialization(&quot;Server VM is only supported on ARMv7+ VFP&quot;);
258   }
259 #endif
260 
261   // ARM doesn&#39;t have special instructions for these but ldrex/ldrexd
262   // enable shorter instruction sequences that the ones based on cas.
263   _supports_atomic_getset4 = supports_ldrex();
264   _supports_atomic_getadd4 = supports_ldrex();
265   _supports_atomic_getset8 = supports_ldrexd();
266   _supports_atomic_getadd8 = supports_ldrexd();
267 
268 #ifdef COMPILER2
269   assert(_supports_cx8 &amp;&amp; _supports_atomic_getset4 &amp;&amp; _supports_atomic_getadd4
270          &amp;&amp; _supports_atomic_getset8 &amp;&amp; _supports_atomic_getadd8, &quot;C2: atomic operations must be supported&quot;);
271 #endif
272   char buf[512];
<span class="line-modified">273   jio_snprintf(buf, sizeof(buf), &quot;(ARMv%d)%s%s%s%s&quot;,</span>
274                _arm_arch,
275                (has_vfp() ? &quot;, vfp&quot; : &quot;&quot;),
276                (has_vfp3_32() ? &quot;, vfp3-32&quot; : &quot;&quot;),
<span class="line-modified">277                (has_simd() ? &quot;, simd&quot; : &quot;&quot;),</span>
<span class="line-added">278                (has_multiprocessing_extensions() ? &quot;, mp_ext&quot; : &quot;&quot;));</span>
279 
280   // buf is started with &quot;, &quot; or is empty
281   _features_string = os::strdup(buf);
282 
283   if (has_simd()) {
284     if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
285       FLAG_SET_DEFAULT(UsePopCountInstruction, true);
286     }
287   } else {
288     FLAG_SET_DEFAULT(UsePopCountInstruction, false);
289   }
290 
291   if (FLAG_IS_DEFAULT(AllocatePrefetchDistance)) {
292     FLAG_SET_DEFAULT(AllocatePrefetchDistance, 128);
293   }
294 
295 #ifdef COMPILER2
296   FLAG_SET_DEFAULT(UseFPUForSpilling, true);
297 
298   if (FLAG_IS_DEFAULT(MaxVectorSize)) {
299     // FLAG_SET_DEFAULT(MaxVectorSize, has_simd() ? 16 : 8);
300     // SIMD/NEON can use 16, but default is 8 because currently
301     // larger than 8 will disable instruction scheduling
302     FLAG_SET_DEFAULT(MaxVectorSize, 8);
<span class="line-modified">303   } else {</span>
<span class="line-modified">304     int max_vector_size = has_simd() ? 16 : 8;</span>
<span class="line-modified">305     if (MaxVectorSize &gt; max_vector_size) {</span>
<span class="line-modified">306       warning(&quot;MaxVectorSize must be at most %i on this platform&quot;, max_vector_size);</span>
<span class="line-added">307       FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);</span>
<span class="line-added">308     }</span>
309   }
310 #endif
311 
312   if (FLAG_IS_DEFAULT(Tier4CompileThreshold)) {
313     Tier4CompileThreshold = 10000;
314   }
315   if (FLAG_IS_DEFAULT(Tier3InvocationThreshold)) {
316     Tier3InvocationThreshold = 1000;
317   }
318   if (FLAG_IS_DEFAULT(Tier3CompileThreshold)) {
319     Tier3CompileThreshold = 5000;
320   }
321   if (FLAG_IS_DEFAULT(Tier3MinInvocationThreshold)) {
322     Tier3MinInvocationThreshold = 500;
323   }
324 
325   UNSUPPORTED_OPTION(TypeProfileLevel);
326   UNSUPPORTED_OPTION(CriticalJNINatives);
327 
328   FLAG_SET_DEFAULT(TypeProfileLevel, 0); // unsupported
</pre>
</td>
</tr>
</table>
<center><a href="vm_version_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_ext_arm.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
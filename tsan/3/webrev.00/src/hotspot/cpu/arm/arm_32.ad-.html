<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/arm/arm_32.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 //
  2 // Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
  3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 //
  5 // This code is free software; you can redistribute it and/or modify it
  6 // under the terms of the GNU General Public License version 2 only, as
  7 // published by the Free Software Foundation.
  8 //
  9 // This code is distributed in the hope that it will be useful, but WITHOUT
 10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12 // version 2 for more details (a copy is included in the LICENSE file that
 13 // accompanied this code).
 14 //
 15 // You should have received a copy of the GNU General Public License version
 16 // 2 along with this work; if not, write to the Free Software Foundation,
 17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18 //
 19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20 // or visit www.oracle.com if you need additional information or have any
 21 // questions.
 22 //
 23 
 24 // ARM Architecture Description File
 25 
 26 //----------REGISTER DEFINITION BLOCK------------------------------------------
 27 // This information is used by the matcher and the register allocator to
 28 // describe individual registers and classes of registers within the target
 29 // archtecture.
 30 register %{
 31 //----------Architecture Description Register Definitions----------------------
 32 // General Registers
 33 // &quot;reg_def&quot;  name ( register save type, C convention save type,
 34 //                   ideal register type, encoding, vm name );
 35 // Register Save Types:
 36 //
 37 // NS  = No-Save:       The register allocator assumes that these registers
 38 //                      can be used without saving upon entry to the method, &amp;
 39 //                      that they do not need to be saved at call sites.
 40 //
 41 // SOC = Save-On-Call:  The register allocator assumes that these registers
 42 //                      can be used without saving upon entry to the method,
 43 //                      but that they must be saved at call sites.
 44 //
 45 // SOE = Save-On-Entry: The register allocator assumes that these registers
 46 //                      must be saved before using them upon entry to the
 47 //                      method, but they do not need to be saved at call
 48 //                      sites.
 49 //
 50 // AS  = Always-Save:   The register allocator assumes that these registers
 51 //                      must be saved before using them upon entry to the
 52 //                      method, &amp; that they must be saved at call sites.
 53 //
 54 // Ideal Register Type is used to determine how to save &amp; restore a
 55 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
 56 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
 57 //
 58 // The encoding number is the actual bit-pattern placed into the opcodes.
 59 
 60 
 61 // ----------------------------
 62 // Integer/Long Registers
 63 // ----------------------------
 64 
 65 reg_def R_R0 (SOC, SOC, Op_RegI,  0,  R(0)-&gt;as_VMReg());
 66 reg_def R_R1 (SOC, SOC, Op_RegI,  1,  R(1)-&gt;as_VMReg());
 67 reg_def R_R2 (SOC, SOC, Op_RegI,  2,  R(2)-&gt;as_VMReg());
 68 reg_def R_R3 (SOC, SOC, Op_RegI,  3,  R(3)-&gt;as_VMReg());
 69 reg_def R_R4 (SOC, SOE, Op_RegI,  4,  R(4)-&gt;as_VMReg());
 70 reg_def R_R5 (SOC, SOE, Op_RegI,  5,  R(5)-&gt;as_VMReg());
 71 reg_def R_R6 (SOC, SOE, Op_RegI,  6,  R(6)-&gt;as_VMReg());
 72 reg_def R_R7 (SOC, SOE, Op_RegI,  7,  R(7)-&gt;as_VMReg());
 73 reg_def R_R8 (SOC, SOE, Op_RegI,  8,  R(8)-&gt;as_VMReg());
 74 reg_def R_R9 (SOC, SOE, Op_RegI,  9,  R(9)-&gt;as_VMReg());
 75 reg_def R_R10(NS,  SOE, Op_RegI, 10, R(10)-&gt;as_VMReg());
 76 reg_def R_R11(NS,  SOE, Op_RegI, 11, R(11)-&gt;as_VMReg());
 77 reg_def R_R12(SOC, SOC, Op_RegI, 12, R(12)-&gt;as_VMReg());
 78 reg_def R_R13(NS,  NS,  Op_RegI, 13, R(13)-&gt;as_VMReg());
 79 reg_def R_R14(SOC, SOC, Op_RegI, 14, R(14)-&gt;as_VMReg());
 80 reg_def R_R15(NS,  NS,  Op_RegI, 15, R(15)-&gt;as_VMReg());
 81 
 82 // ----------------------------
 83 // Float/Double Registers
 84 // ----------------------------
 85 
 86 // Float Registers
 87 
 88 reg_def R_S0 ( SOC, SOC, Op_RegF,  0, S0-&gt;as_VMReg());
 89 reg_def R_S1 ( SOC, SOC, Op_RegF,  1, S1_reg-&gt;as_VMReg());
 90 reg_def R_S2 ( SOC, SOC, Op_RegF,  2, S2_reg-&gt;as_VMReg());
 91 reg_def R_S3 ( SOC, SOC, Op_RegF,  3, S3_reg-&gt;as_VMReg());
 92 reg_def R_S4 ( SOC, SOC, Op_RegF,  4, S4_reg-&gt;as_VMReg());
 93 reg_def R_S5 ( SOC, SOC, Op_RegF,  5, S5_reg-&gt;as_VMReg());
 94 reg_def R_S6 ( SOC, SOC, Op_RegF,  6, S6_reg-&gt;as_VMReg());
 95 reg_def R_S7 ( SOC, SOC, Op_RegF,  7, S7-&gt;as_VMReg());
 96 reg_def R_S8 ( SOC, SOC, Op_RegF,  8, S8-&gt;as_VMReg());
 97 reg_def R_S9 ( SOC, SOC, Op_RegF,  9, S9-&gt;as_VMReg());
 98 reg_def R_S10( SOC, SOC, Op_RegF, 10,S10-&gt;as_VMReg());
 99 reg_def R_S11( SOC, SOC, Op_RegF, 11,S11-&gt;as_VMReg());
100 reg_def R_S12( SOC, SOC, Op_RegF, 12,S12-&gt;as_VMReg());
101 reg_def R_S13( SOC, SOC, Op_RegF, 13,S13-&gt;as_VMReg());
102 reg_def R_S14( SOC, SOC, Op_RegF, 14,S14-&gt;as_VMReg());
103 reg_def R_S15( SOC, SOC, Op_RegF, 15,S15-&gt;as_VMReg());
104 reg_def R_S16( SOC, SOE, Op_RegF, 16,S16-&gt;as_VMReg());
105 reg_def R_S17( SOC, SOE, Op_RegF, 17,S17-&gt;as_VMReg());
106 reg_def R_S18( SOC, SOE, Op_RegF, 18,S18-&gt;as_VMReg());
107 reg_def R_S19( SOC, SOE, Op_RegF, 19,S19-&gt;as_VMReg());
108 reg_def R_S20( SOC, SOE, Op_RegF, 20,S20-&gt;as_VMReg());
109 reg_def R_S21( SOC, SOE, Op_RegF, 21,S21-&gt;as_VMReg());
110 reg_def R_S22( SOC, SOE, Op_RegF, 22,S22-&gt;as_VMReg());
111 reg_def R_S23( SOC, SOE, Op_RegF, 23,S23-&gt;as_VMReg());
112 reg_def R_S24( SOC, SOE, Op_RegF, 24,S24-&gt;as_VMReg());
113 reg_def R_S25( SOC, SOE, Op_RegF, 25,S25-&gt;as_VMReg());
114 reg_def R_S26( SOC, SOE, Op_RegF, 26,S26-&gt;as_VMReg());
115 reg_def R_S27( SOC, SOE, Op_RegF, 27,S27-&gt;as_VMReg());
116 reg_def R_S28( SOC, SOE, Op_RegF, 28,S28-&gt;as_VMReg());
117 reg_def R_S29( SOC, SOE, Op_RegF, 29,S29-&gt;as_VMReg());
118 reg_def R_S30( SOC, SOE, Op_RegF, 30,S30-&gt;as_VMReg());
119 reg_def R_S31( SOC, SOE, Op_RegF, 31,S31-&gt;as_VMReg());
120 
121 // Double Registers
122 // The rules of ADL require that double registers be defined in pairs.
123 // Each pair must be two 32-bit values, but not necessarily a pair of
124 // single float registers.  In each pair, ADLC-assigned register numbers
125 // must be adjacent, with the lower number even.  Finally, when the
126 // CPU stores such a register pair to memory, the word associated with
127 // the lower ADLC-assigned number must be stored to the lower address.
128 
129 reg_def R_D16 (SOC, SOC, Op_RegD, 32, D16-&gt;as_VMReg());
130 reg_def R_D16x(SOC, SOC, Op_RegD,255, D16-&gt;as_VMReg()-&gt;next());
131 reg_def R_D17 (SOC, SOC, Op_RegD, 34, D17-&gt;as_VMReg());
132 reg_def R_D17x(SOC, SOC, Op_RegD,255, D17-&gt;as_VMReg()-&gt;next());
133 reg_def R_D18 (SOC, SOC, Op_RegD, 36, D18-&gt;as_VMReg());
134 reg_def R_D18x(SOC, SOC, Op_RegD,255, D18-&gt;as_VMReg()-&gt;next());
135 reg_def R_D19 (SOC, SOC, Op_RegD, 38, D19-&gt;as_VMReg());
136 reg_def R_D19x(SOC, SOC, Op_RegD,255, D19-&gt;as_VMReg()-&gt;next());
137 reg_def R_D20 (SOC, SOC, Op_RegD, 40, D20-&gt;as_VMReg());
138 reg_def R_D20x(SOC, SOC, Op_RegD,255, D20-&gt;as_VMReg()-&gt;next());
139 reg_def R_D21 (SOC, SOC, Op_RegD, 42, D21-&gt;as_VMReg());
140 reg_def R_D21x(SOC, SOC, Op_RegD,255, D21-&gt;as_VMReg()-&gt;next());
141 reg_def R_D22 (SOC, SOC, Op_RegD, 44, D22-&gt;as_VMReg());
142 reg_def R_D22x(SOC, SOC, Op_RegD,255, D22-&gt;as_VMReg()-&gt;next());
143 reg_def R_D23 (SOC, SOC, Op_RegD, 46, D23-&gt;as_VMReg());
144 reg_def R_D23x(SOC, SOC, Op_RegD,255, D23-&gt;as_VMReg()-&gt;next());
145 reg_def R_D24 (SOC, SOC, Op_RegD, 48, D24-&gt;as_VMReg());
146 reg_def R_D24x(SOC, SOC, Op_RegD,255, D24-&gt;as_VMReg()-&gt;next());
147 reg_def R_D25 (SOC, SOC, Op_RegD, 50, D25-&gt;as_VMReg());
148 reg_def R_D25x(SOC, SOC, Op_RegD,255, D25-&gt;as_VMReg()-&gt;next());
149 reg_def R_D26 (SOC, SOC, Op_RegD, 52, D26-&gt;as_VMReg());
150 reg_def R_D26x(SOC, SOC, Op_RegD,255, D26-&gt;as_VMReg()-&gt;next());
151 reg_def R_D27 (SOC, SOC, Op_RegD, 54, D27-&gt;as_VMReg());
152 reg_def R_D27x(SOC, SOC, Op_RegD,255, D27-&gt;as_VMReg()-&gt;next());
153 reg_def R_D28 (SOC, SOC, Op_RegD, 56, D28-&gt;as_VMReg());
154 reg_def R_D28x(SOC, SOC, Op_RegD,255, D28-&gt;as_VMReg()-&gt;next());
155 reg_def R_D29 (SOC, SOC, Op_RegD, 58, D29-&gt;as_VMReg());
156 reg_def R_D29x(SOC, SOC, Op_RegD,255, D29-&gt;as_VMReg()-&gt;next());
157 reg_def R_D30 (SOC, SOC, Op_RegD, 60, D30-&gt;as_VMReg());
158 reg_def R_D30x(SOC, SOC, Op_RegD,255, D30-&gt;as_VMReg()-&gt;next());
159 reg_def R_D31 (SOC, SOC, Op_RegD, 62, D31-&gt;as_VMReg());
160 reg_def R_D31x(SOC, SOC, Op_RegD,255, D31-&gt;as_VMReg()-&gt;next());
161 
162 // ----------------------------
163 // Special Registers
164 // Condition Codes Flag Registers
165 reg_def APSR (SOC, SOC,  Op_RegFlags, 0, VMRegImpl::Bad());
166 reg_def FPSCR(SOC, SOC,  Op_RegFlags, 0, VMRegImpl::Bad());
167 
168 // ----------------------------
169 // Specify the enum values for the registers.  These enums are only used by the
170 // OptoReg &quot;class&quot;. We can convert these enum values at will to VMReg when needed
171 // for visibility to the rest of the vm. The order of this enum influences the
172 // register allocator so having the freedom to set this order and not be stuck
173 // with the order that is natural for the rest of the vm is worth it.
174 
175 // registers in that order so that R11/R12 is an aligned pair that can be used for longs
176 alloc_class chunk0(
177                    R_R4, R_R5, R_R6, R_R7, R_R8, R_R9, R_R11, R_R12, R_R10, R_R13, R_R14, R_R15, R_R0, R_R1, R_R2, R_R3);
178 
179 // Note that a register is not allocatable unless it is also mentioned
180 // in a widely-used reg_class below.
181 
182 alloc_class chunk1(
183                    R_S16, R_S17, R_S18, R_S19, R_S20, R_S21, R_S22, R_S23,
184                    R_S24, R_S25, R_S26, R_S27, R_S28, R_S29, R_S30, R_S31,
185                    R_S0,  R_S1,  R_S2,  R_S3,  R_S4,  R_S5,  R_S6,  R_S7, 
186                    R_S8,  R_S9,  R_S10, R_S11, R_S12, R_S13, R_S14, R_S15,
187                    R_D16, R_D16x,R_D17, R_D17x,R_D18, R_D18x,R_D19, R_D19x, 
188                    R_D20, R_D20x,R_D21, R_D21x,R_D22, R_D22x,R_D23, R_D23x, 
189                    R_D24, R_D24x,R_D25, R_D25x,R_D26, R_D26x,R_D27, R_D27x, 
190                    R_D28, R_D28x,R_D29, R_D29x,R_D30, R_D30x,R_D31, R_D31x
191 );
192 
193 alloc_class chunk2(APSR, FPSCR);
194 
195 //----------Architecture Description Register Classes--------------------------
196 // Several register classes are automatically defined based upon information in
197 // this architecture description.
198 // 1) reg_class inline_cache_reg           ( as defined in frame section )
199 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
200 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
201 //
202 
203 // ----------------------------
204 // Integer Register Classes
205 // ----------------------------
206 // Exclusions from i_reg:
207 // SP (R13), PC (R15)
208 // R10: reserved by HotSpot to the TLS register (invariant within Java)
209 reg_class int_reg(R_R0, R_R1, R_R2, R_R3, R_R4, R_R5, R_R6, R_R7, R_R8, R_R9, R_R11, R_R12, R_R14);
210 
211 reg_class R0_regI(R_R0);
212 reg_class R1_regI(R_R1);
213 reg_class R2_regI(R_R2);
214 reg_class R3_regI(R_R3);
215 reg_class R12_regI(R_R12);
216 
217 // ----------------------------
218 // Pointer Register Classes
219 // ----------------------------
220 reg_class ptr_reg(R_R0, R_R1, R_R2, R_R3, R_R4, R_R5, R_R6, R_R7, R_R8, R_R9, R_R11, R_R12, R_R14);
221 // Special class for storeP instructions, which can store SP or RPC to TLS.
222 // It is also used for memory addressing, allowing direct TLS addressing.
223 reg_class sp_ptr_reg(R_R0, R_R1, R_R2, R_R3, R_R4, R_R5, R_R6, R_R7, R_R8, R_R9, R_R11, R_R12, R_R14, R_R10 /* TLS*/, R_R13 /* SP*/);
224 
225 #define R_Ricklass R_R8
226 #define R_Rmethod  R_R9
227 #define R_Rthread  R_R10
228 #define R_Rexception_obj R_R4
229 
230 // Other special pointer regs
231 reg_class R0_regP(R_R0);
232 reg_class R1_regP(R_R1);
233 reg_class R2_regP(R_R2);
234 reg_class R4_regP(R_R4);
235 reg_class Rexception_regP(R_Rexception_obj);
236 reg_class Ricklass_regP(R_Ricklass);
237 reg_class Rmethod_regP(R_Rmethod);
238 reg_class Rthread_regP(R_Rthread);
239 reg_class IP_regP(R_R12);
240 reg_class LR_regP(R_R14);
241 
242 reg_class FP_regP(R_R11);
243 
244 // ----------------------------
245 // Long Register Classes
246 // ----------------------------
247 reg_class long_reg (             R_R0,R_R1, R_R2,R_R3, R_R4,R_R5, R_R6,R_R7, R_R8,R_R9, R_R11,R_R12);
248 // for ldrexd, strexd: first reg of pair must be even
249 reg_class long_reg_align (       R_R0,R_R1, R_R2,R_R3, R_R4,R_R5, R_R6,R_R7, R_R8,R_R9);
250 
251 reg_class R0R1_regL(R_R0,R_R1);
252 reg_class R2R3_regL(R_R2,R_R3);
253 
254 // ----------------------------
255 // Special Class for Condition Code Flags Register
256 reg_class int_flags(APSR);
257 reg_class float_flags(FPSCR);
258 
259 
260 // ----------------------------
261 // Float Point Register Classes
262 // ----------------------------
263 // Skip S14/S15, they are reserved for mem-mem copies
264 reg_class sflt_reg(R_S0, R_S1, R_S2, R_S3, R_S4, R_S5, R_S6, R_S7, R_S8, R_S9, R_S10, R_S11, R_S12, R_S13,
265                    R_S16, R_S17, R_S18, R_S19, R_S20, R_S21, R_S22, R_S23, R_S24, R_S25, R_S26, R_S27, R_S28, R_S29, R_S30, R_S31);
266 
267 // Paired floating point registers--they show up in the same order as the floats,
268 // but they are used with the &quot;Op_RegD&quot; type, and always occur in even/odd pairs.
269 reg_class dflt_reg(R_S0,R_S1, R_S2,R_S3, R_S4,R_S5, R_S6,R_S7, R_S8,R_S9, R_S10,R_S11, R_S12,R_S13,
270                    R_S16,R_S17, R_S18,R_S19, R_S20,R_S21, R_S22,R_S23, R_S24,R_S25, R_S26,R_S27, R_S28,R_S29, R_S30,R_S31,
271                    R_D16,R_D16x, R_D17,R_D17x, R_D18,R_D18x, R_D19,R_D19x, R_D20,R_D20x, R_D21,R_D21x, R_D22,R_D22x,
272                    R_D23,R_D23x, R_D24,R_D24x, R_D25,R_D25x, R_D26,R_D26x, R_D27,R_D27x, R_D28,R_D28x, R_D29,R_D29x,
273                    R_D30,R_D30x, R_D31,R_D31x);
274 
275 reg_class dflt_low_reg(R_S0,R_S1, R_S2,R_S3, R_S4,R_S5, R_S6,R_S7, R_S8,R_S9, R_S10,R_S11, R_S12,R_S13,
276                        R_S16,R_S17, R_S18,R_S19, R_S20,R_S21, R_S22,R_S23, R_S24,R_S25, R_S26,R_S27, R_S28,R_S29, R_S30,R_S31);
277 
278 
279 reg_class actual_dflt_reg %{
280   if (VM_Version::has_vfp3_32()) {
281     return DFLT_REG_mask();
282   } else {
283     return DFLT_LOW_REG_mask();
284   }
285 %}
286 
287 reg_class S0_regF(R_S0);
288 reg_class D0_regD(R_S0,R_S1);
289 reg_class D1_regD(R_S2,R_S3);
290 reg_class D2_regD(R_S4,R_S5);
291 reg_class D3_regD(R_S6,R_S7);
292 reg_class D4_regD(R_S8,R_S9);
293 reg_class D5_regD(R_S10,R_S11);
294 reg_class D6_regD(R_S12,R_S13);
295 reg_class D7_regD(R_S14,R_S15);
296 
297 reg_class D16_regD(R_D16,R_D16x);
298 reg_class D17_regD(R_D17,R_D17x);
299 reg_class D18_regD(R_D18,R_D18x);
300 reg_class D19_regD(R_D19,R_D19x);
301 reg_class D20_regD(R_D20,R_D20x);
302 reg_class D21_regD(R_D21,R_D21x);
303 reg_class D22_regD(R_D22,R_D22x);
304 reg_class D23_regD(R_D23,R_D23x);
305 reg_class D24_regD(R_D24,R_D24x);
306 reg_class D25_regD(R_D25,R_D25x);
307 reg_class D26_regD(R_D26,R_D26x);
308 reg_class D27_regD(R_D27,R_D27x);
309 reg_class D28_regD(R_D28,R_D28x);
310 reg_class D29_regD(R_D29,R_D29x);
311 reg_class D30_regD(R_D30,R_D30x);
312 reg_class D31_regD(R_D31,R_D31x);
313 
314 reg_class vectorx_reg(R_S0,R_S1,R_S2,R_S3, R_S4,R_S5,R_S6,R_S7,
315                       R_S8,R_S9,R_S10,R_S11, /* skip S14/S15 */
316                       R_S16,R_S17,R_S18,R_S19, R_S20,R_S21,R_S22,R_S23,
317                       R_S24,R_S25,R_S26,R_S27, R_S28,R_S29,R_S30,R_S31,
318                       R_D16,R_D16x,R_D17,R_D17x, R_D18,R_D18x,R_D19,R_D19x,
319                       R_D20,R_D20x,R_D21,R_D21x, R_D22,R_D22x,R_D23,R_D23x,
320                       R_D24,R_D24x,R_D25,R_D25x, R_D26,R_D26x,R_D27,R_D27x,
321                       R_D28,R_D28x,R_D29,R_D29x, R_D30,R_D30x,R_D31,R_D31x);
322 
323 %}
324 
325 source_hpp %{
326 // FIXME
327 const MachRegisterNumbers R_mem_copy_lo_num = R_S14_num;
328 const MachRegisterNumbers R_mem_copy_hi_num = R_S15_num;
329 const FloatRegister Rmemcopy = S14;
330 const MachRegisterNumbers R_hf_ret_lo_num = R_S0_num;
331 const MachRegisterNumbers R_hf_ret_hi_num = R_S1_num;
332 
333 const MachRegisterNumbers R_Ricklass_num = R_R8_num;
334 const MachRegisterNumbers R_Rmethod_num  = R_R9_num;
335 
336 #define LDR_DOUBLE &quot;FLDD&quot;
337 #define LDR_FLOAT  &quot;FLDS&quot;
338 #define STR_DOUBLE &quot;FSTD&quot;
339 #define STR_FLOAT  &quot;FSTS&quot;
340 #define LDR_64     &quot;LDRD&quot;
341 #define STR_64     &quot;STRD&quot;
342 #define LDR_32     &quot;LDR&quot;
343 #define STR_32     &quot;STR&quot;
344 #define MOV_DOUBLE &quot;FCPYD&quot;
345 #define MOV_FLOAT  &quot;FCPYS&quot;
346 #define FMSR       &quot;FMSR&quot;
347 #define FMRS       &quot;FMRS&quot;
348 #define LDREX      &quot;ldrex &quot;
349 #define STREX      &quot;strex &quot;
350 
351 #define str_64     strd
352 #define ldr_64     ldrd
353 #define ldr_32     ldr
354 #define ldrex      ldrex
355 #define strex      strex
356 
357 static inline bool is_memoryD(int offset) {
358   return offset &lt; 1024 &amp;&amp; offset &gt; -1024;
359 }
360 
361 static inline bool is_memoryfp(int offset) {
362   return offset &lt; 1024 &amp;&amp; offset &gt; -1024;
363 }
364 
365 static inline bool is_memoryI(int offset) {
366   return offset &lt; 4096 &amp;&amp; offset &gt; -4096;
367 }
368 
369 static inline bool is_memoryP(int offset) {
370   return offset &lt; 4096 &amp;&amp; offset &gt; -4096;
371 }
372 
373 static inline bool is_memoryHD(int offset) {
374   return offset &lt; 256 &amp;&amp; offset &gt; -256;
375 }
376 
377 static inline bool is_aimm(int imm) {
378   return AsmOperand::is_rotated_imm(imm);
379 }
380 
381 static inline bool is_limmI(jint imm) {
382   return AsmOperand::is_rotated_imm(imm);
383 }
384 
385 static inline bool is_limmI_low(jint imm, int n) {
386   int imml = imm &amp; right_n_bits(n);
387   return is_limmI(imml) || is_limmI(imm);
388 }
389 
390 static inline int limmI_low(jint imm, int n) {
391   int imml = imm &amp; right_n_bits(n);
392   return is_limmI(imml) ? imml : imm;
393 }
394 
395 %}
396 
397 source %{
398 
399 // Given a register encoding, produce a Integer Register object
400 static Register reg_to_register_object(int register_encoding) {
401   assert(R0-&gt;encoding() == R_R0_enc &amp;&amp; R15-&gt;encoding() == R_R15_enc, &quot;right coding&quot;);
402   return as_Register(register_encoding);
403 }
404 
405 // Given a register encoding, produce a single-precision Float Register object
406 static FloatRegister reg_to_FloatRegister_object(int register_encoding) {
407   assert(S0-&gt;encoding() == R_S0_enc &amp;&amp; S31-&gt;encoding() == R_S31_enc, &quot;right coding&quot;);
408   return as_FloatRegister(register_encoding);
409 }
410 
411 void Compile::pd_compiler2_init() {
412   // Umimplemented
413 }
414 
415 // Location of compiled Java return values.  Same as C
416 OptoRegPair c2::return_value(int ideal_reg) {
417   assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
418 #ifndef __ABI_HARD__
419   static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, R_R0_num,     R_R0_num,     R_R0_num,     R_R0_num, R_R0_num };
420   static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_R1_num, R_R1_num };
421 #else
422   static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, R_R0_num,     R_R0_num,     R_hf_ret_lo_num,  R_hf_ret_lo_num, R_R0_num };
423   static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad,     R_hf_ret_hi_num, R_R1_num };
424 #endif
425   return OptoRegPair( hi[ideal_reg], lo[ideal_reg]);
426 }
427 
428 // !!!!! Special hack to get all type of calls to specify the byte offset
429 //       from the start of the call to the point where the return address
430 //       will point.
431 
432 int MachCallStaticJavaNode::ret_addr_offset() {
433   bool far = (_method == NULL) ? maybe_far_call(this) : !cache_reachable();
434   return ((far ? 3 : 1) + (_method_handle_invoke ? 1 : 0)) *
435     NativeInstruction::instruction_size;
436 }
437 
438 int MachCallDynamicJavaNode::ret_addr_offset() {
439   bool far = !cache_reachable();
440   // mov_oop is always 2 words
441   return (2 + (far ? 3 : 1)) * NativeInstruction::instruction_size; 
442 }
443 
444 int MachCallRuntimeNode::ret_addr_offset() {
445   // bl or movw; movt; blx
446   bool far = maybe_far_call(this);
447   return (far ? 3 : 1) * NativeInstruction::instruction_size;
448 }
449 %}
450 
451 // The intptr_t operand types, defined by textual substitution.
452 // (Cf. opto/type.hpp.  This lets us avoid many, many other ifdefs.)
453 #define immX      immI
454 #define immXRot   immIRot
455 #define iRegX     iRegI
456 #define aimmX     aimmI
457 #define limmX     limmI
458 #define immX10x2  immI10x2
459 #define LShiftX   LShiftI
460 #define shimmX    immU5
461 
462 // Compatibility interface
463 #define aimmP     immPRot
464 #define immIMov   immIRot
465 
466 #define store_RegL     iRegL
467 #define store_RegLd    iRegLd
468 #define store_RegI     iRegI
469 #define store_ptr_RegP iRegP
470 
471 //----------ATTRIBUTES---------------------------------------------------------
472 //----------Operand Attributes-------------------------------------------------
473 op_attrib op_cost(1);          // Required cost attribute
474 
475 //----------OPERANDS-----------------------------------------------------------
476 // Operand definitions must precede instruction definitions for correct parsing
477 // in the ADLC because operands constitute user defined types which are used in
478 // instruction definitions.
479 
480 //----------Simple Operands----------------------------------------------------
481 // Immediate Operands
482 
483 operand immIRot() %{
484   predicate(AsmOperand::is_rotated_imm(n-&gt;get_int()));
485   match(ConI);
486 
487   op_cost(0);
488   // formats are generated automatically for constants and base registers
489   format %{ %}
490   interface(CONST_INTER);
491 %}
492 
493 operand immIRotn() %{
494   predicate(n-&gt;get_int() != 0 &amp;&amp; AsmOperand::is_rotated_imm(~n-&gt;get_int()));
495   match(ConI);
496 
497   op_cost(0);
498   // formats are generated automatically for constants and base registers
499   format %{ %}
500   interface(CONST_INTER);
501 %}
502 
503 operand immIRotneg() %{
504   // if AsmOperand::is_rotated_imm() is true for this constant, it is
505   // a immIRot and an optimal instruction combination exists to handle the
506   // constant as an immIRot
507   predicate(!AsmOperand::is_rotated_imm(n-&gt;get_int()) &amp;&amp; AsmOperand::is_rotated_imm(-n-&gt;get_int()));
508   match(ConI);
509 
510   op_cost(0);
511   // formats are generated automatically for constants and base registers
512   format %{ %}
513   interface(CONST_INTER);
514 %}
515 
516 // Non-negative integer immediate that is encodable using the rotation scheme,
517 // and that when expanded fits in 31 bits.
518 operand immU31Rot() %{
519   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; AsmOperand::is_rotated_imm(n-&gt;get_int()));
520   match(ConI);
521 
522   op_cost(0);
523   // formats are generated automatically for constants and base registers
524   format %{ %}
525   interface(CONST_INTER);
526 %}
527 
528 operand immPRot() %{
529   predicate(n-&gt;get_ptr() == 0 || (AsmOperand::is_rotated_imm(n-&gt;get_ptr()) &amp;&amp; ((ConPNode*)n)-&gt;type()-&gt;reloc() == relocInfo::none));
530 
531   match(ConP);
532 
533   op_cost(0);
534   // formats are generated automatically for constants and base registers
535   format %{ %}
536   interface(CONST_INTER);
537 %}
538 
539 operand immLlowRot() %{
540   predicate(n-&gt;get_long() &gt;&gt; 32 == 0 &amp;&amp; AsmOperand::is_rotated_imm((int)n-&gt;get_long()));
541   match(ConL);
542   op_cost(0);
543 
544   format %{ %}
545   interface(CONST_INTER);
546 %}
547 
548 operand immLRot2() %{
549   predicate(AsmOperand::is_rotated_imm((int)(n-&gt;get_long() &gt;&gt; 32)) &amp;&amp;
550             AsmOperand::is_rotated_imm((int)(n-&gt;get_long())));
551   match(ConL);
552   op_cost(0);
553 
554   format %{ %}
555   interface(CONST_INTER);
556 %}
557 
558 // Integer Immediate: 12-bit - for addressing mode
559 operand immI12() %{
560   predicate((-4096 &lt; n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 4096));
561   match(ConI);
562   op_cost(0);
563 
564   format %{ %}
565   interface(CONST_INTER);
566 %}
567 
568 // Integer Immediate: 10-bit disp and disp+4 - for addressing float pair
569 operand immI10x2() %{
570   predicate((-1024 &lt; n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 1024 - 4));
571   match(ConI);
572   op_cost(0);
573 
574   format %{ %}
575   interface(CONST_INTER);
576 %}
577 
578 // Integer Immediate: 12-bit disp and disp+4 - for addressing word pair
579 operand immI12x2() %{
580   predicate((-4096 &lt; n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 4096 - 4));
581   match(ConI);
582   op_cost(0);
583 
584   format %{ %}
585   interface(CONST_INTER);
586 %}
    </pre>
  </body>
</html>
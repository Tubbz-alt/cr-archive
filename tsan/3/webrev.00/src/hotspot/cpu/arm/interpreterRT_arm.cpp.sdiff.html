<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/interpreterRT_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniFastGetField_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/interpreterRT_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.inline.hpp&quot;
 27 #include &quot;interpreter/interp_masm.hpp&quot;
 28 #include &quot;interpreter/interpreter.hpp&quot;
 29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-removed"> 31 #include &quot;memory/universe.hpp&quot;</span>
 32 #include &quot;oops/method.hpp&quot;
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/icache.hpp&quot;
 36 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 37 #include &quot;runtime/signature.hpp&quot;
 38 
 39 #define __ _masm-&gt;
 40 
 41 InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 42     const methodHandle&amp; method, CodeBuffer* buffer) : NativeSignatureIterator(method) {
 43   _masm = new MacroAssembler(buffer);
 44   _abi_offset = 0;
 45   _ireg = is_static() ? 2 : 1;
 46 #ifdef __ABI_HARD__
 47   _fp_slot = 0;
 48   _single_fpr_slot = 0;
 49 #endif
 50 }
 51 
 52 #ifdef SHARING_FAST_NATIVE_FINGERPRINTS
 53 // mapping from SignatureIterator param to (common) type of parsing
<span class="line-modified"> 54 static const u1 shared_type[] = {</span>
<span class="line-modified"> 55   (u1) SignatureIterator::int_parm, // bool</span>
<span class="line-modified"> 56   (u1) SignatureIterator::int_parm, // byte</span>
<span class="line-removed"> 57   (u1) SignatureIterator::int_parm, // char</span>
<span class="line-removed"> 58   (u1) SignatureIterator::int_parm, // short</span>
<span class="line-removed"> 59   (u1) SignatureIterator::int_parm, // int</span>
<span class="line-removed"> 60   (u1) SignatureIterator::long_parm, // long</span>
 61 #ifndef __ABI_HARD__
<span class="line-modified"> 62   (u1) SignatureIterator::int_parm, // float, passed as int</span>
<span class="line-modified"> 63   (u1) SignatureIterator::long_parm, // double, passed as long</span>
 64 #else
<span class="line-modified"> 65   (u1) SignatureIterator::float_parm, // float</span>
<span class="line-modified"> 66   (u1) SignatureIterator::double_parm, // double</span>
 67 #endif
<span class="line-modified"> 68   (u1) SignatureIterator::obj_parm, // obj</span>
<span class="line-modified"> 69   (u1) SignatureIterator::done_parm // done</span>




 70 };
 71 
 72 uint64_t InterpreterRuntime::normalize_fast_native_fingerprint(uint64_t fingerprint) {
 73   if (fingerprint == UCONST64(-1)) {
 74     // special signature used when the argument list cannot be encoded in a 64 bits value
 75     return fingerprint;
 76   }
<span class="line-modified"> 77   int shift = SignatureIterator::static_feature_size;</span>
<span class="line-modified"> 78   uint64_t result = fingerprint &amp; ((1 &lt;&lt; shift) - 1);</span>
<span class="line-removed"> 79   fingerprint &gt;&gt;= shift;</span>
 80 
<span class="line-modified"> 81   BasicType ret_type = (BasicType) (fingerprint &amp; SignatureIterator::result_feature_mask);</span>
 82   // For ARM, the fast signature handler only needs to know whether
 83   // the return value must be unboxed. T_OBJECT and T_ARRAY need not
 84   // be distinguished from each other and all other return values
 85   // behave like integers with respect to the handler except T_BOOLEAN
 86   // which must be mapped to the range 0..1.
<span class="line-modified"> 87   bool unbox = (ret_type == T_OBJECT) || (ret_type == T_ARRAY);</span>
<span class="line-removed"> 88   if (unbox) {</span>
 89     ret_type = T_OBJECT;
 90   } else if (ret_type != T_BOOLEAN) {
 91     ret_type = T_INT;
 92   }
<span class="line-modified"> 93   result |= ((uint64_t) ret_type) &lt;&lt; shift;</span>
<span class="line-modified"> 94   shift += SignatureIterator::result_feature_size;</span>
<span class="line-removed"> 95   fingerprint &gt;&gt;= SignatureIterator::result_feature_size;</span>
 96 

 97   while (true) {
<span class="line-modified"> 98     uint32_t type = (uint32_t) (fingerprint &amp; SignatureIterator::parameter_feature_mask);</span>
<span class="line-modified"> 99     if (type == SignatureIterator::done_parm) {</span>
<span class="line-removed">100       result |= ((uint64_t) SignatureIterator::done_parm) &lt;&lt; shift;</span>
101       return result;
102     }
<span class="line-modified">103     assert((type &gt;= SignatureIterator::bool_parm) &amp;&amp; (type &lt;= SignatureIterator::obj_parm), &quot;check fingerprint encoding&quot;);</span>
<span class="line-modified">104     int shared = shared_type[type - SignatureIterator::bool_parm];</span>
<span class="line-modified">105     result |= ((uint64_t) shared) &lt;&lt; shift;</span>
<span class="line-modified">106     shift += SignatureIterator::parameter_feature_size;</span>
<span class="line-removed">107     fingerprint &gt;&gt;= SignatureIterator::parameter_feature_size;</span>
108   }
109 }
110 #endif // SHARING_FAST_NATIVE_FINGERPRINTS
111 
112 // Implementation of SignatureHandlerGenerator
113 void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
114   if (_ireg &lt; GPR_PARAMS) {
115     Register dst = as_Register(_ireg);
116     __ ldr_s32(dst, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
117     _ireg++;
118   } else {
119     __ ldr_s32(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
120     __ str_32(Rtemp, Address(SP, _abi_offset * wordSize));
121     _abi_offset++;
122   }
123 }
124 
125 void InterpreterRuntime::SignatureHandlerGenerator::pass_long() {
126   if (_ireg &lt;= 2) {
127 #if (ALIGN_WIDE_ARGUMENTS == 1)
</pre>
<hr />
<pre>
206 
207 void InterpreterRuntime::SignatureHandlerGenerator::pass_double() {
208     if(_fp_slot &lt;= 14) {
209       __ fldd(as_FloatRegister(_fp_slot), Address(Rlocals, Interpreter::local_offset_in_bytes(offset()+1)));
210       _fp_slot += 2;
211     } else {
212       __ ldr(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset()+1)));
213       __ str(Rtemp, Address(SP, (_abi_offset) * wordSize));
214       __ ldr(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
215       __ str(Rtemp, Address(SP, (_abi_offset+1) * wordSize));
216       _abi_offset += 2;
217       _single_fpr_slot = 16;
218     }
219 }
220 #endif // __SOFTFP__
221 #endif // __ABI_HARD__
222 
223 void InterpreterRuntime::SignatureHandlerGenerator::generate(uint64_t fingerprint) {
224   iterate(fingerprint);
225 
<span class="line-modified">226   BasicType result_type = SignatureIterator::return_type(fingerprint);</span>
227 
228   address result_handler = Interpreter::result_handler(result_type);
229 
230   __ mov_slow(R0, (intptr_t)result_handler);
231 
232   __ ret();
233 }
234 
235 
236 // Implementation of SignatureHandlerLibrary
237 
238 void SignatureHandlerLibrary::pd_set_handler(address handler) {}
239 
240 class SlowSignatureHandler: public NativeSignatureIterator {
241  private:
242   address   _from;
243   intptr_t* _to;
244 
245 #ifndef __ABI_HARD__
246   virtual void pass_int() {
</pre>
<hr />
<pre>
352 #endif // !__ABI_HARD__
353 
354  public:
355   SlowSignatureHandler(const methodHandle&amp; method, address from, intptr_t* to) :
356     NativeSignatureIterator(method) {
357     _from = from;
358 
359 #ifdef __ABI_HARD__
360     _toGP  = to;
361     _toFP = _toGP + GPR_PARAMS;
362     _to   = _toFP + (8*2);
363     _last_gp = (is_static() ? 2 : 1);
364     _last_fp = 0;
365     _last_single_fp = 0;
366 #else
367     _to   = to + (is_static() ? 2 : 1);
368 #endif // __ABI_HARD__
369   }
370 };
371 
<span class="line-modified">372 IRT_ENTRY(address, InterpreterRuntime::slow_signature_handler(JavaThread* thread, Method* method, intptr_t* from, intptr_t* to))</span>
373   methodHandle m(thread, (Method*)method);
374   assert(m-&gt;is_native(), &quot;sanity check&quot;);
375   SlowSignatureHandler(m, (address)from, to).iterate(UCONST64(-1));
376   return Interpreter::result_handler(m-&gt;result_type());
<span class="line-modified">377 IRT_END</span>
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.inline.hpp&quot;
 27 #include &quot;interpreter/interp_masm.hpp&quot;
 28 #include &quot;interpreter/interpreter.hpp&quot;
 29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;

 31 #include &quot;oops/method.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/icache.hpp&quot;
 35 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 36 #include &quot;runtime/signature.hpp&quot;
 37 
 38 #define __ _masm-&gt;
 39 
 40 InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 41     const methodHandle&amp; method, CodeBuffer* buffer) : NativeSignatureIterator(method) {
 42   _masm = new MacroAssembler(buffer);
 43   _abi_offset = 0;
 44   _ireg = is_static() ? 2 : 1;
 45 #ifdef __ABI_HARD__
 46   _fp_slot = 0;
 47   _single_fpr_slot = 0;
 48 #endif
 49 }
 50 
 51 #ifdef SHARING_FAST_NATIVE_FINGERPRINTS
 52 // mapping from SignatureIterator param to (common) type of parsing
<span class="line-modified"> 53 static const BasicType shared_type[] = {</span>
<span class="line-modified"> 54   T_INT,    // bool</span>
<span class="line-modified"> 55   T_INT,    // char</span>




 56 #ifndef __ABI_HARD__
<span class="line-modified"> 57   T_INT,    // float, passed as int</span>
<span class="line-modified"> 58   T_LONG,   // double, passed as long</span>
 59 #else
<span class="line-modified"> 60   T_FLOAT,  // float</span>
<span class="line-modified"> 61   T_DOUBLE, // double</span>
 62 #endif
<span class="line-modified"> 63   T_INT,    // byte</span>
<span class="line-modified"> 64   T_INT,    // short</span>
<span class="line-added"> 65   T_INT,    // int</span>
<span class="line-added"> 66   T_LONG,   // long</span>
<span class="line-added"> 67   T_OBJECT, // obj</span>
<span class="line-added"> 68   T_OBJECT, // array</span>
 69 };
 70 
 71 uint64_t InterpreterRuntime::normalize_fast_native_fingerprint(uint64_t fingerprint) {
 72   if (fingerprint == UCONST64(-1)) {
 73     // special signature used when the argument list cannot be encoded in a 64 bits value
 74     return fingerprint;
 75   }
<span class="line-modified"> 76   int shift = SignatureIterator::fp_static_feature_size;</span>
<span class="line-modified"> 77   SignatureIterator::fingerprint_t result = fingerprint &amp; ((1 &lt;&lt; shift) - 1);</span>

 78 
<span class="line-modified"> 79   BasicType ret_type = SignatureIterator::fp_return_type(fingerprint);</span>
 80   // For ARM, the fast signature handler only needs to know whether
 81   // the return value must be unboxed. T_OBJECT and T_ARRAY need not
 82   // be distinguished from each other and all other return values
 83   // behave like integers with respect to the handler except T_BOOLEAN
 84   // which must be mapped to the range 0..1.
<span class="line-modified"> 85   if (is_reference_type(ret_type)) {</span>

 86     ret_type = T_OBJECT;
 87   } else if (ret_type != T_BOOLEAN) {
 88     ret_type = T_INT;
 89   }
<span class="line-modified"> 90   result |= ((SignatureIterator::fingerprint_t) ret_type) &lt;&lt; shift;</span>
<span class="line-modified"> 91   shift += SignatureIterator::fp_result_feature_size;</span>

 92 
<span class="line-added"> 93   SignatureIterator::fingerprint_t unaccumulator = SignatureIterator::fp_start_parameters(fingerprint);</span>
 94   while (true) {
<span class="line-modified"> 95     BasicType type = SignatureIterator::fp_next_parameter(unaccumulator);</span>
<span class="line-modified"> 96     if (type == (BasicType)SignatureIterator::fp_parameters_done) {</span>

 97       return result;
 98     }
<span class="line-modified"> 99     assert(SignatureIterator::fp_is_valid_type(type), &quot;garbled fingerprint&quot;);</span>
<span class="line-modified">100     BasicType shared = shared_type[type - T_BOOLEAN];</span>
<span class="line-modified">101     result |= ((SignatureIterator::fingerprint_t) shared) &lt;&lt; shift;</span>
<span class="line-modified">102     shift += SignatureIterator::fp_parameter_feature_size;</span>

103   }
104 }
105 #endif // SHARING_FAST_NATIVE_FINGERPRINTS
106 
107 // Implementation of SignatureHandlerGenerator
108 void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
109   if (_ireg &lt; GPR_PARAMS) {
110     Register dst = as_Register(_ireg);
111     __ ldr_s32(dst, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
112     _ireg++;
113   } else {
114     __ ldr_s32(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
115     __ str_32(Rtemp, Address(SP, _abi_offset * wordSize));
116     _abi_offset++;
117   }
118 }
119 
120 void InterpreterRuntime::SignatureHandlerGenerator::pass_long() {
121   if (_ireg &lt;= 2) {
122 #if (ALIGN_WIDE_ARGUMENTS == 1)
</pre>
<hr />
<pre>
201 
202 void InterpreterRuntime::SignatureHandlerGenerator::pass_double() {
203     if(_fp_slot &lt;= 14) {
204       __ fldd(as_FloatRegister(_fp_slot), Address(Rlocals, Interpreter::local_offset_in_bytes(offset()+1)));
205       _fp_slot += 2;
206     } else {
207       __ ldr(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset()+1)));
208       __ str(Rtemp, Address(SP, (_abi_offset) * wordSize));
209       __ ldr(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
210       __ str(Rtemp, Address(SP, (_abi_offset+1) * wordSize));
211       _abi_offset += 2;
212       _single_fpr_slot = 16;
213     }
214 }
215 #endif // __SOFTFP__
216 #endif // __ABI_HARD__
217 
218 void InterpreterRuntime::SignatureHandlerGenerator::generate(uint64_t fingerprint) {
219   iterate(fingerprint);
220 
<span class="line-modified">221   BasicType result_type = SignatureIterator::fp_return_type(fingerprint);</span>
222 
223   address result_handler = Interpreter::result_handler(result_type);
224 
225   __ mov_slow(R0, (intptr_t)result_handler);
226 
227   __ ret();
228 }
229 
230 
231 // Implementation of SignatureHandlerLibrary
232 
233 void SignatureHandlerLibrary::pd_set_handler(address handler) {}
234 
235 class SlowSignatureHandler: public NativeSignatureIterator {
236  private:
237   address   _from;
238   intptr_t* _to;
239 
240 #ifndef __ABI_HARD__
241   virtual void pass_int() {
</pre>
<hr />
<pre>
347 #endif // !__ABI_HARD__
348 
349  public:
350   SlowSignatureHandler(const methodHandle&amp; method, address from, intptr_t* to) :
351     NativeSignatureIterator(method) {
352     _from = from;
353 
354 #ifdef __ABI_HARD__
355     _toGP  = to;
356     _toFP = _toGP + GPR_PARAMS;
357     _to   = _toFP + (8*2);
358     _last_gp = (is_static() ? 2 : 1);
359     _last_fp = 0;
360     _last_single_fp = 0;
361 #else
362     _to   = to + (is_static() ? 2 : 1);
363 #endif // __ABI_HARD__
364   }
365 };
366 
<span class="line-modified">367 JRT_ENTRY(address, InterpreterRuntime::slow_signature_handler(JavaThread* thread, Method* method, intptr_t* from, intptr_t* to))</span>
368   methodHandle m(thread, (Method*)method);
369   assert(m-&gt;is_native(), &quot;sanity check&quot;);
370   SlowSignatureHandler(m, (address)from, to).iterate(UCONST64(-1));
371   return Interpreter::result_handler(m-&gt;result_type());
<span class="line-modified">372 JRT_END</span>
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniFastGetField_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
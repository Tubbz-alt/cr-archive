<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/arm/c1_FrameMap_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;c1/c1_FrameMap.hpp&quot;
 27 #include &quot;c1/c1_LIR.hpp&quot;
 28 #include &quot;runtime/sharedRuntime.hpp&quot;
 29 #include &quot;vmreg_arm.inline.hpp&quot;
 30 
 31 LIR_Opr FrameMap::R0_opr;
 32 LIR_Opr FrameMap::R1_opr;
 33 LIR_Opr FrameMap::R2_opr;
 34 LIR_Opr FrameMap::R3_opr;
 35 LIR_Opr FrameMap::R4_opr;
 36 LIR_Opr FrameMap::R5_opr;
 37 
 38 LIR_Opr FrameMap::R0_oop_opr;
 39 LIR_Opr FrameMap::R1_oop_opr;
 40 LIR_Opr FrameMap::R2_oop_opr;
 41 LIR_Opr FrameMap::R3_oop_opr;
 42 LIR_Opr FrameMap::R4_oop_opr;
 43 LIR_Opr FrameMap::R5_oop_opr;
 44 
 45 LIR_Opr FrameMap::R0_metadata_opr;
 46 LIR_Opr FrameMap::R1_metadata_opr;
 47 LIR_Opr FrameMap::R2_metadata_opr;
 48 LIR_Opr FrameMap::R3_metadata_opr;
 49 LIR_Opr FrameMap::R4_metadata_opr;
 50 LIR_Opr FrameMap::R5_metadata_opr;
 51 
 52 
 53 LIR_Opr FrameMap::LR_opr;
 54 LIR_Opr FrameMap::LR_oop_opr;
 55 LIR_Opr FrameMap::LR_ptr_opr;
 56 LIR_Opr FrameMap::FP_opr;
 57 LIR_Opr FrameMap::SP_opr;
 58 LIR_Opr FrameMap::Rthread_opr;
 59 
 60 LIR_Opr FrameMap::Int_result_opr;
 61 LIR_Opr FrameMap::Long_result_opr;
 62 LIR_Opr FrameMap::Object_result_opr;
 63 LIR_Opr FrameMap::Float_result_opr;
 64 LIR_Opr FrameMap::Double_result_opr;
 65 
 66 LIR_Opr FrameMap::Exception_oop_opr;
 67 LIR_Opr FrameMap::Exception_pc_opr;
 68 
 69 LIR_Opr FrameMap::_caller_save_cpu_regs[] = { 0 };
 70 LIR_Opr FrameMap::_caller_save_fpu_regs[];  // same as initialize to zero
 71 
 72 LIR_Opr FrameMap::map_to_opr(BasicType type, VMRegPair* reg, bool) {
 73   LIR_Opr opr = LIR_OprFact::illegalOpr;
 74   VMReg r_1 = reg-&gt;first();
 75   VMReg r_2 = reg-&gt;second();
 76   if (r_1-&gt;is_stack()) {
 77     int st_off = (r_1-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 78     opr = LIR_OprFact::address(new LIR_Address(SP_opr, st_off, type));
 79   } else if (r_1-&gt;is_Register()) {
 80     Register reg = r_1-&gt;as_Register();
 81     if (r_2-&gt;is_Register() &amp;&amp; (type == T_LONG || type == T_DOUBLE)) {
 82       opr = as_long_opr(reg, r_2-&gt;as_Register());
<a name="1" id="anc1"></a><span class="line-modified"> 83     } else if (is_reference_type(type)) {</span>
 84       opr = as_oop_opr(reg);
 85     } else if (type == T_METADATA) {
 86       opr = as_metadata_opr(reg);
<a name="2" id="anc2"></a><span class="line-added"> 87     } else if (type == T_ADDRESS) {</span>
<span class="line-added"> 88       opr = as_address_opr(reg);</span>
 89     } else {
 90       // PreferInterpreterNativeStubs should ensure we never need to
 91       // handle a long opr passed as R3+stack_slot
 92       assert(! r_2-&gt;is_stack(), &quot;missing support for ALIGN_WIDE_ARGUMENTS==0&quot;);
 93       opr = as_opr(reg);
 94     }
 95   } else if (r_1-&gt;is_FloatRegister()) {
 96     FloatRegister reg = r_1-&gt;as_FloatRegister();
 97     opr = type == T_FLOAT ? as_float_opr(reg) : as_double_opr(reg);
 98   } else {
 99     ShouldNotReachHere();
100   }
101   return opr;
102 }
103 
104 
105 void FrameMap::initialize() {
106   if (_init_done) return;
107 
108   int i;
109   int rnum = 0;
110 
111   // Registers used for allocation
112   assert(Rthread == R10 &amp;&amp; Rtemp == R12, &quot;change the code here&quot;);
113   for (i = 0; i &lt; 10; i++) {
114     map_register(rnum++, as_Register(i));
115   }
116   assert(rnum == pd_nof_cpu_regs_reg_alloc, &quot;should be&quot;);
117 
118   // Registers not used for allocation
119   map_register(rnum++, LR); // LR register should be listed first, see c1_LinearScan_arm.hpp::is_processed_reg_num.
120   assert(rnum == pd_nof_cpu_regs_processed_in_linearscan, &quot;should be&quot;);
121 
122   map_register(rnum++, Rtemp);
123   map_register(rnum++, Rthread);
124   map_register(rnum++, FP); // ARM32: R7 or R11
125   map_register(rnum++, SP);
126   map_register(rnum++, PC);
127   assert(rnum == pd_nof_cpu_regs_frame_map, &quot;should be&quot;);
128 
129   _init_done = true;
130 
131   R0_opr  = as_opr(R0);   R0_oop_opr = as_oop_opr(R0);    R0_metadata_opr = as_metadata_opr(R0);
132   R1_opr  = as_opr(R1);   R1_oop_opr = as_oop_opr(R1);    R1_metadata_opr = as_metadata_opr(R1);
133   R2_opr  = as_opr(R2);   R2_oop_opr = as_oop_opr(R2);    R2_metadata_opr = as_metadata_opr(R2);
134   R3_opr  = as_opr(R3);   R3_oop_opr = as_oop_opr(R3);    R3_metadata_opr = as_metadata_opr(R3);
135   R4_opr  = as_opr(R4);   R4_oop_opr = as_oop_opr(R4);    R4_metadata_opr = as_metadata_opr(R4);
136   R5_opr  = as_opr(R5);   R5_oop_opr = as_oop_opr(R5);    R5_metadata_opr = as_metadata_opr(R5);
137 
138 
139   LR_opr      = as_opr(LR);
140   LR_oop_opr  = as_oop_opr(LR);
141   LR_ptr_opr  = as_pointer_opr(LR);
142   FP_opr      = as_pointer_opr(FP);
143   SP_opr      = as_pointer_opr(SP);
144   Rthread_opr = as_pointer_opr(Rthread);
145 
146   // LIR operands for result
147   Int_result_opr = R0_opr;
148   Object_result_opr = R0_oop_opr;
149   Long_result_opr = as_long_opr(R0, R1);
150 #ifdef __ABI_HARD__
151   Float_result_opr = as_float_opr(S0);
152   Double_result_opr = as_double_opr(D0);
153 #else
154   Float_result_opr = LIR_OprFact::single_softfp(0);
155   Double_result_opr = LIR_OprFact::double_softfp(0, 1);
156 #endif // __ABI_HARD__
157 
158   Exception_oop_opr = as_oop_opr(Rexception_obj);
159   Exception_pc_opr = as_opr(Rexception_pc);
160 
161   for (i = 0; i &lt; nof_caller_save_cpu_regs(); i++) {
162     _caller_save_cpu_regs[i] = LIR_OprFact::single_cpu(i);
163   }
164   for (i = 0; i &lt; nof_caller_save_fpu_regs; i++) {
165     _caller_save_fpu_regs[i] = LIR_OprFact::single_fpu(i);
166   }
167 }
168 
169 
170 Address FrameMap::make_new_address(ByteSize sp_offset) const {
171   return Address(SP, sp_offset);
172 }
173 
174 LIR_Opr FrameMap::stack_pointer() {
175   return FrameMap::SP_opr;
176 }
177 
178 LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {
179   assert(Rmh_SP_save == FP, &quot;Fix register used for saving SP for MethodHandle calls&quot;);
180   return FP_opr;
181 }
182 
183 bool FrameMap::validate_frame() {
184   int max_offset = in_bytes(framesize_in_bytes());
185   int java_index = 0;
186   for (int i = 0; i &lt; _incoming_arguments-&gt;length(); i++) {
187     LIR_Opr opr = _incoming_arguments-&gt;at(i);
188     if (opr-&gt;is_stack()) {
189       int arg_offset = _argument_locations-&gt;at(java_index);
190       if (arg_offset &gt; max_offset) {
191         max_offset = arg_offset;
192       }
193     }
194     java_index += type2size[opr-&gt;type()];
195   }
196   return max_offset &lt; 4096;
197 }
198 
199 VMReg FrameMap::fpu_regname(int n) {
200   return as_FloatRegister(n)-&gt;as_VMReg();
201 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
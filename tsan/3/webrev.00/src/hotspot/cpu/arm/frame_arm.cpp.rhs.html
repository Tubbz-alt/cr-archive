<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/arm/frame_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/interpreter.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 28 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added"> 29 #include &quot;oops/markWord.hpp&quot;</span>
 30 #include &quot;oops/method.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/frame.inline.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/javaCalls.hpp&quot;
 35 #include &quot;runtime/monitorChunk.hpp&quot;
 36 #include &quot;runtime/os.inline.hpp&quot;
 37 #include &quot;runtime/signature.hpp&quot;
 38 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 39 #include &quot;runtime/stubRoutines.hpp&quot;
 40 #include &quot;vmreg_arm.inline.hpp&quot;
 41 #ifdef COMPILER1
 42 #include &quot;c1/c1_Runtime1.hpp&quot;
 43 #include &quot;runtime/vframeArray.hpp&quot;
 44 #endif
 45 #include &quot;prims/methodHandles.hpp&quot;
 46 
 47 #ifdef ASSERT
 48 void RegisterMap::check_location_valid() {
 49 }
 50 #endif
 51 
 52 
 53 // Profiling/safepoint support
 54 
 55 bool frame::safe_for_sender(JavaThread *thread) {
 56   address   sp = (address)_sp;
 57   address   fp = (address)_fp;
 58   address   unextended_sp = (address)_unextended_sp;
 59 
<a name="3" id="anc3"></a><span class="line-modified"> 60   // consider stack guards when trying to determine &quot;safe&quot; stack pointers</span>



 61   // sp must be within the usable part of the stack (not in guards)
<a name="4" id="anc4"></a><span class="line-modified"> 62   if (!thread-&gt;is_in_usable_stack(sp)) {</span>




 63     return false;
 64   }
 65 
 66   bool unextended_sp_safe = (unextended_sp != NULL &amp;&amp;
<a name="5" id="anc5"></a><span class="line-modified"> 67                              (unextended_sp &lt; thread-&gt;stack_base()) &amp;&amp;</span>
 68                              (unextended_sp &gt;= sp));
 69   if (!unextended_sp_safe) {
 70     return false;
 71   }
 72 
 73   // We know sp/unextended_sp are safe. Only fp is questionable here.
 74 
 75   bool fp_safe = (fp != NULL &amp;&amp;
<a name="6" id="anc6"></a><span class="line-modified"> 76                   (fp &lt; thread-&gt;stack_base()) &amp;&amp;</span>
 77                   fp &gt;= sp);
 78 
 79   if (_cb != NULL ) {
 80 
 81     // First check if frame is complete and tester is reliable
 82     // Unfortunately we can only check frame complete for runtime stubs and nmethod
 83     // other generic buffer blobs are more problematic so we just assume they are
 84     // ok. adapter blobs never have a frame complete and are never ok.
 85 
 86     if (!_cb-&gt;is_frame_complete_at(_pc)) {
 87       if (_cb-&gt;is_compiled() || _cb-&gt;is_adapter_blob() || _cb-&gt;is_runtime_stub()) {
 88         return false;
 89       }
 90     }
 91 
 92     // Could just be some random pointer within the codeBlob
 93     if (!_cb-&gt;code_contains(_pc)) {
 94       return false;
 95     }
 96 
 97     // Entry frame checks
 98     if (is_entry_frame()) {
 99       // an entry frame must have a valid fp.
100       return fp_safe &amp;&amp; is_entry_frame_valid(thread);
101     }
102 
103     intptr_t* sender_sp = NULL;
104     address   sender_pc = NULL;
105 
106     if (is_interpreted_frame()) {
107       // fp must be safe
108       if (!fp_safe) {
109         return false;
110       }
111 
112       sender_pc = (address) this-&gt;fp()[return_addr_offset];
113       sender_sp = (intptr_t*) addr_at(sender_sp_offset);
114 
115     } else {
116       // must be some sort of compiled/runtime frame
117       // fp does not have to be safe (although it could be check for c1?)
118 
119       sender_sp = _unextended_sp + _cb-&gt;frame_size();
120       // Is sender_sp safe?
121       if ((address)sender_sp &gt;= thread-&gt;stack_base()) {
122         return false;
123       }
124       // With our calling conventions, the return_address should
125       // end up being the word on the stack
126       sender_pc = (address) *(sender_sp - sender_sp_offset + return_addr_offset);
127     }
128 
129     // We must always be able to find a recognizable pc
130     CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);
131     if (sender_pc == NULL || sender_blob == NULL) {
132       return false;
133     }
134 
135 
136     // If the potential sender is the interpreter then we can do some more checking
137     if (Interpreter::contains(sender_pc)) {
138 
139       // FP is always saved in a recognizable place in any code we generate. However
140       // only if the sender is interpreted/call_stub (c1 too?) are we certain that the saved FP
141       // is really a frame pointer.
142 
143       intptr_t *saved_fp = (intptr_t*)*(sender_sp - frame::sender_sp_offset + link_offset);
<a name="7" id="anc7"></a><span class="line-modified">144       bool saved_fp_safe = ((address)saved_fp &lt; thread-&gt;stack_base()) &amp;&amp; (saved_fp &gt; sender_sp);</span>
145 
146       if (!saved_fp_safe) {
147         return false;
148       }
149 
150       // construct the potential sender
151 
152       frame sender(sender_sp, saved_fp, sender_pc);
153 
154       return sender.is_interpreted_frame_valid(thread);
155     }
156 
157     if (sender_blob-&gt;is_zombie() || sender_blob-&gt;is_unloaded()) {
158       return false;
159     }
160 
161     // Could just be some random pointer within the codeBlob
162     if (!sender_blob-&gt;code_contains(sender_pc)) {
163       return false;
164     }
165 
166     // We should never be able to see an adapter if the current frame is something from code cache
167     if (sender_blob-&gt;is_adapter_blob()) {
168       return false;
169     }
170 
171     // Could be the call_stub
172     if (StubRoutines::returns_to_call_stub(sender_pc)) {
173       intptr_t *saved_fp = (intptr_t*)*(sender_sp - frame::sender_sp_offset + link_offset);
<a name="8" id="anc8"></a><span class="line-modified">174       bool saved_fp_safe = ((address)saved_fp &lt; thread-&gt;stack_base()) &amp;&amp; (saved_fp &gt; sender_sp);</span>
175 
176       if (!saved_fp_safe) {
177         return false;
178       }
179 
180       // construct the potential sender
181 
182       frame sender(sender_sp, saved_fp, sender_pc);
183 
184       // Validate the JavaCallWrapper an entry frame must have
185       address jcw = (address)sender.entry_frame_call_wrapper();
186 
<a name="9" id="anc9"></a><span class="line-modified">187       bool jcw_safe = (jcw &lt; thread-&gt;stack_base()) &amp;&amp; (jcw &gt; (address)sender.fp());</span>
188 
189       return jcw_safe;
190     }
191 
192     // If the frame size is 0 something (or less) is bad because every nmethod has a non-zero frame size
193     // because the return address counts against the callee&#39;s frame.
194 
195     if (sender_blob-&gt;frame_size() &lt;= 0) {
196       assert(!sender_blob-&gt;is_compiled(), &quot;should count return address at least&quot;);
197       return false;
198     }
199 
200     // We should never be able to see anything here except an nmethod. If something in the
201     // code cache (current frame) is called by an entity within the code cache that entity
202     // should not be anything but the call stub (already covered), the interpreter (already covered)
203     // or an nmethod.
204 
205     if (!sender_blob-&gt;is_compiled()) {
206       return false;
207     }
208 
209     // Could put some more validation for the potential non-interpreted sender
210     // frame we&#39;d create by calling sender if I could think of any. Wait for next crash in forte...
211 
212     // One idea is seeing if the sender_pc we have is one that we&#39;d expect to call to current cb
213 
214     // We&#39;ve validated the potential sender that would be created
215     return true;
216   }
217 
218   // Must be native-compiled frame. Since sender will try and use fp to find
219   // linkages it must be safe
220 
221   if (!fp_safe) {
222     return false;
223   }
224 
225   // Will the pc we fetch be non-zero (which we&#39;ll find at the oldest frame)
226 
227   if ((address) this-&gt;fp()[return_addr_offset] == NULL) return false;
228 
229 
230   // could try and do some more potential verification of native frame if we could think of some...
231 
232   return true;
233 }
234 
235 
236 void frame::patch_pc(Thread* thread, address pc) {
237   address* pc_addr = &amp;((address *)sp())[-sender_sp_offset+return_addr_offset];
238   if (TracePcPatching) {
239     tty-&gt;print_cr(&quot;patch_pc at address&quot; INTPTR_FORMAT &quot; [&quot; INTPTR_FORMAT &quot; -&gt; &quot; INTPTR_FORMAT &quot;] &quot;,
240                   p2i(pc_addr), p2i(*pc_addr), p2i(pc));
241   }
242   *pc_addr = pc;
243   _cb = CodeCache::find_blob(pc);
244   address original_pc = CompiledMethod::get_deopt_original_pc(this);
245   if (original_pc != NULL) {
246     assert(original_pc == _pc, &quot;expected original PC to be stored before patching&quot;);
247     _deopt_state = is_deoptimized;
248     // leave _pc as is
249   } else {
250     _deopt_state = not_deoptimized;
251     _pc = pc;
252   }
253 }
254 
255 bool frame::is_interpreted_frame() const  {
256   return Interpreter::contains(pc());
257 }
258 
259 int frame::frame_size(RegisterMap* map) const {
260   frame sender = this-&gt;sender(map);
261   return sender.sp() - sp();
262 }
263 
264 intptr_t* frame::entry_frame_argument_at(int offset) const {
265   assert(is_entry_frame(), &quot;entry frame expected&quot;);
266   // convert offset to index to deal with tsi
267   int index = (Interpreter::expr_offset_in_bytes(offset)/wordSize);
268   // Entry frame&#39;s arguments are always in relation to unextended_sp()
269   return &amp;unextended_sp()[index];
270 }
271 
272 // sender_sp
273 intptr_t* frame::interpreter_frame_sender_sp() const {
274   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
275   return (intptr_t*) at(interpreter_frame_sender_sp_offset);
276 }
277 
278 void frame::set_interpreter_frame_sender_sp(intptr_t* sender_sp) {
279   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
280   ptr_at_put(interpreter_frame_sender_sp_offset, (intptr_t) sender_sp);
281 }
282 
283 
284 // monitor elements
285 
286 BasicObjectLock* frame::interpreter_frame_monitor_begin() const {
287   return (BasicObjectLock*) addr_at(interpreter_frame_monitor_block_bottom_offset);
288 }
289 
290 BasicObjectLock* frame::interpreter_frame_monitor_end() const {
291   BasicObjectLock* result = (BasicObjectLock*) *addr_at(interpreter_frame_monitor_block_top_offset);
292   // make sure the pointer points inside the frame
293   assert((intptr_t) fp() &gt;  (intptr_t) result, &quot;result must &lt;  than frame pointer&quot;);
294   assert((intptr_t) sp() &lt;= (intptr_t) result, &quot;result must &gt;= than stack pointer&quot;);
295   return result;
296 }
297 
298 void frame::interpreter_frame_set_monitor_end(BasicObjectLock* value) {
299   *((BasicObjectLock**)addr_at(interpreter_frame_monitor_block_top_offset)) = value;
300 }
301 
302 
303 // Used by template based interpreter deoptimization
304 void frame::interpreter_frame_set_last_sp(intptr_t* sp) {
305     *((intptr_t**)addr_at(interpreter_frame_last_sp_offset)) = sp;
306 }
307 
308 
309 frame frame::sender_for_entry_frame(RegisterMap* map) const {
310   assert(map != NULL, &quot;map must be set&quot;);
311   // Java frame called from C; skip all C frames and return top C
312   // frame of that chunk as the sender
313   JavaFrameAnchor* jfa = entry_frame_call_wrapper()-&gt;anchor();
314   assert(!entry_frame_is_first(), &quot;next Java fp must be non zero&quot;);
315   assert(jfa-&gt;last_Java_sp() &gt; sp(), &quot;must be above this frame on stack&quot;);
316   map-&gt;clear();
317   assert(map-&gt;include_argument_oops(), &quot;should be set by clear&quot;);
318   if (jfa-&gt;last_Java_pc() != NULL) {
319     frame fr(jfa-&gt;last_Java_sp(), jfa-&gt;last_Java_fp(), jfa-&gt;last_Java_pc());
320     return fr;
321   }
322   frame fr(jfa-&gt;last_Java_sp(), jfa-&gt;last_Java_fp());
323   return fr;
324 }
325 
326 //------------------------------------------------------------------------------
327 // frame::verify_deopt_original_pc
328 //
329 // Verifies the calculated original PC of a deoptimization PC for the
330 // given unextended SP.  The unextended SP might also be the saved SP
331 // for MethodHandle call sites.
332 #ifdef ASSERT
333 void frame::verify_deopt_original_pc(CompiledMethod* nm, intptr_t* unextended_sp, bool is_method_handle_return) {
334   frame fr;
335 
336   // This is ugly but it&#39;s better than to change {get,set}_original_pc
337   // to take an SP value as argument.  And it&#39;s only a debugging
338   // method anyway.
339   fr._unextended_sp = unextended_sp;
340 
341   address original_pc = nm-&gt;get_original_pc(&amp;fr);
342   assert(nm-&gt;insts_contains_inclusive(original_pc),
343          &quot;original PC must be in the main code section of the the compiled method (or must be immediately following it)&quot;);
344   assert(nm-&gt;is_method_handle_return(original_pc) == is_method_handle_return, &quot;must be&quot;);
345 }
346 #endif
347 
348 //------------------------------------------------------------------------------
349 // frame::adjust_unextended_sp
350 void frame::adjust_unextended_sp() {
351   // same as on x86
352 
353   // If we are returning to a compiled MethodHandle call site, the
354   // saved_fp will in fact be a saved value of the unextended SP.  The
355   // simplest way to tell whether we are returning to such a call site
356   // is as follows:
357 
358   CompiledMethod* sender_cm = (_cb == NULL) ? NULL : _cb-&gt;as_compiled_method_or_null();
359   if (sender_cm != NULL) {
360     // If the sender PC is a deoptimization point, get the original
361     // PC.  For MethodHandle call site the unextended_sp is stored in
362     // saved_fp.
363     if (sender_cm-&gt;is_deopt_mh_entry(_pc)) {
364       DEBUG_ONLY(verify_deopt_mh_original_pc(sender_cm, _fp));
365       _unextended_sp = _fp;
366     }
367     else if (sender_cm-&gt;is_deopt_entry(_pc)) {
368       DEBUG_ONLY(verify_deopt_original_pc(sender_cm, _unextended_sp));
369     }
370     else if (sender_cm-&gt;is_method_handle_return(_pc)) {
371       _unextended_sp = _fp;
372     }
373   }
374 }
375 
376 //------------------------------------------------------------------------------
377 // frame::update_map_with_saved_link
378 void frame::update_map_with_saved_link(RegisterMap* map, intptr_t** link_addr) {
379   // see x86 for comments
380   map-&gt;set_location(FP-&gt;as_VMReg(), (address) link_addr);
381 }
382 
383 frame frame::sender_for_interpreter_frame(RegisterMap* map) const {
384   // SP is the raw SP from the sender after adapter or interpreter
385   // extension.
386   intptr_t* sender_sp = this-&gt;sender_sp();
387 
388   // This is the sp before any possible extension (adapter/locals).
389   intptr_t* unextended_sp = interpreter_frame_sender_sp();
390 
391 #ifdef COMPILER2
392   if (map-&gt;update_map()) {
393     update_map_with_saved_link(map, (intptr_t**) addr_at(link_offset));
394   }
395 #endif // COMPILER2
396 
397   return frame(sender_sp, unextended_sp, link(), sender_pc());
398 }
399 
400 frame frame::sender_for_compiled_frame(RegisterMap* map) const {
401   assert(map != NULL, &quot;map must be set&quot;);
402 
403   // frame owned by optimizing compiler
404   assert(_cb-&gt;frame_size() &gt;= 0, &quot;must have non-zero frame size&quot;);
405   intptr_t* sender_sp = unextended_sp() + _cb-&gt;frame_size();
406   intptr_t* unextended_sp = sender_sp;
407 
408   address sender_pc = (address) *(sender_sp - sender_sp_offset + return_addr_offset);
409 
410   // This is the saved value of FP which may or may not really be an FP.
411   // It is only an FP if the sender is an interpreter frame (or C1?).
412   intptr_t** saved_fp_addr = (intptr_t**) (sender_sp - sender_sp_offset + link_offset);
413 
414   if (map-&gt;update_map()) {
415     // Tell GC to use argument oopmaps for some runtime stubs that need it.
416     // For C1, the runtime stub might not have oop maps, so set this flag
417     // outside of update_register_map.
418     map-&gt;set_include_argument_oops(_cb-&gt;caller_must_gc_arguments(map-&gt;thread()));
419     if (_cb-&gt;oop_maps() != NULL) {
420       OopMapSet::update_register_map(this, map);
421     }
422 
423     // Since the prolog does the save and restore of FP there is no oopmap
424     // for it so we must fill in its location as if there was an oopmap entry
425     // since if our caller was compiled code there could be live jvm state in it.
426     update_map_with_saved_link(map, saved_fp_addr);
427   }
428 
429   assert(sender_sp != sp(), &quot;must have changed&quot;);
430   return frame(sender_sp, unextended_sp, *saved_fp_addr, sender_pc);
431 }
432 
433 frame frame::sender(RegisterMap* map) const {
434   // Default is we done have to follow them. The sender_for_xxx will
435   // update it accordingly
436   map-&gt;set_include_argument_oops(false);
437 
438   if (is_entry_frame())       return sender_for_entry_frame(map);
439   if (is_interpreted_frame()) return sender_for_interpreter_frame(map);
440   assert(_cb == CodeCache::find_blob(pc()),&quot;Must be the same&quot;);
441 
442   if (_cb != NULL) {
443     return sender_for_compiled_frame(map);
444   }
445 
446   assert(false, &quot;should not be called for a C frame&quot;);
447   return frame();
448 }
449 
450 bool frame::is_interpreted_frame_valid(JavaThread* thread) const {
451   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
452   // These are reasonable sanity checks
453   if (fp() == 0 || (intptr_t(fp()) &amp; (wordSize-1)) != 0) {
454     return false;
455   }
456   if (sp() == 0 || (intptr_t(sp()) &amp; (wordSize-1)) != 0) {
457     return false;
458   }
459   if (fp() + interpreter_frame_initial_sp_offset &lt; sp()) {
460     return false;
461   }
462   // These are hacks to keep us out of trouble.
463   // The problem with these is that they mask other problems
464   if (fp() &lt;= sp()) {        // this attempts to deal with unsigned comparison above
465     return false;
466   }
467   // do some validation of frame elements
468 
469   // first the method
470 
471   Method* m = *interpreter_frame_method_addr();
472 
473   // validate the method we&#39;d find in this potential sender
474   if (!Method::is_valid_method(m)) return false;
475 
476   // stack frames shouldn&#39;t be much larger than max_stack elements
477 
478   if (fp() - sp() &gt; 1024 + m-&gt;max_stack()*Interpreter::stackElementSize) {
479     return false;
480   }
481 
482   // validate bci/bcp
483 
484   address bcp = interpreter_frame_bcp();
485   if (m-&gt;validate_bci_from_bcp(bcp) &lt; 0) {
486     return false;
487   }
488 
489   // validate ConstantPoolCache*
490   ConstantPoolCache* cp = *interpreter_frame_cache_addr();
<a name="10" id="anc10"></a><span class="line-modified">491   if (MetaspaceObj::is_valid(cp) == false) return false;</span>
492 
493   // validate locals
494 
495   address locals =  (address) *interpreter_frame_locals_addr();
496 
<a name="11" id="anc11"></a><span class="line-modified">497   if (locals &gt;= thread-&gt;stack_base() || locals &lt; (address) fp()) return false;</span>
498 
499   // We&#39;d have to be pretty unlucky to be mislead at this point
500 
501   return true;
502 }
503 
504 BasicType frame::interpreter_frame_result(oop* oop_result, jvalue* value_result) {
505   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
506   Method* method = interpreter_frame_method();
507   BasicType type = method-&gt;result_type();
508 
509   intptr_t* res_addr;
510   if (method-&gt;is_native()) {
511     // Prior to calling into the runtime to report the method_exit both of
512     // the possible return value registers are saved.
513     // Return value registers are pushed to the native stack
514     res_addr = (intptr_t*)sp();
515 #ifdef __ABI_HARD__
516     // FP result is pushed onto a stack along with integer result registers
517     if (type == T_FLOAT || type == T_DOUBLE) {
518       res_addr += 2;
519     }
520 #endif // __ABI_HARD__
521   } else {
522     res_addr = (intptr_t*)interpreter_frame_tos_address();
523   }
524 
525   switch (type) {
526     case T_OBJECT  :
527     case T_ARRAY   : {
528       oop obj;
529       if (method-&gt;is_native()) {
530         obj = cast_to_oop(at(interpreter_frame_oop_temp_offset));
531       } else {
532         obj = *(oop*)res_addr;
533       }
534       assert(obj == NULL || Universe::heap()-&gt;is_in(obj), &quot;sanity check&quot;);
535       *oop_result = obj;
536       break;
537     }
538     case T_BOOLEAN : value_result-&gt;z = *(jboolean*)res_addr; break;
539     case T_BYTE    : value_result-&gt;b = *(jbyte*)res_addr; break;
540     case T_CHAR    : value_result-&gt;c = *(jchar*)res_addr; break;
541     case T_SHORT   : value_result-&gt;s = *(jshort*)res_addr; break;
542     case T_INT     : value_result-&gt;i = *(jint*)res_addr; break;
543     case T_LONG    : value_result-&gt;j = *(jlong*)res_addr; break;
544     case T_FLOAT   : value_result-&gt;f = *(jfloat*)res_addr; break;
545     case T_DOUBLE  : value_result-&gt;d = *(jdouble*)res_addr; break;
546     case T_VOID    : /* Nothing to do */ break;
547     default        : ShouldNotReachHere();
548   }
549 
550   return type;
551 }
552 
553 
554 intptr_t* frame::interpreter_frame_tos_at(jint offset) const {
555   int index = (Interpreter::expr_offset_in_bytes(offset)/wordSize);
556   return &amp;interpreter_frame_tos_address()[index];
557 }
558 
559 #ifndef PRODUCT
560 
561 #define DESCRIBE_FP_OFFSET(name) \
562   values.describe(frame_no, fp() + frame::name##_offset, #name)
563 
564 void frame::describe_pd(FrameValues&amp; values, int frame_no) {
565   if (is_interpreted_frame()) {
566     DESCRIBE_FP_OFFSET(interpreter_frame_sender_sp);
567     DESCRIBE_FP_OFFSET(interpreter_frame_last_sp);
568     DESCRIBE_FP_OFFSET(interpreter_frame_method);
569     DESCRIBE_FP_OFFSET(interpreter_frame_mdp);
570     DESCRIBE_FP_OFFSET(interpreter_frame_cache);
571     DESCRIBE_FP_OFFSET(interpreter_frame_locals);
572     DESCRIBE_FP_OFFSET(interpreter_frame_bcp);
573     DESCRIBE_FP_OFFSET(interpreter_frame_initial_sp);
574   }
575 }
576 
577 // This is a generic constructor which is only used by pns() in debug.cpp.
578 frame::frame(void* sp, void* fp, void* pc) {
579   init((intptr_t*)sp, (intptr_t*)fp, (address)pc);
580 }
581 
582 void frame::pd_ps() {}
583 #endif
584 
585 intptr_t *frame::initial_deoptimization_info() {
586   // used to reset the saved FP
587   return fp();
588 }
589 
590 intptr_t* frame::real_fp() const {
591   if (is_entry_frame()) {
592     // Work-around: FP (currently) does not conform to the ABI for entry
593     // frames (see generate_call_stub). Might be worth fixing as another CR.
594     // Following code assumes (and asserts) this has not yet been fixed.
595     assert(frame::entry_frame_call_wrapper_offset == 0, &quot;adjust this code&quot;);
596     intptr_t* new_fp = fp();
597     new_fp += 5; // saved R0,R1,R2,R4,R10
598 #ifndef __SOFTFP__
599     new_fp += 8*2; // saved D8..D15
600 #endif
601     return new_fp;
602   }
603   if (_cb != NULL) {
604     // use the frame size if valid
605     int size = _cb-&gt;frame_size();
606     if (size &gt; 0) {
607       return unextended_sp() + size;
608     }
609   }
610   // else rely on fp()
611   assert(! is_compiled_frame(), &quot;unknown compiled frame size&quot;);
612   return fp();
613 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
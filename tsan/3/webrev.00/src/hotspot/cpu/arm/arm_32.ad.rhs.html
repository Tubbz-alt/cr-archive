<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/arm/arm_32.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 //
  2 // Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
  3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 //
  5 // This code is free software; you can redistribute it and/or modify it
  6 // under the terms of the GNU General Public License version 2 only, as
  7 // published by the Free Software Foundation.
  8 //
  9 // This code is distributed in the hope that it will be useful, but WITHOUT
 10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12 // version 2 for more details (a copy is included in the LICENSE file that
 13 // accompanied this code).
 14 //
 15 // You should have received a copy of the GNU General Public License version
 16 // 2 along with this work; if not, write to the Free Software Foundation,
 17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18 //
 19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20 // or visit www.oracle.com if you need additional information or have any
 21 // questions.
 22 //
 23 
 24 // ARM Architecture Description File
 25 
 26 //----------REGISTER DEFINITION BLOCK------------------------------------------
 27 // This information is used by the matcher and the register allocator to
 28 // describe individual registers and classes of registers within the target
 29 // archtecture.
 30 register %{
 31 //----------Architecture Description Register Definitions----------------------
 32 // General Registers
 33 // &quot;reg_def&quot;  name ( register save type, C convention save type,
 34 //                   ideal register type, encoding, vm name );
 35 // Register Save Types:
 36 //
 37 // NS  = No-Save:       The register allocator assumes that these registers
 38 //                      can be used without saving upon entry to the method, &amp;
 39 //                      that they do not need to be saved at call sites.
 40 //
 41 // SOC = Save-On-Call:  The register allocator assumes that these registers
 42 //                      can be used without saving upon entry to the method,
 43 //                      but that they must be saved at call sites.
 44 //
 45 // SOE = Save-On-Entry: The register allocator assumes that these registers
 46 //                      must be saved before using them upon entry to the
 47 //                      method, but they do not need to be saved at call
 48 //                      sites.
 49 //
 50 // AS  = Always-Save:   The register allocator assumes that these registers
 51 //                      must be saved before using them upon entry to the
 52 //                      method, &amp; that they must be saved at call sites.
 53 //
 54 // Ideal Register Type is used to determine how to save &amp; restore a
 55 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
 56 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
 57 //
 58 // The encoding number is the actual bit-pattern placed into the opcodes.
 59 
 60 
 61 // ----------------------------
 62 // Integer/Long Registers
 63 // ----------------------------
 64 
 65 reg_def R_R0 (SOC, SOC, Op_RegI,  0,  R(0)-&gt;as_VMReg());
 66 reg_def R_R1 (SOC, SOC, Op_RegI,  1,  R(1)-&gt;as_VMReg());
 67 reg_def R_R2 (SOC, SOC, Op_RegI,  2,  R(2)-&gt;as_VMReg());
 68 reg_def R_R3 (SOC, SOC, Op_RegI,  3,  R(3)-&gt;as_VMReg());
 69 reg_def R_R4 (SOC, SOE, Op_RegI,  4,  R(4)-&gt;as_VMReg());
 70 reg_def R_R5 (SOC, SOE, Op_RegI,  5,  R(5)-&gt;as_VMReg());
 71 reg_def R_R6 (SOC, SOE, Op_RegI,  6,  R(6)-&gt;as_VMReg());
 72 reg_def R_R7 (SOC, SOE, Op_RegI,  7,  R(7)-&gt;as_VMReg());
 73 reg_def R_R8 (SOC, SOE, Op_RegI,  8,  R(8)-&gt;as_VMReg());
 74 reg_def R_R9 (SOC, SOE, Op_RegI,  9,  R(9)-&gt;as_VMReg());
 75 reg_def R_R10(NS,  SOE, Op_RegI, 10, R(10)-&gt;as_VMReg());
 76 reg_def R_R11(NS,  SOE, Op_RegI, 11, R(11)-&gt;as_VMReg());
 77 reg_def R_R12(SOC, SOC, Op_RegI, 12, R(12)-&gt;as_VMReg());
 78 reg_def R_R13(NS,  NS,  Op_RegI, 13, R(13)-&gt;as_VMReg());
 79 reg_def R_R14(SOC, SOC, Op_RegI, 14, R(14)-&gt;as_VMReg());
 80 reg_def R_R15(NS,  NS,  Op_RegI, 15, R(15)-&gt;as_VMReg());
 81 
 82 // ----------------------------
 83 // Float/Double Registers
 84 // ----------------------------
 85 
 86 // Float Registers
 87 
 88 reg_def R_S0 ( SOC, SOC, Op_RegF,  0, S0-&gt;as_VMReg());
 89 reg_def R_S1 ( SOC, SOC, Op_RegF,  1, S1_reg-&gt;as_VMReg());
 90 reg_def R_S2 ( SOC, SOC, Op_RegF,  2, S2_reg-&gt;as_VMReg());
 91 reg_def R_S3 ( SOC, SOC, Op_RegF,  3, S3_reg-&gt;as_VMReg());
 92 reg_def R_S4 ( SOC, SOC, Op_RegF,  4, S4_reg-&gt;as_VMReg());
 93 reg_def R_S5 ( SOC, SOC, Op_RegF,  5, S5_reg-&gt;as_VMReg());
 94 reg_def R_S6 ( SOC, SOC, Op_RegF,  6, S6_reg-&gt;as_VMReg());
 95 reg_def R_S7 ( SOC, SOC, Op_RegF,  7, S7-&gt;as_VMReg());
 96 reg_def R_S8 ( SOC, SOC, Op_RegF,  8, S8-&gt;as_VMReg());
 97 reg_def R_S9 ( SOC, SOC, Op_RegF,  9, S9-&gt;as_VMReg());
 98 reg_def R_S10( SOC, SOC, Op_RegF, 10,S10-&gt;as_VMReg());
 99 reg_def R_S11( SOC, SOC, Op_RegF, 11,S11-&gt;as_VMReg());
100 reg_def R_S12( SOC, SOC, Op_RegF, 12,S12-&gt;as_VMReg());
101 reg_def R_S13( SOC, SOC, Op_RegF, 13,S13-&gt;as_VMReg());
102 reg_def R_S14( SOC, SOC, Op_RegF, 14,S14-&gt;as_VMReg());
103 reg_def R_S15( SOC, SOC, Op_RegF, 15,S15-&gt;as_VMReg());
104 reg_def R_S16( SOC, SOE, Op_RegF, 16,S16-&gt;as_VMReg());
105 reg_def R_S17( SOC, SOE, Op_RegF, 17,S17-&gt;as_VMReg());
106 reg_def R_S18( SOC, SOE, Op_RegF, 18,S18-&gt;as_VMReg());
107 reg_def R_S19( SOC, SOE, Op_RegF, 19,S19-&gt;as_VMReg());
108 reg_def R_S20( SOC, SOE, Op_RegF, 20,S20-&gt;as_VMReg());
109 reg_def R_S21( SOC, SOE, Op_RegF, 21,S21-&gt;as_VMReg());
110 reg_def R_S22( SOC, SOE, Op_RegF, 22,S22-&gt;as_VMReg());
111 reg_def R_S23( SOC, SOE, Op_RegF, 23,S23-&gt;as_VMReg());
112 reg_def R_S24( SOC, SOE, Op_RegF, 24,S24-&gt;as_VMReg());
113 reg_def R_S25( SOC, SOE, Op_RegF, 25,S25-&gt;as_VMReg());
114 reg_def R_S26( SOC, SOE, Op_RegF, 26,S26-&gt;as_VMReg());
115 reg_def R_S27( SOC, SOE, Op_RegF, 27,S27-&gt;as_VMReg());
116 reg_def R_S28( SOC, SOE, Op_RegF, 28,S28-&gt;as_VMReg());
117 reg_def R_S29( SOC, SOE, Op_RegF, 29,S29-&gt;as_VMReg());
118 reg_def R_S30( SOC, SOE, Op_RegF, 30,S30-&gt;as_VMReg());
119 reg_def R_S31( SOC, SOE, Op_RegF, 31,S31-&gt;as_VMReg());
120 
121 // Double Registers
122 // The rules of ADL require that double registers be defined in pairs.
123 // Each pair must be two 32-bit values, but not necessarily a pair of
124 // single float registers.  In each pair, ADLC-assigned register numbers
125 // must be adjacent, with the lower number even.  Finally, when the
126 // CPU stores such a register pair to memory, the word associated with
127 // the lower ADLC-assigned number must be stored to the lower address.
128 
129 reg_def R_D16 (SOC, SOC, Op_RegD, 32, D16-&gt;as_VMReg());
130 reg_def R_D16x(SOC, SOC, Op_RegD,255, D16-&gt;as_VMReg()-&gt;next());
131 reg_def R_D17 (SOC, SOC, Op_RegD, 34, D17-&gt;as_VMReg());
132 reg_def R_D17x(SOC, SOC, Op_RegD,255, D17-&gt;as_VMReg()-&gt;next());
133 reg_def R_D18 (SOC, SOC, Op_RegD, 36, D18-&gt;as_VMReg());
134 reg_def R_D18x(SOC, SOC, Op_RegD,255, D18-&gt;as_VMReg()-&gt;next());
135 reg_def R_D19 (SOC, SOC, Op_RegD, 38, D19-&gt;as_VMReg());
136 reg_def R_D19x(SOC, SOC, Op_RegD,255, D19-&gt;as_VMReg()-&gt;next());
137 reg_def R_D20 (SOC, SOC, Op_RegD, 40, D20-&gt;as_VMReg());
138 reg_def R_D20x(SOC, SOC, Op_RegD,255, D20-&gt;as_VMReg()-&gt;next());
139 reg_def R_D21 (SOC, SOC, Op_RegD, 42, D21-&gt;as_VMReg());
140 reg_def R_D21x(SOC, SOC, Op_RegD,255, D21-&gt;as_VMReg()-&gt;next());
141 reg_def R_D22 (SOC, SOC, Op_RegD, 44, D22-&gt;as_VMReg());
142 reg_def R_D22x(SOC, SOC, Op_RegD,255, D22-&gt;as_VMReg()-&gt;next());
143 reg_def R_D23 (SOC, SOC, Op_RegD, 46, D23-&gt;as_VMReg());
144 reg_def R_D23x(SOC, SOC, Op_RegD,255, D23-&gt;as_VMReg()-&gt;next());
145 reg_def R_D24 (SOC, SOC, Op_RegD, 48, D24-&gt;as_VMReg());
146 reg_def R_D24x(SOC, SOC, Op_RegD,255, D24-&gt;as_VMReg()-&gt;next());
147 reg_def R_D25 (SOC, SOC, Op_RegD, 50, D25-&gt;as_VMReg());
148 reg_def R_D25x(SOC, SOC, Op_RegD,255, D25-&gt;as_VMReg()-&gt;next());
149 reg_def R_D26 (SOC, SOC, Op_RegD, 52, D26-&gt;as_VMReg());
150 reg_def R_D26x(SOC, SOC, Op_RegD,255, D26-&gt;as_VMReg()-&gt;next());
151 reg_def R_D27 (SOC, SOC, Op_RegD, 54, D27-&gt;as_VMReg());
152 reg_def R_D27x(SOC, SOC, Op_RegD,255, D27-&gt;as_VMReg()-&gt;next());
153 reg_def R_D28 (SOC, SOC, Op_RegD, 56, D28-&gt;as_VMReg());
154 reg_def R_D28x(SOC, SOC, Op_RegD,255, D28-&gt;as_VMReg()-&gt;next());
155 reg_def R_D29 (SOC, SOC, Op_RegD, 58, D29-&gt;as_VMReg());
156 reg_def R_D29x(SOC, SOC, Op_RegD,255, D29-&gt;as_VMReg()-&gt;next());
157 reg_def R_D30 (SOC, SOC, Op_RegD, 60, D30-&gt;as_VMReg());
158 reg_def R_D30x(SOC, SOC, Op_RegD,255, D30-&gt;as_VMReg()-&gt;next());
159 reg_def R_D31 (SOC, SOC, Op_RegD, 62, D31-&gt;as_VMReg());
160 reg_def R_D31x(SOC, SOC, Op_RegD,255, D31-&gt;as_VMReg()-&gt;next());
161 
162 // ----------------------------
163 // Special Registers
164 // Condition Codes Flag Registers
165 reg_def APSR (SOC, SOC,  Op_RegFlags, 0, VMRegImpl::Bad());
166 reg_def FPSCR(SOC, SOC,  Op_RegFlags, 0, VMRegImpl::Bad());
167 
168 // ----------------------------
169 // Specify the enum values for the registers.  These enums are only used by the
170 // OptoReg &quot;class&quot;. We can convert these enum values at will to VMReg when needed
171 // for visibility to the rest of the vm. The order of this enum influences the
172 // register allocator so having the freedom to set this order and not be stuck
173 // with the order that is natural for the rest of the vm is worth it.
174 
175 // registers in that order so that R11/R12 is an aligned pair that can be used for longs
176 alloc_class chunk0(
177                    R_R4, R_R5, R_R6, R_R7, R_R8, R_R9, R_R11, R_R12, R_R10, R_R13, R_R14, R_R15, R_R0, R_R1, R_R2, R_R3);
178 
179 // Note that a register is not allocatable unless it is also mentioned
180 // in a widely-used reg_class below.
181 
182 alloc_class chunk1(
183                    R_S16, R_S17, R_S18, R_S19, R_S20, R_S21, R_S22, R_S23,
184                    R_S24, R_S25, R_S26, R_S27, R_S28, R_S29, R_S30, R_S31,
185                    R_S0,  R_S1,  R_S2,  R_S3,  R_S4,  R_S5,  R_S6,  R_S7, 
186                    R_S8,  R_S9,  R_S10, R_S11, R_S12, R_S13, R_S14, R_S15,
187                    R_D16, R_D16x,R_D17, R_D17x,R_D18, R_D18x,R_D19, R_D19x, 
188                    R_D20, R_D20x,R_D21, R_D21x,R_D22, R_D22x,R_D23, R_D23x, 
189                    R_D24, R_D24x,R_D25, R_D25x,R_D26, R_D26x,R_D27, R_D27x, 
190                    R_D28, R_D28x,R_D29, R_D29x,R_D30, R_D30x,R_D31, R_D31x
191 );
192 
193 alloc_class chunk2(APSR, FPSCR);
194 
195 //----------Architecture Description Register Classes--------------------------
196 // Several register classes are automatically defined based upon information in
197 // this architecture description.
198 // 1) reg_class inline_cache_reg           ( as defined in frame section )
199 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
200 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
201 //
202 
203 // ----------------------------
204 // Integer Register Classes
205 // ----------------------------
206 // Exclusions from i_reg:
207 // SP (R13), PC (R15)
208 // R10: reserved by HotSpot to the TLS register (invariant within Java)
209 reg_class int_reg(R_R0, R_R1, R_R2, R_R3, R_R4, R_R5, R_R6, R_R7, R_R8, R_R9, R_R11, R_R12, R_R14);
210 
211 reg_class R0_regI(R_R0);
212 reg_class R1_regI(R_R1);
213 reg_class R2_regI(R_R2);
214 reg_class R3_regI(R_R3);
215 reg_class R12_regI(R_R12);
216 
217 // ----------------------------
218 // Pointer Register Classes
219 // ----------------------------
220 reg_class ptr_reg(R_R0, R_R1, R_R2, R_R3, R_R4, R_R5, R_R6, R_R7, R_R8, R_R9, R_R11, R_R12, R_R14);
221 // Special class for storeP instructions, which can store SP or RPC to TLS.
222 // It is also used for memory addressing, allowing direct TLS addressing.
223 reg_class sp_ptr_reg(R_R0, R_R1, R_R2, R_R3, R_R4, R_R5, R_R6, R_R7, R_R8, R_R9, R_R11, R_R12, R_R14, R_R10 /* TLS*/, R_R13 /* SP*/);
224 
225 #define R_Ricklass R_R8
226 #define R_Rmethod  R_R9
227 #define R_Rthread  R_R10
228 #define R_Rexception_obj R_R4
229 
230 // Other special pointer regs
231 reg_class R0_regP(R_R0);
232 reg_class R1_regP(R_R1);
233 reg_class R2_regP(R_R2);
234 reg_class R4_regP(R_R4);
<a name="1" id="anc1"></a><span class="line-added">235 reg_class R8_regP(R_R8);</span>
<span class="line-added">236 reg_class R9_regP(R_R9);</span>
<span class="line-added">237 reg_class R12_regP(R_R12);</span>
238 reg_class Rexception_regP(R_Rexception_obj);
239 reg_class Ricklass_regP(R_Ricklass);
240 reg_class Rmethod_regP(R_Rmethod);
241 reg_class Rthread_regP(R_Rthread);
242 reg_class IP_regP(R_R12);
<a name="2" id="anc2"></a><span class="line-added">243 reg_class SP_regP(R_R13);</span>
244 reg_class LR_regP(R_R14);
245 
246 reg_class FP_regP(R_R11);
247 
248 // ----------------------------
249 // Long Register Classes
250 // ----------------------------
251 reg_class long_reg (             R_R0,R_R1, R_R2,R_R3, R_R4,R_R5, R_R6,R_R7, R_R8,R_R9, R_R11,R_R12);
252 // for ldrexd, strexd: first reg of pair must be even
253 reg_class long_reg_align (       R_R0,R_R1, R_R2,R_R3, R_R4,R_R5, R_R6,R_R7, R_R8,R_R9);
254 
255 reg_class R0R1_regL(R_R0,R_R1);
256 reg_class R2R3_regL(R_R2,R_R3);
257 
258 // ----------------------------
259 // Special Class for Condition Code Flags Register
260 reg_class int_flags(APSR);
261 reg_class float_flags(FPSCR);
262 
263 
264 // ----------------------------
265 // Float Point Register Classes
266 // ----------------------------
267 // Skip S14/S15, they are reserved for mem-mem copies
268 reg_class sflt_reg(R_S0, R_S1, R_S2, R_S3, R_S4, R_S5, R_S6, R_S7, R_S8, R_S9, R_S10, R_S11, R_S12, R_S13,
269                    R_S16, R_S17, R_S18, R_S19, R_S20, R_S21, R_S22, R_S23, R_S24, R_S25, R_S26, R_S27, R_S28, R_S29, R_S30, R_S31);
270 
271 // Paired floating point registers--they show up in the same order as the floats,
272 // but they are used with the &quot;Op_RegD&quot; type, and always occur in even/odd pairs.
273 reg_class dflt_reg(R_S0,R_S1, R_S2,R_S3, R_S4,R_S5, R_S6,R_S7, R_S8,R_S9, R_S10,R_S11, R_S12,R_S13,
274                    R_S16,R_S17, R_S18,R_S19, R_S20,R_S21, R_S22,R_S23, R_S24,R_S25, R_S26,R_S27, R_S28,R_S29, R_S30,R_S31,
275                    R_D16,R_D16x, R_D17,R_D17x, R_D18,R_D18x, R_D19,R_D19x, R_D20,R_D20x, R_D21,R_D21x, R_D22,R_D22x,
276                    R_D23,R_D23x, R_D24,R_D24x, R_D25,R_D25x, R_D26,R_D26x, R_D27,R_D27x, R_D28,R_D28x, R_D29,R_D29x,
277                    R_D30,R_D30x, R_D31,R_D31x);
278 
279 reg_class dflt_low_reg(R_S0,R_S1, R_S2,R_S3, R_S4,R_S5, R_S6,R_S7, R_S8,R_S9, R_S10,R_S11, R_S12,R_S13,
280                        R_S16,R_S17, R_S18,R_S19, R_S20,R_S21, R_S22,R_S23, R_S24,R_S25, R_S26,R_S27, R_S28,R_S29, R_S30,R_S31);
281 
282 
283 reg_class actual_dflt_reg %{
284   if (VM_Version::has_vfp3_32()) {
285     return DFLT_REG_mask();
286   } else {
287     return DFLT_LOW_REG_mask();
288   }
289 %}
290 
291 reg_class S0_regF(R_S0);
292 reg_class D0_regD(R_S0,R_S1);
293 reg_class D1_regD(R_S2,R_S3);
294 reg_class D2_regD(R_S4,R_S5);
295 reg_class D3_regD(R_S6,R_S7);
296 reg_class D4_regD(R_S8,R_S9);
297 reg_class D5_regD(R_S10,R_S11);
298 reg_class D6_regD(R_S12,R_S13);
299 reg_class D7_regD(R_S14,R_S15);
300 
301 reg_class D16_regD(R_D16,R_D16x);
302 reg_class D17_regD(R_D17,R_D17x);
303 reg_class D18_regD(R_D18,R_D18x);
304 reg_class D19_regD(R_D19,R_D19x);
305 reg_class D20_regD(R_D20,R_D20x);
306 reg_class D21_regD(R_D21,R_D21x);
307 reg_class D22_regD(R_D22,R_D22x);
308 reg_class D23_regD(R_D23,R_D23x);
309 reg_class D24_regD(R_D24,R_D24x);
310 reg_class D25_regD(R_D25,R_D25x);
311 reg_class D26_regD(R_D26,R_D26x);
312 reg_class D27_regD(R_D27,R_D27x);
313 reg_class D28_regD(R_D28,R_D28x);
314 reg_class D29_regD(R_D29,R_D29x);
315 reg_class D30_regD(R_D30,R_D30x);
316 reg_class D31_regD(R_D31,R_D31x);
317 
318 reg_class vectorx_reg(R_S0,R_S1,R_S2,R_S3, R_S4,R_S5,R_S6,R_S7,
319                       R_S8,R_S9,R_S10,R_S11, /* skip S14/S15 */
320                       R_S16,R_S17,R_S18,R_S19, R_S20,R_S21,R_S22,R_S23,
321                       R_S24,R_S25,R_S26,R_S27, R_S28,R_S29,R_S30,R_S31,
322                       R_D16,R_D16x,R_D17,R_D17x, R_D18,R_D18x,R_D19,R_D19x,
323                       R_D20,R_D20x,R_D21,R_D21x, R_D22,R_D22x,R_D23,R_D23x,
324                       R_D24,R_D24x,R_D25,R_D25x, R_D26,R_D26x,R_D27,R_D27x,
325                       R_D28,R_D28x,R_D29,R_D29x, R_D30,R_D30x,R_D31,R_D31x);
326 
327 %}
328 
329 source_hpp %{
330 // FIXME
331 const MachRegisterNumbers R_mem_copy_lo_num = R_S14_num;
332 const MachRegisterNumbers R_mem_copy_hi_num = R_S15_num;
333 const FloatRegister Rmemcopy = S14;
334 const MachRegisterNumbers R_hf_ret_lo_num = R_S0_num;
335 const MachRegisterNumbers R_hf_ret_hi_num = R_S1_num;
336 
337 const MachRegisterNumbers R_Ricklass_num = R_R8_num;
338 const MachRegisterNumbers R_Rmethod_num  = R_R9_num;
339 
340 #define LDR_DOUBLE &quot;FLDD&quot;
341 #define LDR_FLOAT  &quot;FLDS&quot;
342 #define STR_DOUBLE &quot;FSTD&quot;
343 #define STR_FLOAT  &quot;FSTS&quot;
344 #define LDR_64     &quot;LDRD&quot;
345 #define STR_64     &quot;STRD&quot;
346 #define LDR_32     &quot;LDR&quot;
347 #define STR_32     &quot;STR&quot;
348 #define MOV_DOUBLE &quot;FCPYD&quot;
349 #define MOV_FLOAT  &quot;FCPYS&quot;
350 #define FMSR       &quot;FMSR&quot;
351 #define FMRS       &quot;FMRS&quot;
352 #define LDREX      &quot;ldrex &quot;
353 #define STREX      &quot;strex &quot;
354 
355 #define str_64     strd
356 #define ldr_64     ldrd
357 #define ldr_32     ldr
358 #define ldrex      ldrex
359 #define strex      strex
360 
361 static inline bool is_memoryD(int offset) {
362   return offset &lt; 1024 &amp;&amp; offset &gt; -1024;
363 }
364 
365 static inline bool is_memoryfp(int offset) {
366   return offset &lt; 1024 &amp;&amp; offset &gt; -1024;
367 }
368 
369 static inline bool is_memoryI(int offset) {
370   return offset &lt; 4096 &amp;&amp; offset &gt; -4096;
371 }
372 
373 static inline bool is_memoryP(int offset) {
374   return offset &lt; 4096 &amp;&amp; offset &gt; -4096;
375 }
376 
377 static inline bool is_memoryHD(int offset) {
378   return offset &lt; 256 &amp;&amp; offset &gt; -256;
379 }
380 
381 static inline bool is_aimm(int imm) {
382   return AsmOperand::is_rotated_imm(imm);
383 }
384 
385 static inline bool is_limmI(jint imm) {
386   return AsmOperand::is_rotated_imm(imm);
387 }
388 
389 static inline bool is_limmI_low(jint imm, int n) {
390   int imml = imm &amp; right_n_bits(n);
391   return is_limmI(imml) || is_limmI(imm);
392 }
393 
394 static inline int limmI_low(jint imm, int n) {
395   int imml = imm &amp; right_n_bits(n);
396   return is_limmI(imml) ? imml : imm;
397 }
398 
399 %}
400 
401 source %{
402 
403 // Given a register encoding, produce a Integer Register object
404 static Register reg_to_register_object(int register_encoding) {
405   assert(R0-&gt;encoding() == R_R0_enc &amp;&amp; R15-&gt;encoding() == R_R15_enc, &quot;right coding&quot;);
406   return as_Register(register_encoding);
407 }
408 
409 // Given a register encoding, produce a single-precision Float Register object
410 static FloatRegister reg_to_FloatRegister_object(int register_encoding) {
411   assert(S0-&gt;encoding() == R_S0_enc &amp;&amp; S31-&gt;encoding() == R_S31_enc, &quot;right coding&quot;);
412   return as_FloatRegister(register_encoding);
413 }
414 
415 void Compile::pd_compiler2_init() {
416   // Umimplemented
417 }
418 
419 // Location of compiled Java return values.  Same as C
420 OptoRegPair c2::return_value(int ideal_reg) {
421   assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
422 #ifndef __ABI_HARD__
423   static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, R_R0_num,     R_R0_num,     R_R0_num,     R_R0_num, R_R0_num };
424   static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_R1_num, R_R1_num };
425 #else
426   static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, R_R0_num,     R_R0_num,     R_hf_ret_lo_num,  R_hf_ret_lo_num, R_R0_num };
427   static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad,     R_hf_ret_hi_num, R_R1_num };
428 #endif
429   return OptoRegPair( hi[ideal_reg], lo[ideal_reg]);
430 }
431 
432 // !!!!! Special hack to get all type of calls to specify the byte offset
433 //       from the start of the call to the point where the return address
434 //       will point.
435 
436 int MachCallStaticJavaNode::ret_addr_offset() {
437   bool far = (_method == NULL) ? maybe_far_call(this) : !cache_reachable();
438   return ((far ? 3 : 1) + (_method_handle_invoke ? 1 : 0)) *
439     NativeInstruction::instruction_size;
440 }
441 
442 int MachCallDynamicJavaNode::ret_addr_offset() {
443   bool far = !cache_reachable();
444   // mov_oop is always 2 words
445   return (2 + (far ? 3 : 1)) * NativeInstruction::instruction_size; 
446 }
447 
448 int MachCallRuntimeNode::ret_addr_offset() {
449   // bl or movw; movt; blx
450   bool far = maybe_far_call(this);
451   return (far ? 3 : 1) * NativeInstruction::instruction_size;
452 }
453 %}
454 
455 // The intptr_t operand types, defined by textual substitution.
456 // (Cf. opto/type.hpp.  This lets us avoid many, many other ifdefs.)
457 #define immX      immI
458 #define immXRot   immIRot
459 #define iRegX     iRegI
460 #define aimmX     aimmI
461 #define limmX     limmI
462 #define immX10x2  immI10x2
463 #define LShiftX   LShiftI
464 #define shimmX    immU5
465 
466 // Compatibility interface
467 #define aimmP     immPRot
468 #define immIMov   immIRot
469 
470 #define store_RegL     iRegL
471 #define store_RegLd    iRegLd
472 #define store_RegI     iRegI
473 #define store_ptr_RegP iRegP
474 
475 //----------ATTRIBUTES---------------------------------------------------------
476 //----------Operand Attributes-------------------------------------------------
477 op_attrib op_cost(1);          // Required cost attribute
478 
479 //----------OPERANDS-----------------------------------------------------------
480 // Operand definitions must precede instruction definitions for correct parsing
481 // in the ADLC because operands constitute user defined types which are used in
482 // instruction definitions.
483 
484 //----------Simple Operands----------------------------------------------------
485 // Immediate Operands
486 
487 operand immIRot() %{
488   predicate(AsmOperand::is_rotated_imm(n-&gt;get_int()));
489   match(ConI);
490 
491   op_cost(0);
492   // formats are generated automatically for constants and base registers
493   format %{ %}
494   interface(CONST_INTER);
495 %}
496 
497 operand immIRotn() %{
498   predicate(n-&gt;get_int() != 0 &amp;&amp; AsmOperand::is_rotated_imm(~n-&gt;get_int()));
499   match(ConI);
500 
501   op_cost(0);
502   // formats are generated automatically for constants and base registers
503   format %{ %}
504   interface(CONST_INTER);
505 %}
506 
507 operand immIRotneg() %{
508   // if AsmOperand::is_rotated_imm() is true for this constant, it is
509   // a immIRot and an optimal instruction combination exists to handle the
510   // constant as an immIRot
511   predicate(!AsmOperand::is_rotated_imm(n-&gt;get_int()) &amp;&amp; AsmOperand::is_rotated_imm(-n-&gt;get_int()));
512   match(ConI);
513 
514   op_cost(0);
515   // formats are generated automatically for constants and base registers
516   format %{ %}
517   interface(CONST_INTER);
518 %}
519 
520 // Non-negative integer immediate that is encodable using the rotation scheme,
521 // and that when expanded fits in 31 bits.
522 operand immU31Rot() %{
523   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; AsmOperand::is_rotated_imm(n-&gt;get_int()));
524   match(ConI);
525 
526   op_cost(0);
527   // formats are generated automatically for constants and base registers
528   format %{ %}
529   interface(CONST_INTER);
530 %}
531 
532 operand immPRot() %{
533   predicate(n-&gt;get_ptr() == 0 || (AsmOperand::is_rotated_imm(n-&gt;get_ptr()) &amp;&amp; ((ConPNode*)n)-&gt;type()-&gt;reloc() == relocInfo::none));
534 
535   match(ConP);
536 
537   op_cost(0);
538   // formats are generated automatically for constants and base registers
539   format %{ %}
540   interface(CONST_INTER);
541 %}
542 
543 operand immLlowRot() %{
544   predicate(n-&gt;get_long() &gt;&gt; 32 == 0 &amp;&amp; AsmOperand::is_rotated_imm((int)n-&gt;get_long()));
545   match(ConL);
546   op_cost(0);
547 
548   format %{ %}
549   interface(CONST_INTER);
550 %}
551 
552 operand immLRot2() %{
553   predicate(AsmOperand::is_rotated_imm((int)(n-&gt;get_long() &gt;&gt; 32)) &amp;&amp;
554             AsmOperand::is_rotated_imm((int)(n-&gt;get_long())));
555   match(ConL);
556   op_cost(0);
557 
558   format %{ %}
559   interface(CONST_INTER);
560 %}
561 
562 // Integer Immediate: 12-bit - for addressing mode
563 operand immI12() %{
564   predicate((-4096 &lt; n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 4096));
565   match(ConI);
566   op_cost(0);
567 
568   format %{ %}
569   interface(CONST_INTER);
570 %}
571 
572 // Integer Immediate: 10-bit disp and disp+4 - for addressing float pair
573 operand immI10x2() %{
574   predicate((-1024 &lt; n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 1024 - 4));
575   match(ConI);
576   op_cost(0);
577 
578   format %{ %}
579   interface(CONST_INTER);
580 %}
581 
582 // Integer Immediate: 12-bit disp and disp+4 - for addressing word pair
583 operand immI12x2() %{
584   predicate((-4096 &lt; n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 4096 - 4));
585   match(ConI);
586   op_cost(0);
587 
588   format %{ %}
589   interface(CONST_INTER);
590 %}
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/arm/interpreterRT_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.inline.hpp&quot;
 27 #include &quot;interpreter/interp_masm.hpp&quot;
 28 #include &quot;interpreter/interpreter.hpp&quot;
 29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/universe.hpp&quot;
 32 #include &quot;oops/method.hpp&quot;
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/icache.hpp&quot;
 36 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 37 #include &quot;runtime/signature.hpp&quot;
 38 
 39 #define __ _masm-&gt;
 40 
 41 InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 42     const methodHandle&amp; method, CodeBuffer* buffer) : NativeSignatureIterator(method) {
 43   _masm = new MacroAssembler(buffer);
 44   _abi_offset = 0;
 45   _ireg = is_static() ? 2 : 1;
 46 #ifdef __ABI_HARD__
 47   _fp_slot = 0;
 48   _single_fpr_slot = 0;
 49 #endif
 50 }
 51 
 52 #ifdef SHARING_FAST_NATIVE_FINGERPRINTS
 53 // mapping from SignatureIterator param to (common) type of parsing
 54 static const u1 shared_type[] = {
 55   (u1) SignatureIterator::int_parm, // bool
 56   (u1) SignatureIterator::int_parm, // byte
 57   (u1) SignatureIterator::int_parm, // char
 58   (u1) SignatureIterator::int_parm, // short
 59   (u1) SignatureIterator::int_parm, // int
 60   (u1) SignatureIterator::long_parm, // long
 61 #ifndef __ABI_HARD__
 62   (u1) SignatureIterator::int_parm, // float, passed as int
 63   (u1) SignatureIterator::long_parm, // double, passed as long
 64 #else
 65   (u1) SignatureIterator::float_parm, // float
 66   (u1) SignatureIterator::double_parm, // double
 67 #endif
 68   (u1) SignatureIterator::obj_parm, // obj
 69   (u1) SignatureIterator::done_parm // done
 70 };
 71 
 72 uint64_t InterpreterRuntime::normalize_fast_native_fingerprint(uint64_t fingerprint) {
 73   if (fingerprint == UCONST64(-1)) {
 74     // special signature used when the argument list cannot be encoded in a 64 bits value
 75     return fingerprint;
 76   }
 77   int shift = SignatureIterator::static_feature_size;
 78   uint64_t result = fingerprint &amp; ((1 &lt;&lt; shift) - 1);
 79   fingerprint &gt;&gt;= shift;
 80 
 81   BasicType ret_type = (BasicType) (fingerprint &amp; SignatureIterator::result_feature_mask);
 82   // For ARM, the fast signature handler only needs to know whether
 83   // the return value must be unboxed. T_OBJECT and T_ARRAY need not
 84   // be distinguished from each other and all other return values
 85   // behave like integers with respect to the handler except T_BOOLEAN
 86   // which must be mapped to the range 0..1.
 87   bool unbox = (ret_type == T_OBJECT) || (ret_type == T_ARRAY);
 88   if (unbox) {
 89     ret_type = T_OBJECT;
 90   } else if (ret_type != T_BOOLEAN) {
 91     ret_type = T_INT;
 92   }
 93   result |= ((uint64_t) ret_type) &lt;&lt; shift;
 94   shift += SignatureIterator::result_feature_size;
 95   fingerprint &gt;&gt;= SignatureIterator::result_feature_size;
 96 
 97   while (true) {
 98     uint32_t type = (uint32_t) (fingerprint &amp; SignatureIterator::parameter_feature_mask);
 99     if (type == SignatureIterator::done_parm) {
100       result |= ((uint64_t) SignatureIterator::done_parm) &lt;&lt; shift;
101       return result;
102     }
103     assert((type &gt;= SignatureIterator::bool_parm) &amp;&amp; (type &lt;= SignatureIterator::obj_parm), &quot;check fingerprint encoding&quot;);
104     int shared = shared_type[type - SignatureIterator::bool_parm];
105     result |= ((uint64_t) shared) &lt;&lt; shift;
106     shift += SignatureIterator::parameter_feature_size;
107     fingerprint &gt;&gt;= SignatureIterator::parameter_feature_size;
108   }
109 }
110 #endif // SHARING_FAST_NATIVE_FINGERPRINTS
111 
112 // Implementation of SignatureHandlerGenerator
113 void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
114   if (_ireg &lt; GPR_PARAMS) {
115     Register dst = as_Register(_ireg);
116     __ ldr_s32(dst, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
117     _ireg++;
118   } else {
119     __ ldr_s32(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
120     __ str_32(Rtemp, Address(SP, _abi_offset * wordSize));
121     _abi_offset++;
122   }
123 }
124 
125 void InterpreterRuntime::SignatureHandlerGenerator::pass_long() {
126   if (_ireg &lt;= 2) {
127 #if (ALIGN_WIDE_ARGUMENTS == 1)
128     if ((_ireg &amp; 1) != 0) {
129       // 64-bit values should be 8-byte aligned
130       _ireg++;
131     }
132 #endif
133     Register dst1 = as_Register(_ireg);
134     Register dst2 = as_Register(_ireg+1);
135     __ ldr(dst1, Address(Rlocals, Interpreter::local_offset_in_bytes(offset()+1)));
136     __ ldr(dst2, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
137     _ireg += 2;
138 #if (ALIGN_WIDE_ARGUMENTS == 0)
139   } else if (_ireg == 3) {
140     // uses R3 + one stack slot
141     Register dst1 = as_Register(_ireg);
142     __ ldr(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
143     __ ldr(dst1, Address(Rlocals, Interpreter::local_offset_in_bytes(offset()+1)));
144     __ str(Rtemp, Address(SP, _abi_offset * wordSize));
145     _ireg += 1;
146     _abi_offset += 1;
147 #endif
148   } else {
149 #if (ALIGN_WIDE_ARGUMENTS == 1)
150     if(_abi_offset &amp; 1) _abi_offset++;
151 #endif
152     __ ldr(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset()+1)));
153     __ str(Rtemp, Address(SP, (_abi_offset) * wordSize));
154     __ ldr(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
155     __ str(Rtemp, Address(SP, (_abi_offset+1) * wordSize));
156     _abi_offset += 2;
157     _ireg = 4;
158   }
159 }
160 
161 void InterpreterRuntime::SignatureHandlerGenerator::pass_object() {
162   if (_ireg &lt; 4) {
163     Register dst = as_Register(_ireg);
164     __ ldr(dst, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
165     __ cmp(dst, 0);
166     __ sub(dst, Rlocals, -Interpreter::local_offset_in_bytes(offset()), ne);
167     _ireg++;
168   } else {
169     __ ldr(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
170     __ cmp(Rtemp, 0);
171     __ sub(Rtemp, Rlocals, -Interpreter::local_offset_in_bytes(offset()), ne);
172     __ str(Rtemp, Address(SP, _abi_offset * wordSize));
173     _abi_offset++;
174   }
175 }
176 
177 #ifndef __ABI_HARD__
178 void InterpreterRuntime::SignatureHandlerGenerator::pass_float() {
179   if (_ireg &lt; 4) {
180     Register dst = as_Register(_ireg);
181     __ ldr(dst, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
182     _ireg++;
183   } else {
184     __ ldr(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
185     __ str(Rtemp, Address(SP, _abi_offset * wordSize));
186     _abi_offset++;
187   }
188 }
189 
190 #else
191 #ifndef __SOFTFP__
192 void InterpreterRuntime::SignatureHandlerGenerator::pass_float() {
193     if((_fp_slot &lt; 16) || (_single_fpr_slot &amp; 1)) {
194       if ((_single_fpr_slot &amp; 1) == 0) {
195         _single_fpr_slot = _fp_slot;
196         _fp_slot += 2;
197       }
198       __ flds(as_FloatRegister(_single_fpr_slot), Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
199       _single_fpr_slot++;
200     } else {
201       __ ldr(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
202       __ str(Rtemp, Address(SP, _abi_offset * wordSize));
203       _abi_offset++;
204     }
205 }
206 
207 void InterpreterRuntime::SignatureHandlerGenerator::pass_double() {
208     if(_fp_slot &lt;= 14) {
209       __ fldd(as_FloatRegister(_fp_slot), Address(Rlocals, Interpreter::local_offset_in_bytes(offset()+1)));
210       _fp_slot += 2;
211     } else {
212       __ ldr(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset()+1)));
213       __ str(Rtemp, Address(SP, (_abi_offset) * wordSize));
214       __ ldr(Rtemp, Address(Rlocals, Interpreter::local_offset_in_bytes(offset())));
215       __ str(Rtemp, Address(SP, (_abi_offset+1) * wordSize));
216       _abi_offset += 2;
217       _single_fpr_slot = 16;
218     }
219 }
220 #endif // __SOFTFP__
221 #endif // __ABI_HARD__
222 
223 void InterpreterRuntime::SignatureHandlerGenerator::generate(uint64_t fingerprint) {
224   iterate(fingerprint);
225 
226   BasicType result_type = SignatureIterator::return_type(fingerprint);
227 
228   address result_handler = Interpreter::result_handler(result_type);
229 
230   __ mov_slow(R0, (intptr_t)result_handler);
231 
232   __ ret();
233 }
234 
235 
236 // Implementation of SignatureHandlerLibrary
237 
238 void SignatureHandlerLibrary::pd_set_handler(address handler) {}
239 
240 class SlowSignatureHandler: public NativeSignatureIterator {
241  private:
242   address   _from;
243   intptr_t* _to;
244 
245 #ifndef __ABI_HARD__
246   virtual void pass_int() {
247     *_to++ = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
248     _from -= Interpreter::stackElementSize;
249   }
250 
251   virtual void pass_float() {
252     *_to++ = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
253     _from -= Interpreter::stackElementSize;
254   }
255 
256   virtual void pass_long() {
257 #if (ALIGN_WIDE_ARGUMENTS == 1)
258     if (((intptr_t)_to &amp; 7) != 0) {
259       // 64-bit values should be 8-byte aligned
260       _to++;
261     }
262 #endif
263     _to[0] = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(1));
264     _to[1] = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(0));
265     _to += 2;
266     _from -= 2*Interpreter::stackElementSize;
267   }
268 
269   virtual void pass_object() {
270     intptr_t from_addr = (intptr_t)(_from + Interpreter::local_offset_in_bytes(0));
271     *_to++ = (*(intptr_t*)from_addr == 0) ? (intptr_t)NULL : from_addr;
272     _from -= Interpreter::stackElementSize;
273    }
274 
275 #else
276 
277   intptr_t* _toFP;
278   intptr_t* _toGP;
279   int       _last_gp;
280   int       _last_fp;
281   int       _last_single_fp;
282 
283   virtual void pass_int() {
284     if(_last_gp &lt; GPR_PARAMS) {
285       _toGP[_last_gp++] = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
286     } else {
287       *_to++ = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
288     }
289     _from -= Interpreter::stackElementSize;
290   }
291 
292   virtual void pass_long() {
293     assert(ALIGN_WIDE_ARGUMENTS == 1, &quot;ABI_HARD not supported with unaligned wide arguments&quot;);
294     if (_last_gp &lt;= 2) {
295       if(_last_gp &amp; 1) _last_gp++;
296       _toGP[_last_gp++] = *(jint *)(_from+Interpreter::local_offset_in_bytes(1));
297       _toGP[_last_gp++] = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
298     } else {
299       if (((intptr_t)_to &amp; 7) != 0) {
300         // 64-bit values should be 8-byte aligned
301         _to++;
302       }
303       _to[0] = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(1));
304       _to[1] = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(0));
305       _to += 2;
306       _last_gp = 4;
307     }
308     _from -= 2*Interpreter::stackElementSize;
309   }
310 
311   virtual void pass_object() {
312     intptr_t from_addr = (intptr_t)(_from + Interpreter::local_offset_in_bytes(0));
313     if(_last_gp &lt; GPR_PARAMS) {
314       _toGP[_last_gp++] = (*(intptr_t*)from_addr == 0) ? NULL : from_addr;
315     } else {
316       *_to++ = (*(intptr_t*)from_addr == 0) ? NULL : from_addr;
317     }
318     _from -= Interpreter::stackElementSize;
319   }
320 
321   virtual void pass_float() {
322     if((_last_fp &lt; 16) || (_last_single_fp &amp; 1)) {
323       if ((_last_single_fp &amp; 1) == 0) {
324         _last_single_fp = _last_fp;
325         _last_fp += 2;
326       }
327 
328       _toFP[_last_single_fp++] = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
329     } else {
330       *_to++ = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
331     }
332     _from -= Interpreter::stackElementSize;
333   }
334 
335   virtual void pass_double() {
336     assert(ALIGN_WIDE_ARGUMENTS == 1, &quot;ABI_HARD not supported with unaligned wide arguments&quot;);
337     if(_last_fp &lt;= 14) {
338       _toFP[_last_fp++] = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(1));
339       _toFP[_last_fp++] = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(0));
340     } else {
341       if (((intptr_t)_to &amp; 7) != 0) {      // 64-bit values should be 8-byte aligned
342         _to++;
343       }
344       _to[0] = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(1));
345       _to[1] = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(0));
346       _to += 2;
347       _last_single_fp = 16;
348     }
349     _from -= 2*Interpreter::stackElementSize;
350   }
351 
352 #endif // !__ABI_HARD__
353 
354  public:
355   SlowSignatureHandler(const methodHandle&amp; method, address from, intptr_t* to) :
356     NativeSignatureIterator(method) {
357     _from = from;
358 
359 #ifdef __ABI_HARD__
360     _toGP  = to;
361     _toFP = _toGP + GPR_PARAMS;
362     _to   = _toFP + (8*2);
363     _last_gp = (is_static() ? 2 : 1);
364     _last_fp = 0;
365     _last_single_fp = 0;
366 #else
367     _to   = to + (is_static() ? 2 : 1);
368 #endif // __ABI_HARD__
369   }
370 };
371 
372 IRT_ENTRY(address, InterpreterRuntime::slow_signature_handler(JavaThread* thread, Method* method, intptr_t* from, intptr_t* to))
373   methodHandle m(thread, (Method*)method);
374   assert(m-&gt;is_native(), &quot;sanity check&quot;);
375   SlowSignatureHandler(m, (address)from, to).iterate(UCONST64(-1));
376   return Interpreter::result_handler(m-&gt;result_type());
377 IRT_END
    </pre>
  </body>
</html>
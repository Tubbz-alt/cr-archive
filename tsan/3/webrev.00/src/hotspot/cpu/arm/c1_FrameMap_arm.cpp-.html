<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/arm/c1_FrameMap_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;c1/c1_FrameMap.hpp&quot;
 27 #include &quot;c1/c1_LIR.hpp&quot;
 28 #include &quot;runtime/sharedRuntime.hpp&quot;
 29 #include &quot;vmreg_arm.inline.hpp&quot;
 30 
 31 LIR_Opr FrameMap::R0_opr;
 32 LIR_Opr FrameMap::R1_opr;
 33 LIR_Opr FrameMap::R2_opr;
 34 LIR_Opr FrameMap::R3_opr;
 35 LIR_Opr FrameMap::R4_opr;
 36 LIR_Opr FrameMap::R5_opr;
 37 
 38 LIR_Opr FrameMap::R0_oop_opr;
 39 LIR_Opr FrameMap::R1_oop_opr;
 40 LIR_Opr FrameMap::R2_oop_opr;
 41 LIR_Opr FrameMap::R3_oop_opr;
 42 LIR_Opr FrameMap::R4_oop_opr;
 43 LIR_Opr FrameMap::R5_oop_opr;
 44 
 45 LIR_Opr FrameMap::R0_metadata_opr;
 46 LIR_Opr FrameMap::R1_metadata_opr;
 47 LIR_Opr FrameMap::R2_metadata_opr;
 48 LIR_Opr FrameMap::R3_metadata_opr;
 49 LIR_Opr FrameMap::R4_metadata_opr;
 50 LIR_Opr FrameMap::R5_metadata_opr;
 51 
 52 
 53 LIR_Opr FrameMap::LR_opr;
 54 LIR_Opr FrameMap::LR_oop_opr;
 55 LIR_Opr FrameMap::LR_ptr_opr;
 56 LIR_Opr FrameMap::FP_opr;
 57 LIR_Opr FrameMap::SP_opr;
 58 LIR_Opr FrameMap::Rthread_opr;
 59 
 60 LIR_Opr FrameMap::Int_result_opr;
 61 LIR_Opr FrameMap::Long_result_opr;
 62 LIR_Opr FrameMap::Object_result_opr;
 63 LIR_Opr FrameMap::Float_result_opr;
 64 LIR_Opr FrameMap::Double_result_opr;
 65 
 66 LIR_Opr FrameMap::Exception_oop_opr;
 67 LIR_Opr FrameMap::Exception_pc_opr;
 68 
 69 LIR_Opr FrameMap::_caller_save_cpu_regs[] = { 0 };
 70 LIR_Opr FrameMap::_caller_save_fpu_regs[];  // same as initialize to zero
 71 
 72 LIR_Opr FrameMap::map_to_opr(BasicType type, VMRegPair* reg, bool) {
 73   LIR_Opr opr = LIR_OprFact::illegalOpr;
 74   VMReg r_1 = reg-&gt;first();
 75   VMReg r_2 = reg-&gt;second();
 76   if (r_1-&gt;is_stack()) {
 77     int st_off = (r_1-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 78     opr = LIR_OprFact::address(new LIR_Address(SP_opr, st_off, type));
 79   } else if (r_1-&gt;is_Register()) {
 80     Register reg = r_1-&gt;as_Register();
 81     if (r_2-&gt;is_Register() &amp;&amp; (type == T_LONG || type == T_DOUBLE)) {
 82       opr = as_long_opr(reg, r_2-&gt;as_Register());
 83     } else if (type == T_OBJECT || type == T_ARRAY) {
 84       opr = as_oop_opr(reg);
 85     } else if (type == T_METADATA) {
 86       opr = as_metadata_opr(reg);
 87     } else {
 88       // PreferInterpreterNativeStubs should ensure we never need to
 89       // handle a long opr passed as R3+stack_slot
 90       assert(! r_2-&gt;is_stack(), &quot;missing support for ALIGN_WIDE_ARGUMENTS==0&quot;);
 91       opr = as_opr(reg);
 92     }
 93   } else if (r_1-&gt;is_FloatRegister()) {
 94     FloatRegister reg = r_1-&gt;as_FloatRegister();
 95     opr = type == T_FLOAT ? as_float_opr(reg) : as_double_opr(reg);
 96   } else {
 97     ShouldNotReachHere();
 98   }
 99   return opr;
100 }
101 
102 
103 void FrameMap::initialize() {
104   if (_init_done) return;
105 
106   int i;
107   int rnum = 0;
108 
109   // Registers used for allocation
110   assert(Rthread == R10 &amp;&amp; Rtemp == R12, &quot;change the code here&quot;);
111   for (i = 0; i &lt; 10; i++) {
112     map_register(rnum++, as_Register(i));
113   }
114   assert(rnum == pd_nof_cpu_regs_reg_alloc, &quot;should be&quot;);
115 
116   // Registers not used for allocation
117   map_register(rnum++, LR); // LR register should be listed first, see c1_LinearScan_arm.hpp::is_processed_reg_num.
118   assert(rnum == pd_nof_cpu_regs_processed_in_linearscan, &quot;should be&quot;);
119 
120   map_register(rnum++, Rtemp);
121   map_register(rnum++, Rthread);
122   map_register(rnum++, FP); // ARM32: R7 or R11
123   map_register(rnum++, SP);
124   map_register(rnum++, PC);
125   assert(rnum == pd_nof_cpu_regs_frame_map, &quot;should be&quot;);
126 
127   _init_done = true;
128 
129   R0_opr  = as_opr(R0);   R0_oop_opr = as_oop_opr(R0);    R0_metadata_opr = as_metadata_opr(R0);
130   R1_opr  = as_opr(R1);   R1_oop_opr = as_oop_opr(R1);    R1_metadata_opr = as_metadata_opr(R1);
131   R2_opr  = as_opr(R2);   R2_oop_opr = as_oop_opr(R2);    R2_metadata_opr = as_metadata_opr(R2);
132   R3_opr  = as_opr(R3);   R3_oop_opr = as_oop_opr(R3);    R3_metadata_opr = as_metadata_opr(R3);
133   R4_opr  = as_opr(R4);   R4_oop_opr = as_oop_opr(R4);    R4_metadata_opr = as_metadata_opr(R4);
134   R5_opr  = as_opr(R5);   R5_oop_opr = as_oop_opr(R5);    R5_metadata_opr = as_metadata_opr(R5);
135 
136 
137   LR_opr      = as_opr(LR);
138   LR_oop_opr  = as_oop_opr(LR);
139   LR_ptr_opr  = as_pointer_opr(LR);
140   FP_opr      = as_pointer_opr(FP);
141   SP_opr      = as_pointer_opr(SP);
142   Rthread_opr = as_pointer_opr(Rthread);
143 
144   // LIR operands for result
145   Int_result_opr = R0_opr;
146   Object_result_opr = R0_oop_opr;
147   Long_result_opr = as_long_opr(R0, R1);
148 #ifdef __ABI_HARD__
149   Float_result_opr = as_float_opr(S0);
150   Double_result_opr = as_double_opr(D0);
151 #else
152   Float_result_opr = LIR_OprFact::single_softfp(0);
153   Double_result_opr = LIR_OprFact::double_softfp(0, 1);
154 #endif // __ABI_HARD__
155 
156   Exception_oop_opr = as_oop_opr(Rexception_obj);
157   Exception_pc_opr = as_opr(Rexception_pc);
158 
159   for (i = 0; i &lt; nof_caller_save_cpu_regs(); i++) {
160     _caller_save_cpu_regs[i] = LIR_OprFact::single_cpu(i);
161   }
162   for (i = 0; i &lt; nof_caller_save_fpu_regs; i++) {
163     _caller_save_fpu_regs[i] = LIR_OprFact::single_fpu(i);
164   }
165 }
166 
167 
168 Address FrameMap::make_new_address(ByteSize sp_offset) const {
169   return Address(SP, sp_offset);
170 }
171 
172 LIR_Opr FrameMap::stack_pointer() {
173   return FrameMap::SP_opr;
174 }
175 
176 LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {
177   assert(Rmh_SP_save == FP, &quot;Fix register used for saving SP for MethodHandle calls&quot;);
178   return FP_opr;
179 }
180 
181 bool FrameMap::validate_frame() {
182   int max_offset = in_bytes(framesize_in_bytes());
183   int java_index = 0;
184   for (int i = 0; i &lt; _incoming_arguments-&gt;length(); i++) {
185     LIR_Opr opr = _incoming_arguments-&gt;at(i);
186     if (opr-&gt;is_stack()) {
187       int arg_offset = _argument_locations-&gt;at(java_index);
188       if (arg_offset &gt; max_offset) {
189         max_offset = arg_offset;
190       }
191     }
192     java_index += type2size[opr-&gt;type()];
193   }
194   return max_offset &lt; 4096;
195 }
196 
197 VMReg FrameMap::fpu_regname(int n) {
198   return as_FloatRegister(n)-&gt;as_VMReg();
199 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/arm/vm_version_arm_32.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vm_version_arm.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_ext_arm.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/vm_version_arm_32.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,21 ***</span>
  #include &quot;asm/macroAssembler.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/stubCodeGenerator.hpp&quot;
<span class="line-modified">! #include &quot;vm_version_arm.hpp&quot;</span>
  
  int  VM_Version::_stored_pc_adjustment = 4;
  int  VM_Version::_arm_arch             = 5;
  bool VM_Version::_is_initialized       = false;
  int VM_Version::_kuser_helper_version  = 0;
  
  extern &quot;C&quot; {
    typedef int (*get_cpu_info_t)();
    typedef bool (*check_vfp_t)(double *d);
    typedef bool (*check_simd_t)();
  }
  
  #define __ _masm-&gt;
  
  class VM_Version_StubGenerator: public StubCodeGenerator {
<span class="line-new-header">--- 27,22 ---</span>
  #include &quot;asm/macroAssembler.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/stubCodeGenerator.hpp&quot;
<span class="line-modified">! #include &quot;runtime/vm_version.hpp&quot;</span>
  
  int  VM_Version::_stored_pc_adjustment = 4;
  int  VM_Version::_arm_arch             = 5;
  bool VM_Version::_is_initialized       = false;
  int VM_Version::_kuser_helper_version  = 0;
  
  extern &quot;C&quot; {
    typedef int (*get_cpu_info_t)();
    typedef bool (*check_vfp_t)(double *d);
    typedef bool (*check_simd_t)();
<span class="line-added">+   typedef bool (*check_mp_ext_t)(int *addr);</span>
  }
  
  #define __ _masm-&gt;
  
  class VM_Version_StubGenerator: public StubCodeGenerator {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,18 ***</span>
<span class="line-new-header">--- 94,33 ---</span>
      __ mov(R0, 1);
      __ bx(LR);
  
      return start;
    };
<span class="line-added">+ </span>
<span class="line-added">+   address generate_check_mp_ext() {</span>
<span class="line-added">+     StubCodeMark mark(this, &quot;VM_Version&quot;, &quot;check_mp_ext&quot;);</span>
<span class="line-added">+     address start = __ pc();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // PLDW is available with Multiprocessing Extensions only</span>
<span class="line-added">+     __ pldw(Address(R0));</span>
<span class="line-added">+     // Return true if instruction caused no signals</span>
<span class="line-added">+     __ mov(R0, 1);</span>
<span class="line-added">+     // JVM_handle_linux_signal moves PC here if SIGILL happens</span>
<span class="line-added">+     __ bx(LR);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return start;</span>
<span class="line-added">+   };</span>
  };
  
  #undef __
  
  
  extern &quot;C&quot; address check_vfp3_32_fault_instr;
  extern &quot;C&quot; address check_vfp_fault_instr;
  extern &quot;C&quot; address check_simd_fault_instr;
<span class="line-added">+ extern &quot;C&quot; address check_mp_ext_fault_instr;</span>
  
  void VM_Version::early_initialize() {
  
    // Make sure that _arm_arch is initialized so that any calls to OrderAccess will
    // use proper dmb instruction
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,10 ***</span>
<span class="line-new-header">--- 179,17 ---</span>
      }
    }
  #endif
  #endif
  
<span class="line-added">+   address check_mp_ext_pc = g.generate_check_mp_ext();</span>
<span class="line-added">+   check_mp_ext_t check_mp_ext = CAST_TO_FN_PTR(check_mp_ext_t, check_mp_ext_pc);</span>
<span class="line-added">+   check_mp_ext_fault_instr = (address)check_mp_ext;</span>
<span class="line-added">+   int dummy_local_variable;</span>
<span class="line-added">+   if (check_mp_ext(&amp;dummy_local_variable)) {</span>
<span class="line-added">+     _features |= mp_ext_m;</span>
<span class="line-added">+   }</span>
  
    if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
      warning(&quot;AES intrinsics are not available on this CPU&quot;);
      FLAG_SET_DEFAULT(UseAESIntrinsics, false);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,15 ***</span>
  #ifdef COMPILER2
    assert(_supports_cx8 &amp;&amp; _supports_atomic_getset4 &amp;&amp; _supports_atomic_getadd4
           &amp;&amp; _supports_atomic_getset8 &amp;&amp; _supports_atomic_getadd8, &quot;C2: atomic operations must be supported&quot;);
  #endif
    char buf[512];
<span class="line-modified">!   jio_snprintf(buf, sizeof(buf), &quot;(ARMv%d)%s%s%s&quot;,</span>
                 _arm_arch,
                 (has_vfp() ? &quot;, vfp&quot; : &quot;&quot;),
                 (has_vfp3_32() ? &quot;, vfp3-32&quot; : &quot;&quot;),
<span class="line-modified">!                (has_simd() ? &quot;, simd&quot; : &quot;&quot;));</span>
  
    // buf is started with &quot;, &quot; or is empty
    _features_string = os::strdup(buf);
  
    if (has_simd()) {
<span class="line-new-header">--- 268,16 ---</span>
  #ifdef COMPILER2
    assert(_supports_cx8 &amp;&amp; _supports_atomic_getset4 &amp;&amp; _supports_atomic_getadd4
           &amp;&amp; _supports_atomic_getset8 &amp;&amp; _supports_atomic_getadd8, &quot;C2: atomic operations must be supported&quot;);
  #endif
    char buf[512];
<span class="line-modified">!   jio_snprintf(buf, sizeof(buf), &quot;(ARMv%d)%s%s%s%s&quot;,</span>
                 _arm_arch,
                 (has_vfp() ? &quot;, vfp&quot; : &quot;&quot;),
                 (has_vfp3_32() ? &quot;, vfp3-32&quot; : &quot;&quot;),
<span class="line-modified">!                (has_simd() ? &quot;, simd&quot; : &quot;&quot;),</span>
<span class="line-added">+                (has_multiprocessing_extensions() ? &quot;, mp_ext&quot; : &quot;&quot;));</span>
  
    // buf is started with &quot;, &quot; or is empty
    _features_string = os::strdup(buf);
  
    if (has_simd()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 274,14 ***</span>
    if (FLAG_IS_DEFAULT(MaxVectorSize)) {
      // FLAG_SET_DEFAULT(MaxVectorSize, has_simd() ? 16 : 8);
      // SIMD/NEON can use 16, but default is 8 because currently
      // larger than 8 will disable instruction scheduling
      FLAG_SET_DEFAULT(MaxVectorSize, 8);
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (MaxVectorSize &gt; 16) {</span>
<span class="line-modified">!     FLAG_SET_DEFAULT(MaxVectorSize, 8);</span>
    }
  #endif
  
    if (FLAG_IS_DEFAULT(Tier4CompileThreshold)) {
      Tier4CompileThreshold = 10000;
<span class="line-new-header">--- 298,16 ---</span>
    if (FLAG_IS_DEFAULT(MaxVectorSize)) {
      // FLAG_SET_DEFAULT(MaxVectorSize, has_simd() ? 16 : 8);
      // SIMD/NEON can use 16, but default is 8 because currently
      // larger than 8 will disable instruction scheduling
      FLAG_SET_DEFAULT(MaxVectorSize, 8);
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     int max_vector_size = has_simd() ? 16 : 8;</span>
<span class="line-modified">!     if (MaxVectorSize &gt; max_vector_size) {</span>
<span class="line-modified">!       warning(&quot;MaxVectorSize must be at most %i on this platform&quot;, max_vector_size);</span>
<span class="line-added">+       FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);</span>
<span class="line-added">+     }</span>
    }
  #endif
  
    if (FLAG_IS_DEFAULT(Tier4CompileThreshold)) {
      Tier4CompileThreshold = 10000;
</pre>
<center><a href="vm_version_arm.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_ext_arm.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
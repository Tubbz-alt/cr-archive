<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/templateTable_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="templateInterpreterGenerator_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_arm.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/templateTable_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.inline.hpp&quot;
  27 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  28 #include &quot;interpreter/interp_masm.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/templateTable.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/cpCache.hpp&quot;
  34 #include &quot;oops/methodData.hpp&quot;
  35 #include &quot;oops/objArrayKlass.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;prims/methodHandles.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;runtime/synchronizer.hpp&quot;

  42 
  43 #define __ _masm-&gt;
  44 
  45 //----------------------------------------------------------------------------------------------------
  46 // Platform-dependent initialization
  47 
  48 void TemplateTable::pd_initialize() {
  49   // No arm specific initialization
  50 }
  51 
  52 //----------------------------------------------------------------------------------------------------
  53 // Address computation
  54 
  55 // local variables
  56 static inline Address iaddress(int n)            {
  57   return Address(Rlocals, Interpreter::local_offset_in_bytes(n));
  58 }
  59 
  60 static inline Address laddress(int n)            { return iaddress(n + 1); }
  61 static inline Address haddress(int n)            { return iaddress(n + 0); }
</pre>
<hr />
<pre>
 470   if (VerifyOops) {
 471     __ verify_oop(R0_tos);
 472   }
 473 }
 474 
 475 void TemplateTable::ldc2_w() {
 476   transition(vtos, vtos);
 477   const Register Rtags  = R2_tmp;
 478   const Register Rindex = R3_tmp;
 479   const Register Rcpool = R4_tmp;
 480   const Register Rbase  = R5_tmp;
 481 
 482   __ get_unsigned_2_byte_index_at_bcp(Rindex, 1);
 483 
 484   __ get_cpool_and_tags(Rcpool, Rtags);
 485   const int base_offset = ConstantPool::header_size() * wordSize;
 486   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 487 
 488   __ add(Rbase, Rcpool, AsmOperand(Rindex, lsl, LogBytesPerWord));
 489 
<span class="line-removed"> 490   Label Condy, exit;</span>
<span class="line-removed"> 491 #ifdef __ABI_HARD__</span>
<span class="line-removed"> 492   Label Long;</span>
 493   // get type from tags
 494   __ add(Rtemp, Rtags, tags_offset);
 495   __ ldrb(Rtemp, Address(Rtemp, Rindex));




 496   __ cmp(Rtemp, JVM_CONSTANT_Double);
<span class="line-modified"> 497   __ b(Long, ne);</span>
 498   __ ldr_double(D0_tos, Address(Rbase, base_offset));
 499 
 500   __ push(dtos);
 501   __ b(exit);
<span class="line-modified"> 502   __ bind(Long);</span>
 503 #endif
 504 
 505   __ cmp(Rtemp, JVM_CONSTANT_Long);
 506   __ b(Condy, ne);
 507   __ ldr(R0_tos_lo, Address(Rbase, base_offset + 0 * wordSize));
 508   __ ldr(R1_tos_hi, Address(Rbase, base_offset + 1 * wordSize));
 509   __ push(ltos);
 510   __ b(exit);
 511 
 512   __ bind(Condy);
 513   condy_helper(exit);
 514 
 515   __ bind(exit);
 516 }
 517 
 518 
 519 void TemplateTable::condy_helper(Label&amp; Done)
 520 {
 521   Register obj   = R0_tmp;
 522   Register rtmp  = R1_tmp;
</pre>
<hr />
<pre>
2150         }
2151       } else {
2152         if (UseOnStackReplacement) {
2153           // check for overflow against Rcnt, which is the sum of the counters
2154           const Address backward_branch_limit(Rcounters, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset()));
2155           __ ldr_s32(Rtemp, backward_branch_limit);
2156           __ cmp_32(Rcnt, Rtemp);
2157           __ b(backedge_counter_overflow, hs);
2158 
2159         }
2160       }
2161     }
2162     __ bind(dispatch);
2163   }
2164 
2165   if (!UseOnStackReplacement) {
2166     __ bind(backedge_counter_overflow);
2167   }
2168 
2169   // continue with the bytecode @ target
<span class="line-modified">2170   __ dispatch_only(vtos);</span>
2171 
2172   if (UseLoopCounter) {
2173     if (ProfileInterpreter) {
2174       // Out-of-line code to allocate method data oop.
2175       __ bind(profile_method);
2176 
2177       __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
2178       __ set_method_data_pointer_for_bcp();
2179       // reload next bytecode
2180       __ ldrb(R3_bytecode, Address(Rbcp));
2181       __ b(dispatch);
2182     }
2183 
2184     if (UseOnStackReplacement) {
2185       // invocation counter overflow
2186       __ bind(backedge_counter_overflow);
2187 
2188       __ sub(R1, Rbcp, Rdisp);                   // branch bcp
2189       call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::frequency_counter_overflow), R1);
2190 
</pre>
<hr />
<pre>
2344 
2345     __ b(default_case, lt);
2346     __ ldr(Roffset, Address(Rabcp, Rindex, lsl, LogBytesPerInt));
2347     __ profile_switch_case(Rabcp, Rindex, Rtemp2, R0_tmp);
2348     __ b(continue_execution);
2349 
2350     __ bind(default_case);
2351     __ profile_switch_default(R0_tmp);
2352     __ ldr(Roffset, Address(Rabcp, -3 * BytesPerInt));
2353 
2354     __ bind(continue_execution);
2355   } else {
2356     __ ldr(Roffset, Address(Rabcp, -3 * BytesPerInt), lt);
2357     __ ldr(Roffset, Address(Rabcp, Rindex, lsl, LogBytesPerInt), ge);
2358   }
2359 
2360   __ byteswap_u32(Roffset, Rtemp, Rtemp2);
2361 
2362   // load the next bytecode to R3_bytecode and advance Rbcp
2363   __ ldrb(R3_bytecode, Address(Rbcp, Roffset, lsl, 0, pre_indexed));
<span class="line-modified">2364   __ dispatch_only(vtos);</span>
2365 
2366 }
2367 
2368 
2369 void TemplateTable::lookupswitch() {
2370   transition(itos, itos);
2371   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2372 }
2373 
2374 
2375 void TemplateTable::fast_linearswitch() {
2376   transition(itos, vtos);
2377   Label loop, found, default_case, continue_execution;
2378 
2379   const Register Rkey     = R0_tos;
2380   const Register Rabcp    = R2_tmp;  // aligned bcp
2381   const Register Rdefault = R3_tmp;
2382   const Register Rcount   = R4_tmp;
2383   const Register Roffset  = R5_tmp;
2384 
</pre>
<hr />
<pre>
2421 
2422     // align bcp
2423     __ add(Rtemp, Rbcp, 1 + (BytesPerInt-1));
2424     __ align_reg(R2_tmp, Rtemp, BytesPerInt);
2425 
2426     // load number of cases
2427     __ ldr_u32(R2_tmp, Address(R2_tmp, BytesPerInt));
2428     __ byteswap_u32(R2_tmp, R1_tmp, Rtemp);
2429 
2430     // Selected index = &lt;number of cases&gt; - &lt;current loop count&gt;
2431     __ sub(R1_tmp, R2_tmp, Rcount);
2432     __ profile_switch_case(R0_tmp, R1_tmp, Rtemp, R1_tmp);
2433   }
2434 
2435   // continue execution
2436   __ bind(continue_execution);
2437   __ byteswap_u32(Roffset, R1_tmp, Rtemp);
2438 
2439   // load the next bytecode to R3_bytecode and advance Rbcp
2440   __ ldrb(R3_bytecode, Address(Rbcp, Roffset, lsl, 0, pre_indexed));
<span class="line-modified">2441   __ dispatch_only(vtos);</span>
2442 }
2443 
2444 
2445 void TemplateTable::fast_binaryswitch() {
2446   transition(itos, vtos);
2447   // Implementation using the following core algorithm:
2448   //
2449   // int binary_search(int key, LookupswitchPair* array, int n) {
2450   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2451   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2452   //   int i = 0;
2453   //   int j = n;
2454   //   while (i+1 &lt; j) {
2455   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2456   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2457   //     // where a stands for the array and assuming that the (inexisting)
2458   //     // element a[n] is infinitely big.
2459   //     int h = (i + j) &gt;&gt; 1;
2460   //     // i &lt; h &lt; j
2461   //     if (key &lt; array[h].fast_match()) {
</pre>
<hr />
<pre>
2515     __ bind(entry);
2516     __ add(temp1, i, 1);                             // i+1
2517     __ cmp(temp1, j);                                // i+1 &lt; j
2518     __ b(loop, lt);
2519   }
2520 
2521   // end of binary search, result index is i (must check again!)
2522   Label default_case;
2523   // Convert array[i].match to native byte-ordering before compare
2524   __ ldr_s32(val, Address(array, i, lsl, 1+LogBytesPerInt));
2525   __ byteswap_u32(val, temp1, temp2);
2526   __ cmp_32(key, val);
2527   __ b(default_case, ne);
2528 
2529   // entry found
2530   __ add(temp1, array, AsmOperand(i, lsl, 1+LogBytesPerInt));
2531   __ ldr_s32(offset, Address(temp1, 1*BytesPerInt));
2532   __ profile_switch_case(R0, i, R1, i);
2533   __ byteswap_u32(offset, temp1, temp2);
2534   __ ldrb(R3_bytecode, Address(Rbcp, offset, lsl, 0, pre_indexed));
<span class="line-modified">2535   __ dispatch_only(vtos);</span>
2536 
2537   // default case
2538   __ bind(default_case);
2539   __ profile_switch_default(R0);
2540   __ ldr_s32(offset, Address(array, -2*BytesPerInt));
2541   __ byteswap_u32(offset, temp1, temp2);
2542   __ ldrb(R3_bytecode, Address(Rbcp, offset, lsl, 0, pre_indexed));
<span class="line-modified">2543   __ dispatch_only(vtos);</span>
2544 }
2545 
2546 
2547 void TemplateTable::_return(TosState state) {
2548   transition(state, state);
2549   assert(_desc-&gt;calls_vm(), &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2550 
2551   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2552     Label skip_register_finalizer;
2553     assert(state == vtos, &quot;only valid state&quot;);
2554     __ ldr(R1, aaddress(0));
2555     __ load_klass(Rtemp, R1);
2556     __ ldr_u32(Rtemp, Address(Rtemp, Klass::access_flags_offset()));
2557     __ tbz(Rtemp, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);
2558 
2559     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), R1);
2560 
2561     __ bind(skip_register_finalizer);
2562   }
2563 
</pre>
<hr />
<pre>
4028     __ add(Rzero_end, Rzero_cur, Rsize);
4029 
4030     // initialize remaining object fields: Rsize was a multiple of 8
4031     { Label loop;
4032       // loop is unrolled 2 times
4033       __ bind(loop);
4034       // #1
4035       __ stmia(Rzero_cur, RegisterSet(Rzero0) | RegisterSet(Rzero1), writeback);
4036       __ cmp(Rzero_cur, Rzero_end);
4037       // #2
4038       __ stmia(Rzero_cur, RegisterSet(Rzero0) | RegisterSet(Rzero1), writeback, ne);
4039       __ cmp(Rzero_cur, Rzero_end, ne);
4040       __ b(loop, ne);
4041     }
4042 
4043     // initialize object header only.
4044     __ bind(initialize_header);
4045     if (UseBiasedLocking) {
4046       __ ldr(Rtemp, Address(Rklass, Klass::prototype_header_offset()));
4047     } else {
<span class="line-modified">4048       __ mov_slow(Rtemp, (intptr_t)markOopDesc::prototype());</span>
4049     }
4050     // mark
4051     __ str(Rtemp, Address(Robj, oopDesc::mark_offset_in_bytes()));
4052 
4053     // klass
4054     __ store_klass(Rklass, Robj); // blows Rklass:
4055     Rklass = noreg;
4056 
4057     // Note: Disable DTrace runtime check for now to eliminate overhead on each allocation
4058     if (DTraceAllocProbes) {
4059       // Trigger dtrace event for fastpath
4060       Label Lcontinue;
4061 
4062       __ ldrb_global(Rtemp, (address)&amp;DTraceAllocProbes);
4063       __ cbz(Rtemp, Lcontinue);
4064 
4065       __ push(atos);
4066       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), Robj);
4067       __ pop(atos);
4068 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.inline.hpp&quot;
  27 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  28 #include &quot;interpreter/interp_masm.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/templateTable.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/cpCache.hpp&quot;
  34 #include &quot;oops/methodData.hpp&quot;
  35 #include &quot;oops/objArrayKlass.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;prims/methodHandles.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;runtime/synchronizer.hpp&quot;
<span class="line-added">  42 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  43 
  44 #define __ _masm-&gt;
  45 
  46 //----------------------------------------------------------------------------------------------------
  47 // Platform-dependent initialization
  48 
  49 void TemplateTable::pd_initialize() {
  50   // No arm specific initialization
  51 }
  52 
  53 //----------------------------------------------------------------------------------------------------
  54 // Address computation
  55 
  56 // local variables
  57 static inline Address iaddress(int n)            {
  58   return Address(Rlocals, Interpreter::local_offset_in_bytes(n));
  59 }
  60 
  61 static inline Address laddress(int n)            { return iaddress(n + 1); }
  62 static inline Address haddress(int n)            { return iaddress(n + 0); }
</pre>
<hr />
<pre>
 471   if (VerifyOops) {
 472     __ verify_oop(R0_tos);
 473   }
 474 }
 475 
 476 void TemplateTable::ldc2_w() {
 477   transition(vtos, vtos);
 478   const Register Rtags  = R2_tmp;
 479   const Register Rindex = R3_tmp;
 480   const Register Rcpool = R4_tmp;
 481   const Register Rbase  = R5_tmp;
 482 
 483   __ get_unsigned_2_byte_index_at_bcp(Rindex, 1);
 484 
 485   __ get_cpool_and_tags(Rcpool, Rtags);
 486   const int base_offset = ConstantPool::header_size() * wordSize;
 487   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 488 
 489   __ add(Rbase, Rcpool, AsmOperand(Rindex, lsl, LogBytesPerWord));
 490 



 491   // get type from tags
 492   __ add(Rtemp, Rtags, tags_offset);
 493   __ ldrb(Rtemp, Address(Rtemp, Rindex));
<span class="line-added"> 494 </span>
<span class="line-added"> 495   Label Condy, exit;</span>
<span class="line-added"> 496 #ifdef __ABI_HARD__</span>
<span class="line-added"> 497   Label NotDouble;</span>
 498   __ cmp(Rtemp, JVM_CONSTANT_Double);
<span class="line-modified"> 499   __ b(NotDouble, ne);</span>
 500   __ ldr_double(D0_tos, Address(Rbase, base_offset));
 501 
 502   __ push(dtos);
 503   __ b(exit);
<span class="line-modified"> 504   __ bind(NotDouble);</span>
 505 #endif
 506 
 507   __ cmp(Rtemp, JVM_CONSTANT_Long);
 508   __ b(Condy, ne);
 509   __ ldr(R0_tos_lo, Address(Rbase, base_offset + 0 * wordSize));
 510   __ ldr(R1_tos_hi, Address(Rbase, base_offset + 1 * wordSize));
 511   __ push(ltos);
 512   __ b(exit);
 513 
 514   __ bind(Condy);
 515   condy_helper(exit);
 516 
 517   __ bind(exit);
 518 }
 519 
 520 
 521 void TemplateTable::condy_helper(Label&amp; Done)
 522 {
 523   Register obj   = R0_tmp;
 524   Register rtmp  = R1_tmp;
</pre>
<hr />
<pre>
2152         }
2153       } else {
2154         if (UseOnStackReplacement) {
2155           // check for overflow against Rcnt, which is the sum of the counters
2156           const Address backward_branch_limit(Rcounters, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset()));
2157           __ ldr_s32(Rtemp, backward_branch_limit);
2158           __ cmp_32(Rcnt, Rtemp);
2159           __ b(backedge_counter_overflow, hs);
2160 
2161         }
2162       }
2163     }
2164     __ bind(dispatch);
2165   }
2166 
2167   if (!UseOnStackReplacement) {
2168     __ bind(backedge_counter_overflow);
2169   }
2170 
2171   // continue with the bytecode @ target
<span class="line-modified">2172   __ dispatch_only(vtos, true);</span>
2173 
2174   if (UseLoopCounter) {
2175     if (ProfileInterpreter) {
2176       // Out-of-line code to allocate method data oop.
2177       __ bind(profile_method);
2178 
2179       __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
2180       __ set_method_data_pointer_for_bcp();
2181       // reload next bytecode
2182       __ ldrb(R3_bytecode, Address(Rbcp));
2183       __ b(dispatch);
2184     }
2185 
2186     if (UseOnStackReplacement) {
2187       // invocation counter overflow
2188       __ bind(backedge_counter_overflow);
2189 
2190       __ sub(R1, Rbcp, Rdisp);                   // branch bcp
2191       call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::frequency_counter_overflow), R1);
2192 
</pre>
<hr />
<pre>
2346 
2347     __ b(default_case, lt);
2348     __ ldr(Roffset, Address(Rabcp, Rindex, lsl, LogBytesPerInt));
2349     __ profile_switch_case(Rabcp, Rindex, Rtemp2, R0_tmp);
2350     __ b(continue_execution);
2351 
2352     __ bind(default_case);
2353     __ profile_switch_default(R0_tmp);
2354     __ ldr(Roffset, Address(Rabcp, -3 * BytesPerInt));
2355 
2356     __ bind(continue_execution);
2357   } else {
2358     __ ldr(Roffset, Address(Rabcp, -3 * BytesPerInt), lt);
2359     __ ldr(Roffset, Address(Rabcp, Rindex, lsl, LogBytesPerInt), ge);
2360   }
2361 
2362   __ byteswap_u32(Roffset, Rtemp, Rtemp2);
2363 
2364   // load the next bytecode to R3_bytecode and advance Rbcp
2365   __ ldrb(R3_bytecode, Address(Rbcp, Roffset, lsl, 0, pre_indexed));
<span class="line-modified">2366   __ dispatch_only(vtos, true);</span>
2367 
2368 }
2369 
2370 
2371 void TemplateTable::lookupswitch() {
2372   transition(itos, itos);
2373   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2374 }
2375 
2376 
2377 void TemplateTable::fast_linearswitch() {
2378   transition(itos, vtos);
2379   Label loop, found, default_case, continue_execution;
2380 
2381   const Register Rkey     = R0_tos;
2382   const Register Rabcp    = R2_tmp;  // aligned bcp
2383   const Register Rdefault = R3_tmp;
2384   const Register Rcount   = R4_tmp;
2385   const Register Roffset  = R5_tmp;
2386 
</pre>
<hr />
<pre>
2423 
2424     // align bcp
2425     __ add(Rtemp, Rbcp, 1 + (BytesPerInt-1));
2426     __ align_reg(R2_tmp, Rtemp, BytesPerInt);
2427 
2428     // load number of cases
2429     __ ldr_u32(R2_tmp, Address(R2_tmp, BytesPerInt));
2430     __ byteswap_u32(R2_tmp, R1_tmp, Rtemp);
2431 
2432     // Selected index = &lt;number of cases&gt; - &lt;current loop count&gt;
2433     __ sub(R1_tmp, R2_tmp, Rcount);
2434     __ profile_switch_case(R0_tmp, R1_tmp, Rtemp, R1_tmp);
2435   }
2436 
2437   // continue execution
2438   __ bind(continue_execution);
2439   __ byteswap_u32(Roffset, R1_tmp, Rtemp);
2440 
2441   // load the next bytecode to R3_bytecode and advance Rbcp
2442   __ ldrb(R3_bytecode, Address(Rbcp, Roffset, lsl, 0, pre_indexed));
<span class="line-modified">2443   __ dispatch_only(vtos, true);</span>
2444 }
2445 
2446 
2447 void TemplateTable::fast_binaryswitch() {
2448   transition(itos, vtos);
2449   // Implementation using the following core algorithm:
2450   //
2451   // int binary_search(int key, LookupswitchPair* array, int n) {
2452   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2453   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2454   //   int i = 0;
2455   //   int j = n;
2456   //   while (i+1 &lt; j) {
2457   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2458   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2459   //     // where a stands for the array and assuming that the (inexisting)
2460   //     // element a[n] is infinitely big.
2461   //     int h = (i + j) &gt;&gt; 1;
2462   //     // i &lt; h &lt; j
2463   //     if (key &lt; array[h].fast_match()) {
</pre>
<hr />
<pre>
2517     __ bind(entry);
2518     __ add(temp1, i, 1);                             // i+1
2519     __ cmp(temp1, j);                                // i+1 &lt; j
2520     __ b(loop, lt);
2521   }
2522 
2523   // end of binary search, result index is i (must check again!)
2524   Label default_case;
2525   // Convert array[i].match to native byte-ordering before compare
2526   __ ldr_s32(val, Address(array, i, lsl, 1+LogBytesPerInt));
2527   __ byteswap_u32(val, temp1, temp2);
2528   __ cmp_32(key, val);
2529   __ b(default_case, ne);
2530 
2531   // entry found
2532   __ add(temp1, array, AsmOperand(i, lsl, 1+LogBytesPerInt));
2533   __ ldr_s32(offset, Address(temp1, 1*BytesPerInt));
2534   __ profile_switch_case(R0, i, R1, i);
2535   __ byteswap_u32(offset, temp1, temp2);
2536   __ ldrb(R3_bytecode, Address(Rbcp, offset, lsl, 0, pre_indexed));
<span class="line-modified">2537   __ dispatch_only(vtos, true);</span>
2538 
2539   // default case
2540   __ bind(default_case);
2541   __ profile_switch_default(R0);
2542   __ ldr_s32(offset, Address(array, -2*BytesPerInt));
2543   __ byteswap_u32(offset, temp1, temp2);
2544   __ ldrb(R3_bytecode, Address(Rbcp, offset, lsl, 0, pre_indexed));
<span class="line-modified">2545   __ dispatch_only(vtos, true);</span>
2546 }
2547 
2548 
2549 void TemplateTable::_return(TosState state) {
2550   transition(state, state);
2551   assert(_desc-&gt;calls_vm(), &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2552 
2553   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2554     Label skip_register_finalizer;
2555     assert(state == vtos, &quot;only valid state&quot;);
2556     __ ldr(R1, aaddress(0));
2557     __ load_klass(Rtemp, R1);
2558     __ ldr_u32(Rtemp, Address(Rtemp, Klass::access_flags_offset()));
2559     __ tbz(Rtemp, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);
2560 
2561     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), R1);
2562 
2563     __ bind(skip_register_finalizer);
2564   }
2565 
</pre>
<hr />
<pre>
4030     __ add(Rzero_end, Rzero_cur, Rsize);
4031 
4032     // initialize remaining object fields: Rsize was a multiple of 8
4033     { Label loop;
4034       // loop is unrolled 2 times
4035       __ bind(loop);
4036       // #1
4037       __ stmia(Rzero_cur, RegisterSet(Rzero0) | RegisterSet(Rzero1), writeback);
4038       __ cmp(Rzero_cur, Rzero_end);
4039       // #2
4040       __ stmia(Rzero_cur, RegisterSet(Rzero0) | RegisterSet(Rzero1), writeback, ne);
4041       __ cmp(Rzero_cur, Rzero_end, ne);
4042       __ b(loop, ne);
4043     }
4044 
4045     // initialize object header only.
4046     __ bind(initialize_header);
4047     if (UseBiasedLocking) {
4048       __ ldr(Rtemp, Address(Rklass, Klass::prototype_header_offset()));
4049     } else {
<span class="line-modified">4050       __ mov_slow(Rtemp, (intptr_t)markWord::prototype().value());</span>
4051     }
4052     // mark
4053     __ str(Rtemp, Address(Robj, oopDesc::mark_offset_in_bytes()));
4054 
4055     // klass
4056     __ store_klass(Rklass, Robj); // blows Rklass:
4057     Rklass = noreg;
4058 
4059     // Note: Disable DTrace runtime check for now to eliminate overhead on each allocation
4060     if (DTraceAllocProbes) {
4061       // Trigger dtrace event for fastpath
4062       Label Lcontinue;
4063 
4064       __ ldrb_global(Rtemp, (address)&amp;DTraceAllocProbes);
4065       __ cbz(Rtemp, Lcontinue);
4066 
4067       __ push(atos);
4068       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), Robj);
4069       __ pop(atos);
4070 
</pre>
</td>
</tr>
</table>
<center><a href="templateInterpreterGenerator_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_arm.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
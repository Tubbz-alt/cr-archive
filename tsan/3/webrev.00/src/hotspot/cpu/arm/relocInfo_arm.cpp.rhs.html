<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/arm/relocInfo_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/assembler.inline.hpp&quot;
 27 #include &quot;assembler_arm.inline.hpp&quot;
 28 #include &quot;code/relocInfo.hpp&quot;
 29 #include &quot;nativeInst_arm.hpp&quot;
 30 #include &quot;oops/compressedOops.inline.hpp&quot;
 31 #include &quot;oops/oop.hpp&quot;
<a name="1" id="anc1"></a>
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 
 34 void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {
 35 
 36   NativeMovConstReg* ni = nativeMovConstReg_at(addr());
 37   if (verify_only) {
 38     guarantee(ni-&gt;data() == (intptr_t)(x + o), &quot;instructions must match&quot;);
 39   } else {
 40     ni-&gt;set_data((intptr_t)(x + o));
 41   }
 42 }
 43 
 44 address Relocation::pd_call_destination(address orig_addr) {
 45   address pc = addr();
 46 
 47   int adj = 0;
 48   if (orig_addr != NULL) {
 49     // We just moved this call instruction from orig_addr to addr().
 50     // This means that, when relative, its target will appear to have grown by addr() - orig_addr.
 51     adj = orig_addr - pc;
 52   }
 53 
 54   RawNativeInstruction* ni = rawNativeInstruction_at(pc);
 55 
 56   if (ni-&gt;is_add_lr()) {
 57     // Skip the optional &#39;add LR, PC, #offset&#39;
 58     // (Allowing the jump support code to handle fat_call)
 59     pc = ni-&gt;next_raw_instruction_address();
 60     ni = nativeInstruction_at(pc);
 61   }
 62 
 63   if (ni-&gt;is_bl()) {
 64     // Fat_call are handled by is_jump for the new &#39;ni&#39;,
 65     // requiring only to support is_bl.
 66     return rawNativeCall_at(pc)-&gt;destination(adj);
 67   }
 68 
 69   if (ni-&gt;is_jump()) {
 70     return rawNativeJump_at(pc)-&gt;jump_destination(adj);
 71   }
 72   ShouldNotReachHere();
 73   return NULL;
 74 }
 75 
 76 void Relocation::pd_set_call_destination(address x) {
 77   address pc = addr();
 78   NativeInstruction* ni = nativeInstruction_at(pc);
 79 
 80   if (ni-&gt;is_add_lr()) {
 81     // Skip the optional &#39;add LR, PC, #offset&#39;
 82     // (Allowing the jump support code to handle fat_call)
 83     pc = ni-&gt;next_raw_instruction_address();
 84     ni = nativeInstruction_at(pc);
 85   }
 86 
 87   if (ni-&gt;is_bl()) {
 88     // Fat_call are handled by is_jump for the new &#39;ni&#39;,
 89     // requiring only to support is_bl.
 90     rawNativeCall_at(pc)-&gt;set_destination(x);
 91     return;
 92   }
 93 
 94   if (ni-&gt;is_jump()) { // raw jump
 95     rawNativeJump_at(pc)-&gt;set_jump_destination(x);
 96     return;
 97   }
 98   ShouldNotReachHere();
 99 }
100 
101 
102 address* Relocation::pd_address_in_code() {
103   return (address*)addr();
104 }
105 
106 address Relocation::pd_get_address_from_code() {
107   return *pd_address_in_code();
108 }
109 
110 void poll_Relocation::fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) {
111 }
112 
113 void metadata_Relocation::pd_fix_value(address x) {
114   assert(! addr_in_const(), &quot;Do not use&quot;);
115   if (!VM_Version::supports_movw()) {
116     set_value(x);
117 #ifdef ASSERT
118   } else {
119     // the movw/movt data should be correct
120     NativeMovConstReg* ni = nativeMovConstReg_at(addr());
121     assert(ni-&gt;is_movw(), &quot;not a movw&quot;);
122     // The following assert should be correct but the shared code
123     // currently &#39;fixes&#39; the metadata instructions before the
124     // metadata_table is copied in the new method (see
125     // JDK-8042845). This means that &#39;x&#39; (which comes from the table)
126     // does not match the value inlined in the code (which is
127     // correct). Failure can be temporarily ignored since the code is
128     // correct and the table is copied shortly afterward.
129     //
130     // assert(ni-&gt;data() == (int)x, &quot;metadata relocation mismatch&quot;);
131 #endif
132   }
133 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/arm/c1_LIRAssembler_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap_arm.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_arm.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/c1_LIRAssembler_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,17 ***</span>
  #include &quot;c1/c1_MacroAssembler.hpp&quot;
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;c1/c1_ValueStack.hpp&quot;
  #include &quot;ci/ciArrayKlass.hpp&quot;
  #include &quot;ci/ciInstance.hpp&quot;
<span class="line-removed">- #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;</span>
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;nativeInst_arm.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;vmreg_arm.inline.hpp&quot;
  
  #define __ _masm-&gt;
  
  // Note: Rtemp usage is this file should not impact C2 and should be
<span class="line-new-header">--- 29,17 ---</span>
  #include &quot;c1/c1_MacroAssembler.hpp&quot;
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;c1/c1_ValueStack.hpp&quot;
  #include &quot;ci/ciArrayKlass.hpp&quot;
  #include &quot;ci/ciInstance.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;nativeInst_arm.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;vmreg_arm.inline.hpp&quot;
  
  #define __ _masm-&gt;
  
  // Note: Rtemp usage is this file should not impact C2 and should be
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,34 ***</span>
  }
  
  //--------------fpu register translations-----------------------
  
  
<span class="line-removed">- void LIR_Assembler::set_24bit_FPU() {</span>
<span class="line-removed">-   ShouldNotReachHere();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::reset_FPU() {</span>
<span class="line-removed">-   ShouldNotReachHere();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::fpop() {</span>
<span class="line-removed">-   Unimplemented();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::fxch(int i) {</span>
<span class="line-removed">-   Unimplemented();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::fld(int i) {</span>
<span class="line-removed">-   Unimplemented();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::ffree(int i) {</span>
<span class="line-removed">-   Unimplemented();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void LIR_Assembler::breakpoint() {
    __ breakpoint();
  }
  
  void LIR_Assembler::push(LIR_Opr opr) {
<span class="line-new-header">--- 85,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,10 ***</span>
<span class="line-new-header">--- 164,13 ---</span>
    int offset = __ offset();
    __ inline_cache_check(receiver, Ricklass);
    return offset;
  }
  
<span class="line-added">+ void LIR_Assembler::clinit_barrier(ciMethod* method) {</span>
<span class="line-added">+   ShouldNotReachHere(); // not implemented</span>
<span class="line-added">+ }</span>
  
  void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
    jobject o = (jobject)Universe::non_oop_word();
    int index = __ oop_recorder()-&gt;allocate_oop_index(o);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,27 ***</span>
  
  
  void LIR_Assembler::return_op(LIR_Opr result) {
    // Pop the frame before safepoint polling
    __ remove_frame(initial_frame_size_in_bytes());
<span class="line-modified">! </span>
<span class="line-removed">-   // mov_slow here is usually one or two instruction</span>
<span class="line-removed">-   __ mov_address(Rtemp, os::get_polling_page());</span>
<span class="line-removed">-   __ relocate(relocInfo::poll_return_type);</span>
<span class="line-removed">-   __ ldr(Rtemp, Address(Rtemp));</span>
    __ ret();
  }
  
<span class="line-removed">- </span>
  int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
<span class="line-removed">-   __ mov_address(Rtemp, os::get_polling_page());</span>
    if (info != NULL) {
      add_debug_info_for_branch(info);
    }
    int offset = __ offset();
<span class="line-modified">!   __ relocate(relocInfo::poll_type);</span>
<span class="line-removed">-   __ ldr(Rtemp, Address(Rtemp));</span>
    return offset;
  }
  
  
  void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
<span class="line-new-header">--- 284,20 ---</span>
  
  
  void LIR_Assembler::return_op(LIR_Opr result) {
    // Pop the frame before safepoint polling
    __ remove_frame(initial_frame_size_in_bytes());
<span class="line-modified">!   __ read_polling_page(Rtemp, relocInfo::poll_return_type);</span>
    __ ret();
  }
  
  int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
    if (info != NULL) {
      add_debug_info_for_branch(info);
    }
    int offset = __ offset();
<span class="line-modified">!   __ read_polling_page(Rtemp, relocInfo::poll_type);</span>
    return offset;
  }
  
  
  void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 575,26 ***</span>
<span class="line-new-header">--- 547,29 ---</span>
          assert(to_addr-&gt;disp() == 0, &quot;Not yet supporting both&quot;);
          __ add(Rtemp, base_reg, to_addr-&gt;index()-&gt;as_register());
          base_reg = Rtemp;
          __ str(from_lo, Address(Rtemp));
          if (patch != NULL) {
<span class="line-added">+           __ nop(); // see comment before patching_epilog for 2nd str</span>
            patching_epilog(patch, lir_patch_low, base_reg, info);
            patch = new PatchingStub(_masm, PatchingStub::access_field_id);
            patch_code = lir_patch_high;
          }
          __ str(from_hi, Address(Rtemp, BytesPerWord));
        } else if (base_reg == from_lo) {
          __ str(from_hi, as_Address_hi(to_addr));
          if (patch != NULL) {
<span class="line-added">+           __ nop(); // see comment before patching_epilog for 2nd str</span>
            patching_epilog(patch, lir_patch_high, base_reg, info);
            patch = new PatchingStub(_masm, PatchingStub::access_field_id);
            patch_code = lir_patch_low;
          }
          __ str(from_lo, as_Address_lo(to_addr));
        } else {
          __ str(from_lo, as_Address_lo(to_addr));
          if (patch != NULL) {
<span class="line-added">+           __ nop(); // see comment before patching_epilog for 2nd str</span>
            patching_epilog(patch, lir_patch_low, base_reg, info);
            patch = new PatchingStub(_masm, PatchingStub::access_field_id);
            patch_code = lir_patch_high;
          }
          __ str(from_hi, as_Address_hi(to_addr));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 634,11 ***</span>
    if (info != NULL) {
      add_debug_info_for_null_check(null_check_offset, info);
    }
  
    if (patch != NULL) {
<span class="line-modified">!     // Offset embeedded into LDR/STR instruction may appear not enough</span>
      // to address a field. So, provide a space for one more instruction
      // that will deal with larger offsets.
      __ nop();
      patching_epilog(patch, patch_code, base_reg, info);
    }
<span class="line-new-header">--- 609,11 ---</span>
    if (info != NULL) {
      add_debug_info_for_null_check(null_check_offset, info);
    }
  
    if (patch != NULL) {
<span class="line-modified">!     // Offset embedded into LDR/STR instruction may appear not enough</span>
      // to address a field. So, provide a space for one more instruction
      // that will deal with larger offsets.
      __ nop();
      patching_epilog(patch, patch_code, base_reg, info);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 785,26 ***</span>
<span class="line-new-header">--- 760,29 ---</span>
          assert(addr-&gt;disp() == 0, &quot;Not yet supporting both&quot;);
          __ add(Rtemp, base_reg, addr-&gt;index()-&gt;as_register());
          base_reg = Rtemp;
          __ ldr(to_lo, Address(Rtemp));
          if (patch != NULL) {
<span class="line-added">+           __ nop(); // see comment before patching_epilog for 2nd ldr</span>
            patching_epilog(patch, lir_patch_low, base_reg, info);
            patch = new PatchingStub(_masm, PatchingStub::access_field_id);
            patch_code = lir_patch_high;
          }
          __ ldr(to_hi, Address(Rtemp, BytesPerWord));
        } else if (base_reg == to_lo) {
          __ ldr(to_hi, as_Address_hi(addr));
          if (patch != NULL) {
<span class="line-added">+           __ nop(); // see comment before patching_epilog for 2nd ldr</span>
            patching_epilog(patch, lir_patch_high, base_reg, info);
            patch = new PatchingStub(_masm, PatchingStub::access_field_id);
            patch_code = lir_patch_low;
          }
          __ ldr(to_lo, as_Address_lo(addr));
        } else {
          __ ldr(to_lo, as_Address_lo(addr));
          if (patch != NULL) {
<span class="line-added">+           __ nop(); // see comment before patching_epilog for 2nd ldr</span>
            patching_epilog(patch, lir_patch_low, base_reg, info);
            patch = new PatchingStub(_masm, PatchingStub::access_field_id);
            patch_code = lir_patch_high;
          }
          __ ldr(to_hi, as_Address_hi(addr));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 840,11 ***</span>
      default:
        ShouldNotReachHere();
    }
  
    if (patch != NULL) {
<span class="line-modified">!     // Offset embeedded into LDR/STR instruction may appear not enough</span>
      // to address a field. So, provide a space for one more instruction
      // that will deal with larger offsets.
      __ nop();
      patching_epilog(patch, patch_code, base_reg, info);
    }
<span class="line-new-header">--- 818,11 ---</span>
      default:
        ShouldNotReachHere();
    }
  
    if (patch != NULL) {
<span class="line-modified">!     // Offset embedded into LDR/STR instruction may appear not enough</span>
      // to address a field. So, provide a space for one more instruction
      // that will deal with larger offsets.
      __ nop();
      patching_epilog(patch, patch_code, base_reg, info);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1811,10 ***</span>
<span class="line-new-header">--- 1789,15 ---</span>
          }
          case T_OBJECT:
            assert(opr2-&gt;as_constant_ptr()-&gt;as_jobject() == NULL, &quot;cannot handle otherwise&quot;);
            __ cmp(opr1-&gt;as_register(), 0);
            break;
<span class="line-added">+         case T_METADATA:</span>
<span class="line-added">+           assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;Only equality tests&quot;);</span>
<span class="line-added">+           assert(opr2-&gt;as_constant_ptr()-&gt;as_metadata() == NULL, &quot;cannot handle otherwise&quot;);</span>
<span class="line-added">+           __ cmp(opr1-&gt;as_register(), 0);</span>
<span class="line-added">+           break;</span>
          default:
            ShouldNotReachHere();
        }
      } else if (opr2-&gt;is_single_cpu()) {
        if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {
</pre>
<center><a href="c1_FrameMap_arm.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_arm.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
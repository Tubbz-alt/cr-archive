<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/arm/arm.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="abstractInterpreter_arm.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arm_32.ad.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/arm.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  //
<span class="line-modified">! // Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  //
  // This code is free software; you can redistribute it and/or modify it
  // under the terms of the GNU General Public License version 2 only, as
  // published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  //
<span class="line-modified">! // Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  //
  // This code is free software; you can redistribute it and/or modify it
  // under the terms of the GNU General Public License version 2 only, as
  // published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,14 ***</span>
    }
    __ raw_pop(FP, LR);
  
    // If this does safepoint polling, then do it here
    if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
<span class="line-modified">!     // mov_slow here is usually one or two instruction</span>
<span class="line-removed">-     __ mov_address(Rtemp, (address)os::get_polling_page());</span>
<span class="line-removed">-     __ relocate(relocInfo::poll_return_type);</span>
<span class="line-removed">-     __ ldr(Rtemp, Address(Rtemp));</span>
    }
  }
  
  uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
    return MachNode::size(ra_);
<span class="line-new-header">--- 349,11 ---</span>
    }
    __ raw_pop(FP, LR);
  
    // If this does safepoint polling, then do it here
    if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
<span class="line-modified">!     __ read_polling_page(Rtemp, relocInfo::poll_return_type);</span>
    }
  }
  
  uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
    return MachNode::size(ra_);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 969,11 ***</span>
    }
  
    return true;  // Per default match rules are supported.
  }
  
<span class="line-modified">! const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {</span>
  
    // TODO
    // identify extra cases that we might want to provide match rules for
    // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
    bool ret_value = match_rule_supported(opcode);
<span class="line-new-header">--- 966,11 ---</span>
    }
  
    return true;  // Per default match rules are supported.
  }
  
<span class="line-modified">! const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {</span>
  
    // TODO
    // identify extra cases that we might want to provide match rules for
    // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
    bool ret_value = match_rule_supported(opcode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1075,10 ***</span>
<span class="line-new-header">--- 1072,28 ---</span>
  // FIXME: does this handle vector shifts as well?
  const bool Matcher::need_masked_shift_count = true;
  
  const bool Matcher::convi2l_type_required = true;
  
<span class="line-added">+ // No support for generic vector operands.</span>
<span class="line-added">+ const bool Matcher::supports_generic_vector_operands  = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+ MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {</span>
<span class="line-added">+   ShouldNotReachHere(); // generic vector operands not supported</span>
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Matcher::is_generic_reg2reg_move(MachNode* m) {</span>
<span class="line-added">+   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Matcher::is_generic_vector(MachOper* opnd)  {</span>
<span class="line-added">+   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Should the Matcher clone shifts on addressing modes, expecting them
  // to be subsumed into complex addressing expressions or compute them
  // into registers?
  bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
    return clone_base_plus_offset_address(m, mstack, address_visited);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1123,12 ***</span>
  
  // No-op on ARM.
  void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
  }
  
<span class="line-modified">! // Advertise here if the CPU requires explicit rounding operations</span>
<span class="line-removed">- // to implement the UseStrictFP mode.</span>
  const bool Matcher::strict_fp_requires_explicit_rounding = false;
  
  // Are floats converted to double when stored to stack during deoptimization?
  // ARM does not handle callee-save floats.
  bool Matcher::float_in_double() {
<span class="line-new-header">--- 1138,11 ---</span>
  
  // No-op on ARM.
  void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
  }
  
<span class="line-modified">! // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>
  const bool Matcher::strict_fp_requires_explicit_rounding = false;
  
  // Are floats converted to double when stored to stack during deoptimization?
  // ARM does not handle callee-save floats.
  bool Matcher::float_in_double() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2202,10 ***</span>
<span class="line-new-header">--- 2216,34 ---</span>
  
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="line-added">+ operand R8RegP() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(R8_regP));</span>
<span class="line-added">+   match(iRegP);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ operand R9RegP() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(R9_regP));</span>
<span class="line-added">+   match(iRegP);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ operand R12RegP() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(R12_regP));</span>
<span class="line-added">+   match(iRegP);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  operand R2RegP() %{
    constraint(ALLOC_IN_RC(R2_regP));
    match(iRegP);
  
    format %{ %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2234,10 ***</span>
<span class="line-new-header">--- 2272,18 ---</span>
  
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="line-added">+ operand SPRegP() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(SP_regP));</span>
<span class="line-added">+   match(iRegP);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  operand LRRegP() %{
    constraint(ALLOC_IN_RC(LR_regP));
    match(iRegP);
  
    format %{ %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4346,11 ***</span>
  %}
  
  // Prefetch instructions.
  // Must be safe to execute with invalid address (cannot fault).
  
<span class="line-modified">! instruct prefetchAlloc( memoryP mem ) %{</span>
    match( PrefetchAllocation mem );
    ins_cost(MEMORY_REF_COST);
    size(4);
  
    format %{ &quot;PLDW $mem\t! Prefetch allocation&quot; %}
<span class="line-new-header">--- 4392,12 ---</span>
  %}
  
  // Prefetch instructions.
  // Must be safe to execute with invalid address (cannot fault).
  
<span class="line-modified">! instruct prefetchAlloc_mp( memoryP mem ) %{</span>
<span class="line-added">+   predicate(VM_Version::has_multiprocessing_extensions());</span>
    match( PrefetchAllocation mem );
    ins_cost(MEMORY_REF_COST);
    size(4);
  
    format %{ &quot;PLDW $mem\t! Prefetch allocation&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4358,10 ***</span>
<span class="line-new-header">--- 4405,24 ---</span>
      __ pldw($mem$$Address);
    %}
    ins_pipe(iload_mem);
  %}
  
<span class="line-added">+ instruct prefetchAlloc_sp( memoryP mem ) %{</span>
<span class="line-added">+   predicate(!VM_Version::has_multiprocessing_extensions());</span>
<span class="line-added">+   match( PrefetchAllocation mem );</span>
<span class="line-added">+   ins_cost(MEMORY_REF_COST);</span>
<span class="line-added">+   size(4);</span>
<span class="line-added">+ </span>
<span class="line-added">+   format %{ &quot;PLD $mem\t! Prefetch allocation&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     __ pld($mem$$Address);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(iload_mem);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  //----------Store Instructions-------------------------------------------------
  // Store Byte
  instruct storeB(memoryB mem, store_RegI src) %{
    match(Set mem (StoreB mem src));
    ins_cost(MEMORY_REF_COST);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5259,10 ***</span>
<span class="line-new-header">--- 5320,18 ---</span>
    ins_encode( /*empty encoding*/ );
    ins_cost(0);
    ins_pipe(empty);
  %}
  
<span class="line-added">+ instruct castLL( iRegL dst ) %{</span>
<span class="line-added">+   match(Set dst (CastLL dst));</span>
<span class="line-added">+   format %{ &quot;! castLL of $dst&quot; %}</span>
<span class="line-added">+   ins_encode( /*empty encoding*/ );</span>
<span class="line-added">+   ins_cost(0);</span>
<span class="line-added">+   ins_pipe(empty);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  //----------Arithmetic Instructions--------------------------------------------
  // Addition Instructions
  // Register Addition
  instruct addI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
    match(Set dst (AddI src1 src2));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10547,11 ***</span>
    %}
  %}
  
  instruct vsl8B_immI(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">!   match(Set dst (LShiftVB src shift));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHL.I8 $dst.D,$src.D,$shift\t! logical left shift packed8B&quot;
    %}
<span class="line-new-header">--- 10616,11 ---</span>
    %}
  %}
  
  instruct vsl8B_immI(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">!   match(Set dst (LShiftVB src (LShiftCntV shift)));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHL.I8 $dst.D,$src.D,$shift\t! logical left shift packed8B&quot;
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10563,11 ***</span>
    ins_pipe( ialu_reg_reg ); // FIXME
  %}
  
  instruct vsl16B_immI(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">!   match(Set dst (LShiftVB src shift));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHL.I8 $dst.Q,$src.Q,$shift\t! logical left shift packed16B&quot;
    %}
<span class="line-new-header">--- 10632,11 ---</span>
    ins_pipe( ialu_reg_reg ); // FIXME
  %}
  
  instruct vsl16B_immI(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">!   match(Set dst (LShiftVB src (LShiftCntV shift)));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHL.I8 $dst.Q,$src.Q,$shift\t! logical left shift packed16B&quot;
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10602,11 ***</span>
    %}
  %}
  
  instruct vsl4S_immI(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">!   match(Set dst (LShiftVS src shift));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHL.I16 $dst.D,$src.D,$shift\t! logical left shift packed4S&quot;
    %}
<span class="line-new-header">--- 10671,11 ---</span>
    %}
  %}
  
  instruct vsl4S_immI(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">!   match(Set dst (LShiftVS src (LShiftCntV shift)));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHL.I16 $dst.D,$src.D,$shift\t! logical left shift packed4S&quot;
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10657,11 ***</span>
    %}
  %}
  
  instruct vsl2I_immI(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; VM_Version::has_simd());
<span class="line-modified">!   match(Set dst (LShiftVI src shift));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHL.I32 $dst.D,$src.D,$shift\t! logical left shift packed2I&quot;
    %}
<span class="line-new-header">--- 10726,11 ---</span>
    %}
  %}
  
  instruct vsl2I_immI(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; VM_Version::has_simd());
<span class="line-modified">!   match(Set dst (LShiftVI src (LShiftCntV shift)));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHL.I32 $dst.D,$src.D,$shift\t! logical left shift packed2I&quot;
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10673,11 ***</span>
    ins_pipe( ialu_reg_reg ); // FIXME
  %}
  
  instruct vsl4I_immI(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; VM_Version::has_simd());
<span class="line-modified">!   match(Set dst (LShiftVI src shift));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHL.I32 $dst.Q,$src.Q,$shift\t! logical left shift packed4I&quot;
    %}
<span class="line-new-header">--- 10742,11 ---</span>
    ins_pipe( ialu_reg_reg ); // FIXME
  %}
  
  instruct vsl4I_immI(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; VM_Version::has_simd());
<span class="line-modified">!   match(Set dst (LShiftVI src (LShiftCntV shift)));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHL.I32 $dst.Q,$src.Q,$shift\t! logical left shift packed4I&quot;
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10701,11 ***</span>
    %}
  %}
  
  instruct vsl2L_immI(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">!   match(Set dst (LShiftVL src shift));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHL.I64 $dst.Q,$src.Q,$shift\t! logical left shift packed2L&quot;
    %}
<span class="line-new-header">--- 10770,11 ---</span>
    %}
  %}
  
  instruct vsl2L_immI(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">!   match(Set dst (LShiftVL src (LShiftCntV shift)));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHL.I64 $dst.Q,$src.Q,$shift\t! logical left shift packed2L&quot;
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10724,11 ***</span>
  // sign extension before a shift.
  
  // Chars vector logical right shift
  instruct vsrl4S_immI(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">!   match(Set dst (URShiftVS src shift));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHR.U16 $dst.D,$src.D,$shift\t! logical right shift packed4S&quot;
    %}
<span class="line-new-header">--- 10793,11 ---</span>
  // sign extension before a shift.
  
  // Chars vector logical right shift
  instruct vsrl4S_immI(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">!   match(Set dst (URShiftVS src (RShiftCntV shift)));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHR.U16 $dst.D,$src.D,$shift\t! logical right shift packed4S&quot;
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10740,11 ***</span>
    ins_pipe( ialu_reg_reg ); // FIXME
  %}
  
  instruct vsrl8S_immI(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">!   match(Set dst (URShiftVS src shift));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHR.U16 $dst.Q,$src.Q,$shift\t! logical right shift packed8S&quot;
    %}
<span class="line-new-header">--- 10809,11 ---</span>
    ins_pipe( ialu_reg_reg ); // FIXME
  %}
  
  instruct vsrl8S_immI(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">!   match(Set dst (URShiftVS src (RShiftCntV shift)));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHR.U16 $dst.Q,$src.Q,$shift\t! logical right shift packed8S&quot;
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10757,11 ***</span>
  %}
  
  // Integers vector logical right shift
  instruct vsrl2I_immI(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; VM_Version::has_simd());
<span class="line-modified">!   match(Set dst (URShiftVI src shift));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHR.U32 $dst.D,$src.D,$shift\t! logical right shift packed2I&quot;
    %}
<span class="line-new-header">--- 10826,11 ---</span>
  %}
  
  // Integers vector logical right shift
  instruct vsrl2I_immI(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; VM_Version::has_simd());
<span class="line-modified">!   match(Set dst (URShiftVI src (RShiftCntV shift)));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHR.U32 $dst.D,$src.D,$shift\t! logical right shift packed2I&quot;
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10773,11 ***</span>
    ins_pipe( ialu_reg_reg ); // FIXME
  %}
  
  instruct vsrl4I_immI(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; VM_Version::has_simd());
<span class="line-modified">!   match(Set dst (URShiftVI src shift));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHR.U32 $dst.Q,$src.Q,$shift\t! logical right shift packed4I&quot;
    %}
<span class="line-new-header">--- 10842,11 ---</span>
    ins_pipe( ialu_reg_reg ); // FIXME
  %}
  
  instruct vsrl4I_immI(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; VM_Version::has_simd());
<span class="line-modified">!   match(Set dst (URShiftVI src (RShiftCntV shift)));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHR.U32 $dst.Q,$src.Q,$shift\t! logical right shift packed4I&quot;
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10790,11 ***</span>
  %}
  
  // Longs vector logical right shift
  instruct vsrl2L_immI(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">!   match(Set dst (URShiftVL src shift));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHR.U64 $dst.Q,$src.Q,$shift\t! logical right shift packed2L&quot;
    %}
<span class="line-new-header">--- 10859,11 ---</span>
  %}
  
  // Longs vector logical right shift
  instruct vsrl2L_immI(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">!   match(Set dst (URShiftVL src (RShiftCntV shift)));</span>
    size(4);
    ins_cost(DEFAULT_COST); // FIXME
    format %{
      &quot;VSHR.U64 $dst.Q,$src.Q,$shift\t! logical right shift packed2L&quot;
    %}
</pre>
<center><a href="abstractInterpreter_arm.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arm_32.ad.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
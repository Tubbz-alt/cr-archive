<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/arm/register_arm.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef CPU_ARM_REGISTER_ARM_HPP
 26 #define CPU_ARM_REGISTER_ARM_HPP
 27 
 28 #include &quot;asm/register.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 29 #include &quot;vm_version_arm.hpp&quot;</span>
 30 
 31 class VMRegImpl;
 32 typedef VMRegImpl* VMReg;
 33 
 34 // These are declared ucontext.h
 35 #undef R0
 36 #undef R1
 37 #undef R2
 38 #undef R3
 39 #undef R4
 40 #undef R5
 41 #undef R6
 42 #undef R7
 43 #undef R8
 44 #undef R9
 45 #undef R10
 46 #undef R11
 47 #undef R12
 48 #undef R13
 49 #undef R14
 50 #undef R15
 51 
 52 #define R(r)   ((Register)(r))
 53 
 54 /////////////////////////////////
 55 // Support for different ARM ABIs
 56 // Note: default ABI is for linux
 57 
 58 
 59 // R9_IS_SCRATCHED
 60 //
 61 // The ARM ABI does not guarantee that R9 is callee saved.
 62 // Set R9_IS_SCRATCHED to 1 to ensure it is properly saved/restored by
 63 // the caller.
 64 #ifndef R9_IS_SCRATCHED
 65 // Default: R9 is callee saved
 66 #define R9_IS_SCRATCHED 0
 67 #endif
 68 
 69 // FP_REG_NUM
 70 //
 71 // The ARM ABI does not state which register is used for the frame pointer.
 72 // Note: for the ABIs we are currently aware of, FP is currently
 73 // either R7 or R11. Code may have to be extended if a third register
 74 // register must be supported (see altFP_7_11).
 75 #ifndef FP_REG_NUM
 76 // Default: FP is R11
 77 #define FP_REG_NUM 11
 78 #endif
 79 
 80 // ALIGN_WIDE_ARGUMENTS
 81 //
 82 // The ARM ABI requires 64-bits arguments to be aligned on 4 words
 83 // or on even registers. Set ALIGN_WIDE_ARGUMENTS to 1 for that behavior.
 84 //
 85 // Unfortunately, some platforms do not endorse that part of the ABI.
 86 //
 87 // We are aware of one which expects 64-bit arguments to only be 4
 88 // bytes aligned and can for instance use R3 + a stack slot for such
 89 // an argument.
 90 //
 91 // This is the behavor implemented if (ALIGN_WIDE_ARGUMENTS == 0)
 92 #ifndef  ALIGN_WIDE_ARGUMENTS
 93 // Default: align on 8 bytes and avoid using &lt;r3+stack&gt;
 94 #define ALIGN_WIDE_ARGUMENTS 1
 95 #endif
 96 
 97 #define R0     ((Register)0)
 98 #define R1     ((Register)1)
 99 #define R2     ((Register)2)
100 #define R3     ((Register)3)
101 #define R4     ((Register)4)
102 #define R5     ((Register)5)
103 #define R6     ((Register)6)
104 #define R7     ((Register)7)
105 #define R8     ((Register)8)
106 #define R9     ((Register)9)
107 #define R10    ((Register)10)
108 #define R11    ((Register)11)
109 #define R12    ((Register)12)
110 #define R13    ((Register)13)
111 #define R14    ((Register)14)
112 #define R15    ((Register)15)
113 
114 
115 #define FP     ((Register)FP_REG_NUM)
116 
117 // Safe use of registers which may be FP on some platforms.
118 //
119 // altFP_7_11: R7 if not equal to FP, else R11 (the default FP)
120 //
121 // Note: add additional altFP_#_11 for each register potentially used
122 // as FP on supported ABIs (and replace R# by altFP_#_11). altFP_#_11
123 // must be #define to R11 if and only if # is FP_REG_NUM.
124 #if (FP_REG_NUM == 7)
125 #define altFP_7_11     ((Register)11)
126 #else
127 #define altFP_7_11     ((Register)7)
128 #endif
129 #define SP     R13
130 #define LR     R14
131 #define PC     R15
132 
133 
134 
135 class RegisterImpl;
136 typedef RegisterImpl* Register;
137 
138 inline Register as_Register(int encoding) {
139   return (Register)(intptr_t)encoding;
140 }
141 
142 class RegisterImpl : public AbstractRegisterImpl {
143  public:
144   enum {
145     number_of_registers = 16
146   };
147 
148   Register successor() const      { return as_Register(encoding() + 1); }
149 
150   inline friend Register as_Register(int encoding);
151 
152   VMReg as_VMReg();
153 
154   // accessors
155   int   encoding() const          { assert(is_valid(), &quot;invalid register&quot;); return value(); }
156   const char* name() const;
157 
158 
159   // testers
160   bool is_valid() const           { return 0 &lt;= value() &amp;&amp; value() &lt; number_of_registers; }
161 
162 };
163 
164 CONSTANT_REGISTER_DECLARATION(Register, noreg, (-1));
165 
166 
167 // Use FloatRegister as shortcut
168 class FloatRegisterImpl;
169 typedef FloatRegisterImpl* FloatRegister;
170 
171 inline FloatRegister as_FloatRegister(int encoding) {
172   return (FloatRegister)(intptr_t)encoding;
173 }
174 
175 class FloatRegisterImpl : public AbstractRegisterImpl {
176  public:
177   enum {
178     number_of_registers = NOT_COMPILER2(32) COMPILER2_PRESENT(64)
179   };
180 
181   inline friend FloatRegister as_FloatRegister(int encoding);
182 
183   VMReg as_VMReg();
184 
185   int   encoding() const          { assert(is_valid(), &quot;invalid register&quot;); return value(); }
186   bool  is_valid() const          { return 0 &lt;= (intx)this &amp;&amp; (intx)this &lt; number_of_registers; }
187   FloatRegister successor() const { return as_FloatRegister(encoding() + 1); }
188 
189   const char* name() const;
190 
191   int hi_bits() const {
192     return (encoding() &gt;&gt; 1) &amp; 0xf;
193   }
194 
195   int lo_bit() const {
196     return encoding() &amp; 1;
197   }
198 
199   int hi_bit() const {
200     return encoding() &gt;&gt; 5;
201   }
202 };
203 
204 CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg, (-1));
205 
206 
207 /*
208  * S1-S6 are named with &quot;_reg&quot; suffix to avoid conflict with
209  * constants defined in sharedRuntimeTrig.cpp
210  */
211 CONSTANT_REGISTER_DECLARATION(FloatRegister, S0,     ( 0));
212 CONSTANT_REGISTER_DECLARATION(FloatRegister, S1_reg, ( 1));
213 CONSTANT_REGISTER_DECLARATION(FloatRegister, S2_reg, ( 2));
214 CONSTANT_REGISTER_DECLARATION(FloatRegister, S3_reg, ( 3));
215 CONSTANT_REGISTER_DECLARATION(FloatRegister, S4_reg, ( 4));
216 CONSTANT_REGISTER_DECLARATION(FloatRegister, S5_reg, ( 5));
217 CONSTANT_REGISTER_DECLARATION(FloatRegister, S6_reg, ( 6));
218 CONSTANT_REGISTER_DECLARATION(FloatRegister, S7,     ( 7));
219 CONSTANT_REGISTER_DECLARATION(FloatRegister, S8,     ( 8));
220 CONSTANT_REGISTER_DECLARATION(FloatRegister, S9,     ( 9));
221 CONSTANT_REGISTER_DECLARATION(FloatRegister, S10,    (10));
222 CONSTANT_REGISTER_DECLARATION(FloatRegister, S11,    (11));
223 CONSTANT_REGISTER_DECLARATION(FloatRegister, S12,    (12));
224 CONSTANT_REGISTER_DECLARATION(FloatRegister, S13,    (13));
225 CONSTANT_REGISTER_DECLARATION(FloatRegister, S14,    (14));
226 CONSTANT_REGISTER_DECLARATION(FloatRegister, S15,    (15));
227 CONSTANT_REGISTER_DECLARATION(FloatRegister, S16,    (16));
228 CONSTANT_REGISTER_DECLARATION(FloatRegister, S17,    (17));
229 CONSTANT_REGISTER_DECLARATION(FloatRegister, S18,    (18));
230 CONSTANT_REGISTER_DECLARATION(FloatRegister, S19,    (19));
231 CONSTANT_REGISTER_DECLARATION(FloatRegister, S20,    (20));
232 CONSTANT_REGISTER_DECLARATION(FloatRegister, S21,    (21));
233 CONSTANT_REGISTER_DECLARATION(FloatRegister, S22,    (22));
234 CONSTANT_REGISTER_DECLARATION(FloatRegister, S23,    (23));
235 CONSTANT_REGISTER_DECLARATION(FloatRegister, S24,    (24));
236 CONSTANT_REGISTER_DECLARATION(FloatRegister, S25,    (25));
237 CONSTANT_REGISTER_DECLARATION(FloatRegister, S26,    (26));
238 CONSTANT_REGISTER_DECLARATION(FloatRegister, S27,    (27));
239 CONSTANT_REGISTER_DECLARATION(FloatRegister, S28,    (28));
240 CONSTANT_REGISTER_DECLARATION(FloatRegister, S29,    (29));
241 CONSTANT_REGISTER_DECLARATION(FloatRegister, S30,    (30));
242 CONSTANT_REGISTER_DECLARATION(FloatRegister, S31,    (31));
243 CONSTANT_REGISTER_DECLARATION(FloatRegister, Stemp,  (30));
244 
245 CONSTANT_REGISTER_DECLARATION(FloatRegister, D0,     ( 0));
246 CONSTANT_REGISTER_DECLARATION(FloatRegister, D1,     ( 2));
247 CONSTANT_REGISTER_DECLARATION(FloatRegister, D2,     ( 4));
248 CONSTANT_REGISTER_DECLARATION(FloatRegister, D3,     ( 6));
249 CONSTANT_REGISTER_DECLARATION(FloatRegister, D4,     ( 8));
250 CONSTANT_REGISTER_DECLARATION(FloatRegister, D5,     ( 10));
251 CONSTANT_REGISTER_DECLARATION(FloatRegister, D6,     ( 12));
252 CONSTANT_REGISTER_DECLARATION(FloatRegister, D7,     ( 14));
253 CONSTANT_REGISTER_DECLARATION(FloatRegister, D8,     ( 16));
254 CONSTANT_REGISTER_DECLARATION(FloatRegister, D9,     ( 18));
255 CONSTANT_REGISTER_DECLARATION(FloatRegister, D10,    ( 20));
256 CONSTANT_REGISTER_DECLARATION(FloatRegister, D11,    ( 22));
257 CONSTANT_REGISTER_DECLARATION(FloatRegister, D12,    ( 24));
258 CONSTANT_REGISTER_DECLARATION(FloatRegister, D13,    ( 26));
259 CONSTANT_REGISTER_DECLARATION(FloatRegister, D14,    ( 28));
260 CONSTANT_REGISTER_DECLARATION(FloatRegister, D15,    (30));
261 CONSTANT_REGISTER_DECLARATION(FloatRegister, D16,    (32));
262 CONSTANT_REGISTER_DECLARATION(FloatRegister, D17,    (34));
263 CONSTANT_REGISTER_DECLARATION(FloatRegister, D18,    (36));
264 CONSTANT_REGISTER_DECLARATION(FloatRegister, D19,    (38));
265 CONSTANT_REGISTER_DECLARATION(FloatRegister, D20,    (40));
266 CONSTANT_REGISTER_DECLARATION(FloatRegister, D21,    (42));
267 CONSTANT_REGISTER_DECLARATION(FloatRegister, D22,    (44));
268 CONSTANT_REGISTER_DECLARATION(FloatRegister, D23,    (46));
269 CONSTANT_REGISTER_DECLARATION(FloatRegister, D24,    (48));
270 CONSTANT_REGISTER_DECLARATION(FloatRegister, D25,    (50));
271 CONSTANT_REGISTER_DECLARATION(FloatRegister, D26,    (52));
272 CONSTANT_REGISTER_DECLARATION(FloatRegister, D27,    (54));
273 CONSTANT_REGISTER_DECLARATION(FloatRegister, D28,    (56));
274 CONSTANT_REGISTER_DECLARATION(FloatRegister, D29,    (58));
275 CONSTANT_REGISTER_DECLARATION(FloatRegister, D30,    (60));
276 CONSTANT_REGISTER_DECLARATION(FloatRegister, D31,    (62));
277 
278 
279 class ConcreteRegisterImpl : public AbstractRegisterImpl {
280  public:
281   enum {
282     log_vmregs_per_word = LogBytesPerWord - LogBytesPerInt, // VMRegs are of 4-byte size
283 #ifdef COMPILER2
284     log_bytes_per_fpr  = 2, // quad vectors
285 #else
286     log_bytes_per_fpr  = 2, // double vectors
287 #endif
288     log_words_per_fpr  = log_bytes_per_fpr - LogBytesPerWord,
289     words_per_fpr      = 1 &lt;&lt; log_words_per_fpr,
290     log_vmregs_per_fpr = log_bytes_per_fpr - LogBytesPerInt,
291     log_vmregs_per_gpr = log_vmregs_per_word,
292     vmregs_per_gpr = 1 &lt;&lt; log_vmregs_per_gpr,
293     vmregs_per_fpr = 1 &lt;&lt; log_vmregs_per_fpr,
294 
295     num_gpr  = RegisterImpl::number_of_registers &lt;&lt; log_vmregs_per_gpr,
296     max_gpr0 = num_gpr,
297     num_fpr  = FloatRegisterImpl::number_of_registers &lt;&lt; log_vmregs_per_fpr,
298     max_fpr0 = max_gpr0 + num_fpr,
299     number_of_registers = num_gpr + num_fpr + 1+1 // APSR and FPSCR so that c2&#39;s REG_COUNT &lt;= ConcreteRegisterImpl::number_of_registers
300   };
301 
302   static const int max_gpr;
303   static const int max_fpr;
304 };
305 
306 class VFPSystemRegisterImpl;
307 typedef VFPSystemRegisterImpl* VFPSystemRegister;
308 class VFPSystemRegisterImpl : public AbstractRegisterImpl {
309  public:
310   int   encoding() const          { return value(); }
311 };
312 
313 #define FPSID     ((VFPSystemRegister)0)
314 #define FPSCR     ((VFPSystemRegister)1)
315 #define MVFR0     ((VFPSystemRegister)0x6)
316 #define MVFR1     ((VFPSystemRegister)0x7)
317 
318 /*
319  * Register definitions shared across interpreter and compiler
320  */
321 #define Rexception_obj   R4
322 #define Rexception_pc    R5
323 
324 /*
325  * Interpreter register definitions common to C++ and template interpreters.
326  */
327 #define Rlocals          R8
328 #define Rmethod          R9
329 #define Rthread          R10
330 #define Rtemp            R12
331 
332 // Interpreter calling conventions
333 
334 #define Rparams          SP
335 #define Rsender_sp       R4
336 
337 // JSR292
338 //  Note: R5_mh is needed only during the call setup, including adapters
339 //  This does not seem to conflict with Rexception_pc
340 //  In case of issues, R3 might be OK but adapters calling the runtime would have to save it
341 #define R5_mh            R5 // MethodHandle register, used during the call setup
342 #define Rmh_SP_save      FP // for C1
343 
344 /*
345  * C++ Interpreter Register Defines
346  */
347 #define Rsave0   R4
348 #define Rsave1   R5
349 #define Rsave2   R6
350 #define Rstate   altFP_7_11 // R7 or R11
351 #define Ricklass R8
352 
353 /*
354  * TemplateTable Interpreter Register Usage
355  */
356 
357 // Temporary registers
358 #define R0_tmp                 R0
359 #define R1_tmp                 R1
360 #define R2_tmp                 R2
361 #define R3_tmp                 R3
362 #define R4_tmp                 R4
363 #define R5_tmp                 R5
364 #define R12_tmp                R12
365 #define LR_tmp                 LR
366 
367 #define S0_tmp                 S0
368 #define S1_tmp                 S1_reg
369 
370 #define D0_tmp                 D0
371 #define D1_tmp                 D1
372 
373 // Temporary registers saved across VM calls (according to C calling conventions)
374 #define Rtmp_save0             R4
375 #define Rtmp_save1             R5
376 
377 // Cached TOS value
378 #define R0_tos                 R0
379 
380 #define R0_tos_lo              R0
381 #define R1_tos_hi              R1
382 
383 #define S0_tos                 S0
384 #define D0_tos                 D0
385 
386 // Dispatch table
387 #define RdispatchTable         R6
388 
389 // Bytecode pointer
390 #define Rbcp                   altFP_7_11
391 
392 // Pre-loaded next bytecode for the dispatch
393 #define R3_bytecode            R3
394 
395 // Conventions between bytecode templates and stubs
396 #define R2_ClassCastException_obj        R2
397 #define R4_ArrayIndexOutOfBounds_index   R4
398 
399 // Interpreter expression stack top
400 #define Rstack_top             SP
401 
402 /*
403  * Linux 32-bit ARM C ABI Register calling conventions
404  *
405  *   REG         use                     callee/caller saved
406  *
407  *   R0         First argument reg            caller
408  *              result register
409  *   R1         Second argument reg           caller
410  *              result register
411  *   R2         Third argument reg            caller
412  *   R3         Fourth argument reg           caller
413  *
414  *   R4 - R8    Local variable registers      callee
415  *   R9
416  *   R10, R11   Local variable registers      callee
417  *
418  *   R12 (IP)   Scratch register used in inter-procedural calling
419  *   R13 (SP)   Stack Pointer                 callee
420  *   R14 (LR)   Link register
421  *   R15 (PC)   Program Counter
422  */
423 #define c_rarg0  R0
424 #define c_rarg1  R1
425 #define c_rarg2  R2
426 #define c_rarg3  R3
427 
428 
429 #define GPR_PARAMS    4
430 
431 
432 // Java ABI
433 // XXX Is this correct?
434 #define j_rarg0  c_rarg0
435 #define j_rarg1  c_rarg1
436 #define j_rarg2  c_rarg2
437 #define j_rarg3  c_rarg3
438 
439 
440 #endif // CPU_ARM_REGISTER_ARM_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/stubGenerator_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubRoutinesCrypto_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/stubGenerator_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.hpp&quot;
  27 #include &quot;assembler_arm.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;

  31 #include &quot;nativeInst_arm.hpp&quot;
  32 #include &quot;oops/instanceOop.hpp&quot;
  33 #include &quot;oops/method.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;prims/methodHandles.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/handles.inline.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;utilities/align.hpp&quot;

  43 #ifdef COMPILER2
  44 #include &quot;opto/runtime.hpp&quot;
  45 #endif
  46 
  47 // Declaration and definition of StubGenerator (no .hpp file).
  48 // For a more detailed description of the stub routine structure
  49 // see the comment in stubRoutines.hpp
  50 
  51 #define __ _masm-&gt;
  52 
  53 #ifdef PRODUCT
  54 #define BLOCK_COMMENT(str) /* nothing */
  55 #else
  56 #define BLOCK_COMMENT(str) __ block_comment(str)
  57 #endif
  58 
  59 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  60 
  61 // -------------------------------------------------------------------------------------------------------------------------
  62 // Stub Code definitions
</pre>
<hr />
<pre>
 161 
 162 #ifdef PRODUCT
 163 #define inc_counter_np(a,b,c) ((void)0)
 164 #else
 165 #define inc_counter_np(counter, t1, t2) \
 166   BLOCK_COMMENT(&quot;inc_counter &quot; #counter); \
 167   __ inc_counter(&amp;counter, t1, t2);
 168 #endif
 169 
 170  private:
 171 
 172   address generate_call_stub(address&amp; return_address) {
 173     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;call_stub&quot;);
 174     address start = __ pc();
 175 
 176 
 177     assert(frame::entry_frame_call_wrapper_offset == 0, &quot;adjust this code&quot;);
 178 
 179     __ mov(Rtemp, SP);
 180     __ push(RegisterSet(FP) | RegisterSet(LR));
<span class="line-modified"> 181 #ifndef __SOFTFP__</span>
<span class="line-removed"> 182     __ fstmdbd(SP, FloatRegisterSet(D8, 8), writeback);</span>
<span class="line-removed"> 183 #endif</span>
 184     __ stmdb(SP, RegisterSet(R0, R2) | RegisterSet(R4, R6) | RegisterSet(R8, R10) | altFP_7_11, writeback);
 185     __ mov(Rmethod, R3);
 186     __ ldmia(Rtemp, RegisterSet(R1, R3) | Rthread); // stacked arguments
 187 
 188     // XXX: TODO
 189     // Would be better with respect to native tools if the following
 190     // setting of FP was changed to conform to the native ABI, with FP
 191     // pointing to the saved FP slot (and the corresponding modifications
 192     // for entry_frame_call_wrapper_offset and frame::real_fp).
 193     __ mov(FP, SP);
 194 
 195     {
 196       Label no_parameters, pass_parameters;
 197       __ cmp(R3, 0);
 198       __ b(no_parameters, eq);
 199 
 200       __ bind(pass_parameters);
 201       __ ldr(Rtemp, Address(R2, wordSize, post_indexed)); // Rtemp OK, unused and scratchable
 202       __ subs(R3, R3, 1);
 203       __ push(Rtemp);
</pre>
<hr />
<pre>
 225     __ cmp(R3, T_FLOAT);
 226     __ b(l_float, eq);
 227 
 228     __ cmp(R3, T_LONG);
 229     __ str(R0, Address(R2));
 230     __ str(R1, Address(R2, wordSize), eq);
 231     __ b(cont);
 232 
 233 
 234     __ bind(l_double);
 235     __ fstd(D0, Address(R2));
 236     __ b(cont);
 237 
 238     __ bind(l_float);
 239     __ fsts(S0, Address(R2));
 240 
 241     __ bind(cont);
 242 #endif
 243 
 244     __ pop(RegisterSet(R4, R6) | RegisterSet(R8, R10) | altFP_7_11);
<span class="line-modified"> 245 #ifndef __SOFTFP__</span>
<span class="line-removed"> 246     __ fldmiad(SP, FloatRegisterSet(D8, 8), writeback);</span>
<span class="line-removed"> 247 #endif</span>
 248     __ pop(RegisterSet(FP) | RegisterSet(PC));
 249 
 250     return start;
 251   }
 252 
 253 
 254   // (in) Rexception_obj: exception oop
 255   address generate_catch_exception() {
 256     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;catch_exception&quot;);
 257     address start = __ pc();
 258 
 259     __ str(Rexception_obj, Address(Rthread, Thread::pending_exception_offset()));
 260     __ b(StubRoutines::_call_stub_return_address);
 261 
 262     return start;
 263   }
 264 
 265 
 266   // (in) Rexception_pc: return address
 267   address generate_forward_exception() {
</pre>
<hr />
<pre>
 419 
 420 
 421  // As per atomic.hpp the Atomic read-modify-write operations must be logically implemented as:
 422  //  &lt;fence&gt;; &lt;op&gt;; &lt;membar StoreLoad|StoreStore&gt;
 423  // But for load-linked/store-conditional based systems a fence here simply means
 424  // no load/store can be reordered with respect to the initial load-linked, so we have:
 425  // &lt;membar storeload|loadload&gt; ; load-linked; &lt;op&gt;; store-conditional; &lt;membar storeload|storestore&gt;
 426  // There are no memory actions in &lt;op&gt; so nothing further is needed.
 427  //
 428  // So we define the following for convenience:
 429 #define MEMBAR_ATOMIC_OP_PRE \
 430     MacroAssembler::Membar_mask_bits(MacroAssembler::StoreLoad|MacroAssembler::LoadLoad)
 431 #define MEMBAR_ATOMIC_OP_POST \
 432     MacroAssembler::Membar_mask_bits(MacroAssembler::StoreLoad|MacroAssembler::StoreStore)
 433 
 434   // Note: JDK 9 only supports ARMv7+ so we always have ldrexd available even though the
 435   // code below allows for it to be otherwise. The else clause indicates an ARMv5 system
 436   // for which we do not support MP and so membars are not necessary. This ARMv5 code will
 437   // be removed in the future.
 438 
<span class="line-modified"> 439   // Support for jint Atomic::add(jint add_value, volatile jint *dest)</span>

 440   //
 441   // Arguments :
 442   //
 443   //      add_value:      R0
 444   //      dest:           R1
 445   //
 446   // Results:
 447   //
 448   //     R0: the new stored in dest
 449   //
 450   // Overwrites:
 451   //
 452   //     R1, R2, R3
 453   //
 454   address generate_atomic_add() {
 455     address start;
 456 
 457     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_add&quot;);
 458     Label retry;
 459     start = __ pc();
</pre>
<hr />
<pre>
 469       __ ldrex(newval, Address(dest));
 470       __ add(newval, addval, newval);
 471       __ strex(ok, newval, Address(dest));
 472       __ cmp(ok, 0);
 473       __ b(retry, ne);
 474       __ mov (R0, newval);
 475       __ membar(MEMBAR_ATOMIC_OP_POST, prev);
 476     } else {
 477       __ bind(retry);
 478       __ ldr (prev, Address(dest));
 479       __ add(newval, addval, prev);
 480       __ atomic_cas_bool(prev, newval, dest, 0, noreg/*ignored*/);
 481       __ b(retry, ne);
 482       __ mov (R0, newval);
 483     }
 484     __ bx(LR);
 485 
 486     return start;
 487   }
 488 
<span class="line-modified"> 489   // Support for jint Atomic::xchg(jint exchange_value, volatile jint *dest)</span>

 490   //
 491   // Arguments :
 492   //
 493   //      exchange_value: R0
 494   //      dest:           R1
 495   //
 496   // Results:
 497   //
 498   //     R0: the value previously stored in dest
 499   //
 500   // Overwrites:
 501   //
 502   //     R1, R2, R3
 503   //
 504   address generate_atomic_xchg() {
 505     address start;
 506 
 507     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_xchg&quot;);
 508     start = __ pc();
 509     Register newval    = R0;
</pre>
<hr />
<pre>
 517       __ membar(MEMBAR_ATOMIC_OP_PRE, prev);
 518       __ bind(retry);
 519       __ ldrex(prev, Address(dest));
 520       __ strex(ok, newval, Address(dest));
 521       __ cmp(ok, 0);
 522       __ b(retry, ne);
 523       __ mov (R0, prev);
 524       __ membar(MEMBAR_ATOMIC_OP_POST, prev);
 525     } else {
 526       __ bind(retry);
 527       __ ldr (prev, Address(dest));
 528       __ atomic_cas_bool(prev, newval, dest, 0, noreg/*ignored*/);
 529       __ b(retry, ne);
 530       __ mov (R0, prev);
 531     }
 532     __ bx(LR);
 533 
 534     return start;
 535   }
 536 
<span class="line-modified"> 537   // Support for jint Atomic::cmpxchg(jint exchange_value, volatile jint *dest, jint compare_value)</span>

 538   //
 539   // Arguments :
 540   //
 541   //      compare_value:  R0
 542   //      exchange_value: R1
 543   //      dest:           R2
 544   //
 545   // Results:
 546   //
 547   //     R0: the value previously stored in dest
 548   //
 549   // Overwrites:
 550   //
 551   //     R0, R1, R2, R3, Rtemp
 552   //
 553   address generate_atomic_cmpxchg() {
 554     address start;
 555 
 556     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_cmpxchg&quot;);
 557     start = __ pc();
</pre>
<hr />
<pre>
 910   // Generate the inner loop for forward aligned array copy
 911   //
 912   // Arguments
 913   //      from:      src address, 64 bits  aligned
 914   //      to:        dst address, wordSize aligned
 915   //      count:     number of elements (32-bit int)
 916   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
 917   //
 918   // Return the minimum initial value for count
 919   //
 920   // Notes:
 921   // - &#39;from&#39; aligned on 64-bit (recommended for 32-bit ARM in case this speeds up LDMIA)
 922   // - &#39;to&#39; aligned on wordSize
 923   // - &#39;count&#39; must be greater or equal than the returned value
 924   //
 925   // Increases &#39;from&#39; and &#39;to&#39; by count*bytes_per_count.
 926   //
 927   // Scratches &#39;count&#39;, R3.
 928   // R4-R10 are preserved (saved/restored).
 929   //
<span class="line-modified"> 930   int generate_forward_aligned_copy_loop(Register from, Register to, Register count, int bytes_per_count) {</span>
 931     assert (from == R0 &amp;&amp; to == R1 &amp;&amp; count == R2, &quot;adjust the implementation below&quot;);
 932 
 933     const int bytes_per_loop = 8*wordSize; // 8 registers are read and written on every loop iteration
 934     arraycopy_loop_config *config=&amp;arraycopy_configurations[ArmCopyPlatform].forward_aligned;
 935     int pld_offset = config-&gt;pld_distance;
 936     const int count_per_loop = bytes_per_loop / bytes_per_count;
 937 
 938     bool split_read= config-&gt;split_ldm;
 939     bool split_write= config-&gt;split_stm;
 940 
 941     // XXX optim: use VLDM/VSTM when available (Neon) with PLD
 942     //  NEONCopyPLD
 943     //      PLD [r1, #0xC0]
 944     //      VLDM r1!,{d0-d7}
 945     //      VSTM r0!,{d0-d7}
 946     //      SUBS r2,r2,#0x40
 947     //      BGE NEONCopyPLD
 948 
 949     __ push(RegisterSet(R4,R10));
 950 
 951     const bool prefetch_before = pld_offset &lt; 0;
 952     const bool prefetch_after = pld_offset &gt; 0;
 953 
 954     Label L_skip_pld;
 955 
<span class="line-modified"> 956     // predecrease to exit when there is less than count_per_loop</span>
<span class="line-modified"> 957     __ sub_32(count, count, count_per_loop);</span>



 958 
<span class="line-modified"> 959     if (pld_offset != 0) {</span>
<span class="line-modified"> 960       pld_offset = (pld_offset &lt; 0) ? -pld_offset : pld_offset;</span>
 961 
<span class="line-modified"> 962       prefetch(from, to, 0);</span>
 963 
<span class="line-modified"> 964       if (prefetch_before) {</span>
<span class="line-modified"> 965         // If prefetch is done ahead, final PLDs that overflow the</span>
<span class="line-modified"> 966         // copied area can be easily avoided. &#39;count&#39; is predecreased</span>
<span class="line-modified"> 967         // by the prefetch distance to optimize the inner loop and the</span>
<span class="line-modified"> 968         // outer loop skips the PLD.</span>
<span class="line-modified"> 969         __ subs_32(count, count, (bytes_per_loop+pld_offset)/bytes_per_count);</span>
 970 
<span class="line-modified"> 971         // skip prefetch for small copies</span>
<span class="line-modified"> 972         __ b(L_skip_pld, lt);</span>
<span class="line-modified"> 973       }</span>
 974 
<span class="line-modified"> 975       int offset = ArmCopyCacheLineSize;</span>
<span class="line-modified"> 976       while (offset &lt;= pld_offset) {</span>
<span class="line-modified"> 977         prefetch(from, to, offset);</span>
<span class="line-modified"> 978         offset += ArmCopyCacheLineSize;</span>
<span class="line-modified"> 979       };</span>
<span class="line-modified"> 980     }</span>
 981 
<span class="line-modified"> 982     {</span>
<span class="line-modified"> 983       // 32-bit ARM note: we have tried implementing loop unrolling to skip one</span>
<span class="line-modified"> 984       // PLD with 64 bytes cache line but the gain was not significant.</span>
 985 
<span class="line-modified"> 986       Label L_copy_loop;</span>
<span class="line-modified"> 987       __ align(OptoLoopAlignment);</span>
<span class="line-modified"> 988       __ BIND(L_copy_loop);</span>
 989 
<span class="line-modified"> 990       if (prefetch_before) {</span>
<span class="line-modified"> 991         prefetch(from, to, bytes_per_loop + pld_offset);</span>
<span class="line-modified"> 992         __ BIND(L_skip_pld);</span>
<span class="line-modified"> 993       }</span>
 994 
<span class="line-modified"> 995       if (split_read) {</span>
<span class="line-modified"> 996         // Split the register set in two sets so that there is less</span>
<span class="line-modified"> 997         // latency between LDM and STM (R3-R6 available while R7-R10</span>
<span class="line-modified"> 998         // still loading) and less register locking issue when iterating</span>
<span class="line-modified"> 999         // on the first LDM.</span>
<span class="line-modified">1000         __ ldmia(from, RegisterSet(R3, R6), writeback);</span>
<span class="line-modified">1001         __ ldmia(from, RegisterSet(R7, R10), writeback);</span>
<span class="line-modified">1002       } else {</span>
<span class="line-modified">1003         __ ldmia(from, RegisterSet(R3, R10), writeback);</span>
<span class="line-modified">1004       }</span>
1005 
<span class="line-modified">1006       __ subs_32(count, count, count_per_loop);</span>
1007 
<span class="line-modified">1008       if (prefetch_after) {</span>
<span class="line-modified">1009         prefetch(from, to, pld_offset, bytes_per_loop);</span>
<span class="line-modified">1010       }</span>
1011 
<span class="line-modified">1012       if (split_write) {</span>
<span class="line-modified">1013         __ stmia(to, RegisterSet(R3, R6), writeback);</span>
<span class="line-modified">1014         __ stmia(to, RegisterSet(R7, R10), writeback);</span>
<span class="line-modified">1015       } else {</span>
<span class="line-modified">1016         __ stmia(to, RegisterSet(R3, R10), writeback);</span>
<span class="line-modified">1017       }</span>
1018 
<span class="line-modified">1019       __ b(L_copy_loop, ge);</span>
1020 
<span class="line-modified">1021       if (prefetch_before) {</span>
<span class="line-modified">1022         // the inner loop may end earlier, allowing to skip PLD for the last iterations</span>
<span class="line-modified">1023         __ cmn_32(count, (bytes_per_loop + pld_offset)/bytes_per_count);</span>
<span class="line-modified">1024         __ b(L_skip_pld, ge);</span>

1025       }
<span class="line-modified">1026     }</span>
<span class="line-modified">1027     BLOCK_COMMENT(&quot;Remaining bytes:&quot;);</span>
<span class="line-removed">1028     // still 0..bytes_per_loop-1 aligned bytes to copy, count already decreased by (at least) bytes_per_loop bytes</span>
1029 
<span class="line-modified">1030     // __ add(count, count, ...); // addition useless for the bit tests</span>
<span class="line-modified">1031     assert (pld_offset % bytes_per_loop == 0, &quot;decreasing count by pld_offset before loop must not change tested bits&quot;);</span>
1032 
<span class="line-modified">1033     __ tst(count, 16 / bytes_per_count);</span>
<span class="line-modified">1034     __ ldmia(from, RegisterSet(R3, R6), writeback, ne); // copy 16 bytes</span>
<span class="line-modified">1035     __ stmia(to, RegisterSet(R3, R6), writeback, ne);</span>
1036 
<span class="line-modified">1037     __ tst(count, 8 / bytes_per_count);</span>
<span class="line-modified">1038     __ ldmia(from, RegisterSet(R3, R4), writeback, ne); // copy 8 bytes</span>
<span class="line-modified">1039     __ stmia(to, RegisterSet(R3, R4), writeback, ne);</span>
1040 
<span class="line-modified">1041     if (bytes_per_count &lt;= 4) {</span>
<span class="line-modified">1042       __ tst(count, 4 / bytes_per_count);</span>
<span class="line-modified">1043       __ ldr(R3, Address(from, 4, post_indexed), ne); // copy 4 bytes</span>
<span class="line-modified">1044       __ str(R3, Address(to, 4, post_indexed), ne);</span>
<span class="line-modified">1045     }</span>
1046 
<span class="line-modified">1047     if (bytes_per_count &lt;= 2) {</span>
<span class="line-modified">1048       __ tst(count, 2 / bytes_per_count);</span>
<span class="line-modified">1049       __ ldrh(R3, Address(from, 2, post_indexed), ne); // copy 2 bytes</span>
<span class="line-modified">1050       __ strh(R3, Address(to, 2, post_indexed), ne);</span>
<span class="line-modified">1051     }</span>
1052 
<span class="line-modified">1053     if (bytes_per_count == 1) {</span>
<span class="line-modified">1054       __ tst(count, 1);</span>
<span class="line-modified">1055       __ ldrb(R3, Address(from, 1, post_indexed), ne);</span>
<span class="line-modified">1056       __ strb(R3, Address(to, 1, post_indexed), ne);</span>

1057     }
1058 
1059     __ pop(RegisterSet(R4,R10));
1060 
1061     return count_per_loop;
1062   }
1063 
1064 
1065   // Generate the inner loop for backward aligned array copy
1066   //
1067   // Arguments
1068   //      end_from:      src end address, 64 bits  aligned
1069   //      end_to:        dst end address, wordSize aligned
1070   //      count:         number of elements (32-bit int)
1071   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
1072   //
1073   // Return the minimum initial value for count
1074   //
1075   // Notes:
1076   // - &#39;end_from&#39; aligned on 64-bit (recommended for 32-bit ARM in case this speeds up LDMIA)
1077   // - &#39;end_to&#39; aligned on wordSize
1078   // - &#39;count&#39; must be greater or equal than the returned value
1079   //
1080   // Decreases &#39;end_from&#39; and &#39;end_to&#39; by count*bytes_per_count.
1081   //
1082   // Scratches &#39;count&#39;, R3.
1083   // ARM R4-R10 are preserved (saved/restored).
1084   //
<span class="line-modified">1085   int generate_backward_aligned_copy_loop(Register end_from, Register end_to, Register count, int bytes_per_count) {</span>
1086     assert (end_from == R0 &amp;&amp; end_to == R1 &amp;&amp; count == R2, &quot;adjust the implementation below&quot;);
1087 
1088     const int bytes_per_loop = 8*wordSize; // 8 registers are read and written on every loop iteration
1089     const int count_per_loop = bytes_per_loop / bytes_per_count;
1090 
1091     arraycopy_loop_config *config=&amp;arraycopy_configurations[ArmCopyPlatform].backward_aligned;
1092     int pld_offset = config-&gt;pld_distance;
1093 
1094     bool split_read= config-&gt;split_ldm;
1095     bool split_write= config-&gt;split_stm;
1096 
1097     // See the forward copy variant for additional comments.
1098 
1099     __ push(RegisterSet(R4,R10));
1100 
<span class="line-modified">1101     __ sub_32(count, count, count_per_loop);</span>



1102 
<span class="line-modified">1103     const bool prefetch_before = pld_offset &lt; 0;</span>
<span class="line-modified">1104     const bool prefetch_after = pld_offset &gt; 0;</span>
1105 
<span class="line-modified">1106     Label L_skip_pld;</span>
1107 
<span class="line-modified">1108     if (pld_offset != 0) {</span>
<span class="line-modified">1109       pld_offset = (pld_offset &lt; 0) ? -pld_offset : pld_offset;</span>
1110 
<span class="line-modified">1111       prefetch(end_from, end_to, -wordSize);</span>
1112 
<span class="line-modified">1113       if (prefetch_before) {</span>
<span class="line-modified">1114         __ subs_32(count, count, (bytes_per_loop + pld_offset) / bytes_per_count);</span>
<span class="line-modified">1115         __ b(L_skip_pld, lt);</span>
<span class="line-modified">1116       }</span>
1117 
<span class="line-modified">1118       int offset = ArmCopyCacheLineSize;</span>
<span class="line-modified">1119       while (offset &lt;= pld_offset) {</span>
<span class="line-modified">1120         prefetch(end_from, end_to, -(wordSize + offset));</span>
<span class="line-modified">1121         offset += ArmCopyCacheLineSize;</span>
<span class="line-modified">1122       };</span>
<span class="line-modified">1123     }</span>
1124 
<span class="line-modified">1125     {</span>
<span class="line-modified">1126       // 32-bit ARM note: we have tried implementing loop unrolling to skip one</span>
<span class="line-modified">1127       // PLD with 64 bytes cache line but the gain was not significant.</span>
1128 
<span class="line-modified">1129       Label L_copy_loop;</span>
<span class="line-modified">1130       __ align(OptoLoopAlignment);</span>
<span class="line-modified">1131       __ BIND(L_copy_loop);</span>
1132 
<span class="line-modified">1133       if (prefetch_before) {</span>
<span class="line-modified">1134         prefetch(end_from, end_to, -(wordSize + bytes_per_loop + pld_offset));</span>
<span class="line-modified">1135         __ BIND(L_skip_pld);</span>
<span class="line-modified">1136       }</span>
1137 
<span class="line-modified">1138       if (split_read) {</span>
<span class="line-modified">1139         __ ldmdb(end_from, RegisterSet(R7, R10), writeback);</span>
<span class="line-modified">1140         __ ldmdb(end_from, RegisterSet(R3, R6), writeback);</span>
<span class="line-modified">1141       } else {</span>
<span class="line-modified">1142         __ ldmdb(end_from, RegisterSet(R3, R10), writeback);</span>
<span class="line-modified">1143       }</span>
1144 
<span class="line-modified">1145       __ subs_32(count, count, count_per_loop);</span>
1146 
<span class="line-modified">1147       if (prefetch_after) {</span>
<span class="line-modified">1148         prefetch(end_from, end_to, -(wordSize + pld_offset), -bytes_per_loop);</span>
<span class="line-modified">1149       }</span>
1150 
<span class="line-modified">1151       if (split_write) {</span>
<span class="line-modified">1152         __ stmdb(end_to, RegisterSet(R7, R10), writeback);</span>
<span class="line-modified">1153         __ stmdb(end_to, RegisterSet(R3, R6), writeback);</span>
<span class="line-modified">1154       } else {</span>
<span class="line-modified">1155         __ stmdb(end_to, RegisterSet(R3, R10), writeback);</span>
<span class="line-modified">1156       }</span>
1157 
<span class="line-modified">1158       __ b(L_copy_loop, ge);</span>
1159 
<span class="line-modified">1160       if (prefetch_before) {</span>
<span class="line-modified">1161         __ cmn_32(count, (bytes_per_loop + pld_offset)/bytes_per_count);</span>
<span class="line-modified">1162         __ b(L_skip_pld, ge);</span>

1163       }
<span class="line-modified">1164     }</span>
<span class="line-modified">1165     BLOCK_COMMENT(&quot;Remaining bytes:&quot;);</span>
<span class="line-removed">1166     // still 0..bytes_per_loop-1 aligned bytes to copy, count already decreased by (at least) bytes_per_loop bytes</span>
1167 
<span class="line-modified">1168     // __ add(count, count, ...); // addition useless for the bit tests</span>
<span class="line-modified">1169     assert (pld_offset % bytes_per_loop == 0, &quot;decreasing count by pld_offset before loop must not change tested bits&quot;);</span>
1170 
<span class="line-modified">1171     __ tst(count, 16 / bytes_per_count);</span>
<span class="line-modified">1172     __ ldmdb(end_from, RegisterSet(R3, R6), writeback, ne); // copy 16 bytes</span>
<span class="line-modified">1173     __ stmdb(end_to, RegisterSet(R3, R6), writeback, ne);</span>
1174 
<span class="line-modified">1175     __ tst(count, 8 / bytes_per_count);</span>
<span class="line-modified">1176     __ ldmdb(end_from, RegisterSet(R3, R4), writeback, ne); // copy 8 bytes</span>
<span class="line-modified">1177     __ stmdb(end_to, RegisterSet(R3, R4), writeback, ne);</span>
1178 
<span class="line-modified">1179     if (bytes_per_count &lt;= 4) {</span>
<span class="line-modified">1180       __ tst(count, 4 / bytes_per_count);</span>
<span class="line-modified">1181       __ ldr(R3, Address(end_from, -4, pre_indexed), ne); // copy 4 bytes</span>
<span class="line-modified">1182       __ str(R3, Address(end_to, -4, pre_indexed), ne);</span>
<span class="line-modified">1183     }</span>
1184 
<span class="line-modified">1185     if (bytes_per_count &lt;= 2) {</span>
<span class="line-modified">1186       __ tst(count, 2 / bytes_per_count);</span>
<span class="line-modified">1187       __ ldrh(R3, Address(end_from, -2, pre_indexed), ne); // copy 2 bytes</span>
<span class="line-modified">1188       __ strh(R3, Address(end_to, -2, pre_indexed), ne);</span>
<span class="line-modified">1189     }</span>
1190 
<span class="line-modified">1191     if (bytes_per_count == 1) {</span>
<span class="line-modified">1192       __ tst(count, 1);</span>
<span class="line-modified">1193       __ ldrb(R3, Address(end_from, -1, pre_indexed), ne);</span>
<span class="line-modified">1194       __ strb(R3, Address(end_to, -1, pre_indexed), ne);</span>

1195     }
<span class="line-removed">1196 </span>
1197     __ pop(RegisterSet(R4,R10));
1198 
1199     return count_per_loop;
1200   }
1201 
1202 
1203   // Generate the inner loop for shifted forward array copy (unaligned copy).
1204   // It can be used when bytes_per_count &lt; wordSize, i.e. byte/short copy
1205   //
1206   // Arguments
1207   //      from:      start src address, 64 bits aligned
1208   //      to:        start dst address, (now) wordSize aligned
1209   //      count:     number of elements (32-bit int)
1210   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
1211   //      lsr_shift: shift applied to &#39;old&#39; value to skipped already written bytes
1212   //      lsl_shift: shift applied to &#39;new&#39; value to set the high bytes of the next write
1213   //
1214   // Return the minimum initial value for count
1215   //
1216   // Notes:
</pre>
<hr />
<pre>
1731       store_one(tmp, to, bytes_per_count, forward, ne);
1732       if (bytes_per_count &lt; 4) {
1733         __ b(L_align_src, ne); // if bytes_per_count == 4, then 0 or 1 loop iterations are enough
1734       }
1735     }
1736     return 7/bytes_per_count;
1737   }
1738 
1739   // Copies &#39;count&#39; of &#39;bytes_per_count&#39;-sized elements in the specified direction.
1740   //
1741   // Arguments:
1742   //     from:              beginning (if forward) or upper bound (if !forward) of the region to be read
1743   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1744   //     count:             32-bit int, number of elements to be copied
1745   //     entry:             copy loop entry point
1746   //     bytes_per_count:   size of an element
1747   //     forward:           specifies copy direction
1748   //
1749   // Notes:
1750   //     shifts &#39;from&#39; and &#39;to&#39;
<span class="line-modified">1751   void copy_small_array(Register from, Register to, Register count, Register tmp, Register tmp2, int bytes_per_count, bool forward, Label &amp; entry) {</span>
1752     assert_different_registers(from, to, count, tmp);
1753 
<span class="line-modified">1754     __ align(OptoLoopAlignment);</span>
<span class="line-modified">1755     Label L_small_loop;</span>
<span class="line-modified">1756     __ BIND(L_small_loop);</span>
<span class="line-modified">1757     store_one(tmp, to, bytes_per_count, forward, al, tmp2);</span>
<span class="line-modified">1758     __ BIND(entry); // entry point</span>
<span class="line-modified">1759     __ subs(count, count, 1);</span>
<span class="line-modified">1760     load_one(tmp, from, bytes_per_count, forward, ge, tmp2);</span>
<span class="line-modified">1761     __ b(L_small_loop, ge);</span>




1762   }
1763 
1764   // Aligns &#39;to&#39; by reading one word from &#39;from&#39; and writting its part to &#39;to&#39;.
1765   //
1766   // Arguments:
1767   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1768   //     count:             32-bit int, number of elements allowed to be copied
1769   //     to_remainder:      remainder of dividing &#39;to&#39; by wordSize
1770   //     bytes_per_count:   size of an element
1771   //     forward:           specifies copy direction
1772   //     Rval:              contains an already read but not yet written word;
1773   //                        its&#39; LSBs (if forward) or MSBs (if !forward) are to be written to align &#39;to&#39;.
1774   //
1775   // Notes:
1776   //     &#39;count&#39; must not be less then the returned value
1777   //     &#39;to&#39; must be aligned by bytes_per_count but must not be aligned by wordSize
1778   //     shifts &#39;to&#39; by the number of written bytes (so that it becomes the bound of memory to be written)
1779   //     decreases &#39;count&#39; by the the number of elements written
1780   //     Rval&#39;s MSBs or LSBs remain to be written further by generate_{forward,backward}_shifted_copy_loop
1781   int align_dst(Register to, Register count, Register Rval, Register tmp,
</pre>
<hr />
<pre>
1858     return min_copy + required_to_align;
1859   }
1860 
1861   // Copies &#39;count&#39; of elements using shifted copy loop
1862   //
1863   // Arguments:
1864   //     from:              beginning (if forward) or upper bound (if !forward) of the region to be read
1865   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1866   //     count:             32-bit int, number of elements to be copied
1867   //     bytes_per_count:   size of an element
1868   //     forward:           specifies copy direction
1869   //
1870   // Notes:
1871   //     &#39;count&#39; must not be less then the returned value
1872   //     &#39;from&#39; must be aligned by wordSize
1873   //     &#39;to&#39; must be aligned by bytes_per_count but must not be aligned by wordSize
1874   //     shifts &#39;to&#39; by the number of copied bytes
1875   //
1876   // Scratches &#39;from&#39;, &#39;count&#39;, R3 and R12.
1877   // R4-R10 saved for use.
<span class="line-modified">1878   int align_dst_and_generate_shifted_copy_loop(Register from, Register to, Register count, int bytes_per_count, bool forward) {</span>
1879 
1880     const Register Rval = forward ? R12 : R3; // as generate_{forward,backward}_shifted_copy_loop expect
1881 
1882     int min_copy = 0;
1883 
1884     // Note: if {seq} is a sequence of numbers, L{seq} means that if the execution reaches this point,
1885     // then the remainder of &#39;to&#39; divided by wordSize is one of elements of {seq}.
1886 
1887     __ push(RegisterSet(R4,R10));
<span class="line-removed">1888     load_one(Rval, from, wordSize, forward);</span>
1889 
<span class="line-modified">1890     switch (bytes_per_count) {</span>
<span class="line-modified">1891       case 2:</span>
<span class="line-modified">1892         min_copy = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 2, bytes_per_count, forward);</span>
<span class="line-modified">1893         break;</span>
<span class="line-modified">1894       case 1:</span>
<span class="line-modified">1895       {</span>
<span class="line-modified">1896         Label L1, L2, L3;</span>
<span class="line-modified">1897         int min_copy1, min_copy2, min_copy3;</span>
<span class="line-modified">1898 </span>
<span class="line-modified">1899         Label L_loop_finished;</span>
<span class="line-modified">1900 </span>
<span class="line-modified">1901         if (forward) {</span>
<span class="line-modified">1902             __ tbz(to, 0, L2);</span>
<span class="line-modified">1903             __ tbz(to, 1, L1);</span>



















1904 
<span class="line-modified">1905             __ BIND(L3);</span>
<span class="line-modified">1906             min_copy3 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 3, bytes_per_count, forward);</span>
<span class="line-modified">1907             __ b(L_loop_finished);</span>
1908 
<span class="line-modified">1909             __ BIND(L1);</span>
<span class="line-modified">1910             min_copy1 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 1, bytes_per_count, forward);</span>
<span class="line-modified">1911             __ b(L_loop_finished);</span>
1912 
<span class="line-modified">1913             __ BIND(L2);</span>
<span class="line-modified">1914             min_copy2 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 2, bytes_per_count, forward);</span>
<span class="line-modified">1915         } else {</span>
<span class="line-removed">1916             __ tbz(to, 0, L2);</span>
<span class="line-removed">1917             __ tbnz(to, 1, L3);</span>
1918 
<span class="line-modified">1919             __ BIND(L1);</span>
<span class="line-removed">1920             min_copy1 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 1, bytes_per_count, forward);</span>
<span class="line-removed">1921             __ b(L_loop_finished);</span>
1922 
<span class="line-modified">1923              __ BIND(L3);</span>
<span class="line-removed">1924             min_copy3 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 3, bytes_per_count, forward);</span>
<span class="line-removed">1925             __ b(L_loop_finished);</span>
1926 
<span class="line-modified">1927            __ BIND(L2);</span>
<span class="line-removed">1928             min_copy2 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 2, bytes_per_count, forward);</span>
1929         }
<span class="line-modified">1930 </span>
<span class="line-modified">1931         min_copy = MAX2(MAX2(min_copy1, min_copy2), min_copy3);</span>
<span class="line-modified">1932 </span>
<span class="line-removed">1933         __ BIND(L_loop_finished);</span>
<span class="line-removed">1934 </span>
<span class="line-removed">1935         break;</span>
1936       }
<span class="line-removed">1937       default:</span>
<span class="line-removed">1938         ShouldNotReachHere();</span>
<span class="line-removed">1939         break;</span>
1940     }
<span class="line-removed">1941 </span>
1942     __ pop(RegisterSet(R4,R10));
1943 
1944     return min_copy;
1945   }
1946 
1947 #ifndef PRODUCT
1948   int * get_arraycopy_counter(int bytes_per_count) {
1949     switch (bytes_per_count) {
1950       case 1:
1951         return &amp;SharedRuntime::_jbyte_array_copy_ctr;
1952       case 2:
1953         return &amp;SharedRuntime::_jshort_array_copy_ctr;
1954       case 4:
1955         return &amp;SharedRuntime::_jint_array_copy_ctr;
1956       case 8:
1957         return &amp;SharedRuntime::_jlong_array_copy_ctr;
1958       default:
1959         ShouldNotReachHere();
1960         return NULL;
1961     }
1962   }
1963 #endif // !PRODUCT
1964 







1965   //
1966   //  Generate stub for primitive array copy.  If &quot;aligned&quot; is true, the
1967   //  &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1968   //
1969   //  If &quot;disjoint&quot; is true, arrays are assumed to be disjoint, otherwise they may overlap and
1970   //  &quot;nooverlap_target&quot; must be specified as the address to jump if they don&#39;t.
1971   //
1972   // Arguments for generated stub:
1973   //      from:  R0
1974   //      to:    R1
1975   //      count: R2 treated as signed 32-bit int
1976   //
1977   address generate_primitive_copy(bool aligned, const char * name, bool status, int bytes_per_count, bool disjoint, address nooverlap_target = NULL) {
1978     __ align(CodeEntryAlignment);
1979     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
1980     address start = __ pc();
1981 
1982     const Register from  = R0;   // source array address
1983     const Register to    = R1;   // destination array address
1984     const Register count = R2;   // elements count
</pre>
<hr />
<pre>
2015     //  *) The small and simple one applicable for any array (but not efficient for large arrays).
2016     // Currently &quot;small&quot; implementation is used if and only if the &quot;large&quot; one could not be used.
2017     // XXX optim: tune the limit higher ?
2018     // Large implementation lower applicability bound is actually determined by
2019     // aligned copy loop which require &lt;=7 bytes for src alignment, and 8 words for aligned copy loop.
2020     const int small_copy_limit = (8*wordSize + 7) / bytes_per_count;
2021 
2022     Label L_small_array;
2023     __ cmp_32(count, small_copy_limit);
2024     __ b(L_small_array, le);
2025 
2026     // Otherwise proceed with large implementation.
2027 
2028     bool from_is_aligned = (bytes_per_count &gt;= 8);
2029     if (aligned &amp;&amp; forward &amp;&amp; (HeapWordSize % 8 == 0)) {
2030         // if &#39;from&#39; is heapword aligned and HeapWordSize is divisible by 8,
2031         //  then from is aligned by 8
2032         from_is_aligned = true;
2033     }
2034 
<span class="line-modified">2035     int count_required_to_align = from_is_aligned ? 0 : align_src(from, to, count, tmp1, bytes_per_count, forward);</span>
<span class="line-modified">2036     assert (small_copy_limit &gt;= count_required_to_align, &quot;alignment could exhaust count&quot;);</span>





2037 
2038     // now &#39;from&#39; is aligned
2039 
2040     bool to_is_aligned = false;
2041 
2042     if (bytes_per_count &gt;= wordSize) {
2043       // &#39;to&#39; is aligned by bytes_per_count, so it is aligned by wordSize
2044       to_is_aligned = true;
2045     } else {
2046       if (aligned &amp;&amp; (8 % HeapWordSize == 0) &amp;&amp; (HeapWordSize % wordSize == 0)) {
2047         // Originally &#39;from&#39; and &#39;to&#39; were heapword aligned;
2048         // (from - to) has not been changed, so since now &#39;from&#39; is 8-byte aligned, then it is also heapword aligned,
2049         //  so &#39;to&#39; is also heapword aligned and thus aligned by wordSize.
2050         to_is_aligned = true;
2051       }
2052     }
2053 
2054     Label L_unaligned_dst;
2055 
2056     if (!to_is_aligned) {
2057       BLOCK_COMMENT(&quot;Check dst alignment:&quot;);
2058       __ tst(to, wordSize - 1);
2059       __ b(L_unaligned_dst, ne); // &#39;to&#39; is not aligned
2060     }
2061 
2062     // &#39;from&#39; and &#39;to&#39; are properly aligned
2063 
2064     int min_copy;
2065     if (forward) {
<span class="line-modified">2066       min_copy = generate_forward_aligned_copy_loop (from, to, count, bytes_per_count);</span>
2067     } else {
<span class="line-modified">2068       min_copy = generate_backward_aligned_copy_loop(from, to, count, bytes_per_count);</span>
2069     }
2070     assert(small_copy_limit &gt;= count_required_to_align + min_copy, &quot;first loop might exhaust count&quot;);
2071 
2072     if (status) {
2073       __ mov(R0, 0); // OK
2074     }
2075 
2076     __ ret();
2077 
2078     {
<span class="line-modified">2079       copy_small_array(from, to, count, tmp1, tmp2, bytes_per_count, forward, L_small_array /* entry */);</span>
2080 
2081       if (status) {
2082         __ mov(R0, 0); // OK
2083       }
2084 
2085       __ ret();
2086     }
2087 
2088     if (! to_is_aligned) {
2089       __ BIND(L_unaligned_dst);
<span class="line-modified">2090       int min_copy_shifted = align_dst_and_generate_shifted_copy_loop(from, to, count, bytes_per_count, forward);</span>
2091       assert (small_copy_limit &gt;= count_required_to_align + min_copy_shifted, &quot;first loop might exhaust count&quot;);
2092 
2093       if (status) {
2094         __ mov(R0, 0); // OK
2095       }
2096 
2097       __ ret();
2098     }
2099 
2100     return start;
2101   }
2102 
2103 
2104   // Generates pattern of code to be placed after raw data copying in generate_oop_copy
2105   // Includes return from arraycopy stub.
2106   //
2107   // Arguments:
2108   //     to:       destination pointer after copying.
2109   //               if &#39;forward&#39; then &#39;to&#39; == upper bound, else &#39;to&#39; == beginning of the modified region
2110   //     count:    total number of copied elements, 32-bit int
</pre>
<hr />
<pre>
2855     //        the conjoint stubs use them.
2856 
2857     bool status = false; // non failing C2 stubs need not return a status in R0
2858 
2859 #ifdef TEST_C2_GENERIC_ARRAYCOPY /* Internal development flag */
2860     // With this flag, the C2 stubs are tested by generating calls to
2861     // generic_arraycopy instead of Runtime1::arraycopy
2862 
2863     // Runtime1::arraycopy return a status in R0 (0 if OK, else ~copied)
2864     // and the result is tested to see whether the arraycopy stub should
2865     // be called.
2866 
2867     // When we test arraycopy this way, we must generate extra code in the
2868     // arraycopy methods callable from C2 generic_arraycopy to set the
2869     // status to 0 for those who always succeed (calling the slow path stub might
2870     // lead to errors since the copy has already been performed).
2871 
2872     status = true; // generate a status compatible with C1 calls
2873 #endif
2874 



2875     // these need always status in case they are called from generic_arraycopy
2876     StubRoutines::_jbyte_disjoint_arraycopy  = generate_primitive_copy(false, &quot;jbyte_disjoint_arraycopy&quot;,  true, 1, true);
2877     StubRoutines::_jshort_disjoint_arraycopy = generate_primitive_copy(false, &quot;jshort_disjoint_arraycopy&quot;, true, 2, true);
2878     StubRoutines::_jint_disjoint_arraycopy   = generate_primitive_copy(false, &quot;jint_disjoint_arraycopy&quot;,   true, 4, true);
2879     StubRoutines::_jlong_disjoint_arraycopy  = generate_primitive_copy(false, &quot;jlong_disjoint_arraycopy&quot;,  true, 8, true);
2880     StubRoutines::_oop_disjoint_arraycopy    = generate_oop_copy      (false, &quot;oop_disjoint_arraycopy&quot;,    true,    true);
2881 
2882     StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_primitive_copy(true, &quot;arrayof_jbyte_disjoint_arraycopy&quot;, status, 1, true);
2883     StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_primitive_copy(true, &quot;arrayof_jshort_disjoint_arraycopy&quot;,status, 2, true);
2884     StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_primitive_copy(true, &quot;arrayof_jint_disjoint_arraycopy&quot;,  status, 4, true);
2885     StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_primitive_copy(true, &quot;arrayof_jlong_disjoint_arraycopy&quot;, status, 8, true);
2886     StubRoutines::_arrayof_oop_disjoint_arraycopy    = generate_oop_copy      (true, &quot;arrayof_oop_disjoint_arraycopy&quot;,   status,    true);
2887 
2888     // these need always status in case they are called from generic_arraycopy
2889     StubRoutines::_jbyte_arraycopy  = generate_primitive_copy(false, &quot;jbyte_arraycopy&quot;,  true, 1, false, StubRoutines::_jbyte_disjoint_arraycopy);
2890     StubRoutines::_jshort_arraycopy = generate_primitive_copy(false, &quot;jshort_arraycopy&quot;, true, 2, false, StubRoutines::_jshort_disjoint_arraycopy);
2891     StubRoutines::_jint_arraycopy   = generate_primitive_copy(false, &quot;jint_arraycopy&quot;,   true, 4, false, StubRoutines::_jint_disjoint_arraycopy);
2892     StubRoutines::_jlong_arraycopy  = generate_primitive_copy(false, &quot;jlong_arraycopy&quot;,  true, 8, false, StubRoutines::_jlong_disjoint_arraycopy);
2893     StubRoutines::_oop_arraycopy    = generate_oop_copy      (false, &quot;oop_arraycopy&quot;,    true,    false, StubRoutines::_oop_disjoint_arraycopy);
2894 
</pre>
<hr />
<pre>
3037       aes_init();
3038       StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
3039       StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
3040       StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_encryptAESCrypt();
3041       StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt();
3042     }
3043 #endif // COMPILE_CRYPTO
3044   }
3045 
3046 
3047  public:
3048   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
3049     if (all) {
3050       generate_all();
3051     } else {
3052       generate_initial();
3053     }
3054   }
3055 }; // end class declaration
3056 

3057 void StubGenerator_generate(CodeBuffer* code, bool all) {



3058   StubGenerator g(code, all);
3059 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.hpp&quot;
  27 #include &quot;assembler_arm.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;
<span class="line-added">  31 #include &quot;memory/universe.hpp&quot;</span>
  32 #include &quot;nativeInst_arm.hpp&quot;
  33 #include &quot;oops/instanceOop.hpp&quot;
  34 #include &quot;oops/method.hpp&quot;
  35 #include &quot;oops/objArrayKlass.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;prims/methodHandles.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/handles.inline.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  42 #include &quot;runtime/stubRoutines.hpp&quot;
  43 #include &quot;utilities/align.hpp&quot;
<span class="line-added">  44 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  45 #ifdef COMPILER2
  46 #include &quot;opto/runtime.hpp&quot;
  47 #endif
  48 
  49 // Declaration and definition of StubGenerator (no .hpp file).
  50 // For a more detailed description of the stub routine structure
  51 // see the comment in stubRoutines.hpp
  52 
  53 #define __ _masm-&gt;
  54 
  55 #ifdef PRODUCT
  56 #define BLOCK_COMMENT(str) /* nothing */
  57 #else
  58 #define BLOCK_COMMENT(str) __ block_comment(str)
  59 #endif
  60 
  61 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  62 
  63 // -------------------------------------------------------------------------------------------------------------------------
  64 // Stub Code definitions
</pre>
<hr />
<pre>
 163 
 164 #ifdef PRODUCT
 165 #define inc_counter_np(a,b,c) ((void)0)
 166 #else
 167 #define inc_counter_np(counter, t1, t2) \
 168   BLOCK_COMMENT(&quot;inc_counter &quot; #counter); \
 169   __ inc_counter(&amp;counter, t1, t2);
 170 #endif
 171 
 172  private:
 173 
 174   address generate_call_stub(address&amp; return_address) {
 175     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;call_stub&quot;);
 176     address start = __ pc();
 177 
 178 
 179     assert(frame::entry_frame_call_wrapper_offset == 0, &quot;adjust this code&quot;);
 180 
 181     __ mov(Rtemp, SP);
 182     __ push(RegisterSet(FP) | RegisterSet(LR));
<span class="line-modified"> 183     __ fpush_hardfp(FloatRegisterSet(D8, 8));</span>


 184     __ stmdb(SP, RegisterSet(R0, R2) | RegisterSet(R4, R6) | RegisterSet(R8, R10) | altFP_7_11, writeback);
 185     __ mov(Rmethod, R3);
 186     __ ldmia(Rtemp, RegisterSet(R1, R3) | Rthread); // stacked arguments
 187 
 188     // XXX: TODO
 189     // Would be better with respect to native tools if the following
 190     // setting of FP was changed to conform to the native ABI, with FP
 191     // pointing to the saved FP slot (and the corresponding modifications
 192     // for entry_frame_call_wrapper_offset and frame::real_fp).
 193     __ mov(FP, SP);
 194 
 195     {
 196       Label no_parameters, pass_parameters;
 197       __ cmp(R3, 0);
 198       __ b(no_parameters, eq);
 199 
 200       __ bind(pass_parameters);
 201       __ ldr(Rtemp, Address(R2, wordSize, post_indexed)); // Rtemp OK, unused and scratchable
 202       __ subs(R3, R3, 1);
 203       __ push(Rtemp);
</pre>
<hr />
<pre>
 225     __ cmp(R3, T_FLOAT);
 226     __ b(l_float, eq);
 227 
 228     __ cmp(R3, T_LONG);
 229     __ str(R0, Address(R2));
 230     __ str(R1, Address(R2, wordSize), eq);
 231     __ b(cont);
 232 
 233 
 234     __ bind(l_double);
 235     __ fstd(D0, Address(R2));
 236     __ b(cont);
 237 
 238     __ bind(l_float);
 239     __ fsts(S0, Address(R2));
 240 
 241     __ bind(cont);
 242 #endif
 243 
 244     __ pop(RegisterSet(R4, R6) | RegisterSet(R8, R10) | altFP_7_11);
<span class="line-modified"> 245     __ fpop_hardfp(FloatRegisterSet(D8, 8));</span>


 246     __ pop(RegisterSet(FP) | RegisterSet(PC));
 247 
 248     return start;
 249   }
 250 
 251 
 252   // (in) Rexception_obj: exception oop
 253   address generate_catch_exception() {
 254     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;catch_exception&quot;);
 255     address start = __ pc();
 256 
 257     __ str(Rexception_obj, Address(Rthread, Thread::pending_exception_offset()));
 258     __ b(StubRoutines::_call_stub_return_address);
 259 
 260     return start;
 261   }
 262 
 263 
 264   // (in) Rexception_pc: return address
 265   address generate_forward_exception() {
</pre>
<hr />
<pre>
 417 
 418 
 419  // As per atomic.hpp the Atomic read-modify-write operations must be logically implemented as:
 420  //  &lt;fence&gt;; &lt;op&gt;; &lt;membar StoreLoad|StoreStore&gt;
 421  // But for load-linked/store-conditional based systems a fence here simply means
 422  // no load/store can be reordered with respect to the initial load-linked, so we have:
 423  // &lt;membar storeload|loadload&gt; ; load-linked; &lt;op&gt;; store-conditional; &lt;membar storeload|storestore&gt;
 424  // There are no memory actions in &lt;op&gt; so nothing further is needed.
 425  //
 426  // So we define the following for convenience:
 427 #define MEMBAR_ATOMIC_OP_PRE \
 428     MacroAssembler::Membar_mask_bits(MacroAssembler::StoreLoad|MacroAssembler::LoadLoad)
 429 #define MEMBAR_ATOMIC_OP_POST \
 430     MacroAssembler::Membar_mask_bits(MacroAssembler::StoreLoad|MacroAssembler::StoreStore)
 431 
 432   // Note: JDK 9 only supports ARMv7+ so we always have ldrexd available even though the
 433   // code below allows for it to be otherwise. The else clause indicates an ARMv5 system
 434   // for which we do not support MP and so membars are not necessary. This ARMv5 code will
 435   // be removed in the future.
 436 
<span class="line-modified"> 437   // Implementation of atomic_add(jint add_value, volatile jint* dest)</span>
<span class="line-added"> 438   // used by Atomic::add(volatile jint* dest, jint add_value)</span>
 439   //
 440   // Arguments :
 441   //
 442   //      add_value:      R0
 443   //      dest:           R1
 444   //
 445   // Results:
 446   //
 447   //     R0: the new stored in dest
 448   //
 449   // Overwrites:
 450   //
 451   //     R1, R2, R3
 452   //
 453   address generate_atomic_add() {
 454     address start;
 455 
 456     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_add&quot;);
 457     Label retry;
 458     start = __ pc();
</pre>
<hr />
<pre>
 468       __ ldrex(newval, Address(dest));
 469       __ add(newval, addval, newval);
 470       __ strex(ok, newval, Address(dest));
 471       __ cmp(ok, 0);
 472       __ b(retry, ne);
 473       __ mov (R0, newval);
 474       __ membar(MEMBAR_ATOMIC_OP_POST, prev);
 475     } else {
 476       __ bind(retry);
 477       __ ldr (prev, Address(dest));
 478       __ add(newval, addval, prev);
 479       __ atomic_cas_bool(prev, newval, dest, 0, noreg/*ignored*/);
 480       __ b(retry, ne);
 481       __ mov (R0, newval);
 482     }
 483     __ bx(LR);
 484 
 485     return start;
 486   }
 487 
<span class="line-modified"> 488   // Implementation of jint atomic_xchg(jint exchange_value, volatile jint* dest)</span>
<span class="line-added"> 489   // used by Atomic::add(volatile jint* dest, jint exchange_value)</span>
 490   //
 491   // Arguments :
 492   //
 493   //      exchange_value: R0
 494   //      dest:           R1
 495   //
 496   // Results:
 497   //
 498   //     R0: the value previously stored in dest
 499   //
 500   // Overwrites:
 501   //
 502   //     R1, R2, R3
 503   //
 504   address generate_atomic_xchg() {
 505     address start;
 506 
 507     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_xchg&quot;);
 508     start = __ pc();
 509     Register newval    = R0;
</pre>
<hr />
<pre>
 517       __ membar(MEMBAR_ATOMIC_OP_PRE, prev);
 518       __ bind(retry);
 519       __ ldrex(prev, Address(dest));
 520       __ strex(ok, newval, Address(dest));
 521       __ cmp(ok, 0);
 522       __ b(retry, ne);
 523       __ mov (R0, prev);
 524       __ membar(MEMBAR_ATOMIC_OP_POST, prev);
 525     } else {
 526       __ bind(retry);
 527       __ ldr (prev, Address(dest));
 528       __ atomic_cas_bool(prev, newval, dest, 0, noreg/*ignored*/);
 529       __ b(retry, ne);
 530       __ mov (R0, prev);
 531     }
 532     __ bx(LR);
 533 
 534     return start;
 535   }
 536 
<span class="line-modified"> 537   // Implementation of jint atomic_cmpxchg(jint exchange_value, volatile jint *dest, jint compare_value)</span>
<span class="line-added"> 538   // used by Atomic::cmpxchg(volatile jint *dest, jint compare_value, jint exchange_value)</span>
 539   //
 540   // Arguments :
 541   //
 542   //      compare_value:  R0
 543   //      exchange_value: R1
 544   //      dest:           R2
 545   //
 546   // Results:
 547   //
 548   //     R0: the value previously stored in dest
 549   //
 550   // Overwrites:
 551   //
 552   //     R0, R1, R2, R3, Rtemp
 553   //
 554   address generate_atomic_cmpxchg() {
 555     address start;
 556 
 557     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_cmpxchg&quot;);
 558     start = __ pc();
</pre>
<hr />
<pre>
 911   // Generate the inner loop for forward aligned array copy
 912   //
 913   // Arguments
 914   //      from:      src address, 64 bits  aligned
 915   //      to:        dst address, wordSize aligned
 916   //      count:     number of elements (32-bit int)
 917   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
 918   //
 919   // Return the minimum initial value for count
 920   //
 921   // Notes:
 922   // - &#39;from&#39; aligned on 64-bit (recommended for 32-bit ARM in case this speeds up LDMIA)
 923   // - &#39;to&#39; aligned on wordSize
 924   // - &#39;count&#39; must be greater or equal than the returned value
 925   //
 926   // Increases &#39;from&#39; and &#39;to&#39; by count*bytes_per_count.
 927   //
 928   // Scratches &#39;count&#39;, R3.
 929   // R4-R10 are preserved (saved/restored).
 930   //
<span class="line-modified"> 931   int generate_forward_aligned_copy_loop(Register from, Register to, Register count, int bytes_per_count, bool unsafe_copy = false) {</span>
 932     assert (from == R0 &amp;&amp; to == R1 &amp;&amp; count == R2, &quot;adjust the implementation below&quot;);
 933 
 934     const int bytes_per_loop = 8*wordSize; // 8 registers are read and written on every loop iteration
 935     arraycopy_loop_config *config=&amp;arraycopy_configurations[ArmCopyPlatform].forward_aligned;
 936     int pld_offset = config-&gt;pld_distance;
 937     const int count_per_loop = bytes_per_loop / bytes_per_count;
 938 
 939     bool split_read= config-&gt;split_ldm;
 940     bool split_write= config-&gt;split_stm;
 941 
 942     // XXX optim: use VLDM/VSTM when available (Neon) with PLD
 943     //  NEONCopyPLD
 944     //      PLD [r1, #0xC0]
 945     //      VLDM r1!,{d0-d7}
 946     //      VSTM r0!,{d0-d7}
 947     //      SUBS r2,r2,#0x40
 948     //      BGE NEONCopyPLD
 949 
 950     __ push(RegisterSet(R4,R10));
 951 
 952     const bool prefetch_before = pld_offset &lt; 0;
 953     const bool prefetch_after = pld_offset &gt; 0;
 954 
 955     Label L_skip_pld;
 956 
<span class="line-modified"> 957     {</span>
<span class="line-modified"> 958       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="line-added"> 959       UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);</span>
<span class="line-added"> 960       // predecrease to exit when there is less than count_per_loop</span>
<span class="line-added"> 961       __ sub_32(count, count, count_per_loop);</span>
 962 
<span class="line-modified"> 963       if (pld_offset != 0) {</span>
<span class="line-modified"> 964         pld_offset = (pld_offset &lt; 0) ? -pld_offset : pld_offset;</span>
 965 
<span class="line-modified"> 966         prefetch(from, to, 0);</span>
 967 
<span class="line-modified"> 968         if (prefetch_before) {</span>
<span class="line-modified"> 969           // If prefetch is done ahead, final PLDs that overflow the</span>
<span class="line-modified"> 970           // copied area can be easily avoided. &#39;count&#39; is predecreased</span>
<span class="line-modified"> 971           // by the prefetch distance to optimize the inner loop and the</span>
<span class="line-modified"> 972           // outer loop skips the PLD.</span>
<span class="line-modified"> 973           __ subs_32(count, count, (bytes_per_loop+pld_offset)/bytes_per_count);</span>
 974 
<span class="line-modified"> 975           // skip prefetch for small copies</span>
<span class="line-modified"> 976           __ b(L_skip_pld, lt);</span>
<span class="line-modified"> 977         }</span>
 978 
<span class="line-modified"> 979         int offset = ArmCopyCacheLineSize;</span>
<span class="line-modified"> 980         while (offset &lt;= pld_offset) {</span>
<span class="line-modified"> 981           prefetch(from, to, offset);</span>
<span class="line-modified"> 982           offset += ArmCopyCacheLineSize;</span>
<span class="line-modified"> 983         };</span>
<span class="line-modified"> 984       }</span>
 985 
<span class="line-modified"> 986       {</span>
<span class="line-modified"> 987         // 32-bit ARM note: we have tried implementing loop unrolling to skip one</span>
<span class="line-modified"> 988         // PLD with 64 bytes cache line but the gain was not significant.</span>
 989 
<span class="line-modified"> 990         Label L_copy_loop;</span>
<span class="line-modified"> 991         __ align(OptoLoopAlignment);</span>
<span class="line-modified"> 992         __ BIND(L_copy_loop);</span>
 993 
<span class="line-modified"> 994         if (prefetch_before) {</span>
<span class="line-modified"> 995           prefetch(from, to, bytes_per_loop + pld_offset);</span>
<span class="line-modified"> 996           __ BIND(L_skip_pld);</span>
<span class="line-modified"> 997         }</span>
 998 
<span class="line-modified"> 999         if (split_read) {</span>
<span class="line-modified">1000           // Split the register set in two sets so that there is less</span>
<span class="line-modified">1001           // latency between LDM and STM (R3-R6 available while R7-R10</span>
<span class="line-modified">1002           // still loading) and less register locking issue when iterating</span>
<span class="line-modified">1003           // on the first LDM.</span>
<span class="line-modified">1004           __ ldmia(from, RegisterSet(R3, R6), writeback);</span>
<span class="line-modified">1005           __ ldmia(from, RegisterSet(R7, R10), writeback);</span>
<span class="line-modified">1006         } else {</span>
<span class="line-modified">1007           __ ldmia(from, RegisterSet(R3, R10), writeback);</span>
<span class="line-modified">1008         }</span>
1009 
<span class="line-modified">1010         __ subs_32(count, count, count_per_loop);</span>
1011 
<span class="line-modified">1012         if (prefetch_after) {</span>
<span class="line-modified">1013           prefetch(from, to, pld_offset, bytes_per_loop);</span>
<span class="line-modified">1014         }</span>
1015 
<span class="line-modified">1016         if (split_write) {</span>
<span class="line-modified">1017           __ stmia(to, RegisterSet(R3, R6), writeback);</span>
<span class="line-modified">1018           __ stmia(to, RegisterSet(R7, R10), writeback);</span>
<span class="line-modified">1019         } else {</span>
<span class="line-modified">1020           __ stmia(to, RegisterSet(R3, R10), writeback);</span>
<span class="line-modified">1021         }</span>
1022 
<span class="line-modified">1023         __ b(L_copy_loop, ge);</span>
1024 
<span class="line-modified">1025         if (prefetch_before) {</span>
<span class="line-modified">1026           // the inner loop may end earlier, allowing to skip PLD for the last iterations</span>
<span class="line-modified">1027           __ cmn_32(count, (bytes_per_loop + pld_offset)/bytes_per_count);</span>
<span class="line-modified">1028           __ b(L_skip_pld, ge);</span>
<span class="line-added">1029         }</span>
1030       }
<span class="line-modified">1031       BLOCK_COMMENT(&quot;Remaining bytes:&quot;);</span>
<span class="line-modified">1032       // still 0..bytes_per_loop-1 aligned bytes to copy, count already decreased by (at least) bytes_per_loop bytes</span>

1033 
<span class="line-modified">1034       // __ add(count, count, ...); // addition useless for the bit tests</span>
<span class="line-modified">1035       assert (pld_offset % bytes_per_loop == 0, &quot;decreasing count by pld_offset before loop must not change tested bits&quot;);</span>
1036 
<span class="line-modified">1037       __ tst(count, 16 / bytes_per_count);</span>
<span class="line-modified">1038       __ ldmia(from, RegisterSet(R3, R6), writeback, ne); // copy 16 bytes</span>
<span class="line-modified">1039       __ stmia(to, RegisterSet(R3, R6), writeback, ne);</span>
1040 
<span class="line-modified">1041       __ tst(count, 8 / bytes_per_count);</span>
<span class="line-modified">1042       __ ldmia(from, RegisterSet(R3, R4), writeback, ne); // copy 8 bytes</span>
<span class="line-modified">1043       __ stmia(to, RegisterSet(R3, R4), writeback, ne);</span>
1044 
<span class="line-modified">1045       if (bytes_per_count &lt;= 4) {</span>
<span class="line-modified">1046         __ tst(count, 4 / bytes_per_count);</span>
<span class="line-modified">1047         __ ldr(R3, Address(from, 4, post_indexed), ne); // copy 4 bytes</span>
<span class="line-modified">1048         __ str(R3, Address(to, 4, post_indexed), ne);</span>
<span class="line-modified">1049       }</span>
1050 
<span class="line-modified">1051       if (bytes_per_count &lt;= 2) {</span>
<span class="line-modified">1052         __ tst(count, 2 / bytes_per_count);</span>
<span class="line-modified">1053         __ ldrh(R3, Address(from, 2, post_indexed), ne); // copy 2 bytes</span>
<span class="line-modified">1054         __ strh(R3, Address(to, 2, post_indexed), ne);</span>
<span class="line-modified">1055       }</span>
1056 
<span class="line-modified">1057       if (bytes_per_count == 1) {</span>
<span class="line-modified">1058         __ tst(count, 1);</span>
<span class="line-modified">1059         __ ldrb(R3, Address(from, 1, post_indexed), ne);</span>
<span class="line-modified">1060         __ strb(R3, Address(to, 1, post_indexed), ne);</span>
<span class="line-added">1061       }</span>
1062     }
1063 
1064     __ pop(RegisterSet(R4,R10));
1065 
1066     return count_per_loop;
1067   }
1068 
1069 
1070   // Generate the inner loop for backward aligned array copy
1071   //
1072   // Arguments
1073   //      end_from:      src end address, 64 bits  aligned
1074   //      end_to:        dst end address, wordSize aligned
1075   //      count:         number of elements (32-bit int)
1076   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
1077   //
1078   // Return the minimum initial value for count
1079   //
1080   // Notes:
1081   // - &#39;end_from&#39; aligned on 64-bit (recommended for 32-bit ARM in case this speeds up LDMIA)
1082   // - &#39;end_to&#39; aligned on wordSize
1083   // - &#39;count&#39; must be greater or equal than the returned value
1084   //
1085   // Decreases &#39;end_from&#39; and &#39;end_to&#39; by count*bytes_per_count.
1086   //
1087   // Scratches &#39;count&#39;, R3.
1088   // ARM R4-R10 are preserved (saved/restored).
1089   //
<span class="line-modified">1090   int generate_backward_aligned_copy_loop(Register end_from, Register end_to, Register count, int bytes_per_count, bool unsafe_copy = false) {</span>
1091     assert (end_from == R0 &amp;&amp; end_to == R1 &amp;&amp; count == R2, &quot;adjust the implementation below&quot;);
1092 
1093     const int bytes_per_loop = 8*wordSize; // 8 registers are read and written on every loop iteration
1094     const int count_per_loop = bytes_per_loop / bytes_per_count;
1095 
1096     arraycopy_loop_config *config=&amp;arraycopy_configurations[ArmCopyPlatform].backward_aligned;
1097     int pld_offset = config-&gt;pld_distance;
1098 
1099     bool split_read= config-&gt;split_ldm;
1100     bool split_write= config-&gt;split_stm;
1101 
1102     // See the forward copy variant for additional comments.
1103 
1104     __ push(RegisterSet(R4,R10));
1105 
<span class="line-modified">1106     {</span>
<span class="line-added">1107       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="line-added">1108       UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);</span>
<span class="line-added">1109       __ sub_32(count, count, count_per_loop);</span>
1110 
<span class="line-modified">1111       const bool prefetch_before = pld_offset &lt; 0;</span>
<span class="line-modified">1112       const bool prefetch_after = pld_offset &gt; 0;</span>
1113 
<span class="line-modified">1114       Label L_skip_pld;</span>
1115 
<span class="line-modified">1116       if (pld_offset != 0) {</span>
<span class="line-modified">1117         pld_offset = (pld_offset &lt; 0) ? -pld_offset : pld_offset;</span>
1118 
<span class="line-modified">1119         prefetch(end_from, end_to, -wordSize);</span>
1120 
<span class="line-modified">1121         if (prefetch_before) {</span>
<span class="line-modified">1122           __ subs_32(count, count, (bytes_per_loop + pld_offset) / bytes_per_count);</span>
<span class="line-modified">1123           __ b(L_skip_pld, lt);</span>
<span class="line-modified">1124         }</span>
1125 
<span class="line-modified">1126         int offset = ArmCopyCacheLineSize;</span>
<span class="line-modified">1127         while (offset &lt;= pld_offset) {</span>
<span class="line-modified">1128           prefetch(end_from, end_to, -(wordSize + offset));</span>
<span class="line-modified">1129           offset += ArmCopyCacheLineSize;</span>
<span class="line-modified">1130         };</span>
<span class="line-modified">1131       }</span>
1132 
<span class="line-modified">1133       {</span>
<span class="line-modified">1134         // 32-bit ARM note: we have tried implementing loop unrolling to skip one</span>
<span class="line-modified">1135         // PLD with 64 bytes cache line but the gain was not significant.</span>
1136 
<span class="line-modified">1137         Label L_copy_loop;</span>
<span class="line-modified">1138         __ align(OptoLoopAlignment);</span>
<span class="line-modified">1139         __ BIND(L_copy_loop);</span>
1140 
<span class="line-modified">1141         if (prefetch_before) {</span>
<span class="line-modified">1142           prefetch(end_from, end_to, -(wordSize + bytes_per_loop + pld_offset));</span>
<span class="line-modified">1143           __ BIND(L_skip_pld);</span>
<span class="line-modified">1144         }</span>
1145 
<span class="line-modified">1146         if (split_read) {</span>
<span class="line-modified">1147           __ ldmdb(end_from, RegisterSet(R7, R10), writeback);</span>
<span class="line-modified">1148           __ ldmdb(end_from, RegisterSet(R3, R6), writeback);</span>
<span class="line-modified">1149         } else {</span>
<span class="line-modified">1150           __ ldmdb(end_from, RegisterSet(R3, R10), writeback);</span>
<span class="line-modified">1151         }</span>
1152 
<span class="line-modified">1153         __ subs_32(count, count, count_per_loop);</span>
1154 
<span class="line-modified">1155         if (prefetch_after) {</span>
<span class="line-modified">1156           prefetch(end_from, end_to, -(wordSize + pld_offset), -bytes_per_loop);</span>
<span class="line-modified">1157         }</span>
1158 
<span class="line-modified">1159         if (split_write) {</span>
<span class="line-modified">1160           __ stmdb(end_to, RegisterSet(R7, R10), writeback);</span>
<span class="line-modified">1161           __ stmdb(end_to, RegisterSet(R3, R6), writeback);</span>
<span class="line-modified">1162         } else {</span>
<span class="line-modified">1163           __ stmdb(end_to, RegisterSet(R3, R10), writeback);</span>
<span class="line-modified">1164         }</span>
1165 
<span class="line-modified">1166         __ b(L_copy_loop, ge);</span>
1167 
<span class="line-modified">1168         if (prefetch_before) {</span>
<span class="line-modified">1169           __ cmn_32(count, (bytes_per_loop + pld_offset)/bytes_per_count);</span>
<span class="line-modified">1170           __ b(L_skip_pld, ge);</span>
<span class="line-added">1171         }</span>
1172       }
<span class="line-modified">1173       BLOCK_COMMENT(&quot;Remaining bytes:&quot;);</span>
<span class="line-modified">1174       // still 0..bytes_per_loop-1 aligned bytes to copy, count already decreased by (at least) bytes_per_loop bytes</span>

1175 
<span class="line-modified">1176       // __ add(count, count, ...); // addition useless for the bit tests</span>
<span class="line-modified">1177       assert (pld_offset % bytes_per_loop == 0, &quot;decreasing count by pld_offset before loop must not change tested bits&quot;);</span>
1178 
<span class="line-modified">1179       __ tst(count, 16 / bytes_per_count);</span>
<span class="line-modified">1180       __ ldmdb(end_from, RegisterSet(R3, R6), writeback, ne); // copy 16 bytes</span>
<span class="line-modified">1181       __ stmdb(end_to, RegisterSet(R3, R6), writeback, ne);</span>
1182 
<span class="line-modified">1183       __ tst(count, 8 / bytes_per_count);</span>
<span class="line-modified">1184       __ ldmdb(end_from, RegisterSet(R3, R4), writeback, ne); // copy 8 bytes</span>
<span class="line-modified">1185       __ stmdb(end_to, RegisterSet(R3, R4), writeback, ne);</span>
1186 
<span class="line-modified">1187       if (bytes_per_count &lt;= 4) {</span>
<span class="line-modified">1188         __ tst(count, 4 / bytes_per_count);</span>
<span class="line-modified">1189         __ ldr(R3, Address(end_from, -4, pre_indexed), ne); // copy 4 bytes</span>
<span class="line-modified">1190         __ str(R3, Address(end_to, -4, pre_indexed), ne);</span>
<span class="line-modified">1191       }</span>
1192 
<span class="line-modified">1193       if (bytes_per_count &lt;= 2) {</span>
<span class="line-modified">1194         __ tst(count, 2 / bytes_per_count);</span>
<span class="line-modified">1195         __ ldrh(R3, Address(end_from, -2, pre_indexed), ne); // copy 2 bytes</span>
<span class="line-modified">1196         __ strh(R3, Address(end_to, -2, pre_indexed), ne);</span>
<span class="line-modified">1197       }</span>
1198 
<span class="line-modified">1199       if (bytes_per_count == 1) {</span>
<span class="line-modified">1200         __ tst(count, 1);</span>
<span class="line-modified">1201         __ ldrb(R3, Address(end_from, -1, pre_indexed), ne);</span>
<span class="line-modified">1202         __ strb(R3, Address(end_to, -1, pre_indexed), ne);</span>
<span class="line-added">1203       }</span>
1204     }

1205     __ pop(RegisterSet(R4,R10));
1206 
1207     return count_per_loop;
1208   }
1209 
1210 
1211   // Generate the inner loop for shifted forward array copy (unaligned copy).
1212   // It can be used when bytes_per_count &lt; wordSize, i.e. byte/short copy
1213   //
1214   // Arguments
1215   //      from:      start src address, 64 bits aligned
1216   //      to:        start dst address, (now) wordSize aligned
1217   //      count:     number of elements (32-bit int)
1218   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
1219   //      lsr_shift: shift applied to &#39;old&#39; value to skipped already written bytes
1220   //      lsl_shift: shift applied to &#39;new&#39; value to set the high bytes of the next write
1221   //
1222   // Return the minimum initial value for count
1223   //
1224   // Notes:
</pre>
<hr />
<pre>
1739       store_one(tmp, to, bytes_per_count, forward, ne);
1740       if (bytes_per_count &lt; 4) {
1741         __ b(L_align_src, ne); // if bytes_per_count == 4, then 0 or 1 loop iterations are enough
1742       }
1743     }
1744     return 7/bytes_per_count;
1745   }
1746 
1747   // Copies &#39;count&#39; of &#39;bytes_per_count&#39;-sized elements in the specified direction.
1748   //
1749   // Arguments:
1750   //     from:              beginning (if forward) or upper bound (if !forward) of the region to be read
1751   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1752   //     count:             32-bit int, number of elements to be copied
1753   //     entry:             copy loop entry point
1754   //     bytes_per_count:   size of an element
1755   //     forward:           specifies copy direction
1756   //
1757   // Notes:
1758   //     shifts &#39;from&#39; and &#39;to&#39;
<span class="line-modified">1759   void copy_small_array(Register from, Register to, Register count, Register tmp, Register tmp2, int bytes_per_count, bool forward, Label &amp; entry, bool unsafe_copy = false) {</span>
1760     assert_different_registers(from, to, count, tmp);
1761 
<span class="line-modified">1762     {</span>
<span class="line-modified">1763       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="line-modified">1764       UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);</span>
<span class="line-modified">1765       __ align(OptoLoopAlignment);</span>
<span class="line-modified">1766       Label L_small_loop;</span>
<span class="line-modified">1767       __ BIND(L_small_loop);</span>
<span class="line-modified">1768       store_one(tmp, to, bytes_per_count, forward, al, tmp2);</span>
<span class="line-modified">1769       __ BIND(entry); // entry point</span>
<span class="line-added">1770       __ subs(count, count, 1);</span>
<span class="line-added">1771       load_one(tmp, from, bytes_per_count, forward, ge, tmp2);</span>
<span class="line-added">1772       __ b(L_small_loop, ge);</span>
<span class="line-added">1773     }</span>
1774   }
1775 
1776   // Aligns &#39;to&#39; by reading one word from &#39;from&#39; and writting its part to &#39;to&#39;.
1777   //
1778   // Arguments:
1779   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1780   //     count:             32-bit int, number of elements allowed to be copied
1781   //     to_remainder:      remainder of dividing &#39;to&#39; by wordSize
1782   //     bytes_per_count:   size of an element
1783   //     forward:           specifies copy direction
1784   //     Rval:              contains an already read but not yet written word;
1785   //                        its&#39; LSBs (if forward) or MSBs (if !forward) are to be written to align &#39;to&#39;.
1786   //
1787   // Notes:
1788   //     &#39;count&#39; must not be less then the returned value
1789   //     &#39;to&#39; must be aligned by bytes_per_count but must not be aligned by wordSize
1790   //     shifts &#39;to&#39; by the number of written bytes (so that it becomes the bound of memory to be written)
1791   //     decreases &#39;count&#39; by the the number of elements written
1792   //     Rval&#39;s MSBs or LSBs remain to be written further by generate_{forward,backward}_shifted_copy_loop
1793   int align_dst(Register to, Register count, Register Rval, Register tmp,
</pre>
<hr />
<pre>
1870     return min_copy + required_to_align;
1871   }
1872 
1873   // Copies &#39;count&#39; of elements using shifted copy loop
1874   //
1875   // Arguments:
1876   //     from:              beginning (if forward) or upper bound (if !forward) of the region to be read
1877   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1878   //     count:             32-bit int, number of elements to be copied
1879   //     bytes_per_count:   size of an element
1880   //     forward:           specifies copy direction
1881   //
1882   // Notes:
1883   //     &#39;count&#39; must not be less then the returned value
1884   //     &#39;from&#39; must be aligned by wordSize
1885   //     &#39;to&#39; must be aligned by bytes_per_count but must not be aligned by wordSize
1886   //     shifts &#39;to&#39; by the number of copied bytes
1887   //
1888   // Scratches &#39;from&#39;, &#39;count&#39;, R3 and R12.
1889   // R4-R10 saved for use.
<span class="line-modified">1890   int align_dst_and_generate_shifted_copy_loop(Register from, Register to, Register count, int bytes_per_count, bool forward, bool unsafe_copy = false) {</span>
1891 
1892     const Register Rval = forward ? R12 : R3; // as generate_{forward,backward}_shifted_copy_loop expect
1893 
1894     int min_copy = 0;
1895 
1896     // Note: if {seq} is a sequence of numbers, L{seq} means that if the execution reaches this point,
1897     // then the remainder of &#39;to&#39; divided by wordSize is one of elements of {seq}.
1898 
1899     __ push(RegisterSet(R4,R10));

1900 
<span class="line-modified">1901     {</span>
<span class="line-modified">1902       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="line-modified">1903       UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);</span>
<span class="line-modified">1904       load_one(Rval, from, wordSize, forward);</span>
<span class="line-modified">1905 </span>
<span class="line-modified">1906       switch (bytes_per_count) {</span>
<span class="line-modified">1907         case 2:</span>
<span class="line-modified">1908           min_copy = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 2, bytes_per_count, forward);</span>
<span class="line-modified">1909           break;</span>
<span class="line-modified">1910         case 1:</span>
<span class="line-modified">1911         {</span>
<span class="line-modified">1912           Label L1, L2, L3;</span>
<span class="line-modified">1913           int min_copy1, min_copy2, min_copy3;</span>
<span class="line-modified">1914 </span>
<span class="line-added">1915           Label L_loop_finished;</span>
<span class="line-added">1916 </span>
<span class="line-added">1917           if (forward) {</span>
<span class="line-added">1918               __ tbz(to, 0, L2);</span>
<span class="line-added">1919               __ tbz(to, 1, L1);</span>
<span class="line-added">1920 </span>
<span class="line-added">1921               __ BIND(L3);</span>
<span class="line-added">1922               min_copy3 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 3, bytes_per_count, forward);</span>
<span class="line-added">1923               __ b(L_loop_finished);</span>
<span class="line-added">1924 </span>
<span class="line-added">1925               __ BIND(L1);</span>
<span class="line-added">1926               min_copy1 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 1, bytes_per_count, forward);</span>
<span class="line-added">1927               __ b(L_loop_finished);</span>
<span class="line-added">1928 </span>
<span class="line-added">1929               __ BIND(L2);</span>
<span class="line-added">1930               min_copy2 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 2, bytes_per_count, forward);</span>
<span class="line-added">1931           } else {</span>
<span class="line-added">1932               __ tbz(to, 0, L2);</span>
<span class="line-added">1933               __ tbnz(to, 1, L3);</span>
1934 
<span class="line-modified">1935               __ BIND(L1);</span>
<span class="line-modified">1936               min_copy1 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 1, bytes_per_count, forward);</span>
<span class="line-modified">1937               __ b(L_loop_finished);</span>
1938 
<span class="line-modified">1939                __ BIND(L3);</span>
<span class="line-modified">1940               min_copy3 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 3, bytes_per_count, forward);</span>
<span class="line-modified">1941               __ b(L_loop_finished);</span>
1942 
<span class="line-modified">1943              __ BIND(L2);</span>
<span class="line-modified">1944               min_copy2 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 2, bytes_per_count, forward);</span>
<span class="line-modified">1945           }</span>


1946 
<span class="line-modified">1947           min_copy = MAX2(MAX2(min_copy1, min_copy2), min_copy3);</span>


1948 
<span class="line-modified">1949           __ BIND(L_loop_finished);</span>


1950 
<span class="line-modified">1951           break;</span>

1952         }
<span class="line-modified">1953         default:</span>
<span class="line-modified">1954           ShouldNotReachHere();</span>
<span class="line-modified">1955           break;</span>



1956       }



1957     }

1958     __ pop(RegisterSet(R4,R10));
1959 
1960     return min_copy;
1961   }
1962 
1963 #ifndef PRODUCT
1964   int * get_arraycopy_counter(int bytes_per_count) {
1965     switch (bytes_per_count) {
1966       case 1:
1967         return &amp;SharedRuntime::_jbyte_array_copy_ctr;
1968       case 2:
1969         return &amp;SharedRuntime::_jshort_array_copy_ctr;
1970       case 4:
1971         return &amp;SharedRuntime::_jint_array_copy_ctr;
1972       case 8:
1973         return &amp;SharedRuntime::_jlong_array_copy_ctr;
1974       default:
1975         ShouldNotReachHere();
1976         return NULL;
1977     }
1978   }
1979 #endif // !PRODUCT
1980 
<span class="line-added">1981   address generate_unsafecopy_common_error_exit() {</span>
<span class="line-added">1982     address start_pc = __ pc();</span>
<span class="line-added">1983       __ mov(R0, 0);</span>
<span class="line-added">1984       __ ret();</span>
<span class="line-added">1985     return start_pc;</span>
<span class="line-added">1986   }</span>
<span class="line-added">1987 </span>
1988   //
1989   //  Generate stub for primitive array copy.  If &quot;aligned&quot; is true, the
1990   //  &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1991   //
1992   //  If &quot;disjoint&quot; is true, arrays are assumed to be disjoint, otherwise they may overlap and
1993   //  &quot;nooverlap_target&quot; must be specified as the address to jump if they don&#39;t.
1994   //
1995   // Arguments for generated stub:
1996   //      from:  R0
1997   //      to:    R1
1998   //      count: R2 treated as signed 32-bit int
1999   //
2000   address generate_primitive_copy(bool aligned, const char * name, bool status, int bytes_per_count, bool disjoint, address nooverlap_target = NULL) {
2001     __ align(CodeEntryAlignment);
2002     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2003     address start = __ pc();
2004 
2005     const Register from  = R0;   // source array address
2006     const Register to    = R1;   // destination array address
2007     const Register count = R2;   // elements count
</pre>
<hr />
<pre>
2038     //  *) The small and simple one applicable for any array (but not efficient for large arrays).
2039     // Currently &quot;small&quot; implementation is used if and only if the &quot;large&quot; one could not be used.
2040     // XXX optim: tune the limit higher ?
2041     // Large implementation lower applicability bound is actually determined by
2042     // aligned copy loop which require &lt;=7 bytes for src alignment, and 8 words for aligned copy loop.
2043     const int small_copy_limit = (8*wordSize + 7) / bytes_per_count;
2044 
2045     Label L_small_array;
2046     __ cmp_32(count, small_copy_limit);
2047     __ b(L_small_array, le);
2048 
2049     // Otherwise proceed with large implementation.
2050 
2051     bool from_is_aligned = (bytes_per_count &gt;= 8);
2052     if (aligned &amp;&amp; forward &amp;&amp; (HeapWordSize % 8 == 0)) {
2053         // if &#39;from&#39; is heapword aligned and HeapWordSize is divisible by 8,
2054         //  then from is aligned by 8
2055         from_is_aligned = true;
2056     }
2057 
<span class="line-modified">2058     int count_required_to_align = 0;</span>
<span class="line-modified">2059     {</span>
<span class="line-added">2060       // UnsafeCopyMemoryMark page error: continue at UnsafeCopyMemory common_error_exit</span>
<span class="line-added">2061       UnsafeCopyMemoryMark ucmm(this, !aligned, false);</span>
<span class="line-added">2062       count_required_to_align = from_is_aligned ? 0 : align_src(from, to, count, tmp1, bytes_per_count, forward);</span>
<span class="line-added">2063       assert (small_copy_limit &gt;= count_required_to_align, &quot;alignment could exhaust count&quot;);</span>
<span class="line-added">2064     }</span>
2065 
2066     // now &#39;from&#39; is aligned
2067 
2068     bool to_is_aligned = false;
2069 
2070     if (bytes_per_count &gt;= wordSize) {
2071       // &#39;to&#39; is aligned by bytes_per_count, so it is aligned by wordSize
2072       to_is_aligned = true;
2073     } else {
2074       if (aligned &amp;&amp; (8 % HeapWordSize == 0) &amp;&amp; (HeapWordSize % wordSize == 0)) {
2075         // Originally &#39;from&#39; and &#39;to&#39; were heapword aligned;
2076         // (from - to) has not been changed, so since now &#39;from&#39; is 8-byte aligned, then it is also heapword aligned,
2077         //  so &#39;to&#39; is also heapword aligned and thus aligned by wordSize.
2078         to_is_aligned = true;
2079       }
2080     }
2081 
2082     Label L_unaligned_dst;
2083 
2084     if (!to_is_aligned) {
2085       BLOCK_COMMENT(&quot;Check dst alignment:&quot;);
2086       __ tst(to, wordSize - 1);
2087       __ b(L_unaligned_dst, ne); // &#39;to&#39; is not aligned
2088     }
2089 
2090     // &#39;from&#39; and &#39;to&#39; are properly aligned
2091 
2092     int min_copy;
2093     if (forward) {
<span class="line-modified">2094       min_copy = generate_forward_aligned_copy_loop(from, to, count, bytes_per_count, !aligned /*add UnsafeCopyMemory entry*/);</span>
2095     } else {
<span class="line-modified">2096       min_copy = generate_backward_aligned_copy_loop(from, to, count, bytes_per_count, !aligned /*add UnsafeCopyMemory entry*/);</span>
2097     }
2098     assert(small_copy_limit &gt;= count_required_to_align + min_copy, &quot;first loop might exhaust count&quot;);
2099 
2100     if (status) {
2101       __ mov(R0, 0); // OK
2102     }
2103 
2104     __ ret();
2105 
2106     {
<span class="line-modified">2107       copy_small_array(from, to, count, tmp1, tmp2, bytes_per_count, forward, L_small_array /* entry */, !aligned /*add UnsafeCopyMemory entry*/);</span>
2108 
2109       if (status) {
2110         __ mov(R0, 0); // OK
2111       }
2112 
2113       __ ret();
2114     }
2115 
2116     if (! to_is_aligned) {
2117       __ BIND(L_unaligned_dst);
<span class="line-modified">2118       int min_copy_shifted = align_dst_and_generate_shifted_copy_loop(from, to, count, bytes_per_count, forward, !aligned /*add UnsafeCopyMemory entry*/);</span>
2119       assert (small_copy_limit &gt;= count_required_to_align + min_copy_shifted, &quot;first loop might exhaust count&quot;);
2120 
2121       if (status) {
2122         __ mov(R0, 0); // OK
2123       }
2124 
2125       __ ret();
2126     }
2127 
2128     return start;
2129   }
2130 
2131 
2132   // Generates pattern of code to be placed after raw data copying in generate_oop_copy
2133   // Includes return from arraycopy stub.
2134   //
2135   // Arguments:
2136   //     to:       destination pointer after copying.
2137   //               if &#39;forward&#39; then &#39;to&#39; == upper bound, else &#39;to&#39; == beginning of the modified region
2138   //     count:    total number of copied elements, 32-bit int
</pre>
<hr />
<pre>
2883     //        the conjoint stubs use them.
2884 
2885     bool status = false; // non failing C2 stubs need not return a status in R0
2886 
2887 #ifdef TEST_C2_GENERIC_ARRAYCOPY /* Internal development flag */
2888     // With this flag, the C2 stubs are tested by generating calls to
2889     // generic_arraycopy instead of Runtime1::arraycopy
2890 
2891     // Runtime1::arraycopy return a status in R0 (0 if OK, else ~copied)
2892     // and the result is tested to see whether the arraycopy stub should
2893     // be called.
2894 
2895     // When we test arraycopy this way, we must generate extra code in the
2896     // arraycopy methods callable from C2 generic_arraycopy to set the
2897     // status to 0 for those who always succeed (calling the slow path stub might
2898     // lead to errors since the copy has already been performed).
2899 
2900     status = true; // generate a status compatible with C1 calls
2901 #endif
2902 
<span class="line-added">2903     address ucm_common_error_exit       =  generate_unsafecopy_common_error_exit();</span>
<span class="line-added">2904     UnsafeCopyMemory::set_common_exit_stub_pc(ucm_common_error_exit);</span>
<span class="line-added">2905 </span>
2906     // these need always status in case they are called from generic_arraycopy
2907     StubRoutines::_jbyte_disjoint_arraycopy  = generate_primitive_copy(false, &quot;jbyte_disjoint_arraycopy&quot;,  true, 1, true);
2908     StubRoutines::_jshort_disjoint_arraycopy = generate_primitive_copy(false, &quot;jshort_disjoint_arraycopy&quot;, true, 2, true);
2909     StubRoutines::_jint_disjoint_arraycopy   = generate_primitive_copy(false, &quot;jint_disjoint_arraycopy&quot;,   true, 4, true);
2910     StubRoutines::_jlong_disjoint_arraycopy  = generate_primitive_copy(false, &quot;jlong_disjoint_arraycopy&quot;,  true, 8, true);
2911     StubRoutines::_oop_disjoint_arraycopy    = generate_oop_copy      (false, &quot;oop_disjoint_arraycopy&quot;,    true,    true);
2912 
2913     StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_primitive_copy(true, &quot;arrayof_jbyte_disjoint_arraycopy&quot;, status, 1, true);
2914     StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_primitive_copy(true, &quot;arrayof_jshort_disjoint_arraycopy&quot;,status, 2, true);
2915     StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_primitive_copy(true, &quot;arrayof_jint_disjoint_arraycopy&quot;,  status, 4, true);
2916     StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_primitive_copy(true, &quot;arrayof_jlong_disjoint_arraycopy&quot;, status, 8, true);
2917     StubRoutines::_arrayof_oop_disjoint_arraycopy    = generate_oop_copy      (true, &quot;arrayof_oop_disjoint_arraycopy&quot;,   status,    true);
2918 
2919     // these need always status in case they are called from generic_arraycopy
2920     StubRoutines::_jbyte_arraycopy  = generate_primitive_copy(false, &quot;jbyte_arraycopy&quot;,  true, 1, false, StubRoutines::_jbyte_disjoint_arraycopy);
2921     StubRoutines::_jshort_arraycopy = generate_primitive_copy(false, &quot;jshort_arraycopy&quot;, true, 2, false, StubRoutines::_jshort_disjoint_arraycopy);
2922     StubRoutines::_jint_arraycopy   = generate_primitive_copy(false, &quot;jint_arraycopy&quot;,   true, 4, false, StubRoutines::_jint_disjoint_arraycopy);
2923     StubRoutines::_jlong_arraycopy  = generate_primitive_copy(false, &quot;jlong_arraycopy&quot;,  true, 8, false, StubRoutines::_jlong_disjoint_arraycopy);
2924     StubRoutines::_oop_arraycopy    = generate_oop_copy      (false, &quot;oop_arraycopy&quot;,    true,    false, StubRoutines::_oop_disjoint_arraycopy);
2925 
</pre>
<hr />
<pre>
3068       aes_init();
3069       StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
3070       StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
3071       StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_encryptAESCrypt();
3072       StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt();
3073     }
3074 #endif // COMPILE_CRYPTO
3075   }
3076 
3077 
3078  public:
3079   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
3080     if (all) {
3081       generate_all();
3082     } else {
3083       generate_initial();
3084     }
3085   }
3086 }; // end class declaration
3087 
<span class="line-added">3088 #define UCM_TABLE_MAX_ENTRIES 32</span>
3089 void StubGenerator_generate(CodeBuffer* code, bool all) {
<span class="line-added">3090   if (UnsafeCopyMemory::_table == NULL) {</span>
<span class="line-added">3091     UnsafeCopyMemory::create_table(UCM_TABLE_MAX_ENTRIES);</span>
<span class="line-added">3092   }</span>
3093   StubGenerator g(code, all);
3094 }
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubRoutinesCrypto_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/c1_LIRAssembler_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/c1_LIRAssembler_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.inline.hpp&quot;
  27 #include &quot;c1/c1_Compilation.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  30 #include &quot;c1/c1_Runtime1.hpp&quot;
  31 #include &quot;c1/c1_ValueStack.hpp&quot;
  32 #include &quot;ci/ciArrayKlass.hpp&quot;
  33 #include &quot;ci/ciInstance.hpp&quot;
<span class="line-removed">  34 #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="line-removed">  35 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;</span>
  36 #include &quot;gc/shared/collectedHeap.hpp&quot;

  37 #include &quot;nativeInst_arm.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;

  41 #include &quot;vmreg_arm.inline.hpp&quot;
  42 
  43 #define __ _masm-&gt;
  44 
  45 // Note: Rtemp usage is this file should not impact C2 and should be
  46 // correct as long as it is not implicitly used in lower layers (the
  47 // arm [macro]assembler) and used with care in the other C1 specific
  48 // files.
  49 
  50 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  51   ShouldNotCallThis(); // Not used on ARM
  52   return false;
  53 }
  54 
  55 
  56 LIR_Opr LIR_Assembler::receiverOpr() {
  57   // The first register in Java calling conventions
  58   return FrameMap::R0_oop_opr;
  59 }
  60 
</pre>
<hr />
<pre>
  70 
  71 void LIR_Assembler::store_parameter(jint c, int offset_from_sp_in_words) {
  72   assert(offset_from_sp_in_words &gt;= 0, &quot;invalid offset from sp&quot;);
  73   int offset_from_sp_in_bytes = offset_from_sp_in_words * BytesPerWord;
  74   assert(offset_from_sp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;not enough space&quot;);
  75   __ mov_slow(Rtemp, c);
  76   __ str(Rtemp, Address(SP, offset_from_sp_in_bytes));
  77 }
  78 
  79 void LIR_Assembler::store_parameter(Metadata* m, int offset_from_sp_in_words) {
  80   assert(offset_from_sp_in_words &gt;= 0, &quot;invalid offset from sp&quot;);
  81   int offset_from_sp_in_bytes = offset_from_sp_in_words * BytesPerWord;
  82   assert(offset_from_sp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;not enough space&quot;);
  83   __ mov_metadata(Rtemp, m);
  84   __ str(Rtemp, Address(SP, offset_from_sp_in_bytes));
  85 }
  86 
  87 //--------------fpu register translations-----------------------
  88 
  89 
<span class="line-removed">  90 void LIR_Assembler::set_24bit_FPU() {</span>
<span class="line-removed">  91   ShouldNotReachHere();</span>
<span class="line-removed">  92 }</span>
<span class="line-removed">  93 </span>
<span class="line-removed">  94 void LIR_Assembler::reset_FPU() {</span>
<span class="line-removed">  95   ShouldNotReachHere();</span>
<span class="line-removed">  96 }</span>
<span class="line-removed">  97 </span>
<span class="line-removed">  98 void LIR_Assembler::fpop() {</span>
<span class="line-removed">  99   Unimplemented();</span>
<span class="line-removed"> 100 }</span>
<span class="line-removed"> 101 </span>
<span class="line-removed"> 102 void LIR_Assembler::fxch(int i) {</span>
<span class="line-removed"> 103   Unimplemented();</span>
<span class="line-removed"> 104 }</span>
<span class="line-removed"> 105 </span>
<span class="line-removed"> 106 void LIR_Assembler::fld(int i) {</span>
<span class="line-removed"> 107   Unimplemented();</span>
<span class="line-removed"> 108 }</span>
<span class="line-removed"> 109 </span>
<span class="line-removed"> 110 void LIR_Assembler::ffree(int i) {</span>
<span class="line-removed"> 111   Unimplemented();</span>
<span class="line-removed"> 112 }</span>
<span class="line-removed"> 113 </span>
 114 void LIR_Assembler::breakpoint() {
 115   __ breakpoint();
 116 }
 117 
 118 void LIR_Assembler::push(LIR_Opr opr) {
 119   Unimplemented();
 120 }
 121 
 122 void LIR_Assembler::pop(LIR_Opr opr) {
 123   Unimplemented();
 124 }
 125 
 126 //-------------------------------------------
 127 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 128   Register base = addr-&gt;base()-&gt;as_pointer_register();
 129 
 130 
 131   if (addr-&gt;index()-&gt;is_illegal() || addr-&gt;index()-&gt;is_constant()) {
 132     int offset = addr-&gt;disp();
 133     if (addr-&gt;index()-&gt;is_constant()) {
</pre>
<hr />
<pre>
 173 
 174   assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 175   int monitor_offset = (method()-&gt;max_locals() + 2 * (number_of_locks - 1)) * BytesPerWord;
 176   for (int i = 0; i &lt; number_of_locks; i++) {
 177     int slot_offset = monitor_offset - (i * 2 * BytesPerWord);
 178     __ ldr(R1, Address(OSR_buf, slot_offset + 0*BytesPerWord));
 179     __ ldr(R2, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 180     __ str(R1, frame_map()-&gt;address_for_monitor_lock(i));
 181     __ str(R2, frame_map()-&gt;address_for_monitor_object(i));
 182   }
 183 }
 184 
 185 
 186 int LIR_Assembler::check_icache() {
 187   Register receiver = LIR_Assembler::receiverOpr()-&gt;as_register();
 188   int offset = __ offset();
 189   __ inline_cache_check(receiver, Ricklass);
 190   return offset;
 191 }
 192 



 193 
 194 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
 195   jobject o = (jobject)Universe::non_oop_word();
 196   int index = __ oop_recorder()-&gt;allocate_oop_index(o);
 197 
 198   PatchingStub* patch = new PatchingStub(_masm, patching_id(info), index);
 199 
 200   __ patchable_mov_oop(reg, o, index);
 201   patching_epilog(patch, lir_patch_normal, reg, info);
 202 }
 203 
 204 
 205 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 206   Metadata* o = (Metadata*)Universe::non_oop_word();
 207   int index = __ oop_recorder()-&gt;allocate_metadata_index(o);
 208   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id, index);
 209 
 210   __ patchable_mov_metadata(reg, o, index);
 211   patching_epilog(patch, lir_patch_normal, reg, info);
 212 }
</pre>
<hr />
<pre>
 290     bailout(&quot;deopt handler overflow&quot;);
 291     return -1;
 292   }
 293 
 294   int offset = code_offset();
 295 
 296   __ mov_relative_address(LR, __ pc());
 297   __ push(LR); // stub expects LR to be saved
 298   __ jump(SharedRuntime::deopt_blob()-&gt;unpack(), relocInfo::runtime_call_type, noreg);
 299 
 300   assert(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 301   __ end_a_stub();
 302 
 303   return offset;
 304 }
 305 
 306 
 307 void LIR_Assembler::return_op(LIR_Opr result) {
 308   // Pop the frame before safepoint polling
 309   __ remove_frame(initial_frame_size_in_bytes());
<span class="line-modified"> 310 </span>
<span class="line-removed"> 311   // mov_slow here is usually one or two instruction</span>
<span class="line-removed"> 312   __ mov_address(Rtemp, os::get_polling_page());</span>
<span class="line-removed"> 313   __ relocate(relocInfo::poll_return_type);</span>
<span class="line-removed"> 314   __ ldr(Rtemp, Address(Rtemp));</span>
 315   __ ret();
 316 }
 317 
<span class="line-removed"> 318 </span>
 319 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
<span class="line-removed"> 320   __ mov_address(Rtemp, os::get_polling_page());</span>
 321   if (info != NULL) {
 322     add_debug_info_for_branch(info);
 323   }
 324   int offset = __ offset();
<span class="line-modified"> 325   __ relocate(relocInfo::poll_type);</span>
<span class="line-removed"> 326   __ ldr(Rtemp, Address(Rtemp));</span>
 327   return offset;
 328 }
 329 
 330 
 331 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 332   if (from_reg != to_reg) {
 333     __ mov(to_reg, from_reg);
 334   }
 335 }
 336 
 337 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 338   assert(src-&gt;is_constant() &amp;&amp; dest-&gt;is_register(), &quot;must be&quot;);
 339   LIR_Const* c = src-&gt;as_constant_ptr();
 340 
 341   switch (c-&gt;type()) {
 342     case T_ADDRESS:
 343     case T_INT:
 344       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 345       __ mov_slow(dest-&gt;as_register(), c-&gt;as_jint());
 346       break;
</pre>
<hr />
<pre>
 560 #ifdef __SOFTFP__
 561     case T_FLOAT:
 562 #endif // __SOFTFP__
 563       __ str_32(src-&gt;as_register(), as_Address(to_addr));
 564       break;
 565 
 566 
 567 #ifdef __SOFTFP__
 568     case T_DOUBLE:
 569 #endif // __SOFTFP__
 570     case T_LONG: {
 571       Register from_lo = src-&gt;as_register_lo();
 572       Register from_hi = src-&gt;as_register_hi();
 573       if (to_addr-&gt;index()-&gt;is_register()) {
 574         assert(to_addr-&gt;scale() == LIR_Address::times_1,&quot;Unexpected scaled register&quot;);
 575         assert(to_addr-&gt;disp() == 0, &quot;Not yet supporting both&quot;);
 576         __ add(Rtemp, base_reg, to_addr-&gt;index()-&gt;as_register());
 577         base_reg = Rtemp;
 578         __ str(from_lo, Address(Rtemp));
 579         if (patch != NULL) {

 580           patching_epilog(patch, lir_patch_low, base_reg, info);
 581           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 582           patch_code = lir_patch_high;
 583         }
 584         __ str(from_hi, Address(Rtemp, BytesPerWord));
 585       } else if (base_reg == from_lo) {
 586         __ str(from_hi, as_Address_hi(to_addr));
 587         if (patch != NULL) {

 588           patching_epilog(patch, lir_patch_high, base_reg, info);
 589           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 590           patch_code = lir_patch_low;
 591         }
 592         __ str(from_lo, as_Address_lo(to_addr));
 593       } else {
 594         __ str(from_lo, as_Address_lo(to_addr));
 595         if (patch != NULL) {

 596           patching_epilog(patch, lir_patch_low, base_reg, info);
 597           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 598           patch_code = lir_patch_high;
 599         }
 600         __ str(from_hi, as_Address_hi(to_addr));
 601       }
 602       break;
 603     }
 604 
 605 #ifndef __SOFTFP__
 606     case T_FLOAT:
 607       if (to_addr-&gt;index()-&gt;is_register()) {
 608         assert(to_addr-&gt;scale() == LIR_Address::times_1,&quot;Unexpected scaled register&quot;);
 609         __ add(Rtemp, base_reg, to_addr-&gt;index()-&gt;as_register());
 610         if ((to_addr-&gt;disp() &lt;= -4096) || (to_addr-&gt;disp() &gt;= 4096)) { BAILOUT(&quot;offset not in range&quot;); }
 611         __ fsts(src-&gt;as_float_reg(), Address(Rtemp, to_addr-&gt;disp()));
 612       } else {
 613         __ fsts(src-&gt;as_float_reg(), as_Address(to_addr));
 614       }
 615       break;
</pre>
<hr />
<pre>
 619         assert(to_addr-&gt;scale() == LIR_Address::times_1,&quot;Unexpected scaled register&quot;);
 620         __ add(Rtemp, base_reg, to_addr-&gt;index()-&gt;as_register());
 621         if ((to_addr-&gt;disp() &lt;= -4096) || (to_addr-&gt;disp() &gt;= 4096)) { BAILOUT(&quot;offset not in range&quot;); }
 622         __ fstd(src-&gt;as_double_reg(), Address(Rtemp, to_addr-&gt;disp()));
 623       } else {
 624         __ fstd(src-&gt;as_double_reg(), as_Address(to_addr));
 625       }
 626       break;
 627 #endif // __SOFTFP__
 628 
 629 
 630     default:
 631       ShouldNotReachHere();
 632   }
 633 
 634   if (info != NULL) {
 635     add_debug_info_for_null_check(null_check_offset, info);
 636   }
 637 
 638   if (patch != NULL) {
<span class="line-modified"> 639     // Offset embeedded into LDR/STR instruction may appear not enough</span>
 640     // to address a field. So, provide a space for one more instruction
 641     // that will deal with larger offsets.
 642     __ nop();
 643     patching_epilog(patch, patch_code, base_reg, info);
 644   }
 645 }
 646 
 647 
 648 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
 649   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
 650   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 651 
 652   Address addr = src-&gt;is_single_word() ?
 653     frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()) :
 654     frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
 655 
 656   assert(lo_word_offset_in_bytes == 0 &amp;&amp; hi_word_offset_in_bytes == 4, &quot;little ending&quot;);
 657   if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
 658     if (addr.disp() &gt;= 1024) { BAILOUT(&quot;Too exotic case to handle here&quot;); }
 659   }
</pre>
<hr />
<pre>
 770       break;
 771 
 772     case T_SHORT:
 773       __ ldrsh(dest-&gt;as_register(), as_Address(addr));
 774       break;
 775 
 776 
 777 #ifdef __SOFTFP__
 778     case T_DOUBLE:
 779 #endif // __SOFTFP__
 780     case T_LONG: {
 781       Register to_lo = dest-&gt;as_register_lo();
 782       Register to_hi = dest-&gt;as_register_hi();
 783       if (addr-&gt;index()-&gt;is_register()) {
 784         assert(addr-&gt;scale() == LIR_Address::times_1,&quot;Unexpected scaled register&quot;);
 785         assert(addr-&gt;disp() == 0, &quot;Not yet supporting both&quot;);
 786         __ add(Rtemp, base_reg, addr-&gt;index()-&gt;as_register());
 787         base_reg = Rtemp;
 788         __ ldr(to_lo, Address(Rtemp));
 789         if (patch != NULL) {

 790           patching_epilog(patch, lir_patch_low, base_reg, info);
 791           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 792           patch_code = lir_patch_high;
 793         }
 794         __ ldr(to_hi, Address(Rtemp, BytesPerWord));
 795       } else if (base_reg == to_lo) {
 796         __ ldr(to_hi, as_Address_hi(addr));
 797         if (patch != NULL) {

 798           patching_epilog(patch, lir_patch_high, base_reg, info);
 799           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 800           patch_code = lir_patch_low;
 801         }
 802         __ ldr(to_lo, as_Address_lo(addr));
 803       } else {
 804         __ ldr(to_lo, as_Address_lo(addr));
 805         if (patch != NULL) {

 806           patching_epilog(patch, lir_patch_low, base_reg, info);
 807           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 808           patch_code = lir_patch_high;
 809         }
 810         __ ldr(to_hi, as_Address_hi(addr));
 811       }
 812       break;
 813     }
 814 
 815 #ifndef __SOFTFP__
 816     case T_FLOAT:
 817       if (addr-&gt;index()-&gt;is_register()) {
 818         assert(addr-&gt;scale() == LIR_Address::times_1,&quot;Unexpected scaled register&quot;);
 819         __ add(Rtemp, base_reg, addr-&gt;index()-&gt;as_register());
 820         if ((addr-&gt;disp() &lt;= -4096) || (addr-&gt;disp() &gt;= 4096)) { BAILOUT(&quot;offset not in range&quot;); }
 821         __ flds(dest-&gt;as_float_reg(), Address(Rtemp, addr-&gt;disp()));
 822       } else {
 823         __ flds(dest-&gt;as_float_reg(), as_Address(addr));
 824       }
 825       break;
 826 
 827     case T_DOUBLE:
 828       if (addr-&gt;index()-&gt;is_register()) {
 829         assert(addr-&gt;scale() == LIR_Address::times_1,&quot;Unexpected scaled register&quot;);
 830         __ add(Rtemp, base_reg, addr-&gt;index()-&gt;as_register());
 831         if ((addr-&gt;disp() &lt;= -4096) || (addr-&gt;disp() &gt;= 4096)) { BAILOUT(&quot;offset not in range&quot;); }
 832         __ fldd(dest-&gt;as_double_reg(), Address(Rtemp, addr-&gt;disp()));
 833       } else {
 834         __ fldd(dest-&gt;as_double_reg(), as_Address(addr));
 835       }
 836       break;
 837 #endif // __SOFTFP__
 838 
 839 
 840     default:
 841       ShouldNotReachHere();
 842   }
 843 
 844   if (patch != NULL) {
<span class="line-modified"> 845     // Offset embeedded into LDR/STR instruction may appear not enough</span>
 846     // to address a field. So, provide a space for one more instruction
 847     // that will deal with larger offsets.
 848     __ nop();
 849     patching_epilog(patch, patch_code, base_reg, info);
 850   }
 851 
 852 }
 853 
 854 
 855 void LIR_Assembler::emit_op3(LIR_Op3* op) {
 856   bool is_32 = op-&gt;result_opr()-&gt;is_single_cpu();
 857 
 858   if (op-&gt;code() == lir_idiv &amp;&amp; op-&gt;in_opr2()-&gt;is_constant() &amp;&amp; is_32) {
 859     int c = op-&gt;in_opr2()-&gt;as_constant_ptr()-&gt;as_jint();
 860     assert(is_power_of_2(c), &quot;non power-of-2 constant should be put in a register&quot;);
 861 
 862     Register left = op-&gt;in_opr1()-&gt;as_register();
 863     Register dest = op-&gt;result_opr()-&gt;as_register();
 864     if (c == 1) {
 865       __ mov(dest, left);
</pre>
<hr />
<pre>
1796   if (opr1-&gt;is_single_cpu()) {
1797     if (opr2-&gt;is_constant()) {
1798       switch (opr2-&gt;as_constant_ptr()-&gt;type()) {
1799         case T_INT: {
1800           const jint c = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1801           if (Assembler::is_arith_imm_in_range(c)) {
1802             __ cmp_32(opr1-&gt;as_register(), c);
1803           } else if (Assembler::is_arith_imm_in_range(-c)) {
1804             __ cmn_32(opr1-&gt;as_register(), -c);
1805           } else {
1806             // This can happen when compiling lookupswitch
1807             __ mov_slow(Rtemp, c);
1808             __ cmp_32(opr1-&gt;as_register(), Rtemp);
1809           }
1810           break;
1811         }
1812         case T_OBJECT:
1813           assert(opr2-&gt;as_constant_ptr()-&gt;as_jobject() == NULL, &quot;cannot handle otherwise&quot;);
1814           __ cmp(opr1-&gt;as_register(), 0);
1815           break;





1816         default:
1817           ShouldNotReachHere();
1818       }
1819     } else if (opr2-&gt;is_single_cpu()) {
1820       if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {
1821         assert(opr2-&gt;type() == T_OBJECT || opr2-&gt;type() == T_ARRAY, &quot;incompatibe type&quot;);
1822         __ cmpoop(opr1-&gt;as_register(), opr2-&gt;as_register());
1823       } else if (opr1-&gt;type() == T_METADATA || opr1-&gt;type() == T_ADDRESS) {
1824         assert(opr2-&gt;type() == T_METADATA || opr2-&gt;type() == T_ADDRESS, &quot;incompatibe type&quot;);
1825         __ cmp(opr1-&gt;as_register(), opr2-&gt;as_register());
1826       } else {
1827         assert(opr2-&gt;type() != T_OBJECT &amp;&amp; opr2-&gt;type() != T_ARRAY &amp;&amp; opr2-&gt;type() != T_METADATA &amp;&amp; opr2-&gt;type() != T_ADDRESS, &quot;incompatibe type&quot;);
1828         __ cmp_32(opr1-&gt;as_register(), opr2-&gt;as_register());
1829       }
1830     } else {
1831       ShouldNotReachHere();
1832     }
1833   } else if (opr1-&gt;is_double_cpu()) {
1834     Register xlo = opr1-&gt;as_register_lo();
1835     Register xhi = opr1-&gt;as_register_hi();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.inline.hpp&quot;
  27 #include &quot;c1/c1_Compilation.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  30 #include &quot;c1/c1_Runtime1.hpp&quot;
  31 #include &quot;c1/c1_ValueStack.hpp&quot;
  32 #include &quot;ci/ciArrayKlass.hpp&quot;
  33 #include &quot;ci/ciInstance.hpp&quot;


  34 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-added">  35 #include &quot;memory/universe.hpp&quot;</span>
  36 #include &quot;nativeInst_arm.hpp&quot;
  37 #include &quot;oops/objArrayKlass.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="line-added">  40 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  41 #include &quot;vmreg_arm.inline.hpp&quot;
  42 
  43 #define __ _masm-&gt;
  44 
  45 // Note: Rtemp usage is this file should not impact C2 and should be
  46 // correct as long as it is not implicitly used in lower layers (the
  47 // arm [macro]assembler) and used with care in the other C1 specific
  48 // files.
  49 
  50 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  51   ShouldNotCallThis(); // Not used on ARM
  52   return false;
  53 }
  54 
  55 
  56 LIR_Opr LIR_Assembler::receiverOpr() {
  57   // The first register in Java calling conventions
  58   return FrameMap::R0_oop_opr;
  59 }
  60 
</pre>
<hr />
<pre>
  70 
  71 void LIR_Assembler::store_parameter(jint c, int offset_from_sp_in_words) {
  72   assert(offset_from_sp_in_words &gt;= 0, &quot;invalid offset from sp&quot;);
  73   int offset_from_sp_in_bytes = offset_from_sp_in_words * BytesPerWord;
  74   assert(offset_from_sp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;not enough space&quot;);
  75   __ mov_slow(Rtemp, c);
  76   __ str(Rtemp, Address(SP, offset_from_sp_in_bytes));
  77 }
  78 
  79 void LIR_Assembler::store_parameter(Metadata* m, int offset_from_sp_in_words) {
  80   assert(offset_from_sp_in_words &gt;= 0, &quot;invalid offset from sp&quot;);
  81   int offset_from_sp_in_bytes = offset_from_sp_in_words * BytesPerWord;
  82   assert(offset_from_sp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;not enough space&quot;);
  83   __ mov_metadata(Rtemp, m);
  84   __ str(Rtemp, Address(SP, offset_from_sp_in_bytes));
  85 }
  86 
  87 //--------------fpu register translations-----------------------
  88 
  89 
























  90 void LIR_Assembler::breakpoint() {
  91   __ breakpoint();
  92 }
  93 
  94 void LIR_Assembler::push(LIR_Opr opr) {
  95   Unimplemented();
  96 }
  97 
  98 void LIR_Assembler::pop(LIR_Opr opr) {
  99   Unimplemented();
 100 }
 101 
 102 //-------------------------------------------
 103 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 104   Register base = addr-&gt;base()-&gt;as_pointer_register();
 105 
 106 
 107   if (addr-&gt;index()-&gt;is_illegal() || addr-&gt;index()-&gt;is_constant()) {
 108     int offset = addr-&gt;disp();
 109     if (addr-&gt;index()-&gt;is_constant()) {
</pre>
<hr />
<pre>
 149 
 150   assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 151   int monitor_offset = (method()-&gt;max_locals() + 2 * (number_of_locks - 1)) * BytesPerWord;
 152   for (int i = 0; i &lt; number_of_locks; i++) {
 153     int slot_offset = monitor_offset - (i * 2 * BytesPerWord);
 154     __ ldr(R1, Address(OSR_buf, slot_offset + 0*BytesPerWord));
 155     __ ldr(R2, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 156     __ str(R1, frame_map()-&gt;address_for_monitor_lock(i));
 157     __ str(R2, frame_map()-&gt;address_for_monitor_object(i));
 158   }
 159 }
 160 
 161 
 162 int LIR_Assembler::check_icache() {
 163   Register receiver = LIR_Assembler::receiverOpr()-&gt;as_register();
 164   int offset = __ offset();
 165   __ inline_cache_check(receiver, Ricklass);
 166   return offset;
 167 }
 168 
<span class="line-added"> 169 void LIR_Assembler::clinit_barrier(ciMethod* method) {</span>
<span class="line-added"> 170   ShouldNotReachHere(); // not implemented</span>
<span class="line-added"> 171 }</span>
 172 
 173 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
 174   jobject o = (jobject)Universe::non_oop_word();
 175   int index = __ oop_recorder()-&gt;allocate_oop_index(o);
 176 
 177   PatchingStub* patch = new PatchingStub(_masm, patching_id(info), index);
 178 
 179   __ patchable_mov_oop(reg, o, index);
 180   patching_epilog(patch, lir_patch_normal, reg, info);
 181 }
 182 
 183 
 184 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 185   Metadata* o = (Metadata*)Universe::non_oop_word();
 186   int index = __ oop_recorder()-&gt;allocate_metadata_index(o);
 187   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id, index);
 188 
 189   __ patchable_mov_metadata(reg, o, index);
 190   patching_epilog(patch, lir_patch_normal, reg, info);
 191 }
</pre>
<hr />
<pre>
 269     bailout(&quot;deopt handler overflow&quot;);
 270     return -1;
 271   }
 272 
 273   int offset = code_offset();
 274 
 275   __ mov_relative_address(LR, __ pc());
 276   __ push(LR); // stub expects LR to be saved
 277   __ jump(SharedRuntime::deopt_blob()-&gt;unpack(), relocInfo::runtime_call_type, noreg);
 278 
 279   assert(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 280   __ end_a_stub();
 281 
 282   return offset;
 283 }
 284 
 285 
 286 void LIR_Assembler::return_op(LIR_Opr result) {
 287   // Pop the frame before safepoint polling
 288   __ remove_frame(initial_frame_size_in_bytes());
<span class="line-modified"> 289   __ read_polling_page(Rtemp, relocInfo::poll_return_type);</span>




 290   __ ret();
 291 }
 292 

 293 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {

 294   if (info != NULL) {
 295     add_debug_info_for_branch(info);
 296   }
 297   int offset = __ offset();
<span class="line-modified"> 298   __ read_polling_page(Rtemp, relocInfo::poll_type);</span>

 299   return offset;
 300 }
 301 
 302 
 303 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 304   if (from_reg != to_reg) {
 305     __ mov(to_reg, from_reg);
 306   }
 307 }
 308 
 309 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 310   assert(src-&gt;is_constant() &amp;&amp; dest-&gt;is_register(), &quot;must be&quot;);
 311   LIR_Const* c = src-&gt;as_constant_ptr();
 312 
 313   switch (c-&gt;type()) {
 314     case T_ADDRESS:
 315     case T_INT:
 316       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 317       __ mov_slow(dest-&gt;as_register(), c-&gt;as_jint());
 318       break;
</pre>
<hr />
<pre>
 532 #ifdef __SOFTFP__
 533     case T_FLOAT:
 534 #endif // __SOFTFP__
 535       __ str_32(src-&gt;as_register(), as_Address(to_addr));
 536       break;
 537 
 538 
 539 #ifdef __SOFTFP__
 540     case T_DOUBLE:
 541 #endif // __SOFTFP__
 542     case T_LONG: {
 543       Register from_lo = src-&gt;as_register_lo();
 544       Register from_hi = src-&gt;as_register_hi();
 545       if (to_addr-&gt;index()-&gt;is_register()) {
 546         assert(to_addr-&gt;scale() == LIR_Address::times_1,&quot;Unexpected scaled register&quot;);
 547         assert(to_addr-&gt;disp() == 0, &quot;Not yet supporting both&quot;);
 548         __ add(Rtemp, base_reg, to_addr-&gt;index()-&gt;as_register());
 549         base_reg = Rtemp;
 550         __ str(from_lo, Address(Rtemp));
 551         if (patch != NULL) {
<span class="line-added"> 552           __ nop(); // see comment before patching_epilog for 2nd str</span>
 553           patching_epilog(patch, lir_patch_low, base_reg, info);
 554           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 555           patch_code = lir_patch_high;
 556         }
 557         __ str(from_hi, Address(Rtemp, BytesPerWord));
 558       } else if (base_reg == from_lo) {
 559         __ str(from_hi, as_Address_hi(to_addr));
 560         if (patch != NULL) {
<span class="line-added"> 561           __ nop(); // see comment before patching_epilog for 2nd str</span>
 562           patching_epilog(patch, lir_patch_high, base_reg, info);
 563           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 564           patch_code = lir_patch_low;
 565         }
 566         __ str(from_lo, as_Address_lo(to_addr));
 567       } else {
 568         __ str(from_lo, as_Address_lo(to_addr));
 569         if (patch != NULL) {
<span class="line-added"> 570           __ nop(); // see comment before patching_epilog for 2nd str</span>
 571           patching_epilog(patch, lir_patch_low, base_reg, info);
 572           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 573           patch_code = lir_patch_high;
 574         }
 575         __ str(from_hi, as_Address_hi(to_addr));
 576       }
 577       break;
 578     }
 579 
 580 #ifndef __SOFTFP__
 581     case T_FLOAT:
 582       if (to_addr-&gt;index()-&gt;is_register()) {
 583         assert(to_addr-&gt;scale() == LIR_Address::times_1,&quot;Unexpected scaled register&quot;);
 584         __ add(Rtemp, base_reg, to_addr-&gt;index()-&gt;as_register());
 585         if ((to_addr-&gt;disp() &lt;= -4096) || (to_addr-&gt;disp() &gt;= 4096)) { BAILOUT(&quot;offset not in range&quot;); }
 586         __ fsts(src-&gt;as_float_reg(), Address(Rtemp, to_addr-&gt;disp()));
 587       } else {
 588         __ fsts(src-&gt;as_float_reg(), as_Address(to_addr));
 589       }
 590       break;
</pre>
<hr />
<pre>
 594         assert(to_addr-&gt;scale() == LIR_Address::times_1,&quot;Unexpected scaled register&quot;);
 595         __ add(Rtemp, base_reg, to_addr-&gt;index()-&gt;as_register());
 596         if ((to_addr-&gt;disp() &lt;= -4096) || (to_addr-&gt;disp() &gt;= 4096)) { BAILOUT(&quot;offset not in range&quot;); }
 597         __ fstd(src-&gt;as_double_reg(), Address(Rtemp, to_addr-&gt;disp()));
 598       } else {
 599         __ fstd(src-&gt;as_double_reg(), as_Address(to_addr));
 600       }
 601       break;
 602 #endif // __SOFTFP__
 603 
 604 
 605     default:
 606       ShouldNotReachHere();
 607   }
 608 
 609   if (info != NULL) {
 610     add_debug_info_for_null_check(null_check_offset, info);
 611   }
 612 
 613   if (patch != NULL) {
<span class="line-modified"> 614     // Offset embedded into LDR/STR instruction may appear not enough</span>
 615     // to address a field. So, provide a space for one more instruction
 616     // that will deal with larger offsets.
 617     __ nop();
 618     patching_epilog(patch, patch_code, base_reg, info);
 619   }
 620 }
 621 
 622 
 623 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
 624   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
 625   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 626 
 627   Address addr = src-&gt;is_single_word() ?
 628     frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()) :
 629     frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
 630 
 631   assert(lo_word_offset_in_bytes == 0 &amp;&amp; hi_word_offset_in_bytes == 4, &quot;little ending&quot;);
 632   if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
 633     if (addr.disp() &gt;= 1024) { BAILOUT(&quot;Too exotic case to handle here&quot;); }
 634   }
</pre>
<hr />
<pre>
 745       break;
 746 
 747     case T_SHORT:
 748       __ ldrsh(dest-&gt;as_register(), as_Address(addr));
 749       break;
 750 
 751 
 752 #ifdef __SOFTFP__
 753     case T_DOUBLE:
 754 #endif // __SOFTFP__
 755     case T_LONG: {
 756       Register to_lo = dest-&gt;as_register_lo();
 757       Register to_hi = dest-&gt;as_register_hi();
 758       if (addr-&gt;index()-&gt;is_register()) {
 759         assert(addr-&gt;scale() == LIR_Address::times_1,&quot;Unexpected scaled register&quot;);
 760         assert(addr-&gt;disp() == 0, &quot;Not yet supporting both&quot;);
 761         __ add(Rtemp, base_reg, addr-&gt;index()-&gt;as_register());
 762         base_reg = Rtemp;
 763         __ ldr(to_lo, Address(Rtemp));
 764         if (patch != NULL) {
<span class="line-added"> 765           __ nop(); // see comment before patching_epilog for 2nd ldr</span>
 766           patching_epilog(patch, lir_patch_low, base_reg, info);
 767           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 768           patch_code = lir_patch_high;
 769         }
 770         __ ldr(to_hi, Address(Rtemp, BytesPerWord));
 771       } else if (base_reg == to_lo) {
 772         __ ldr(to_hi, as_Address_hi(addr));
 773         if (patch != NULL) {
<span class="line-added"> 774           __ nop(); // see comment before patching_epilog for 2nd ldr</span>
 775           patching_epilog(patch, lir_patch_high, base_reg, info);
 776           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 777           patch_code = lir_patch_low;
 778         }
 779         __ ldr(to_lo, as_Address_lo(addr));
 780       } else {
 781         __ ldr(to_lo, as_Address_lo(addr));
 782         if (patch != NULL) {
<span class="line-added"> 783           __ nop(); // see comment before patching_epilog for 2nd ldr</span>
 784           patching_epilog(patch, lir_patch_low, base_reg, info);
 785           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 786           patch_code = lir_patch_high;
 787         }
 788         __ ldr(to_hi, as_Address_hi(addr));
 789       }
 790       break;
 791     }
 792 
 793 #ifndef __SOFTFP__
 794     case T_FLOAT:
 795       if (addr-&gt;index()-&gt;is_register()) {
 796         assert(addr-&gt;scale() == LIR_Address::times_1,&quot;Unexpected scaled register&quot;);
 797         __ add(Rtemp, base_reg, addr-&gt;index()-&gt;as_register());
 798         if ((addr-&gt;disp() &lt;= -4096) || (addr-&gt;disp() &gt;= 4096)) { BAILOUT(&quot;offset not in range&quot;); }
 799         __ flds(dest-&gt;as_float_reg(), Address(Rtemp, addr-&gt;disp()));
 800       } else {
 801         __ flds(dest-&gt;as_float_reg(), as_Address(addr));
 802       }
 803       break;
 804 
 805     case T_DOUBLE:
 806       if (addr-&gt;index()-&gt;is_register()) {
 807         assert(addr-&gt;scale() == LIR_Address::times_1,&quot;Unexpected scaled register&quot;);
 808         __ add(Rtemp, base_reg, addr-&gt;index()-&gt;as_register());
 809         if ((addr-&gt;disp() &lt;= -4096) || (addr-&gt;disp() &gt;= 4096)) { BAILOUT(&quot;offset not in range&quot;); }
 810         __ fldd(dest-&gt;as_double_reg(), Address(Rtemp, addr-&gt;disp()));
 811       } else {
 812         __ fldd(dest-&gt;as_double_reg(), as_Address(addr));
 813       }
 814       break;
 815 #endif // __SOFTFP__
 816 
 817 
 818     default:
 819       ShouldNotReachHere();
 820   }
 821 
 822   if (patch != NULL) {
<span class="line-modified"> 823     // Offset embedded into LDR/STR instruction may appear not enough</span>
 824     // to address a field. So, provide a space for one more instruction
 825     // that will deal with larger offsets.
 826     __ nop();
 827     patching_epilog(patch, patch_code, base_reg, info);
 828   }
 829 
 830 }
 831 
 832 
 833 void LIR_Assembler::emit_op3(LIR_Op3* op) {
 834   bool is_32 = op-&gt;result_opr()-&gt;is_single_cpu();
 835 
 836   if (op-&gt;code() == lir_idiv &amp;&amp; op-&gt;in_opr2()-&gt;is_constant() &amp;&amp; is_32) {
 837     int c = op-&gt;in_opr2()-&gt;as_constant_ptr()-&gt;as_jint();
 838     assert(is_power_of_2(c), &quot;non power-of-2 constant should be put in a register&quot;);
 839 
 840     Register left = op-&gt;in_opr1()-&gt;as_register();
 841     Register dest = op-&gt;result_opr()-&gt;as_register();
 842     if (c == 1) {
 843       __ mov(dest, left);
</pre>
<hr />
<pre>
1774   if (opr1-&gt;is_single_cpu()) {
1775     if (opr2-&gt;is_constant()) {
1776       switch (opr2-&gt;as_constant_ptr()-&gt;type()) {
1777         case T_INT: {
1778           const jint c = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1779           if (Assembler::is_arith_imm_in_range(c)) {
1780             __ cmp_32(opr1-&gt;as_register(), c);
1781           } else if (Assembler::is_arith_imm_in_range(-c)) {
1782             __ cmn_32(opr1-&gt;as_register(), -c);
1783           } else {
1784             // This can happen when compiling lookupswitch
1785             __ mov_slow(Rtemp, c);
1786             __ cmp_32(opr1-&gt;as_register(), Rtemp);
1787           }
1788           break;
1789         }
1790         case T_OBJECT:
1791           assert(opr2-&gt;as_constant_ptr()-&gt;as_jobject() == NULL, &quot;cannot handle otherwise&quot;);
1792           __ cmp(opr1-&gt;as_register(), 0);
1793           break;
<span class="line-added">1794         case T_METADATA:</span>
<span class="line-added">1795           assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;Only equality tests&quot;);</span>
<span class="line-added">1796           assert(opr2-&gt;as_constant_ptr()-&gt;as_metadata() == NULL, &quot;cannot handle otherwise&quot;);</span>
<span class="line-added">1797           __ cmp(opr1-&gt;as_register(), 0);</span>
<span class="line-added">1798           break;</span>
1799         default:
1800           ShouldNotReachHere();
1801       }
1802     } else if (opr2-&gt;is_single_cpu()) {
1803       if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {
1804         assert(opr2-&gt;type() == T_OBJECT || opr2-&gt;type() == T_ARRAY, &quot;incompatibe type&quot;);
1805         __ cmpoop(opr1-&gt;as_register(), opr2-&gt;as_register());
1806       } else if (opr1-&gt;type() == T_METADATA || opr1-&gt;type() == T_ADDRESS) {
1807         assert(opr2-&gt;type() == T_METADATA || opr2-&gt;type() == T_ADDRESS, &quot;incompatibe type&quot;);
1808         __ cmp(opr1-&gt;as_register(), opr2-&gt;as_register());
1809       } else {
1810         assert(opr2-&gt;type() != T_OBJECT &amp;&amp; opr2-&gt;type() != T_ARRAY &amp;&amp; opr2-&gt;type() != T_METADATA &amp;&amp; opr2-&gt;type() != T_ADDRESS, &quot;incompatibe type&quot;);
1811         __ cmp_32(opr1-&gt;as_register(), opr2-&gt;as_register());
1812       }
1813     } else {
1814       ShouldNotReachHere();
1815     }
1816   } else if (opr1-&gt;is_double_cpu()) {
1817     Register xlo = opr1-&gt;as_register_lo();
1818     Register xhi = opr1-&gt;as_register_hi();
</pre>
</td>
</tr>
</table>
<center><a href="c1_FrameMap_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/arm/sharedRuntime_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.hpp&quot;
  27 #include &quot;assembler_arm.inline.hpp&quot;
  28 #include &quot;code/debugInfoRec.hpp&quot;
  29 #include &quot;code/icBuffer.hpp&quot;
  30 #include &quot;code/vtableStubs.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;logging/log.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/compiledICHolder.hpp&quot;
  35 #include &quot;runtime/sharedRuntime.hpp&quot;
  36 #include &quot;runtime/vframeArray.hpp&quot;
  37 #include &quot;utilities/align.hpp&quot;
  38 #include &quot;vmreg_arm.inline.hpp&quot;
  39 #ifdef COMPILER1
  40 #include &quot;c1/c1_Runtime1.hpp&quot;
  41 #endif
  42 #ifdef COMPILER2
  43 #include &quot;opto/runtime.hpp&quot;
  44 #endif
  45 
  46 #define __ masm-&gt;
  47 
  48 class RegisterSaver {
  49 public:
  50 
  51   // Special registers:
  52   //              32-bit ARM     64-bit ARM
  53   //  Rthread:       R10            R28
  54   //  LR:            R14            R30
  55 
  56   // Rthread is callee saved in the C ABI and never changed by compiled code:
  57   // no need to save it.
  58 
  59   // 2 slots for LR: the one at LR_offset and an other one at R14/R30_offset.
  60   // The one at LR_offset is a return address that is needed by stack walking.
  61   // A c2 method uses LR as a standard register so it may be live when we
  62   // branch to the runtime. The slot at R14/R30_offset is for the value of LR
  63   // in case it&#39;s live in the method we are coming from.
  64 
  65 
  66   enum RegisterLayout {
  67     fpu_save_size = FloatRegisterImpl::number_of_registers,
  68 #ifndef __SOFTFP__
  69     D0_offset = 0,
  70 #endif
  71     R0_offset = fpu_save_size,
  72     R1_offset,
  73     R2_offset,
  74     R3_offset,
  75     R4_offset,
  76     R5_offset,
  77     R6_offset,
  78 #if (FP_REG_NUM != 7)
  79     // if not saved as FP
  80     R7_offset,
  81 #endif
  82     R8_offset,
  83     R9_offset,
  84 #if (FP_REG_NUM != 11)
  85     // if not saved as FP
  86     R11_offset,
  87 #endif
  88     R12_offset,
  89     R14_offset,
  90     FP_offset,
  91     LR_offset,
  92     reg_save_size,
  93 
  94     Rmethod_offset = R9_offset,
  95     Rtemp_offset = R12_offset,
  96   };
  97 
  98   // all regs but Rthread (R10), FP (R7 or R11), SP and PC
  99   // (altFP_7_11 is the one amoung R7 and R11 which is not FP)
 100 #define SAVED_BASE_REGS (RegisterSet(R0, R6) | RegisterSet(R8, R9) | RegisterSet(R12) | R14 | altFP_7_11)
 101 
 102 
 103   //  When LR may be live in the nmethod from which we are comming
 104   //  then lr_saved is true, the return address is saved before the
 105   //  call to save_live_register by the caller and LR contains the
 106   //  live value.
 107 
 108   static OopMap* save_live_registers(MacroAssembler* masm,
 109                                      int* total_frame_words,
 110                                      bool lr_saved = false);
 111   static void restore_live_registers(MacroAssembler* masm, bool restore_lr = true);
 112 
 113 };
 114 
 115 
 116 
 117 
 118 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm,
 119                                            int* total_frame_words,
 120                                            bool lr_saved) {
 121   *total_frame_words = reg_save_size;
 122 
 123   OopMapSet *oop_maps = new OopMapSet();
 124   OopMap* map = new OopMap(VMRegImpl::slots_per_word * (*total_frame_words), 0);
 125 
 126   if (lr_saved) {
 127     __ push(RegisterSet(FP));
 128   } else {
 129     __ push(RegisterSet(FP) | RegisterSet(LR));
 130   }
 131   __ push(SAVED_BASE_REGS);
 132   if (HaveVFP) {
 133     if (VM_Version::has_vfp3_32()) {
 134       __ fstmdbd(SP, FloatRegisterSet(D16, 16), writeback);
 135     } else {
 136       if (FloatRegisterImpl::number_of_registers &gt; 32) {
 137         assert(FloatRegisterImpl::number_of_registers == 64, &quot;nb fp registers should be 64&quot;);
 138         __ sub(SP, SP, 32 * wordSize);
 139       }
 140     }
 141     __ fstmdbd(SP, FloatRegisterSet(D0, 16), writeback);
 142   } else {
 143     __ sub(SP, SP, fpu_save_size * wordSize);
 144   }
 145 
 146   int i;
 147   int j=0;
 148   for (i = R0_offset; i &lt;= R9_offset; i++) {
 149     if (j == FP_REG_NUM) {
 150       // skip the FP register, managed below.
 151       j++;
 152     }
 153     map-&gt;set_callee_saved(VMRegImpl::stack2reg(i), as_Register(j)-&gt;as_VMReg());
 154     j++;
 155   }
 156   assert(j == R10-&gt;encoding(), &quot;must be&quot;);
 157 #if (FP_REG_NUM != 11)
 158   // add R11, if not managed as FP
 159   map-&gt;set_callee_saved(VMRegImpl::stack2reg(R11_offset), R11-&gt;as_VMReg());
 160 #endif
 161   map-&gt;set_callee_saved(VMRegImpl::stack2reg(R12_offset), R12-&gt;as_VMReg());
 162   map-&gt;set_callee_saved(VMRegImpl::stack2reg(R14_offset), R14-&gt;as_VMReg());
 163   if (HaveVFP) {
 164     for (i = 0; i &lt; (VM_Version::has_vfp3_32() ? 64 : 32); i+=2) {
 165       map-&gt;set_callee_saved(VMRegImpl::stack2reg(i), as_FloatRegister(i)-&gt;as_VMReg());
 166       map-&gt;set_callee_saved(VMRegImpl::stack2reg(i + 1), as_FloatRegister(i)-&gt;as_VMReg()-&gt;next());
 167     }
 168   }
 169 
 170   return map;
 171 }
 172 
 173 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_lr) {
 174   if (HaveVFP) {
 175     __ fldmiad(SP, FloatRegisterSet(D0, 16), writeback);
 176     if (VM_Version::has_vfp3_32()) {
 177       __ fldmiad(SP, FloatRegisterSet(D16, 16), writeback);
 178     } else {
 179       if (FloatRegisterImpl::number_of_registers &gt; 32) {
 180         assert(FloatRegisterImpl::number_of_registers == 64, &quot;nb fp registers should be 64&quot;);
 181         __ add(SP, SP, 32 * wordSize);
 182       }
 183     }
 184   } else {
 185     __ add(SP, SP, fpu_save_size * wordSize);
 186   }
 187   __ pop(SAVED_BASE_REGS);
 188   if (restore_lr) {
 189     __ pop(RegisterSet(FP) | RegisterSet(LR));
 190   } else {
 191     __ pop(RegisterSet(FP));
 192   }
 193 }
 194 
 195 
 196 static void push_result_registers(MacroAssembler* masm, BasicType ret_type) {
 197 #ifdef __ABI_HARD__
 198   if (ret_type == T_DOUBLE || ret_type == T_FLOAT) {
 199     __ sub(SP, SP, 8);
 200     __ fstd(D0, Address(SP));
 201     return;
 202   }
 203 #endif // __ABI_HARD__
 204   __ raw_push(R0, R1);
 205 }
 206 
 207 static void pop_result_registers(MacroAssembler* masm, BasicType ret_type) {
 208 #ifdef __ABI_HARD__
 209   if (ret_type == T_DOUBLE || ret_type == T_FLOAT) {
 210     __ fldd(D0, Address(SP));
 211     __ add(SP, SP, 8);
 212     return;
 213   }
 214 #endif // __ABI_HARD__
 215   __ raw_pop(R0, R1);
 216 }
 217 
 218 static void push_param_registers(MacroAssembler* masm, int fp_regs_in_arguments) {
 219   // R1-R3 arguments need to be saved, but we push 4 registers for 8-byte alignment
 220   __ push(RegisterSet(R0, R3));
 221 
 222 #ifdef __ABI_HARD__
 223   // preserve arguments
 224   // Likely not needed as the locking code won&#39;t probably modify volatile FP registers,
 225   // but there is no way to guarantee that
 226   if (fp_regs_in_arguments) {
 227     // convert fp_regs_in_arguments to a number of double registers
 228     int double_regs_num = (fp_regs_in_arguments + 1) &gt;&gt; 1;
 229     __ fstmdbd(SP, FloatRegisterSet(D0, double_regs_num), writeback);
 230   }
 231 #endif // __ ABI_HARD__
 232 }
 233 
 234 static void pop_param_registers(MacroAssembler* masm, int fp_regs_in_arguments) {
 235 #ifdef __ABI_HARD__
 236   if (fp_regs_in_arguments) {
 237     int double_regs_num = (fp_regs_in_arguments + 1) &gt;&gt; 1;
 238     __ fldmiad(SP, FloatRegisterSet(D0, double_regs_num), writeback);
 239   }
 240 #endif // __ABI_HARD__
 241 
 242   __ pop(RegisterSet(R0, R3));
 243 }
 244 
 245 
 246 
 247 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
 248 // All vector registers are saved by default on ARM.
 249 bool SharedRuntime::is_wide_vector(int size) {
 250   return false;
 251 }
 252 
 253 size_t SharedRuntime::trampoline_size() {
 254   return 16;
 255 }
 256 
 257 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 258   InlinedAddress dest(destination);
 259   __ indirect_jump(dest, Rtemp);
 260   __ bind_literal(dest);
 261 }
 262 
 263 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 264                                         VMRegPair *regs,
 265                                         VMRegPair *regs2,
 266                                         int total_args_passed) {
 267   assert(regs2 == NULL, &quot;not needed on arm&quot;);
 268 
 269   int slot = 0;
 270   int ireg = 0;
 271 #ifdef __ABI_HARD__
 272   int fp_slot = 0;
 273   int single_fpr_slot = 0;
 274 #endif // __ABI_HARD__
 275   for (int i = 0; i &lt; total_args_passed; i++) {
 276     switch (sig_bt[i]) {
 277     case T_SHORT:
 278     case T_CHAR:
 279     case T_BYTE:
 280     case T_BOOLEAN:
 281     case T_INT:
 282     case T_ARRAY:
 283     case T_OBJECT:
 284     case T_ADDRESS:
 285     case T_METADATA:
 286 #ifndef __ABI_HARD__
 287     case T_FLOAT:
 288 #endif // !__ABI_HARD__
 289       if (ireg &lt; 4) {
 290         Register r = as_Register(ireg);
 291         regs[i].set1(r-&gt;as_VMReg());
 292         ireg++;
 293       } else {
 294         regs[i].set1(VMRegImpl::stack2reg(slot));
 295         slot++;
 296       }
 297       break;
 298     case T_LONG:
 299 #ifndef __ABI_HARD__
 300     case T_DOUBLE:
 301 #endif // !__ABI_HARD__
 302       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;missing Half&quot; );
 303       if (ireg &lt;= 2) {
 304 #if (ALIGN_WIDE_ARGUMENTS == 1)
 305         if(ireg &amp; 1) ireg++;  // Aligned location required
 306 #endif
 307         Register r1 = as_Register(ireg);
 308         Register r2 = as_Register(ireg + 1);
 309         regs[i].set_pair(r2-&gt;as_VMReg(), r1-&gt;as_VMReg());
 310         ireg += 2;
 311 #if (ALIGN_WIDE_ARGUMENTS == 0)
 312       } else if (ireg == 3) {
 313         // uses R3 + one stack slot
 314         Register r = as_Register(ireg);
 315         regs[i].set_pair(VMRegImpl::stack2reg(slot), r-&gt;as_VMReg());
 316         ireg += 1;
 317         slot += 1;
 318 #endif
 319       } else {
 320         if (slot &amp; 1) slot++; // Aligned location required
 321         regs[i].set_pair(VMRegImpl::stack2reg(slot+1), VMRegImpl::stack2reg(slot));
 322         slot += 2;
 323         ireg = 4;
 324       }
 325       break;
 326     case T_VOID:
 327       regs[i].set_bad();
 328       break;
 329 #ifdef __ABI_HARD__
 330     case T_FLOAT:
 331       if ((fp_slot &lt; 16)||(single_fpr_slot &amp; 1)) {
 332         if ((single_fpr_slot &amp; 1) == 0) {
 333           single_fpr_slot = fp_slot;
 334           fp_slot += 2;
 335         }
 336         FloatRegister r = as_FloatRegister(single_fpr_slot);
 337         single_fpr_slot++;
 338         regs[i].set1(r-&gt;as_VMReg());
 339       } else {
 340         regs[i].set1(VMRegImpl::stack2reg(slot));
 341         slot++;
 342       }
 343       break;
 344     case T_DOUBLE:
 345       assert(ALIGN_WIDE_ARGUMENTS == 1, &quot;ABI_HARD not supported with unaligned wide arguments&quot;);
 346       if (fp_slot &lt;= 14) {
 347         FloatRegister r1 = as_FloatRegister(fp_slot);
 348         FloatRegister r2 = as_FloatRegister(fp_slot+1);
 349         regs[i].set_pair(r2-&gt;as_VMReg(), r1-&gt;as_VMReg());
 350         fp_slot += 2;
 351       } else {
 352         if(slot &amp; 1) slot++;
 353         regs[i].set_pair(VMRegImpl::stack2reg(slot+1), VMRegImpl::stack2reg(slot));
 354         slot += 2;
 355         single_fpr_slot = 16;
 356       }
 357       break;
 358 #endif // __ABI_HARD__
 359     default:
 360       ShouldNotReachHere();
 361     }
 362   }
 363   return slot;
 364 }
 365 
 366 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 367                                            VMRegPair *regs,
 368                                            int total_args_passed,
 369                                            int is_outgoing) {
 370 #ifdef __SOFTFP__
 371   // soft float is the same as the C calling convention.
 372   return c_calling_convention(sig_bt, regs, NULL, total_args_passed);
 373 #endif // __SOFTFP__
 374   (void) is_outgoing;
 375   int slot = 0;
 376   int ireg = 0;
 377   int freg = 0;
 378   int single_fpr = 0;
 379 
 380   for (int i = 0; i &lt; total_args_passed; i++) {
 381     switch (sig_bt[i]) {
 382     case T_SHORT:
 383     case T_CHAR:
 384     case T_BYTE:
 385     case T_BOOLEAN:
 386     case T_INT:
 387     case T_ARRAY:
 388     case T_OBJECT:
 389     case T_ADDRESS:
 390       if (ireg &lt; 4) {
 391         Register r = as_Register(ireg++);
 392         regs[i].set1(r-&gt;as_VMReg());
 393       } else {
 394         regs[i].set1(VMRegImpl::stack2reg(slot++));
 395       }
 396       break;
 397     case T_FLOAT:
 398       // C2 utilizes S14/S15 for mem-mem moves
 399       if ((freg &lt; 16 COMPILER2_PRESENT(-2)) || (single_fpr &amp; 1)) {
 400         if ((single_fpr &amp; 1) == 0) {
 401           single_fpr = freg;
 402           freg += 2;
 403         }
 404         FloatRegister r = as_FloatRegister(single_fpr++);
 405         regs[i].set1(r-&gt;as_VMReg());
 406       } else {
 407         regs[i].set1(VMRegImpl::stack2reg(slot++));
 408       }
 409       break;
 410     case T_DOUBLE:
 411       // C2 utilizes S14/S15 for mem-mem moves
 412       if (freg &lt;= 14 COMPILER2_PRESENT(-2)) {
 413         FloatRegister r1 = as_FloatRegister(freg);
 414         FloatRegister r2 = as_FloatRegister(freg + 1);
 415         regs[i].set_pair(r2-&gt;as_VMReg(), r1-&gt;as_VMReg());
 416         freg += 2;
 417       } else {
 418         // Keep internally the aligned calling convention,
 419         // ignoring ALIGN_WIDE_ARGUMENTS
 420         if (slot &amp; 1) slot++;
 421         regs[i].set_pair(VMRegImpl::stack2reg(slot + 1), VMRegImpl::stack2reg(slot));
 422         slot += 2;
 423         single_fpr = 16;
 424       }
 425       break;
 426     case T_LONG:
 427       // Keep internally the aligned calling convention,
 428       // ignoring ALIGN_WIDE_ARGUMENTS
 429       if (ireg &lt;= 2) {
 430         if (ireg &amp; 1) ireg++;
 431         Register r1 = as_Register(ireg);
 432         Register r2 = as_Register(ireg + 1);
 433         regs[i].set_pair(r2-&gt;as_VMReg(), r1-&gt;as_VMReg());
 434         ireg += 2;
 435       } else {
 436         if (slot &amp; 1) slot++;
 437         regs[i].set_pair(VMRegImpl::stack2reg(slot + 1), VMRegImpl::stack2reg(slot));
 438         slot += 2;
 439         ireg = 4;
 440       }
 441       break;
 442     case T_VOID:
 443       regs[i].set_bad();
 444       break;
 445     default:
 446       ShouldNotReachHere();
 447     }
 448   }
 449 
 450   if (slot &amp; 1) slot++;
 451   return slot;
 452 }
 453 
 454 static void patch_callers_callsite(MacroAssembler *masm) {
 455   Label skip;
 456 
 457   __ ldr(Rtemp, Address(Rmethod, Method::code_offset()));
 458   __ cbz(Rtemp, skip);
 459 
 460   // Pushing an even number of registers for stack alignment.
 461   // Selecting R9, which had to be saved anyway for some platforms.
 462   __ push(RegisterSet(R0, R3) | R9 | LR);
 463 
 464   __ mov(R0, Rmethod);
 465   __ mov(R1, LR);
 466   __ call(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite));
 467 
 468   __ pop(RegisterSet(R0, R3) | R9 | LR);
 469 
 470   __ bind(skip);
 471 }
 472 
 473 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,
 474                                     int total_args_passed, int comp_args_on_stack,
 475                                     const BasicType *sig_bt, const VMRegPair *regs) {
 476   // TODO: ARM - May be can use ldm to load arguments
 477   const Register tmp = Rtemp; // avoid erasing R5_mh
 478 
 479   // Next assert may not be needed but safer. Extra analysis required
 480   // if this there is not enough free registers and we need to use R5 here.
 481   assert_different_registers(tmp, R5_mh);
 482 
 483   // 6243940 We might end up in handle_wrong_method if
 484   // the callee is deoptimized as we race thru here. If that
 485   // happens we don&#39;t want to take a safepoint because the
 486   // caller frame will look interpreted and arguments are now
 487   // &quot;compiled&quot; so it is much better to make this transition
 488   // invisible to the stack walking code. Unfortunately if
 489   // we try and find the callee by normal means a safepoint
 490   // is possible. So we stash the desired callee in the thread
 491   // and the vm will find there should this case occur.
 492   Address callee_target_addr(Rthread, JavaThread::callee_target_offset());
 493   __ str(Rmethod, callee_target_addr);
 494 
 495 
 496   assert_different_registers(tmp, R0, R1, R2, R3, Rsender_sp, Rmethod);
 497 
 498   const Register initial_sp = Rmethod; // temporarily scratched
 499 
 500   // Old code was modifying R4 but this looks unsafe (particularly with JSR292)
 501   assert_different_registers(tmp, R0, R1, R2, R3, Rsender_sp, initial_sp);
 502 
 503   __ mov(initial_sp, SP);
 504 
 505   if (comp_args_on_stack) {
 506     __ sub_slow(SP, SP, comp_args_on_stack * VMRegImpl::stack_slot_size);
 507   }
 508   __ bic(SP, SP, StackAlignmentInBytes - 1);
 509 
 510   for (int i = 0; i &lt; total_args_passed; i++) {
 511     if (sig_bt[i] == T_VOID) {
 512       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 513       continue;
 514     }
 515     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(), &quot;must be ordered&quot;);
 516     int arg_offset = Interpreter::expr_offset_in_bytes(total_args_passed - 1 - i);
 517 
 518     VMReg r_1 = regs[i].first();
 519     VMReg r_2 = regs[i].second();
 520     if (r_1-&gt;is_stack()) {
 521       int stack_offset = r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size;
 522       if (!r_2-&gt;is_valid()) {
 523         __ ldr(tmp, Address(initial_sp, arg_offset));
 524         __ str(tmp, Address(SP, stack_offset));
 525       } else {
 526         __ ldr(tmp, Address(initial_sp, arg_offset - Interpreter::stackElementSize));
 527         __ str(tmp, Address(SP, stack_offset));
 528         __ ldr(tmp, Address(initial_sp, arg_offset));
 529         __ str(tmp, Address(SP, stack_offset + wordSize));
 530       }
 531     } else if (r_1-&gt;is_Register()) {
 532       if (!r_2-&gt;is_valid()) {
 533         __ ldr(r_1-&gt;as_Register(), Address(initial_sp, arg_offset));
 534       } else {
 535         __ ldr(r_1-&gt;as_Register(), Address(initial_sp, arg_offset - Interpreter::stackElementSize));
 536         __ ldr(r_2-&gt;as_Register(), Address(initial_sp, arg_offset));
 537       }
 538     } else if (r_1-&gt;is_FloatRegister()) {
 539 #ifdef __SOFTFP__
 540       ShouldNotReachHere();
 541 #endif // __SOFTFP__
 542       if (!r_2-&gt;is_valid()) {
 543         __ flds(r_1-&gt;as_FloatRegister(), Address(initial_sp, arg_offset));
 544       } else {
 545         __ fldd(r_1-&gt;as_FloatRegister(), Address(initial_sp, arg_offset - Interpreter::stackElementSize));
 546       }
 547     } else {
 548       assert(!r_1-&gt;is_valid() &amp;&amp; !r_2-&gt;is_valid(), &quot;must be&quot;);
 549     }
 550   }
 551 
 552   // restore Rmethod (scratched for initial_sp)
 553   __ ldr(Rmethod, callee_target_addr);
 554   __ ldr(PC, Address(Rmethod, Method::from_compiled_offset()));
 555 
 556 }
 557 
 558 static void gen_c2i_adapter(MacroAssembler *masm,
 559                             int total_args_passed,  int comp_args_on_stack,
 560                             const BasicType *sig_bt, const VMRegPair *regs,
 561                             Label&amp; skip_fixup) {
 562   // TODO: ARM - May be can use stm to deoptimize arguments
 563   const Register tmp = Rtemp;
 564 
 565   patch_callers_callsite(masm);
 566   __ bind(skip_fixup);
 567 
 568   __ mov(Rsender_sp, SP); // not yet saved
 569 
 570 
 571   int extraspace = total_args_passed * Interpreter::stackElementSize;
 572   if (extraspace) {
 573     __ sub_slow(SP, SP, extraspace);
 574   }
 575 
 576   for (int i = 0; i &lt; total_args_passed; i++) {
 577     if (sig_bt[i] == T_VOID) {
 578       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 579       continue;
 580     }
 581     int stack_offset = (total_args_passed - 1 - i) * Interpreter::stackElementSize;
 582 
 583     VMReg r_1 = regs[i].first();
 584     VMReg r_2 = regs[i].second();
 585     if (r_1-&gt;is_stack()) {
 586       int arg_offset = r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extraspace;
 587       if (!r_2-&gt;is_valid()) {
 588         __ ldr(tmp, Address(SP, arg_offset));
 589         __ str(tmp, Address(SP, stack_offset));
 590       } else {
 591         __ ldr(tmp, Address(SP, arg_offset));
 592         __ str(tmp, Address(SP, stack_offset - Interpreter::stackElementSize));
 593         __ ldr(tmp, Address(SP, arg_offset + wordSize));
 594         __ str(tmp, Address(SP, stack_offset));
 595       }
 596     } else if (r_1-&gt;is_Register()) {
 597       if (!r_2-&gt;is_valid()) {
 598         __ str(r_1-&gt;as_Register(), Address(SP, stack_offset));
 599       } else {
 600         __ str(r_1-&gt;as_Register(), Address(SP, stack_offset - Interpreter::stackElementSize));
 601         __ str(r_2-&gt;as_Register(), Address(SP, stack_offset));
 602       }
 603     } else if (r_1-&gt;is_FloatRegister()) {
 604 #ifdef __SOFTFP__
 605       ShouldNotReachHere();
 606 #endif // __SOFTFP__
 607       if (!r_2-&gt;is_valid()) {
 608         __ fsts(r_1-&gt;as_FloatRegister(), Address(SP, stack_offset));
 609       } else {
 610         __ fstd(r_1-&gt;as_FloatRegister(), Address(SP, stack_offset - Interpreter::stackElementSize));
 611       }
 612     } else {
 613       assert(!r_1-&gt;is_valid() &amp;&amp; !r_2-&gt;is_valid(), &quot;must be&quot;);
 614     }
 615   }
 616 
 617   __ ldr(PC, Address(Rmethod, Method::interpreter_entry_offset()));
 618 
 619 }
 620 
 621 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
 622                                                             int total_args_passed,
 623                                                             int comp_args_on_stack,
 624                                                             const BasicType *sig_bt,
 625                                                             const VMRegPair *regs,
 626                                                             AdapterFingerPrint* fingerprint) {
 627   address i2c_entry = __ pc();
 628   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
 629 
 630   address c2i_unverified_entry = __ pc();
 631   Label skip_fixup;
 632   const Register receiver       = R0;
 633   const Register holder_klass   = Rtemp; // XXX should be OK for C2 but not 100% sure
 634   const Register receiver_klass = R4;
 635 
 636   __ load_klass(receiver_klass, receiver);
 637   __ ldr(holder_klass, Address(Ricklass, CompiledICHolder::holder_klass_offset()));
 638   __ ldr(Rmethod, Address(Ricklass, CompiledICHolder::holder_metadata_offset()));
 639   __ cmp(receiver_klass, holder_klass);
 640 
 641   __ ldr(Rtemp, Address(Rmethod, Method::code_offset()), eq);
 642   __ cmp(Rtemp, 0, eq);
 643   __ b(skip_fixup, eq);
 644   __ jump(SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type, noreg, ne);
 645 
 646   address c2i_entry = __ pc();
 647   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 648 
 649   __ flush();
 650   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);
 651 }
 652 
 653 
 654 static int reg2offset_in(VMReg r) {
 655   // Account for saved FP and LR
 656   return r-&gt;reg2stack() * VMRegImpl::stack_slot_size + 2*wordSize;
 657 }
 658 
 659 static int reg2offset_out(VMReg r) {
 660   return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 661 }
 662 
 663 
 664 static void verify_oop_args(MacroAssembler* masm,
 665                             const methodHandle&amp; method,
 666                             const BasicType* sig_bt,
 667                             const VMRegPair* regs) {
 668   Register temp_reg = Rmethod;  // not part of any compiled calling seq
 669   if (VerifyOops) {
 670     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
 671       if (sig_bt[i] == T_OBJECT || sig_bt[i] == T_ARRAY) {
 672         VMReg r = regs[i].first();
 673         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
 674         if (r-&gt;is_stack()) {
 675           __ ldr(temp_reg, Address(SP, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
 676           __ verify_oop(temp_reg);
 677         } else {
 678           __ verify_oop(r-&gt;as_Register());
 679         }
 680       }
 681     }
 682   }
 683 }
 684 
 685 static void gen_special_dispatch(MacroAssembler* masm,
 686                                  const methodHandle&amp; method,
 687                                  const BasicType* sig_bt,
 688                                  const VMRegPair* regs) {
 689   verify_oop_args(masm, method, sig_bt, regs);
 690   vmIntrinsics::ID iid = method-&gt;intrinsic_id();
 691 
 692   // Now write the args into the outgoing interpreter space
 693   bool     has_receiver   = false;
 694   Register receiver_reg   = noreg;
 695   int      member_arg_pos = -1;
 696   Register member_reg     = noreg;
 697   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
 698   if (ref_kind != 0) {
 699     member_arg_pos = method-&gt;size_of_parameters() - 1;  // trailing MemberName argument
 700     member_reg = Rmethod;  // known to be free at this point
 701     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
 702   } else if (iid == vmIntrinsics::_invokeBasic) {
 703     has_receiver = true;
 704   } else {
 705     fatal(&quot;unexpected intrinsic id %d&quot;, iid);
 706   }
 707 
 708   if (member_reg != noreg) {
 709     // Load the member_arg into register, if necessary.
 710     SharedRuntime::check_member_name_argument_is_last_argument(method, sig_bt, regs);
 711     VMReg r = regs[member_arg_pos].first();
 712     if (r-&gt;is_stack()) {
 713       __ ldr(member_reg, Address(SP, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
 714     } else {
 715       // no data motion is needed
 716       member_reg = r-&gt;as_Register();
 717     }
 718   }
 719 
 720   if (has_receiver) {
 721     // Make sure the receiver is loaded into a register.
 722     assert(method-&gt;size_of_parameters() &gt; 0, &quot;oob&quot;);
 723     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
 724     VMReg r = regs[0].first();
 725     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
 726     if (r-&gt;is_stack()) {
 727       // Porting note:  This assumes that compiled calling conventions always
 728       // pass the receiver oop in a register.  If this is not true on some
 729       // platform, pick a temp and load the receiver from stack.
 730       assert(false, &quot;receiver always in a register&quot;);
 731       receiver_reg = j_rarg0;  // known to be free at this point
 732       __ ldr(receiver_reg, Address(SP, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
 733     } else {
 734       // no data motion is needed
 735       receiver_reg = r-&gt;as_Register();
 736     }
 737   }
 738 
 739   // Figure out which address we are really jumping to:
 740   MethodHandles::generate_method_handle_dispatch(masm, iid,
 741                                                  receiver_reg, member_reg, /*for_compiler_entry:*/ true);
 742 }
 743 
 744 // ---------------------------------------------------------------------------
 745 // Generate a native wrapper for a given method.  The method takes arguments
 746 // in the Java compiled code convention, marshals them to the native
 747 // convention (handlizes oops, etc), transitions to native, makes the call,
 748 // returns to java state (possibly blocking), unhandlizes any result and
 749 // returns.
 750 nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
 751                                                 const methodHandle&amp; method,
 752                                                 int compile_id,
 753                                                 BasicType* in_sig_bt,
 754                                                 VMRegPair* in_regs,
 755                                                 BasicType ret_type) {
 756   if (method-&gt;is_method_handle_intrinsic()) {
 757     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
 758     intptr_t start = (intptr_t)__ pc();
 759     int vep_offset = ((intptr_t)__ pc()) - start;
 760     gen_special_dispatch(masm,
 761                          method,
 762                          in_sig_bt,
 763                          in_regs);
 764     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
 765     __ flush();
 766     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
 767     return nmethod::new_native_nmethod(method,
 768                                        compile_id,
 769                                        masm-&gt;code(),
 770                                        vep_offset,
 771                                        frame_complete,
 772                                        stack_slots / VMRegImpl::slots_per_word,
 773                                        in_ByteSize(-1),
 774                                        in_ByteSize(-1),
 775                                        (OopMapSet*)NULL);
 776   }
 777   // Arguments for JNI method include JNIEnv and Class if static
 778 
 779   // Usage of Rtemp should be OK since scratched by native call
 780 
 781   bool is_static = method-&gt;is_static();
 782 
 783   const int total_in_args = method-&gt;size_of_parameters();
 784   int total_c_args = total_in_args + 1;
 785   if (is_static) {
 786     total_c_args++;
 787   }
 788 
 789   BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
 790   VMRegPair* out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
 791 
 792   int argc = 0;
 793   out_sig_bt[argc++] = T_ADDRESS;
 794   if (is_static) {
 795     out_sig_bt[argc++] = T_OBJECT;
 796   }
 797 
 798   int i;
 799   for (i = 0; i &lt; total_in_args; i++) {
 800     out_sig_bt[argc++] = in_sig_bt[i];
 801   }
 802 
 803   int out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
 804   int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;
 805   // Since object arguments need to be wrapped, we must preserve space
 806   // for those object arguments which come in registers (GPR_PARAMS maximum)
 807   // plus one more slot for Klass handle (for static methods)
 808   int oop_handle_offset = stack_slots;
 809   stack_slots += (GPR_PARAMS + 1) * VMRegImpl::slots_per_word;
 810 
 811   // Plus a lock if needed
 812   int lock_slot_offset = 0;
 813   if (method-&gt;is_synchronized()) {
 814     lock_slot_offset = stack_slots;
 815     assert(sizeof(BasicLock) == wordSize, &quot;adjust this code&quot;);
 816     stack_slots += VMRegImpl::slots_per_word;
 817   }
 818 
 819   // Space to save return address and FP
 820   stack_slots += 2 * VMRegImpl::slots_per_word;
 821 
 822   // Calculate the final stack size taking account of alignment
 823   stack_slots = align_up(stack_slots, StackAlignmentInBytes / VMRegImpl::stack_slot_size);
 824   int stack_size = stack_slots * VMRegImpl::stack_slot_size;
 825   int lock_slot_fp_offset = stack_size - 2 * wordSize -
 826     lock_slot_offset * VMRegImpl::stack_slot_size;
 827 
 828   // Unverified entry point
 829   address start = __ pc();
 830 
 831   // Inline cache check, same as in C1_MacroAssembler::inline_cache_check()
 832   const Register receiver = R0; // see receiverOpr()
 833   __ load_klass(Rtemp, receiver);
 834   __ cmp(Rtemp, Ricklass);
 835   Label verified;
 836 
 837   __ b(verified, eq); // jump over alignment no-ops too
 838   __ jump(SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type, Rtemp);
 839   __ align(CodeEntryAlignment);
 840 
 841   // Verified entry point
 842   __ bind(verified);
 843   int vep_offset = __ pc() - start;
 844 
 845 
 846   if ((InlineObjectHash &amp;&amp; method-&gt;intrinsic_id() == vmIntrinsics::_hashCode) || (method-&gt;intrinsic_id() == vmIntrinsics::_identityHashCode)) {
 847     // Object.hashCode, System.identityHashCode can pull the hashCode from the header word
 848     // instead of doing a full VM transition once it&#39;s been computed.
 849     Label slow_case;
 850     const Register obj_reg = R0;
 851 
 852     // Unlike for Object.hashCode, System.identityHashCode is static method and
 853     // gets object as argument instead of the receiver.
 854     if (method-&gt;intrinsic_id() == vmIntrinsics::_identityHashCode) {
 855       assert(method-&gt;is_static(), &quot;method should be static&quot;);
 856       // return 0 for null reference input, return val = R0 = obj_reg = 0
 857       __ cmp(obj_reg, 0);
 858       __ bx(LR, eq);
 859     }
 860 
 861     __ ldr(Rtemp, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
 862 
 863     assert(markOopDesc::unlocked_value == 1, &quot;adjust this code&quot;);
 864     __ tbz(Rtemp, exact_log2(markOopDesc::unlocked_value), slow_case);
 865 
 866     if (UseBiasedLocking) {
 867       assert(is_power_of_2(markOopDesc::biased_lock_bit_in_place), &quot;adjust this code&quot;);
 868       __ tbnz(Rtemp, exact_log2(markOopDesc::biased_lock_bit_in_place), slow_case);
 869     }
 870 
 871     __ bics(Rtemp, Rtemp, ~markOopDesc::hash_mask_in_place);
 872     __ mov(R0, AsmOperand(Rtemp, lsr, markOopDesc::hash_shift), ne);
 873     __ bx(LR, ne);
 874 
 875     __ bind(slow_case);
 876   }
 877 
 878   // Bang stack pages
 879   __ arm_stack_overflow_check(stack_size, Rtemp);
 880 
 881   // Setup frame linkage
 882   __ raw_push(FP, LR);
 883   __ mov(FP, SP);
 884   __ sub_slow(SP, SP, stack_size - 2*wordSize);
 885 
 886   int frame_complete = __ pc() - start;
 887 
 888   OopMapSet* oop_maps = new OopMapSet();
 889   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
 890   const int extra_args = is_static ? 2 : 1;
 891   int receiver_offset = -1;
 892   int fp_regs_in_arguments = 0;
 893 
 894   for (i = total_in_args; --i &gt;= 0; ) {
 895     switch (in_sig_bt[i]) {
 896     case T_ARRAY:
 897     case T_OBJECT: {
 898       VMReg src = in_regs[i].first();
 899       VMReg dst = out_regs[i + extra_args].first();
 900       if (src-&gt;is_stack()) {
 901         assert(dst-&gt;is_stack(), &quot;must be&quot;);
 902         assert(i != 0, &quot;Incoming receiver is always in a register&quot;);
 903         __ ldr(Rtemp, Address(FP, reg2offset_in(src)));
 904         __ cmp(Rtemp, 0);
 905         __ add(Rtemp, FP, reg2offset_in(src), ne);
 906         __ str(Rtemp, Address(SP, reg2offset_out(dst)));
 907         int offset_in_older_frame = src-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
 908         map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + stack_slots));
 909       } else {
 910         int offset = oop_handle_offset * VMRegImpl::stack_slot_size;
 911         __ str(src-&gt;as_Register(), Address(SP, offset));
 912         map-&gt;set_oop(VMRegImpl::stack2reg(oop_handle_offset));
 913         if ((i == 0) &amp;&amp; (!is_static)) {
 914           receiver_offset = offset;
 915         }
 916         oop_handle_offset += VMRegImpl::slots_per_word;
 917 
 918         if (dst-&gt;is_stack()) {
 919           __ movs(Rtemp, src-&gt;as_Register());
 920           __ add(Rtemp, SP, offset, ne);
 921           __ str(Rtemp, Address(SP, reg2offset_out(dst)));
 922         } else {
 923           __ movs(dst-&gt;as_Register(), src-&gt;as_Register());
 924           __ add(dst-&gt;as_Register(), SP, offset, ne);
 925         }
 926       }
 927     }
 928 
 929     case T_VOID:
 930       break;
 931 
 932 
 933 #ifdef __SOFTFP__
 934     case T_DOUBLE:
 935 #endif
 936     case T_LONG: {
 937       VMReg src_1 = in_regs[i].first();
 938       VMReg src_2 = in_regs[i].second();
 939       VMReg dst_1 = out_regs[i + extra_args].first();
 940       VMReg dst_2 = out_regs[i + extra_args].second();
 941 #if (ALIGN_WIDE_ARGUMENTS == 0)
 942       // C convention can mix a register and a stack slot for a
 943       // 64-bits native argument.
 944 
 945       // Note: following code should work independently of whether
 946       // the Java calling convention follows C convention or whether
 947       // it aligns 64-bit values.
 948       if (dst_2-&gt;is_Register()) {
 949         if (src_1-&gt;as_Register() != dst_1-&gt;as_Register()) {
 950           assert(src_1-&gt;as_Register() != dst_2-&gt;as_Register() &amp;&amp;
 951                  src_2-&gt;as_Register() != dst_2-&gt;as_Register(), &quot;must be&quot;);
 952           __ mov(dst_2-&gt;as_Register(), src_2-&gt;as_Register());
 953           __ mov(dst_1-&gt;as_Register(), src_1-&gt;as_Register());
 954         } else {
 955           assert(src_2-&gt;as_Register() == dst_2-&gt;as_Register(), &quot;must be&quot;);
 956         }
 957       } else if (src_2-&gt;is_Register()) {
 958         if (dst_1-&gt;is_Register()) {
 959           // dst mixes a register and a stack slot
 960           assert(dst_2-&gt;is_stack() &amp;&amp; src_1-&gt;is_Register() &amp;&amp; src_2-&gt;is_Register(), &quot;must be&quot;);
 961           assert(src_1-&gt;as_Register() != dst_1-&gt;as_Register(), &quot;must be&quot;);
 962           __ str(src_2-&gt;as_Register(), Address(SP, reg2offset_out(dst_2)));
 963           __ mov(dst_1-&gt;as_Register(), src_1-&gt;as_Register());
 964         } else {
 965           // registers to stack slots
 966           assert(dst_2-&gt;is_stack() &amp;&amp; src_1-&gt;is_Register() &amp;&amp; src_2-&gt;is_Register(), &quot;must be&quot;);
 967           __ str(src_1-&gt;as_Register(), Address(SP, reg2offset_out(dst_1)));
 968           __ str(src_2-&gt;as_Register(), Address(SP, reg2offset_out(dst_2)));
 969         }
 970       } else if (src_1-&gt;is_Register()) {
 971         if (dst_1-&gt;is_Register()) {
 972           // src and dst must be R3 + stack slot
 973           assert(dst_1-&gt;as_Register() == src_1-&gt;as_Register(), &quot;must be&quot;);
 974           __ ldr(Rtemp,    Address(FP, reg2offset_in(src_2)));
 975           __ str(Rtemp,    Address(SP, reg2offset_out(dst_2)));
 976         } else {
 977           // &lt;R3,stack&gt; -&gt; &lt;stack,stack&gt;
 978           assert(dst_2-&gt;is_stack() &amp;&amp; src_2-&gt;is_stack(), &quot;must be&quot;);
 979           __ ldr(LR, Address(FP, reg2offset_in(src_2)));
 980           __ str(src_1-&gt;as_Register(), Address(SP, reg2offset_out(dst_1)));
 981           __ str(LR, Address(SP, reg2offset_out(dst_2)));
 982         }
 983       } else {
 984         assert(src_2-&gt;is_stack() &amp;&amp; dst_1-&gt;is_stack() &amp;&amp; dst_2-&gt;is_stack(), &quot;must be&quot;);
 985         __ ldr(Rtemp, Address(FP, reg2offset_in(src_1)));
 986         __ ldr(LR,    Address(FP, reg2offset_in(src_2)));
 987         __ str(Rtemp, Address(SP, reg2offset_out(dst_1)));
 988         __ str(LR,    Address(SP, reg2offset_out(dst_2)));
 989       }
 990 #else // ALIGN_WIDE_ARGUMENTS
 991       if (src_1-&gt;is_stack()) {
 992         assert(src_2-&gt;is_stack() &amp;&amp; dst_1-&gt;is_stack() &amp;&amp; dst_2-&gt;is_stack(), &quot;must be&quot;);
 993         __ ldr(Rtemp, Address(FP, reg2offset_in(src_1)));
 994         __ ldr(LR,    Address(FP, reg2offset_in(src_2)));
 995         __ str(Rtemp, Address(SP, reg2offset_out(dst_1)));
 996         __ str(LR,    Address(SP, reg2offset_out(dst_2)));
 997       } else if (dst_1-&gt;is_stack()) {
 998         assert(dst_2-&gt;is_stack() &amp;&amp; src_1-&gt;is_Register() &amp;&amp; src_2-&gt;is_Register(), &quot;must be&quot;);
 999         __ str(src_1-&gt;as_Register(), Address(SP, reg2offset_out(dst_1)));
1000         __ str(src_2-&gt;as_Register(), Address(SP, reg2offset_out(dst_2)));
1001       } else if (src_1-&gt;as_Register() == dst_1-&gt;as_Register()) {
1002         assert(src_2-&gt;as_Register() == dst_2-&gt;as_Register(), &quot;must be&quot;);
1003       } else {
1004         assert(src_1-&gt;as_Register() != dst_2-&gt;as_Register() &amp;&amp;
1005                src_2-&gt;as_Register() != dst_2-&gt;as_Register(), &quot;must be&quot;);
1006         __ mov(dst_2-&gt;as_Register(), src_2-&gt;as_Register());
1007         __ mov(dst_1-&gt;as_Register(), src_1-&gt;as_Register());
1008       }
1009 #endif // ALIGN_WIDE_ARGUMENTS
1010       break;
1011     }
1012 
1013 #if (!defined __SOFTFP__ &amp;&amp; !defined __ABI_HARD__)
1014     case T_FLOAT: {
1015       VMReg src = in_regs[i].first();
1016       VMReg dst = out_regs[i + extra_args].first();
1017       if (src-&gt;is_stack()) {
1018         assert(dst-&gt;is_stack(), &quot;must be&quot;);
1019         __ ldr(Rtemp, Address(FP, reg2offset_in(src)));
1020         __ str(Rtemp, Address(SP, reg2offset_out(dst)));
1021       } else if (dst-&gt;is_stack()) {
1022         __ fsts(src-&gt;as_FloatRegister(), Address(SP, reg2offset_out(dst)));
1023       } else {
1024         assert(src-&gt;is_FloatRegister() &amp;&amp; dst-&gt;is_Register(), &quot;must be&quot;);
1025         __ fmrs(dst-&gt;as_Register(), src-&gt;as_FloatRegister());
1026       }
1027       break;
1028     }
1029 
1030     case T_DOUBLE: {
1031       VMReg src_1 = in_regs[i].first();
1032       VMReg src_2 = in_regs[i].second();
1033       VMReg dst_1 = out_regs[i + extra_args].first();
1034       VMReg dst_2 = out_regs[i + extra_args].second();
1035       if (src_1-&gt;is_stack()) {
1036         assert(src_2-&gt;is_stack() &amp;&amp; dst_1-&gt;is_stack() &amp;&amp; dst_2-&gt;is_stack(), &quot;must be&quot;);
1037         __ ldr(Rtemp, Address(FP, reg2offset_in(src_1)));
1038         __ ldr(LR,    Address(FP, reg2offset_in(src_2)));
1039         __ str(Rtemp, Address(SP, reg2offset_out(dst_1)));
1040         __ str(LR,    Address(SP, reg2offset_out(dst_2)));
1041       } else if (dst_1-&gt;is_stack()) {
1042         assert(dst_2-&gt;is_stack() &amp;&amp; src_1-&gt;is_FloatRegister(), &quot;must be&quot;);
1043         __ fstd(src_1-&gt;as_FloatRegister(), Address(SP, reg2offset_out(dst_1)));
1044 #if (ALIGN_WIDE_ARGUMENTS == 0)
1045       } else if (dst_2-&gt;is_stack()) {
1046         assert(! src_2-&gt;is_stack(), &quot;must be&quot;); // assuming internal java convention is aligned
1047         // double register must go into R3 + one stack slot
1048         __ fmrrd(dst_1-&gt;as_Register(), Rtemp, src_1-&gt;as_FloatRegister());
1049         __ str(Rtemp, Address(SP, reg2offset_out(dst_2)));
1050 #endif
1051       } else {
1052         assert(src_1-&gt;is_FloatRegister() &amp;&amp; dst_1-&gt;is_Register() &amp;&amp; dst_2-&gt;is_Register(), &quot;must be&quot;);
1053         __ fmrrd(dst_1-&gt;as_Register(), dst_2-&gt;as_Register(), src_1-&gt;as_FloatRegister());
1054       }
1055       break;
1056     }
1057 #endif // __SOFTFP__
1058 
1059 #ifdef __ABI_HARD__
1060     case T_FLOAT: {
1061       VMReg src = in_regs[i].first();
1062       VMReg dst = out_regs[i + extra_args].first();
1063       if (src-&gt;is_stack()) {
1064         if (dst-&gt;is_stack()) {
1065           __ ldr(Rtemp, Address(FP, reg2offset_in(src)));
1066           __ str(Rtemp, Address(SP, reg2offset_out(dst)));
1067         } else {
1068           // C2 Java calling convention does not populate S14 and S15, therefore
1069           // those need to be loaded from stack here
1070           __ flds(dst-&gt;as_FloatRegister(), Address(FP, reg2offset_in(src)));
1071           fp_regs_in_arguments++;
1072         }
1073       } else {
1074         assert(src-&gt;is_FloatRegister(), &quot;must be&quot;);
1075         fp_regs_in_arguments++;
1076       }
1077       break;
1078     }
1079     case T_DOUBLE: {
1080       VMReg src_1 = in_regs[i].first();
1081       VMReg src_2 = in_regs[i].second();
1082       VMReg dst_1 = out_regs[i + extra_args].first();
1083       VMReg dst_2 = out_regs[i + extra_args].second();
1084       if (src_1-&gt;is_stack()) {
1085         if (dst_1-&gt;is_stack()) {
1086           assert(dst_2-&gt;is_stack(), &quot;must be&quot;);
1087           __ ldr(Rtemp, Address(FP, reg2offset_in(src_1)));
1088           __ ldr(LR,    Address(FP, reg2offset_in(src_2)));
1089           __ str(Rtemp, Address(SP, reg2offset_out(dst_1)));
1090           __ str(LR,    Address(SP, reg2offset_out(dst_2)));
1091         } else {
1092           // C2 Java calling convention does not populate S14 and S15, therefore
1093           // those need to be loaded from stack here
1094           __ fldd(dst_1-&gt;as_FloatRegister(), Address(FP, reg2offset_in(src_1)));
1095           fp_regs_in_arguments += 2;
1096         }
1097       } else {
1098         assert(src_1-&gt;is_FloatRegister() &amp;&amp; src_2-&gt;is_FloatRegister(), &quot;must be&quot;);
1099         fp_regs_in_arguments += 2;
1100       }
1101       break;
1102     }
1103 #endif // __ABI_HARD__
1104 
1105     default: {
1106       assert(in_sig_bt[i] != T_ADDRESS, &quot;found T_ADDRESS in java args&quot;);
1107       VMReg src = in_regs[i].first();
1108       VMReg dst = out_regs[i + extra_args].first();
1109       if (src-&gt;is_stack()) {
1110         assert(dst-&gt;is_stack(), &quot;must be&quot;);
1111         __ ldr(Rtemp, Address(FP, reg2offset_in(src)));
1112         __ str(Rtemp, Address(SP, reg2offset_out(dst)));
1113       } else if (dst-&gt;is_stack()) {
1114         __ str(src-&gt;as_Register(), Address(SP, reg2offset_out(dst)));
1115       } else {
1116         assert(src-&gt;is_Register() &amp;&amp; dst-&gt;is_Register(), &quot;must be&quot;);
1117         __ mov(dst-&gt;as_Register(), src-&gt;as_Register());
1118       }
1119     }
1120     }
1121   }
1122 
1123   // Get Klass mirror
1124   int klass_offset = -1;
1125   if (is_static) {
1126     klass_offset = oop_handle_offset * VMRegImpl::stack_slot_size;
1127     __ mov_oop(Rtemp, JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()));
1128     __ add(c_rarg1, SP, klass_offset);
1129     __ str(Rtemp, Address(SP, klass_offset));
1130     map-&gt;set_oop(VMRegImpl::stack2reg(oop_handle_offset));
1131   }
1132 
1133   // the PC offset given to add_gc_map must match the PC saved in set_last_Java_frame
1134   int pc_offset = __ set_last_Java_frame(SP, FP, true, Rtemp);
1135   assert(((__ pc()) - start) == __ offset(), &quot;warning: start differs from code_begin&quot;);
1136   oop_maps-&gt;add_gc_map(pc_offset, map);
1137 
1138   // Order last_Java_pc store with the thread state transition (to _thread_in_native)
1139   __ membar(MacroAssembler::StoreStore, Rtemp);
1140 
1141   // RedefineClasses() tracing support for obsolete method entry
1142   if (log_is_enabled(Trace, redefine, class, obsolete)) {
1143     __ save_caller_save_registers();
1144     __ mov(R0, Rthread);
1145     __ mov_metadata(R1, method());
1146     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::rc_trace_method_entry), R0, R1);
1147     __ restore_caller_save_registers();
1148   }
1149 
1150   const Register sync_handle = R5;
1151   const Register sync_obj    = R6;
1152   const Register disp_hdr    = altFP_7_11;
1153   const Register tmp         = R8;
1154 
1155   Label slow_lock, slow_lock_biased, lock_done, fast_lock;
1156   if (method-&gt;is_synchronized()) {
1157     // The first argument is a handle to sync object (a class or an instance)
1158     __ ldr(sync_obj, Address(R1));
1159     // Remember the handle for the unlocking code
1160     __ mov(sync_handle, R1);
1161 
1162     __ resolve(IS_NOT_NULL, sync_obj);
1163 
1164     if(UseBiasedLocking) {
1165       __ biased_locking_enter(sync_obj, tmp, disp_hdr/*scratched*/, false, Rtemp, lock_done, slow_lock_biased);
1166     }
1167 
1168     const Register mark = tmp;
1169     // On MP platforms the next load could return a &#39;stale&#39; value if the memory location has been modified by another thread.
1170     // That would be acceptable as either CAS or slow case path is taken in that case
1171 
1172     __ ldr(mark, Address(sync_obj, oopDesc::mark_offset_in_bytes()));
1173     __ sub(disp_hdr, FP, lock_slot_fp_offset);
1174     __ tst(mark, markOopDesc::unlocked_value);
1175     __ b(fast_lock, ne);
1176 
1177     // Check for recursive lock
1178     // See comments in InterpreterMacroAssembler::lock_object for
1179     // explanations on the fast recursive locking check.
1180     // Check independently the low bits and the distance to SP
1181     // -1- test low 2 bits
1182     __ movs(Rtemp, AsmOperand(mark, lsl, 30));
1183     // -2- test (hdr - SP) if the low two bits are 0
1184     __ sub(Rtemp, mark, SP, eq);
1185     __ movs(Rtemp, AsmOperand(Rtemp, lsr, exact_log2(os::vm_page_size())), eq);
1186     // If still &#39;eq&#39; then recursive locking OK: set displaced header to 0
1187     __ str(Rtemp, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()), eq);
1188     __ b(lock_done, eq);
1189     __ b(slow_lock);
1190 
1191     __ bind(fast_lock);
1192     __ str(mark, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()));
1193 
1194     __ cas_for_lock_acquire(mark, disp_hdr, sync_obj, Rtemp, slow_lock);
1195 
1196     __ bind(lock_done);
1197   }
1198 
1199   // Get JNIEnv*
1200   __ add(c_rarg0, Rthread, in_bytes(JavaThread::jni_environment_offset()));
1201 
1202   // Perform thread state transition
1203   __ mov(Rtemp, _thread_in_native);
1204   __ str(Rtemp, Address(Rthread, JavaThread::thread_state_offset()));
1205 
1206   // Finally, call the native method
1207   __ call(method-&gt;native_function());
1208 
1209   // Set FPSCR/FPCR to a known state
1210   if (AlwaysRestoreFPU) {
1211     __ restore_default_fp_mode();
1212   }
1213 
1214   // Ensure a Boolean result is mapped to 0..1
1215   if (ret_type == T_BOOLEAN) {
1216     __ c2bool(R0);
1217   }
1218 
1219   // Do a safepoint check while thread is in transition state
1220   InlinedAddress safepoint_state(SafepointSynchronize::address_of_state());
1221   Label call_safepoint_runtime, return_to_java;
1222   __ mov(Rtemp, _thread_in_native_trans);
1223   __ ldr_literal(R2, safepoint_state);
1224   __ str_32(Rtemp, Address(Rthread, JavaThread::thread_state_offset()));
1225 
1226   // make sure the store is observed before reading the SafepointSynchronize state and further mem refs
1227   __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreLoad | MacroAssembler::StoreStore), Rtemp);
1228 
1229   __ ldr_s32(R2, Address(R2));
1230   __ ldr_u32(R3, Address(Rthread, JavaThread::suspend_flags_offset()));
1231   __ cmp(R2, SafepointSynchronize::_not_synchronized);
1232   __ cond_cmp(R3, 0, eq);
1233   __ b(call_safepoint_runtime, ne);
1234   __ bind(return_to_java);
1235 
1236   // Perform thread state transition and reguard stack yellow pages if needed
1237   Label reguard, reguard_done;
1238   __ mov(Rtemp, _thread_in_Java);
1239   __ ldr_s32(R2, Address(Rthread, JavaThread::stack_guard_state_offset()));
1240   __ str_32(Rtemp, Address(Rthread, JavaThread::thread_state_offset()));
1241 
1242   __ cmp(R2, JavaThread::stack_guard_yellow_reserved_disabled);
1243   __ b(reguard, eq);
1244   __ bind(reguard_done);
1245 
1246   Label slow_unlock, unlock_done;
1247   if (method-&gt;is_synchronized()) {
1248     __ ldr(sync_obj, Address(sync_handle));
1249 
1250     __ resolve(IS_NOT_NULL, sync_obj);
1251 
1252     if(UseBiasedLocking) {
1253       __ biased_locking_exit(sync_obj, Rtemp, unlock_done);
1254       // disp_hdr may not have been saved on entry with biased locking
1255       __ sub(disp_hdr, FP, lock_slot_fp_offset);
1256     }
1257 
1258     // See C1_MacroAssembler::unlock_object() for more comments
1259     __ ldr(R2, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()));
1260     __ cbz(R2, unlock_done);
1261 
1262     __ cas_for_lock_release(disp_hdr, R2, sync_obj, Rtemp, slow_unlock);
1263 
1264     __ bind(unlock_done);
1265   }
1266 
1267   // Set last java frame and handle block to zero
1268   __ ldr(LR, Address(Rthread, JavaThread::active_handles_offset()));
1269   __ reset_last_Java_frame(Rtemp); // sets Rtemp to 0 on 32-bit ARM
1270 
1271   __ str_32(Rtemp, Address(LR, JNIHandleBlock::top_offset_in_bytes()));
1272   if (CheckJNICalls) {
1273     __ str(__ zero_register(Rtemp), Address(Rthread, JavaThread::pending_jni_exception_check_fn_offset()));
1274   }
1275 
1276   // Unbox oop result, e.g. JNIHandles::resolve value in R0.
1277   if (ret_type == T_OBJECT || ret_type == T_ARRAY) {
1278     __ resolve_jobject(R0,      // value
1279                        Rtemp,   // tmp1
1280                        R1_tmp); // tmp2
1281   }
1282 
1283   // Any exception pending?
1284   __ ldr(Rtemp, Address(Rthread, Thread::pending_exception_offset()));
1285   __ mov(SP, FP);
1286 
1287   __ cmp(Rtemp, 0);
1288   // Pop the frame and return if no exception pending
1289   __ pop(RegisterSet(FP) | RegisterSet(PC), eq);
1290   // Pop the frame and forward the exception. Rexception_pc contains return address.
1291   __ ldr(FP, Address(SP, wordSize, post_indexed), ne);
1292   __ ldr(Rexception_pc, Address(SP, wordSize, post_indexed), ne);
1293   __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);
1294 
1295   // Safepoint operation and/or pending suspend request is in progress.
1296   // Save the return values and call the runtime function by hand.
1297   __ bind(call_safepoint_runtime);
1298   push_result_registers(masm, ret_type);
1299   __ mov(R0, Rthread);
1300   __ call(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));
1301   pop_result_registers(masm, ret_type);
1302   __ b(return_to_java);
1303 
1304   __ bind_literal(safepoint_state);
1305 
1306   // Reguard stack pages. Save native results around a call to C runtime.
1307   __ bind(reguard);
1308   push_result_registers(masm, ret_type);
1309   __ call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));
1310   pop_result_registers(masm, ret_type);
1311   __ b(reguard_done);
1312 
1313   if (method-&gt;is_synchronized()) {
1314     // Locking slow case
1315     if(UseBiasedLocking) {
1316       __ bind(slow_lock_biased);
1317       __ sub(disp_hdr, FP, lock_slot_fp_offset);
1318     }
1319 
1320     __ bind(slow_lock);
1321 
1322     push_param_registers(masm, fp_regs_in_arguments);
1323 
1324     // last_Java_frame is already set, so do call_VM manually; no exception can occur
1325     __ mov(R0, sync_obj);
1326     __ mov(R1, disp_hdr);
1327     __ mov(R2, Rthread);
1328     __ call(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C));
1329 
1330     pop_param_registers(masm, fp_regs_in_arguments);
1331 
1332     __ b(lock_done);
1333 
1334     // Unlocking slow case
1335     __ bind(slow_unlock);
1336 
1337     push_result_registers(masm, ret_type);
1338 
1339     // Clear pending exception before reentering VM.
1340     // Can store the oop in register since it is a leaf call.
1341     assert_different_registers(Rtmp_save1, sync_obj, disp_hdr);
1342     __ ldr(Rtmp_save1, Address(Rthread, Thread::pending_exception_offset()));
1343     Register zero = __ zero_register(Rtemp);
1344     __ str(zero, Address(Rthread, Thread::pending_exception_offset()));
1345     __ mov(R0, sync_obj);
1346     __ mov(R1, disp_hdr);
1347     __ mov(R2, Rthread);
1348     __ call(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C));
1349     __ str(Rtmp_save1, Address(Rthread, Thread::pending_exception_offset()));
1350 
1351     pop_result_registers(masm, ret_type);
1352 
1353     __ b(unlock_done);
1354   }
1355 
1356   __ flush();
1357   return nmethod::new_native_nmethod(method,
1358                                      compile_id,
1359                                      masm-&gt;code(),
1360                                      vep_offset,
1361                                      frame_complete,
1362                                      stack_slots / VMRegImpl::slots_per_word,
1363                                      in_ByteSize(is_static ? klass_offset : receiver_offset),
1364                                      in_ByteSize(lock_slot_offset * VMRegImpl::stack_slot_size),
1365                                      oop_maps);
1366 }
1367 
1368 // this function returns the adjust size (in number of words) to a c2i adapter
1369 // activation for use during deoptimization
1370 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals) {
1371   int extra_locals_size = (callee_locals - callee_parameters) * Interpreter::stackElementWords;
1372   return extra_locals_size;
1373 }
1374 
1375 
1376 uint SharedRuntime::out_preserve_stack_slots() {
1377   return 0;
1378 }
1379 
1380 
1381 //------------------------------generate_deopt_blob----------------------------
1382 void SharedRuntime::generate_deopt_blob() {
1383   ResourceMark rm;
1384   CodeBuffer buffer(&quot;deopt_blob&quot;, 1024, 1024);
1385   int frame_size_in_words;
1386   OopMapSet* oop_maps;
1387   int reexecute_offset;
1388   int exception_in_tls_offset;
1389   int exception_offset;
1390 
1391   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
1392   Label cont;
1393   const Register Rkind   = R9; // caller-saved
1394   const Register Rublock = R6;
1395   const Register Rsender = altFP_7_11;
1396   assert_different_registers(Rkind, Rublock, Rsender, Rexception_obj, Rexception_pc, R0, R1, R2, R3, R8, Rtemp);
1397 
1398   address start = __ pc();
1399 
1400   oop_maps = new OopMapSet();
1401   // LR saved by caller (can be live in c2 method)
1402 
1403   // A deopt is a case where LR may be live in the c2 nmethod. So it&#39;s
1404   // not possible to call the deopt blob from the nmethod and pass the
1405   // address of the deopt handler of the nmethod in LR. What happens
1406   // now is that the caller of the deopt blob pushes the current
1407   // address so the deopt blob doesn&#39;t have to do it. This way LR can
1408   // be preserved, contains the live value from the nmethod and is
1409   // saved at R14/R30_offset here.
1410   OopMap* map = RegisterSaver::save_live_registers(masm, &amp;frame_size_in_words, true);
1411   __ mov(Rkind, Deoptimization::Unpack_deopt);
1412   __ b(cont);
1413 
1414   exception_offset = __ pc() - start;
1415 
1416   // Transfer Rexception_obj &amp; Rexception_pc in TLS and fall thru to the
1417   // exception_in_tls_offset entry point.
1418   __ str(Rexception_obj, Address(Rthread, JavaThread::exception_oop_offset()));
1419   __ str(Rexception_pc, Address(Rthread, JavaThread::exception_pc_offset()));
1420   // Force return value to NULL to avoid confusing the escape analysis
1421   // logic. Everything is dead here anyway.
1422   __ mov(R0, 0);
1423 
1424   exception_in_tls_offset = __ pc() - start;
1425 
1426   // Exception data is in JavaThread structure
1427   // Patch the return address of the current frame
1428   __ ldr(LR, Address(Rthread, JavaThread::exception_pc_offset()));
1429   (void) RegisterSaver::save_live_registers(masm, &amp;frame_size_in_words);
1430   {
1431     const Register Rzero = __ zero_register(Rtemp); // XXX should be OK for C2 but not 100% sure
1432     __ str(Rzero, Address(Rthread, JavaThread::exception_pc_offset()));
1433   }
1434   __ mov(Rkind, Deoptimization::Unpack_exception);
1435   __ b(cont);
1436 
1437   reexecute_offset = __ pc() - start;
1438 
1439   (void) RegisterSaver::save_live_registers(masm, &amp;frame_size_in_words);
1440   __ mov(Rkind, Deoptimization::Unpack_reexecute);
1441 
1442   // Calculate UnrollBlock and save the result in Rublock
1443   __ bind(cont);
1444   __ mov(R0, Rthread);
1445   __ mov(R1, Rkind);
1446 
1447   int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp); // note: FP may not need to be saved (not on x86)
1448   assert(((__ pc()) - start) == __ offset(), &quot;warning: start differs from code_begin&quot;);
1449   __ call(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info));
1450   if (pc_offset == -1) {
1451     pc_offset = __ offset();
1452   }
1453   oop_maps-&gt;add_gc_map(pc_offset, map);
1454   __ reset_last_Java_frame(Rtemp); // Rtemp free since scratched by far call
1455 
1456   __ mov(Rublock, R0);
1457 
1458   // Reload Rkind from the UnrollBlock (might have changed)
1459   __ ldr_s32(Rkind, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
1460   Label noException;
1461   __ cmp_32(Rkind, Deoptimization::Unpack_exception);   // Was exception pending?
1462   __ b(noException, ne);
1463   // handle exception case
1464 #ifdef ASSERT
1465   // assert that exception_pc is zero in tls
1466   { Label L;
1467     __ ldr(Rexception_pc, Address(Rthread, JavaThread::exception_pc_offset()));
1468     __ cbz(Rexception_pc, L);
1469     __ stop(&quot;exception pc should be null&quot;);
1470     __ bind(L);
1471   }
1472 #endif
1473   __ ldr(Rexception_obj, Address(Rthread, JavaThread::exception_oop_offset()));
1474   __ verify_oop(Rexception_obj);
1475   {
1476     const Register Rzero = __ zero_register(Rtemp);
1477     __ str(Rzero, Address(Rthread, JavaThread::exception_oop_offset()));
1478   }
1479 
1480   __ bind(noException);
1481 
1482   // This frame is going away.  Fetch return value, so we can move it to
1483   // a new frame.
1484   __ ldr(R0, Address(SP, RegisterSaver::R0_offset * wordSize));
1485   __ ldr(R1, Address(SP, RegisterSaver::R1_offset * wordSize));
1486 #ifndef __SOFTFP__
1487   __ ldr_double(D0, Address(SP, RegisterSaver::D0_offset * wordSize));
1488 #endif
1489   // pop frame
1490   __ add(SP, SP, RegisterSaver::reg_save_size * wordSize);
1491 
1492   // Set initial stack state before pushing interpreter frames
1493   __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
1494   __ ldr(R2, Address(Rublock, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
1495   __ ldr(R3, Address(Rublock, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
1496 
1497   __ add(SP, SP, Rtemp);
1498 
1499 #ifdef ASSERT
1500   // Compilers generate code that bang the stack by as much as the
1501   // interpreter would need. So this stack banging should never
1502   // trigger a fault. Verify that it does not on non product builds.
1503   // See if it is enough stack to push deoptimized frames
1504   if (UseStackBanging) {
1505     // The compiled method that we are deoptimizing was popped from the stack.
1506     // If the stack bang results in a stack overflow, we don&#39;t return to the
1507     // method that is being deoptimized. The stack overflow exception is
1508     // propagated to the caller of the deoptimized method. Need to get the pc
1509     // from the caller in LR and restore FP.
1510     __ ldr(LR, Address(R2, 0));
1511     __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
1512     __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
1513     __ arm_stack_overflow_check(R8, Rtemp);
1514   }
1515 #endif
1516   __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
1517 
1518   // Pick up the initial fp we should save
1519   // XXX Note: was ldr(FP, Address(FP));
1520 
1521   // The compiler no longer uses FP as a frame pointer for the
1522   // compiled code. It can be used by the allocator in C2 or to
1523   // memorize the original SP for JSR292 call sites.
1524 
1525   // Hence, ldr(FP, Address(FP)) is probably not correct. For x86,
1526   // Deoptimization::fetch_unroll_info computes the right FP value and
1527   // stores it in Rublock.initial_info. This has been activated for ARM.
1528   __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
1529 
1530   __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes()));
1531   __ mov(Rsender, SP);
1532   __ sub(SP, SP, Rtemp);
1533 
1534   // Push interpreter frames in a loop
1535   Label loop;
1536   __ bind(loop);
1537   __ ldr(LR, Address(R2, wordSize, post_indexed));         // load frame pc
1538   __ ldr(Rtemp, Address(R3, wordSize, post_indexed));      // load frame size
1539 
1540   __ raw_push(FP, LR);                                     // create new frame
1541   __ mov(FP, SP);
1542   __ sub(Rtemp, Rtemp, 2*wordSize);
1543 
1544   __ sub(SP, SP, Rtemp);
1545 
1546   __ str(Rsender, Address(FP, frame::interpreter_frame_sender_sp_offset * wordSize));
1547   __ mov(LR, 0);
1548   __ str(LR, Address(FP, frame::interpreter_frame_last_sp_offset * wordSize));
1549 
1550   __ subs(R8, R8, 1);                               // decrement counter
1551   __ mov(Rsender, SP);
1552   __ b(loop, ne);
1553 
1554   // Re-push self-frame
1555   __ ldr(LR, Address(R2));
1556   __ raw_push(FP, LR);
1557   __ mov(FP, SP);
1558   __ sub(SP, SP, (frame_size_in_words - 2) * wordSize);
1559 
1560   // Restore frame locals after moving the frame
1561   __ str(R0, Address(SP, RegisterSaver::R0_offset * wordSize));
1562   __ str(R1, Address(SP, RegisterSaver::R1_offset * wordSize));
1563 
1564 #ifndef __SOFTFP__
1565   __ str_double(D0, Address(SP, RegisterSaver::D0_offset * wordSize));
1566 #endif // !__SOFTFP__
1567 
1568 #ifdef ASSERT
1569   // Reload Rkind from the UnrollBlock and check that it was not overwritten (Rkind is not callee-saved)
1570   { Label L;
1571     __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
1572     __ cmp_32(Rkind, Rtemp);
1573     __ b(L, eq);
1574     __ stop(&quot;Rkind was overwritten&quot;);
1575     __ bind(L);
1576   }
1577 #endif
1578 
1579   // Call unpack_frames with proper arguments
1580   __ mov(R0, Rthread);
1581   __ mov(R1, Rkind);
1582 
1583   pc_offset = __ set_last_Java_frame(SP, FP, true, Rtemp);
1584   assert(((__ pc()) - start) == __ offset(), &quot;warning: start differs from code_begin&quot;);
1585   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames));
1586   if (pc_offset == -1) {
1587     pc_offset = __ offset();
1588   }
1589   oop_maps-&gt;add_gc_map(pc_offset, new OopMap(frame_size_in_words * VMRegImpl::slots_per_word, 0));
1590   __ reset_last_Java_frame(Rtemp); // Rtemp free since scratched by far call
1591 
1592   // Collect return values, pop self-frame and jump to interpreter
1593   __ ldr(R0, Address(SP, RegisterSaver::R0_offset * wordSize));
1594   __ ldr(R1, Address(SP, RegisterSaver::R1_offset * wordSize));
1595   // Interpreter floats controlled by __SOFTFP__, but compiler
1596   // float return value registers controlled by __ABI_HARD__
1597   // This matters for vfp-sflt builds.
1598 #ifndef __SOFTFP__
1599   // Interpreter hard float
1600 #ifdef __ABI_HARD__
1601   // Compiler float return value in FP registers
1602   __ ldr_double(D0, Address(SP, RegisterSaver::D0_offset * wordSize));
1603 #else
1604   // Compiler float return value in integer registers,
1605   // copy to D0 for interpreter (S0 &lt;-- R0)
1606   __ fmdrr(D0_tos, R0, R1);
1607 #endif
1608 #endif // !__SOFTFP__
1609   __ mov(SP, FP);
1610 
1611   __ pop(RegisterSet(FP) | RegisterSet(PC));
1612 
1613   __ flush();
1614 
1615   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset,
1616                                            reexecute_offset, frame_size_in_words);
1617   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
1618 }
1619 
1620 #ifdef COMPILER2
1621 
1622 //------------------------------generate_uncommon_trap_blob--------------------
1623 // Ought to generate an ideal graph &amp; compile, but here&#39;s some SPARC ASM
1624 // instead.
1625 void SharedRuntime::generate_uncommon_trap_blob() {
1626   // allocate space for the code
1627   ResourceMark rm;
1628 
1629   // setup code generation tools
1630   int pad = VerifyThread ? 512 : 0;
1631 #ifdef _LP64
1632   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2700+pad, 512);
1633 #else
1634   // Measured 8/7/03 at 660 in 32bit debug build (no VerifyThread)
1635   // Measured 8/7/03 at 1028 in 32bit debug build (VerifyThread)
1636   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2000+pad, 512);
1637 #endif
1638   // bypassed when code generation useless
1639   MacroAssembler* masm               = new MacroAssembler(&amp;buffer);
1640   const Register Rublock = R6;
1641   const Register Rsender = altFP_7_11;
1642   assert_different_registers(Rublock, Rsender, Rexception_obj, R0, R1, R2, R3, R8, Rtemp);
1643 
1644   //
1645   // This is the entry point for all traps the compiler takes when it thinks
1646   // it cannot handle further execution of compilation code. The frame is
1647   // deoptimized in these cases and converted into interpreter frames for
1648   // execution
1649   // The steps taken by this frame are as follows:
1650   //   - push a fake &quot;unpack_frame&quot;
1651   //   - call the C routine Deoptimization::uncommon_trap (this function
1652   //     packs the current compiled frame into vframe arrays and returns
1653   //     information about the number and size of interpreter frames which
1654   //     are equivalent to the frame which is being deoptimized)
1655   //   - deallocate the &quot;unpack_frame&quot;
1656   //   - deallocate the deoptimization frame
1657   //   - in a loop using the information returned in the previous step
1658   //     push interpreter frames;
1659   //   - create a dummy &quot;unpack_frame&quot;
1660   //   - call the C routine: Deoptimization::unpack_frames (this function
1661   //     lays out values on the interpreter frame which was just created)
1662   //   - deallocate the dummy unpack_frame
1663   //   - return to the interpreter entry point
1664   //
1665   //  Refer to the following methods for more information:
1666   //   - Deoptimization::uncommon_trap
1667   //   - Deoptimization::unpack_frame
1668 
1669   // the unloaded class index is in R0 (first parameter to this blob)
1670 
1671   __ raw_push(FP, LR);
1672   __ set_last_Java_frame(SP, FP, false, Rtemp);
1673   __ mov(R2, Deoptimization::Unpack_uncommon_trap);
1674   __ mov(R1, R0);
1675   __ mov(R0, Rthread);
1676   __ call(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap));
1677   __ mov(Rublock, R0);
1678   __ reset_last_Java_frame(Rtemp);
1679   __ raw_pop(FP, LR);
1680 
1681 #ifdef ASSERT
1682   { Label L;
1683     __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
1684     __ cmp_32(Rtemp, Deoptimization::Unpack_uncommon_trap);
1685     __ b(L, eq);
1686     __ stop(&quot;SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap&quot;);
1687     __ bind(L);
1688   }
1689 #endif
1690 
1691 
1692   // Set initial stack state before pushing interpreter frames
1693   __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
1694   __ ldr(R2, Address(Rublock, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
1695   __ ldr(R3, Address(Rublock, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
1696 
1697   __ add(SP, SP, Rtemp);
1698 
1699   // See if it is enough stack to push deoptimized frames
1700 #ifdef ASSERT
1701   // Compilers generate code that bang the stack by as much as the
1702   // interpreter would need. So this stack banging should never
1703   // trigger a fault. Verify that it does not on non product builds.
1704   if (UseStackBanging) {
1705     // The compiled method that we are deoptimizing was popped from the stack.
1706     // If the stack bang results in a stack overflow, we don&#39;t return to the
1707     // method that is being deoptimized. The stack overflow exception is
1708     // propagated to the caller of the deoptimized method. Need to get the pc
1709     // from the caller in LR and restore FP.
1710     __ ldr(LR, Address(R2, 0));
1711     __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
1712     __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
1713     __ arm_stack_overflow_check(R8, Rtemp);
1714   }
1715 #endif
1716   __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
1717   __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes()));
1718   __ mov(Rsender, SP);
1719   __ sub(SP, SP, Rtemp);
1720   //  __ ldr(FP, Address(FP));
1721   __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
1722 
1723   // Push interpreter frames in a loop
1724   Label loop;
1725   __ bind(loop);
1726   __ ldr(LR, Address(R2, wordSize, post_indexed));         // load frame pc
1727   __ ldr(Rtemp, Address(R3, wordSize, post_indexed));      // load frame size
1728 
1729   __ raw_push(FP, LR);                                     // create new frame
1730   __ mov(FP, SP);
1731   __ sub(Rtemp, Rtemp, 2*wordSize);
1732 
1733   __ sub(SP, SP, Rtemp);
1734 
1735   __ str(Rsender, Address(FP, frame::interpreter_frame_sender_sp_offset * wordSize));
1736   __ mov(LR, 0);
1737   __ str(LR, Address(FP, frame::interpreter_frame_last_sp_offset * wordSize));
1738   __ subs(R8, R8, 1);                               // decrement counter
1739   __ mov(Rsender, SP);
1740   __ b(loop, ne);
1741 
1742   // Re-push self-frame
1743   __ ldr(LR, Address(R2));
1744   __ raw_push(FP, LR);
1745   __ mov(FP, SP);
1746 
1747   // Call unpack_frames with proper arguments
1748   __ mov(R0, Rthread);
1749   __ mov(R1, Deoptimization::Unpack_uncommon_trap);
1750   __ set_last_Java_frame(SP, FP, true, Rtemp);
1751   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames));
1752   //  oop_maps-&gt;add_gc_map(__ pc() - start, new OopMap(frame_size_in_words, 0));
1753   __ reset_last_Java_frame(Rtemp);
1754 
1755   __ mov(SP, FP);
1756   __ pop(RegisterSet(FP) | RegisterSet(PC));
1757 
1758   masm-&gt;flush();
1759   _uncommon_trap_blob = UncommonTrapBlob::create(&amp;buffer, NULL, 2 /* LR+FP */);
1760 }
1761 
1762 #endif // COMPILER2
1763 
1764 //------------------------------generate_handler_blob------
1765 //
1766 // Generate a special Compile2Runtime blob that saves all registers,
1767 // setup oopmap, and calls safepoint code to stop the compiled code for
1768 // a safepoint.
1769 //
1770 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
1771   assert(StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
1772 
1773   ResourceMark rm;
1774   CodeBuffer buffer(&quot;handler_blob&quot;, 256, 256);
1775   int frame_size_words;
1776   OopMapSet* oop_maps;
1777 
1778   bool cause_return = (poll_type == POLL_AT_RETURN);
1779 
1780   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
1781   address start = __ pc();
1782   oop_maps = new OopMapSet();
1783 
1784   if (!cause_return) {
1785     __ sub(SP, SP, 4); // make room for LR which may still be live
1786                        // here if we are coming from a c2 method
1787   }
1788 
1789   OopMap* map = RegisterSaver::save_live_registers(masm, &amp;frame_size_words, !cause_return);
1790   if (!cause_return) {
1791     // update saved PC with correct value
1792     // need 2 steps because LR can be live in c2 method
1793     __ ldr(LR, Address(Rthread, JavaThread::saved_exception_pc_offset()));
1794     __ str(LR, Address(SP, RegisterSaver::LR_offset * wordSize));
1795   }
1796 
1797   __ mov(R0, Rthread);
1798   int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp); // note: FP may not need to be saved (not on x86)
1799   assert(((__ pc()) - start) == __ offset(), &quot;warning: start differs from code_begin&quot;);
1800   __ call(call_ptr);
1801   if (pc_offset == -1) {
1802     pc_offset = __ offset();
1803   }
1804   oop_maps-&gt;add_gc_map(pc_offset, map);
1805   __ reset_last_Java_frame(Rtemp); // Rtemp free since scratched by far call
1806 
1807   // Check for pending exception
1808   __ ldr(Rtemp, Address(Rthread, Thread::pending_exception_offset()));
1809   __ cmp(Rtemp, 0);
1810 
1811   if (!cause_return) {
1812     RegisterSaver::restore_live_registers(masm, false);
1813     __ pop(PC, eq);
1814     __ pop(Rexception_pc);
1815   } else {
1816     RegisterSaver::restore_live_registers(masm);
1817     __ bx(LR, eq);
1818     __ mov(Rexception_pc, LR);
1819   }
1820 
1821   __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);
1822 
1823   __ flush();
1824 
1825   return SafepointBlob::create(&amp;buffer, oop_maps, frame_size_words);
1826 }
1827 
1828 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
1829   assert(StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
1830 
1831   ResourceMark rm;
1832   CodeBuffer buffer(name, 1000, 512);
1833   int frame_size_words;
1834   OopMapSet *oop_maps;
1835   int frame_complete;
1836 
1837   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
1838   Label pending_exception;
1839 
1840   int start = __ offset();
1841 
1842   oop_maps = new OopMapSet();
1843   OopMap* map = RegisterSaver::save_live_registers(masm, &amp;frame_size_words);
1844 
1845   frame_complete = __ offset();
1846 
1847   __ mov(R0, Rthread);
1848 
1849   int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);
1850   assert(start == 0, &quot;warning: start differs from code_begin&quot;);
1851   __ call(destination);
1852   if (pc_offset == -1) {
1853     pc_offset = __ offset();
1854   }
1855   oop_maps-&gt;add_gc_map(pc_offset, map);
1856   __ reset_last_Java_frame(Rtemp); // Rtemp free since scratched by far call
1857 
1858   __ ldr(R1, Address(Rthread, Thread::pending_exception_offset()));
1859   __ cbnz(R1, pending_exception);
1860 
1861   // Overwrite saved register values
1862 
1863   // Place metadata result of VM call into Rmethod
1864   __ get_vm_result_2(R1, Rtemp);
1865   __ str(R1, Address(SP, RegisterSaver::Rmethod_offset * wordSize));
1866 
1867   // Place target address (VM call result) into Rtemp
1868   __ str(R0, Address(SP, RegisterSaver::Rtemp_offset * wordSize));
1869 
1870   RegisterSaver::restore_live_registers(masm);
1871   __ jump(Rtemp);
1872 
1873   __ bind(pending_exception);
1874 
1875   RegisterSaver::restore_live_registers(masm);
1876   const Register Rzero = __ zero_register(Rtemp);
1877   __ str(Rzero, Address(Rthread, JavaThread::vm_result_2_offset()));
1878   __ mov(Rexception_pc, LR);
1879   __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);
1880 
1881   __ flush();
1882 
1883   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_words, oop_maps, true);
1884 }
    </pre>
  </body>
</html>
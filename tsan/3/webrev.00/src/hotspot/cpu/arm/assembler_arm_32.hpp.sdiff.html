<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/assembler_arm_32.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arm_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_CodeStubs_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/assembler_arm_32.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 182 
 183   int encoding_s() const {
 184     return _encoding;
 185   }
 186 
 187   int encoding_d() const {
 188     assert((_encoding &amp; 0xFF) &lt;= 16, &quot;no more than 16 double registers&quot; );
 189     return (_encoding &amp; 0xFFFFFF00) | ((_encoding &amp; 0xFF) &lt;&lt; 1);
 190   }
 191 
 192 };
 193 
 194 
 195 class Assembler : public AbstractAssembler  {
 196 
 197  public:
 198 
 199   static const int LogInstructionSize = 2;
 200   static const int InstructionSize    = 1 &lt;&lt; LogInstructionSize;
 201 








 202   static inline AsmCondition inverse(AsmCondition cond) {
 203     assert ((cond != al) &amp;&amp; (cond != nv), &quot;AL and NV conditions cannot be inversed&quot;);
 204     return (AsmCondition)((int)cond ^ 1);
 205   }
 206 
 207   // Returns true if given value can be used as immediate in arithmetic (add/sub/cmp/cmn) instructions.
 208   static inline bool is_arith_imm_in_range(intx value) {
 209     return AsmOperand::is_rotated_imm(value);
 210   }
 211 
 212   // Arithmetic instructions
 213 
 214 #define F(mnemonic, opcode) \
 215   void mnemonic(Register rd, Register rn, AsmOperand operand, AsmCondition cond = al) {    \
 216     emit_int32(cond &lt;&lt; 28 | opcode &lt;&lt; 21 | rn-&gt;encoding() &lt;&lt; 16 |                          \
 217                rd-&gt;encoding() &lt;&lt; 12 | operand.encoding());                                 \
 218   }                                                                                        \
 219   void mnemonic##s(Register rd, Register rn, AsmOperand operand, AsmCondition cond = al) { \
 220     emit_int32(cond &lt;&lt; 28 | opcode &lt;&lt; 21 | 1 &lt;&lt; 20 | rn-&gt;encoding() &lt;&lt; 16 |                \
 221                rd-&gt;encoding() &lt;&lt; 12 | operand.encoding());                                 \
</pre>
<hr />
<pre>
 417     emit_int32(cond &lt;&lt; 28 | 0x06bf0f30 | rd-&gt;encoding() &lt;&lt; 12 | rm-&gt;encoding());
 418   }
 419 
 420   void rev16(Register rd, Register rm, AsmCondition cond = al) {
 421     emit_int32(cond &lt;&lt; 28 | 0x6bf0fb0 | rd-&gt;encoding() &lt;&lt; 12 | rm-&gt;encoding());
 422   }
 423 
 424   void revsh(Register rd, Register rm, AsmCondition cond = al) {
 425     emit_int32(cond &lt;&lt; 28 | 0x6ff0fb0 | rd-&gt;encoding() &lt;&lt; 12 | rm-&gt;encoding());
 426   }
 427 
 428   void rbit(Register rd, Register rm, AsmCondition cond = al) {
 429     emit_int32(cond &lt;&lt; 28 | 0x6ff0f30 | rd-&gt;encoding() &lt;&lt; 12 | rm-&gt;encoding());
 430   }
 431 
 432   void pld(Address addr) {
 433     emit_int32(0xf550f000 | addr.encoding2());
 434   }
 435 
 436   void pldw(Address addr) {
<span class="line-modified"> 437     assert(VM_Version::arm_arch() &gt;= 7 &amp;&amp; os::is_MP(), &quot;no pldw on this processor&quot;);</span>


 438     emit_int32(0xf510f000 | addr.encoding2());
 439   }
 440 
 441   void svc(int imm_24, AsmCondition cond = al) {
 442     assert((imm_24 &gt;&gt; 24) == 0, &quot;encoding constraint&quot;);
 443     emit_int32(cond &lt;&lt; 28 | 0xf &lt;&lt; 24 | imm_24);
 444   }
 445 
 446   void ubfx(Register rd, Register rn, unsigned int lsb, unsigned int width, AsmCondition cond = al) {
 447     assert(VM_Version::arm_arch() &gt;= 7, &quot;no ubfx on this processor&quot;);
 448     assert(width &gt; 0, &quot;must be&quot;);
 449     assert(lsb &lt; 32, &quot;must be&quot;);
 450     emit_int32(cond &lt;&lt; 28 | 0x3f &lt;&lt; 21 | (width - 1)  &lt;&lt; 16 | rd-&gt;encoding() &lt;&lt; 12 |
 451               lsb &lt;&lt; 7 | 0x5 &lt;&lt; 4 | rn-&gt;encoding());
 452   }
 453 
 454   void uxtb(Register rd, Register rm, unsigned int rotation = 0, AsmCondition cond = al) {
 455     assert(VM_Version::arm_arch() &gt;= 7, &quot;no uxtb on this processor&quot;);
 456     assert((rotation % 8) == 0 &amp;&amp; (rotation &lt;= 24), &quot;encoding constraint&quot;);
 457     emit_int32(cond &lt;&lt; 28 | 0x6e &lt;&lt; 20 | 0xf &lt;&lt; 16 | rd-&gt;encoding() &lt;&lt; 12 |
</pre>
<hr />
<pre>
 936   void mnemonic##d(Register rn, FloatRegisterSet reg_set,                    \
 937                    AsmWriteback w = no_writeback, AsmCondition cond = al) {  \
 938     CHECK_VFP_PRESENT;                                                       \
 939     assert(w == no_writeback || rn != PC, &quot;unpredictable instruction&quot;);      \
 940     assert(!(w == no_writeback &amp;&amp; pu == 2), &quot;encoding constraint&quot;);          \
 941     assert((reg_set.encoding_d() &amp; 1) == 0, &quot;encoding constraint&quot;);          \
 942     emit_int32(cond &lt;&lt; 28 | 6 &lt;&lt; 25 | pu &lt;&lt; 23 | w &lt;&lt; 21 | l &lt;&lt; 20 |         \
 943               rn-&gt;encoding() &lt;&lt; 16 | reg_set.encoding_d() | double_cp_num);  \
 944   }                                                                          \
 945   void mnemonic##s(Register rn, FloatRegisterSet reg_set,                    \
 946                    AsmWriteback w = no_writeback, AsmCondition cond = al) {  \
 947     CHECK_VFP_PRESENT;                                                       \
 948     assert(w == no_writeback || rn != PC, &quot;unpredictable instruction&quot;);      \
 949     assert(!(w == no_writeback &amp;&amp; pu == 2), &quot;encoding constraint&quot;);          \
 950     emit_int32(cond &lt;&lt; 28 | 6 &lt;&lt; 25 | pu &lt;&lt; 23 | w &lt;&lt; 21 | l &lt;&lt; 20 |         \
 951               rn-&gt;encoding() &lt;&lt; 16 | reg_set.encoding_s() | single_cp_num);  \
 952   }
 953 
 954   F(fldmia, 1, 1)    F(fldmfd, 1, 1)
 955   F(fldmdb, 1, 2)    F(fldmea, 1, 2)
<span class="line-modified"> 956   F(fstmia, 0, 1)    F(fstmfd, 0, 1)</span>
<span class="line-modified"> 957   F(fstmdb, 0, 2)    F(fstmea, 0, 2)</span>
 958 #undef F
 959 
 960   // fconst{s,d} encoding:
 961   //  31  28 27   23 22  21 20 19   16 15 12 10  9  8   7    4 3     0
 962   // | cond | 11101 | D | 11  | imm4H | Vd  | 101 | sz | 0000 | imm4L |
 963   // sz = 0 for single precision, 1 otherwise
 964   // Register number is Vd:D for single precision, D:Vd otherwise
 965   // immediate value is imm4H:imm4L
 966 
 967   void fconsts(FloatRegister fd, unsigned char imm_8, AsmCondition cond = al) {
 968     CHECK_VFP_PRESENT;
 969     assert(fd-&gt;hi_bit() == 0, &quot;double precision register?&quot;);
 970     emit_int32(cond &lt;&lt; 28 | 0xeb &lt;&lt; 20 | single_cp_num |
 971               fd-&gt;hi_bits() &lt;&lt; 12 | fd-&gt;lo_bit() &lt;&lt; 22 | (imm_8 &amp; 0xf) | (imm_8 &gt;&gt; 4) &lt;&lt; 16);
 972   }
 973 
 974   void fconstd(FloatRegister fd, unsigned char imm_8, AsmCondition cond = al) {
 975     CHECK_VFP_PRESENT;
 976     assert(fd-&gt;lo_bit() == 0, &quot;double precision register?&quot;);
 977     emit_int32(cond &lt;&lt; 28 | 0xeb &lt;&lt; 20 | double_cp_num |
</pre>
</td>
<td>
<hr />
<pre>
 182 
 183   int encoding_s() const {
 184     return _encoding;
 185   }
 186 
 187   int encoding_d() const {
 188     assert((_encoding &amp; 0xFF) &lt;= 16, &quot;no more than 16 double registers&quot; );
 189     return (_encoding &amp; 0xFFFFFF00) | ((_encoding &amp; 0xFF) &lt;&lt; 1);
 190   }
 191 
 192 };
 193 
 194 
 195 class Assembler : public AbstractAssembler  {
 196 
 197  public:
 198 
 199   static const int LogInstructionSize = 2;
 200   static const int InstructionSize    = 1 &lt;&lt; LogInstructionSize;
 201 
<span class="line-added"> 202   //---&lt;  calculate length of instruction  &gt;---</span>
<span class="line-added"> 203   // We just use the values set above.</span>
<span class="line-added"> 204   // instruction must start at passed address</span>
<span class="line-added"> 205   static unsigned int instr_len(unsigned char *instr) { return InstructionSize; }</span>
<span class="line-added"> 206 </span>
<span class="line-added"> 207   //---&lt;  longest instructions  &gt;---</span>
<span class="line-added"> 208   static unsigned int instr_maxlen() { return InstructionSize; }</span>
<span class="line-added"> 209 </span>
 210   static inline AsmCondition inverse(AsmCondition cond) {
 211     assert ((cond != al) &amp;&amp; (cond != nv), &quot;AL and NV conditions cannot be inversed&quot;);
 212     return (AsmCondition)((int)cond ^ 1);
 213   }
 214 
 215   // Returns true if given value can be used as immediate in arithmetic (add/sub/cmp/cmn) instructions.
 216   static inline bool is_arith_imm_in_range(intx value) {
 217     return AsmOperand::is_rotated_imm(value);
 218   }
 219 
 220   // Arithmetic instructions
 221 
 222 #define F(mnemonic, opcode) \
 223   void mnemonic(Register rd, Register rn, AsmOperand operand, AsmCondition cond = al) {    \
 224     emit_int32(cond &lt;&lt; 28 | opcode &lt;&lt; 21 | rn-&gt;encoding() &lt;&lt; 16 |                          \
 225                rd-&gt;encoding() &lt;&lt; 12 | operand.encoding());                                 \
 226   }                                                                                        \
 227   void mnemonic##s(Register rd, Register rn, AsmOperand operand, AsmCondition cond = al) { \
 228     emit_int32(cond &lt;&lt; 28 | opcode &lt;&lt; 21 | 1 &lt;&lt; 20 | rn-&gt;encoding() &lt;&lt; 16 |                \
 229                rd-&gt;encoding() &lt;&lt; 12 | operand.encoding());                                 \
</pre>
<hr />
<pre>
 425     emit_int32(cond &lt;&lt; 28 | 0x06bf0f30 | rd-&gt;encoding() &lt;&lt; 12 | rm-&gt;encoding());
 426   }
 427 
 428   void rev16(Register rd, Register rm, AsmCondition cond = al) {
 429     emit_int32(cond &lt;&lt; 28 | 0x6bf0fb0 | rd-&gt;encoding() &lt;&lt; 12 | rm-&gt;encoding());
 430   }
 431 
 432   void revsh(Register rd, Register rm, AsmCondition cond = al) {
 433     emit_int32(cond &lt;&lt; 28 | 0x6ff0fb0 | rd-&gt;encoding() &lt;&lt; 12 | rm-&gt;encoding());
 434   }
 435 
 436   void rbit(Register rd, Register rm, AsmCondition cond = al) {
 437     emit_int32(cond &lt;&lt; 28 | 0x6ff0f30 | rd-&gt;encoding() &lt;&lt; 12 | rm-&gt;encoding());
 438   }
 439 
 440   void pld(Address addr) {
 441     emit_int32(0xf550f000 | addr.encoding2());
 442   }
 443 
 444   void pldw(Address addr) {
<span class="line-modified"> 445     assert(!VM_Version::is_initialized() ||</span>
<span class="line-added"> 446            (VM_Version::arm_arch() &gt;= 7 &amp;&amp; VM_Version::has_multiprocessing_extensions()),</span>
<span class="line-added"> 447            &quot;PLDW is available on ARMv7 with Multiprocessing Extensions only&quot;);</span>
 448     emit_int32(0xf510f000 | addr.encoding2());
 449   }
 450 
 451   void svc(int imm_24, AsmCondition cond = al) {
 452     assert((imm_24 &gt;&gt; 24) == 0, &quot;encoding constraint&quot;);
 453     emit_int32(cond &lt;&lt; 28 | 0xf &lt;&lt; 24 | imm_24);
 454   }
 455 
 456   void ubfx(Register rd, Register rn, unsigned int lsb, unsigned int width, AsmCondition cond = al) {
 457     assert(VM_Version::arm_arch() &gt;= 7, &quot;no ubfx on this processor&quot;);
 458     assert(width &gt; 0, &quot;must be&quot;);
 459     assert(lsb &lt; 32, &quot;must be&quot;);
 460     emit_int32(cond &lt;&lt; 28 | 0x3f &lt;&lt; 21 | (width - 1)  &lt;&lt; 16 | rd-&gt;encoding() &lt;&lt; 12 |
 461               lsb &lt;&lt; 7 | 0x5 &lt;&lt; 4 | rn-&gt;encoding());
 462   }
 463 
 464   void uxtb(Register rd, Register rm, unsigned int rotation = 0, AsmCondition cond = al) {
 465     assert(VM_Version::arm_arch() &gt;= 7, &quot;no uxtb on this processor&quot;);
 466     assert((rotation % 8) == 0 &amp;&amp; (rotation &lt;= 24), &quot;encoding constraint&quot;);
 467     emit_int32(cond &lt;&lt; 28 | 0x6e &lt;&lt; 20 | 0xf &lt;&lt; 16 | rd-&gt;encoding() &lt;&lt; 12 |
</pre>
<hr />
<pre>
 946   void mnemonic##d(Register rn, FloatRegisterSet reg_set,                    \
 947                    AsmWriteback w = no_writeback, AsmCondition cond = al) {  \
 948     CHECK_VFP_PRESENT;                                                       \
 949     assert(w == no_writeback || rn != PC, &quot;unpredictable instruction&quot;);      \
 950     assert(!(w == no_writeback &amp;&amp; pu == 2), &quot;encoding constraint&quot;);          \
 951     assert((reg_set.encoding_d() &amp; 1) == 0, &quot;encoding constraint&quot;);          \
 952     emit_int32(cond &lt;&lt; 28 | 6 &lt;&lt; 25 | pu &lt;&lt; 23 | w &lt;&lt; 21 | l &lt;&lt; 20 |         \
 953               rn-&gt;encoding() &lt;&lt; 16 | reg_set.encoding_d() | double_cp_num);  \
 954   }                                                                          \
 955   void mnemonic##s(Register rn, FloatRegisterSet reg_set,                    \
 956                    AsmWriteback w = no_writeback, AsmCondition cond = al) {  \
 957     CHECK_VFP_PRESENT;                                                       \
 958     assert(w == no_writeback || rn != PC, &quot;unpredictable instruction&quot;);      \
 959     assert(!(w == no_writeback &amp;&amp; pu == 2), &quot;encoding constraint&quot;);          \
 960     emit_int32(cond &lt;&lt; 28 | 6 &lt;&lt; 25 | pu &lt;&lt; 23 | w &lt;&lt; 21 | l &lt;&lt; 20 |         \
 961               rn-&gt;encoding() &lt;&lt; 16 | reg_set.encoding_s() | single_cp_num);  \
 962   }
 963 
 964   F(fldmia, 1, 1)    F(fldmfd, 1, 1)
 965   F(fldmdb, 1, 2)    F(fldmea, 1, 2)
<span class="line-modified"> 966   F(fstmia, 0, 1)    F(fstmea, 0, 1)</span>
<span class="line-modified"> 967   F(fstmdb, 0, 2)    F(fstmfd, 0, 2)</span>
 968 #undef F
 969 
 970   // fconst{s,d} encoding:
 971   //  31  28 27   23 22  21 20 19   16 15 12 10  9  8   7    4 3     0
 972   // | cond | 11101 | D | 11  | imm4H | Vd  | 101 | sz | 0000 | imm4L |
 973   // sz = 0 for single precision, 1 otherwise
 974   // Register number is Vd:D for single precision, D:Vd otherwise
 975   // immediate value is imm4H:imm4L
 976 
 977   void fconsts(FloatRegister fd, unsigned char imm_8, AsmCondition cond = al) {
 978     CHECK_VFP_PRESENT;
 979     assert(fd-&gt;hi_bit() == 0, &quot;double precision register?&quot;);
 980     emit_int32(cond &lt;&lt; 28 | 0xeb &lt;&lt; 20 | single_cp_num |
 981               fd-&gt;hi_bits() &lt;&lt; 12 | fd-&gt;lo_bit() &lt;&lt; 22 | (imm_8 &amp; 0xf) | (imm_8 &gt;&gt; 4) &lt;&lt; 16);
 982   }
 983 
 984   void fconstd(FloatRegister fd, unsigned char imm_8, AsmCondition cond = al) {
 985     CHECK_VFP_PRESENT;
 986     assert(fd-&gt;lo_bit() == 0, &quot;double precision register?&quot;);
 987     emit_int32(cond &lt;&lt; 28 | 0xeb &lt;&lt; 20 | double_cp_num |
</pre>
</td>
</tr>
</table>
<center><a href="arm_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_CodeStubs_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
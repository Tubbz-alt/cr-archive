<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/macroAssembler_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jniFastGetField_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_arm.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/macroAssembler_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  29 #include &quot;ci/ciEnv.hpp&quot;
  30 #include &quot;code/nativeInst.hpp&quot;
  31 #include &quot;compiler/disassembler.hpp&quot;
  32 #include &quot;gc/shared/barrierSet.hpp&quot;
  33 #include &quot;gc/shared/cardTable.hpp&quot;
  34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  35 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  36 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;oops/accessDecorators.hpp&quot;
  40 #include &quot;oops/klass.inline.hpp&quot;
  41 #include &quot;prims/methodHandles.hpp&quot;
  42 #include &quot;runtime/biasedLocking.hpp&quot;
  43 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  44 #include &quot;runtime/objectMonitor.hpp&quot;
  45 #include &quot;runtime/os.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;runtime/stubRoutines.hpp&quot;
  48 #include &quot;utilities/macros.hpp&quot;

  49 
  50 // Implementation of AddressLiteral
  51 
  52 void AddressLiteral::set_rspec(relocInfo::relocType rtype) {
  53   switch (rtype) {
  54   case relocInfo::oop_type:
  55     // Oops are a special case. Normally they would be their own section
  56     // but in cases like icBuffer they are literals in the code stream that
  57     // we don&#39;t have a section for. We use none so that we get a literal address
  58     // which is always patchable.
  59     break;
  60   case relocInfo::external_word_type:
  61     _rspec = external_word_Relocation::spec(_target);
  62     break;
  63   case relocInfo::internal_word_type:
  64     _rspec = internal_word_Relocation::spec(_target);
  65     break;
  66   case relocInfo::opt_virtual_call_type:
  67     _rspec = opt_virtual_call_Relocation::spec();
  68     break;
</pre>
<hr />
<pre>
1328                                          BiasedLockingCounters* counters) {
1329   // obj_reg must be preserved (at least) if the bias locking fails
1330   // tmp_reg is a temporary register
1331   // swap_reg was used as a temporary but contained a value
1332   //   that was used afterwards in some call pathes. Callers
1333   //   have been fixed so that swap_reg no longer needs to be
1334   //   saved.
1335   // Rtemp in no longer scratched
1336 
1337   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1338   assert_different_registers(obj_reg, swap_reg, tmp_reg, tmp2);
1339   guarantee(swap_reg!=tmp_reg, &quot;invariant&quot;);
1340   assert(tmp_reg != noreg, &quot;must supply tmp_reg&quot;);
1341 
1342 #ifndef PRODUCT
1343   if (PrintBiasedLockingStatistics &amp;&amp; (counters == NULL)) {
1344     counters = BiasedLocking::counters();
1345   }
1346 #endif
1347 
<span class="line-modified">1348   assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);</span>
1349   Address mark_addr(obj_reg, oopDesc::mark_offset_in_bytes());
1350 
1351   // Biased locking
1352   // See whether the lock is currently biased toward our thread and
1353   // whether the epoch is still valid
1354   // Note that the runtime guarantees sufficient alignment of JavaThread
1355   // pointers to allow age to be placed into low bits
1356   // First check to see whether biasing is even enabled for this object
1357   Label cas_label;
1358 
1359   // The null check applies to the mark loading, if we need to load it.
1360   // If the mark has already been loaded in swap_reg then it has already
1361   // been performed and the offset is irrelevant.
1362   int null_check_offset = offset();
1363   if (!swap_reg_contains_mark) {
1364     ldr(swap_reg, mark_addr);
1365   }
1366 
1367   // On MP platform loads could return &#39;stale&#39; values in some cases.
1368   // That is acceptable since either CAS or slow case path is taken in the worst case.
1369 
<span class="line-modified">1370   andr(tmp_reg, swap_reg, (uintx)markOopDesc::biased_lock_mask_in_place);</span>
<span class="line-modified">1371   cmp(tmp_reg, markOopDesc::biased_lock_pattern);</span>
1372 
1373   b(cas_label, ne);
1374 
1375   // The bias pattern is present in the object&#39;s header. Need to check
1376   // whether the bias owner and the epoch are both still current.
1377   load_klass(tmp_reg, obj_reg);
1378   ldr(tmp_reg, Address(tmp_reg, Klass::prototype_header_offset()));
1379   orr(tmp_reg, tmp_reg, Rthread);
1380   eor(tmp_reg, tmp_reg, swap_reg);
1381 
<span class="line-modified">1382   bics(tmp_reg, tmp_reg, ((int) markOopDesc::age_mask_in_place));</span>
1383 
1384 #ifndef PRODUCT
1385   if (counters != NULL) {
1386     cond_atomic_inc32(eq, counters-&gt;biased_lock_entry_count_addr());
1387   }
1388 #endif // !PRODUCT
1389 
1390   b(done, eq);
1391 
1392   Label try_revoke_bias;
1393   Label try_rebias;
1394 
1395   // At this point we know that the header has the bias pattern and
1396   // that we are not the bias owner in the current epoch. We need to
1397   // figure out more details about the state of the header in order to
1398   // know what operations can be legally performed on the object&#39;s
1399   // header.
1400 
1401   // If the low three bits in the xor result aren&#39;t clear, that means
1402   // the prototype header is no longer biased and we have to revoke
1403   // the bias on this object.
<span class="line-modified">1404   tst(tmp_reg, (uintx)markOopDesc::biased_lock_mask_in_place);</span>
1405   b(try_revoke_bias, ne);
1406 
1407   // Biasing is still enabled for this data type. See whether the
1408   // epoch of the current bias is still valid, meaning that the epoch
1409   // bits of the mark word are equal to the epoch bits of the
1410   // prototype header. (Note that the prototype header&#39;s epoch bits
1411   // only change at a safepoint.) If not, attempt to rebias the object
1412   // toward the current thread. Note that we must be absolutely sure
1413   // that the current epoch is invalid in order to do this because
1414   // otherwise the manipulations it performs on the mark word are
1415   // illegal.
<span class="line-modified">1416   tst(tmp_reg, (uintx)markOopDesc::epoch_mask_in_place);</span>
1417   b(try_rebias, ne);
1418 
1419   // tmp_reg has the age, epoch and pattern bits cleared
1420   // The remaining (owner) bits are (Thread ^ current_owner)
1421 
1422   // The epoch of the current bias is still valid but we know nothing
1423   // about the owner; it might be set or it might be clear. Try to
1424   // acquire the bias of the object using an atomic operation. If this
1425   // fails we will go in to the runtime to revoke the object&#39;s bias.
1426   // Note that we first construct the presumed unbiased header so we
1427   // don&#39;t accidentally blow away another thread&#39;s valid bias.
1428 
1429   // Note that we know the owner is not ourself. Hence, success can
1430   // only happen when the owner bits is 0
1431 
1432   // until the assembler can be made smarter, we need to make some assumptions about the values
1433   // so we can optimize this:
<span class="line-modified">1434   assert((markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place) == 0x1ff, &quot;biased bitmasks changed&quot;);</span>
1435 
1436   mov(swap_reg, AsmOperand(swap_reg, lsl, 23));
<span class="line-modified">1437   mov(swap_reg, AsmOperand(swap_reg, lsr, 23)); // markOop with thread bits cleared (for CAS)</span>
1438 
1439   orr(tmp_reg, swap_reg, Rthread); // new mark
1440 
1441   biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, slow_case,
1442         (counters != NULL) ? counters-&gt;anonymously_biased_lock_entry_count_addr() : NULL);
1443 
1444   // If the biasing toward our thread failed, this means that
1445   // another thread succeeded in biasing it toward itself and we
1446   // need to revoke that bias. The revocation will occur in the
1447   // interpreter runtime in the slow case.
1448 
1449   b(done);
1450 
1451   bind(try_rebias);
1452 
1453   // At this point we know the epoch has expired, meaning that the
1454   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
1455   // circumstances _only_, we are allowed to use the current header&#39;s
1456   // value as the comparison value when doing the cas to acquire the
1457   // bias in the current epoch. In other words, we allow transfer of
</pre>
<hr />
<pre>
1502   // the result of the above CAS, some thread must have succeeded in
1503   // removing the bias bit from the object&#39;s header.
1504 
1505   bind(cas_label);
1506 
1507   return null_check_offset;
1508 }
1509 
1510 
1511 void MacroAssembler::biased_locking_exit(Register obj_reg, Register tmp_reg, Label&amp; done) {
1512   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1513 
1514   // Check for biased locking unlock case, which is a no-op
1515   // Note: we do not have to check the thread ID for two reasons.
1516   // First, the interpreter checks for IllegalMonitorStateException at
1517   // a higher level. Second, if the bias was revoked while we held the
1518   // lock, the object could not be rebiased toward another thread, so
1519   // the bias bit would be clear.
1520   ldr(tmp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1521 
<span class="line-modified">1522   andr(tmp_reg, tmp_reg, (uintx)markOopDesc::biased_lock_mask_in_place);</span>
<span class="line-modified">1523   cmp(tmp_reg, markOopDesc::biased_lock_pattern);</span>
1524   b(done, eq);
1525 }
1526 
1527 
1528 void MacroAssembler::resolve_jobject(Register value,
1529                                      Register tmp1,
1530                                      Register tmp2) {
1531   assert_different_registers(value, tmp1, tmp2);
1532   Label done, not_weak;
1533   cbz(value, done);             // Use NULL as-is.
1534   STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);
1535   tbz(value, 0, not_weak);      // Test for jweak tag.
1536 
1537   // Resolve jweak.
1538   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
1539                  Address(value, -JNIHandles::weak_tag_value), value, tmp1, tmp2, noreg);
1540   b(done);
1541   bind(not_weak);
1542   // Resolve (untagged) jobject.
1543   access_load_at(T_OBJECT, IN_NATIVE,
</pre>
<hr />
<pre>
1976   assert(VM_Version::supports_ldrex(), &quot;unsupported, yet?&quot;);
1977 
1978   Register Rmark      = Rscratch2;
1979 
1980   assert(Roop != Rscratch, &quot;&quot;);
1981   assert(Roop != Rmark, &quot;&quot;);
1982   assert(Rbox != Rscratch, &quot;&quot;);
1983   assert(Rbox != Rmark, &quot;&quot;);
1984 
1985   Label fast_lock, done;
1986 
1987   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
1988     assert(scratch3 != noreg, &quot;need extra temporary for -XX:-UseOptoBiasInlining&quot;);
1989     biased_locking_enter(Roop, Rmark, Rscratch, false, scratch3, done, done);
1990     // Fall through if lock not biased otherwise branch to done
1991   }
1992 
1993   // Invariant: Rmark loaded below does not contain biased lock pattern
1994 
1995   ldr(Rmark, Address(Roop, oopDesc::mark_offset_in_bytes()));
<span class="line-modified">1996   tst(Rmark, markOopDesc::unlocked_value);</span>
1997   b(fast_lock, ne);
1998 
1999   // Check for recursive lock
2000   // See comments in InterpreterMacroAssembler::lock_object for
2001   // explanations on the fast recursive locking check.
2002   // -1- test low 2 bits
2003   movs(Rscratch, AsmOperand(Rmark, lsl, 30));
2004   // -2- test (hdr - SP) if the low two bits are 0
2005   sub(Rscratch, Rmark, SP, eq);
2006   movs(Rscratch, AsmOperand(Rscratch, lsr, exact_log2(os::vm_page_size())), eq);
2007   // If still &#39;eq&#39; then recursive locking OK
2008   // set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8153107)
2009   str(Rscratch, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));
2010   b(done);
2011 
2012   bind(fast_lock);
2013   str(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));
2014 
2015   bool allow_fallthrough_on_failure = true;
2016   bool one_shot = true;
</pre>
<hr />
<pre>
2036 
2037   Label done;
2038 
2039   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
2040     biased_locking_exit(Roop, Rscratch, done);
2041   }
2042 
2043   ldr(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));
2044   // If hdr is NULL, we&#39;ve got recursive locking and there&#39;s nothing more to do
2045   cmp(Rmark, 0);
2046   b(done, eq);
2047 
2048   // Restore the object header
2049   bool allow_fallthrough_on_failure = true;
2050   bool one_shot = true;
2051   cas_for_lock_release(Rmark, Rbox, Roop, Rscratch, done, allow_fallthrough_on_failure, one_shot);
2052 
2053   bind(done);
2054 
2055 }




























2056 #endif // COMPILER2
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  29 #include &quot;ci/ciEnv.hpp&quot;
  30 #include &quot;code/nativeInst.hpp&quot;
  31 #include &quot;compiler/disassembler.hpp&quot;
  32 #include &quot;gc/shared/barrierSet.hpp&quot;
  33 #include &quot;gc/shared/cardTable.hpp&quot;
  34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  35 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  36 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;oops/accessDecorators.hpp&quot;
  40 #include &quot;oops/klass.inline.hpp&quot;
  41 #include &quot;prims/methodHandles.hpp&quot;
  42 #include &quot;runtime/biasedLocking.hpp&quot;
  43 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  44 #include &quot;runtime/objectMonitor.hpp&quot;
  45 #include &quot;runtime/os.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;runtime/stubRoutines.hpp&quot;
  48 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  49 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  50 
  51 // Implementation of AddressLiteral
  52 
  53 void AddressLiteral::set_rspec(relocInfo::relocType rtype) {
  54   switch (rtype) {
  55   case relocInfo::oop_type:
  56     // Oops are a special case. Normally they would be their own section
  57     // but in cases like icBuffer they are literals in the code stream that
  58     // we don&#39;t have a section for. We use none so that we get a literal address
  59     // which is always patchable.
  60     break;
  61   case relocInfo::external_word_type:
  62     _rspec = external_word_Relocation::spec(_target);
  63     break;
  64   case relocInfo::internal_word_type:
  65     _rspec = internal_word_Relocation::spec(_target);
  66     break;
  67   case relocInfo::opt_virtual_call_type:
  68     _rspec = opt_virtual_call_Relocation::spec();
  69     break;
</pre>
<hr />
<pre>
1329                                          BiasedLockingCounters* counters) {
1330   // obj_reg must be preserved (at least) if the bias locking fails
1331   // tmp_reg is a temporary register
1332   // swap_reg was used as a temporary but contained a value
1333   //   that was used afterwards in some call pathes. Callers
1334   //   have been fixed so that swap_reg no longer needs to be
1335   //   saved.
1336   // Rtemp in no longer scratched
1337 
1338   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1339   assert_different_registers(obj_reg, swap_reg, tmp_reg, tmp2);
1340   guarantee(swap_reg!=tmp_reg, &quot;invariant&quot;);
1341   assert(tmp_reg != noreg, &quot;must supply tmp_reg&quot;);
1342 
1343 #ifndef PRODUCT
1344   if (PrintBiasedLockingStatistics &amp;&amp; (counters == NULL)) {
1345     counters = BiasedLocking::counters();
1346   }
1347 #endif
1348 
<span class="line-modified">1349   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);</span>
1350   Address mark_addr(obj_reg, oopDesc::mark_offset_in_bytes());
1351 
1352   // Biased locking
1353   // See whether the lock is currently biased toward our thread and
1354   // whether the epoch is still valid
1355   // Note that the runtime guarantees sufficient alignment of JavaThread
1356   // pointers to allow age to be placed into low bits
1357   // First check to see whether biasing is even enabled for this object
1358   Label cas_label;
1359 
1360   // The null check applies to the mark loading, if we need to load it.
1361   // If the mark has already been loaded in swap_reg then it has already
1362   // been performed and the offset is irrelevant.
1363   int null_check_offset = offset();
1364   if (!swap_reg_contains_mark) {
1365     ldr(swap_reg, mark_addr);
1366   }
1367 
1368   // On MP platform loads could return &#39;stale&#39; values in some cases.
1369   // That is acceptable since either CAS or slow case path is taken in the worst case.
1370 
<span class="line-modified">1371   andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);</span>
<span class="line-modified">1372   cmp(tmp_reg, markWord::biased_lock_pattern);</span>
1373 
1374   b(cas_label, ne);
1375 
1376   // The bias pattern is present in the object&#39;s header. Need to check
1377   // whether the bias owner and the epoch are both still current.
1378   load_klass(tmp_reg, obj_reg);
1379   ldr(tmp_reg, Address(tmp_reg, Klass::prototype_header_offset()));
1380   orr(tmp_reg, tmp_reg, Rthread);
1381   eor(tmp_reg, tmp_reg, swap_reg);
1382 
<span class="line-modified">1383   bics(tmp_reg, tmp_reg, ((int) markWord::age_mask_in_place));</span>
1384 
1385 #ifndef PRODUCT
1386   if (counters != NULL) {
1387     cond_atomic_inc32(eq, counters-&gt;biased_lock_entry_count_addr());
1388   }
1389 #endif // !PRODUCT
1390 
1391   b(done, eq);
1392 
1393   Label try_revoke_bias;
1394   Label try_rebias;
1395 
1396   // At this point we know that the header has the bias pattern and
1397   // that we are not the bias owner in the current epoch. We need to
1398   // figure out more details about the state of the header in order to
1399   // know what operations can be legally performed on the object&#39;s
1400   // header.
1401 
1402   // If the low three bits in the xor result aren&#39;t clear, that means
1403   // the prototype header is no longer biased and we have to revoke
1404   // the bias on this object.
<span class="line-modified">1405   tst(tmp_reg, markWord::biased_lock_mask_in_place);</span>
1406   b(try_revoke_bias, ne);
1407 
1408   // Biasing is still enabled for this data type. See whether the
1409   // epoch of the current bias is still valid, meaning that the epoch
1410   // bits of the mark word are equal to the epoch bits of the
1411   // prototype header. (Note that the prototype header&#39;s epoch bits
1412   // only change at a safepoint.) If not, attempt to rebias the object
1413   // toward the current thread. Note that we must be absolutely sure
1414   // that the current epoch is invalid in order to do this because
1415   // otherwise the manipulations it performs on the mark word are
1416   // illegal.
<span class="line-modified">1417   tst(tmp_reg, markWord::epoch_mask_in_place);</span>
1418   b(try_rebias, ne);
1419 
1420   // tmp_reg has the age, epoch and pattern bits cleared
1421   // The remaining (owner) bits are (Thread ^ current_owner)
1422 
1423   // The epoch of the current bias is still valid but we know nothing
1424   // about the owner; it might be set or it might be clear. Try to
1425   // acquire the bias of the object using an atomic operation. If this
1426   // fails we will go in to the runtime to revoke the object&#39;s bias.
1427   // Note that we first construct the presumed unbiased header so we
1428   // don&#39;t accidentally blow away another thread&#39;s valid bias.
1429 
1430   // Note that we know the owner is not ourself. Hence, success can
1431   // only happen when the owner bits is 0
1432 
1433   // until the assembler can be made smarter, we need to make some assumptions about the values
1434   // so we can optimize this:
<span class="line-modified">1435   assert((markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place) == 0x1ff, &quot;biased bitmasks changed&quot;);</span>
1436 
1437   mov(swap_reg, AsmOperand(swap_reg, lsl, 23));
<span class="line-modified">1438   mov(swap_reg, AsmOperand(swap_reg, lsr, 23)); // markWord with thread bits cleared (for CAS)</span>
1439 
1440   orr(tmp_reg, swap_reg, Rthread); // new mark
1441 
1442   biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, slow_case,
1443         (counters != NULL) ? counters-&gt;anonymously_biased_lock_entry_count_addr() : NULL);
1444 
1445   // If the biasing toward our thread failed, this means that
1446   // another thread succeeded in biasing it toward itself and we
1447   // need to revoke that bias. The revocation will occur in the
1448   // interpreter runtime in the slow case.
1449 
1450   b(done);
1451 
1452   bind(try_rebias);
1453 
1454   // At this point we know the epoch has expired, meaning that the
1455   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
1456   // circumstances _only_, we are allowed to use the current header&#39;s
1457   // value as the comparison value when doing the cas to acquire the
1458   // bias in the current epoch. In other words, we allow transfer of
</pre>
<hr />
<pre>
1503   // the result of the above CAS, some thread must have succeeded in
1504   // removing the bias bit from the object&#39;s header.
1505 
1506   bind(cas_label);
1507 
1508   return null_check_offset;
1509 }
1510 
1511 
1512 void MacroAssembler::biased_locking_exit(Register obj_reg, Register tmp_reg, Label&amp; done) {
1513   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1514 
1515   // Check for biased locking unlock case, which is a no-op
1516   // Note: we do not have to check the thread ID for two reasons.
1517   // First, the interpreter checks for IllegalMonitorStateException at
1518   // a higher level. Second, if the bias was revoked while we held the
1519   // lock, the object could not be rebiased toward another thread, so
1520   // the bias bit would be clear.
1521   ldr(tmp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1522 
<span class="line-modified">1523   andr(tmp_reg, tmp_reg, markWord::biased_lock_mask_in_place);</span>
<span class="line-modified">1524   cmp(tmp_reg, markWord::biased_lock_pattern);</span>
1525   b(done, eq);
1526 }
1527 
1528 
1529 void MacroAssembler::resolve_jobject(Register value,
1530                                      Register tmp1,
1531                                      Register tmp2) {
1532   assert_different_registers(value, tmp1, tmp2);
1533   Label done, not_weak;
1534   cbz(value, done);             // Use NULL as-is.
1535   STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);
1536   tbz(value, 0, not_weak);      // Test for jweak tag.
1537 
1538   // Resolve jweak.
1539   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
1540                  Address(value, -JNIHandles::weak_tag_value), value, tmp1, tmp2, noreg);
1541   b(done);
1542   bind(not_weak);
1543   // Resolve (untagged) jobject.
1544   access_load_at(T_OBJECT, IN_NATIVE,
</pre>
<hr />
<pre>
1977   assert(VM_Version::supports_ldrex(), &quot;unsupported, yet?&quot;);
1978 
1979   Register Rmark      = Rscratch2;
1980 
1981   assert(Roop != Rscratch, &quot;&quot;);
1982   assert(Roop != Rmark, &quot;&quot;);
1983   assert(Rbox != Rscratch, &quot;&quot;);
1984   assert(Rbox != Rmark, &quot;&quot;);
1985 
1986   Label fast_lock, done;
1987 
1988   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
1989     assert(scratch3 != noreg, &quot;need extra temporary for -XX:-UseOptoBiasInlining&quot;);
1990     biased_locking_enter(Roop, Rmark, Rscratch, false, scratch3, done, done);
1991     // Fall through if lock not biased otherwise branch to done
1992   }
1993 
1994   // Invariant: Rmark loaded below does not contain biased lock pattern
1995 
1996   ldr(Rmark, Address(Roop, oopDesc::mark_offset_in_bytes()));
<span class="line-modified">1997   tst(Rmark, markWord::unlocked_value);</span>
1998   b(fast_lock, ne);
1999 
2000   // Check for recursive lock
2001   // See comments in InterpreterMacroAssembler::lock_object for
2002   // explanations on the fast recursive locking check.
2003   // -1- test low 2 bits
2004   movs(Rscratch, AsmOperand(Rmark, lsl, 30));
2005   // -2- test (hdr - SP) if the low two bits are 0
2006   sub(Rscratch, Rmark, SP, eq);
2007   movs(Rscratch, AsmOperand(Rscratch, lsr, exact_log2(os::vm_page_size())), eq);
2008   // If still &#39;eq&#39; then recursive locking OK
2009   // set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8153107)
2010   str(Rscratch, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));
2011   b(done);
2012 
2013   bind(fast_lock);
2014   str(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));
2015 
2016   bool allow_fallthrough_on_failure = true;
2017   bool one_shot = true;
</pre>
<hr />
<pre>
2037 
2038   Label done;
2039 
2040   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
2041     biased_locking_exit(Roop, Rscratch, done);
2042   }
2043 
2044   ldr(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));
2045   // If hdr is NULL, we&#39;ve got recursive locking and there&#39;s nothing more to do
2046   cmp(Rmark, 0);
2047   b(done, eq);
2048 
2049   // Restore the object header
2050   bool allow_fallthrough_on_failure = true;
2051   bool one_shot = true;
2052   cas_for_lock_release(Rmark, Rbox, Roop, Rscratch, done, allow_fallthrough_on_failure, one_shot);
2053 
2054   bind(done);
2055 
2056 }
<span class="line-added">2057 </span>
<span class="line-added">2058 void MacroAssembler::safepoint_poll(Register tmp1, Label&amp; slow_path) {</span>
<span class="line-added">2059   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-added">2060     ldr_u32(tmp1, Address(Rthread, Thread::polling_page_offset()));</span>
<span class="line-added">2061     tst(tmp1, exact_log2(SafepointMechanism::poll_bit()));</span>
<span class="line-added">2062     b(slow_path, eq);</span>
<span class="line-added">2063   } else {</span>
<span class="line-added">2064     ldr_global_s32(tmp1, SafepointSynchronize::address_of_state());</span>
<span class="line-added">2065     cmp(tmp1, SafepointSynchronize::_not_synchronized);</span>
<span class="line-added">2066     b(slow_path, ne);</span>
<span class="line-added">2067   }</span>
<span class="line-added">2068 }</span>
<span class="line-added">2069 </span>
<span class="line-added">2070 void MacroAssembler::get_polling_page(Register dest) {</span>
<span class="line-added">2071   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-added">2072     ldr(dest, Address(Rthread, Thread::polling_page_offset()));</span>
<span class="line-added">2073   } else {</span>
<span class="line-added">2074     mov_address(dest, os::get_polling_page());</span>
<span class="line-added">2075   }</span>
<span class="line-added">2076 }</span>
<span class="line-added">2077 </span>
<span class="line-added">2078 void MacroAssembler::read_polling_page(Register dest, relocInfo::relocType rtype) {</span>
<span class="line-added">2079   get_polling_page(dest);</span>
<span class="line-added">2080   relocate(rtype);</span>
<span class="line-added">2081   ldr(dest, Address(dest));</span>
<span class="line-added">2082 }</span>
<span class="line-added">2083 </span>
<span class="line-added">2084 </span>
2085 #endif // COMPILER2
</pre>
</td>
</tr>
</table>
<center><a href="jniFastGetField_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_arm.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
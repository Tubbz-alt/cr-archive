<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/arm/jniFastGetField_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interpreterRT_arm.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_arm.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/jniFastGetField_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30,11 +30,11 @@</span>
  #include &quot;prims/jvm_misc.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  
  #define __ masm-&gt;
  
<span class="udiff-line-modified-removed">- #define BUFFER_SIZE  96</span>
<span class="udiff-line-modified-added">+ #define BUFFER_SIZE 120</span>
  
  address JNI_FastGetField::generate_fast_get_int_field0(BasicType type) {
    const char* name = NULL;
    address slow_case_addr = NULL;
    switch (type) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97,26 +97,38 @@</span>
    ResourceMark rm;
    BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE);
    CodeBuffer cbuf(blob);
    MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
    fast_entry = __ pc();
<span class="udiff-line-added">+   Label slow_case;</span>
  
    // Safepoint check
    InlinedAddress safepoint_counter_addr(SafepointSynchronize::safepoint_counter_addr());
<span class="udiff-line-removed">-   Label slow_case;</span>
    __ ldr_literal(Rsafepoint_counter_addr, safepoint_counter_addr);
  
    __ push(RegisterSet(R0, R3));  // save incoming arguments for slow case
  
    __ ldr_s32(Rsafept_cnt, Address(Rsafepoint_counter_addr));
    __ tbnz(Rsafept_cnt, 0, slow_case);
  
    __ bic(R1, R1, JNIHandles::weak_tag_mask);
  
<span class="udiff-line-modified-removed">-   // Address dependency restricts memory access ordering. It&#39;s cheaper than explicit LoadLoad barrier</span>
<span class="udiff-line-modified-removed">-   __ andr(Rtmp1, Rsafept_cnt, (unsigned)1);</span>
<span class="udiff-line-modified-removed">-   __ ldr(Robj, Address(R1, Rtmp1));</span>
<span class="udiff-line-modified-added">+   if (JvmtiExport::can_post_field_access()) {</span>
<span class="udiff-line-modified-added">+     // Using barrier to order wrt. JVMTI check and load of result.</span>
<span class="udiff-line-modified-added">+     __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad), Rtmp1);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Check to see if a field access watch has been set before we</span>
<span class="udiff-line-added">+     // take the fast path.</span>
<span class="udiff-line-added">+     __ ldr_global_s32(Rtmp1, (address)JvmtiExport::get_field_access_count_addr());</span>
<span class="udiff-line-added">+     __ cbnz(Rtmp1, slow_case);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ ldr(Robj, Address(R1));</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // Address dependency restricts memory access ordering. It&#39;s cheaper than explicit LoadLoad barrier</span>
<span class="udiff-line-added">+     __ andr(Rtmp1, Rsafept_cnt, (unsigned)1);</span>
<span class="udiff-line-added">+     __ ldr(Robj, Address(R1, Rtmp1));</span>
<span class="udiff-line-added">+   }</span>
  
    Address field_addr;
    if (type != T_BOOLEAN
        &amp;&amp; type != T_INT
  #ifndef __ABI_HARD__
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -168,24 +180,22 @@</span>
  #endif // __ABI_HARD__
      default:
        ShouldNotReachHere();
    }
  
<span class="udiff-line-modified-removed">-   // Address dependency restricts memory access ordering. It&#39;s cheaper than explicit LoadLoad barrier</span>
<span class="udiff-line-modified-added">+   __ ldr_literal(Rsafepoint_counter_addr, safepoint_counter_addr);</span>
  #ifdef __ABI_HARD__
    if (type == T_FLOAT || type == T_DOUBLE) {
<span class="udiff-line-removed">-     __ ldr_literal(Rsafepoint_counter_addr, safepoint_counter_addr);</span>
      __ fmrrd(Rres, Rres_hi, D0);
<span class="udiff-line-removed">-     __ eor(Rtmp2, Rres, Rres);</span>
<span class="udiff-line-removed">-     __ ldr_s32(Rsafept_cnt2, Address(Rsafepoint_counter_addr, Rtmp2));</span>
<span class="udiff-line-removed">-   } else</span>
<span class="udiff-line-removed">- #endif // __ABI_HARD__</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     __ ldr_literal(Rsafepoint_counter_addr, safepoint_counter_addr);</span>
<span class="udiff-line-removed">-     __ eor(Rtmp2, Rres, Rres);</span>
<span class="udiff-line-removed">-     __ ldr_s32(Rsafept_cnt2, Address(Rsafepoint_counter_addr, Rtmp2));</span>
    }
<span class="udiff-line-added">+ #endif // __ABI_HARD__</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Order JVMTI check and load of result wrt. succeeding check</span>
<span class="udiff-line-added">+   // (LoadStore for volatile field).</span>
<span class="udiff-line-added">+   __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtmp2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ ldr_s32(Rsafept_cnt2, Address(Rsafepoint_counter_addr));</span>
    __ cmp(Rsafept_cnt2, Rsafept_cnt);
    // discards saved R0 R1 R2 R3
    __ add(SP, SP, 4 * wordSize, eq);
    __ bx(LR, eq);
  
</pre>
<center><a href="interpreterRT_arm.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_arm.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
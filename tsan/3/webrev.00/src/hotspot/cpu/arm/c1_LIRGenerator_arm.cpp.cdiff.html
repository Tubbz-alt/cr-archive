<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/arm/c1_LIRGenerator_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRAssembler_arm.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_arm.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/c1_LIRGenerator_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 38,10 ***</span>
<span class="line-new-header">--- 38,11 ---</span>
  #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  #include &quot;gc/shared/cardTable.hpp&quot;
  #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;vmreg_arm.inline.hpp&quot;
  
  #ifdef ASSERT
  #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 772,20 ***</span>
  
  LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
    bool is_oop = type == T_OBJECT || type == T_ARRAY;
    LIR_Opr result = new_register(type);
    value.load_item();
<span class="line-modified">!   assert(type == T_INT || is_oop LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);</span>
    LIR_Opr tmp = (UseCompressedOops &amp;&amp; is_oop) ? new_pointer_register() : LIR_OprFact::illegalOpr;
    __ xchg(addr, value.result(), result, tmp);
    return result;
  }
  
  LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
    LIR_Opr result = new_register(type);
    value.load_item();
<span class="line-modified">!   assert(type == T_INT LP64_ONLY( || type == T_LONG), &quot;unexpected type&quot;);</span>
    LIR_Opr tmp = new_register(type);
    __ xadd(addr, value.result(), result, tmp);
    return result;
  }
  
<span class="line-new-header">--- 773,20 ---</span>
  
  LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
    bool is_oop = type == T_OBJECT || type == T_ARRAY;
    LIR_Opr result = new_register(type);
    value.load_item();
<span class="line-modified">!   assert(type == T_INT || is_oop || (type == T_LONG &amp;&amp; VM_Version::supports_ldrexd()), &quot;unexpected type&quot;);</span>
    LIR_Opr tmp = (UseCompressedOops &amp;&amp; is_oop) ? new_pointer_register() : LIR_OprFact::illegalOpr;
    __ xchg(addr, value.result(), result, tmp);
    return result;
  }
  
  LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
    LIR_Opr result = new_register(type);
    value.load_item();
<span class="line-modified">!   assert(type == T_INT || (type == T_LONG &amp;&amp; VM_Version::supports_ldrexd ()), &quot;unexpected type&quot;);</span>
    LIR_Opr tmp = new_register(type);
    __ xadd(addr, value.result(), result, tmp);
    return result;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1308,24 ***</span>
  
  void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
                                          CodeEmitInfo* info) {
    if (value-&gt;is_double_cpu()) {
      assert(address-&gt;index()-&gt;is_illegal(), &quot;should have a constant displacement&quot;);
<span class="line-modified">!     LIR_Opr tmp = new_pointer_register();</span>
<span class="line-modified">!     add_large_constant(address-&gt;base(), address-&gt;disp(), tmp);</span>
<span class="line-modified">!     __ volatile_store_mem_reg(value, new LIR_Address(tmp, (intx)0, address-&gt;type()), info);</span>
      return;
    }
    __ store(value, address, info, lir_patch_none);
  }
  
  void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
                                         CodeEmitInfo* info) {
    if (result-&gt;is_double_cpu()) {
      assert(address-&gt;index()-&gt;is_illegal(), &quot;should have a constant displacement&quot;);
<span class="line-modified">!     LIR_Opr tmp = new_pointer_register();</span>
<span class="line-modified">!     add_large_constant(address-&gt;base(), address-&gt;disp(), tmp);</span>
<span class="line-modified">!     __ volatile_load_mem_reg(new LIR_Address(tmp, (intx)0, address-&gt;type()), result, info);</span>
      return;
    }
    __ load(address, result, info, lir_patch_none);
  }
<span class="line-new-header">--- 1309,38 ---</span>
  
  void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
                                          CodeEmitInfo* info) {
    if (value-&gt;is_double_cpu()) {
      assert(address-&gt;index()-&gt;is_illegal(), &quot;should have a constant displacement&quot;);
<span class="line-modified">!     LIR_Address* store_addr = NULL;</span>
<span class="line-modified">!     if (address-&gt;disp() != 0) {</span>
<span class="line-modified">!       LIR_Opr tmp = new_pointer_register();</span>
<span class="line-added">+       add_large_constant(address-&gt;base(), address-&gt;disp(), tmp);</span>
<span class="line-added">+       store_addr = new LIR_Address(tmp, (intx)0, address-&gt;type());</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // address-&gt;disp() can be 0, if the address is referenced using the unsafe intrinsic</span>
<span class="line-added">+       store_addr = address;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     __ volatile_store_mem_reg(value, store_addr, info);</span>
      return;
    }
    __ store(value, address, info, lir_patch_none);
  }
  
  void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
                                         CodeEmitInfo* info) {
    if (result-&gt;is_double_cpu()) {
      assert(address-&gt;index()-&gt;is_illegal(), &quot;should have a constant displacement&quot;);
<span class="line-modified">!     LIR_Address* load_addr = NULL;</span>
<span class="line-modified">!     if (address-&gt;disp() != 0) {</span>
<span class="line-modified">!       LIR_Opr tmp = new_pointer_register();</span>
<span class="line-added">+       add_large_constant(address-&gt;base(), address-&gt;disp(), tmp);</span>
<span class="line-added">+       load_addr = new LIR_Address(tmp, (intx)0, address-&gt;type());</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // address-&gt;disp() can be 0, if the address is referenced using the unsafe intrinsic</span>
<span class="line-added">+       load_addr = address;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     __ volatile_load_mem_reg(load_addr, result, info);</span>
      return;
    }
    __ load(address, result, info, lir_patch_none);
  }
</pre>
<center><a href="c1_LIRAssembler_arm.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_arm.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
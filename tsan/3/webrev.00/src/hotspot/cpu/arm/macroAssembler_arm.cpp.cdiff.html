<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/arm/macroAssembler_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jniFastGetField_arm.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_arm.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/macroAssembler_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,10 ***</span>
<span class="line-new-header">--- 44,11 ---</span>
  #include &quot;runtime/objectMonitor.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  // Implementation of AddressLiteral
  
  void AddressLiteral::set_rspec(relocInfo::relocType rtype) {
    switch (rtype) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1343,11 ***</span>
    if (PrintBiasedLockingStatistics &amp;&amp; (counters == NULL)) {
      counters = BiasedLocking::counters();
    }
  #endif
  
<span class="line-modified">!   assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);</span>
    Address mark_addr(obj_reg, oopDesc::mark_offset_in_bytes());
  
    // Biased locking
    // See whether the lock is currently biased toward our thread and
    // whether the epoch is still valid
<span class="line-new-header">--- 1344,11 ---</span>
    if (PrintBiasedLockingStatistics &amp;&amp; (counters == NULL)) {
      counters = BiasedLocking::counters();
    }
  #endif
  
<span class="line-modified">!   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);</span>
    Address mark_addr(obj_reg, oopDesc::mark_offset_in_bytes());
  
    // Biased locking
    // See whether the lock is currently biased toward our thread and
    // whether the epoch is still valid
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1365,23 ***</span>
    }
  
    // On MP platform loads could return &#39;stale&#39; values in some cases.
    // That is acceptable since either CAS or slow case path is taken in the worst case.
  
<span class="line-modified">!   andr(tmp_reg, swap_reg, (uintx)markOopDesc::biased_lock_mask_in_place);</span>
<span class="line-modified">!   cmp(tmp_reg, markOopDesc::biased_lock_pattern);</span>
  
    b(cas_label, ne);
  
    // The bias pattern is present in the object&#39;s header. Need to check
    // whether the bias owner and the epoch are both still current.
    load_klass(tmp_reg, obj_reg);
    ldr(tmp_reg, Address(tmp_reg, Klass::prototype_header_offset()));
    orr(tmp_reg, tmp_reg, Rthread);
    eor(tmp_reg, tmp_reg, swap_reg);
  
<span class="line-modified">!   bics(tmp_reg, tmp_reg, ((int) markOopDesc::age_mask_in_place));</span>
  
  #ifndef PRODUCT
    if (counters != NULL) {
      cond_atomic_inc32(eq, counters-&gt;biased_lock_entry_count_addr());
    }
<span class="line-new-header">--- 1366,23 ---</span>
    }
  
    // On MP platform loads could return &#39;stale&#39; values in some cases.
    // That is acceptable since either CAS or slow case path is taken in the worst case.
  
<span class="line-modified">!   andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);</span>
<span class="line-modified">!   cmp(tmp_reg, markWord::biased_lock_pattern);</span>
  
    b(cas_label, ne);
  
    // The bias pattern is present in the object&#39;s header. Need to check
    // whether the bias owner and the epoch are both still current.
    load_klass(tmp_reg, obj_reg);
    ldr(tmp_reg, Address(tmp_reg, Klass::prototype_header_offset()));
    orr(tmp_reg, tmp_reg, Rthread);
    eor(tmp_reg, tmp_reg, swap_reg);
  
<span class="line-modified">!   bics(tmp_reg, tmp_reg, ((int) markWord::age_mask_in_place));</span>
  
  #ifndef PRODUCT
    if (counters != NULL) {
      cond_atomic_inc32(eq, counters-&gt;biased_lock_entry_count_addr());
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1399,11 ***</span>
    // header.
  
    // If the low three bits in the xor result aren&#39;t clear, that means
    // the prototype header is no longer biased and we have to revoke
    // the bias on this object.
<span class="line-modified">!   tst(tmp_reg, (uintx)markOopDesc::biased_lock_mask_in_place);</span>
    b(try_revoke_bias, ne);
  
    // Biasing is still enabled for this data type. See whether the
    // epoch of the current bias is still valid, meaning that the epoch
    // bits of the mark word are equal to the epoch bits of the
<span class="line-new-header">--- 1400,11 ---</span>
    // header.
  
    // If the low three bits in the xor result aren&#39;t clear, that means
    // the prototype header is no longer biased and we have to revoke
    // the bias on this object.
<span class="line-modified">!   tst(tmp_reg, markWord::biased_lock_mask_in_place);</span>
    b(try_revoke_bias, ne);
  
    // Biasing is still enabled for this data type. See whether the
    // epoch of the current bias is still valid, meaning that the epoch
    // bits of the mark word are equal to the epoch bits of the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1411,11 ***</span>
    // only change at a safepoint.) If not, attempt to rebias the object
    // toward the current thread. Note that we must be absolutely sure
    // that the current epoch is invalid in order to do this because
    // otherwise the manipulations it performs on the mark word are
    // illegal.
<span class="line-modified">!   tst(tmp_reg, (uintx)markOopDesc::epoch_mask_in_place);</span>
    b(try_rebias, ne);
  
    // tmp_reg has the age, epoch and pattern bits cleared
    // The remaining (owner) bits are (Thread ^ current_owner)
  
<span class="line-new-header">--- 1412,11 ---</span>
    // only change at a safepoint.) If not, attempt to rebias the object
    // toward the current thread. Note that we must be absolutely sure
    // that the current epoch is invalid in order to do this because
    // otherwise the manipulations it performs on the mark word are
    // illegal.
<span class="line-modified">!   tst(tmp_reg, markWord::epoch_mask_in_place);</span>
    b(try_rebias, ne);
  
    // tmp_reg has the age, epoch and pattern bits cleared
    // The remaining (owner) bits are (Thread ^ current_owner)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1429,14 ***</span>
    // Note that we know the owner is not ourself. Hence, success can
    // only happen when the owner bits is 0
  
    // until the assembler can be made smarter, we need to make some assumptions about the values
    // so we can optimize this:
<span class="line-modified">!   assert((markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place) == 0x1ff, &quot;biased bitmasks changed&quot;);</span>
  
    mov(swap_reg, AsmOperand(swap_reg, lsl, 23));
<span class="line-modified">!   mov(swap_reg, AsmOperand(swap_reg, lsr, 23)); // markOop with thread bits cleared (for CAS)</span>
  
    orr(tmp_reg, swap_reg, Rthread); // new mark
  
    biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, slow_case,
          (counters != NULL) ? counters-&gt;anonymously_biased_lock_entry_count_addr() : NULL);
<span class="line-new-header">--- 1430,14 ---</span>
    // Note that we know the owner is not ourself. Hence, success can
    // only happen when the owner bits is 0
  
    // until the assembler can be made smarter, we need to make some assumptions about the values
    // so we can optimize this:
<span class="line-modified">!   assert((markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place) == 0x1ff, &quot;biased bitmasks changed&quot;);</span>
  
    mov(swap_reg, AsmOperand(swap_reg, lsl, 23));
<span class="line-modified">!   mov(swap_reg, AsmOperand(swap_reg, lsr, 23)); // markWord with thread bits cleared (for CAS)</span>
  
    orr(tmp_reg, swap_reg, Rthread); // new mark
  
    biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, slow_case,
          (counters != NULL) ? counters-&gt;anonymously_biased_lock_entry_count_addr() : NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1517,12 ***</span>
    // a higher level. Second, if the bias was revoked while we held the
    // lock, the object could not be rebiased toward another thread, so
    // the bias bit would be clear.
    ldr(tmp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
  
<span class="line-modified">!   andr(tmp_reg, tmp_reg, (uintx)markOopDesc::biased_lock_mask_in_place);</span>
<span class="line-modified">!   cmp(tmp_reg, markOopDesc::biased_lock_pattern);</span>
    b(done, eq);
  }
  
  
  void MacroAssembler::resolve_jobject(Register value,
<span class="line-new-header">--- 1518,12 ---</span>
    // a higher level. Second, if the bias was revoked while we held the
    // lock, the object could not be rebiased toward another thread, so
    // the bias bit would be clear.
    ldr(tmp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
  
<span class="line-modified">!   andr(tmp_reg, tmp_reg, markWord::biased_lock_mask_in_place);</span>
<span class="line-modified">!   cmp(tmp_reg, markWord::biased_lock_pattern);</span>
    b(done, eq);
  }
  
  
  void MacroAssembler::resolve_jobject(Register value,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1991,11 ***</span>
    }
  
    // Invariant: Rmark loaded below does not contain biased lock pattern
  
    ldr(Rmark, Address(Roop, oopDesc::mark_offset_in_bytes()));
<span class="line-modified">!   tst(Rmark, markOopDesc::unlocked_value);</span>
    b(fast_lock, ne);
  
    // Check for recursive lock
    // See comments in InterpreterMacroAssembler::lock_object for
    // explanations on the fast recursive locking check.
<span class="line-new-header">--- 1992,11 ---</span>
    }
  
    // Invariant: Rmark loaded below does not contain biased lock pattern
  
    ldr(Rmark, Address(Roop, oopDesc::mark_offset_in_bytes()));
<span class="line-modified">!   tst(Rmark, markWord::unlocked_value);</span>
    b(fast_lock, ne);
  
    // Check for recursive lock
    // See comments in InterpreterMacroAssembler::lock_object for
    // explanations on the fast recursive locking check.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2051,6 ***</span>
<span class="line-new-header">--- 2052,34 ---</span>
    cas_for_lock_release(Rmark, Rbox, Roop, Rscratch, done, allow_fallthrough_on_failure, one_shot);
  
    bind(done);
  
  }
<span class="line-added">+ </span>
<span class="line-added">+ void MacroAssembler::safepoint_poll(Register tmp1, Label&amp; slow_path) {</span>
<span class="line-added">+   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-added">+     ldr_u32(tmp1, Address(Rthread, Thread::polling_page_offset()));</span>
<span class="line-added">+     tst(tmp1, exact_log2(SafepointMechanism::poll_bit()));</span>
<span class="line-added">+     b(slow_path, eq);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     ldr_global_s32(tmp1, SafepointSynchronize::address_of_state());</span>
<span class="line-added">+     cmp(tmp1, SafepointSynchronize::_not_synchronized);</span>
<span class="line-added">+     b(slow_path, ne);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void MacroAssembler::get_polling_page(Register dest) {</span>
<span class="line-added">+   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-added">+     ldr(dest, Address(Rthread, Thread::polling_page_offset()));</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     mov_address(dest, os::get_polling_page());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void MacroAssembler::read_polling_page(Register dest, relocInfo::relocType rtype) {</span>
<span class="line-added">+   get_polling_page(dest);</span>
<span class="line-added">+   relocate(rtype);</span>
<span class="line-added">+   ldr(dest, Address(dest));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  #endif // COMPILER2
</pre>
<center><a href="jniFastGetField_arm.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_arm.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/nativeInst_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2014, 2018, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;code/compiledIC.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;nativeInst_aarch64.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/handles.hpp&quot;
<a name="1" id="anc1"></a>
 33 #include &quot;runtime/sharedRuntime.hpp&quot;
 34 #include &quot;runtime/stubRoutines.hpp&quot;
 35 #include &quot;utilities/ostream.hpp&quot;
 36 #ifdef COMPILER1
 37 #include &quot;c1/c1_Runtime1.hpp&quot;
 38 #endif
 39 
 40 void NativeCall::verify() {
 41   assert(NativeCall::is_call_at((address)this), &quot;unexpected code at call site&quot;);
 42 }
 43 
 44 void NativeInstruction::wrote(int offset) {
 45   ICache::invalidate_word(addr_at(offset));
 46 }
 47 
 48 void NativeLoadGot::report_and_fail() const {
 49   tty-&gt;print_cr(&quot;Addr: &quot; INTPTR_FORMAT, p2i(instruction_address()));
 50   fatal(&quot;not a indirect rip mov to rbx&quot;);
 51 }
 52 
 53 void NativeLoadGot::verify() const {
 54   assert(is_adrp_at((address)this), &quot;must be adrp&quot;);
 55 }
 56 
 57 address NativeLoadGot::got_address() const {
 58   return MacroAssembler::target_addr_for_insn((address)this);
 59 }
 60 
 61 intptr_t NativeLoadGot::data() const {
 62   return *(intptr_t *) got_address();
 63 }
 64 
 65 address NativePltCall::destination() const {
 66   NativeGotJump* jump = nativeGotJump_at(plt_jump());
 67   return *(address*)MacroAssembler::target_addr_for_insn((address)jump);
 68 }
 69 
 70 address NativePltCall::plt_entry() const {
 71   return MacroAssembler::target_addr_for_insn((address)this);
 72 }
 73 
 74 address NativePltCall::plt_jump() const {
 75   address entry = plt_entry();
 76   // Virtual PLT code has move instruction first
 77   if (((NativeGotJump*)entry)-&gt;is_GotJump()) {
 78     return entry;
 79   } else {
 80     return nativeLoadGot_at(entry)-&gt;next_instruction_address();
 81   }
 82 }
 83 
 84 address NativePltCall::plt_load_got() const {
 85   address entry = plt_entry();
 86   if (!((NativeGotJump*)entry)-&gt;is_GotJump()) {
 87     // Virtual PLT code has move instruction first
 88     return entry;
 89   } else {
 90     // Static PLT code has move instruction second (from c2i stub)
 91     return nativeGotJump_at(entry)-&gt;next_instruction_address();
 92   }
 93 }
 94 
 95 address NativePltCall::plt_c2i_stub() const {
 96   address entry = plt_load_got();
 97   // This method should be called only for static calls which has C2I stub.
 98   NativeLoadGot* load = nativeLoadGot_at(entry);
 99   return entry;
100 }
101 
102 address NativePltCall::plt_resolve_call() const {
103   NativeGotJump* jump = nativeGotJump_at(plt_jump());
104   address entry = jump-&gt;next_instruction_address();
105   if (((NativeGotJump*)entry)-&gt;is_GotJump()) {
106     return entry;
107   } else {
108     // c2i stub 2 instructions
109     entry = nativeLoadGot_at(entry)-&gt;next_instruction_address();
110     return nativeGotJump_at(entry)-&gt;next_instruction_address();
111   }
112 }
113 
114 void NativePltCall::reset_to_plt_resolve_call() {
115   set_destination_mt_safe(plt_resolve_call());
116 }
117 
118 void NativePltCall::set_destination_mt_safe(address dest) {
119   // rewriting the value in the GOT, it should always be aligned
120   NativeGotJump* jump = nativeGotJump_at(plt_jump());
121   address* got = (address *) jump-&gt;got_address();
122   *got = dest;
123 }
124 
125 void NativePltCall::set_stub_to_clean() {
126   NativeLoadGot* method_loader = nativeLoadGot_at(plt_c2i_stub());
127   NativeGotJump* jump          = nativeGotJump_at(method_loader-&gt;next_instruction_address());
128   method_loader-&gt;set_data(0);
129   jump-&gt;set_jump_destination((address)-1);
130 }
131 
132 void NativePltCall::verify() const {
133   assert(NativeCall::is_call_at((address)this), &quot;unexpected code at call site&quot;);
134 }
135 
136 address NativeGotJump::got_address() const {
137   return MacroAssembler::target_addr_for_insn((address)this);
138 }
139 
140 address NativeGotJump::destination() const {
141   address *got_entry = (address *) got_address();
142   return *got_entry;
143 }
144 
145 bool NativeGotJump::is_GotJump() const {
146   NativeInstruction *insn =
147     nativeInstruction_at(addr_at(3 * NativeInstruction::instruction_size));
148   return insn-&gt;encoding() == 0xd61f0200; // br x16
149 }
150 
151 void NativeGotJump::verify() const {
152   assert(is_adrp_at((address)this), &quot;must be adrp&quot;);
153 }
154 
155 address NativeCall::destination() const {
156   address addr = (address)this;
157   address destination = instruction_address() + displacement();
158 
159   // Do we use a trampoline stub for this call?
160   CodeBlob* cb = CodeCache::find_blob_unsafe(addr);   // Else we get assertion if nmethod is zombie.
161   assert(cb &amp;&amp; cb-&gt;is_nmethod(), &quot;sanity&quot;);
162   nmethod *nm = (nmethod *)cb;
163   if (nm-&gt;stub_contains(destination) &amp;&amp; is_NativeCallTrampolineStub_at(destination)) {
164     // Yes we do, so get the destination from the trampoline stub.
165     const address trampoline_stub_addr = destination;
166     destination = nativeCallTrampolineStub_at(trampoline_stub_addr)-&gt;destination();
167   }
168 
169   return destination;
170 }
171 
172 // Similar to replace_mt_safe, but just changes the destination. The
173 // important thing is that free-running threads are able to execute this
174 // call instruction at all times.
175 //
176 // Used in the runtime linkage of calls; see class CompiledIC.
177 //
178 // Add parameter assert_lock to switch off assertion
179 // during code generation, where no patching lock is needed.
180 void NativeCall::set_destination_mt_safe(address dest, bool assert_lock) {
181   assert(!assert_lock ||
182          (Patching_lock-&gt;is_locked() || SafepointSynchronize::is_at_safepoint()) ||
183          CompiledICLocker::is_safe(addr_at(0)),
184          &quot;concurrent code patching&quot;);
185 
186   ResourceMark rm;
187   int code_size = NativeInstruction::instruction_size;
188   address addr_call = addr_at(0);
189   bool reachable = Assembler::reachable_from_branch_at(addr_call, dest);
190   assert(NativeCall::is_call_at(addr_call), &quot;unexpected code at call site&quot;);
191 
192   // Patch the constant in the call&#39;s trampoline stub.
193   address trampoline_stub_addr = get_trampoline();
194   if (trampoline_stub_addr != NULL) {
195     assert (! is_NativeCallTrampolineStub_at(dest), &quot;chained trampolines&quot;);
196     nativeCallTrampolineStub_at(trampoline_stub_addr)-&gt;set_destination(dest);
197   }
198 
199   // Patch the call.
200   if (reachable) {
201     set_destination(dest);
202   } else {
203     assert (trampoline_stub_addr != NULL, &quot;we need a trampoline&quot;);
204     set_destination(trampoline_stub_addr);
205   }
206 
207   ICache::invalidate_range(addr_call, instruction_size);
208 }
209 
210 address NativeCall::get_trampoline() {
211   address call_addr = addr_at(0);
212 
213   CodeBlob *code = CodeCache::find_blob(call_addr);
214   assert(code != NULL, &quot;Could not find the containing code blob&quot;);
215 
216   address bl_destination
217     = MacroAssembler::pd_call_destination(call_addr);
218   if (code-&gt;contains(bl_destination) &amp;&amp;
219       is_NativeCallTrampolineStub_at(bl_destination))
220     return bl_destination;
221 
222   if (code-&gt;is_nmethod()) {
223     return trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);
224   }
225 
226   return NULL;
227 }
228 
229 // Inserts a native call instruction at a given pc
230 void NativeCall::insert(address code_pos, address entry) { Unimplemented(); }
231 
232 //-------------------------------------------------------------------
233 
234 void NativeMovConstReg::verify() {
<a name="2" id="anc2"></a><span class="line-modified">235   // make sure code pattern is actually mov reg64, imm64 instructions</span>




236 }
237 
238 
239 intptr_t NativeMovConstReg::data() const {
240   // das(uint64_t(instruction_address()),2);
241   address addr = MacroAssembler::target_addr_for_insn(instruction_address());
242   if (maybe_cpool_ref(instruction_address())) {
243     return *(intptr_t*)addr;
244   } else {
245     return (intptr_t)addr;
246   }
247 }
248 
249 void NativeMovConstReg::set_data(intptr_t x) {
250   if (maybe_cpool_ref(instruction_address())) {
251     address addr = MacroAssembler::target_addr_for_insn(instruction_address());
252     *(intptr_t*)addr = x;
253   } else {
254     // Store x into the instruction stream.
255     MacroAssembler::pd_patch_instruction(instruction_address(), (address)x);
256     ICache::invalidate_range(instruction_address(), instruction_size);
257   }
258 
259   // Find and replace the oop/metadata corresponding to this
260   // instruction in oops section.
261   CodeBlob* cb = CodeCache::find_blob(instruction_address());
262   nmethod* nm = cb-&gt;as_nmethod_or_null();
263   if (nm != NULL) {
264     RelocIterator iter(nm, instruction_address(), next_instruction_address());
265     while (iter.next()) {
266       if (iter.type() == relocInfo::oop_type) {
267         oop* oop_addr = iter.oop_reloc()-&gt;oop_addr();
268         *oop_addr = cast_to_oop(x);
269         break;
270       } else if (iter.type() == relocInfo::metadata_type) {
271         Metadata** metadata_addr = iter.metadata_reloc()-&gt;metadata_addr();
272         *metadata_addr = (Metadata*)x;
273         break;
274       }
275     }
276   }
277 }
278 
279 void NativeMovConstReg::print() {
280   tty-&gt;print_cr(PTR_FORMAT &quot;: mov reg, &quot; INTPTR_FORMAT,
281                 p2i(instruction_address()), data());
282 }
283 
284 //-------------------------------------------------------------------
285 
<a name="3" id="anc3"></a><span class="line-removed">286 address NativeMovRegMem::instruction_address() const      { return addr_at(instruction_offset); }</span>
<span class="line-removed">287 </span>
288 int NativeMovRegMem::offset() const  {
289   address pc = instruction_address();
290   unsigned insn = *(unsigned*)pc;
291   if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
292     address addr = MacroAssembler::target_addr_for_insn(pc);
293     return *addr;
294   } else {
295     return (int)(intptr_t)MacroAssembler::target_addr_for_insn(instruction_address());
296   }
297 }
298 
299 void NativeMovRegMem::set_offset(int x) {
300   address pc = instruction_address();
301   unsigned insn = *(unsigned*)pc;
302   if (maybe_cpool_ref(pc)) {
303     address addr = MacroAssembler::target_addr_for_insn(pc);
304     *(long*)addr = x;
305   } else {
306     MacroAssembler::pd_patch_instruction(pc, (address)intptr_t(x));
307     ICache::invalidate_range(instruction_address(), instruction_size);
308   }
309 }
310 
311 void NativeMovRegMem::verify() {
312 #ifdef ASSERT
313   address dest = MacroAssembler::target_addr_for_insn(instruction_address());
314 #endif
315 }
316 
317 //--------------------------------------------------------------------------------
318 
319 void NativeJump::verify() { ; }
320 
321 
322 void NativeJump::check_verified_entry_alignment(address entry, address verified_entry) {
323 }
324 
325 
326 address NativeJump::jump_destination() const          {
327   address dest = MacroAssembler::target_addr_for_insn(instruction_address());
328 
329   // We use jump to self as the unresolved address which the inline
330   // cache code (and relocs) know about
<a name="4" id="anc4"></a>


331 
<a name="5" id="anc5"></a><span class="line-modified">332   // return -1 if jump to self</span>
<span class="line-modified">333   dest = (dest == (address) this) ? (address) -1 : dest;</span>


334   return dest;
335 }
336 
337 void NativeJump::set_jump_destination(address dest) {
338   // We use jump to self as the unresolved address which the inline
339   // cache code (and relocs) know about
340   if (dest == (address) -1)
341     dest = instruction_address();
342 
343   MacroAssembler::pd_patch_instruction(instruction_address(), dest);
344   ICache::invalidate_range(instruction_address(), instruction_size);
345 };
346 
347 //-------------------------------------------------------------------
348 
349 address NativeGeneralJump::jump_destination() const {
350   NativeMovConstReg* move = nativeMovConstReg_at(instruction_address());
351   address dest = (address) move-&gt;data();
352 
353   // We use jump to self as the unresolved address which the inline
354   // cache code (and relocs) know about
<a name="6" id="anc6"></a>

355 
<a name="7" id="anc7"></a><span class="line-modified">356   // return -1 if jump to self</span>
<span class="line-modified">357   dest = (dest == (address) this) ? (address) -1 : dest;</span>


358   return dest;
359 }
360 
361 void NativeGeneralJump::set_jump_destination(address dest) {
362   NativeMovConstReg* move = nativeMovConstReg_at(instruction_address());
363 
364   // We use jump to self as the unresolved address which the inline
365   // cache code (and relocs) know about
366   if (dest == (address) -1) {
367     dest = instruction_address();
368   }
369 
370   move-&gt;set_data((uintptr_t) dest);
371 };
372 
373 //-------------------------------------------------------------------
374 
375 bool NativeInstruction::is_safepoint_poll() {
376   // a safepoint_poll is implemented in two steps as either
377   //
378   // adrp(reg, polling_page);
379   // ldr(zr, [reg, #offset]);
380   //
381   // or
382   //
383   // mov(reg, polling_page);
384   // ldr(zr, [reg, #offset]);
385   //
386   // or
387   //
388   // ldr(reg, [rthread, #offset]);
389   // ldr(zr, [reg, #offset]);
390   //
391   // however, we cannot rely on the polling page address load always
392   // directly preceding the read from the page. C1 does that but C2
393   // has to do the load and read as two independent instruction
394   // generation steps. that&#39;s because with a single macro sequence the
395   // generic C2 code can only add the oop map before the mov/adrp and
396   // the trap handler expects an oop map to be associated with the
397   // load. with the load scheuled as a prior step the oop map goes
398   // where it is needed.
399   //
400   // so all we can do here is check that marked instruction is a load
401   // word to zr
402   return is_ldrw_to_zr(address(this));
403 }
404 
405 bool NativeInstruction::is_adrp_at(address instr) {
406   unsigned insn = *(unsigned*)instr;
407   return (Instruction_aarch64::extract(insn, 31, 24) &amp; 0b10011111) == 0b10010000;
408 }
409 
410 bool NativeInstruction::is_ldr_literal_at(address instr) {
411   unsigned insn = *(unsigned*)instr;
412   return (Instruction_aarch64::extract(insn, 29, 24) &amp; 0b011011) == 0b00011000;
413 }
414 
415 bool NativeInstruction::is_ldrw_to_zr(address instr) {
416   unsigned insn = *(unsigned*)instr;
417   return (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
418           Instruction_aarch64::extract(insn, 4, 0) == 0b11111);
419 }
420 
421 bool NativeInstruction::is_general_jump() {
422   if (is_movz()) {
423     NativeInstruction* inst1 = nativeInstruction_at(addr_at(instruction_size * 1));
424     if (inst1-&gt;is_movk()) {
425       NativeInstruction* inst2 = nativeInstruction_at(addr_at(instruction_size * 2));
426       if (inst2-&gt;is_movk()) {
427         NativeInstruction* inst3 = nativeInstruction_at(addr_at(instruction_size * 3));
428         if (inst3-&gt;is_blr()) {
429           return true;
430         }
431       }
432     }
433   }
434   return false;
435 }
436 
437 bool NativeInstruction::is_movz() {
438   return Instruction_aarch64::extract(int_at(0), 30, 23) == 0b10100101;
439 }
440 
441 bool NativeInstruction::is_movk() {
442   return Instruction_aarch64::extract(int_at(0), 30, 23) == 0b11100101;
443 }
444 
445 bool NativeInstruction::is_sigill_zombie_not_entrant() {
446   return uint_at(0) == 0xd4bbd5a1; // dcps1 #0xdead
447 }
448 
449 void NativeIllegalInstruction::insert(address code_pos) {
450   *(juint*)code_pos = 0xd4bbd5a1; // dcps1 #0xdead
451 }
452 
453 //-------------------------------------------------------------------
454 
455 // MT-safe inserting of a jump over a jump or a nop (used by
456 // nmethod::make_not_entrant_or_zombie)
457 
458 void NativeJump::patch_verified_entry(address entry, address verified_entry, address dest) {
459 
460   assert(dest == SharedRuntime::get_handle_wrong_method_stub(), &quot;expected fixed destination of patch&quot;);
461 
462 #ifdef ASSERT
463   // This may be the temporary nmethod generated while we&#39;re AOT
464   // compiling.  Such an nmethod doesn&#39;t begin with a NOP but with an ADRP.
465   if (! (CalculateClassFingerprint &amp;&amp; UseAOT &amp;&amp; is_adrp_at(verified_entry))) {
466     assert(nativeInstruction_at(verified_entry)-&gt;is_jump_or_nop()
467            || nativeInstruction_at(verified_entry)-&gt;is_sigill_zombie_not_entrant(),
468            &quot;Aarch64 cannot replace non-jump with jump&quot;);
469   }
470 #endif
471 
472   // Patch this nmethod atomically.
473   if (Assembler::reachable_from_branch_at(verified_entry, dest)) {
474     ptrdiff_t disp = dest - verified_entry;
475     guarantee(disp &lt; 1 &lt;&lt; 27 &amp;&amp; disp &gt; - (1 &lt;&lt; 27), &quot;branch overflow&quot;);
476 
477     unsigned int insn = (0b000101 &lt;&lt; 26) | ((disp &gt;&gt; 2) &amp; 0x3ffffff);
478     *(unsigned int*)verified_entry = insn;
479   } else {
480     // We use an illegal instruction for marking a method as
481     // not_entrant or zombie.
482     NativeIllegalInstruction::insert(verified_entry);
483   }
484 
485   ICache::invalidate_range(verified_entry, instruction_size);
486 }
487 
488 void NativeGeneralJump::verify() {  }
489 
490 void NativeGeneralJump::insert_unconditional(address code_pos, address entry) {
491   NativeGeneralJump* n_jump = (NativeGeneralJump*)code_pos;
492 
493   CodeBuffer cb(code_pos, instruction_size);
494   MacroAssembler a(&amp;cb);
495 
496   a.movptr(rscratch1, (uintptr_t)entry);
497   a.br(rscratch1);
498 
499   ICache::invalidate_range(code_pos, instruction_size);
500 }
501 
502 // MT-safe patching of a long jump instruction.
503 void NativeGeneralJump::replace_mt_safe(address instr_addr, address code_buffer) {
504   ShouldNotCallThis();
505 }
506 
507 address NativeCallTrampolineStub::destination(nmethod *nm) const {
508   return ptr_at(data_offset);
509 }
510 
511 void NativeCallTrampolineStub::set_destination(address new_destination) {
512   set_ptr_at(data_offset, new_destination);
513   OrderAccess::release();
514 }
515 
516 // Generate a trampoline for a branch to dest.  If there&#39;s no need for a
517 // trampoline, simply patch the call directly to dest.
518 address NativeCall::trampoline_jump(CodeBuffer &amp;cbuf, address dest) {
519   MacroAssembler a(&amp;cbuf);
520   address stub = NULL;
521 
522   if (a.far_branches()
523       &amp;&amp; ! is_NativeCallTrampolineStub_at(instruction_address() + displacement())) {
524     stub = a.emit_trampoline_stub(instruction_address() - cbuf.insts()-&gt;start(), dest);
525   }
526 
527   if (stub == NULL) {
528     // If we generated no stub, patch this call directly to dest.
529     // This will happen if we don&#39;t need far branches or if there
530     // already was a trampoline.
531     set_destination(dest);
532   }
533 
534   return stub;
535 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/register_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="register_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/register_aarch64.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #define CPU_AARCH64_REGISTER_AARCH64_HPP
 28 
 29 #include &quot;asm/register.hpp&quot;
 30 
 31 class VMRegImpl;
 32 typedef VMRegImpl* VMReg;
 33 
 34 // Use Register as shortcut
 35 class RegisterImpl;
 36 typedef RegisterImpl* Register;
 37 
 38 inline Register as_Register(int encoding) {
 39   return (Register)(intptr_t) encoding;
 40 }
 41 
 42 class RegisterImpl: public AbstractRegisterImpl {
 43  public:
 44   enum {
 45     number_of_registers         =   32,
 46     number_of_byte_registers      = 32,
<span class="line-modified"> 47     number_of_registers_for_jvmci = 34   // Including SP and ZR.</span>

 48   };
 49 
 50   // derived registers, offsets, and addresses
 51   Register successor() const                          { return as_Register(encoding() + 1); }
 52 
 53   // construction
 54   inline friend Register as_Register(int encoding);
 55 
 56   VMReg as_VMReg();
 57 
 58   // accessors
 59   int   encoding() const                         { assert(is_valid(), &quot;invalid register&quot;); return (intptr_t)this; }
 60   bool  is_valid() const                         { return 0 &lt;= (intptr_t)this &amp;&amp; (intptr_t)this &lt; number_of_registers; }
 61   bool  has_byte_register() const                { return 0 &lt;= (intptr_t)this &amp;&amp; (intptr_t)this &lt; number_of_byte_registers; }
 62   const char* name() const;
 63   int   encoding_nocheck() const                 { return (intptr_t)this; }
 64 
 65   // Return the bit which represents this register.  This is intended
 66   // to be ORed into a bitmask: for usage see class RegSet below.
 67   unsigned long bit(bool should_set = true) const { return should_set ? 1 &lt;&lt; encoding() : 0; }
</pre>
<hr />
<pre>
110 // instruction.
111 CONSTANT_REGISTER_DECLARATION(Register, r31_sp, (31));
112 CONSTANT_REGISTER_DECLARATION(Register, zr,  (32));
113 CONSTANT_REGISTER_DECLARATION(Register, sp,  (33));
114 
115 // Used as a filler in instructions where a register field is unused.
116 const Register dummy_reg = r31_sp;
117 
118 // Use FloatRegister as shortcut
119 class FloatRegisterImpl;
120 typedef FloatRegisterImpl* FloatRegister;
121 
122 inline FloatRegister as_FloatRegister(int encoding) {
123   return (FloatRegister)(intptr_t) encoding;
124 }
125 
126 // The implementation of floating point registers for the architecture
127 class FloatRegisterImpl: public AbstractRegisterImpl {
128  public:
129   enum {
<span class="line-modified">130     number_of_registers = 32</span>



131   };
132 
133   // construction
134   inline friend FloatRegister as_FloatRegister(int encoding);
135 
136   VMReg as_VMReg();
137 
138   // derived registers, offsets, and addresses
<span class="line-modified">139   FloatRegister successor() const                          { return as_FloatRegister(encoding() + 1); }</span>
140 
141   // accessors
142   int   encoding() const                          { assert(is_valid(), &quot;invalid register&quot;); return (intptr_t)this; }
143   int   encoding_nocheck() const                         { return (intptr_t)this; }
144   bool  is_valid() const                          { return 0 &lt;= (intptr_t)this &amp;&amp; (intptr_t)this &lt; number_of_registers; }
145   const char* name() const;
146 
147 };
148 
149 // The float registers of the AARCH64 architecture
150 
151 CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg , (-1));
152 
153 CONSTANT_REGISTER_DECLARATION(FloatRegister, v0     , ( 0));
154 CONSTANT_REGISTER_DECLARATION(FloatRegister, v1     , ( 1));
155 CONSTANT_REGISTER_DECLARATION(FloatRegister, v2     , ( 2));
156 CONSTANT_REGISTER_DECLARATION(FloatRegister, v3     , ( 3));
157 CONSTANT_REGISTER_DECLARATION(FloatRegister, v4     , ( 4));
158 CONSTANT_REGISTER_DECLARATION(FloatRegister, v5     , ( 5));
159 CONSTANT_REGISTER_DECLARATION(FloatRegister, v6     , ( 6));
</pre>
<hr />
<pre>
176 CONSTANT_REGISTER_DECLARATION(FloatRegister, v23    , (23));
177 CONSTANT_REGISTER_DECLARATION(FloatRegister, v24    , (24));
178 CONSTANT_REGISTER_DECLARATION(FloatRegister, v25    , (25));
179 CONSTANT_REGISTER_DECLARATION(FloatRegister, v26    , (26));
180 CONSTANT_REGISTER_DECLARATION(FloatRegister, v27    , (27));
181 CONSTANT_REGISTER_DECLARATION(FloatRegister, v28    , (28));
182 CONSTANT_REGISTER_DECLARATION(FloatRegister, v29    , (29));
183 CONSTANT_REGISTER_DECLARATION(FloatRegister, v30    , (30));
184 CONSTANT_REGISTER_DECLARATION(FloatRegister, v31    , (31));
185 
186 // Need to know the total number of registers of all sorts for SharedInfo.
187 // Define a class that exports it.
188 class ConcreteRegisterImpl : public AbstractRegisterImpl {
189  public:
190   enum {
191   // A big enough number for C2: all the registers plus flags
192   // This number must be large enough to cover REG_COUNT (defined by c2) registers.
193   // There is no requirement that any ordering here matches any ordering c2 gives
194   // it&#39;s optoregs.
195 
<span class="line-modified">196     number_of_registers = (2 * RegisterImpl::number_of_registers +</span>
<span class="line-modified">197                            4 * FloatRegisterImpl::number_of_registers +</span>
198                            1) // flags
199   };
200 
201   // added to make it compile
202   static const int max_gpr;
203   static const int max_fpr;
204 };
205 
206 // A set of registers
207 class RegSet {
208   uint32_t _bitset;
209 
210   RegSet(uint32_t bitset) : _bitset(bitset) { }
211 
212 public:
213 
214   RegSet() : _bitset(0) { }
215 
216   RegSet(Register r1) : _bitset(r1-&gt;bit()) { }
217 
218   RegSet operator+(const RegSet aSet) const {
219     RegSet result(_bitset | aSet._bitset);
220     return result;
221   }
222 
223   RegSet operator-(const RegSet aSet) const {
224     RegSet result(_bitset &amp; ~aSet._bitset);
225     return result;
226   }
227 
228   RegSet &amp;operator+=(const RegSet aSet) {
229     *this = *this + aSet;
230     return *this;
231   }
232 





233   static RegSet of(Register r1) {
234     return RegSet(r1);
235   }
236 
237   static RegSet of(Register r1, Register r2) {
238     return of(r1) + r2;
239   }
240 
241   static RegSet of(Register r1, Register r2, Register r3) {
242     return of(r1, r2) + r3;
243   }
244 
245   static RegSet of(Register r1, Register r2, Register r3, Register r4) {
246     return of(r1, r2, r3) + r4;
247   }
248 
249   static RegSet range(Register start, Register end) {
250     uint32_t bits = ~0;
251     bits &lt;&lt;= start-&gt;encoding();
252     bits &lt;&lt;= 31 - end-&gt;encoding();
</pre>
</td>
<td>
<hr />
<pre>
 27 #define CPU_AARCH64_REGISTER_AARCH64_HPP
 28 
 29 #include &quot;asm/register.hpp&quot;
 30 
 31 class VMRegImpl;
 32 typedef VMRegImpl* VMReg;
 33 
 34 // Use Register as shortcut
 35 class RegisterImpl;
 36 typedef RegisterImpl* Register;
 37 
 38 inline Register as_Register(int encoding) {
 39   return (Register)(intptr_t) encoding;
 40 }
 41 
 42 class RegisterImpl: public AbstractRegisterImpl {
 43  public:
 44   enum {
 45     number_of_registers         =   32,
 46     number_of_byte_registers      = 32,
<span class="line-modified"> 47     number_of_registers_for_jvmci = 34,  // Including SP and ZR.</span>
<span class="line-added"> 48     max_slots_per_register = 2</span>
 49   };
 50 
 51   // derived registers, offsets, and addresses
 52   Register successor() const                          { return as_Register(encoding() + 1); }
 53 
 54   // construction
 55   inline friend Register as_Register(int encoding);
 56 
 57   VMReg as_VMReg();
 58 
 59   // accessors
 60   int   encoding() const                         { assert(is_valid(), &quot;invalid register&quot;); return (intptr_t)this; }
 61   bool  is_valid() const                         { return 0 &lt;= (intptr_t)this &amp;&amp; (intptr_t)this &lt; number_of_registers; }
 62   bool  has_byte_register() const                { return 0 &lt;= (intptr_t)this &amp;&amp; (intptr_t)this &lt; number_of_byte_registers; }
 63   const char* name() const;
 64   int   encoding_nocheck() const                 { return (intptr_t)this; }
 65 
 66   // Return the bit which represents this register.  This is intended
 67   // to be ORed into a bitmask: for usage see class RegSet below.
 68   unsigned long bit(bool should_set = true) const { return should_set ? 1 &lt;&lt; encoding() : 0; }
</pre>
<hr />
<pre>
111 // instruction.
112 CONSTANT_REGISTER_DECLARATION(Register, r31_sp, (31));
113 CONSTANT_REGISTER_DECLARATION(Register, zr,  (32));
114 CONSTANT_REGISTER_DECLARATION(Register, sp,  (33));
115 
116 // Used as a filler in instructions where a register field is unused.
117 const Register dummy_reg = r31_sp;
118 
119 // Use FloatRegister as shortcut
120 class FloatRegisterImpl;
121 typedef FloatRegisterImpl* FloatRegister;
122 
123 inline FloatRegister as_FloatRegister(int encoding) {
124   return (FloatRegister)(intptr_t) encoding;
125 }
126 
127 // The implementation of floating point registers for the architecture
128 class FloatRegisterImpl: public AbstractRegisterImpl {
129  public:
130   enum {
<span class="line-modified">131     number_of_registers = 32,</span>
<span class="line-added">132     max_slots_per_register = 4,</span>
<span class="line-added">133     save_slots_per_register = 2,</span>
<span class="line-added">134     extra_save_slots_per_register = max_slots_per_register - save_slots_per_register</span>
135   };
136 
137   // construction
138   inline friend FloatRegister as_FloatRegister(int encoding);
139 
140   VMReg as_VMReg();
141 
142   // derived registers, offsets, and addresses
<span class="line-modified">143   FloatRegister successor() const                          { return as_FloatRegister((encoding() + 1) % 32); }</span>
144 
145   // accessors
146   int   encoding() const                          { assert(is_valid(), &quot;invalid register&quot;); return (intptr_t)this; }
147   int   encoding_nocheck() const                         { return (intptr_t)this; }
148   bool  is_valid() const                          { return 0 &lt;= (intptr_t)this &amp;&amp; (intptr_t)this &lt; number_of_registers; }
149   const char* name() const;
150 
151 };
152 
153 // The float registers of the AARCH64 architecture
154 
155 CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg , (-1));
156 
157 CONSTANT_REGISTER_DECLARATION(FloatRegister, v0     , ( 0));
158 CONSTANT_REGISTER_DECLARATION(FloatRegister, v1     , ( 1));
159 CONSTANT_REGISTER_DECLARATION(FloatRegister, v2     , ( 2));
160 CONSTANT_REGISTER_DECLARATION(FloatRegister, v3     , ( 3));
161 CONSTANT_REGISTER_DECLARATION(FloatRegister, v4     , ( 4));
162 CONSTANT_REGISTER_DECLARATION(FloatRegister, v5     , ( 5));
163 CONSTANT_REGISTER_DECLARATION(FloatRegister, v6     , ( 6));
</pre>
<hr />
<pre>
180 CONSTANT_REGISTER_DECLARATION(FloatRegister, v23    , (23));
181 CONSTANT_REGISTER_DECLARATION(FloatRegister, v24    , (24));
182 CONSTANT_REGISTER_DECLARATION(FloatRegister, v25    , (25));
183 CONSTANT_REGISTER_DECLARATION(FloatRegister, v26    , (26));
184 CONSTANT_REGISTER_DECLARATION(FloatRegister, v27    , (27));
185 CONSTANT_REGISTER_DECLARATION(FloatRegister, v28    , (28));
186 CONSTANT_REGISTER_DECLARATION(FloatRegister, v29    , (29));
187 CONSTANT_REGISTER_DECLARATION(FloatRegister, v30    , (30));
188 CONSTANT_REGISTER_DECLARATION(FloatRegister, v31    , (31));
189 
190 // Need to know the total number of registers of all sorts for SharedInfo.
191 // Define a class that exports it.
192 class ConcreteRegisterImpl : public AbstractRegisterImpl {
193  public:
194   enum {
195   // A big enough number for C2: all the registers plus flags
196   // This number must be large enough to cover REG_COUNT (defined by c2) registers.
197   // There is no requirement that any ordering here matches any ordering c2 gives
198   // it&#39;s optoregs.
199 
<span class="line-modified">200     number_of_registers = (RegisterImpl::max_slots_per_register * RegisterImpl::number_of_registers +</span>
<span class="line-modified">201                            FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers +</span>
202                            1) // flags
203   };
204 
205   // added to make it compile
206   static const int max_gpr;
207   static const int max_fpr;
208 };
209 
210 // A set of registers
211 class RegSet {
212   uint32_t _bitset;
213 
214   RegSet(uint32_t bitset) : _bitset(bitset) { }
215 
216 public:
217 
218   RegSet() : _bitset(0) { }
219 
220   RegSet(Register r1) : _bitset(r1-&gt;bit()) { }
221 
222   RegSet operator+(const RegSet aSet) const {
223     RegSet result(_bitset | aSet._bitset);
224     return result;
225   }
226 
227   RegSet operator-(const RegSet aSet) const {
228     RegSet result(_bitset &amp; ~aSet._bitset);
229     return result;
230   }
231 
232   RegSet &amp;operator+=(const RegSet aSet) {
233     *this = *this + aSet;
234     return *this;
235   }
236 
<span class="line-added">237   RegSet &amp;operator-=(const RegSet aSet) {</span>
<span class="line-added">238     *this = *this - aSet;</span>
<span class="line-added">239     return *this;</span>
<span class="line-added">240   }</span>
<span class="line-added">241 </span>
242   static RegSet of(Register r1) {
243     return RegSet(r1);
244   }
245 
246   static RegSet of(Register r1, Register r2) {
247     return of(r1) + r2;
248   }
249 
250   static RegSet of(Register r1, Register r2, Register r3) {
251     return of(r1, r2) + r3;
252   }
253 
254   static RegSet of(Register r1, Register r2, Register r3, Register r4) {
255     return of(r1, r2, r3) + r4;
256   }
257 
258   static RegSet range(Register start, Register end) {
259     uint32_t bits = ~0;
260     bits &lt;&lt;= start-&gt;encoding();
261     bits &lt;&lt;= 31 - end-&gt;encoding();
</pre>
</td>
</tr>
</table>
<center><a href="register_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
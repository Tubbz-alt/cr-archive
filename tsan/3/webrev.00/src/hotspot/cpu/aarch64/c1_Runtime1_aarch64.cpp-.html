<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/c1_Runtime1_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/assembler.hpp&quot;
  28 #include &quot;c1/c1_CodeStubs.hpp&quot;
  29 #include &quot;c1/c1_Defs.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;compiler/disassembler.hpp&quot;
  33 #include &quot;gc/shared/cardTable.hpp&quot;
  34 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  35 #include &quot;interpreter/interpreter.hpp&quot;
  36 #include &quot;nativeInst_aarch64.hpp&quot;
  37 #include &quot;oops/compiledICHolder.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;prims/jvmtiExport.hpp&quot;
  40 #include &quot;register_aarch64.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
  42 #include &quot;runtime/signature.hpp&quot;
  43 #include &quot;runtime/vframe.hpp&quot;
  44 #include &quot;runtime/vframeArray.hpp&quot;
  45 #include &quot;vmreg_aarch64.inline.hpp&quot;
  46 
  47 
  48 // Implementation of StubAssembler
  49 
  50 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, int args_size) {
  51   // setup registers
  52   assert(!(oop_result1-&gt;is_valid() || metadata_result-&gt;is_valid()) || oop_result1 != metadata_result, &quot;registers must be different&quot;);
  53   assert(oop_result1 != rthread &amp;&amp; metadata_result != rthread, &quot;registers must be different&quot;);
  54   assert(args_size &gt;= 0, &quot;illegal args_size&quot;);
  55   bool align_stack = false;
  56 
  57   mov(c_rarg0, rthread);
  58   set_num_rt_args(0); // Nothing on stack
  59 
  60   Label retaddr;
  61   set_last_Java_frame(sp, rfp, retaddr, rscratch1);
  62 
  63   // do the call
  64   lea(rscratch1, RuntimeAddress(entry));
  65   blrt(rscratch1, args_size + 1, 8, 1);
  66   bind(retaddr);
  67   int call_offset = offset();
  68   // verify callee-saved register
  69 #ifdef ASSERT
  70   push(r0, sp);
  71   { Label L;
  72     get_thread(r0);
  73     cmp(rthread, r0);
  74     br(Assembler::EQ, L);
  75     stop(&quot;StubAssembler::call_RT: rthread not callee saved?&quot;);
  76     bind(L);
  77   }
  78   pop(r0, sp);
  79 #endif
  80   reset_last_Java_frame(true);
  81   maybe_isb();
  82 
  83   // check for pending exceptions
  84   { Label L;
  85     // check for pending exceptions (java_thread is set upon return)
  86     ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
  87     cbz(rscratch1, L);
  88     // exception pending =&gt; remove activation and forward to exception handler
  89     // make sure that the vm_results are cleared
  90     if (oop_result1-&gt;is_valid()) {
  91       str(zr, Address(rthread, JavaThread::vm_result_offset()));
  92     }
  93     if (metadata_result-&gt;is_valid()) {
  94       str(zr, Address(rthread, JavaThread::vm_result_2_offset()));
  95     }
  96     if (frame_size() == no_frame_size) {
  97       leave();
  98       far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
  99     } else if (_stub_id == Runtime1::forward_exception_id) {
 100       should_not_reach_here();
 101     } else {
 102       far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::forward_exception_id)));
 103     }
 104     bind(L);
 105   }
 106   // get oop results if there are any and reset the values in the thread
 107   if (oop_result1-&gt;is_valid()) {
 108     get_vm_result(oop_result1, rthread);
 109   }
 110   if (metadata_result-&gt;is_valid()) {
 111     get_vm_result_2(metadata_result, rthread);
 112   }
 113   return call_offset;
 114 }
 115 
 116 
 117 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, Register arg1) {
 118   mov(c_rarg1, arg1);
 119   return call_RT(oop_result1, metadata_result, entry, 1);
 120 }
 121 
 122 
 123 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, Register arg1, Register arg2) {
 124   if (c_rarg1 == arg2) {
 125     if (c_rarg2 == arg1) {
 126       mov(rscratch1, arg1);
 127       mov(arg1, arg2);
 128       mov(arg2, rscratch1);
 129     } else {
 130       mov(c_rarg2, arg2);
 131       mov(c_rarg1, arg1);
 132     }
 133   } else {
 134     mov(c_rarg1, arg1);
 135     mov(c_rarg2, arg2);
 136   }
 137   return call_RT(oop_result1, metadata_result, entry, 2);
 138 }
 139 
 140 
 141 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, Register arg1, Register arg2, Register arg3) {
 142   // if there is any conflict use the stack
 143   if (arg1 == c_rarg2 || arg1 == c_rarg3 ||
 144       arg2 == c_rarg1 || arg1 == c_rarg3 ||
 145       arg3 == c_rarg1 || arg1 == c_rarg2) {
 146     stp(arg3, arg2, Address(pre(sp, 2 * wordSize)));
 147     stp(arg1, zr, Address(pre(sp, -2 * wordSize)));
 148     ldp(c_rarg1, zr, Address(post(sp, 2 * wordSize)));
 149     ldp(c_rarg3, c_rarg2, Address(post(sp, 2 * wordSize)));
 150   } else {
 151     mov(c_rarg1, arg1);
 152     mov(c_rarg2, arg2);
 153     mov(c_rarg3, arg3);
 154   }
 155   return call_RT(oop_result1, metadata_result, entry, 3);
 156 }
 157 
 158 // Implementation of StubFrame
 159 
 160 class StubFrame: public StackObj {
 161  private:
 162   StubAssembler* _sasm;
 163 
 164  public:
 165   StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments);
 166   void load_argument(int offset_in_words, Register reg);
 167 
 168   ~StubFrame();
 169 };;
 170 
 171 void StubAssembler::prologue(const char* name, bool must_gc_arguments) {
 172   set_info(name, must_gc_arguments);
 173   enter();
 174 }
 175 
 176 void StubAssembler::epilogue() {
 177   leave();
 178   ret(lr);
 179 }
 180 
 181 #define __ _sasm-&gt;
 182 
 183 StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments) {
 184   _sasm = sasm;
 185   __ prologue(name, must_gc_arguments);
 186 }
 187 
 188 // load parameters that were stored with LIR_Assembler::store_parameter
 189 // Note: offsets for store_parameter and load_argument must match
 190 void StubFrame::load_argument(int offset_in_words, Register reg) {
 191   __ load_parameter(offset_in_words, reg);
 192 }
 193 
 194 
 195 StubFrame::~StubFrame() {
 196   __ epilogue();
 197 }
 198 
 199 #undef __
 200 
 201 
 202 // Implementation of Runtime1
 203 
 204 #define __ sasm-&gt;
 205 
 206 const int float_regs_as_doubles_size_in_slots = pd_nof_fpu_regs_frame_map * 2;
 207 
 208 // Stack layout for saving/restoring  all the registers needed during a runtime
 209 // call (this includes deoptimization)
 210 // Note: note that users of this frame may well have arguments to some runtime
 211 // while these values are on the stack. These positions neglect those arguments
 212 // but the code in save_live_registers will take the argument count into
 213 // account.
 214 //
 215 
 216 enum reg_save_layout {
 217   reg_save_frame_size = 32 /* float */ + 32 /* integer */
 218 };
 219 
 220 // Save off registers which might be killed by calls into the runtime.
 221 // Tries to smart of about FP registers.  In particular we separate
 222 // saving and describing the FPU registers for deoptimization since we
 223 // have to save the FPU registers twice if we describe them.  The
 224 // deopt blob is the only thing which needs to describe FPU registers.
 225 // In all other cases it should be sufficient to simply save their
 226 // current value.
 227 
 228 static int cpu_reg_save_offsets[FrameMap::nof_cpu_regs];
 229 static int fpu_reg_save_offsets[FrameMap::nof_fpu_regs];
 230 static int reg_save_size_in_words;
 231 static int frame_size_in_bytes = -1;
 232 
 233 static OopMap* generate_oop_map(StubAssembler* sasm, bool save_fpu_registers) {
 234   int frame_size_in_bytes = reg_save_frame_size * BytesPerWord;
 235   sasm-&gt;set_frame_size(frame_size_in_bytes / BytesPerWord);
 236   int frame_size_in_slots = frame_size_in_bytes / sizeof(jint);
 237   OopMap* oop_map = new OopMap(frame_size_in_slots, 0);
 238 
 239   for (int i = 0; i &lt; FrameMap::nof_cpu_regs; i++) {
 240     Register r = as_Register(i);
 241     if (i &lt;= 18 &amp;&amp; i != rscratch1-&gt;encoding() &amp;&amp; i != rscratch2-&gt;encoding()) {
 242       int sp_offset = cpu_reg_save_offsets[i];
 243       oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
 244                                 r-&gt;as_VMReg());
 245     }
 246   }
 247 
 248   if (save_fpu_registers) {
 249     for (int i = 0; i &lt; FrameMap::nof_fpu_regs; i++) {
 250       FloatRegister r = as_FloatRegister(i);
 251       {
 252         int sp_offset = fpu_reg_save_offsets[i];
 253         oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
 254                                   r-&gt;as_VMReg());
 255       }
 256     }
 257   }
 258   return oop_map;
 259 }
 260 
 261 static OopMap* save_live_registers(StubAssembler* sasm,
 262                                    bool save_fpu_registers = true) {
 263   __ block_comment(&quot;save_live_registers&quot;);
 264 
 265   __ push(RegSet::range(r0, r29), sp);         // integer registers except lr &amp; sp
 266 
 267   if (save_fpu_registers) {
 268     for (int i = 31; i&gt;= 0; i -= 4) {
 269       __ sub(sp, sp, 4 * wordSize); // no pre-increment for st1. Emulate it without modifying other registers
 270       __ st1(as_FloatRegister(i-3), as_FloatRegister(i-2), as_FloatRegister(i-1),
 271           as_FloatRegister(i), __ T1D, Address(sp));
 272     }
 273   } else {
 274     __ add(sp, sp, -32 * wordSize);
 275   }
 276 
 277   return generate_oop_map(sasm, save_fpu_registers);
 278 }
 279 
 280 static void restore_live_registers(StubAssembler* sasm, bool restore_fpu_registers = true) {
 281   if (restore_fpu_registers) {
 282     for (int i = 0; i &lt; 32; i += 4)
 283       __ ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
 284           as_FloatRegister(i+3), __ T1D, Address(__ post(sp, 4 * wordSize)));
 285   } else {
 286     __ add(sp, sp, 32 * wordSize);
 287   }
 288 
 289   __ pop(RegSet::range(r0, r29), sp);
 290 }
 291 
 292 static void restore_live_registers_except_r0(StubAssembler* sasm, bool restore_fpu_registers = true)  {
 293 
 294   if (restore_fpu_registers) {
 295     for (int i = 0; i &lt; 32; i += 4)
 296       __ ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
 297           as_FloatRegister(i+3), __ T1D, Address(__ post(sp, 4 * wordSize)));
 298   } else {
 299     __ add(sp, sp, 32 * wordSize);
 300   }
 301 
 302   __ ldp(zr, r1, Address(__ post(sp, 16)));
 303   __ pop(RegSet::range(r2, r29), sp);
 304 }
 305 
 306 
 307 
 308 void Runtime1::initialize_pd() {
 309   int i;
 310   int sp_offset = 0;
 311 
 312   // all float registers are saved explicitly
 313   assert(FrameMap::nof_fpu_regs == 32, &quot;double registers not handled here&quot;);
 314   for (i = 0; i &lt; FrameMap::nof_fpu_regs; i++) {
 315     fpu_reg_save_offsets[i] = sp_offset;
 316     sp_offset += 2;   // SP offsets are in halfwords
 317   }
 318 
 319   for (i = 0; i &lt; FrameMap::nof_cpu_regs; i++) {
 320     Register r = as_Register(i);
 321     cpu_reg_save_offsets[i] = sp_offset;
 322     sp_offset += 2;   // SP offsets are in halfwords
 323   }
 324 }
 325 
 326 
 327 // target: the entry point of the method that creates and posts the exception oop
 328 // has_argument: true if the exception needs arguments (passed in rscratch1 and rscratch2)
 329 
 330 OopMapSet* Runtime1::generate_exception_throw(StubAssembler* sasm, address target, bool has_argument) {
 331   // make a frame and preserve the caller&#39;s caller-save registers
 332   OopMap* oop_map = save_live_registers(sasm);
 333   int call_offset;
 334   if (!has_argument) {
 335     call_offset = __ call_RT(noreg, noreg, target);
 336   } else {
 337     __ mov(c_rarg1, rscratch1);
 338     __ mov(c_rarg2, rscratch2);
 339     call_offset = __ call_RT(noreg, noreg, target);
 340   }
 341   OopMapSet* oop_maps = new OopMapSet();
 342   oop_maps-&gt;add_gc_map(call_offset, oop_map);
 343 
 344   __ should_not_reach_here();
 345   return oop_maps;
 346 }
 347 
 348 
 349 OopMapSet* Runtime1::generate_handle_exception(StubID id, StubAssembler *sasm) {
 350   __ block_comment(&quot;generate_handle_exception&quot;);
 351 
 352   // incoming parameters
 353   const Register exception_oop = r0;
 354   const Register exception_pc  = r3;
 355   // other registers used in this stub
 356 
 357   // Save registers, if required.
 358   OopMapSet* oop_maps = new OopMapSet();
 359   OopMap* oop_map = NULL;
 360   switch (id) {
 361   case forward_exception_id:
 362     // We&#39;re handling an exception in the context of a compiled frame.
 363     // The registers have been saved in the standard places.  Perform
 364     // an exception lookup in the caller and dispatch to the handler
 365     // if found.  Otherwise unwind and dispatch to the callers
 366     // exception handler.
 367     oop_map = generate_oop_map(sasm, 1 /*thread*/);
 368 
 369     // load and clear pending exception oop into r0
 370     __ ldr(exception_oop, Address(rthread, Thread::pending_exception_offset()));
 371     __ str(zr, Address(rthread, Thread::pending_exception_offset()));
 372 
 373     // load issuing PC (the return address for this stub) into r3
 374     __ ldr(exception_pc, Address(rfp, 1*BytesPerWord));
 375 
 376     // make sure that the vm_results are cleared (may be unnecessary)
 377     __ str(zr, Address(rthread, JavaThread::vm_result_offset()));
 378     __ str(zr, Address(rthread, JavaThread::vm_result_2_offset()));
 379     break;
 380   case handle_exception_nofpu_id:
 381   case handle_exception_id:
 382     // At this point all registers MAY be live.
 383     oop_map = save_live_registers(sasm, id != handle_exception_nofpu_id);
 384     break;
 385   case handle_exception_from_callee_id: {
 386     // At this point all registers except exception oop (r0) and
 387     // exception pc (lr) are dead.
 388     const int frame_size = 2 /*fp, return address*/;
 389     oop_map = new OopMap(frame_size * VMRegImpl::slots_per_word, 0);
 390     sasm-&gt;set_frame_size(frame_size);
 391     break;
 392   }
 393   default:
 394     __ should_not_reach_here();
 395     break;
 396   }
 397 
 398   // verify that only r0 and r3 are valid at this time
 399   __ invalidate_registers(false, true, true, false, true, true);
 400   // verify that r0 contains a valid exception
 401   __ verify_not_null_oop(exception_oop);
 402 
 403 #ifdef ASSERT
 404   // check that fields in JavaThread for exception oop and issuing pc are
 405   // empty before writing to them
 406   Label oop_empty;
 407   __ ldr(rscratch1, Address(rthread, JavaThread::exception_oop_offset()));
 408   __ cbz(rscratch1, oop_empty);
 409   __ stop(&quot;exception oop already set&quot;);
 410   __ bind(oop_empty);
 411 
 412   Label pc_empty;
 413   __ ldr(rscratch1, Address(rthread, JavaThread::exception_pc_offset()));
 414   __ cbz(rscratch1, pc_empty);
 415   __ stop(&quot;exception pc already set&quot;);
 416   __ bind(pc_empty);
 417 #endif
 418 
 419   // save exception oop and issuing pc into JavaThread
 420   // (exception handler will load it from here)
 421   __ str(exception_oop, Address(rthread, JavaThread::exception_oop_offset()));
 422   __ str(exception_pc, Address(rthread, JavaThread::exception_pc_offset()));
 423 
 424   // patch throwing pc into return address (has bci &amp; oop map)
 425   __ str(exception_pc, Address(rfp, 1*BytesPerWord));
 426 
 427   // compute the exception handler.
 428   // the exception oop and the throwing pc are read from the fields in JavaThread
 429   int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, exception_handler_for_pc));
 430   oop_maps-&gt;add_gc_map(call_offset, oop_map);
 431 
 432   // r0: handler address
 433   //      will be the deopt blob if nmethod was deoptimized while we looked up
 434   //      handler regardless of whether handler existed in the nmethod.
 435 
 436   // only r0 is valid at this time, all other registers have been destroyed by the runtime call
 437   __ invalidate_registers(false, true, true, true, true, true);
 438 
 439   // patch the return address, this stub will directly return to the exception handler
 440   __ str(r0, Address(rfp, 1*BytesPerWord));
 441 
 442   switch (id) {
 443   case forward_exception_id:
 444   case handle_exception_nofpu_id:
 445   case handle_exception_id:
 446     // Restore the registers that were saved at the beginning.
 447     restore_live_registers(sasm, id != handle_exception_nofpu_id);
 448     break;
 449   case handle_exception_from_callee_id:
 450     // Pop the return address.
 451     __ leave();
 452     __ ret(lr);  // jump to exception handler
 453     break;
 454   default:  ShouldNotReachHere();
 455   }
 456 
 457   return oop_maps;
 458 }
 459 
 460 
 461 void Runtime1::generate_unwind_exception(StubAssembler *sasm) {
 462   // incoming parameters
 463   const Register exception_oop = r0;
 464   // callee-saved copy of exception_oop during runtime call
 465   const Register exception_oop_callee_saved = r19;
 466   // other registers used in this stub
 467   const Register exception_pc = r3;
 468   const Register handler_addr = r1;
 469 
 470   // verify that only r0, is valid at this time
 471   __ invalidate_registers(false, true, true, true, true, true);
 472 
 473 #ifdef ASSERT
 474   // check that fields in JavaThread for exception oop and issuing pc are empty
 475   Label oop_empty;
 476   __ ldr(rscratch1, Address(rthread, JavaThread::exception_oop_offset()));
 477   __ cbz(rscratch1, oop_empty);
 478   __ stop(&quot;exception oop must be empty&quot;);
 479   __ bind(oop_empty);
 480 
 481   Label pc_empty;
 482   __ ldr(rscratch1, Address(rthread, JavaThread::exception_pc_offset()));
 483   __ cbz(rscratch1, pc_empty);
 484   __ stop(&quot;exception pc must be empty&quot;);
 485   __ bind(pc_empty);
 486 #endif
 487 
 488   // Save our return address because
 489   // exception_handler_for_return_address will destroy it.  We also
 490   // save exception_oop
 491   __ stp(lr, exception_oop, Address(__ pre(sp, -2 * wordSize)));
 492 
 493   // search the exception handler address of the caller (using the return address)
 494   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), rthread, lr);
 495   // r0: exception handler address of the caller
 496 
 497   // Only R0 is valid at this time; all other registers have been
 498   // destroyed by the call.
 499   __ invalidate_registers(false, true, true, true, false, true);
 500 
 501   // move result of call into correct register
 502   __ mov(handler_addr, r0);
 503 
 504   // get throwing pc (= return address).
 505   // lr has been destroyed by the call
 506   __ ldp(lr, exception_oop, Address(__ post(sp, 2 * wordSize)));
 507   __ mov(r3, lr);
 508 
 509   __ verify_not_null_oop(exception_oop);
 510 
 511   // continue at exception handler (return address removed)
 512   // note: do *not* remove arguments when unwinding the
 513   //       activation since the caller assumes having
 514   //       all arguments on the stack when entering the
 515   //       runtime to determine the exception handler
 516   //       (GC happens at call site with arguments!)
 517   // r0: exception oop
 518   // r3: throwing pc
 519   // r1: exception handler
 520   __ br(handler_addr);
 521 }
 522 
 523 
 524 
 525 OopMapSet* Runtime1::generate_patching(StubAssembler* sasm, address target) {
 526   // use the maximum number of runtime-arguments here because it is difficult to
 527   // distinguish each RT-Call.
 528   // Note: This number affects also the RT-Call in generate_handle_exception because
 529   //       the oop-map is shared for all calls.
 530   DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
 531   assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
 532 
 533   OopMap* oop_map = save_live_registers(sasm);
 534 
 535   __ mov(c_rarg0, rthread);
 536   Label retaddr;
 537   __ set_last_Java_frame(sp, rfp, retaddr, rscratch1);
 538   // do the call
 539   __ lea(rscratch1, RuntimeAddress(target));
 540   __ blrt(rscratch1, 1, 0, 1);
 541   __ bind(retaddr);
 542   OopMapSet* oop_maps = new OopMapSet();
 543   oop_maps-&gt;add_gc_map(__ offset(), oop_map);
 544   // verify callee-saved register
 545 #ifdef ASSERT
 546   { Label L;
 547     __ get_thread(rscratch1);
 548     __ cmp(rthread, rscratch1);
 549     __ br(Assembler::EQ, L);
 550     __ stop(&quot;StubAssembler::call_RT: rthread not callee saved?&quot;);
 551     __ bind(L);
 552   }
 553 #endif
 554   __ reset_last_Java_frame(true);
 555   __ maybe_isb();
 556 
 557   // check for pending exceptions
 558   { Label L;
 559     __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
 560     __ cbz(rscratch1, L);
 561     // exception pending =&gt; remove activation and forward to exception handler
 562 
 563     { Label L1;
 564       __ cbnz(r0, L1);                                  // have we deoptimized?
 565       __ far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::forward_exception_id)));
 566       __ bind(L1);
 567     }
 568 
 569     // the deopt blob expects exceptions in the special fields of
 570     // JavaThread, so copy and clear pending exception.
 571 
 572     // load and clear pending exception
 573     __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
 574     __ str(zr, Address(rthread, Thread::pending_exception_offset()));
 575 
 576     // check that there is really a valid exception
 577     __ verify_not_null_oop(r0);
 578 
 579     // load throwing pc: this is the return address of the stub
 580     __ mov(r3, lr);
 581 
 582 #ifdef ASSERT
 583     // check that fields in JavaThread for exception oop and issuing pc are empty
 584     Label oop_empty;
 585     __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
 586     __ cbz(rscratch1, oop_empty);
 587     __ stop(&quot;exception oop must be empty&quot;);
 588     __ bind(oop_empty);
 589 
 590     Label pc_empty;
 591     __ ldr(rscratch1, Address(rthread, JavaThread::exception_pc_offset()));
 592     __ cbz(rscratch1, pc_empty);
 593     __ stop(&quot;exception pc must be empty&quot;);
 594     __ bind(pc_empty);
 595 #endif
 596 
 597     // store exception oop and throwing pc to JavaThread
 598     __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
 599     __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
 600 
 601     restore_live_registers(sasm);
 602 
 603     __ leave();
 604 
 605     // Forward the exception directly to deopt blob. We can blow no
 606     // registers and must leave throwing pc on the stack.  A patch may
 607     // have values live in registers so the entry point with the
 608     // exception in tls.
 609     __ far_jump(RuntimeAddress(deopt_blob-&gt;unpack_with_exception_in_tls()));
 610 
 611     __ bind(L);
 612   }
 613 
 614 
 615   // Runtime will return true if the nmethod has been deoptimized during
 616   // the patching process. In that case we must do a deopt reexecute instead.
 617 
 618   Label cont;
 619 
 620   __ cbz(r0, cont);                                 // have we deoptimized?
 621 
 622   // Will reexecute. Proper return address is already on the stack we just restore
 623   // registers, pop all of our frame but the return address and jump to the deopt blob
 624   restore_live_registers(sasm);
 625   __ leave();
 626   __ far_jump(RuntimeAddress(deopt_blob-&gt;unpack_with_reexecution()));
 627 
 628   __ bind(cont);
 629   restore_live_registers(sasm);
 630   __ leave();
 631   __ ret(lr);
 632 
 633   return oop_maps;
 634 }
 635 
 636 
 637 OopMapSet* Runtime1::generate_code_for(StubID id, StubAssembler* sasm) {
 638 
 639   const Register exception_oop = r0;
 640   const Register exception_pc  = r3;
 641 
 642   // for better readability
 643   const bool must_gc_arguments = true;
 644   const bool dont_gc_arguments = false;
 645 
 646   // default value; overwritten for some optimized stubs that are called from methods that do not use the fpu
 647   bool save_fpu_registers = true;
 648 
 649   // stub code &amp; info for the different stubs
 650   OopMapSet* oop_maps = NULL;
 651   OopMap* oop_map = NULL;
 652   switch (id) {
 653     {
 654     case forward_exception_id:
 655       {
 656         oop_maps = generate_handle_exception(id, sasm);
 657         __ leave();
 658         __ ret(lr);
 659       }
 660       break;
 661 
 662     case throw_div0_exception_id:
 663       { StubFrame f(sasm, &quot;throw_div0_exception&quot;, dont_gc_arguments);
 664         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_div0_exception), false);
 665       }
 666       break;
 667 
 668     case throw_null_pointer_exception_id:
 669       { StubFrame f(sasm, &quot;throw_null_pointer_exception&quot;, dont_gc_arguments);
 670         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_null_pointer_exception), false);
 671       }
 672       break;
 673 
 674     case new_instance_id:
 675     case fast_new_instance_id:
 676     case fast_new_instance_init_check_id:
 677       {
 678         Register klass = r3; // Incoming
 679         Register obj   = r0; // Result
 680 
 681         if (id == new_instance_id) {
 682           __ set_info(&quot;new_instance&quot;, dont_gc_arguments);
 683         } else if (id == fast_new_instance_id) {
 684           __ set_info(&quot;fast new_instance&quot;, dont_gc_arguments);
 685         } else {
 686           assert(id == fast_new_instance_init_check_id, &quot;bad StubID&quot;);
 687           __ set_info(&quot;fast new_instance init check&quot;, dont_gc_arguments);
 688         }
 689 
 690         // If TLAB is disabled, see if there is support for inlining contiguous
 691         // allocations.
 692         // Otherwise, just go to the slow path.
 693         if ((id == fast_new_instance_id || id == fast_new_instance_init_check_id) &amp;&amp;
 694             !UseTLAB &amp;&amp; Universe::heap()-&gt;supports_inline_contig_alloc()) {
 695           Label slow_path;
 696           Register obj_size = r2;
 697           Register t1       = r19;
 698           Register t2       = r4;
 699           assert_different_registers(klass, obj, obj_size, t1, t2);
 700 
 701           __ stp(r19, zr, Address(__ pre(sp, -2 * wordSize)));
 702 
 703           if (id == fast_new_instance_init_check_id) {
 704             // make sure the klass is initialized
 705             __ ldrb(rscratch1, Address(klass, InstanceKlass::init_state_offset()));
 706             __ cmpw(rscratch1, InstanceKlass::fully_initialized);
 707             __ br(Assembler::NE, slow_path);
 708           }
 709 
 710 #ifdef ASSERT
 711           // assert object can be fast path allocated
 712           {
 713             Label ok, not_ok;
 714             __ ldrw(obj_size, Address(klass, Klass::layout_helper_offset()));
 715             __ cmp(obj_size, (u1)0);
 716             __ br(Assembler::LE, not_ok);  // make sure it&#39;s an instance (LH &gt; 0)
 717             __ tstw(obj_size, Klass::_lh_instance_slow_path_bit);
 718             __ br(Assembler::EQ, ok);
 719             __ bind(not_ok);
 720             __ stop(&quot;assert(can be fast path allocated)&quot;);
 721             __ should_not_reach_here();
 722             __ bind(ok);
 723           }
 724 #endif // ASSERT
 725 
 726           // get the instance size (size is postive so movl is fine for 64bit)
 727           __ ldrw(obj_size, Address(klass, Klass::layout_helper_offset()));
 728 
 729           __ eden_allocate(obj, obj_size, 0, t1, slow_path);
 730 
 731           __ initialize_object(obj, klass, obj_size, 0, t1, t2, /* is_tlab_allocated */ false);
 732           __ verify_oop(obj);
 733           __ ldp(r19, zr, Address(__ post(sp, 2 * wordSize)));
 734           __ ret(lr);
 735 
 736           __ bind(slow_path);
 737           __ ldp(r19, zr, Address(__ post(sp, 2 * wordSize)));
 738         }
 739 
 740         __ enter();
 741         OopMap* map = save_live_registers(sasm);
 742         int call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);
 743         oop_maps = new OopMapSet();
 744         oop_maps-&gt;add_gc_map(call_offset, map);
 745         restore_live_registers_except_r0(sasm);
 746         __ verify_oop(obj);
 747         __ leave();
 748         __ ret(lr);
 749 
 750         // r0,: new instance
 751       }
 752 
 753       break;
 754 
 755     case counter_overflow_id:
 756       {
 757         Register bci = r0, method = r1;
 758         __ enter();
 759         OopMap* map = save_live_registers(sasm);
 760         // Retrieve bci
 761         __ ldrw(bci, Address(rfp, 2*BytesPerWord));
 762         // And a pointer to the Method*
 763         __ ldr(method, Address(rfp, 3*BytesPerWord));
 764         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, counter_overflow), bci, method);
 765         oop_maps = new OopMapSet();
 766         oop_maps-&gt;add_gc_map(call_offset, map);
 767         restore_live_registers(sasm);
 768         __ leave();
 769         __ ret(lr);
 770       }
 771       break;
 772 
 773     case new_type_array_id:
 774     case new_object_array_id:
 775       {
 776         Register length   = r19; // Incoming
 777         Register klass    = r3; // Incoming
 778         Register obj      = r0; // Result
 779 
 780         if (id == new_type_array_id) {
 781           __ set_info(&quot;new_type_array&quot;, dont_gc_arguments);
 782         } else {
 783           __ set_info(&quot;new_object_array&quot;, dont_gc_arguments);
 784         }
 785 
 786 #ifdef ASSERT
 787         // assert object type is really an array of the proper kind
 788         {
 789           Label ok;
 790           Register t0 = obj;
 791           __ ldrw(t0, Address(klass, Klass::layout_helper_offset()));
 792           __ asrw(t0, t0, Klass::_lh_array_tag_shift);
 793           int tag = ((id == new_type_array_id)
 794                      ? Klass::_lh_array_tag_type_value
 795                      : Klass::_lh_array_tag_obj_value);
 796           __ mov(rscratch1, tag);
 797           __ cmpw(t0, rscratch1);
 798           __ br(Assembler::EQ, ok);
 799           __ stop(&quot;assert(is an array klass)&quot;);
 800           __ should_not_reach_here();
 801           __ bind(ok);
 802         }
 803 #endif // ASSERT
 804 
 805         // If TLAB is disabled, see if there is support for inlining contiguous
 806         // allocations.
 807         // Otherwise, just go to the slow path.
 808         if (!UseTLAB &amp;&amp; Universe::heap()-&gt;supports_inline_contig_alloc()) {
 809           Register arr_size = r4;
 810           Register t1       = r2;
 811           Register t2       = r5;
 812           Label slow_path;
 813           assert_different_registers(length, klass, obj, arr_size, t1, t2);
 814 
 815           // check that array length is small enough for fast path.
 816           __ mov(rscratch1, C1_MacroAssembler::max_array_allocation_length);
 817           __ cmpw(length, rscratch1);
 818           __ br(Assembler::HI, slow_path);
 819 
 820           // get the allocation size: round_up(hdr + length &lt;&lt; (layout_helper &amp; 0x1F))
 821           // since size is positive ldrw does right thing on 64bit
 822           __ ldrw(t1, Address(klass, Klass::layout_helper_offset()));
 823           // since size is positive movw does right thing on 64bit
 824           __ movw(arr_size, length);
 825           __ lslvw(arr_size, length, t1);
 826           __ ubfx(t1, t1, Klass::_lh_header_size_shift,
 827                   exact_log2(Klass::_lh_header_size_mask + 1));
 828           __ add(arr_size, arr_size, t1);
 829           __ add(arr_size, arr_size, MinObjAlignmentInBytesMask); // align up
 830           __ andr(arr_size, arr_size, ~MinObjAlignmentInBytesMask);
 831 
 832           __ eden_allocate(obj, arr_size, 0, t1, slow_path);  // preserves arr_size
 833 
 834           __ initialize_header(obj, klass, length, t1, t2);
 835           __ ldrb(t1, Address(klass, in_bytes(Klass::layout_helper_offset()) + (Klass::_lh_header_size_shift / BitsPerByte)));
 836           assert(Klass::_lh_header_size_shift % BitsPerByte == 0, &quot;bytewise&quot;);
 837           assert(Klass::_lh_header_size_mask &lt;= 0xFF, &quot;bytewise&quot;);
 838           __ andr(t1, t1, Klass::_lh_header_size_mask);
 839           __ sub(arr_size, arr_size, t1);  // body length
 840           __ add(t1, t1, obj);       // body start
 841           __ initialize_body(t1, arr_size, 0, t2);
 842           __ verify_oop(obj);
 843 
 844           __ ret(lr);
 845 
 846           __ bind(slow_path);
 847         }
 848 
 849         __ enter();
 850         OopMap* map = save_live_registers(sasm);
 851         int call_offset;
 852         if (id == new_type_array_id) {
 853           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_type_array), klass, length);
 854         } else {
 855           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_object_array), klass, length);
 856         }
 857 
 858         oop_maps = new OopMapSet();
 859         oop_maps-&gt;add_gc_map(call_offset, map);
 860         restore_live_registers_except_r0(sasm);
 861 
 862         __ verify_oop(obj);
 863         __ leave();
 864         __ ret(lr);
 865 
 866         // r0: new array
 867       }
 868       break;
 869 
 870     case new_multi_array_id:
 871       { StubFrame f(sasm, &quot;new_multi_array&quot;, dont_gc_arguments);
 872         // r0,: klass
 873         // r19,: rank
 874         // r2: address of 1st dimension
 875         OopMap* map = save_live_registers(sasm);
 876         __ mov(c_rarg1, r0);
 877         __ mov(c_rarg3, r2);
 878         __ mov(c_rarg2, r19);
 879         int call_offset = __ call_RT(r0, noreg, CAST_FROM_FN_PTR(address, new_multi_array), r1, r2, r3);
 880 
 881         oop_maps = new OopMapSet();
 882         oop_maps-&gt;add_gc_map(call_offset, map);
 883         restore_live_registers_except_r0(sasm);
 884 
 885         // r0,: new multi array
 886         __ verify_oop(r0);
 887       }
 888       break;
 889 
 890     case register_finalizer_id:
 891       {
 892         __ set_info(&quot;register_finalizer&quot;, dont_gc_arguments);
 893 
 894         // This is called via call_runtime so the arguments
 895         // will be place in C abi locations
 896 
 897         __ verify_oop(c_rarg0);
 898 
 899         // load the klass and check the has finalizer flag
 900         Label register_finalizer;
 901         Register t = r5;
 902         __ load_klass(t, r0);
 903         __ ldrw(t, Address(t, Klass::access_flags_offset()));
 904         __ tbnz(t, exact_log2(JVM_ACC_HAS_FINALIZER), register_finalizer);
 905         __ ret(lr);
 906 
 907         __ bind(register_finalizer);
 908         __ enter();
 909         OopMap* oop_map = save_live_registers(sasm);
 910         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, SharedRuntime::register_finalizer), r0);
 911         oop_maps = new OopMapSet();
 912         oop_maps-&gt;add_gc_map(call_offset, oop_map);
 913 
 914         // Now restore all the live registers
 915         restore_live_registers(sasm);
 916 
 917         __ leave();
 918         __ ret(lr);
 919       }
 920       break;
 921 
 922     case throw_class_cast_exception_id:
 923       { StubFrame f(sasm, &quot;throw_class_cast_exception&quot;, dont_gc_arguments);
 924         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_class_cast_exception), true);
 925       }
 926       break;
 927 
 928     case throw_incompatible_class_change_error_id:
 929       { StubFrame f(sasm, &quot;throw_incompatible_class_cast_exception&quot;, dont_gc_arguments);
 930         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_incompatible_class_change_error), false);
 931       }
 932       break;
 933 
 934     case slow_subtype_check_id:
 935       {
 936         // Typical calling sequence:
 937         // __ push(klass_RInfo);  // object klass or other subclass
 938         // __ push(sup_k_RInfo);  // array element klass or other superclass
 939         // __ bl(slow_subtype_check);
 940         // Note that the subclass is pushed first, and is therefore deepest.
 941         enum layout {
 942           r0_off, r0_off_hi,
 943           r2_off, r2_off_hi,
 944           r4_off, r4_off_hi,
 945           r5_off, r5_off_hi,
 946           sup_k_off, sup_k_off_hi,
 947           klass_off, klass_off_hi,
 948           framesize,
 949           result_off = sup_k_off
 950         };
 951 
 952         __ set_info(&quot;slow_subtype_check&quot;, dont_gc_arguments);
 953         __ push(RegSet::of(r0, r2, r4, r5), sp);
 954 
 955         // This is called by pushing args and not with C abi
 956         // __ ldr(r4, Address(sp, (klass_off) * VMRegImpl::stack_slot_size)); // subclass
 957         // __ ldr(r0, Address(sp, (sup_k_off) * VMRegImpl::stack_slot_size)); // superclass
 958 
 959         __ ldp(r4, r0, Address(sp, (sup_k_off) * VMRegImpl::stack_slot_size));
 960 
 961         Label miss;
 962         __ check_klass_subtype_slow_path(r4, r0, r2, r5, NULL, &amp;miss);
 963 
 964         // fallthrough on success:
 965         __ mov(rscratch1, 1);
 966         __ str(rscratch1, Address(sp, (result_off) * VMRegImpl::stack_slot_size)); // result
 967         __ pop(RegSet::of(r0, r2, r4, r5), sp);
 968         __ ret(lr);
 969 
 970         __ bind(miss);
 971         __ str(zr, Address(sp, (result_off) * VMRegImpl::stack_slot_size)); // result
 972         __ pop(RegSet::of(r0, r2, r4, r5), sp);
 973         __ ret(lr);
 974       }
 975       break;
 976 
 977     case monitorenter_nofpu_id:
 978       save_fpu_registers = false;
 979       // fall through
 980     case monitorenter_id:
 981       {
 982         StubFrame f(sasm, &quot;monitorenter&quot;, dont_gc_arguments);
 983         OopMap* map = save_live_registers(sasm, save_fpu_registers);
 984 
 985         // Called with store_parameter and not C abi
 986 
 987         f.load_argument(1, r0); // r0,: object
 988         f.load_argument(0, r1); // r1,: lock address
 989 
 990         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, monitorenter), r0, r1);
 991 
 992         oop_maps = new OopMapSet();
 993         oop_maps-&gt;add_gc_map(call_offset, map);
 994         restore_live_registers(sasm, save_fpu_registers);
 995       }
 996       break;
 997 
 998     case monitorexit_nofpu_id:
 999       save_fpu_registers = false;
1000       // fall through
1001     case monitorexit_id:
1002       {
1003         StubFrame f(sasm, &quot;monitorexit&quot;, dont_gc_arguments);
1004         OopMap* map = save_live_registers(sasm, save_fpu_registers);
1005 
1006         // Called with store_parameter and not C abi
1007 
1008         f.load_argument(0, r0); // r0,: lock address
1009 
1010         // note: really a leaf routine but must setup last java sp
1011         //       =&gt; use call_RT for now (speed can be improved by
1012         //       doing last java sp setup manually)
1013         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, monitorexit), r0);
1014 
1015         oop_maps = new OopMapSet();
1016         oop_maps-&gt;add_gc_map(call_offset, map);
1017         restore_live_registers(sasm, save_fpu_registers);
1018       }
1019       break;
1020 
1021     case deoptimize_id:
1022       {
1023         StubFrame f(sasm, &quot;deoptimize&quot;, dont_gc_arguments);
1024         OopMap* oop_map = save_live_registers(sasm);
1025         f.load_argument(0, c_rarg1);
1026         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, deoptimize), c_rarg1);
1027 
1028         oop_maps = new OopMapSet();
1029         oop_maps-&gt;add_gc_map(call_offset, oop_map);
1030         restore_live_registers(sasm);
1031         DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
1032         assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
1033         __ leave();
1034         __ far_jump(RuntimeAddress(deopt_blob-&gt;unpack_with_reexecution()));
1035       }
1036       break;
1037 
1038     case throw_range_check_failed_id:
1039       { StubFrame f(sasm, &quot;range_check_failed&quot;, dont_gc_arguments);
1040         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_range_check_exception), true);
1041       }
1042       break;
1043 
1044     case unwind_exception_id:
1045       { __ set_info(&quot;unwind_exception&quot;, dont_gc_arguments);
1046         // note: no stubframe since we are about to leave the current
1047         //       activation and we are calling a leaf VM function only.
1048         generate_unwind_exception(sasm);
1049       }
1050       break;
1051 
1052     case access_field_patching_id:
1053       { StubFrame f(sasm, &quot;access_field_patching&quot;, dont_gc_arguments);
1054         // we should set up register map
1055         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, access_field_patching));
1056       }
1057       break;
1058 
1059     case load_klass_patching_id:
1060       { StubFrame f(sasm, &quot;load_klass_patching&quot;, dont_gc_arguments);
1061         // we should set up register map
1062         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, move_klass_patching));
1063       }
1064       break;
1065 
1066     case load_mirror_patching_id:
1067       { StubFrame f(sasm, &quot;load_mirror_patching&quot;, dont_gc_arguments);
1068         // we should set up register map
1069         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, move_mirror_patching));
1070       }
1071       break;
1072 
1073     case load_appendix_patching_id:
1074       { StubFrame f(sasm, &quot;load_appendix_patching&quot;, dont_gc_arguments);
1075         // we should set up register map
1076         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, move_appendix_patching));
1077       }
1078       break;
1079 
1080     case handle_exception_nofpu_id:
1081     case handle_exception_id:
1082       { StubFrame f(sasm, &quot;handle_exception&quot;, dont_gc_arguments);
1083         oop_maps = generate_handle_exception(id, sasm);
1084       }
1085       break;
1086 
1087     case handle_exception_from_callee_id:
1088       { StubFrame f(sasm, &quot;handle_exception_from_callee&quot;, dont_gc_arguments);
1089         oop_maps = generate_handle_exception(id, sasm);
1090       }
1091       break;
1092 
1093     case throw_index_exception_id:
1094       { StubFrame f(sasm, &quot;index_range_check_failed&quot;, dont_gc_arguments);
1095         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_index_exception), true);
1096       }
1097       break;
1098 
1099     case throw_array_store_exception_id:
1100       { StubFrame f(sasm, &quot;throw_array_store_exception&quot;, dont_gc_arguments);
1101         // tos + 0: link
1102         //     + 1: return address
1103         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_array_store_exception), true);
1104       }
1105       break;
1106 
1107     case predicate_failed_trap_id:
1108       {
1109         StubFrame f(sasm, &quot;predicate_failed_trap&quot;, dont_gc_arguments);
1110 
1111         OopMap* map = save_live_registers(sasm);
1112 
1113         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, predicate_failed_trap));
1114         oop_maps = new OopMapSet();
1115         oop_maps-&gt;add_gc_map(call_offset, map);
1116         restore_live_registers(sasm);
1117         __ leave();
1118         DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
1119         assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
1120 
1121         __ far_jump(RuntimeAddress(deopt_blob-&gt;unpack_with_reexecution()));
1122       }
1123       break;
1124 
1125 
1126     default:
1127       { StubFrame f(sasm, &quot;unimplemented entry&quot;, dont_gc_arguments);
1128         __ mov(r0, (int)id);
1129         __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, unimplemented_entry), r0);
1130         __ should_not_reach_here();
1131       }
1132       break;
1133     }
1134   }
1135   return oop_maps;
1136 }
1137 
1138 #undef __
1139 
1140 const char *Runtime1::pd_name_for_address(address entry) { Unimplemented(); return 0; }
    </pre>
  </body>
</html>
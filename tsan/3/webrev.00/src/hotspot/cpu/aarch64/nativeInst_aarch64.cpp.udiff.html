<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/aarch64/nativeInst_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64_trig.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_aarch64.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/nativeInst_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -28,10 +28,11 @@</span>
  #include &quot;code/compiledIC.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;nativeInst_aarch64.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/handles.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;utilities/ostream.hpp&quot;
  #ifdef COMPILER1
  #include &quot;c1/c1_Runtime1.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -230,11 +231,15 @@</span>
  void NativeCall::insert(address code_pos, address entry) { Unimplemented(); }
  
  //-------------------------------------------------------------------
  
  void NativeMovConstReg::verify() {
<span class="udiff-line-modified-removed">-   // make sure code pattern is actually mov reg64, imm64 instructions</span>
<span class="udiff-line-modified-added">+   if (! (nativeInstruction_at(instruction_address())-&gt;is_movz() ||</span>
<span class="udiff-line-added">+         is_adrp_at(instruction_address()) ||</span>
<span class="udiff-line-added">+         is_ldr_literal_at(instruction_address())) ) {</span>
<span class="udiff-line-added">+     fatal(&quot;should be MOVZ or ADRP or LDR (literal)&quot;);</span>
<span class="udiff-line-added">+   }</span>
  }
  
  
  intptr_t NativeMovConstReg::data() const {
    // das(uint64_t(instruction_address()),2);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -281,12 +286,10 @@</span>
                  p2i(instruction_address()), data());
  }
  
  //-------------------------------------------------------------------
  
<span class="udiff-line-removed">- address NativeMovRegMem::instruction_address() const      { return addr_at(instruction_offset); }</span>
<span class="udiff-line-removed">- </span>
  int NativeMovRegMem::offset() const  {
    address pc = instruction_address();
    unsigned insn = *(unsigned*)pc;
    if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
      address addr = MacroAssembler::target_addr_for_insn(pc);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -326,13 +329,18 @@</span>
  address NativeJump::jump_destination() const          {
    address dest = MacroAssembler::target_addr_for_insn(instruction_address());
  
    // We use jump to self as the unresolved address which the inline
    // cache code (and relocs) know about
<span class="udiff-line-added">+   // As a special case we also use sequence movptr(r,0); br(r);</span>
<span class="udiff-line-added">+   // i.e. jump to 0 when we need leave space for a wide immediate</span>
<span class="udiff-line-added">+   // load</span>
  
<span class="udiff-line-modified-removed">-   // return -1 if jump to self</span>
<span class="udiff-line-modified-removed">-   dest = (dest == (address) this) ? (address) -1 : dest;</span>
<span class="udiff-line-modified-added">+   // return -1 if jump to self or to 0</span>
<span class="udiff-line-modified-added">+   if ((dest == (address)this) || dest == 0) {</span>
<span class="udiff-line-added">+     dest = (address) -1;</span>
<span class="udiff-line-added">+   }</span>
    return dest;
  }
  
  void NativeJump::set_jump_destination(address dest) {
    // We use jump to self as the unresolved address which the inline
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -350,13 +358,17 @@</span>
    NativeMovConstReg* move = nativeMovConstReg_at(instruction_address());
    address dest = (address) move-&gt;data();
  
    // We use jump to self as the unresolved address which the inline
    // cache code (and relocs) know about
<span class="udiff-line-added">+   // As a special case we also use jump to 0 when first generating</span>
<span class="udiff-line-added">+   // a general jump</span>
  
<span class="udiff-line-modified-removed">-   // return -1 if jump to self</span>
<span class="udiff-line-modified-removed">-   dest = (dest == (address) this) ? (address) -1 : dest;</span>
<span class="udiff-line-modified-added">+   // return -1 if jump to self or to 0</span>
<span class="udiff-line-modified-added">+   if ((dest == (address)this) || dest == 0) {</span>
<span class="udiff-line-added">+     dest = (address) -1;</span>
<span class="udiff-line-added">+   }</span>
    return dest;
  }
  
  void NativeGeneralJump::set_jump_destination(address dest) {
    NativeMovConstReg* move = nativeMovConstReg_at(instruction_address());
</pre>
<center><a href="macroAssembler_aarch64_trig.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_aarch64.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/frame_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="disassembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/g1/g1BarrierSetAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/frame_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified"> 29 #include &quot;oops/markOop.hpp&quot;</span>

 30 #include &quot;oops/method.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;prims/methodHandles.hpp&quot;
 33 #include &quot;runtime/frame.inline.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/javaCalls.hpp&quot;
 36 #include &quot;runtime/monitorChunk.hpp&quot;
 37 #include &quot;runtime/os.inline.hpp&quot;
 38 #include &quot;runtime/signature.hpp&quot;
 39 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 40 #include &quot;runtime/stubRoutines.hpp&quot;
 41 #include &quot;vmreg_aarch64.inline.hpp&quot;
 42 #ifdef COMPILER1
 43 #include &quot;c1/c1_Runtime1.hpp&quot;
 44 #include &quot;runtime/vframeArray.hpp&quot;
 45 #endif
 46 
 47 #ifdef ASSERT
 48 void RegisterMap::check_location_valid() {
 49 }
 50 #endif
 51 
 52 
 53 // Profiling/safepoint support
 54 
 55 bool frame::safe_for_sender(JavaThread *thread) {
 56   address   sp = (address)_sp;
 57   address   fp = (address)_fp;
 58   address   unextended_sp = (address)_unextended_sp;
 59 
 60   // consider stack guards when trying to determine &quot;safe&quot; stack pointers
<span class="line-removed"> 61   static size_t stack_guard_size = os::uses_stack_guard_pages() ?</span>
<span class="line-removed"> 62     (JavaThread::stack_red_zone_size() + JavaThread::stack_yellow_zone_size()) : 0;</span>
<span class="line-removed"> 63   size_t usable_stack_size = thread-&gt;stack_size() - stack_guard_size;</span>
<span class="line-removed"> 64 </span>
 65   // sp must be within the usable part of the stack (not in guards)
<span class="line-modified"> 66   bool sp_safe = (sp &lt; thread-&gt;stack_base()) &amp;&amp;</span>
<span class="line-removed"> 67                  (sp &gt;= thread-&gt;stack_base() - usable_stack_size);</span>
<span class="line-removed"> 68 </span>
<span class="line-removed"> 69 </span>
<span class="line-removed"> 70   if (!sp_safe) {</span>
 71     return false;
 72   }
 73 
 74   // When we are running interpreted code the machine stack pointer, SP, is
 75   // set low enough so that the Java expression stack can grow and shrink
 76   // without ever exceeding the machine stack bounds.  So, ESP &gt;= SP.
 77 
 78   // When we call out of an interpreted method, SP is incremented so that
 79   // the space between SP and ESP is removed.  The SP saved in the callee&#39;s
 80   // frame is the SP *before* this increment.  So, when we walk a stack of
 81   // interpreter frames the sender&#39;s SP saved in a frame might be less than
 82   // the SP at the point of call.
 83 
 84   // So unextended sp must be within the stack but we need not to check
 85   // that unextended sp &gt;= sp
 86 
 87   bool unextended_sp_safe = (unextended_sp &lt; thread-&gt;stack_base());
 88 
 89   if (!unextended_sp_safe) {
 90     return false;
</pre>
<hr />
<pre>
542   if (!Method::is_valid_method(m)) return false;
543 
544   // stack frames shouldn&#39;t be much larger than max_stack elements
545   // this test requires the use of unextended_sp which is the sp as seen by
546   // the current frame, and not sp which is the &quot;raw&quot; pc which could point
547   // further because of local variables of the callee method inserted after
548   // method arguments
549   if (fp() - unextended_sp() &gt; 1024 + m-&gt;max_stack()*Interpreter::stackElementSize) {
550     return false;
551   }
552 
553   // validate bci/bcx
554 
555   address  bcp    = interpreter_frame_bcp();
556   if (m-&gt;validate_bci_from_bcp(bcp) &lt; 0) {
557     return false;
558   }
559 
560   // validate constantPoolCache*
561   ConstantPoolCache* cp = *interpreter_frame_cache_addr();
<span class="line-modified">562   if (cp == NULL || !cp-&gt;is_metaspace_object()) return false;</span>
563 
564   // validate locals
565 
566   address locals =  (address) *interpreter_frame_locals_addr();
567 
<span class="line-modified">568   if (locals &gt; thread-&gt;stack_base() || locals &lt; (address) fp()) return false;</span>
569 
570   // We&#39;d have to be pretty unlucky to be mislead at this point
571   return true;
572 }
573 
574 BasicType frame::interpreter_frame_result(oop* oop_result, jvalue* value_result) {
575   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
576   Method* method = interpreter_frame_method();
577   BasicType type = method-&gt;result_type();
578 
579   intptr_t* tos_addr;
580   if (method-&gt;is_native()) {
581     // TODO : ensure AARCH64 does the same as Intel here i.e. push v0 then r0
582     // Prior to calling into the runtime to report the method_exit the possible
583     // return value is pushed to the native stack. If the result is a jfloat/jdouble
584     // then ST0 is saved before EAX/EDX. See the note in generate_native_result
585     tos_addr = (intptr_t*)sp();
586     if (type == T_FLOAT || type == T_DOUBLE) {
587       // This is times two because we do a push(ltos) after pushing XMM0
588       // and that takes two interpreter stack slots.
</pre>
<hr />
<pre>
750       } else if (cb-&gt;name()) {
751         printf(&quot;CodeBlob %s\n&quot;, cb-&gt;name());
752       }
753     }
754   }
755 }
756 
757 extern &quot;C&quot; void npf() {
758   CodeBlob *cb = CodeCache::find_blob((address)nextpc);
759   // C2 does not always chain the frame pointers when it can, instead
760   // preferring to use fixed offsets from SP, so a simple leave() does
761   // not work.  Instead, it adds the frame size to SP then pops FP and
762   // LR.  We have to do the same thing to get a good call chain.
763   if (cb &amp;&amp; cb-&gt;frame_size())
764     nextfp = nextsp + wordSize * (cb-&gt;frame_size() - 2);
765   internal_pf (nextsp, nextfp, nextpc, -1);
766 }
767 
768 extern &quot;C&quot; void pf(unsigned long sp, unsigned long fp, unsigned long pc,
769                    unsigned long bcx, unsigned long thread) {
<span class="line-removed">770   RegisterMap map((JavaThread*)thread, false);</span>
771   if (!reg_map) {
<span class="line-modified">772     reg_map = (RegisterMap*)os::malloc(sizeof map, mtNone);</span>



773   }
<span class="line-modified">774   memcpy(reg_map, &amp;map, sizeof map);</span>
775   {
776     CodeBlob *cb = CodeCache::find_blob((address)pc);
777     if (cb &amp;&amp; cb-&gt;frame_size())
778       fp = sp + wordSize * (cb-&gt;frame_size() - 2);
779   }
780   internal_pf(sp, fp, pc, bcx);
781 }
782 
783 // support for printing out where we are in a Java method
784 // needs to be passed current fp and bcp register values
785 // prints method name, bc index and bytecode name
786 extern &quot;C&quot; void pm(unsigned long fp, unsigned long bcx) {
787   DESCRIBE_FP_OFFSET(interpreter_frame_method);
788   unsigned long *p = (unsigned long *)fp;
789   Method* m = (Method*)p[frame::interpreter_frame_method_offset];
790   printbc(m, bcx);
791 }
792 
793 #ifndef PRODUCT
794 // This is a generic constructor which is only used by pns() in debug.cpp.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified"> 29 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added"> 30 #include &quot;oops/markWord.hpp&quot;</span>
 31 #include &quot;oops/method.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;prims/methodHandles.hpp&quot;
 34 #include &quot;runtime/frame.inline.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 #include &quot;runtime/javaCalls.hpp&quot;
 37 #include &quot;runtime/monitorChunk.hpp&quot;
 38 #include &quot;runtime/os.inline.hpp&quot;
 39 #include &quot;runtime/signature.hpp&quot;
 40 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 41 #include &quot;runtime/stubRoutines.hpp&quot;
 42 #include &quot;vmreg_aarch64.inline.hpp&quot;
 43 #ifdef COMPILER1
 44 #include &quot;c1/c1_Runtime1.hpp&quot;
 45 #include &quot;runtime/vframeArray.hpp&quot;
 46 #endif
 47 
 48 #ifdef ASSERT
 49 void RegisterMap::check_location_valid() {
 50 }
 51 #endif
 52 
 53 
 54 // Profiling/safepoint support
 55 
 56 bool frame::safe_for_sender(JavaThread *thread) {
 57   address   sp = (address)_sp;
 58   address   fp = (address)_fp;
 59   address   unextended_sp = (address)_unextended_sp;
 60 
 61   // consider stack guards when trying to determine &quot;safe&quot; stack pointers




 62   // sp must be within the usable part of the stack (not in guards)
<span class="line-modified"> 63   if (!thread-&gt;is_in_usable_stack(sp)) {</span>




 64     return false;
 65   }
 66 
 67   // When we are running interpreted code the machine stack pointer, SP, is
 68   // set low enough so that the Java expression stack can grow and shrink
 69   // without ever exceeding the machine stack bounds.  So, ESP &gt;= SP.
 70 
 71   // When we call out of an interpreted method, SP is incremented so that
 72   // the space between SP and ESP is removed.  The SP saved in the callee&#39;s
 73   // frame is the SP *before* this increment.  So, when we walk a stack of
 74   // interpreter frames the sender&#39;s SP saved in a frame might be less than
 75   // the SP at the point of call.
 76 
 77   // So unextended sp must be within the stack but we need not to check
 78   // that unextended sp &gt;= sp
 79 
 80   bool unextended_sp_safe = (unextended_sp &lt; thread-&gt;stack_base());
 81 
 82   if (!unextended_sp_safe) {
 83     return false;
</pre>
<hr />
<pre>
535   if (!Method::is_valid_method(m)) return false;
536 
537   // stack frames shouldn&#39;t be much larger than max_stack elements
538   // this test requires the use of unextended_sp which is the sp as seen by
539   // the current frame, and not sp which is the &quot;raw&quot; pc which could point
540   // further because of local variables of the callee method inserted after
541   // method arguments
542   if (fp() - unextended_sp() &gt; 1024 + m-&gt;max_stack()*Interpreter::stackElementSize) {
543     return false;
544   }
545 
546   // validate bci/bcx
547 
548   address  bcp    = interpreter_frame_bcp();
549   if (m-&gt;validate_bci_from_bcp(bcp) &lt; 0) {
550     return false;
551   }
552 
553   // validate constantPoolCache*
554   ConstantPoolCache* cp = *interpreter_frame_cache_addr();
<span class="line-modified">555   if (MetaspaceObj::is_valid(cp) == false) return false;</span>
556 
557   // validate locals
558 
559   address locals =  (address) *interpreter_frame_locals_addr();
560 
<span class="line-modified">561   if (locals &gt;= thread-&gt;stack_base() || locals &lt; (address) fp()) return false;</span>
562 
563   // We&#39;d have to be pretty unlucky to be mislead at this point
564   return true;
565 }
566 
567 BasicType frame::interpreter_frame_result(oop* oop_result, jvalue* value_result) {
568   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
569   Method* method = interpreter_frame_method();
570   BasicType type = method-&gt;result_type();
571 
572   intptr_t* tos_addr;
573   if (method-&gt;is_native()) {
574     // TODO : ensure AARCH64 does the same as Intel here i.e. push v0 then r0
575     // Prior to calling into the runtime to report the method_exit the possible
576     // return value is pushed to the native stack. If the result is a jfloat/jdouble
577     // then ST0 is saved before EAX/EDX. See the note in generate_native_result
578     tos_addr = (intptr_t*)sp();
579     if (type == T_FLOAT || type == T_DOUBLE) {
580       // This is times two because we do a push(ltos) after pushing XMM0
581       // and that takes two interpreter stack slots.
</pre>
<hr />
<pre>
743       } else if (cb-&gt;name()) {
744         printf(&quot;CodeBlob %s\n&quot;, cb-&gt;name());
745       }
746     }
747   }
748 }
749 
750 extern &quot;C&quot; void npf() {
751   CodeBlob *cb = CodeCache::find_blob((address)nextpc);
752   // C2 does not always chain the frame pointers when it can, instead
753   // preferring to use fixed offsets from SP, so a simple leave() does
754   // not work.  Instead, it adds the frame size to SP then pops FP and
755   // LR.  We have to do the same thing to get a good call chain.
756   if (cb &amp;&amp; cb-&gt;frame_size())
757     nextfp = nextsp + wordSize * (cb-&gt;frame_size() - 2);
758   internal_pf (nextsp, nextfp, nextpc, -1);
759 }
760 
761 extern &quot;C&quot; void pf(unsigned long sp, unsigned long fp, unsigned long pc,
762                    unsigned long bcx, unsigned long thread) {

763   if (!reg_map) {
<span class="line-modified">764     reg_map = NEW_C_HEAP_OBJ(RegisterMap, mtNone);</span>
<span class="line-added">765     ::new (reg_map) RegisterMap((JavaThread*)thread, false);</span>
<span class="line-added">766   } else {</span>
<span class="line-added">767     *reg_map = RegisterMap((JavaThread*)thread, false);</span>
768   }
<span class="line-modified">769 </span>
770   {
771     CodeBlob *cb = CodeCache::find_blob((address)pc);
772     if (cb &amp;&amp; cb-&gt;frame_size())
773       fp = sp + wordSize * (cb-&gt;frame_size() - 2);
774   }
775   internal_pf(sp, fp, pc, bcx);
776 }
777 
778 // support for printing out where we are in a Java method
779 // needs to be passed current fp and bcp register values
780 // prints method name, bc index and bytecode name
781 extern &quot;C&quot; void pm(unsigned long fp, unsigned long bcx) {
782   DESCRIBE_FP_OFFSET(interpreter_frame_method);
783   unsigned long *p = (unsigned long *)fp;
784   Method* m = (Method*)p[frame::interpreter_frame_method_offset];
785   printbc(m, bcx);
786 }
787 
788 #ifndef PRODUCT
789 // This is a generic constructor which is only used by pns() in debug.cpp.
</pre>
</td>
</tr>
</table>
<center><a href="disassembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/g1/g1BarrierSetAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
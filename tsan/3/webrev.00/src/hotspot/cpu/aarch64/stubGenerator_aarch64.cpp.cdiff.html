<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubRoutines_aarch64.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,10 ***</span>
<span class="line-new-header">--- 27,11 ---</span>
  #include &quot;asm/macroAssembler.hpp&quot;
  #include &quot;asm/macroAssembler.inline.hpp&quot;
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;nativeInst_aarch64.hpp&quot;
  #include &quot;oops/instanceOop.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,16 ***</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubCodeGenerator.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #ifdef COMPILER2
  #include &quot;opto/runtime.hpp&quot;
  #endif
<span class="line-modified">! </span>
<span class="line-modified">! #ifdef BUILTIN_SIM</span>
<span class="line-removed">- #include &quot;../../../../../../simulator/simulator.hpp&quot;</span>
  #endif
  
  // Declaration and definition of StubGenerator (no .hpp file).
  // For a more detailed description of the stub routine structure
  // see the comment in stubRoutines.hpp
<span class="line-new-header">--- 41,16 ---</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubCodeGenerator.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #ifdef COMPILER2
  #include &quot;opto/runtime.hpp&quot;
  #endif
<span class="line-modified">! #if INCLUDE_ZGC</span>
<span class="line-modified">! #include &quot;gc/z/zThreadLocalData.hpp&quot;</span>
  #endif
  
  // Declaration and definition of StubGenerator (no .hpp file).
  // For a more detailed description of the stub routine structure
  // see the comment in stubRoutines.hpp
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,20 ***</span>
      const Address r22_save      (rfp, r22_off * wordSize);
      const Address r20_save      (rfp, r20_off * wordSize);
  
      // stub code
  
<span class="line-removed">-     // we need a C prolog to bootstrap the x86 caller into the sim</span>
<span class="line-removed">-     __ c_stub_prolog(8, 0, MacroAssembler::ret_type_void);</span>
<span class="line-removed">- </span>
      address aarch64_entry = __ pc();
  
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-     // Save sender&#39;s SP for stack traces.</span>
<span class="line-removed">-     __ mov(rscratch1, sp);</span>
<span class="line-removed">-     __ str(rscratch1, Address(__ pre(sp, -2 * wordSize)));</span>
<span class="line-removed">- #endif</span>
      // set up frame and move sp to end of save area
      __ enter();
      __ sub(sp, rfp, -sp_after_call_off * wordSize);
  
      // save register parameters and Java scratch/global registers
<span class="line-new-header">--- 216,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,24 ***</span>
      //      r13: sender sp
      BLOCK_COMMENT(&quot;call Java function&quot;);
      __ mov(r13, sp);
      __ blr(c_rarg4);
  
<span class="line-removed">-     // tell the simulator we have returned to the stub</span>
<span class="line-removed">- </span>
      // we do this here because the notify will already have been done
      // if we get to the next instruction via an exception
      //
      // n.b. adding this instruction here affects the calculation of
      // whether or not a routine returns to the call stub (used when
      // doing stack walks) since the normal test is to check the return
      // pc against the address saved below. so we may need to allow for
      // this extra instruction in the check.
  
<span class="line-removed">-     if (NotifySimulator) {</span>
<span class="line-removed">-       __ notify(Assembler::method_reentry);</span>
<span class="line-removed">-     }</span>
      // save current address for use by exception handling code
  
      return_address = __ pc();
  
      // store result depending on type (everything that is not
<span class="line-new-header">--- 288,19 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 371,16 ***</span>
      __ ldrw(c_rarg2, result_type);
      __ ldr(c_rarg3,  method);
      __ ldp(c_rarg4, c_rarg5,  entry_point);
      __ ldp(c_rarg6, c_rarg7,  parameter_size);
  
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-     // tell the simulator we are about to end Java execution</span>
<span class="line-removed">-     if (NotifySimulator) {</span>
<span class="line-removed">-       __ notify(Assembler::method_exit);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
      // leave frame and return to caller
      __ leave();
      __ ret(lr);
  
      // handle return types different from T_INT
<span class="line-new-header">--- 359,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,17 ***</span>
    // not the case if the callee is compiled code =&gt; need to setup the
    // rsp.
    //
    // r0: exception oop
  
<span class="line-removed">-   // NOTE: this is used as a target from the signal handler so it</span>
<span class="line-removed">-   // needs an x86 prolog which returns into the current simulator</span>
<span class="line-removed">-   // executing the generated catch_exception code. so the prolog</span>
<span class="line-removed">-   // needs to install rax in a sim register and adjust the sim&#39;s</span>
<span class="line-removed">-   // restart pc to enter the generated code at the start position</span>
<span class="line-removed">-   // then return from native to simulated execution.</span>
<span class="line-removed">- </span>
    address generate_catch_exception() {
      StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;catch_exception&quot;);
      address start = __ pc();
  
      // same as in generate_call_stub():
<span class="line-new-header">--- 392,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 577,10 ***</span>
<span class="line-new-header">--- 552,20 ---</span>
  
      // object is in r0
      // make sure object is &#39;reasonable&#39;
      __ cbz(r0, exit); // if obj is NULL it is OK
  
<span class="line-added">+ #if INCLUDE_ZGC</span>
<span class="line-added">+     if (UseZGC) {</span>
<span class="line-added">+       // Check if mask is good.</span>
<span class="line-added">+       // verifies that ZAddressBadMask &amp; r0 == 0</span>
<span class="line-added">+       __ ldr(c_rarg3, Address(rthread, ZThreadLocalData::address_bad_mask_offset()));</span>
<span class="line-added">+       __ andr(c_rarg2, r0, c_rarg3);</span>
<span class="line-added">+       __ cbnz(c_rarg2, error);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      // Check if the oop is in the right area of memory
      __ mov(c_rarg3, (intptr_t) Universe::verify_oop_mask());
      __ andr(c_rarg2, r0, c_rarg3);
      __ mov(c_rarg3, (intptr_t) Universe::verify_oop_bits());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 611,11 ***</span>
  #ifndef PRODUCT
      assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
  #endif
      BLOCK_COMMENT(&quot;call MacroAssembler::debug&quot;);
      __ mov(rscratch1, CAST_FROM_FN_PTR(address, MacroAssembler::debug64));
<span class="line-modified">!     __ blrt(rscratch1, 3, 0, 1);</span>
  
      return start;
    }
  
    void array_overlap_test(Label&amp; L_no_overlap, Address::sxtw sf) { __ b(L_no_overlap); }
<span class="line-new-header">--- 596,12 ---</span>
  #ifndef PRODUCT
      assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
  #endif
      BLOCK_COMMENT(&quot;call MacroAssembler::debug&quot;);
      __ mov(rscratch1, CAST_FROM_FN_PTR(address, MacroAssembler::debug64));
<span class="line-modified">!     __ blr(rscratch1);</span>
<span class="line-added">+     __ hlt(0);</span>
  
      return start;
    }
  
    void array_overlap_test(Label&amp; L_no_overlap, Address::sxtw sf) { __ b(L_no_overlap); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1361,37 ***</span>
      if (aligned) {
        decorators |= ARRAYCOPY_ALIGNED;
      }
  
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
<span class="line-modified">!     bs-&gt;arraycopy_prologue(_masm, decorators, is_oop, d, count, saved_reg);</span>
  
      if (is_oop) {
        // save regs before copy_memory
        __ push(RegSet::of(d, count), sp);
      }
<span class="line-modified">!     copy_memory(aligned, s, d, count, rscratch1, size);</span>
  
      if (is_oop) {
        __ pop(RegSet::of(d, count), sp);
        if (VerifyOops)
          verify_oop_array(size, d, count, r16);
<span class="line-removed">-       __ sub(count, count, 1); // make an inclusive end pointer</span>
<span class="line-removed">-       __ lea(count, Address(d, count, Address::lsl(exact_log2(size))));</span>
      }
  
      bs-&gt;arraycopy_epilogue(_masm, decorators, is_oop, d, count, rscratch1, RegSet());
  
      __ leave();
      __ mov(r0, zr); // return 0
      __ ret(lr);
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       AArch64Simulator *sim = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed">-       sim-&gt;notifyCompile(const_cast&lt;char*&gt;(name), start);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
      return start;
    }
  
    // Arguments:
    //   aligned - true =&gt; Input and output aligned on a HeapWord == 8-byte boundary
<span class="line-new-header">--- 1347,34 ---</span>
      if (aligned) {
        decorators |= ARRAYCOPY_ALIGNED;
      }
  
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
<span class="line-modified">!     bs-&gt;arraycopy_prologue(_masm, decorators, is_oop, s, d, count, saved_reg);</span>
  
      if (is_oop) {
        // save regs before copy_memory
        __ push(RegSet::of(d, count), sp);
      }
<span class="line-modified">!     {</span>
<span class="line-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="line-added">+       bool add_entry = !is_oop &amp;&amp; (!aligned || sizeof(jlong) == size);</span>
<span class="line-added">+       UnsafeCopyMemoryMark ucmm(this, add_entry, true);</span>
<span class="line-added">+       copy_memory(aligned, s, d, count, rscratch1, size);</span>
<span class="line-added">+     }</span>
  
      if (is_oop) {
        __ pop(RegSet::of(d, count), sp);
        if (VerifyOops)
          verify_oop_array(size, d, count, r16);
      }
  
      bs-&gt;arraycopy_epilogue(_masm, decorators, is_oop, d, count, rscratch1, RegSet());
  
      __ leave();
      __ mov(r0, zr); // return 0
      __ ret(lr);
      return start;
    }
  
    // Arguments:
    //   aligned - true =&gt; Input and output aligned on a HeapWord == 8-byte boundary
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1435,34 ***</span>
      if (aligned) {
        decorators |= ARRAYCOPY_ALIGNED;
      }
  
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
<span class="line-modified">!     bs-&gt;arraycopy_prologue(_masm, decorators, is_oop, d, count, saved_regs);</span>
  
      if (is_oop) {
        // save regs before copy_memory
        __ push(RegSet::of(d, count), sp);
      }
<span class="line-modified">!     copy_memory(aligned, s, d, count, rscratch1, -size);</span>
      if (is_oop) {
        __ pop(RegSet::of(d, count), sp);
        if (VerifyOops)
          verify_oop_array(size, d, count, r16);
<span class="line-removed">-       __ sub(count, count, 1); // make an inclusive end pointer</span>
<span class="line-removed">-       __ lea(count, Address(d, count, Address::lsl(exact_log2(size))));</span>
      }
      bs-&gt;arraycopy_epilogue(_masm, decorators, is_oop, d, count, rscratch1, RegSet());
      __ leave();
      __ mov(r0, zr); // return 0
      __ ret(lr);
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       AArch64Simulator *sim = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed">-       sim-&gt;notifyCompile(const_cast&lt;char*&gt;(name), start);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
      return start;
  }
  
    // Arguments:
    //   aligned - true =&gt; Input and output aligned on a HeapWord == 8-byte boundary
<span class="line-new-header">--- 1418,31 ---</span>
      if (aligned) {
        decorators |= ARRAYCOPY_ALIGNED;
      }
  
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
<span class="line-modified">!     bs-&gt;arraycopy_prologue(_masm, decorators, is_oop, s, d, count, saved_regs);</span>
  
      if (is_oop) {
        // save regs before copy_memory
        __ push(RegSet::of(d, count), sp);
      }
<span class="line-modified">!     {</span>
<span class="line-added">+       // UnsafeCopyMemory page error: continue after ucm</span>
<span class="line-added">+       bool add_entry = !is_oop &amp;&amp; (!aligned || sizeof(jlong) == size);</span>
<span class="line-added">+       UnsafeCopyMemoryMark ucmm(this, add_entry, true);</span>
<span class="line-added">+       copy_memory(aligned, s, d, count, rscratch1, -size);</span>
<span class="line-added">+     }</span>
      if (is_oop) {
        __ pop(RegSet::of(d, count), sp);
        if (VerifyOops)
          verify_oop_array(size, d, count, r16);
      }
      bs-&gt;arraycopy_epilogue(_masm, decorators, is_oop, d, count, rscratch1, RegSet());
      __ leave();
      __ mov(r0, zr); // return 0
      __ ret(lr);
      return start;
  }
  
    // Arguments:
    //   aligned - true =&gt; Input and output aligned on a HeapWord == 8-byte boundary
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1790,18 ***</span>
        __ stop(&quot;super_check_offset inconsistent&quot;);
        __ bind(L);
      }
  #endif //ASSERT
  
<span class="line-modified">!     DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_CHECKCAST;</span>
      bool is_oop = true;
      if (dest_uninitialized) {
        decorators |= IS_DEST_UNINITIALIZED;
      }
  
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
<span class="line-modified">!     bs-&gt;arraycopy_prologue(_masm, decorators, is_oop, to, count, wb_pre_saved_regs);</span>
  
      // save the original count
      __ mov(count_save, count);
  
      // Copy from low to high addresses
<span class="line-new-header">--- 1770,18 ---</span>
        __ stop(&quot;super_check_offset inconsistent&quot;);
        __ bind(L);
      }
  #endif //ASSERT
  
<span class="line-modified">!     DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_CHECKCAST | ARRAYCOPY_DISJOINT;</span>
      bool is_oop = true;
      if (dest_uninitialized) {
        decorators |= IS_DEST_UNINITIALIZED;
      }
  
      BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
<span class="line-modified">!     bs-&gt;arraycopy_prologue(_masm, decorators, is_oop, from, to, count, wb_pre_saved_regs);</span>
  
      // save the original count
      __ mov(count_save, count);
  
      // Copy from low to high addresses
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1840,12 ***</span>
      __ subs(count, count_save, count);     // K = partially copied oop count
      __ eon(count, count, zr);                   // report (-1^K) to caller
      __ br(Assembler::EQ, L_done_pop);
  
      __ BIND(L_do_card_marks);
<span class="line-modified">!     __ add(to, to, -heapOopSize);         // make an inclusive end pointer</span>
<span class="line-removed">-     bs-&gt;arraycopy_epilogue(_masm, decorators, is_oop, start_to, to, rscratch1, wb_post_saved_regs);</span>
  
      __ bind(L_done_pop);
      __ pop(RegSet::of(r18, r19, r20, r21), sp);
      inc_counter_np(SharedRuntime::_checkcast_array_copy_ctr);
  
<span class="line-new-header">--- 1820,11 ---</span>
      __ subs(count, count_save, count);     // K = partially copied oop count
      __ eon(count, count, zr);                   // report (-1^K) to caller
      __ br(Assembler::EQ, L_done_pop);
  
      __ BIND(L_do_card_marks);
<span class="line-modified">!     bs-&gt;arraycopy_epilogue(_masm, decorators, is_oop, start_to, count_save, rscratch1, wb_post_saved_regs);</span>
  
      __ bind(L_done_pop);
      __ pop(RegSet::of(r18, r19, r20, r21), sp);
      inc_counter_np(SharedRuntime::_checkcast_array_copy_ctr);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2371,10 ***</span>
<span class="line-new-header">--- 2350,48 ---</span>
      __ leave();
      __ ret(lr);
      return start;
    }
  
<span class="line-added">+   address generate_data_cache_writeback() {</span>
<span class="line-added">+     const Register line        = c_rarg0;  // address of line to write back</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ align(CodeEntryAlignment);</span>
<span class="line-added">+ </span>
<span class="line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;_data_cache_writeback&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     address start = __ pc();</span>
<span class="line-added">+     __ enter();</span>
<span class="line-added">+     __ cache_wb(Address(line, 0));</span>
<span class="line-added">+     __ leave();</span>
<span class="line-added">+     __ ret(lr);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return start;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   address generate_data_cache_writeback_sync() {</span>
<span class="line-added">+     const Register is_pre     = c_rarg0;  // pre or post sync</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ align(CodeEntryAlignment);</span>
<span class="line-added">+ </span>
<span class="line-added">+     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;_data_cache_writeback_sync&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // pre wbsync is a no-op</span>
<span class="line-added">+     // post wbsync translates to an sfence</span>
<span class="line-added">+ </span>
<span class="line-added">+     Label skip;</span>
<span class="line-added">+     address start = __ pc();</span>
<span class="line-added">+     __ enter();</span>
<span class="line-added">+     __ cbnz(is_pre, skip);</span>
<span class="line-added">+     __ cache_wbsync(false);</span>
<span class="line-added">+     __ bind(skip);</span>
<span class="line-added">+     __ leave();</span>
<span class="line-added">+     __ ret(lr);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return start;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    void generate_arraycopy_stubs() {
      address entry;
      address entry_jbyte_arraycopy;
      address entry_jshort_arraycopy;
      address entry_jint_arraycopy;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3107,11 ***</span>
      __ ret(lr);
  
      return start;
    }
  
<span class="line-removed">- #ifndef BUILTIN_SIM</span>
    // Safefetch stubs.
    void generate_safefetch(const char* name, int size, address* entry,
                            address* fault_pc, address* continuation_pc) {
      // safefetch signatures:
      //   int      SafeFetch32(int*      adr, int      errValue);
<span class="line-new-header">--- 3124,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3147,11 ***</span>
      // return errValue or *adr
      *continuation_pc = __ pc();
      __ mov(r0, c_rarg1);
      __ ret(lr);
    }
<span class="line-removed">- #endif</span>
  
    /**
     *  Arguments:
     *
     * Inputs:
<span class="line-new-header">--- 3163,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3994,11 ***</span>
    }
  
    // code for comparing 16 characters of strings with Latin1 and Utf16 encoding
    void compare_string_16_x_LU(Register tmpL, Register tmpU, Label &amp;DIFF1,
        Label &amp;DIFF2) {
<span class="line-modified">!     Register cnt1 = r2, tmp1 = r10, tmp2 = r11, tmp3 = r12;</span>
      FloatRegister vtmp = v1, vtmpZ = v0, vtmp3 = v2;
  
      __ ldrq(vtmp, Address(__ post(tmp2, 16)));
      __ ldr(tmpU, Address(__ post(cnt1, 8)));
      __ zip1(vtmp3, __ T16B, vtmp, vtmpZ);
<span class="line-new-header">--- 4009,11 ---</span>
    }
  
    // code for comparing 16 characters of strings with Latin1 and Utf16 encoding
    void compare_string_16_x_LU(Register tmpL, Register tmpU, Label &amp;DIFF1,
        Label &amp;DIFF2) {
<span class="line-modified">!     Register cnt1 = r2, tmp2 = r11, tmp3 = r12;</span>
      FloatRegister vtmp = v1, vtmpZ = v0, vtmp3 = v2;
  
      __ ldrq(vtmp, Address(__ post(tmp2, 16)));
      __ ldr(tmpU, Address(__ post(cnt1, 8)));
      __ zip1(vtmp3, __ T16B, vtmp, vtmpZ);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4037,45 ***</span>
      StubCodeMark mark(this, &quot;StubRoutines&quot;, isLU
          ? &quot;compare_long_string_different_encoding LU&quot;
          : &quot;compare_long_string_different_encoding UL&quot;);
      address entry = __ pc();
      Label SMALL_LOOP, TAIL, TAIL_LOAD_16, LOAD_LAST, DIFF1, DIFF2,
<span class="line-modified">!         DONE, CALCULATE_DIFFERENCE, LARGE_LOOP_PREFETCH, SMALL_LOOP_ENTER,</span>
          LARGE_LOOP_PREFETCH_REPEAT1, LARGE_LOOP_PREFETCH_REPEAT2;
      Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,
          tmp1 = r10, tmp2 = r11, tmp3 = r12, tmp4 = r14;
      FloatRegister vtmpZ = v0, vtmp = v1, vtmp3 = v2;
      RegSet spilled_regs = RegSet::of(tmp3, tmp4);
  
<span class="line-modified">!     int prefetchLoopExitCondition = MAX(32, SoftwarePrefetchHintDistance/2);</span>
  
      __ eor(vtmpZ, __ T16B, vtmpZ, vtmpZ);
      // cnt2 == amount of characters left to compare
      // Check already loaded first 4 symbols(vtmp and tmp2(LU)/tmp1(UL))
      __ zip1(vtmp, __ T8B, vtmp, vtmpZ);
      __ add(str1, str1, isLU ? wordSize/2 : wordSize);
      __ add(str2, str2, isLU ? wordSize : wordSize/2);
      __ fmovd(isLU ? tmp1 : tmp2, vtmp);
      __ subw(cnt2, cnt2, 8); // Already loaded 4 symbols. Last 4 is special case.
<span class="line-removed">-     __ add(str1, str1, cnt2, __ LSL, isLU ? 0 : 1);</span>
      __ eor(rscratch2, tmp1, tmp2);
<span class="line-removed">-     __ add(str2, str2, cnt2, __ LSL, isLU ? 1 : 0);</span>
      __ mov(rscratch1, tmp2);
      __ cbnz(rscratch2, CALCULATE_DIFFERENCE);
<span class="line-modified">!     Register strU = isLU ? str2 : str1,</span>
<span class="line-removed">-              strL = isLU ? str1 : str2,</span>
<span class="line-removed">-              tmpU = isLU ? rscratch1 : tmp1, // where to keep U for comparison</span>
               tmpL = isLU ? tmp1 : rscratch1; // where to keep L for comparison
      __ push(spilled_regs, sp);
<span class="line-modified">!     __ sub(tmp2, strL, cnt2); // strL pointer to load from</span>
<span class="line-modified">!     __ sub(cnt1, strU, cnt2, __ LSL, 1); // strU pointer to load from</span>
  
      __ ldr(tmp3, Address(__ post(cnt1, 8)));
  
      if (SoftwarePrefetchHintDistance &gt;= 0) {
        __ subs(rscratch2, cnt2, prefetchLoopExitCondition);
<span class="line-modified">!       __ br(__ LT, SMALL_LOOP);</span>
        __ bind(LARGE_LOOP_PREFETCH);
          __ prfm(Address(tmp2, SoftwarePrefetchHintDistance));
          __ mov(tmp4, 2);
          __ prfm(Address(cnt1, SoftwarePrefetchHintDistance));
          __ bind(LARGE_LOOP_PREFETCH_REPEAT1);
<span class="line-new-header">--- 4052,41 ---</span>
      StubCodeMark mark(this, &quot;StubRoutines&quot;, isLU
          ? &quot;compare_long_string_different_encoding LU&quot;
          : &quot;compare_long_string_different_encoding UL&quot;);
      address entry = __ pc();
      Label SMALL_LOOP, TAIL, TAIL_LOAD_16, LOAD_LAST, DIFF1, DIFF2,
<span class="line-modified">!         DONE, CALCULATE_DIFFERENCE, LARGE_LOOP_PREFETCH, NO_PREFETCH,</span>
          LARGE_LOOP_PREFETCH_REPEAT1, LARGE_LOOP_PREFETCH_REPEAT2;
      Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,
          tmp1 = r10, tmp2 = r11, tmp3 = r12, tmp4 = r14;
      FloatRegister vtmpZ = v0, vtmp = v1, vtmp3 = v2;
      RegSet spilled_regs = RegSet::of(tmp3, tmp4);
  
<span class="line-modified">!     int prefetchLoopExitCondition = MAX(64, SoftwarePrefetchHintDistance/2);</span>
  
      __ eor(vtmpZ, __ T16B, vtmpZ, vtmpZ);
      // cnt2 == amount of characters left to compare
      // Check already loaded first 4 symbols(vtmp and tmp2(LU)/tmp1(UL))
      __ zip1(vtmp, __ T8B, vtmp, vtmpZ);
      __ add(str1, str1, isLU ? wordSize/2 : wordSize);
      __ add(str2, str2, isLU ? wordSize : wordSize/2);
      __ fmovd(isLU ? tmp1 : tmp2, vtmp);
      __ subw(cnt2, cnt2, 8); // Already loaded 4 symbols. Last 4 is special case.
      __ eor(rscratch2, tmp1, tmp2);
      __ mov(rscratch1, tmp2);
      __ cbnz(rscratch2, CALCULATE_DIFFERENCE);
<span class="line-modified">!     Register tmpU = isLU ? rscratch1 : tmp1, // where to keep U for comparison</span>
               tmpL = isLU ? tmp1 : rscratch1; // where to keep L for comparison
      __ push(spilled_regs, sp);
<span class="line-modified">!     __ mov(tmp2, isLU ? str1 : str2); // init the pointer to L next load</span>
<span class="line-modified">!     __ mov(cnt1, isLU ? str2 : str1); // init the pointer to U next load</span>
  
      __ ldr(tmp3, Address(__ post(cnt1, 8)));
  
      if (SoftwarePrefetchHintDistance &gt;= 0) {
        __ subs(rscratch2, cnt2, prefetchLoopExitCondition);
<span class="line-modified">!       __ br(__ LT, NO_PREFETCH);</span>
        __ bind(LARGE_LOOP_PREFETCH);
          __ prfm(Address(tmp2, SoftwarePrefetchHintDistance));
          __ mov(tmp4, 2);
          __ prfm(Address(cnt1, SoftwarePrefetchHintDistance));
          __ bind(LARGE_LOOP_PREFETCH_REPEAT1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4091,66 ***</span>
            __ sub(cnt2, cnt2, 64);
            __ subs(rscratch2, cnt2, prefetchLoopExitCondition);
            __ br(__ GE, LARGE_LOOP_PREFETCH);
      }
      __ cbz(cnt2, LOAD_LAST); // no characters left except last load
      __ subs(cnt2, cnt2, 16);
      __ br(__ LT, TAIL);
<span class="line-modified">!     __ b(SMALL_LOOP_ENTER);</span>
      __ bind(SMALL_LOOP); // smaller loop
        __ subs(cnt2, cnt2, 16);
<span class="line-removed">-     __ bind(SMALL_LOOP_ENTER);</span>
        compare_string_16_x_LU(tmpL, tmpU, DIFF1, DIFF2);
        __ br(__ GE, SMALL_LOOP);
<span class="line-modified">!       __ cbz(cnt2, LOAD_LAST);</span>
<span class="line-modified">!     __ bind(TAIL); // 1..15 characters left</span>
<span class="line-modified">!       __ subs(zr, cnt2, -8);</span>
<span class="line-modified">!       __ br(__ GT, TAIL_LOAD_16);</span>
<span class="line-modified">!       __ ldrd(vtmp, Address(tmp2));</span>
<span class="line-modified">!       __ zip1(vtmp3, __ T8B, vtmp, vtmpZ);</span>
<span class="line-modified">! </span>
<span class="line-removed">-       __ ldr(tmpU, Address(__ post(cnt1, 8)));</span>
<span class="line-removed">-       __ fmovd(tmpL, vtmp3);</span>
<span class="line-removed">-       __ eor(rscratch2, tmp3, tmpL);</span>
<span class="line-removed">-       __ cbnz(rscratch2, DIFF2);</span>
<span class="line-removed">-       __ umov(tmpL, vtmp3, __ D, 1);</span>
<span class="line-removed">-       __ eor(rscratch2, tmpU, tmpL);</span>
<span class="line-removed">-       __ cbnz(rscratch2, DIFF1);</span>
<span class="line-removed">-       __ b(LOAD_LAST);</span>
<span class="line-removed">-     __ bind(TAIL_LOAD_16);</span>
<span class="line-removed">-       __ ldrq(vtmp, Address(tmp2));</span>
<span class="line-removed">-       __ ldr(tmpU, Address(__ post(cnt1, 8)));</span>
<span class="line-removed">-       __ zip1(vtmp3, __ T16B, vtmp, vtmpZ);</span>
<span class="line-removed">-       __ zip2(vtmp, __ T16B, vtmp, vtmpZ);</span>
<span class="line-removed">-       __ fmovd(tmpL, vtmp3);</span>
<span class="line-removed">-       __ eor(rscratch2, tmp3, tmpL);</span>
<span class="line-removed">-       __ cbnz(rscratch2, DIFF2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       __ ldr(tmp3, Address(__ post(cnt1, 8)));</span>
<span class="line-removed">-       __ umov(tmpL, vtmp3, __ D, 1);</span>
<span class="line-removed">-       __ eor(rscratch2, tmpU, tmpL);</span>
<span class="line-removed">-       __ cbnz(rscratch2, DIFF1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       __ ldr(tmpU, Address(__ post(cnt1, 8)));</span>
<span class="line-removed">-       __ fmovd(tmpL, vtmp);</span>
<span class="line-removed">-       __ eor(rscratch2, tmp3, tmpL);</span>
<span class="line-removed">-       __ cbnz(rscratch2, DIFF2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       __ umov(tmpL, vtmp, __ D, 1);</span>
<span class="line-removed">-       __ eor(rscratch2, tmpU, tmpL);</span>
<span class="line-removed">-       __ cbnz(rscratch2, DIFF1);</span>
        __ b(LOAD_LAST);
      __ bind(DIFF2);
        __ mov(tmpU, tmp3);
      __ bind(DIFF1);
        __ pop(spilled_regs, sp);
        __ b(CALCULATE_DIFFERENCE);
      __ bind(LOAD_LAST);
        __ pop(spilled_regs, sp);
  
<span class="line-modified">!       __ ldrs(vtmp, Address(strL));</span>
<span class="line-modified">!       __ ldr(tmpU, Address(strU));</span>
        __ zip1(vtmp, __ T8B, vtmp, vtmpZ);
        __ fmovd(tmpL, vtmp);
  
        __ eor(rscratch2, tmpU, tmpL);
        __ cbz(rscratch2, DONE);
<span class="line-new-header">--- 4102,39 ---</span>
            __ sub(cnt2, cnt2, 64);
            __ subs(rscratch2, cnt2, prefetchLoopExitCondition);
            __ br(__ GE, LARGE_LOOP_PREFETCH);
      }
      __ cbz(cnt2, LOAD_LAST); // no characters left except last load
<span class="line-added">+     __ bind(NO_PREFETCH);</span>
      __ subs(cnt2, cnt2, 16);
      __ br(__ LT, TAIL);
<span class="line-modified">!     __ align(OptoLoopAlignment);</span>
      __ bind(SMALL_LOOP); // smaller loop
        __ subs(cnt2, cnt2, 16);
        compare_string_16_x_LU(tmpL, tmpU, DIFF1, DIFF2);
        __ br(__ GE, SMALL_LOOP);
<span class="line-modified">!       __ cmn(cnt2, (u1)16);</span>
<span class="line-modified">!       __ br(__ EQ, LOAD_LAST);</span>
<span class="line-modified">!     __ bind(TAIL); // 1..15 characters left until last load (last 4 characters)</span>
<span class="line-modified">!       __ add(cnt1, cnt1, cnt2, __ LSL, 1); // Address of 32 bytes before last 4 characters in UTF-16 string</span>
<span class="line-modified">!       __ add(tmp2, tmp2, cnt2); // Address of 16 bytes before last 4 characters in Latin1 string</span>
<span class="line-modified">!       __ ldr(tmp3, Address(cnt1, -8));</span>
<span class="line-modified">!       compare_string_16_x_LU(tmpL, tmpU, DIFF1, DIFF2); // last 16 characters before last load</span>
        __ b(LOAD_LAST);
      __ bind(DIFF2);
        __ mov(tmpU, tmp3);
      __ bind(DIFF1);
        __ pop(spilled_regs, sp);
        __ b(CALCULATE_DIFFERENCE);
      __ bind(LOAD_LAST);
<span class="line-added">+       // Last 4 UTF-16 characters are already pre-loaded into tmp3 by compare_string_16_x_LU.</span>
<span class="line-added">+       // No need to load it again</span>
<span class="line-added">+       __ mov(tmpU, tmp3);</span>
        __ pop(spilled_regs, sp);
  
<span class="line-modified">!       // tmp2 points to the address of the last 4 Latin1 characters right now</span>
<span class="line-modified">!       __ ldrs(vtmp, Address(tmp2));</span>
        __ zip1(vtmp, __ T8B, vtmp, vtmpZ);
        __ fmovd(tmpL, vtmp);
  
        __ eor(rscratch2, tmpU, tmpL);
        __ cbz(rscratch2, DONE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4208,14 ***</span>
          compare_string_16_bytes_same(DIFF, DIFF2);
          __ subs(rscratch2, cnt2, largeLoopExitCondition);
          compare_string_16_bytes_same(DIFF, DIFF2);
          __ br(__ GT, LARGE_LOOP_PREFETCH);
          __ cbz(cnt2, LAST_CHECK_AND_LENGTH_DIFF); // no more chars left?
<span class="line-removed">-         // less than 16 bytes left?</span>
<span class="line-removed">-         __ subs(cnt2, cnt2, isLL ? 16 : 8);</span>
<span class="line-removed">-         __ br(__ LT, TAIL);</span>
      }
      __ bind(SMALL_LOOP);
        compare_string_16_bytes_same(DIFF, DIFF2);
        __ subs(cnt2, cnt2, isLL ? 16 : 8);
        __ br(__ GE, SMALL_LOOP);
      __ bind(TAIL);
<span class="line-new-header">--- 4192,15 ---</span>
          compare_string_16_bytes_same(DIFF, DIFF2);
          __ subs(rscratch2, cnt2, largeLoopExitCondition);
          compare_string_16_bytes_same(DIFF, DIFF2);
          __ br(__ GT, LARGE_LOOP_PREFETCH);
          __ cbz(cnt2, LAST_CHECK_AND_LENGTH_DIFF); // no more chars left?
      }
<span class="line-added">+     // less than 16 bytes left?</span>
<span class="line-added">+     __ subs(cnt2, cnt2, isLL ? 16 : 8);</span>
<span class="line-added">+     __ br(__ LT, TAIL);</span>
<span class="line-added">+     __ align(OptoLoopAlignment);</span>
      __ bind(SMALL_LOOP);
        compare_string_16_bytes_same(DIFF, DIFF2);
        __ subs(cnt2, cnt2, isLL ? 16 : 8);
        __ br(__ GE, SMALL_LOOP);
      __ bind(TAIL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4340,10 ***</span>
<span class="line-new-header">--- 4325,11 ---</span>
          L_CMP_LOOP_LAST_CMP2, DONE, NOMATCH;
      // Read whole register from str1. It is safe, because length &gt;=8 here
      __ ldr(ch1, Address(str1));
      // Read whole register from str2. It is safe, because length &gt;=8 here
      __ ldr(ch2, Address(str2));
<span class="line-added">+     __ sub(cnt2, cnt2, cnt1);</span>
      __ andr(first, ch1, str1_isL ? 0xFF : 0xFFFF);
      if (str1_isL != str2_isL) {
        __ eor(v0, __ T16B, v0, v0);
      }
      __ mov(tmp1, str2_isL ? 0x0101010101010101 : 0x0001000100010001);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4811,11 ***</span>
        __ mov(c_rarg2, arg2);
      }
      __ mov(c_rarg0, rthread);
      BLOCK_COMMENT(&quot;call runtime_entry&quot;);
      __ mov(rscratch1, runtime_entry);
<span class="line-modified">!     __ blrt(rscratch1, 3 /* number_of_arguments */, 0, 1);</span>
  
      // Generate oop map
      OopMap* map = new OopMap(framesize, 0);
  
      oop_maps-&gt;add_gc_map(the_pc - start, map);
<span class="line-new-header">--- 4797,11 ---</span>
        __ mov(c_rarg2, arg2);
      }
      __ mov(c_rarg0, rthread);
      BLOCK_COMMENT(&quot;call runtime_entry&quot;);
      __ mov(rscratch1, runtime_entry);
<span class="line-modified">!     __ blr(rscratch1);</span>
  
      // Generate oop map
      OopMap* map = new OopMap(framesize, 0);
  
      oop_maps-&gt;add_gc_map(the_pc - start, map);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5785,16 ***</span>
        // because it&#39;s faster for the sizes of modulus we care about.
        StubRoutines::_montgomerySquare = g.generate_multiply();
      }
  #endif // COMPILER2
  
<span class="line-removed">- #ifndef BUILTIN_SIM</span>
      // generate GHASH intrinsics code
      if (UseGHASHIntrinsics) {
        StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks();
      }
  
      if (UseAESIntrinsics) {
        StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
        StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
        StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_encryptAESCrypt();
        StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt();
<span class="line-new-header">--- 5771,19 ---</span>
        // because it&#39;s faster for the sizes of modulus we care about.
        StubRoutines::_montgomerySquare = g.generate_multiply();
      }
  #endif // COMPILER2
  
      // generate GHASH intrinsics code
      if (UseGHASHIntrinsics) {
        StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks();
      }
  
<span class="line-added">+     // data cache line writeback</span>
<span class="line-added">+     StubRoutines::_data_cache_writeback = generate_data_cache_writeback();</span>
<span class="line-added">+     StubRoutines::_data_cache_writeback_sync = generate_data_cache_writeback_sync();</span>
<span class="line-added">+ </span>
      if (UseAESIntrinsics) {
        StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
        StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
        StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_encryptAESCrypt();
        StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5819,11 ***</span>
                                                         &amp;StubRoutines::_safefetch32_fault_pc,
                                                         &amp;StubRoutines::_safefetch32_continuation_pc);
      generate_safefetch(&quot;SafeFetchN&quot;, sizeof(intptr_t), &amp;StubRoutines::_safefetchN_entry,
                                                         &amp;StubRoutines::_safefetchN_fault_pc,
                                                         &amp;StubRoutines::_safefetchN_continuation_pc);
<span class="line-removed">- #endif</span>
      StubRoutines::aarch64::set_completed();
    }
  
   public:
    StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
<span class="line-new-header">--- 5808,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5833,8 ***</span>
<span class="line-new-header">--- 5821,12 ---</span>
        generate_initial();
      }
    }
  }; // end class declaration
  
<span class="line-added">+ #define UCM_TABLE_MAX_ENTRIES 8</span>
  void StubGenerator_generate(CodeBuffer* code, bool all) {
<span class="line-added">+   if (UnsafeCopyMemory::_table == NULL) {</span>
<span class="line-added">+     UnsafeCopyMemory::create_table(UCM_TABLE_MAX_ENTRIES);</span>
<span class="line-added">+   }</span>
    StubGenerator g(code, all);
  }
</pre>
<center><a href="sharedRuntime_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubRoutines_aarch64.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
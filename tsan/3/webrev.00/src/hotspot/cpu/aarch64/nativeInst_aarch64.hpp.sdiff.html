<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/nativeInst_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nativeInst_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="register_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/nativeInst_aarch64.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
364 //      fstp_s [reg + offset]
365 //      fstp_d [reg + offset]
366 //      mov_literal64  scratch,&lt;pointer&gt; ; mov[b/w/l/q] 0(scratch),reg | mov[b/w/l/q] reg,0(scratch)
367 //
368 // Warning: These routines must be able to handle any instruction sequences
369 // that are generated as a result of the load/store byte,word,long
370 // macros.  For example: The load_unsigned_byte instruction generates
371 // an xor reg,reg inst prior to generating the movb instruction.  This
372 // class must skip the xor instruction.
373 
374 class NativeMovRegMem: public NativeInstruction {
375   enum AArch64_specific_constants {
376     instruction_size            =    4,
377     instruction_offset          =    0,
378     data_offset                 =    0,
379     next_instruction_offset     =    4
380   };
381 
382  public:
383   // helper
<span class="line-modified">384   int instruction_start() const;</span>
385 
<span class="line-modified">386   address instruction_address() const;</span>
387 
<span class="line-modified">388   address next_instruction_address() const;</span>
389 
390   int   offset() const;
391 
392   void  set_offset(int x);
393 
394   void  add_offset_in_bytes(int add_offset)     { set_offset ( ( offset() + add_offset ) ); }
395 
396   void verify();
397   void print ();
398 
399   // unit test stuff
400   static void test() {}
401 
402  private:
403   inline friend NativeMovRegMem* nativeMovRegMem_at (address address);
404 };
405 
406 inline NativeMovRegMem* nativeMovRegMem_at (address address) {
407   NativeMovRegMem* test = (NativeMovRegMem*)(address - NativeMovRegMem::instruction_offset);
408 #ifdef ASSERT
</pre>
</td>
<td>
<hr />
<pre>
364 //      fstp_s [reg + offset]
365 //      fstp_d [reg + offset]
366 //      mov_literal64  scratch,&lt;pointer&gt; ; mov[b/w/l/q] 0(scratch),reg | mov[b/w/l/q] reg,0(scratch)
367 //
368 // Warning: These routines must be able to handle any instruction sequences
369 // that are generated as a result of the load/store byte,word,long
370 // macros.  For example: The load_unsigned_byte instruction generates
371 // an xor reg,reg inst prior to generating the movb instruction.  This
372 // class must skip the xor instruction.
373 
374 class NativeMovRegMem: public NativeInstruction {
375   enum AArch64_specific_constants {
376     instruction_size            =    4,
377     instruction_offset          =    0,
378     data_offset                 =    0,
379     next_instruction_offset     =    4
380   };
381 
382  public:
383   // helper
<span class="line-modified">384   int instruction_start() const { return instruction_offset; }</span>
385 
<span class="line-modified">386   address instruction_address() const { return addr_at(instruction_offset); }</span>
387 
<span class="line-modified">388   int num_bytes_to_end_of_patch() const { return instruction_offset + instruction_size; }</span>
389 
390   int   offset() const;
391 
392   void  set_offset(int x);
393 
394   void  add_offset_in_bytes(int add_offset)     { set_offset ( ( offset() + add_offset ) ); }
395 
396   void verify();
397   void print ();
398 
399   // unit test stuff
400   static void test() {}
401 
402  private:
403   inline friend NativeMovRegMem* nativeMovRegMem_at (address address);
404 };
405 
406 inline NativeMovRegMem* nativeMovRegMem_at (address address) {
407   NativeMovRegMem* test = (NativeMovRegMem*)(address - NativeMovRegMem::instruction_offset);
408 #ifdef ASSERT
</pre>
</td>
</tr>
</table>
<center><a href="nativeInst_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="register_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
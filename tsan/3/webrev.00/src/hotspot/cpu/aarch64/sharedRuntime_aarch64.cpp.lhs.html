<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;code/debugInfoRec.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/interp_masm.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a>
  36 #include &quot;oops/compiledICHolder.hpp&quot;
<a name="3" id="anc3"></a>
  37 #include &quot;runtime/safepointMechanism.hpp&quot;
  38 #include &quot;runtime/sharedRuntime.hpp&quot;
  39 #include &quot;runtime/vframeArray.hpp&quot;
  40 #include &quot;utilities/align.hpp&quot;
  41 #include &quot;vmreg_aarch64.inline.hpp&quot;
  42 #ifdef COMPILER1
  43 #include &quot;c1/c1_Runtime1.hpp&quot;
  44 #endif
  45 #if COMPILER2_OR_JVMCI
  46 #include &quot;adfiles/ad_aarch64.hpp&quot;
  47 #include &quot;opto/runtime.hpp&quot;
  48 #endif
  49 #if INCLUDE_JVMCI
  50 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  51 #endif
  52 
<a name="4" id="anc4"></a><span class="line-removed">  53 #ifdef BUILTIN_SIM</span>
<span class="line-removed">  54 #include &quot;../../../../../../simulator/simulator.hpp&quot;</span>
<span class="line-removed">  55 #endif</span>
<span class="line-removed">  56 </span>
  57 #define __ masm-&gt;
  58 
  59 const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  60 
  61 class SimpleRuntimeFrame {
  62 
  63   public:
  64 
  65   // Most of the runtime stubs have this simple frame layout.
  66   // This class exists to make the layout shared in one place.
  67   // Offsets are for compiler stack slots, which are jints.
  68   enum layout {
  69     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
  70     // will override any oopMap setting for it. We must therefore force the layout
  71     // so that it agrees with the frame sender code.
  72     // we don&#39;t expect any arg reg save area so aarch64 asserts that
  73     // frame::arg_reg_save_area_bytes == 0
  74     rbp_off = 0,
  75     rbp_off2,
  76     return_off, return_off2,
  77     framesize
  78   };
  79 };
  80 
  81 // FIXME -- this is used by C1
  82 class RegisterSaver {
  83  public:
  84   static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors = false);
  85   static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);
  86 
  87   // Offsets into the register save area
  88   // Used by deoptimization when it is managing result register
  89   // values on its own
  90 
  91   static int r0_offset_in_bytes(void)    { return (32 + r0-&gt;encoding()) * wordSize; }
  92   static int reg_offset_in_bytes(Register r)    { return r0_offset_in_bytes() + r-&gt;encoding() * wordSize; }
  93   static int rmethod_offset_in_bytes(void)    { return reg_offset_in_bytes(rmethod); }
  94   static int rscratch1_offset_in_bytes(void)    { return (32 + rscratch1-&gt;encoding()) * wordSize; }
  95   static int v0_offset_in_bytes(void)   { return 0; }
  96   static int return_offset_in_bytes(void) { return (32 /* floats*/ + 31 /* gregs*/) * wordSize; }
  97 
  98   // During deoptimization only the result registers need to be restored,
  99   // all the other values have already been extracted.
 100   static void restore_result_registers(MacroAssembler* masm);
 101 
 102     // Capture info about frame layout
 103   enum layout {
 104                 fpu_state_off = 0,
<a name="5" id="anc5"></a><span class="line-modified"> 105                 fpu_state_end = fpu_state_off+FPUStateSizeInWords-1,</span>
 106                 // The frame sender code expects that rfp will be in
 107                 // the &quot;natural&quot; place and will override any oopMap
 108                 // setting for it. We must therefore force the layout
 109                 // so that it agrees with the frame sender code.
<a name="6" id="anc6"></a><span class="line-modified"> 110                 r0_off = fpu_state_off+FPUStateSizeInWords,</span>
<span class="line-modified"> 111                 rfp_off = r0_off + 30 * 2,</span>
<span class="line-modified"> 112                 return_off = rfp_off + 2,      // slot for return address</span>
<span class="line-modified"> 113                 reg_save_size = return_off + 2};</span>
 114 
 115 };
 116 
 117 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {
 118 #if COMPILER2_OR_JVMCI
 119   if (save_vectors) {
 120     // Save upper half of vector registers
<a name="7" id="anc7"></a><span class="line-modified"> 121     int vect_words = 32 * 8 / wordSize;</span>

 122     additional_frame_words += vect_words;
 123   }
 124 #else
 125   assert(!save_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 126 #endif
 127 
<a name="8" id="anc8"></a><span class="line-modified"> 128   int frame_size_in_bytes = align_up(additional_frame_words*wordSize +</span>
<span class="line-modified"> 129                                      reg_save_size*BytesPerInt, 16);</span>
 130   // OopMap frame size is in compiler stack slots (jint&#39;s) not bytes or words
 131   int frame_size_in_slots = frame_size_in_bytes / BytesPerInt;
 132   // The caller will allocate additional_frame_words
<a name="9" id="anc9"></a><span class="line-modified"> 133   int additional_frame_slots = additional_frame_words*wordSize / BytesPerInt;</span>
 134   // CodeBlob frame size is in words.
 135   int frame_size_in_words = frame_size_in_bytes / wordSize;
 136   *total_frame_words = frame_size_in_words;
 137 
<a name="10" id="anc10"></a><span class="line-modified"> 138   // Save registers, fpu state, and flags.</span>
<span class="line-removed"> 139 </span>
 140   __ enter();
 141   __ push_CPU_state(save_vectors);
 142 
 143   // Set an oopmap for the call site.  This oopmap will map all
 144   // oop-registers and debug-info registers as callee-saved.  This
 145   // will allow deoptimization at this safepoint to find all possible
 146   // debug-info recordings, as well as let GC find all oops.
 147 
 148   OopMapSet *oop_maps = new OopMapSet();
 149   OopMap* oop_map = new OopMap(frame_size_in_slots, 0);
 150 
 151   for (int i = 0; i &lt; RegisterImpl::number_of_registers; i++) {
 152     Register r = as_Register(i);
<a name="11" id="anc11"></a><span class="line-modified"> 153     if (r &lt; rheapbase &amp;&amp; r != rscratch1 &amp;&amp; r != rscratch2) {</span>
<span class="line-modified"> 154       int sp_offset = 2 * (i + 32); // SP offsets are in 4-byte words,</span>
<span class="line-modified"> 155                                     // register slots are 8 bytes</span>
<span class="line-modified"> 156                                     // wide, 32 floating-point</span>
<span class="line-modified"> 157                                     // registers</span>
 158       oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset + additional_frame_slots),
 159                                 r-&gt;as_VMReg());
 160     }
 161   }
 162 
 163   for (int i = 0; i &lt; FloatRegisterImpl::number_of_registers; i++) {
 164     FloatRegister r = as_FloatRegister(i);
<a name="12" id="anc12"></a><span class="line-modified"> 165     int sp_offset = save_vectors ? (4 * i) : (2 * i);</span>

 166     oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
 167                               r-&gt;as_VMReg());
 168   }
 169 
 170   return oop_map;
 171 }
 172 
 173 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {
 174 #ifndef COMPILER2
 175   assert(!restore_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 176 #endif
 177   __ pop_CPU_state(restore_vectors);
 178   __ leave();
 179 }
 180 
 181 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 182 
 183   // Just restore result register. Only used by deoptimization. By
 184   // now any callee save register that needs to be restored to a c2
 185   // caller of the deoptee has been extracted into the vframeArray
 186   // and will be stuffed into the c2i adapter we create for later
 187   // restoration so only result registers need to be restored here.
 188 
 189   // Restore fp result register
 190   __ ldrd(v0, Address(sp, v0_offset_in_bytes()));
 191   // Restore integer result register
 192   __ ldr(r0, Address(sp, r0_offset_in_bytes()));
 193 
 194   // Pop all of the register save are off the stack
 195   __ add(sp, sp, align_up(return_offset_in_bytes(), 16));
 196 }
 197 
 198 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
 199 // 8 bytes vector registers are saved by default on AArch64.
 200 bool SharedRuntime::is_wide_vector(int size) {
 201   return size &gt; 8;
 202 }
 203 
 204 size_t SharedRuntime::trampoline_size() {
 205   return 16;
 206 }
 207 
 208 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 209   __ mov(rscratch1, destination);
 210   __ br(rscratch1);
 211 }
 212 
 213 // The java_calling_convention describes stack locations as ideal slots on
 214 // a frame with no abi restrictions. Since we must observe abi restrictions
 215 // (like the placement of the register window) the slots must be biased by
 216 // the following value.
 217 static int reg2offset_in(VMReg r) {
 218   // Account for saved rfp and lr
 219   // This should really be in_preserve_stack_slots
 220   return (r-&gt;reg2stack() + 4) * VMRegImpl::stack_slot_size;
 221 }
 222 
 223 static int reg2offset_out(VMReg r) {
 224   return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 225 }
 226 
 227 // ---------------------------------------------------------------------------
 228 // Read the array of BasicTypes from a signature, and compute where the
 229 // arguments should go.  Values in the VMRegPair regs array refer to 4-byte
 230 // quantities.  Values less than VMRegImpl::stack0 are registers, those above
 231 // refer to 4-byte stack slots.  All stack slots are based off of the stack pointer
 232 // as framesizes are fixed.
 233 // VMRegImpl::stack0 refers to the first slot 0(sp).
 234 // and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register
 235 // up to RegisterImpl::number_of_registers) are the 64-bit
 236 // integer registers.
 237 
 238 // Note: the INPUTS in sig_bt are in units of Java argument words,
 239 // which are 64-bit.  The OUTPUTS are in 32-bit units.
 240 
 241 // The Java calling convention is a &quot;shifted&quot; version of the C ABI.
 242 // By skipping the first C ABI register we can call non-static jni
 243 // methods with small numbers of arguments without having to shuffle
 244 // the arguments at all. Since we control the java ABI we ought to at
 245 // least get some advantage out of it.
 246 
 247 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 248                                            VMRegPair *regs,
 249                                            int total_args_passed,
 250                                            int is_outgoing) {
 251 
 252   // Create the mapping between argument positions and
 253   // registers.
 254   static const Register INT_ArgReg[Argument::n_int_register_parameters_j] = {
 255     j_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4, j_rarg5, j_rarg6, j_rarg7
 256   };
 257   static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_j] = {
 258     j_farg0, j_farg1, j_farg2, j_farg3,
 259     j_farg4, j_farg5, j_farg6, j_farg7
 260   };
 261 
 262 
 263   uint int_args = 0;
 264   uint fp_args = 0;
 265   uint stk_args = 0; // inc by 2 each time
 266 
 267   for (int i = 0; i &lt; total_args_passed; i++) {
 268     switch (sig_bt[i]) {
 269     case T_BOOLEAN:
 270     case T_CHAR:
 271     case T_BYTE:
 272     case T_SHORT:
 273     case T_INT:
 274       if (int_args &lt; Argument::n_int_register_parameters_j) {
 275         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 276       } else {
 277         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 278         stk_args += 2;
 279       }
 280       break;
 281     case T_VOID:
 282       // halves of T_LONG or T_DOUBLE
 283       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 284       regs[i].set_bad();
 285       break;
 286     case T_LONG:
 287       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 288       // fall through
 289     case T_OBJECT:
 290     case T_ARRAY:
 291     case T_ADDRESS:
 292       if (int_args &lt; Argument::n_int_register_parameters_j) {
 293         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 294       } else {
 295         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 296         stk_args += 2;
 297       }
 298       break;
 299     case T_FLOAT:
 300       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 301         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 302       } else {
 303         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 304         stk_args += 2;
 305       }
 306       break;
 307     case T_DOUBLE:
 308       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 309       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 310         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 311       } else {
 312         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 313         stk_args += 2;
 314       }
 315       break;
 316     default:
 317       ShouldNotReachHere();
 318       break;
 319     }
 320   }
 321 
 322   return align_up(stk_args, 2);
 323 }
 324 
 325 // Patch the callers callsite with entry to compiled code if it exists.
 326 static void patch_callers_callsite(MacroAssembler *masm) {
 327   Label L;
 328   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 329   __ cbz(rscratch1, L);
 330 
 331   __ enter();
 332   __ push_CPU_state();
 333 
 334   // VM needs caller&#39;s callsite
 335   // VM needs target method
 336   // This needs to be a long call since we will relocate this adapter to
 337   // the codeBuffer and it may not reach
 338 
 339 #ifndef PRODUCT
 340   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 341 #endif
 342 
 343   __ mov(c_rarg0, rmethod);
 344   __ mov(c_rarg1, lr);
 345   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
<a name="13" id="anc13"></a><span class="line-modified"> 346   __ blrt(rscratch1, 2, 0, 0);</span>
 347   __ maybe_isb();
 348 
 349   __ pop_CPU_state();
 350   // restore sp
 351   __ leave();
 352   __ bind(L);
 353 }
 354 
 355 static void gen_c2i_adapter(MacroAssembler *masm,
 356                             int total_args_passed,
 357                             int comp_args_on_stack,
 358                             const BasicType *sig_bt,
 359                             const VMRegPair *regs,
 360                             Label&amp; skip_fixup) {
 361   // Before we get into the guts of the C2I adapter, see if we should be here
 362   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 363   // interpreter, which means the caller made a static call to get here
 364   // (vcalls always get a compiled target if there is one).  Check for a
 365   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 366   patch_callers_callsite(masm);
 367 
 368   __ bind(skip_fixup);
 369 
 370   int words_pushed = 0;
 371 
 372   // Since all args are passed on the stack, total_args_passed *
 373   // Interpreter::stackElementSize is the space we need.
 374 
 375   int extraspace = total_args_passed * Interpreter::stackElementSize;
 376 
 377   __ mov(r13, sp);
 378 
 379   // stack is aligned, keep it that way
 380   extraspace = align_up(extraspace, 2*wordSize);
 381 
 382   if (extraspace)
 383     __ sub(sp, sp, extraspace);
 384 
 385   // Now write the args into the outgoing interpreter space
 386   for (int i = 0; i &lt; total_args_passed; i++) {
 387     if (sig_bt[i] == T_VOID) {
 388       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 389       continue;
 390     }
 391 
 392     // offset to start parameters
 393     int st_off   = (total_args_passed - i - 1) * Interpreter::stackElementSize;
 394     int next_off = st_off - Interpreter::stackElementSize;
 395 
 396     // Say 4 args:
 397     // i   st_off
 398     // 0   32 T_LONG
 399     // 1   24 T_VOID
 400     // 2   16 T_OBJECT
 401     // 3    8 T_BOOL
 402     // -    0 return address
 403     //
 404     // However to make thing extra confusing. Because we can fit a long/double in
 405     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 406     // leaves one slot empty and only stores to a single slot. In this case the
 407     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 408 
 409     VMReg r_1 = regs[i].first();
 410     VMReg r_2 = regs[i].second();
 411     if (!r_1-&gt;is_valid()) {
 412       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 413       continue;
 414     }
 415     if (r_1-&gt;is_stack()) {
 416       // memory to memory use rscratch1
 417       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size
 418                     + extraspace
 419                     + words_pushed * wordSize);
 420       if (!r_2-&gt;is_valid()) {
 421         // sign extend??
 422         __ ldrw(rscratch1, Address(sp, ld_off));
 423         __ str(rscratch1, Address(sp, st_off));
 424 
 425       } else {
 426 
 427         __ ldr(rscratch1, Address(sp, ld_off));
 428 
 429         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG
 430         // T_DOUBLE and T_LONG use two slots in the interpreter
 431         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
 432           // ld_off == LSW, ld_off+wordSize == MSW
 433           // st_off == MSW, next_off == LSW
 434           __ str(rscratch1, Address(sp, next_off));
 435 #ifdef ASSERT
 436           // Overwrite the unused slot with known junk
 437           __ mov(rscratch1, 0xdeadffffdeadaaaaul);
 438           __ str(rscratch1, Address(sp, st_off));
 439 #endif /* ASSERT */
 440         } else {
 441           __ str(rscratch1, Address(sp, st_off));
 442         }
 443       }
 444     } else if (r_1-&gt;is_Register()) {
 445       Register r = r_1-&gt;as_Register();
 446       if (!r_2-&gt;is_valid()) {
 447         // must be only an int (or less ) so move only 32bits to slot
 448         // why not sign extend??
 449         __ str(r, Address(sp, st_off));
 450       } else {
 451         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG
 452         // T_DOUBLE and T_LONG use two slots in the interpreter
 453         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
 454           // long/double in gpr
 455 #ifdef ASSERT
 456           // Overwrite the unused slot with known junk
 457           __ mov(rscratch1, 0xdeadffffdeadaaabul);
 458           __ str(rscratch1, Address(sp, st_off));
 459 #endif /* ASSERT */
 460           __ str(r, Address(sp, next_off));
 461         } else {
 462           __ str(r, Address(sp, st_off));
 463         }
 464       }
 465     } else {
 466       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 467       if (!r_2-&gt;is_valid()) {
 468         // only a float use just part of the slot
 469         __ strs(r_1-&gt;as_FloatRegister(), Address(sp, st_off));
 470       } else {
 471 #ifdef ASSERT
 472         // Overwrite the unused slot with known junk
 473         __ mov(rscratch1, 0xdeadffffdeadaaacul);
 474         __ str(rscratch1, Address(sp, st_off));
 475 #endif /* ASSERT */
 476         __ strd(r_1-&gt;as_FloatRegister(), Address(sp, next_off));
 477       }
 478     }
 479   }
 480 
 481   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 482 
 483   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 484   __ br(rscratch1);
 485 }
 486 
 487 
 488 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,
 489                                     int total_args_passed,
 490                                     int comp_args_on_stack,
 491                                     const BasicType *sig_bt,
 492                                     const VMRegPair *regs) {
 493 
 494   // Note: r13 contains the senderSP on entry. We must preserve it since
 495   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 496   // code goes non-entrant while we get args ready.
 497 
 498   // In addition we use r13 to locate all the interpreter args because
 499   // we must align the stack to 16 bytes.
 500 
 501   // Adapters are frameless.
 502 
 503   // An i2c adapter is frameless because the *caller* frame, which is
 504   // interpreted, routinely repairs its own esp (from
 505   // interpreter_frame_last_sp), even if a callee has modified the
 506   // stack pointer.  It also recalculates and aligns sp.
 507 
 508   // A c2i adapter is frameless because the *callee* frame, which is
 509   // interpreted, routinely repairs its caller&#39;s sp (from sender_sp,
 510   // which is set up via the senderSP register).
 511 
 512   // In other words, if *either* the caller or callee is interpreted, we can
 513   // get the stack pointer repaired after a call.
 514 
 515   // This is why c2i and i2c adapters cannot be indefinitely composed.
 516   // In particular, if a c2i adapter were to somehow call an i2c adapter,
 517   // both caller and callee would be compiled methods, and neither would
 518   // clean up the stack pointer changes performed by the two adapters.
 519   // If this happens, control eventually transfers back to the compiled
 520   // caller, but with an uncorrected stack, causing delayed havoc.
 521 
 522   if (VerifyAdapterCalls &amp;&amp;
 523       (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {
 524 #if 0
 525     // So, let&#39;s test for cascading c2i/i2c adapters right now.
 526     //  assert(Interpreter::contains($return_addr) ||
 527     //         StubRoutines::contains($return_addr),
 528     //         &quot;i2c adapter must return to an interpreter frame&quot;);
 529     __ block_comment(&quot;verify_i2c { &quot;);
 530     Label L_ok;
 531     if (Interpreter::code() != NULL)
 532       range_check(masm, rax, r11,
 533                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 534                   L_ok);
 535     if (StubRoutines::code1() != NULL)
 536       range_check(masm, rax, r11,
 537                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 538                   L_ok);
 539     if (StubRoutines::code2() != NULL)
 540       range_check(masm, rax, r11,
 541                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 542                   L_ok);
 543     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 544     __ block_comment(msg);
 545     __ stop(msg);
 546     __ bind(L_ok);
 547     __ block_comment(&quot;} verify_i2ce &quot;);
 548 #endif
 549   }
 550 
 551   // Cut-out for having no stack args.
 552   int comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;
 553   if (comp_args_on_stack) {
 554     __ sub(rscratch1, sp, comp_words_on_stack * wordSize);
 555     __ andr(sp, rscratch1, -16);
 556   }
 557 
 558   // Will jump to the compiled code just as if compiled code was doing it.
 559   // Pre-load the register-jump target early, to schedule it better.
 560   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 561 
 562 #if INCLUDE_JVMCI
 563   if (EnableJVMCI || UseAOT) {
 564     // check if this call should be routed towards a specific entry point
 565     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 566     Label no_alternative_target;
 567     __ cbz(rscratch2, no_alternative_target);
 568     __ mov(rscratch1, rscratch2);
 569     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 570     __ bind(no_alternative_target);
 571   }
 572 #endif // INCLUDE_JVMCI
 573 
 574   // Now generate the shuffle code.
 575   for (int i = 0; i &lt; total_args_passed; i++) {
 576     if (sig_bt[i] == T_VOID) {
 577       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 578       continue;
 579     }
 580 
 581     // Pick up 0, 1 or 2 words from SP+offset.
 582 
 583     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
 584             &quot;scrambled load targets?&quot;);
 585     // Load in argument order going down.
 586     int ld_off = (total_args_passed - i - 1)*Interpreter::stackElementSize;
 587     // Point to interpreter value (vs. tag)
 588     int next_off = ld_off - Interpreter::stackElementSize;
 589     //
 590     //
 591     //
 592     VMReg r_1 = regs[i].first();
 593     VMReg r_2 = regs[i].second();
 594     if (!r_1-&gt;is_valid()) {
 595       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 596       continue;
 597     }
 598     if (r_1-&gt;is_stack()) {
 599       // Convert stack slot to an SP offset (+ wordSize to account for return address )
 600       int st_off = regs[i].first()-&gt;reg2stack()*VMRegImpl::stack_slot_size;
 601       if (!r_2-&gt;is_valid()) {
 602         // sign extend???
 603         __ ldrsw(rscratch2, Address(esp, ld_off));
 604         __ str(rscratch2, Address(sp, st_off));
 605       } else {
 606         //
 607         // We are using two optoregs. This can be either T_OBJECT,
 608         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 609         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 610         // So we must adjust where to pick up the data to match the
 611         // interpreter.
 612         //
 613         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 614         // are accessed as negative so LSW is at LOW address
 615 
 616         // ld_off is MSW so get LSW
 617         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?
 618                            next_off : ld_off;
 619         __ ldr(rscratch2, Address(esp, offset));
 620         // st_off is LSW (i.e. reg.first())
 621         __ str(rscratch2, Address(sp, st_off));
 622       }
 623     } else if (r_1-&gt;is_Register()) {  // Register argument
 624       Register r = r_1-&gt;as_Register();
 625       if (r_2-&gt;is_valid()) {
 626         //
 627         // We are using two VMRegs. This can be either T_OBJECT,
 628         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 629         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 630         // So we must adjust where to pick up the data to match the
 631         // interpreter.
 632 
 633         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?
 634                            next_off : ld_off;
 635 
 636         // this can be a misaligned move
 637         __ ldr(r, Address(esp, offset));
 638       } else {
 639         // sign extend and use a full word?
 640         __ ldrw(r, Address(esp, ld_off));
 641       }
 642     } else {
 643       if (!r_2-&gt;is_valid()) {
 644         __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));
 645       } else {
 646         __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));
 647       }
 648     }
 649   }
 650 
 651   // 6243940 We might end up in handle_wrong_method if
 652   // the callee is deoptimized as we race thru here. If that
 653   // happens we don&#39;t want to take a safepoint because the
 654   // caller frame will look interpreted and arguments are now
 655   // &quot;compiled&quot; so it is much better to make this transition
 656   // invisible to the stack walking code. Unfortunately if
 657   // we try and find the callee by normal means a safepoint
 658   // is possible. So we stash the desired callee in the thread
 659   // and the vm will find there should this case occur.
 660 
 661   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));
 662 
 663   __ br(rscratch1);
 664 }
 665 
<a name="14" id="anc14"></a><span class="line-removed"> 666 #ifdef BUILTIN_SIM</span>
<span class="line-removed"> 667 static void generate_i2c_adapter_name(char *result, int total_args_passed, const BasicType *sig_bt)</span>
<span class="line-removed"> 668 {</span>
<span class="line-removed"> 669   strcpy(result, &quot;i2c(&quot;);</span>
<span class="line-removed"> 670   int idx = 4;</span>
<span class="line-removed"> 671   for (int i = 0; i &lt; total_args_passed; i++) {</span>
<span class="line-removed"> 672     switch(sig_bt[i]) {</span>
<span class="line-removed"> 673     case T_BOOLEAN:</span>
<span class="line-removed"> 674       result[idx++] = &#39;Z&#39;;</span>
<span class="line-removed"> 675       break;</span>
<span class="line-removed"> 676     case T_CHAR:</span>
<span class="line-removed"> 677       result[idx++] = &#39;C&#39;;</span>
<span class="line-removed"> 678       break;</span>
<span class="line-removed"> 679     case T_FLOAT:</span>
<span class="line-removed"> 680       result[idx++] = &#39;F&#39;;</span>
<span class="line-removed"> 681       break;</span>
<span class="line-removed"> 682     case T_DOUBLE:</span>
<span class="line-removed"> 683       assert((i &lt; (total_args_passed - 1)) &amp;&amp; (sig_bt[i+1] == T_VOID),</span>
<span class="line-removed"> 684              &quot;double must be followed by void&quot;);</span>
<span class="line-removed"> 685       i++;</span>
<span class="line-removed"> 686       result[idx++] = &#39;D&#39;;</span>
<span class="line-removed"> 687       break;</span>
<span class="line-removed"> 688     case T_BYTE:</span>
<span class="line-removed"> 689       result[idx++] = &#39;B&#39;;</span>
<span class="line-removed"> 690       break;</span>
<span class="line-removed"> 691     case T_SHORT:</span>
<span class="line-removed"> 692       result[idx++] = &#39;S&#39;;</span>
<span class="line-removed"> 693       break;</span>
<span class="line-removed"> 694     case T_INT:</span>
<span class="line-removed"> 695       result[idx++] = &#39;I&#39;;</span>
<span class="line-removed"> 696       break;</span>
<span class="line-removed"> 697     case T_LONG:</span>
<span class="line-removed"> 698       assert((i &lt; (total_args_passed - 1)) &amp;&amp; (sig_bt[i+1] == T_VOID),</span>
<span class="line-removed"> 699              &quot;long must be followed by void&quot;);</span>
<span class="line-removed"> 700       i++;</span>
<span class="line-removed"> 701       result[idx++] = &#39;L&#39;;</span>
<span class="line-removed"> 702       break;</span>
<span class="line-removed"> 703     case T_OBJECT:</span>
<span class="line-removed"> 704       result[idx++] = &#39;O&#39;;</span>
<span class="line-removed"> 705       break;</span>
<span class="line-removed"> 706     case T_ARRAY:</span>
<span class="line-removed"> 707       result[idx++] = &#39;[&#39;;</span>
<span class="line-removed"> 708       break;</span>
<span class="line-removed"> 709     case T_ADDRESS:</span>
<span class="line-removed"> 710       result[idx++] = &#39;P&#39;;</span>
<span class="line-removed"> 711       break;</span>
<span class="line-removed"> 712     case T_NARROWOOP:</span>
<span class="line-removed"> 713       result[idx++] = &#39;N&#39;;</span>
<span class="line-removed"> 714       break;</span>
<span class="line-removed"> 715     case T_METADATA:</span>
<span class="line-removed"> 716       result[idx++] = &#39;M&#39;;</span>
<span class="line-removed"> 717       break;</span>
<span class="line-removed"> 718     case T_NARROWKLASS:</span>
<span class="line-removed"> 719       result[idx++] = &#39;K&#39;;</span>
<span class="line-removed"> 720       break;</span>
<span class="line-removed"> 721     default:</span>
<span class="line-removed"> 722       result[idx++] = &#39;?&#39;;</span>
<span class="line-removed"> 723       break;</span>
<span class="line-removed"> 724     }</span>
<span class="line-removed"> 725   }</span>
<span class="line-removed"> 726   result[idx++] = &#39;)&#39;;</span>
<span class="line-removed"> 727   result[idx] = &#39;\0&#39;;</span>
<span class="line-removed"> 728 }</span>
<span class="line-removed"> 729 #endif</span>
<span class="line-removed"> 730 </span>
 731 // ---------------------------------------------------------------
 732 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
 733                                                             int total_args_passed,
 734                                                             int comp_args_on_stack,
 735                                                             const BasicType *sig_bt,
 736                                                             const VMRegPair *regs,
 737                                                             AdapterFingerPrint* fingerprint) {
 738   address i2c_entry = __ pc();
<a name="15" id="anc15"></a><span class="line-removed"> 739 #ifdef BUILTIN_SIM</span>
<span class="line-removed"> 740   char *name = NULL;</span>
<span class="line-removed"> 741   AArch64Simulator *sim = NULL;</span>
<span class="line-removed"> 742   size_t len = 65536;</span>
<span class="line-removed"> 743   if (NotifySimulator) {</span>
<span class="line-removed"> 744     name = NEW_C_HEAP_ARRAY(char, len, mtInternal);</span>
<span class="line-removed"> 745   }</span>
 746 
<a name="16" id="anc16"></a><span class="line-removed"> 747   if (name) {</span>
<span class="line-removed"> 748     generate_i2c_adapter_name(name, total_args_passed, sig_bt);</span>
<span class="line-removed"> 749     sim = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed"> 750     sim-&gt;notifyCompile(name, i2c_entry);</span>
<span class="line-removed"> 751   }</span>
<span class="line-removed"> 752 #endif</span>
 753   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
 754 
 755   address c2i_unverified_entry = __ pc();
 756   Label skip_fixup;
 757 
 758   Label ok;
 759 
 760   Register holder = rscratch2;
 761   Register receiver = j_rarg0;
 762   Register tmp = r10;  // A call-clobbered register not used for arg passing
 763 
 764   // -------------------------------------------------------------------------
 765   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 766   // to the interpreter.  The args start out packed in the compiled layout.  They
 767   // need to be unpacked into the interpreter layout.  This will almost always
 768   // require some stack space.  We grow the current (compiled) stack, then repack
 769   // the args.  We  finally end in a jump to the generic interpreter entry point.
 770   // On exit from the interpreter, the interpreter will restore our SP (lest the
 771   // compiled code, which relys solely on SP and not FP, get sick).
 772 
 773   {
 774     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 775     __ load_klass(rscratch1, receiver);
 776     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 777     __ cmp(rscratch1, tmp);
 778     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 779     __ br(Assembler::EQ, ok);
 780     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 781 
 782     __ bind(ok);
 783     // Method might have been compiled since the call site was patched to
 784     // interpreted; if that is the case treat it as a miss so we can get
 785     // the call site corrected.
 786     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 787     __ cbz(rscratch1, skip_fixup);
 788     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 789     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 790   }
 791 
 792   address c2i_entry = __ pc();
 793 
<a name="17" id="anc17"></a><span class="line-modified"> 794 #ifdef BUILTIN_SIM</span>
<span class="line-modified"> 795   if (name) {</span>
<span class="line-modified"> 796     name[0] = &#39;c&#39;;</span>
<span class="line-modified"> 797     name[2] = &#39;i&#39;;</span>
<span class="line-modified"> 798     sim-&gt;notifyCompile(name, c2i_entry);</span>
<span class="line-modified"> 799     FREE_C_HEAP_ARRAY(char, name, mtInternal);</span>











 800   }
<a name="18" id="anc18"></a><span class="line-removed"> 801 #endif</span>
 802 
 803   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 804 
 805   __ flush();
<a name="19" id="anc19"></a><span class="line-modified"> 806   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);</span>
 807 }
 808 
 809 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 810                                          VMRegPair *regs,
 811                                          VMRegPair *regs2,
 812                                          int total_args_passed) {
 813   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
 814 
 815 // We return the amount of VMRegImpl stack slots we need to reserve for all
 816 // the arguments NOT counting out_preserve_stack_slots.
 817 
 818     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
 819       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
 820     };
 821     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
 822       c_farg0, c_farg1, c_farg2, c_farg3,
 823       c_farg4, c_farg5, c_farg6, c_farg7
 824     };
 825 
 826     uint int_args = 0;
 827     uint fp_args = 0;
 828     uint stk_args = 0; // inc by 2 each time
 829 
 830     for (int i = 0; i &lt; total_args_passed; i++) {
 831       switch (sig_bt[i]) {
 832       case T_BOOLEAN:
 833       case T_CHAR:
 834       case T_BYTE:
 835       case T_SHORT:
 836       case T_INT:
 837         if (int_args &lt; Argument::n_int_register_parameters_c) {
 838           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 839         } else {
 840           regs[i].set1(VMRegImpl::stack2reg(stk_args));
 841           stk_args += 2;
 842         }
 843         break;
 844       case T_LONG:
 845         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 846         // fall through
 847       case T_OBJECT:
 848       case T_ARRAY:
 849       case T_ADDRESS:
 850       case T_METADATA:
 851         if (int_args &lt; Argument::n_int_register_parameters_c) {
 852           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 853         } else {
 854           regs[i].set2(VMRegImpl::stack2reg(stk_args));
 855           stk_args += 2;
 856         }
 857         break;
 858       case T_FLOAT:
 859         if (fp_args &lt; Argument::n_float_register_parameters_c) {
 860           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 861         } else {
 862           regs[i].set1(VMRegImpl::stack2reg(stk_args));
 863           stk_args += 2;
 864         }
 865         break;
 866       case T_DOUBLE:
 867         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 868         if (fp_args &lt; Argument::n_float_register_parameters_c) {
 869           regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 870         } else {
 871           regs[i].set2(VMRegImpl::stack2reg(stk_args));
 872           stk_args += 2;
 873         }
 874         break;
 875       case T_VOID: // Halves of longs and doubles
 876         assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 877         regs[i].set_bad();
 878         break;
 879       default:
 880         ShouldNotReachHere();
 881         break;
 882       }
 883     }
 884 
 885   return stk_args;
 886 }
 887 
 888 // On 64 bit we will store integer like items to the stack as
 889 // 64 bits items (sparc abi) even though java would only store
 890 // 32bits for a parameter. On 32bit it will simply be 32 bits
 891 // So this routine will do 32-&gt;32 on 32bit and 32-&gt;64 on 64bit
 892 static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
 893   if (src.first()-&gt;is_stack()) {
 894     if (dst.first()-&gt;is_stack()) {
 895       // stack to stack
 896       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
 897       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
 898     } else {
 899       // stack to reg
 900       __ ldrsw(dst.first()-&gt;as_Register(), Address(rfp, reg2offset_in(src.first())));
 901     }
 902   } else if (dst.first()-&gt;is_stack()) {
 903     // reg to stack
 904     // Do we really have to sign extend???
 905     // __ movslq(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
 906     __ str(src.first()-&gt;as_Register(), Address(sp, reg2offset_out(dst.first())));
 907   } else {
 908     if (dst.first() != src.first()) {
 909       __ sxtw(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
 910     }
 911   }
 912 }
 913 
 914 // An oop arg. Must pass a handle not the oop itself
 915 static void object_move(MacroAssembler* masm,
 916                         OopMap* map,
 917                         int oop_handle_offset,
 918                         int framesize_in_slots,
 919                         VMRegPair src,
 920                         VMRegPair dst,
 921                         bool is_receiver,
 922                         int* receiver_offset) {
 923 
 924   // must pass a handle. First figure out the location we use as a handle
 925 
 926   Register rHandle = dst.first()-&gt;is_stack() ? rscratch2 : dst.first()-&gt;as_Register();
 927 
 928   // See if oop is NULL if it is we need no handle
 929 
 930   if (src.first()-&gt;is_stack()) {
 931 
 932     // Oop is already on the stack as an argument
 933     int offset_in_older_frame = src.first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
 934     map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));
 935     if (is_receiver) {
 936       *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;
 937     }
 938 
 939     __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
 940     __ lea(rHandle, Address(rfp, reg2offset_in(src.first())));
 941     // conditionally move a NULL
 942     __ cmp(rscratch1, zr);
 943     __ csel(rHandle, zr, rHandle, Assembler::EQ);
 944   } else {
 945 
 946     // Oop is in an a register we must store it to the space we reserve
 947     // on the stack for oop_handles and pass a handle if oop is non-NULL
 948 
 949     const Register rOop = src.first()-&gt;as_Register();
 950     int oop_slot;
 951     if (rOop == j_rarg0)
 952       oop_slot = 0;
 953     else if (rOop == j_rarg1)
 954       oop_slot = 1;
 955     else if (rOop == j_rarg2)
 956       oop_slot = 2;
 957     else if (rOop == j_rarg3)
 958       oop_slot = 3;
 959     else if (rOop == j_rarg4)
 960       oop_slot = 4;
 961     else if (rOop == j_rarg5)
 962       oop_slot = 5;
 963     else if (rOop == j_rarg6)
 964       oop_slot = 6;
 965     else {
 966       assert(rOop == j_rarg7, &quot;wrong register&quot;);
 967       oop_slot = 7;
 968     }
 969 
 970     oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;
 971     int offset = oop_slot*VMRegImpl::stack_slot_size;
 972 
 973     map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot));
 974     // Store oop in handle area, may be NULL
 975     __ str(rOop, Address(sp, offset));
 976     if (is_receiver) {
 977       *receiver_offset = offset;
 978     }
 979 
 980     __ cmp(rOop, zr);
 981     __ lea(rHandle, Address(sp, offset));
 982     // conditionally move a NULL
 983     __ csel(rHandle, zr, rHandle, Assembler::EQ);
 984   }
 985 
 986   // If arg is on the stack then place it otherwise it is already in correct reg.
 987   if (dst.first()-&gt;is_stack()) {
 988     __ str(rHandle, Address(sp, reg2offset_out(dst.first())));
 989   }
 990 }
 991 
 992 // A float arg may have to do float reg int reg conversion
 993 static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
 994   assert(src.first()-&gt;is_stack() &amp;&amp; dst.first()-&gt;is_stack() ||
 995          src.first()-&gt;is_reg() &amp;&amp; dst.first()-&gt;is_reg(), &quot;Unexpected error&quot;);
 996   if (src.first()-&gt;is_stack()) {
 997     if (dst.first()-&gt;is_stack()) {
 998       __ ldrw(rscratch1, Address(rfp, reg2offset_in(src.first())));
 999       __ strw(rscratch1, Address(sp, reg2offset_out(dst.first())));
1000     } else {
1001       ShouldNotReachHere();
1002     }
1003   } else if (src.first() != dst.first()) {
1004     if (src.is_single_phys_reg() &amp;&amp; dst.is_single_phys_reg())
1005       __ fmovs(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
1006     else
1007       ShouldNotReachHere();
1008   }
1009 }
1010 
1011 // A long move
1012 static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1013   if (src.first()-&gt;is_stack()) {
1014     if (dst.first()-&gt;is_stack()) {
1015       // stack to stack
1016       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
1017       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
1018     } else {
1019       // stack to reg
1020       __ ldr(dst.first()-&gt;as_Register(), Address(rfp, reg2offset_in(src.first())));
1021     }
1022   } else if (dst.first()-&gt;is_stack()) {
1023     // reg to stack
1024     // Do we really have to sign extend???
1025     // __ movslq(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1026     __ str(src.first()-&gt;as_Register(), Address(sp, reg2offset_out(dst.first())));
1027   } else {
1028     if (dst.first() != src.first()) {
1029       __ mov(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1030     }
1031   }
1032 }
1033 
1034 
1035 // A double move
1036 static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1037   assert(src.first()-&gt;is_stack() &amp;&amp; dst.first()-&gt;is_stack() ||
1038          src.first()-&gt;is_reg() &amp;&amp; dst.first()-&gt;is_reg(), &quot;Unexpected error&quot;);
1039   if (src.first()-&gt;is_stack()) {
1040     if (dst.first()-&gt;is_stack()) {
1041       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
1042       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
1043     } else {
1044       ShouldNotReachHere();
1045     }
1046   } else if (src.first() != dst.first()) {
1047     if (src.is_single_phys_reg() &amp;&amp; dst.is_single_phys_reg())
1048       __ fmovd(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
1049     else
1050       ShouldNotReachHere();
1051   }
1052 }
1053 
1054 
1055 void SharedRuntime::save_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1056   // We always ignore the frame_slots arg and just use the space just below frame pointer
1057   // which by this time is free to use
1058   switch (ret_type) {
1059   case T_FLOAT:
1060     __ strs(v0, Address(rfp, -wordSize));
1061     break;
1062   case T_DOUBLE:
1063     __ strd(v0, Address(rfp, -wordSize));
1064     break;
1065   case T_VOID:  break;
1066   default: {
1067     __ str(r0, Address(rfp, -wordSize));
1068     }
1069   }
1070 }
1071 
1072 void SharedRuntime::restore_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1073   // We always ignore the frame_slots arg and just use the space just below frame pointer
1074   // which by this time is free to use
1075   switch (ret_type) {
1076   case T_FLOAT:
1077     __ ldrs(v0, Address(rfp, -wordSize));
1078     break;
1079   case T_DOUBLE:
1080     __ ldrd(v0, Address(rfp, -wordSize));
1081     break;
1082   case T_VOID:  break;
1083   default: {
1084     __ ldr(r0, Address(rfp, -wordSize));
1085     }
1086   }
1087 }
1088 static void save_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1089   RegSet x;
1090   for ( int i = first_arg ; i &lt; arg_count ; i++ ) {
1091     if (args[i].first()-&gt;is_Register()) {
1092       x = x + args[i].first()-&gt;as_Register();
1093     } else if (args[i].first()-&gt;is_FloatRegister()) {
1094       __ strd(args[i].first()-&gt;as_FloatRegister(), Address(__ pre(sp, -2 * wordSize)));
1095     }
1096   }
1097   __ push(x, sp);
1098 }
1099 
1100 static void restore_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1101   RegSet x;
1102   for ( int i = first_arg ; i &lt; arg_count ; i++ ) {
1103     if (args[i].first()-&gt;is_Register()) {
1104       x = x + args[i].first()-&gt;as_Register();
1105     } else {
1106       ;
1107     }
1108   }
1109   __ pop(x, sp);
1110   for ( int i = arg_count - 1 ; i &gt;= first_arg ; i-- ) {
1111     if (args[i].first()-&gt;is_Register()) {
1112       ;
1113     } else if (args[i].first()-&gt;is_FloatRegister()) {
1114       __ ldrd(args[i].first()-&gt;as_FloatRegister(), Address(__ post(sp, 2 * wordSize)));
1115     }
1116   }
1117 }
1118 
1119 
1120 // Check GCLocker::needs_gc and enter the runtime if it&#39;s true.  This
1121 // keeps a new JNI critical region from starting until a GC has been
1122 // forced.  Save down any oops in registers and describe them in an
1123 // OopMap.
1124 static void check_needs_gc_for_critical_native(MacroAssembler* masm,
1125                                                int stack_slots,
1126                                                int total_c_args,
1127                                                int total_in_args,
1128                                                int arg_save_area,
1129                                                OopMapSet* oop_maps,
1130                                                VMRegPair* in_regs,
1131                                                BasicType* in_sig_bt) { Unimplemented(); }
1132 
1133 // Unpack an array argument into a pointer to the body and the length
1134 // if the array is non-null, otherwise pass 0 for both.
1135 static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type, VMRegPair body_arg, VMRegPair length_arg) { Unimplemented(); }
1136 
1137 
1138 class ComputeMoveOrder: public StackObj {
1139   class MoveOperation: public ResourceObj {
1140     friend class ComputeMoveOrder;
1141    private:
1142     VMRegPair        _src;
1143     VMRegPair        _dst;
1144     int              _src_index;
1145     int              _dst_index;
1146     bool             _processed;
1147     MoveOperation*  _next;
1148     MoveOperation*  _prev;
1149 
1150     static int get_id(VMRegPair r) { Unimplemented(); return 0; }
1151 
1152    public:
1153     MoveOperation(int src_index, VMRegPair src, int dst_index, VMRegPair dst):
1154       _src(src)
1155     , _dst(dst)
1156     , _src_index(src_index)
1157     , _dst_index(dst_index)
1158     , _processed(false)
1159     , _next(NULL)
1160     , _prev(NULL) { Unimplemented(); }
1161 
1162     VMRegPair src() const              { Unimplemented(); return _src; }
1163     int src_id() const                 { Unimplemented(); return 0; }
1164     int src_index() const              { Unimplemented(); return 0; }
1165     VMRegPair dst() const              { Unimplemented(); return _src; }
1166     void set_dst(int i, VMRegPair dst) { Unimplemented(); }
1167     int dst_index() const              { Unimplemented(); return 0; }
1168     int dst_id() const                 { Unimplemented(); return 0; }
1169     MoveOperation* next() const        { Unimplemented(); return 0; }
1170     MoveOperation* prev() const        { Unimplemented(); return 0; }
1171     void set_processed()               { Unimplemented(); }
1172     bool is_processed() const          { Unimplemented(); return 0; }
1173 
1174     // insert
1175     void break_cycle(VMRegPair temp_register) { Unimplemented(); }
1176 
1177     void link(GrowableArray&lt;MoveOperation*&gt;&amp; killer) { Unimplemented(); }
1178   };
1179 
1180  private:
1181   GrowableArray&lt;MoveOperation*&gt; edges;
1182 
1183  public:
1184   ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,
1185                     BasicType* in_sig_bt, GrowableArray&lt;int&gt;&amp; arg_order, VMRegPair tmp_vmreg) { Unimplemented(); }
1186 
1187   // Collected all the move operations
1188   void add_edge(int src_index, VMRegPair src, int dst_index, VMRegPair dst) { Unimplemented(); }
1189 
1190   // Walk the edges breaking cycles between moves.  The result list
1191   // can be walked in order to produce the proper set of loads
1192   GrowableArray&lt;MoveOperation*&gt;* get_store_order(VMRegPair temp_register) { Unimplemented(); return 0; }
1193 };
1194 
1195 
1196 static void rt_call(MacroAssembler* masm, address dest, int gpargs, int fpargs, int type) {
1197   CodeBlob *cb = CodeCache::find_blob(dest);
1198   if (cb) {
1199     __ far_call(RuntimeAddress(dest));
1200   } else {
1201     assert((unsigned)gpargs &lt; 256, &quot;eek!&quot;);
1202     assert((unsigned)fpargs &lt; 32, &quot;eek!&quot;);
1203     __ lea(rscratch1, RuntimeAddress(dest));
<a name="20" id="anc20"></a><span class="line-modified">1204     if (UseBuiltinSim)   __ mov(rscratch2, (gpargs &lt;&lt; 6) | (fpargs &lt;&lt; 2) | type);</span>
<span class="line-removed">1205     __ blrt(rscratch1, rscratch2);</span>
1206     __ maybe_isb();
1207   }
1208 }
1209 
1210 static void verify_oop_args(MacroAssembler* masm,
1211                             const methodHandle&amp; method,
1212                             const BasicType* sig_bt,
1213                             const VMRegPair* regs) {
1214   Register temp_reg = r19;  // not part of any compiled calling seq
1215   if (VerifyOops) {
1216     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
1217       if (sig_bt[i] == T_OBJECT ||
1218           sig_bt[i] == T_ARRAY) {
1219         VMReg r = regs[i].first();
1220         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
1221         if (r-&gt;is_stack()) {
1222           __ ldr(temp_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1223           __ verify_oop(temp_reg);
1224         } else {
1225           __ verify_oop(r-&gt;as_Register());
1226         }
1227       }
1228     }
1229   }
1230 }
1231 
1232 static void gen_special_dispatch(MacroAssembler* masm,
1233                                  const methodHandle&amp; method,
1234                                  const BasicType* sig_bt,
1235                                  const VMRegPair* regs) {
1236   verify_oop_args(masm, method, sig_bt, regs);
1237   vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1238 
1239   // Now write the args into the outgoing interpreter space
1240   bool     has_receiver   = false;
1241   Register receiver_reg   = noreg;
1242   int      member_arg_pos = -1;
1243   Register member_reg     = noreg;
1244   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
1245   if (ref_kind != 0) {
1246     member_arg_pos = method-&gt;size_of_parameters() - 1;  // trailing MemberName argument
1247     member_reg = r19;  // known to be free at this point
1248     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
1249   } else if (iid == vmIntrinsics::_invokeBasic) {
1250     has_receiver = true;
1251   } else {
1252     fatal(&quot;unexpected intrinsic id %d&quot;, iid);
1253   }
1254 
1255   if (member_reg != noreg) {
1256     // Load the member_arg into register, if necessary.
1257     SharedRuntime::check_member_name_argument_is_last_argument(method, sig_bt, regs);
1258     VMReg r = regs[member_arg_pos].first();
1259     if (r-&gt;is_stack()) {
1260       __ ldr(member_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1261     } else {
1262       // no data motion is needed
1263       member_reg = r-&gt;as_Register();
1264     }
1265   }
1266 
1267   if (has_receiver) {
1268     // Make sure the receiver is loaded into a register.
1269     assert(method-&gt;size_of_parameters() &gt; 0, &quot;oob&quot;);
1270     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
1271     VMReg r = regs[0].first();
1272     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
1273     if (r-&gt;is_stack()) {
1274       // Porting note:  This assumes that compiled calling conventions always
1275       // pass the receiver oop in a register.  If this is not true on some
1276       // platform, pick a temp and load the receiver from stack.
1277       fatal(&quot;receiver always in a register&quot;);
1278       receiver_reg = r2;  // known to be free at this point
1279       __ ldr(receiver_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1280     } else {
1281       // no data motion is needed
1282       receiver_reg = r-&gt;as_Register();
1283     }
1284   }
1285 
1286   // Figure out which address we are really jumping to:
1287   MethodHandles::generate_method_handle_dispatch(masm, iid,
1288                                                  receiver_reg, member_reg, /*for_compiler_entry:*/ true);
1289 }
1290 
1291 // ---------------------------------------------------------------------------
1292 // Generate a native wrapper for a given method.  The method takes arguments
1293 // in the Java compiled code convention, marshals them to the native
1294 // convention (handlizes oops, etc), transitions to native, makes the call,
1295 // returns to java state (possibly blocking), unhandlizes any result and
1296 // returns.
1297 //
1298 // Critical native functions are a shorthand for the use of
1299 // GetPrimtiveArrayCritical and disallow the use of any other JNI
1300 // functions.  The wrapper is expected to unpack the arguments before
1301 // passing them to the callee and perform checks before and after the
1302 // native call to ensure that they GCLocker
1303 // lock_critical/unlock_critical semantics are followed.  Some other
1304 // parts of JNI setup are skipped like the tear down of the JNI handle
1305 // block and the check for pending exceptions it&#39;s impossible for them
1306 // to be thrown.
1307 //
1308 // They are roughly structured like this:
1309 //    if (GCLocker::needs_gc())
1310 //      SharedRuntime::block_for_jni_critical();
1311 //    tranistion to thread_in_native
1312 //    unpack arrray arguments and call native entry point
1313 //    check for safepoint in progress
1314 //    check if any thread suspend flags are set
1315 //      call into JVM and possible unlock the JNI critical
1316 //      if a GC was suppressed while in the critical native.
1317 //    transition back to thread_in_Java
1318 //    return to caller
1319 //
1320 nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
1321                                                 const methodHandle&amp; method,
1322                                                 int compile_id,
1323                                                 BasicType* in_sig_bt,
1324                                                 VMRegPair* in_regs,
<a name="21" id="anc21"></a><span class="line-modified">1325                                                 BasicType ret_type) {</span>
<span class="line-modified">1326 #ifdef BUILTIN_SIM</span>
<span class="line-removed">1327   if (NotifySimulator) {</span>
<span class="line-removed">1328     // Names are up to 65536 chars long.  UTF8-coded strings are up to</span>
<span class="line-removed">1329     // 3 bytes per character.  We concatenate three such strings.</span>
<span class="line-removed">1330     // Yes, I know this is ridiculous, but it&#39;s debug code and glibc</span>
<span class="line-removed">1331     // allocates large arrays very efficiently.</span>
<span class="line-removed">1332     size_t len = (65536 * 3) * 3;</span>
<span class="line-removed">1333     char *name = new char[len];</span>
<span class="line-removed">1334 </span>
<span class="line-removed">1335     strncpy(name, method()-&gt;method_holder()-&gt;name()-&gt;as_utf8(), len);</span>
<span class="line-removed">1336     strncat(name, &quot;.&quot;, len);</span>
<span class="line-removed">1337     strncat(name, method()-&gt;name()-&gt;as_utf8(), len);</span>
<span class="line-removed">1338     strncat(name, method()-&gt;signature()-&gt;as_utf8(), len);</span>
<span class="line-removed">1339     AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck)-&gt;notifyCompile(name, __ pc());</span>
<span class="line-removed">1340     delete[] name;</span>
<span class="line-removed">1341   }</span>
<span class="line-removed">1342 #endif</span>
<span class="line-removed">1343 </span>
1344   if (method-&gt;is_method_handle_intrinsic()) {
1345     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1346     intptr_t start = (intptr_t)__ pc();
1347     int vep_offset = ((intptr_t)__ pc()) - start;
1348 
1349     // First instruction must be a nop as it may need to be patched on deoptimisation
1350     __ nop();
1351     gen_special_dispatch(masm,
1352                          method,
1353                          in_sig_bt,
1354                          in_regs);
1355     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
1356     __ flush();
1357     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
1358     return nmethod::new_native_nmethod(method,
1359                                        compile_id,
1360                                        masm-&gt;code(),
1361                                        vep_offset,
1362                                        frame_complete,
1363                                        stack_slots / VMRegImpl::slots_per_word,
1364                                        in_ByteSize(-1),
1365                                        in_ByteSize(-1),
1366                                        (OopMapSet*)NULL);
1367   }
1368   bool is_critical_native = true;
<a name="22" id="anc22"></a><span class="line-modified">1369   address native_func = method-&gt;critical_native_function();</span>
1370   if (native_func == NULL) {
1371     native_func = method-&gt;native_function();
1372     is_critical_native = false;
1373   }
1374   assert(native_func != NULL, &quot;must have function&quot;);
1375 
1376   // An OopMap for lock (and class if static)
1377   OopMapSet *oop_maps = new OopMapSet();
1378   intptr_t start = (intptr_t)__ pc();
1379 
1380   // We have received a description of where all the java arg are located
1381   // on entry to the wrapper. We need to convert these args to where
1382   // the jni function will expect them. To figure out where they go
1383   // we convert the java signature to a C signature by inserting
1384   // the hidden arguments as arg[0] and possibly arg[1] (static method)
1385 
1386   const int total_in_args = method-&gt;size_of_parameters();
1387   int total_c_args = total_in_args;
1388   if (!is_critical_native) {
1389     total_c_args += 1;
1390     if (method-&gt;is_static()) {
1391       total_c_args++;
1392     }
1393   } else {
1394     for (int i = 0; i &lt; total_in_args; i++) {
1395       if (in_sig_bt[i] == T_ARRAY) {
1396         total_c_args++;
1397       }
1398     }
1399   }
1400 
1401   BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1402   VMRegPair* out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1403   BasicType* in_elem_bt = NULL;
1404 
1405   int argc = 0;
1406   if (!is_critical_native) {
1407     out_sig_bt[argc++] = T_ADDRESS;
1408     if (method-&gt;is_static()) {
1409       out_sig_bt[argc++] = T_OBJECT;
1410     }
1411 
1412     for (int i = 0; i &lt; total_in_args ; i++ ) {
1413       out_sig_bt[argc++] = in_sig_bt[i];
1414     }
1415   } else {
<a name="23" id="anc23"></a><span class="line-removed">1416     Thread* THREAD = Thread::current();</span>
1417     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
1418     SignatureStream ss(method-&gt;signature());
1419     for (int i = 0; i &lt; total_in_args ; i++ ) {
1420       if (in_sig_bt[i] == T_ARRAY) {
1421         // Arrays are passed as int, elem* pair
1422         out_sig_bt[argc++] = T_INT;
1423         out_sig_bt[argc++] = T_ADDRESS;
<a name="24" id="anc24"></a><span class="line-modified">1424         Symbol* atype = ss.as_symbol(CHECK_NULL);</span>
<span class="line-modified">1425         const char* at = atype-&gt;as_C_string();</span>
<span class="line-modified">1426         if (strlen(at) == 2) {</span>
<span class="line-removed">1427           assert(at[0] == &#39;[&#39;, &quot;must be&quot;);</span>
<span class="line-removed">1428           switch (at[1]) {</span>
<span class="line-removed">1429             case &#39;B&#39;: in_elem_bt[i]  = T_BYTE; break;</span>
<span class="line-removed">1430             case &#39;C&#39;: in_elem_bt[i]  = T_CHAR; break;</span>
<span class="line-removed">1431             case &#39;D&#39;: in_elem_bt[i]  = T_DOUBLE; break;</span>
<span class="line-removed">1432             case &#39;F&#39;: in_elem_bt[i]  = T_FLOAT; break;</span>
<span class="line-removed">1433             case &#39;I&#39;: in_elem_bt[i]  = T_INT; break;</span>
<span class="line-removed">1434             case &#39;J&#39;: in_elem_bt[i]  = T_LONG; break;</span>
<span class="line-removed">1435             case &#39;S&#39;: in_elem_bt[i]  = T_SHORT; break;</span>
<span class="line-removed">1436             case &#39;Z&#39;: in_elem_bt[i]  = T_BOOLEAN; break;</span>
<span class="line-removed">1437             default: ShouldNotReachHere();</span>
<span class="line-removed">1438           }</span>
<span class="line-removed">1439         }</span>
1440       } else {
1441         out_sig_bt[argc++] = in_sig_bt[i];
1442         in_elem_bt[i] = T_VOID;
1443       }
1444       if (in_sig_bt[i] != T_VOID) {
<a name="25" id="anc25"></a><span class="line-modified">1445         assert(in_sig_bt[i] == ss.type(), &quot;must match&quot;);</span>

1446         ss.next();
1447       }
1448     }
1449   }
1450 
1451   // Now figure out where the args must be stored and how much stack space
1452   // they require.
1453   int out_arg_slots;
1454   out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
1455 
1456   // Compute framesize for the wrapper.  We need to handlize all oops in
1457   // incoming registers
1458 
1459   // Calculate the total number of stack slots we will need.
1460 
1461   // First count the abi requirement plus all of the outgoing args
1462   int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;
1463 
1464   // Now the space for the inbound oop handle area
1465   int total_save_slots = 8 * VMRegImpl::slots_per_word;  // 8 arguments passed in registers
1466   if (is_critical_native) {
1467     // Critical natives may have to call out so they need a save area
1468     // for register arguments.
1469     int double_slots = 0;
1470     int single_slots = 0;
1471     for ( int i = 0; i &lt; total_in_args; i++) {
1472       if (in_regs[i].first()-&gt;is_Register()) {
1473         const Register reg = in_regs[i].first()-&gt;as_Register();
1474         switch (in_sig_bt[i]) {
1475           case T_BOOLEAN:
1476           case T_BYTE:
1477           case T_SHORT:
1478           case T_CHAR:
1479           case T_INT:  single_slots++; break;
1480           case T_ARRAY:  // specific to LP64 (7145024)
1481           case T_LONG: double_slots++; break;
1482           default:  ShouldNotReachHere();
1483         }
1484       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1485         ShouldNotReachHere();
1486       }
1487     }
1488     total_save_slots = double_slots * 2 + single_slots;
1489     // align the save area
1490     if (double_slots != 0) {
1491       stack_slots = align_up(stack_slots, 2);
1492     }
1493   }
1494 
1495   int oop_handle_offset = stack_slots;
1496   stack_slots += total_save_slots;
1497 
1498   // Now any space we need for handlizing a klass if static method
1499 
1500   int klass_slot_offset = 0;
1501   int klass_offset = -1;
1502   int lock_slot_offset = 0;
1503   bool is_static = false;
1504 
1505   if (method-&gt;is_static()) {
1506     klass_slot_offset = stack_slots;
1507     stack_slots += VMRegImpl::slots_per_word;
1508     klass_offset = klass_slot_offset * VMRegImpl::stack_slot_size;
1509     is_static = true;
1510   }
1511 
1512   // Plus a lock if needed
1513 
1514   if (method-&gt;is_synchronized()) {
1515     lock_slot_offset = stack_slots;
1516     stack_slots += VMRegImpl::slots_per_word;
1517   }
1518 
1519   // Now a place (+2) to save return values or temp during shuffling
1520   // + 4 for return address (which we own) and saved rfp
1521   stack_slots += 6;
1522 
1523   // Ok The space we have allocated will look like:
1524   //
1525   //
1526   // FP-&gt; |                     |
1527   //      |---------------------|
1528   //      | 2 slots for moves   |
1529   //      |---------------------|
1530   //      | lock box (if sync)  |
1531   //      |---------------------| &lt;- lock_slot_offset
1532   //      | klass (if static)   |
1533   //      |---------------------| &lt;- klass_slot_offset
1534   //      | oopHandle area      |
1535   //      |---------------------| &lt;- oop_handle_offset (8 java arg registers)
1536   //      | outbound memory     |
1537   //      | based arguments     |
1538   //      |                     |
1539   //      |---------------------|
1540   //      |                     |
1541   // SP-&gt; | out_preserved_slots |
1542   //
1543   //
1544 
1545 
1546   // Now compute actual number of stack words we need rounding to make
1547   // stack properly aligned.
1548   stack_slots = align_up(stack_slots, StackAlignmentInSlots);
1549 
1550   int stack_size = stack_slots * VMRegImpl::stack_slot_size;
1551 
1552   // First thing make an ic check to see if we should even be here
1553 
1554   // We are free to use all registers as temps without saving them and
1555   // restoring them except rfp. rfp is the only callee save register
1556   // as far as the interpreter and the compiler(s) are concerned.
1557 
1558 
1559   const Register ic_reg = rscratch2;
1560   const Register receiver = j_rarg0;
1561 
1562   Label hit;
1563   Label exception_pending;
1564 
1565   assert_different_registers(ic_reg, receiver, rscratch1);
1566   __ verify_oop(receiver);
1567   __ cmp_klass(receiver, ic_reg, rscratch1);
1568   __ br(Assembler::EQ, hit);
1569 
1570   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1571 
1572   // Verified entry point must be aligned
1573   __ align(8);
1574 
1575   __ bind(hit);
1576 
1577   int vep_offset = ((intptr_t)__ pc()) - start;
1578 
1579   // If we have to make this method not-entrant we&#39;ll overwrite its
1580   // first instruction with a jump.  For this action to be legal we
1581   // must ensure that this first instruction is a B, BL, NOP, BKPT,
1582   // SVC, HVC, or SMC.  Make it a NOP.
1583   __ nop();
1584 
<a name="26" id="anc26"></a>








1585   // Generate stack overflow check
1586   if (UseStackBanging) {
1587     __ bang_stack_with_offset(JavaThread::stack_shadow_zone_size());
1588   } else {
1589     Unimplemented();
1590   }
1591 
1592   // Generate a new frame for the wrapper.
1593   __ enter();
1594   // -2 because return address is already present and so is saved rfp
1595   __ sub(sp, sp, stack_size - 2*wordSize);
1596 
1597   // Frame is now completed as far as size and linkage.
1598   int frame_complete = ((intptr_t)__ pc()) - start;
1599 
<a name="27" id="anc27"></a><span class="line-removed">1600   // record entry into native wrapper code</span>
<span class="line-removed">1601   if (NotifySimulator) {</span>
<span class="line-removed">1602     __ notify(Assembler::method_entry);</span>
<span class="line-removed">1603   }</span>
<span class="line-removed">1604 </span>
1605   // We use r20 as the oop handle for the receiver/klass
1606   // It is callee save so it survives the call to native
1607 
1608   const Register oop_handle_reg = r20;
1609 
1610   if (is_critical_native) {
1611     check_needs_gc_for_critical_native(masm, stack_slots, total_c_args, total_in_args,
1612                                        oop_handle_offset, oop_maps, in_regs, in_sig_bt);
1613   }
1614 
1615   //
1616   // We immediately shuffle the arguments so that any vm call we have to
1617   // make from here on out (sync slow path, jvmti, etc.) we will have
1618   // captured the oops from our caller and have a valid oopMap for
1619   // them.
1620 
1621   // -----------------
1622   // The Grand Shuffle
1623 
1624   // The Java calling convention is either equal (linux) or denser (win64) than the
1625   // c calling convention. However the because of the jni_env argument the c calling
1626   // convention always has at least one more (and two for static) arguments than Java.
1627   // Therefore if we move the args from java -&gt; c backwards then we will never have
1628   // a register-&gt;register conflict and we don&#39;t have to build a dependency graph
1629   // and figure out how to break any cycles.
1630   //
1631 
1632   // Record esp-based slot for receiver on stack for non-static methods
1633   int receiver_offset = -1;
1634 
1635   // This is a trick. We double the stack slots so we can claim
1636   // the oops in the caller&#39;s frame. Since we are sure to have
1637   // more args than the caller doubling is enough to make
1638   // sure we can capture all the incoming oop args from the
1639   // caller.
1640   //
1641   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1642 
1643   // Mark location of rfp (someday)
1644   // map-&gt;set_callee_saved(VMRegImpl::stack2reg( stack_slots - 2), stack_slots * 2, 0, vmreg(rfp));
1645 
1646 
1647   int float_args = 0;
1648   int int_args = 0;
1649 
1650 #ifdef ASSERT
1651   bool reg_destroyed[RegisterImpl::number_of_registers];
1652   bool freg_destroyed[FloatRegisterImpl::number_of_registers];
1653   for ( int r = 0 ; r &lt; RegisterImpl::number_of_registers ; r++ ) {
1654     reg_destroyed[r] = false;
1655   }
1656   for ( int f = 0 ; f &lt; FloatRegisterImpl::number_of_registers ; f++ ) {
1657     freg_destroyed[f] = false;
1658   }
1659 
1660 #endif /* ASSERT */
1661 
1662   // This may iterate in two different directions depending on the
1663   // kind of native it is.  The reason is that for regular JNI natives
1664   // the incoming and outgoing registers are offset upwards and for
1665   // critical natives they are offset down.
1666   GrowableArray&lt;int&gt; arg_order(2 * total_in_args);
1667   VMRegPair tmp_vmreg;
1668   tmp_vmreg.set2(r19-&gt;as_VMReg());
1669 
1670   if (!is_critical_native) {
1671     for (int i = total_in_args - 1, c_arg = total_c_args - 1; i &gt;= 0; i--, c_arg--) {
1672       arg_order.push(i);
1673       arg_order.push(c_arg);
1674     }
1675   } else {
1676     // Compute a valid move order, using tmp_vmreg to break any cycles
1677     ComputeMoveOrder cmo(total_in_args, in_regs, total_c_args, out_regs, in_sig_bt, arg_order, tmp_vmreg);
1678   }
1679 
1680   int temploc = -1;
1681   for (int ai = 0; ai &lt; arg_order.length(); ai += 2) {
1682     int i = arg_order.at(ai);
1683     int c_arg = arg_order.at(ai + 1);
1684     __ block_comment(err_msg(&quot;move %d -&gt; %d&quot;, i, c_arg));
1685     if (c_arg == -1) {
1686       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
1687       // This arg needs to be moved to a temporary
1688       __ mov(tmp_vmreg.first()-&gt;as_Register(), in_regs[i].first()-&gt;as_Register());
1689       in_regs[i] = tmp_vmreg;
1690       temploc = i;
1691       continue;
1692     } else if (i == -1) {
1693       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
1694       // Read from the temporary location
1695       assert(temploc != -1, &quot;must be valid&quot;);
1696       i = temploc;
1697       temploc = -1;
1698     }
1699 #ifdef ASSERT
1700     if (in_regs[i].first()-&gt;is_Register()) {
1701       assert(!reg_destroyed[in_regs[i].first()-&gt;as_Register()-&gt;encoding()], &quot;destroyed reg!&quot;);
1702     } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1703       assert(!freg_destroyed[in_regs[i].first()-&gt;as_FloatRegister()-&gt;encoding()], &quot;destroyed reg!&quot;);
1704     }
1705     if (out_regs[c_arg].first()-&gt;is_Register()) {
1706       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1707     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1708       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1709     }
1710 #endif /* ASSERT */
1711     switch (in_sig_bt[i]) {
1712       case T_ARRAY:
1713         if (is_critical_native) {
1714           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1715           c_arg++;
1716 #ifdef ASSERT
1717           if (out_regs[c_arg].first()-&gt;is_Register()) {
1718             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1719           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1720             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1721           }
1722 #endif
1723           int_args++;
1724           break;
1725         }
1726       case T_OBJECT:
1727         assert(!is_critical_native, &quot;no oop arguments&quot;);
1728         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1729                     ((i == 0) &amp;&amp; (!is_static)),
1730                     &amp;receiver_offset);
1731         int_args++;
1732         break;
1733       case T_VOID:
1734         break;
1735 
1736       case T_FLOAT:
1737         float_move(masm, in_regs[i], out_regs[c_arg]);
1738         float_args++;
1739         break;
1740 
1741       case T_DOUBLE:
1742         assert( i + 1 &lt; total_in_args &amp;&amp;
1743                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1744                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1745         double_move(masm, in_regs[i], out_regs[c_arg]);
1746         float_args++;
1747         break;
1748 
1749       case T_LONG :
1750         long_move(masm, in_regs[i], out_regs[c_arg]);
1751         int_args++;
1752         break;
1753 
1754       case T_ADDRESS: assert(false, &quot;found T_ADDRESS in java args&quot;);
1755 
1756       default:
1757         move32_64(masm, in_regs[i], out_regs[c_arg]);
1758         int_args++;
1759     }
1760   }
1761 
1762   // point c_arg at the first arg that is already loaded in case we
1763   // need to spill before we call out
1764   int c_arg = total_c_args - total_in_args;
1765 
1766   // Pre-load a static method&#39;s oop into c_rarg1.
1767   if (method-&gt;is_static() &amp;&amp; !is_critical_native) {
1768 
1769     //  load oop into a register
1770     __ movoop(c_rarg1,
1771               JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()),
1772               /*immediate*/true);
1773 
1774     // Now handlize the static class mirror it&#39;s known not-null.
1775     __ str(c_rarg1, Address(sp, klass_offset));
1776     map-&gt;set_oop(VMRegImpl::stack2reg(klass_slot_offset));
1777 
1778     // Now get the handle
1779     __ lea(c_rarg1, Address(sp, klass_offset));
1780     // and protect the arg if we must spill
1781     c_arg--;
1782   }
1783 
1784   // Change state to native (we save the return address in the thread, since it might not
1785   // be pushed on the stack when we do a stack traversal).
1786   // We use the same pc/oopMap repeatedly when we call out
1787 
1788   Label native_return;
1789   __ set_last_Java_frame(sp, noreg, native_return, rscratch1);
1790 
1791   Label dtrace_method_entry, dtrace_method_entry_done;
1792   {
1793     unsigned long offset;
1794     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
1795     __ ldrb(rscratch1, Address(rscratch1, offset));
1796     __ cbnzw(rscratch1, dtrace_method_entry);
1797     __ bind(dtrace_method_entry_done);
1798   }
1799 
1800   // RedefineClasses() tracing support for obsolete method entry
1801   if (log_is_enabled(Trace, redefine, class, obsolete)) {
1802     // protect the args we&#39;ve loaded
1803     save_args(masm, total_c_args, c_arg, out_regs);
1804     __ mov_metadata(c_rarg1, method());
1805     __ call_VM_leaf(
1806       CAST_FROM_FN_PTR(address, SharedRuntime::rc_trace_method_entry),
1807       rthread, c_rarg1);
1808     restore_args(masm, total_c_args, c_arg, out_regs);
1809   }
1810 
1811   // Lock a synchronized method
1812 
1813   // Register definitions used by locking and unlocking
1814 
1815   const Register swap_reg = r0;
1816   const Register obj_reg  = r19;  // Will contain the oop
1817   const Register lock_reg = r13;  // Address of compiler lock object (BasicLock)
1818   const Register old_hdr  = r13;  // value of old header at unlock time
1819   const Register tmp = lr;
1820 
1821   Label slow_path_lock;
1822   Label lock_done;
1823 
1824   if (method-&gt;is_synchronized()) {
1825     assert(!is_critical_native, &quot;unhandled&quot;);
1826 
1827     const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();
1828 
1829     // Get the handle (the 2nd argument)
1830     __ mov(oop_handle_reg, c_rarg1);
1831 
1832     // Get address of the box
1833 
1834     __ lea(lock_reg, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
1835 
1836     // Load the oop from the handle
1837     __ ldr(obj_reg, Address(oop_handle_reg, 0));
1838 
1839     __ resolve(IS_NOT_NULL, obj_reg);
1840 
1841     if (UseBiasedLocking) {
1842       __ biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, lock_done, &amp;slow_path_lock);
1843     }
1844 
1845     // Load (object-&gt;mark() | 1) into swap_reg %r0
1846     __ ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1847     __ orr(swap_reg, rscratch1, 1);
1848 
1849     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
1850     __ str(swap_reg, Address(lock_reg, mark_word_offset));
1851 
1852     // src -&gt; dest iff dest == r0 else r0 &lt;- dest
1853     { Label here;
1854       __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, lock_done, /*fallthrough*/NULL);
1855     }
1856 
1857     // Hmm should this move to the slow path code area???
1858 
1859     // Test if the oopMark is an obvious stack pointer, i.e.,
1860     //  1) (mark &amp; 3) == 0, and
1861     //  2) sp &lt;= mark &lt; mark + os::pagesize()
1862     // These 3 tests can be done by evaluating the following
1863     // expression: ((mark - sp) &amp; (3 - os::vm_page_size())),
1864     // assuming both stack pointer and pagesize have their
1865     // least significant 2 bits clear.
1866     // NOTE: the oopMark is in swap_reg %r0 as the result of cmpxchg
1867 
1868     __ sub(swap_reg, sp, swap_reg);
1869     __ neg(swap_reg, swap_reg);
1870     __ ands(swap_reg, swap_reg, 3 - os::vm_page_size());
1871 
1872     // Save the test result, for recursive case, the result is zero
1873     __ str(swap_reg, Address(lock_reg, mark_word_offset));
1874     __ br(Assembler::NE, slow_path_lock);
1875 
1876     // Slow path will re-enter here
1877 
1878     __ bind(lock_done);
1879   }
1880 
1881 
1882   // Finally just about ready to make the JNI call
1883 
1884   // get JNIEnv* which is first argument to native
1885   if (!is_critical_native) {
1886     __ lea(c_rarg0, Address(rthread, in_bytes(JavaThread::jni_environment_offset())));
1887   }
1888 
1889   // Now set thread in native
1890   __ mov(rscratch1, _thread_in_native);
1891   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1892   __ stlrw(rscratch1, rscratch2);
1893 
1894   {
1895     int return_type = 0;
1896     switch (ret_type) {
1897     case T_VOID: break;
1898       return_type = 0; break;
1899     case T_CHAR:
1900     case T_BYTE:
1901     case T_SHORT:
1902     case T_INT:
1903     case T_BOOLEAN:
1904     case T_LONG:
1905       return_type = 1; break;
1906     case T_ARRAY:
1907     case T_OBJECT:
1908       return_type = 1; break;
1909     case T_FLOAT:
1910       return_type = 2; break;
1911     case T_DOUBLE:
1912       return_type = 3; break;
1913     default:
1914       ShouldNotReachHere();
1915     }
1916     rt_call(masm, native_func,
1917             int_args + 2, // AArch64 passes up to 8 args in int registers
1918             float_args,   // and up to 8 float args
1919             return_type);
1920   }
1921 
1922   __ bind(native_return);
1923 
1924   intptr_t return_pc = (intptr_t) __ pc();
1925   oop_maps-&gt;add_gc_map(return_pc - start, map);
1926 
1927   // Unpack native results.
1928   switch (ret_type) {
1929   case T_BOOLEAN: __ c2bool(r0);                     break;
1930   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
1931   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
1932   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
1933   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
1934   case T_DOUBLE :
1935   case T_FLOAT  :
1936     // Result is in v0 we&#39;ll save as needed
1937     break;
1938   case T_ARRAY:                 // Really a handle
1939   case T_OBJECT:                // Really a handle
1940       break; // can&#39;t de-handlize until after safepoint check
1941   case T_VOID: break;
1942   case T_LONG: break;
1943   default       : ShouldNotReachHere();
1944   }
1945 
1946   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
1947   // This additional state is necessary because reading and testing the synchronization
1948   // state is not atomic w.r.t. GC, as this scenario demonstrates:
1949   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
1950   //     VM thread changes sync state to synchronizing and suspends threads for GC.
1951   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
1952   //     didn&#39;t see any synchronization is progress, and escapes.
1953   __ mov(rscratch1, _thread_in_native_trans);
1954 
1955   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
1956 
1957   // Force this write out before the read below
1958   __ dmb(Assembler::ISH);
1959 
1960   // check for safepoint operation in progress and/or pending suspend requests
1961   Label safepoint_in_progress, safepoint_in_progress_done;
1962   {
1963     __ safepoint_poll_acquire(safepoint_in_progress);
1964     __ ldrw(rscratch1, Address(rthread, JavaThread::suspend_flags_offset()));
1965     __ cbnzw(rscratch1, safepoint_in_progress);
1966     __ bind(safepoint_in_progress_done);
1967   }
1968 
1969   // change thread state
1970   Label after_transition;
1971   __ mov(rscratch1, _thread_in_Java);
1972   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1973   __ stlrw(rscratch1, rscratch2);
1974   __ bind(after_transition);
1975 
1976   Label reguard;
1977   Label reguard_done;
1978   __ ldrb(rscratch1, Address(rthread, JavaThread::stack_guard_state_offset()));
1979   __ cmpw(rscratch1, JavaThread::stack_guard_yellow_reserved_disabled);
1980   __ br(Assembler::EQ, reguard);
1981   __ bind(reguard_done);
1982 
1983   // native result if any is live
1984 
1985   // Unlock
1986   Label unlock_done;
1987   Label slow_path_unlock;
1988   if (method-&gt;is_synchronized()) {
1989 
1990     // Get locked oop from the handle we passed to jni
1991     __ ldr(obj_reg, Address(oop_handle_reg, 0));
1992 
1993     __ resolve(IS_NOT_NULL, obj_reg);
1994 
1995     Label done;
1996 
1997     if (UseBiasedLocking) {
1998       __ biased_locking_exit(obj_reg, old_hdr, done);
1999     }
2000 
2001     // Simple recursive lock?
2002 
2003     __ ldr(rscratch1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2004     __ cbz(rscratch1, done);
2005 
2006     // Must save r0 if if it is live now because cmpxchg must use it
2007     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2008       save_native_result(masm, ret_type, stack_slots);
2009     }
2010 
2011 
2012     // get address of the stack lock
2013     __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2014     //  get old displaced header
2015     __ ldr(old_hdr, Address(r0, 0));
2016 
2017     // Atomic swap old header if oop still contains the stack lock
2018     Label succeed;
2019     __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, succeed, &amp;slow_path_unlock);
2020     __ bind(succeed);
2021 
2022     // slow path re-enters here
2023     __ bind(unlock_done);
2024     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2025       restore_native_result(masm, ret_type, stack_slots);
2026     }
2027 
2028     __ bind(done);
2029   }
2030 
2031   Label dtrace_method_exit, dtrace_method_exit_done;
2032   {
2033     unsigned long offset;
2034     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
2035     __ ldrb(rscratch1, Address(rscratch1, offset));
2036     __ cbnzw(rscratch1, dtrace_method_exit);
2037     __ bind(dtrace_method_exit_done);
2038   }
2039 
2040   __ reset_last_Java_frame(false);
2041 
2042   // Unbox oop result, e.g. JNIHandles::resolve result.
<a name="28" id="anc28"></a><span class="line-modified">2043   if (ret_type == T_OBJECT || ret_type == T_ARRAY) {</span>
2044     __ resolve_jobject(r0, rthread, rscratch2);
2045   }
2046 
2047   if (CheckJNICalls) {
2048     // clear_pending_jni_exception_check
2049     __ str(zr, Address(rthread, JavaThread::pending_jni_exception_check_fn_offset()));
2050   }
2051 
2052   if (!is_critical_native) {
2053     // reset handle block
2054     __ ldr(r2, Address(rthread, JavaThread::active_handles_offset()));
2055     __ str(zr, Address(r2, JNIHandleBlock::top_offset_in_bytes()));
2056   }
2057 
2058   __ leave();
2059 
2060   if (!is_critical_native) {
2061     // Any exception pending?
2062     __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2063     __ cbnz(rscratch1, exception_pending);
2064   }
2065 
<a name="29" id="anc29"></a><span class="line-removed">2066   // record exit from native wrapper code</span>
<span class="line-removed">2067   if (NotifySimulator) {</span>
<span class="line-removed">2068     __ notify(Assembler::method_reentry);</span>
<span class="line-removed">2069   }</span>
<span class="line-removed">2070 </span>
2071   // We&#39;re done
2072   __ ret(lr);
2073 
2074   // Unexpected paths are out of line and go here
2075 
2076   if (!is_critical_native) {
2077     // forward the exception
2078     __ bind(exception_pending);
2079 
2080     // and forward the exception
2081     __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2082   }
2083 
2084   // Slow path locking &amp; unlocking
2085   if (method-&gt;is_synchronized()) {
2086 
2087     __ block_comment(&quot;Slow path lock {&quot;);
2088     __ bind(slow_path_lock);
2089 
2090     // has last_Java_frame setup. No exceptions so do vanilla call not call_VM
2091     // args are (oop obj, BasicLock* lock, JavaThread* thread)
2092 
2093     // protect the args we&#39;ve loaded
2094     save_args(masm, total_c_args, c_arg, out_regs);
2095 
2096     __ mov(c_rarg0, obj_reg);
2097     __ mov(c_rarg1, lock_reg);
2098     __ mov(c_rarg2, rthread);
2099 
2100     // Not a leaf but we have last_Java_frame setup as we want
2101     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C), 3);
2102     restore_args(masm, total_c_args, c_arg, out_regs);
2103 
2104 #ifdef ASSERT
2105     { Label L;
2106       __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2107       __ cbz(rscratch1, L);
2108       __ stop(&quot;no pending exception allowed on exit from monitorenter&quot;);
2109       __ bind(L);
2110     }
2111 #endif
2112     __ b(lock_done);
2113 
2114     __ block_comment(&quot;} Slow path lock&quot;);
2115 
2116     __ block_comment(&quot;Slow path unlock {&quot;);
2117     __ bind(slow_path_unlock);
2118 
2119     // If we haven&#39;t already saved the native result we must save it now as xmm registers
2120     // are still exposed.
2121 
2122     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2123       save_native_result(masm, ret_type, stack_slots);
2124     }
2125 
2126     __ mov(c_rarg2, rthread);
2127     __ lea(c_rarg1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2128     __ mov(c_rarg0, obj_reg);
2129 
2130     // Save pending exception around call to VM (which contains an EXCEPTION_MARK)
2131     // NOTE that obj_reg == r19 currently
2132     __ ldr(r19, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2133     __ str(zr, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2134 
2135     rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C), 3, 0, 1);
2136 
2137 #ifdef ASSERT
2138     {
2139       Label L;
2140       __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2141       __ cbz(rscratch1, L);
2142       __ stop(&quot;no pending exception allowed on exit complete_monitor_unlocking_C&quot;);
2143       __ bind(L);
2144     }
2145 #endif /* ASSERT */
2146 
2147     __ str(r19, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2148 
2149     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2150       restore_native_result(masm, ret_type, stack_slots);
2151     }
2152     __ b(unlock_done);
2153 
2154     __ block_comment(&quot;} Slow path unlock&quot;);
2155 
2156   } // synchronized
2157 
2158   // SLOW PATH Reguard the stack if needed
2159 
2160   __ bind(reguard);
2161   save_native_result(masm, ret_type, stack_slots);
2162   rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), 0, 0, 0);
2163   restore_native_result(masm, ret_type, stack_slots);
2164   // and continue
2165   __ b(reguard_done);
2166 
2167   // SLOW PATH safepoint
2168   {
2169     __ block_comment(&quot;safepoint {&quot;);
2170     __ bind(safepoint_in_progress);
2171 
2172     // Don&#39;t use call_VM as it will see a possible pending exception and forward it
2173     // and never return here preventing us from clearing _last_native_pc down below.
2174     //
2175     save_native_result(masm, ret_type, stack_slots);
2176     __ mov(c_rarg0, rthread);
2177 #ifndef PRODUCT
2178   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2179 #endif
2180     if (!is_critical_native) {
2181       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
2182     } else {
2183       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)));
2184     }
<a name="30" id="anc30"></a><span class="line-modified">2185     __ blrt(rscratch1, 1, 0, 1);</span>
2186     __ maybe_isb();
2187     // Restore any method result value
2188     restore_native_result(masm, ret_type, stack_slots);
2189 
2190     if (is_critical_native) {
2191       // The call above performed the transition to thread_in_Java so
2192       // skip the transition logic above.
2193       __ b(after_transition);
2194     }
2195 
2196     __ b(safepoint_in_progress_done);
2197     __ block_comment(&quot;} safepoint&quot;);
2198   }
2199 
2200   // SLOW PATH dtrace support
2201   {
2202     __ block_comment(&quot;dtrace entry {&quot;);
2203     __ bind(dtrace_method_entry);
2204 
2205     // We have all of the arguments setup at this point. We must not touch any register
2206     // argument registers at this point (what if we save/restore them there are no oop?
2207 
2208     save_args(masm, total_c_args, c_arg, out_regs);
2209     __ mov_metadata(c_rarg1, method());
2210     __ call_VM_leaf(
2211       CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),
2212       rthread, c_rarg1);
2213     restore_args(masm, total_c_args, c_arg, out_regs);
2214     __ b(dtrace_method_entry_done);
2215     __ block_comment(&quot;} dtrace entry&quot;);
2216   }
2217 
2218   {
2219     __ block_comment(&quot;dtrace exit {&quot;);
2220     __ bind(dtrace_method_exit);
2221     save_native_result(masm, ret_type, stack_slots);
2222     __ mov_metadata(c_rarg1, method());
2223     __ call_VM_leaf(
2224          CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),
2225          rthread, c_rarg1);
2226     restore_native_result(masm, ret_type, stack_slots);
2227     __ b(dtrace_method_exit_done);
2228     __ block_comment(&quot;} dtrace exit&quot;);
2229   }
2230 
2231 
2232   __ flush();
2233 
2234   nmethod *nm = nmethod::new_native_nmethod(method,
2235                                             compile_id,
2236                                             masm-&gt;code(),
2237                                             vep_offset,
2238                                             frame_complete,
2239                                             stack_slots / VMRegImpl::slots_per_word,
2240                                             (is_static ? in_ByteSize(klass_offset) : in_ByteSize(receiver_offset)),
2241                                             in_ByteSize(lock_slot_offset*VMRegImpl::stack_slot_size),
2242                                             oop_maps);
2243 
2244   if (is_critical_native) {
2245     nm-&gt;set_lazy_critical_native(true);
2246   }
2247 
2248   return nm;
2249 
2250 }
2251 
2252 // this function returns the adjust size (in number of words) to a c2i adapter
2253 // activation for use during deoptimization
2254 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals) {
2255   assert(callee_locals &gt;= callee_parameters,
2256           &quot;test and remove; got more parms than locals&quot;);
2257   if (callee_locals &lt; callee_parameters)
2258     return 0;                   // No adjustment for negative locals
2259   int diff = (callee_locals - callee_parameters) * Interpreter::stackElementWords;
2260   // diff is counted in stack words
2261   return align_up(diff, 2);
2262 }
2263 
2264 
2265 //------------------------------generate_deopt_blob----------------------------
2266 void SharedRuntime::generate_deopt_blob() {
2267   // Allocate space for the code
2268   ResourceMark rm;
2269   // Setup code generation tools
2270   int pad = 0;
2271 #if INCLUDE_JVMCI
2272   if (EnableJVMCI || UseAOT) {
2273     pad += 512; // Increase the buffer size when compiling for JVMCI
2274   }
2275 #endif
2276   CodeBuffer buffer(&quot;deopt_blob&quot;, 2048+pad, 1024);
2277   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2278   int frame_size_in_words;
2279   OopMap* map = NULL;
2280   OopMapSet *oop_maps = new OopMapSet();
2281 
<a name="31" id="anc31"></a><span class="line-removed">2282 #ifdef BUILTIN_SIM</span>
<span class="line-removed">2283   AArch64Simulator *simulator;</span>
<span class="line-removed">2284   if (NotifySimulator) {</span>
<span class="line-removed">2285     simulator = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed">2286     simulator-&gt;notifyCompile(const_cast&lt;char*&gt;(&quot;SharedRuntime::deopt_blob&quot;), __ pc());</span>
<span class="line-removed">2287   }</span>
<span class="line-removed">2288 #endif</span>
<span class="line-removed">2289 </span>
2290   // -------------
2291   // This code enters when returning to a de-optimized nmethod.  A return
2292   // address has been pushed on the the stack, and return values are in
2293   // registers.
2294   // If we are doing a normal deopt then we were called from the patched
2295   // nmethod from the point we returned to the nmethod. So the return
2296   // address on the stack is wrong by NativeCall::instruction_size
2297   // We will adjust the value so it looks like we have the original return
2298   // address on the stack (like when we eagerly deoptimized).
2299   // In the case of an exception pending when deoptimizing, we enter
2300   // with a return address on the stack that points after the call we patched
2301   // into the exception handler. We have the following register state from,
2302   // e.g., the forward exception stub (see stubGenerator_x86_64.cpp).
2303   //    r0: exception oop
2304   //    r19: exception handler
2305   //    r3: throwing pc
2306   // So in this case we simply jam r3 into the useless return address and
2307   // the stack looks just like we want.
2308   //
2309   // At this point we need to de-opt.  We save the argument return
2310   // registers.  We call the first C routine, fetch_unroll_info().  This
2311   // routine captures the return values and returns a structure which
2312   // describes the current frame size and the sizes of all replacement frames.
2313   // The current frame is compiled code and may contain many inlined
2314   // functions, each with their own JVM state.  We pop the current frame, then
2315   // push all the new frames.  Then we call the C routine unpack_frames() to
2316   // populate these frames.  Finally unpack_frames() returns us the new target
2317   // address.  Notice that callee-save registers are BLOWN here; they have
2318   // already been captured in the vframeArray at the time the return PC was
2319   // patched.
2320   address start = __ pc();
2321   Label cont;
2322 
2323   // Prolog for non exception case!
2324 
2325   // Save everything in sight.
2326   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2327 
2328   // Normal deoptimization.  Save exec mode for unpack_frames.
2329   __ movw(rcpool, Deoptimization::Unpack_deopt); // callee-saved
2330   __ b(cont);
2331 
2332   int reexecute_offset = __ pc() - start;
2333 #if INCLUDE_JVMCI &amp;&amp; !defined(COMPILER1)
2334   if (EnableJVMCI &amp;&amp; UseJVMCICompiler) {
2335     // JVMCI does not use this kind of deoptimization
2336     __ should_not_reach_here();
2337   }
2338 #endif
2339 
2340   // Reexecute case
2341   // return address is the pc describes what bci to do re-execute at
2342 
2343   // No need to update map as each call to save_live_registers will produce identical oopmap
2344   (void) RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2345 
2346   __ movw(rcpool, Deoptimization::Unpack_reexecute); // callee-saved
2347   __ b(cont);
2348 
2349 #if INCLUDE_JVMCI
2350   Label after_fetch_unroll_info_call;
2351   int implicit_exception_uncommon_trap_offset = 0;
2352   int uncommon_trap_offset = 0;
2353 
2354   if (EnableJVMCI || UseAOT) {
2355     implicit_exception_uncommon_trap_offset = __ pc() - start;
2356 
2357     __ ldr(lr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2358     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2359 
2360     uncommon_trap_offset = __ pc() - start;
2361 
2362     // Save everything in sight.
2363     RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2364     // fetch_unroll_info needs to call last_java_frame()
2365     Label retaddr;
2366     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2367 
2368     __ ldrw(c_rarg1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2369     __ movw(rscratch1, -1);
2370     __ strw(rscratch1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2371 
2372     __ movw(rcpool, (int32_t)Deoptimization::Unpack_reexecute);
2373     __ mov(c_rarg0, rthread);
2374     __ movw(c_rarg2, rcpool); // exec mode
2375     __ lea(rscratch1,
2376            RuntimeAddress(CAST_FROM_FN_PTR(address,
2377                                            Deoptimization::uncommon_trap)));
<a name="32" id="anc32"></a><span class="line-modified">2378     __ blrt(rscratch1, 2, 0, MacroAssembler::ret_type_integral);</span>
2379     __ bind(retaddr);
2380     oop_maps-&gt;add_gc_map( __ pc()-start, map-&gt;deep_copy());
2381 
2382     __ reset_last_Java_frame(false);
2383 
2384     __ b(after_fetch_unroll_info_call);
2385   } // EnableJVMCI
2386 #endif // INCLUDE_JVMCI
2387 
2388   int exception_offset = __ pc() - start;
2389 
2390   // Prolog for exception case
2391 
2392   // all registers are dead at this entry point, except for r0, and
2393   // r3 which contain the exception oop and exception pc
2394   // respectively.  Set them in TLS and fall thru to the
2395   // unpack_with_exception_in_tls entry point.
2396 
2397   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
2398   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
2399 
2400   int exception_in_tls_offset = __ pc() - start;
2401 
2402   // new implementation because exception oop is now passed in JavaThread
2403 
2404   // Prolog for exception case
2405   // All registers must be preserved because they might be used by LinearScan
2406   // Exceptiop oop and throwing PC are passed in JavaThread
2407   // tos: stack at point of call to method that threw the exception (i.e. only
2408   // args are on the stack, no return address)
2409 
2410   // The return address pushed by save_live_registers will be patched
2411   // later with the throwing pc. The correct value is not available
2412   // now because loading it from memory would destroy registers.
2413 
2414   // NB: The SP at this point must be the SP of the method that is
2415   // being deoptimized.  Deoptimization assumes that the frame created
2416   // here by save_live_registers is immediately below the method&#39;s SP.
2417   // This is a somewhat fragile mechanism.
2418 
2419   // Save everything in sight.
2420   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2421 
2422   // Now it is safe to overwrite any register
2423 
2424   // Deopt during an exception.  Save exec mode for unpack_frames.
2425   __ mov(rcpool, Deoptimization::Unpack_exception); // callee-saved
2426 
2427   // load throwing pc from JavaThread and patch it as the return address
2428   // of the current frame. Then clear the field in JavaThread
2429 
2430   __ ldr(r3, Address(rthread, JavaThread::exception_pc_offset()));
2431   __ str(r3, Address(rfp, wordSize));
2432   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
2433 
2434 #ifdef ASSERT
2435   // verify that there is really an exception oop in JavaThread
2436   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
2437   __ verify_oop(r0);
2438 
2439   // verify that there is no pending exception
2440   Label no_pending_exception;
2441   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2442   __ cbz(rscratch1, no_pending_exception);
2443   __ stop(&quot;must not have pending exception here&quot;);
2444   __ bind(no_pending_exception);
2445 #endif
2446 
2447   __ bind(cont);
2448 
2449   // Call C code.  Need thread and this frame, but NOT official VM entry
2450   // crud.  We cannot block on this call, no GC can happen.
2451   //
2452   // UnrollBlock* fetch_unroll_info(JavaThread* thread)
2453 
2454   // fetch_unroll_info needs to call last_java_frame().
2455 
2456   Label retaddr;
2457   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2458 #ifdef ASSERT0
2459   { Label L;
2460     __ ldr(rscratch1, Address(rthread,
2461                               JavaThread::last_Java_fp_offset()));
2462     __ cbz(rscratch1, L);
2463     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
2464     __ bind(L);
2465   }
2466 #endif // ASSERT
2467   __ mov(c_rarg0, rthread);
2468   __ mov(c_rarg1, rcpool);
2469   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)));
<a name="33" id="anc33"></a><span class="line-modified">2470   __ blrt(rscratch1, 1, 0, 1);</span>
2471   __ bind(retaddr);
2472 
2473   // Need to have an oopmap that tells fetch_unroll_info where to
2474   // find any register it might need.
2475   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2476 
2477   __ reset_last_Java_frame(false);
2478 
2479 #if INCLUDE_JVMCI
2480   if (EnableJVMCI || UseAOT) {
2481     __ bind(after_fetch_unroll_info_call);
2482   }
2483 #endif
2484 
2485   // Load UnrollBlock* into r5
2486   __ mov(r5, r0);
2487 
2488   __ ldrw(rcpool, Address(r5, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2489    Label noException;
2490   __ cmpw(rcpool, Deoptimization::Unpack_exception);   // Was exception pending?
2491   __ br(Assembler::NE, noException);
2492   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
2493   // QQQ this is useless it was NULL above
2494   __ ldr(r3, Address(rthread, JavaThread::exception_pc_offset()));
2495   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
2496   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
2497 
2498   __ verify_oop(r0);
2499 
2500   // Overwrite the result registers with the exception results.
2501   __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2502   // I think this is useless
2503   // __ str(r3, Address(sp, RegisterSaver::r3_offset_in_bytes()));
2504 
2505   __ bind(noException);
2506 
2507   // Only register save data is on the stack.
2508   // Now restore the result registers.  Everything else is either dead
2509   // or captured in the vframeArray.
2510   RegisterSaver::restore_result_registers(masm);
2511 
2512   // All of the register save area has been popped of the stack. Only the
2513   // return address remains.
2514 
2515   // Pop all the frames we must move/replace.
2516   //
2517   // Frame picture (youngest to oldest)
2518   // 1: self-frame (no frame link)
2519   // 2: deopting frame  (no frame link)
2520   // 3: caller of deopting frame (could be compiled/interpreted).
2521   //
2522   // Note: by leaving the return address of self-frame on the stack
2523   // and using the size of frame 2 to adjust the stack
2524   // when we are done the return to frame 3 will still be on the stack.
2525 
2526   // Pop deoptimized frame
2527   __ ldrw(r2, Address(r5, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
2528   __ sub(r2, r2, 2 * wordSize);
2529   __ add(sp, sp, r2);
2530   __ ldp(rfp, lr, __ post(sp, 2 * wordSize));
2531   // LR should now be the return address to the caller (3)
2532 
2533 #ifdef ASSERT
2534   // Compilers generate code that bang the stack by as much as the
2535   // interpreter would need. So this stack banging should never
2536   // trigger a fault. Verify that it does not on non product builds.
2537   if (UseStackBanging) {
2538     __ ldrw(r19, Address(r5, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
2539     __ bang_stack_size(r19, r2);
2540   }
2541 #endif
2542   // Load address of array of frame pcs into r2
2543   __ ldr(r2, Address(r5, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2544 
2545   // Trash the old pc
2546   // __ addptr(sp, wordSize);  FIXME ????
2547 
2548   // Load address of array of frame sizes into r4
2549   __ ldr(r4, Address(r5, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
2550 
2551   // Load counter into r3
2552   __ ldrw(r3, Address(r5, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
2553 
2554   // Now adjust the caller&#39;s stack to make up for the extra locals
2555   // but record the original sp so that we can save it in the skeletal interpreter
2556   // frame and the stack walking of interpreter_sender will get the unextended sp
2557   // value and not the &quot;real&quot; sp value.
2558 
2559   const Register sender_sp = r6;
2560 
2561   __ mov(sender_sp, sp);
2562   __ ldrw(r19, Address(r5,
2563                        Deoptimization::UnrollBlock::
2564                        caller_adjustment_offset_in_bytes()));
2565   __ sub(sp, sp, r19);
2566 
2567   // Push interpreter frames in a loop
2568   __ mov(rscratch1, (address)0xDEADDEAD);        // Make a recognizable pattern
2569   __ mov(rscratch2, rscratch1);
2570   Label loop;
2571   __ bind(loop);
2572   __ ldr(r19, Address(__ post(r4, wordSize)));          // Load frame size
2573   __ sub(r19, r19, 2*wordSize);           // We&#39;ll push pc and fp by hand
2574   __ ldr(lr, Address(__ post(r2, wordSize)));  // Load pc
2575   __ enter();                           // Save old &amp; set new fp
2576   __ sub(sp, sp, r19);                  // Prolog
2577   // This value is corrected by layout_activation_impl
2578   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
2579   __ str(sender_sp, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize)); // Make it walkable
2580   __ mov(sender_sp, sp);               // Pass sender_sp to next frame
2581   __ sub(r3, r3, 1);                   // Decrement counter
2582   __ cbnz(r3, loop);
2583 
2584     // Re-push self-frame
2585   __ ldr(lr, Address(r2));
2586   __ enter();
2587 
2588   // Allocate a full sized register save area.  We subtract 2 because
2589   // enter() just pushed 2 words
2590   __ sub(sp, sp, (frame_size_in_words - 2) * wordSize);
2591 
2592   // Restore frame locals after moving the frame
2593   __ strd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2594   __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2595 
2596   // Call C code.  Need thread but NOT official VM entry
2597   // crud.  We cannot block on this call, no GC can happen.  Call should
2598   // restore return values to their stack-slots with the new SP.
2599   //
2600   // void Deoptimization::unpack_frames(JavaThread* thread, int exec_mode)
2601 
2602   // Use rfp because the frames look interpreted now
2603   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2604   address the_pc = __ pc();
2605   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2606 
2607   __ mov(c_rarg0, rthread);
2608   __ movw(c_rarg1, rcpool); // second arg: exec_mode
2609   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
<a name="34" id="anc34"></a><span class="line-modified">2610   __ blrt(rscratch1, 2, 0, 0);</span>
2611 
2612   // Set an oopmap for the call site
2613   // Use the same PC we used for the last java frame
2614   oop_maps-&gt;add_gc_map(the_pc - start,
2615                        new OopMap( frame_size_in_words, 0 ));
2616 
2617   // Clear fp AND pc
2618   __ reset_last_Java_frame(true);
2619 
2620   // Collect return values
2621   __ ldrd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2622   __ ldr(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2623   // I think this is useless (throwing pc?)
2624   // __ ldr(r3, Address(sp, RegisterSaver::r3_offset_in_bytes()));
2625 
2626   // Pop self-frame.
2627   __ leave();                           // Epilog
2628 
2629   // Jump to interpreter
2630   __ ret(lr);
2631 
2632   // Make sure all code is generated
2633   masm-&gt;flush();
2634 
2635   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);
2636   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
2637 #if INCLUDE_JVMCI
2638   if (EnableJVMCI || UseAOT) {
2639     _deopt_blob-&gt;set_uncommon_trap_offset(uncommon_trap_offset);
2640     _deopt_blob-&gt;set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);
2641   }
2642 #endif
<a name="35" id="anc35"></a><span class="line-removed">2643 #ifdef BUILTIN_SIM</span>
<span class="line-removed">2644   if (NotifySimulator) {</span>
<span class="line-removed">2645     unsigned char *base = _deopt_blob-&gt;code_begin();</span>
<span class="line-removed">2646     simulator-&gt;notifyRelocate(start, base - start);</span>
<span class="line-removed">2647   }</span>
<span class="line-removed">2648 #endif</span>
2649 }
2650 
2651 uint SharedRuntime::out_preserve_stack_slots() {
2652   return 0;
2653 }
2654 
2655 #if COMPILER2_OR_JVMCI
2656 //------------------------------generate_uncommon_trap_blob--------------------
2657 void SharedRuntime::generate_uncommon_trap_blob() {
2658   // Allocate space for the code
2659   ResourceMark rm;
2660   // Setup code generation tools
2661   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
2662   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2663 
<a name="36" id="anc36"></a><span class="line-removed">2664 #ifdef BUILTIN_SIM</span>
<span class="line-removed">2665   AArch64Simulator *simulator;</span>
<span class="line-removed">2666   if (NotifySimulator) {</span>
<span class="line-removed">2667     simulator = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed">2668     simulator-&gt;notifyCompile(const_cast&lt;char*&gt;(&quot;SharedRuntime:uncommon_trap_blob&quot;), __ pc());</span>
<span class="line-removed">2669   }</span>
<span class="line-removed">2670 #endif</span>
<span class="line-removed">2671 </span>
2672   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
2673 
2674   address start = __ pc();
2675 
2676   // Push self-frame.  We get here with a return address in LR
2677   // and sp should be 16 byte aligned
2678   // push rfp and retaddr by hand
2679   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
2680   // we don&#39;t expect an arg reg save area
2681 #ifndef PRODUCT
2682   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2683 #endif
2684   // compiler left unloaded_class_index in j_rarg0 move to where the
2685   // runtime expects it.
2686   if (c_rarg1 != j_rarg0) {
2687     __ movw(c_rarg1, j_rarg0);
2688   }
2689 
2690   // we need to set the past SP to the stack pointer of the stub frame
2691   // and the pc to the address where this runtime call will return
2692   // although actually any pc in this code blob will do).
2693   Label retaddr;
2694   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2695 
2696   // Call C code.  Need thread but NOT official VM entry
2697   // crud.  We cannot block on this call, no GC can happen.  Call should
2698   // capture callee-saved registers as well as return values.
2699   // Thread is in rdi already.
2700   //
2701   // UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);
2702   //
2703   // n.b. 2 gp args, 0 fp args, integral return type
2704 
2705   __ mov(c_rarg0, rthread);
2706   __ movw(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);
2707   __ lea(rscratch1,
2708          RuntimeAddress(CAST_FROM_FN_PTR(address,
2709                                          Deoptimization::uncommon_trap)));
<a name="37" id="anc37"></a><span class="line-modified">2710   __ blrt(rscratch1, 2, 0, MacroAssembler::ret_type_integral);</span>
2711   __ bind(retaddr);
2712 
2713   // Set an oopmap for the call site
2714   OopMapSet* oop_maps = new OopMapSet();
2715   OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);
2716 
2717   // location of rfp is known implicitly by the frame sender code
2718 
2719   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2720 
2721   __ reset_last_Java_frame(false);
2722 
2723   // move UnrollBlock* into r4
2724   __ mov(r4, r0);
2725 
2726 #ifdef ASSERT
2727   { Label L;
2728     __ ldrw(rscratch1, Address(r4, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2729     __ cmpw(rscratch1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2730     __ br(Assembler::EQ, L);
2731     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
2732     __ bind(L);
2733   }
2734 #endif
2735 
2736   // Pop all the frames we must move/replace.
2737   //
2738   // Frame picture (youngest to oldest)
2739   // 1: self-frame (no frame link)
2740   // 2: deopting frame  (no frame link)
2741   // 3: caller of deopting frame (could be compiled/interpreted).
2742 
2743   // Pop self-frame.  We have no frame, and must rely only on r0 and sp.
2744   __ add(sp, sp, (SimpleRuntimeFrame::framesize) &lt;&lt; LogBytesPerInt); // Epilog!
2745 
2746   // Pop deoptimized frame (int)
2747   __ ldrw(r2, Address(r4,
2748                       Deoptimization::UnrollBlock::
2749                       size_of_deoptimized_frame_offset_in_bytes()));
2750   __ sub(r2, r2, 2 * wordSize);
2751   __ add(sp, sp, r2);
2752   __ ldp(rfp, lr, __ post(sp, 2 * wordSize));
2753   // LR should now be the return address to the caller (3) frame
2754 
2755 #ifdef ASSERT
2756   // Compilers generate code that bang the stack by as much as the
2757   // interpreter would need. So this stack banging should never
2758   // trigger a fault. Verify that it does not on non product builds.
2759   if (UseStackBanging) {
2760     __ ldrw(r1, Address(r4,
2761                         Deoptimization::UnrollBlock::
2762                         total_frame_sizes_offset_in_bytes()));
2763     __ bang_stack_size(r1, r2);
2764   }
2765 #endif
2766 
2767   // Load address of array of frame pcs into r2 (address*)
2768   __ ldr(r2, Address(r4,
2769                      Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2770 
2771   // Load address of array of frame sizes into r5 (intptr_t*)
2772   __ ldr(r5, Address(r4,
2773                      Deoptimization::UnrollBlock::
2774                      frame_sizes_offset_in_bytes()));
2775 
2776   // Counter
2777   __ ldrw(r3, Address(r4,
2778                       Deoptimization::UnrollBlock::
2779                       number_of_frames_offset_in_bytes())); // (int)
2780 
2781   // Now adjust the caller&#39;s stack to make up for the extra locals but
2782   // record the original sp so that we can save it in the skeletal
2783   // interpreter frame and the stack walking of interpreter_sender
2784   // will get the unextended sp value and not the &quot;real&quot; sp value.
2785 
2786   const Register sender_sp = r8;
2787 
2788   __ mov(sender_sp, sp);
2789   __ ldrw(r1, Address(r4,
2790                       Deoptimization::UnrollBlock::
2791                       caller_adjustment_offset_in_bytes())); // (int)
2792   __ sub(sp, sp, r1);
2793 
2794   // Push interpreter frames in a loop
2795   Label loop;
2796   __ bind(loop);
2797   __ ldr(r1, Address(r5, 0));       // Load frame size
2798   __ sub(r1, r1, 2 * wordSize);     // We&#39;ll push pc and rfp by hand
2799   __ ldr(lr, Address(r2, 0));       // Save return address
2800   __ enter();                       // and old rfp &amp; set new rfp
2801   __ sub(sp, sp, r1);               // Prolog
2802   __ str(sender_sp, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize)); // Make it walkable
2803   // This value is corrected by layout_activation_impl
2804   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
2805   __ mov(sender_sp, sp);          // Pass sender_sp to next frame
2806   __ add(r5, r5, wordSize);       // Bump array pointer (sizes)
2807   __ add(r2, r2, wordSize);       // Bump array pointer (pcs)
2808   __ subsw(r3, r3, 1);            // Decrement counter
2809   __ br(Assembler::GT, loop);
2810   __ ldr(lr, Address(r2, 0));     // save final return address
2811   // Re-push self-frame
2812   __ enter();                     // &amp; old rfp &amp; set new rfp
2813 
2814   // Use rfp because the frames look interpreted now
2815   // Save &quot;the_pc&quot; since it cannot easily be retrieved using the last_java_SP after we aligned SP.
2816   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2817   address the_pc = __ pc();
2818   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2819 
2820   // Call C code.  Need thread but NOT official VM entry
2821   // crud.  We cannot block on this call, no GC can happen.  Call should
2822   // restore return values to their stack-slots with the new SP.
2823   // Thread is in rdi already.
2824   //
2825   // BasicType unpack_frames(JavaThread* thread, int exec_mode);
2826   //
2827   // n.b. 2 gp args, 0 fp args, integral return type
2828 
2829   // sp should already be aligned
2830   __ mov(c_rarg0, rthread);
2831   __ movw(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2832   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
<a name="38" id="anc38"></a><span class="line-modified">2833   __ blrt(rscratch1, 2, 0, MacroAssembler::ret_type_integral);</span>
2834 
2835   // Set an oopmap for the call site
2836   // Use the same PC we used for the last java frame
2837   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
2838 
2839   // Clear fp AND pc
2840   __ reset_last_Java_frame(true);
2841 
2842   // Pop self-frame.
2843   __ leave();                 // Epilog
2844 
2845   // Jump to interpreter
2846   __ ret(lr);
2847 
2848   // Make sure all code is generated
2849   masm-&gt;flush();
2850 
2851   _uncommon_trap_blob =  UncommonTrapBlob::create(&amp;buffer, oop_maps,
2852                                                  SimpleRuntimeFrame::framesize &gt;&gt; 1);
<a name="39" id="anc39"></a><span class="line-removed">2853 </span>
<span class="line-removed">2854 #ifdef BUILTIN_SIM</span>
<span class="line-removed">2855   if (NotifySimulator) {</span>
<span class="line-removed">2856     unsigned char *base = _deopt_blob-&gt;code_begin();</span>
<span class="line-removed">2857     simulator-&gt;notifyRelocate(start, base - start);</span>
<span class="line-removed">2858   }</span>
<span class="line-removed">2859 #endif</span>
2860 }
2861 #endif // COMPILER2_OR_JVMCI
2862 
2863 
2864 //------------------------------generate_handler_blob------
2865 //
2866 // Generate a special Compile2Runtime blob that saves all registers,
2867 // and setup oopmap.
2868 //
2869 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
2870   ResourceMark rm;
2871   OopMapSet *oop_maps = new OopMapSet();
2872   OopMap* map;
2873 
2874   // Allocate space for the code.  Setup code generation tools.
2875   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
2876   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2877 
2878   address start   = __ pc();
2879   address call_pc = NULL;
2880   int frame_size_in_words;
2881   bool cause_return = (poll_type == POLL_AT_RETURN);
2882   bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
2883 
<a name="40" id="anc40"></a><span class="line-modified">2884   // Save registers, fpu state, and flags</span>
2885   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words, save_vectors);
2886 
2887   // The following is basically a call_VM.  However, we need the precise
2888   // address of the call in order to generate an oopmap. Hence, we do all the
2889   // work outselves.
2890 
2891   Label retaddr;
2892   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2893 
2894   // The return address must always be correct so that frame constructor never
2895   // sees an invalid pc.
2896 
2897   if (!cause_return) {
2898     // overwrite the return address pushed by save_live_registers
2899     // Additionally, r20 is a callee-saved register so we can look at
2900     // it later to determine if someone changed the return address for
2901     // us!
2902     __ ldr(r20, Address(rthread, JavaThread::saved_exception_pc_offset()));
2903     __ str(r20, Address(rfp, wordSize));
2904   }
2905 
2906   // Do the call
2907   __ mov(c_rarg0, rthread);
2908   __ lea(rscratch1, RuntimeAddress(call_ptr));
<a name="41" id="anc41"></a><span class="line-modified">2909   __ blrt(rscratch1, 1, 0, 1);</span>
2910   __ bind(retaddr);
2911 
2912   // Set an oopmap for the call site.  This oopmap will map all
2913   // oop-registers and debug-info registers as callee-saved.  This
2914   // will allow deoptimization at this safepoint to find all possible
2915   // debug-info recordings, as well as let GC find all oops.
2916 
2917   oop_maps-&gt;add_gc_map( __ pc() - start, map);
2918 
2919   Label noException;
2920 
2921   __ reset_last_Java_frame(false);
2922 
2923   __ maybe_isb();
2924   __ membar(Assembler::LoadLoad | Assembler::LoadStore);
2925 
2926   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2927   __ cbz(rscratch1, noException);
2928 
2929   // Exception pending
2930 
2931   RegisterSaver::restore_live_registers(masm, save_vectors);
2932 
2933   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2934 
2935   // No exception case
2936   __ bind(noException);
2937 
2938   Label no_adjust, bail;
2939   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; !cause_return) {
2940     // If our stashed return pc was modified by the runtime we avoid touching it
2941     __ ldr(rscratch1, Address(rfp, wordSize));
2942     __ cmp(r20, rscratch1);
2943     __ br(Assembler::NE, no_adjust);
2944 
2945 #ifdef ASSERT
2946     // Verify the correct encoding of the poll we&#39;re about to skip.
2947     // See NativeInstruction::is_ldrw_to_zr()
2948     __ ldrw(rscratch1, Address(r20));
2949     __ ubfx(rscratch2, rscratch1, 22, 10);
2950     __ cmpw(rscratch2, 0b1011100101);
2951     __ br(Assembler::NE, bail);
2952     __ ubfx(rscratch2, rscratch1, 0, 5);
2953     __ cmpw(rscratch2, 0b11111);
2954     __ br(Assembler::NE, bail);
2955 #endif
2956     // Adjust return pc forward to step over the safepoint poll instruction
2957     __ add(r20, r20, NativeInstruction::instruction_size);
2958     __ str(r20, Address(rfp, wordSize));
2959   }
2960 
2961   __ bind(no_adjust);
2962   // Normal exit, restore registers and exit.
2963   RegisterSaver::restore_live_registers(masm, save_vectors);
2964 
2965   __ ret(lr);
2966 
2967 #ifdef ASSERT
2968   __ bind(bail);
2969   __ stop(&quot;Attempting to adjust pc to skip safepoint poll but the return point is not what we expected&quot;);
2970 #endif
2971 
2972   // Make sure all code is generated
2973   masm-&gt;flush();
2974 
2975   // Fill-out other meta info
2976   return SafepointBlob::create(&amp;buffer, oop_maps, frame_size_in_words);
2977 }
2978 
2979 //
2980 // generate_resolve_blob - call resolution (static/virtual/opt-virtual/ic-miss
2981 //
2982 // Generate a stub that calls into vm to find out the proper destination
2983 // of a java call. All the argument registers are live at this point
2984 // but since this is generic code we don&#39;t know what they are and the caller
2985 // must do any gc of the args.
2986 //
2987 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
2988   assert (StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
2989 
2990   // allocate space for the code
2991   ResourceMark rm;
2992 
2993   CodeBuffer buffer(name, 1000, 512);
2994   MacroAssembler* masm                = new MacroAssembler(&amp;buffer);
2995 
2996   int frame_size_in_words;
2997 
2998   OopMapSet *oop_maps = new OopMapSet();
2999   OopMap* map = NULL;
3000 
3001   int start = __ offset();
3002 
3003   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
3004 
3005   int frame_complete = __ offset();
3006 
3007   {
3008     Label retaddr;
3009     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
3010 
3011     __ mov(c_rarg0, rthread);
3012     __ lea(rscratch1, RuntimeAddress(destination));
3013 
<a name="42" id="anc42"></a><span class="line-modified">3014     __ blrt(rscratch1, 1, 0, 1);</span>
3015     __ bind(retaddr);
3016   }
3017 
3018   // Set an oopmap for the call site.
3019   // We need this not only for callee-saved registers, but also for volatile
3020   // registers that the compiler might be keeping live across a safepoint.
3021 
3022   oop_maps-&gt;add_gc_map( __ offset() - start, map);
3023 
3024   __ maybe_isb();
3025 
3026   // r0 contains the address we are going to jump to assuming no exception got installed
3027 
3028   // clear last_Java_sp
3029   __ reset_last_Java_frame(false);
3030   // check for pending exceptions
3031   Label pending;
3032   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
3033   __ cbnz(rscratch1, pending);
3034 
3035   // get the returned Method*
3036   __ get_vm_result_2(rmethod, rthread);
3037   __ str(rmethod, Address(sp, RegisterSaver::reg_offset_in_bytes(rmethod)));
3038 
3039   // r0 is where we want to jump, overwrite rscratch1 which is saved and scratch
3040   __ str(r0, Address(sp, RegisterSaver::rscratch1_offset_in_bytes()));
3041   RegisterSaver::restore_live_registers(masm);
3042 
3043   // We are back the the original state on entry and ready to go.
3044 
3045   __ br(rscratch1);
3046 
3047   // Pending exception after the safepoint
3048 
3049   __ bind(pending);
3050 
3051   RegisterSaver::restore_live_registers(masm);
3052 
3053   // exception pending =&gt; remove activation and forward to exception handler
3054 
3055   __ str(zr, Address(rthread, JavaThread::vm_result_offset()));
3056 
3057   __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
3058   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3059 
3060   // -------------
3061   // make sure all code is generated
3062   masm-&gt;flush();
3063 
3064   // return the  blob
3065   // frame_size_words or bytes??
3066   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_in_words, oop_maps, true);
3067 }
3068 
3069 #if COMPILER2_OR_JVMCI
3070 // This is here instead of runtime_x86_64.cpp because it uses SimpleRuntimeFrame
3071 //
3072 //------------------------------generate_exception_blob---------------------------
3073 // creates exception blob at the end
3074 // Using exception blob, this code is jumped from a compiled method.
3075 // (see emit_exception_handler in x86_64.ad file)
3076 //
3077 // Given an exception pc at a call we call into the runtime for the
3078 // handler in this method. This handler might merely restore state
3079 // (i.e. callee save registers) unwind the frame and jump to the
3080 // exception handler for the nmethod if there is no Java level handler
3081 // for the nmethod.
3082 //
3083 // This code is entered with a jmp.
3084 //
3085 // Arguments:
3086 //   r0: exception oop
3087 //   r3: exception pc
3088 //
3089 // Results:
3090 //   r0: exception oop
3091 //   r3: exception pc in caller or ???
3092 //   destination: exception handler of caller
3093 //
3094 // Note: the exception pc MUST be at a call (precise debug information)
3095 //       Registers r0, r3, r2, r4, r5, r8-r11 are not callee saved.
3096 //
3097 
3098 void OptoRuntime::generate_exception_blob() {
3099   assert(!OptoRuntime::is_callee_saved_register(R3_num), &quot;&quot;);
3100   assert(!OptoRuntime::is_callee_saved_register(R0_num), &quot;&quot;);
3101   assert(!OptoRuntime::is_callee_saved_register(R2_num), &quot;&quot;);
3102 
3103   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
3104 
3105   // Allocate space for the code
3106   ResourceMark rm;
3107   // Setup code generation tools
3108   CodeBuffer buffer(&quot;exception_blob&quot;, 2048, 1024);
3109   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3110 
3111   // TODO check various assumptions made here
3112   //
3113   // make sure we do so before running this
3114 
3115   address start = __ pc();
3116 
3117   // push rfp and retaddr by hand
3118   // Exception pc is &#39;return address&#39; for stack walker
3119   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
3120   // there are no callee save registers and we don&#39;t expect an
3121   // arg reg save area
3122 #ifndef PRODUCT
3123   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
3124 #endif
3125   // Store exception in Thread object. We cannot pass any arguments to the
3126   // handle_exception call, since we do not want to make any assumption
3127   // about the size of the frame where the exception happened in.
3128   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
3129   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
3130 
3131   // This call does all the hard work.  It checks if an exception handler
3132   // exists in the method.
3133   // If so, it returns the handler address.
3134   // If not, it prepares for stack-unwinding, restoring the callee-save
3135   // registers of the frame being removed.
3136   //
3137   // address OptoRuntime::handle_exception_C(JavaThread* thread)
3138   //
3139   // n.b. 1 gp arg, 0 fp args, integral return type
3140 
3141   // the stack should always be aligned
3142   address the_pc = __ pc();
3143   __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);
3144   __ mov(c_rarg0, rthread);
3145   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));
<a name="43" id="anc43"></a><span class="line-modified">3146   __ blrt(rscratch1, 1, 0, MacroAssembler::ret_type_integral);</span>
3147   __ maybe_isb();
3148 
3149   // Set an oopmap for the call site.  This oopmap will only be used if we
3150   // are unwinding the stack.  Hence, all locations will be dead.
3151   // Callee-saved registers will be the same as the frame above (i.e.,
3152   // handle_exception_stub), since they were restored when we got the
3153   // exception.
3154 
3155   OopMapSet* oop_maps = new OopMapSet();
3156 
3157   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
3158 
3159   __ reset_last_Java_frame(false);
3160 
3161   // Restore callee-saved registers
3162 
3163   // rfp is an implicitly saved callee saved register (i.e. the calling
3164   // convention will save restore it in prolog/epilog) Other than that
3165   // there are no callee save registers now that adapter frames are gone.
3166   // and we dont&#39; expect an arg reg save area
3167   __ ldp(rfp, r3, Address(__ post(sp, 2 * wordSize)));
3168 
3169   // r0: exception handler
3170 
3171   // We have a handler in r0 (could be deopt blob).
3172   __ mov(r8, r0);
3173 
3174   // Get the exception oop
3175   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
3176   // Get the exception pc in case we are deoptimized
3177   __ ldr(r4, Address(rthread, JavaThread::exception_pc_offset()));
3178 #ifdef ASSERT
3179   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3180   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3181 #endif
3182   // Clear the exception oop so GC no longer processes it as a root.
3183   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3184 
3185   // r0: exception oop
3186   // r8:  exception handler
3187   // r4: exception pc
3188   // Jump to handler
3189 
3190   __ br(r8);
3191 
3192   // Make sure all code is generated
3193   masm-&gt;flush();
3194 
3195   // Set exception blob
3196   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3197 }
3198 #endif // COMPILER2_OR_JVMCI
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>
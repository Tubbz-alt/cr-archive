<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_FrameMap.hpp&quot;
  30 #include &quot;c1/c1_Instruction.hpp&quot;
  31 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  32 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  33 #include &quot;c1/c1_Runtime1.hpp&quot;
  34 #include &quot;c1/c1_ValueStack.hpp&quot;
  35 #include &quot;ci/ciArray.hpp&quot;
  36 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  37 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  38 #include &quot;runtime/sharedRuntime.hpp&quot;
  39 #include &quot;runtime/stubRoutines.hpp&quot;

  40 #include &quot;vmreg_aarch64.inline.hpp&quot;
  41 
  42 #ifdef ASSERT
  43 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  44 #else
  45 #define __ gen()-&gt;lir()-&gt;
  46 #endif
  47 
  48 // Item will be loaded into a byte register; Intel only
  49 void LIRItem::load_byte_item() {
  50   load_item();
  51 }
  52 
  53 
  54 void LIRItem::load_nonconstant() {
  55   LIR_Opr r = value()-&gt;operand();
  56   if (r-&gt;is_constant()) {
  57     _result = r;
  58   } else {
  59     load_item();
</pre>
<hr />
<pre>
 409     return;
 410   }
 411 
 412   LIRItem left(x-&gt;x(),  this);
 413   LIRItem right(x-&gt;y(), this);
 414   LIRItem* left_arg  = &amp;left;
 415   LIRItem* right_arg = &amp;right;
 416 
 417   // Always load right hand side.
 418   right.load_item();
 419 
 420   if (!left.is_register())
 421     left.load_item();
 422 
 423   LIR_Opr reg = rlock(x);
 424   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 425   if (x-&gt;is_strictfp() &amp;&amp; (x-&gt;op() == Bytecodes::_dmul || x-&gt;op() == Bytecodes::_ddiv)) {
 426     tmp = new_register(T_DOUBLE);
 427   }
 428 
<span class="line-modified"> 429   arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), NULL);</span>
 430 
 431   set_result(x, round_item(reg));
 432 }
 433 
 434 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 435 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 436 
 437   // missing test if instr is commutative and if we should swap
 438   LIRItem left(x-&gt;x(), this);
 439   LIRItem right(x-&gt;y(), this);
 440 
 441   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 442 
 443     left.load_item();
 444     bool need_zero_check = true;
 445     if (right.is_constant()) {
 446       jlong c = right.get_jlong_constant();
 447       // no need to do div-by-zero check if the divisor is a non-zero constant
 448       if (c != 0) need_zero_check = false;
 449       // do not load right if the divisor is a power-of-2 constant
<span class="line-modified"> 450       if (c &gt; 0 &amp;&amp; is_power_of_2_long(c)) {</span>
 451         right.dont_load_item();
 452       } else {
 453         right.load_item();
 454       }
 455     } else {
 456       right.load_item();
 457     }
 458     if (need_zero_check) {
 459       CodeEmitInfo* info = state_for(x);
 460       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
 461       __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));
 462     }
 463 
 464     rlock_result(x);
 465     switch (x-&gt;op()) {
 466     case Bytecodes::_lrem:
 467       __ rem (left.result(), right.result(), x-&gt;operand());
 468       break;
 469     case Bytecodes::_ldiv:
 470       __ div (left.result(), right.result(), x-&gt;operand());
</pre>
<hr />
<pre>
 716   }
 717   left.load_item();
 718   right.load_item();
 719   LIR_Opr reg = rlock_result(x);
 720 
 721   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 722     Bytecodes::Code code = x-&gt;op();
 723     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 724   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 725     __ lcmp2int(left.result(), right.result(), reg);
 726   } else {
 727     Unimplemented();
 728   }
 729 }
 730 
 731 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 732   LIR_Opr ill = LIR_OprFact::illegalOpr;  // for convenience
 733   new_value.load_item();
 734   cmp_value.load_item();
 735   LIR_Opr result = new_register(T_INT);
<span class="line-modified"> 736   if (type == T_OBJECT || type == T_ARRAY) {</span>
 737     __ cas_obj(addr, cmp_value.result(), new_value.result(), new_register(T_INT), new_register(T_INT), result);
 738   } else if (type == T_INT) {
 739     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 740   } else if (type == T_LONG) {
 741     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 742   } else {
 743     ShouldNotReachHere();
 744     Unimplemented();
 745   }
 746   __ logical_xor(FrameMap::r8_opr, LIR_OprFact::intConst(1), result);
 747   return result;
 748 }
 749 
 750 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
<span class="line-modified"> 751   bool is_oop = type == T_OBJECT || type == T_ARRAY;</span>
 752   LIR_Opr result = new_register(type);
 753   value.load_item();
 754   assert(type == T_INT || is_oop LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 755   LIR_Opr tmp = new_register(T_INT);
 756   __ xchg(addr, value.result(), result, tmp);
 757   return result;
 758 }
 759 
 760 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 761   LIR_Opr result = new_register(type);
 762   value.load_item();
 763   assert(type == T_INT LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 764   LIR_Opr tmp = new_register(T_INT);
 765   __ xadd(addr, value.result(), result, tmp);
 766   return result;
 767 }
 768 
 769 void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {
 770   assert(x-&gt;number_of_arguments() == 1 || (x-&gt;number_of_arguments() == 2 &amp;&amp; x-&gt;id() == vmIntrinsics::_dpow), &quot;wrong type&quot;);
 771   if (x-&gt;id() == vmIntrinsics::_dexp || x-&gt;id() == vmIntrinsics::_dlog ||
</pre>
<hr />
<pre>
1110   case vmIntrinsics::_fmaF:   __ fmaf(calc_input, calc_input1, calc_input2, calc_result); break;
1111   default:                    ShouldNotReachHere();
1112   }
1113 }
1114 
1115 void LIRGenerator::do_vectorizedMismatch(Intrinsic* x) {
1116   fatal(&quot;vectorizedMismatch intrinsic is not implemented on this platform&quot;);
1117 }
1118 
1119 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
1120 // _i2b, _i2c, _i2s
1121 void LIRGenerator::do_Convert(Convert* x) {
1122   LIRItem value(x-&gt;value(), this);
1123   value.load_item();
1124   LIR_Opr input = value.result();
1125   LIR_Opr result = rlock(x);
1126 
1127   // arguments of lir_convert
1128   LIR_Opr conv_input = input;
1129   LIR_Opr conv_result = result;
<span class="line-removed">1130   ConversionStub* stub = NULL;</span>
1131 
1132   __ convert(x-&gt;op(), conv_input, conv_result);
1133 
1134   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1135   set_result(x, result);
1136 }
1137 
1138 void LIRGenerator::do_NewInstance(NewInstance* x) {
1139 #ifndef PRODUCT
1140   if (PrintNotLoaded &amp;&amp; !x-&gt;klass()-&gt;is_loaded()) {
1141     tty-&gt;print_cr(&quot;   ###class not loaded at new bci %d&quot;, x-&gt;printable_bci());
1142   }
1143 #endif
1144   CodeEmitInfo* info = state_for(x, x-&gt;state());
1145   LIR_Opr reg = result_register_for(x-&gt;type());
1146   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1147                        FrameMap::r2_oop_opr,
1148                        FrameMap::r5_oop_opr,
1149                        FrameMap::r4_oop_opr,
1150                        LIR_OprFact::illegalOpr,
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_FrameMap.hpp&quot;
  30 #include &quot;c1/c1_Instruction.hpp&quot;
  31 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  32 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  33 #include &quot;c1/c1_Runtime1.hpp&quot;
  34 #include &quot;c1/c1_ValueStack.hpp&quot;
  35 #include &quot;ci/ciArray.hpp&quot;
  36 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  37 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  38 #include &quot;runtime/sharedRuntime.hpp&quot;
  39 #include &quot;runtime/stubRoutines.hpp&quot;
<span class="line-added">  40 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  41 #include &quot;vmreg_aarch64.inline.hpp&quot;
  42 
  43 #ifdef ASSERT
  44 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  45 #else
  46 #define __ gen()-&gt;lir()-&gt;
  47 #endif
  48 
  49 // Item will be loaded into a byte register; Intel only
  50 void LIRItem::load_byte_item() {
  51   load_item();
  52 }
  53 
  54 
  55 void LIRItem::load_nonconstant() {
  56   LIR_Opr r = value()-&gt;operand();
  57   if (r-&gt;is_constant()) {
  58     _result = r;
  59   } else {
  60     load_item();
</pre>
<hr />
<pre>
 410     return;
 411   }
 412 
 413   LIRItem left(x-&gt;x(),  this);
 414   LIRItem right(x-&gt;y(), this);
 415   LIRItem* left_arg  = &amp;left;
 416   LIRItem* right_arg = &amp;right;
 417 
 418   // Always load right hand side.
 419   right.load_item();
 420 
 421   if (!left.is_register())
 422     left.load_item();
 423 
 424   LIR_Opr reg = rlock(x);
 425   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 426   if (x-&gt;is_strictfp() &amp;&amp; (x-&gt;op() == Bytecodes::_dmul || x-&gt;op() == Bytecodes::_ddiv)) {
 427     tmp = new_register(T_DOUBLE);
 428   }
 429 
<span class="line-modified"> 430   arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp());</span>
 431 
 432   set_result(x, round_item(reg));
 433 }
 434 
 435 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 436 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 437 
 438   // missing test if instr is commutative and if we should swap
 439   LIRItem left(x-&gt;x(), this);
 440   LIRItem right(x-&gt;y(), this);
 441 
 442   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 443 
 444     left.load_item();
 445     bool need_zero_check = true;
 446     if (right.is_constant()) {
 447       jlong c = right.get_jlong_constant();
 448       // no need to do div-by-zero check if the divisor is a non-zero constant
 449       if (c != 0) need_zero_check = false;
 450       // do not load right if the divisor is a power-of-2 constant
<span class="line-modified"> 451       if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {</span>
 452         right.dont_load_item();
 453       } else {
 454         right.load_item();
 455       }
 456     } else {
 457       right.load_item();
 458     }
 459     if (need_zero_check) {
 460       CodeEmitInfo* info = state_for(x);
 461       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
 462       __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));
 463     }
 464 
 465     rlock_result(x);
 466     switch (x-&gt;op()) {
 467     case Bytecodes::_lrem:
 468       __ rem (left.result(), right.result(), x-&gt;operand());
 469       break;
 470     case Bytecodes::_ldiv:
 471       __ div (left.result(), right.result(), x-&gt;operand());
</pre>
<hr />
<pre>
 717   }
 718   left.load_item();
 719   right.load_item();
 720   LIR_Opr reg = rlock_result(x);
 721 
 722   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 723     Bytecodes::Code code = x-&gt;op();
 724     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 725   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 726     __ lcmp2int(left.result(), right.result(), reg);
 727   } else {
 728     Unimplemented();
 729   }
 730 }
 731 
 732 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 733   LIR_Opr ill = LIR_OprFact::illegalOpr;  // for convenience
 734   new_value.load_item();
 735   cmp_value.load_item();
 736   LIR_Opr result = new_register(T_INT);
<span class="line-modified"> 737   if (is_reference_type(type)) {</span>
 738     __ cas_obj(addr, cmp_value.result(), new_value.result(), new_register(T_INT), new_register(T_INT), result);
 739   } else if (type == T_INT) {
 740     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 741   } else if (type == T_LONG) {
 742     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 743   } else {
 744     ShouldNotReachHere();
 745     Unimplemented();
 746   }
 747   __ logical_xor(FrameMap::r8_opr, LIR_OprFact::intConst(1), result);
 748   return result;
 749 }
 750 
 751 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
<span class="line-modified"> 752   bool is_oop = is_reference_type(type);</span>
 753   LIR_Opr result = new_register(type);
 754   value.load_item();
 755   assert(type == T_INT || is_oop LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 756   LIR_Opr tmp = new_register(T_INT);
 757   __ xchg(addr, value.result(), result, tmp);
 758   return result;
 759 }
 760 
 761 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 762   LIR_Opr result = new_register(type);
 763   value.load_item();
 764   assert(type == T_INT LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 765   LIR_Opr tmp = new_register(T_INT);
 766   __ xadd(addr, value.result(), result, tmp);
 767   return result;
 768 }
 769 
 770 void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {
 771   assert(x-&gt;number_of_arguments() == 1 || (x-&gt;number_of_arguments() == 2 &amp;&amp; x-&gt;id() == vmIntrinsics::_dpow), &quot;wrong type&quot;);
 772   if (x-&gt;id() == vmIntrinsics::_dexp || x-&gt;id() == vmIntrinsics::_dlog ||
</pre>
<hr />
<pre>
1111   case vmIntrinsics::_fmaF:   __ fmaf(calc_input, calc_input1, calc_input2, calc_result); break;
1112   default:                    ShouldNotReachHere();
1113   }
1114 }
1115 
1116 void LIRGenerator::do_vectorizedMismatch(Intrinsic* x) {
1117   fatal(&quot;vectorizedMismatch intrinsic is not implemented on this platform&quot;);
1118 }
1119 
1120 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
1121 // _i2b, _i2c, _i2s
1122 void LIRGenerator::do_Convert(Convert* x) {
1123   LIRItem value(x-&gt;value(), this);
1124   value.load_item();
1125   LIR_Opr input = value.result();
1126   LIR_Opr result = rlock(x);
1127 
1128   // arguments of lir_convert
1129   LIR_Opr conv_input = input;
1130   LIR_Opr conv_result = result;

1131 
1132   __ convert(x-&gt;op(), conv_input, conv_result);
1133 
1134   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1135   set_result(x, result);
1136 }
1137 
1138 void LIRGenerator::do_NewInstance(NewInstance* x) {
1139 #ifndef PRODUCT
1140   if (PrintNotLoaded &amp;&amp; !x-&gt;klass()-&gt;is_loaded()) {
1141     tty-&gt;print_cr(&quot;   ###class not loaded at new bci %d&quot;, x-&gt;printable_bci());
1142   }
1143 #endif
1144   CodeEmitInfo* info = state_for(x, x-&gt;state());
1145   LIR_Opr reg = result_register_for(x-&gt;type());
1146   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1147                        FrameMap::r2_oop_opr,
1148                        FrameMap::r5_oop_opr,
1149                        FrameMap::r4_oop_opr,
1150                        LIR_OprFact::illegalOpr,
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
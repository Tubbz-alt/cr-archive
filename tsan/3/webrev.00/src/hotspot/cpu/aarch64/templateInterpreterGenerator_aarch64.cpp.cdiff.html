<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubRoutines_aarch64.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 47,20 ***</span>
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/synchronizer.hpp&quot;
  #include &quot;runtime/timer.hpp&quot;
  #include &quot;runtime/vframeArray.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  #include &lt;sys/types.h&gt;
  
  #ifndef PRODUCT
  #include &quot;oops/method.hpp&quot;
  #endif // !PRODUCT
  
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">- #include &quot;../../../../../../simulator/simulator.hpp&quot;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  // Size of interpreter code.  Increase if too small.  Interpreter will
  // fail with a guarantee (&quot;not enough space for interpreter generation&quot;);
  // if too small.
  // Run with +PrintInterpreter to get the VM to print out the size.
  // Max size with JVMTI
<span class="line-new-header">--- 47,17 ---</span>
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/synchronizer.hpp&quot;
  #include &quot;runtime/timer.hpp&quot;
  #include &quot;runtime/vframeArray.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &lt;sys/types.h&gt;
  
  #ifndef PRODUCT
  #include &quot;oops/method.hpp&quot;
  #endif // !PRODUCT
  
  // Size of interpreter code.  Increase if too small.  Interpreter will
  // fail with a guarantee (&quot;not enough space for interpreter generation&quot;);
  // if too small.
  // Run with +PrintInterpreter to get the VM to print out the size.
  // Max size with JVMTI
</pre>
<hr />
<pre>
<span class="line-old-header">*** 287,24 ***</span>
      } else {
        fn = CAST_FROM_FN_PTR(address, StubRoutines::dexp());
      }
      break;
    case Interpreter::java_lang_math_pow :
<span class="line-removed">-     fpargs = 2;</span>
      if (StubRoutines::dpow() == NULL) {
        fn = CAST_FROM_FN_PTR(address, SharedRuntime::dpow);
      } else {
        fn = CAST_FROM_FN_PTR(address, StubRoutines::dpow());
      }
      break;
    default:
      ShouldNotReachHere();
      fn = NULL;  // unreachable
    }
<span class="line-removed">-   const int gpargs = 0, rtype = 3;</span>
    __ mov(rscratch1, fn);
<span class="line-modified">!   __ blrt(rscratch1, gpargs, fpargs, rtype);</span>
  }
  
  // Abstract method entry
  // Attempt to execute abstract method. Throw exception
  address TemplateInterpreterGenerator::generate_abstract_entry(void) {
<span class="line-new-header">--- 284,22 ---</span>
      } else {
        fn = CAST_FROM_FN_PTR(address, StubRoutines::dexp());
      }
      break;
    case Interpreter::java_lang_math_pow :
      if (StubRoutines::dpow() == NULL) {
        fn = CAST_FROM_FN_PTR(address, SharedRuntime::dpow);
      } else {
        fn = CAST_FROM_FN_PTR(address, StubRoutines::dpow());
      }
      break;
    default:
      ShouldNotReachHere();
      fn = NULL;  // unreachable
    }
    __ mov(rscratch1, fn);
<span class="line-modified">!   __ blr(rscratch1);</span>
  }
  
  // Abstract method entry
  // Attempt to execute abstract method. Throw exception
  address TemplateInterpreterGenerator::generate_abstract_entry(void) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 447,11 ***</span>
  
    if (state == atos) {
      Register obj = r0;
      Register mdp = r1;
      Register tmp = r2;
<span class="line-removed">-     __ ldr(mdp, Address(rmethod, Method::method_data_offset()));</span>
      __ profile_return_type(mdp, obj, tmp);
    }
  
    // Pop N words from the stack
    __ get_cache_and_index_at_bcp(r1, r2, 1, index_size);
<span class="line-new-header">--- 442,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 467,17 ***</span>
    __ ldr(rscratch2,
           Address(rfp, frame::interpreter_frame_initial_sp_offset * wordSize));
    __ sub(rscratch1, rscratch2, rscratch1, ext::uxtw, 3);
    __ andr(sp, rscratch1, -16);
  
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-   // tell the simulator that the method has been reentered</span>
<span class="line-removed">-   if (NotifySimulator) {</span>
<span class="line-removed">-     __ notify(Assembler::method_reentry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
   __ check_and_handle_popframe(rthread);
   __ check_and_handle_earlyret(rthread);
  
    __ get_dispatch();
    __ dispatch_next(state, step);
<span class="line-new-header">--- 461,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 512,22 ***</span>
  #if INCLUDE_JVMCI
    // Check if we need to take lock at entry of synchronized method.  This can
    // only occur on method entry so emit it only for vtos with step 0.
    if ((EnableJVMCI || UseAOT) &amp;&amp; state == vtos &amp;&amp; step == 0) {
      Label L;
<span class="line-modified">!     __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));</span>
      __ cbz(rscratch1, L);
      // Clear flag.
      __ strb(zr, Address(rthread, JavaThread::pending_monitorenter_offset()));
      // Take lock.
      lock_method();
      __ bind(L);
    } else {
  #ifdef ASSERT
      if (EnableJVMCI) {
        Label L;
<span class="line-modified">!       __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));</span>
        __ cbz(rscratch1, L);
        __ stop(&quot;unexpected pending monitor in deopt entry&quot;);
        __ bind(L);
      }
  #endif
<span class="line-new-header">--- 499,22 ---</span>
  #if INCLUDE_JVMCI
    // Check if we need to take lock at entry of synchronized method.  This can
    // only occur on method entry so emit it only for vtos with step 0.
    if ((EnableJVMCI || UseAOT) &amp;&amp; state == vtos &amp;&amp; step == 0) {
      Label L;
<span class="line-modified">!     __ ldrb(rscratch1, Address(rthread, JavaThread::pending_monitorenter_offset()));</span>
      __ cbz(rscratch1, L);
      // Clear flag.
      __ strb(zr, Address(rthread, JavaThread::pending_monitorenter_offset()));
      // Take lock.
      lock_method();
      __ bind(L);
    } else {
  #ifdef ASSERT
      if (EnableJVMCI) {
        Label L;
<span class="line-modified">!       __ ldrb(rscratch1, Address(rthread, JavaThread::pending_monitorenter_offset()));</span>
        __ cbz(rscratch1, L);
        __ stop(&quot;unexpected pending monitor in deopt entry&quot;);
        __ bind(L);
      }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 884,12 ***</span>
    } else {
      __ stp(zr, rmethod, Address(sp, 6 * wordSize));        // save Method* (no mdp)
    }
  
    // Get mirror and store it in the frame as GC root for this Method*
<span class="line-modified">!   __ load_mirror(rscratch1, rmethod);</span>
<span class="line-modified">!   __ stp(rscratch1, zr, Address(sp, 4 * wordSize));</span>
  
    __ ldr(rcpool, Address(rmethod, Method::const_offset()));
    __ ldr(rcpool, Address(rcpool, ConstMethod::constants_offset()));
    __ ldr(rcpool, Address(rcpool, ConstantPool::cache_offset_in_bytes()));
    __ stp(rlocals, rcpool, Address(sp, 2 * wordSize));
<span class="line-new-header">--- 871,12 ---</span>
    } else {
      __ stp(zr, rmethod, Address(sp, 6 * wordSize));        // save Method* (no mdp)
    }
  
    // Get mirror and store it in the frame as GC root for this Method*
<span class="line-modified">!   __ load_mirror(r10, rmethod);</span>
<span class="line-modified">!   __ stp(r10, zr, Address(sp, 4 * wordSize));</span>
  
    __ ldr(rcpool, Address(rmethod, Method::const_offset()));
    __ ldr(rcpool, Address(rcpool, ConstMethod::constants_offset()));
    __ ldr(rcpool, Address(rcpool, ConstantPool::cache_offset_in_bytes()));
    __ stp(rlocals, rcpool, Address(sp, 2 * wordSize));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1183,16 ***</span>
    // Pull SP back to minimum size: this avoids holes in the stack
    __ andr(sp, esp, -16);
  
    // initialize fixed part of activation frame
    generate_fixed_frame(true);
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-   // tell the simulator that a method has been entered</span>
<span class="line-removed">-   if (NotifySimulator) {</span>
<span class="line-removed">-     __ notify(Assembler::method_entry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
  
    // make sure method is native &amp; not abstract
  #ifdef ASSERT
    __ ldrw(r0, access_flags);
    {
<span class="line-new-header">--- 1170,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1373,11 ***</span>
    __ mov(rscratch1, _thread_in_native);
    __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
    __ stlrw(rscratch1, rscratch2);
  
    // Call the native method.
<span class="line-modified">!   __ blrt(r10, rscratch1);</span>
    __ bind(native_return);
    __ maybe_isb();
    __ get_method(rmethod);
    // result potentially in r0 or v0
  
<span class="line-new-header">--- 1354,11 ---</span>
    __ mov(rscratch1, _thread_in_native);
    __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
    __ stlrw(rscratch1, rscratch2);
  
    // Call the native method.
<span class="line-modified">!   __ blr(r10);</span>
    __ bind(native_return);
    __ maybe_isb();
    __ get_method(rmethod);
    // result potentially in r0 or v0
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1413,11 ***</span>
      // clearing _last_native_pc down below. So we do a runtime call by
      // hand.
      //
      __ mov(c_rarg0, rthread);
      __ mov(rscratch2, CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));
<span class="line-modified">!     __ blrt(rscratch2, 1, 0, 0);</span>
      __ maybe_isb();
      __ get_method(rmethod);
      __ reinit_heapbase();
      __ bind(Continue);
    }
<span class="line-new-header">--- 1394,11 ---</span>
      // clearing _last_native_pc down below. So we do a runtime call by
      // hand.
      //
      __ mov(c_rarg0, rthread);
      __ mov(rscratch2, CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));
<span class="line-modified">!     __ blr(rscratch2);</span>
      __ maybe_isb();
      __ get_method(rmethod);
      __ reinit_heapbase();
      __ bind(Continue);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1464,11 ***</span>
      __ br(Assembler::NE, no_reguard);
  
      __ pusha(); // XXX only save smashed registers
      __ mov(c_rarg0, rthread);
      __ mov(rscratch2, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));
<span class="line-modified">!     __ blrt(rscratch2, 0, 0, 0);</span>
      __ popa(); // XXX only restore smashed registers
      __ bind(no_reguard);
    }
  
    // The method register is junk from after the thread_in_native transition
<span class="line-new-header">--- 1445,11 ---</span>
      __ br(Assembler::NE, no_reguard);
  
      __ pusha(); // XXX only save smashed registers
      __ mov(c_rarg0, rthread);
      __ mov(rscratch2, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));
<span class="line-modified">!     __ blr(rscratch2);</span>
      __ popa(); // XXX only restore smashed registers
      __ bind(no_reguard);
    }
  
    // The method register is junk from after the thread_in_native transition
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1619,16 ***</span>
    // And the base dispatch table
    __ get_dispatch();
  
    // initialize fixed part of activation frame
    generate_fixed_frame(false);
<span class="line-modified">! #ifndef PRODUCT</span>
<span class="line-removed">-   // tell the simulator that a method has been entered</span>
<span class="line-removed">-   if (NotifySimulator) {</span>
<span class="line-removed">-     __ notify(Assembler::method_entry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
    // make sure method is not native &amp; not abstract
  #ifdef ASSERT
    __ ldrw(r0, access_flags);
    {
      Label L;
<span class="line-new-header">--- 1600,11 ---</span>
    // And the base dispatch table
    __ get_dispatch();
  
    // initialize fixed part of activation frame
    generate_fixed_frame(false);
<span class="line-modified">! </span>
    // make sure method is not native &amp; not abstract
  #ifdef ASSERT
    __ ldrw(r0, access_flags);
    {
      Label L;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1655,17 ***</span>
     const Address do_not_unlock_if_synchronized(rthread,
          in_bytes(JavaThread::do_not_unlock_if_synchronized_offset()));
    __ mov(rscratch2, true);
    __ strb(rscratch2, do_not_unlock_if_synchronized);
  
<span class="line-removed">-   Label no_mdp;</span>
    Register mdp = r3;
<span class="line-removed">-   __ ldr(mdp, Address(rmethod, Method::method_data_offset()));</span>
<span class="line-removed">-   __ cbz(mdp, no_mdp);</span>
<span class="line-removed">-   __ add(mdp, mdp, in_bytes(MethodData::data_offset()));</span>
    __ profile_parameters_type(mdp, r1, r2);
<span class="line-removed">-   __ bind(no_mdp);</span>
  
    // increment invocation count &amp; check for overflow
    Label invocation_counter_overflow;
    Label profile_method;
    Label profile_method_continue;
<span class="line-new-header">--- 1631,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1760,17 ***</span>
    __ restore_locals();
    __ restore_constant_pool_cache();
    __ reinit_heapbase();  // restore rheapbase as heapbase.
    __ get_dispatch();
  
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-   // tell the simulator that the caller method has been reentered</span>
<span class="line-removed">-   if (NotifySimulator) {</span>
<span class="line-removed">-     __ get_method(rmethod);</span>
<span class="line-removed">-     __ notify(Assembler::method_reentry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
    // Entry point for exceptions thrown within interpreter code
    Interpreter::_throw_exception_entry = __ pc();
    // If we came here via a NullPointerException on the receiver of a
    // method, rmethod may be corrupt.
    __ get_method(rmethod);
<span class="line-new-header">--- 1731,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2084,123 ***</span>
    __ brk(0);
    __ bind(L);
    __ pop(rscratch1);
  }
  
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">- </span>
<span class="line-removed">- #include &lt;sys/mman.h&gt;</span>
<span class="line-removed">- #include &lt;unistd.h&gt;</span>
<span class="line-removed">- </span>
<span class="line-removed">- extern &quot;C&quot; {</span>
<span class="line-removed">-   static int PAGESIZE = getpagesize();</span>
<span class="line-removed">-   int is_mapped_address(u_int64_t address)</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     address = (address &amp; ~((u_int64_t)PAGESIZE - 1));</span>
<span class="line-removed">-     if (msync((void *)address, PAGESIZE, MS_ASYNC) == 0) {</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (errno != ENOMEM) {</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void bccheck1(u_int64_t pc, u_int64_t fp, char *method, int *bcidx, int *framesize, char *decode)</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (method != 0) {</span>
<span class="line-removed">-       method[0] = &#39;\0&#39;;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (bcidx != 0) {</span>
<span class="line-removed">-       *bcidx = -2;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (decode != 0) {</span>
<span class="line-removed">-       decode[0] = 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (framesize != 0) {</span>
<span class="line-removed">-       *framesize = -1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (Interpreter::contains((address)pc)) {</span>
<span class="line-removed">-       AArch64Simulator *sim = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed">-       Method* meth;</span>
<span class="line-removed">-       address bcp;</span>
<span class="line-removed">-       if (fp) {</span>
<span class="line-removed">- #define FRAME_SLOT_METHOD 3</span>
<span class="line-removed">- #define FRAME_SLOT_BCP 7</span>
<span class="line-removed">-         meth = (Method*)sim-&gt;getMemory()-&gt;loadU64(fp - (FRAME_SLOT_METHOD &lt;&lt; 3));</span>
<span class="line-removed">-         bcp = (address)sim-&gt;getMemory()-&gt;loadU64(fp - (FRAME_SLOT_BCP &lt;&lt; 3));</span>
<span class="line-removed">- #undef FRAME_SLOT_METHOD</span>
<span class="line-removed">- #undef FRAME_SLOT_BCP</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         meth = (Method*)sim-&gt;getCPUState().xreg(RMETHOD, 0);</span>
<span class="line-removed">-         bcp = (address)sim-&gt;getCPUState().xreg(RBCP, 0);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (meth-&gt;is_native()) {</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if(method &amp;&amp; meth-&gt;is_method()) {</span>
<span class="line-removed">-         ResourceMark rm;</span>
<span class="line-removed">-         method[0] = &#39;I&#39;;</span>
<span class="line-removed">-         method[1] = &#39; &#39;;</span>
<span class="line-removed">-         meth-&gt;name_and_sig_as_C_string(method + 2, 398);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (bcidx) {</span>
<span class="line-removed">-         if (meth-&gt;contains(bcp)) {</span>
<span class="line-removed">-           *bcidx = meth-&gt;bci_from(bcp);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           *bcidx = -2;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (decode) {</span>
<span class="line-removed">-         if (!BytecodeTracer::closure()) {</span>
<span class="line-removed">-           BytecodeTracer::set_closure(BytecodeTracer::std_closure());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         stringStream str(decode, 400);</span>
<span class="line-removed">-         BytecodeTracer::trace(meth, bcp, &amp;str);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       if (method) {</span>
<span class="line-removed">-         CodeBlob *cb = CodeCache::find_blob((address)pc);</span>
<span class="line-removed">-         if (cb != NULL) {</span>
<span class="line-removed">-           if (cb-&gt;is_nmethod()) {</span>
<span class="line-removed">-             ResourceMark rm;</span>
<span class="line-removed">-             nmethod* nm = (nmethod*)cb;</span>
<span class="line-removed">-             method[0] = &#39;C&#39;;</span>
<span class="line-removed">-             method[1] = &#39; &#39;;</span>
<span class="line-removed">-             nm-&gt;method()-&gt;name_and_sig_as_C_string(method + 2, 398);</span>
<span class="line-removed">-           } else if (cb-&gt;is_adapter_blob()) {</span>
<span class="line-removed">-             strcpy(method, &quot;B adapter blob&quot;);</span>
<span class="line-removed">-           } else if (cb-&gt;is_runtime_stub()) {</span>
<span class="line-removed">-             strcpy(method, &quot;B runtime stub&quot;);</span>
<span class="line-removed">-           } else if (cb-&gt;is_exception_stub()) {</span>
<span class="line-removed">-             strcpy(method, &quot;B exception stub&quot;);</span>
<span class="line-removed">-           } else if (cb-&gt;is_deoptimization_stub()) {</span>
<span class="line-removed">-             strcpy(method, &quot;B deoptimization stub&quot;);</span>
<span class="line-removed">-           } else if (cb-&gt;is_safepoint_stub()) {</span>
<span class="line-removed">-             strcpy(method, &quot;B safepoint stub&quot;);</span>
<span class="line-removed">-           } else if (cb-&gt;is_uncommon_trap_stub()) {</span>
<span class="line-removed">-             strcpy(method, &quot;B uncommon trap stub&quot;);</span>
<span class="line-removed">-           } else if (cb-&gt;contains((address)StubRoutines::call_stub())) {</span>
<span class="line-removed">-             strcpy(method, &quot;B call stub&quot;);</span>
<span class="line-removed">-           } else {</span>
<span class="line-removed">-             strcpy(method, &quot;B unknown blob : &quot;);</span>
<span class="line-removed">-             strcat(method, cb-&gt;name());</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           if (framesize != NULL) {</span>
<span class="line-removed">-             *framesize = cb-&gt;frame_size();</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-   JNIEXPORT void bccheck(u_int64_t pc, u_int64_t fp, char *method, int *bcidx, int *framesize, char *decode)</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     bccheck1(pc, fp, method, bcidx, framesize, decode);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif // BUILTIN_SIM</span>
  #endif // !PRODUCT
<span class="line-new-header">--- 2048,6 ---</span>
</pre>
<center><a href="stubRoutines_aarch64.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRGenerator_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Runtime1_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 28 #include &quot;c1/c1_Runtime1.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
 31 #include &quot;interpreter/interpreter.hpp&quot;
 32 #include &quot;oops/arrayOop.hpp&quot;
<span class="line-modified"> 33 #include &quot;oops/markOop.hpp&quot;</span>
 34 #include &quot;runtime/basicLock.hpp&quot;
 35 #include &quot;runtime/biasedLocking.hpp&quot;
 36 #include &quot;runtime/os.hpp&quot;
 37 #include &quot;runtime/sharedRuntime.hpp&quot;
 38 #include &quot;runtime/stubRoutines.hpp&quot;
 39 
 40 void C1_MacroAssembler::float_cmp(bool is_float, int unordered_result,
 41                                   FloatRegister f0, FloatRegister f1,
 42                                   Register result)
 43 {
 44   Label done;
 45   if (is_float) {
 46     fcmps(f0, f1);
 47   } else {
 48     fcmpd(f0, f1);
 49   }
 50   if (unordered_result &lt; 0) {
 51     // we want -1 for unordered or less than, 0 for equal and 1 for
 52     // greater than.
 53     cset(result, NE);  // Not equal or unordered
</pre>
<hr />
<pre>
 65   const int hdr_offset = oopDesc::mark_offset_in_bytes();
 66   assert(hdr != obj &amp;&amp; hdr != disp_hdr &amp;&amp; obj != disp_hdr, &quot;registers must be different&quot;);
 67   Label done;
 68   int null_check_offset = -1;
 69 
 70   verify_oop(obj);
 71 
 72   // save object being locked into the BasicObjectLock
 73   str(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));
 74 
 75   if (UseBiasedLocking) {
 76     assert(scratch != noreg, &quot;should have scratch register at this point&quot;);
 77     null_check_offset = biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &amp;slow_case);
 78   } else {
 79     null_check_offset = offset();
 80   }
 81 
 82   // Load object header
 83   ldr(hdr, Address(obj, hdr_offset));
 84   // and mark it as unlocked
<span class="line-modified"> 85   orr(hdr, hdr, markOopDesc::unlocked_value);</span>
 86   // save unlocked object header into the displaced header location on the stack
 87   str(hdr, Address(disp_hdr, 0));
 88   // test if object header is still the same (i.e. unlocked), and if so, store the
 89   // displaced header address in the object header - if it is not the same, get the
 90   // object header instead
 91   lea(rscratch2, Address(obj, hdr_offset));
 92   cmpxchgptr(hdr, disp_hdr, rscratch2, rscratch1, done, /*fallthough*/NULL);
 93   // if the object header was the same, we&#39;re done
 94   // if the object header was not the same, it is now in the hdr register
 95   // =&gt; test if it is a stack pointer into the same stack (recursive locking), i.e.:
 96   //
 97   // 1) (hdr &amp; aligned_mask) == 0
 98   // 2) sp &lt;= hdr
 99   // 3) hdr &lt;= sp + page_size
100   //
101   // these 3 tests can be done by evaluating the following expression:
102   //
103   // (hdr - sp) &amp; (aligned_mask - page_size)
104   //
105   // assuming both the stack pointer and page_size have their least
</pre>
<hr />
<pre>
159   bind(done);
160 }
161 
162 
163 // Defines obj, preserves var_size_in_bytes
164 void C1_MacroAssembler::try_allocate(Register obj, Register var_size_in_bytes, int con_size_in_bytes, Register t1, Register t2, Label&amp; slow_case) {
165   if (UseTLAB) {
166     tlab_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
167   } else {
168     eden_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
169   }
170 }
171 
172 void C1_MacroAssembler::initialize_header(Register obj, Register klass, Register len, Register t1, Register t2) {
173   assert_different_registers(obj, klass, len);
174   if (UseBiasedLocking &amp;&amp; !len-&gt;is_valid()) {
175     assert_different_registers(obj, klass, len, t1, t2);
176     ldr(t1, Address(klass, Klass::prototype_header_offset()));
177   } else {
178     // This assumes that all prototype bits fit in an int32_t
<span class="line-modified">179     mov(t1, (int32_t)(intptr_t)markOopDesc::prototype());</span>
180   }
181   str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));
182 
183   if (UseCompressedClassPointers) { // Take care not to kill klass
184     encode_klass_not_null(t1, klass);
185     strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));
186   } else {
187     str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));
188   }
189 
190   if (len-&gt;is_valid()) {
191     strw(len, Address(obj, arrayOopDesc::length_offset_in_bytes()));
192   } else if (UseCompressedClassPointers) {
193     store_klass_gap(obj, zr);
194   }
195 }
196 
197 // preserves obj, destroys len_in_bytes
198 void C1_MacroAssembler::initialize_body(Register obj, Register len_in_bytes, int hdr_size_in_bytes, Register t1) {
199   assert(hdr_size_in_bytes &gt;= 0, &quot;header size must be positive or 0&quot;);
</pre>
<hr />
<pre>
314   if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
315     assert(obj == r0, &quot;must be&quot;);
316     far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)));
317   }
318 
319   verify_oop(obj);
320 }
321 
322 
323 void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
324   verify_oop(receiver);
325   // explicit NULL check not needed since load from [klass_offset] causes a trap
326   // check against inline cache
327   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), &quot;must add explicit null check&quot;);
328 
329   cmp_klass(receiver, iCache, rscratch1);
330 }
331 
332 
333 void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes) {
<span class="line-removed">334   // If we have to make this method not-entrant we&#39;ll overwrite its</span>
<span class="line-removed">335   // first instruction with a jump.  For this action to be legal we</span>
<span class="line-removed">336   // must ensure that this first instruction is a B, BL, NOP, BKPT,</span>
<span class="line-removed">337   // SVC, HVC, or SMC.  Make it a NOP.</span>
<span class="line-removed">338   nop();</span>
339   assert(bang_size_in_bytes &gt;= framesize, &quot;stack bang size incorrect&quot;);
340   // Make sure there is enough stack space for this method&#39;s activation.
341   // Note that we do this before doing an enter().
342   generate_stack_overflow_check(bang_size_in_bytes);
343   MacroAssembler::build_frame(framesize + 2 * wordSize);
<span class="line-removed">344   if (NotifySimulator) {</span>
<span class="line-removed">345     notify(Assembler::method_entry);</span>
<span class="line-removed">346   }</span>
347 }
348 
349 void C1_MacroAssembler::remove_frame(int framesize) {
350   MacroAssembler::remove_frame(framesize + 2 * wordSize);
<span class="line-removed">351   if (NotifySimulator) {</span>
<span class="line-removed">352     notify(Assembler::method_reentry);</span>
<span class="line-removed">353   }</span>
354 }
355 
356 
357 void C1_MacroAssembler::verified_entry() {





358 }
359 
360 void C1_MacroAssembler::load_parameter(int offset_in_words, Register reg) {
361   // rbp, + 0: link
362   //     + 1: return address
363   //     + 2: argument with offset 0
364   //     + 3: argument with offset 1
365   //     + 4: ...
366 
367   ldr(reg, Address(rfp, (offset_in_words + 2) * BytesPerWord));
368 }
369 
370 #ifndef PRODUCT
371 
372 void C1_MacroAssembler::verify_stack_oop(int stack_offset) {
373   if (!VerifyOops) return;
374   verify_oop_addr(Address(sp, stack_offset), &quot;oop&quot;);
375 }
376 
377 void C1_MacroAssembler::verify_not_null_oop(Register r) {
</pre>
</td>
<td>
<hr />
<pre>
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 28 #include &quot;c1/c1_Runtime1.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
 31 #include &quot;interpreter/interpreter.hpp&quot;
 32 #include &quot;oops/arrayOop.hpp&quot;
<span class="line-modified"> 33 #include &quot;oops/markWord.hpp&quot;</span>
 34 #include &quot;runtime/basicLock.hpp&quot;
 35 #include &quot;runtime/biasedLocking.hpp&quot;
 36 #include &quot;runtime/os.hpp&quot;
 37 #include &quot;runtime/sharedRuntime.hpp&quot;
 38 #include &quot;runtime/stubRoutines.hpp&quot;
 39 
 40 void C1_MacroAssembler::float_cmp(bool is_float, int unordered_result,
 41                                   FloatRegister f0, FloatRegister f1,
 42                                   Register result)
 43 {
 44   Label done;
 45   if (is_float) {
 46     fcmps(f0, f1);
 47   } else {
 48     fcmpd(f0, f1);
 49   }
 50   if (unordered_result &lt; 0) {
 51     // we want -1 for unordered or less than, 0 for equal and 1 for
 52     // greater than.
 53     cset(result, NE);  // Not equal or unordered
</pre>
<hr />
<pre>
 65   const int hdr_offset = oopDesc::mark_offset_in_bytes();
 66   assert(hdr != obj &amp;&amp; hdr != disp_hdr &amp;&amp; obj != disp_hdr, &quot;registers must be different&quot;);
 67   Label done;
 68   int null_check_offset = -1;
 69 
 70   verify_oop(obj);
 71 
 72   // save object being locked into the BasicObjectLock
 73   str(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));
 74 
 75   if (UseBiasedLocking) {
 76     assert(scratch != noreg, &quot;should have scratch register at this point&quot;);
 77     null_check_offset = biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &amp;slow_case);
 78   } else {
 79     null_check_offset = offset();
 80   }
 81 
 82   // Load object header
 83   ldr(hdr, Address(obj, hdr_offset));
 84   // and mark it as unlocked
<span class="line-modified"> 85   orr(hdr, hdr, markWord::unlocked_value);</span>
 86   // save unlocked object header into the displaced header location on the stack
 87   str(hdr, Address(disp_hdr, 0));
 88   // test if object header is still the same (i.e. unlocked), and if so, store the
 89   // displaced header address in the object header - if it is not the same, get the
 90   // object header instead
 91   lea(rscratch2, Address(obj, hdr_offset));
 92   cmpxchgptr(hdr, disp_hdr, rscratch2, rscratch1, done, /*fallthough*/NULL);
 93   // if the object header was the same, we&#39;re done
 94   // if the object header was not the same, it is now in the hdr register
 95   // =&gt; test if it is a stack pointer into the same stack (recursive locking), i.e.:
 96   //
 97   // 1) (hdr &amp; aligned_mask) == 0
 98   // 2) sp &lt;= hdr
 99   // 3) hdr &lt;= sp + page_size
100   //
101   // these 3 tests can be done by evaluating the following expression:
102   //
103   // (hdr - sp) &amp; (aligned_mask - page_size)
104   //
105   // assuming both the stack pointer and page_size have their least
</pre>
<hr />
<pre>
159   bind(done);
160 }
161 
162 
163 // Defines obj, preserves var_size_in_bytes
164 void C1_MacroAssembler::try_allocate(Register obj, Register var_size_in_bytes, int con_size_in_bytes, Register t1, Register t2, Label&amp; slow_case) {
165   if (UseTLAB) {
166     tlab_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
167   } else {
168     eden_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
169   }
170 }
171 
172 void C1_MacroAssembler::initialize_header(Register obj, Register klass, Register len, Register t1, Register t2) {
173   assert_different_registers(obj, klass, len);
174   if (UseBiasedLocking &amp;&amp; !len-&gt;is_valid()) {
175     assert_different_registers(obj, klass, len, t1, t2);
176     ldr(t1, Address(klass, Klass::prototype_header_offset()));
177   } else {
178     // This assumes that all prototype bits fit in an int32_t
<span class="line-modified">179     mov(t1, (int32_t)(intptr_t)markWord::prototype().value());</span>
180   }
181   str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));
182 
183   if (UseCompressedClassPointers) { // Take care not to kill klass
184     encode_klass_not_null(t1, klass);
185     strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));
186   } else {
187     str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));
188   }
189 
190   if (len-&gt;is_valid()) {
191     strw(len, Address(obj, arrayOopDesc::length_offset_in_bytes()));
192   } else if (UseCompressedClassPointers) {
193     store_klass_gap(obj, zr);
194   }
195 }
196 
197 // preserves obj, destroys len_in_bytes
198 void C1_MacroAssembler::initialize_body(Register obj, Register len_in_bytes, int hdr_size_in_bytes, Register t1) {
199   assert(hdr_size_in_bytes &gt;= 0, &quot;header size must be positive or 0&quot;);
</pre>
<hr />
<pre>
314   if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
315     assert(obj == r0, &quot;must be&quot;);
316     far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)));
317   }
318 
319   verify_oop(obj);
320 }
321 
322 
323 void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
324   verify_oop(receiver);
325   // explicit NULL check not needed since load from [klass_offset] causes a trap
326   // check against inline cache
327   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), &quot;must add explicit null check&quot;);
328 
329   cmp_klass(receiver, iCache, rscratch1);
330 }
331 
332 
333 void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes) {





334   assert(bang_size_in_bytes &gt;= framesize, &quot;stack bang size incorrect&quot;);
335   // Make sure there is enough stack space for this method&#39;s activation.
336   // Note that we do this before doing an enter().
337   generate_stack_overflow_check(bang_size_in_bytes);
338   MacroAssembler::build_frame(framesize + 2 * wordSize);



339 }
340 
341 void C1_MacroAssembler::remove_frame(int framesize) {
342   MacroAssembler::remove_frame(framesize + 2 * wordSize);



343 }
344 
345 
346 void C1_MacroAssembler::verified_entry() {
<span class="line-added">347   // If we have to make this method not-entrant we&#39;ll overwrite its</span>
<span class="line-added">348   // first instruction with a jump.  For this action to be legal we</span>
<span class="line-added">349   // must ensure that this first instruction is a B, BL, NOP, BKPT,</span>
<span class="line-added">350   // SVC, HVC, or SMC.  Make it a NOP.</span>
<span class="line-added">351   nop();</span>
352 }
353 
354 void C1_MacroAssembler::load_parameter(int offset_in_words, Register reg) {
355   // rbp, + 0: link
356   //     + 1: return address
357   //     + 2: argument with offset 0
358   //     + 3: argument with offset 1
359   //     + 4: ...
360 
361   ldr(reg, Address(rfp, (offset_in_words + 2) * BytesPerWord));
362 }
363 
364 #ifndef PRODUCT
365 
366 void C1_MacroAssembler::verify_stack_oop(int stack_offset) {
367   if (!VerifyOops) return;
368   verify_oop_addr(Address(sp, stack_offset), &quot;oop&quot;);
369 }
370 
371 void C1_MacroAssembler::verify_not_null_oop(Register r) {
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRGenerator_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Runtime1_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
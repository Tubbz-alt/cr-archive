diff a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -27,11 +27,10 @@
 #include "asm/macroAssembler.inline.hpp"
 #include "interpreter/interp_masm.hpp"
 #include "interpreter/interpreter.hpp"
 #include "interpreter/interpreterRuntime.hpp"
 #include "memory/allocation.inline.hpp"
-#include "memory/universe.hpp"
 #include "oops/method.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/icache.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
@@ -258,33 +257,10 @@
 
 void InterpreterRuntime::SignatureHandlerGenerator::generate(uint64_t fingerprint) {
   // generate code to handle arguments
   iterate(fingerprint);
 
-  // set the call format
-  // n.b. allow extra 1 for the JNI_Env in c_rarg0
-  unsigned int call_format = ((_num_int_args + 1) << 6) | (_num_fp_args << 2);
-
-  switch (method()->result_type()) {
-  case T_VOID:
-    call_format |= MacroAssembler::ret_type_void;
-    break;
-  case T_FLOAT:
-    call_format |= MacroAssembler::ret_type_float;
-    break;
-  case T_DOUBLE:
-    call_format |= MacroAssembler::ret_type_double;
-    break;
-  default:
-    call_format |= MacroAssembler::ret_type_integral;
-    break;
-  }
-
-  // // store the call format in the method
-  // __ movw(r0, call_format);
-  // __ str(r0, Address(rmethod, Method::call_format_offset()));
-
   // return result handler
   __ lea(r0, ExternalAddress(Interpreter::result_handler(method()->result_type())));
   __ ret(lr);
 
   __ flush();
@@ -391,36 +367,14 @@
     *(int*) _fp_identifiers = 0;
     _num_int_args = (method->is_static() ? 1 : 0);
     _num_fp_args = 0;
   }
 
-  // n.b. allow extra 1 for the JNI_Env in c_rarg0
-  unsigned int get_call_format()
-  {
-    unsigned int call_format = ((_num_int_args + 1) << 6) | (_num_fp_args << 2);
-
-    switch (method()->result_type()) {
-    case T_VOID:
-      call_format |= MacroAssembler::ret_type_void;
-      break;
-    case T_FLOAT:
-      call_format |= MacroAssembler::ret_type_float;
-      break;
-    case T_DOUBLE:
-      call_format |= MacroAssembler::ret_type_double;
-      break;
-    default:
-      call_format |= MacroAssembler::ret_type_integral;
-      break;
-    }
-
-    return call_format;
-  }
 };
 
 
-IRT_ENTRY(address,
+JRT_ENTRY(address,
           InterpreterRuntime::slow_signature_handler(JavaThread* thread,
                                                      Method* method,
                                                      intptr_t* from,
                                                      intptr_t* to))
   methodHandle m(thread, (Method*)method);
@@ -428,11 +382,8 @@
 
   // handle arguments
   SlowSignatureHandler ssh(m, (address)from, to);
   ssh.iterate(UCONST64(-1));
 
-  // // set the call format
-  // method->set_call_format(ssh.get_call_format());
-
   // return result handler
   return Interpreter::result_handler(m->result_type());
-IRT_END
+JRT_END

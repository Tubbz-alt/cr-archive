<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../.mx.jvmci/suite.py.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aarch64Test.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,8 +1,8 @@</span>
  //
<span class="udiff-line-modified-removed">- // Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-removed">- // Copyright (c) 2014, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+ // Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+ // Copyright (c) 2014, 2020, Red Hat, Inc. All rights reserved.</span>
  // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  //
  // This code is free software; you can redistribute it and/or modify it
  // under the terms of the GNU General Public License version 2 only, as
  // published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -126,12 +126,12 @@</span>
  reg_def R24_H   ( SOC, SOE, Op_RegI, 24, r24-&gt;as_VMReg()-&gt;next());
  reg_def R25     ( SOC, SOE, Op_RegI, 25, r25-&gt;as_VMReg()        );
  reg_def R25_H   ( SOC, SOE, Op_RegI, 25, r25-&gt;as_VMReg()-&gt;next());
  reg_def R26     ( SOC, SOE, Op_RegI, 26, r26-&gt;as_VMReg()        );
  reg_def R26_H   ( SOC, SOE, Op_RegI, 26, r26-&gt;as_VMReg()-&gt;next());
<span class="udiff-line-modified-removed">- reg_def R27     (  NS, SOE, Op_RegI, 27, r27-&gt;as_VMReg()        ); // heapbase</span>
<span class="udiff-line-modified-removed">- reg_def R27_H   (  NS, SOE, Op_RegI, 27, r27-&gt;as_VMReg()-&gt;next());</span>
<span class="udiff-line-modified-added">+ reg_def R27     ( SOC, SOE, Op_RegI, 27, r27-&gt;as_VMReg()        ); // heapbase</span>
<span class="udiff-line-modified-added">+ reg_def R27_H   ( SOC, SOE, Op_RegI, 27, r27-&gt;as_VMReg()-&gt;next());</span>
  reg_def R28     (  NS, SOE, Op_RegI, 28, r28-&gt;as_VMReg()        ); // thread
  reg_def R28_H   (  NS, SOE, Op_RegI, 28, r28-&gt;as_VMReg()-&gt;next());
  reg_def R29     (  NS,  NS, Op_RegI, 29, r29-&gt;as_VMReg()        ); // fp
  reg_def R29_H   (  NS,  NS, Op_RegI, 29, r29-&gt;as_VMReg()-&gt;next());
  reg_def R30     (  NS,  NS, Op_RegI, 30, r30-&gt;as_VMReg()        ); // lr
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -433,13 +433,12 @@</span>
  // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  //
  
<span class="udiff-line-modified-removed">- // Class for all 32 bit integer registers -- excludes SP which will</span>
<span class="udiff-line-modified-removed">- // never be used as an integer register</span>
<span class="udiff-line-removed">- reg_class any_reg32(</span>
<span class="udiff-line-modified-added">+ // Class for all 32 bit general purpose registers</span>
<span class="udiff-line-modified-added">+ reg_class all_reg32(</span>
      R0,
      R1,
      R2,
      R3,
      R4,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -464,13 +463,21 @@</span>
      R25,
      R26,
      R27,
      R28,
      R29,
<span class="udiff-line-modified-removed">-     R30</span>
<span class="udiff-line-modified-added">+     R30,</span>
<span class="udiff-line-added">+     R31</span>
  );
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for all 32 bit integer registers (excluding SP which</span>
<span class="udiff-line-added">+ // will never be used as an integer register)</span>
<span class="udiff-line-added">+ reg_class any_reg32 %{</span>
<span class="udiff-line-added">+   return _ANY_REG32_mask;</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
  // Singleton class for R0 int register
  reg_class int_r0_reg(R0);
  
  // Singleton class for R2 int register
  reg_class int_r2_reg(R2);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -479,12 +486,15 @@</span>
  reg_class int_r3_reg(R3);
  
  // Singleton class for R4 int register
  reg_class int_r4_reg(R4);
  
<span class="udiff-line-modified-removed">- // Class for all long integer registers (including RSP)</span>
<span class="udiff-line-modified-removed">- reg_class any_reg(</span>
<span class="udiff-line-modified-added">+ // Singleton class for R31 int register</span>
<span class="udiff-line-modified-added">+ reg_class int_r31_reg(R31);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for all 64 bit general purpose registers</span>
<span class="udiff-line-added">+ reg_class all_reg(</span>
      R0, R0_H,
      R1, R1_H,
      R2, R2_H,
      R3, R3_H,
      R4, R4_H,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -513,147 +523,38 @@</span>
      R29, R29_H,
      R30, R30_H,
      R31, R31_H
  );
  
<span class="udiff-line-modified-removed">- // Class for all non-special integer registers</span>
<span class="udiff-line-modified-removed">- reg_class no_special_reg32_no_fp(</span>
<span class="udiff-line-modified-removed">-     R0,</span>
<span class="udiff-line-modified-removed">-     R1,</span>
<span class="udiff-line-removed">-     R2,</span>
<span class="udiff-line-removed">-     R3,</span>
<span class="udiff-line-removed">-     R4,</span>
<span class="udiff-line-removed">-     R5,</span>
<span class="udiff-line-removed">-     R6,</span>
<span class="udiff-line-removed">-     R7,</span>
<span class="udiff-line-removed">-     R10,</span>
<span class="udiff-line-removed">-     R11,</span>
<span class="udiff-line-removed">-     R12,                        // rmethod</span>
<span class="udiff-line-removed">-     R13,</span>
<span class="udiff-line-removed">-     R14,</span>
<span class="udiff-line-removed">-     R15,</span>
<span class="udiff-line-removed">-     R16,</span>
<span class="udiff-line-removed">-     R17,</span>
<span class="udiff-line-removed">-     R18,</span>
<span class="udiff-line-removed">-     R19,</span>
<span class="udiff-line-removed">-     R20,</span>
<span class="udiff-line-removed">-     R21,</span>
<span class="udiff-line-removed">-     R22,</span>
<span class="udiff-line-removed">-     R23,</span>
<span class="udiff-line-removed">-     R24,</span>
<span class="udiff-line-removed">-     R25,</span>
<span class="udiff-line-removed">-     R26</span>
<span class="udiff-line-removed">-  /* R27, */                     // heapbase</span>
<span class="udiff-line-removed">-  /* R28, */                     // thread</span>
<span class="udiff-line-removed">-  /* R29, */                     // fp</span>
<span class="udiff-line-removed">-  /* R30, */                     // lr</span>
<span class="udiff-line-removed">-  /* R31 */                      // sp</span>
<span class="udiff-line-removed">- );</span>
<span class="udiff-line-modified-added">+ // Class for all long integer registers (including SP)</span>
<span class="udiff-line-modified-added">+ reg_class any_reg %{</span>
<span class="udiff-line-modified-added">+   return _ANY_REG_mask;</span>
<span class="udiff-line-modified-added">+ %}</span>
  
<span class="udiff-line-modified-removed">- reg_class no_special_reg32_with_fp(</span>
<span class="udiff-line-modified-removed">-     R0,</span>
<span class="udiff-line-modified-removed">-     R1,</span>
<span class="udiff-line-modified-removed">-     R2,</span>
<span class="udiff-line-modified-removed">-     R3,</span>
<span class="udiff-line-removed">-     R4,</span>
<span class="udiff-line-removed">-     R5,</span>
<span class="udiff-line-removed">-     R6,</span>
<span class="udiff-line-removed">-     R7,</span>
<span class="udiff-line-removed">-     R10,</span>
<span class="udiff-line-removed">-     R11,</span>
<span class="udiff-line-removed">-     R12,                        // rmethod</span>
<span class="udiff-line-removed">-     R13,</span>
<span class="udiff-line-removed">-     R14,</span>
<span class="udiff-line-removed">-     R15,</span>
<span class="udiff-line-removed">-     R16,</span>
<span class="udiff-line-removed">-     R17,</span>
<span class="udiff-line-removed">-     R18,</span>
<span class="udiff-line-removed">-     R19,</span>
<span class="udiff-line-removed">-     R20,</span>
<span class="udiff-line-removed">-     R21,</span>
<span class="udiff-line-removed">-     R22,</span>
<span class="udiff-line-removed">-     R23,</span>
<span class="udiff-line-removed">-     R24,</span>
<span class="udiff-line-removed">-     R25,</span>
<span class="udiff-line-removed">-     R26</span>
<span class="udiff-line-removed">-  /* R27, */                     // heapbase</span>
<span class="udiff-line-removed">-  /* R28, */                     // thread</span>
<span class="udiff-line-removed">-     R29,                        // fp</span>
<span class="udiff-line-removed">-  /* R30, */                     // lr</span>
<span class="udiff-line-removed">-  /* R31 */                      // sp</span>
<span class="udiff-line-modified-added">+ // Class for non-allocatable 32 bit registers</span>
<span class="udiff-line-modified-added">+ reg_class non_allocatable_reg32(</span>
<span class="udiff-line-modified-added">+     R28,                        // thread</span>
<span class="udiff-line-modified-added">+     R30,                        // lr</span>
<span class="udiff-line-modified-added">+     R31                         // sp</span>
  );
  
<span class="udiff-line-modified-removed">- reg_class_dynamic no_special_reg32(no_special_reg32_no_fp, no_special_reg32_with_fp, %{ PreserveFramePointer %});</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- // Class for all non-special long integer registers</span>
<span class="udiff-line-modified-removed">- reg_class no_special_reg_no_fp(</span>
<span class="udiff-line-modified-removed">-     R0, R0_H,</span>
<span class="udiff-line-removed">-     R1, R1_H,</span>
<span class="udiff-line-removed">-     R2, R2_H,</span>
<span class="udiff-line-removed">-     R3, R3_H,</span>
<span class="udiff-line-removed">-     R4, R4_H,</span>
<span class="udiff-line-removed">-     R5, R5_H,</span>
<span class="udiff-line-removed">-     R6, R6_H,</span>
<span class="udiff-line-removed">-     R7, R7_H,</span>
<span class="udiff-line-removed">-     R10, R10_H,</span>
<span class="udiff-line-removed">-     R11, R11_H,</span>
<span class="udiff-line-removed">-     R12, R12_H,                 // rmethod</span>
<span class="udiff-line-removed">-     R13, R13_H,</span>
<span class="udiff-line-removed">-     R14, R14_H,</span>
<span class="udiff-line-removed">-     R15, R15_H,</span>
<span class="udiff-line-removed">-     R16, R16_H,</span>
<span class="udiff-line-removed">-     R17, R17_H,</span>
<span class="udiff-line-removed">-     R18, R18_H,</span>
<span class="udiff-line-removed">-     R19, R19_H,</span>
<span class="udiff-line-removed">-     R20, R20_H,</span>
<span class="udiff-line-removed">-     R21, R21_H,</span>
<span class="udiff-line-removed">-     R22, R22_H,</span>
<span class="udiff-line-removed">-     R23, R23_H,</span>
<span class="udiff-line-removed">-     R24, R24_H,</span>
<span class="udiff-line-removed">-     R25, R25_H,</span>
<span class="udiff-line-removed">-     R26, R26_H,</span>
<span class="udiff-line-removed">-  /* R27, R27_H, */              // heapbase</span>
<span class="udiff-line-removed">-  /* R28, R28_H, */              // thread</span>
<span class="udiff-line-removed">-  /* R29, R29_H, */              // fp</span>
<span class="udiff-line-removed">-  /* R30, R30_H, */              // lr</span>
<span class="udiff-line-removed">-  /* R31, R31_H */               // sp</span>
<span class="udiff-line-modified-added">+ // Class for non-allocatable 64 bit registers</span>
<span class="udiff-line-modified-added">+ reg_class non_allocatable_reg(</span>
<span class="udiff-line-modified-added">+     R28, R28_H,                 // thread</span>
<span class="udiff-line-modified-added">+     R30, R30_H,                 // lr</span>
<span class="udiff-line-modified-added">+     R31, R31_H                  // sp</span>
  );
  
<span class="udiff-line-modified-removed">- reg_class no_special_reg_with_fp(</span>
<span class="udiff-line-modified-removed">-     R0, R0_H,</span>
<span class="udiff-line-modified-removed">-     R1, R1_H,</span>
<span class="udiff-line-modified-removed">-     R2, R2_H,</span>
<span class="udiff-line-removed">-     R3, R3_H,</span>
<span class="udiff-line-removed">-     R4, R4_H,</span>
<span class="udiff-line-removed">-     R5, R5_H,</span>
<span class="udiff-line-removed">-     R6, R6_H,</span>
<span class="udiff-line-removed">-     R7, R7_H,</span>
<span class="udiff-line-removed">-     R10, R10_H,</span>
<span class="udiff-line-removed">-     R11, R11_H,</span>
<span class="udiff-line-removed">-     R12, R12_H,                 // rmethod</span>
<span class="udiff-line-removed">-     R13, R13_H,</span>
<span class="udiff-line-removed">-     R14, R14_H,</span>
<span class="udiff-line-removed">-     R15, R15_H,</span>
<span class="udiff-line-removed">-     R16, R16_H,</span>
<span class="udiff-line-removed">-     R17, R17_H,</span>
<span class="udiff-line-removed">-     R18, R18_H,</span>
<span class="udiff-line-removed">-     R19, R19_H,</span>
<span class="udiff-line-removed">-     R20, R20_H,</span>
<span class="udiff-line-removed">-     R21, R21_H,</span>
<span class="udiff-line-removed">-     R22, R22_H,</span>
<span class="udiff-line-removed">-     R23, R23_H,</span>
<span class="udiff-line-removed">-     R24, R24_H,</span>
<span class="udiff-line-removed">-     R25, R25_H,</span>
<span class="udiff-line-removed">-     R26, R26_H,</span>
<span class="udiff-line-removed">-  /* R27, R27_H, */              // heapbase</span>
<span class="udiff-line-removed">-  /* R28, R28_H, */              // thread</span>
<span class="udiff-line-removed">-     R29, R29_H,                 // fp</span>
<span class="udiff-line-removed">-  /* R30, R30_H, */              // lr</span>
<span class="udiff-line-removed">-  /* R31, R31_H */               // sp</span>
<span class="udiff-line-removed">- );</span>
<span class="udiff-line-modified-added">+ // Class for all non-special integer registers</span>
<span class="udiff-line-modified-added">+ reg_class no_special_reg32 %{</span>
<span class="udiff-line-modified-added">+   return _NO_SPECIAL_REG32_mask;</span>
<span class="udiff-line-modified-added">+ %}</span>
  
<span class="udiff-line-modified-removed">- reg_class_dynamic no_special_reg(no_special_reg_no_fp, no_special_reg_with_fp, %{ PreserveFramePointer %});</span>
<span class="udiff-line-modified-added">+ // Class for all non-special long integer registers</span>
<span class="udiff-line-added">+ reg_class no_special_reg %{</span>
<span class="udiff-line-added">+   return _NO_SPECIAL_REG_mask;</span>
<span class="udiff-line-added">+ %}</span>
  
  // Class for 64 bit register r0
  reg_class r0_reg(
      R0, R0_H
  );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -722,76 +623,18 @@</span>
  reg_class sp_reg(
    R31, R31_H
  );
  
  // Class for all pointer registers
<span class="udiff-line-modified-removed">- reg_class ptr_reg(</span>
<span class="udiff-line-modified-removed">-     R0, R0_H,</span>
<span class="udiff-line-modified-removed">-     R1, R1_H,</span>
<span class="udiff-line-removed">-     R2, R2_H,</span>
<span class="udiff-line-removed">-     R3, R3_H,</span>
<span class="udiff-line-removed">-     R4, R4_H,</span>
<span class="udiff-line-removed">-     R5, R5_H,</span>
<span class="udiff-line-removed">-     R6, R6_H,</span>
<span class="udiff-line-removed">-     R7, R7_H,</span>
<span class="udiff-line-removed">-     R10, R10_H,</span>
<span class="udiff-line-removed">-     R11, R11_H,</span>
<span class="udiff-line-removed">-     R12, R12_H,</span>
<span class="udiff-line-removed">-     R13, R13_H,</span>
<span class="udiff-line-removed">-     R14, R14_H,</span>
<span class="udiff-line-removed">-     R15, R15_H,</span>
<span class="udiff-line-removed">-     R16, R16_H,</span>
<span class="udiff-line-removed">-     R17, R17_H,</span>
<span class="udiff-line-removed">-     R18, R18_H,</span>
<span class="udiff-line-removed">-     R19, R19_H,</span>
<span class="udiff-line-removed">-     R20, R20_H,</span>
<span class="udiff-line-removed">-     R21, R21_H,</span>
<span class="udiff-line-removed">-     R22, R22_H,</span>
<span class="udiff-line-removed">-     R23, R23_H,</span>
<span class="udiff-line-removed">-     R24, R24_H,</span>
<span class="udiff-line-removed">-     R25, R25_H,</span>
<span class="udiff-line-removed">-     R26, R26_H,</span>
<span class="udiff-line-removed">-     R27, R27_H,</span>
<span class="udiff-line-removed">-     R28, R28_H,</span>
<span class="udiff-line-removed">-     R29, R29_H,</span>
<span class="udiff-line-removed">-     R30, R30_H,</span>
<span class="udiff-line-removed">-     R31, R31_H</span>
<span class="udiff-line-removed">- );</span>
<span class="udiff-line-modified-added">+ reg_class ptr_reg %{</span>
<span class="udiff-line-modified-added">+   return _PTR_REG_mask;</span>
<span class="udiff-line-modified-added">+ %}</span>
  
  // Class for all non_special pointer registers
<span class="udiff-line-modified-removed">- reg_class no_special_ptr_reg(</span>
<span class="udiff-line-modified-removed">-     R0, R0_H,</span>
<span class="udiff-line-modified-removed">-     R1, R1_H,</span>
<span class="udiff-line-removed">-     R2, R2_H,</span>
<span class="udiff-line-removed">-     R3, R3_H,</span>
<span class="udiff-line-removed">-     R4, R4_H,</span>
<span class="udiff-line-removed">-     R5, R5_H,</span>
<span class="udiff-line-removed">-     R6, R6_H,</span>
<span class="udiff-line-removed">-     R7, R7_H,</span>
<span class="udiff-line-removed">-     R10, R10_H,</span>
<span class="udiff-line-removed">-     R11, R11_H,</span>
<span class="udiff-line-removed">-     R12, R12_H,</span>
<span class="udiff-line-removed">-     R13, R13_H,</span>
<span class="udiff-line-removed">-     R14, R14_H,</span>
<span class="udiff-line-removed">-     R15, R15_H,</span>
<span class="udiff-line-removed">-     R16, R16_H,</span>
<span class="udiff-line-removed">-     R17, R17_H,</span>
<span class="udiff-line-removed">-     R18, R18_H,</span>
<span class="udiff-line-removed">-     R19, R19_H,</span>
<span class="udiff-line-removed">-     R20, R20_H,</span>
<span class="udiff-line-removed">-     R21, R21_H,</span>
<span class="udiff-line-removed">-     R22, R22_H,</span>
<span class="udiff-line-removed">-     R23, R23_H,</span>
<span class="udiff-line-removed">-     R24, R24_H,</span>
<span class="udiff-line-removed">-     R25, R25_H,</span>
<span class="udiff-line-removed">-     R26, R26_H,</span>
<span class="udiff-line-removed">-  /* R27, R27_H, */              // heapbase</span>
<span class="udiff-line-removed">-  /* R28, R28_H, */              // thread</span>
<span class="udiff-line-removed">-  /* R29, R29_H, */              // fp</span>
<span class="udiff-line-removed">-  /* R30, R30_H, */              // lr</span>
<span class="udiff-line-removed">-  /* R31, R31_H */               // sp</span>
<span class="udiff-line-removed">- );</span>
<span class="udiff-line-modified-added">+ reg_class no_special_ptr_reg %{</span>
<span class="udiff-line-modified-added">+   return _NO_SPECIAL_PTR_REG_mask;</span>
<span class="udiff-line-modified-added">+ %}</span>
  
  // Class for all float registers
  reg_class float_reg(
      V0,
      V1,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -955,10 +798,150 @@</span>
  // Class for 128 bit register v3
  reg_class v3_reg(
      V3, V3_H
  );
  
<span class="udiff-line-added">+ // Class for 128 bit register v4</span>
<span class="udiff-line-added">+ reg_class v4_reg(</span>
<span class="udiff-line-added">+     V4, V4_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v5</span>
<span class="udiff-line-added">+ reg_class v5_reg(</span>
<span class="udiff-line-added">+     V5, V5_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v6</span>
<span class="udiff-line-added">+ reg_class v6_reg(</span>
<span class="udiff-line-added">+     V6, V6_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v7</span>
<span class="udiff-line-added">+ reg_class v7_reg(</span>
<span class="udiff-line-added">+     V7, V7_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v8</span>
<span class="udiff-line-added">+ reg_class v8_reg(</span>
<span class="udiff-line-added">+     V8, V8_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v9</span>
<span class="udiff-line-added">+ reg_class v9_reg(</span>
<span class="udiff-line-added">+     V9, V9_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v10</span>
<span class="udiff-line-added">+ reg_class v10_reg(</span>
<span class="udiff-line-added">+     V10, V10_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v11</span>
<span class="udiff-line-added">+ reg_class v11_reg(</span>
<span class="udiff-line-added">+     V11, V11_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v12</span>
<span class="udiff-line-added">+ reg_class v12_reg(</span>
<span class="udiff-line-added">+     V12, V12_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v13</span>
<span class="udiff-line-added">+ reg_class v13_reg(</span>
<span class="udiff-line-added">+     V13, V13_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v14</span>
<span class="udiff-line-added">+ reg_class v14_reg(</span>
<span class="udiff-line-added">+     V14, V14_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v15</span>
<span class="udiff-line-added">+ reg_class v15_reg(</span>
<span class="udiff-line-added">+     V15, V15_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v16</span>
<span class="udiff-line-added">+ reg_class v16_reg(</span>
<span class="udiff-line-added">+     V16, V16_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v17</span>
<span class="udiff-line-added">+ reg_class v17_reg(</span>
<span class="udiff-line-added">+     V17, V17_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v18</span>
<span class="udiff-line-added">+ reg_class v18_reg(</span>
<span class="udiff-line-added">+     V18, V18_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v19</span>
<span class="udiff-line-added">+ reg_class v19_reg(</span>
<span class="udiff-line-added">+     V19, V19_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v20</span>
<span class="udiff-line-added">+ reg_class v20_reg(</span>
<span class="udiff-line-added">+     V20, V20_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v21</span>
<span class="udiff-line-added">+ reg_class v21_reg(</span>
<span class="udiff-line-added">+     V21, V21_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v22</span>
<span class="udiff-line-added">+ reg_class v22_reg(</span>
<span class="udiff-line-added">+     V22, V22_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v23</span>
<span class="udiff-line-added">+ reg_class v23_reg(</span>
<span class="udiff-line-added">+     V23, V23_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v24</span>
<span class="udiff-line-added">+ reg_class v24_reg(</span>
<span class="udiff-line-added">+     V24, V24_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v25</span>
<span class="udiff-line-added">+ reg_class v25_reg(</span>
<span class="udiff-line-added">+     V25, V25_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v26</span>
<span class="udiff-line-added">+ reg_class v26_reg(</span>
<span class="udiff-line-added">+     V26, V26_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v27</span>
<span class="udiff-line-added">+ reg_class v27_reg(</span>
<span class="udiff-line-added">+     V27, V27_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v28</span>
<span class="udiff-line-added">+ reg_class v28_reg(</span>
<span class="udiff-line-added">+     V28, V28_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v29</span>
<span class="udiff-line-added">+ reg_class v29_reg(</span>
<span class="udiff-line-added">+     V29, V29_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v30</span>
<span class="udiff-line-added">+ reg_class v30_reg(</span>
<span class="udiff-line-added">+     V30, V30_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Class for 128 bit register v31</span>
<span class="udiff-line-added">+ reg_class v31_reg(</span>
<span class="udiff-line-added">+     V31, V31_H</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ </span>
  // Singleton class for condition codes
  reg_class int_flags(RFLAGS);
  
  %}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -998,10 +981,18 @@</span>
  #include &quot;asm/macroAssembler.hpp&quot;
  #include &quot;gc/shared/cardTable.hpp&quot;
  #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;opto/addnode.hpp&quot;
<span class="udiff-line-added">+ #include &quot;opto/convertnode.hpp&quot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ extern RegMask _ANY_REG32_mask;</span>
<span class="udiff-line-added">+ extern RegMask _ANY_REG_mask;</span>
<span class="udiff-line-added">+ extern RegMask _PTR_REG_mask;</span>
<span class="udiff-line-added">+ extern RegMask _NO_SPECIAL_REG32_mask;</span>
<span class="udiff-line-added">+ extern RegMask _NO_SPECIAL_REG_mask;</span>
<span class="udiff-line-added">+ extern RegMask _NO_SPECIAL_PTR_REG_mask;</span>
  
  class CallStubImpl {
  
    //--------------------------------------------------------------
    //---&lt;  Used for optimization in Compile::shorten_branches  &gt;---
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1050,19 +1041,62 @@</span>
    bool needs_releasing_store(const Node *store);
  
    // predicate controlling translation of CompareAndSwapX
    bool needs_acquiring_load_exclusive(const Node *load);
  
<span class="udiff-line-removed">-   // predicate controlling translation of StoreCM</span>
<span class="udiff-line-removed">-   bool unnecessary_storestore(const Node *storecm);</span>
<span class="udiff-line-removed">- </span>
    // predicate controlling addressing modes
    bool size_fits_all_mem_uses(AddPNode* addp, int shift);
  %}
  
  source %{
  
<span class="udiff-line-added">+   // Derived RegMask with conditionally allocatable registers</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   RegMask _ANY_REG32_mask;</span>
<span class="udiff-line-added">+   RegMask _ANY_REG_mask;</span>
<span class="udiff-line-added">+   RegMask _PTR_REG_mask;</span>
<span class="udiff-line-added">+   RegMask _NO_SPECIAL_REG32_mask;</span>
<span class="udiff-line-added">+   RegMask _NO_SPECIAL_REG_mask;</span>
<span class="udiff-line-added">+   RegMask _NO_SPECIAL_PTR_REG_mask;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void reg_mask_init() {</span>
<span class="udiff-line-added">+     // We derive below RegMask(s) from the ones which are auto-generated from</span>
<span class="udiff-line-added">+     // adlc register classes to make AArch64 rheapbase (r27) and rfp (r29)</span>
<span class="udiff-line-added">+     // registers conditionally reserved.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _ANY_REG32_mask = _ALL_REG32_mask;</span>
<span class="udiff-line-added">+     _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r31_sp-&gt;as_VMReg()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _ANY_REG_mask = _ALL_REG_mask;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _PTR_REG_mask = _ALL_REG_mask;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _NO_SPECIAL_REG32_mask = _ALL_REG32_mask;</span>
<span class="udiff-line-added">+     _NO_SPECIAL_REG32_mask.SUBTRACT(_NON_ALLOCATABLE_REG32_mask);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _NO_SPECIAL_REG_mask = _ALL_REG_mask;</span>
<span class="udiff-line-added">+     _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;</span>
<span class="udiff-line-added">+     _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // r27 is not allocatable when compressed oops is on, compressed klass</span>
<span class="udiff-line-added">+     // pointers doesn&#39;t use r27 after JDK-8234794</span>
<span class="udiff-line-added">+     if (UseCompressedOops) {</span>
<span class="udiff-line-added">+       _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r27-&gt;as_VMReg()));</span>
<span class="udiff-line-added">+       _NO_SPECIAL_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);</span>
<span class="udiff-line-added">+       _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // r29 is not allocatable when PreserveFramePointer is on</span>
<span class="udiff-line-added">+     if (PreserveFramePointer) {</span>
<span class="udiff-line-added">+       _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r29-&gt;as_VMReg()));</span>
<span class="udiff-line-added">+       _NO_SPECIAL_REG_mask.SUBTRACT(_FP_REG_mask);</span>
<span class="udiff-line-added">+       _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_FP_REG_mask);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // Optimizaton of volatile gets and puts
    // -------------------------------------
    //
    // AArch64 has ldar&lt;x&gt; and stlr&lt;x&gt; instructions which we can safely
    // use to implement volatile reads and writes. For a volatile read
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1441,33 +1475,10 @@</span>
  
    // so we can just return true here
    return true;
  }
  
<span class="udiff-line-removed">- // predicate controlling translation of StoreCM</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // returns true if a StoreStore must precede the card write otherwise</span>
<span class="udiff-line-removed">- // false</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool unnecessary_storestore(const Node *storecm)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   assert(storecm-&gt;Opcode()  == Op_StoreCM, &quot;expecting a StoreCM&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // we need to generate a dmb ishst between an object put and the</span>
<span class="udiff-line-removed">-   // associated card mark when we are using CMS without conditional</span>
<span class="udiff-line-removed">-   // card marking</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (UseConcMarkSweepGC &amp;&amp; !UseCondCardMark) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // a storestore is unnecesary in all other cases</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  #define __ _masm.
  
  // advance declarations for helper functions to convert register
  // indices to register objects
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1500,11 +1511,11 @@</span>
    // for real runtime callouts it will be six instructions
    // see aarch64_enc_java_to_runtime
    //   adr(rscratch2, retaddr)
    //   lea(rscratch1, RuntimeAddress(addr)
    //   stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)))
<span class="udiff-line-modified-removed">-   //   blrt rscratch1</span>
<span class="udiff-line-modified-added">+   //   blr(rscratch1)</span>
    CodeBlob *cb = CodeCache::find_blob(_entry_point);
    if (cb) {
      return MacroAssembler::far_branch_size();
    } else {
      return 6 * NativeInstruction::instruction_size;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1619,20 +1630,27 @@</span>
  
    // insert a nop at the start of the prolog so we can patch in a
    // branch if we need to invalidate the method later
    __ nop();
  
<span class="udiff-line-modified-removed">-   int bangsize = C-&gt;bang_size_in_bytes();</span>
<span class="udiff-line-modified-removed">-   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
<span class="udiff-line-removed">-     __ generate_stack_overflow_check(bangsize);</span>
<span class="udiff-line-modified-added">+   if (C-&gt;clinit_barrier_on_entry()) {</span>
<span class="udiff-line-modified-added">+     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
  
<span class="udiff-line-modified-removed">-   __ build_frame(framesize);</span>
<span class="udiff-line-modified-added">+     Label L_skip_barrier;</span>
  
<span class="udiff-line-modified-removed">-   if (NotifySimulator) {</span>
<span class="udiff-line-modified-removed">-     __ notify(Assembler::method_entry);</span>
<span class="udiff-line-modified-added">+     __ mov_metadata(rscratch2, C-&gt;method()-&gt;holder()-&gt;constant_encoding());</span>
<span class="udiff-line-modified-added">+     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);</span>
<span class="udiff-line-added">+     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>
<span class="udiff-line-added">+     __ bind(L_skip_barrier);</span>
    }
  
<span class="udiff-line-added">+   int bangsize = C-&gt;bang_size_in_bytes();</span>
<span class="udiff-line-added">+   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
<span class="udiff-line-added">+     __ generate_stack_overflow_check(bangsize);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ build_frame(framesize);</span>
<span class="udiff-line-added">+ </span>
    if (VerifyStackAtCalls) {
      Unimplemented();
    }
  
    C-&gt;set_frame_complete(cbuf.insts_size());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1689,14 +1707,10 @@</span>
    MacroAssembler _masm(&amp;cbuf);
    int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
  
    __ remove_frame(framesize);
  
<span class="udiff-line-removed">-   if (NotifySimulator) {</span>
<span class="udiff-line-removed">-     __ notify(Assembler::method_reentry);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
      __ reserved_stack_check();
    }
  
    if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1738,17 +1752,18 @@</span>
      return rc_bad;
    }
  
    // we have 30 int registers * 2 halves
    // (rscratch1 and rscratch2 are omitted)
<span class="udiff-line-added">+   int slots_of_int_registers = RegisterImpl::max_slots_per_register * (RegisterImpl::number_of_registers - 2);</span>
  
<span class="udiff-line-modified-removed">-   if (reg &lt; 60) {</span>
<span class="udiff-line-modified-added">+   if (reg &lt; slots_of_int_registers) {</span>
      return rc_int;
    }
  
<span class="udiff-line-modified-removed">-   // we have 32 float register * 2 halves</span>
<span class="udiff-line-modified-removed">-   if (reg &lt; 60 + 128) {</span>
<span class="udiff-line-modified-added">+   // we have 32 float register * 4 halves</span>
<span class="udiff-line-modified-added">+   if (reg &lt; slots_of_int_registers + FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers) {</span>
      return rc_float;
    }
  
    // Between float regs &amp; stack is the flags regs.
    assert(OptoReg::is_stack(reg), &quot;blow up if spilling flags&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1960,11 +1975,11 @@</span>
  void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  {
    st-&gt;print_cr(&quot;# MachUEPNode&quot;);
    if (UseCompressedClassPointers) {
      st-&gt;print_cr(&quot;\tldrw rscratch1, j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
<span class="udiff-line-modified-removed">-     if (Universe::narrow_klass_shift() != 0) {</span>
<span class="udiff-line-modified-added">+     if (CompressedKlassPointers::shift() != 0) {</span>
        st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
      }
    } else {
     st-&gt;print_cr(&quot;\tldr rscratch1, j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2040,24 +2055,28 @@</span>
  // REQUIRED MATCHER CODE
  
  //=============================================================================
  
  const bool Matcher::match_rule_supported(int opcode) {
<span class="udiff-line-added">+   if (!has_match_rule(opcode))</span>
<span class="udiff-line-added">+     return false;</span>
  
<span class="udiff-line-added">+   bool ret_value = true;</span>
    switch (opcode) {
<span class="udiff-line-modified-removed">-   default:</span>
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   if (!has_match_rule(opcode)) {</span>
<span class="udiff-line-modified-removed">-     return false;</span>
<span class="udiff-line-modified-added">+     case Op_CacheWB:</span>
<span class="udiff-line-modified-added">+     case Op_CacheWBPreSync:</span>
<span class="udiff-line-modified-added">+     case Op_CacheWBPostSync:</span>
<span class="udiff-line-modified-added">+       if (!VM_Version::supports_data_cache_line_flush()) {</span>
<span class="udiff-line-modified-added">+         ret_value = false;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
    }
  
<span class="udiff-line-modified-removed">-   return true;  // Per default match rules are supported.</span>
<span class="udiff-line-modified-added">+   return ret_value; // Per default match rules are supported.</span>
  }
  
<span class="udiff-line-modified-removed">- const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {</span>
<span class="udiff-line-modified-added">+ const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {</span>
  
    // TODO
    // identify extra cases that we might want to provide match rules for
    // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
    bool ret_value = match_rule_supported(opcode);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2170,10 +2189,28 @@</span>
  
  // Do we need to mask the count passed to shift instructions or does
  // the cpu only look at the lower 5/6 bits anyway?
  const bool Matcher::need_masked_shift_count = false;
  
<span class="udiff-line-added">+ // No support for generic vector operands.</span>
<span class="udiff-line-added">+ const bool Matcher::supports_generic_vector_operands  = false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {</span>
<span class="udiff-line-added">+   ShouldNotReachHere(); // generic vector operands not supported</span>
<span class="udiff-line-added">+   return NULL;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool Matcher::is_generic_reg2reg_move(MachNode* m) {</span>
<span class="udiff-line-added">+   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool Matcher::is_generic_vector(MachOper* opnd)  {</span>
<span class="udiff-line-added">+   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // This affects two different things:
  //  - how Decode nodes are matched
  //  - how ImplicitNullCheck opportunities are recognized
  // If true, the matcher will try to remove all Decodes and match them
  // (as operands) into nodes. NullChecks are not prepared to deal with
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2181,27 +2218,27 @@</span>
  // If false, final_graph_reshaping() forces the decode behind the Cmp
  // for a NullCheck. The matcher matches the Decode node into a register.
  // Implicit_null_check optimization moves the Decode along with the
  // memory operation back up before the NullCheck.
  bool Matcher::narrow_oop_use_complex_address() {
<span class="udiff-line-modified-removed">-   return Universe::narrow_oop_shift() == 0;</span>
<span class="udiff-line-modified-added">+   return CompressedOops::shift() == 0;</span>
  }
  
  bool Matcher::narrow_klass_use_complex_address() {
  // TODO
  // decide whether we need to set this to true
    return false;
  }
  
  bool Matcher::const_oop_prefer_decode() {
    // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="udiff-line-modified-removed">-   return Universe::narrow_oop_base() == NULL;</span>
<span class="udiff-line-modified-added">+   return CompressedOops::base() == NULL;</span>
  }
  
  bool Matcher::const_klass_prefer_decode() {
    // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="udiff-line-modified-removed">-   return Universe::narrow_klass_base() == NULL;</span>
<span class="udiff-line-modified-added">+   return CompressedKlassPointers::base() == NULL;</span>
  }
  
  // Is it better to copy float constants, or load them directly from
  // memory?  Intel can load a float constant from a direct address,
  // requiring no extra registers.  Most RISCs will have to materialize
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2218,12 +2255,11 @@</span>
  // No-op on amd64
  void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
    Unimplemented();
  }
  
<span class="udiff-line-modified-removed">- // Advertise here if the CPU requires explicit rounding operations to</span>
<span class="udiff-line-removed">- // implement the UseStrictFP mode.</span>
<span class="udiff-line-modified-added">+ // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>
  const bool Matcher::strict_fp_requires_explicit_rounding = false;
  
  // Are floats converted to double when stored to stack during
  // deoptimization?
  bool Matcher::float_in_double() { return false; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2354,72 +2390,22 @@</span>
  }
  
  void Compile::reshape_address(AddPNode* addp) {
  }
  
<span class="udiff-line-removed">- // helper for encoding java_to_runtime calls on sim</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // this is needed to compute the extra arguments required when</span>
<span class="udiff-line-removed">- // planting a call to the simulator blrt instruction. the TypeFunc</span>
<span class="udiff-line-removed">- // can be queried to identify the counts for integral, and floating</span>
<span class="udiff-line-removed">- // arguments and the return type</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void getCallInfo(const TypeFunc *tf, int &amp;gpcnt, int &amp;fpcnt, int &amp;rtype)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   int gps = 0;</span>
<span class="udiff-line-removed">-   int fps = 0;</span>
<span class="udiff-line-removed">-   const TypeTuple *domain = tf-&gt;domain();</span>
<span class="udiff-line-removed">-   int max = domain-&gt;cnt();</span>
<span class="udiff-line-removed">-   for (int i = TypeFunc::Parms; i &lt; max; i++) {</span>
<span class="udiff-line-removed">-     const Type *t = domain-&gt;field_at(i);</span>
<span class="udiff-line-removed">-     switch(t-&gt;basic_type()) {</span>
<span class="udiff-line-removed">-     case T_FLOAT:</span>
<span class="udiff-line-removed">-     case T_DOUBLE:</span>
<span class="udiff-line-removed">-       fps++;</span>
<span class="udiff-line-removed">-     default:</span>
<span class="udiff-line-removed">-       gps++;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   gpcnt = gps;</span>
<span class="udiff-line-removed">-   fpcnt = fps;</span>
<span class="udiff-line-removed">-   BasicType rt = tf-&gt;return_type();</span>
<span class="udiff-line-removed">-   switch (rt) {</span>
<span class="udiff-line-removed">-   case T_VOID:</span>
<span class="udiff-line-removed">-     rtype = MacroAssembler::ret_type_void;</span>
<span class="udiff-line-removed">-     break;</span>
<span class="udiff-line-removed">-   default:</span>
<span class="udiff-line-removed">-     rtype = MacroAssembler::ret_type_integral;</span>
<span class="udiff-line-removed">-     break;</span>
<span class="udiff-line-removed">-   case T_FLOAT:</span>
<span class="udiff-line-removed">-     rtype = MacroAssembler::ret_type_float;</span>
<span class="udiff-line-removed">-     break;</span>
<span class="udiff-line-removed">-   case T_DOUBLE:</span>
<span class="udiff-line-removed">-     rtype = MacroAssembler::ret_type_double;</span>
<span class="udiff-line-removed">-     break;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
  
  #define MOV_VOLATILE(REG, BASE, INDEX, SCALE, DISP, SCRATCH, INSN)      \
    MacroAssembler _masm(&amp;cbuf);                                          \
    {                                                                     \
      guarantee(INDEX == -1, &quot;mode not permitted for volatile&quot;);          \
      guarantee(DISP == 0, &quot;mode not permitted for volatile&quot;);            \
      guarantee(SCALE == 0, &quot;mode not permitted for volatile&quot;);           \
      __ INSN(REG, as_Register(BASE));                                    \
    }
  
<span class="udiff-line-removed">- typedef void (MacroAssembler::* mem_insn)(Register Rt, const Address &amp;adr);</span>
<span class="udiff-line-removed">- typedef void (MacroAssembler::* mem_float_insn)(FloatRegister Rt, const Address &amp;adr);</span>
<span class="udiff-line-removed">- typedef void (MacroAssembler::* mem_vector_insn)(FloatRegister Rt,</span>
<span class="udiff-line-removed">-                                   MacroAssembler::SIMD_RegVariant T, const Address &amp;adr);</span>
  
<span class="udiff-line-modified-removed">-   // Used for all non-volatile memory accesses.  The use of</span>
<span class="udiff-line-removed">-   // $mem-&gt;opcode() to discover whether this pattern uses sign-extended</span>
<span class="udiff-line-removed">-   // offsets is something of a kludge.</span>
<span class="udiff-line-removed">-   static void loadStore(MacroAssembler masm, mem_insn insn,</span>
<span class="udiff-line-removed">-                          Register reg, int opcode,</span>
<span class="udiff-line-removed">-                          Register base, int index, int size, int disp)</span>
<span class="udiff-line-modified-added">+ static Address mem2address(int opcode, Register base, int index, int size, int disp)</span>
    {
      Address::extend scale;
  
      // Hooboy, this is fugly.  We need a way to communicate to the
      // encoder that the index needs to be sign extended, so we have to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2434,20 +2420,50 @@</span>
      default:
        scale = Address::lsl(size);
      }
  
      if (index == -1) {
<span class="udiff-line-modified-removed">-       (masm.*insn)(reg, Address(base, disp));</span>
<span class="udiff-line-modified-added">+       return Address(base, disp);</span>
      } else {
        assert(disp == 0, &quot;unsupported address mode: disp = %d&quot;, disp);
<span class="udiff-line-modified-removed">-       (masm.*insn)(reg, Address(base, as_Register(index), scale));</span>
<span class="udiff-line-modified-added">+       return Address(base, as_Register(index), scale);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ typedef void (MacroAssembler::* mem_insn)(Register Rt, const Address &amp;adr);</span>
<span class="udiff-line-added">+ typedef void (MacroAssembler::* mem_insn2)(Register Rt, Register adr);</span>
<span class="udiff-line-added">+ typedef void (MacroAssembler::* mem_float_insn)(FloatRegister Rt, const Address &amp;adr);</span>
<span class="udiff-line-added">+ typedef void (MacroAssembler::* mem_vector_insn)(FloatRegister Rt,</span>
<span class="udiff-line-added">+                                   MacroAssembler::SIMD_RegVariant T, const Address &amp;adr);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Used for all non-volatile memory accesses.  The use of</span>
<span class="udiff-line-added">+   // $mem-&gt;opcode() to discover whether this pattern uses sign-extended</span>
<span class="udiff-line-added">+   // offsets is something of a kludge.</span>
<span class="udiff-line-added">+   static void loadStore(MacroAssembler masm, mem_insn insn,</span>
<span class="udiff-line-added">+                         Register reg, int opcode,</span>
<span class="udiff-line-added">+                         Register base, int index, int scale, int disp,</span>
<span class="udiff-line-added">+                         int size_in_memory)</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     Address addr = mem2address(opcode, base, index, scale, disp);</span>
<span class="udiff-line-added">+     if (addr.getMode() == Address::base_plus_offset) {</span>
<span class="udiff-line-added">+       /* If we get an out-of-range offset it is a bug in the compiler,</span>
<span class="udiff-line-added">+          so we assert here. */</span>
<span class="udiff-line-added">+       assert(Address::offset_ok_for_immed(addr.offset(), exact_log2(size_in_memory)),</span>
<span class="udiff-line-added">+              &quot;c2 compiler bug&quot;);</span>
<span class="udiff-line-added">+       /* Fix up any out-of-range offsets. */</span>
<span class="udiff-line-added">+       assert_different_registers(rscratch1, base);</span>
<span class="udiff-line-added">+       assert_different_registers(rscratch1, reg);</span>
<span class="udiff-line-added">+       addr = masm.legitimize_address(addr, size_in_memory, rscratch1);</span>
      }
<span class="udiff-line-added">+     (masm.*insn)(reg, addr);</span>
    }
  
    static void loadStore(MacroAssembler masm, mem_float_insn insn,
<span class="udiff-line-modified-removed">-                          FloatRegister reg, int opcode,</span>
<span class="udiff-line-modified-removed">-                          Register base, int index, int size, int disp)</span>
<span class="udiff-line-modified-added">+                         FloatRegister reg, int opcode,</span>
<span class="udiff-line-modified-added">+                         Register base, int index, int size, int disp,</span>
<span class="udiff-line-added">+                         int size_in_memory)</span>
    {
      Address::extend scale;
  
      switch (opcode) {
      case INDINDEXSCALEDI2L:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2456,21 +2472,28 @@</span>
        break;
      default:
        scale = Address::lsl(size);
      }
  
<span class="udiff-line-modified-removed">-      if (index == -1) {</span>
<span class="udiff-line-modified-removed">-       (masm.*insn)(reg, Address(base, disp));</span>
<span class="udiff-line-modified-added">+     if (index == -1) {</span>
<span class="udiff-line-modified-added">+       /* If we get an out-of-range offset it is a bug in the compiler,</span>
<span class="udiff-line-added">+          so we assert here. */</span>
<span class="udiff-line-added">+       assert(Address::offset_ok_for_immed(disp, exact_log2(size_in_memory)), &quot;c2 compiler bug&quot;);</span>
<span class="udiff-line-added">+       /* Fix up any out-of-range offsets. */</span>
<span class="udiff-line-added">+       assert_different_registers(rscratch1, base);</span>
<span class="udiff-line-added">+       Address addr = Address(base, disp);</span>
<span class="udiff-line-added">+       addr = masm.legitimize_address(addr, size_in_memory, rscratch1);</span>
<span class="udiff-line-added">+       (masm.*insn)(reg, addr);</span>
      } else {
        assert(disp == 0, &quot;unsupported address mode: disp = %d&quot;, disp);
        (masm.*insn)(reg, Address(base, as_Register(index), scale));
      }
    }
  
    static void loadStore(MacroAssembler masm, mem_vector_insn insn,
<span class="udiff-line-modified-removed">-                          FloatRegister reg, MacroAssembler::SIMD_RegVariant T,</span>
<span class="udiff-line-modified-removed">-                          int opcode, Register base, int index, int size, int disp)</span>
<span class="udiff-line-modified-added">+                         FloatRegister reg, MacroAssembler::SIMD_RegVariant T,</span>
<span class="udiff-line-modified-added">+                         int opcode, Register base, int index, int size, int disp)</span>
    {
      if (index == -1) {
        (masm.*insn)(reg, T, Address(base, disp));
      } else {
        assert(disp == 0, &quot;unsupported address mode&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2523,185 +2546,264 @@</span>
      __ unimplemented(&quot;C2 catch all&quot;);
    %}
  
    // BEGIN Non-volatile memory access
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrsbw(iRegI dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrsbw(iRegI dst, memory1 mem) %{</span>
      Register dst_reg = as_Register($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsbw, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrsb(iRegI dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrsb(iRegI dst, memory1 mem) %{</span>
      Register dst_reg = as_Register($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsb, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrb(iRegI dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrb(iRegI dst, memory1 mem) %{</span>
      Register dst_reg = as_Register($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrb(iRegL dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrb(iRegL dst, memory1 mem) %{</span>
      Register dst_reg = as_Register($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrshw(iRegI dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrshw(iRegI dst, memory2 mem) %{</span>
      Register dst_reg = as_Register($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrshw, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrsh(iRegI dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrsh(iRegI dst, memory2 mem) %{</span>
      Register dst_reg = as_Register($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsh, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrh(iRegI dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrh(iRegI dst, memory2 mem) %{</span>
      Register dst_reg = as_Register($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrh(iRegL dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrh(iRegL dst, memory2 mem) %{</span>
      Register dst_reg = as_Register($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrw(iRegI dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrw(iRegI dst, memory4 mem) %{</span>
      Register dst_reg = as_Register($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrw(iRegL dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrw(iRegL dst, memory4 mem) %{</span>
      Register dst_reg = as_Register($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrsw(iRegL dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrsw(iRegL dst, memory4 mem) %{</span>
      Register dst_reg = as_Register($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsw, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldr(iRegL dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldr(iRegL dst, memory8 mem) %{</span>
      Register dst_reg = as_Register($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrs(vRegF dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrs(vRegF dst, memory4 mem) %{</span>
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldrd(vRegD dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrd(vRegD dst, memory8 mem) %{</span>
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, dst_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-removed">-   %}</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   enc_class aarch64_enc_ldrvS(vecD dst, memory mem) %{</span>
<span class="udiff-line-removed">-     FloatRegister dst_reg = as_FloatRegister($dst$$reg);</span>
<span class="udiff-line-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::S,</span>
<span class="udiff-line-removed">-        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-removed">-   %}</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   enc_class aarch64_enc_ldrvD(vecD dst, memory mem) %{</span>
<span class="udiff-line-removed">-     FloatRegister dst_reg = as_FloatRegister($dst$$reg);</span>
<span class="udiff-line-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::D,</span>
<span class="udiff-line-removed">-        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-removed">-   %}</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   enc_class aarch64_enc_ldrvQ(vecX dst, memory mem) %{</span>
<span class="udiff-line-removed">-     FloatRegister dst_reg = as_FloatRegister($dst$$reg);</span>
<span class="udiff-line-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::Q,</span>
<span class="udiff-line-removed">-        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_strb(iRegI src, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_strb(iRegI src, memory1 mem) %{</span>
      Register src_reg = as_Register($src$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strb, src_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-removed">-   %}</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   enc_class aarch64_enc_strb0(memory mem) %{</span>
<span class="udiff-line-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-removed">-     loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),</span>
<span class="udiff-line-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_strb0_ordered(memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_strb0(memory1 mem) %{</span>
      MacroAssembler _masm(&amp;cbuf);
<span class="udiff-line-removed">-     __ membar(Assembler::StoreStore);</span>
      loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_strh(iRegI src, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_strh(iRegI src, memory2 mem) %{</span>
      Register src_reg = as_Register($src$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strh, src_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_strh0(memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_strh0(memory2 mem) %{</span>
      MacroAssembler _masm(&amp;cbuf);
      loadStore(_masm, &amp;MacroAssembler::strh, zr, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_strw(iRegI src, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_strw(iRegI src, memory4 mem) %{</span>
      Register src_reg = as_Register($src$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strw, src_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_strw0(memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_strw0(memory4 mem) %{</span>
      MacroAssembler _masm(&amp;cbuf);
      loadStore(_masm, &amp;MacroAssembler::strw, zr, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_str(iRegL src, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_str(iRegL src, memory8 mem) %{</span>
      Register src_reg = as_Register($src$$reg);
      // we sometimes get asked to store the stack pointer into the
      // current thread -- we cannot do that directly on AArch64
      if (src_reg == r31_sp) {
        MacroAssembler _masm(&amp;cbuf);
        assert(as_Register($mem$$base) == rthread, &quot;unexpected store for sp&quot;);
        __ mov(rscratch2, sp);
        src_reg = rscratch2;
      }
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_str0(memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_str0(memory8 mem) %{</span>
      MacroAssembler _masm(&amp;cbuf);
      loadStore(_masm, &amp;MacroAssembler::str, zr, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_strs(vRegF src, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_strs(vRegF src, memory4 mem) %{</span>
      FloatRegister src_reg = as_FloatRegister($src$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strs, src_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_strd(vRegD src, memory mem) %{</span>
<span class="udiff-line-modified-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_strd(vRegD src, memory8 mem) %{</span>
      FloatRegister src_reg = as_FloatRegister($src$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strd, src_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_strw_immn(immN src, memory1 mem) %{</span>
<span class="udiff-line-added">+     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-added">+     address con = (address)$src$$constant;</span>
<span class="udiff-line-added">+     // need to do this the hard way until we can manage relocs</span>
<span class="udiff-line-added">+     // for 32 bit constants</span>
<span class="udiff-line-added">+     __ movoop(rscratch2, (jobject)con);</span>
<span class="udiff-line-added">+     if (con) __ encode_heap_oop_not_null(rscratch2);</span>
<span class="udiff-line-added">+     loadStore(_masm, &amp;MacroAssembler::strw, rscratch2, $mem-&gt;opcode(),</span>
<span class="udiff-line-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_strw_immnk(immN src, memory4 mem) %{</span>
<span class="udiff-line-added">+     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-added">+     address con = (address)$src$$constant;</span>
<span class="udiff-line-added">+     // need to do this the hard way until we can manage relocs</span>
<span class="udiff-line-added">+     // for 32 bit constants</span>
<span class="udiff-line-added">+     __ movoop(rscratch2, (jobject)con);</span>
<span class="udiff-line-added">+     __ encode_klass_not_null(rscratch2);</span>
<span class="udiff-line-added">+     loadStore(_masm, &amp;MacroAssembler::strw, rscratch2, $mem-&gt;opcode(),</span>
<span class="udiff-line-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="udiff-line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_strb0_ordered(memory4 mem) %{</span>
<span class="udiff-line-added">+       MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-added">+       __ membar(Assembler::StoreStore);</span>
<span class="udiff-line-added">+       loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),</span>
<span class="udiff-line-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // END Non-volatile memory access</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Vector loads and stores</span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrvS(vecD dst, memory mem) %{</span>
<span class="udiff-line-added">+     FloatRegister dst_reg = as_FloatRegister($dst$$reg);</span>
<span class="udiff-line-added">+     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::S,</span>
<span class="udiff-line-added">+        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrvD(vecD dst, memory mem) %{</span>
<span class="udiff-line-added">+     FloatRegister dst_reg = as_FloatRegister($dst$$reg);</span>
<span class="udiff-line-added">+     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::D,</span>
<span class="udiff-line-added">+        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   enc_class aarch64_enc_ldrvQ(vecX dst, memory mem) %{</span>
<span class="udiff-line-added">+     FloatRegister dst_reg = as_FloatRegister($dst$$reg);</span>
<span class="udiff-line-added">+     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::Q,</span>
<span class="udiff-line-added">+        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
    %}
  
    enc_class aarch64_enc_strvS(vecD src, memory mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::S,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2718,12 +2820,10 @@</span>
      FloatRegister src_reg = as_FloatRegister($src$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::Q,
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
<span class="udiff-line-removed">-   // END Non-volatile memory access</span>
<span class="udiff-line-removed">- </span>
    // volatile loads and stores
  
    enc_class aarch64_enc_stlrb(iRegI src, memory mem) %{
      MOV_VOLATILE(as_Register($src$$reg), $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
                   rscratch1, stlrb);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2849,11 +2949,11 @@</span>
                   rscratch1, stlr);
    %}
  
    // synchronized read/update encodings
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_ldaxr(iRegL dst, memory mem) %{</span>
<span class="udiff-line-modified-added">+   enc_class aarch64_enc_ldaxr(iRegL dst, memory8 mem) %{</span>
      MacroAssembler _masm(&amp;cbuf);
      Register dst_reg = as_Register($dst$$reg);
      Register base = as_Register($mem$$base);
      int index = $mem$$index;
      int scale = $mem$$scale;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2878,11 +2978,11 @@</span>
          __ ldaxr(dst_reg, rscratch1);
        }
      }
    %}
  
<span class="udiff-line-modified-removed">-   enc_class aarch64_enc_stlxr(iRegLNoSp src, memory mem) %{</span>
<span class="udiff-line-modified-added">+   enc_class aarch64_enc_stlxr(iRegLNoSp src, memory8 mem) %{</span>
      MacroAssembler _masm(&amp;cbuf);
      Register src_reg = as_Register($src$$reg);
      Register base = as_Register($mem$$base);
      int index = $mem$$index;
      int scale = $mem$$scale;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3344,31 +3444,27 @@</span>
    enc_class aarch64_enc_java_to_runtime(method meth) %{
      MacroAssembler _masm(&amp;cbuf);
  
      // some calls to generated routines (arraycopy code) are scheduled
      // by C2 as runtime calls. if so we can call them using a br (they
<span class="udiff-line-modified-removed">-     // will be in a reachable segment) otherwise we have to use a blrt</span>
<span class="udiff-line-modified-added">+     // will be in a reachable segment) otherwise we have to use a blr</span>
      // which loads the absolute address into a register.
      address entry = (address)$meth$$method;
      CodeBlob *cb = CodeCache::find_blob(entry);
      if (cb) {
        address call = __ trampoline_call(Address(entry, relocInfo::runtime_call_type));
        if (call == NULL) {
          ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
          return;
        }
      } else {
<span class="udiff-line-removed">-       int gpcnt;</span>
<span class="udiff-line-removed">-       int fpcnt;</span>
<span class="udiff-line-removed">-       int rtype;</span>
<span class="udiff-line-removed">-       getCallInfo(tf(), gpcnt, fpcnt, rtype);</span>
        Label retaddr;
        __ adr(rscratch2, retaddr);
        __ lea(rscratch1, RuntimeAddress(entry));
        // Leave a breadcrumb for JavaFrameAnchor::capture_last_Java_pc()
        __ stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)));
<span class="udiff-line-modified-removed">-       __ blrt(rscratch1, gpcnt, fpcnt, rtype);</span>
<span class="udiff-line-modified-added">+       __ blr(rscratch1);</span>
        __ bind(retaddr);
        __ add(sp, sp, 2 * wordSize);
      }
    %}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3408,29 +3504,29 @@</span>
      Label object_has_monitor;
      Label cas_failed;
  
      assert_different_registers(oop, box, tmp, disp_hdr);
  
<span class="udiff-line-modified-removed">-     // Load markOop from object into displaced_header.</span>
<span class="udiff-line-modified-added">+     // Load markWord from object into displaced_header.</span>
      __ ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));
  
      if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
        __ biased_locking_enter(box, oop, disp_hdr, tmp, true, cont);
      }
  
      // Check for existing monitor
<span class="udiff-line-modified-removed">-     __ tbnz(disp_hdr, exact_log2(markOopDesc::monitor_value), object_has_monitor);</span>
<span class="udiff-line-modified-added">+     __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);</span>
  
<span class="udiff-line-modified-removed">-     // Set tmp to be (markOop of object | UNLOCK_VALUE).</span>
<span class="udiff-line-modified-removed">-     __ orr(tmp, disp_hdr, markOopDesc::unlocked_value);</span>
<span class="udiff-line-modified-added">+     // Set tmp to be (markWord of object | UNLOCK_VALUE).</span>
<span class="udiff-line-modified-added">+     __ orr(tmp, disp_hdr, markWord::unlocked_value);</span>
  
      // Initialize the box. (Must happen before we update the object mark!)
      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));
  
<span class="udiff-line-modified-removed">-     // Compare object markOop with an unlocked value (tmp) and if</span>
<span class="udiff-line-modified-removed">-     // equal exchange the stack address of our box with object markOop.</span>
<span class="udiff-line-modified-removed">-     // On failure disp_hdr contains the possibly locked markOop.</span>
<span class="udiff-line-modified-added">+     // Compare object markWord with an unlocked value (tmp) and if</span>
<span class="udiff-line-modified-added">+     // equal exchange the stack address of our box with object markWord.</span>
<span class="udiff-line-modified-added">+     // On failure disp_hdr contains the possibly locked markWord.</span>
      __ cmpxchg(oop, tmp, box, Assembler::xword, /*acquire*/ true,
                 /*release*/ true, /*weak*/ false, disp_hdr);
      __ br(Assembler::EQ, cont);
  
      assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3440,14 +3536,14 @@</span>
  
      __ bind(cas_failed);
      // We did not see an unlocked object so try the fast recursive case.
  
      // Check if the owner is self by comparing the value in the
<span class="udiff-line-modified-removed">-     // markOop of object (disp_hdr) with the stack pointer.</span>
<span class="udiff-line-modified-added">+     // markWord of object (disp_hdr) with the stack pointer.</span>
      __ mov(rscratch1, sp);
      __ sub(disp_hdr, disp_hdr, rscratch1);
<span class="udiff-line-modified-removed">-     __ mov(tmp, (address) (~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place));</span>
<span class="udiff-line-modified-added">+     __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));</span>
      // If condition is true we are cont and hence we can store 0 as the
      // displaced header in the box, which indicates that it is a recursive lock.
      __ ands(tmp/*==0?*/, disp_hdr, tmp);   // Sets flags for result
      __ str(tmp/*==0, perhaps*/, Address(box, BasicLock::displaced_header_offset_in_bytes()));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3458,19 +3554,19 @@</span>
  
      // The object&#39;s monitor m is unlocked iff m-&gt;owner == NULL,
      // otherwise m-&gt;owner may contain a thread or a stack address.
      //
      // Try to CAS m-&gt;owner from NULL to current thread.
<span class="udiff-line-modified-removed">-     __ add(tmp, disp_hdr, (ObjectMonitor::owner_offset_in_bytes()-markOopDesc::monitor_value));</span>
<span class="udiff-line-modified-added">+     __ add(tmp, disp_hdr, (ObjectMonitor::owner_offset_in_bytes()-markWord::monitor_value));</span>
      __ cmpxchg(tmp, zr, rthread, Assembler::xword, /*acquire*/ true,
                 /*release*/ true, /*weak*/ false, noreg); // Sets flags for result
  
      // Store a non-null value into the box to avoid looking like a re-entrant
      // lock. The fast-path monitor unlock code checks for
<span class="udiff-line-modified-removed">-     // markOopDesc::monitor_value so use markOopDesc::unused_mark which has the</span>
<span class="udiff-line-modified-removed">-     // relevant bit set, and also matches ObjectSynchronizer::slow_enter.</span>
<span class="udiff-line-modified-removed">-     __ mov(tmp, (address)markOopDesc::unused_mark());</span>
<span class="udiff-line-modified-added">+     // markWord::monitor_value so use markWord::unused_mark which has the</span>
<span class="udiff-line-modified-added">+     // relevant bit set, and also matches ObjectSynchronizer::enter.</span>
<span class="udiff-line-modified-added">+     __ mov(tmp, (address)markWord::unused_mark().value());</span>
      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));
  
      __ bind(cont);
      // flag == EQ indicates success
      // flag == NE indicates failure
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3498,25 +3594,26 @@</span>
      __ cmp(disp_hdr, zr);
      __ br(Assembler::EQ, cont);
  
      // Handle existing monitor.
      __ ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));
<span class="udiff-line-modified-removed">-     __ tbnz(disp_hdr, exact_log2(markOopDesc::monitor_value), object_has_monitor);</span>
<span class="udiff-line-modified-added">+     __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);</span>
  
      // Check if it is still a light weight lock, this is is true if we
<span class="udiff-line-modified-removed">-     // see the stack address of the basicLock in the markOop of the</span>
<span class="udiff-line-modified-added">+     // see the stack address of the basicLock in the markWord of the</span>
      // object.
  
      __ cmpxchg(oop, box, disp_hdr, Assembler::xword, /*acquire*/ false,
                 /*release*/ true, /*weak*/ false, tmp);
      __ b(cont);
  
      assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
  
      // Handle existing monitor.
      __ bind(object_has_monitor);
<span class="udiff-line-modified-removed">-     __ add(tmp, tmp, -markOopDesc::monitor_value); // monitor</span>
<span class="udiff-line-modified-added">+     STATIC_ASSERT(markWord::monitor_value &lt;= INT_MAX);</span>
<span class="udiff-line-added">+     __ add(tmp, tmp, -(int)markWord::monitor_value); // monitor</span>
      __ ldr(rscratch1, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));
      __ ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));
      __ eor(rscratch1, rscratch1, rthread); // Will be 0 if we are the owner.
      __ orr(rscratch1, rscratch1, disp_hdr); // Will be 0 if there are 0 recursions
      __ cmp(rscratch1, zr); // Sets flags for result
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3686,11 +3783,11 @@</span>
      };
  
      static const int hi[Op_RegL + 1] = { // enum name
        0,                                 // Op_Node
        0,                                 // Op_Set
<span class="udiff-line-modified-removed">-       OptoReg::Bad,                       // Op_RegN</span>
<span class="udiff-line-modified-added">+       OptoReg::Bad,                      // Op_RegN</span>
        OptoReg::Bad,                      // Op_RegI
        R0_H_num,                          // Op_RegP
        OptoReg::Bad,                      // Op_RegF
        V0_H_num,                          // Op_RegD
        R0_H_num                           // Op_RegL
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3930,22 +4027,24 @@</span>
    interface(CONST_INTER);
  %}
  
  operand immL_bitmask()
  %{
<span class="udiff-line-modified-removed">-   predicate(((n-&gt;get_long() &amp; 0xc000000000000000l) == 0)</span>
<span class="udiff-line-modified-added">+   predicate((n-&gt;get_long() != 0)</span>
<span class="udiff-line-added">+             &amp;&amp; ((n-&gt;get_long() &amp; 0xc000000000000000l) == 0)</span>
              &amp;&amp; is_power_of_2(n-&gt;get_long() + 1));
    match(ConL);
  
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
  %}
  
  operand immI_bitmask()
  %{
<span class="udiff-line-modified-removed">-   predicate(((n-&gt;get_int() &amp; 0xc0000000) == 0)</span>
<span class="udiff-line-modified-added">+   predicate((n-&gt;get_int() != 0)</span>
<span class="udiff-line-added">+             &amp;&amp; ((n-&gt;get_int() &amp; 0xc0000000) == 0)</span>
              &amp;&amp; is_power_of_2(n-&gt;get_int() + 1));
    match(ConI);
  
    op_cost(0);
    format %{ %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4007,11 +4106,31 @@</span>
  %}
  
  // Offset for scaled or unscaled immediate loads and stores
  operand immIOffset()
  %{
<span class="udiff-line-modified-removed">-   predicate(Address::offset_ok_for_immed(n-&gt;get_int()));</span>
<span class="udiff-line-modified-added">+   predicate(Address::offset_ok_for_immed(n-&gt;get_int(), 0));</span>
<span class="udiff-line-added">+   match(ConI);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(CONST_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand immIOffset1()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   predicate(Address::offset_ok_for_immed(n-&gt;get_int(), 0));</span>
<span class="udiff-line-added">+   match(ConI);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(CONST_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand immIOffset2()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   predicate(Address::offset_ok_for_immed(n-&gt;get_int(), 1));</span>
    match(ConI);
  
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4047,11 +4166,31 @@</span>
    interface(CONST_INTER);
  %}
  
  operand immLoffset()
  %{
<span class="udiff-line-modified-removed">-   predicate(Address::offset_ok_for_immed(n-&gt;get_long()));</span>
<span class="udiff-line-modified-added">+   predicate(Address::offset_ok_for_immed(n-&gt;get_long(), 0));</span>
<span class="udiff-line-added">+   match(ConL);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(CONST_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand immLoffset1()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   predicate(Address::offset_ok_for_immed(n-&gt;get_long(), 0));</span>
<span class="udiff-line-added">+   match(ConL);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(CONST_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand immLoffset2()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   predicate(Address::offset_ok_for_immed(n-&gt;get_long(), 1));</span>
    match(ConL);
  
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4630,144 +4769,396 @@</span>
    format %{ %}
    interface(REG_INTER);
  %}
  
  
<span class="udiff-line-modified-removed">- // Pointer Register Operands</span>
<span class="udiff-line-modified-removed">- // Narrow Pointer Register</span>
<span class="udiff-line-modified-removed">- operand iRegN()</span>
<span class="udiff-line-modified-added">+ // Pointer Register Operands</span>
<span class="udiff-line-modified-added">+ // Narrow Pointer Register</span>
<span class="udiff-line-modified-added">+ operand iRegN()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(any_reg32));</span>
<span class="udiff-line-added">+   match(RegN);</span>
<span class="udiff-line-added">+   match(iRegNNoSp);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand iRegN_R0()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(r0_reg));</span>
<span class="udiff-line-added">+   match(iRegN);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand iRegN_R2()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(r2_reg));</span>
<span class="udiff-line-added">+   match(iRegN);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand iRegN_R3()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(r3_reg));</span>
<span class="udiff-line-added">+   match(iRegN);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Integer 64 bit Register not Special</span>
<span class="udiff-line-added">+ operand iRegNNoSp()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(no_special_reg32));</span>
<span class="udiff-line-added">+   match(RegN);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // heap base register -- used for encoding immN0</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand iRegIHeapbase()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(heapbase_reg));</span>
<span class="udiff-line-added">+   match(RegI);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Float Register</span>
<span class="udiff-line-added">+ // Float register operands</span>
<span class="udiff-line-added">+ operand vRegF()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(float_reg));</span>
<span class="udiff-line-added">+   match(RegF);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Double Register</span>
<span class="udiff-line-added">+ // Double register operands</span>
<span class="udiff-line-added">+ operand vRegD()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(double_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vecD()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(vectord_reg));</span>
<span class="udiff-line-added">+   match(VecD);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vecX()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(vectorx_reg));</span>
<span class="udiff-line-added">+   match(VecX);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V0()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v0_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V1()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v1_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V2()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v2_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V3()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v3_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V4()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v4_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V5()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v5_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V6()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v6_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V7()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v7_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V8()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v8_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V9()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v9_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V10()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v10_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V11()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v11_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V12()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v12_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V13()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v13_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V14()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v14_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V15()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v15_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V16()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v16_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V17()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(v17_reg));</span>
<span class="udiff-line-added">+   match(RegD);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ %}</span>
<span class="udiff-line-added">+   interface(REG_INTER);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand vRegD_V18()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(any_reg32));</span>
<span class="udiff-line-modified-removed">-   match(RegN);</span>
<span class="udiff-line-removed">-   match(iRegNNoSp);</span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v18_reg));</span>
<span class="udiff-line-modified-added">+   match(RegD);</span>
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- operand iRegN_R0()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V19()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(r0_reg));</span>
<span class="udiff-line-modified-removed">-   match(iRegN);</span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v19_reg));</span>
<span class="udiff-line-modified-added">+   match(RegD);</span>
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- operand iRegN_R2()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V20()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(r2_reg));</span>
<span class="udiff-line-modified-removed">-   match(iRegN);</span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v20_reg));</span>
<span class="udiff-line-modified-added">+   match(RegD);</span>
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- operand iRegN_R3()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V21()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(r3_reg));</span>
<span class="udiff-line-modified-removed">-   match(iRegN);</span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v21_reg));</span>
<span class="udiff-line-modified-added">+   match(RegD);</span>
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- // Integer 64 bit Register not Special</span>
<span class="udiff-line-removed">- operand iRegNNoSp()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V22()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(no_special_reg32));</span>
<span class="udiff-line-modified-removed">-   match(RegN);</span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v22_reg));</span>
<span class="udiff-line-modified-added">+   match(RegD);</span>
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- // heap base register -- used for encoding immN0</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- operand iRegIHeapbase()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V23()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(heapbase_reg));</span>
<span class="udiff-line-modified-removed">-   match(RegI);</span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v23_reg));</span>
<span class="udiff-line-modified-added">+   match(RegD);</span>
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- // Float Register</span>
<span class="udiff-line-removed">- // Float register operands</span>
<span class="udiff-line-removed">- operand vRegF()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V24()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(float_reg));</span>
<span class="udiff-line-modified-removed">-   match(RegF);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v24_reg));</span>
<span class="udiff-line-modified-added">+   match(RegD);</span>
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- // Double Register</span>
<span class="udiff-line-removed">- // Double register operands</span>
<span class="udiff-line-removed">- operand vRegD()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V25()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(double_reg));</span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v25_reg));</span>
    match(RegD);
<span class="udiff-line-removed">- </span>
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- operand vecD()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V26()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(vectord_reg));</span>
<span class="udiff-line-modified-removed">-   match(VecD);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v26_reg));</span>
<span class="udiff-line-modified-added">+   match(RegD);</span>
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- operand vecX()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V27()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(vectorx_reg));</span>
<span class="udiff-line-modified-removed">-   match(VecX);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v27_reg));</span>
<span class="udiff-line-modified-added">+   match(RegD);</span>
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- operand vRegD_V0()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V28()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(v0_reg));</span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v28_reg));</span>
    match(RegD);
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- operand vRegD_V1()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V29()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(v1_reg));</span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v29_reg));</span>
    match(RegD);
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- operand vRegD_V2()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V30()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(v2_reg));</span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v30_reg));</span>
    match(RegD);
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="udiff-line-modified-removed">- operand vRegD_V3()</span>
<span class="udiff-line-modified-added">+ operand vRegD_V31()</span>
  %{
<span class="udiff-line-modified-removed">-   constraint(ALLOC_IN_RC(v3_reg));</span>
<span class="udiff-line-modified-added">+   constraint(ALLOC_IN_RC(v31_reg));</span>
    match(RegD);
    op_cost(0);
    format %{ %}
    interface(REG_INTER);
  %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4940,10 +5331,38 @@</span>
      scale(0x0);
      disp($off);
    %}
  %}
  
<span class="udiff-line-added">+ operand indOffI1(iRegP reg, immIOffset1 off)</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(ptr_reg));</span>
<span class="udiff-line-added">+   match(AddP reg off);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ &quot;[$reg, $off]&quot; %}</span>
<span class="udiff-line-added">+   interface(MEMORY_INTER) %{</span>
<span class="udiff-line-added">+     base($reg);</span>
<span class="udiff-line-added">+     index(0xffffffff);</span>
<span class="udiff-line-added">+     scale(0x0);</span>
<span class="udiff-line-added">+     disp($off);</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand indOffI2(iRegP reg, immIOffset2 off)</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(ptr_reg));</span>
<span class="udiff-line-added">+   match(AddP reg off);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ &quot;[$reg, $off]&quot; %}</span>
<span class="udiff-line-added">+   interface(MEMORY_INTER) %{</span>
<span class="udiff-line-added">+     base($reg);</span>
<span class="udiff-line-added">+     index(0xffffffff);</span>
<span class="udiff-line-added">+     scale(0x0);</span>
<span class="udiff-line-added">+     disp($off);</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
  operand indOffI4(iRegP reg, immIOffset4 off)
  %{
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP reg off);
    op_cost(0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4996,10 +5415,38 @@</span>
      scale(0x0);
      disp($off);
    %}
  %}
  
<span class="udiff-line-added">+ operand indOffL1(iRegP reg, immLoffset1 off)</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(ptr_reg));</span>
<span class="udiff-line-added">+   match(AddP reg off);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ &quot;[$reg, $off]&quot; %}</span>
<span class="udiff-line-added">+   interface(MEMORY_INTER) %{</span>
<span class="udiff-line-added">+     base($reg);</span>
<span class="udiff-line-added">+     index(0xffffffff);</span>
<span class="udiff-line-added">+     scale(0x0);</span>
<span class="udiff-line-added">+     disp($off);</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ operand indOffL2(iRegP reg, immLoffset2 off)</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   constraint(ALLOC_IN_RC(ptr_reg));</span>
<span class="udiff-line-added">+   match(AddP reg off);</span>
<span class="udiff-line-added">+   op_cost(0);</span>
<span class="udiff-line-added">+   format %{ &quot;[$reg, $off]&quot; %}</span>
<span class="udiff-line-added">+   interface(MEMORY_INTER) %{</span>
<span class="udiff-line-added">+     base($reg);</span>
<span class="udiff-line-added">+     index(0xffffffff);</span>
<span class="udiff-line-added">+     scale(0x0);</span>
<span class="udiff-line-added">+     disp($off);</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
  operand indOffL4(iRegP reg, immLoffset4 off)
  %{
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP reg off);
    op_cost(0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5040,11 +5487,11 @@</span>
    %}
  %}
  
  operand indirectN(iRegN reg)
  %{
<span class="udiff-line-modified-removed">-   predicate(Universe::narrow_oop_shift() == 0);</span>
<span class="udiff-line-modified-added">+   predicate(CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(DecodeN reg);
    op_cost(0);
    format %{ &quot;[$reg]\t# narrow&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5055,11 +5502,11 @@</span>
    %}
  %}
  
  operand indIndexScaledI2LN(iRegN reg, iRegI ireg, immIScale scale)
  %{
<span class="udiff-line-modified-removed">-   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; size_fits_all_mem_uses(n-&gt;as_AddP(), n-&gt;in(AddPNode::Offset)-&gt;in(2)-&gt;get_int()));</span>
<span class="udiff-line-modified-added">+   predicate(CompressedOops::shift() == 0 &amp;&amp; size_fits_all_mem_uses(n-&gt;as_AddP(), n-&gt;in(AddPNode::Offset)-&gt;in(2)-&gt;get_int()));</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) (LShiftL (ConvI2L ireg) scale));
    op_cost(0);
    format %{ &quot;$reg, $ireg sxtw($scale), 0, I2L\t# narrow&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5070,11 +5517,11 @@</span>
    %}
  %}
  
  operand indIndexScaledN(iRegN reg, iRegL lreg, immIScale scale)
  %{
<span class="udiff-line-modified-removed">-   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; size_fits_all_mem_uses(n-&gt;as_AddP(), n-&gt;in(AddPNode::Offset)-&gt;in(2)-&gt;get_int()));</span>
<span class="udiff-line-modified-added">+   predicate(CompressedOops::shift() == 0 &amp;&amp; size_fits_all_mem_uses(n-&gt;as_AddP(), n-&gt;in(AddPNode::Offset)-&gt;in(2)-&gt;get_int()));</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) (LShiftL lreg scale));
    op_cost(0);
    format %{ &quot;$reg, $lreg lsl($scale)\t# narrow&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5085,11 +5532,11 @@</span>
    %}
  %}
  
  operand indIndexI2LN(iRegN reg, iRegI ireg)
  %{
<span class="udiff-line-modified-removed">-   predicate(Universe::narrow_oop_shift() == 0);</span>
<span class="udiff-line-modified-added">+   predicate(CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) (ConvI2L ireg));
    op_cost(0);
    format %{ &quot;$reg, $ireg, 0, I2L\t# narrow&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5100,11 +5547,11 @@</span>
    %}
  %}
  
  operand indIndexN(iRegN reg, iRegL lreg)
  %{
<span class="udiff-line-modified-removed">-   predicate(Universe::narrow_oop_shift() == 0);</span>
<span class="udiff-line-modified-added">+   predicate(CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) lreg);
    op_cost(0);
    format %{ &quot;$reg, $lreg\t# narrow&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5115,11 +5562,11 @@</span>
    %}
  %}
  
  operand indOffIN(iRegN reg, immIOffset off)
  %{
<span class="udiff-line-modified-removed">-   predicate(Universe::narrow_oop_shift() == 0);</span>
<span class="udiff-line-modified-added">+   predicate(CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) off);
    op_cost(0);
    format %{ &quot;[$reg, $off]\t# narrow&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5130,11 +5577,11 @@</span>
    %}
  %}
  
  operand indOffLN(iRegN reg, immLoffset off)
  %{
<span class="udiff-line-modified-removed">-   predicate(Universe::narrow_oop_shift() == 0);</span>
<span class="udiff-line-modified-added">+   predicate(CompressedOops::shift() == 0);</span>
    constraint(ALLOC_IN_RC(ptr_reg));
    match(AddP (DecodeN reg) off);
    op_cost(0);
    format %{ &quot;[$reg, $off]\t# narrow&quot; %}
    interface(MEMORY_INTER) %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5297,11 +5744,10 @@</span>
  // converted to cbxx or tbxx instructions
  
  operand cmpOpEqNe()
  %{
    match(Bool);
<span class="udiff-line-removed">-   match(CmpOp);</span>
    op_cost(0);
    predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne
              || n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
  
    format %{ &quot;&quot; %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5321,11 +5767,10 @@</span>
  // converted to cbxx or tbxx instructions
  
  operand cmpOpLtGe()
  %{
    match(Bool);
<span class="udiff-line-removed">-   match(CmpOp);</span>
    op_cost(0);
  
    predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt
              || n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5346,11 +5791,10 @@</span>
  // converted to cbxx or tbxx instructions
  
  operand cmpOpUEqNeLtGe()
  %{
    match(Bool);
<span class="udiff-line-removed">-   match(CmpOp);</span>
    op_cost(0);
  
    predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq
              || n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne
              || n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5394,13 +5838,28 @@</span>
  // encoding and format. The classic case of this is memory operands.
  
  // memory is used to define read/write location for load/store
  // instruction defs. we can turn a memory op into an Address
  
<span class="udiff-line-modified-removed">- opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI, indOffL,</span>
<span class="udiff-line-modified-added">+ opclass memory1(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI1, indOffL1,</span>
<span class="udiff-line-added">+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ opclass memory2(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI2, indOffL2,</span>
<span class="udiff-line-added">+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ opclass memory4(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI4, indOffL4,</span>
<span class="udiff-line-added">+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ opclass memory8(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI8, indOffL8,</span>
                 indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);
  
<span class="udiff-line-added">+ // All of the memory operands. For the pipeline description.</span>
<span class="udiff-line-added">+ opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex,</span>
<span class="udiff-line-added">+                indOffI1, indOffL1, indOffI2, indOffL2, indOffI4, indOffL4, indOffI8, indOffL8,</span>
<span class="udiff-line-added">+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  // iRegIorL2I is used for src inputs in rules for 32 bit int (I)
  // operations. it allows the src to be either an iRegI or a (ConvL2I
  // iRegL). in the latter case the l2i normally planted for a ConvL2I
  // can be elided because the 32-bit instruction will just employ the
  // lower 32 bits anyway.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6380,11 +6839,11 @@</span>
  // Memory (Load/Store) Instructions
  
  // Load Instructions
  
  // Load Byte (8 bit signed)
<span class="udiff-line-modified-removed">- instruct loadB(iRegINoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadB(iRegINoSp dst, memory1 mem)</span>
  %{
    match(Set dst (LoadB mem));
    predicate(!needs_acquiring_load(n));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6394,11 +6853,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Byte (8 bit signed) into long
<span class="udiff-line-modified-removed">- instruct loadB2L(iRegLNoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadB2L(iRegLNoSp dst, memory1 mem)</span>
  %{
    match(Set dst (ConvI2L (LoadB mem)));
    predicate(!needs_acquiring_load(n-&gt;in(1)));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6408,11 +6867,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Byte (8 bit unsigned)
<span class="udiff-line-modified-removed">- instruct loadUB(iRegINoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadUB(iRegINoSp dst, memory1 mem)</span>
  %{
    match(Set dst (LoadUB mem));
    predicate(!needs_acquiring_load(n));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6422,11 +6881,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Byte (8 bit unsigned) into long
<span class="udiff-line-modified-removed">- instruct loadUB2L(iRegLNoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadUB2L(iRegLNoSp dst, memory1 mem)</span>
  %{
    match(Set dst (ConvI2L (LoadUB mem)));
    predicate(!needs_acquiring_load(n-&gt;in(1)));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6436,11 +6895,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Short (16 bit signed)
<span class="udiff-line-modified-removed">- instruct loadS(iRegINoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadS(iRegINoSp dst, memory2 mem)</span>
  %{
    match(Set dst (LoadS mem));
    predicate(!needs_acquiring_load(n));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6450,11 +6909,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Short (16 bit signed) into long
<span class="udiff-line-modified-removed">- instruct loadS2L(iRegLNoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadS2L(iRegLNoSp dst, memory2 mem)</span>
  %{
    match(Set dst (ConvI2L (LoadS mem)));
    predicate(!needs_acquiring_load(n-&gt;in(1)));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6464,11 +6923,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Char (16 bit unsigned)
<span class="udiff-line-modified-removed">- instruct loadUS(iRegINoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadUS(iRegINoSp dst, memory2 mem)</span>
  %{
    match(Set dst (LoadUS mem));
    predicate(!needs_acquiring_load(n));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6478,11 +6937,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Short/Char (16 bit unsigned) into long
<span class="udiff-line-modified-removed">- instruct loadUS2L(iRegLNoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadUS2L(iRegLNoSp dst, memory2 mem)</span>
  %{
    match(Set dst (ConvI2L (LoadUS mem)));
    predicate(!needs_acquiring_load(n-&gt;in(1)));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6492,11 +6951,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Integer (32 bit signed)
<span class="udiff-line-modified-removed">- instruct loadI(iRegINoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadI(iRegINoSp dst, memory4 mem)</span>
  %{
    match(Set dst (LoadI mem));
    predicate(!needs_acquiring_load(n));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6506,11 +6965,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Integer (32 bit signed) into long
<span class="udiff-line-modified-removed">- instruct loadI2L(iRegLNoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadI2L(iRegLNoSp dst, memory4 mem)</span>
  %{
    match(Set dst (ConvI2L (LoadI mem)));
    predicate(!needs_acquiring_load(n-&gt;in(1)));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6520,11 +6979,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Integer (32 bit unsigned) into long
<span class="udiff-line-modified-removed">- instruct loadUI2L(iRegLNoSp dst, memory mem, immL_32bits mask)</span>
<span class="udiff-line-modified-added">+ instruct loadUI2L(iRegLNoSp dst, memory4 mem, immL_32bits mask)</span>
  %{
    match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
    predicate(!needs_acquiring_load(n-&gt;in(1)-&gt;in(1)-&gt;as_Load()));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6534,11 +6993,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Long (64 bit signed)
<span class="udiff-line-modified-removed">- instruct loadL(iRegLNoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadL(iRegLNoSp dst, memory8 mem)</span>
  %{
    match(Set dst (LoadL mem));
    predicate(!needs_acquiring_load(n));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6548,11 +7007,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Range
<span class="udiff-line-modified-removed">- instruct loadRange(iRegINoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadRange(iRegINoSp dst, memory4 mem)</span>
  %{
    match(Set dst (LoadRange mem));
  
    ins_cost(4 * INSN_COST);
    format %{ &quot;ldrw  $dst, $mem\t# range&quot; %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6561,25 +7020,25 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Pointer
<span class="udiff-line-modified-removed">- instruct loadP(iRegPNoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadP(iRegPNoSp dst, memory8 mem)</span>
  %{
    match(Set dst (LoadP mem));
<span class="udiff-line-modified-removed">-   predicate(!needs_acquiring_load(n));</span>
<span class="udiff-line-modified-added">+   predicate(!needs_acquiring_load(n) &amp;&amp; (n-&gt;as_Load()-&gt;barrier_data() == 0));</span>
  
    ins_cost(4 * INSN_COST);
    format %{ &quot;ldr  $dst, $mem\t# ptr&quot; %}
  
    ins_encode(aarch64_enc_ldr(dst, mem));
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Compressed Pointer
<span class="udiff-line-modified-removed">- instruct loadN(iRegNNoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadN(iRegNNoSp dst, memory4 mem)</span>
  %{
    match(Set dst (LoadN mem));
    predicate(!needs_acquiring_load(n));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6589,11 +7048,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Klass Pointer
<span class="udiff-line-modified-removed">- instruct loadKlass(iRegPNoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadKlass(iRegPNoSp dst, memory8 mem)</span>
  %{
    match(Set dst (LoadKlass mem));
    predicate(!needs_acquiring_load(n));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6603,11 +7062,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Narrow Klass Pointer
<span class="udiff-line-modified-removed">- instruct loadNKlass(iRegNNoSp dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadNKlass(iRegNNoSp dst, memory4 mem)</span>
  %{
    match(Set dst (LoadNKlass mem));
    predicate(!needs_acquiring_load(n));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6617,11 +7076,11 @@</span>
  
    ins_pipe(iload_reg_mem);
  %}
  
  // Load Float
<span class="udiff-line-modified-removed">- instruct loadF(vRegF dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadF(vRegF dst, memory4 mem)</span>
  %{
    match(Set dst (LoadF mem));
    predicate(!needs_acquiring_load(n));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6631,11 +7090,11 @@</span>
  
    ins_pipe(pipe_class_memory);
  %}
  
  // Load Double
<span class="udiff-line-modified-removed">- instruct loadD(vRegD dst, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct loadD(vRegD dst, memory8 mem)</span>
  %{
    match(Set dst (LoadD mem));
    predicate(!needs_acquiring_load(n));
  
    ins_cost(4 * INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6849,14 +7308,13 @@</span>
  %}
  
  // Store Instructions
  
  // Store CMS card-mark Immediate
<span class="udiff-line-modified-removed">- instruct storeimmCM0(immI0 zero, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeimmCM0(immI0 zero, memory1 mem)</span>
  %{
    match(Set mem (StoreCM mem zero));
<span class="udiff-line-removed">-   predicate(unnecessary_storestore(n));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;storestore (elided)\n\t&quot;
              &quot;strb zr, $mem\t# byte&quot; %}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6865,11 +7323,11 @@</span>
    ins_pipe(istore_mem);
  %}
  
  // Store CMS card-mark Immediate with intervening StoreStore
  // needed when using CMS with no conditional card marking
<span class="udiff-line-modified-removed">- instruct storeimmCM0_ordered(immI0 zero, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeimmCM0_ordered(immI0 zero, memory1 mem)</span>
  %{
    match(Set mem (StoreCM mem zero));
  
    ins_cost(INSN_COST * 2);
    format %{ &quot;storestore\n\t&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6880,11 +7338,11 @@</span>
  
    ins_pipe(istore_mem);
  %}
  
  // Store Byte
<span class="udiff-line-modified-removed">- instruct storeB(iRegIorL2I src, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeB(iRegIorL2I src, memory1 mem)</span>
  %{
    match(Set mem (StoreB mem src));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6894,11 +7352,11 @@</span>
  
    ins_pipe(istore_reg_mem);
  %}
  
  
<span class="udiff-line-modified-removed">- instruct storeimmB0(immI0 zero, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeimmB0(immI0 zero, memory1 mem)</span>
  %{
    match(Set mem (StoreB mem zero));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6908,11 +7366,11 @@</span>
  
    ins_pipe(istore_mem);
  %}
  
  // Store Char/Short
<span class="udiff-line-modified-removed">- instruct storeC(iRegIorL2I src, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeC(iRegIorL2I src, memory2 mem)</span>
  %{
    match(Set mem (StoreC mem src));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6921,11 +7379,11 @@</span>
    ins_encode(aarch64_enc_strh(src, mem));
  
    ins_pipe(istore_reg_mem);
  %}
  
<span class="udiff-line-modified-removed">- instruct storeimmC0(immI0 zero, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeimmC0(immI0 zero, memory2 mem)</span>
  %{
    match(Set mem (StoreC mem zero));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6936,11 +7394,11 @@</span>
    ins_pipe(istore_mem);
  %}
  
  // Store Integer
  
<span class="udiff-line-modified-removed">- instruct storeI(iRegIorL2I src, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeI(iRegIorL2I src, memory4 mem)</span>
  %{
    match(Set mem(StoreI mem src));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6949,11 +7407,11 @@</span>
    ins_encode(aarch64_enc_strw(src, mem));
  
    ins_pipe(istore_reg_mem);
  %}
  
<span class="udiff-line-modified-removed">- instruct storeimmI0(immI0 zero, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeimmI0(immI0 zero, memory4 mem)</span>
  %{
    match(Set mem(StoreI mem zero));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6963,11 +7421,11 @@</span>
  
    ins_pipe(istore_mem);
  %}
  
  // Store Long (64 bit signed)
<span class="udiff-line-modified-removed">- instruct storeL(iRegL src, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeL(iRegL src, memory8 mem)</span>
  %{
    match(Set mem (StoreL mem src));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6977,11 +7435,11 @@</span>
  
    ins_pipe(istore_reg_mem);
  %}
  
  // Store Long (64 bit signed)
<span class="udiff-line-modified-removed">- instruct storeimmL0(immL0 zero, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeimmL0(immL0 zero, memory8 mem)</span>
  %{
    match(Set mem (StoreL mem zero));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6991,11 +7449,11 @@</span>
  
    ins_pipe(istore_mem);
  %}
  
  // Store Pointer
<span class="udiff-line-modified-removed">- instruct storeP(iRegP src, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeP(iRegP src, memory8 mem)</span>
  %{
    match(Set mem (StoreP mem src));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7005,11 +7463,11 @@</span>
  
    ins_pipe(istore_reg_mem);
  %}
  
  // Store Pointer
<span class="udiff-line-modified-removed">- instruct storeimmP0(immP0 zero, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeimmP0(immP0 zero, memory8 mem)</span>
  %{
    match(Set mem (StoreP mem zero));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7019,11 +7477,11 @@</span>
  
    ins_pipe(istore_mem);
  %}
  
  // Store Compressed Pointer
<span class="udiff-line-modified-removed">- instruct storeN(iRegN src, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeN(iRegN src, memory4 mem)</span>
  %{
    match(Set mem (StoreN mem src));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7032,15 +7490,15 @@</span>
    ins_encode(aarch64_enc_strw(src, mem));
  
    ins_pipe(istore_reg_mem);
  %}
  
<span class="udiff-line-modified-removed">- instruct storeImmN0(iRegIHeapbase heapbase, immN0 zero, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeImmN0(iRegIHeapbase heapbase, immN0 zero, memory4 mem)</span>
  %{
    match(Set mem (StoreN mem zero));
<span class="udiff-line-modified-removed">-   predicate(Universe::narrow_oop_base() == NULL &amp;&amp;</span>
<span class="udiff-line-modified-removed">-             Universe::narrow_klass_base() == NULL &amp;&amp;</span>
<span class="udiff-line-modified-added">+   predicate(CompressedOops::base() == NULL &amp;&amp;</span>
<span class="udiff-line-modified-added">+             CompressedKlassPointers::base() == NULL &amp;&amp;</span>
              (!needs_releasing_store(n)));
  
    ins_cost(INSN_COST);
    format %{ &quot;strw  rheapbase, $mem\t# compressed ptr (rheapbase==0)&quot; %}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7048,11 +7506,11 @@</span>
  
    ins_pipe(istore_reg_mem);
  %}
  
  // Store Float
<span class="udiff-line-modified-removed">- instruct storeF(vRegF src, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeF(vRegF src, memory4 mem)</span>
  %{
    match(Set mem (StoreF mem src));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7065,11 +7523,11 @@</span>
  
  // TODO
  // implement storeImmF0 and storeFImmPacked
  
  // Store Double
<span class="udiff-line-modified-removed">- instruct storeD(vRegD src, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeD(vRegD src, memory8 mem)</span>
  %{
    match(Set mem (StoreD mem src));
    predicate(!needs_releasing_store(n));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7079,11 +7537,11 @@</span>
  
    ins_pipe(pipe_class_memory);
  %}
  
  // Store Compressed Klass Pointer
<span class="udiff-line-modified-removed">- instruct storeNKlass(iRegN src, memory mem)</span>
<span class="udiff-line-modified-added">+ instruct storeNKlass(iRegN src, memory4 mem)</span>
  %{
    predicate(!needs_releasing_store(n));
    match(Set mem (StoreNKlass mem src));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7098,11 +7556,11 @@</span>
  // implement storeImmD0 and storeDImmPacked
  
  // prefetch instructions
  // Must be safe to execute with invalid address (cannot fault).
  
<span class="udiff-line-modified-removed">- instruct prefetchalloc( memory mem ) %{</span>
<span class="udiff-line-modified-added">+ instruct prefetchalloc( memory8 mem ) %{</span>
    match(PrefetchAllocation mem);
  
    ins_cost(INSN_COST);
    format %{ &quot;prfm $mem, PSTL1KEEP\t# Prefetch into level 1 cache write keep&quot; %}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7257,10 +7715,11 @@</span>
  
  // Load Pointer
  instruct loadP_volatile(iRegPNoSp dst, /* sync_memory*/indirect mem)
  %{
    match(Set dst (LoadP mem));
<span class="udiff-line-added">+   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);</span>
  
    ins_cost(VOLATILE_REF_COST);
    format %{ &quot;ldar  $dst, $mem\t# ptr&quot; %}
  
    ins_encode(aarch64_enc_ldar(dst, mem));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7415,10 +7874,51 @@</span>
    ins_pipe(pipe_class_memory);
  %}
  
  //  ---------------- end of volatile loads and stores ----------------
  
<span class="udiff-line-added">+ instruct cacheWB(indirect addr)</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   predicate(VM_Version::supports_data_cache_line_flush());</span>
<span class="udiff-line-added">+   match(CacheWB addr);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_cost(100);</span>
<span class="udiff-line-added">+   format %{&quot;cache wb $addr&quot; %}</span>
<span class="udiff-line-added">+   ins_encode %{</span>
<span class="udiff-line-added">+     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);</span>
<span class="udiff-line-added">+     assert($addr$$disp == 0, &quot;should be&quot;);</span>
<span class="udiff-line-added">+     __ cache_wb(Address($addr$$base$$Register, 0));</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+   ins_pipe(pipe_slow); // XXX</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ instruct cacheWBPreSync()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   predicate(VM_Version::supports_data_cache_line_flush());</span>
<span class="udiff-line-added">+   match(CacheWBPreSync);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_cost(100);</span>
<span class="udiff-line-added">+   format %{&quot;cache wb presync&quot; %}</span>
<span class="udiff-line-added">+   ins_encode %{</span>
<span class="udiff-line-added">+     __ cache_wbsync(true);</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+   ins_pipe(pipe_slow); // XXX</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ instruct cacheWBPostSync()</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   predicate(VM_Version::supports_data_cache_line_flush());</span>
<span class="udiff-line-added">+   match(CacheWBPostSync);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_cost(100);</span>
<span class="udiff-line-added">+   format %{&quot;cache wb postsync&quot; %}</span>
<span class="udiff-line-added">+   ins_encode %{</span>
<span class="udiff-line-added">+     __ cache_wbsync(false);</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+   ins_pipe(pipe_slow); // XXX</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
  // ============================================================================
  // BSWAP Instructions
  
  instruct bytes_reverse_int(iRegINoSp dst, iRegIorL2I src) %{
    match(Set dst (ReverseBytesI src));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7552,11 +8052,11 @@</span>
    %}
  
    ins_pipe(pipe_class_default);
  %}
  
<span class="udiff-line-modified-removed">- instruct popCountI_mem(iRegINoSp dst, memory mem, vRegF tmp) %{</span>
<span class="udiff-line-modified-added">+ instruct popCountI_mem(iRegINoSp dst, memory4 mem, vRegF tmp) %{</span>
    predicate(UsePopCountInstruction);
    match(Set dst (PopCountI (LoadI mem)));
    effect(TEMP tmp);
    ins_cost(INSN_COST * 13);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7565,11 +8065,11 @@</span>
              &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
    ins_encode %{
      FloatRegister tmp_reg = as_FloatRegister($tmp$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, tmp_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
      __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
    %}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7595,11 +8095,11 @@</span>
    %}
  
    ins_pipe(pipe_class_default);
  %}
  
<span class="udiff-line-modified-removed">- instruct popCountL_mem(iRegINoSp dst, memory mem, vRegD tmp) %{</span>
<span class="udiff-line-modified-added">+ instruct popCountL_mem(iRegINoSp dst, memory8 mem, vRegD tmp) %{</span>
    predicate(UsePopCountInstruction);
    match(Set dst (PopCountL (LoadL mem)));
    effect(TEMP tmp);
    ins_cost(INSN_COST * 13);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7608,11 +8108,11 @@</span>
              &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
    ins_encode %{
      FloatRegister tmp_reg = as_FloatRegister($tmp$$reg);
      loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, tmp_reg, $mem-&gt;opcode(),
<span class="udiff-line-modified-removed">-                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="udiff-line-modified-added">+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);</span>
      __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
    %}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7818,11 +8318,11 @@</span>
  
  // Convert compressed oop into int for vectors alignment masking
  // in case of 32bit oops (heap &lt; 4Gb).
  instruct convN2I(iRegINoSp dst, iRegN src)
  %{
<span class="udiff-line-modified-removed">-   predicate(Universe::narrow_oop_shift() == 0);</span>
<span class="udiff-line-modified-added">+   predicate(CompressedOops::shift() == 0);</span>
    match(Set dst (ConvL2I (CastP2X (DecodeN src))));
  
    ins_cost(INSN_COST);
    format %{ &quot;mov dst, $src\t# compressed ptr -&gt; int&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7954,10 +8454,21 @@</span>
    ins_encode(/* empty encoding */);
    ins_cost(0);
    ins_pipe(pipe_class_empty);
  %}
  
<span class="udiff-line-added">+ instruct castLL(iRegL dst)</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   match(Set dst (CastLL dst));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size(0);</span>
<span class="udiff-line-added">+   format %{ &quot;# castLL of $dst&quot; %}</span>
<span class="udiff-line-added">+   ins_encode(/* empty encoding */);</span>
<span class="udiff-line-added">+   ins_cost(0);</span>
<span class="udiff-line-added">+   ins_pipe(pipe_class_empty);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
  // ============================================================================
  // Atomic operation instructions
  //
  // Intel and SPARC both implement Ideal Node LoadPLocked and
  // Store{PIL}Conditional instructions using a normal load for the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8000,11 +8511,11 @@</span>
  // Conditional-store of the updated heap-top.
  // Used during allocation of the shared heap.
  // Sets flag (EQ) on success.
  // implemented using stlxr on AArch64.
  
<span class="udiff-line-modified-removed">- instruct storePConditional(memory heap_top_ptr, iRegP oldval, iRegP newval, rFlagsReg cr)</span>
<span class="udiff-line-modified-added">+ instruct storePConditional(memory8 heap_top_ptr, iRegP oldval, iRegP newval, rFlagsReg cr)</span>
  %{
    match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
  
    ins_cost(VOLATILE_REF_COST);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8141,10 +8652,11 @@</span>
  %}
  
  instruct compareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  
    match(Set res (CompareAndSwapP mem (Binary oldval newval)));
<span class="udiff-line-added">+   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
    ins_cost(2 * VOLATILE_REF_COST);
  
    effect(KILL cr);
  
   format %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8254,11 +8766,11 @@</span>
    ins_pipe(pipe_slow);
  %}
  
  instruct compareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  
<span class="udiff-line-modified-removed">-   predicate(needs_acquiring_load_exclusive(n));</span>
<span class="udiff-line-modified-added">+   predicate(needs_acquiring_load_exclusive(n) &amp;&amp; (n-&gt;as_LoadStore()-&gt;barrier_data() == 0));</span>
    match(Set res (CompareAndSwapP mem (Binary oldval newval)));
    ins_cost(VOLATILE_REF_COST);
  
    effect(KILL cr);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8385,10 +8897,11 @@</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct compareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
<span class="udiff-line-added">+   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
    match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
    ins_cost(2 * VOLATILE_REF_COST);
    effect(TEMP_DEF res, KILL cr);
    format %{
      &quot;cmpxchg $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8484,11 +8997,11 @@</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct compareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
<span class="udiff-line-modified-removed">-   predicate(needs_acquiring_load_exclusive(n));</span>
<span class="udiff-line-modified-added">+   predicate(needs_acquiring_load_exclusive(n) &amp;&amp; (n-&gt;as_LoadStore()-&gt;barrier_data() == 0));</span>
    match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
    ins_cost(VOLATILE_REF_COST);
    effect(TEMP_DEF res, KILL cr);
    format %{
      &quot;cmpxchg_acq $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8585,10 +9098,11 @@</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct weakCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
<span class="udiff-line-added">+   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
    match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
    ins_cost(2 * VOLATILE_REF_COST);
    effect(KILL cr);
    format %{
      &quot;cmpxchg $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8692,12 +9206,12 @@</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct weakCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
<span class="udiff-line-removed">-   predicate(needs_acquiring_load_exclusive(n));</span>
    match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
<span class="udiff-line-added">+   predicate(needs_acquiring_load_exclusive(n) &amp;&amp; (n-&gt;as_LoadStore()-&gt;barrier_data() == 0));</span>
    ins_cost(VOLATILE_REF_COST);
    effect(KILL cr);
    format %{
      &quot;cmpxchg_acq $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
      &quot;csetw $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8743,10 +9257,11 @@</span>
    %}
    ins_pipe(pipe_serial);
  %}
  
  instruct get_and_setP(indirect mem, iRegP newv, iRegPNoSp prev) %{
<span class="udiff-line-added">+   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
    match(Set prev (GetAndSetP mem newv));
    ins_cost(2 * VOLATILE_REF_COST);
    format %{ &quot;atomic_xchg  $prev, $newv, [$mem]&quot; %}
    ins_encode %{
      __ atomic_xchg($prev$$Register, $newv$$Register, as_Register($mem$$base));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8786,11 +9301,11 @@</span>
    %}
    ins_pipe(pipe_serial);
  %}
  
  instruct get_and_setPAcq(indirect mem, iRegP newv, iRegPNoSp prev) %{
<span class="udiff-line-modified-removed">-   predicate(needs_acquiring_load_exclusive(n));</span>
<span class="udiff-line-modified-added">+   predicate(needs_acquiring_load_exclusive(n) &amp;&amp; (n-&gt;as_LoadStore()-&gt;barrier_data() == 0));</span>
    match(Set prev (GetAndSetP mem newv));
    ins_cost(VOLATILE_REF_COST);
    format %{ &quot;atomic_xchg_acq  $prev, $newv, [$mem]&quot; %}
    ins_encode %{
      __ atomic_xchgal($prev$$Register, $newv$$Register, as_Register($mem$$base));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9988,10 +10503,60 @@</span>
    %}
  
    ins_pipe(lmac_reg_reg);
  %}
  
<span class="udiff-line-added">+ // Combine Integer Signed Multiply &amp; Add/Sub/Neg Long</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ instruct smaddL(iRegLNoSp dst, iRegIorL2I src1, iRegIorL2I src2, iRegLNoSp src3) %{</span>
<span class="udiff-line-added">+   match(Set dst (AddL src3 (MulL (ConvI2L src1) (ConvI2L src2))));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_cost(INSN_COST * 3);</span>
<span class="udiff-line-added">+   format %{ &quot;smaddl  $dst, $src1, $src2, $src3&quot; %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_encode %{</span>
<span class="udiff-line-added">+     __ smaddl(as_Register($dst$$reg),</span>
<span class="udiff-line-added">+               as_Register($src1$$reg),</span>
<span class="udiff-line-added">+               as_Register($src2$$reg),</span>
<span class="udiff-line-added">+               as_Register($src3$$reg));</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_pipe(imac_reg_reg);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ instruct smsubL(iRegLNoSp dst, iRegIorL2I src1, iRegIorL2I src2, iRegLNoSp src3) %{</span>
<span class="udiff-line-added">+   match(Set dst (SubL src3 (MulL (ConvI2L src1) (ConvI2L src2))));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_cost(INSN_COST * 3);</span>
<span class="udiff-line-added">+   format %{ &quot;smsubl  $dst, $src1, $src2, $src3&quot; %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_encode %{</span>
<span class="udiff-line-added">+     __ smsubl(as_Register($dst$$reg),</span>
<span class="udiff-line-added">+               as_Register($src1$$reg),</span>
<span class="udiff-line-added">+               as_Register($src2$$reg),</span>
<span class="udiff-line-added">+               as_Register($src3$$reg));</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_pipe(imac_reg_reg);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ instruct smnegL(iRegLNoSp dst, iRegIorL2I src1, iRegIorL2I src2, immL0 zero) %{</span>
<span class="udiff-line-added">+   match(Set dst (MulL (SubL zero (ConvI2L src1)) (ConvI2L src2)));</span>
<span class="udiff-line-added">+   match(Set dst (MulL (ConvI2L src1) (SubL zero (ConvI2L src2))));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_cost(INSN_COST * 3);</span>
<span class="udiff-line-added">+   format %{ &quot;smnegl  $dst, $src1, $src2&quot; %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_encode %{</span>
<span class="udiff-line-added">+     __ smnegl(as_Register($dst$$reg),</span>
<span class="udiff-line-added">+               as_Register($src1$$reg),</span>
<span class="udiff-line-added">+               as_Register($src2$$reg));</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_pipe(imac_reg_reg);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
  // Integer Divide
  
  instruct divI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{
    match(Set dst (DivI src1 src2));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11339,18 +11904,15 @@</span>
  // Shift Left followed by Shift Right.
  // This idiom is used by the compiler for the i2b bytecode etc.
  instruct sbfmL(iRegLNoSp dst, iRegL src, immI lshift_count, immI rshift_count)
  %{
    match(Set dst (RShiftL (LShiftL src lshift_count) rshift_count));
<span class="udiff-line-removed">-   // Make sure we are not going to exceed what sbfm can do.</span>
<span class="udiff-line-removed">-   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 63</span>
<span class="udiff-line-removed">-             &amp;&amp; (unsigned int)n-&gt;in(1)-&gt;in(2)-&gt;get_int() &lt;= 63);</span>
<span class="udiff-line-removed">- </span>
    ins_cost(INSN_COST * 2);
    format %{ &quot;sbfm  $dst, $src, $rshift_count - $lshift_count, #63 - $lshift_count&quot; %}
    ins_encode %{
<span class="udiff-line-modified-removed">-     int lshift = $lshift_count$$constant, rshift = $rshift_count$$constant;</span>
<span class="udiff-line-modified-added">+     int lshift = $lshift_count$$constant &amp; 63;</span>
<span class="udiff-line-added">+     int rshift = $rshift_count$$constant &amp; 63;</span>
      int s = 63 - lshift;
      int r = (rshift - lshift) &amp; 63;
      __ sbfm(as_Register($dst$$reg),
              as_Register($src$$reg),
              r, s);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11362,18 +11924,15 @@</span>
  // Shift Left followed by Shift Right.
  // This idiom is used by the compiler for the i2b bytecode etc.
  instruct sbfmwI(iRegINoSp dst, iRegIorL2I src, immI lshift_count, immI rshift_count)
  %{
    match(Set dst (RShiftI (LShiftI src lshift_count) rshift_count));
<span class="udiff-line-removed">-   // Make sure we are not going to exceed what sbfmw can do.</span>
<span class="udiff-line-removed">-   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 31</span>
<span class="udiff-line-removed">-             &amp;&amp; (unsigned int)n-&gt;in(1)-&gt;in(2)-&gt;get_int() &lt;= 31);</span>
<span class="udiff-line-removed">- </span>
    ins_cost(INSN_COST * 2);
    format %{ &quot;sbfmw  $dst, $src, $rshift_count - $lshift_count, #31 - $lshift_count&quot; %}
    ins_encode %{
<span class="udiff-line-modified-removed">-     int lshift = $lshift_count$$constant, rshift = $rshift_count$$constant;</span>
<span class="udiff-line-modified-added">+     int lshift = $lshift_count$$constant &amp; 31;</span>
<span class="udiff-line-added">+     int rshift = $rshift_count$$constant &amp; 31;</span>
      int s = 31 - lshift;
      int r = (rshift - lshift) &amp; 31;
      __ sbfmw(as_Register($dst$$reg),
              as_Register($src$$reg),
              r, s);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11385,18 +11944,15 @@</span>
  // Shift Left followed by Shift Right.
  // This idiom is used by the compiler for the i2b bytecode etc.
  instruct ubfmL(iRegLNoSp dst, iRegL src, immI lshift_count, immI rshift_count)
  %{
    match(Set dst (URShiftL (LShiftL src lshift_count) rshift_count));
<span class="udiff-line-removed">-   // Make sure we are not going to exceed what ubfm can do.</span>
<span class="udiff-line-removed">-   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 63</span>
<span class="udiff-line-removed">-             &amp;&amp; (unsigned int)n-&gt;in(1)-&gt;in(2)-&gt;get_int() &lt;= 63);</span>
<span class="udiff-line-removed">- </span>
    ins_cost(INSN_COST * 2);
    format %{ &quot;ubfm  $dst, $src, $rshift_count - $lshift_count, #63 - $lshift_count&quot; %}
    ins_encode %{
<span class="udiff-line-modified-removed">-     int lshift = $lshift_count$$constant, rshift = $rshift_count$$constant;</span>
<span class="udiff-line-modified-added">+     int lshift = $lshift_count$$constant &amp; 63;</span>
<span class="udiff-line-added">+     int rshift = $rshift_count$$constant &amp; 63;</span>
      int s = 63 - lshift;
      int r = (rshift - lshift) &amp; 63;
      __ ubfm(as_Register($dst$$reg),
              as_Register($src$$reg),
              r, s);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11408,18 +11964,15 @@</span>
  // Shift Left followed by Shift Right.
  // This idiom is used by the compiler for the i2b bytecode etc.
  instruct ubfmwI(iRegINoSp dst, iRegIorL2I src, immI lshift_count, immI rshift_count)
  %{
    match(Set dst (URShiftI (LShiftI src lshift_count) rshift_count));
<span class="udiff-line-removed">-   // Make sure we are not going to exceed what ubfmw can do.</span>
<span class="udiff-line-removed">-   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 31</span>
<span class="udiff-line-removed">-             &amp;&amp; (unsigned int)n-&gt;in(1)-&gt;in(2)-&gt;get_int() &lt;= 31);</span>
<span class="udiff-line-removed">- </span>
    ins_cost(INSN_COST * 2);
    format %{ &quot;ubfmw  $dst, $src, $rshift_count - $lshift_count, #31 - $lshift_count&quot; %}
    ins_encode %{
<span class="udiff-line-modified-removed">-     int lshift = $lshift_count$$constant, rshift = $rshift_count$$constant;</span>
<span class="udiff-line-modified-added">+     int lshift = $lshift_count$$constant &amp; 31;</span>
<span class="udiff-line-added">+     int rshift = $rshift_count$$constant &amp; 31;</span>
      int s = 31 - lshift;
      int r = (rshift - lshift) &amp; 31;
      __ ubfmw(as_Register($dst$$reg),
              as_Register($src$$reg),
              r, s);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11430,32 +11983,36 @@</span>
  // Bitfield extract with shift &amp; mask
  
  instruct ubfxwI(iRegINoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
  %{
    match(Set dst (AndI (URShiftI src rshift) mask));
<span class="udiff-line-added">+   // Make sure we are not going to exceed what ubfxw can do.</span>
<span class="udiff-line-added">+   predicate((exact_log2(n-&gt;in(2)-&gt;get_int() + 1) + (n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 31)) &lt;= (31 + 1));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;ubfxw $dst, $src, $rshift, $mask&quot; %}
    ins_encode %{
<span class="udiff-line-modified-removed">-     int rshift = $rshift$$constant;</span>
<span class="udiff-line-modified-added">+     int rshift = $rshift$$constant &amp; 31;</span>
      long mask = $mask$$constant;
      int width = exact_log2(mask+1);
      __ ubfxw(as_Register($dst$$reg),
              as_Register($src$$reg), rshift, width);
    %}
    ins_pipe(ialu_reg_shift);
  %}
  instruct ubfxL(iRegLNoSp dst, iRegL src, immI rshift, immL_bitmask mask)
  %{
    match(Set dst (AndL (URShiftL src rshift) mask));
<span class="udiff-line-added">+   // Make sure we are not going to exceed what ubfx can do.</span>
<span class="udiff-line-added">+   predicate((exact_log2_long(n-&gt;in(2)-&gt;get_long() + 1) + (n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 63)) &lt;= (63 + 1));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;ubfx $dst, $src, $rshift, $mask&quot; %}
    ins_encode %{
<span class="udiff-line-modified-removed">-     int rshift = $rshift$$constant;</span>
<span class="udiff-line-modified-added">+     int rshift = $rshift$$constant &amp; 63;</span>
      long mask = $mask$$constant;
<span class="udiff-line-modified-removed">-     int width = exact_log2(mask+1);</span>
<span class="udiff-line-modified-added">+     int width = exact_log2_long(mask+1);</span>
      __ ubfx(as_Register($dst$$reg),
              as_Register($src$$reg), rshift, width);
    %}
    ins_pipe(ialu_reg_shift);
  %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11463,15 +12020,17 @@</span>
  // We can use ubfx when extending an And with a mask when we know mask
  // is positive.  We know that because immI_bitmask guarantees it.
  instruct ubfxIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
  %{
    match(Set dst (ConvI2L (AndI (URShiftI src rshift) mask)));
<span class="udiff-line-added">+   // Make sure we are not going to exceed what ubfxw can do.</span>
<span class="udiff-line-added">+   predicate((exact_log2(n-&gt;in(1)-&gt;in(2)-&gt;get_int() + 1) + (n-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 31)) &lt;= (31 + 1));</span>
  
    ins_cost(INSN_COST * 2);
    format %{ &quot;ubfx $dst, $src, $rshift, $mask&quot; %}
    ins_encode %{
<span class="udiff-line-modified-removed">-     int rshift = $rshift$$constant;</span>
<span class="udiff-line-modified-added">+     int rshift = $rshift$$constant &amp; 31;</span>
      long mask = $mask$$constant;
      int width = exact_log2(mask+1);
      __ ubfx(as_Register($dst$$reg),
              as_Register($src$$reg), rshift, width);
    %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11481,17 +12040,16 @@</span>
  // We can use ubfiz when masking by a positive number and then left shifting the result.
  // We know that the mask is positive because immI_bitmask guarantees it.
  instruct ubfizwI(iRegINoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
  %{
    match(Set dst (LShiftI (AndI src mask) lshift));
<span class="udiff-line-modified-removed">-   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 31 &amp;&amp;</span>
<span class="udiff-line-removed">-     (exact_log2(n-&gt;in(1)-&gt;in(2)-&gt;get_int()+1) + (unsigned int)n-&gt;in(2)-&gt;get_int()) &lt;= (31+1));</span>
<span class="udiff-line-modified-added">+   predicate((exact_log2(n-&gt;in(1)-&gt;in(2)-&gt;get_int() + 1) + (n-&gt;in(2)-&gt;get_int() &amp; 31)) &lt;= (31 + 1));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;ubfizw $dst, $src, $lshift, $mask&quot; %}
    ins_encode %{
<span class="udiff-line-modified-removed">-     int lshift = $lshift$$constant;</span>
<span class="udiff-line-modified-added">+     int lshift = $lshift$$constant &amp; 31;</span>
      long mask = $mask$$constant;
      int width = exact_log2(mask+1);
      __ ubfizw(as_Register($dst$$reg),
            as_Register($src$$reg), lshift, width);
    %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11500,36 +12058,34 @@</span>
  // We can use ubfiz when masking by a positive number and then left shifting the result.
  // We know that the mask is positive because immL_bitmask guarantees it.
  instruct ubfizL(iRegLNoSp dst, iRegL src, immI lshift, immL_bitmask mask)
  %{
    match(Set dst (LShiftL (AndL src mask) lshift));
<span class="udiff-line-modified-removed">-   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 63 &amp;&amp;</span>
<span class="udiff-line-removed">-     (exact_log2_long(n-&gt;in(1)-&gt;in(2)-&gt;get_long()+1) + (unsigned int)n-&gt;in(2)-&gt;get_int()) &lt;= (63+1));</span>
<span class="udiff-line-modified-added">+   predicate((exact_log2_long(n-&gt;in(1)-&gt;in(2)-&gt;get_long() + 1) + (n-&gt;in(2)-&gt;get_int() &amp; 63)) &lt;= (63 + 1));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;ubfiz $dst, $src, $lshift, $mask&quot; %}
    ins_encode %{
<span class="udiff-line-modified-removed">-     int lshift = $lshift$$constant;</span>
<span class="udiff-line-modified-added">+     int lshift = $lshift$$constant &amp; 63;</span>
      long mask = $mask$$constant;
<span class="udiff-line-modified-removed">-     int width = exact_log2(mask+1);</span>
<span class="udiff-line-modified-added">+     int width = exact_log2_long(mask+1);</span>
      __ ubfiz(as_Register($dst$$reg),
            as_Register($src$$reg), lshift, width);
    %}
    ins_pipe(ialu_reg_shift);
  %}
  
  // If there is a convert I to L block between and AndI and a LShiftL, we can also match ubfiz
  instruct ubfizIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
  %{
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftL (ConvI2L(AndI src mask)) lshift));</span>
<span class="udiff-line-modified-removed">-   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 31 &amp;&amp;</span>
<span class="udiff-line-removed">-     (exact_log2((unsigned int)n-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;get_int()+1) + (unsigned int)n-&gt;in(2)-&gt;get_int()) &lt;= 32);</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftL (ConvI2L (AndI src mask)) lshift));</span>
<span class="udiff-line-modified-added">+   predicate((exact_log2(n-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;get_int() + 1) + (n-&gt;in(2)-&gt;get_int() &amp; 63)) &lt;= (63 + 1));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;ubfiz $dst, $src, $lshift, $mask&quot; %}
    ins_encode %{
<span class="udiff-line-modified-removed">-     int lshift = $lshift$$constant;</span>
<span class="udiff-line-modified-added">+     int lshift = $lshift$$constant &amp; 63;</span>
      long mask = $mask$$constant;
      int width = exact_log2(mask+1);
      __ ubfiz(as_Register($dst$$reg),
               as_Register($src$$reg), lshift, width);
    %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11539,11 +12095,11 @@</span>
  // Rotations
  
  instruct extrOrL(iRegLNoSp dst, iRegL src1, iRegL src2, immI lshift, immI rshift, rFlagsReg cr)
  %{
    match(Set dst (OrL (LShiftL src1 lshift) (URShiftL src2 rshift)));
<span class="udiff-line-modified-removed">-   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 63));</span>
<span class="udiff-line-modified-added">+   predicate(0 == (((n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 63) + (n-&gt;in(2)-&gt;in(2)-&gt;get_int() &amp; 63)) &amp; 63));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
  
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11554,11 +12110,11 @@</span>
  %}
  
  instruct extrOrI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI lshift, immI rshift, rFlagsReg cr)
  %{
    match(Set dst (OrI (LShiftI src1 lshift) (URShiftI src2 rshift)));
<span class="udiff-line-modified-removed">-   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 31));</span>
<span class="udiff-line-modified-added">+   predicate(0 == (((n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 31) + (n-&gt;in(2)-&gt;in(2)-&gt;get_int() &amp; 31)) &amp; 31));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
  
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11569,11 +12125,11 @@</span>
  %}
  
  instruct extrAddL(iRegLNoSp dst, iRegL src1, iRegL src2, immI lshift, immI rshift, rFlagsReg cr)
  %{
    match(Set dst (AddL (LShiftL src1 lshift) (URShiftL src2 rshift)));
<span class="udiff-line-modified-removed">-   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 63));</span>
<span class="udiff-line-modified-added">+   predicate(0 == (((n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 63) + (n-&gt;in(2)-&gt;in(2)-&gt;get_int() &amp; 63)) &amp; 63));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
  
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11584,11 +12140,11 @@</span>
  %}
  
  instruct extrAddI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI lshift, immI rshift, rFlagsReg cr)
  %{
    match(Set dst (AddI (LShiftI src1 lshift) (URShiftI src2 rshift)));
<span class="udiff-line-modified-removed">-   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 31));</span>
<span class="udiff-line-modified-added">+   predicate(0 == (((n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 31) + (n-&gt;in(2)-&gt;in(2)-&gt;get_int() &amp; 31)) &amp; 31));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
  
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12674,10 +13230,33 @@</span>
    %}
  
    ins_pipe(fp_div_d);
  %}
  
<span class="udiff-line-added">+ // Math.rint, floor, ceil</span>
<span class="udiff-line-added">+ instruct roundD_reg(vRegD dst, vRegD src, immI rmode) %{</span>
<span class="udiff-line-added">+   match(Set dst (RoundDoubleMode src rmode));</span>
<span class="udiff-line-added">+   format %{ &quot;frint  $dst, $src, $rmode&quot; %}</span>
<span class="udiff-line-added">+   ins_encode %{</span>
<span class="udiff-line-added">+     switch ($rmode$$constant) {</span>
<span class="udiff-line-added">+       case RoundDoubleModeNode::rmode_rint:</span>
<span class="udiff-line-added">+         __ frintnd(as_FloatRegister($dst$$reg),</span>
<span class="udiff-line-added">+                    as_FloatRegister($src$$reg));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       case RoundDoubleModeNode::rmode_floor:</span>
<span class="udiff-line-added">+         __ frintmd(as_FloatRegister($dst$$reg),</span>
<span class="udiff-line-added">+                    as_FloatRegister($src$$reg));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       case RoundDoubleModeNode::rmode_ceil:</span>
<span class="udiff-line-added">+         __ frintpd(as_FloatRegister($dst$$reg),</span>
<span class="udiff-line-added">+                    as_FloatRegister($src$$reg));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+   ins_pipe(fp_uop_d);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
  // ============================================================================
  // Logical Instructions
  
  // Integer Logical Instructions
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13868,11 +14447,11 @@</span>
  
    ins_cost(3 * INSN_COST);
    format %{ &quot;fcmps $src1, 0.0&quot; %}
  
    ins_encode %{
<span class="udiff-line-modified-removed">-     __ fcmps(as_FloatRegister($src1$$reg), 0.0D);</span>
<span class="udiff-line-modified-added">+     __ fcmps(as_FloatRegister($src1$$reg), 0.0);</span>
    %}
  
    ins_pipe(pipe_class_compare);
  %}
  // FROM HERE
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13897,11 +14476,11 @@</span>
  
    ins_cost(3 * INSN_COST);
    format %{ &quot;fcmpd $src1, 0.0&quot; %}
  
    ins_encode %{
<span class="udiff-line-modified-removed">-     __ fcmpd(as_FloatRegister($src1$$reg), 0.0D);</span>
<span class="udiff-line-modified-added">+     __ fcmpd(as_FloatRegister($src1$$reg), 0.0);</span>
    %}
  
    ins_pipe(pipe_class_compare);
  %}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13973,11 +14552,11 @@</span>
  
    ins_encode %{
      Label done;
      FloatRegister s1 = as_FloatRegister($src1$$reg);
      Register d = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     __ fcmps(s1, 0.0D);</span>
<span class="udiff-line-modified-added">+     __ fcmps(s1, 0.0);</span>
      // installs 0 if EQ else -1
      __ csinvw(d, zr, zr, Assembler::EQ);
      // keeps -1 if less or unordered else installs 1
      __ csnegw(d, d, d, Assembler::LT);
      __ bind(done);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -14000,11 +14579,11 @@</span>
  
    ins_encode %{
      Label done;
      FloatRegister s1 = as_FloatRegister($src1$$reg);
      Register d = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     __ fcmpd(s1, 0.0D);</span>
<span class="udiff-line-modified-added">+     __ fcmpd(s1, 0.0);</span>
      // installs 0 if EQ else -1
      __ csinvw(d, zr, zr, Assembler::EQ);
      // keeps -1 if less or unordered else installs 1
      __ csnegw(d, d, d, Assembler::LT);
      __ bind(done);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -14051,59 +14630,67 @@</span>
  %}
  
  // ============================================================================
  // Max and Min
  
<span class="udiff-line-modified-removed">- instruct minI_rReg(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)</span>
<span class="udiff-line-modified-added">+ instruct cmovI_reg_reg_lt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)</span>
  %{
<span class="udiff-line-modified-removed">-   match(Set dst (MinI src1 src2));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   effect(DEF dst, USE src1, USE src2, KILL cr);</span>
<span class="udiff-line-removed">-   size(8);</span>
<span class="udiff-line-modified-added">+   effect( DEF dst, USE src1, USE src2, USE cr );</span>
  
<span class="udiff-line-modified-removed">-   ins_cost(INSN_COST * 3);</span>
<span class="udiff-line-modified-removed">-   format %{</span>
<span class="udiff-line-removed">-     &quot;cmpw $src1 $src2\t signed int\n\t&quot;</span>
<span class="udiff-line-removed">-     &quot;cselw $dst, $src1, $src2 lt\t&quot;</span>
<span class="udiff-line-removed">-   %}</span>
<span class="udiff-line-modified-added">+   ins_cost(INSN_COST * 2);</span>
<span class="udiff-line-modified-added">+   format %{ &quot;cselw $dst, $src1, $src2 lt\t&quot;  %}</span>
  
    ins_encode %{
<span class="udiff-line-removed">-     __ cmpw(as_Register($src1$$reg),</span>
<span class="udiff-line-removed">-             as_Register($src2$$reg));</span>
      __ cselw(as_Register($dst$$reg),
               as_Register($src1$$reg),
               as_Register($src2$$reg),
               Assembler::LT);
    %}
  
<span class="udiff-line-modified-removed">-   ins_pipe(ialu_reg_reg);</span>
<span class="udiff-line-modified-added">+   ins_pipe(icond_reg_reg);</span>
  %}
<span class="udiff-line-removed">- // FROM HERE</span>
  
<span class="udiff-line-modified-removed">- instruct maxI_rReg(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)</span>
<span class="udiff-line-modified-added">+ instruct minI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)</span>
  %{
<span class="udiff-line-modified-removed">-   match(Set dst (MaxI src1 src2));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   effect(DEF dst, USE src1, USE src2, KILL cr);</span>
<span class="udiff-line-removed">-   size(8);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+   match(Set dst (MinI src1 src2));</span>
    ins_cost(INSN_COST * 3);
<span class="udiff-line-modified-removed">-   format %{</span>
<span class="udiff-line-modified-removed">-     &quot;cmpw $src1 $src2\t signed int\n\t&quot;</span>
<span class="udiff-line-modified-removed">-     &quot;cselw $dst, $src1, $src2 gt\t&quot;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   expand %{</span>
<span class="udiff-line-modified-added">+     rFlagsReg cr;</span>
<span class="udiff-line-added">+     compI_reg_reg(cr, src1, src2);</span>
<span class="udiff-line-added">+     cmovI_reg_reg_lt(dst, src1, src2, cr);</span>
    %}
  
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ // FROM HERE</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ instruct cmovI_reg_reg_gt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   effect( DEF dst, USE src1, USE src2, USE cr );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_cost(INSN_COST * 2);</span>
<span class="udiff-line-added">+   format %{ &quot;cselw $dst, $src1, $src2 gt\t&quot;  %}</span>
<span class="udiff-line-added">+ </span>
    ins_encode %{
<span class="udiff-line-removed">-     __ cmpw(as_Register($src1$$reg),</span>
<span class="udiff-line-removed">-             as_Register($src2$$reg));</span>
      __ cselw(as_Register($dst$$reg),
               as_Register($src1$$reg),
               as_Register($src2$$reg),
               Assembler::GT);
    %}
  
<span class="udiff-line-modified-removed">-   ins_pipe(ialu_reg_reg);</span>
<span class="udiff-line-modified-added">+   ins_pipe(icond_reg_reg);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ instruct maxI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)</span>
<span class="udiff-line-added">+ %{</span>
<span class="udiff-line-added">+   match(Set dst (MaxI src1 src2));</span>
<span class="udiff-line-added">+   ins_cost(INSN_COST * 3);</span>
<span class="udiff-line-added">+   expand %{</span>
<span class="udiff-line-added">+     rFlagsReg cr;</span>
<span class="udiff-line-added">+     compI_reg_reg(cr, src1, src2);</span>
<span class="udiff-line-added">+     cmovI_reg_reg_gt(dst, src1, src2, cr);</span>
<span class="udiff-line-added">+   %}</span>
  %}
  
  // ============================================================================
  // Branch Instructions
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -14548,13 +15135,14 @@</span>
  // Safepoint Instructions
  
  // TODO
  // provide a near and far version of this code
  
<span class="udiff-line-modified-removed">- instruct safePoint(iRegP poll)</span>
<span class="udiff-line-modified-added">+ instruct safePoint(rFlagsReg cr, iRegP poll)</span>
  %{
    match(SafePoint poll);
<span class="udiff-line-added">+   effect(KILL cr);</span>
  
    format %{
      &quot;ldrw zr, [$poll]\t# Safepoint: poll for GC&quot;
    %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16722,11 +17310,11 @@</span>
  %}
  
  instruct vsll8B_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
              n-&gt;as_Vector()-&gt;length() == 8);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVB src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVB src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (8B)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 8) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16741,11 +17329,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsll16B_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVB src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVB src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (16B)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 8) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16761,11 +17349,11 @@</span>
  %}
  
  instruct vsra8B_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
              n-&gt;as_Vector()-&gt;length() == 8);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVB src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVB src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (8B)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 8) sh = 7;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16775,11 +17363,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsra16B_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVB src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVB src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (16B)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 8) sh = 7;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16790,11 +17378,11 @@</span>
  %}
  
  instruct vsrl8B_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
              n-&gt;as_Vector()-&gt;length() == 8);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVB src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVB src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (8B)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 8) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16809,11 +17397,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsrl16B_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVB src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVB src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (16B)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 8) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16926,11 +17514,11 @@</span>
  %}
  
  instruct vsll4S_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
              n-&gt;as_Vector()-&gt;length() == 4);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVS src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (4H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16945,11 +17533,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsll8S_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVS src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (8H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16965,11 +17553,11 @@</span>
  %}
  
  instruct vsra4S_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
              n-&gt;as_Vector()-&gt;length() == 4);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVS src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVS src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (4H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) sh = 15;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16979,11 +17567,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsra8S_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVS src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVS src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (8H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) sh = 15;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16994,11 +17582,11 @@</span>
  %}
  
  instruct vsrl4S_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
              n-&gt;as_Vector()-&gt;length() == 4);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVS src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVS src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (4H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17013,11 +17601,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsrl8S_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVS src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVS src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (8H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17126,11 +17714,11 @@</span>
    ins_pipe(vshift128);
  %}
  
  instruct vsll2I_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVI src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVI src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (2S)&quot; %}
    ins_encode %{
      __ shl(as_FloatRegister($dst$$reg), __ T2S,
             as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17139,11 +17727,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsll4I_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVI src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVI src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (4S)&quot; %}
    ins_encode %{
      __ shl(as_FloatRegister($dst$$reg), __ T4S,
             as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17152,11 +17740,11 @@</span>
    ins_pipe(vshift128_imm);
  %}
  
  instruct vsra2I_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVI src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVI src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (2S)&quot; %}
    ins_encode %{
      __ sshr(as_FloatRegister($dst$$reg), __ T2S,
              as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17165,11 +17753,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsra4I_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVI src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVI src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (4S)&quot; %}
    ins_encode %{
      __ sshr(as_FloatRegister($dst$$reg), __ T4S,
              as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17178,11 +17766,11 @@</span>
    ins_pipe(vshift128_imm);
  %}
  
  instruct vsrl2I_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVI src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVI src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (2S)&quot; %}
    ins_encode %{
      __ ushr(as_FloatRegister($dst$$reg), __ T2S,
              as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17191,11 +17779,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsrl4I_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVI src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVI src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (4S)&quot; %}
    ins_encode %{
      __ ushr(as_FloatRegister($dst$$reg), __ T4S,
              as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17251,11 +17839,11 @@</span>
    ins_pipe(vshift128);
  %}
  
  instruct vsll2L_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVL src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVL src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (2D)&quot; %}
    ins_encode %{
      __ shl(as_FloatRegister($dst$$reg), __ T2D,
             as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17264,11 +17852,11 @@</span>
    ins_pipe(vshift128_imm);
  %}
  
  instruct vsra2L_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVL src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVL src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (2D)&quot; %}
    ins_encode %{
      __ sshr(as_FloatRegister($dst$$reg), __ T2D,
              as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17277,11 +17865,11 @@</span>
    ins_pipe(vshift128_imm);
  %}
  
  instruct vsrl2L_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVL src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVL src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (2D)&quot; %}
    ins_encode %{
      __ ushr(as_FloatRegister($dst$$reg), __ T2D,
              as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17372,10 +17960,33 @@</span>
              as_FloatRegister($src2$$reg));
    %}
    ins_pipe(vdop_fp128);
  %}
  
<span class="udiff-line-added">+ instruct vround2D_reg(vecX dst, vecX src, immI rmode) %{</span>
<span class="udiff-line-added">+   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; n-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_DOUBLE);</span>
<span class="udiff-line-added">+   match(Set dst (RoundDoubleModeV src rmode));</span>
<span class="udiff-line-added">+   format %{ &quot;frint  $dst, $src, $rmode&quot; %}</span>
<span class="udiff-line-added">+   ins_encode %{</span>
<span class="udiff-line-added">+     switch ($rmode$$constant) {</span>
<span class="udiff-line-added">+       case RoundDoubleModeNode::rmode_rint:</span>
<span class="udiff-line-added">+         __ frintn(as_FloatRegister($dst$$reg), __ T2D,</span>
<span class="udiff-line-added">+                   as_FloatRegister($src$$reg));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       case RoundDoubleModeNode::rmode_floor:</span>
<span class="udiff-line-added">+         __ frintm(as_FloatRegister($dst$$reg), __ T2D,</span>
<span class="udiff-line-added">+                   as_FloatRegister($src$$reg));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       case RoundDoubleModeNode::rmode_ceil:</span>
<span class="udiff-line-added">+         __ frintp(as_FloatRegister($dst$$reg), __ T2D,</span>
<span class="udiff-line-added">+                   as_FloatRegister($src$$reg));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+   ins_pipe(vdop_fp128);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
  //----------PEEPHOLE RULES-----------------------------------------------------
  // These must follow all instruction definitions as they use the names
  // defined in the instructions definitions.
  //
  // peepmatch ( root_instr_name [preceding_instruction]* );
</pre>
<center><a href="../../.mx.jvmci/suite.py.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aarch64Test.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
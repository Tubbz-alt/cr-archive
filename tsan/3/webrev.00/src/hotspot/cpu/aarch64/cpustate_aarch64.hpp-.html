<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/cpustate_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef _CPU_STATE_H
 26 #define _CPU_STATE_H
 27 
 28 #include &lt;sys/types.h&gt;
 29 
 30 /*
 31  * symbolic names used to identify general registers which also match
 32  * the registers indices in machine code
 33  *
 34  * We have 32 general registers which can be read/written as 32 bit or
 35  * 64 bit sources/sinks and are appropriately referred to as Wn or Xn
 36  * in the assembly code.  Some instructions mix these access modes
 37  * (e.g. ADD X0, X1, W2) so the implementation of the instruction
 38  * needs to *know* which type of read or write access is required.
 39  */
 40 enum GReg {
 41   R0,
 42   R1,
 43   R2,
 44   R3,
 45   R4,
 46   R5,
 47   R6,
 48   R7,
 49   R8,
 50   R9,
 51   R10,
 52   R11,
 53   R12,
 54   R13,
 55   R14,
 56   R15,
 57   R16,
 58   R17,
 59   R18,
 60   R19,
 61   R20,
 62   R21,
 63   R22,
 64   R23,
 65   R24,
 66   R25,
 67   R26,
 68   R27,
 69   R28,
 70   R29,
 71   R30,
 72   R31,
 73   // and now the aliases
 74   RSCRATCH1=R8,
 75   RSCRATCH2=R9,
 76   RMETHOD=R12,
 77   RESP=R20,
 78   RDISPATCH=R21,
 79   RBCP=R22,
 80   RLOCALS=R24,
 81   RMONITORS=R25,
 82   RCPOOL=R26,
 83   RHEAPBASE=R27,
 84   RTHREAD=R28,
 85   FP = R29,
 86   LR = R30,
 87   SP = R31,
 88   ZR = R31
 89 };
 90 
 91 /*
 92  * symbolic names used to refer to floating point registers which also
 93  * match the registers indices in machine code
 94  *
 95  * We have 32 FP registers which can be read/written as 8, 16, 32, 64
 96  * and 128 bit sources/sinks and are appropriately referred to as Bn,
 97  * Hn, Sn, Dn and Qn in the assembly code. Some instructions mix these
 98  * access modes (e.g. FCVT S0, D0) so the implementation of the
 99  * instruction needs to *know* which type of read or write access is
100  * required.
101  */
102 
103 enum VReg {
104   V0,
105   V1,
106   V2,
107   V3,
108   V4,
109   V5,
110   V6,
111   V7,
112   V8,
113   V9,
114   V10,
115   V11,
116   V12,
117   V13,
118   V14,
119   V15,
120   V16,
121   V17,
122   V18,
123   V19,
124   V20,
125   V21,
126   V22,
127   V23,
128   V24,
129   V25,
130   V26,
131   V27,
132   V28,
133   V29,
134   V30,
135   V31,
136 };
137 
138 /**
139  * all the different integer bit patterns for the components of a
140  * general register are overlaid here using a union so as to allow all
141  * reading and writing of the desired bits.
142  *
143  * n.b. the ARM spec says that when you write a 32 bit register you
144  * are supposed to write the low 32 bits and zero the high 32
145  * bits. But we don&#39;t actually have to care about this because Java
146  * will only ever consume the 32 bits value as a 64 bit quantity after
147  * an explicit extend.
148  */
149 union GRegisterValue
150 {
151   int8_t s8;
152   int16_t s16;
153   int32_t s32;
154   int64_t s64;
155   u_int8_t u8;
156   u_int16_t u16;
157   u_int32_t u32;
158   u_int64_t u64;
159 };
160 
161 class GRegister
162 {
163 public:
164   GRegisterValue value;
165 };
166 
167 /*
168  * float registers provide for storage of a single, double or quad
169  * word format float in the same register. single floats are not
170  * paired within each double register as per 32 bit arm. instead each
171  * 128 bit register Vn embeds the bits for Sn, and Dn in the lower
172  * quarter and half, respectively, of the bits for Qn.
173  *
174  * The upper bits can also be accessed as single or double floats by
175  * the float vector operations using indexing e.g. V1.D[1], V1.S[3]
176  * etc and, for SIMD operations using a horrible index range notation.
177  *
178  * The spec also talks about accessing float registers as half words
179  * and bytes with Hn and Bn providing access to the low 16 and 8 bits
180  * of Vn but it is not really clear what these bits represent. We can
181  * probably ignore this for Java anyway. However, we do need to access
182  * the raw bits at 32 and 64 bit resolution to load to/from integer
183  * registers.
184  */
185 
186 union FRegisterValue
187 {
188   float s;
189   double d;
190   long double q;
191   // eventually we will need to be able to access the data as a vector
192   // the integral array elements allow us to access the bits in s, d,
193   // q, vs and vd at an appropriate level of granularity
194   u_int8_t vb[16];
195   u_int16_t vh[8];
196   u_int32_t vw[4];
197   u_int64_t vx[2];
198   float vs[4];
199   double vd[2];
200 };
201 
202 class FRegister
203 {
204 public:
205   FRegisterValue value;
206 };
207 
208 /*
209  * CPSR register -- this does not exist as a directly accessible
210  * register but we need to store the flags so we can implement
211  * flag-seting and flag testing operations
212  *
213  * we can possibly use injected x86 asm to report the outcome of flag
214  * setting operations. if so we will need to grab the flags
215  * immediately after the operation in order to ensure we don&#39;t lose
216  * them because of the actions of the simulator. so we still need
217  * somewhere to store the condition codes.
218  */
219 
220 class CPSRRegister
221 {
222 public:
223   u_int32_t value;
224 
225 /*
226  * condition register bit select values
227  *
228  * the order of bits here is important because some of
229  * the flag setting conditional instructions employ a
230  * bit field to populate the flags when a false condition
231  * bypasses execution of the operation and we want to
232  * be able to assign the flags register using the
233  * supplied value.
234  */
235 
236   enum CPSRIdx {
237     V_IDX,
238     C_IDX,
239     Z_IDX,
240     N_IDX
241   };
242 
243   enum CPSRMask {
244     V = 1 &lt;&lt; V_IDX,
245     C = 1 &lt;&lt; C_IDX,
246     Z = 1 &lt;&lt; Z_IDX,
247     N = 1 &lt;&lt; N_IDX
248   };
249 
250   static const int CPSR_ALL_FLAGS = (V | C | Z | N);
251 };
252 
253 // auxiliary function to assemble the relevant bits from
254 // the x86 EFLAGS register into an ARM CPSR value
255 
256 #define X86_V_IDX 11
257 #define X86_C_IDX 0
258 #define X86_Z_IDX 6
259 #define X86_N_IDX 7
260 
261 #define X86_V (1 &lt;&lt; X86_V_IDX)
262 #define X86_C (1 &lt;&lt; X86_C_IDX)
263 #define X86_Z (1 &lt;&lt; X86_Z_IDX)
264 #define X86_N (1 &lt;&lt; X86_N_IDX)
265 
266 inline u_int32_t convertX86Flags(u_int32_t x86flags)
267 {
268   u_int32_t flags;
269   // set N flag
270   flags = ((x86flags &amp; X86_N) &gt;&gt; X86_N_IDX);
271   // shift then or in Z flag
272   flags &lt;&lt;= 1;
273   flags |= ((x86flags &amp; X86_Z) &gt;&gt; X86_Z_IDX);
274   // shift then or in C flag
275   flags &lt;&lt;= 1;
276   flags |= ((x86flags &amp; X86_C) &gt;&gt; X86_C_IDX);
277   // shift then or in V flag
278   flags &lt;&lt;= 1;
279   flags |= ((x86flags &amp; X86_V) &gt;&gt; X86_V_IDX);
280 
281   return flags;
282 }
283 
284 inline u_int32_t convertX86FlagsFP(u_int32_t x86flags)
285 {
286   // x86 flags set by fcomi(x,y) are ZF:PF:CF
287   // (yes, that&#39;s PF for parity, WTF?)
288   // where
289   // 0) 0:0:0 means x &gt; y
290   // 1) 0:0:1 means x &lt; y
291   // 2) 1:0:0 means x = y
292   // 3) 1:1:1 means x and y are unordered
293   // note that we don&#39;t have to check PF so
294   // we really have a simple 2-bit case switch
295   // the corresponding ARM64 flags settings
296   //  in hi-&gt;lo bit order are
297   // 0) --C-
298   // 1) N---
299   // 2) -ZC-
300   // 3) --CV
301 
302   static u_int32_t armFlags[] = {
303       0b0010,
304       0b1000,
305       0b0110,
306       0b0011
307   };
308   // pick out the ZF and CF bits
309   u_int32_t zc = ((x86flags &amp; X86_Z) &gt;&gt; X86_Z_IDX);
310   zc &lt;&lt;= 1;
311   zc |= ((x86flags &amp; X86_C) &gt;&gt; X86_C_IDX);
312 
313   return armFlags[zc];
314 }
315 
316 /*
317  * FPSR register -- floating point status register
318 
319  * this register includes IDC, IXC, UFC, OFC, DZC, IOC and QC bits,
320  * and the floating point N, Z, C, V bits but the latter are unused in
321  * aarch64 mode. the sim ignores QC for now.
322  *
323  * bit positions are as per the ARMv7 FPSCR register
324  *
325  * IDC :  7 ==&gt; Input Denormal (cumulative exception bit)
326  * IXC :  4 ==&gt; Inexact
327  * UFC :  3 ==&gt; Underflow
328  * OFC :  2 ==&gt; Overflow
329  * DZC :  1 ==&gt; Division by Zero
330  * IOC :  0 ==&gt; Invalid Operation
331  */
332 
333 class FPSRRegister
334 {
335 public:
336   u_int32_t value;
337   // indices for bits in the FPSR register value
338   enum FPSRIdx {
339     IO_IDX = 0,
340     DZ_IDX = 1,
341     OF_IDX = 2,
342     UF_IDX = 3,
343     IX_IDX = 4,
344     ID_IDX = 7
345   };
346   // corresponding bits as numeric values
347   enum FPSRMask {
348     IO = (1 &lt;&lt; IO_IDX),
349     DZ = (1 &lt;&lt; DZ_IDX),
350     OF = (1 &lt;&lt; OF_IDX),
351     UF = (1 &lt;&lt; UF_IDX),
352     IX = (1 &lt;&lt; IX_IDX),
353     ID = (1 &lt;&lt; ID_IDX)
354   };
355   static const int FPSR_ALL_FPSRS = (IO | DZ | OF | UF | IX | ID);
356 };
357 
358 // debugger support
359 
360 enum PrintFormat
361 {
362   FMT_DECIMAL,
363   FMT_HEX,
364   FMT_SINGLE,
365   FMT_DOUBLE,
366   FMT_QUAD,
367   FMT_MULTI
368 };
369 
370 /*
371  * model of the registers and other state associated with the cpu
372  */
373 class CPUState
374 {
375   friend class AArch64Simulator;
376 private:
377   // this is the PC of the instruction being executed
378   u_int64_t pc;
379   // this is the PC of the instruction to be executed next
380   // it is defaulted to pc + 4 at instruction decode but
381   // execute may reset it
382 
383   u_int64_t nextpc;
384   GRegister gr[33];             // extra register at index 32 is used
385                                 // to hold zero value
386   FRegister fr[32];
387   CPSRRegister cpsr;
388   FPSRRegister fpsr;
389 
390 public:
391 
392   CPUState() {
393     gr[20].value.u64 = 0;  // establish initial condition for
394                            // checkAssertions()
395     trace_counter = 0;
396   }
397 
398   // General Register access macros
399 
400   // only xreg or xregs can be used as an lvalue in order to update a
401   // register. this ensures that the top part of a register is always
402   // assigned when it is written by the sim.
403 
404   inline u_int64_t &amp;xreg(GReg reg, int r31_is_sp) {
405     if (reg == R31 &amp;&amp; !r31_is_sp) {
406       return gr[32].value.u64;
407     } else {
408       return gr[reg].value.u64;
409     }
410   }
411 
412   inline int64_t &amp;xregs(GReg reg, int r31_is_sp) {
413     if (reg == R31 &amp;&amp; !r31_is_sp) {
414       return gr[32].value.s64;
415     } else {
416       return gr[reg].value.s64;
417     }
418   }
419 
420   inline u_int32_t wreg(GReg reg, int r31_is_sp) {
421     if (reg == R31 &amp;&amp; !r31_is_sp) {
422       return gr[32].value.u32;
423     } else {
424       return gr[reg].value.u32;
425     }
426   }
427 
428   inline int32_t wregs(GReg reg, int r31_is_sp) {
429     if (reg == R31 &amp;&amp; !r31_is_sp) {
430       return gr[32].value.s32;
431     } else {
432       return gr[reg].value.s32;
433     }
434   }
435 
436   inline u_int32_t hreg(GReg reg, int r31_is_sp) {
437     if (reg == R31 &amp;&amp; !r31_is_sp) {
438       return gr[32].value.u16;
439     } else {
440       return gr[reg].value.u16;
441     }
442   }
443 
444   inline int32_t hregs(GReg reg, int r31_is_sp) {
445     if (reg == R31 &amp;&amp; !r31_is_sp) {
446       return gr[32].value.s16;
447     } else {
448       return gr[reg].value.s16;
449     }
450   }
451 
452   inline u_int32_t breg(GReg reg, int r31_is_sp) {
453     if (reg == R31 &amp;&amp; !r31_is_sp) {
454       return gr[32].value.u8;
455     } else {
456       return gr[reg].value.u8;
457     }
458   }
459 
460   inline int32_t bregs(GReg reg, int r31_is_sp) {
461     if (reg == R31 &amp;&amp; !r31_is_sp) {
462       return gr[32].value.s8;
463     } else {
464       return gr[reg].value.s8;
465     }
466   }
467 
468   // FP Register access macros
469 
470   // all non-vector accessors return a reference so we can both read
471   // and assign
472 
473   inline float &amp;sreg(VReg reg) {
474     return fr[reg].value.s;
475   }
476 
477   inline double &amp;dreg(VReg reg) {
478     return fr[reg].value.d;
479   }
480 
481   inline long double &amp;qreg(VReg reg) {
482     return fr[reg].value.q;
483   }
484 
485   // all vector register accessors return a pointer
486 
487   inline float *vsreg(VReg reg) {
488     return &amp;fr[reg].value.vs[0];
489   }
490 
491   inline double *vdreg(VReg reg) {
492     return &amp;fr[reg].value.vd[0];
493   }
494 
495   inline u_int8_t *vbreg(VReg reg) {
496     return &amp;fr[reg].value.vb[0];
497   }
498 
499   inline u_int16_t *vhreg(VReg reg) {
500     return &amp;fr[reg].value.vh[0];
501   }
502 
503   inline u_int32_t *vwreg(VReg reg) {
504     return &amp;fr[reg].value.vw[0];
505   }
506 
507   inline u_int64_t *vxreg(VReg reg) {
508     return &amp;fr[reg].value.vx[0];
509   }
510 
511   union GRegisterValue prev_sp, prev_fp;
512 
513   static const int trace_size = 256;
514   u_int64_t trace_buffer[trace_size];
515   int trace_counter;
516 
517   bool checkAssertions()
518   {
519     // Make sure that SP is 16-aligned
520     // Also make sure that ESP is above SP.
521     // We don&#39;t care about checking ESP if it is null, i.e. it hasn&#39;t
522     // been used yet.
523     if (gr[31].value.u64 &amp; 0x0f) {
524       asm volatile(&quot;nop&quot;);
525       return false;
526     }
527     return true;
528   }
529 
530   // pc register accessors
531 
532   // this instruction can be used to fetch the current PC
533   u_int64_t getPC();
534   // instead of setting the current PC directly you can
535   // first set the next PC (either absolute or PC-relative)
536   // and later copy the next PC into the current PC
537   // this supports a default increment by 4 at instruction
538   // fetch with an optional reset by control instructions
539   u_int64_t getNextPC();
540   void setNextPC(u_int64_t next);
541   void offsetNextPC(int64_t offset);
542   // install nextpc as current pc
543   void updatePC();
544 
545   // this instruction can be used to save the next PC to LR
546   // just before installing a branch PC
547   inline void saveLR() { gr[LR].value.u64 = nextpc; }
548 
549   // cpsr register accessors
550   u_int32_t getCPSRRegister();
551   void setCPSRRegister(u_int32_t flags);
552   // read a specific subset of the flags as a bit pattern
553   // mask should be composed using elements of enum FlagMask
554   u_int32_t getCPSRBits(u_int32_t mask);
555   // assign a specific subset of the flags as a bit pattern
556   // mask and value should be composed using elements of enum FlagMask
557   void setCPSRBits(u_int32_t mask, u_int32_t value);
558   // test the value of a single flag returned as 1 or 0
559   u_int32_t testCPSR(CPSRRegister::CPSRIdx idx);
560   // set a single flag
561   void setCPSR(CPSRRegister::CPSRIdx idx);
562   // clear a single flag
563   void clearCPSR(CPSRRegister::CPSRIdx idx);
564   // utility method to set ARM CSPR flags from an x86 bit mask generated by integer arithmetic
565   void setCPSRRegisterFromX86(u_int64_t x86Flags);
566   // utility method to set ARM CSPR flags from an x86 bit mask generated by floating compare
567   void setCPSRRegisterFromX86FP(u_int64_t x86Flags);
568 
569   // fpsr register accessors
570   u_int32_t getFPSRRegister();
571   void setFPSRRegister(u_int32_t flags);
572   // read a specific subset of the fprs bits as a bit pattern
573   // mask should be composed using elements of enum FPSRRegister::FlagMask
574   u_int32_t getFPSRBits(u_int32_t mask);
575   // assign a specific subset of the flags as a bit pattern
576   // mask and value should be composed using elements of enum FPSRRegister::FlagMask
577   void setFPSRBits(u_int32_t mask, u_int32_t value);
578   // test the value of a single flag returned as 1 or 0
579   u_int32_t testFPSR(FPSRRegister::FPSRIdx idx);
580   // set a single flag
581   void setFPSR(FPSRRegister::FPSRIdx idx);
582   // clear a single flag
583   void clearFPSR(FPSRRegister::FPSRIdx idx);
584 
585   // debugger support
586   void printPC(int pending, const char *trailing = &quot;\n&quot;);
587   void printInstr(u_int32_t instr, void (*dasm)(u_int64_t), const char *trailing = &quot;\n&quot;);
588   void printGReg(GReg reg, PrintFormat format = FMT_HEX, const char *trailing = &quot;\n&quot;);
589   void printVReg(VReg reg, PrintFormat format = FMT_HEX, const char *trailing = &quot;\n&quot;);
590   void printCPSR(const char *trailing = &quot;\n&quot;);
591   void printFPSR(const char *trailing = &quot;\n&quot;);
592   void dumpState();
593 };
594 
595 #endif // ifndef _CPU_STATE_H
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/interp_masm.hpp&quot;
  32 #include &quot;interpreter/templateTable.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
  34 #include &quot;oops/methodData.hpp&quot;
  35 #include &quot;oops/method.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/oop.inline.hpp&quot;
  38 #include &quot;prims/methodHandles.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/synchronizer.hpp&quot;
<a name="1" id="anc1"></a>
  43 
  44 #define __ _masm-&gt;
  45 
  46 // Platform-dependent initialization
  47 
  48 void TemplateTable::pd_initialize() {
  49   // No aarch64 specific initialization
  50 }
  51 
  52 // Address computation: local variables
  53 
  54 static inline Address iaddress(int n) {
  55   return Address(rlocals, Interpreter::local_offset_in_bytes(n));
  56 }
  57 
  58 static inline Address laddress(int n) {
  59   return iaddress(n + 1);
  60 }
  61 
  62 static inline Address faddress(int n) {
  63   return iaddress(n);
  64 }
  65 
  66 static inline Address daddress(int n) {
  67   return laddress(n);
  68 }
  69 
  70 static inline Address aaddress(int n) {
  71   return iaddress(n);
  72 }
  73 
  74 static inline Address iaddress(Register r) {
  75   return Address(rlocals, r, Address::lsl(3));
  76 }
  77 
  78 static inline Address laddress(Register r, Register scratch,
  79                                InterpreterMacroAssembler* _masm) {
  80   __ lea(scratch, Address(rlocals, r, Address::lsl(3)));
  81   return Address(scratch, Interpreter::local_offset_in_bytes(1));
  82 }
  83 
  84 static inline Address faddress(Register r) {
  85   return iaddress(r);
  86 }
  87 
  88 static inline Address daddress(Register r, Register scratch,
  89                                InterpreterMacroAssembler* _masm) {
  90   return laddress(r, scratch, _masm);
  91 }
  92 
  93 static inline Address aaddress(Register r) {
  94   return iaddress(r);
  95 }
  96 
  97 static inline Address at_rsp() {
  98   return Address(esp, 0);
  99 }
 100 
 101 // At top of Java expression stack which may be different than esp().  It
 102 // isn&#39;t for category 1 objects.
 103 static inline Address at_tos   () {
 104   return Address(esp,  Interpreter::expr_offset_in_bytes(0));
 105 }
 106 
 107 static inline Address at_tos_p1() {
 108   return Address(esp,  Interpreter::expr_offset_in_bytes(1));
 109 }
 110 
 111 static inline Address at_tos_p2() {
 112   return Address(esp,  Interpreter::expr_offset_in_bytes(2));
 113 }
 114 
 115 static inline Address at_tos_p3() {
 116   return Address(esp,  Interpreter::expr_offset_in_bytes(3));
 117 }
 118 
 119 static inline Address at_tos_p4() {
 120   return Address(esp,  Interpreter::expr_offset_in_bytes(4));
 121 }
 122 
 123 static inline Address at_tos_p5() {
 124   return Address(esp,  Interpreter::expr_offset_in_bytes(5));
 125 }
 126 
 127 // Condition conversion
 128 static Assembler::Condition j_not(TemplateTable::Condition cc) {
 129   switch (cc) {
 130   case TemplateTable::equal        : return Assembler::NE;
 131   case TemplateTable::not_equal    : return Assembler::EQ;
 132   case TemplateTable::less         : return Assembler::GE;
 133   case TemplateTable::less_equal   : return Assembler::GT;
 134   case TemplateTable::greater      : return Assembler::LE;
 135   case TemplateTable::greater_equal: return Assembler::LT;
 136   }
 137   ShouldNotReachHere();
 138   return Assembler::EQ;
 139 }
 140 
 141 
 142 // Miscelaneous helper routines
 143 // Store an oop (or NULL) at the Address described by obj.
 144 // If val == noreg this means store a NULL
 145 static void do_oop_store(InterpreterMacroAssembler* _masm,
 146                          Address dst,
 147                          Register val,
 148                          DecoratorSet decorators) {
 149   assert(val == noreg || val == r0, &quot;parameter is just for looks&quot;);
 150   __ store_heap_oop(dst, val, r10, r1, decorators);
 151 }
 152 
 153 static void do_oop_load(InterpreterMacroAssembler* _masm,
 154                         Address src,
 155                         Register dst,
 156                         DecoratorSet decorators) {
 157   __ load_heap_oop(dst, src, r10, r1, decorators);
 158 }
 159 
 160 Address TemplateTable::at_bcp(int offset) {
 161   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 162   return Address(rbcp, offset);
 163 }
 164 
 165 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 166                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 167                                    int byte_no)
 168 {
 169   if (!RewriteBytecodes)  return;
 170   Label L_patch_done;
 171 
 172   switch (bc) {
 173   case Bytecodes::_fast_aputfield:
 174   case Bytecodes::_fast_bputfield:
 175   case Bytecodes::_fast_zputfield:
 176   case Bytecodes::_fast_cputfield:
 177   case Bytecodes::_fast_dputfield:
 178   case Bytecodes::_fast_fputfield:
 179   case Bytecodes::_fast_iputfield:
 180   case Bytecodes::_fast_lputfield:
 181   case Bytecodes::_fast_sputfield:
 182     {
 183       // We skip bytecode quickening for putfield instructions when
 184       // the put_code written to the constant pool cache is zero.
 185       // This is required so that every execution of this instruction
 186       // calls out to InterpreterRuntime::resolve_get_put to do
 187       // additional, required work.
 188       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 189       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 190       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 191       __ movw(bc_reg, bc);
 192       __ cbzw(temp_reg, L_patch_done);  // don&#39;t patch
 193     }
 194     break;
 195   default:
 196     assert(byte_no == -1, &quot;sanity&quot;);
 197     // the pair bytecodes have already done the load.
 198     if (load_bc_into_bc_reg) {
 199       __ movw(bc_reg, bc);
 200     }
 201   }
 202 
 203   if (JvmtiExport::can_post_breakpoint()) {
 204     Label L_fast_patch;
 205     // if a breakpoint is present we can&#39;t rewrite the stream directly
 206     __ load_unsigned_byte(temp_reg, at_bcp(0));
 207     __ cmpw(temp_reg, Bytecodes::_breakpoint);
 208     __ br(Assembler::NE, L_fast_patch);
 209     // Let breakpoint table handling rewrite to quicker bytecode
 210     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::set_original_bytecode_at), rmethod, rbcp, bc_reg);
 211     __ b(L_patch_done);
 212     __ bind(L_fast_patch);
 213   }
 214 
 215 #ifdef ASSERT
 216   Label L_okay;
 217   __ load_unsigned_byte(temp_reg, at_bcp(0));
 218   __ cmpw(temp_reg, (int) Bytecodes::java_code(bc));
 219   __ br(Assembler::EQ, L_okay);
 220   __ cmpw(temp_reg, bc_reg);
 221   __ br(Assembler::EQ, L_okay);
 222   __ stop(&quot;patching the wrong bytecode&quot;);
 223   __ bind(L_okay);
 224 #endif
 225 
 226   // patch bytecode
 227   __ strb(bc_reg, at_bcp(0));
 228   __ bind(L_patch_done);
 229 }
 230 
 231 
 232 // Individual instructions
 233 
 234 void TemplateTable::nop() {
 235   transition(vtos, vtos);
 236   // nothing to do
 237 }
 238 
 239 void TemplateTable::shouldnotreachhere() {
 240   transition(vtos, vtos);
 241   __ stop(&quot;shouldnotreachhere bytecode&quot;);
 242 }
 243 
 244 void TemplateTable::aconst_null()
 245 {
 246   transition(vtos, atos);
 247   __ mov(r0, 0);
 248 }
 249 
 250 void TemplateTable::iconst(int value)
 251 {
 252   transition(vtos, itos);
 253   __ mov(r0, value);
 254 }
 255 
 256 void TemplateTable::lconst(int value)
 257 {
 258   __ mov(r0, value);
 259 }
 260 
 261 void TemplateTable::fconst(int value)
 262 {
 263   transition(vtos, ftos);
 264   switch (value) {
 265   case 0:
 266     __ fmovs(v0, zr);
 267     break;
 268   case 1:
 269     __ fmovs(v0, 1.0);
 270     break;
 271   case 2:
 272     __ fmovs(v0, 2.0);
 273     break;
 274   default:
 275     ShouldNotReachHere();
 276     break;
 277   }
 278 }
 279 
 280 void TemplateTable::dconst(int value)
 281 {
 282   transition(vtos, dtos);
 283   switch (value) {
 284   case 0:
 285     __ fmovd(v0, zr);
 286     break;
 287   case 1:
 288     __ fmovd(v0, 1.0);
 289     break;
 290   case 2:
 291     __ fmovd(v0, 2.0);
 292     break;
 293   default:
 294     ShouldNotReachHere();
 295     break;
 296   }
 297 }
 298 
 299 void TemplateTable::bipush()
 300 {
 301   transition(vtos, itos);
 302   __ load_signed_byte32(r0, at_bcp(1));
 303 }
 304 
 305 void TemplateTable::sipush()
 306 {
 307   transition(vtos, itos);
 308   __ load_unsigned_short(r0, at_bcp(1));
 309   __ revw(r0, r0);
 310   __ asrw(r0, r0, 16);
 311 }
 312 
 313 void TemplateTable::ldc(bool wide)
 314 {
 315   transition(vtos, vtos);
 316   Label call_ldc, notFloat, notClass, notInt, Done;
 317 
 318   if (wide) {
 319     __ get_unsigned_2_byte_index_at_bcp(r1, 1);
 320   } else {
 321     __ load_unsigned_byte(r1, at_bcp(1));
 322   }
 323   __ get_cpool_and_tags(r2, r0);
 324 
 325   const int base_offset = ConstantPool::header_size() * wordSize;
 326   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 327 
 328   // get type
 329   __ add(r3, r1, tags_offset);
 330   __ lea(r3, Address(r0, r3));
 331   __ ldarb(r3, r3);
 332 
 333   // unresolved class - get the resolved class
 334   __ cmp(r3, (u1)JVM_CONSTANT_UnresolvedClass);
 335   __ br(Assembler::EQ, call_ldc);
 336 
 337   // unresolved class in error state - call into runtime to throw the error
 338   // from the first resolution attempt
 339   __ cmp(r3, (u1)JVM_CONSTANT_UnresolvedClassInError);
 340   __ br(Assembler::EQ, call_ldc);
 341 
 342   // resolved class - need to call vm to get java mirror of the class
 343   __ cmp(r3, (u1)JVM_CONSTANT_Class);
 344   __ br(Assembler::NE, notClass);
 345 
 346   __ bind(call_ldc);
 347   __ mov(c_rarg1, wide);
 348   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), c_rarg1);
 349   __ push_ptr(r0);
 350   __ verify_oop(r0);
 351   __ b(Done);
 352 
 353   __ bind(notClass);
 354   __ cmp(r3, (u1)JVM_CONSTANT_Float);
 355   __ br(Assembler::NE, notFloat);
 356   // ftos
 357   __ adds(r1, r2, r1, Assembler::LSL, 3);
 358   __ ldrs(v0, Address(r1, base_offset));
 359   __ push_f();
 360   __ b(Done);
 361 
 362   __ bind(notFloat);
 363 
 364   __ cmp(r3, (u1)JVM_CONSTANT_Integer);
 365   __ br(Assembler::NE, notInt);
 366 
 367   // itos
 368   __ adds(r1, r2, r1, Assembler::LSL, 3);
 369   __ ldrw(r0, Address(r1, base_offset));
 370   __ push_i(r0);
 371   __ b(Done);
 372 
 373   __ bind(notInt);
 374   condy_helper(Done);
 375 
 376   __ bind(Done);
 377 }
 378 
 379 // Fast path for caching oop constants.
 380 void TemplateTable::fast_aldc(bool wide)
 381 {
 382   transition(vtos, atos);
 383 
 384   Register result = r0;
 385   Register tmp = r1;
 386   Register rarg = r2;
 387 
 388   int index_size = wide ? sizeof(u2) : sizeof(u1);
 389 
 390   Label resolved;
 391 
 392   // We are resolved if the resolved reference cache entry contains a
 393   // non-null object (String, MethodType, etc.)
 394   assert_different_registers(result, tmp);
 395   __ get_cache_index_at_bcp(tmp, 1, index_size);
 396   __ load_resolved_reference_at_index(result, tmp);
 397   __ cbnz(result, resolved);
 398 
 399   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 400 
 401   // first time invocation - must resolve first
 402   __ mov(rarg, (int)bytecode());
 403   __ call_VM(result, entry, rarg);
 404 
 405   __ bind(resolved);
 406 
 407   { // Check for the null sentinel.
 408     // If we just called the VM, it already did the mapping for us,
 409     // but it&#39;s harmless to retry.
 410     Label notNull;
 411 
 412     // Stash null_sentinel address to get its value later
 413     __ movptr(rarg, (uintptr_t)Universe::the_null_sentinel_addr());
 414     __ ldr(tmp, Address(rarg));
 415     __ cmpoop(result, tmp);
 416     __ br(Assembler::NE, notNull);
 417     __ mov(result, 0);  // NULL object reference
 418     __ bind(notNull);
 419   }
 420 
 421   if (VerifyOops) {
 422     // Safe to call with 0 result
 423     __ verify_oop(result);
 424   }
 425 }
 426 
 427 void TemplateTable::ldc2_w()
 428 {
 429   transition(vtos, vtos);
 430   Label notDouble, notLong, Done;
 431   __ get_unsigned_2_byte_index_at_bcp(r0, 1);
 432 
 433   __ get_cpool_and_tags(r1, r2);
 434   const int base_offset = ConstantPool::header_size() * wordSize;
 435   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 436 
 437   // get type
 438   __ lea(r2, Address(r2, r0, Address::lsl(0)));
 439   __ load_unsigned_byte(r2, Address(r2, tags_offset));
 440   __ cmpw(r2, (int)JVM_CONSTANT_Double);
 441   __ br(Assembler::NE, notDouble);
 442 
 443   // dtos
 444   __ lea (r2, Address(r1, r0, Address::lsl(3)));
 445   __ ldrd(v0, Address(r2, base_offset));
 446   __ push_d();
 447   __ b(Done);
 448 
 449   __ bind(notDouble);
 450   __ cmpw(r2, (int)JVM_CONSTANT_Long);
 451   __ br(Assembler::NE, notLong);
 452 
 453   // ltos
 454   __ lea(r0, Address(r1, r0, Address::lsl(3)));
 455   __ ldr(r0, Address(r0, base_offset));
 456   __ push_l();
 457   __ b(Done);
 458 
 459   __ bind(notLong);
 460   condy_helper(Done);
 461 
 462   __ bind(Done);
 463 }
 464 
 465 void TemplateTable::condy_helper(Label&amp; Done)
 466 {
 467   Register obj = r0;
 468   Register rarg = r1;
 469   Register flags = r2;
 470   Register off = r3;
 471 
 472   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 473 
 474   __ mov(rarg, (int) bytecode());
 475   __ call_VM(obj, entry, rarg);
 476 
 477   __ get_vm_result_2(flags, rthread);
 478 
 479   // VMr = obj = base address to find primitive value to push
 480   // VMr2 = flags = (tos, off) using format of CPCE::_flags
 481   __ mov(off, flags);
 482   __ andw(off, off, ConstantPoolCacheEntry::field_index_mask);
 483 
 484   const Address field(obj, off);
 485 
 486   // What sort of thing are we loading?
 487   // x86 uses a shift and mask or wings it with a shift plus assert
 488   // the mask is not needed. aarch64 just uses bitfield extract
 489   __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,
 490            ConstantPoolCacheEntry::tos_state_bits);
 491 
 492   switch (bytecode()) {
 493     case Bytecodes::_ldc:
 494     case Bytecodes::_ldc_w:
 495       {
 496         // tos in (itos, ftos, stos, btos, ctos, ztos)
 497         Label notInt, notFloat, notShort, notByte, notChar, notBool;
 498         __ cmpw(flags, itos);
 499         __ br(Assembler::NE, notInt);
 500         // itos
 501         __ ldrw(r0, field);
 502         __ push(itos);
 503         __ b(Done);
 504 
 505         __ bind(notInt);
 506         __ cmpw(flags, ftos);
 507         __ br(Assembler::NE, notFloat);
 508         // ftos
 509         __ load_float(field);
 510         __ push(ftos);
 511         __ b(Done);
 512 
 513         __ bind(notFloat);
 514         __ cmpw(flags, stos);
 515         __ br(Assembler::NE, notShort);
 516         // stos
 517         __ load_signed_short(r0, field);
 518         __ push(stos);
 519         __ b(Done);
 520 
 521         __ bind(notShort);
 522         __ cmpw(flags, btos);
 523         __ br(Assembler::NE, notByte);
 524         // btos
 525         __ load_signed_byte(r0, field);
 526         __ push(btos);
 527         __ b(Done);
 528 
 529         __ bind(notByte);
 530         __ cmpw(flags, ctos);
 531         __ br(Assembler::NE, notChar);
 532         // ctos
 533         __ load_unsigned_short(r0, field);
 534         __ push(ctos);
 535         __ b(Done);
 536 
 537         __ bind(notChar);
 538         __ cmpw(flags, ztos);
 539         __ br(Assembler::NE, notBool);
 540         // ztos
 541         __ load_signed_byte(r0, field);
 542         __ push(ztos);
 543         __ b(Done);
 544 
 545         __ bind(notBool);
 546         break;
 547       }
 548 
 549     case Bytecodes::_ldc2_w:
 550       {
 551         Label notLong, notDouble;
 552         __ cmpw(flags, ltos);
 553         __ br(Assembler::NE, notLong);
 554         // ltos
 555         __ ldr(r0, field);
 556         __ push(ltos);
 557         __ b(Done);
 558 
 559         __ bind(notLong);
 560         __ cmpw(flags, dtos);
 561         __ br(Assembler::NE, notDouble);
 562         // dtos
 563         __ load_double(field);
 564         __ push(dtos);
 565         __ b(Done);
 566 
 567        __ bind(notDouble);
 568         break;
 569       }
 570 
 571     default:
 572       ShouldNotReachHere();
 573     }
 574 
 575     __ stop(&quot;bad ldc/condy&quot;);
 576 }
 577 
 578 void TemplateTable::locals_index(Register reg, int offset)
 579 {
 580   __ ldrb(reg, at_bcp(offset));
 581   __ neg(reg, reg);
 582 }
 583 
 584 void TemplateTable::iload() {
 585   iload_internal();
 586 }
 587 
 588 void TemplateTable::nofast_iload() {
 589   iload_internal(may_not_rewrite);
 590 }
 591 
 592 void TemplateTable::iload_internal(RewriteControl rc) {
 593   transition(vtos, itos);
 594   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 595     Label rewrite, done;
 596     Register bc = r4;
 597 
 598     // get next bytecode
 599     __ load_unsigned_byte(r1, at_bcp(Bytecodes::length_for(Bytecodes::_iload)));
 600 
 601     // if _iload, wait to rewrite to iload2.  We only want to rewrite the
 602     // last two iloads in a pair.  Comparing against fast_iload means that
 603     // the next bytecode is neither an iload or a caload, and therefore
 604     // an iload pair.
 605     __ cmpw(r1, Bytecodes::_iload);
 606     __ br(Assembler::EQ, done);
 607 
 608     // if _fast_iload rewrite to _fast_iload2
 609     __ cmpw(r1, Bytecodes::_fast_iload);
 610     __ movw(bc, Bytecodes::_fast_iload2);
 611     __ br(Assembler::EQ, rewrite);
 612 
 613     // if _caload rewrite to _fast_icaload
 614     __ cmpw(r1, Bytecodes::_caload);
 615     __ movw(bc, Bytecodes::_fast_icaload);
 616     __ br(Assembler::EQ, rewrite);
 617 
 618     // else rewrite to _fast_iload
 619     __ movw(bc, Bytecodes::_fast_iload);
 620 
 621     // rewrite
 622     // bc: new bytecode
 623     __ bind(rewrite);
 624     patch_bytecode(Bytecodes::_iload, bc, r1, false);
 625     __ bind(done);
 626 
 627   }
 628 
 629   // do iload, get the local value into tos
 630   locals_index(r1);
 631   __ ldr(r0, iaddress(r1));
 632 
 633 }
 634 
 635 void TemplateTable::fast_iload2()
 636 {
 637   transition(vtos, itos);
 638   locals_index(r1);
 639   __ ldr(r0, iaddress(r1));
 640   __ push(itos);
 641   locals_index(r1, 3);
 642   __ ldr(r0, iaddress(r1));
 643 }
 644 
 645 void TemplateTable::fast_iload()
 646 {
 647   transition(vtos, itos);
 648   locals_index(r1);
 649   __ ldr(r0, iaddress(r1));
 650 }
 651 
 652 void TemplateTable::lload()
 653 {
 654   transition(vtos, ltos);
 655   __ ldrb(r1, at_bcp(1));
 656   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 657   __ ldr(r0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 658 }
 659 
 660 void TemplateTable::fload()
 661 {
 662   transition(vtos, ftos);
 663   locals_index(r1);
 664   // n.b. we use ldrd here because this is a 64 bit slot
 665   // this is comparable to the iload case
 666   __ ldrd(v0, faddress(r1));
 667 }
 668 
 669 void TemplateTable::dload()
 670 {
 671   transition(vtos, dtos);
 672   __ ldrb(r1, at_bcp(1));
 673   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 674   __ ldrd(v0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 675 }
 676 
 677 void TemplateTable::aload()
 678 {
 679   transition(vtos, atos);
 680   locals_index(r1);
 681   __ ldr(r0, iaddress(r1));
 682 }
 683 
 684 void TemplateTable::locals_index_wide(Register reg) {
 685   __ ldrh(reg, at_bcp(2));
 686   __ rev16w(reg, reg);
 687   __ neg(reg, reg);
 688 }
 689 
 690 void TemplateTable::wide_iload() {
 691   transition(vtos, itos);
 692   locals_index_wide(r1);
 693   __ ldr(r0, iaddress(r1));
 694 }
 695 
 696 void TemplateTable::wide_lload()
 697 {
 698   transition(vtos, ltos);
 699   __ ldrh(r1, at_bcp(2));
 700   __ rev16w(r1, r1);
 701   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 702   __ ldr(r0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 703 }
 704 
 705 void TemplateTable::wide_fload()
 706 {
 707   transition(vtos, ftos);
 708   locals_index_wide(r1);
 709   // n.b. we use ldrd here because this is a 64 bit slot
 710   // this is comparable to the iload case
 711   __ ldrd(v0, faddress(r1));
 712 }
 713 
 714 void TemplateTable::wide_dload()
 715 {
 716   transition(vtos, dtos);
 717   __ ldrh(r1, at_bcp(2));
 718   __ rev16w(r1, r1);
 719   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 720   __ ldrd(v0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 721 }
 722 
 723 void TemplateTable::wide_aload()
 724 {
 725   transition(vtos, atos);
 726   locals_index_wide(r1);
 727   __ ldr(r0, aaddress(r1));
 728 }
 729 
 730 void TemplateTable::index_check(Register array, Register index)
 731 {
 732   // destroys r1, rscratch1
 733   // check array
 734   __ null_check(array, arrayOopDesc::length_offset_in_bytes());
 735   // sign extend index for use by indexed load
 736   // __ movl2ptr(index, index);
 737   // check index
 738   Register length = rscratch1;
 739   __ ldrw(length, Address(array, arrayOopDesc::length_offset_in_bytes()));
 740   __ cmpw(index, length);
 741   if (index != r1) {
 742     // ??? convention: move aberrant index into r1 for exception message
 743     assert(r1 != array, &quot;different registers&quot;);
 744     __ mov(r1, index);
 745   }
 746   Label ok;
 747   __ br(Assembler::LO, ok);
 748     // ??? convention: move array into r3 for exception message
 749   __ mov(r3, array);
 750   __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);
 751   __ br(rscratch1);
 752   __ bind(ok);
 753 }
 754 
 755 void TemplateTable::iaload()
 756 {
 757   transition(itos, itos);
 758   __ mov(r1, r0);
 759   __ pop_ptr(r0);
 760   // r0: array
 761   // r1: index
 762   index_check(r0, r1); // leaves index in r1, kills rscratch1
 763   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
 764   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);
 765 }
 766 
 767 void TemplateTable::laload()
 768 {
 769   transition(itos, ltos);
 770   __ mov(r1, r0);
 771   __ pop_ptr(r0);
 772   // r0: array
 773   // r1: index
 774   index_check(r0, r1); // leaves index in r1, kills rscratch1
 775   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
 776   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);
 777 }
 778 
 779 void TemplateTable::faload()
 780 {
 781   transition(itos, ftos);
 782   __ mov(r1, r0);
 783   __ pop_ptr(r0);
 784   // r0: array
 785   // r1: index
 786   index_check(r0, r1); // leaves index in r1, kills rscratch1
 787   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
 788   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);
 789 }
 790 
 791 void TemplateTable::daload()
 792 {
 793   transition(itos, dtos);
 794   __ mov(r1, r0);
 795   __ pop_ptr(r0);
 796   // r0: array
 797   // r1: index
 798   index_check(r0, r1); // leaves index in r1, kills rscratch1
 799   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
 800   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);
 801 }
 802 
 803 void TemplateTable::aaload()
 804 {
 805   transition(itos, atos);
 806   __ mov(r1, r0);
 807   __ pop_ptr(r0);
 808   // r0: array
 809   // r1: index
 810   index_check(r0, r1); // leaves index in r1, kills rscratch1
 811   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
 812   do_oop_load(_masm,
 813               Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)),
 814               r0,
 815               IS_ARRAY);
 816 }
 817 
 818 void TemplateTable::baload()
 819 {
 820   transition(itos, itos);
 821   __ mov(r1, r0);
 822   __ pop_ptr(r0);
 823   // r0: array
 824   // r1: index
 825   index_check(r0, r1); // leaves index in r1, kills rscratch1
 826   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
 827   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(0)), noreg, noreg);
 828 }
 829 
 830 void TemplateTable::caload()
 831 {
 832   transition(itos, itos);
 833   __ mov(r1, r0);
 834   __ pop_ptr(r0);
 835   // r0: array
 836   // r1: index
 837   index_check(r0, r1); // leaves index in r1, kills rscratch1
 838   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
 839   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 840 }
 841 
 842 // iload followed by caload frequent pair
 843 void TemplateTable::fast_icaload()
 844 {
 845   transition(vtos, itos);
 846   // load index out of locals
 847   locals_index(r2);
 848   __ ldr(r1, iaddress(r2));
 849 
 850   __ pop_ptr(r0);
 851 
 852   // r0: array
 853   // r1: index
 854   index_check(r0, r1); // leaves index in r1, kills rscratch1
 855   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
 856   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 857 }
 858 
 859 void TemplateTable::saload()
 860 {
 861   transition(itos, itos);
 862   __ mov(r1, r0);
 863   __ pop_ptr(r0);
 864   // r0: array
 865   // r1: index
 866   index_check(r0, r1); // leaves index in r1, kills rscratch1
 867   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_SHORT) &gt;&gt; 1);
 868   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 869 }
 870 
 871 void TemplateTable::iload(int n)
 872 {
 873   transition(vtos, itos);
 874   __ ldr(r0, iaddress(n));
 875 }
 876 
 877 void TemplateTable::lload(int n)
 878 {
 879   transition(vtos, ltos);
 880   __ ldr(r0, laddress(n));
 881 }
 882 
 883 void TemplateTable::fload(int n)
 884 {
 885   transition(vtos, ftos);
 886   __ ldrs(v0, faddress(n));
 887 }
 888 
 889 void TemplateTable::dload(int n)
 890 {
 891   transition(vtos, dtos);
 892   __ ldrd(v0, daddress(n));
 893 }
 894 
 895 void TemplateTable::aload(int n)
 896 {
 897   transition(vtos, atos);
 898   __ ldr(r0, iaddress(n));
 899 }
 900 
 901 void TemplateTable::aload_0() {
 902   aload_0_internal();
 903 }
 904 
 905 void TemplateTable::nofast_aload_0() {
 906   aload_0_internal(may_not_rewrite);
 907 }
 908 
 909 void TemplateTable::aload_0_internal(RewriteControl rc) {
 910   // According to bytecode histograms, the pairs:
 911   //
 912   // _aload_0, _fast_igetfield
 913   // _aload_0, _fast_agetfield
 914   // _aload_0, _fast_fgetfield
 915   //
 916   // occur frequently. If RewriteFrequentPairs is set, the (slow)
 917   // _aload_0 bytecode checks if the next bytecode is either
 918   // _fast_igetfield, _fast_agetfield or _fast_fgetfield and then
 919   // rewrites the current bytecode into a pair bytecode; otherwise it
 920   // rewrites the current bytecode into _fast_aload_0 that doesn&#39;t do
 921   // the pair check anymore.
 922   //
 923   // Note: If the next bytecode is _getfield, the rewrite must be
 924   //       delayed, otherwise we may miss an opportunity for a pair.
 925   //
 926   // Also rewrite frequent pairs
 927   //   aload_0, aload_1
 928   //   aload_0, iload_1
 929   // These bytecodes with a small amount of code are most profitable
 930   // to rewrite
 931   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 932     Label rewrite, done;
 933     const Register bc = r4;
 934 
 935     // get next bytecode
 936     __ load_unsigned_byte(r1, at_bcp(Bytecodes::length_for(Bytecodes::_aload_0)));
 937 
 938     // if _getfield then wait with rewrite
 939     __ cmpw(r1, Bytecodes::Bytecodes::_getfield);
 940     __ br(Assembler::EQ, done);
 941 
 942     // if _igetfield then rewrite to _fast_iaccess_0
 943     assert(Bytecodes::java_code(Bytecodes::_fast_iaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 944     __ cmpw(r1, Bytecodes::_fast_igetfield);
 945     __ movw(bc, Bytecodes::_fast_iaccess_0);
 946     __ br(Assembler::EQ, rewrite);
 947 
 948     // if _agetfield then rewrite to _fast_aaccess_0
 949     assert(Bytecodes::java_code(Bytecodes::_fast_aaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 950     __ cmpw(r1, Bytecodes::_fast_agetfield);
 951     __ movw(bc, Bytecodes::_fast_aaccess_0);
 952     __ br(Assembler::EQ, rewrite);
 953 
 954     // if _fgetfield then rewrite to _fast_faccess_0
 955     assert(Bytecodes::java_code(Bytecodes::_fast_faccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 956     __ cmpw(r1, Bytecodes::_fast_fgetfield);
 957     __ movw(bc, Bytecodes::_fast_faccess_0);
 958     __ br(Assembler::EQ, rewrite);
 959 
 960     // else rewrite to _fast_aload0
 961     assert(Bytecodes::java_code(Bytecodes::_fast_aload_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 962     __ movw(bc, Bytecodes::Bytecodes::_fast_aload_0);
 963 
 964     // rewrite
 965     // bc: new bytecode
 966     __ bind(rewrite);
 967     patch_bytecode(Bytecodes::_aload_0, bc, r1, false);
 968 
 969     __ bind(done);
 970   }
 971 
 972   // Do actual aload_0 (must do this after patch_bytecode which might call VM and GC might change oop).
 973   aload(0);
 974 }
 975 
 976 void TemplateTable::istore()
 977 {
 978   transition(itos, vtos);
 979   locals_index(r1);
 980   // FIXME: We&#39;re being very pernickerty here storing a jint in a
 981   // local with strw, which costs an extra instruction over what we&#39;d
 982   // be able to do with a simple str.  We should just store the whole
 983   // word.
 984   __ lea(rscratch1, iaddress(r1));
 985   __ strw(r0, Address(rscratch1));
 986 }
 987 
 988 void TemplateTable::lstore()
 989 {
 990   transition(ltos, vtos);
 991   locals_index(r1);
 992   __ str(r0, laddress(r1, rscratch1, _masm));
 993 }
 994 
 995 void TemplateTable::fstore() {
 996   transition(ftos, vtos);
 997   locals_index(r1);
 998   __ lea(rscratch1, iaddress(r1));
 999   __ strs(v0, Address(rscratch1));
1000 }
1001 
1002 void TemplateTable::dstore() {
1003   transition(dtos, vtos);
1004   locals_index(r1);
1005   __ strd(v0, daddress(r1, rscratch1, _masm));
1006 }
1007 
1008 void TemplateTable::astore()
1009 {
1010   transition(vtos, vtos);
1011   __ pop_ptr(r0);
1012   locals_index(r1);
1013   __ str(r0, aaddress(r1));
1014 }
1015 
1016 void TemplateTable::wide_istore() {
1017   transition(vtos, vtos);
1018   __ pop_i();
1019   locals_index_wide(r1);
1020   __ lea(rscratch1, iaddress(r1));
1021   __ strw(r0, Address(rscratch1));
1022 }
1023 
1024 void TemplateTable::wide_lstore() {
1025   transition(vtos, vtos);
1026   __ pop_l();
1027   locals_index_wide(r1);
1028   __ str(r0, laddress(r1, rscratch1, _masm));
1029 }
1030 
1031 void TemplateTable::wide_fstore() {
1032   transition(vtos, vtos);
1033   __ pop_f();
1034   locals_index_wide(r1);
1035   __ lea(rscratch1, faddress(r1));
1036   __ strs(v0, rscratch1);
1037 }
1038 
1039 void TemplateTable::wide_dstore() {
1040   transition(vtos, vtos);
1041   __ pop_d();
1042   locals_index_wide(r1);
1043   __ strd(v0, daddress(r1, rscratch1, _masm));
1044 }
1045 
1046 void TemplateTable::wide_astore() {
1047   transition(vtos, vtos);
1048   __ pop_ptr(r0);
1049   locals_index_wide(r1);
1050   __ str(r0, aaddress(r1));
1051 }
1052 
1053 void TemplateTable::iastore() {
1054   transition(itos, vtos);
1055   __ pop_i(r1);
1056   __ pop_ptr(r3);
1057   // r0: value
1058   // r1: index
1059   // r3: array
1060   index_check(r3, r1); // prefer index in r1
1061   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
1062   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), r0, noreg, noreg);
1063 }
1064 
1065 void TemplateTable::lastore() {
1066   transition(ltos, vtos);
1067   __ pop_i(r1);
1068   __ pop_ptr(r3);
1069   // r0: value
1070   // r1: index
1071   // r3: array
1072   index_check(r3, r1); // prefer index in r1
1073   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
1074   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), r0, noreg, noreg);
1075 }
1076 
1077 void TemplateTable::fastore() {
1078   transition(ftos, vtos);
1079   __ pop_i(r1);
1080   __ pop_ptr(r3);
1081   // v0: value
1082   // r1:  index
1083   // r3:  array
1084   index_check(r3, r1); // prefer index in r1
1085   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
1086   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), noreg /* ftos */, noreg, noreg);
1087 }
1088 
1089 void TemplateTable::dastore() {
1090   transition(dtos, vtos);
1091   __ pop_i(r1);
1092   __ pop_ptr(r3);
1093   // v0: value
1094   // r1:  index
1095   // r3:  array
1096   index_check(r3, r1); // prefer index in r1
1097   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
1098   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), noreg /* dtos */, noreg, noreg);
1099 }
1100 
1101 void TemplateTable::aastore() {
1102   Label is_null, ok_is_subtype, done;
1103   transition(vtos, vtos);
1104   // stack: ..., array, index, value
1105   __ ldr(r0, at_tos());    // value
1106   __ ldr(r2, at_tos_p1()); // index
1107   __ ldr(r3, at_tos_p2()); // array
1108 
1109   Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));
1110 
1111   index_check(r3, r2);     // kills r1
1112   __ add(r4, r2, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
1113 
1114   // do array store check - check for NULL value first
1115   __ cbz(r0, is_null);
1116 
1117   // Move subklass into r1
1118   __ load_klass(r1, r0);
1119   // Move superklass into r0
1120   __ load_klass(r0, r3);
1121   __ ldr(r0, Address(r0,
1122                      ObjArrayKlass::element_klass_offset()));
1123   // Compress array + index*oopSize + 12 into a single register.  Frees r2.
1124 
1125   // Generate subtype check.  Blows r2, r5
1126   // Superklass in r0.  Subklass in r1.
1127   __ gen_subtype_check(r1, ok_is_subtype);
1128 
1129   // Come here on failure
1130   // object is at TOS
1131   __ b(Interpreter::_throw_ArrayStoreException_entry);
1132 
1133   // Come here on success
1134   __ bind(ok_is_subtype);
1135 
1136   // Get the value we will store
1137   __ ldr(r0, at_tos());
1138   // Now store using the appropriate barrier
1139   do_oop_store(_masm, element_address, r0, IS_ARRAY);
1140   __ b(done);
1141 
1142   // Have a NULL in r0, r3=array, r2=index.  Store NULL at ary[idx]
1143   __ bind(is_null);
1144   __ profile_null_seen(r2);
1145 
1146   // Store a NULL
1147   do_oop_store(_masm, element_address, noreg, IS_ARRAY);
1148 
1149   // Pop stack arguments
1150   __ bind(done);
1151   __ add(esp, esp, 3 * Interpreter::stackElementSize);
1152 }
1153 
1154 void TemplateTable::bastore()
1155 {
1156   transition(itos, vtos);
1157   __ pop_i(r1);
1158   __ pop_ptr(r3);
1159   // r0: value
1160   // r1: index
1161   // r3: array
1162   index_check(r3, r1); // prefer index in r1
1163 
1164   // Need to check whether array is boolean or byte
1165   // since both types share the bastore bytecode.
1166   __ load_klass(r2, r3);
1167   __ ldrw(r2, Address(r2, Klass::layout_helper_offset()));
1168   int diffbit_index = exact_log2(Klass::layout_helper_boolean_diffbit());
1169   Label L_skip;
1170   __ tbz(r2, diffbit_index, L_skip);
1171   __ andw(r0, r0, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
1172   __ bind(L_skip);
1173 
1174   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
1175   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(0)), r0, noreg, noreg);
1176 }
1177 
1178 void TemplateTable::castore()
1179 {
1180   transition(itos, vtos);
1181   __ pop_i(r1);
1182   __ pop_ptr(r3);
1183   // r0: value
1184   // r1: index
1185   // r3: array
1186   index_check(r3, r1); // prefer index in r1
1187   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
1188   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(1)), r0, noreg, noreg);
1189 }
1190 
1191 void TemplateTable::sastore()
1192 {
1193   castore();
1194 }
1195 
1196 void TemplateTable::istore(int n)
1197 {
1198   transition(itos, vtos);
1199   __ str(r0, iaddress(n));
1200 }
1201 
1202 void TemplateTable::lstore(int n)
1203 {
1204   transition(ltos, vtos);
1205   __ str(r0, laddress(n));
1206 }
1207 
1208 void TemplateTable::fstore(int n)
1209 {
1210   transition(ftos, vtos);
1211   __ strs(v0, faddress(n));
1212 }
1213 
1214 void TemplateTable::dstore(int n)
1215 {
1216   transition(dtos, vtos);
1217   __ strd(v0, daddress(n));
1218 }
1219 
1220 void TemplateTable::astore(int n)
1221 {
1222   transition(vtos, vtos);
1223   __ pop_ptr(r0);
1224   __ str(r0, iaddress(n));
1225 }
1226 
1227 void TemplateTable::pop()
1228 {
1229   transition(vtos, vtos);
1230   __ add(esp, esp, Interpreter::stackElementSize);
1231 }
1232 
1233 void TemplateTable::pop2()
1234 {
1235   transition(vtos, vtos);
1236   __ add(esp, esp, 2 * Interpreter::stackElementSize);
1237 }
1238 
1239 void TemplateTable::dup()
1240 {
1241   transition(vtos, vtos);
1242   __ ldr(r0, Address(esp, 0));
1243   __ push(r0);
1244   // stack: ..., a, a
1245 }
1246 
1247 void TemplateTable::dup_x1()
1248 {
1249   transition(vtos, vtos);
1250   // stack: ..., a, b
1251   __ ldr(r0, at_tos());  // load b
1252   __ ldr(r2, at_tos_p1());  // load a
1253   __ str(r0, at_tos_p1());  // store b
1254   __ str(r2, at_tos());  // store a
1255   __ push(r0);                  // push b
1256   // stack: ..., b, a, b
1257 }
1258 
1259 void TemplateTable::dup_x2()
1260 {
1261   transition(vtos, vtos);
1262   // stack: ..., a, b, c
1263   __ ldr(r0, at_tos());  // load c
1264   __ ldr(r2, at_tos_p2());  // load a
1265   __ str(r0, at_tos_p2());  // store c in a
1266   __ push(r0);      // push c
1267   // stack: ..., c, b, c, c
1268   __ ldr(r0, at_tos_p2());  // load b
1269   __ str(r2, at_tos_p2());  // store a in b
1270   // stack: ..., c, a, c, c
1271   __ str(r0, at_tos_p1());  // store b in c
1272   // stack: ..., c, a, b, c
1273 }
1274 
1275 void TemplateTable::dup2()
1276 {
1277   transition(vtos, vtos);
1278   // stack: ..., a, b
1279   __ ldr(r0, at_tos_p1());  // load a
1280   __ push(r0);                  // push a
1281   __ ldr(r0, at_tos_p1());  // load b
1282   __ push(r0);                  // push b
1283   // stack: ..., a, b, a, b
1284 }
1285 
1286 void TemplateTable::dup2_x1()
1287 {
1288   transition(vtos, vtos);
1289   // stack: ..., a, b, c
1290   __ ldr(r2, at_tos());  // load c
1291   __ ldr(r0, at_tos_p1());  // load b
1292   __ push(r0);                  // push b
1293   __ push(r2);                  // push c
1294   // stack: ..., a, b, c, b, c
1295   __ str(r2, at_tos_p3());  // store c in b
1296   // stack: ..., a, c, c, b, c
1297   __ ldr(r2, at_tos_p4());  // load a
1298   __ str(r2, at_tos_p2());  // store a in 2nd c
1299   // stack: ..., a, c, a, b, c
1300   __ str(r0, at_tos_p4());  // store b in a
1301   // stack: ..., b, c, a, b, c
1302 }
1303 
1304 void TemplateTable::dup2_x2()
1305 {
1306   transition(vtos, vtos);
1307   // stack: ..., a, b, c, d
1308   __ ldr(r2, at_tos());  // load d
1309   __ ldr(r0, at_tos_p1());  // load c
1310   __ push(r0)            ;      // push c
1311   __ push(r2);                  // push d
1312   // stack: ..., a, b, c, d, c, d
1313   __ ldr(r0, at_tos_p4());  // load b
1314   __ str(r0, at_tos_p2());  // store b in d
1315   __ str(r2, at_tos_p4());  // store d in b
1316   // stack: ..., a, d, c, b, c, d
1317   __ ldr(r2, at_tos_p5());  // load a
1318   __ ldr(r0, at_tos_p3());  // load c
1319   __ str(r2, at_tos_p3());  // store a in c
1320   __ str(r0, at_tos_p5());  // store c in a
1321   // stack: ..., c, d, a, b, c, d
1322 }
1323 
1324 void TemplateTable::swap()
1325 {
1326   transition(vtos, vtos);
1327   // stack: ..., a, b
1328   __ ldr(r2, at_tos_p1());  // load a
1329   __ ldr(r0, at_tos());  // load b
1330   __ str(r2, at_tos());  // store a in b
1331   __ str(r0, at_tos_p1());  // store b in a
1332   // stack: ..., b, a
1333 }
1334 
1335 void TemplateTable::iop2(Operation op)
1336 {
1337   transition(itos, itos);
1338   // r0 &lt;== r1 op r0
1339   __ pop_i(r1);
1340   switch (op) {
1341   case add  : __ addw(r0, r1, r0); break;
1342   case sub  : __ subw(r0, r1, r0); break;
1343   case mul  : __ mulw(r0, r1, r0); break;
1344   case _and : __ andw(r0, r1, r0); break;
1345   case _or  : __ orrw(r0, r1, r0); break;
1346   case _xor : __ eorw(r0, r1, r0); break;
1347   case shl  : __ lslvw(r0, r1, r0); break;
1348   case shr  : __ asrvw(r0, r1, r0); break;
1349   case ushr : __ lsrvw(r0, r1, r0);break;
1350   default   : ShouldNotReachHere();
1351   }
1352 }
1353 
1354 void TemplateTable::lop2(Operation op)
1355 {
1356   transition(ltos, ltos);
1357   // r0 &lt;== r1 op r0
1358   __ pop_l(r1);
1359   switch (op) {
1360   case add  : __ add(r0, r1, r0); break;
1361   case sub  : __ sub(r0, r1, r0); break;
1362   case mul  : __ mul(r0, r1, r0); break;
1363   case _and : __ andr(r0, r1, r0); break;
1364   case _or  : __ orr(r0, r1, r0); break;
1365   case _xor : __ eor(r0, r1, r0); break;
1366   default   : ShouldNotReachHere();
1367   }
1368 }
1369 
1370 void TemplateTable::idiv()
1371 {
1372   transition(itos, itos);
1373   // explicitly check for div0
1374   Label no_div0;
1375   __ cbnzw(r0, no_div0);
1376   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1377   __ br(rscratch1);
1378   __ bind(no_div0);
1379   __ pop_i(r1);
1380   // r0 &lt;== r1 idiv r0
1381   __ corrected_idivl(r0, r1, r0, /* want_remainder */ false);
1382 }
1383 
1384 void TemplateTable::irem()
1385 {
1386   transition(itos, itos);
1387   // explicitly check for div0
1388   Label no_div0;
1389   __ cbnzw(r0, no_div0);
1390   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1391   __ br(rscratch1);
1392   __ bind(no_div0);
1393   __ pop_i(r1);
1394   // r0 &lt;== r1 irem r0
1395   __ corrected_idivl(r0, r1, r0, /* want_remainder */ true);
1396 }
1397 
1398 void TemplateTable::lmul()
1399 {
1400   transition(ltos, ltos);
1401   __ pop_l(r1);
1402   __ mul(r0, r0, r1);
1403 }
1404 
1405 void TemplateTable::ldiv()
1406 {
1407   transition(ltos, ltos);
1408   // explicitly check for div0
1409   Label no_div0;
1410   __ cbnz(r0, no_div0);
1411   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1412   __ br(rscratch1);
1413   __ bind(no_div0);
1414   __ pop_l(r1);
1415   // r0 &lt;== r1 ldiv r0
1416   __ corrected_idivq(r0, r1, r0, /* want_remainder */ false);
1417 }
1418 
1419 void TemplateTable::lrem()
1420 {
1421   transition(ltos, ltos);
1422   // explicitly check for div0
1423   Label no_div0;
1424   __ cbnz(r0, no_div0);
1425   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1426   __ br(rscratch1);
1427   __ bind(no_div0);
1428   __ pop_l(r1);
1429   // r0 &lt;== r1 lrem r0
1430   __ corrected_idivq(r0, r1, r0, /* want_remainder */ true);
1431 }
1432 
1433 void TemplateTable::lshl()
1434 {
1435   transition(itos, ltos);
1436   // shift count is in r0
1437   __ pop_l(r1);
1438   __ lslv(r0, r1, r0);
1439 }
1440 
1441 void TemplateTable::lshr()
1442 {
1443   transition(itos, ltos);
1444   // shift count is in r0
1445   __ pop_l(r1);
1446   __ asrv(r0, r1, r0);
1447 }
1448 
1449 void TemplateTable::lushr()
1450 {
1451   transition(itos, ltos);
1452   // shift count is in r0
1453   __ pop_l(r1);
1454   __ lsrv(r0, r1, r0);
1455 }
1456 
1457 void TemplateTable::fop2(Operation op)
1458 {
1459   transition(ftos, ftos);
1460   switch (op) {
1461   case add:
1462     // n.b. use ldrd because this is a 64 bit slot
1463     __ pop_f(v1);
1464     __ fadds(v0, v1, v0);
1465     break;
1466   case sub:
1467     __ pop_f(v1);
1468     __ fsubs(v0, v1, v0);
1469     break;
1470   case mul:
1471     __ pop_f(v1);
1472     __ fmuls(v0, v1, v0);
1473     break;
1474   case div:
1475     __ pop_f(v1);
1476     __ fdivs(v0, v1, v0);
1477     break;
1478   case rem:
1479     __ fmovs(v1, v0);
1480     __ pop_f(v0);
<a name="2" id="anc2"></a><span class="line-modified">1481     __ call_VM_leaf_base1(CAST_FROM_FN_PTR(address, SharedRuntime::frem),</span>
<span class="line-removed">1482                          0, 2, MacroAssembler::ret_type_float);</span>
1483     break;
1484   default:
1485     ShouldNotReachHere();
1486     break;
1487   }
1488 }
1489 
1490 void TemplateTable::dop2(Operation op)
1491 {
1492   transition(dtos, dtos);
1493   switch (op) {
1494   case add:
1495     // n.b. use ldrd because this is a 64 bit slot
1496     __ pop_d(v1);
1497     __ faddd(v0, v1, v0);
1498     break;
1499   case sub:
1500     __ pop_d(v1);
1501     __ fsubd(v0, v1, v0);
1502     break;
1503   case mul:
1504     __ pop_d(v1);
1505     __ fmuld(v0, v1, v0);
1506     break;
1507   case div:
1508     __ pop_d(v1);
1509     __ fdivd(v0, v1, v0);
1510     break;
1511   case rem:
1512     __ fmovd(v1, v0);
1513     __ pop_d(v0);
<a name="3" id="anc3"></a><span class="line-modified">1514     __ call_VM_leaf_base1(CAST_FROM_FN_PTR(address, SharedRuntime::drem),</span>
<span class="line-removed">1515                          0, 2, MacroAssembler::ret_type_double);</span>
1516     break;
1517   default:
1518     ShouldNotReachHere();
1519     break;
1520   }
1521 }
1522 
1523 void TemplateTable::ineg()
1524 {
1525   transition(itos, itos);
1526   __ negw(r0, r0);
1527 
1528 }
1529 
1530 void TemplateTable::lneg()
1531 {
1532   transition(ltos, ltos);
1533   __ neg(r0, r0);
1534 }
1535 
1536 void TemplateTable::fneg()
1537 {
1538   transition(ftos, ftos);
1539   __ fnegs(v0, v0);
1540 }
1541 
1542 void TemplateTable::dneg()
1543 {
1544   transition(dtos, dtos);
1545   __ fnegd(v0, v0);
1546 }
1547 
1548 void TemplateTable::iinc()
1549 {
1550   transition(vtos, vtos);
1551   __ load_signed_byte(r1, at_bcp(2)); // get constant
1552   locals_index(r2);
1553   __ ldr(r0, iaddress(r2));
1554   __ addw(r0, r0, r1);
1555   __ str(r0, iaddress(r2));
1556 }
1557 
1558 void TemplateTable::wide_iinc()
1559 {
1560   transition(vtos, vtos);
1561   // __ mov(r1, zr);
1562   __ ldrw(r1, at_bcp(2)); // get constant and index
1563   __ rev16(r1, r1);
1564   __ ubfx(r2, r1, 0, 16);
1565   __ neg(r2, r2);
1566   __ sbfx(r1, r1, 16, 16);
1567   __ ldr(r0, iaddress(r2));
1568   __ addw(r0, r0, r1);
1569   __ str(r0, iaddress(r2));
1570 }
1571 
1572 void TemplateTable::convert()
1573 {
1574   // Checking
1575 #ifdef ASSERT
1576   {
1577     TosState tos_in  = ilgl;
1578     TosState tos_out = ilgl;
1579     switch (bytecode()) {
1580     case Bytecodes::_i2l: // fall through
1581     case Bytecodes::_i2f: // fall through
1582     case Bytecodes::_i2d: // fall through
1583     case Bytecodes::_i2b: // fall through
1584     case Bytecodes::_i2c: // fall through
1585     case Bytecodes::_i2s: tos_in = itos; break;
1586     case Bytecodes::_l2i: // fall through
1587     case Bytecodes::_l2f: // fall through
1588     case Bytecodes::_l2d: tos_in = ltos; break;
1589     case Bytecodes::_f2i: // fall through
1590     case Bytecodes::_f2l: // fall through
1591     case Bytecodes::_f2d: tos_in = ftos; break;
1592     case Bytecodes::_d2i: // fall through
1593     case Bytecodes::_d2l: // fall through
1594     case Bytecodes::_d2f: tos_in = dtos; break;
1595     default             : ShouldNotReachHere();
1596     }
1597     switch (bytecode()) {
1598     case Bytecodes::_l2i: // fall through
1599     case Bytecodes::_f2i: // fall through
1600     case Bytecodes::_d2i: // fall through
1601     case Bytecodes::_i2b: // fall through
1602     case Bytecodes::_i2c: // fall through
1603     case Bytecodes::_i2s: tos_out = itos; break;
1604     case Bytecodes::_i2l: // fall through
1605     case Bytecodes::_f2l: // fall through
1606     case Bytecodes::_d2l: tos_out = ltos; break;
1607     case Bytecodes::_i2f: // fall through
1608     case Bytecodes::_l2f: // fall through
1609     case Bytecodes::_d2f: tos_out = ftos; break;
1610     case Bytecodes::_i2d: // fall through
1611     case Bytecodes::_l2d: // fall through
1612     case Bytecodes::_f2d: tos_out = dtos; break;
1613     default             : ShouldNotReachHere();
1614     }
1615     transition(tos_in, tos_out);
1616   }
1617 #endif // ASSERT
1618   // static const int64_t is_nan = 0x8000000000000000L;
1619 
1620   // Conversion
1621   switch (bytecode()) {
1622   case Bytecodes::_i2l:
1623     __ sxtw(r0, r0);
1624     break;
1625   case Bytecodes::_i2f:
1626     __ scvtfws(v0, r0);
1627     break;
1628   case Bytecodes::_i2d:
1629     __ scvtfwd(v0, r0);
1630     break;
1631   case Bytecodes::_i2b:
1632     __ sxtbw(r0, r0);
1633     break;
1634   case Bytecodes::_i2c:
1635     __ uxthw(r0, r0);
1636     break;
1637   case Bytecodes::_i2s:
1638     __ sxthw(r0, r0);
1639     break;
1640   case Bytecodes::_l2i:
1641     __ uxtw(r0, r0);
1642     break;
1643   case Bytecodes::_l2f:
1644     __ scvtfs(v0, r0);
1645     break;
1646   case Bytecodes::_l2d:
1647     __ scvtfd(v0, r0);
1648     break;
1649   case Bytecodes::_f2i:
1650   {
1651     Label L_Okay;
1652     __ clear_fpsr();
1653     __ fcvtzsw(r0, v0);
1654     __ get_fpsr(r1);
1655     __ cbzw(r1, L_Okay);
<a name="4" id="anc4"></a><span class="line-modified">1656     __ call_VM_leaf_base1(CAST_FROM_FN_PTR(address, SharedRuntime::f2i),</span>
<span class="line-removed">1657                          0, 1, MacroAssembler::ret_type_integral);</span>
1658     __ bind(L_Okay);
1659   }
1660     break;
1661   case Bytecodes::_f2l:
1662   {
1663     Label L_Okay;
1664     __ clear_fpsr();
1665     __ fcvtzs(r0, v0);
1666     __ get_fpsr(r1);
1667     __ cbzw(r1, L_Okay);
<a name="5" id="anc5"></a><span class="line-modified">1668     __ call_VM_leaf_base1(CAST_FROM_FN_PTR(address, SharedRuntime::f2l),</span>
<span class="line-removed">1669                          0, 1, MacroAssembler::ret_type_integral);</span>
1670     __ bind(L_Okay);
1671   }
1672     break;
1673   case Bytecodes::_f2d:
1674     __ fcvts(v0, v0);
1675     break;
1676   case Bytecodes::_d2i:
1677   {
1678     Label L_Okay;
1679     __ clear_fpsr();
1680     __ fcvtzdw(r0, v0);
1681     __ get_fpsr(r1);
1682     __ cbzw(r1, L_Okay);
<a name="6" id="anc6"></a><span class="line-modified">1683     __ call_VM_leaf_base1(CAST_FROM_FN_PTR(address, SharedRuntime::d2i),</span>
<span class="line-removed">1684                          0, 1, MacroAssembler::ret_type_integral);</span>
1685     __ bind(L_Okay);
1686   }
1687     break;
1688   case Bytecodes::_d2l:
1689   {
1690     Label L_Okay;
1691     __ clear_fpsr();
1692     __ fcvtzd(r0, v0);
1693     __ get_fpsr(r1);
1694     __ cbzw(r1, L_Okay);
<a name="7" id="anc7"></a><span class="line-modified">1695     __ call_VM_leaf_base1(CAST_FROM_FN_PTR(address, SharedRuntime::d2l),</span>
<span class="line-removed">1696                          0, 1, MacroAssembler::ret_type_integral);</span>
1697     __ bind(L_Okay);
1698   }
1699     break;
1700   case Bytecodes::_d2f:
1701     __ fcvtd(v0, v0);
1702     break;
1703   default:
1704     ShouldNotReachHere();
1705   }
1706 }
1707 
1708 void TemplateTable::lcmp()
1709 {
1710   transition(ltos, itos);
1711   Label done;
1712   __ pop_l(r1);
1713   __ cmp(r1, r0);
1714   __ mov(r0, (u_int64_t)-1L);
1715   __ br(Assembler::LT, done);
1716   // __ mov(r0, 1UL);
1717   // __ csel(r0, r0, zr, Assembler::NE);
1718   // and here is a faster way
1719   __ csinc(r0, zr, zr, Assembler::EQ);
1720   __ bind(done);
1721 }
1722 
1723 void TemplateTable::float_cmp(bool is_float, int unordered_result)
1724 {
1725   Label done;
1726   if (is_float) {
1727     // XXX get rid of pop here, use ... reg, mem32
1728     __ pop_f(v1);
1729     __ fcmps(v1, v0);
1730   } else {
1731     // XXX get rid of pop here, use ... reg, mem64
1732     __ pop_d(v1);
1733     __ fcmpd(v1, v0);
1734   }
1735   if (unordered_result &lt; 0) {
1736     // we want -1 for unordered or less than, 0 for equal and 1 for
1737     // greater than.
1738     __ mov(r0, (u_int64_t)-1L);
1739     // for FP LT tests less than or unordered
1740     __ br(Assembler::LT, done);
1741     // install 0 for EQ otherwise 1
1742     __ csinc(r0, zr, zr, Assembler::EQ);
1743   } else {
1744     // we want -1 for less than, 0 for equal and 1 for unordered or
1745     // greater than.
1746     __ mov(r0, 1L);
1747     // for FP HI tests greater than or unordered
1748     __ br(Assembler::HI, done);
1749     // install 0 for EQ otherwise ~0
1750     __ csinv(r0, zr, zr, Assembler::EQ);
1751 
1752   }
1753   __ bind(done);
1754 }
1755 
1756 void TemplateTable::branch(bool is_jsr, bool is_wide)
1757 {
1758   // We might be moving to a safepoint.  The thread which calls
1759   // Interpreter::notice_safepoints() will effectively flush its cache
1760   // when it makes a system call, but we need to do something to
1761   // ensure that we see the changed dispatch table.
1762   __ membar(MacroAssembler::LoadLoad);
1763 
1764   __ profile_taken_branch(r0, r1);
1765   const ByteSize be_offset = MethodCounters::backedge_counter_offset() +
1766                              InvocationCounter::counter_offset();
1767   const ByteSize inv_offset = MethodCounters::invocation_counter_offset() +
1768                               InvocationCounter::counter_offset();
1769 
1770   // load branch displacement
1771   if (!is_wide) {
1772     __ ldrh(r2, at_bcp(1));
1773     __ rev16(r2, r2);
1774     // sign extend the 16 bit value in r2
1775     __ sbfm(r2, r2, 0, 15);
1776   } else {
1777     __ ldrw(r2, at_bcp(1));
1778     __ revw(r2, r2);
1779     // sign extend the 32 bit value in r2
1780     __ sbfm(r2, r2, 0, 31);
1781   }
1782 
1783   // Handle all the JSR stuff here, then exit.
1784   // It&#39;s much shorter and cleaner than intermingling with the non-JSR
1785   // normal-branch stuff occurring below.
1786 
1787   if (is_jsr) {
1788     // Pre-load the next target bytecode into rscratch1
1789     __ load_unsigned_byte(rscratch1, Address(rbcp, r2));
1790     // compute return address as bci
1791     __ ldr(rscratch2, Address(rmethod, Method::const_offset()));
1792     __ add(rscratch2, rscratch2,
1793            in_bytes(ConstMethod::codes_offset()) - (is_wide ? 5 : 3));
1794     __ sub(r1, rbcp, rscratch2);
1795     __ push_i(r1);
1796     // Adjust the bcp by the 16-bit displacement in r2
1797     __ add(rbcp, rbcp, r2);
1798     __ dispatch_only(vtos, /*generate_poll*/true);
1799     return;
1800   }
1801 
1802   // Normal (non-jsr) branch handling
1803 
1804   // Adjust the bcp by the displacement in r2
1805   __ add(rbcp, rbcp, r2);
1806 
1807   assert(UseLoopCounter || !UseOnStackReplacement,
1808          &quot;on-stack-replacement requires loop counters&quot;);
1809   Label backedge_counter_overflow;
1810   Label profile_method;
1811   Label dispatch;
1812   if (UseLoopCounter) {
1813     // increment backedge counter for backward branches
1814     // r0: MDO
1815     // w1: MDO bumped taken-count
1816     // r2: target offset
1817     __ cmp(r2, zr);
1818     __ br(Assembler::GT, dispatch); // count only if backward branch
1819 
1820     // ECN: FIXME: This code smells
1821     // check if MethodCounters exists
1822     Label has_counters;
1823     __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1824     __ cbnz(rscratch1, has_counters);
1825     __ push(r0);
1826     __ push(r1);
1827     __ push(r2);
1828     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
1829             InterpreterRuntime::build_method_counters), rmethod);
1830     __ pop(r2);
1831     __ pop(r1);
1832     __ pop(r0);
1833     __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1834     __ cbz(rscratch1, dispatch); // No MethodCounters allocated, OutOfMemory
1835     __ bind(has_counters);
1836 
1837     if (TieredCompilation) {
1838       Label no_mdo;
1839       int increment = InvocationCounter::count_increment;
1840       if (ProfileInterpreter) {
1841         // Are we profiling?
1842         __ ldr(r1, Address(rmethod, in_bytes(Method::method_data_offset())));
1843         __ cbz(r1, no_mdo);
1844         // Increment the MDO backedge counter
1845         const Address mdo_backedge_counter(r1, in_bytes(MethodData::backedge_counter_offset()) +
1846                                            in_bytes(InvocationCounter::counter_offset()));
1847         const Address mask(r1, in_bytes(MethodData::backedge_mask_offset()));
1848         __ increment_mask_and_jump(mdo_backedge_counter, increment, mask,
1849                                    r0, rscratch1, false, Assembler::EQ,
1850                                    UseOnStackReplacement ? &amp;backedge_counter_overflow : &amp;dispatch);
1851         __ b(dispatch);
1852       }
1853       __ bind(no_mdo);
1854       // Increment backedge counter in MethodCounters*
1855       __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1856       const Address mask(rscratch1, in_bytes(MethodCounters::backedge_mask_offset()));
1857       __ increment_mask_and_jump(Address(rscratch1, be_offset), increment, mask,
1858                                  r0, rscratch2, false, Assembler::EQ,
1859                                  UseOnStackReplacement ? &amp;backedge_counter_overflow : &amp;dispatch);
1860     } else { // not TieredCompilation
1861       // increment counter
1862       __ ldr(rscratch2, Address(rmethod, Method::method_counters_offset()));
1863       __ ldrw(r0, Address(rscratch2, be_offset));        // load backedge counter
1864       __ addw(rscratch1, r0, InvocationCounter::count_increment); // increment counter
1865       __ strw(rscratch1, Address(rscratch2, be_offset));        // store counter
1866 
1867       __ ldrw(r0, Address(rscratch2, inv_offset));    // load invocation counter
1868       __ andw(r0, r0, (unsigned)InvocationCounter::count_mask_value); // and the status bits
1869       __ addw(r0, r0, rscratch1);        // add both counters
1870 
1871       if (ProfileInterpreter) {
1872         // Test to see if we should create a method data oop
1873         __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_profile_limit_offset())));
1874         __ cmpw(r0, rscratch1);
1875         __ br(Assembler::LT, dispatch);
1876 
1877         // if no method data exists, go to profile method
1878         __ test_method_data_pointer(r0, profile_method);
1879 
1880         if (UseOnStackReplacement) {
1881           // check for overflow against w1 which is the MDO taken count
1882           __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
1883           __ cmpw(r1, rscratch1);
1884           __ br(Assembler::LO, dispatch); // Intel == Assembler::below
1885 
1886           // When ProfileInterpreter is on, the backedge_count comes
1887           // from the MethodData*, which value does not get reset on
1888           // the call to frequency_counter_overflow().  To avoid
1889           // excessive calls to the overflow routine while the method is
1890           // being compiled, add a second test to make sure the overflow
1891           // function is called only once every overflow_frequency.
1892           const int overflow_frequency = 1024;
1893           __ andsw(r1, r1, overflow_frequency - 1);
1894           __ br(Assembler::EQ, backedge_counter_overflow);
1895 
1896         }
1897       } else {
1898         if (UseOnStackReplacement) {
1899           // check for overflow against w0, which is the sum of the
1900           // counters
1901           __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
1902           __ cmpw(r0, rscratch1);
1903           __ br(Assembler::HS, backedge_counter_overflow); // Intel == Assembler::aboveEqual
1904         }
1905       }
1906     }
1907     __ bind(dispatch);
1908   }
1909 
1910   // Pre-load the next target bytecode into rscratch1
1911   __ load_unsigned_byte(rscratch1, Address(rbcp, 0));
1912 
1913   // continue with the bytecode @ target
1914   // rscratch1: target bytecode
1915   // rbcp: target bcp
1916   __ dispatch_only(vtos, /*generate_poll*/true);
1917 
1918   if (UseLoopCounter) {
1919     if (ProfileInterpreter) {
1920       // Out-of-line code to allocate method data oop.
1921       __ bind(profile_method);
1922       __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
1923       __ load_unsigned_byte(r1, Address(rbcp, 0));  // restore target bytecode
1924       __ set_method_data_pointer_for_bcp();
1925       __ b(dispatch);
1926     }
1927 
1928     if (UseOnStackReplacement) {
1929       // invocation counter overflow
1930       __ bind(backedge_counter_overflow);
1931       __ neg(r2, r2);
1932       __ add(r2, r2, rbcp);     // branch bcp
1933       // IcoResult frequency_counter_overflow([JavaThread*], address branch_bcp)
1934       __ call_VM(noreg,
1935                  CAST_FROM_FN_PTR(address,
1936                                   InterpreterRuntime::frequency_counter_overflow),
1937                  r2);
1938       __ load_unsigned_byte(r1, Address(rbcp, 0));  // restore target bytecode
1939 
1940       // r0: osr nmethod (osr ok) or NULL (osr not possible)
1941       // w1: target bytecode
1942       // r2: scratch
1943       __ cbz(r0, dispatch);     // test result -- no osr if null
1944       // nmethod may have been invalidated (VM may block upon call_VM return)
1945       __ ldrb(r2, Address(r0, nmethod::state_offset()));
1946       if (nmethod::in_use != 0)
1947         __ sub(r2, r2, nmethod::in_use);
1948       __ cbnz(r2, dispatch);
1949 
1950       // We have the address of an on stack replacement routine in r0
1951       // We need to prepare to execute the OSR method. First we must
1952       // migrate the locals and monitors off of the stack.
1953 
1954       __ mov(r19, r0);                             // save the nmethod
1955 
1956       call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));
1957 
1958       // r0 is OSR buffer, move it to expected parameter location
1959       __ mov(j_rarg0, r0);
1960 
1961       // remove activation
1962       // get sender esp
1963       __ ldr(esp,
1964           Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));
1965       // remove frame anchor
1966       __ leave();
1967       // Ensure compiled code always sees stack at proper alignment
1968       __ andr(sp, esp, -16);
1969 
1970       // and begin the OSR nmethod
1971       __ ldr(rscratch1, Address(r19, nmethod::osr_entry_point_offset()));
1972       __ br(rscratch1);
1973     }
1974   }
1975 }
1976 
1977 
1978 void TemplateTable::if_0cmp(Condition cc)
1979 {
1980   transition(itos, vtos);
1981   // assume branch is more often taken than not (loops use backward branches)
1982   Label not_taken;
1983   if (cc == equal)
1984     __ cbnzw(r0, not_taken);
1985   else if (cc == not_equal)
1986     __ cbzw(r0, not_taken);
1987   else {
1988     __ andsw(zr, r0, r0);
1989     __ br(j_not(cc), not_taken);
1990   }
1991 
1992   branch(false, false);
1993   __ bind(not_taken);
1994   __ profile_not_taken_branch(r0);
1995 }
1996 
1997 void TemplateTable::if_icmp(Condition cc)
1998 {
1999   transition(itos, vtos);
2000   // assume branch is more often taken than not (loops use backward branches)
2001   Label not_taken;
2002   __ pop_i(r1);
2003   __ cmpw(r1, r0, Assembler::LSL);
2004   __ br(j_not(cc), not_taken);
2005   branch(false, false);
2006   __ bind(not_taken);
2007   __ profile_not_taken_branch(r0);
2008 }
2009 
2010 void TemplateTable::if_nullcmp(Condition cc)
2011 {
2012   transition(atos, vtos);
2013   // assume branch is more often taken than not (loops use backward branches)
2014   Label not_taken;
2015   if (cc == equal)
2016     __ cbnz(r0, not_taken);
2017   else
2018     __ cbz(r0, not_taken);
2019   branch(false, false);
2020   __ bind(not_taken);
2021   __ profile_not_taken_branch(r0);
2022 }
2023 
2024 void TemplateTable::if_acmp(Condition cc)
2025 {
2026   transition(atos, vtos);
2027   // assume branch is more often taken than not (loops use backward branches)
2028   Label not_taken;
2029   __ pop_ptr(r1);
2030   __ cmpoop(r1, r0);
2031   __ br(j_not(cc), not_taken);
2032   branch(false, false);
2033   __ bind(not_taken);
2034   __ profile_not_taken_branch(r0);
2035 }
2036 
2037 void TemplateTable::ret() {
2038   transition(vtos, vtos);
2039   // We might be moving to a safepoint.  The thread which calls
2040   // Interpreter::notice_safepoints() will effectively flush its cache
2041   // when it makes a system call, but we need to do something to
2042   // ensure that we see the changed dispatch table.
2043   __ membar(MacroAssembler::LoadLoad);
2044 
2045   locals_index(r1);
2046   __ ldr(r1, aaddress(r1)); // get return bci, compute return bcp
2047   __ profile_ret(r1, r2);
2048   __ ldr(rbcp, Address(rmethod, Method::const_offset()));
2049   __ lea(rbcp, Address(rbcp, r1));
2050   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));
2051   __ dispatch_next(vtos, 0, /*generate_poll*/true);
2052 }
2053 
2054 void TemplateTable::wide_ret() {
2055   transition(vtos, vtos);
2056   locals_index_wide(r1);
2057   __ ldr(r1, aaddress(r1)); // get return bci, compute return bcp
2058   __ profile_ret(r1, r2);
2059   __ ldr(rbcp, Address(rmethod, Method::const_offset()));
2060   __ lea(rbcp, Address(rbcp, r1));
2061   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));
2062   __ dispatch_next(vtos, 0, /*generate_poll*/true);
2063 }
2064 
2065 
2066 void TemplateTable::tableswitch() {
2067   Label default_case, continue_execution;
2068   transition(itos, vtos);
2069   // align rbcp
2070   __ lea(r1, at_bcp(BytesPerInt));
2071   __ andr(r1, r1, -BytesPerInt);
2072   // load lo &amp; hi
2073   __ ldrw(r2, Address(r1, BytesPerInt));
2074   __ ldrw(r3, Address(r1, 2 * BytesPerInt));
2075   __ rev32(r2, r2);
2076   __ rev32(r3, r3);
2077   // check against lo &amp; hi
2078   __ cmpw(r0, r2);
2079   __ br(Assembler::LT, default_case);
2080   __ cmpw(r0, r3);
2081   __ br(Assembler::GT, default_case);
2082   // lookup dispatch offset
2083   __ subw(r0, r0, r2);
2084   __ lea(r3, Address(r1, r0, Address::uxtw(2)));
2085   __ ldrw(r3, Address(r3, 3 * BytesPerInt));
2086   __ profile_switch_case(r0, r1, r2);
2087   // continue execution
2088   __ bind(continue_execution);
2089   __ rev32(r3, r3);
2090   __ load_unsigned_byte(rscratch1, Address(rbcp, r3, Address::sxtw(0)));
2091   __ add(rbcp, rbcp, r3, ext::sxtw);
2092   __ dispatch_only(vtos, /*generate_poll*/true);
2093   // handle default
2094   __ bind(default_case);
2095   __ profile_switch_default(r0);
2096   __ ldrw(r3, Address(r1, 0));
2097   __ b(continue_execution);
2098 }
2099 
2100 void TemplateTable::lookupswitch() {
2101   transition(itos, itos);
2102   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2103 }
2104 
2105 void TemplateTable::fast_linearswitch() {
2106   transition(itos, vtos);
2107   Label loop_entry, loop, found, continue_execution;
2108   // bswap r0 so we can avoid bswapping the table entries
2109   __ rev32(r0, r0);
2110   // align rbcp
2111   __ lea(r19, at_bcp(BytesPerInt)); // btw: should be able to get rid of
2112                                     // this instruction (change offsets
2113                                     // below)
2114   __ andr(r19, r19, -BytesPerInt);
2115   // set counter
2116   __ ldrw(r1, Address(r19, BytesPerInt));
2117   __ rev32(r1, r1);
2118   __ b(loop_entry);
2119   // table search
2120   __ bind(loop);
2121   __ lea(rscratch1, Address(r19, r1, Address::lsl(3)));
2122   __ ldrw(rscratch1, Address(rscratch1, 2 * BytesPerInt));
2123   __ cmpw(r0, rscratch1);
2124   __ br(Assembler::EQ, found);
2125   __ bind(loop_entry);
2126   __ subs(r1, r1, 1);
2127   __ br(Assembler::PL, loop);
2128   // default case
2129   __ profile_switch_default(r0);
2130   __ ldrw(r3, Address(r19, 0));
2131   __ b(continue_execution);
2132   // entry found -&gt; get offset
2133   __ bind(found);
2134   __ lea(rscratch1, Address(r19, r1, Address::lsl(3)));
2135   __ ldrw(r3, Address(rscratch1, 3 * BytesPerInt));
2136   __ profile_switch_case(r1, r0, r19);
2137   // continue execution
2138   __ bind(continue_execution);
2139   __ rev32(r3, r3);
2140   __ add(rbcp, rbcp, r3, ext::sxtw);
2141   __ ldrb(rscratch1, Address(rbcp, 0));
2142   __ dispatch_only(vtos, /*generate_poll*/true);
2143 }
2144 
2145 void TemplateTable::fast_binaryswitch() {
2146   transition(itos, vtos);
2147   // Implementation using the following core algorithm:
2148   //
2149   // int binary_search(int key, LookupswitchPair* array, int n) {
2150   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2151   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2152   //   int i = 0;
2153   //   int j = n;
2154   //   while (i+1 &lt; j) {
2155   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2156   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2157   //     // where a stands for the array and assuming that the (inexisting)
2158   //     // element a[n] is infinitely big.
2159   //     int h = (i + j) &gt;&gt; 1;
2160   //     // i &lt; h &lt; j
2161   //     if (key &lt; array[h].fast_match()) {
2162   //       j = h;
2163   //     } else {
2164   //       i = h;
2165   //     }
2166   //   }
2167   //   // R: a[i] &lt;= key &lt; a[i+1] or Q
2168   //   // (i.e., if key is within array, i is the correct index)
2169   //   return i;
2170   // }
2171 
2172   // Register allocation
2173   const Register key   = r0; // already set (tosca)
2174   const Register array = r1;
2175   const Register i     = r2;
2176   const Register j     = r3;
2177   const Register h     = rscratch1;
2178   const Register temp  = rscratch2;
2179 
2180   // Find array start
2181   __ lea(array, at_bcp(3 * BytesPerInt)); // btw: should be able to
2182                                           // get rid of this
2183                                           // instruction (change
2184                                           // offsets below)
2185   __ andr(array, array, -BytesPerInt);
2186 
2187   // Initialize i &amp; j
2188   __ mov(i, 0);                            // i = 0;
2189   __ ldrw(j, Address(array, -BytesPerInt)); // j = length(array);
2190 
2191   // Convert j into native byteordering
2192   __ rev32(j, j);
2193 
2194   // And start
2195   Label entry;
2196   __ b(entry);
2197 
2198   // binary search loop
2199   {
2200     Label loop;
2201     __ bind(loop);
2202     // int h = (i + j) &gt;&gt; 1;
2203     __ addw(h, i, j);                           // h = i + j;
2204     __ lsrw(h, h, 1);                                   // h = (i + j) &gt;&gt; 1;
2205     // if (key &lt; array[h].fast_match()) {
2206     //   j = h;
2207     // } else {
2208     //   i = h;
2209     // }
2210     // Convert array[h].match to native byte-ordering before compare
2211     __ ldr(temp, Address(array, h, Address::lsl(3)));
2212     __ rev32(temp, temp);
2213     __ cmpw(key, temp);
2214     // j = h if (key &lt;  array[h].fast_match())
2215     __ csel(j, h, j, Assembler::LT);
2216     // i = h if (key &gt;= array[h].fast_match())
2217     __ csel(i, h, i, Assembler::GE);
2218     // while (i+1 &lt; j)
2219     __ bind(entry);
2220     __ addw(h, i, 1);          // i+1
2221     __ cmpw(h, j);             // i+1 &lt; j
2222     __ br(Assembler::LT, loop);
2223   }
2224 
2225   // end of binary search, result index is i (must check again!)
2226   Label default_case;
2227   // Convert array[i].match to native byte-ordering before compare
2228   __ ldr(temp, Address(array, i, Address::lsl(3)));
2229   __ rev32(temp, temp);
2230   __ cmpw(key, temp);
2231   __ br(Assembler::NE, default_case);
2232 
2233   // entry found -&gt; j = offset
2234   __ add(j, array, i, ext::uxtx, 3);
2235   __ ldrw(j, Address(j, BytesPerInt));
2236   __ profile_switch_case(i, key, array);
2237   __ rev32(j, j);
2238   __ load_unsigned_byte(rscratch1, Address(rbcp, j, Address::sxtw(0)));
2239   __ lea(rbcp, Address(rbcp, j, Address::sxtw(0)));
2240   __ dispatch_only(vtos, /*generate_poll*/true);
2241 
2242   // default case -&gt; j = default offset
2243   __ bind(default_case);
2244   __ profile_switch_default(i);
2245   __ ldrw(j, Address(array, -2 * BytesPerInt));
2246   __ rev32(j, j);
2247   __ load_unsigned_byte(rscratch1, Address(rbcp, j, Address::sxtw(0)));
2248   __ lea(rbcp, Address(rbcp, j, Address::sxtw(0)));
2249   __ dispatch_only(vtos, /*generate_poll*/true);
2250 }
2251 
2252 
2253 void TemplateTable::_return(TosState state)
2254 {
2255   transition(state, state);
2256   assert(_desc-&gt;calls_vm(),
2257          &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2258 
2259   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2260     assert(state == vtos, &quot;only valid state&quot;);
2261 
2262     __ ldr(c_rarg1, aaddress(0));
2263     __ load_klass(r3, c_rarg1);
2264     __ ldrw(r3, Address(r3, Klass::access_flags_offset()));
2265     Label skip_register_finalizer;
2266     __ tbz(r3, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);
2267 
2268     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), c_rarg1);
2269 
2270     __ bind(skip_register_finalizer);
2271   }
2272 
2273   // Issue a StoreStore barrier after all stores but before return
2274   // from any constructor for any class with a final field.  We don&#39;t
2275   // know if this is a finalizer, so we always do so.
2276   if (_desc-&gt;bytecode() == Bytecodes::_return)
2277     __ membar(MacroAssembler::StoreStore);
2278 
2279   // Narrow result if state is itos but result type is smaller.
2280   // Need to narrow in the return bytecode rather than in generate_return_entry
2281   // since compiled code callers expect the result to already be narrowed.
2282   if (state == itos) {
2283     __ narrow(r0);
2284   }
2285 
2286   __ remove_activation(state);
2287   __ ret(lr);
2288 }
2289 
2290 // ----------------------------------------------------------------------------
2291 // Volatile variables demand their effects be made known to all CPU&#39;s
2292 // in order.  Store buffers on most chips allow reads &amp; writes to
2293 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2294 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2295 // the interpreter does not reorder volatile references, the hardware
2296 // also must not reorder them).
2297 //
2298 // According to the new Java Memory Model (JMM):
2299 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2300 //     writes act as aquire &amp; release, so:
2301 // (2) A read cannot let unrelated NON-volatile memory refs that
2302 //     happen after the read float up to before the read.  It&#39;s OK for
2303 //     non-volatile memory refs that happen before the volatile read to
2304 //     float down below it.
2305 // (3) Similar a volatile write cannot let unrelated NON-volatile
2306 //     memory refs that happen BEFORE the write float down to after the
2307 //     write.  It&#39;s OK for non-volatile memory refs that happen after the
2308 //     volatile write to float up before it.
2309 //
2310 // We only put in barriers around volatile refs (they are expensive),
2311 // not _between_ memory refs (that would require us to track the
2312 // flavor of the previous memory refs).  Requirements (2) and (3)
2313 // require some barriers before volatile stores and after volatile
2314 // loads.  These nearly cover requirement (1) but miss the
2315 // volatile-store-volatile-load case.  This final case is placed after
2316 // volatile-stores although it could just as well go before
2317 // volatile-loads.
2318 
2319 void TemplateTable::resolve_cache_and_index(int byte_no,
2320                                             Register Rcache,
2321                                             Register index,
2322                                             size_t index_size) {
2323   const Register temp = r19;
2324   assert_different_registers(Rcache, index, temp);
2325 
<a name="8" id="anc8"></a><span class="line-modified">2326   Label resolved;</span>
2327 
2328   Bytecodes::Code code = bytecode();
2329   switch (code) {
2330   case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2331   case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2332   default: break;
2333   }
2334 
2335   assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
2336   __ get_cache_and_index_and_bytecode_at_bcp(Rcache, index, temp, byte_no, 1, index_size);
2337   __ subs(zr, temp, (int) code);  // have we resolved this bytecode?
2338   __ br(Assembler::EQ, resolved);
2339 
2340   // resolve first time through
<a name="9" id="anc9"></a>

2341   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2342   __ mov(temp, (int) code);
2343   __ call_VM(noreg, entry, temp);
2344 
2345   // Update registers with resolved info
2346   __ get_cache_and_index_at_bcp(Rcache, index, 1, index_size);
2347   // n.b. unlike x86 Rcache is now rcpool plus the indexed offset
2348   // so all clients ofthis method must be modified accordingly
2349   __ bind(resolved);
<a name="10" id="anc10"></a>






2350 }
2351 
2352 // The Rcache and index registers must be set before call
2353 // n.b unlike x86 cache already includes the index offset
2354 void TemplateTable::load_field_cp_cache_entry(Register obj,
2355                                               Register cache,
2356                                               Register index,
2357                                               Register off,
2358                                               Register flags,
2359                                               bool is_static = false) {
2360   assert_different_registers(cache, index, flags, off);
2361 
2362   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2363   // Field offset
2364   __ ldr(off, Address(cache, in_bytes(cp_base_offset +
2365                                           ConstantPoolCacheEntry::f2_offset())));
2366   // Flags
2367   __ ldrw(flags, Address(cache, in_bytes(cp_base_offset +
2368                                            ConstantPoolCacheEntry::flags_offset())));
2369 
2370   // klass overwrite register
2371   if (is_static) {
2372     __ ldr(obj, Address(cache, in_bytes(cp_base_offset +
2373                                         ConstantPoolCacheEntry::f1_offset())));
2374     const int mirror_offset = in_bytes(Klass::java_mirror_offset());
2375     __ ldr(obj, Address(obj, mirror_offset));
2376     __ resolve_oop_handle(obj);
2377   }
2378 }
2379 
2380 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
2381                                                Register method,
2382                                                Register itable_index,
2383                                                Register flags,
2384                                                bool is_invokevirtual,
2385                                                bool is_invokevfinal, /*unused*/
2386                                                bool is_invokedynamic) {
2387   // setup registers
2388   const Register cache = rscratch2;
2389   const Register index = r4;
2390   assert_different_registers(method, flags);
2391   assert_different_registers(method, cache, index);
2392   assert_different_registers(itable_index, flags);
2393   assert_different_registers(itable_index, cache, index);
2394   // determine constant pool cache field offsets
2395   assert(is_invokevirtual == (byte_no == f2_byte), &quot;is_invokevirtual flag redundant&quot;);
2396   const int method_offset = in_bytes(
2397     ConstantPoolCache::base_offset() +
2398       (is_invokevirtual
2399        ? ConstantPoolCacheEntry::f2_offset()
2400        : ConstantPoolCacheEntry::f1_offset()));
2401   const int flags_offset = in_bytes(ConstantPoolCache::base_offset() +
2402                                     ConstantPoolCacheEntry::flags_offset());
2403   // access constant pool cache fields
2404   const int index_offset = in_bytes(ConstantPoolCache::base_offset() +
2405                                     ConstantPoolCacheEntry::f2_offset());
2406 
2407   size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));
2408   resolve_cache_and_index(byte_no, cache, index, index_size);
2409   __ ldr(method, Address(cache, method_offset));
2410 
2411   if (itable_index != noreg) {
2412     __ ldr(itable_index, Address(cache, index_offset));
2413   }
2414   __ ldrw(flags, Address(cache, flags_offset));
2415 }
2416 
2417 
2418 // The registers cache and index expected to be set before call.
2419 // Correct values of the cache and index registers are preserved.
2420 void TemplateTable::jvmti_post_field_access(Register cache, Register index,
2421                                             bool is_static, bool has_tos) {
2422   // do the JVMTI work here to avoid disturbing the register state below
2423   // We use c_rarg registers here because we want to use the register used in
2424   // the call to the VM
2425   if (JvmtiExport::can_post_field_access()) {
2426     // Check to see if a field access watch has been set before we
2427     // take the time to call into the VM.
2428     Label L1;
2429     assert_different_registers(cache, index, r0);
2430     __ lea(rscratch1, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
2431     __ ldrw(r0, Address(rscratch1));
2432     __ cbzw(r0, L1);
2433 
2434     __ get_cache_and_index_at_bcp(c_rarg2, c_rarg3, 1);
2435     __ lea(c_rarg2, Address(c_rarg2, in_bytes(ConstantPoolCache::base_offset())));
2436 
2437     if (is_static) {
2438       __ mov(c_rarg1, zr); // NULL object reference
2439     } else {
2440       __ ldr(c_rarg1, at_tos()); // get object pointer without popping it
2441       __ verify_oop(c_rarg1);
2442     }
2443     // c_rarg1: object pointer or NULL
2444     // c_rarg2: cache entry pointer
2445     // c_rarg3: jvalue object on the stack
2446     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2447                                        InterpreterRuntime::post_field_access),
2448                c_rarg1, c_rarg2, c_rarg3);
2449     __ get_cache_and_index_at_bcp(cache, index, 1);
2450     __ bind(L1);
2451   }
2452 }
2453 
2454 void TemplateTable::pop_and_check_object(Register r)
2455 {
2456   __ pop_ptr(r);
2457   __ null_check(r);  // for field access must check obj.
2458   __ verify_oop(r);
2459 }
2460 
2461 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc)
2462 {
2463   const Register cache = r2;
2464   const Register index = r3;
2465   const Register obj   = r4;
2466   const Register off   = r19;
2467   const Register flags = r0;
2468   const Register raw_flags = r6;
2469   const Register bc    = r4; // uses same reg as obj, so don&#39;t mix them
2470 
2471   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2472   jvmti_post_field_access(cache, index, is_static, false);
2473   load_field_cp_cache_entry(obj, cache, index, off, raw_flags, is_static);
2474 
2475   if (!is_static) {
2476     // obj is on the stack
2477     pop_and_check_object(obj);
2478   }
2479 
2480   // 8179954: We need to make sure that the code generated for
2481   // volatile accesses forms a sequentially-consistent set of
2482   // operations when combined with STLR and LDAR.  Without a leading
2483   // membar it&#39;s possible for a simple Dekker test to fail if loads
2484   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
2485   // the stores in one method and we interpret the loads in another.
2486   if (! UseBarriersForVolatile) {
2487     Label notVolatile;
2488     __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2489     __ membar(MacroAssembler::AnyAny);
2490     __ bind(notVolatile);
2491   }
2492 
2493   const Address field(obj, off);
2494 
2495   Label Done, notByte, notBool, notInt, notShort, notChar,
2496               notLong, notFloat, notObj, notDouble;
2497 
2498   // x86 uses a shift and mask or wings it with a shift plus assert
2499   // the mask is not needed. aarch64 just uses bitfield extract
2500   __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift,
2501            ConstantPoolCacheEntry::tos_state_bits);
2502 
2503   assert(btos == 0, &quot;change code, btos != 0&quot;);
2504   __ cbnz(flags, notByte);
2505 
2506   // Don&#39;t rewrite getstatic, only getfield
2507   if (is_static) rc = may_not_rewrite;
2508 
2509   // btos
2510   __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
2511   __ push(btos);
2512   // Rewrite bytecode to be faster
2513   if (rc == may_rewrite) {
2514     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
2515   }
2516   __ b(Done);
2517 
2518   __ bind(notByte);
2519   __ cmp(flags, (u1)ztos);
2520   __ br(Assembler::NE, notBool);
2521 
2522   // ztos (same code as btos)
2523   __ access_load_at(T_BOOLEAN, IN_HEAP, r0, field, noreg, noreg);
2524   __ push(ztos);
2525   // Rewrite bytecode to be faster
2526   if (rc == may_rewrite) {
2527     // use btos rewriting, no truncating to t/f bit is needed for getfield.
2528     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
2529   }
2530   __ b(Done);
2531 
2532   __ bind(notBool);
2533   __ cmp(flags, (u1)atos);
2534   __ br(Assembler::NE, notObj);
2535   // atos
2536   do_oop_load(_masm, field, r0, IN_HEAP);
2537   __ push(atos);
2538   if (rc == may_rewrite) {
2539     patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);
2540   }
2541   __ b(Done);
2542 
2543   __ bind(notObj);
2544   __ cmp(flags, (u1)itos);
2545   __ br(Assembler::NE, notInt);
2546   // itos
2547   __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
2548   __ push(itos);
2549   // Rewrite bytecode to be faster
2550   if (rc == may_rewrite) {
2551     patch_bytecode(Bytecodes::_fast_igetfield, bc, r1);
2552   }
2553   __ b(Done);
2554 
2555   __ bind(notInt);
2556   __ cmp(flags, (u1)ctos);
2557   __ br(Assembler::NE, notChar);
2558   // ctos
2559   __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
2560   __ push(ctos);
2561   // Rewrite bytecode to be faster
2562   if (rc == may_rewrite) {
2563     patch_bytecode(Bytecodes::_fast_cgetfield, bc, r1);
2564   }
2565   __ b(Done);
2566 
2567   __ bind(notChar);
2568   __ cmp(flags, (u1)stos);
2569   __ br(Assembler::NE, notShort);
2570   // stos
2571   __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
2572   __ push(stos);
2573   // Rewrite bytecode to be faster
2574   if (rc == may_rewrite) {
2575     patch_bytecode(Bytecodes::_fast_sgetfield, bc, r1);
2576   }
2577   __ b(Done);
2578 
2579   __ bind(notShort);
2580   __ cmp(flags, (u1)ltos);
2581   __ br(Assembler::NE, notLong);
2582   // ltos
2583   __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
2584   __ push(ltos);
2585   // Rewrite bytecode to be faster
2586   if (rc == may_rewrite) {
2587     patch_bytecode(Bytecodes::_fast_lgetfield, bc, r1);
2588   }
2589   __ b(Done);
2590 
2591   __ bind(notLong);
2592   __ cmp(flags, (u1)ftos);
2593   __ br(Assembler::NE, notFloat);
2594   // ftos
2595   __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
2596   __ push(ftos);
2597   // Rewrite bytecode to be faster
2598   if (rc == may_rewrite) {
2599     patch_bytecode(Bytecodes::_fast_fgetfield, bc, r1);
2600   }
2601   __ b(Done);
2602 
2603   __ bind(notFloat);
2604 #ifdef ASSERT
2605   __ cmp(flags, (u1)dtos);
2606   __ br(Assembler::NE, notDouble);
2607 #endif
2608   // dtos
2609   __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
2610   __ push(dtos);
2611   // Rewrite bytecode to be faster
2612   if (rc == may_rewrite) {
2613     patch_bytecode(Bytecodes::_fast_dgetfield, bc, r1);
2614   }
2615 #ifdef ASSERT
2616   __ b(Done);
2617 
2618   __ bind(notDouble);
2619   __ stop(&quot;Bad state&quot;);
2620 #endif
2621 
2622   __ bind(Done);
2623 
2624   Label notVolatile;
2625   __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2626   __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
2627   __ bind(notVolatile);
2628 }
2629 
2630 
2631 void TemplateTable::getfield(int byte_no)
2632 {
2633   getfield_or_static(byte_no, false);
2634 }
2635 
2636 void TemplateTable::nofast_getfield(int byte_no) {
2637   getfield_or_static(byte_no, false, may_not_rewrite);
2638 }
2639 
2640 void TemplateTable::getstatic(int byte_no)
2641 {
2642   getfield_or_static(byte_no, true);
2643 }
2644 
2645 // The registers cache and index expected to be set before call.
2646 // The function may destroy various registers, just not the cache and index registers.
2647 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
2648   transition(vtos, vtos);
2649 
2650   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2651 
2652   if (JvmtiExport::can_post_field_modification()) {
2653     // Check to see if a field modification watch has been set before
2654     // we take the time to call into the VM.
2655     Label L1;
2656     assert_different_registers(cache, index, r0);
2657     __ lea(rscratch1, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
2658     __ ldrw(r0, Address(rscratch1));
2659     __ cbz(r0, L1);
2660 
2661     __ get_cache_and_index_at_bcp(c_rarg2, rscratch1, 1);
2662 
2663     if (is_static) {
2664       // Life is simple.  Null out the object pointer.
2665       __ mov(c_rarg1, zr);
2666     } else {
2667       // Life is harder. The stack holds the value on top, followed by
2668       // the object.  We don&#39;t know the size of the value, though; it
2669       // could be one or two words depending on its type. As a result,
2670       // we must find the type to determine where the object is.
2671       __ ldrw(c_rarg3, Address(c_rarg2,
2672                                in_bytes(cp_base_offset +
2673                                         ConstantPoolCacheEntry::flags_offset())));
2674       __ lsr(c_rarg3, c_rarg3,
2675              ConstantPoolCacheEntry::tos_state_shift);
2676       ConstantPoolCacheEntry::verify_tos_state_shift();
2677       Label nope2, done, ok;
2678       __ ldr(c_rarg1, at_tos_p1());  // initially assume a one word jvalue
2679       __ cmpw(c_rarg3, ltos);
2680       __ br(Assembler::EQ, ok);
2681       __ cmpw(c_rarg3, dtos);
2682       __ br(Assembler::NE, nope2);
2683       __ bind(ok);
2684       __ ldr(c_rarg1, at_tos_p2()); // ltos (two word jvalue)
2685       __ bind(nope2);
2686     }
2687     // cache entry pointer
2688     __ add(c_rarg2, c_rarg2, in_bytes(cp_base_offset));
2689     // object (tos)
2690     __ mov(c_rarg3, esp);
2691     // c_rarg1: object pointer set up above (NULL if static)
2692     // c_rarg2: cache entry pointer
2693     // c_rarg3: jvalue object on the stack
2694     __ call_VM(noreg,
2695                CAST_FROM_FN_PTR(address,
2696                                 InterpreterRuntime::post_field_modification),
2697                c_rarg1, c_rarg2, c_rarg3);
2698     __ get_cache_and_index_at_bcp(cache, index, 1);
2699     __ bind(L1);
2700   }
2701 }
2702 
2703 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2704   transition(vtos, vtos);
2705 
2706   const Register cache = r2;
2707   const Register index = r3;
2708   const Register obj   = r2;
2709   const Register off   = r19;
2710   const Register flags = r0;
2711   const Register bc    = r4;
2712 
2713   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2714   jvmti_post_field_mod(cache, index, is_static);
2715   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2716 
2717   Label Done;
2718   __ mov(r5, flags);
2719 
2720   {
2721     Label notVolatile;
2722     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2723     __ membar(MacroAssembler::StoreStore | MacroAssembler::LoadStore);
2724     __ bind(notVolatile);
2725   }
2726 
2727   // field address
2728   const Address field(obj, off);
2729 
2730   Label notByte, notBool, notInt, notShort, notChar,
2731         notLong, notFloat, notObj, notDouble;
2732 
2733   // x86 uses a shift and mask or wings it with a shift plus assert
2734   // the mask is not needed. aarch64 just uses bitfield extract
2735   __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);
2736 
2737   assert(btos == 0, &quot;change code, btos != 0&quot;);
2738   __ cbnz(flags, notByte);
2739 
2740   // Don&#39;t rewrite putstatic, only putfield
2741   if (is_static) rc = may_not_rewrite;
2742 
2743   // btos
2744   {
2745     __ pop(btos);
2746     if (!is_static) pop_and_check_object(obj);
2747     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
2748     if (rc == may_rewrite) {
2749       patch_bytecode(Bytecodes::_fast_bputfield, bc, r1, true, byte_no);
2750     }
2751     __ b(Done);
2752   }
2753 
2754   __ bind(notByte);
2755   __ cmp(flags, (u1)ztos);
2756   __ br(Assembler::NE, notBool);
2757 
2758   // ztos
2759   {
2760     __ pop(ztos);
2761     if (!is_static) pop_and_check_object(obj);
2762     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
2763     if (rc == may_rewrite) {
2764       patch_bytecode(Bytecodes::_fast_zputfield, bc, r1, true, byte_no);
2765     }
2766     __ b(Done);
2767   }
2768 
2769   __ bind(notBool);
2770   __ cmp(flags, (u1)atos);
2771   __ br(Assembler::NE, notObj);
2772 
2773   // atos
2774   {
2775     __ pop(atos);
2776     if (!is_static) pop_and_check_object(obj);
2777     // Store into the field
2778     do_oop_store(_masm, field, r0, IN_HEAP);
2779     if (rc == may_rewrite) {
2780       patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);
2781     }
2782     __ b(Done);
2783   }
2784 
2785   __ bind(notObj);
2786   __ cmp(flags, (u1)itos);
2787   __ br(Assembler::NE, notInt);
2788 
2789   // itos
2790   {
2791     __ pop(itos);
2792     if (!is_static) pop_and_check_object(obj);
2793     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
2794     if (rc == may_rewrite) {
2795       patch_bytecode(Bytecodes::_fast_iputfield, bc, r1, true, byte_no);
2796     }
2797     __ b(Done);
2798   }
2799 
2800   __ bind(notInt);
2801   __ cmp(flags, (u1)ctos);
2802   __ br(Assembler::NE, notChar);
2803 
2804   // ctos
2805   {
2806     __ pop(ctos);
2807     if (!is_static) pop_and_check_object(obj);
2808     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
2809     if (rc == may_rewrite) {
2810       patch_bytecode(Bytecodes::_fast_cputfield, bc, r1, true, byte_no);
2811     }
2812     __ b(Done);
2813   }
2814 
2815   __ bind(notChar);
2816   __ cmp(flags, (u1)stos);
2817   __ br(Assembler::NE, notShort);
2818 
2819   // stos
2820   {
2821     __ pop(stos);
2822     if (!is_static) pop_and_check_object(obj);
2823     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
2824     if (rc == may_rewrite) {
2825       patch_bytecode(Bytecodes::_fast_sputfield, bc, r1, true, byte_no);
2826     }
2827     __ b(Done);
2828   }
2829 
2830   __ bind(notShort);
2831   __ cmp(flags, (u1)ltos);
2832   __ br(Assembler::NE, notLong);
2833 
2834   // ltos
2835   {
2836     __ pop(ltos);
2837     if (!is_static) pop_and_check_object(obj);
2838     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
2839     if (rc == may_rewrite) {
2840       patch_bytecode(Bytecodes::_fast_lputfield, bc, r1, true, byte_no);
2841     }
2842     __ b(Done);
2843   }
2844 
2845   __ bind(notLong);
2846   __ cmp(flags, (u1)ftos);
2847   __ br(Assembler::NE, notFloat);
2848 
2849   // ftos
2850   {
2851     __ pop(ftos);
2852     if (!is_static) pop_and_check_object(obj);
2853     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
2854     if (rc == may_rewrite) {
2855       patch_bytecode(Bytecodes::_fast_fputfield, bc, r1, true, byte_no);
2856     }
2857     __ b(Done);
2858   }
2859 
2860   __ bind(notFloat);
2861 #ifdef ASSERT
2862   __ cmp(flags, (u1)dtos);
2863   __ br(Assembler::NE, notDouble);
2864 #endif
2865 
2866   // dtos
2867   {
2868     __ pop(dtos);
2869     if (!is_static) pop_and_check_object(obj);
2870     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
2871     if (rc == may_rewrite) {
2872       patch_bytecode(Bytecodes::_fast_dputfield, bc, r1, true, byte_no);
2873     }
2874   }
2875 
2876 #ifdef ASSERT
2877   __ b(Done);
2878 
2879   __ bind(notDouble);
2880   __ stop(&quot;Bad state&quot;);
2881 #endif
2882 
2883   __ bind(Done);
2884 
2885   {
2886     Label notVolatile;
2887     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
<a name="11" id="anc11"></a><span class="line-modified">2888     __ membar(MacroAssembler::StoreLoad);</span>
2889     __ bind(notVolatile);
2890   }
2891 }
2892 
2893 void TemplateTable::putfield(int byte_no)
2894 {
2895   putfield_or_static(byte_no, false);
2896 }
2897 
2898 void TemplateTable::nofast_putfield(int byte_no) {
2899   putfield_or_static(byte_no, false, may_not_rewrite);
2900 }
2901 
2902 void TemplateTable::putstatic(int byte_no) {
2903   putfield_or_static(byte_no, true);
2904 }
2905 
2906 void TemplateTable::jvmti_post_fast_field_mod()
2907 {
2908   if (JvmtiExport::can_post_field_modification()) {
2909     // Check to see if a field modification watch has been set before
2910     // we take the time to call into the VM.
2911     Label L2;
2912     __ lea(rscratch1, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
2913     __ ldrw(c_rarg3, Address(rscratch1));
2914     __ cbzw(c_rarg3, L2);
2915     __ pop_ptr(r19);                  // copy the object pointer from tos
2916     __ verify_oop(r19);
2917     __ push_ptr(r19);                 // put the object pointer back on tos
2918     // Save tos values before call_VM() clobbers them. Since we have
2919     // to do it for every data type, we use the saved values as the
2920     // jvalue object.
2921     switch (bytecode()) {          // load values into the jvalue object
2922     case Bytecodes::_fast_aputfield: __ push_ptr(r0); break;
2923     case Bytecodes::_fast_bputfield: // fall through
2924     case Bytecodes::_fast_zputfield: // fall through
2925     case Bytecodes::_fast_sputfield: // fall through
2926     case Bytecodes::_fast_cputfield: // fall through
2927     case Bytecodes::_fast_iputfield: __ push_i(r0); break;
2928     case Bytecodes::_fast_dputfield: __ push_d(); break;
2929     case Bytecodes::_fast_fputfield: __ push_f(); break;
2930     case Bytecodes::_fast_lputfield: __ push_l(r0); break;
2931 
2932     default:
2933       ShouldNotReachHere();
2934     }
2935     __ mov(c_rarg3, esp);             // points to jvalue on the stack
2936     // access constant pool cache entry
2937     __ get_cache_entry_pointer_at_bcp(c_rarg2, r0, 1);
2938     __ verify_oop(r19);
2939     // r19: object pointer copied above
2940     // c_rarg2: cache entry pointer
2941     // c_rarg3: jvalue object on the stack
2942     __ call_VM(noreg,
2943                CAST_FROM_FN_PTR(address,
2944                                 InterpreterRuntime::post_field_modification),
2945                r19, c_rarg2, c_rarg3);
2946 
2947     switch (bytecode()) {             // restore tos values
2948     case Bytecodes::_fast_aputfield: __ pop_ptr(r0); break;
2949     case Bytecodes::_fast_bputfield: // fall through
2950     case Bytecodes::_fast_zputfield: // fall through
2951     case Bytecodes::_fast_sputfield: // fall through
2952     case Bytecodes::_fast_cputfield: // fall through
2953     case Bytecodes::_fast_iputfield: __ pop_i(r0); break;
2954     case Bytecodes::_fast_dputfield: __ pop_d(); break;
2955     case Bytecodes::_fast_fputfield: __ pop_f(); break;
2956     case Bytecodes::_fast_lputfield: __ pop_l(r0); break;
2957     default: break;
2958     }
2959     __ bind(L2);
2960   }
2961 }
2962 
2963 void TemplateTable::fast_storefield(TosState state)
2964 {
2965   transition(state, vtos);
2966 
2967   ByteSize base = ConstantPoolCache::base_offset();
2968 
2969   jvmti_post_fast_field_mod();
2970 
2971   // access constant pool cache
2972   __ get_cache_and_index_at_bcp(r2, r1, 1);
2973 
2974   // test for volatile with r3
2975   __ ldrw(r3, Address(r2, in_bytes(base +
2976                                    ConstantPoolCacheEntry::flags_offset())));
2977 
2978   // replace index with field offset from cache entry
2979   __ ldr(r1, Address(r2, in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
2980 
2981   {
2982     Label notVolatile;
2983     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2984     __ membar(MacroAssembler::StoreStore | MacroAssembler::LoadStore);
2985     __ bind(notVolatile);
2986   }
2987 
2988   Label notVolatile;
2989 
2990   // Get object from stack
2991   pop_and_check_object(r2);
2992 
2993   // field address
2994   const Address field(r2, r1);
2995 
2996   // access field
2997   switch (bytecode()) {
2998   case Bytecodes::_fast_aputfield:
2999     do_oop_store(_masm, field, r0, IN_HEAP);
3000     break;
3001   case Bytecodes::_fast_lputfield:
3002     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
3003     break;
3004   case Bytecodes::_fast_iputfield:
3005     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
3006     break;
3007   case Bytecodes::_fast_zputfield:
3008     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
3009     break;
3010   case Bytecodes::_fast_bputfield:
3011     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
3012     break;
3013   case Bytecodes::_fast_sputfield:
3014     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
3015     break;
3016   case Bytecodes::_fast_cputfield:
3017     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
3018     break;
3019   case Bytecodes::_fast_fputfield:
3020     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
3021     break;
3022   case Bytecodes::_fast_dputfield:
3023     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
3024     break;
3025   default:
3026     ShouldNotReachHere();
3027   }
3028 
3029   {
3030     Label notVolatile;
3031     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
<a name="12" id="anc12"></a><span class="line-modified">3032     __ membar(MacroAssembler::StoreLoad);</span>
3033     __ bind(notVolatile);
3034   }
3035 }
3036 
3037 
3038 void TemplateTable::fast_accessfield(TosState state)
3039 {
3040   transition(atos, state);
3041   // Do the JVMTI work here to avoid disturbing the register state below
3042   if (JvmtiExport::can_post_field_access()) {
3043     // Check to see if a field access watch has been set before we
3044     // take the time to call into the VM.
3045     Label L1;
3046     __ lea(rscratch1, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
3047     __ ldrw(r2, Address(rscratch1));
3048     __ cbzw(r2, L1);
3049     // access constant pool cache entry
3050     __ get_cache_entry_pointer_at_bcp(c_rarg2, rscratch2, 1);
3051     __ verify_oop(r0);
3052     __ push_ptr(r0);  // save object pointer before call_VM() clobbers it
3053     __ mov(c_rarg1, r0);
3054     // c_rarg1: object pointer copied above
3055     // c_rarg2: cache entry pointer
3056     __ call_VM(noreg,
3057                CAST_FROM_FN_PTR(address,
3058                                 InterpreterRuntime::post_field_access),
3059                c_rarg1, c_rarg2);
3060     __ pop_ptr(r0); // restore object pointer
3061     __ bind(L1);
3062   }
3063 
3064   // access constant pool cache
3065   __ get_cache_and_index_at_bcp(r2, r1, 1);
3066   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3067                                   ConstantPoolCacheEntry::f2_offset())));
3068   __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3069                                    ConstantPoolCacheEntry::flags_offset())));
3070 
3071   // r0: object
3072   __ verify_oop(r0);
3073   __ null_check(r0);
3074   const Address field(r0, r1);
3075 
3076   // 8179954: We need to make sure that the code generated for
3077   // volatile accesses forms a sequentially-consistent set of
3078   // operations when combined with STLR and LDAR.  Without a leading
3079   // membar it&#39;s possible for a simple Dekker test to fail if loads
3080   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3081   // the stores in one method and we interpret the loads in another.
3082   if (! UseBarriersForVolatile) {
3083     Label notVolatile;
3084     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3085     __ membar(MacroAssembler::AnyAny);
3086     __ bind(notVolatile);
3087   }
3088 
3089   // access field
3090   switch (bytecode()) {
3091   case Bytecodes::_fast_agetfield:
3092     do_oop_load(_masm, field, r0, IN_HEAP);
3093     __ verify_oop(r0);
3094     break;
3095   case Bytecodes::_fast_lgetfield:
3096     __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
3097     break;
3098   case Bytecodes::_fast_igetfield:
3099     __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
3100     break;
3101   case Bytecodes::_fast_bgetfield:
3102     __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
3103     break;
3104   case Bytecodes::_fast_sgetfield:
3105     __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
3106     break;
3107   case Bytecodes::_fast_cgetfield:
3108     __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
3109     break;
3110   case Bytecodes::_fast_fgetfield:
3111     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3112     break;
3113   case Bytecodes::_fast_dgetfield:
3114     __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* dtos */, field, noreg, noreg);
3115     break;
3116   default:
3117     ShouldNotReachHere();
3118   }
3119   {
3120     Label notVolatile;
3121     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3122     __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
3123     __ bind(notVolatile);
3124   }
3125 }
3126 
3127 void TemplateTable::fast_xaccess(TosState state)
3128 {
3129   transition(vtos, state);
3130 
3131   // get receiver
3132   __ ldr(r0, aaddress(0));
3133   // access constant pool cache
3134   __ get_cache_and_index_at_bcp(r2, r3, 2);
3135   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3136                                   ConstantPoolCacheEntry::f2_offset())));
3137 
3138   // 8179954: We need to make sure that the code generated for
3139   // volatile accesses forms a sequentially-consistent set of
3140   // operations when combined with STLR and LDAR.  Without a leading
3141   // membar it&#39;s possible for a simple Dekker test to fail if loads
3142   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3143   // the stores in one method and we interpret the loads in another.
3144   if (! UseBarriersForVolatile) {
3145     Label notVolatile;
3146     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3147                                      ConstantPoolCacheEntry::flags_offset())));
3148     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3149     __ membar(MacroAssembler::AnyAny);
3150     __ bind(notVolatile);
3151   }
3152 
3153   // make sure exception is reported in correct bcp range (getfield is
3154   // next instruction)
3155   __ increment(rbcp);
3156   __ null_check(r0);
3157   switch (state) {
3158   case itos:
3159     __ access_load_at(T_INT, IN_HEAP, r0, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3160     break;
3161   case atos:
3162     do_oop_load(_masm, Address(r0, r1, Address::lsl(0)), r0, IN_HEAP);
3163     __ verify_oop(r0);
3164     break;
3165   case ftos:
3166     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3167     break;
3168   default:
3169     ShouldNotReachHere();
3170   }
3171 
3172   {
3173     Label notVolatile;
3174     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3175                                      ConstantPoolCacheEntry::flags_offset())));
3176     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3177     __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
3178     __ bind(notVolatile);
3179   }
3180 
3181   __ decrement(rbcp);
3182 }
3183 
3184 
3185 
3186 //-----------------------------------------------------------------------------
3187 // Calls
3188 
3189 void TemplateTable::count_calls(Register method, Register temp)
3190 {
3191   __ call_Unimplemented();
3192 }
3193 
3194 void TemplateTable::prepare_invoke(int byte_no,
3195                                    Register method, // linked method (or i-klass)
3196                                    Register index,  // itable index, MethodType, etc.
3197                                    Register recv,   // if caller wants to see it
3198                                    Register flags   // if caller wants to test it
3199                                    ) {
3200   // determine flags
3201   Bytecodes::Code code = bytecode();
3202   const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;
3203   const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;
3204   const bool is_invokehandle     = code == Bytecodes::_invokehandle;
3205   const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;
3206   const bool is_invokespecial    = code == Bytecodes::_invokespecial;
3207   const bool load_receiver       = (recv  != noreg);
3208   const bool save_flags          = (flags != noreg);
3209   assert(load_receiver == (code != Bytecodes::_invokestatic &amp;&amp; code != Bytecodes::_invokedynamic), &quot;&quot;);
3210   assert(save_flags    == (is_invokeinterface || is_invokevirtual), &quot;need flags for vfinal&quot;);
3211   assert(flags == noreg || flags == r3, &quot;&quot;);
3212   assert(recv  == noreg || recv  == r2, &quot;&quot;);
3213 
3214   // setup registers &amp; access constant pool cache
3215   if (recv  == noreg)  recv  = r2;
3216   if (flags == noreg)  flags = r3;
3217   assert_different_registers(method, index, recv, flags);
3218 
3219   // save &#39;interpreter return address&#39;
3220   __ save_bcp();
3221 
3222   load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, false, is_invokedynamic);
3223 
3224   // maybe push appendix to arguments (just before return address)
3225   if (is_invokedynamic || is_invokehandle) {
3226     Label L_no_push;
3227     __ tbz(flags, ConstantPoolCacheEntry::has_appendix_shift, L_no_push);
3228     // Push the appendix as a trailing parameter.
3229     // This must be done before we get the receiver,
3230     // since the parameter_size includes it.
3231     __ push(r19);
3232     __ mov(r19, index);
3233     __ load_resolved_reference_at_index(index, r19);
3234     __ pop(r19);
3235     __ push(index);  // push appendix (MethodType, CallSite, etc.)
3236     __ bind(L_no_push);
3237   }
3238 
3239   // load receiver if needed (note: no return address pushed yet)
3240   if (load_receiver) {
3241     __ andw(recv, flags, ConstantPoolCacheEntry::parameter_size_mask);
3242     // FIXME -- is this actually correct? looks like it should be 2
3243     // const int no_return_pc_pushed_yet = -1;  // argument slot correction before we push return address
3244     // const int receiver_is_at_end      = -1;  // back off one slot to get receiver
3245     // Address recv_addr = __ argument_address(recv, no_return_pc_pushed_yet + receiver_is_at_end);
3246     // __ movptr(recv, recv_addr);
3247     __ add(rscratch1, esp, recv, ext::uxtx, 3); // FIXME: uxtb here?
3248     __ ldr(recv, Address(rscratch1, -Interpreter::expr_offset_in_bytes(1)));
3249     __ verify_oop(recv);
3250   }
3251 
3252   // compute return type
3253   // x86 uses a shift and mask or wings it with a shift plus assert
3254   // the mask is not needed. aarch64 just uses bitfield extract
3255   __ ubfxw(rscratch2, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);
3256   // load return address
3257   {
3258     const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);
3259     __ mov(rscratch1, table_addr);
3260     __ ldr(lr, Address(rscratch1, rscratch2, Address::lsl(3)));
3261   }
3262 }
3263 
3264 
3265 void TemplateTable::invokevirtual_helper(Register index,
3266                                          Register recv,
3267                                          Register flags)
3268 {
3269   // Uses temporary registers r0, r3
3270   assert_different_registers(index, recv, r0, r3);
3271   // Test for an invoke of a final method
3272   Label notFinal;
3273   __ tbz(flags, ConstantPoolCacheEntry::is_vfinal_shift, notFinal);
3274 
3275   const Register method = index;  // method must be rmethod
3276   assert(method == rmethod,
3277          &quot;methodOop must be rmethod for interpreter calling convention&quot;);
3278 
3279   // do the call - the index is actually the method to call
3280   // that is, f2 is a vtable index if !is_vfinal, else f2 is a Method*
3281 
3282   // It&#39;s final, need a null check here!
3283   __ null_check(recv);
3284 
3285   // profile this call
3286   __ profile_final_call(r0);
3287   __ profile_arguments_type(r0, method, r4, true);
3288 
3289   __ jump_from_interpreted(method, r0);
3290 
3291   __ bind(notFinal);
3292 
3293   // get receiver klass
3294   __ null_check(recv, oopDesc::klass_offset_in_bytes());
3295   __ load_klass(r0, recv);
3296 
3297   // profile this call
3298   __ profile_virtual_call(r0, rlocals, r3);
3299 
3300   // get target methodOop &amp; entry point
3301   __ lookup_virtual_method(r0, index, method);
3302   __ profile_arguments_type(r3, method, r4, true);
3303   // FIXME -- this looks completely redundant. is it?
3304   // __ ldr(r3, Address(method, Method::interpreter_entry_offset()));
3305   __ jump_from_interpreted(method, r3);
3306 }
3307 
3308 void TemplateTable::invokevirtual(int byte_no)
3309 {
3310   transition(vtos, vtos);
3311   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3312 
3313   prepare_invoke(byte_no, rmethod, noreg, r2, r3);
3314 
3315   // rmethod: index (actually a Method*)
3316   // r2: receiver
3317   // r3: flags
3318 
3319   invokevirtual_helper(rmethod, r2, r3);
3320 }
3321 
3322 void TemplateTable::invokespecial(int byte_no)
3323 {
3324   transition(vtos, vtos);
3325   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3326 
3327   prepare_invoke(byte_no, rmethod, noreg,  // get f1 Method*
3328                  r2);  // get receiver also for null check
3329   __ verify_oop(r2);
3330   __ null_check(r2);
3331   // do the call
3332   __ profile_call(r0);
3333   __ profile_arguments_type(r0, rmethod, rbcp, false);
3334   __ jump_from_interpreted(rmethod, r0);
3335 }
3336 
3337 void TemplateTable::invokestatic(int byte_no)
3338 {
3339   transition(vtos, vtos);
3340   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3341 
3342   prepare_invoke(byte_no, rmethod);  // get f1 Method*
3343   // do the call
3344   __ profile_call(r0);
3345   __ profile_arguments_type(r0, rmethod, r4, false);
3346   __ jump_from_interpreted(rmethod, r0);
3347 }
3348 
3349 void TemplateTable::fast_invokevfinal(int byte_no)
3350 {
3351   __ call_Unimplemented();
3352 }
3353 
3354 void TemplateTable::invokeinterface(int byte_no) {
3355   transition(vtos, vtos);
3356   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3357 
3358   prepare_invoke(byte_no, r0, rmethod,  // get f1 Klass*, f2 Method*
3359                  r2, r3); // recv, flags
3360 
3361   // r0: interface klass (from f1)
3362   // rmethod: method (from f2)
3363   // r2: receiver
3364   // r3: flags
3365 
3366   // First check for Object case, then private interface method,
3367   // then regular interface method.
3368 
3369   // Special case of invokeinterface called for virtual method of
3370   // java.lang.Object.  See cpCache.cpp for details.
3371   Label notObjectMethod;
3372   __ tbz(r3, ConstantPoolCacheEntry::is_forced_virtual_shift, notObjectMethod);
3373 
3374   invokevirtual_helper(rmethod, r2, r3);
3375   __ bind(notObjectMethod);
3376 
3377   Label no_such_interface;
3378 
3379   // Check for private method invocation - indicated by vfinal
3380   Label notVFinal;
3381   __ tbz(r3, ConstantPoolCacheEntry::is_vfinal_shift, notVFinal);
3382 
3383   // Get receiver klass into r3 - also a null check
3384   __ null_check(r2, oopDesc::klass_offset_in_bytes());
3385   __ load_klass(r3, r2);
3386 
3387   Label subtype;
3388   __ check_klass_subtype(r3, r0, r4, subtype);
3389   // If we get here the typecheck failed
3390   __ b(no_such_interface);
3391   __ bind(subtype);
3392 
3393   __ profile_final_call(r0);
3394   __ profile_arguments_type(r0, rmethod, r4, true);
3395   __ jump_from_interpreted(rmethod, r0);
3396 
3397   __ bind(notVFinal);
3398 
3399   // Get receiver klass into r3 - also a null check
3400   __ restore_locals();
3401   __ null_check(r2, oopDesc::klass_offset_in_bytes());
3402   __ load_klass(r3, r2);
3403 
3404   Label no_such_method;
3405 
3406   // Preserve method for throw_AbstractMethodErrorVerbose.
3407   __ mov(r16, rmethod);
3408   // Receiver subtype check against REFC.
3409   // Superklass in r0. Subklass in r3. Blows rscratch2, r13
3410   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3411                              r3, r0, noreg,
3412                              // outputs: scan temp. reg, scan temp. reg
3413                              rscratch2, r13,
3414                              no_such_interface,
3415                              /*return_method=*/false);
3416 
3417   // profile this call
3418   __ profile_virtual_call(r3, r13, r19);
3419 
3420   // Get declaring interface class from method, and itable index
<a name="13" id="anc13"></a><span class="line-modified">3421   __ ldr(r0, Address(rmethod, Method::const_offset()));</span>
<span class="line-modified">3422   __ ldr(r0, Address(r0, ConstMethod::constants_offset()));</span>
<span class="line-removed">3423   __ ldr(r0, Address(r0, ConstantPool::pool_holder_offset_in_bytes()));</span>
3424   __ ldrw(rmethod, Address(rmethod, Method::itable_index_offset()));
3425   __ subw(rmethod, rmethod, Method::itable_index_max);
3426   __ negw(rmethod, rmethod);
3427 
3428   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
3429   __ mov(rlocals, r3);
3430   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3431                              rlocals, r0, rmethod,
3432                              // outputs: method, scan temp. reg
3433                              rmethod, r13,
3434                              no_such_interface);
3435 
3436   // rmethod,: methodOop to call
3437   // r2: receiver
3438   // Check for abstract method error
3439   // Note: This should be done more efficiently via a throw_abstract_method_error
3440   //       interpreter entry point and a conditional jump to it in case of a null
3441   //       method.
3442   __ cbz(rmethod, no_such_method);
3443 
3444   __ profile_arguments_type(r3, rmethod, r13, true);
3445 
3446   // do the call
3447   // r2: receiver
3448   // rmethod,: methodOop
3449   __ jump_from_interpreted(rmethod, r3);
3450   __ should_not_reach_here();
3451 
3452   // exception handling code follows...
3453   // note: must restore interpreter registers to canonical
3454   //       state for exception handling to work correctly!
3455 
3456   __ bind(no_such_method);
3457   // throw exception
3458   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
3459   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3460   // Pass arguments for generating a verbose error message.
3461   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_AbstractMethodErrorVerbose), r3, r16);
3462   // the call_VM checks for exception, so we should never return here.
3463   __ should_not_reach_here();
3464 
3465   __ bind(no_such_interface);
3466   // throw exception
3467   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
3468   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3469   // Pass arguments for generating a verbose error message.
3470   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
3471                    InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose), r3, r0);
3472   // the call_VM checks for exception, so we should never return here.
3473   __ should_not_reach_here();
3474   return;
3475 }
3476 
3477 void TemplateTable::invokehandle(int byte_no) {
3478   transition(vtos, vtos);
3479   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3480 
3481   prepare_invoke(byte_no, rmethod, r0, r2);
3482   __ verify_method_ptr(r2);
3483   __ verify_oop(r2);
3484   __ null_check(r2);
3485 
3486   // FIXME: profile the LambdaForm also
3487 
3488   // r13 is safe to use here as a scratch reg because it is about to
3489   // be clobbered by jump_from_interpreted().
3490   __ profile_final_call(r13);
3491   __ profile_arguments_type(r13, rmethod, r4, true);
3492 
3493   __ jump_from_interpreted(rmethod, r0);
3494 }
3495 
3496 void TemplateTable::invokedynamic(int byte_no) {
3497   transition(vtos, vtos);
3498   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3499 
3500   prepare_invoke(byte_no, rmethod, r0);
3501 
3502   // r0: CallSite object (from cpool-&gt;resolved_references[])
3503   // rmethod: MH.linkToCallSite method (from f2)
3504 
3505   // Note:  r0_callsite is already pushed by prepare_invoke
3506 
3507   // %%% should make a type profile for any invokedynamic that takes a ref argument
3508   // profile this call
3509   __ profile_call(rbcp);
3510   __ profile_arguments_type(r3, rmethod, r13, false);
3511 
3512   __ verify_oop(r0);
3513 
3514   __ jump_from_interpreted(rmethod, r0);
3515 }
3516 
3517 
3518 //-----------------------------------------------------------------------------
3519 // Allocation
3520 
3521 void TemplateTable::_new() {
3522   transition(vtos, atos);
3523 
3524   __ get_unsigned_2_byte_index_at_bcp(r3, 1);
3525   Label slow_case;
3526   Label done;
3527   Label initialize_header;
3528   Label initialize_object; // including clearing the fields
3529 
3530   __ get_cpool_and_tags(r4, r0);
3531   // Make sure the class we&#39;re about to instantiate has been resolved.
3532   // This is done before loading InstanceKlass to be consistent with the order
3533   // how Constant Pool is updated (see ConstantPool::klass_at_put)
3534   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
3535   __ lea(rscratch1, Address(r0, r3, Address::lsl(0)));
3536   __ lea(rscratch1, Address(rscratch1, tags_offset));
3537   __ ldarb(rscratch1, rscratch1);
3538   __ cmp(rscratch1, (u1)JVM_CONSTANT_Class);
3539   __ br(Assembler::NE, slow_case);
3540 
3541   // get InstanceKlass
3542   __ load_resolved_klass_at_offset(r4, r3, r4, rscratch1);
3543 
3544   // make sure klass is initialized &amp; doesn&#39;t have finalizer
3545   // make sure klass is fully initialized
3546   __ ldrb(rscratch1, Address(r4, InstanceKlass::init_state_offset()));
3547   __ cmp(rscratch1, (u1)InstanceKlass::fully_initialized);
3548   __ br(Assembler::NE, slow_case);
3549 
3550   // get instance_size in InstanceKlass (scaled to a count of bytes)
3551   __ ldrw(r3,
3552           Address(r4,
3553                   Klass::layout_helper_offset()));
3554   // test to see if it has a finalizer or is malformed in some way
3555   __ tbnz(r3, exact_log2(Klass::_lh_instance_slow_path_bit), slow_case);
3556 
3557   // Allocate the instance:
3558   //  If TLAB is enabled:
3559   //    Try to allocate in the TLAB.
3560   //    If fails, go to the slow path.
3561   //  Else If inline contiguous allocations are enabled:
3562   //    Try to allocate in eden.
3563   //    If fails due to heap end, go to slow path.
3564   //
3565   //  If TLAB is enabled OR inline contiguous is enabled:
3566   //    Initialize the allocation.
3567   //    Exit.
3568   //
3569   //  Go to slow path.
3570   const bool allow_shared_alloc =
3571     Universe::heap()-&gt;supports_inline_contig_alloc();
3572 
3573   if (UseTLAB) {
3574     __ tlab_allocate(r0, r3, 0, noreg, r1, slow_case);
3575 
3576     if (ZeroTLAB) {
3577       // the fields have been already cleared
3578       __ b(initialize_header);
3579     } else {
3580       // initialize both the header and fields
3581       __ b(initialize_object);
3582     }
3583   } else {
3584     // Allocation in the shared Eden, if allowed.
3585     //
3586     // r3: instance size in bytes
3587     if (allow_shared_alloc) {
3588       __ eden_allocate(r0, r3, 0, r10, slow_case);
3589     }
3590   }
3591 
3592   // If UseTLAB or allow_shared_alloc are true, the object is created above and
3593   // there is an initialize need. Otherwise, skip and go to the slow path.
3594   if (UseTLAB || allow_shared_alloc) {
3595     // The object is initialized before the header.  If the object size is
3596     // zero, go directly to the header initialization.
3597     __ bind(initialize_object);
3598     __ sub(r3, r3, sizeof(oopDesc));
3599     __ cbz(r3, initialize_header);
3600 
3601     // Initialize object fields
3602     {
3603       __ add(r2, r0, sizeof(oopDesc));
3604       Label loop;
3605       __ bind(loop);
3606       __ str(zr, Address(__ post(r2, BytesPerLong)));
3607       __ sub(r3, r3, BytesPerLong);
3608       __ cbnz(r3, loop);
3609     }
3610 
3611     // initialize object header only.
3612     __ bind(initialize_header);
3613     if (UseBiasedLocking) {
3614       __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));
3615     } else {
<a name="14" id="anc14"></a><span class="line-modified">3616       __ mov(rscratch1, (intptr_t)markOopDesc::prototype());</span>
3617     }
3618     __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));
3619     __ store_klass_gap(r0, zr);  // zero klass gap for compressed oops
3620     __ store_klass(r0, r4);      // store klass last
3621 
3622     {
3623       SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false);
3624       // Trigger dtrace event for fastpath
3625       __ push(atos); // save the return value
3626       __ call_VM_leaf(
3627            CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), r0);
3628       __ pop(atos); // restore the return value
3629 
3630     }
3631     __ b(done);
3632   }
3633 
3634   // slow case
3635   __ bind(slow_case);
3636   __ get_constant_pool(c_rarg1);
3637   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3638   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);
3639   __ verify_oop(r0);
3640 
3641   // continue
3642   __ bind(done);
3643   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3644   __ membar(Assembler::StoreStore);
3645 }
3646 
3647 void TemplateTable::newarray() {
3648   transition(itos, atos);
3649   __ load_unsigned_byte(c_rarg1, at_bcp(1));
3650   __ mov(c_rarg2, r0);
3651   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
3652           c_rarg1, c_rarg2);
3653   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3654   __ membar(Assembler::StoreStore);
3655 }
3656 
3657 void TemplateTable::anewarray() {
3658   transition(itos, atos);
3659   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3660   __ get_constant_pool(c_rarg1);
3661   __ mov(c_rarg3, r0);
3662   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
3663           c_rarg1, c_rarg2, c_rarg3);
3664   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3665   __ membar(Assembler::StoreStore);
3666 }
3667 
3668 void TemplateTable::arraylength() {
3669   transition(atos, itos);
3670   __ null_check(r0, arrayOopDesc::length_offset_in_bytes());
3671   __ ldrw(r0, Address(r0, arrayOopDesc::length_offset_in_bytes()));
3672 }
3673 
3674 void TemplateTable::checkcast()
3675 {
3676   transition(atos, atos);
3677   Label done, is_null, ok_is_subtype, quicked, resolved;
3678   __ cbz(r0, is_null);
3679 
3680   // Get cpool &amp; tags index
3681   __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
3682   __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
3683   // See if bytecode has already been quicked
3684   __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
3685   __ lea(r1, Address(rscratch1, r19));
3686   __ ldarb(r1, r1);
3687   __ cmp(r1, (u1)JVM_CONSTANT_Class);
3688   __ br(Assembler::EQ, quicked);
3689 
3690   __ push(atos); // save receiver for result, and for GC
3691   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3692   // vm_result_2 has metadata result
3693   __ get_vm_result_2(r0, rthread);
3694   __ pop(r3); // restore receiver
3695   __ b(resolved);
3696 
3697   // Get superklass in r0 and subklass in r3
3698   __ bind(quicked);
3699   __ mov(r3, r0); // Save object in r3; r0 needed for subtype check
3700   __ load_resolved_klass_at_offset(r2, r19, r0, rscratch1); // r0 = klass
3701 
3702   __ bind(resolved);
3703   __ load_klass(r19, r3);
3704 
3705   // Generate subtype check.  Blows r2, r5.  Object in r3.
3706   // Superklass in r0.  Subklass in r19.
3707   __ gen_subtype_check(r19, ok_is_subtype);
3708 
3709   // Come here on failure
3710   __ push(r3);
3711   // object is at TOS
3712   __ b(Interpreter::_throw_ClassCastException_entry);
3713 
3714   // Come here on success
3715   __ bind(ok_is_subtype);
3716   __ mov(r0, r3); // Restore object in r3
3717 
3718   // Collect counts on whether this test sees NULLs a lot or not.
3719   if (ProfileInterpreter) {
3720     __ b(done);
3721     __ bind(is_null);
3722     __ profile_null_seen(r2);
3723   } else {
3724     __ bind(is_null);   // same as &#39;done&#39;
3725   }
3726   __ bind(done);
3727 }
3728 
3729 void TemplateTable::instanceof() {
3730   transition(atos, itos);
3731   Label done, is_null, ok_is_subtype, quicked, resolved;
3732   __ cbz(r0, is_null);
3733 
3734   // Get cpool &amp; tags index
3735   __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
3736   __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
3737   // See if bytecode has already been quicked
3738   __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
3739   __ lea(r1, Address(rscratch1, r19));
3740   __ ldarb(r1, r1);
3741   __ cmp(r1, (u1)JVM_CONSTANT_Class);
3742   __ br(Assembler::EQ, quicked);
3743 
3744   __ push(atos); // save receiver for result, and for GC
3745   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3746   // vm_result_2 has metadata result
3747   __ get_vm_result_2(r0, rthread);
3748   __ pop(r3); // restore receiver
3749   __ verify_oop(r3);
3750   __ load_klass(r3, r3);
3751   __ b(resolved);
3752 
3753   // Get superklass in r0 and subklass in r3
3754   __ bind(quicked);
3755   __ load_klass(r3, r0);
3756   __ load_resolved_klass_at_offset(r2, r19, r0, rscratch1);
3757 
3758   __ bind(resolved);
3759 
3760   // Generate subtype check.  Blows r2, r5
3761   // Superklass in r0.  Subklass in r3.
3762   __ gen_subtype_check(r3, ok_is_subtype);
3763 
3764   // Come here on failure
3765   __ mov(r0, 0);
3766   __ b(done);
3767   // Come here on success
3768   __ bind(ok_is_subtype);
3769   __ mov(r0, 1);
3770 
3771   // Collect counts on whether this test sees NULLs a lot or not.
3772   if (ProfileInterpreter) {
3773     __ b(done);
3774     __ bind(is_null);
3775     __ profile_null_seen(r2);
3776   } else {
3777     __ bind(is_null);   // same as &#39;done&#39;
3778   }
3779   __ bind(done);
3780   // r0 = 0: obj == NULL or  obj is not an instanceof the specified klass
3781   // r0 = 1: obj != NULL and obj is     an instanceof the specified klass
3782 }
3783 
3784 //-----------------------------------------------------------------------------
3785 // Breakpoints
3786 void TemplateTable::_breakpoint() {
3787   // Note: We get here even if we are single stepping..
3788   // jbug inists on setting breakpoints at every bytecode
3789   // even if we are in single step mode.
3790 
3791   transition(vtos, vtos);
3792 
3793   // get the unpatched byte code
3794   __ get_method(c_rarg1);
3795   __ call_VM(noreg,
3796              CAST_FROM_FN_PTR(address,
3797                               InterpreterRuntime::get_original_bytecode_at),
3798              c_rarg1, rbcp);
3799   __ mov(r19, r0);
3800 
3801   // post the breakpoint event
3802   __ call_VM(noreg,
3803              CAST_FROM_FN_PTR(address, InterpreterRuntime::_breakpoint),
3804              rmethod, rbcp);
3805 
3806   // complete the execution of original bytecode
3807   __ mov(rscratch1, r19);
3808   __ dispatch_only_normal(vtos);
3809 }
3810 
3811 //-----------------------------------------------------------------------------
3812 // Exceptions
3813 
3814 void TemplateTable::athrow() {
3815   transition(atos, vtos);
3816   __ null_check(r0);
3817   __ b(Interpreter::throw_exception_entry());
3818 }
3819 
3820 //-----------------------------------------------------------------------------
3821 // Synchronization
3822 //
3823 // Note: monitorenter &amp; exit are symmetric routines; which is reflected
3824 //       in the assembly code structure as well
3825 //
3826 // Stack layout:
3827 //
3828 // [expressions  ] &lt;--- esp               = expression stack top
3829 // ..
3830 // [expressions  ]
3831 // [monitor entry] &lt;--- monitor block top = expression stack bot
3832 // ..
3833 // [monitor entry]
3834 // [frame data   ] &lt;--- monitor block bot
3835 // ...
3836 // [saved rbp    ] &lt;--- rbp
3837 void TemplateTable::monitorenter()
3838 {
3839   transition(atos, vtos);
3840 
3841   // check for NULL object
3842   __ null_check(r0);
3843 
3844   __ resolve(IS_NOT_NULL, r0);
3845 
3846   const Address monitor_block_top(
3847         rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
3848   const Address monitor_block_bot(
3849         rfp, frame::interpreter_frame_initial_sp_offset * wordSize);
3850   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
3851 
3852   Label allocated;
3853 
3854   // initialize entry pointer
3855   __ mov(c_rarg1, zr); // points to free slot or NULL
3856 
3857   // find a free slot in the monitor block (result in c_rarg1)
3858   {
3859     Label entry, loop, exit;
3860     __ ldr(c_rarg3, monitor_block_top); // points to current entry,
3861                                         // starting with top-most entry
3862     __ lea(c_rarg2, monitor_block_bot); // points to word before bottom
3863 
3864     __ b(entry);
3865 
3866     __ bind(loop);
3867     // check if current entry is used
3868     // if not used then remember entry in c_rarg1
3869     __ ldr(rscratch1, Address(c_rarg3, BasicObjectLock::obj_offset_in_bytes()));
3870     __ cmp(zr, rscratch1);
3871     __ csel(c_rarg1, c_rarg3, c_rarg1, Assembler::EQ);
3872     // check if current entry is for same object
3873     __ cmp(r0, rscratch1);
3874     // if same object then stop searching
3875     __ br(Assembler::EQ, exit);
3876     // otherwise advance to next entry
3877     __ add(c_rarg3, c_rarg3, entry_size);
3878     __ bind(entry);
3879     // check if bottom reached
3880     __ cmp(c_rarg3, c_rarg2);
3881     // if not at bottom then check this entry
3882     __ br(Assembler::NE, loop);
3883     __ bind(exit);
3884   }
3885 
3886   __ cbnz(c_rarg1, allocated); // check if a slot has been found and
3887                             // if found, continue with that on
3888 
3889   // allocate one if there&#39;s no free slot
3890   {
3891     Label entry, loop;
3892     // 1. compute new pointers            // rsp: old expression stack top
3893     __ ldr(c_rarg1, monitor_block_bot);   // c_rarg1: old expression stack bottom
3894     __ sub(esp, esp, entry_size);         // move expression stack top
3895     __ sub(c_rarg1, c_rarg1, entry_size); // move expression stack bottom
3896     __ mov(c_rarg3, esp);                 // set start value for copy loop
3897     __ str(c_rarg1, monitor_block_bot);   // set new monitor block bottom
3898 
3899     __ sub(sp, sp, entry_size);           // make room for the monitor
3900 
3901     __ b(entry);
3902     // 2. move expression stack contents
3903     __ bind(loop);
3904     __ ldr(c_rarg2, Address(c_rarg3, entry_size)); // load expression stack
3905                                                    // word from old location
3906     __ str(c_rarg2, Address(c_rarg3, 0));          // and store it at new location
3907     __ add(c_rarg3, c_rarg3, wordSize);            // advance to next word
3908     __ bind(entry);
3909     __ cmp(c_rarg3, c_rarg1);        // check if bottom reached
3910     __ br(Assembler::NE, loop);      // if not at bottom then
3911                                      // copy next word
3912   }
3913 
3914   // call run-time routine
3915   // c_rarg1: points to monitor entry
3916   __ bind(allocated);
3917 
3918   // Increment bcp to point to the next bytecode, so exception
3919   // handling for async. exceptions work correctly.
3920   // The object has already been poped from the stack, so the
3921   // expression stack looks correct.
3922   __ increment(rbcp);
3923 
3924   // store object
3925   __ str(r0, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));
3926   __ lock_object(c_rarg1);
3927 
3928   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
3929   __ save_bcp();  // in case of exception
3930   __ generate_stack_overflow_check(0);
3931 
3932   // The bcp has already been incremented. Just need to dispatch to
3933   // next instruction.
3934   __ dispatch_next(vtos);
3935 }
3936 
3937 
3938 void TemplateTable::monitorexit()
3939 {
3940   transition(atos, vtos);
3941 
3942   // check for NULL object
3943   __ null_check(r0);
3944 
3945   __ resolve(IS_NOT_NULL, r0);
3946 
3947   const Address monitor_block_top(
3948         rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
3949   const Address monitor_block_bot(
3950         rfp, frame::interpreter_frame_initial_sp_offset * wordSize);
3951   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
3952 
3953   Label found;
3954 
3955   // find matching slot
3956   {
3957     Label entry, loop;
3958     __ ldr(c_rarg1, monitor_block_top); // points to current entry,
3959                                         // starting with top-most entry
3960     __ lea(c_rarg2, monitor_block_bot); // points to word before bottom
3961                                         // of monitor block
3962     __ b(entry);
3963 
3964     __ bind(loop);
3965     // check if current entry is for same object
3966     __ ldr(rscratch1, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));
3967     __ cmp(r0, rscratch1);
3968     // if same object then stop searching
3969     __ br(Assembler::EQ, found);
3970     // otherwise advance to next entry
3971     __ add(c_rarg1, c_rarg1, entry_size);
3972     __ bind(entry);
3973     // check if bottom reached
3974     __ cmp(c_rarg1, c_rarg2);
3975     // if not at bottom then check this entry
3976     __ br(Assembler::NE, loop);
3977   }
3978 
3979   // error handling. Unlocking was not block-structured
3980   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
3981                    InterpreterRuntime::throw_illegal_monitor_state_exception));
3982   __ should_not_reach_here();
3983 
3984   // call run-time routine
3985   __ bind(found);
3986   __ push_ptr(r0); // make sure object is on stack (contract with oopMaps)
3987   __ unlock_object(c_rarg1);
3988   __ pop_ptr(r0); // discard object
3989 }
3990 
3991 
3992 // Wide instructions
3993 void TemplateTable::wide()
3994 {
3995   __ load_unsigned_byte(r19, at_bcp(1));
3996   __ mov(rscratch1, (address)Interpreter::_wentry_point);
3997   __ ldr(rscratch1, Address(rscratch1, r19, Address::uxtw(3)));
3998   __ br(rscratch1);
3999 }
4000 
4001 
4002 // Multi arrays
4003 void TemplateTable::multianewarray() {
4004   transition(vtos, atos);
4005   __ load_unsigned_byte(r0, at_bcp(3)); // get number of dimensions
4006   // last dim is on top of stack; we want address of first one:
4007   // first_addr = last_addr + (ndims - 1) * wordSize
4008   __ lea(c_rarg1, Address(esp, r0, Address::uxtw(3)));
4009   __ sub(c_rarg1, c_rarg1, wordSize);
4010   call_VM(r0,
4011           CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray),
4012           c_rarg1);
4013   __ load_unsigned_byte(r1, at_bcp(3));
4014   __ lea(esp, Address(esp, r1, Address::uxtw(3)));
4015 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
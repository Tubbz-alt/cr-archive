<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/ad_encode.m4</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="abstractInterpreter_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/ad_encode.m4</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,6 ***</span>
<span class="line-modified">! dnl Copyright (c) 2014, Red Hat Inc. All rights reserved.</span>
  dnl DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  dnl
  dnl This code is free software; you can redistribute it and/or modify it
  dnl under the terms of the GNU General Public License version 2 only, as
  dnl published by the Free Software Foundation.
<span class="line-new-header">--- 1,6 ---</span>
<span class="line-modified">! dnl Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.</span>
  dnl DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  dnl
  dnl This code is free software; you can redistribute it and/or modify it
  dnl under the terms of the GNU General Public License version 2 only, as
  dnl published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,77 ***</span>
  dnl 
  dnl Process this file with m4 ad_encode.m4 to generate the load/store
  dnl patterns used in aarch64.ad.
  dnl
  define(choose, `loadStore($1, &amp;MacroAssembler::$3, $2, $4,
<span class="line-modified">!                $5, $6, $7, $8);dnl</span>
  
    %}&#39;)dnl
  define(access, `
      $3Register $1_reg = as_$3Register($$1$$reg);
      $4choose(MacroAssembler(&amp;cbuf), $1_reg,$2,$mem-&gt;opcode(),
<span class="line-modified">!         as_Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp)&#39;)dnl</span>
  define(load,`
<span class="line-modified">!   enc_class aarch64_enc_$2($1 dst, memory mem) %{dnl</span>
<span class="line-modified">! access(dst,$2,$3)&#39;)dnl</span>
<span class="line-modified">! load(iRegI,ldrsbw)</span>
<span class="line-modified">! load(iRegI,ldrsb)</span>
<span class="line-modified">! load(iRegI,ldrb)</span>
<span class="line-modified">! load(iRegL,ldrb)</span>
<span class="line-modified">! load(iRegI,ldrshw)</span>
<span class="line-modified">! load(iRegI,ldrsh)</span>
<span class="line-modified">! load(iRegI,ldrh)</span>
<span class="line-modified">! load(iRegL,ldrh)</span>
<span class="line-modified">! load(iRegI,ldrw)</span>
<span class="line-modified">! load(iRegL,ldrw)</span>
<span class="line-modified">! load(iRegL,ldrsw)</span>
<span class="line-modified">! load(iRegL,ldr)</span>
<span class="line-modified">! load(vRegF,ldrs,Float)</span>
<span class="line-modified">! load(vRegD,ldrd,Float)</span>
  define(STORE,`
<span class="line-modified">!   enc_class aarch64_enc_$2($1 src, memory mem) %{dnl</span>
<span class="line-modified">! access(src,$2,$3,$4)&#39;)dnl</span>
  define(STORE0,`
<span class="line-modified">!   enc_class aarch64_enc_$2`&#39;0(memory mem) %{</span>
      MacroAssembler _masm(&amp;cbuf);
      choose(_masm,zr,$2,$mem-&gt;opcode(),
<span class="line-modified">!         as_$3Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp)&#39;)dnl</span>
<span class="line-modified">! STORE(iRegI,strb)</span>
<span class="line-modified">! STORE0(iRegI,strb)</span>
<span class="line-modified">! STORE(iRegI,strh)</span>
<span class="line-modified">! STORE0(iRegI,strh)</span>
<span class="line-modified">! STORE(iRegI,strw)</span>
<span class="line-modified">! STORE0(iRegI,strw)</span>
  STORE(iRegL,str,,
  `// we sometimes get asked to store the stack pointer into the
      // current thread -- we cannot do that directly on AArch64
      if (src_reg == r31_sp) {
        MacroAssembler _masm(&amp;cbuf);
        assert(as_Register($mem$$base) == rthread, &quot;unexpected store for sp&quot;);
        __ mov(rscratch2, sp);
        src_reg = rscratch2;
      }
<span class="line-modified">!     &#39;)</span>
<span class="line-modified">! STORE0(iRegL,str)</span>
<span class="line-modified">! STORE(vRegF,strs,Float)</span>
<span class="line-modified">! STORE(vRegD,strd,Float)</span>
  
<span class="line-modified">!   enc_class aarch64_enc_strw_immn(immN src, memory mem) %{</span>
      MacroAssembler _masm(&amp;cbuf);
      address con = (address)$src$$constant;
      // need to do this the hard way until we can manage relocs
      // for 32 bit constants
      __ movoop(rscratch2, (jobject)con);
      if (con) __ encode_heap_oop_not_null(rscratch2);
      choose(_masm,rscratch2,strw,$mem-&gt;opcode(),
<span class="line-modified">!         as_Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp)</span>
  
<span class="line-modified">!   enc_class aarch64_enc_strw_immnk(immN src, memory mem) %{</span>
      MacroAssembler _masm(&amp;cbuf);
      address con = (address)$src$$constant;
      // need to do this the hard way until we can manage relocs
      // for 32 bit constants
      __ movoop(rscratch2, (jobject)con);
      __ encode_klass_not_null(rscratch2);
      choose(_masm,rscratch2,strw,$mem-&gt;opcode(),
<span class="line-modified">!         as_Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp)</span>
  
<span class="line-new-header">--- 22,96 ---</span>
  dnl 
  dnl Process this file with m4 ad_encode.m4 to generate the load/store
  dnl patterns used in aarch64.ad.
  dnl
  define(choose, `loadStore($1, &amp;MacroAssembler::$3, $2, $4,
<span class="line-modified">!                $5, $6, $7, $8, $9);dnl</span>
  
    %}&#39;)dnl
  define(access, `
      $3Register $1_reg = as_$3Register($$1$$reg);
      $4choose(MacroAssembler(&amp;cbuf), $1_reg,$2,$mem-&gt;opcode(),
<span class="line-modified">!         as_Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp,$5)&#39;)dnl</span>
  define(load,`
<span class="line-modified">!   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-modified">!   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-modified">!   enc_class aarch64_enc_$2($1 dst, memory$5 mem) %{dnl</span>
<span class="line-modified">! access(dst,$2,$3,$4,$5)&#39;)dnl</span>
<span class="line-modified">! load(iRegI,ldrsbw,,,1)</span>
<span class="line-modified">! load(iRegI,ldrsb,,,1)</span>
<span class="line-modified">! load(iRegI,ldrb,,,1)</span>
<span class="line-modified">! load(iRegL,ldrb,,,1)</span>
<span class="line-modified">! load(iRegI,ldrshw,,,2)</span>
<span class="line-modified">! load(iRegI,ldrsh,,,2)</span>
<span class="line-modified">! load(iRegI,ldrh,,,2)</span>
<span class="line-modified">! load(iRegL,ldrh,,,2)</span>
<span class="line-modified">! load(iRegI,ldrw,,,4)</span>
<span class="line-modified">! load(iRegL,ldrw,,,4)</span>
<span class="line-modified">! load(iRegL,ldrsw,,,4)</span>
<span class="line-modified">! load(iRegL,ldr,,,8)</span>
<span class="line-added">+ load(vRegF,ldrs,Float,,4)</span>
<span class="line-added">+ load(vRegD,ldrd,Float,,8)</span>
  define(STORE,`
<span class="line-modified">!   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-modified">!   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added">+   enc_class aarch64_enc_$2($1 src, memory$5 mem) %{dnl</span>
<span class="line-added">+ access(src,$2,$3,$4,$5)&#39;)dnl</span>
  define(STORE0,`
<span class="line-modified">!   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added">+   enc_class aarch64_enc_$2`&#39;0(memory$4 mem) %{</span>
      MacroAssembler _masm(&amp;cbuf);
      choose(_masm,zr,$2,$mem-&gt;opcode(),
<span class="line-modified">!         as_$3Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp,$4)&#39;)dnl</span>
<span class="line-modified">! STORE(iRegI,strb,,,1)</span>
<span class="line-modified">! STORE0(iRegI,strb,,1)</span>
<span class="line-modified">! STORE(iRegI,strh,,,2)</span>
<span class="line-modified">! STORE0(iRegI,strh,,2)</span>
<span class="line-modified">! STORE(iRegI,strw,,,4)</span>
<span class="line-modified">! STORE0(iRegI,strw,,4)</span>
  STORE(iRegL,str,,
  `// we sometimes get asked to store the stack pointer into the
      // current thread -- we cannot do that directly on AArch64
      if (src_reg == r31_sp) {
        MacroAssembler _masm(&amp;cbuf);
        assert(as_Register($mem$$base) == rthread, &quot;unexpected store for sp&quot;);
        __ mov(rscratch2, sp);
        src_reg = rscratch2;
      }
<span class="line-modified">!     &#39;,8)</span>
<span class="line-modified">! STORE0(iRegL,str,,8)</span>
<span class="line-modified">! STORE(vRegF,strs,Float,,4)</span>
<span class="line-modified">! STORE(vRegD,strd,Float,,8)</span>
  
<span class="line-modified">!   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added">+   enc_class aarch64_enc_strw_immn(immN src, memory1 mem) %{</span>
      MacroAssembler _masm(&amp;cbuf);
      address con = (address)$src$$constant;
      // need to do this the hard way until we can manage relocs
      // for 32 bit constants
      __ movoop(rscratch2, (jobject)con);
      if (con) __ encode_heap_oop_not_null(rscratch2);
      choose(_masm,rscratch2,strw,$mem-&gt;opcode(),
<span class="line-modified">!         as_Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp, 4)</span>
  
<span class="line-modified">!   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added">+   enc_class aarch64_enc_strw_immnk(immN src, memory4 mem) %{</span>
      MacroAssembler _masm(&amp;cbuf);
      address con = (address)$src$$constant;
      // need to do this the hard way until we can manage relocs
      // for 32 bit constants
      __ movoop(rscratch2, (jobject)con);
      __ encode_klass_not_null(rscratch2);
      choose(_masm,rscratch2,strw,$mem-&gt;opcode(),
<span class="line-modified">!         as_Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp, 4)</span>
<span class="line-added">+ </span>
<span class="line-added">+   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added">+   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added">+   enc_class aarch64_enc_strb0_ordered(memory4 mem) %{</span>
<span class="line-added">+       MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-added">+       __ membar(Assembler::StoreStore);</span>
<span class="line-added">+       loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),</span>
<span class="line-added">+                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
<span class="line-added">+   %}</span>
  
</pre>
<center><a href="abstractInterpreter_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
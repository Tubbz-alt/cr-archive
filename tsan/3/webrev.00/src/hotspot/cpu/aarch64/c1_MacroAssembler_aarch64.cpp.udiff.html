<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRGenerator_aarch64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Runtime1_aarch64.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -28,11 +28,11 @@</span>
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;oops/arrayOop.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;oops/markOop.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/markWord.hpp&quot;</span>
  #include &quot;runtime/basicLock.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -80,11 +80,11 @@</span>
    }
  
    // Load object header
    ldr(hdr, Address(obj, hdr_offset));
    // and mark it as unlocked
<span class="udiff-line-modified-removed">-   orr(hdr, hdr, markOopDesc::unlocked_value);</span>
<span class="udiff-line-modified-added">+   orr(hdr, hdr, markWord::unlocked_value);</span>
    // save unlocked object header into the displaced header location on the stack
    str(hdr, Address(disp_hdr, 0));
    // test if object header is still the same (i.e. unlocked), and if so, store the
    // displaced header address in the object header - if it is not the same, get the
    // object header instead
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -174,11 +174,11 @@</span>
    if (UseBiasedLocking &amp;&amp; !len-&gt;is_valid()) {
      assert_different_registers(obj, klass, len, t1, t2);
      ldr(t1, Address(klass, Klass::prototype_header_offset()));
    } else {
      // This assumes that all prototype bits fit in an int32_t
<span class="udiff-line-modified-removed">-     mov(t1, (int32_t)(intptr_t)markOopDesc::prototype());</span>
<span class="udiff-line-modified-added">+     mov(t1, (int32_t)(intptr_t)markWord::prototype().value());</span>
    }
    str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));
  
    if (UseCompressedClassPointers) { // Take care not to kill klass
      encode_klass_not_null(t1, klass);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -329,34 +329,28 @@</span>
    cmp_klass(receiver, iCache, rscratch1);
  }
  
  
  void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes) {
<span class="udiff-line-removed">-   // If we have to make this method not-entrant we&#39;ll overwrite its</span>
<span class="udiff-line-removed">-   // first instruction with a jump.  For this action to be legal we</span>
<span class="udiff-line-removed">-   // must ensure that this first instruction is a B, BL, NOP, BKPT,</span>
<span class="udiff-line-removed">-   // SVC, HVC, or SMC.  Make it a NOP.</span>
<span class="udiff-line-removed">-   nop();</span>
    assert(bang_size_in_bytes &gt;= framesize, &quot;stack bang size incorrect&quot;);
    // Make sure there is enough stack space for this method&#39;s activation.
    // Note that we do this before doing an enter().
    generate_stack_overflow_check(bang_size_in_bytes);
    MacroAssembler::build_frame(framesize + 2 * wordSize);
<span class="udiff-line-removed">-   if (NotifySimulator) {</span>
<span class="udiff-line-removed">-     notify(Assembler::method_entry);</span>
<span class="udiff-line-removed">-   }</span>
  }
  
  void C1_MacroAssembler::remove_frame(int framesize) {
    MacroAssembler::remove_frame(framesize + 2 * wordSize);
<span class="udiff-line-removed">-   if (NotifySimulator) {</span>
<span class="udiff-line-removed">-     notify(Assembler::method_reentry);</span>
<span class="udiff-line-removed">-   }</span>
  }
  
  
  void C1_MacroAssembler::verified_entry() {
<span class="udiff-line-added">+   // If we have to make this method not-entrant we&#39;ll overwrite its</span>
<span class="udiff-line-added">+   // first instruction with a jump.  For this action to be legal we</span>
<span class="udiff-line-added">+   // must ensure that this first instruction is a B, BL, NOP, BKPT,</span>
<span class="udiff-line-added">+   // SVC, HVC, or SMC.  Make it a NOP.</span>
<span class="udiff-line-added">+   nop();</span>
  }
  
  void C1_MacroAssembler::load_parameter(int offset_in_words, Register reg) {
    // rbp, + 0: link
    //     + 1: return address
</pre>
<center><a href="c1_LIRGenerator_aarch64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Runtime1_aarch64.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
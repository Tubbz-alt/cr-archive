<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="register_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;code/debugInfoRec.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/interp_masm.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;

  36 #include &quot;oops/compiledICHolder.hpp&quot;

  37 #include &quot;runtime/safepointMechanism.hpp&quot;
  38 #include &quot;runtime/sharedRuntime.hpp&quot;
  39 #include &quot;runtime/vframeArray.hpp&quot;
  40 #include &quot;utilities/align.hpp&quot;
  41 #include &quot;vmreg_aarch64.inline.hpp&quot;
  42 #ifdef COMPILER1
  43 #include &quot;c1/c1_Runtime1.hpp&quot;
  44 #endif
  45 #if COMPILER2_OR_JVMCI
  46 #include &quot;adfiles/ad_aarch64.hpp&quot;
  47 #include &quot;opto/runtime.hpp&quot;
  48 #endif
  49 #if INCLUDE_JVMCI
  50 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  51 #endif
  52 
<span class="line-removed">  53 #ifdef BUILTIN_SIM</span>
<span class="line-removed">  54 #include &quot;../../../../../../simulator/simulator.hpp&quot;</span>
<span class="line-removed">  55 #endif</span>
<span class="line-removed">  56 </span>
  57 #define __ masm-&gt;
  58 
  59 const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  60 
  61 class SimpleRuntimeFrame {
  62 
  63   public:
  64 
  65   // Most of the runtime stubs have this simple frame layout.
  66   // This class exists to make the layout shared in one place.
  67   // Offsets are for compiler stack slots, which are jints.
  68   enum layout {
  69     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
  70     // will override any oopMap setting for it. We must therefore force the layout
  71     // so that it agrees with the frame sender code.
  72     // we don&#39;t expect any arg reg save area so aarch64 asserts that
  73     // frame::arg_reg_save_area_bytes == 0
  74     rbp_off = 0,
  75     rbp_off2,
  76     return_off, return_off2,
</pre>
<hr />
<pre>
  85   static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);
  86 
  87   // Offsets into the register save area
  88   // Used by deoptimization when it is managing result register
  89   // values on its own
  90 
  91   static int r0_offset_in_bytes(void)    { return (32 + r0-&gt;encoding()) * wordSize; }
  92   static int reg_offset_in_bytes(Register r)    { return r0_offset_in_bytes() + r-&gt;encoding() * wordSize; }
  93   static int rmethod_offset_in_bytes(void)    { return reg_offset_in_bytes(rmethod); }
  94   static int rscratch1_offset_in_bytes(void)    { return (32 + rscratch1-&gt;encoding()) * wordSize; }
  95   static int v0_offset_in_bytes(void)   { return 0; }
  96   static int return_offset_in_bytes(void) { return (32 /* floats*/ + 31 /* gregs*/) * wordSize; }
  97 
  98   // During deoptimization only the result registers need to be restored,
  99   // all the other values have already been extracted.
 100   static void restore_result_registers(MacroAssembler* masm);
 101 
 102     // Capture info about frame layout
 103   enum layout {
 104                 fpu_state_off = 0,
<span class="line-modified"> 105                 fpu_state_end = fpu_state_off+FPUStateSizeInWords-1,</span>
 106                 // The frame sender code expects that rfp will be in
 107                 // the &quot;natural&quot; place and will override any oopMap
 108                 // setting for it. We must therefore force the layout
 109                 // so that it agrees with the frame sender code.
<span class="line-modified"> 110                 r0_off = fpu_state_off+FPUStateSizeInWords,</span>
<span class="line-modified"> 111                 rfp_off = r0_off + 30 * 2,</span>
<span class="line-modified"> 112                 return_off = rfp_off + 2,      // slot for return address</span>
<span class="line-modified"> 113                 reg_save_size = return_off + 2};</span>
 114 
 115 };
 116 
 117 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {
 118 #if COMPILER2_OR_JVMCI
 119   if (save_vectors) {
 120     // Save upper half of vector registers
<span class="line-modified"> 121     int vect_words = 32 * 8 / wordSize;</span>

 122     additional_frame_words += vect_words;
 123   }
 124 #else
 125   assert(!save_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 126 #endif
 127 
<span class="line-modified"> 128   int frame_size_in_bytes = align_up(additional_frame_words*wordSize +</span>
<span class="line-modified"> 129                                      reg_save_size*BytesPerInt, 16);</span>
 130   // OopMap frame size is in compiler stack slots (jint&#39;s) not bytes or words
 131   int frame_size_in_slots = frame_size_in_bytes / BytesPerInt;
 132   // The caller will allocate additional_frame_words
<span class="line-modified"> 133   int additional_frame_slots = additional_frame_words*wordSize / BytesPerInt;</span>
 134   // CodeBlob frame size is in words.
 135   int frame_size_in_words = frame_size_in_bytes / wordSize;
 136   *total_frame_words = frame_size_in_words;
 137 
<span class="line-modified"> 138   // Save registers, fpu state, and flags.</span>
<span class="line-removed"> 139 </span>
 140   __ enter();
 141   __ push_CPU_state(save_vectors);
 142 
 143   // Set an oopmap for the call site.  This oopmap will map all
 144   // oop-registers and debug-info registers as callee-saved.  This
 145   // will allow deoptimization at this safepoint to find all possible
 146   // debug-info recordings, as well as let GC find all oops.
 147 
 148   OopMapSet *oop_maps = new OopMapSet();
 149   OopMap* oop_map = new OopMap(frame_size_in_slots, 0);
 150 
 151   for (int i = 0; i &lt; RegisterImpl::number_of_registers; i++) {
 152     Register r = as_Register(i);
<span class="line-modified"> 153     if (r &lt; rheapbase &amp;&amp; r != rscratch1 &amp;&amp; r != rscratch2) {</span>
<span class="line-modified"> 154       int sp_offset = 2 * (i + 32); // SP offsets are in 4-byte words,</span>
<span class="line-modified"> 155                                     // register slots are 8 bytes</span>
<span class="line-modified"> 156                                     // wide, 32 floating-point</span>
<span class="line-modified"> 157                                     // registers</span>
 158       oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset + additional_frame_slots),
 159                                 r-&gt;as_VMReg());
 160     }
 161   }
 162 
 163   for (int i = 0; i &lt; FloatRegisterImpl::number_of_registers; i++) {
 164     FloatRegister r = as_FloatRegister(i);
<span class="line-modified"> 165     int sp_offset = save_vectors ? (4 * i) : (2 * i);</span>

 166     oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
 167                               r-&gt;as_VMReg());
 168   }
 169 
 170   return oop_map;
 171 }
 172 
 173 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {
 174 #ifndef COMPILER2
 175   assert(!restore_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 176 #endif
 177   __ pop_CPU_state(restore_vectors);
 178   __ leave();
 179 }
 180 
 181 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 182 
 183   // Just restore result register. Only used by deoptimization. By
 184   // now any callee save register that needs to be restored to a c2
 185   // caller of the deoptee has been extracted into the vframeArray
</pre>
<hr />
<pre>
 326 static void patch_callers_callsite(MacroAssembler *masm) {
 327   Label L;
 328   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 329   __ cbz(rscratch1, L);
 330 
 331   __ enter();
 332   __ push_CPU_state();
 333 
 334   // VM needs caller&#39;s callsite
 335   // VM needs target method
 336   // This needs to be a long call since we will relocate this adapter to
 337   // the codeBuffer and it may not reach
 338 
 339 #ifndef PRODUCT
 340   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 341 #endif
 342 
 343   __ mov(c_rarg0, rmethod);
 344   __ mov(c_rarg1, lr);
 345   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
<span class="line-modified"> 346   __ blrt(rscratch1, 2, 0, 0);</span>
 347   __ maybe_isb();
 348 
 349   __ pop_CPU_state();
 350   // restore sp
 351   __ leave();
 352   __ bind(L);
 353 }
 354 
 355 static void gen_c2i_adapter(MacroAssembler *masm,
 356                             int total_args_passed,
 357                             int comp_args_on_stack,
 358                             const BasicType *sig_bt,
 359                             const VMRegPair *regs,
 360                             Label&amp; skip_fixup) {
 361   // Before we get into the guts of the C2I adapter, see if we should be here
 362   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 363   // interpreter, which means the caller made a static call to get here
 364   // (vcalls always get a compiled target if there is one).  Check for a
 365   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 366   patch_callers_callsite(masm);
</pre>
<hr />
<pre>
 646         __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));
 647       }
 648     }
 649   }
 650 
 651   // 6243940 We might end up in handle_wrong_method if
 652   // the callee is deoptimized as we race thru here. If that
 653   // happens we don&#39;t want to take a safepoint because the
 654   // caller frame will look interpreted and arguments are now
 655   // &quot;compiled&quot; so it is much better to make this transition
 656   // invisible to the stack walking code. Unfortunately if
 657   // we try and find the callee by normal means a safepoint
 658   // is possible. So we stash the desired callee in the thread
 659   // and the vm will find there should this case occur.
 660 
 661   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));
 662 
 663   __ br(rscratch1);
 664 }
 665 
<span class="line-removed"> 666 #ifdef BUILTIN_SIM</span>
<span class="line-removed"> 667 static void generate_i2c_adapter_name(char *result, int total_args_passed, const BasicType *sig_bt)</span>
<span class="line-removed"> 668 {</span>
<span class="line-removed"> 669   strcpy(result, &quot;i2c(&quot;);</span>
<span class="line-removed"> 670   int idx = 4;</span>
<span class="line-removed"> 671   for (int i = 0; i &lt; total_args_passed; i++) {</span>
<span class="line-removed"> 672     switch(sig_bt[i]) {</span>
<span class="line-removed"> 673     case T_BOOLEAN:</span>
<span class="line-removed"> 674       result[idx++] = &#39;Z&#39;;</span>
<span class="line-removed"> 675       break;</span>
<span class="line-removed"> 676     case T_CHAR:</span>
<span class="line-removed"> 677       result[idx++] = &#39;C&#39;;</span>
<span class="line-removed"> 678       break;</span>
<span class="line-removed"> 679     case T_FLOAT:</span>
<span class="line-removed"> 680       result[idx++] = &#39;F&#39;;</span>
<span class="line-removed"> 681       break;</span>
<span class="line-removed"> 682     case T_DOUBLE:</span>
<span class="line-removed"> 683       assert((i &lt; (total_args_passed - 1)) &amp;&amp; (sig_bt[i+1] == T_VOID),</span>
<span class="line-removed"> 684              &quot;double must be followed by void&quot;);</span>
<span class="line-removed"> 685       i++;</span>
<span class="line-removed"> 686       result[idx++] = &#39;D&#39;;</span>
<span class="line-removed"> 687       break;</span>
<span class="line-removed"> 688     case T_BYTE:</span>
<span class="line-removed"> 689       result[idx++] = &#39;B&#39;;</span>
<span class="line-removed"> 690       break;</span>
<span class="line-removed"> 691     case T_SHORT:</span>
<span class="line-removed"> 692       result[idx++] = &#39;S&#39;;</span>
<span class="line-removed"> 693       break;</span>
<span class="line-removed"> 694     case T_INT:</span>
<span class="line-removed"> 695       result[idx++] = &#39;I&#39;;</span>
<span class="line-removed"> 696       break;</span>
<span class="line-removed"> 697     case T_LONG:</span>
<span class="line-removed"> 698       assert((i &lt; (total_args_passed - 1)) &amp;&amp; (sig_bt[i+1] == T_VOID),</span>
<span class="line-removed"> 699              &quot;long must be followed by void&quot;);</span>
<span class="line-removed"> 700       i++;</span>
<span class="line-removed"> 701       result[idx++] = &#39;L&#39;;</span>
<span class="line-removed"> 702       break;</span>
<span class="line-removed"> 703     case T_OBJECT:</span>
<span class="line-removed"> 704       result[idx++] = &#39;O&#39;;</span>
<span class="line-removed"> 705       break;</span>
<span class="line-removed"> 706     case T_ARRAY:</span>
<span class="line-removed"> 707       result[idx++] = &#39;[&#39;;</span>
<span class="line-removed"> 708       break;</span>
<span class="line-removed"> 709     case T_ADDRESS:</span>
<span class="line-removed"> 710       result[idx++] = &#39;P&#39;;</span>
<span class="line-removed"> 711       break;</span>
<span class="line-removed"> 712     case T_NARROWOOP:</span>
<span class="line-removed"> 713       result[idx++] = &#39;N&#39;;</span>
<span class="line-removed"> 714       break;</span>
<span class="line-removed"> 715     case T_METADATA:</span>
<span class="line-removed"> 716       result[idx++] = &#39;M&#39;;</span>
<span class="line-removed"> 717       break;</span>
<span class="line-removed"> 718     case T_NARROWKLASS:</span>
<span class="line-removed"> 719       result[idx++] = &#39;K&#39;;</span>
<span class="line-removed"> 720       break;</span>
<span class="line-removed"> 721     default:</span>
<span class="line-removed"> 722       result[idx++] = &#39;?&#39;;</span>
<span class="line-removed"> 723       break;</span>
<span class="line-removed"> 724     }</span>
<span class="line-removed"> 725   }</span>
<span class="line-removed"> 726   result[idx++] = &#39;)&#39;;</span>
<span class="line-removed"> 727   result[idx] = &#39;\0&#39;;</span>
<span class="line-removed"> 728 }</span>
<span class="line-removed"> 729 #endif</span>
<span class="line-removed"> 730 </span>
 731 // ---------------------------------------------------------------
 732 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
 733                                                             int total_args_passed,
 734                                                             int comp_args_on_stack,
 735                                                             const BasicType *sig_bt,
 736                                                             const VMRegPair *regs,
 737                                                             AdapterFingerPrint* fingerprint) {
 738   address i2c_entry = __ pc();
<span class="line-removed"> 739 #ifdef BUILTIN_SIM</span>
<span class="line-removed"> 740   char *name = NULL;</span>
<span class="line-removed"> 741   AArch64Simulator *sim = NULL;</span>
<span class="line-removed"> 742   size_t len = 65536;</span>
<span class="line-removed"> 743   if (NotifySimulator) {</span>
<span class="line-removed"> 744     name = NEW_C_HEAP_ARRAY(char, len, mtInternal);</span>
<span class="line-removed"> 745   }</span>
 746 
<span class="line-removed"> 747   if (name) {</span>
<span class="line-removed"> 748     generate_i2c_adapter_name(name, total_args_passed, sig_bt);</span>
<span class="line-removed"> 749     sim = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed"> 750     sim-&gt;notifyCompile(name, i2c_entry);</span>
<span class="line-removed"> 751   }</span>
<span class="line-removed"> 752 #endif</span>
 753   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
 754 
 755   address c2i_unverified_entry = __ pc();
 756   Label skip_fixup;
 757 
 758   Label ok;
 759 
 760   Register holder = rscratch2;
 761   Register receiver = j_rarg0;
 762   Register tmp = r10;  // A call-clobbered register not used for arg passing
 763 
 764   // -------------------------------------------------------------------------
 765   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 766   // to the interpreter.  The args start out packed in the compiled layout.  They
 767   // need to be unpacked into the interpreter layout.  This will almost always
 768   // require some stack space.  We grow the current (compiled) stack, then repack
 769   // the args.  We  finally end in a jump to the generic interpreter entry point.
 770   // On exit from the interpreter, the interpreter will restore our SP (lest the
 771   // compiled code, which relys solely on SP and not FP, get sick).
 772 
</pre>
<hr />
<pre>
 774     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 775     __ load_klass(rscratch1, receiver);
 776     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 777     __ cmp(rscratch1, tmp);
 778     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 779     __ br(Assembler::EQ, ok);
 780     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 781 
 782     __ bind(ok);
 783     // Method might have been compiled since the call site was patched to
 784     // interpreted; if that is the case treat it as a miss so we can get
 785     // the call site corrected.
 786     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 787     __ cbz(rscratch1, skip_fixup);
 788     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 789     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 790   }
 791 
 792   address c2i_entry = __ pc();
 793 
<span class="line-modified"> 794 #ifdef BUILTIN_SIM</span>
<span class="line-modified"> 795   if (name) {</span>
<span class="line-modified"> 796     name[0] = &#39;c&#39;;</span>
<span class="line-modified"> 797     name[2] = &#39;i&#39;;</span>
<span class="line-modified"> 798     sim-&gt;notifyCompile(name, c2i_entry);</span>
<span class="line-modified"> 799     FREE_C_HEAP_ARRAY(char, name, mtInternal);</span>











 800   }
<span class="line-removed"> 801 #endif</span>
 802 
 803   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 804 
 805   __ flush();
<span class="line-modified"> 806   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);</span>
 807 }
 808 
 809 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 810                                          VMRegPair *regs,
 811                                          VMRegPair *regs2,
 812                                          int total_args_passed) {
 813   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
 814 
 815 // We return the amount of VMRegImpl stack slots we need to reserve for all
 816 // the arguments NOT counting out_preserve_stack_slots.
 817 
 818     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
 819       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
 820     };
 821     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
 822       c_farg0, c_farg1, c_farg2, c_farg3,
 823       c_farg4, c_farg5, c_farg6, c_farg7
 824     };
 825 
 826     uint int_args = 0;
</pre>
<hr />
<pre>
1184   ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,
1185                     BasicType* in_sig_bt, GrowableArray&lt;int&gt;&amp; arg_order, VMRegPair tmp_vmreg) { Unimplemented(); }
1186 
1187   // Collected all the move operations
1188   void add_edge(int src_index, VMRegPair src, int dst_index, VMRegPair dst) { Unimplemented(); }
1189 
1190   // Walk the edges breaking cycles between moves.  The result list
1191   // can be walked in order to produce the proper set of loads
1192   GrowableArray&lt;MoveOperation*&gt;* get_store_order(VMRegPair temp_register) { Unimplemented(); return 0; }
1193 };
1194 
1195 
1196 static void rt_call(MacroAssembler* masm, address dest, int gpargs, int fpargs, int type) {
1197   CodeBlob *cb = CodeCache::find_blob(dest);
1198   if (cb) {
1199     __ far_call(RuntimeAddress(dest));
1200   } else {
1201     assert((unsigned)gpargs &lt; 256, &quot;eek!&quot;);
1202     assert((unsigned)fpargs &lt; 32, &quot;eek!&quot;);
1203     __ lea(rscratch1, RuntimeAddress(dest));
<span class="line-modified">1204     if (UseBuiltinSim)   __ mov(rscratch2, (gpargs &lt;&lt; 6) | (fpargs &lt;&lt; 2) | type);</span>
<span class="line-removed">1205     __ blrt(rscratch1, rscratch2);</span>
1206     __ maybe_isb();
1207   }
1208 }
1209 
1210 static void verify_oop_args(MacroAssembler* masm,
1211                             const methodHandle&amp; method,
1212                             const BasicType* sig_bt,
1213                             const VMRegPair* regs) {
1214   Register temp_reg = r19;  // not part of any compiled calling seq
1215   if (VerifyOops) {
1216     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
1217       if (sig_bt[i] == T_OBJECT ||
1218           sig_bt[i] == T_ARRAY) {
1219         VMReg r = regs[i].first();
1220         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
1221         if (r-&gt;is_stack()) {
1222           __ ldr(temp_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1223           __ verify_oop(temp_reg);
1224         } else {
1225           __ verify_oop(r-&gt;as_Register());
</pre>
<hr />
<pre>
1305 // block and the check for pending exceptions it&#39;s impossible for them
1306 // to be thrown.
1307 //
1308 // They are roughly structured like this:
1309 //    if (GCLocker::needs_gc())
1310 //      SharedRuntime::block_for_jni_critical();
1311 //    tranistion to thread_in_native
1312 //    unpack arrray arguments and call native entry point
1313 //    check for safepoint in progress
1314 //    check if any thread suspend flags are set
1315 //      call into JVM and possible unlock the JNI critical
1316 //      if a GC was suppressed while in the critical native.
1317 //    transition back to thread_in_Java
1318 //    return to caller
1319 //
1320 nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
1321                                                 const methodHandle&amp; method,
1322                                                 int compile_id,
1323                                                 BasicType* in_sig_bt,
1324                                                 VMRegPair* in_regs,
<span class="line-modified">1325                                                 BasicType ret_type) {</span>
<span class="line-modified">1326 #ifdef BUILTIN_SIM</span>
<span class="line-removed">1327   if (NotifySimulator) {</span>
<span class="line-removed">1328     // Names are up to 65536 chars long.  UTF8-coded strings are up to</span>
<span class="line-removed">1329     // 3 bytes per character.  We concatenate three such strings.</span>
<span class="line-removed">1330     // Yes, I know this is ridiculous, but it&#39;s debug code and glibc</span>
<span class="line-removed">1331     // allocates large arrays very efficiently.</span>
<span class="line-removed">1332     size_t len = (65536 * 3) * 3;</span>
<span class="line-removed">1333     char *name = new char[len];</span>
<span class="line-removed">1334 </span>
<span class="line-removed">1335     strncpy(name, method()-&gt;method_holder()-&gt;name()-&gt;as_utf8(), len);</span>
<span class="line-removed">1336     strncat(name, &quot;.&quot;, len);</span>
<span class="line-removed">1337     strncat(name, method()-&gt;name()-&gt;as_utf8(), len);</span>
<span class="line-removed">1338     strncat(name, method()-&gt;signature()-&gt;as_utf8(), len);</span>
<span class="line-removed">1339     AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck)-&gt;notifyCompile(name, __ pc());</span>
<span class="line-removed">1340     delete[] name;</span>
<span class="line-removed">1341   }</span>
<span class="line-removed">1342 #endif</span>
<span class="line-removed">1343 </span>
1344   if (method-&gt;is_method_handle_intrinsic()) {
1345     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1346     intptr_t start = (intptr_t)__ pc();
1347     int vep_offset = ((intptr_t)__ pc()) - start;
1348 
1349     // First instruction must be a nop as it may need to be patched on deoptimisation
1350     __ nop();
1351     gen_special_dispatch(masm,
1352                          method,
1353                          in_sig_bt,
1354                          in_regs);
1355     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
1356     __ flush();
1357     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
1358     return nmethod::new_native_nmethod(method,
1359                                        compile_id,
1360                                        masm-&gt;code(),
1361                                        vep_offset,
1362                                        frame_complete,
1363                                        stack_slots / VMRegImpl::slots_per_word,
1364                                        in_ByteSize(-1),
1365                                        in_ByteSize(-1),
1366                                        (OopMapSet*)NULL);
1367   }
1368   bool is_critical_native = true;
<span class="line-modified">1369   address native_func = method-&gt;critical_native_function();</span>
1370   if (native_func == NULL) {
1371     native_func = method-&gt;native_function();
1372     is_critical_native = false;
1373   }
1374   assert(native_func != NULL, &quot;must have function&quot;);
1375 
1376   // An OopMap for lock (and class if static)
1377   OopMapSet *oop_maps = new OopMapSet();
1378   intptr_t start = (intptr_t)__ pc();
1379 
1380   // We have received a description of where all the java arg are located
1381   // on entry to the wrapper. We need to convert these args to where
1382   // the jni function will expect them. To figure out where they go
1383   // we convert the java signature to a C signature by inserting
1384   // the hidden arguments as arg[0] and possibly arg[1] (static method)
1385 
1386   const int total_in_args = method-&gt;size_of_parameters();
1387   int total_c_args = total_in_args;
1388   if (!is_critical_native) {
1389     total_c_args += 1;
</pre>
<hr />
<pre>
1396         total_c_args++;
1397       }
1398     }
1399   }
1400 
1401   BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1402   VMRegPair* out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1403   BasicType* in_elem_bt = NULL;
1404 
1405   int argc = 0;
1406   if (!is_critical_native) {
1407     out_sig_bt[argc++] = T_ADDRESS;
1408     if (method-&gt;is_static()) {
1409       out_sig_bt[argc++] = T_OBJECT;
1410     }
1411 
1412     for (int i = 0; i &lt; total_in_args ; i++ ) {
1413       out_sig_bt[argc++] = in_sig_bt[i];
1414     }
1415   } else {
<span class="line-removed">1416     Thread* THREAD = Thread::current();</span>
1417     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
1418     SignatureStream ss(method-&gt;signature());
1419     for (int i = 0; i &lt; total_in_args ; i++ ) {
1420       if (in_sig_bt[i] == T_ARRAY) {
1421         // Arrays are passed as int, elem* pair
1422         out_sig_bt[argc++] = T_INT;
1423         out_sig_bt[argc++] = T_ADDRESS;
<span class="line-modified">1424         Symbol* atype = ss.as_symbol(CHECK_NULL);</span>
<span class="line-modified">1425         const char* at = atype-&gt;as_C_string();</span>
<span class="line-modified">1426         if (strlen(at) == 2) {</span>
<span class="line-removed">1427           assert(at[0] == &#39;[&#39;, &quot;must be&quot;);</span>
<span class="line-removed">1428           switch (at[1]) {</span>
<span class="line-removed">1429             case &#39;B&#39;: in_elem_bt[i]  = T_BYTE; break;</span>
<span class="line-removed">1430             case &#39;C&#39;: in_elem_bt[i]  = T_CHAR; break;</span>
<span class="line-removed">1431             case &#39;D&#39;: in_elem_bt[i]  = T_DOUBLE; break;</span>
<span class="line-removed">1432             case &#39;F&#39;: in_elem_bt[i]  = T_FLOAT; break;</span>
<span class="line-removed">1433             case &#39;I&#39;: in_elem_bt[i]  = T_INT; break;</span>
<span class="line-removed">1434             case &#39;J&#39;: in_elem_bt[i]  = T_LONG; break;</span>
<span class="line-removed">1435             case &#39;S&#39;: in_elem_bt[i]  = T_SHORT; break;</span>
<span class="line-removed">1436             case &#39;Z&#39;: in_elem_bt[i]  = T_BOOLEAN; break;</span>
<span class="line-removed">1437             default: ShouldNotReachHere();</span>
<span class="line-removed">1438           }</span>
<span class="line-removed">1439         }</span>
1440       } else {
1441         out_sig_bt[argc++] = in_sig_bt[i];
1442         in_elem_bt[i] = T_VOID;
1443       }
1444       if (in_sig_bt[i] != T_VOID) {
<span class="line-modified">1445         assert(in_sig_bt[i] == ss.type(), &quot;must match&quot;);</span>

1446         ss.next();
1447       }
1448     }
1449   }
1450 
1451   // Now figure out where the args must be stored and how much stack space
1452   // they require.
1453   int out_arg_slots;
1454   out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
1455 
1456   // Compute framesize for the wrapper.  We need to handlize all oops in
1457   // incoming registers
1458 
1459   // Calculate the total number of stack slots we will need.
1460 
1461   // First count the abi requirement plus all of the outgoing args
1462   int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;
1463 
1464   // Now the space for the inbound oop handle area
1465   int total_save_slots = 8 * VMRegImpl::slots_per_word;  // 8 arguments passed in registers
</pre>
<hr />
<pre>
1565   assert_different_registers(ic_reg, receiver, rscratch1);
1566   __ verify_oop(receiver);
1567   __ cmp_klass(receiver, ic_reg, rscratch1);
1568   __ br(Assembler::EQ, hit);
1569 
1570   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1571 
1572   // Verified entry point must be aligned
1573   __ align(8);
1574 
1575   __ bind(hit);
1576 
1577   int vep_offset = ((intptr_t)__ pc()) - start;
1578 
1579   // If we have to make this method not-entrant we&#39;ll overwrite its
1580   // first instruction with a jump.  For this action to be legal we
1581   // must ensure that this first instruction is a B, BL, NOP, BKPT,
1582   // SVC, HVC, or SMC.  Make it a NOP.
1583   __ nop();
1584 









1585   // Generate stack overflow check
1586   if (UseStackBanging) {
1587     __ bang_stack_with_offset(JavaThread::stack_shadow_zone_size());
1588   } else {
1589     Unimplemented();
1590   }
1591 
1592   // Generate a new frame for the wrapper.
1593   __ enter();
1594   // -2 because return address is already present and so is saved rfp
1595   __ sub(sp, sp, stack_size - 2*wordSize);
1596 
1597   // Frame is now completed as far as size and linkage.
1598   int frame_complete = ((intptr_t)__ pc()) - start;
1599 
<span class="line-removed">1600   // record entry into native wrapper code</span>
<span class="line-removed">1601   if (NotifySimulator) {</span>
<span class="line-removed">1602     __ notify(Assembler::method_entry);</span>
<span class="line-removed">1603   }</span>
<span class="line-removed">1604 </span>
1605   // We use r20 as the oop handle for the receiver/klass
1606   // It is callee save so it survives the call to native
1607 
1608   const Register oop_handle_reg = r20;
1609 
1610   if (is_critical_native) {
1611     check_needs_gc_for_critical_native(masm, stack_slots, total_c_args, total_in_args,
1612                                        oop_handle_offset, oop_maps, in_regs, in_sig_bt);
1613   }
1614 
1615   //
1616   // We immediately shuffle the arguments so that any vm call we have to
1617   // make from here on out (sync slow path, jvmti, etc.) we will have
1618   // captured the oops from our caller and have a valid oopMap for
1619   // them.
1620 
1621   // -----------------
1622   // The Grand Shuffle
1623 
1624   // The Java calling convention is either equal (linux) or denser (win64) than the
</pre>
<hr />
<pre>
2023     __ bind(unlock_done);
2024     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2025       restore_native_result(masm, ret_type, stack_slots);
2026     }
2027 
2028     __ bind(done);
2029   }
2030 
2031   Label dtrace_method_exit, dtrace_method_exit_done;
2032   {
2033     unsigned long offset;
2034     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
2035     __ ldrb(rscratch1, Address(rscratch1, offset));
2036     __ cbnzw(rscratch1, dtrace_method_exit);
2037     __ bind(dtrace_method_exit_done);
2038   }
2039 
2040   __ reset_last_Java_frame(false);
2041 
2042   // Unbox oop result, e.g. JNIHandles::resolve result.
<span class="line-modified">2043   if (ret_type == T_OBJECT || ret_type == T_ARRAY) {</span>
2044     __ resolve_jobject(r0, rthread, rscratch2);
2045   }
2046 
2047   if (CheckJNICalls) {
2048     // clear_pending_jni_exception_check
2049     __ str(zr, Address(rthread, JavaThread::pending_jni_exception_check_fn_offset()));
2050   }
2051 
2052   if (!is_critical_native) {
2053     // reset handle block
2054     __ ldr(r2, Address(rthread, JavaThread::active_handles_offset()));
2055     __ str(zr, Address(r2, JNIHandleBlock::top_offset_in_bytes()));
2056   }
2057 
2058   __ leave();
2059 
2060   if (!is_critical_native) {
2061     // Any exception pending?
2062     __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2063     __ cbnz(rscratch1, exception_pending);
2064   }
2065 
<span class="line-removed">2066   // record exit from native wrapper code</span>
<span class="line-removed">2067   if (NotifySimulator) {</span>
<span class="line-removed">2068     __ notify(Assembler::method_reentry);</span>
<span class="line-removed">2069   }</span>
<span class="line-removed">2070 </span>
2071   // We&#39;re done
2072   __ ret(lr);
2073 
2074   // Unexpected paths are out of line and go here
2075 
2076   if (!is_critical_native) {
2077     // forward the exception
2078     __ bind(exception_pending);
2079 
2080     // and forward the exception
2081     __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2082   }
2083 
2084   // Slow path locking &amp; unlocking
2085   if (method-&gt;is_synchronized()) {
2086 
2087     __ block_comment(&quot;Slow path lock {&quot;);
2088     __ bind(slow_path_lock);
2089 
2090     // has last_Java_frame setup. No exceptions so do vanilla call not call_VM
</pre>
<hr />
<pre>
2165   __ b(reguard_done);
2166 
2167   // SLOW PATH safepoint
2168   {
2169     __ block_comment(&quot;safepoint {&quot;);
2170     __ bind(safepoint_in_progress);
2171 
2172     // Don&#39;t use call_VM as it will see a possible pending exception and forward it
2173     // and never return here preventing us from clearing _last_native_pc down below.
2174     //
2175     save_native_result(masm, ret_type, stack_slots);
2176     __ mov(c_rarg0, rthread);
2177 #ifndef PRODUCT
2178   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2179 #endif
2180     if (!is_critical_native) {
2181       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
2182     } else {
2183       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)));
2184     }
<span class="line-modified">2185     __ blrt(rscratch1, 1, 0, 1);</span>
2186     __ maybe_isb();
2187     // Restore any method result value
2188     restore_native_result(masm, ret_type, stack_slots);
2189 
2190     if (is_critical_native) {
2191       // The call above performed the transition to thread_in_Java so
2192       // skip the transition logic above.
2193       __ b(after_transition);
2194     }
2195 
2196     __ b(safepoint_in_progress_done);
2197     __ block_comment(&quot;} safepoint&quot;);
2198   }
2199 
2200   // SLOW PATH dtrace support
2201   {
2202     __ block_comment(&quot;dtrace entry {&quot;);
2203     __ bind(dtrace_method_entry);
2204 
2205     // We have all of the arguments setup at this point. We must not touch any register
</pre>
<hr />
<pre>
2262 }
2263 
2264 
2265 //------------------------------generate_deopt_blob----------------------------
2266 void SharedRuntime::generate_deopt_blob() {
2267   // Allocate space for the code
2268   ResourceMark rm;
2269   // Setup code generation tools
2270   int pad = 0;
2271 #if INCLUDE_JVMCI
2272   if (EnableJVMCI || UseAOT) {
2273     pad += 512; // Increase the buffer size when compiling for JVMCI
2274   }
2275 #endif
2276   CodeBuffer buffer(&quot;deopt_blob&quot;, 2048+pad, 1024);
2277   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2278   int frame_size_in_words;
2279   OopMap* map = NULL;
2280   OopMapSet *oop_maps = new OopMapSet();
2281 
<span class="line-removed">2282 #ifdef BUILTIN_SIM</span>
<span class="line-removed">2283   AArch64Simulator *simulator;</span>
<span class="line-removed">2284   if (NotifySimulator) {</span>
<span class="line-removed">2285     simulator = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed">2286     simulator-&gt;notifyCompile(const_cast&lt;char*&gt;(&quot;SharedRuntime::deopt_blob&quot;), __ pc());</span>
<span class="line-removed">2287   }</span>
<span class="line-removed">2288 #endif</span>
<span class="line-removed">2289 </span>
2290   // -------------
2291   // This code enters when returning to a de-optimized nmethod.  A return
2292   // address has been pushed on the the stack, and return values are in
2293   // registers.
2294   // If we are doing a normal deopt then we were called from the patched
2295   // nmethod from the point we returned to the nmethod. So the return
2296   // address on the stack is wrong by NativeCall::instruction_size
2297   // We will adjust the value so it looks like we have the original return
2298   // address on the stack (like when we eagerly deoptimized).
2299   // In the case of an exception pending when deoptimizing, we enter
2300   // with a return address on the stack that points after the call we patched
2301   // into the exception handler. We have the following register state from,
2302   // e.g., the forward exception stub (see stubGenerator_x86_64.cpp).
2303   //    r0: exception oop
2304   //    r19: exception handler
2305   //    r3: throwing pc
2306   // So in this case we simply jam r3 into the useless return address and
2307   // the stack looks just like we want.
2308   //
2309   // At this point we need to de-opt.  We save the argument return
</pre>
<hr />
<pre>
2358     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2359 
2360     uncommon_trap_offset = __ pc() - start;
2361 
2362     // Save everything in sight.
2363     RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2364     // fetch_unroll_info needs to call last_java_frame()
2365     Label retaddr;
2366     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2367 
2368     __ ldrw(c_rarg1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2369     __ movw(rscratch1, -1);
2370     __ strw(rscratch1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2371 
2372     __ movw(rcpool, (int32_t)Deoptimization::Unpack_reexecute);
2373     __ mov(c_rarg0, rthread);
2374     __ movw(c_rarg2, rcpool); // exec mode
2375     __ lea(rscratch1,
2376            RuntimeAddress(CAST_FROM_FN_PTR(address,
2377                                            Deoptimization::uncommon_trap)));
<span class="line-modified">2378     __ blrt(rscratch1, 2, 0, MacroAssembler::ret_type_integral);</span>
2379     __ bind(retaddr);
2380     oop_maps-&gt;add_gc_map( __ pc()-start, map-&gt;deep_copy());
2381 
2382     __ reset_last_Java_frame(false);
2383 
2384     __ b(after_fetch_unroll_info_call);
2385   } // EnableJVMCI
2386 #endif // INCLUDE_JVMCI
2387 
2388   int exception_offset = __ pc() - start;
2389 
2390   // Prolog for exception case
2391 
2392   // all registers are dead at this entry point, except for r0, and
2393   // r3 which contain the exception oop and exception pc
2394   // respectively.  Set them in TLS and fall thru to the
2395   // unpack_with_exception_in_tls entry point.
2396 
2397   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
2398   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
</pre>
<hr />
<pre>
2450   // crud.  We cannot block on this call, no GC can happen.
2451   //
2452   // UnrollBlock* fetch_unroll_info(JavaThread* thread)
2453 
2454   // fetch_unroll_info needs to call last_java_frame().
2455 
2456   Label retaddr;
2457   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2458 #ifdef ASSERT0
2459   { Label L;
2460     __ ldr(rscratch1, Address(rthread,
2461                               JavaThread::last_Java_fp_offset()));
2462     __ cbz(rscratch1, L);
2463     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
2464     __ bind(L);
2465   }
2466 #endif // ASSERT
2467   __ mov(c_rarg0, rthread);
2468   __ mov(c_rarg1, rcpool);
2469   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)));
<span class="line-modified">2470   __ blrt(rscratch1, 1, 0, 1);</span>
2471   __ bind(retaddr);
2472 
2473   // Need to have an oopmap that tells fetch_unroll_info where to
2474   // find any register it might need.
2475   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2476 
2477   __ reset_last_Java_frame(false);
2478 
2479 #if INCLUDE_JVMCI
2480   if (EnableJVMCI || UseAOT) {
2481     __ bind(after_fetch_unroll_info_call);
2482   }
2483 #endif
2484 
2485   // Load UnrollBlock* into r5
2486   __ mov(r5, r0);
2487 
2488   __ ldrw(rcpool, Address(r5, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2489    Label noException;
2490   __ cmpw(rcpool, Deoptimization::Unpack_exception);   // Was exception pending?
</pre>
<hr />
<pre>
2590   __ sub(sp, sp, (frame_size_in_words - 2) * wordSize);
2591 
2592   // Restore frame locals after moving the frame
2593   __ strd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2594   __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2595 
2596   // Call C code.  Need thread but NOT official VM entry
2597   // crud.  We cannot block on this call, no GC can happen.  Call should
2598   // restore return values to their stack-slots with the new SP.
2599   //
2600   // void Deoptimization::unpack_frames(JavaThread* thread, int exec_mode)
2601 
2602   // Use rfp because the frames look interpreted now
2603   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2604   address the_pc = __ pc();
2605   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2606 
2607   __ mov(c_rarg0, rthread);
2608   __ movw(c_rarg1, rcpool); // second arg: exec_mode
2609   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
<span class="line-modified">2610   __ blrt(rscratch1, 2, 0, 0);</span>
2611 
2612   // Set an oopmap for the call site
2613   // Use the same PC we used for the last java frame
2614   oop_maps-&gt;add_gc_map(the_pc - start,
2615                        new OopMap( frame_size_in_words, 0 ));
2616 
2617   // Clear fp AND pc
2618   __ reset_last_Java_frame(true);
2619 
2620   // Collect return values
2621   __ ldrd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2622   __ ldr(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2623   // I think this is useless (throwing pc?)
2624   // __ ldr(r3, Address(sp, RegisterSaver::r3_offset_in_bytes()));
2625 
2626   // Pop self-frame.
2627   __ leave();                           // Epilog
2628 
2629   // Jump to interpreter
2630   __ ret(lr);
2631 
2632   // Make sure all code is generated
2633   masm-&gt;flush();
2634 
2635   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);
2636   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
2637 #if INCLUDE_JVMCI
2638   if (EnableJVMCI || UseAOT) {
2639     _deopt_blob-&gt;set_uncommon_trap_offset(uncommon_trap_offset);
2640     _deopt_blob-&gt;set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);
2641   }
2642 #endif
<span class="line-removed">2643 #ifdef BUILTIN_SIM</span>
<span class="line-removed">2644   if (NotifySimulator) {</span>
<span class="line-removed">2645     unsigned char *base = _deopt_blob-&gt;code_begin();</span>
<span class="line-removed">2646     simulator-&gt;notifyRelocate(start, base - start);</span>
<span class="line-removed">2647   }</span>
<span class="line-removed">2648 #endif</span>
2649 }
2650 
2651 uint SharedRuntime::out_preserve_stack_slots() {
2652   return 0;
2653 }
2654 
2655 #if COMPILER2_OR_JVMCI
2656 //------------------------------generate_uncommon_trap_blob--------------------
2657 void SharedRuntime::generate_uncommon_trap_blob() {
2658   // Allocate space for the code
2659   ResourceMark rm;
2660   // Setup code generation tools
2661   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
2662   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2663 
<span class="line-removed">2664 #ifdef BUILTIN_SIM</span>
<span class="line-removed">2665   AArch64Simulator *simulator;</span>
<span class="line-removed">2666   if (NotifySimulator) {</span>
<span class="line-removed">2667     simulator = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed">2668     simulator-&gt;notifyCompile(const_cast&lt;char*&gt;(&quot;SharedRuntime:uncommon_trap_blob&quot;), __ pc());</span>
<span class="line-removed">2669   }</span>
<span class="line-removed">2670 #endif</span>
<span class="line-removed">2671 </span>
2672   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
2673 
2674   address start = __ pc();
2675 
2676   // Push self-frame.  We get here with a return address in LR
2677   // and sp should be 16 byte aligned
2678   // push rfp and retaddr by hand
2679   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
2680   // we don&#39;t expect an arg reg save area
2681 #ifndef PRODUCT
2682   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2683 #endif
2684   // compiler left unloaded_class_index in j_rarg0 move to where the
2685   // runtime expects it.
2686   if (c_rarg1 != j_rarg0) {
2687     __ movw(c_rarg1, j_rarg0);
2688   }
2689 
2690   // we need to set the past SP to the stack pointer of the stub frame
2691   // and the pc to the address where this runtime call will return
2692   // although actually any pc in this code blob will do).
2693   Label retaddr;
2694   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2695 
2696   // Call C code.  Need thread but NOT official VM entry
2697   // crud.  We cannot block on this call, no GC can happen.  Call should
2698   // capture callee-saved registers as well as return values.
2699   // Thread is in rdi already.
2700   //
2701   // UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);
2702   //
2703   // n.b. 2 gp args, 0 fp args, integral return type
2704 
2705   __ mov(c_rarg0, rthread);
2706   __ movw(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);
2707   __ lea(rscratch1,
2708          RuntimeAddress(CAST_FROM_FN_PTR(address,
2709                                          Deoptimization::uncommon_trap)));
<span class="line-modified">2710   __ blrt(rscratch1, 2, 0, MacroAssembler::ret_type_integral);</span>
2711   __ bind(retaddr);
2712 
2713   // Set an oopmap for the call site
2714   OopMapSet* oop_maps = new OopMapSet();
2715   OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);
2716 
2717   // location of rfp is known implicitly by the frame sender code
2718 
2719   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2720 
2721   __ reset_last_Java_frame(false);
2722 
2723   // move UnrollBlock* into r4
2724   __ mov(r4, r0);
2725 
2726 #ifdef ASSERT
2727   { Label L;
2728     __ ldrw(rscratch1, Address(r4, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2729     __ cmpw(rscratch1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2730     __ br(Assembler::EQ, L);
</pre>
<hr />
<pre>
2813 
2814   // Use rfp because the frames look interpreted now
2815   // Save &quot;the_pc&quot; since it cannot easily be retrieved using the last_java_SP after we aligned SP.
2816   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2817   address the_pc = __ pc();
2818   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2819 
2820   // Call C code.  Need thread but NOT official VM entry
2821   // crud.  We cannot block on this call, no GC can happen.  Call should
2822   // restore return values to their stack-slots with the new SP.
2823   // Thread is in rdi already.
2824   //
2825   // BasicType unpack_frames(JavaThread* thread, int exec_mode);
2826   //
2827   // n.b. 2 gp args, 0 fp args, integral return type
2828 
2829   // sp should already be aligned
2830   __ mov(c_rarg0, rthread);
2831   __ movw(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2832   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
<span class="line-modified">2833   __ blrt(rscratch1, 2, 0, MacroAssembler::ret_type_integral);</span>
2834 
2835   // Set an oopmap for the call site
2836   // Use the same PC we used for the last java frame
2837   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
2838 
2839   // Clear fp AND pc
2840   __ reset_last_Java_frame(true);
2841 
2842   // Pop self-frame.
2843   __ leave();                 // Epilog
2844 
2845   // Jump to interpreter
2846   __ ret(lr);
2847 
2848   // Make sure all code is generated
2849   masm-&gt;flush();
2850 
2851   _uncommon_trap_blob =  UncommonTrapBlob::create(&amp;buffer, oop_maps,
2852                                                  SimpleRuntimeFrame::framesize &gt;&gt; 1);
<span class="line-removed">2853 </span>
<span class="line-removed">2854 #ifdef BUILTIN_SIM</span>
<span class="line-removed">2855   if (NotifySimulator) {</span>
<span class="line-removed">2856     unsigned char *base = _deopt_blob-&gt;code_begin();</span>
<span class="line-removed">2857     simulator-&gt;notifyRelocate(start, base - start);</span>
<span class="line-removed">2858   }</span>
<span class="line-removed">2859 #endif</span>
2860 }
2861 #endif // COMPILER2_OR_JVMCI
2862 
2863 
2864 //------------------------------generate_handler_blob------
2865 //
2866 // Generate a special Compile2Runtime blob that saves all registers,
2867 // and setup oopmap.
2868 //
2869 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
2870   ResourceMark rm;
2871   OopMapSet *oop_maps = new OopMapSet();
2872   OopMap* map;
2873 
2874   // Allocate space for the code.  Setup code generation tools.
2875   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
2876   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2877 
2878   address start   = __ pc();
2879   address call_pc = NULL;
2880   int frame_size_in_words;
2881   bool cause_return = (poll_type == POLL_AT_RETURN);
2882   bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
2883 
<span class="line-modified">2884   // Save registers, fpu state, and flags</span>
2885   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words, save_vectors);
2886 
2887   // The following is basically a call_VM.  However, we need the precise
2888   // address of the call in order to generate an oopmap. Hence, we do all the
2889   // work outselves.
2890 
2891   Label retaddr;
2892   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2893 
2894   // The return address must always be correct so that frame constructor never
2895   // sees an invalid pc.
2896 
2897   if (!cause_return) {
2898     // overwrite the return address pushed by save_live_registers
2899     // Additionally, r20 is a callee-saved register so we can look at
2900     // it later to determine if someone changed the return address for
2901     // us!
2902     __ ldr(r20, Address(rthread, JavaThread::saved_exception_pc_offset()));
2903     __ str(r20, Address(rfp, wordSize));
2904   }
2905 
2906   // Do the call
2907   __ mov(c_rarg0, rthread);
2908   __ lea(rscratch1, RuntimeAddress(call_ptr));
<span class="line-modified">2909   __ blrt(rscratch1, 1, 0, 1);</span>
2910   __ bind(retaddr);
2911 
2912   // Set an oopmap for the call site.  This oopmap will map all
2913   // oop-registers and debug-info registers as callee-saved.  This
2914   // will allow deoptimization at this safepoint to find all possible
2915   // debug-info recordings, as well as let GC find all oops.
2916 
2917   oop_maps-&gt;add_gc_map( __ pc() - start, map);
2918 
2919   Label noException;
2920 
2921   __ reset_last_Java_frame(false);
2922 
2923   __ maybe_isb();
2924   __ membar(Assembler::LoadLoad | Assembler::LoadStore);
2925 
2926   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2927   __ cbz(rscratch1, noException);
2928 
2929   // Exception pending
</pre>
<hr />
<pre>
2994   MacroAssembler* masm                = new MacroAssembler(&amp;buffer);
2995 
2996   int frame_size_in_words;
2997 
2998   OopMapSet *oop_maps = new OopMapSet();
2999   OopMap* map = NULL;
3000 
3001   int start = __ offset();
3002 
3003   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
3004 
3005   int frame_complete = __ offset();
3006 
3007   {
3008     Label retaddr;
3009     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
3010 
3011     __ mov(c_rarg0, rthread);
3012     __ lea(rscratch1, RuntimeAddress(destination));
3013 
<span class="line-modified">3014     __ blrt(rscratch1, 1, 0, 1);</span>
3015     __ bind(retaddr);
3016   }
3017 
3018   // Set an oopmap for the call site.
3019   // We need this not only for callee-saved registers, but also for volatile
3020   // registers that the compiler might be keeping live across a safepoint.
3021 
3022   oop_maps-&gt;add_gc_map( __ offset() - start, map);
3023 
3024   __ maybe_isb();
3025 
3026   // r0 contains the address we are going to jump to assuming no exception got installed
3027 
3028   // clear last_Java_sp
3029   __ reset_last_Java_frame(false);
3030   // check for pending exceptions
3031   Label pending;
3032   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
3033   __ cbnz(rscratch1, pending);
3034 
</pre>
<hr />
<pre>
3126   // handle_exception call, since we do not want to make any assumption
3127   // about the size of the frame where the exception happened in.
3128   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
3129   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
3130 
3131   // This call does all the hard work.  It checks if an exception handler
3132   // exists in the method.
3133   // If so, it returns the handler address.
3134   // If not, it prepares for stack-unwinding, restoring the callee-save
3135   // registers of the frame being removed.
3136   //
3137   // address OptoRuntime::handle_exception_C(JavaThread* thread)
3138   //
3139   // n.b. 1 gp arg, 0 fp args, integral return type
3140 
3141   // the stack should always be aligned
3142   address the_pc = __ pc();
3143   __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);
3144   __ mov(c_rarg0, rthread);
3145   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));
<span class="line-modified">3146   __ blrt(rscratch1, 1, 0, MacroAssembler::ret_type_integral);</span>
3147   __ maybe_isb();
3148 
3149   // Set an oopmap for the call site.  This oopmap will only be used if we
3150   // are unwinding the stack.  Hence, all locations will be dead.
3151   // Callee-saved registers will be the same as the frame above (i.e.,
3152   // handle_exception_stub), since they were restored when we got the
3153   // exception.
3154 
3155   OopMapSet* oop_maps = new OopMapSet();
3156 
3157   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
3158 
3159   __ reset_last_Java_frame(false);
3160 
3161   // Restore callee-saved registers
3162 
3163   // rfp is an implicitly saved callee saved register (i.e. the calling
3164   // convention will save restore it in prolog/epilog) Other than that
3165   // there are no callee save registers now that adapter frames are gone.
3166   // and we dont&#39; expect an arg reg save area
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;code/debugInfoRec.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/interp_masm.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  36 #include &quot;nativeInst_aarch64.hpp&quot;</span>
  37 #include &quot;oops/compiledICHolder.hpp&quot;
<span class="line-added">  38 #include &quot;oops/klass.inline.hpp&quot;</span>
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/vframeArray.hpp&quot;
  42 #include &quot;utilities/align.hpp&quot;
  43 #include &quot;vmreg_aarch64.inline.hpp&quot;
  44 #ifdef COMPILER1
  45 #include &quot;c1/c1_Runtime1.hpp&quot;
  46 #endif
  47 #if COMPILER2_OR_JVMCI
  48 #include &quot;adfiles/ad_aarch64.hpp&quot;
  49 #include &quot;opto/runtime.hpp&quot;
  50 #endif
  51 #if INCLUDE_JVMCI
  52 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  53 #endif
  54 




  55 #define __ masm-&gt;
  56 
  57 const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  58 
  59 class SimpleRuntimeFrame {
  60 
  61   public:
  62 
  63   // Most of the runtime stubs have this simple frame layout.
  64   // This class exists to make the layout shared in one place.
  65   // Offsets are for compiler stack slots, which are jints.
  66   enum layout {
  67     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
  68     // will override any oopMap setting for it. We must therefore force the layout
  69     // so that it agrees with the frame sender code.
  70     // we don&#39;t expect any arg reg save area so aarch64 asserts that
  71     // frame::arg_reg_save_area_bytes == 0
  72     rbp_off = 0,
  73     rbp_off2,
  74     return_off, return_off2,
</pre>
<hr />
<pre>
  83   static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);
  84 
  85   // Offsets into the register save area
  86   // Used by deoptimization when it is managing result register
  87   // values on its own
  88 
  89   static int r0_offset_in_bytes(void)    { return (32 + r0-&gt;encoding()) * wordSize; }
  90   static int reg_offset_in_bytes(Register r)    { return r0_offset_in_bytes() + r-&gt;encoding() * wordSize; }
  91   static int rmethod_offset_in_bytes(void)    { return reg_offset_in_bytes(rmethod); }
  92   static int rscratch1_offset_in_bytes(void)    { return (32 + rscratch1-&gt;encoding()) * wordSize; }
  93   static int v0_offset_in_bytes(void)   { return 0; }
  94   static int return_offset_in_bytes(void) { return (32 /* floats*/ + 31 /* gregs*/) * wordSize; }
  95 
  96   // During deoptimization only the result registers need to be restored,
  97   // all the other values have already been extracted.
  98   static void restore_result_registers(MacroAssembler* masm);
  99 
 100     // Capture info about frame layout
 101   enum layout {
 102                 fpu_state_off = 0,
<span class="line-modified"> 103                 fpu_state_end = fpu_state_off + FPUStateSizeInWords - 1,</span>
 104                 // The frame sender code expects that rfp will be in
 105                 // the &quot;natural&quot; place and will override any oopMap
 106                 // setting for it. We must therefore force the layout
 107                 // so that it agrees with the frame sender code.
<span class="line-modified"> 108                 r0_off = fpu_state_off + FPUStateSizeInWords,</span>
<span class="line-modified"> 109                 rfp_off = r0_off + (RegisterImpl::number_of_registers - 2) * RegisterImpl::max_slots_per_register,</span>
<span class="line-modified"> 110                 return_off = rfp_off + RegisterImpl::max_slots_per_register,      // slot for return address</span>
<span class="line-modified"> 111                 reg_save_size = return_off + RegisterImpl::max_slots_per_register};</span>
 112 
 113 };
 114 
 115 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {
 116 #if COMPILER2_OR_JVMCI
 117   if (save_vectors) {
 118     // Save upper half of vector registers
<span class="line-modified"> 119     int vect_words = FloatRegisterImpl::number_of_registers * FloatRegisterImpl::extra_save_slots_per_register /</span>
<span class="line-added"> 120                      VMRegImpl::slots_per_word;</span>
 121     additional_frame_words += vect_words;
 122   }
 123 #else
 124   assert(!save_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 125 #endif
 126 
<span class="line-modified"> 127   int frame_size_in_bytes = align_up(additional_frame_words * wordSize +</span>
<span class="line-modified"> 128                                      reg_save_size * BytesPerInt, 16);</span>
 129   // OopMap frame size is in compiler stack slots (jint&#39;s) not bytes or words
 130   int frame_size_in_slots = frame_size_in_bytes / BytesPerInt;
 131   // The caller will allocate additional_frame_words
<span class="line-modified"> 132   int additional_frame_slots = additional_frame_words * wordSize / BytesPerInt;</span>
 133   // CodeBlob frame size is in words.
 134   int frame_size_in_words = frame_size_in_bytes / wordSize;
 135   *total_frame_words = frame_size_in_words;
 136 
<span class="line-modified"> 137   // Save Integer and Float registers.</span>

 138   __ enter();
 139   __ push_CPU_state(save_vectors);
 140 
 141   // Set an oopmap for the call site.  This oopmap will map all
 142   // oop-registers and debug-info registers as callee-saved.  This
 143   // will allow deoptimization at this safepoint to find all possible
 144   // debug-info recordings, as well as let GC find all oops.
 145 
 146   OopMapSet *oop_maps = new OopMapSet();
 147   OopMap* oop_map = new OopMap(frame_size_in_slots, 0);
 148 
 149   for (int i = 0; i &lt; RegisterImpl::number_of_registers; i++) {
 150     Register r = as_Register(i);
<span class="line-modified"> 151     if (r &lt;= rfp &amp;&amp; r != rscratch1 &amp;&amp; r != rscratch2) {</span>
<span class="line-modified"> 152       // SP offsets are in 4-byte words.</span>
<span class="line-modified"> 153       // Register slots are 8 bytes wide, 32 floating-point registers.</span>
<span class="line-modified"> 154       int sp_offset = RegisterImpl::max_slots_per_register * i +</span>
<span class="line-modified"> 155                       FloatRegisterImpl::save_slots_per_register * FloatRegisterImpl::number_of_registers;</span>
 156       oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset + additional_frame_slots),
 157                                 r-&gt;as_VMReg());
 158     }
 159   }
 160 
 161   for (int i = 0; i &lt; FloatRegisterImpl::number_of_registers; i++) {
 162     FloatRegister r = as_FloatRegister(i);
<span class="line-modified"> 163     int sp_offset = save_vectors ? (FloatRegisterImpl::max_slots_per_register * i) :</span>
<span class="line-added"> 164                                    (FloatRegisterImpl::save_slots_per_register * i);</span>
 165     oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
 166                               r-&gt;as_VMReg());
 167   }
 168 
 169   return oop_map;
 170 }
 171 
 172 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {
 173 #ifndef COMPILER2
 174   assert(!restore_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 175 #endif
 176   __ pop_CPU_state(restore_vectors);
 177   __ leave();
 178 }
 179 
 180 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 181 
 182   // Just restore result register. Only used by deoptimization. By
 183   // now any callee save register that needs to be restored to a c2
 184   // caller of the deoptee has been extracted into the vframeArray
</pre>
<hr />
<pre>
 325 static void patch_callers_callsite(MacroAssembler *masm) {
 326   Label L;
 327   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 328   __ cbz(rscratch1, L);
 329 
 330   __ enter();
 331   __ push_CPU_state();
 332 
 333   // VM needs caller&#39;s callsite
 334   // VM needs target method
 335   // This needs to be a long call since we will relocate this adapter to
 336   // the codeBuffer and it may not reach
 337 
 338 #ifndef PRODUCT
 339   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 340 #endif
 341 
 342   __ mov(c_rarg0, rmethod);
 343   __ mov(c_rarg1, lr);
 344   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
<span class="line-modified"> 345   __ blr(rscratch1);</span>
 346   __ maybe_isb();
 347 
 348   __ pop_CPU_state();
 349   // restore sp
 350   __ leave();
 351   __ bind(L);
 352 }
 353 
 354 static void gen_c2i_adapter(MacroAssembler *masm,
 355                             int total_args_passed,
 356                             int comp_args_on_stack,
 357                             const BasicType *sig_bt,
 358                             const VMRegPair *regs,
 359                             Label&amp; skip_fixup) {
 360   // Before we get into the guts of the C2I adapter, see if we should be here
 361   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 362   // interpreter, which means the caller made a static call to get here
 363   // (vcalls always get a compiled target if there is one).  Check for a
 364   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 365   patch_callers_callsite(masm);
</pre>
<hr />
<pre>
 645         __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));
 646       }
 647     }
 648   }
 649 
 650   // 6243940 We might end up in handle_wrong_method if
 651   // the callee is deoptimized as we race thru here. If that
 652   // happens we don&#39;t want to take a safepoint because the
 653   // caller frame will look interpreted and arguments are now
 654   // &quot;compiled&quot; so it is much better to make this transition
 655   // invisible to the stack walking code. Unfortunately if
 656   // we try and find the callee by normal means a safepoint
 657   // is possible. So we stash the desired callee in the thread
 658   // and the vm will find there should this case occur.
 659 
 660   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));
 661 
 662   __ br(rscratch1);
 663 }
 664 

































































 665 // ---------------------------------------------------------------
 666 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
 667                                                             int total_args_passed,
 668                                                             int comp_args_on_stack,
 669                                                             const BasicType *sig_bt,
 670                                                             const VMRegPair *regs,
 671                                                             AdapterFingerPrint* fingerprint) {
 672   address i2c_entry = __ pc();







 673 






 674   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
 675 
 676   address c2i_unverified_entry = __ pc();
 677   Label skip_fixup;
 678 
 679   Label ok;
 680 
 681   Register holder = rscratch2;
 682   Register receiver = j_rarg0;
 683   Register tmp = r10;  // A call-clobbered register not used for arg passing
 684 
 685   // -------------------------------------------------------------------------
 686   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 687   // to the interpreter.  The args start out packed in the compiled layout.  They
 688   // need to be unpacked into the interpreter layout.  This will almost always
 689   // require some stack space.  We grow the current (compiled) stack, then repack
 690   // the args.  We  finally end in a jump to the generic interpreter entry point.
 691   // On exit from the interpreter, the interpreter will restore our SP (lest the
 692   // compiled code, which relys solely on SP and not FP, get sick).
 693 
</pre>
<hr />
<pre>
 695     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 696     __ load_klass(rscratch1, receiver);
 697     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 698     __ cmp(rscratch1, tmp);
 699     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 700     __ br(Assembler::EQ, ok);
 701     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 702 
 703     __ bind(ok);
 704     // Method might have been compiled since the call site was patched to
 705     // interpreted; if that is the case treat it as a miss so we can get
 706     // the call site corrected.
 707     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 708     __ cbz(rscratch1, skip_fixup);
 709     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 710     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 711   }
 712 
 713   address c2i_entry = __ pc();
 714 
<span class="line-modified"> 715   // Class initialization barrier for static methods</span>
<span class="line-modified"> 716   address c2i_no_clinit_check_entry = NULL;</span>
<span class="line-modified"> 717   if (VM_Version::supports_fast_class_init_checks()) {</span>
<span class="line-modified"> 718     Label L_skip_barrier;</span>
<span class="line-modified"> 719 </span>
<span class="line-modified"> 720     { // Bypass the barrier for non-static methods</span>
<span class="line-added"> 721       __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));</span>
<span class="line-added"> 722       __ andsw(zr, rscratch1, JVM_ACC_STATIC);</span>
<span class="line-added"> 723       __ br(Assembler::EQ, L_skip_barrier); // non-static</span>
<span class="line-added"> 724     }</span>
<span class="line-added"> 725 </span>
<span class="line-added"> 726     __ load_method_holder(rscratch2, rmethod);</span>
<span class="line-added"> 727     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);</span>
<span class="line-added"> 728     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>
<span class="line-added"> 729 </span>
<span class="line-added"> 730     __ bind(L_skip_barrier);</span>
<span class="line-added"> 731     c2i_no_clinit_check_entry = __ pc();</span>
 732   }

 733 
 734   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 735 
 736   __ flush();
<span class="line-modified"> 737   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>
 738 }
 739 
 740 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 741                                          VMRegPair *regs,
 742                                          VMRegPair *regs2,
 743                                          int total_args_passed) {
 744   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
 745 
 746 // We return the amount of VMRegImpl stack slots we need to reserve for all
 747 // the arguments NOT counting out_preserve_stack_slots.
 748 
 749     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
 750       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
 751     };
 752     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
 753       c_farg0, c_farg1, c_farg2, c_farg3,
 754       c_farg4, c_farg5, c_farg6, c_farg7
 755     };
 756 
 757     uint int_args = 0;
</pre>
<hr />
<pre>
1115   ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,
1116                     BasicType* in_sig_bt, GrowableArray&lt;int&gt;&amp; arg_order, VMRegPair tmp_vmreg) { Unimplemented(); }
1117 
1118   // Collected all the move operations
1119   void add_edge(int src_index, VMRegPair src, int dst_index, VMRegPair dst) { Unimplemented(); }
1120 
1121   // Walk the edges breaking cycles between moves.  The result list
1122   // can be walked in order to produce the proper set of loads
1123   GrowableArray&lt;MoveOperation*&gt;* get_store_order(VMRegPair temp_register) { Unimplemented(); return 0; }
1124 };
1125 
1126 
1127 static void rt_call(MacroAssembler* masm, address dest, int gpargs, int fpargs, int type) {
1128   CodeBlob *cb = CodeCache::find_blob(dest);
1129   if (cb) {
1130     __ far_call(RuntimeAddress(dest));
1131   } else {
1132     assert((unsigned)gpargs &lt; 256, &quot;eek!&quot;);
1133     assert((unsigned)fpargs &lt; 32, &quot;eek!&quot;);
1134     __ lea(rscratch1, RuntimeAddress(dest));
<span class="line-modified">1135     __ blr(rscratch1);</span>

1136     __ maybe_isb();
1137   }
1138 }
1139 
1140 static void verify_oop_args(MacroAssembler* masm,
1141                             const methodHandle&amp; method,
1142                             const BasicType* sig_bt,
1143                             const VMRegPair* regs) {
1144   Register temp_reg = r19;  // not part of any compiled calling seq
1145   if (VerifyOops) {
1146     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
1147       if (sig_bt[i] == T_OBJECT ||
1148           sig_bt[i] == T_ARRAY) {
1149         VMReg r = regs[i].first();
1150         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
1151         if (r-&gt;is_stack()) {
1152           __ ldr(temp_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1153           __ verify_oop(temp_reg);
1154         } else {
1155           __ verify_oop(r-&gt;as_Register());
</pre>
<hr />
<pre>
1235 // block and the check for pending exceptions it&#39;s impossible for them
1236 // to be thrown.
1237 //
1238 // They are roughly structured like this:
1239 //    if (GCLocker::needs_gc())
1240 //      SharedRuntime::block_for_jni_critical();
1241 //    tranistion to thread_in_native
1242 //    unpack arrray arguments and call native entry point
1243 //    check for safepoint in progress
1244 //    check if any thread suspend flags are set
1245 //      call into JVM and possible unlock the JNI critical
1246 //      if a GC was suppressed while in the critical native.
1247 //    transition back to thread_in_Java
1248 //    return to caller
1249 //
1250 nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
1251                                                 const methodHandle&amp; method,
1252                                                 int compile_id,
1253                                                 BasicType* in_sig_bt,
1254                                                 VMRegPair* in_regs,
<span class="line-modified">1255                                                 BasicType ret_type,</span>
<span class="line-modified">1256                                                 address critical_entry) {</span>

















1257   if (method-&gt;is_method_handle_intrinsic()) {
1258     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1259     intptr_t start = (intptr_t)__ pc();
1260     int vep_offset = ((intptr_t)__ pc()) - start;
1261 
1262     // First instruction must be a nop as it may need to be patched on deoptimisation
1263     __ nop();
1264     gen_special_dispatch(masm,
1265                          method,
1266                          in_sig_bt,
1267                          in_regs);
1268     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
1269     __ flush();
1270     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
1271     return nmethod::new_native_nmethod(method,
1272                                        compile_id,
1273                                        masm-&gt;code(),
1274                                        vep_offset,
1275                                        frame_complete,
1276                                        stack_slots / VMRegImpl::slots_per_word,
1277                                        in_ByteSize(-1),
1278                                        in_ByteSize(-1),
1279                                        (OopMapSet*)NULL);
1280   }
1281   bool is_critical_native = true;
<span class="line-modified">1282   address native_func = critical_entry;</span>
1283   if (native_func == NULL) {
1284     native_func = method-&gt;native_function();
1285     is_critical_native = false;
1286   }
1287   assert(native_func != NULL, &quot;must have function&quot;);
1288 
1289   // An OopMap for lock (and class if static)
1290   OopMapSet *oop_maps = new OopMapSet();
1291   intptr_t start = (intptr_t)__ pc();
1292 
1293   // We have received a description of where all the java arg are located
1294   // on entry to the wrapper. We need to convert these args to where
1295   // the jni function will expect them. To figure out where they go
1296   // we convert the java signature to a C signature by inserting
1297   // the hidden arguments as arg[0] and possibly arg[1] (static method)
1298 
1299   const int total_in_args = method-&gt;size_of_parameters();
1300   int total_c_args = total_in_args;
1301   if (!is_critical_native) {
1302     total_c_args += 1;
</pre>
<hr />
<pre>
1309         total_c_args++;
1310       }
1311     }
1312   }
1313 
1314   BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1315   VMRegPair* out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1316   BasicType* in_elem_bt = NULL;
1317 
1318   int argc = 0;
1319   if (!is_critical_native) {
1320     out_sig_bt[argc++] = T_ADDRESS;
1321     if (method-&gt;is_static()) {
1322       out_sig_bt[argc++] = T_OBJECT;
1323     }
1324 
1325     for (int i = 0; i &lt; total_in_args ; i++ ) {
1326       out_sig_bt[argc++] = in_sig_bt[i];
1327     }
1328   } else {

1329     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
1330     SignatureStream ss(method-&gt;signature());
1331     for (int i = 0; i &lt; total_in_args ; i++ ) {
1332       if (in_sig_bt[i] == T_ARRAY) {
1333         // Arrays are passed as int, elem* pair
1334         out_sig_bt[argc++] = T_INT;
1335         out_sig_bt[argc++] = T_ADDRESS;
<span class="line-modified">1336         ss.skip_array_prefix(1);  // skip one &#39;[&#39;</span>
<span class="line-modified">1337         assert(ss.is_primitive(), &quot;primitive type expected&quot;);</span>
<span class="line-modified">1338         in_elem_bt[i] = ss.type();</span>













1339       } else {
1340         out_sig_bt[argc++] = in_sig_bt[i];
1341         in_elem_bt[i] = T_VOID;
1342       }
1343       if (in_sig_bt[i] != T_VOID) {
<span class="line-modified">1344         assert(in_sig_bt[i] == ss.type() ||</span>
<span class="line-added">1345                in_sig_bt[i] == T_ARRAY, &quot;must match&quot;);</span>
1346         ss.next();
1347       }
1348     }
1349   }
1350 
1351   // Now figure out where the args must be stored and how much stack space
1352   // they require.
1353   int out_arg_slots;
1354   out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
1355 
1356   // Compute framesize for the wrapper.  We need to handlize all oops in
1357   // incoming registers
1358 
1359   // Calculate the total number of stack slots we will need.
1360 
1361   // First count the abi requirement plus all of the outgoing args
1362   int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;
1363 
1364   // Now the space for the inbound oop handle area
1365   int total_save_slots = 8 * VMRegImpl::slots_per_word;  // 8 arguments passed in registers
</pre>
<hr />
<pre>
1465   assert_different_registers(ic_reg, receiver, rscratch1);
1466   __ verify_oop(receiver);
1467   __ cmp_klass(receiver, ic_reg, rscratch1);
1468   __ br(Assembler::EQ, hit);
1469 
1470   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1471 
1472   // Verified entry point must be aligned
1473   __ align(8);
1474 
1475   __ bind(hit);
1476 
1477   int vep_offset = ((intptr_t)__ pc()) - start;
1478 
1479   // If we have to make this method not-entrant we&#39;ll overwrite its
1480   // first instruction with a jump.  For this action to be legal we
1481   // must ensure that this first instruction is a B, BL, NOP, BKPT,
1482   // SVC, HVC, or SMC.  Make it a NOP.
1483   __ nop();
1484 
<span class="line-added">1485   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {</span>
<span class="line-added">1486     Label L_skip_barrier;</span>
<span class="line-added">1487     __ mov_metadata(rscratch2, method-&gt;method_holder()); // InstanceKlass*</span>
<span class="line-added">1488     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);</span>
<span class="line-added">1489     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>
<span class="line-added">1490 </span>
<span class="line-added">1491     __ bind(L_skip_barrier);</span>
<span class="line-added">1492   }</span>
<span class="line-added">1493 </span>
1494   // Generate stack overflow check
1495   if (UseStackBanging) {
1496     __ bang_stack_with_offset(JavaThread::stack_shadow_zone_size());
1497   } else {
1498     Unimplemented();
1499   }
1500 
1501   // Generate a new frame for the wrapper.
1502   __ enter();
1503   // -2 because return address is already present and so is saved rfp
1504   __ sub(sp, sp, stack_size - 2*wordSize);
1505 
1506   // Frame is now completed as far as size and linkage.
1507   int frame_complete = ((intptr_t)__ pc()) - start;
1508 





1509   // We use r20 as the oop handle for the receiver/klass
1510   // It is callee save so it survives the call to native
1511 
1512   const Register oop_handle_reg = r20;
1513 
1514   if (is_critical_native) {
1515     check_needs_gc_for_critical_native(masm, stack_slots, total_c_args, total_in_args,
1516                                        oop_handle_offset, oop_maps, in_regs, in_sig_bt);
1517   }
1518 
1519   //
1520   // We immediately shuffle the arguments so that any vm call we have to
1521   // make from here on out (sync slow path, jvmti, etc.) we will have
1522   // captured the oops from our caller and have a valid oopMap for
1523   // them.
1524 
1525   // -----------------
1526   // The Grand Shuffle
1527 
1528   // The Java calling convention is either equal (linux) or denser (win64) than the
</pre>
<hr />
<pre>
1927     __ bind(unlock_done);
1928     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
1929       restore_native_result(masm, ret_type, stack_slots);
1930     }
1931 
1932     __ bind(done);
1933   }
1934 
1935   Label dtrace_method_exit, dtrace_method_exit_done;
1936   {
1937     unsigned long offset;
1938     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
1939     __ ldrb(rscratch1, Address(rscratch1, offset));
1940     __ cbnzw(rscratch1, dtrace_method_exit);
1941     __ bind(dtrace_method_exit_done);
1942   }
1943 
1944   __ reset_last_Java_frame(false);
1945 
1946   // Unbox oop result, e.g. JNIHandles::resolve result.
<span class="line-modified">1947   if (is_reference_type(ret_type)) {</span>
1948     __ resolve_jobject(r0, rthread, rscratch2);
1949   }
1950 
1951   if (CheckJNICalls) {
1952     // clear_pending_jni_exception_check
1953     __ str(zr, Address(rthread, JavaThread::pending_jni_exception_check_fn_offset()));
1954   }
1955 
1956   if (!is_critical_native) {
1957     // reset handle block
1958     __ ldr(r2, Address(rthread, JavaThread::active_handles_offset()));
1959     __ str(zr, Address(r2, JNIHandleBlock::top_offset_in_bytes()));
1960   }
1961 
1962   __ leave();
1963 
1964   if (!is_critical_native) {
1965     // Any exception pending?
1966     __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
1967     __ cbnz(rscratch1, exception_pending);
1968   }
1969 





1970   // We&#39;re done
1971   __ ret(lr);
1972 
1973   // Unexpected paths are out of line and go here
1974 
1975   if (!is_critical_native) {
1976     // forward the exception
1977     __ bind(exception_pending);
1978 
1979     // and forward the exception
1980     __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
1981   }
1982 
1983   // Slow path locking &amp; unlocking
1984   if (method-&gt;is_synchronized()) {
1985 
1986     __ block_comment(&quot;Slow path lock {&quot;);
1987     __ bind(slow_path_lock);
1988 
1989     // has last_Java_frame setup. No exceptions so do vanilla call not call_VM
</pre>
<hr />
<pre>
2064   __ b(reguard_done);
2065 
2066   // SLOW PATH safepoint
2067   {
2068     __ block_comment(&quot;safepoint {&quot;);
2069     __ bind(safepoint_in_progress);
2070 
2071     // Don&#39;t use call_VM as it will see a possible pending exception and forward it
2072     // and never return here preventing us from clearing _last_native_pc down below.
2073     //
2074     save_native_result(masm, ret_type, stack_slots);
2075     __ mov(c_rarg0, rthread);
2076 #ifndef PRODUCT
2077   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2078 #endif
2079     if (!is_critical_native) {
2080       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
2081     } else {
2082       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)));
2083     }
<span class="line-modified">2084     __ blr(rscratch1);</span>
2085     __ maybe_isb();
2086     // Restore any method result value
2087     restore_native_result(masm, ret_type, stack_slots);
2088 
2089     if (is_critical_native) {
2090       // The call above performed the transition to thread_in_Java so
2091       // skip the transition logic above.
2092       __ b(after_transition);
2093     }
2094 
2095     __ b(safepoint_in_progress_done);
2096     __ block_comment(&quot;} safepoint&quot;);
2097   }
2098 
2099   // SLOW PATH dtrace support
2100   {
2101     __ block_comment(&quot;dtrace entry {&quot;);
2102     __ bind(dtrace_method_entry);
2103 
2104     // We have all of the arguments setup at this point. We must not touch any register
</pre>
<hr />
<pre>
2161 }
2162 
2163 
2164 //------------------------------generate_deopt_blob----------------------------
2165 void SharedRuntime::generate_deopt_blob() {
2166   // Allocate space for the code
2167   ResourceMark rm;
2168   // Setup code generation tools
2169   int pad = 0;
2170 #if INCLUDE_JVMCI
2171   if (EnableJVMCI || UseAOT) {
2172     pad += 512; // Increase the buffer size when compiling for JVMCI
2173   }
2174 #endif
2175   CodeBuffer buffer(&quot;deopt_blob&quot;, 2048+pad, 1024);
2176   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2177   int frame_size_in_words;
2178   OopMap* map = NULL;
2179   OopMapSet *oop_maps = new OopMapSet();
2180 








2181   // -------------
2182   // This code enters when returning to a de-optimized nmethod.  A return
2183   // address has been pushed on the the stack, and return values are in
2184   // registers.
2185   // If we are doing a normal deopt then we were called from the patched
2186   // nmethod from the point we returned to the nmethod. So the return
2187   // address on the stack is wrong by NativeCall::instruction_size
2188   // We will adjust the value so it looks like we have the original return
2189   // address on the stack (like when we eagerly deoptimized).
2190   // In the case of an exception pending when deoptimizing, we enter
2191   // with a return address on the stack that points after the call we patched
2192   // into the exception handler. We have the following register state from,
2193   // e.g., the forward exception stub (see stubGenerator_x86_64.cpp).
2194   //    r0: exception oop
2195   //    r19: exception handler
2196   //    r3: throwing pc
2197   // So in this case we simply jam r3 into the useless return address and
2198   // the stack looks just like we want.
2199   //
2200   // At this point we need to de-opt.  We save the argument return
</pre>
<hr />
<pre>
2249     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2250 
2251     uncommon_trap_offset = __ pc() - start;
2252 
2253     // Save everything in sight.
2254     RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2255     // fetch_unroll_info needs to call last_java_frame()
2256     Label retaddr;
2257     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2258 
2259     __ ldrw(c_rarg1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2260     __ movw(rscratch1, -1);
2261     __ strw(rscratch1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2262 
2263     __ movw(rcpool, (int32_t)Deoptimization::Unpack_reexecute);
2264     __ mov(c_rarg0, rthread);
2265     __ movw(c_rarg2, rcpool); // exec mode
2266     __ lea(rscratch1,
2267            RuntimeAddress(CAST_FROM_FN_PTR(address,
2268                                            Deoptimization::uncommon_trap)));
<span class="line-modified">2269     __ blr(rscratch1);</span>
2270     __ bind(retaddr);
2271     oop_maps-&gt;add_gc_map( __ pc()-start, map-&gt;deep_copy());
2272 
2273     __ reset_last_Java_frame(false);
2274 
2275     __ b(after_fetch_unroll_info_call);
2276   } // EnableJVMCI
2277 #endif // INCLUDE_JVMCI
2278 
2279   int exception_offset = __ pc() - start;
2280 
2281   // Prolog for exception case
2282 
2283   // all registers are dead at this entry point, except for r0, and
2284   // r3 which contain the exception oop and exception pc
2285   // respectively.  Set them in TLS and fall thru to the
2286   // unpack_with_exception_in_tls entry point.
2287 
2288   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
2289   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
</pre>
<hr />
<pre>
2341   // crud.  We cannot block on this call, no GC can happen.
2342   //
2343   // UnrollBlock* fetch_unroll_info(JavaThread* thread)
2344 
2345   // fetch_unroll_info needs to call last_java_frame().
2346 
2347   Label retaddr;
2348   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2349 #ifdef ASSERT0
2350   { Label L;
2351     __ ldr(rscratch1, Address(rthread,
2352                               JavaThread::last_Java_fp_offset()));
2353     __ cbz(rscratch1, L);
2354     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
2355     __ bind(L);
2356   }
2357 #endif // ASSERT
2358   __ mov(c_rarg0, rthread);
2359   __ mov(c_rarg1, rcpool);
2360   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)));
<span class="line-modified">2361   __ blr(rscratch1);</span>
2362   __ bind(retaddr);
2363 
2364   // Need to have an oopmap that tells fetch_unroll_info where to
2365   // find any register it might need.
2366   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2367 
2368   __ reset_last_Java_frame(false);
2369 
2370 #if INCLUDE_JVMCI
2371   if (EnableJVMCI || UseAOT) {
2372     __ bind(after_fetch_unroll_info_call);
2373   }
2374 #endif
2375 
2376   // Load UnrollBlock* into r5
2377   __ mov(r5, r0);
2378 
2379   __ ldrw(rcpool, Address(r5, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2380    Label noException;
2381   __ cmpw(rcpool, Deoptimization::Unpack_exception);   // Was exception pending?
</pre>
<hr />
<pre>
2481   __ sub(sp, sp, (frame_size_in_words - 2) * wordSize);
2482 
2483   // Restore frame locals after moving the frame
2484   __ strd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2485   __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2486 
2487   // Call C code.  Need thread but NOT official VM entry
2488   // crud.  We cannot block on this call, no GC can happen.  Call should
2489   // restore return values to their stack-slots with the new SP.
2490   //
2491   // void Deoptimization::unpack_frames(JavaThread* thread, int exec_mode)
2492 
2493   // Use rfp because the frames look interpreted now
2494   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2495   address the_pc = __ pc();
2496   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2497 
2498   __ mov(c_rarg0, rthread);
2499   __ movw(c_rarg1, rcpool); // second arg: exec_mode
2500   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
<span class="line-modified">2501   __ blr(rscratch1);</span>
2502 
2503   // Set an oopmap for the call site
2504   // Use the same PC we used for the last java frame
2505   oop_maps-&gt;add_gc_map(the_pc - start,
2506                        new OopMap( frame_size_in_words, 0 ));
2507 
2508   // Clear fp AND pc
2509   __ reset_last_Java_frame(true);
2510 
2511   // Collect return values
2512   __ ldrd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2513   __ ldr(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2514   // I think this is useless (throwing pc?)
2515   // __ ldr(r3, Address(sp, RegisterSaver::r3_offset_in_bytes()));
2516 
2517   // Pop self-frame.
2518   __ leave();                           // Epilog
2519 
2520   // Jump to interpreter
2521   __ ret(lr);
2522 
2523   // Make sure all code is generated
2524   masm-&gt;flush();
2525 
2526   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);
2527   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
2528 #if INCLUDE_JVMCI
2529   if (EnableJVMCI || UseAOT) {
2530     _deopt_blob-&gt;set_uncommon_trap_offset(uncommon_trap_offset);
2531     _deopt_blob-&gt;set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);
2532   }
2533 #endif






2534 }
2535 
2536 uint SharedRuntime::out_preserve_stack_slots() {
2537   return 0;
2538 }
2539 
2540 #if COMPILER2_OR_JVMCI
2541 //------------------------------generate_uncommon_trap_blob--------------------
2542 void SharedRuntime::generate_uncommon_trap_blob() {
2543   // Allocate space for the code
2544   ResourceMark rm;
2545   // Setup code generation tools
2546   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
2547   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2548 








2549   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
2550 
2551   address start = __ pc();
2552 
2553   // Push self-frame.  We get here with a return address in LR
2554   // and sp should be 16 byte aligned
2555   // push rfp and retaddr by hand
2556   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
2557   // we don&#39;t expect an arg reg save area
2558 #ifndef PRODUCT
2559   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2560 #endif
2561   // compiler left unloaded_class_index in j_rarg0 move to where the
2562   // runtime expects it.
2563   if (c_rarg1 != j_rarg0) {
2564     __ movw(c_rarg1, j_rarg0);
2565   }
2566 
2567   // we need to set the past SP to the stack pointer of the stub frame
2568   // and the pc to the address where this runtime call will return
2569   // although actually any pc in this code blob will do).
2570   Label retaddr;
2571   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2572 
2573   // Call C code.  Need thread but NOT official VM entry
2574   // crud.  We cannot block on this call, no GC can happen.  Call should
2575   // capture callee-saved registers as well as return values.
2576   // Thread is in rdi already.
2577   //
2578   // UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);
2579   //
2580   // n.b. 2 gp args, 0 fp args, integral return type
2581 
2582   __ mov(c_rarg0, rthread);
2583   __ movw(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);
2584   __ lea(rscratch1,
2585          RuntimeAddress(CAST_FROM_FN_PTR(address,
2586                                          Deoptimization::uncommon_trap)));
<span class="line-modified">2587   __ blr(rscratch1);</span>
2588   __ bind(retaddr);
2589 
2590   // Set an oopmap for the call site
2591   OopMapSet* oop_maps = new OopMapSet();
2592   OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);
2593 
2594   // location of rfp is known implicitly by the frame sender code
2595 
2596   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2597 
2598   __ reset_last_Java_frame(false);
2599 
2600   // move UnrollBlock* into r4
2601   __ mov(r4, r0);
2602 
2603 #ifdef ASSERT
2604   { Label L;
2605     __ ldrw(rscratch1, Address(r4, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2606     __ cmpw(rscratch1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2607     __ br(Assembler::EQ, L);
</pre>
<hr />
<pre>
2690 
2691   // Use rfp because the frames look interpreted now
2692   // Save &quot;the_pc&quot; since it cannot easily be retrieved using the last_java_SP after we aligned SP.
2693   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2694   address the_pc = __ pc();
2695   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2696 
2697   // Call C code.  Need thread but NOT official VM entry
2698   // crud.  We cannot block on this call, no GC can happen.  Call should
2699   // restore return values to their stack-slots with the new SP.
2700   // Thread is in rdi already.
2701   //
2702   // BasicType unpack_frames(JavaThread* thread, int exec_mode);
2703   //
2704   // n.b. 2 gp args, 0 fp args, integral return type
2705 
2706   // sp should already be aligned
2707   __ mov(c_rarg0, rthread);
2708   __ movw(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2709   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
<span class="line-modified">2710   __ blr(rscratch1);</span>
2711 
2712   // Set an oopmap for the call site
2713   // Use the same PC we used for the last java frame
2714   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
2715 
2716   // Clear fp AND pc
2717   __ reset_last_Java_frame(true);
2718 
2719   // Pop self-frame.
2720   __ leave();                 // Epilog
2721 
2722   // Jump to interpreter
2723   __ ret(lr);
2724 
2725   // Make sure all code is generated
2726   masm-&gt;flush();
2727 
2728   _uncommon_trap_blob =  UncommonTrapBlob::create(&amp;buffer, oop_maps,
2729                                                  SimpleRuntimeFrame::framesize &gt;&gt; 1);







2730 }
2731 #endif // COMPILER2_OR_JVMCI
2732 
2733 
2734 //------------------------------generate_handler_blob------
2735 //
2736 // Generate a special Compile2Runtime blob that saves all registers,
2737 // and setup oopmap.
2738 //
2739 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
2740   ResourceMark rm;
2741   OopMapSet *oop_maps = new OopMapSet();
2742   OopMap* map;
2743 
2744   // Allocate space for the code.  Setup code generation tools.
2745   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
2746   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2747 
2748   address start   = __ pc();
2749   address call_pc = NULL;
2750   int frame_size_in_words;
2751   bool cause_return = (poll_type == POLL_AT_RETURN);
2752   bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
2753 
<span class="line-modified">2754   // Save Integer and Float registers.</span>
2755   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words, save_vectors);
2756 
2757   // The following is basically a call_VM.  However, we need the precise
2758   // address of the call in order to generate an oopmap. Hence, we do all the
2759   // work outselves.
2760 
2761   Label retaddr;
2762   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2763 
2764   // The return address must always be correct so that frame constructor never
2765   // sees an invalid pc.
2766 
2767   if (!cause_return) {
2768     // overwrite the return address pushed by save_live_registers
2769     // Additionally, r20 is a callee-saved register so we can look at
2770     // it later to determine if someone changed the return address for
2771     // us!
2772     __ ldr(r20, Address(rthread, JavaThread::saved_exception_pc_offset()));
2773     __ str(r20, Address(rfp, wordSize));
2774   }
2775 
2776   // Do the call
2777   __ mov(c_rarg0, rthread);
2778   __ lea(rscratch1, RuntimeAddress(call_ptr));
<span class="line-modified">2779   __ blr(rscratch1);</span>
2780   __ bind(retaddr);
2781 
2782   // Set an oopmap for the call site.  This oopmap will map all
2783   // oop-registers and debug-info registers as callee-saved.  This
2784   // will allow deoptimization at this safepoint to find all possible
2785   // debug-info recordings, as well as let GC find all oops.
2786 
2787   oop_maps-&gt;add_gc_map( __ pc() - start, map);
2788 
2789   Label noException;
2790 
2791   __ reset_last_Java_frame(false);
2792 
2793   __ maybe_isb();
2794   __ membar(Assembler::LoadLoad | Assembler::LoadStore);
2795 
2796   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2797   __ cbz(rscratch1, noException);
2798 
2799   // Exception pending
</pre>
<hr />
<pre>
2864   MacroAssembler* masm                = new MacroAssembler(&amp;buffer);
2865 
2866   int frame_size_in_words;
2867 
2868   OopMapSet *oop_maps = new OopMapSet();
2869   OopMap* map = NULL;
2870 
2871   int start = __ offset();
2872 
2873   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2874 
2875   int frame_complete = __ offset();
2876 
2877   {
2878     Label retaddr;
2879     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2880 
2881     __ mov(c_rarg0, rthread);
2882     __ lea(rscratch1, RuntimeAddress(destination));
2883 
<span class="line-modified">2884     __ blr(rscratch1);</span>
2885     __ bind(retaddr);
2886   }
2887 
2888   // Set an oopmap for the call site.
2889   // We need this not only for callee-saved registers, but also for volatile
2890   // registers that the compiler might be keeping live across a safepoint.
2891 
2892   oop_maps-&gt;add_gc_map( __ offset() - start, map);
2893 
2894   __ maybe_isb();
2895 
2896   // r0 contains the address we are going to jump to assuming no exception got installed
2897 
2898   // clear last_Java_sp
2899   __ reset_last_Java_frame(false);
2900   // check for pending exceptions
2901   Label pending;
2902   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2903   __ cbnz(rscratch1, pending);
2904 
</pre>
<hr />
<pre>
2996   // handle_exception call, since we do not want to make any assumption
2997   // about the size of the frame where the exception happened in.
2998   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
2999   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
3000 
3001   // This call does all the hard work.  It checks if an exception handler
3002   // exists in the method.
3003   // If so, it returns the handler address.
3004   // If not, it prepares for stack-unwinding, restoring the callee-save
3005   // registers of the frame being removed.
3006   //
3007   // address OptoRuntime::handle_exception_C(JavaThread* thread)
3008   //
3009   // n.b. 1 gp arg, 0 fp args, integral return type
3010 
3011   // the stack should always be aligned
3012   address the_pc = __ pc();
3013   __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);
3014   __ mov(c_rarg0, rthread);
3015   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));
<span class="line-modified">3016   __ blr(rscratch1);</span>
3017   __ maybe_isb();
3018 
3019   // Set an oopmap for the call site.  This oopmap will only be used if we
3020   // are unwinding the stack.  Hence, all locations will be dead.
3021   // Callee-saved registers will be the same as the frame above (i.e.,
3022   // handle_exception_stub), since they were restored when we got the
3023   // exception.
3024 
3025   OopMapSet* oop_maps = new OopMapSet();
3026 
3027   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
3028 
3029   __ reset_last_Java_frame(false);
3030 
3031   // Restore callee-saved registers
3032 
3033   // rfp is an implicitly saved callee saved register (i.e. the calling
3034   // convention will save restore it in prolog/epilog) Other than that
3035   // there are no callee save registers now that adapter frames are gone.
3036   // and we dont&#39; expect an arg reg save area
</pre>
</td>
</tr>
</table>
<center><a href="register_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
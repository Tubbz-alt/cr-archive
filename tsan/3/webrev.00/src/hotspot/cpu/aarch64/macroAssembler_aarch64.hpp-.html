<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2015, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
  27 #define CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
  28 
  29 #include &quot;asm/assembler.hpp&quot;
  30 
  31 // MacroAssembler extends Assembler by frequently used macros.
  32 //
  33 // Instructions for which a &#39;better&#39; code sequence exists depending
  34 // on arguments should also go in here.
  35 
  36 class MacroAssembler: public Assembler {
  37   friend class LIR_Assembler;
  38 
  39  public:
  40   using Assembler::mov;
  41   using Assembler::movi;
  42 
  43  protected:
  44 
  45   // Support for VM calls
  46   //
  47   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  48   // may customize this version by overriding it for its purposes (e.g., to save/restore
  49   // additional registers when doing a VM call).
  50   virtual void call_VM_leaf_base(
  51     address entry_point,               // the entry point
  52     int     number_of_arguments,        // the number of arguments to pop after the call
  53     Label *retaddr = NULL
  54   );
  55 
  56   virtual void call_VM_leaf_base(
  57     address entry_point,               // the entry point
  58     int     number_of_arguments,        // the number of arguments to pop after the call
  59     Label &amp;retaddr) {
  60     call_VM_leaf_base(entry_point, number_of_arguments, &amp;retaddr);
  61   }
  62 
  63   // This is the base routine called by the different versions of call_VM. The interpreter
  64   // may customize this version by overriding it for its purposes (e.g., to save/restore
  65   // additional registers when doing a VM call).
  66   //
  67   // If no java_thread register is specified (noreg) than rthread will be used instead. call_VM_base
  68   // returns the register which contains the thread upon return. If a thread register has been
  69   // specified, the return value will correspond to that register. If no last_java_sp is specified
  70   // (noreg) than rsp will be used instead.
  71   virtual void call_VM_base(           // returns the register containing the thread upon return
  72     Register oop_result,               // where an oop-result ends up if any; use noreg otherwise
  73     Register java_thread,              // the thread if computed before     ; use noreg otherwise
  74     Register last_java_sp,             // to set up last_Java_frame in stubs; use noreg otherwise
  75     address  entry_point,              // the entry point
  76     int      number_of_arguments,      // the number of arguments (w/o thread) to pop after the call
  77     bool     check_exceptions          // whether to check for pending exceptions after return
  78   );
  79 
  80   void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions = true);
  81 
  82   // True if an XOR can be used to expand narrow klass references.
  83   bool use_XOR_for_compressed_class_base;
  84 
  85  public:
  86   MacroAssembler(CodeBuffer* code) : Assembler(code) {
  87     use_XOR_for_compressed_class_base
  88       = (operand_valid_for_logical_immediate(false /*is32*/,
  89                                              (uint64_t)Universe::narrow_klass_base())
  90          &amp;&amp; ((uint64_t)Universe::narrow_klass_base()
  91              &gt; (1UL &lt;&lt; log2_intptr(Universe::narrow_klass_range()))));
  92   }
  93 
  94  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
  95  // The implementation is only non-empty for the InterpreterMacroAssembler,
  96  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
  97  virtual void check_and_handle_popframe(Register java_thread);
  98  virtual void check_and_handle_earlyret(Register java_thread);
  99 
 100   void safepoint_poll(Label&amp; slow_path);
 101   void safepoint_poll_acquire(Label&amp; slow_path);
 102 
 103   // Biased locking support
 104   // lock_reg and obj_reg must be loaded up with the appropriate values.
 105   // swap_reg is killed.
 106   // tmp_reg must be supplied and must not be rscratch1 or rscratch2
 107   // Optional slow case is for implementations (interpreter and C1) which branch to
 108   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 109   // Returns offset of first potentially-faulting instruction for null
 110   // check info (currently consumed only by C1). If
 111   // swap_reg_contains_mark is true then returns -1 as it is assumed
 112   // the calling code has already passed any potential faults.
 113   int biased_locking_enter(Register lock_reg, Register obj_reg,
 114                            Register swap_reg, Register tmp_reg,
 115                            bool swap_reg_contains_mark,
 116                            Label&amp; done, Label* slow_case = NULL,
 117                            BiasedLockingCounters* counters = NULL);
 118   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 119 
 120 
 121   // Helper functions for statistics gathering.
 122   // Unconditional atomic increment.
 123   void atomic_incw(Register counter_addr, Register tmp, Register tmp2);
 124   void atomic_incw(Address counter_addr, Register tmp1, Register tmp2, Register tmp3) {
 125     lea(tmp1, counter_addr);
 126     atomic_incw(tmp1, tmp2, tmp3);
 127   }
 128   // Load Effective Address
 129   void lea(Register r, const Address &amp;a) {
 130     InstructionMark im(this);
 131     code_section()-&gt;relocate(inst_mark(), a.rspec());
 132     a.lea(this, r);
 133   }
 134 
 135   void addmw(Address a, Register incr, Register scratch) {
 136     ldrw(scratch, a);
 137     addw(scratch, scratch, incr);
 138     strw(scratch, a);
 139   }
 140 
 141   // Add constant to memory word
 142   void addmw(Address a, int imm, Register scratch) {
 143     ldrw(scratch, a);
 144     if (imm &gt; 0)
 145       addw(scratch, scratch, (unsigned)imm);
 146     else
 147       subw(scratch, scratch, (unsigned)-imm);
 148     strw(scratch, a);
 149   }
 150 
 151   void bind(Label&amp; L) {
 152     Assembler::bind(L);
 153     code()-&gt;clear_last_insn();
 154   }
 155 
 156   void membar(Membar_mask_bits order_constraint);
 157 
 158   using Assembler::ldr;
 159   using Assembler::str;
 160 
 161   void ldr(Register Rx, const Address &amp;adr);
 162   void ldrw(Register Rw, const Address &amp;adr);
 163   void str(Register Rx, const Address &amp;adr);
 164   void strw(Register Rx, const Address &amp;adr);
 165 
 166   // Frame creation and destruction shared between JITs.
 167   void build_frame(int framesize);
 168   void remove_frame(int framesize);
 169 
 170   virtual void _call_Unimplemented(address call_site) {
 171     mov(rscratch2, call_site);
 172     haltsim();
 173   }
 174 
 175 #define call_Unimplemented() _call_Unimplemented((address)__PRETTY_FUNCTION__)
 176 
 177   virtual void notify(int type);
 178 
 179   // aliases defined in AARCH64 spec
 180 
 181   template&lt;class T&gt;
 182   inline void cmpw(Register Rd, T imm)  { subsw(zr, Rd, imm); }
 183 
 184   inline void cmp(Register Rd, unsigned char imm8)  { subs(zr, Rd, imm8); }
 185   inline void cmp(Register Rd, unsigned imm) __attribute__ ((deprecated));
 186 
 187   inline void cmnw(Register Rd, unsigned imm) { addsw(zr, Rd, imm); }
 188   inline void cmn(Register Rd, unsigned imm) { adds(zr, Rd, imm); }
 189 
 190   void cset(Register Rd, Assembler::Condition cond) {
 191     csinc(Rd, zr, zr, ~cond);
 192   }
 193   void csetw(Register Rd, Assembler::Condition cond) {
 194     csincw(Rd, zr, zr, ~cond);
 195   }
 196 
 197   void cneg(Register Rd, Register Rn, Assembler::Condition cond) {
 198     csneg(Rd, Rn, Rn, ~cond);
 199   }
 200   void cnegw(Register Rd, Register Rn, Assembler::Condition cond) {
 201     csnegw(Rd, Rn, Rn, ~cond);
 202   }
 203 
 204   inline void movw(Register Rd, Register Rn) {
 205     if (Rd == sp || Rn == sp) {
 206       addw(Rd, Rn, 0U);
 207     } else {
 208       orrw(Rd, zr, Rn);
 209     }
 210   }
 211   inline void mov(Register Rd, Register Rn) {
 212     assert(Rd != r31_sp &amp;&amp; Rn != r31_sp, &quot;should be&quot;);
 213     if (Rd == Rn) {
 214     } else if (Rd == sp || Rn == sp) {
 215       add(Rd, Rn, 0U);
 216     } else {
 217       orr(Rd, zr, Rn);
 218     }
 219   }
 220 
 221   inline void moviw(Register Rd, unsigned imm) { orrw(Rd, zr, imm); }
 222   inline void movi(Register Rd, unsigned imm) { orr(Rd, zr, imm); }
 223 
 224   inline void tstw(Register Rd, Register Rn) { andsw(zr, Rd, Rn); }
 225   inline void tst(Register Rd, Register Rn) { ands(zr, Rd, Rn); }
 226 
 227   inline void tstw(Register Rd, uint64_t imm) { andsw(zr, Rd, imm); }
 228   inline void tst(Register Rd, uint64_t imm) { ands(zr, Rd, imm); }
 229 
 230   inline void bfiw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 231     bfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 232   }
 233   inline void bfi(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 234     bfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 235   }
 236 
 237   inline void bfxilw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 238     bfmw(Rd, Rn, lsb, (lsb + width - 1));
 239   }
 240   inline void bfxil(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 241     bfm(Rd, Rn, lsb , (lsb + width - 1));
 242   }
 243 
 244   inline void sbfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 245     sbfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 246   }
 247   inline void sbfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 248     sbfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 249   }
 250 
 251   inline void sbfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 252     sbfmw(Rd, Rn, lsb, (lsb + width - 1));
 253   }
 254   inline void sbfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 255     sbfm(Rd, Rn, lsb , (lsb + width - 1));
 256   }
 257 
 258   inline void ubfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 259     ubfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 260   }
 261   inline void ubfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 262     ubfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 263   }
 264 
 265   inline void ubfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 266     ubfmw(Rd, Rn, lsb, (lsb + width - 1));
 267   }
 268   inline void ubfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 269     ubfm(Rd, Rn, lsb , (lsb + width - 1));
 270   }
 271 
 272   inline void asrw(Register Rd, Register Rn, unsigned imm) {
 273     sbfmw(Rd, Rn, imm, 31);
 274   }
 275 
 276   inline void asr(Register Rd, Register Rn, unsigned imm) {
 277     sbfm(Rd, Rn, imm, 63);
 278   }
 279 
 280   inline void lslw(Register Rd, Register Rn, unsigned imm) {
 281     ubfmw(Rd, Rn, ((32 - imm) &amp; 31), (31 - imm));
 282   }
 283 
 284   inline void lsl(Register Rd, Register Rn, unsigned imm) {
 285     ubfm(Rd, Rn, ((64 - imm) &amp; 63), (63 - imm));
 286   }
 287 
 288   inline void lsrw(Register Rd, Register Rn, unsigned imm) {
 289     ubfmw(Rd, Rn, imm, 31);
 290   }
 291 
 292   inline void lsr(Register Rd, Register Rn, unsigned imm) {
 293     ubfm(Rd, Rn, imm, 63);
 294   }
 295 
 296   inline void rorw(Register Rd, Register Rn, unsigned imm) {
 297     extrw(Rd, Rn, Rn, imm);
 298   }
 299 
 300   inline void ror(Register Rd, Register Rn, unsigned imm) {
 301     extr(Rd, Rn, Rn, imm);
 302   }
 303 
 304   inline void sxtbw(Register Rd, Register Rn) {
 305     sbfmw(Rd, Rn, 0, 7);
 306   }
 307   inline void sxthw(Register Rd, Register Rn) {
 308     sbfmw(Rd, Rn, 0, 15);
 309   }
 310   inline void sxtb(Register Rd, Register Rn) {
 311     sbfm(Rd, Rn, 0, 7);
 312   }
 313   inline void sxth(Register Rd, Register Rn) {
 314     sbfm(Rd, Rn, 0, 15);
 315   }
 316   inline void sxtw(Register Rd, Register Rn) {
 317     sbfm(Rd, Rn, 0, 31);
 318   }
 319 
 320   inline void uxtbw(Register Rd, Register Rn) {
 321     ubfmw(Rd, Rn, 0, 7);
 322   }
 323   inline void uxthw(Register Rd, Register Rn) {
 324     ubfmw(Rd, Rn, 0, 15);
 325   }
 326   inline void uxtb(Register Rd, Register Rn) {
 327     ubfm(Rd, Rn, 0, 7);
 328   }
 329   inline void uxth(Register Rd, Register Rn) {
 330     ubfm(Rd, Rn, 0, 15);
 331   }
 332   inline void uxtw(Register Rd, Register Rn) {
 333     ubfm(Rd, Rn, 0, 31);
 334   }
 335 
 336   inline void cmnw(Register Rn, Register Rm) {
 337     addsw(zr, Rn, Rm);
 338   }
 339   inline void cmn(Register Rn, Register Rm) {
 340     adds(zr, Rn, Rm);
 341   }
 342 
 343   inline void cmpw(Register Rn, Register Rm) {
 344     subsw(zr, Rn, Rm);
 345   }
 346   inline void cmp(Register Rn, Register Rm) {
 347     subs(zr, Rn, Rm);
 348   }
 349 
 350   inline void negw(Register Rd, Register Rn) {
 351     subw(Rd, zr, Rn);
 352   }
 353 
 354   inline void neg(Register Rd, Register Rn) {
 355     sub(Rd, zr, Rn);
 356   }
 357 
 358   inline void negsw(Register Rd, Register Rn) {
 359     subsw(Rd, zr, Rn);
 360   }
 361 
 362   inline void negs(Register Rd, Register Rn) {
 363     subs(Rd, zr, Rn);
 364   }
 365 
 366   inline void cmnw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 367     addsw(zr, Rn, Rm, kind, shift);
 368   }
 369   inline void cmn(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 370     adds(zr, Rn, Rm, kind, shift);
 371   }
 372 
 373   inline void cmpw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 374     subsw(zr, Rn, Rm, kind, shift);
 375   }
 376   inline void cmp(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 377     subs(zr, Rn, Rm, kind, shift);
 378   }
 379 
 380   inline void negw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 381     subw(Rd, zr, Rn, kind, shift);
 382   }
 383 
 384   inline void neg(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 385     sub(Rd, zr, Rn, kind, shift);
 386   }
 387 
 388   inline void negsw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 389     subsw(Rd, zr, Rn, kind, shift);
 390   }
 391 
 392   inline void negs(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 393     subs(Rd, zr, Rn, kind, shift);
 394   }
 395 
 396   inline void mnegw(Register Rd, Register Rn, Register Rm) {
 397     msubw(Rd, Rn, Rm, zr);
 398   }
 399   inline void mneg(Register Rd, Register Rn, Register Rm) {
 400     msub(Rd, Rn, Rm, zr);
 401   }
 402 
 403   inline void mulw(Register Rd, Register Rn, Register Rm) {
 404     maddw(Rd, Rn, Rm, zr);
 405   }
 406   inline void mul(Register Rd, Register Rn, Register Rm) {
 407     madd(Rd, Rn, Rm, zr);
 408   }
 409 
 410   inline void smnegl(Register Rd, Register Rn, Register Rm) {
 411     smsubl(Rd, Rn, Rm, zr);
 412   }
 413   inline void smull(Register Rd, Register Rn, Register Rm) {
 414     smaddl(Rd, Rn, Rm, zr);
 415   }
 416 
 417   inline void umnegl(Register Rd, Register Rn, Register Rm) {
 418     umsubl(Rd, Rn, Rm, zr);
 419   }
 420   inline void umull(Register Rd, Register Rn, Register Rm) {
 421     umaddl(Rd, Rn, Rm, zr);
 422   }
 423 
 424 #define WRAP(INSN)                                                            \
 425   void INSN(Register Rd, Register Rn, Register Rm, Register Ra) {             \
 426     if ((VM_Version::features() &amp; VM_Version::CPU_A53MAC) &amp;&amp; Ra != zr)        \
 427       nop();                                                                  \
 428     Assembler::INSN(Rd, Rn, Rm, Ra);                                          \
 429   }
 430 
 431   WRAP(madd) WRAP(msub) WRAP(maddw) WRAP(msubw)
 432   WRAP(smaddl) WRAP(smsubl) WRAP(umaddl) WRAP(umsubl)
 433 #undef WRAP
 434 
 435 
 436   // macro assembly operations needed for aarch64
 437 
 438   // first two private routines for loading 32 bit or 64 bit constants
 439 private:
 440 
 441   void mov_immediate64(Register dst, u_int64_t imm64);
 442   void mov_immediate32(Register dst, u_int32_t imm32);
 443 
 444   int push(unsigned int bitset, Register stack);
 445   int pop(unsigned int bitset, Register stack);
 446 
 447   void mov(Register dst, Address a);
 448 
 449 public:
 450   void push(RegSet regs, Register stack) { if (regs.bits()) push(regs.bits(), stack); }
 451   void pop(RegSet regs, Register stack) { if (regs.bits()) pop(regs.bits(), stack); }
 452 
 453   // Push and pop everything that might be clobbered by a native
 454   // runtime call except rscratch1 and rscratch2.  (They are always
 455   // scratch, so we don&#39;t have to protect them.)  Only save the lower
 456   // 64 bits of each vector register.
 457   void push_call_clobbered_registers();
 458   void pop_call_clobbered_registers();
 459 
 460   // now mov instructions for loading absolute addresses and 32 or
 461   // 64 bit integers
 462 
 463   inline void mov(Register dst, address addr)
 464   {
 465     mov_immediate64(dst, (u_int64_t)addr);
 466   }
 467 
 468   inline void mov(Register dst, u_int64_t imm64)
 469   {
 470     mov_immediate64(dst, imm64);
 471   }
 472 
 473   inline void movw(Register dst, u_int32_t imm32)
 474   {
 475     mov_immediate32(dst, imm32);
 476   }
 477 
 478   inline void mov(Register dst, long l)
 479   {
 480     mov(dst, (u_int64_t)l);
 481   }
 482 
 483   inline void mov(Register dst, int i)
 484   {
 485     mov(dst, (long)i);
 486   }
 487 
 488   void mov(Register dst, RegisterOrConstant src) {
 489     if (src.is_register())
 490       mov(dst, src.as_register());
 491     else
 492       mov(dst, src.as_constant());
 493   }
 494 
 495   void movptr(Register r, uintptr_t imm64);
 496 
 497   void mov(FloatRegister Vd, SIMD_Arrangement T, u_int32_t imm32);
 498 
 499   void mov(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {
 500     orr(Vd, T, Vn, Vn);
 501   }
 502 
 503 public:
 504 
 505   // Generalized Test Bit And Branch, including a &quot;far&quot; variety which
 506   // spans more than 32KiB.
 507   void tbr(Condition cond, Register Rt, int bitpos, Label &amp;dest, bool far = false) {
 508     assert(cond == EQ || cond == NE, &quot;must be&quot;);
 509 
 510     if (far)
 511       cond = ~cond;
 512 
 513     void (Assembler::* branch)(Register Rt, int bitpos, Label &amp;L);
 514     if (cond == Assembler::EQ)
 515       branch = &amp;Assembler::tbz;
 516     else
 517       branch = &amp;Assembler::tbnz;
 518 
 519     if (far) {
 520       Label L;
 521       (this-&gt;*branch)(Rt, bitpos, L);
 522       b(dest);
 523       bind(L);
 524     } else {
 525       (this-&gt;*branch)(Rt, bitpos, dest);
 526     }
 527   }
 528 
 529   // macro instructions for accessing and updating floating point
 530   // status register
 531   //
 532   // FPSR : op1 == 011
 533   //        CRn == 0100
 534   //        CRm == 0100
 535   //        op2 == 001
 536 
 537   inline void get_fpsr(Register reg)
 538   {
 539     mrs(0b11, 0b0100, 0b0100, 0b001, reg);
 540   }
 541 
 542   inline void set_fpsr(Register reg)
 543   {
 544     msr(0b011, 0b0100, 0b0100, 0b001, reg);
 545   }
 546 
 547   inline void clear_fpsr()
 548   {
 549     msr(0b011, 0b0100, 0b0100, 0b001, zr);
 550   }
 551 
 552   // DCZID_EL0: op1 == 011
 553   //            CRn == 0000
 554   //            CRm == 0000
 555   //            op2 == 111
 556   inline void get_dczid_el0(Register reg)
 557   {
 558     mrs(0b011, 0b0000, 0b0000, 0b111, reg);
 559   }
 560 
 561   // CTR_EL0:   op1 == 011
 562   //            CRn == 0000
 563   //            CRm == 0000
 564   //            op2 == 001
 565   inline void get_ctr_el0(Register reg)
 566   {
 567     mrs(0b011, 0b0000, 0b0000, 0b001, reg);
 568   }
 569 
 570   // idiv variant which deals with MINLONG as dividend and -1 as divisor
 571   int corrected_idivl(Register result, Register ra, Register rb,
 572                       bool want_remainder, Register tmp = rscratch1);
 573   int corrected_idivq(Register result, Register ra, Register rb,
 574                       bool want_remainder, Register tmp = rscratch1);
 575 
 576   // Support for NULL-checks
 577   //
 578   // Generates code that causes a NULL OS exception if the content of reg is NULL.
 579   // If the accessed location is M[reg + offset] and the offset is known, provide the
 580   // offset. No explicit code generation is needed if the offset is within a certain
 581   // range (0 &lt;= offset &lt;= page_size).
 582 
 583   virtual void null_check(Register reg, int offset = -1);
 584   static bool needs_explicit_null_check(intptr_t offset);
 585   static bool uses_implicit_null_check(void* address);
 586 
 587   static address target_addr_for_insn(address insn_addr, unsigned insn);
 588   static address target_addr_for_insn(address insn_addr) {
 589     unsigned insn = *(unsigned*)insn_addr;
 590     return target_addr_for_insn(insn_addr, insn);
 591   }
 592 
 593   // Required platform-specific helpers for Label::patch_instructions.
 594   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 595   static int pd_patch_instruction_size(address branch, address target);
 596   static void pd_patch_instruction(address branch, address target, const char* file = NULL, int line = 0) {
 597     pd_patch_instruction_size(branch, target);
 598   }
 599   static address pd_call_destination(address branch) {
 600     return target_addr_for_insn(branch);
 601   }
 602 #ifndef PRODUCT
 603   static void pd_print_patched_instruction(address branch);
 604 #endif
 605 
 606   static int patch_oop(address insn_addr, address o);
 607   static int patch_narrow_klass(address insn_addr, narrowKlass n);
 608 
 609   address emit_trampoline_stub(int insts_call_instruction_offset, address target);
 610 
 611   // The following 4 methods return the offset of the appropriate move instruction
 612 
 613   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 614   int load_unsigned_byte(Register dst, Address src);
 615   int load_unsigned_short(Register dst, Address src);
 616 
 617   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 618   int load_signed_byte(Register dst, Address src);
 619   int load_signed_short(Register dst, Address src);
 620 
 621   int load_signed_byte32(Register dst, Address src);
 622   int load_signed_short32(Register dst, Address src);
 623 
 624   // Support for sign-extension (hi:lo = extend_sign(lo))
 625   void extend_sign(Register hi, Register lo);
 626 
 627   // Load and store values by size and signed-ness
 628   void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);
 629   void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);
 630 
 631   // Support for inc/dec with optimal instruction selection depending on value
 632 
 633   // x86_64 aliases an unqualified register/address increment and
 634   // decrement to call incrementq and decrementq but also supports
 635   // explicitly sized calls to incrementq/decrementq or
 636   // incrementl/decrementl
 637 
 638   // for aarch64 the proper convention would be to use
 639   // increment/decrement for 64 bit operatons and
 640   // incrementw/decrementw for 32 bit operations. so when porting
 641   // x86_64 code we can leave calls to increment/decrement as is,
 642   // replace incrementq/decrementq with increment/decrement and
 643   // replace incrementl/decrementl with incrementw/decrementw.
 644 
 645   // n.b. increment/decrement calls with an Address destination will
 646   // need to use a scratch register to load the value to be
 647   // incremented. increment/decrement calls which add or subtract a
 648   // constant value greater than 2^12 will need to use a 2nd scratch
 649   // register to hold the constant. so, a register increment/decrement
 650   // may trash rscratch2 and an address increment/decrement trash
 651   // rscratch and rscratch2
 652 
 653   void decrementw(Address dst, int value = 1);
 654   void decrementw(Register reg, int value = 1);
 655 
 656   void decrement(Register reg, int value = 1);
 657   void decrement(Address dst, int value = 1);
 658 
 659   void incrementw(Address dst, int value = 1);
 660   void incrementw(Register reg, int value = 1);
 661 
 662   void increment(Register reg, int value = 1);
 663   void increment(Address dst, int value = 1);
 664 
 665 
 666   // Alignment
 667   void align(int modulus);
 668 
 669   // Stack frame creation/removal
 670   void enter()
 671   {
 672     stp(rfp, lr, Address(pre(sp, -2 * wordSize)));
 673     mov(rfp, sp);
 674   }
 675   void leave()
 676   {
 677     mov(sp, rfp);
 678     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
 679   }
 680 
 681   // Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)
 682   // The pointer will be loaded into the thread register.
 683   void get_thread(Register thread);
 684 
 685 
 686   // Support for VM calls
 687   //
 688   // It is imperative that all calls into the VM are handled via the call_VM macros.
 689   // They make sure that the stack linkage is setup correctly. call_VM&#39;s correspond
 690   // to ENTRY/ENTRY_X entry points while call_VM_leaf&#39;s correspond to LEAF entry points.
 691 
 692 
 693   void call_VM(Register oop_result,
 694                address entry_point,
 695                bool check_exceptions = true);
 696   void call_VM(Register oop_result,
 697                address entry_point,
 698                Register arg_1,
 699                bool check_exceptions = true);
 700   void call_VM(Register oop_result,
 701                address entry_point,
 702                Register arg_1, Register arg_2,
 703                bool check_exceptions = true);
 704   void call_VM(Register oop_result,
 705                address entry_point,
 706                Register arg_1, Register arg_2, Register arg_3,
 707                bool check_exceptions = true);
 708 
 709   // Overloadings with last_Java_sp
 710   void call_VM(Register oop_result,
 711                Register last_java_sp,
 712                address entry_point,
 713                int number_of_arguments = 0,
 714                bool check_exceptions = true);
 715   void call_VM(Register oop_result,
 716                Register last_java_sp,
 717                address entry_point,
 718                Register arg_1, bool
 719                check_exceptions = true);
 720   void call_VM(Register oop_result,
 721                Register last_java_sp,
 722                address entry_point,
 723                Register arg_1, Register arg_2,
 724                bool check_exceptions = true);
 725   void call_VM(Register oop_result,
 726                Register last_java_sp,
 727                address entry_point,
 728                Register arg_1, Register arg_2, Register arg_3,
 729                bool check_exceptions = true);
 730 
 731   void get_vm_result  (Register oop_result, Register thread);
 732   void get_vm_result_2(Register metadata_result, Register thread);
 733 
 734   // These always tightly bind to MacroAssembler::call_VM_base
 735   // bypassing the virtual implementation
 736   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments = 0, bool check_exceptions = true);
 737   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true);
 738   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
 739   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
 740   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4, bool check_exceptions = true);
 741 
 742   void call_VM_leaf(address entry_point,
 743                     int number_of_arguments = 0);
 744   void call_VM_leaf(address entry_point,
 745                     Register arg_1);
 746   void call_VM_leaf(address entry_point,
 747                     Register arg_1, Register arg_2);
 748   void call_VM_leaf(address entry_point,
 749                     Register arg_1, Register arg_2, Register arg_3);
 750 
 751   // These always tightly bind to MacroAssembler::call_VM_leaf_base
 752   // bypassing the virtual implementation
 753   void super_call_VM_leaf(address entry_point);
 754   void super_call_VM_leaf(address entry_point, Register arg_1);
 755   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
 756   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3);
 757   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4);
 758 
 759   // last Java Frame (fills frame anchor)
 760   void set_last_Java_frame(Register last_java_sp,
 761                            Register last_java_fp,
 762                            address last_java_pc,
 763                            Register scratch);
 764 
 765   void set_last_Java_frame(Register last_java_sp,
 766                            Register last_java_fp,
 767                            Label &amp;last_java_pc,
 768                            Register scratch);
 769 
 770   void set_last_Java_frame(Register last_java_sp,
 771                            Register last_java_fp,
 772                            Register last_java_pc,
 773                            Register scratch);
 774 
 775   void reset_last_Java_frame(Register thread);
 776 
 777   // thread in the default location (rthread)
 778   void reset_last_Java_frame(bool clear_fp);
 779 
 780   // Stores
 781   void store_check(Register obj);                // store check for obj - register is destroyed afterwards
 782   void store_check(Register obj, Address dst);   // same as above, dst is exact store location (reg. is destroyed)
 783 
 784   void resolve_jobject(Register value, Register thread, Register tmp);
 785 
 786   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 787   void c2bool(Register x);
 788 
 789   // oop manipulations
 790   void load_klass(Register dst, Register src);
 791   void store_klass(Register dst, Register src);
 792   void cmp_klass(Register oop, Register trial_klass, Register tmp);
 793 
 794   void resolve_oop_handle(Register result, Register tmp = r5);
 795   void load_mirror(Register dst, Register method, Register tmp = r5);
 796 
 797   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 798                       Register tmp1, Register tmp_thread);
 799 
 800   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 801                        Register tmp1, Register tmp_thread);
 802 
 803   // Resolves obj for access. Result is placed in the same register.
 804   // All other registers are preserved.
 805   void resolve(DecoratorSet decorators, Register obj);
 806 
 807   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 808                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 809 
 810   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 811                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 812   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 813                       Register tmp_thread = noreg, DecoratorSet decorators = 0);
 814 
 815   // currently unimplemented
 816   // Used for storing NULL. All other oop constants should be
 817   // stored using routines that take a jobject.
 818   void store_heap_oop_null(Address dst);
 819 
 820   void load_prototype_header(Register dst, Register src);
 821 
 822   void store_klass_gap(Register dst, Register src);
 823 
 824   // This dummy is to prevent a call to store_heap_oop from
 825   // converting a zero (like NULL) into a Register by giving
 826   // the compiler two choices it can&#39;t resolve
 827 
 828   void store_heap_oop(Address dst, void* dummy);
 829 
 830   void encode_heap_oop(Register d, Register s);
 831   void encode_heap_oop(Register r) { encode_heap_oop(r, r); }
 832   void decode_heap_oop(Register d, Register s);
 833   void decode_heap_oop(Register r) { decode_heap_oop(r, r); }
 834   void encode_heap_oop_not_null(Register r);
 835   void decode_heap_oop_not_null(Register r);
 836   void encode_heap_oop_not_null(Register dst, Register src);
 837   void decode_heap_oop_not_null(Register dst, Register src);
 838 
 839   void set_narrow_oop(Register dst, jobject obj);
 840 
 841   void encode_klass_not_null(Register r);
 842   void decode_klass_not_null(Register r);
 843   void encode_klass_not_null(Register dst, Register src);
 844   void decode_klass_not_null(Register dst, Register src);
 845 
 846   void set_narrow_klass(Register dst, Klass* k);
 847 
 848   // if heap base register is used - reinit it with the correct value
 849   void reinit_heapbase();
 850 
 851   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 852 
 853   void push_CPU_state(bool save_vectors = false);
 854   void pop_CPU_state(bool restore_vectors = false) ;
 855 
 856   // Round up to a power of two
 857   void round_to(Register reg, int modulus);
 858 
 859   // allocation
 860   void eden_allocate(
 861     Register obj,                      // result: pointer to object after successful allocation
 862     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 863     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 864     Register t1,                       // temp register
 865     Label&amp;   slow_case                 // continuation point if fast allocation fails
 866   );
 867   void tlab_allocate(
 868     Register obj,                      // result: pointer to object after successful allocation
 869     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 870     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 871     Register t1,                       // temp register
 872     Register t2,                       // temp register
 873     Label&amp;   slow_case                 // continuation point if fast allocation fails
 874   );
 875   void zero_memory(Register addr, Register len, Register t1);
 876   void verify_tlab();
 877 
 878   // interface method calling
 879   void lookup_interface_method(Register recv_klass,
 880                                Register intf_klass,
 881                                RegisterOrConstant itable_index,
 882                                Register method_result,
 883                                Register scan_temp,
 884                                Label&amp; no_such_interface,
 885                    bool return_method = true);
 886 
 887   // virtual method calling
 888   // n.b. x86 allows RegisterOrConstant for vtable_index
 889   void lookup_virtual_method(Register recv_klass,
 890                              RegisterOrConstant vtable_index,
 891                              Register method_result);
 892 
 893   // Test sub_klass against super_klass, with fast and slow paths.
 894 
 895   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 896   // One of the three labels can be NULL, meaning take the fall-through.
 897   // If super_check_offset is -1, the value is loaded up from super_klass.
 898   // No registers are killed, except temp_reg.
 899   void check_klass_subtype_fast_path(Register sub_klass,
 900                                      Register super_klass,
 901                                      Register temp_reg,
 902                                      Label* L_success,
 903                                      Label* L_failure,
 904                                      Label* L_slow_path,
 905                 RegisterOrConstant super_check_offset = RegisterOrConstant(-1));
 906 
 907   // The rest of the type check; must be wired to a corresponding fast path.
 908   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 909   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 910   // Updates the sub&#39;s secondary super cache as necessary.
 911   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 912   void check_klass_subtype_slow_path(Register sub_klass,
 913                                      Register super_klass,
 914                                      Register temp_reg,
 915                                      Register temp2_reg,
 916                                      Label* L_success,
 917                                      Label* L_failure,
 918                                      bool set_cond_codes = false);
 919 
 920   // Simplified, combined version, good for typical uses.
 921   // Falls through on failure.
 922   void check_klass_subtype(Register sub_klass,
 923                            Register super_klass,
 924                            Register temp_reg,
 925                            Label&amp; L_success);
 926 
 927   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 928 
 929 
 930   // Debugging
 931 
 932   // only if +VerifyOops
 933   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
 934   void verify_oop_addr(Address addr, const char * s = &quot;broken oop addr&quot;);
 935 
 936 // TODO: verify method and klass metadata (compare against vptr?)
 937   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 938   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 939 
 940 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 941 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 942 
 943   // only if +VerifyFPU
 944   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 945 
 946   // prints msg, dumps registers and stops execution
 947   void stop(const char* msg);
 948 
 949   // prints msg and continues
 950   void warn(const char* msg);
 951 
 952   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 953 
 954   void untested()                                { stop(&quot;untested&quot;); }
 955 
 956   void unimplemented(const char* what = &quot;&quot;);
 957 
 958   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
 959 
 960   // Stack overflow checking
 961   void bang_stack_with_offset(int offset) {
 962     // stack grows down, caller passes positive offset
 963     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
 964     sub(rscratch2, sp, offset);
 965     str(zr, Address(rscratch2));
 966   }
 967 
 968   // Writes to stack successive pages until offset reached to check for
 969   // stack overflow + shadow pages.  Also, clobbers tmp
 970   void bang_stack_size(Register size, Register tmp);
 971 
 972   // Check for reserved stack access in method being exited (for JIT)
 973   void reserved_stack_check();
 974 
 975   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
 976                                                 Register tmp,
 977                                                 int offset);
 978 
 979   // Arithmetics
 980 
 981   void addptr(const Address &amp;dst, int32_t src);
 982   void cmpptr(Register src1, Address src2);
 983 
 984   void cmpoop(Register obj1, Register obj2);
 985 
 986   // Various forms of CAS
 987 
 988   void cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,
 989                           Label &amp;suceed, Label *fail);
 990   void cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,
 991                   Label &amp;suceed, Label *fail);
 992 
 993   void cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,
 994                   Label &amp;suceed, Label *fail);
 995 
 996   void atomic_add(Register prev, RegisterOrConstant incr, Register addr);
 997   void atomic_addw(Register prev, RegisterOrConstant incr, Register addr);
 998   void atomic_addal(Register prev, RegisterOrConstant incr, Register addr);
 999   void atomic_addalw(Register prev, RegisterOrConstant incr, Register addr);
1000 
1001   void atomic_xchg(Register prev, Register newv, Register addr);
1002   void atomic_xchgw(Register prev, Register newv, Register addr);
1003   void atomic_xchgal(Register prev, Register newv, Register addr);
1004   void atomic_xchgalw(Register prev, Register newv, Register addr);
1005 
1006   void orptr(Address adr, RegisterOrConstant src) {
1007     ldr(rscratch1, adr);
1008     if (src.is_register())
1009       orr(rscratch1, rscratch1, src.as_register());
1010     else
1011       orr(rscratch1, rscratch1, src.as_constant());
1012     str(rscratch1, adr);
1013   }
1014 
1015   // A generic CAS; success or failure is in the EQ flag.
1016   // Clobbers rscratch1
1017   void cmpxchg(Register addr, Register expected, Register new_val,
1018                enum operand_size size,
1019                bool acquire, bool release, bool weak,
1020                Register result);
1021 private:
1022   void compare_eq(Register rn, Register rm, enum operand_size size);
1023 
1024 public:
1025   // Calls
1026 
1027   address trampoline_call(Address entry, CodeBuffer *cbuf = NULL);
1028 
1029   static bool far_branches() {
1030     return ReservedCodeCacheSize &gt; branch_range || UseAOT;
1031   }
1032 
1033   // Jumps that can reach anywhere in the code cache.
1034   // Trashes tmp.
1035   void far_call(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);
1036   void far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);
1037 
1038   static int far_branch_size() {
1039     if (far_branches()) {
1040       return 3 * 4;  // adrp, add, br
1041     } else {
1042       return 4;
1043     }
1044   }
1045 
1046   // Emit the CompiledIC call idiom
1047   address ic_call(address entry, jint method_index = 0);
1048 
1049 public:
1050 
1051   // Data
1052 
1053   void mov_metadata(Register dst, Metadata* obj);
1054   Address allocate_metadata_address(Metadata* obj);
1055   Address constant_oop_address(jobject obj);
1056 
1057   void movoop(Register dst, jobject obj, bool immediate = false);
1058 
1059   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1060   void kernel_crc32(Register crc, Register buf, Register len,
1061         Register table0, Register table1, Register table2, Register table3,
1062         Register tmp, Register tmp2, Register tmp3);
1063   // CRC32 code for java.util.zip.CRC32C::updateBytes() instrinsic.
1064   void kernel_crc32c(Register crc, Register buf, Register len,
1065         Register table0, Register table1, Register table2, Register table3,
1066         Register tmp, Register tmp2, Register tmp3);
1067 
1068   // Stack push and pop individual 64 bit registers
1069   void push(Register src);
1070   void pop(Register dst);
1071 
1072   // push all registers onto the stack
1073   void pusha();
1074   void popa();
1075 
1076   void repne_scan(Register addr, Register value, Register count,
1077                   Register scratch);
1078   void repne_scanw(Register addr, Register value, Register count,
1079                    Register scratch);
1080 
1081   typedef void (MacroAssembler::* add_sub_imm_insn)(Register Rd, Register Rn, unsigned imm);
1082   typedef void (MacroAssembler::* add_sub_reg_insn)(Register Rd, Register Rn, Register Rm, enum shift_kind kind, unsigned shift);
1083 
1084   // If a constant does not fit in an immediate field, generate some
1085   // number of MOV instructions and then perform the operation
1086   void wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
1087                              add_sub_imm_insn insn1,
1088                              add_sub_reg_insn insn2);
1089   // Seperate vsn which sets the flags
1090   void wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,
1091                              add_sub_imm_insn insn1,
1092                              add_sub_reg_insn insn2);
1093 
1094 #define WRAP(INSN)                                                      \
1095   void INSN(Register Rd, Register Rn, unsigned imm) {                   \
1096     wrap_add_sub_imm_insn(Rd, Rn, imm, &amp;Assembler::INSN, &amp;Assembler::INSN); \
1097   }                                                                     \
1098                                                                         \
1099   void INSN(Register Rd, Register Rn, Register Rm,                      \
1100              enum shift_kind kind, unsigned shift = 0) {                \
1101     Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \
1102   }                                                                     \
1103                                                                         \
1104   void INSN(Register Rd, Register Rn, Register Rm) {                    \
1105     Assembler::INSN(Rd, Rn, Rm);                                        \
1106   }                                                                     \
1107                                                                         \
1108   void INSN(Register Rd, Register Rn, Register Rm,                      \
1109            ext::operation option, int amount = 0) {                     \
1110     Assembler::INSN(Rd, Rn, Rm, option, amount);                        \
1111   }
1112 
1113   WRAP(add) WRAP(addw) WRAP(sub) WRAP(subw)
1114 
1115 #undef WRAP
1116 #define WRAP(INSN)                                                      \
1117   void INSN(Register Rd, Register Rn, unsigned imm) {                   \
1118     wrap_adds_subs_imm_insn(Rd, Rn, imm, &amp;Assembler::INSN, &amp;Assembler::INSN); \
1119   }                                                                     \
1120                                                                         \
1121   void INSN(Register Rd, Register Rn, Register Rm,                      \
1122              enum shift_kind kind, unsigned shift = 0) {                \
1123     Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \
1124   }                                                                     \
1125                                                                         \
1126   void INSN(Register Rd, Register Rn, Register Rm) {                    \
1127     Assembler::INSN(Rd, Rn, Rm);                                        \
1128   }                                                                     \
1129                                                                         \
1130   void INSN(Register Rd, Register Rn, Register Rm,                      \
1131            ext::operation option, int amount = 0) {                     \
1132     Assembler::INSN(Rd, Rn, Rm, option, amount);                        \
1133   }
1134 
1135   WRAP(adds) WRAP(addsw) WRAP(subs) WRAP(subsw)
1136 
1137   void add(Register Rd, Register Rn, RegisterOrConstant increment);
1138   void addw(Register Rd, Register Rn, RegisterOrConstant increment);
1139   void sub(Register Rd, Register Rn, RegisterOrConstant decrement);
1140   void subw(Register Rd, Register Rn, RegisterOrConstant decrement);
1141 
1142   void adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset);
1143 
1144   void tableswitch(Register index, jint lowbound, jint highbound,
1145                    Label &amp;jumptable, Label &amp;jumptable_end, int stride = 1) {
1146     adr(rscratch1, jumptable);
1147     subsw(rscratch2, index, lowbound);
1148     subsw(zr, rscratch2, highbound - lowbound);
1149     br(Assembler::HS, jumptable_end);
1150     add(rscratch1, rscratch1, rscratch2,
1151         ext::sxtw, exact_log2(stride * Assembler::instruction_size));
1152     br(rscratch1);
1153   }
1154 
1155   // Form an address from base + offset in Rd.  Rd may or may not
1156   // actually be used: you must use the Address that is returned.  It
1157   // is up to you to ensure that the shift provided matches the size
1158   // of your data.
1159   Address form_address(Register Rd, Register base, long byte_offset, int shift);
1160 
1161   // Return true iff an address is within the 48-bit AArch64 address
1162   // space.
1163   bool is_valid_AArch64_address(address a) {
1164     return ((uint64_t)a &gt;&gt; 48) == 0;
1165   }
1166 
1167   // Load the base of the cardtable byte map into reg.
1168   void load_byte_map_base(Register reg);
1169 
1170   // Prolog generator routines to support switch between x86 code and
1171   // generated ARM code
1172 
1173   // routine to generate an x86 prolog for a stub function which
1174   // bootstraps into the generated ARM code which directly follows the
1175   // stub
1176   //
1177 
1178   public:
1179   // enum used for aarch64--x86 linkage to define return type of x86 function
1180   enum ret_type { ret_type_void, ret_type_integral, ret_type_float, ret_type_double};
1181 
1182 #ifdef BUILTIN_SIM
1183   void c_stub_prolog(int gp_arg_count, int fp_arg_count, int ret_type, address *prolog_ptr = NULL);
1184 #else
1185   void c_stub_prolog(int gp_arg_count, int fp_arg_count, int ret_type) { }
1186 #endif
1187 
1188   // special version of call_VM_leaf_base needed for aarch64 simulator
1189   // where we need to specify both the gp and fp arg counts and the
1190   // return type so that the linkage routine from aarch64 to x86 and
1191   // back knows which aarch64 registers to copy to x86 registers and
1192   // which x86 result register to copy back to an aarch64 register
1193 
1194   void call_VM_leaf_base1(
1195     address  entry_point,             // the entry point
1196     int      number_of_gp_arguments,  // the number of gp reg arguments to pass
1197     int      number_of_fp_arguments,  // the number of fp reg arguments to pass
1198     ret_type type,                    // the return type for the call
1199     Label*   retaddr = NULL
1200   );
1201 
1202   void ldr_constant(Register dest, const Address &amp;const_addr) {
1203     if (NearCpool) {
1204       ldr(dest, const_addr);
1205     } else {
1206       unsigned long offset;
1207       adrp(dest, InternalAddress(const_addr.target()), offset);
1208       ldr(dest, Address(dest, offset));
1209     }
1210   }
1211 
1212   address read_polling_page(Register r, address page, relocInfo::relocType rtype);
1213   address read_polling_page(Register r, relocInfo::relocType rtype);
1214   void get_polling_page(Register dest, address page, relocInfo::relocType rtype);
1215 
1216   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1217   void update_byte_crc32(Register crc, Register val, Register table);
1218   void update_word_crc32(Register crc, Register v, Register tmp,
1219         Register table0, Register table1, Register table2, Register table3,
1220         bool upper = false);
1221 
1222   void string_compare(Register str1, Register str2,
1223                       Register cnt1, Register cnt2, Register result,
1224                       Register tmp1, Register tmp2, FloatRegister vtmp1,
1225                       FloatRegister vtmp2, FloatRegister vtmp3, int ae);
1226 
1227   void has_negatives(Register ary1, Register len, Register result);
1228 
1229   void arrays_equals(Register a1, Register a2, Register result, Register cnt1,
1230                      Register tmp1, Register tmp2, Register tmp3, int elem_size);
1231 
1232   void string_equals(Register a1, Register a2, Register result, Register cnt1,
1233                      int elem_size);
1234 
1235   void fill_words(Register base, Register cnt, Register value);
1236   void zero_words(Register base, u_int64_t cnt);
1237   void zero_words(Register ptr, Register cnt);
1238   void zero_dcache_blocks(Register base, Register cnt);
1239 
1240   static const int zero_words_block_size;
1241 
1242   void byte_array_inflate(Register src, Register dst, Register len,
1243                           FloatRegister vtmp1, FloatRegister vtmp2,
1244                           FloatRegister vtmp3, Register tmp4);
1245 
1246   void char_array_compress(Register src, Register dst, Register len,
1247                            FloatRegister tmp1Reg, FloatRegister tmp2Reg,
1248                            FloatRegister tmp3Reg, FloatRegister tmp4Reg,
1249                            Register result);
1250 
1251   void encode_iso_array(Register src, Register dst,
1252                         Register len, Register result,
1253                         FloatRegister Vtmp1, FloatRegister Vtmp2,
1254                         FloatRegister Vtmp3, FloatRegister Vtmp4);
1255   void string_indexof(Register str1, Register str2,
1256                       Register cnt1, Register cnt2,
1257                       Register tmp1, Register tmp2,
1258                       Register tmp3, Register tmp4,
1259                       Register tmp5, Register tmp6,
1260                       int int_cnt1, Register result, int ae);
1261   void string_indexof_char(Register str1, Register cnt1,
1262                            Register ch, Register result,
1263                            Register tmp1, Register tmp2, Register tmp3);
1264   void fast_log(FloatRegister vtmp0, FloatRegister vtmp1, FloatRegister vtmp2,
1265                 FloatRegister vtmp3, FloatRegister vtmp4, FloatRegister vtmp5,
1266                 FloatRegister tmpC1, FloatRegister tmpC2, FloatRegister tmpC3,
1267                 FloatRegister tmpC4, Register tmp1, Register tmp2,
1268                 Register tmp3, Register tmp4, Register tmp5);
1269   void generate_dsin_dcos(bool isCos, address npio2_hw, address two_over_pi,
1270       address pio2, address dsin_coef, address dcos_coef);
1271  private:
1272   // begin trigonometric functions support block
1273   void generate__ieee754_rem_pio2(address npio2_hw, address two_over_pi, address pio2);
1274   void generate__kernel_rem_pio2(address two_over_pi, address pio2);
1275   void generate_kernel_sin(FloatRegister x, bool iyIsOne, address dsin_coef);
1276   void generate_kernel_cos(FloatRegister x, address dcos_coef);
1277   // end trigonometric functions support block
1278   void add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,
1279                        Register src1, Register src2);
1280   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
1281     add2_with_carry(dest_hi, dest_hi, dest_lo, src1, src2);
1282   }
1283   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1284                              Register y, Register y_idx, Register z,
1285                              Register carry, Register product,
1286                              Register idx, Register kdx);
1287   void multiply_128_x_128_loop(Register y, Register z,
1288                                Register carry, Register carry2,
1289                                Register idx, Register jdx,
1290                                Register yz_idx1, Register yz_idx2,
1291                                Register tmp, Register tmp3, Register tmp4,
1292                                Register tmp7, Register product_hi);
1293   void kernel_crc32_using_crc32(Register crc, Register buf,
1294         Register len, Register tmp0, Register tmp1, Register tmp2,
1295         Register tmp3);
1296   void kernel_crc32c_using_crc32c(Register crc, Register buf,
1297         Register len, Register tmp0, Register tmp1, Register tmp2,
1298         Register tmp3);
1299 public:
1300   void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z,
1301                        Register zlen, Register tmp1, Register tmp2, Register tmp3,
1302                        Register tmp4, Register tmp5, Register tmp6, Register tmp7);
1303   void mul_add(Register out, Register in, Register offs, Register len, Register k);
1304   // ISB may be needed because of a safepoint
1305   void maybe_isb() { isb(); }
1306 
1307 private:
1308   // Return the effective address r + (r1 &lt;&lt; ext) + offset.
1309   // Uses rscratch2.
1310   Address offsetted_address(Register r, Register r1, Address::extend ext,
1311                             int offset, int size);
1312 
1313 private:
1314   // Returns an address on the stack which is reachable with a ldr/str of size
1315   // Uses rscratch2 if the address is not directly reachable
1316   Address spill_address(int size, int offset, Register tmp=rscratch2);
1317 
1318   bool merge_alignment_check(Register base, size_t size, long cur_offset, long prev_offset) const;
1319 
1320   // Check whether two loads/stores can be merged into ldp/stp.
1321   bool ldst_can_merge(Register rx, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store) const;
1322 
1323   // Merge current load/store with previous load/store into ldp/stp.
1324   void merge_ldst(Register rx, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store);
1325 
1326   // Try to merge two loads/stores into ldp/stp. If success, returns true else false.
1327   bool try_merge_ldst(Register rt, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store);
1328 
1329 public:
1330   void spill(Register Rx, bool is64, int offset) {
1331     if (is64) {
1332       str(Rx, spill_address(8, offset));
1333     } else {
1334       strw(Rx, spill_address(4, offset));
1335     }
1336   }
1337   void spill(FloatRegister Vx, SIMD_RegVariant T, int offset) {
1338     str(Vx, T, spill_address(1 &lt;&lt; (int)T, offset));
1339   }
1340   void unspill(Register Rx, bool is64, int offset) {
1341     if (is64) {
1342       ldr(Rx, spill_address(8, offset));
1343     } else {
1344       ldrw(Rx, spill_address(4, offset));
1345     }
1346   }
1347   void unspill(FloatRegister Vx, SIMD_RegVariant T, int offset) {
1348     ldr(Vx, T, spill_address(1 &lt;&lt; (int)T, offset));
1349   }
1350   void spill_copy128(int src_offset, int dst_offset,
1351                      Register tmp1=rscratch1, Register tmp2=rscratch2) {
1352     if (src_offset &lt; 512 &amp;&amp; (src_offset &amp; 7) == 0 &amp;&amp;
1353         dst_offset &lt; 512 &amp;&amp; (dst_offset &amp; 7) == 0) {
1354       ldp(tmp1, tmp2, Address(sp, src_offset));
1355       stp(tmp1, tmp2, Address(sp, dst_offset));
1356     } else {
1357       unspill(tmp1, true, src_offset);
1358       spill(tmp1, true, dst_offset);
1359       unspill(tmp1, true, src_offset+8);
1360       spill(tmp1, true, dst_offset+8);
1361     }
1362   }
1363 };
1364 
1365 #ifdef ASSERT
1366 inline bool AbstractAssembler::pd_check_instruction_mark() { return false; }
1367 #endif
1368 
1369 /**
1370  * class SkipIfEqual:
1371  *
1372  * Instantiating this class will result in assembly code being output that will
1373  * jump around any code emitted between the creation of the instance and it&#39;s
1374  * automatic destruction at the end of a scope block, depending on the value of
1375  * the flag passed to the constructor, which will be checked at run-time.
1376  */
1377 class SkipIfEqual {
1378  private:
1379   MacroAssembler* _masm;
1380   Label _label;
1381 
1382  public:
1383    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1384    ~SkipIfEqual();
1385 };
1386 
1387 struct tableswitch {
1388   Register _reg;
1389   int _insn_index; jint _first_key; jint _last_key;
1390   Label _after;
1391   Label _branches;
1392 };
1393 
1394 #endif // CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
    </pre>
  </body>
</html>
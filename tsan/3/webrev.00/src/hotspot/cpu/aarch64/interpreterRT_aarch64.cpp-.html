<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;interpreter/interp_masm.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 31 #include &quot;memory/allocation.inline.hpp&quot;
 32 #include &quot;memory/universe.hpp&quot;
 33 #include &quot;oops/method.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 #include &quot;runtime/icache.hpp&quot;
 37 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 38 #include &quot;runtime/signature.hpp&quot;
 39 
 40 #define __ _masm-&gt;
 41 
 42 // Implementation of SignatureHandlerGenerator
 43 Register InterpreterRuntime::SignatureHandlerGenerator::from() { return rlocals; }
 44 Register InterpreterRuntime::SignatureHandlerGenerator::to()   { return sp; }
 45 Register InterpreterRuntime::SignatureHandlerGenerator::temp() { return rscratch1; }
 46 
 47 InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 48       const methodHandle&amp; method, CodeBuffer* buffer) : NativeSignatureIterator(method) {
 49   _masm = new MacroAssembler(buffer);
 50   _num_int_args = (method-&gt;is_static() ? 1 : 0);
 51   _num_fp_args = 0;
 52   _stack_offset = 0;
 53 }
 54 
 55 void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
 56   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 57 
 58   switch (_num_int_args) {
 59   case 0:
 60     __ ldr(c_rarg1, src);
 61     _num_int_args++;
 62     break;
 63   case 1:
 64     __ ldr(c_rarg2, src);
 65     _num_int_args++;
 66     break;
 67   case 2:
 68     __ ldr(c_rarg3, src);
 69     _num_int_args++;
 70     break;
 71   case 3:
 72     __ ldr(c_rarg4, src);
 73     _num_int_args++;
 74     break;
 75   case 4:
 76     __ ldr(c_rarg5, src);
 77     _num_int_args++;
 78     break;
 79   case 5:
 80     __ ldr(c_rarg6, src);
 81     _num_int_args++;
 82     break;
 83   case 6:
 84     __ ldr(c_rarg7, src);
 85     _num_int_args++;
 86     break;
 87   default:
 88     __ ldr(r0, src);
 89     __ str(r0, Address(to(), _stack_offset));
 90     _stack_offset += wordSize;
 91     _num_int_args++;
 92     break;
 93   }
 94 }
 95 
 96 void InterpreterRuntime::SignatureHandlerGenerator::pass_long() {
 97   const Address src(from(), Interpreter::local_offset_in_bytes(offset() + 1));
 98 
 99   switch (_num_int_args) {
100   case 0:
101     __ ldr(c_rarg1, src);
102     _num_int_args++;
103     break;
104   case 1:
105     __ ldr(c_rarg2, src);
106     _num_int_args++;
107     break;
108   case 2:
109     __ ldr(c_rarg3, src);
110     _num_int_args++;
111     break;
112   case 3:
113     __ ldr(c_rarg4, src);
114     _num_int_args++;
115     break;
116   case 4:
117     __ ldr(c_rarg5, src);
118     _num_int_args++;
119     break;
120   case 5:
121     __ ldr(c_rarg6, src);
122     _num_int_args++;
123     break;
124   case 6:
125     __ ldr(c_rarg7, src);
126     _num_int_args++;
127     break;
128   default:
129     __ ldr(r0, src);
130     __ str(r0, Address(to(), _stack_offset));
131     _stack_offset += wordSize;
132     _num_int_args++;
133     break;
134   }
135 }
136 
137 void InterpreterRuntime::SignatureHandlerGenerator::pass_float() {
138   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
139 
140   if (_num_fp_args &lt; Argument::n_float_register_parameters_c) {
141     __ ldrs(as_FloatRegister(_num_fp_args++), src);
142   } else {
143     __ ldrw(r0, src);
144     __ strw(r0, Address(to(), _stack_offset));
145     _stack_offset += wordSize;
146     _num_fp_args++;
147   }
148 }
149 
150 void InterpreterRuntime::SignatureHandlerGenerator::pass_double() {
151   const Address src(from(), Interpreter::local_offset_in_bytes(offset() + 1));
152 
153   if (_num_fp_args &lt; Argument::n_float_register_parameters_c) {
154     __ ldrd(as_FloatRegister(_num_fp_args++), src);
155   } else {
156     __ ldr(r0, src);
157     __ str(r0, Address(to(), _stack_offset));
158     _stack_offset += wordSize;
159     _num_fp_args++;
160   }
161 }
162 
163 void InterpreterRuntime::SignatureHandlerGenerator::pass_object() {
164 
165   switch (_num_int_args) {
166   case 0:
167     assert(offset() == 0, &quot;argument register 1 can only be (non-null) receiver&quot;);
168     __ add(c_rarg1, from(), Interpreter::local_offset_in_bytes(offset()));
169     _num_int_args++;
170     break;
171   case 1:
172     {
173       __ add(r0, from(), Interpreter::local_offset_in_bytes(offset()));
174       __ mov(c_rarg2, 0);
175       __ ldr(temp(), r0);
176       Label L;
177       __ cbz(temp(), L);
178       __ mov(c_rarg2, r0);
179       __ bind(L);
180       _num_int_args++;
181       break;
182     }
183   case 2:
184     {
185       __ add(r0, from(), Interpreter::local_offset_in_bytes(offset()));
186       __ mov(c_rarg3, 0);
187       __ ldr(temp(), r0);
188       Label L;
189       __ cbz(temp(), L);
190       __ mov(c_rarg3, r0);
191       __ bind(L);
192       _num_int_args++;
193       break;
194     }
195   case 3:
196     {
197       __ add(r0, from(), Interpreter::local_offset_in_bytes(offset()));
198       __ mov(c_rarg4, 0);
199       __ ldr(temp(), r0);
200       Label L;
201       __ cbz(temp(), L);
202       __ mov(c_rarg4, r0);
203       __ bind(L);
204       _num_int_args++;
205       break;
206     }
207   case 4:
208     {
209       __ add(r0, from(), Interpreter::local_offset_in_bytes(offset()));
210       __ mov(c_rarg5, 0);
211       __ ldr(temp(), r0);
212       Label L;
213       __ cbz(temp(), L);
214       __ mov(c_rarg5, r0);
215       __ bind(L);
216       _num_int_args++;
217       break;
218     }
219   case 5:
220     {
221       __ add(r0, from(), Interpreter::local_offset_in_bytes(offset()));
222       __ mov(c_rarg6, 0);
223       __ ldr(temp(), r0);
224       Label L;
225       __ cbz(temp(), L);
226       __ mov(c_rarg6, r0);
227       __ bind(L);
228       _num_int_args++;
229       break;
230     }
231   case 6:
232     {
233       __ add(r0, from(), Interpreter::local_offset_in_bytes(offset()));
234       __ mov(c_rarg7, 0);
235       __ ldr(temp(), r0);
236       Label L;
237       __ cbz(temp(), L);
238       __ mov(c_rarg7, r0);
239       __ bind(L);
240       _num_int_args++;
241       break;
242     }
243  default:
244    {
245       __ add(r0, from(), Interpreter::local_offset_in_bytes(offset()));
246       __ ldr(temp(), r0);
247       Label L;
248       __ cbnz(temp(), L);
249       __ mov(r0, zr);
250       __ bind(L);
251       __ str(r0, Address(to(), _stack_offset));
252       _stack_offset += wordSize;
253       _num_int_args++;
254       break;
255    }
256   }
257 }
258 
259 void InterpreterRuntime::SignatureHandlerGenerator::generate(uint64_t fingerprint) {
260   // generate code to handle arguments
261   iterate(fingerprint);
262 
263   // set the call format
264   // n.b. allow extra 1 for the JNI_Env in c_rarg0
265   unsigned int call_format = ((_num_int_args + 1) &lt;&lt; 6) | (_num_fp_args &lt;&lt; 2);
266 
267   switch (method()-&gt;result_type()) {
268   case T_VOID:
269     call_format |= MacroAssembler::ret_type_void;
270     break;
271   case T_FLOAT:
272     call_format |= MacroAssembler::ret_type_float;
273     break;
274   case T_DOUBLE:
275     call_format |= MacroAssembler::ret_type_double;
276     break;
277   default:
278     call_format |= MacroAssembler::ret_type_integral;
279     break;
280   }
281 
282   // // store the call format in the method
283   // __ movw(r0, call_format);
284   // __ str(r0, Address(rmethod, Method::call_format_offset()));
285 
286   // return result handler
287   __ lea(r0, ExternalAddress(Interpreter::result_handler(method()-&gt;result_type())));
288   __ ret(lr);
289 
290   __ flush();
291 }
292 
293 
294 // Implementation of SignatureHandlerLibrary
295 
296 void SignatureHandlerLibrary::pd_set_handler(address handler) {}
297 
298 
299 class SlowSignatureHandler
300   : public NativeSignatureIterator {
301  private:
302   address   _from;
303   intptr_t* _to;
304   intptr_t* _int_args;
305   intptr_t* _fp_args;
306   intptr_t* _fp_identifiers;
307   unsigned int _num_int_args;
308   unsigned int _num_fp_args;
309 
310   virtual void pass_int()
311   {
312     jint from_obj = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
313     _from -= Interpreter::stackElementSize;
314 
315     if (_num_int_args &lt; Argument::n_int_register_parameters_c-1) {
316       *_int_args++ = from_obj;
317       _num_int_args++;
318     } else {
319       *_to++ = from_obj;
320       _num_int_args++;
321     }
322   }
323 
324   virtual void pass_long()
325   {
326     intptr_t from_obj = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(1));
327     _from -= 2*Interpreter::stackElementSize;
328 
329     if (_num_int_args &lt; Argument::n_int_register_parameters_c-1) {
330       *_int_args++ = from_obj;
331       _num_int_args++;
332     } else {
333       *_to++ = from_obj;
334       _num_int_args++;
335     }
336   }
337 
338   virtual void pass_object()
339   {
340     intptr_t *from_addr = (intptr_t*)(_from + Interpreter::local_offset_in_bytes(0));
341     _from -= Interpreter::stackElementSize;
342 
343     if (_num_int_args &lt; Argument::n_int_register_parameters_c-1) {
344       *_int_args++ = (*from_addr == 0) ? NULL : (intptr_t)from_addr;
345       _num_int_args++;
346     } else {
347       *_to++ = (*from_addr == 0) ? NULL : (intptr_t) from_addr;
348       _num_int_args++;
349     }
350   }
351 
352   virtual void pass_float()
353   {
354     jint from_obj = *(jint*)(_from+Interpreter::local_offset_in_bytes(0));
355     _from -= Interpreter::stackElementSize;
356 
357     if (_num_fp_args &lt; Argument::n_float_register_parameters_c) {
358       *_fp_args++ = from_obj;
359       _num_fp_args++;
360     } else {
361       *_to++ = from_obj;
362       _num_fp_args++;
363     }
364   }
365 
366   virtual void pass_double()
367   {
368     intptr_t from_obj = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(1));
369     _from -= 2*Interpreter::stackElementSize;
370 
371     if (_num_fp_args &lt; Argument::n_float_register_parameters_c) {
372       *_fp_args++ = from_obj;
373       *_fp_identifiers |= (1 &lt;&lt; _num_fp_args); // mark as double
374       _num_fp_args++;
375     } else {
376       *_to++ = from_obj;
377       _num_fp_args++;
378     }
379   }
380 
381  public:
382   SlowSignatureHandler(const methodHandle&amp; method, address from, intptr_t* to)
383     : NativeSignatureIterator(method)
384   {
385     _from = from;
386     _to   = to;
387 
388     _int_args = to - (method-&gt;is_static() ? 16 : 17);
389     _fp_args =  to - 8;
390     _fp_identifiers = to - 9;
391     *(int*) _fp_identifiers = 0;
392     _num_int_args = (method-&gt;is_static() ? 1 : 0);
393     _num_fp_args = 0;
394   }
395 
396   // n.b. allow extra 1 for the JNI_Env in c_rarg0
397   unsigned int get_call_format()
398   {
399     unsigned int call_format = ((_num_int_args + 1) &lt;&lt; 6) | (_num_fp_args &lt;&lt; 2);
400 
401     switch (method()-&gt;result_type()) {
402     case T_VOID:
403       call_format |= MacroAssembler::ret_type_void;
404       break;
405     case T_FLOAT:
406       call_format |= MacroAssembler::ret_type_float;
407       break;
408     case T_DOUBLE:
409       call_format |= MacroAssembler::ret_type_double;
410       break;
411     default:
412       call_format |= MacroAssembler::ret_type_integral;
413       break;
414     }
415 
416     return call_format;
417   }
418 };
419 
420 
421 IRT_ENTRY(address,
422           InterpreterRuntime::slow_signature_handler(JavaThread* thread,
423                                                      Method* method,
424                                                      intptr_t* from,
425                                                      intptr_t* to))
426   methodHandle m(thread, (Method*)method);
427   assert(m-&gt;is_native(), &quot;sanity check&quot;);
428 
429   // handle arguments
430   SlowSignatureHandler ssh(m, (address)from, to);
431   ssh.iterate(UCONST64(-1));
432 
433   // // set the call format
434   // method-&gt;set_call_format(ssh.get_call_format());
435 
436   // return result handler
437   return Interpreter::result_handler(m-&gt;result_type());
438 IRT_END
    </pre>
  </body>
</html>
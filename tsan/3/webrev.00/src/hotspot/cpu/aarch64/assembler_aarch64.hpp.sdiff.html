<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/assembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_FrameMap_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/assembler_aarch64.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2014, 2015, Red Hat Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
 259     f(r-&gt;encoding_nocheck(), lsb + 4, lsb);
 260   }
 261 
 262   // reg|ZR
 263   void zrf(Register r, int lsb) {
 264     f(r-&gt;encoding_nocheck() - (r == zr), lsb + 4, lsb);
 265   }
 266 
 267   // reg|SP
 268   void srf(Register r, int lsb) {
 269     f(r == sp ? 31 : r-&gt;encoding_nocheck(), lsb + 4, lsb);
 270   }
 271 
 272   void rf(FloatRegister r, int lsb) {
 273     f(r-&gt;encoding_nocheck(), lsb + 4, lsb);
 274   }
 275 
 276   unsigned get(int msb = 31, int lsb = 0) {
 277     int nbits = msb - lsb + 1;
 278     unsigned mask = ((1U &lt;&lt; nbits) - 1) &lt;&lt; lsb;
<span class="line-modified"> 279     assert_cond(bits &amp; mask == mask);</span>
 280     return (insn &amp; mask) &gt;&gt; lsb;
 281   }
 282 
 283   void fixed(unsigned value, unsigned mask) {
 284     assert_cond ((mask &amp; bits) == 0);
 285 #ifdef ASSERT
 286     bits |= mask;
 287 #endif
 288     insn |= value;
 289   }
 290 };
 291 
 292 #define starti Instruction_aarch64 do_not_use(this); set_current(&amp;do_not_use)
 293 
 294 class PrePost {
 295   int _offset;
 296   Register _r;
 297 public:
 298   PrePost(Register reg, int o) : _offset(o), _r(reg) { }
 299   int offset() { return _offset; }
 300   Register reg() { return _r; }
 301 };
 302 
 303 class Pre : public PrePost {
 304 public:
 305   Pre(Register reg, int o) : PrePost(reg, o) { }
 306 };
 307 class Post : public PrePost {
 308   Register _idx;

 309 public:
<span class="line-modified"> 310   Post(Register reg, int o) : PrePost(reg, o) { _idx = NULL; }</span>
<span class="line-modified"> 311   Post(Register reg, Register idx) : PrePost(reg, 0) { _idx = idx; }</span>
 312   Register idx_reg() { return _idx; }

 313 };
 314 
 315 namespace ext
 316 {
 317   enum operation { uxtb, uxth, uxtw, uxtx, sxtb, sxth, sxtw, sxtx };
 318 };
 319 
 320 // Addressing modes
 321 class Address {
 322  public:
 323 
 324   enum mode { no_mode, base_plus_offset, pre, post, post_reg, pcrel,
 325               base_plus_offset_reg, literal };
 326 
 327   // Shift and extend for base reg + reg offset addressing
 328   class extend {
 329     int _option, _shift;
 330     ext::operation _op;
 331   public:
 332     extend() { }
</pre>
<hr />
<pre>
 376     : _mode(no_mode) { }
 377   Address(Register r)
 378     : _base(r), _index(noreg), _offset(0), _mode(base_plus_offset), _target(0) { }
 379   Address(Register r, int o)
 380     : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }
 381   Address(Register r, long o)
 382     : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }
 383   Address(Register r, unsigned long o)
 384     : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }
 385 #ifdef ASSERT
 386   Address(Register r, ByteSize disp)
 387     : _base(r), _index(noreg), _offset(in_bytes(disp)), _mode(base_plus_offset), _target(0) { }
 388 #endif
 389   Address(Register r, Register r1, extend ext = lsl())
 390     : _base(r), _index(r1), _offset(0), _mode(base_plus_offset_reg),
 391       _ext(ext), _target(0) { }
 392   Address(Pre p)
 393     : _base(p.reg()), _offset(p.offset()), _mode(pre) { }
 394   Address(Post p)
 395     : _base(p.reg()),  _index(p.idx_reg()), _offset(p.offset()),
<span class="line-modified"> 396       _mode(p.idx_reg() == NULL ? post : post_reg), _target(0) { }</span>
 397   Address(address target, RelocationHolder const&amp; rspec)
 398     : _mode(literal),
 399       _rspec(rspec),
 400       _is_lval(false),
 401       _target(target)  { }
 402   Address(address target, relocInfo::relocType rtype = relocInfo::external_word_type);
 403   Address(Register base, RegisterOrConstant index, extend ext = lsl())
 404     : _base (base),
 405       _offset(0), _ext(ext), _target(0) {
 406     if (index.is_register()) {
 407       _mode = base_plus_offset_reg;
 408       _index = index.as_register();
 409     } else {
 410       guarantee(ext.option() == ext::uxtx, &quot;should be&quot;);
 411       assert(index.is_constant(), &quot;should be&quot;);
 412       _mode = base_plus_offset;
 413       _offset = index.as_constant() &lt;&lt; ext.shift();
 414     }
 415   }
 416 
</pre>
<hr />
<pre>
 535     size = 4 &lt;&lt; size;
 536     guarantee(_offset % size == 0, &quot;bad offset&quot;);
 537     i-&gt;sf(_offset / size, 21, 15);
 538     i-&gt;srf(_base, 5);
 539   }
 540 
 541   void encode_nontemporal_pair(Instruction_aarch64 *i) const {
 542     // Only base + offset is allowed
 543     i-&gt;f(0b000, 25, 23);
 544     unsigned size = i-&gt;get(31, 31);
 545     size = 4 &lt;&lt; size;
 546     guarantee(_offset % size == 0, &quot;bad offset&quot;);
 547     i-&gt;sf(_offset / size, 21, 15);
 548     i-&gt;srf(_base, 5);
 549     guarantee(_mode == Address::base_plus_offset,
 550               &quot;Bad addressing mode for non-temporal op&quot;);
 551   }
 552 
 553   void lea(MacroAssembler *, Register) const;
 554 
<span class="line-modified"> 555   static bool offset_ok_for_immed(long offset, int shift = 0) {</span>
 556     unsigned mask = (1 &lt;&lt; shift) - 1;
 557     if (offset &lt; 0 || offset &amp; mask) {
 558       return (uabs(offset) &lt; (1 &lt;&lt; (20 - 12))); // Unscaled offset
 559     } else {
 560       return ((offset &gt;&gt; shift) &lt; (1 &lt;&lt; (21 - 10 + 1))); // Scaled, unsigned offset
 561     }
 562   }
 563 };
 564 
 565 // Convience classes
 566 class RuntimeAddress: public Address {
 567 
 568   public:
 569 
 570   RuntimeAddress(address target) : Address(target, relocInfo::runtime_call_type) {}
 571 
 572 };
 573 
 574 class OopAddress: public Address {
 575 
</pre>
<hr />
<pre>
 585     // Sometimes ExternalAddress is used for values which aren&#39;t
 586     // exactly addresses, like the card table base.
 587     // external_word_type can&#39;t be used for values in the first page
 588     // so just skip the reloc in that case.
 589     return external_word_Relocation::can_be_relocated(target) ? relocInfo::external_word_type : relocInfo::none;
 590   }
 591 
 592  public:
 593 
 594   ExternalAddress(address target) : Address(target, reloc_for_target(target)) {}
 595 
 596 };
 597 
 598 class InternalAddress: public Address {
 599 
 600   public:
 601 
 602   InternalAddress(address target) : Address(target, relocInfo::internal_word_type) {}
 603 };
 604 
<span class="line-modified"> 605 const int FPUStateSizeInWords = 32 * 2;</span>


 606 typedef enum {
 607   PLDL1KEEP = 0b00000, PLDL1STRM, PLDL2KEEP, PLDL2STRM, PLDL3KEEP, PLDL3STRM,
 608   PSTL1KEEP = 0b10000, PSTL1STRM, PSTL2KEEP, PSTL2STRM, PSTL3KEEP, PSTL3STRM,
 609   PLIL1KEEP = 0b01000, PLIL1STRM, PLIL2KEEP, PLIL2STRM, PLIL3KEEP, PLIL3STRM
 610 } prfop;
 611 
 612 class Assembler : public AbstractAssembler {
 613 
 614 #ifndef PRODUCT
 615   static const unsigned long asm_bp;
 616 
 617   void emit_long(jint x) {
 618     if ((unsigned long)pc() == asm_bp)
 619       asm volatile (&quot;nop&quot;);
 620     AbstractAssembler::emit_int32(x);
 621   }
 622 #else
 623   void emit_long(jint x) {
 624     AbstractAssembler::emit_int32(x);
 625   }
 626 #endif
 627 
 628 public:
 629 
 630   enum { instruction_size = 4 };
 631 








 632   Address adjust(Register base, int offset, bool preIncrement) {
 633     if (preIncrement)
 634       return Address(Pre(base, offset));
 635     else
 636       return Address(Post(base, offset));
 637   }
 638 
 639   Address pre(Register base, int offset) {
 640     return adjust(base, offset, true);
 641   }
 642 
 643   Address post(Register base, int offset) {
 644     return adjust(base, offset, false);
 645   }
 646 
 647   Address post(Register base, Register idx) {
 648     return Address(Post(base, idx));
 649   }
 650 
 651   Instruction_aarch64* current;
</pre>
<hr />
<pre>
 782   // Move wide (immediate)
 783 #define INSN(NAME, opcode)                                              \
 784   void NAME(Register Rd, unsigned imm, unsigned shift = 0) {            \
 785     assert_cond((shift/16)*16 == shift);                                \
 786     starti;                                                             \
 787     f(opcode, 31, 29), f(0b100101, 28, 23), f(shift/16, 22, 21),        \
 788       f(imm, 20, 5);                                                    \
 789     rf(Rd, 0);                                                          \
 790   }
 791 
 792   INSN(movnw, 0b000);
 793   INSN(movzw, 0b010);
 794   INSN(movkw, 0b011);
 795   INSN(movn, 0b100);
 796   INSN(movz, 0b110);
 797   INSN(movk, 0b111);
 798 
 799 #undef INSN
 800 
 801   // Bitfield
<span class="line-modified"> 802 #define INSN(NAME, opcode)                                              \</span>
 803   void NAME(Register Rd, Register Rn, unsigned immr, unsigned imms) {   \
 804     starti;                                                             \

 805     f(opcode, 31, 22), f(immr, 21, 16), f(imms, 15, 10);                \
 806     zrf(Rn, 5), rf(Rd, 0);                                              \
 807   }
 808 
<span class="line-modified"> 809   INSN(sbfmw, 0b0001001100);</span>
<span class="line-modified"> 810   INSN(bfmw,  0b0011001100);</span>
<span class="line-modified"> 811   INSN(ubfmw, 0b0101001100);</span>
<span class="line-modified"> 812   INSN(sbfm,  0b1001001101);</span>
<span class="line-modified"> 813   INSN(bfm,   0b1011001101);</span>
<span class="line-modified"> 814   INSN(ubfm,  0b1101001101);</span>
 815 
 816 #undef INSN
 817 
 818   // Extract
<span class="line-modified"> 819 #define INSN(NAME, opcode)                                              \</span>
 820   void NAME(Register Rd, Register Rn, Register Rm, unsigned imms) {     \
 821     starti;                                                             \

 822     f(opcode, 31, 21), f(imms, 15, 10);                                 \
<span class="line-modified"> 823     rf(Rm, 16), rf(Rn, 5), rf(Rd, 0);                                   \</span>
 824   }
 825 
<span class="line-modified"> 826   INSN(extrw, 0b00010011100);</span>
<span class="line-modified"> 827   INSN(extr,  0b10010011110);</span>
 828 
 829 #undef INSN
 830 
 831   // The maximum range of a branch is fixed for the AArch64
 832   // architecture.  In debug mode we shrink it in order to test
 833   // trampolines, but not so small that branches in the interpreter
 834   // are out of range.
 835   static const unsigned long branch_range = NOT_DEBUG(128 * M) DEBUG_ONLY(2 * M);
 836 
 837   static bool reachable_from_branch_at(address branch, address target) {
 838     return uabs(target - branch) &lt; branch_range;
 839   }
 840 
 841   // Unconditional branch (immediate)
 842 #define INSN(NAME, opcode)                                              \
 843   void NAME(address dest) {                                             \
 844     starti;                                                             \
 845     long offset = (dest - pc()) &gt;&gt; 2;                                   \
 846     DEBUG_ONLY(assert(reachable_from_branch_at(pc(), dest), &quot;debug only&quot;)); \
 847     f(opcode, 31), f(0b00101, 30, 26), sf(offset, 25, 0);               \
</pre>
<hr />
<pre>
1029     system(0b00, 0b011, 0b00011, imm, 0b100);
1030   }
1031 
1032   void dmb(barrier imm) {
1033     system(0b00, 0b011, 0b00011, imm, 0b101);
1034   }
1035 
1036   void isb() {
1037     system(0b00, 0b011, 0b00011, SY, 0b110);
1038   }
1039 
1040   void sys(int op1, int CRn, int CRm, int op2,
1041            Register rt = (Register)0b11111) {
1042     system(0b01, op1, CRn, CRm, op2, rt);
1043   }
1044 
1045   // Only implement operations accessible from EL0 or higher, i.e.,
1046   //            op1    CRn    CRm    op2
1047   // IC IVAU     3      7      5      1
1048   // DC CVAC     3      7      10     1

1049   // DC CVAU     3      7      11     1
1050   // DC CIVAC    3      7      14     1
1051   // DC ZVA      3      7      4      1
1052   // So only deal with the CRm field.
1053   enum icache_maintenance {IVAU = 0b0101};
<span class="line-modified">1054   enum dcache_maintenance {CVAC = 0b1010, CVAU = 0b1011, CIVAC = 0b1110, ZVA = 0b100};</span>
1055 
1056   void dc(dcache_maintenance cm, Register Rt) {
1057     sys(0b011, 0b0111, cm, 0b001, Rt);
1058   }
1059 
1060   void ic(icache_maintenance cm, Register Rt) {
1061     sys(0b011, 0b0111, cm, 0b001, Rt);
1062   }
1063 
1064   // A more convenient access to dmb for our purposes
1065   enum Membar_mask_bits {
1066     // We can use ISH for a barrier because the ARM ARM says &quot;This
1067     // architecture assumes that all Processing Elements that use the
1068     // same operating system or hypervisor are in the same Inner
1069     // Shareable shareability domain.&quot;
1070     StoreStore = ISHST,
1071     LoadStore  = ISHLD,
1072     LoadLoad   = ISHLD,
1073     StoreLoad  = ISH,
1074     AnyAny     = ISH
</pre>
<hr />
<pre>
1101 
1102 #undef INSN
1103 
1104 #define INSN(NAME, opc)                         \
1105   void NAME() {                 \
1106     branch_reg(dummy_reg, opc);         \
1107   }
1108 
1109   INSN(eret, 0b0100);
1110   INSN(drps, 0b0101);
1111 
1112 #undef INSN
1113 
1114   // Load/store exclusive
1115   enum operand_size { byte, halfword, word, xword };
1116 
1117   void load_store_exclusive(Register Rs, Register Rt1, Register Rt2,
1118     Register Rn, enum operand_size sz, int op, bool ordered) {
1119     starti;
1120     f(sz, 31, 30), f(0b001000, 29, 24), f(op, 23, 21);
<span class="line-modified">1121     rf(Rs, 16), f(ordered, 15), rf(Rt2, 10), srf(Rn, 5), zrf(Rt1, 0);</span>
1122   }
1123 
1124   void load_exclusive(Register dst, Register addr,
1125                       enum operand_size sz, bool ordered) {
1126     load_store_exclusive(dummy_reg, dst, dummy_reg, addr,
1127                          sz, 0b010, ordered);
1128   }
1129 
1130   void store_exclusive(Register status, Register new_val, Register addr,
1131                        enum operand_size sz, bool ordered) {
1132     load_store_exclusive(status, new_val, dummy_reg, addr,
1133                          sz, 0b000, ordered);
1134   }
1135 
1136 #define INSN4(NAME, sz, op, o0) /* Four registers */                    \
1137   void NAME(Register Rs, Register Rt1, Register Rt2, Register Rn) {     \
1138     guarantee(Rs != Rn &amp;&amp; Rs != Rt1 &amp;&amp; Rs != Rt2, &quot;unpredictable instruction&quot;); \
1139     load_store_exclusive(Rs, Rt1, Rt2, Rn, sz, op, o0);                 \
1140   }
1141 
</pre>
<hr />
<pre>
1194   INSN2(ldaxr, xword, 0b010, 1);
1195   INSN_FOO(ldxp, xword, 0b011, 0);
1196   INSN_FOO(ldaxp, xword, 0b011, 1);
1197   INSN2(stlr, xword, 0b100, 1);
1198   INSN2(ldar, xword, 0b110, 1);
1199 
1200 #undef INSN2
1201 #undef INSN3
1202 #undef INSN4
1203 #undef INSN_FOO
1204 
1205   // 8.1 Compare and swap extensions
1206   void lse_cas(Register Rs, Register Rt, Register Rn,
1207                         enum operand_size sz, bool a, bool r, bool not_pair) {
1208     starti;
1209     if (! not_pair) { // Pair
1210       assert(sz == word || sz == xword, &quot;invalid size&quot;);
1211       /* The size bit is in bit 30, not 31 */
1212       sz = (operand_size)(sz == word ? 0b00:0b01);
1213     }
<span class="line-modified">1214     f(sz, 31, 30), f(0b001000, 29, 24), f(1, 23), f(a, 22), f(1, 21);</span>
<span class="line-modified">1215     rf(Rs, 16), f(r, 15), f(0b11111, 14, 10), rf(Rn, 5), rf(Rt, 0);</span>
1216   }
1217 
1218   // CAS
1219 #define INSN(NAME, a, r)                                                \
1220   void NAME(operand_size sz, Register Rs, Register Rt, Register Rn) {   \
1221     assert(Rs != Rn &amp;&amp; Rs != Rt, &quot;unpredictable instruction&quot;);          \
1222     lse_cas(Rs, Rt, Rn, sz, a, r, true);                                \
1223   }
1224   INSN(cas,    false, false)
1225   INSN(casa,   true,  false)
1226   INSN(casl,   false, true)
1227   INSN(casal,  true,  true)
1228 #undef INSN
1229 
1230   // CASP
1231 #define INSN(NAME, a, r)                                                \
1232   void NAME(operand_size sz, Register Rs, Register Rs1,                 \
1233             Register Rt, Register Rt1, Register Rn) {                   \
1234     assert((Rs-&gt;encoding() &amp; 1) == 0 &amp;&amp; (Rt-&gt;encoding() &amp; 1) == 0 &amp;&amp;    \
1235            Rs-&gt;successor() == Rs1 &amp;&amp; Rt-&gt;successor() == Rt1 &amp;&amp;          \
1236            Rs != Rn &amp;&amp; Rs1 != Rn &amp;&amp; Rs != Rt, &quot;invalid registers&quot;);     \
1237     lse_cas(Rs, Rt, Rn, sz, a, r, false);                               \
1238   }
1239   INSN(casp,    false, false)
1240   INSN(caspa,   true,  false)
1241   INSN(caspl,   false, true)
1242   INSN(caspal,  true,  true)
1243 #undef INSN
1244 
1245   // 8.1 Atomic operations
1246   void lse_atomic(Register Rs, Register Rt, Register Rn,
1247                   enum operand_size sz, int op1, int op2, bool a, bool r) {
1248     starti;
1249     f(sz, 31, 30), f(0b111000, 29, 24), f(a, 23), f(r, 22), f(1, 21);
<span class="line-modified">1250     rf(Rs, 16), f(op1, 15), f(op2, 14, 12), f(0, 11, 10), srf(Rn, 5), zrf(Rt, 0);</span>
1251   }
1252 
1253 #define INSN(NAME, NAME_A, NAME_L, NAME_AL, op1, op2)                   \
1254   void NAME(operand_size sz, Register Rs, Register Rt, Register Rn) {   \
1255     lse_atomic(Rs, Rt, Rn, sz, op1, op2, false, false);                 \
1256   }                                                                     \
1257   void NAME_A(operand_size sz, Register Rs, Register Rt, Register Rn) { \
1258     lse_atomic(Rs, Rt, Rn, sz, op1, op2, true, false);                  \
1259   }                                                                     \
1260   void NAME_L(operand_size sz, Register Rs, Register Rt, Register Rn) { \
1261     lse_atomic(Rs, Rt, Rn, sz, op1, op2, false, true);                  \
1262   }                                                                     \
1263   void NAME_AL(operand_size sz, Register Rs, Register Rt, Register Rn) {\
1264     lse_atomic(Rs, Rt, Rn, sz, op1, op2, true, true);                   \
1265   }
1266   INSN(ldadd,  ldadda,  ldaddl,  ldaddal,  0, 0b000);
1267   INSN(ldbic,  ldbica,  ldbicl,  ldbical,  0, 0b001);
1268   INSN(ldeor,  ldeora,  ldeorl,  ldeoral,  0, 0b010);
1269   INSN(ldorr,  ldorra,  ldorrl,  ldorral,  0, 0b011);
1270   INSN(ldsmax, ldsmaxa, ldsmaxl, ldsmaxal, 0, 0b100);
</pre>
<hr />
<pre>
1452 
1453 #undef INSN
1454 
1455   enum shift_kind { LSL, LSR, ASR, ROR };
1456 
1457   void op_shifted_reg(unsigned decode,
1458                       enum shift_kind kind, unsigned shift,
1459                       unsigned size, unsigned op) {
1460     f(size, 31);
1461     f(op, 30, 29);
1462     f(decode, 28, 24);
1463     f(shift, 15, 10);
1464     f(kind, 23, 22);
1465   }
1466 
1467   // Logical (shifted register)
1468 #define INSN(NAME, size, op, N)                                 \
1469   void NAME(Register Rd, Register Rn, Register Rm,              \
1470             enum shift_kind kind = LSL, unsigned shift = 0) {   \
1471     starti;                                                     \

1472     f(N, 21);                                                   \
1473     zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                        \
1474     op_shifted_reg(0b01010, kind, shift, size, op);             \
1475   }
1476 
1477   INSN(andr, 1, 0b00, 0);
1478   INSN(orr, 1, 0b01, 0);
1479   INSN(eor, 1, 0b10, 0);
1480   INSN(ands, 1, 0b11, 0);
1481   INSN(andw, 0, 0b00, 0);
1482   INSN(orrw, 0, 0b01, 0);
1483   INSN(eorw, 0, 0b10, 0);
1484   INSN(andsw, 0, 0b11, 0);
1485 



















1486   INSN(bic, 1, 0b00, 1);
1487   INSN(orn, 1, 0b01, 1);
1488   INSN(eon, 1, 0b10, 1);
1489   INSN(bics, 1, 0b11, 1);
1490   INSN(bicw, 0, 0b00, 1);
1491   INSN(ornw, 0, 0b01, 1);
1492   INSN(eonw, 0, 0b10, 1);
1493   INSN(bicsw, 0, 0b11, 1);
1494 
1495 #undef INSN
1496 
1497   // Aliases for short forms of orn
1498 void mvn(Register Rd, Register Rm,
1499             enum shift_kind kind = LSL, unsigned shift = 0) {
1500   orn(Rd, zr, Rm, kind, shift);
1501 }
1502 
1503 void mvnw(Register Rd, Register Rm,
1504             enum shift_kind kind = LSL, unsigned shift = 0) {
1505   ornw(Rd, zr, Rm, kind, shift);
1506 }
1507 
1508   // Add/subtract (shifted register)
1509 #define INSN(NAME, size, op)                            \
1510   void NAME(Register Rd, Register Rn, Register Rm,      \
1511             enum shift_kind kind, unsigned shift = 0) { \
1512     starti;                                             \
1513     f(0, 21);                                           \
1514     assert_cond(kind != ROR);                           \

1515     zrf(Rd, 0), zrf(Rn, 5), zrf(Rm, 16);                \
1516     op_shifted_reg(0b01011, kind, shift, size, op);     \
1517   }
1518 
1519   INSN(add, 1, 0b000);
1520   INSN(sub, 1, 0b10);
1521   INSN(addw, 0, 0b000);
1522   INSN(subw, 0, 0b10);
1523 
1524   INSN(adds, 1, 0b001);
1525   INSN(subs, 1, 0b11);
1526   INSN(addsw, 0, 0b001);
1527   INSN(subsw, 0, 0b11);
1528 
1529 #undef INSN
1530 
1531   // Add/subtract (extended register)
1532 #define INSN(NAME, op)                                                  \
1533   void NAME(Register Rd, Register Rn, Register Rm,                      \
1534            ext::operation option, int amount = 0) {                     \
1535     starti;                                                             \
1536     zrf(Rm, 16), srf(Rn, 5), srf(Rd, 0);                                \
1537     add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \
1538   }
1539 
1540   void add_sub_extended_reg(unsigned op, unsigned decode,
1541     Register Rd, Register Rn, Register Rm,
1542     unsigned opt, ext::operation option, unsigned imm) {
<span class="line-modified">1543     guarantee(imm &lt;= 4, &quot;shift amount must be &lt; 4&quot;);</span>
1544     f(op, 31, 29), f(decode, 28, 24), f(opt, 23, 22), f(1, 21);
1545     f(option, 15, 13), f(imm, 12, 10);
1546   }
1547 
1548   INSN(addw, 0b000);
1549   INSN(subw, 0b010);
1550   INSN(add, 0b100);
1551   INSN(sub, 0b110);
1552 
1553 #undef INSN
1554 
1555 #define INSN(NAME, op)                                                  \
1556   void NAME(Register Rd, Register Rn, Register Rm,                      \
1557            ext::operation option, int amount = 0) {                     \
1558     starti;                                                             \
1559     zrf(Rm, 16), srf(Rn, 5), zrf(Rd, 0);                                \
1560     add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \
1561   }
1562 
1563   INSN(addsw, 0b001);
</pre>
<hr />
<pre>
1608   INSN(sbcsw, 0b011);
1609   INSN(adc, 0b100);
1610   INSN(adcs, 0b101);
1611   INSN(sbc,0b110);
1612   INSN(sbcs, 0b111);
1613 
1614 #undef INSN
1615 
1616   // Conditional compare (both kinds)
1617   void conditional_compare(unsigned op, int o1, int o2, int o3,
1618                            Register Rn, unsigned imm5, unsigned nzcv,
1619                            unsigned cond) {
1620     starti;
1621     f(op, 31, 29);
1622     f(0b11010010, 28, 21);
1623     f(cond, 15, 12);
1624     f(o1, 11);
1625     f(o2, 10);
1626     f(o3, 4);
1627     f(nzcv, 3, 0);
<span class="line-modified">1628     f(imm5, 20, 16), rf(Rn, 5);</span>
1629   }
1630 
1631 #define INSN(NAME, op)                                                  \
1632   void NAME(Register Rn, Register Rm, int imm, Condition cond) {        \
1633     int regNumber = (Rm == zr ? 31 : (uintptr_t)Rm);                    \
1634     conditional_compare(op, 0, 0, 0, Rn, regNumber, imm, cond);         \
1635   }                                                                     \
1636                                                                         \
1637   void NAME(Register Rn, int imm5, int imm, Condition cond) {           \
1638     conditional_compare(op, 1, 0, 0, Rn, imm5, imm, cond);              \
1639   }
1640 
1641   INSN(ccmnw, 0b001);
1642   INSN(ccmpw, 0b011);
1643   INSN(ccmn, 0b101);
1644   INSN(ccmp, 0b111);
1645 
1646 #undef INSN
1647 
1648   // Conditional select
</pre>
<hr />
<pre>
2077 #define INSN(NAME, op)                                            \
2078   void NAME(FloatRegister Rt, SIMD_RegVariant T, const Address &amp;adr) {   \
2079     ld_st2((Register)Rt, adr, (int)T &amp; 3, op + ((T==Q) ? 0b10:0b00), 1); \
2080   }                                                                      \
2081 
2082   INSN(ldr, 1);
2083   INSN(str, 0);
2084 
2085 #undef INSN
2086 
2087  private:
2088 
2089   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn, int op1, int op2) {
2090     starti;
2091     f(0,31), f((int)T &amp; 1, 30);
2092     f(op1, 29, 21), f(0, 20, 16), f(op2, 15, 12);
2093     f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
2094   }
2095   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn,
2096              int imm, int op1, int op2, int regs) {
<span class="line-modified">2097     guarantee(T &lt;= T1Q &amp;&amp; imm == SIMD_Size_in_bytes[T] * regs, &quot;bad offset&quot;);</span>





2098     starti;
2099     f(0,31), f((int)T &amp; 1, 30);
2100     f(op1 | 0b100, 29, 21), f(0b11111, 20, 16), f(op2, 15, 12);
2101     f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
2102   }
2103   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn,
2104              Register Xm, int op1, int op2) {
2105     starti;
2106     f(0,31), f((int)T &amp; 1, 30);
2107     f(op1 | 0b100, 29, 21), rf(Xm, 16), f(op2, 15, 12);
2108     f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
2109   }
2110 
2111   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Address a, int op1, int op2, int regs) {
2112     switch (a.getMode()) {
2113     case Address::base_plus_offset:
2114       guarantee(a.offset() == 0, &quot;no offset allowed here&quot;);
2115       ld_st(Vt, T, a.base(), op1, op2);
2116       break;
2117     case Address::post:
</pre>
<hr />
<pre>
2184 
2185 #define INSN(NAME, opc)                                                                 \
2186   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
2187     starti;                                                                             \
2188     assert(T == T8B || T == T16B, &quot;must be T8B or T16B&quot;);                               \
2189     f(0, 31), f((int)T &amp; 1, 30), f(opc, 29, 21);                                        \
2190     rf(Vm, 16), f(0b000111, 15, 10), rf(Vn, 5), rf(Vd, 0);                              \
2191   }
2192 
2193   INSN(eor,  0b101110001);
2194   INSN(orr,  0b001110101);
2195   INSN(andr, 0b001110001);
2196   INSN(bic,  0b001110011);
2197   INSN(bif,  0b101110111);
2198   INSN(bit,  0b101110101);
2199   INSN(bsl,  0b101110011);
2200   INSN(orn,  0b001110111);
2201 
2202 #undef INSN
2203 
<span class="line-modified">2204 #define INSN(NAME, opc, opc2)                                                                 \</span>
2205   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \


2206     starti;                                                                             \
2207     f(0, 31), f((int)T &amp; 1, 30), f(opc, 29), f(0b01110, 28, 24);                        \
2208     f((int)T &gt;&gt; 1, 23, 22), f(1, 21), rf(Vm, 16), f(opc2, 15, 10);                      \
2209     rf(Vn, 5), rf(Vd, 0);                                                               \
2210   }
2211 
<span class="line-modified">2212   INSN(addv,   0, 0b100001);</span>
<span class="line-modified">2213   INSN(subv,   1, 0b100001);</span>
<span class="line-modified">2214   INSN(mulv,   0, 0b100111);</span>
<span class="line-modified">2215   INSN(mlav,   0, 0b100101);</span>
<span class="line-modified">2216   INSN(mlsv,   1, 0b100101);</span>
<span class="line-modified">2217   INSN(sshl,   0, 0b010001);</span>
<span class="line-modified">2218   INSN(ushl,   1, 0b010001);</span>
<span class="line-modified">2219   INSN(umullv, 1, 0b110000);</span>
<span class="line-modified">2220   INSN(umlalv, 1, 0b100000);</span>
2221 
2222 #undef INSN
2223 
<span class="line-modified">2224 #define INSN(NAME, opc, opc2) \</span>
2225   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                   \



2226     starti;                                                                             \
2227     f(0, 31), f((int)T &amp; 1, 30), f(opc, 29), f(0b01110, 28, 24);                        \
2228     f((int)T &gt;&gt; 1, 23, 22), f(opc2, 21, 10);                                            \
2229     rf(Vn, 5), rf(Vd, 0);                                                               \
2230   }
2231 
<span class="line-modified">2232   INSN(absr,   0, 0b100000101110);</span>
<span class="line-modified">2233   INSN(negr,   1, 0b100000101110);</span>
<span class="line-modified">2234   INSN(notr,   1, 0b100000010110);</span>
<span class="line-modified">2235   INSN(addv,   0, 0b110001101110);</span>
<span class="line-modified">2236   INSN(cls,    0, 0b100000010010);</span>
<span class="line-modified">2237   INSN(clz,    1, 0b100000010010);</span>
<span class="line-modified">2238   INSN(cnt,    0, 0b100000010110);</span>
<span class="line-modified">2239   INSN(uaddlv, 1, 0b110000001110);</span>
2240 
2241 #undef INSN
2242 
2243 #define INSN(NAME, opc) \
2244   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                  \
2245     starti;                                                                            \
2246     assert(T == T4S, &quot;arrangement must be T4S&quot;);                                       \
2247     f(0, 31), f((int)T &amp; 1, 30), f(0b101110, 29, 24), f(opc, 23),                      \
2248     f(T == T4S ? 0 : 1, 22), f(0b110000111110, 21, 10); rf(Vn, 5), rf(Vd, 0);          \
2249   }
2250 
2251   INSN(fmaxv, 0);
2252   INSN(fminv, 1);
2253 
2254 #undef INSN
2255 
2256 #define INSN(NAME, op0, cmode0) \
2257   void NAME(FloatRegister Vd, SIMD_Arrangement T, unsigned imm8, unsigned lsl = 0) {   \
2258     unsigned cmode = cmode0;                                                           \
2259     unsigned op = op0;                                                                 \
2260     starti;                                                                            \
2261     assert(lsl == 0 ||                                                                 \
2262            ((T == T4H || T == T8H) &amp;&amp; lsl == 8) ||                                     \
<span class="line-modified">2263            ((T == T2S || T == T4S) &amp;&amp; ((lsl &gt;&gt; 3) &lt; 4)), &quot;invalid shift&quot;);             \</span>
2264     cmode |= lsl &gt;&gt; 2;                                                                 \
2265     if (T == T4H || T == T8H) cmode |= 0b1000;                                         \
2266     if (!(T == T4H || T == T8H || T == T2S || T == T4S)) {                             \
2267       assert(op == 0 &amp;&amp; cmode0 == 0, &quot;must be MOVI&quot;);                                  \
2268       cmode = 0b1110;                                                                  \
2269       if (T == T1D || T == T2D) op = 1;                                                \
2270     }                                                                                  \
2271     f(0, 31), f((int)T &amp; 1, 30), f(op, 29), f(0b0111100000, 28, 19);                   \
2272     f(imm8 &gt;&gt; 5, 18, 16), f(cmode, 15, 12), f(0x01, 11, 10), f(imm8 &amp; 0b11111, 9, 5);  \
2273     rf(Vd, 0);                                                                         \
2274   }
2275 
2276   INSN(movi, 0, 0);
2277   INSN(orri, 0, 1);
2278   INSN(mvni, 1, 0);
2279   INSN(bici, 1, 1);
2280 
2281 #undef INSN
2282 
2283 #define INSN(NAME, op1, op2, op3) \
</pre>
<hr />
<pre>
2404      * for SHL shift is calculated as:                                  \
2405      *   0001 xxx       8B/16B, shift = UInt(immh:immb) - 8             \
2406      *   001x xxx       4H/8H,  shift = UInt(immh:immb) - 16            \
2407      *   01xx xxx       2S/4S,  shift = UInt(immh:immb) - 32            \
2408      *   1xxx xxx       1D/2D,  shift = UInt(immh:immb) - 64            \
2409      *   (1D is RESERVED)                                               \
2410      */                                                                 \
2411     assert((1 &lt;&lt; ((T&gt;&gt;1)+3)) &gt; shift, &quot;Invalid Shift value&quot;);           \
2412     int cVal = (1 &lt;&lt; (((T &gt;&gt; 1) + 3) + (isSHR ? 1 : 0)));               \
2413     int encodedShift = isSHR ? cVal - shift : cVal + shift;             \
2414     f(0, 31), f(T &amp; 1, 30), f(opc, 29), f(0b011110, 28, 23),            \
2415     f(encodedShift, 22, 16); f(opc2, 15, 10), rf(Vn, 5), rf(Vd, 0);     \
2416   }
2417 
2418   INSN(shl,  0, 0b010101, /* isSHR = */ false);
2419   INSN(sshr, 0, 0b000001, /* isSHR = */ true);
2420   INSN(ushr, 1, 0b000001, /* isSHR = */ true);
2421 
2422 #undef INSN
2423 
<span class="line-modified">2424   void ushll(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, SIMD_Arrangement Tb, int shift) {</span>

2425     starti;
2426     /* The encodings for the immh:immb fields (bits 22:16) are
2427      *   0001 xxx       8H, 8B/16b shift = xxx
2428      *   001x xxx       4S, 4H/8H  shift = xxxx
2429      *   01xx xxx       2D, 2S/4S  shift = xxxxx
2430      *   1xxx xxx       RESERVED
2431      */
2432     assert((Tb &gt;&gt; 1) + 1 == (Ta &gt;&gt; 1), &quot;Incompatible arrangement&quot;);
2433     assert((1 &lt;&lt; ((Tb&gt;&gt;1)+3)) &gt; shift, &quot;Invalid shift value&quot;);
2434     f(0, 31), f(Tb &amp; 1, 30), f(0b1011110, 29, 23), f((1 &lt;&lt; ((Tb&gt;&gt;1)+3))|shift, 22, 16);
2435     f(0b101001, 15, 10), rf(Vn, 5), rf(Vd, 0);
2436   }







2437   void ushll2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn,  SIMD_Arrangement Tb, int shift) {
<span class="line-modified">2438     ushll(Vd, Ta, Vn, Tb, shift);</span>

2439   }
2440 
2441   // Move from general purpose register
2442   //   mov  Vd.T[index], Rn
2443   void mov(FloatRegister Vd, SIMD_Arrangement T, int index, Register Xn) {
2444     starti;
2445     f(0b01001110000, 31, 21), f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
<span class="line-modified">2446     f(0b000111, 15, 10), rf(Xn, 5), rf(Vd, 0);</span>
2447   }
2448 
2449   // Move to general purpose register
2450   //   mov  Rd, Vn.T[index]
2451   void mov(Register Xd, FloatRegister Vn, SIMD_Arrangement T, int index) {

2452     starti;
2453     f(0, 31), f((T &gt;= T1D) ? 1:0, 30), f(0b001110000, 29, 21);
2454     f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
2455     f(0b001111, 15, 10), rf(Vn, 5), rf(Xd, 0);
2456   }
2457 
<span class="line-modified">2458   void pmull(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {</span>

2459     starti;
2460     assert((Ta == T1Q &amp;&amp; (Tb == T1D || Tb == T2D)) ||
2461            (Ta == T8H &amp;&amp; (Tb == T8B || Tb == T16B)), &quot;Invalid Size specifier&quot;);
2462     int size = (Ta == T1Q) ? 0b11 : 0b00;
2463     f(0, 31), f(Tb &amp; 1, 30), f(0b001110, 29, 24), f(size, 23, 22);
2464     f(1, 21), rf(Vm, 16), f(0b111000, 15, 10), rf(Vn, 5), rf(Vd, 0);
2465   }







2466   void pmull2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {
2467     assert(Tb == T2D || Tb == T16B, &quot;pmull2 assumes T2D or T16B as the second size specifier&quot;);
<span class="line-modified">2468     pmull(Vd, Ta, Vn, Vm, Tb);</span>
2469   }
2470 
2471   void uqxtn(FloatRegister Vd, SIMD_Arrangement Tb, FloatRegister Vn, SIMD_Arrangement Ta) {
2472     starti;
2473     int size_b = (int)Tb &gt;&gt; 1;
2474     int size_a = (int)Ta &gt;&gt; 1;
2475     assert(size_b &lt; 3 &amp;&amp; size_b == size_a - 1, &quot;Invalid size specifier&quot;);
2476     f(0, 31), f(Tb &amp; 1, 30), f(0b101110, 29, 24), f(size_b, 23, 22);
2477     f(0b100001010010, 21, 10), rf(Vn, 5), rf(Vd, 0);
2478   }
2479 
2480   void dup(FloatRegister Vd, SIMD_Arrangement T, Register Xs)
2481   {
2482     starti;
2483     assert(T != T1D, &quot;reserved encoding&quot;);
2484     f(0,31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21);
<span class="line-modified">2485     f((1 &lt;&lt; (T &gt;&gt; 1)), 20, 16), f(0b000011, 15, 10), rf(Xs, 5), rf(Vd, 0);</span>
2486   }
2487 
2488   void dup(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int index = 0)
2489   {
2490     starti;
2491     assert(T != T1D, &quot;reserved encoding&quot;);
2492     f(0, 31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21);
2493     f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
2494     f(0b000001, 15, 10), rf(Vn, 5), rf(Vd, 0);
2495   }
2496 
2497   // AdvSIMD ZIP/UZP/TRN
2498 #define INSN(NAME, opcode)                                              \
2499   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \

2500     starti;                                                             \
2501     f(0, 31), f(0b001110, 29, 24), f(0, 21), f(0, 15);                  \
2502     f(opcode, 14, 12), f(0b10, 11, 10);                                 \
2503     rf(Vm, 16), rf(Vn, 5), rf(Vd, 0);                                   \
2504     f(T &amp; 1, 30), f(T &gt;&gt; 1, 23, 22);                                    \
2505   }
2506 
2507   INSN(uzp1, 0b001);
2508   INSN(trn1, 0b010);
2509   INSN(zip1, 0b011);
2510   INSN(uzp2, 0b101);
2511   INSN(trn2, 0b110);
2512   INSN(zip2, 0b111);
2513 
2514 #undef INSN
2515 
2516   // CRC32 instructions
2517 #define INSN(NAME, c, sf, sz)                                             \
2518   void NAME(Register Rd, Register Rn, Register Rm) {                      \
2519     starti;                                                               \
</pre>
<hr />
<pre>
2531   INSN(crc32cx, 1, 1, 0b11);
2532 
2533 #undef INSN
2534 
2535   // Table vector lookup
2536 #define INSN(NAME, op)                                                  \
2537   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, unsigned registers, FloatRegister Vm) { \
2538     starti;                                                             \
2539     assert(T == T8B || T == T16B, &quot;invalid arrangement&quot;);               \
2540     assert(0 &lt; registers &amp;&amp; registers &lt;= 4, &quot;invalid number of registers&quot;); \
2541     f(0, 31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21), rf(Vm, 16), f(0, 15); \
2542     f(registers - 1, 14, 13), f(op, 12),f(0b00, 11, 10), rf(Vn, 5), rf(Vd, 0); \
2543   }
2544 
2545   INSN(tbl, 0);
2546   INSN(tbx, 1);
2547 
2548 #undef INSN
2549 
2550   // AdvSIMD two-reg misc
<span class="line-modified">2551 #define INSN(NAME, U, opcode)                                                       \</span>





2552   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {               \
2553        starti;                                                                      \
2554        assert((ASSERTION), MSG);                                                    \
2555        f(0, 31), f((int)T &amp; 1, 30), f(U, 29), f(0b01110, 28, 24);                   \
<span class="line-modified">2556        f((int)(T &gt;&gt; 1), 23, 22), f(0b10000, 21, 17), f(opcode, 16, 12);             \</span>
<span class="line-modified">2557        f(0b10, 11, 10), rf(Vn, 5), rf(Vd, 0);                                       \</span>
2558  }
2559 
2560 #define MSG &quot;invalid arrangement&quot;
2561 
2562 #define ASSERTION (T == T2S || T == T4S || T == T2D)
<span class="line-modified">2563   INSN(fsqrt, 1, 0b11111);</span>
<span class="line-modified">2564   INSN(fabs,  0, 0b01111);</span>
<span class="line-modified">2565   INSN(fneg,  1, 0b01111);</span>



2566 #undef ASSERTION
2567 
2568 #define ASSERTION (T == T8B || T == T16B || T == T4H || T == T8H || T == T2S || T == T4S)
<span class="line-modified">2569   INSN(rev64, 0, 0b00000);</span>
2570 #undef ASSERTION
2571 
2572 #define ASSERTION (T == T8B || T == T16B || T == T4H || T == T8H)
<span class="line-modified">2573   INSN(rev32, 1, 0b00000);</span>
<span class="line-removed">2574 private:</span>
<span class="line-removed">2575   INSN(_rbit, 1, 0b00101);</span>
<span class="line-removed">2576 public:</span>
<span class="line-removed">2577 </span>
2578 #undef ASSERTION
2579 
2580 #define ASSERTION (T == T8B || T == T16B)
<span class="line-modified">2581   INSN(rev16, 0, 0b00001);</span>
<span class="line-modified">2582   // RBIT only allows T8B and T16B but encodes them oddly.  Argh...</span>
<span class="line-removed">2583   void rbit(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {</span>
<span class="line-removed">2584     assert((ASSERTION), MSG);</span>
<span class="line-removed">2585     _rbit(Vd, SIMD_Arrangement(T &amp; 1 | 0b010), Vn);</span>
<span class="line-removed">2586   }</span>
2587 #undef ASSERTION
2588 
2589 #undef MSG
2590 
2591 #undef INSN
2592 
2593 void ext(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm, int index)
2594   {
2595     starti;
2596     assert(T == T8B || T == T16B, &quot;invalid arrangement&quot;);
2597     assert((T == T8B &amp;&amp; index &lt;= 0b0111) || (T == T16B &amp;&amp; index &lt;= 0b1111), &quot;Invalid index value&quot;);
2598     f(0, 31), f((int)T &amp; 1, 30), f(0b101110000, 29, 21);
2599     rf(Vm, 16), f(0, 15), f(index, 14, 11);
2600     f(0, 10), rf(Vn, 5), rf(Vd, 0);
2601   }
2602 
<span class="line-removed">2603 /* Simulator extensions to the ISA</span>
<span class="line-removed">2604 </span>
<span class="line-removed">2605    haltsim</span>
<span class="line-removed">2606 </span>
<span class="line-removed">2607    takes no arguments, causes the sim to enter a debug break and then</span>
<span class="line-removed">2608    return from the simulator run() call with STATUS_HALT? The linking</span>
<span class="line-removed">2609    code will call fatal() when it sees STATUS_HALT.</span>
<span class="line-removed">2610 </span>
<span class="line-removed">2611    blrt Xn, Wm</span>
<span class="line-removed">2612    blrt Xn, #gpargs, #fpargs, #type</span>
<span class="line-removed">2613    Xn holds the 64 bit x86 branch_address</span>
<span class="line-removed">2614    call format is encoded either as immediate data in the call</span>
<span class="line-removed">2615    or in register Wm. In the latter case</span>
<span class="line-removed">2616      Wm[13..6] = #gpargs,</span>
<span class="line-removed">2617      Wm[5..2] = #fpargs,</span>
<span class="line-removed">2618      Wm[1,0] = #type</span>
<span class="line-removed">2619 </span>
<span class="line-removed">2620    calls the x86 code address &#39;branch_address&#39; supplied in Xn passing</span>
<span class="line-removed">2621    arguments taken from the general and floating point registers according</span>
<span class="line-removed">2622    to the supplied counts &#39;gpargs&#39; and &#39;fpargs&#39;. may return a result in r0</span>
<span class="line-removed">2623    or v0 according to the the return type #type&#39; where</span>
<span class="line-removed">2624 </span>
<span class="line-removed">2625    address branch_address;</span>
<span class="line-removed">2626    uimm4 gpargs;</span>
<span class="line-removed">2627    uimm4 fpargs;</span>
<span class="line-removed">2628    enum ReturnType type;</span>
<span class="line-removed">2629 </span>
<span class="line-removed">2630    enum ReturnType</span>
<span class="line-removed">2631      {</span>
<span class="line-removed">2632        void_ret = 0,</span>
<span class="line-removed">2633        int_ret = 1,</span>
<span class="line-removed">2634        long_ret = 1,</span>
<span class="line-removed">2635        obj_ret = 1, // i.e. same as long</span>
<span class="line-removed">2636        float_ret = 2,</span>
<span class="line-removed">2637        double_ret = 3</span>
<span class="line-removed">2638      }</span>
<span class="line-removed">2639 </span>
<span class="line-removed">2640    notify</span>
<span class="line-removed">2641 </span>
<span class="line-removed">2642    notifies the simulator of a transfer of control. instr[14:0]</span>
<span class="line-removed">2643    identifies the type of change of control.</span>
<span class="line-removed">2644 </span>
<span class="line-removed">2645    0 ==&gt; initial entry to a method.</span>
<span class="line-removed">2646 </span>
<span class="line-removed">2647    1 ==&gt; return into a method from a submethod call.</span>
<span class="line-removed">2648 </span>
<span class="line-removed">2649    2 ==&gt; exit out of Java method code.</span>
<span class="line-removed">2650 </span>
<span class="line-removed">2651    3 ==&gt; start execution for a new bytecode.</span>
<span class="line-removed">2652 </span>
<span class="line-removed">2653    in cases 1 and 2 the simulator is expected to use a JVM callback to</span>
<span class="line-removed">2654    identify the name of the specific method being executed. in case 4</span>
<span class="line-removed">2655    the simulator is expected to use a JVM callback to identify the</span>
<span class="line-removed">2656    bytecode index.</span>
<span class="line-removed">2657 </span>
<span class="line-removed">2658    Instruction encodings</span>
<span class="line-removed">2659    ---------------------</span>
<span class="line-removed">2660 </span>
<span class="line-removed">2661    These are encoded in the space with instr[28:25] = 00 which is</span>
<span class="line-removed">2662    unallocated. Encodings are</span>
<span class="line-removed">2663 </span>
<span class="line-removed">2664                      10987654321098765432109876543210</span>
<span class="line-removed">2665    PSEUDO_HALT   = 0x11100000000000000000000000000000</span>
<span class="line-removed">2666    PSEUDO_BLRT  = 0x11000000000000000_______________</span>
<span class="line-removed">2667    PSEUDO_BLRTR = 0x1100000000000000100000__________</span>
<span class="line-removed">2668    PSEUDO_NOTIFY = 0x10100000000000000_______________</span>
<span class="line-removed">2669 </span>
<span class="line-removed">2670    instr[31,29] = op1 : 111 ==&gt; HALT, 110 ==&gt; BLRT/BLRTR, 101 ==&gt; NOTIFY</span>
<span class="line-removed">2671 </span>
<span class="line-removed">2672    for BLRT</span>
<span class="line-removed">2673      instr[14,11] = #gpargs, instr[10,7] = #fpargs</span>
<span class="line-removed">2674      instr[6,5] = #type, instr[4,0] = Rn</span>
<span class="line-removed">2675    for BLRTR</span>
<span class="line-removed">2676      instr[9,5] = Rm, instr[4,0] = Rn</span>
<span class="line-removed">2677    for NOTIFY</span>
<span class="line-removed">2678      instr[14:0] = type : 0 ==&gt; entry, 1 ==&gt; reentry, 2 ==&gt; exit, 3 ==&gt; bcstart</span>
<span class="line-removed">2679 */</span>
<span class="line-removed">2680 </span>
<span class="line-removed">2681   enum NotifyType { method_entry, method_reentry, method_exit, bytecode_start };</span>
<span class="line-removed">2682 </span>
<span class="line-removed">2683   virtual void notify(int type) {</span>
<span class="line-removed">2684     if (UseBuiltinSim) {</span>
<span class="line-removed">2685       starti;</span>
<span class="line-removed">2686       //  109</span>
<span class="line-removed">2687       f(0b101, 31, 29);</span>
<span class="line-removed">2688       //  87654321098765</span>
<span class="line-removed">2689       f(0b00000000000000, 28, 15);</span>
<span class="line-removed">2690       f(type, 14, 0);</span>
<span class="line-removed">2691     }</span>
<span class="line-removed">2692   }</span>
<span class="line-removed">2693 </span>
<span class="line-removed">2694   void blrt(Register Rn, int gpargs, int fpargs, int type) {</span>
<span class="line-removed">2695     if (UseBuiltinSim) {</span>
<span class="line-removed">2696       starti;</span>
<span class="line-removed">2697       f(0b110, 31 ,29);</span>
<span class="line-removed">2698       f(0b00, 28, 25);</span>
<span class="line-removed">2699       //  4321098765</span>
<span class="line-removed">2700       f(0b0000000000, 24, 15);</span>
<span class="line-removed">2701       f(gpargs, 14, 11);</span>
<span class="line-removed">2702       f(fpargs, 10, 7);</span>
<span class="line-removed">2703       f(type, 6, 5);</span>
<span class="line-removed">2704       rf(Rn, 0);</span>
<span class="line-removed">2705     } else {</span>
<span class="line-removed">2706       blr(Rn);</span>
<span class="line-removed">2707     }</span>
<span class="line-removed">2708   }</span>
<span class="line-removed">2709 </span>
<span class="line-removed">2710   void blrt(Register Rn, Register Rm) {</span>
<span class="line-removed">2711     if (UseBuiltinSim) {</span>
<span class="line-removed">2712       starti;</span>
<span class="line-removed">2713       f(0b110, 31 ,29);</span>
<span class="line-removed">2714       f(0b00, 28, 25);</span>
<span class="line-removed">2715       //  4321098765</span>
<span class="line-removed">2716       f(0b0000000001, 24, 15);</span>
<span class="line-removed">2717       //  43210</span>
<span class="line-removed">2718       f(0b00000, 14, 10);</span>
<span class="line-removed">2719       rf(Rm, 5);</span>
<span class="line-removed">2720       rf(Rn, 0);</span>
<span class="line-removed">2721     } else {</span>
<span class="line-removed">2722       blr(Rn);</span>
<span class="line-removed">2723     }</span>
<span class="line-removed">2724   }</span>
<span class="line-removed">2725 </span>
<span class="line-removed">2726   void haltsim() {</span>
<span class="line-removed">2727     starti;</span>
<span class="line-removed">2728     f(0b111, 31 ,29);</span>
<span class="line-removed">2729     f(0b00, 28, 27);</span>
<span class="line-removed">2730     //  654321098765432109876543210</span>
<span class="line-removed">2731     f(0b000000000000000000000000000, 26, 0);</span>
<span class="line-removed">2732   }</span>
<span class="line-removed">2733 </span>
2734   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
2735   }
2736 
2737   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
2738                                                 Register tmp,
2739                                                 int offset) {
2740     ShouldNotCallThis();
2741     return RegisterOrConstant();
2742   }
2743 
2744   // Stack overflow checking
2745   virtual void bang_stack_with_offset(int offset);
2746 
2747   static bool operand_valid_for_logical_immediate(bool is32, uint64_t imm);
2748   static bool operand_valid_for_add_sub_immediate(long imm);
2749   static bool operand_valid_for_float_immediate(double imm);
2750 
2751   void emit_data64(jlong data, relocInfo::relocType rtype, int format = 0);
2752   void emit_data64(jlong data, RelocationHolder const&amp; rspec, int format = 0);
2753 };
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
 259     f(r-&gt;encoding_nocheck(), lsb + 4, lsb);
 260   }
 261 
 262   // reg|ZR
 263   void zrf(Register r, int lsb) {
 264     f(r-&gt;encoding_nocheck() - (r == zr), lsb + 4, lsb);
 265   }
 266 
 267   // reg|SP
 268   void srf(Register r, int lsb) {
 269     f(r == sp ? 31 : r-&gt;encoding_nocheck(), lsb + 4, lsb);
 270   }
 271 
 272   void rf(FloatRegister r, int lsb) {
 273     f(r-&gt;encoding_nocheck(), lsb + 4, lsb);
 274   }
 275 
 276   unsigned get(int msb = 31, int lsb = 0) {
 277     int nbits = msb - lsb + 1;
 278     unsigned mask = ((1U &lt;&lt; nbits) - 1) &lt;&lt; lsb;
<span class="line-modified"> 279     assert_cond((bits &amp; mask) == mask);</span>
 280     return (insn &amp; mask) &gt;&gt; lsb;
 281   }
 282 
 283   void fixed(unsigned value, unsigned mask) {
 284     assert_cond ((mask &amp; bits) == 0);
 285 #ifdef ASSERT
 286     bits |= mask;
 287 #endif
 288     insn |= value;
 289   }
 290 };
 291 
 292 #define starti Instruction_aarch64 do_not_use(this); set_current(&amp;do_not_use)
 293 
 294 class PrePost {
 295   int _offset;
 296   Register _r;
 297 public:
 298   PrePost(Register reg, int o) : _offset(o), _r(reg) { }
 299   int offset() { return _offset; }
 300   Register reg() { return _r; }
 301 };
 302 
 303 class Pre : public PrePost {
 304 public:
 305   Pre(Register reg, int o) : PrePost(reg, o) { }
 306 };
 307 class Post : public PrePost {
 308   Register _idx;
<span class="line-added"> 309   bool _is_postreg;</span>
 310 public:
<span class="line-modified"> 311   Post(Register reg, int o) : PrePost(reg, o) { _idx = NULL; _is_postreg = false; }</span>
<span class="line-modified"> 312   Post(Register reg, Register idx) : PrePost(reg, 0) { _idx = idx; _is_postreg = true; }</span>
 313   Register idx_reg() { return _idx; }
<span class="line-added"> 314   bool is_postreg() {return _is_postreg; }</span>
 315 };
 316 
 317 namespace ext
 318 {
 319   enum operation { uxtb, uxth, uxtw, uxtx, sxtb, sxth, sxtw, sxtx };
 320 };
 321 
 322 // Addressing modes
 323 class Address {
 324  public:
 325 
 326   enum mode { no_mode, base_plus_offset, pre, post, post_reg, pcrel,
 327               base_plus_offset_reg, literal };
 328 
 329   // Shift and extend for base reg + reg offset addressing
 330   class extend {
 331     int _option, _shift;
 332     ext::operation _op;
 333   public:
 334     extend() { }
</pre>
<hr />
<pre>
 378     : _mode(no_mode) { }
 379   Address(Register r)
 380     : _base(r), _index(noreg), _offset(0), _mode(base_plus_offset), _target(0) { }
 381   Address(Register r, int o)
 382     : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }
 383   Address(Register r, long o)
 384     : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }
 385   Address(Register r, unsigned long o)
 386     : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }
 387 #ifdef ASSERT
 388   Address(Register r, ByteSize disp)
 389     : _base(r), _index(noreg), _offset(in_bytes(disp)), _mode(base_plus_offset), _target(0) { }
 390 #endif
 391   Address(Register r, Register r1, extend ext = lsl())
 392     : _base(r), _index(r1), _offset(0), _mode(base_plus_offset_reg),
 393       _ext(ext), _target(0) { }
 394   Address(Pre p)
 395     : _base(p.reg()), _offset(p.offset()), _mode(pre) { }
 396   Address(Post p)
 397     : _base(p.reg()),  _index(p.idx_reg()), _offset(p.offset()),
<span class="line-modified"> 398       _mode(p.is_postreg() ? post_reg : post), _target(0) { }</span>
 399   Address(address target, RelocationHolder const&amp; rspec)
 400     : _mode(literal),
 401       _rspec(rspec),
 402       _is_lval(false),
 403       _target(target)  { }
 404   Address(address target, relocInfo::relocType rtype = relocInfo::external_word_type);
 405   Address(Register base, RegisterOrConstant index, extend ext = lsl())
 406     : _base (base),
 407       _offset(0), _ext(ext), _target(0) {
 408     if (index.is_register()) {
 409       _mode = base_plus_offset_reg;
 410       _index = index.as_register();
 411     } else {
 412       guarantee(ext.option() == ext::uxtx, &quot;should be&quot;);
 413       assert(index.is_constant(), &quot;should be&quot;);
 414       _mode = base_plus_offset;
 415       _offset = index.as_constant() &lt;&lt; ext.shift();
 416     }
 417   }
 418 
</pre>
<hr />
<pre>
 537     size = 4 &lt;&lt; size;
 538     guarantee(_offset % size == 0, &quot;bad offset&quot;);
 539     i-&gt;sf(_offset / size, 21, 15);
 540     i-&gt;srf(_base, 5);
 541   }
 542 
 543   void encode_nontemporal_pair(Instruction_aarch64 *i) const {
 544     // Only base + offset is allowed
 545     i-&gt;f(0b000, 25, 23);
 546     unsigned size = i-&gt;get(31, 31);
 547     size = 4 &lt;&lt; size;
 548     guarantee(_offset % size == 0, &quot;bad offset&quot;);
 549     i-&gt;sf(_offset / size, 21, 15);
 550     i-&gt;srf(_base, 5);
 551     guarantee(_mode == Address::base_plus_offset,
 552               &quot;Bad addressing mode for non-temporal op&quot;);
 553   }
 554 
 555   void lea(MacroAssembler *, Register) const;
 556 
<span class="line-modified"> 557   static bool offset_ok_for_immed(long offset, int shift) {</span>
 558     unsigned mask = (1 &lt;&lt; shift) - 1;
 559     if (offset &lt; 0 || offset &amp; mask) {
 560       return (uabs(offset) &lt; (1 &lt;&lt; (20 - 12))); // Unscaled offset
 561     } else {
 562       return ((offset &gt;&gt; shift) &lt; (1 &lt;&lt; (21 - 10 + 1))); // Scaled, unsigned offset
 563     }
 564   }
 565 };
 566 
 567 // Convience classes
 568 class RuntimeAddress: public Address {
 569 
 570   public:
 571 
 572   RuntimeAddress(address target) : Address(target, relocInfo::runtime_call_type) {}
 573 
 574 };
 575 
 576 class OopAddress: public Address {
 577 
</pre>
<hr />
<pre>
 587     // Sometimes ExternalAddress is used for values which aren&#39;t
 588     // exactly addresses, like the card table base.
 589     // external_word_type can&#39;t be used for values in the first page
 590     // so just skip the reloc in that case.
 591     return external_word_Relocation::can_be_relocated(target) ? relocInfo::external_word_type : relocInfo::none;
 592   }
 593 
 594  public:
 595 
 596   ExternalAddress(address target) : Address(target, reloc_for_target(target)) {}
 597 
 598 };
 599 
 600 class InternalAddress: public Address {
 601 
 602   public:
 603 
 604   InternalAddress(address target) : Address(target, relocInfo::internal_word_type) {}
 605 };
 606 
<span class="line-modified"> 607 const int FPUStateSizeInWords = FloatRegisterImpl::number_of_registers *</span>
<span class="line-added"> 608                                 FloatRegisterImpl::save_slots_per_register;</span>
<span class="line-added"> 609 </span>
 610 typedef enum {
 611   PLDL1KEEP = 0b00000, PLDL1STRM, PLDL2KEEP, PLDL2STRM, PLDL3KEEP, PLDL3STRM,
 612   PSTL1KEEP = 0b10000, PSTL1STRM, PSTL2KEEP, PSTL2STRM, PSTL3KEEP, PSTL3STRM,
 613   PLIL1KEEP = 0b01000, PLIL1STRM, PLIL2KEEP, PLIL2STRM, PLIL3KEEP, PLIL3STRM
 614 } prfop;
 615 
 616 class Assembler : public AbstractAssembler {
 617 
 618 #ifndef PRODUCT
 619   static const unsigned long asm_bp;
 620 
 621   void emit_long(jint x) {
 622     if ((unsigned long)pc() == asm_bp)
 623       asm volatile (&quot;nop&quot;);
 624     AbstractAssembler::emit_int32(x);
 625   }
 626 #else
 627   void emit_long(jint x) {
 628     AbstractAssembler::emit_int32(x);
 629   }
 630 #endif
 631 
 632 public:
 633 
 634   enum { instruction_size = 4 };
 635 
<span class="line-added"> 636   //---&lt;  calculate length of instruction  &gt;---</span>
<span class="line-added"> 637   // We just use the values set above.</span>
<span class="line-added"> 638   // instruction must start at passed address</span>
<span class="line-added"> 639   static unsigned int instr_len(unsigned char *instr) { return instruction_size; }</span>
<span class="line-added"> 640 </span>
<span class="line-added"> 641   //---&lt;  longest instructions  &gt;---</span>
<span class="line-added"> 642   static unsigned int instr_maxlen() { return instruction_size; }</span>
<span class="line-added"> 643 </span>
 644   Address adjust(Register base, int offset, bool preIncrement) {
 645     if (preIncrement)
 646       return Address(Pre(base, offset));
 647     else
 648       return Address(Post(base, offset));
 649   }
 650 
 651   Address pre(Register base, int offset) {
 652     return adjust(base, offset, true);
 653   }
 654 
 655   Address post(Register base, int offset) {
 656     return adjust(base, offset, false);
 657   }
 658 
 659   Address post(Register base, Register idx) {
 660     return Address(Post(base, idx));
 661   }
 662 
 663   Instruction_aarch64* current;
</pre>
<hr />
<pre>
 794   // Move wide (immediate)
 795 #define INSN(NAME, opcode)                                              \
 796   void NAME(Register Rd, unsigned imm, unsigned shift = 0) {            \
 797     assert_cond((shift/16)*16 == shift);                                \
 798     starti;                                                             \
 799     f(opcode, 31, 29), f(0b100101, 28, 23), f(shift/16, 22, 21),        \
 800       f(imm, 20, 5);                                                    \
 801     rf(Rd, 0);                                                          \
 802   }
 803 
 804   INSN(movnw, 0b000);
 805   INSN(movzw, 0b010);
 806   INSN(movkw, 0b011);
 807   INSN(movn, 0b100);
 808   INSN(movz, 0b110);
 809   INSN(movk, 0b111);
 810 
 811 #undef INSN
 812 
 813   // Bitfield
<span class="line-modified"> 814 #define INSN(NAME, opcode, size)                                        \</span>
 815   void NAME(Register Rd, Register Rn, unsigned immr, unsigned imms) {   \
 816     starti;                                                             \
<span class="line-added"> 817     guarantee(size == 1 || (immr &lt; 32 &amp;&amp; imms &lt; 32), &quot;incorrect immr/imms&quot;);\</span>
 818     f(opcode, 31, 22), f(immr, 21, 16), f(imms, 15, 10);                \
 819     zrf(Rn, 5), rf(Rd, 0);                                              \
 820   }
 821 
<span class="line-modified"> 822   INSN(sbfmw, 0b0001001100, 0);</span>
<span class="line-modified"> 823   INSN(bfmw,  0b0011001100, 0);</span>
<span class="line-modified"> 824   INSN(ubfmw, 0b0101001100, 0);</span>
<span class="line-modified"> 825   INSN(sbfm,  0b1001001101, 1);</span>
<span class="line-modified"> 826   INSN(bfm,   0b1011001101, 1);</span>
<span class="line-modified"> 827   INSN(ubfm,  0b1101001101, 1);</span>
 828 
 829 #undef INSN
 830 
 831   // Extract
<span class="line-modified"> 832 #define INSN(NAME, opcode, size)                                        \</span>
 833   void NAME(Register Rd, Register Rn, Register Rm, unsigned imms) {     \
 834     starti;                                                             \
<span class="line-added"> 835     guarantee(size == 1 || imms &lt; 32, &quot;incorrect imms&quot;);                \</span>
 836     f(opcode, 31, 21), f(imms, 15, 10);                                 \
<span class="line-modified"> 837     zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                                \</span>
 838   }
 839 
<span class="line-modified"> 840   INSN(extrw, 0b00010011100, 0);</span>
<span class="line-modified"> 841   INSN(extr,  0b10010011110, 1);</span>
 842 
 843 #undef INSN
 844 
 845   // The maximum range of a branch is fixed for the AArch64
 846   // architecture.  In debug mode we shrink it in order to test
 847   // trampolines, but not so small that branches in the interpreter
 848   // are out of range.
 849   static const unsigned long branch_range = NOT_DEBUG(128 * M) DEBUG_ONLY(2 * M);
 850 
 851   static bool reachable_from_branch_at(address branch, address target) {
 852     return uabs(target - branch) &lt; branch_range;
 853   }
 854 
 855   // Unconditional branch (immediate)
 856 #define INSN(NAME, opcode)                                              \
 857   void NAME(address dest) {                                             \
 858     starti;                                                             \
 859     long offset = (dest - pc()) &gt;&gt; 2;                                   \
 860     DEBUG_ONLY(assert(reachable_from_branch_at(pc(), dest), &quot;debug only&quot;)); \
 861     f(opcode, 31), f(0b00101, 30, 26), sf(offset, 25, 0);               \
</pre>
<hr />
<pre>
1043     system(0b00, 0b011, 0b00011, imm, 0b100);
1044   }
1045 
1046   void dmb(barrier imm) {
1047     system(0b00, 0b011, 0b00011, imm, 0b101);
1048   }
1049 
1050   void isb() {
1051     system(0b00, 0b011, 0b00011, SY, 0b110);
1052   }
1053 
1054   void sys(int op1, int CRn, int CRm, int op2,
1055            Register rt = (Register)0b11111) {
1056     system(0b01, op1, CRn, CRm, op2, rt);
1057   }
1058 
1059   // Only implement operations accessible from EL0 or higher, i.e.,
1060   //            op1    CRn    CRm    op2
1061   // IC IVAU     3      7      5      1
1062   // DC CVAC     3      7      10     1
<span class="line-added">1063   // DC CVAP     3      7      12     1</span>
1064   // DC CVAU     3      7      11     1
1065   // DC CIVAC    3      7      14     1
1066   // DC ZVA      3      7      4      1
1067   // So only deal with the CRm field.
1068   enum icache_maintenance {IVAU = 0b0101};
<span class="line-modified">1069   enum dcache_maintenance {CVAC = 0b1010, CVAP = 0b1100, CVAU = 0b1011, CIVAC = 0b1110, ZVA = 0b100};</span>
1070 
1071   void dc(dcache_maintenance cm, Register Rt) {
1072     sys(0b011, 0b0111, cm, 0b001, Rt);
1073   }
1074 
1075   void ic(icache_maintenance cm, Register Rt) {
1076     sys(0b011, 0b0111, cm, 0b001, Rt);
1077   }
1078 
1079   // A more convenient access to dmb for our purposes
1080   enum Membar_mask_bits {
1081     // We can use ISH for a barrier because the ARM ARM says &quot;This
1082     // architecture assumes that all Processing Elements that use the
1083     // same operating system or hypervisor are in the same Inner
1084     // Shareable shareability domain.&quot;
1085     StoreStore = ISHST,
1086     LoadStore  = ISHLD,
1087     LoadLoad   = ISHLD,
1088     StoreLoad  = ISH,
1089     AnyAny     = ISH
</pre>
<hr />
<pre>
1116 
1117 #undef INSN
1118 
1119 #define INSN(NAME, opc)                         \
1120   void NAME() {                 \
1121     branch_reg(dummy_reg, opc);         \
1122   }
1123 
1124   INSN(eret, 0b0100);
1125   INSN(drps, 0b0101);
1126 
1127 #undef INSN
1128 
1129   // Load/store exclusive
1130   enum operand_size { byte, halfword, word, xword };
1131 
1132   void load_store_exclusive(Register Rs, Register Rt1, Register Rt2,
1133     Register Rn, enum operand_size sz, int op, bool ordered) {
1134     starti;
1135     f(sz, 31, 30), f(0b001000, 29, 24), f(op, 23, 21);
<span class="line-modified">1136     rf(Rs, 16), f(ordered, 15), zrf(Rt2, 10), srf(Rn, 5), zrf(Rt1, 0);</span>
1137   }
1138 
1139   void load_exclusive(Register dst, Register addr,
1140                       enum operand_size sz, bool ordered) {
1141     load_store_exclusive(dummy_reg, dst, dummy_reg, addr,
1142                          sz, 0b010, ordered);
1143   }
1144 
1145   void store_exclusive(Register status, Register new_val, Register addr,
1146                        enum operand_size sz, bool ordered) {
1147     load_store_exclusive(status, new_val, dummy_reg, addr,
1148                          sz, 0b000, ordered);
1149   }
1150 
1151 #define INSN4(NAME, sz, op, o0) /* Four registers */                    \
1152   void NAME(Register Rs, Register Rt1, Register Rt2, Register Rn) {     \
1153     guarantee(Rs != Rn &amp;&amp; Rs != Rt1 &amp;&amp; Rs != Rt2, &quot;unpredictable instruction&quot;); \
1154     load_store_exclusive(Rs, Rt1, Rt2, Rn, sz, op, o0);                 \
1155   }
1156 
</pre>
<hr />
<pre>
1209   INSN2(ldaxr, xword, 0b010, 1);
1210   INSN_FOO(ldxp, xword, 0b011, 0);
1211   INSN_FOO(ldaxp, xword, 0b011, 1);
1212   INSN2(stlr, xword, 0b100, 1);
1213   INSN2(ldar, xword, 0b110, 1);
1214 
1215 #undef INSN2
1216 #undef INSN3
1217 #undef INSN4
1218 #undef INSN_FOO
1219 
1220   // 8.1 Compare and swap extensions
1221   void lse_cas(Register Rs, Register Rt, Register Rn,
1222                         enum operand_size sz, bool a, bool r, bool not_pair) {
1223     starti;
1224     if (! not_pair) { // Pair
1225       assert(sz == word || sz == xword, &quot;invalid size&quot;);
1226       /* The size bit is in bit 30, not 31 */
1227       sz = (operand_size)(sz == word ? 0b00:0b01);
1228     }
<span class="line-modified">1229     f(sz, 31, 30), f(0b001000, 29, 24), f(not_pair ? 1 : 0, 23), f(a, 22), f(1, 21);</span>
<span class="line-modified">1230     zrf(Rs, 16), f(r, 15), f(0b11111, 14, 10), srf(Rn, 5), zrf(Rt, 0);</span>
1231   }
1232 
1233   // CAS
1234 #define INSN(NAME, a, r)                                                \
1235   void NAME(operand_size sz, Register Rs, Register Rt, Register Rn) {   \
1236     assert(Rs != Rn &amp;&amp; Rs != Rt, &quot;unpredictable instruction&quot;);          \
1237     lse_cas(Rs, Rt, Rn, sz, a, r, true);                                \
1238   }
1239   INSN(cas,    false, false)
1240   INSN(casa,   true,  false)
1241   INSN(casl,   false, true)
1242   INSN(casal,  true,  true)
1243 #undef INSN
1244 
1245   // CASP
1246 #define INSN(NAME, a, r)                                                \
1247   void NAME(operand_size sz, Register Rs, Register Rs1,                 \
1248             Register Rt, Register Rt1, Register Rn) {                   \
1249     assert((Rs-&gt;encoding() &amp; 1) == 0 &amp;&amp; (Rt-&gt;encoding() &amp; 1) == 0 &amp;&amp;    \
1250            Rs-&gt;successor() == Rs1 &amp;&amp; Rt-&gt;successor() == Rt1 &amp;&amp;          \
1251            Rs != Rn &amp;&amp; Rs1 != Rn &amp;&amp; Rs != Rt, &quot;invalid registers&quot;);     \
1252     lse_cas(Rs, Rt, Rn, sz, a, r, false);                               \
1253   }
1254   INSN(casp,    false, false)
1255   INSN(caspa,   true,  false)
1256   INSN(caspl,   false, true)
1257   INSN(caspal,  true,  true)
1258 #undef INSN
1259 
1260   // 8.1 Atomic operations
1261   void lse_atomic(Register Rs, Register Rt, Register Rn,
1262                   enum operand_size sz, int op1, int op2, bool a, bool r) {
1263     starti;
1264     f(sz, 31, 30), f(0b111000, 29, 24), f(a, 23), f(r, 22), f(1, 21);
<span class="line-modified">1265     zrf(Rs, 16), f(op1, 15), f(op2, 14, 12), f(0, 11, 10), srf(Rn, 5), zrf(Rt, 0);</span>
1266   }
1267 
1268 #define INSN(NAME, NAME_A, NAME_L, NAME_AL, op1, op2)                   \
1269   void NAME(operand_size sz, Register Rs, Register Rt, Register Rn) {   \
1270     lse_atomic(Rs, Rt, Rn, sz, op1, op2, false, false);                 \
1271   }                                                                     \
1272   void NAME_A(operand_size sz, Register Rs, Register Rt, Register Rn) { \
1273     lse_atomic(Rs, Rt, Rn, sz, op1, op2, true, false);                  \
1274   }                                                                     \
1275   void NAME_L(operand_size sz, Register Rs, Register Rt, Register Rn) { \
1276     lse_atomic(Rs, Rt, Rn, sz, op1, op2, false, true);                  \
1277   }                                                                     \
1278   void NAME_AL(operand_size sz, Register Rs, Register Rt, Register Rn) {\
1279     lse_atomic(Rs, Rt, Rn, sz, op1, op2, true, true);                   \
1280   }
1281   INSN(ldadd,  ldadda,  ldaddl,  ldaddal,  0, 0b000);
1282   INSN(ldbic,  ldbica,  ldbicl,  ldbical,  0, 0b001);
1283   INSN(ldeor,  ldeora,  ldeorl,  ldeoral,  0, 0b010);
1284   INSN(ldorr,  ldorra,  ldorrl,  ldorral,  0, 0b011);
1285   INSN(ldsmax, ldsmaxa, ldsmaxl, ldsmaxal, 0, 0b100);
</pre>
<hr />
<pre>
1467 
1468 #undef INSN
1469 
1470   enum shift_kind { LSL, LSR, ASR, ROR };
1471 
1472   void op_shifted_reg(unsigned decode,
1473                       enum shift_kind kind, unsigned shift,
1474                       unsigned size, unsigned op) {
1475     f(size, 31);
1476     f(op, 30, 29);
1477     f(decode, 28, 24);
1478     f(shift, 15, 10);
1479     f(kind, 23, 22);
1480   }
1481 
1482   // Logical (shifted register)
1483 #define INSN(NAME, size, op, N)                                 \
1484   void NAME(Register Rd, Register Rn, Register Rm,              \
1485             enum shift_kind kind = LSL, unsigned shift = 0) {   \
1486     starti;                                                     \
<span class="line-added">1487     guarantee(size == 1 || shift &lt; 32, &quot;incorrect shift&quot;);      \</span>
1488     f(N, 21);                                                   \
1489     zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                        \
1490     op_shifted_reg(0b01010, kind, shift, size, op);             \
1491   }
1492 
1493   INSN(andr, 1, 0b00, 0);
1494   INSN(orr, 1, 0b01, 0);
1495   INSN(eor, 1, 0b10, 0);
1496   INSN(ands, 1, 0b11, 0);
1497   INSN(andw, 0, 0b00, 0);
1498   INSN(orrw, 0, 0b01, 0);
1499   INSN(eorw, 0, 0b10, 0);
1500   INSN(andsw, 0, 0b11, 0);
1501 
<span class="line-added">1502 #undef INSN</span>
<span class="line-added">1503 </span>
<span class="line-added">1504 #define INSN(NAME, size, op, N)                                         \</span>
<span class="line-added">1505   void NAME(Register Rd, Register Rn, Register Rm,                      \</span>
<span class="line-added">1506             enum shift_kind kind = LSL, unsigned shift = 0) {           \</span>
<span class="line-added">1507     starti;                                                             \</span>
<span class="line-added">1508     f(N, 21);                                                           \</span>
<span class="line-added">1509     zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                                \</span>
<span class="line-added">1510     op_shifted_reg(0b01010, kind, shift, size, op);                     \</span>
<span class="line-added">1511   }                                                                     \</span>
<span class="line-added">1512                                                                         \</span>
<span class="line-added">1513   /* These instructions have no immediate form. Provide an overload so  \</span>
<span class="line-added">1514      that if anyone does try to use an immediate operand -- this has    \</span>
<span class="line-added">1515      happened! -- we&#39;ll get a compile-time error. */                    \</span>
<span class="line-added">1516   void NAME(Register Rd, Register Rn, unsigned imm,                     \</span>
<span class="line-added">1517             enum shift_kind kind = LSL, unsigned shift = 0) {           \</span>
<span class="line-added">1518     assert(false, &quot; can&#39;t be used with immediate operand&quot;);             \</span>
<span class="line-added">1519   }</span>
<span class="line-added">1520 </span>
1521   INSN(bic, 1, 0b00, 1);
1522   INSN(orn, 1, 0b01, 1);
1523   INSN(eon, 1, 0b10, 1);
1524   INSN(bics, 1, 0b11, 1);
1525   INSN(bicw, 0, 0b00, 1);
1526   INSN(ornw, 0, 0b01, 1);
1527   INSN(eonw, 0, 0b10, 1);
1528   INSN(bicsw, 0, 0b11, 1);
1529 
1530 #undef INSN
1531 
1532   // Aliases for short forms of orn
1533 void mvn(Register Rd, Register Rm,
1534             enum shift_kind kind = LSL, unsigned shift = 0) {
1535   orn(Rd, zr, Rm, kind, shift);
1536 }
1537 
1538 void mvnw(Register Rd, Register Rm,
1539             enum shift_kind kind = LSL, unsigned shift = 0) {
1540   ornw(Rd, zr, Rm, kind, shift);
1541 }
1542 
1543   // Add/subtract (shifted register)
1544 #define INSN(NAME, size, op)                            \
1545   void NAME(Register Rd, Register Rn, Register Rm,      \
1546             enum shift_kind kind, unsigned shift = 0) { \
1547     starti;                                             \
1548     f(0, 21);                                           \
1549     assert_cond(kind != ROR);                           \
<span class="line-added">1550     guarantee(size == 1 || shift &lt; 32, &quot;incorrect shift&quot;);\</span>
1551     zrf(Rd, 0), zrf(Rn, 5), zrf(Rm, 16);                \
1552     op_shifted_reg(0b01011, kind, shift, size, op);     \
1553   }
1554 
1555   INSN(add, 1, 0b000);
1556   INSN(sub, 1, 0b10);
1557   INSN(addw, 0, 0b000);
1558   INSN(subw, 0, 0b10);
1559 
1560   INSN(adds, 1, 0b001);
1561   INSN(subs, 1, 0b11);
1562   INSN(addsw, 0, 0b001);
1563   INSN(subsw, 0, 0b11);
1564 
1565 #undef INSN
1566 
1567   // Add/subtract (extended register)
1568 #define INSN(NAME, op)                                                  \
1569   void NAME(Register Rd, Register Rn, Register Rm,                      \
1570            ext::operation option, int amount = 0) {                     \
1571     starti;                                                             \
1572     zrf(Rm, 16), srf(Rn, 5), srf(Rd, 0);                                \
1573     add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \
1574   }
1575 
1576   void add_sub_extended_reg(unsigned op, unsigned decode,
1577     Register Rd, Register Rn, Register Rm,
1578     unsigned opt, ext::operation option, unsigned imm) {
<span class="line-modified">1579     guarantee(imm &lt;= 4, &quot;shift amount must be &lt;= 4&quot;);</span>
1580     f(op, 31, 29), f(decode, 28, 24), f(opt, 23, 22), f(1, 21);
1581     f(option, 15, 13), f(imm, 12, 10);
1582   }
1583 
1584   INSN(addw, 0b000);
1585   INSN(subw, 0b010);
1586   INSN(add, 0b100);
1587   INSN(sub, 0b110);
1588 
1589 #undef INSN
1590 
1591 #define INSN(NAME, op)                                                  \
1592   void NAME(Register Rd, Register Rn, Register Rm,                      \
1593            ext::operation option, int amount = 0) {                     \
1594     starti;                                                             \
1595     zrf(Rm, 16), srf(Rn, 5), zrf(Rd, 0);                                \
1596     add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \
1597   }
1598 
1599   INSN(addsw, 0b001);
</pre>
<hr />
<pre>
1644   INSN(sbcsw, 0b011);
1645   INSN(adc, 0b100);
1646   INSN(adcs, 0b101);
1647   INSN(sbc,0b110);
1648   INSN(sbcs, 0b111);
1649 
1650 #undef INSN
1651 
1652   // Conditional compare (both kinds)
1653   void conditional_compare(unsigned op, int o1, int o2, int o3,
1654                            Register Rn, unsigned imm5, unsigned nzcv,
1655                            unsigned cond) {
1656     starti;
1657     f(op, 31, 29);
1658     f(0b11010010, 28, 21);
1659     f(cond, 15, 12);
1660     f(o1, 11);
1661     f(o2, 10);
1662     f(o3, 4);
1663     f(nzcv, 3, 0);
<span class="line-modified">1664     f(imm5, 20, 16), zrf(Rn, 5);</span>
1665   }
1666 
1667 #define INSN(NAME, op)                                                  \
1668   void NAME(Register Rn, Register Rm, int imm, Condition cond) {        \
1669     int regNumber = (Rm == zr ? 31 : (uintptr_t)Rm);                    \
1670     conditional_compare(op, 0, 0, 0, Rn, regNumber, imm, cond);         \
1671   }                                                                     \
1672                                                                         \
1673   void NAME(Register Rn, int imm5, int imm, Condition cond) {           \
1674     conditional_compare(op, 1, 0, 0, Rn, imm5, imm, cond);              \
1675   }
1676 
1677   INSN(ccmnw, 0b001);
1678   INSN(ccmpw, 0b011);
1679   INSN(ccmn, 0b101);
1680   INSN(ccmp, 0b111);
1681 
1682 #undef INSN
1683 
1684   // Conditional select
</pre>
<hr />
<pre>
2113 #define INSN(NAME, op)                                            \
2114   void NAME(FloatRegister Rt, SIMD_RegVariant T, const Address &amp;adr) {   \
2115     ld_st2((Register)Rt, adr, (int)T &amp; 3, op + ((T==Q) ? 0b10:0b00), 1); \
2116   }                                                                      \
2117 
2118   INSN(ldr, 1);
2119   INSN(str, 0);
2120 
2121 #undef INSN
2122 
2123  private:
2124 
2125   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn, int op1, int op2) {
2126     starti;
2127     f(0,31), f((int)T &amp; 1, 30);
2128     f(op1, 29, 21), f(0, 20, 16), f(op2, 15, 12);
2129     f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
2130   }
2131   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn,
2132              int imm, int op1, int op2, int regs) {
<span class="line-modified">2133 </span>
<span class="line-added">2134     bool replicate = op2 &gt;&gt; 2 == 3;</span>
<span class="line-added">2135     // post-index value (imm) is formed differently for replicate/non-replicate ld* instructions</span>
<span class="line-added">2136     int expectedImmediate = replicate ? regs * (1 &lt;&lt; (T &gt;&gt; 1)) : SIMD_Size_in_bytes[T] * regs;</span>
<span class="line-added">2137     guarantee(T &lt; T1Q , &quot;incorrect arrangement&quot;);</span>
<span class="line-added">2138     guarantee(imm == expectedImmediate, &quot;bad offset&quot;);</span>
2139     starti;
2140     f(0,31), f((int)T &amp; 1, 30);
2141     f(op1 | 0b100, 29, 21), f(0b11111, 20, 16), f(op2, 15, 12);
2142     f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
2143   }
2144   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn,
2145              Register Xm, int op1, int op2) {
2146     starti;
2147     f(0,31), f((int)T &amp; 1, 30);
2148     f(op1 | 0b100, 29, 21), rf(Xm, 16), f(op2, 15, 12);
2149     f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
2150   }
2151 
2152   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Address a, int op1, int op2, int regs) {
2153     switch (a.getMode()) {
2154     case Address::base_plus_offset:
2155       guarantee(a.offset() == 0, &quot;no offset allowed here&quot;);
2156       ld_st(Vt, T, a.base(), op1, op2);
2157       break;
2158     case Address::post:
</pre>
<hr />
<pre>
2225 
2226 #define INSN(NAME, opc)                                                                 \
2227   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
2228     starti;                                                                             \
2229     assert(T == T8B || T == T16B, &quot;must be T8B or T16B&quot;);                               \
2230     f(0, 31), f((int)T &amp; 1, 30), f(opc, 29, 21);                                        \
2231     rf(Vm, 16), f(0b000111, 15, 10), rf(Vn, 5), rf(Vd, 0);                              \
2232   }
2233 
2234   INSN(eor,  0b101110001);
2235   INSN(orr,  0b001110101);
2236   INSN(andr, 0b001110001);
2237   INSN(bic,  0b001110011);
2238   INSN(bif,  0b101110111);
2239   INSN(bit,  0b101110101);
2240   INSN(bsl,  0b101110011);
2241   INSN(orn,  0b001110111);
2242 
2243 #undef INSN
2244 
<span class="line-modified">2245 #define INSN(NAME, opc, opc2, acceptT2D)                                                \</span>
2246   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
<span class="line-added">2247     guarantee(T != T1Q &amp;&amp; T != T1D, &quot;incorrect arrangement&quot;);                           \</span>
<span class="line-added">2248     if (!acceptT2D) guarantee(T != T2D, &quot;incorrect arrangement&quot;);                       \</span>
2249     starti;                                                                             \
2250     f(0, 31), f((int)T &amp; 1, 30), f(opc, 29), f(0b01110, 28, 24);                        \
2251     f((int)T &gt;&gt; 1, 23, 22), f(1, 21), rf(Vm, 16), f(opc2, 15, 10);                      \
2252     rf(Vn, 5), rf(Vd, 0);                                                               \
2253   }
2254 
<span class="line-modified">2255   INSN(addv,   0, 0b100001, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D</span>
<span class="line-modified">2256   INSN(subv,   1, 0b100001, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D</span>
<span class="line-modified">2257   INSN(mulv,   0, 0b100111, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S</span>
<span class="line-modified">2258   INSN(mlav,   0, 0b100101, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S</span>
<span class="line-modified">2259   INSN(mlsv,   1, 0b100101, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S</span>
<span class="line-modified">2260   INSN(sshl,   0, 0b010001, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D</span>
<span class="line-modified">2261   INSN(ushl,   1, 0b010001, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D</span>
<span class="line-modified">2262   INSN(umullv, 1, 0b110000, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S</span>
<span class="line-modified">2263   INSN(umlalv, 1, 0b100000, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S</span>
2264 
2265 #undef INSN
2266 
<span class="line-modified">2267 #define INSN(NAME, opc, opc2, accepted) \</span>
2268   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                   \
<span class="line-added">2269     guarantee(T != T1Q &amp;&amp; T != T1D, &quot;incorrect arrangement&quot;);                           \</span>
<span class="line-added">2270     if (accepted &lt; 2) guarantee(T != T2S &amp;&amp; T != T2D, &quot;incorrect arrangement&quot;);         \</span>
<span class="line-added">2271     if (accepted == 0) guarantee(T == T8B || T == T16B, &quot;incorrect arrangement&quot;);       \</span>
2272     starti;                                                                             \
2273     f(0, 31), f((int)T &amp; 1, 30), f(opc, 29), f(0b01110, 28, 24);                        \
2274     f((int)T &gt;&gt; 1, 23, 22), f(opc2, 21, 10);                                            \
2275     rf(Vn, 5), rf(Vd, 0);                                                               \
2276   }
2277 
<span class="line-modified">2278   INSN(absr,   0, 0b100000101110, 1); // accepted arrangements: T8B, T16B, T4H, T8H,      T4S</span>
<span class="line-modified">2279   INSN(negr,   1, 0b100000101110, 2); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D</span>
<span class="line-modified">2280   INSN(notr,   1, 0b100000010110, 0); // accepted arrangements: T8B, T16B</span>
<span class="line-modified">2281   INSN(addv,   0, 0b110001101110, 1); // accepted arrangements: T8B, T16B, T4H, T8H,      T4S</span>
<span class="line-modified">2282   INSN(cls,    0, 0b100000010010, 1); // accepted arrangements: T8B, T16B, T4H, T8H,      T4S</span>
<span class="line-modified">2283   INSN(clz,    1, 0b100000010010, 1); // accepted arrangements: T8B, T16B, T4H, T8H,      T4S</span>
<span class="line-modified">2284   INSN(cnt,    0, 0b100000010110, 0); // accepted arrangements: T8B, T16B</span>
<span class="line-modified">2285   INSN(uaddlv, 1, 0b110000001110, 1); // accepted arrangements: T8B, T16B, T4H, T8H,      T4S</span>
2286 
2287 #undef INSN
2288 
2289 #define INSN(NAME, opc) \
2290   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                  \
2291     starti;                                                                            \
2292     assert(T == T4S, &quot;arrangement must be T4S&quot;);                                       \
2293     f(0, 31), f((int)T &amp; 1, 30), f(0b101110, 29, 24), f(opc, 23),                      \
2294     f(T == T4S ? 0 : 1, 22), f(0b110000111110, 21, 10); rf(Vn, 5), rf(Vd, 0);          \
2295   }
2296 
2297   INSN(fmaxv, 0);
2298   INSN(fminv, 1);
2299 
2300 #undef INSN
2301 
2302 #define INSN(NAME, op0, cmode0) \
2303   void NAME(FloatRegister Vd, SIMD_Arrangement T, unsigned imm8, unsigned lsl = 0) {   \
2304     unsigned cmode = cmode0;                                                           \
2305     unsigned op = op0;                                                                 \
2306     starti;                                                                            \
2307     assert(lsl == 0 ||                                                                 \
2308            ((T == T4H || T == T8H) &amp;&amp; lsl == 8) ||                                     \
<span class="line-modified">2309            ((T == T2S || T == T4S) &amp;&amp; ((lsl &gt;&gt; 3) &lt; 4) &amp;&amp; ((lsl &amp; 7) == 0)), &quot;invalid shift&quot;);\</span>
2310     cmode |= lsl &gt;&gt; 2;                                                                 \
2311     if (T == T4H || T == T8H) cmode |= 0b1000;                                         \
2312     if (!(T == T4H || T == T8H || T == T2S || T == T4S)) {                             \
2313       assert(op == 0 &amp;&amp; cmode0 == 0, &quot;must be MOVI&quot;);                                  \
2314       cmode = 0b1110;                                                                  \
2315       if (T == T1D || T == T2D) op = 1;                                                \
2316     }                                                                                  \
2317     f(0, 31), f((int)T &amp; 1, 30), f(op, 29), f(0b0111100000, 28, 19);                   \
2318     f(imm8 &gt;&gt; 5, 18, 16), f(cmode, 15, 12), f(0x01, 11, 10), f(imm8 &amp; 0b11111, 9, 5);  \
2319     rf(Vd, 0);                                                                         \
2320   }
2321 
2322   INSN(movi, 0, 0);
2323   INSN(orri, 0, 1);
2324   INSN(mvni, 1, 0);
2325   INSN(bici, 1, 1);
2326 
2327 #undef INSN
2328 
2329 #define INSN(NAME, op1, op2, op3) \
</pre>
<hr />
<pre>
2450      * for SHL shift is calculated as:                                  \
2451      *   0001 xxx       8B/16B, shift = UInt(immh:immb) - 8             \
2452      *   001x xxx       4H/8H,  shift = UInt(immh:immb) - 16            \
2453      *   01xx xxx       2S/4S,  shift = UInt(immh:immb) - 32            \
2454      *   1xxx xxx       1D/2D,  shift = UInt(immh:immb) - 64            \
2455      *   (1D is RESERVED)                                               \
2456      */                                                                 \
2457     assert((1 &lt;&lt; ((T&gt;&gt;1)+3)) &gt; shift, &quot;Invalid Shift value&quot;);           \
2458     int cVal = (1 &lt;&lt; (((T &gt;&gt; 1) + 3) + (isSHR ? 1 : 0)));               \
2459     int encodedShift = isSHR ? cVal - shift : cVal + shift;             \
2460     f(0, 31), f(T &amp; 1, 30), f(opc, 29), f(0b011110, 28, 23),            \
2461     f(encodedShift, 22, 16); f(opc2, 15, 10), rf(Vn, 5), rf(Vd, 0);     \
2462   }
2463 
2464   INSN(shl,  0, 0b010101, /* isSHR = */ false);
2465   INSN(sshr, 0, 0b000001, /* isSHR = */ true);
2466   INSN(ushr, 1, 0b000001, /* isSHR = */ true);
2467 
2468 #undef INSN
2469 
<span class="line-modified">2470 private:</span>
<span class="line-added">2471   void _ushll(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, SIMD_Arrangement Tb, int shift) {</span>
2472     starti;
2473     /* The encodings for the immh:immb fields (bits 22:16) are
2474      *   0001 xxx       8H, 8B/16b shift = xxx
2475      *   001x xxx       4S, 4H/8H  shift = xxxx
2476      *   01xx xxx       2D, 2S/4S  shift = xxxxx
2477      *   1xxx xxx       RESERVED
2478      */
2479     assert((Tb &gt;&gt; 1) + 1 == (Ta &gt;&gt; 1), &quot;Incompatible arrangement&quot;);
2480     assert((1 &lt;&lt; ((Tb&gt;&gt;1)+3)) &gt; shift, &quot;Invalid shift value&quot;);
2481     f(0, 31), f(Tb &amp; 1, 30), f(0b1011110, 29, 23), f((1 &lt;&lt; ((Tb&gt;&gt;1)+3))|shift, 22, 16);
2482     f(0b101001, 15, 10), rf(Vn, 5), rf(Vd, 0);
2483   }
<span class="line-added">2484 </span>
<span class="line-added">2485 public:</span>
<span class="line-added">2486   void ushll(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn,  SIMD_Arrangement Tb, int shift) {</span>
<span class="line-added">2487     assert(Tb == T8B || Tb == T4H || Tb == T2S, &quot;invalid arrangement&quot;);</span>
<span class="line-added">2488     _ushll(Vd, Ta, Vn, Tb, shift);</span>
<span class="line-added">2489   }</span>
<span class="line-added">2490 </span>
2491   void ushll2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn,  SIMD_Arrangement Tb, int shift) {
<span class="line-modified">2492     assert(Tb == T16B || Tb == T8H || Tb == T4S, &quot;invalid arrangement&quot;);</span>
<span class="line-added">2493     _ushll(Vd, Ta, Vn, Tb, shift);</span>
2494   }
2495 
2496   // Move from general purpose register
2497   //   mov  Vd.T[index], Rn
2498   void mov(FloatRegister Vd, SIMD_Arrangement T, int index, Register Xn) {
2499     starti;
2500     f(0b01001110000, 31, 21), f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
<span class="line-modified">2501     f(0b000111, 15, 10), zrf(Xn, 5), rf(Vd, 0);</span>
2502   }
2503 
2504   // Move to general purpose register
2505   //   mov  Rd, Vn.T[index]
2506   void mov(Register Xd, FloatRegister Vn, SIMD_Arrangement T, int index) {
<span class="line-added">2507     guarantee(T &gt;= T2S &amp;&amp; T &lt; T1Q, &quot;only D and S arrangements are supported&quot;);</span>
2508     starti;
2509     f(0, 31), f((T &gt;= T1D) ? 1:0, 30), f(0b001110000, 29, 21);
2510     f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
2511     f(0b001111, 15, 10), rf(Vn, 5), rf(Xd, 0);
2512   }
2513 
<span class="line-modified">2514 private:</span>
<span class="line-added">2515   void _pmull(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {</span>
2516     starti;
2517     assert((Ta == T1Q &amp;&amp; (Tb == T1D || Tb == T2D)) ||
2518            (Ta == T8H &amp;&amp; (Tb == T8B || Tb == T16B)), &quot;Invalid Size specifier&quot;);
2519     int size = (Ta == T1Q) ? 0b11 : 0b00;
2520     f(0, 31), f(Tb &amp; 1, 30), f(0b001110, 29, 24), f(size, 23, 22);
2521     f(1, 21), rf(Vm, 16), f(0b111000, 15, 10), rf(Vn, 5), rf(Vd, 0);
2522   }
<span class="line-added">2523 </span>
<span class="line-added">2524 public:</span>
<span class="line-added">2525   void pmull(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {</span>
<span class="line-added">2526     assert(Tb == T1D || Tb == T8B, &quot;pmull assumes T1D or T8B as the second size specifier&quot;);</span>
<span class="line-added">2527     _pmull(Vd, Ta, Vn, Vm, Tb);</span>
<span class="line-added">2528   }</span>
<span class="line-added">2529 </span>
2530   void pmull2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {
2531     assert(Tb == T2D || Tb == T16B, &quot;pmull2 assumes T2D or T16B as the second size specifier&quot;);
<span class="line-modified">2532     _pmull(Vd, Ta, Vn, Vm, Tb);</span>
2533   }
2534 
2535   void uqxtn(FloatRegister Vd, SIMD_Arrangement Tb, FloatRegister Vn, SIMD_Arrangement Ta) {
2536     starti;
2537     int size_b = (int)Tb &gt;&gt; 1;
2538     int size_a = (int)Ta &gt;&gt; 1;
2539     assert(size_b &lt; 3 &amp;&amp; size_b == size_a - 1, &quot;Invalid size specifier&quot;);
2540     f(0, 31), f(Tb &amp; 1, 30), f(0b101110, 29, 24), f(size_b, 23, 22);
2541     f(0b100001010010, 21, 10), rf(Vn, 5), rf(Vd, 0);
2542   }
2543 
2544   void dup(FloatRegister Vd, SIMD_Arrangement T, Register Xs)
2545   {
2546     starti;
2547     assert(T != T1D, &quot;reserved encoding&quot;);
2548     f(0,31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21);
<span class="line-modified">2549     f((1 &lt;&lt; (T &gt;&gt; 1)), 20, 16), f(0b000011, 15, 10), zrf(Xs, 5), rf(Vd, 0);</span>
2550   }
2551 
2552   void dup(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int index = 0)
2553   {
2554     starti;
2555     assert(T != T1D, &quot;reserved encoding&quot;);
2556     f(0, 31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21);
2557     f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
2558     f(0b000001, 15, 10), rf(Vn, 5), rf(Vd, 0);
2559   }
2560 
2561   // AdvSIMD ZIP/UZP/TRN
2562 #define INSN(NAME, opcode)                                              \
2563   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
<span class="line-added">2564     guarantee(T != T1D &amp;&amp; T != T1Q, &quot;invalid arrangement&quot;);             \</span>
2565     starti;                                                             \
2566     f(0, 31), f(0b001110, 29, 24), f(0, 21), f(0, 15);                  \
2567     f(opcode, 14, 12), f(0b10, 11, 10);                                 \
2568     rf(Vm, 16), rf(Vn, 5), rf(Vd, 0);                                   \
2569     f(T &amp; 1, 30), f(T &gt;&gt; 1, 23, 22);                                    \
2570   }
2571 
2572   INSN(uzp1, 0b001);
2573   INSN(trn1, 0b010);
2574   INSN(zip1, 0b011);
2575   INSN(uzp2, 0b101);
2576   INSN(trn2, 0b110);
2577   INSN(zip2, 0b111);
2578 
2579 #undef INSN
2580 
2581   // CRC32 instructions
2582 #define INSN(NAME, c, sf, sz)                                             \
2583   void NAME(Register Rd, Register Rn, Register Rm) {                      \
2584     starti;                                                               \
</pre>
<hr />
<pre>
2596   INSN(crc32cx, 1, 1, 0b11);
2597 
2598 #undef INSN
2599 
2600   // Table vector lookup
2601 #define INSN(NAME, op)                                                  \
2602   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, unsigned registers, FloatRegister Vm) { \
2603     starti;                                                             \
2604     assert(T == T8B || T == T16B, &quot;invalid arrangement&quot;);               \
2605     assert(0 &lt; registers &amp;&amp; registers &lt;= 4, &quot;invalid number of registers&quot;); \
2606     f(0, 31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21), rf(Vm, 16), f(0, 15); \
2607     f(registers - 1, 14, 13), f(op, 12),f(0b00, 11, 10), rf(Vn, 5), rf(Vd, 0); \
2608   }
2609 
2610   INSN(tbl, 0);
2611   INSN(tbx, 1);
2612 
2613 #undef INSN
2614 
2615   // AdvSIMD two-reg misc
<span class="line-modified">2616   // In this instruction group, the 2 bits in the size field ([23:22]) may be</span>
<span class="line-added">2617   // fixed or determined by the &quot;SIMD_Arrangement T&quot;, or both. The additional</span>
<span class="line-added">2618   // parameter &quot;tmask&quot; is a 2-bit mask used to indicate which bits in the size</span>
<span class="line-added">2619   // field are determined by the SIMD_Arrangement. The bit of &quot;tmask&quot; should be</span>
<span class="line-added">2620   // set to 1 if corresponding bit marked as &quot;x&quot; in the ArmARM.</span>
<span class="line-added">2621 #define INSN(NAME, U, size, tmask, opcode)                                          \</span>
2622   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {               \
2623        starti;                                                                      \
2624        assert((ASSERTION), MSG);                                                    \
2625        f(0, 31), f((int)T &amp; 1, 30), f(U, 29), f(0b01110, 28, 24);                   \
<span class="line-modified">2626        f(size | ((int)(T &gt;&gt; 1) &amp; tmask), 23, 22), f(0b10000, 21, 17);               \</span>
<span class="line-modified">2627        f(opcode, 16, 12), f(0b10, 11, 10), rf(Vn, 5), rf(Vd, 0);                    \</span>
2628  }
2629 
2630 #define MSG &quot;invalid arrangement&quot;
2631 
2632 #define ASSERTION (T == T2S || T == T4S || T == T2D)
<span class="line-modified">2633   INSN(fsqrt,  1, 0b10, 0b01, 0b11111);</span>
<span class="line-modified">2634   INSN(fabs,   0, 0b10, 0b01, 0b01111);</span>
<span class="line-modified">2635   INSN(fneg,   1, 0b10, 0b01, 0b01111);</span>
<span class="line-added">2636   INSN(frintn, 0, 0b00, 0b01, 0b11000);</span>
<span class="line-added">2637   INSN(frintm, 0, 0b00, 0b01, 0b11001);</span>
<span class="line-added">2638   INSN(frintp, 0, 0b10, 0b01, 0b11000);</span>
2639 #undef ASSERTION
2640 
2641 #define ASSERTION (T == T8B || T == T16B || T == T4H || T == T8H || T == T2S || T == T4S)
<span class="line-modified">2642   INSN(rev64, 0, 0b00, 0b11, 0b00000);</span>
2643 #undef ASSERTION
2644 
2645 #define ASSERTION (T == T8B || T == T16B || T == T4H || T == T8H)
<span class="line-modified">2646   INSN(rev32, 1, 0b00, 0b11, 0b00000);</span>




2647 #undef ASSERTION
2648 
2649 #define ASSERTION (T == T8B || T == T16B)
<span class="line-modified">2650   INSN(rev16, 0, 0b00, 0b11, 0b00001);</span>
<span class="line-modified">2651   INSN(rbit,  1, 0b01, 0b00, 0b00101);</span>




2652 #undef ASSERTION
2653 
2654 #undef MSG
2655 
2656 #undef INSN
2657 
2658 void ext(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm, int index)
2659   {
2660     starti;
2661     assert(T == T8B || T == T16B, &quot;invalid arrangement&quot;);
2662     assert((T == T8B &amp;&amp; index &lt;= 0b0111) || (T == T16B &amp;&amp; index &lt;= 0b1111), &quot;Invalid index value&quot;);
2663     f(0, 31), f((int)T &amp; 1, 30), f(0b101110000, 29, 21);
2664     rf(Vm, 16), f(0, 15), f(index, 14, 11);
2665     f(0, 10), rf(Vn, 5), rf(Vd, 0);
2666   }
2667 



































































































































2668   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
2669   }
2670 
2671   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
2672                                                 Register tmp,
2673                                                 int offset) {
2674     ShouldNotCallThis();
2675     return RegisterOrConstant();
2676   }
2677 
2678   // Stack overflow checking
2679   virtual void bang_stack_with_offset(int offset);
2680 
2681   static bool operand_valid_for_logical_immediate(bool is32, uint64_t imm);
2682   static bool operand_valid_for_add_sub_immediate(long imm);
2683   static bool operand_valid_for_float_immediate(double imm);
2684 
2685   void emit_data64(jlong data, relocInfo::relocType rtype, int format = 0);
2686   void emit_data64(jlong data, RelocationHolder const&amp; rspec, int format = 0);
2687 };
</pre>
</td>
</tr>
</table>
<center><a href="assembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_FrameMap_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
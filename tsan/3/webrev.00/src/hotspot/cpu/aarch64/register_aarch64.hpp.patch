diff a/src/hotspot/cpu/aarch64/register_aarch64.hpp b/src/hotspot/cpu/aarch64/register_aarch64.hpp
--- a/src/hotspot/cpu/aarch64/register_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/register_aarch64.hpp
@@ -42,11 +42,12 @@
 class RegisterImpl: public AbstractRegisterImpl {
  public:
   enum {
     number_of_registers         =   32,
     number_of_byte_registers      = 32,
-    number_of_registers_for_jvmci = 34   // Including SP and ZR.
+    number_of_registers_for_jvmci = 34,  // Including SP and ZR.
+    max_slots_per_register = 2
   };
 
   // derived registers, offsets, and addresses
   Register successor() const                          { return as_Register(encoding() + 1); }
 
@@ -125,20 +126,23 @@
 
 // The implementation of floating point registers for the architecture
 class FloatRegisterImpl: public AbstractRegisterImpl {
  public:
   enum {
-    number_of_registers = 32
+    number_of_registers = 32,
+    max_slots_per_register = 4,
+    save_slots_per_register = 2,
+    extra_save_slots_per_register = max_slots_per_register - save_slots_per_register
   };
 
   // construction
   inline friend FloatRegister as_FloatRegister(int encoding);
 
   VMReg as_VMReg();
 
   // derived registers, offsets, and addresses
-  FloatRegister successor() const                          { return as_FloatRegister(encoding() + 1); }
+  FloatRegister successor() const                          { return as_FloatRegister((encoding() + 1) % 32); }
 
   // accessors
   int   encoding() const                          { assert(is_valid(), "invalid register"); return (intptr_t)this; }
   int   encoding_nocheck() const                         { return (intptr_t)this; }
   bool  is_valid() const                          { return 0 <= (intptr_t)this && (intptr_t)this < number_of_registers; }
@@ -191,12 +195,12 @@
   // A big enough number for C2: all the registers plus flags
   // This number must be large enough to cover REG_COUNT (defined by c2) registers.
   // There is no requirement that any ordering here matches any ordering c2 gives
   // it's optoregs.
 
-    number_of_registers = (2 * RegisterImpl::number_of_registers +
-                           4 * FloatRegisterImpl::number_of_registers +
+    number_of_registers = (RegisterImpl::max_slots_per_register * RegisterImpl::number_of_registers +
+                           FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers +
                            1) // flags
   };
 
   // added to make it compile
   static const int max_gpr;
@@ -228,10 +232,15 @@
   RegSet &operator+=(const RegSet aSet) {
     *this = *this + aSet;
     return *this;
   }
 
+  RegSet &operator-=(const RegSet aSet) {
+    *this = *this - aSet;
+    return *this;
+  }
+
   static RegSet of(Register r1) {
     return RegSet(r1);
   }
 
   static RegSet of(Register r1, Register r2) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/c1_Runtime1_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_MacroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_globals_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/c1_Runtime1_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/assembler.hpp&quot;
  28 #include &quot;c1/c1_CodeStubs.hpp&quot;
  29 #include &quot;c1/c1_Defs.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;compiler/disassembler.hpp&quot;
  33 #include &quot;gc/shared/cardTable.hpp&quot;
  34 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  35 #include &quot;interpreter/interpreter.hpp&quot;

  36 #include &quot;nativeInst_aarch64.hpp&quot;
  37 #include &quot;oops/compiledICHolder.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;prims/jvmtiExport.hpp&quot;
  40 #include &quot;register_aarch64.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
  42 #include &quot;runtime/signature.hpp&quot;
  43 #include &quot;runtime/vframe.hpp&quot;
  44 #include &quot;runtime/vframeArray.hpp&quot;

  45 #include &quot;vmreg_aarch64.inline.hpp&quot;
  46 
  47 
  48 // Implementation of StubAssembler
  49 
  50 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, int args_size) {
  51   // setup registers
  52   assert(!(oop_result1-&gt;is_valid() || metadata_result-&gt;is_valid()) || oop_result1 != metadata_result, &quot;registers must be different&quot;);
  53   assert(oop_result1 != rthread &amp;&amp; metadata_result != rthread, &quot;registers must be different&quot;);
  54   assert(args_size &gt;= 0, &quot;illegal args_size&quot;);
  55   bool align_stack = false;
  56 
  57   mov(c_rarg0, rthread);
  58   set_num_rt_args(0); // Nothing on stack
  59 
  60   Label retaddr;
  61   set_last_Java_frame(sp, rfp, retaddr, rscratch1);
  62 
  63   // do the call
  64   lea(rscratch1, RuntimeAddress(entry));
<span class="line-modified">  65   blrt(rscratch1, args_size + 1, 8, 1);</span>
  66   bind(retaddr);
  67   int call_offset = offset();
  68   // verify callee-saved register
  69 #ifdef ASSERT
  70   push(r0, sp);
  71   { Label L;
  72     get_thread(r0);
  73     cmp(rthread, r0);
  74     br(Assembler::EQ, L);
  75     stop(&quot;StubAssembler::call_RT: rthread not callee saved?&quot;);
  76     bind(L);
  77   }
  78   pop(r0, sp);
  79 #endif
  80   reset_last_Java_frame(true);
  81   maybe_isb();
  82 
  83   // check for pending exceptions
  84   { Label L;
  85     // check for pending exceptions (java_thread is set upon return)
</pre>
<hr />
<pre>
 520   __ br(handler_addr);
 521 }
 522 
 523 
 524 
 525 OopMapSet* Runtime1::generate_patching(StubAssembler* sasm, address target) {
 526   // use the maximum number of runtime-arguments here because it is difficult to
 527   // distinguish each RT-Call.
 528   // Note: This number affects also the RT-Call in generate_handle_exception because
 529   //       the oop-map is shared for all calls.
 530   DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
 531   assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
 532 
 533   OopMap* oop_map = save_live_registers(sasm);
 534 
 535   __ mov(c_rarg0, rthread);
 536   Label retaddr;
 537   __ set_last_Java_frame(sp, rfp, retaddr, rscratch1);
 538   // do the call
 539   __ lea(rscratch1, RuntimeAddress(target));
<span class="line-modified"> 540   __ blrt(rscratch1, 1, 0, 1);</span>
 541   __ bind(retaddr);
 542   OopMapSet* oop_maps = new OopMapSet();
 543   oop_maps-&gt;add_gc_map(__ offset(), oop_map);
 544   // verify callee-saved register
 545 #ifdef ASSERT
 546   { Label L;
 547     __ get_thread(rscratch1);
 548     __ cmp(rthread, rscratch1);
 549     __ br(Assembler::EQ, L);
 550     __ stop(&quot;StubAssembler::call_RT: rthread not callee saved?&quot;);
 551     __ bind(L);
 552   }
 553 #endif
 554   __ reset_last_Java_frame(true);
 555   __ maybe_isb();
 556 
 557   // check for pending exceptions
 558   { Label L;
 559     __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
 560     __ cbz(rscratch1, L);
</pre>
<hr />
<pre>
 822           __ ldrw(t1, Address(klass, Klass::layout_helper_offset()));
 823           // since size is positive movw does right thing on 64bit
 824           __ movw(arr_size, length);
 825           __ lslvw(arr_size, length, t1);
 826           __ ubfx(t1, t1, Klass::_lh_header_size_shift,
 827                   exact_log2(Klass::_lh_header_size_mask + 1));
 828           __ add(arr_size, arr_size, t1);
 829           __ add(arr_size, arr_size, MinObjAlignmentInBytesMask); // align up
 830           __ andr(arr_size, arr_size, ~MinObjAlignmentInBytesMask);
 831 
 832           __ eden_allocate(obj, arr_size, 0, t1, slow_path);  // preserves arr_size
 833 
 834           __ initialize_header(obj, klass, length, t1, t2);
 835           __ ldrb(t1, Address(klass, in_bytes(Klass::layout_helper_offset()) + (Klass::_lh_header_size_shift / BitsPerByte)));
 836           assert(Klass::_lh_header_size_shift % BitsPerByte == 0, &quot;bytewise&quot;);
 837           assert(Klass::_lh_header_size_mask &lt;= 0xFF, &quot;bytewise&quot;);
 838           __ andr(t1, t1, Klass::_lh_header_size_mask);
 839           __ sub(arr_size, arr_size, t1);  // body length
 840           __ add(t1, t1, obj);       // body start
 841           __ initialize_body(t1, arr_size, 0, t2);

 842           __ verify_oop(obj);
 843 
 844           __ ret(lr);
 845 
 846           __ bind(slow_path);
 847         }
 848 
 849         __ enter();
 850         OopMap* map = save_live_registers(sasm);
 851         int call_offset;
 852         if (id == new_type_array_id) {
 853           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_type_array), klass, length);
 854         } else {
 855           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_object_array), klass, length);
 856         }
 857 
 858         oop_maps = new OopMapSet();
 859         oop_maps-&gt;add_gc_map(call_offset, map);
 860         restore_live_registers_except_r0(sasm);
 861 
</pre>
</td>
<td>
<hr />
<pre>
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/assembler.hpp&quot;
  28 #include &quot;c1/c1_CodeStubs.hpp&quot;
  29 #include &quot;c1/c1_Defs.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;compiler/disassembler.hpp&quot;
  33 #include &quot;gc/shared/cardTable.hpp&quot;
  34 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  35 #include &quot;interpreter/interpreter.hpp&quot;
<span class="line-added">  36 #include &quot;memory/universe.hpp&quot;</span>
  37 #include &quot;nativeInst_aarch64.hpp&quot;
  38 #include &quot;oops/compiledICHolder.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;prims/jvmtiExport.hpp&quot;
  41 #include &quot;register_aarch64.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;runtime/signature.hpp&quot;
  44 #include &quot;runtime/vframe.hpp&quot;
  45 #include &quot;runtime/vframeArray.hpp&quot;
<span class="line-added">  46 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  47 #include &quot;vmreg_aarch64.inline.hpp&quot;
  48 
  49 
  50 // Implementation of StubAssembler
  51 
  52 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, int args_size) {
  53   // setup registers
  54   assert(!(oop_result1-&gt;is_valid() || metadata_result-&gt;is_valid()) || oop_result1 != metadata_result, &quot;registers must be different&quot;);
  55   assert(oop_result1 != rthread &amp;&amp; metadata_result != rthread, &quot;registers must be different&quot;);
  56   assert(args_size &gt;= 0, &quot;illegal args_size&quot;);
  57   bool align_stack = false;
  58 
  59   mov(c_rarg0, rthread);
  60   set_num_rt_args(0); // Nothing on stack
  61 
  62   Label retaddr;
  63   set_last_Java_frame(sp, rfp, retaddr, rscratch1);
  64 
  65   // do the call
  66   lea(rscratch1, RuntimeAddress(entry));
<span class="line-modified">  67   blr(rscratch1);</span>
  68   bind(retaddr);
  69   int call_offset = offset();
  70   // verify callee-saved register
  71 #ifdef ASSERT
  72   push(r0, sp);
  73   { Label L;
  74     get_thread(r0);
  75     cmp(rthread, r0);
  76     br(Assembler::EQ, L);
  77     stop(&quot;StubAssembler::call_RT: rthread not callee saved?&quot;);
  78     bind(L);
  79   }
  80   pop(r0, sp);
  81 #endif
  82   reset_last_Java_frame(true);
  83   maybe_isb();
  84 
  85   // check for pending exceptions
  86   { Label L;
  87     // check for pending exceptions (java_thread is set upon return)
</pre>
<hr />
<pre>
 522   __ br(handler_addr);
 523 }
 524 
 525 
 526 
 527 OopMapSet* Runtime1::generate_patching(StubAssembler* sasm, address target) {
 528   // use the maximum number of runtime-arguments here because it is difficult to
 529   // distinguish each RT-Call.
 530   // Note: This number affects also the RT-Call in generate_handle_exception because
 531   //       the oop-map is shared for all calls.
 532   DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
 533   assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
 534 
 535   OopMap* oop_map = save_live_registers(sasm);
 536 
 537   __ mov(c_rarg0, rthread);
 538   Label retaddr;
 539   __ set_last_Java_frame(sp, rfp, retaddr, rscratch1);
 540   // do the call
 541   __ lea(rscratch1, RuntimeAddress(target));
<span class="line-modified"> 542   __ blr(rscratch1);</span>
 543   __ bind(retaddr);
 544   OopMapSet* oop_maps = new OopMapSet();
 545   oop_maps-&gt;add_gc_map(__ offset(), oop_map);
 546   // verify callee-saved register
 547 #ifdef ASSERT
 548   { Label L;
 549     __ get_thread(rscratch1);
 550     __ cmp(rthread, rscratch1);
 551     __ br(Assembler::EQ, L);
 552     __ stop(&quot;StubAssembler::call_RT: rthread not callee saved?&quot;);
 553     __ bind(L);
 554   }
 555 #endif
 556   __ reset_last_Java_frame(true);
 557   __ maybe_isb();
 558 
 559   // check for pending exceptions
 560   { Label L;
 561     __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
 562     __ cbz(rscratch1, L);
</pre>
<hr />
<pre>
 824           __ ldrw(t1, Address(klass, Klass::layout_helper_offset()));
 825           // since size is positive movw does right thing on 64bit
 826           __ movw(arr_size, length);
 827           __ lslvw(arr_size, length, t1);
 828           __ ubfx(t1, t1, Klass::_lh_header_size_shift,
 829                   exact_log2(Klass::_lh_header_size_mask + 1));
 830           __ add(arr_size, arr_size, t1);
 831           __ add(arr_size, arr_size, MinObjAlignmentInBytesMask); // align up
 832           __ andr(arr_size, arr_size, ~MinObjAlignmentInBytesMask);
 833 
 834           __ eden_allocate(obj, arr_size, 0, t1, slow_path);  // preserves arr_size
 835 
 836           __ initialize_header(obj, klass, length, t1, t2);
 837           __ ldrb(t1, Address(klass, in_bytes(Klass::layout_helper_offset()) + (Klass::_lh_header_size_shift / BitsPerByte)));
 838           assert(Klass::_lh_header_size_shift % BitsPerByte == 0, &quot;bytewise&quot;);
 839           assert(Klass::_lh_header_size_mask &lt;= 0xFF, &quot;bytewise&quot;);
 840           __ andr(t1, t1, Klass::_lh_header_size_mask);
 841           __ sub(arr_size, arr_size, t1);  // body length
 842           __ add(t1, t1, obj);       // body start
 843           __ initialize_body(t1, arr_size, 0, t2);
<span class="line-added"> 844           __ membar(Assembler::StoreStore);</span>
 845           __ verify_oop(obj);
 846 
 847           __ ret(lr);
 848 
 849           __ bind(slow_path);
 850         }
 851 
 852         __ enter();
 853         OopMap* map = save_live_registers(sasm);
 854         int call_offset;
 855         if (id == new_type_array_id) {
 856           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_type_array), klass, length);
 857         } else {
 858           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_object_array), klass, length);
 859         }
 860 
 861         oop_maps = new OopMapSet();
 862         oop_maps-&gt;add_gc_map(call_offset, map);
 863         restore_live_registers_except_r0(sasm);
 864 
</pre>
</td>
</tr>
</table>
<center><a href="c1_MacroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_globals_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;c1/c1_CodeStubs.hpp&quot;
  30 #include &quot;c1/c1_Compilation.hpp&quot;
  31 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  32 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  33 #include &quot;c1/c1_Runtime1.hpp&quot;
  34 #include &quot;c1/c1_ValueStack.hpp&quot;
  35 #include &quot;ci/ciArrayKlass.hpp&quot;
  36 #include &quot;ci/ciInstance.hpp&quot;
  37 #include &quot;gc/shared/barrierSet.hpp&quot;
  38 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.hpp&quot;
  40 #include &quot;nativeInst_aarch64.hpp&quot;
  41 #include &quot;oops/objArrayKlass.hpp&quot;
  42 #include &quot;runtime/frame.inline.hpp&quot;
  43 #include &quot;runtime/sharedRuntime.hpp&quot;
  44 #include &quot;vmreg_aarch64.inline.hpp&quot;
  45 
  46 
  47 
  48 #ifndef PRODUCT
  49 #define COMMENT(x)   do { __ block_comment(x); } while (0)
  50 #else
  51 #define COMMENT(x)
  52 #endif
  53 
  54 NEEDS_CLEANUP // remove this definitions ?
  55 const Register IC_Klass    = rscratch2;   // where the IC klass is cached
  56 const Register SYNC_header = r0;   // synchronization header
  57 const Register SHIFT_count = r0;   // where count for shift operations must be
  58 
  59 #define __ _masm-&gt;
  60 
  61 
  62 static void select_different_registers(Register preserve,
  63                                        Register extra,
  64                                        Register &amp;tmp1,
  65                                        Register &amp;tmp2) {
  66   if (tmp1 == preserve) {
  67     assert_different_registers(tmp1, tmp2, extra);
  68     tmp1 = extra;
  69   } else if (tmp2 == preserve) {
  70     assert_different_registers(tmp1, tmp2, extra);
  71     tmp2 = extra;
  72   }
  73   assert_different_registers(preserve, tmp1, tmp2);
  74 }
  75 
  76 
  77 
  78 static void select_different_registers(Register preserve,
  79                                        Register extra,
  80                                        Register &amp;tmp1,
  81                                        Register &amp;tmp2,
  82                                        Register &amp;tmp3) {
  83   if (tmp1 == preserve) {
  84     assert_different_registers(tmp1, tmp2, tmp3, extra);
  85     tmp1 = extra;
  86   } else if (tmp2 == preserve) {
  87     assert_different_registers(tmp1, tmp2, tmp3, extra);
  88     tmp2 = extra;
  89   } else if (tmp3 == preserve) {
  90     assert_different_registers(tmp1, tmp2, tmp3, extra);
  91     tmp3 = extra;
  92   }
  93   assert_different_registers(preserve, tmp1, tmp2, tmp3);
  94 }
  95 
  96 
  97 bool LIR_Assembler::is_small_constant(LIR_Opr opr) { Unimplemented(); return false; }
  98 
  99 
 100 LIR_Opr LIR_Assembler::receiverOpr() {
 101   return FrameMap::receiver_opr;
 102 }
 103 
 104 LIR_Opr LIR_Assembler::osrBufferPointer() {
 105   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 106 }
 107 
 108 //--------------fpu register translations-----------------------
 109 
 110 
 111 address LIR_Assembler::float_constant(float f) {
 112   address const_addr = __ float_constant(f);
 113   if (const_addr == NULL) {
 114     bailout(&quot;const section overflow&quot;);
 115     return __ code()-&gt;consts()-&gt;start();
 116   } else {
 117     return const_addr;
 118   }
 119 }
 120 
 121 
 122 address LIR_Assembler::double_constant(double d) {
 123   address const_addr = __ double_constant(d);
 124   if (const_addr == NULL) {
 125     bailout(&quot;const section overflow&quot;);
 126     return __ code()-&gt;consts()-&gt;start();
 127   } else {
 128     return const_addr;
 129   }
 130 }
 131 
 132 address LIR_Assembler::int_constant(jlong n) {
 133   address const_addr = __ long_constant(n);
 134   if (const_addr == NULL) {
 135     bailout(&quot;const section overflow&quot;);
 136     return __ code()-&gt;consts()-&gt;start();
 137   } else {
 138     return const_addr;
 139   }
 140 }
 141 
 142 void LIR_Assembler::set_24bit_FPU() { Unimplemented(); }
 143 
 144 void LIR_Assembler::reset_FPU() { Unimplemented(); }
 145 
 146 void LIR_Assembler::fpop() { Unimplemented(); }
 147 
 148 void LIR_Assembler::fxch(int i) { Unimplemented(); }
 149 
 150 void LIR_Assembler::fld(int i) { Unimplemented(); }
 151 
 152 void LIR_Assembler::ffree(int i) { Unimplemented(); }
 153 
 154 void LIR_Assembler::breakpoint() { Unimplemented(); }
 155 
 156 void LIR_Assembler::push(LIR_Opr opr) { Unimplemented(); }
 157 
 158 void LIR_Assembler::pop(LIR_Opr opr) { Unimplemented(); }
 159 
 160 bool LIR_Assembler::is_literal_address(LIR_Address* addr) { Unimplemented(); return false; }
 161 //-------------------------------------------
 162 
 163 static Register as_reg(LIR_Opr op) {
 164   return op-&gt;is_double_cpu() ? op-&gt;as_register_lo() : op-&gt;as_register();
 165 }
 166 
 167 static jlong as_long(LIR_Opr data) {
 168   jlong result;
 169   switch (data-&gt;type()) {
 170   case T_INT:
 171     result = (data-&gt;as_jint());
 172     break;
 173   case T_LONG:
 174     result = (data-&gt;as_jlong());
 175     break;
 176   default:
 177     ShouldNotReachHere();
 178     result = 0;  // unreachable
 179   }
 180   return result;
 181 }
 182 
 183 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 184   Register base = addr-&gt;base()-&gt;as_pointer_register();
 185   LIR_Opr opr = addr-&gt;index();
 186   if (opr-&gt;is_cpu_register()) {
 187     Register index;
 188     if (opr-&gt;is_single_cpu())
 189       index = opr-&gt;as_register();
 190     else
 191       index = opr-&gt;as_register_lo();
 192     assert(addr-&gt;disp() == 0, &quot;must be&quot;);
 193     switch(opr-&gt;type()) {
 194       case T_INT:
 195         return Address(base, index, Address::sxtw(addr-&gt;scale()));
 196       case T_LONG:
 197         return Address(base, index, Address::lsl(addr-&gt;scale()));
 198       default:
 199         ShouldNotReachHere();
 200       }
 201   } else  {
 202     intptr_t addr_offset = intptr_t(addr-&gt;disp());
 203     if (Address::offset_ok_for_immed(addr_offset, addr-&gt;scale()))
 204       return Address(base, addr_offset, Address::lsl(addr-&gt;scale()));
 205     else {
 206       __ mov(tmp, addr_offset);
 207       return Address(base, tmp, Address::lsl(addr-&gt;scale()));
 208     }
 209   }
 210   return Address();
 211 }
 212 
 213 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 214   ShouldNotReachHere();
 215   return Address();
 216 }
 217 
 218 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 219   return as_Address(addr, rscratch1);
 220 }
 221 
 222 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 223   return as_Address(addr, rscratch1);  // Ouch
 224   // FIXME: This needs to be much more clever.  See x86.
 225 }
 226 
 227 
 228 void LIR_Assembler::osr_entry() {
 229   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 230   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 231   ValueStack* entry_state = osr_entry-&gt;state();
 232   int number_of_locks = entry_state-&gt;locks_size();
 233 
 234   // we jump here if osr happens with the interpreter
 235   // state set up to continue at the beginning of the
 236   // loop that triggered osr - in particular, we have
 237   // the following registers setup:
 238   //
 239   // r2: osr buffer
 240   //
 241 
 242   // build frame
 243   ciMethod* m = compilation()-&gt;method();
 244   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 245 
 246   // OSR buffer is
 247   //
 248   // locals[nlocals-1..0]
 249   // monitors[0..number_of_locks]
 250   //
 251   // locals is a direct copy of the interpreter frame so in the osr buffer
 252   // so first slot in the local array is the last local from the interpreter
 253   // and last slot is local[0] (receiver) from the interpreter
 254   //
 255   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 256   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 257   // in the interpreter frame (the method lock if a sync method)
 258 
 259   // Initialize monitors in the compiled activation.
 260   //   r2: pointer to osr buffer
 261   //
 262   // All other registers are dead at this point and the locals will be
 263   // copied into place by code emitted in the IR.
 264 
 265   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 266   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 267     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 268       (2 * BytesPerWord) * (number_of_locks - 1);
 269     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 270     // the OSR buffer using 2 word entries: first the lock and then
 271     // the oop.
 272     for (int i = 0; i &lt; number_of_locks; i++) {
 273       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 274 #ifdef ASSERT
 275       // verify the interpreter&#39;s monitor has a non-null object
 276       {
 277         Label L;
 278         __ ldr(rscratch1, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 279         __ cbnz(rscratch1, L);
 280         __ stop(&quot;locked object is NULL&quot;);
 281         __ bind(L);
 282       }
 283 #endif
 284       __ ldr(r19, Address(OSR_buf, slot_offset + 0));
 285       __ str(r19, frame_map()-&gt;address_for_monitor_lock(i));
 286       __ ldr(r19, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 287       __ str(r19, frame_map()-&gt;address_for_monitor_object(i));
 288     }
 289   }
 290 }
 291 
 292 
 293 // inline cache check; done before the frame is built.
 294 int LIR_Assembler::check_icache() {
 295   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 296   Register ic_klass = IC_Klass;
 297   int start_offset = __ offset();
 298   __ inline_cache_check(receiver, ic_klass);
 299 
 300   // if icache check fails, then jump to runtime routine
 301   // Note: RECEIVER must still contain the receiver!
 302   Label dont;
 303   __ br(Assembler::EQ, dont);
 304   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 305 
 306   // We align the verified entry point unless the method body
 307   // (including its inline cache check) will fit in a single 64-byte
 308   // icache line.
 309   if (! method()-&gt;is_accessor() || __ offset() - start_offset &gt; 4 * 4) {
 310     // force alignment after the cache check.
 311     __ align(CodeEntryAlignment);
 312   }
 313 
 314   __ bind(dont);
 315   return start_offset;
 316 }
 317 
 318 
 319 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 320   if (o == NULL) {
 321     __ mov(reg, zr);
 322   } else {
 323     __ movoop(reg, o, /*immediate*/true);
 324   }
 325 }
 326 
 327 void LIR_Assembler::deoptimize_trap(CodeEmitInfo *info) {
 328   address target = NULL;
 329   relocInfo::relocType reloc_type = relocInfo::none;
 330 
 331   switch (patching_id(info)) {
 332   case PatchingStub::access_field_id:
 333     target = Runtime1::entry_for(Runtime1::access_field_patching_id);
 334     reloc_type = relocInfo::section_word_type;
 335     break;
 336   case PatchingStub::load_klass_id:
 337     target = Runtime1::entry_for(Runtime1::load_klass_patching_id);
 338     reloc_type = relocInfo::metadata_type;
 339     break;
 340   case PatchingStub::load_mirror_id:
 341     target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);
 342     reloc_type = relocInfo::oop_type;
 343     break;
 344   case PatchingStub::load_appendix_id:
 345     target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);
 346     reloc_type = relocInfo::oop_type;
 347     break;
 348   default: ShouldNotReachHere();
 349   }
 350 
 351   __ far_call(RuntimeAddress(target));
 352   add_call_info_here(info);
 353 }
 354 
 355 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 356   deoptimize_trap(info);
 357 }
 358 
 359 
 360 // This specifies the rsp decrement needed to build the frame
 361 int LIR_Assembler::initial_frame_size_in_bytes() const {
 362   // if rounding, must let FrameMap know!
 363 
 364   // The frame_map records size in slots (32bit word)
 365 
 366   // subtract two words to account for return address and link
 367   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 368 }
 369 
 370 
 371 int LIR_Assembler::emit_exception_handler() {
 372   // if the last instruction is a call (typically to do a throw which
 373   // is coming at the end after block reordering) the return address
 374   // must still point into the code area in order to avoid assertion
 375   // failures when searching for the corresponding bci =&gt; add a nop
 376   // (was bug 5/14/1999 - gri)
 377   __ nop();
 378 
 379   // generate code for exception handler
 380   address handler_base = __ start_a_stub(exception_handler_size());
 381   if (handler_base == NULL) {
 382     // not enough space left for the handler
 383     bailout(&quot;exception handler overflow&quot;);
 384     return -1;
 385   }
 386 
 387   int offset = code_offset();
 388 
 389   // the exception oop and pc are in r0, and r3
 390   // no other registers need to be preserved, so invalidate them
 391   __ invalidate_registers(false, true, true, false, true, true);
 392 
 393   // check that there is really an exception
 394   __ verify_not_null_oop(r0);
 395 
 396   // search an exception handler (r0: exception oop, r3: throwing pc)
 397   __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));  __ should_not_reach_here();
 398   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 399   __ end_a_stub();
 400 
 401   return offset;
 402 }
 403 
 404 
 405 // Emit the code to remove the frame from the stack in the exception
 406 // unwind path.
 407 int LIR_Assembler::emit_unwind_handler() {
 408 #ifndef PRODUCT
 409   if (CommentedAssembly) {
 410     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 411   }
 412 #endif
 413 
 414   int offset = code_offset();
 415 
 416   // Fetch the exception from TLS and clear out exception related thread state
 417   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
 418   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
 419   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
 420 
 421   __ bind(_unwind_handler_entry);
 422   __ verify_not_null_oop(r0);
 423   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 424     __ mov(r19, r0);  // Preserve the exception
 425   }
 426 
 427   // Preform needed unlocking
 428   MonitorExitStub* stub = NULL;
 429   if (method()-&gt;is_synchronized()) {
 430     monitor_address(0, FrameMap::r0_opr);
 431     stub = new MonitorExitStub(FrameMap::r0_opr, true, 0);
 432     __ unlock_object(r5, r4, r0, *stub-&gt;entry());
 433     __ bind(*stub-&gt;continuation());
 434   }
 435 
 436   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 437     __ call_Unimplemented();
 438 #if 0
 439     __ movptr(Address(rsp, 0), rax);
 440     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 441     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 442 #endif
 443   }
 444 
 445   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 446     __ mov(r0, r19);  // Restore the exception
 447   }
 448 
 449   // remove the activation and dispatch to the unwind handler
 450   __ block_comment(&quot;remove_frame and dispatch to the unwind handler&quot;);
 451   __ remove_frame(initial_frame_size_in_bytes());
 452   __ far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 453 
 454   // Emit the slow path assembly
 455   if (stub != NULL) {
 456     stub-&gt;emit_code(this);
 457   }
 458 
 459   return offset;
 460 }
 461 
 462 
 463 int LIR_Assembler::emit_deopt_handler() {
 464   // if the last instruction is a call (typically to do a throw which
 465   // is coming at the end after block reordering) the return address
 466   // must still point into the code area in order to avoid assertion
 467   // failures when searching for the corresponding bci =&gt; add a nop
 468   // (was bug 5/14/1999 - gri)
 469   __ nop();
 470 
 471   // generate code for exception handler
 472   address handler_base = __ start_a_stub(deopt_handler_size());
 473   if (handler_base == NULL) {
 474     // not enough space left for the handler
 475     bailout(&quot;deopt handler overflow&quot;);
 476     return -1;
 477   }
 478 
 479   int offset = code_offset();
 480 
 481   __ adr(lr, pc());
 482   __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 483   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 484   __ end_a_stub();
 485 
 486   return offset;
 487 }
 488 
 489 void LIR_Assembler::add_debug_info_for_branch(address adr, CodeEmitInfo* info) {
 490   _masm-&gt;code_section()-&gt;relocate(adr, relocInfo::poll_type);
 491   int pc_offset = code_offset();
 492   flush_debug_info(pc_offset);
 493   info-&gt;record_debug_info(compilation()-&gt;debug_info_recorder(), pc_offset);
 494   if (info-&gt;exception_handlers() != NULL) {
 495     compilation()-&gt;add_exception_handlers_for_pco(pc_offset, info-&gt;exception_handlers());
 496   }
 497 }
 498 
 499 void LIR_Assembler::return_op(LIR_Opr result) {
 500   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == r0, &quot;word returns are in r0,&quot;);
 501 
 502   // Pop the stack before the safepoint code
 503   __ remove_frame(initial_frame_size_in_bytes());
 504 
 505   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 506     __ reserved_stack_check();
 507   }
 508 
 509   address polling_page(os::get_polling_page());
 510   __ read_polling_page(rscratch1, polling_page, relocInfo::poll_return_type);
 511   __ ret(lr);
 512 }
 513 
 514 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 515   address polling_page(os::get_polling_page());
 516   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 517   assert(os::is_poll_address(polling_page), &quot;should be&quot;);
 518   __ get_polling_page(rscratch1, polling_page, relocInfo::poll_type);
 519   add_debug_info_for_branch(info);  // This isn&#39;t just debug info:
 520                                     // it&#39;s the oop map
 521   __ read_polling_page(rscratch1, relocInfo::poll_type);
 522   return __ offset();
 523 }
 524 
 525 
 526 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 527   if (from_reg == r31_sp)
 528     from_reg = sp;
 529   if (to_reg == r31_sp)
 530     to_reg = sp;
 531   __ mov(to_reg, from_reg);
 532 }
 533 
 534 void LIR_Assembler::swap_reg(Register a, Register b) { Unimplemented(); }
 535 
 536 
 537 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 538   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 539   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 540   LIR_Const* c = src-&gt;as_constant_ptr();
 541 
 542   switch (c-&gt;type()) {
 543     case T_INT: {
 544       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 545       __ movw(dest-&gt;as_register(), c-&gt;as_jint());
 546       break;
 547     }
 548 
 549     case T_ADDRESS: {
 550       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 551       __ mov(dest-&gt;as_register(), c-&gt;as_jint());
 552       break;
 553     }
 554 
 555     case T_LONG: {
 556       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 557       __ mov(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 558       break;
 559     }
 560 
 561     case T_OBJECT: {
 562         if (patch_code == lir_patch_none) {
 563           jobject2reg(c-&gt;as_jobject(), dest-&gt;as_register());
 564         } else {
 565           jobject2reg_with_patching(dest-&gt;as_register(), info);
 566         }
 567       break;
 568     }
 569 
 570     case T_METADATA: {
 571       if (patch_code != lir_patch_none) {
 572         klass2reg_with_patching(dest-&gt;as_register(), info);
 573       } else {
 574         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 575       }
 576       break;
 577     }
 578 
 579     case T_FLOAT: {
 580       if (__ operand_valid_for_float_immediate(c-&gt;as_jfloat())) {
 581         __ fmovs(dest-&gt;as_float_reg(), (c-&gt;as_jfloat()));
 582       } else {
 583         __ adr(rscratch1, InternalAddress(float_constant(c-&gt;as_jfloat())));
 584         __ ldrs(dest-&gt;as_float_reg(), Address(rscratch1));
 585       }
 586       break;
 587     }
 588 
 589     case T_DOUBLE: {
 590       if (__ operand_valid_for_float_immediate(c-&gt;as_jdouble())) {
 591         __ fmovd(dest-&gt;as_double_reg(), (c-&gt;as_jdouble()));
 592       } else {
 593         __ adr(rscratch1, InternalAddress(double_constant(c-&gt;as_jdouble())));
 594         __ ldrd(dest-&gt;as_double_reg(), Address(rscratch1));
 595       }
 596       break;
 597     }
 598 
 599     default:
 600       ShouldNotReachHere();
 601   }
 602 }
 603 
 604 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 605   LIR_Const* c = src-&gt;as_constant_ptr();
 606   switch (c-&gt;type()) {
 607   case T_OBJECT:
 608     {
 609       if (! c-&gt;as_jobject())
 610         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 611       else {
 612         const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 613         reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 614       }
 615     }
 616     break;
 617   case T_ADDRESS:
 618     {
 619       const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 620       reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 621     }
 622   case T_INT:
 623   case T_FLOAT:
 624     {
 625       Register reg = zr;
 626       if (c-&gt;as_jint_bits() == 0)
 627         __ strw(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 628       else {
 629         __ movw(rscratch1, c-&gt;as_jint_bits());
 630         __ strw(rscratch1, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 631       }
 632     }
 633     break;
 634   case T_LONG:
 635   case T_DOUBLE:
 636     {
 637       Register reg = zr;
 638       if (c-&gt;as_jlong_bits() == 0)
 639         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 640                                                  lo_word_offset_in_bytes));
 641       else {
 642         __ mov(rscratch1, (intptr_t)c-&gt;as_jlong_bits());
 643         __ str(rscratch1, frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 644                                                         lo_word_offset_in_bytes));
 645       }
 646     }
 647     break;
 648   default:
 649     ShouldNotReachHere();
 650   }
 651 }
 652 
 653 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 654   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 655   LIR_Const* c = src-&gt;as_constant_ptr();
 656   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 657 
 658   void (Assembler::* insn)(Register Rt, const Address &amp;adr);
 659 
 660   switch (type) {
 661   case T_ADDRESS:
 662     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 663     insn = &amp;Assembler::str;
 664     break;
 665   case T_LONG:
 666     assert(c-&gt;as_jlong() == 0, &quot;should be&quot;);
 667     insn = &amp;Assembler::str;
 668     break;
 669   case T_INT:
 670     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 671     insn = &amp;Assembler::strw;
 672     break;
 673   case T_OBJECT:
 674   case T_ARRAY:
 675     assert(c-&gt;as_jobject() == 0, &quot;should be&quot;);
 676     if (UseCompressedOops &amp;&amp; !wide) {
 677       insn = &amp;Assembler::strw;
 678     } else {
 679       insn = &amp;Assembler::str;
 680     }
 681     break;
 682   case T_CHAR:
 683   case T_SHORT:
 684     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 685     insn = &amp;Assembler::strh;
 686     break;
 687   case T_BOOLEAN:
 688   case T_BYTE:
 689     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 690     insn = &amp;Assembler::strb;
 691     break;
 692   default:
 693     ShouldNotReachHere();
 694     insn = &amp;Assembler::str;  // unreachable
 695   }
 696 
 697   if (info) add_debug_info_for_null_check_here(info);
 698   (_masm-&gt;*insn)(zr, as_Address(to_addr, rscratch1));
 699 }
 700 
 701 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 702   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 703   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 704 
 705   // move between cpu-registers
 706   if (dest-&gt;is_single_cpu()) {
 707     if (src-&gt;type() == T_LONG) {
 708       // Can do LONG -&gt; OBJECT
 709       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 710       return;
 711     }
 712     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 713     if (src-&gt;type() == T_OBJECT) {
 714       __ verify_oop(src-&gt;as_register());
 715     }
 716     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 717 
 718   } else if (dest-&gt;is_double_cpu()) {
 719     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_ARRAY) {
 720       // Surprising to me but we can see move of a long to t_object
 721       __ verify_oop(src-&gt;as_register());
 722       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 723       return;
 724     }
 725     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 726     Register f_lo = src-&gt;as_register_lo();
 727     Register f_hi = src-&gt;as_register_hi();
 728     Register t_lo = dest-&gt;as_register_lo();
 729     Register t_hi = dest-&gt;as_register_hi();
 730     assert(f_hi == f_lo, &quot;must be same&quot;);
 731     assert(t_hi == t_lo, &quot;must be same&quot;);
 732     move_regs(f_lo, t_lo);
 733 
 734   } else if (dest-&gt;is_single_fpu()) {
 735     __ fmovs(dest-&gt;as_float_reg(), src-&gt;as_float_reg());
 736 
 737   } else if (dest-&gt;is_double_fpu()) {
 738     __ fmovd(dest-&gt;as_double_reg(), src-&gt;as_double_reg());
 739 
 740   } else {
 741     ShouldNotReachHere();
 742   }
 743 }
 744 
 745 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 746   if (src-&gt;is_single_cpu()) {
 747     if (type == T_ARRAY || type == T_OBJECT) {
 748       __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 749       __ verify_oop(src-&gt;as_register());
 750     } else if (type == T_METADATA || type == T_DOUBLE) {
 751       __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 752     } else {
 753       __ strw(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 754     }
 755 
 756   } else if (src-&gt;is_double_cpu()) {
 757     Address dest_addr_LO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 758     __ str(src-&gt;as_register_lo(), dest_addr_LO);
 759 
 760   } else if (src-&gt;is_single_fpu()) {
 761     Address dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 762     __ strs(src-&gt;as_float_reg(), dest_addr);
 763 
 764   } else if (src-&gt;is_double_fpu()) {
 765     Address dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 766     __ strd(src-&gt;as_double_reg(), dest_addr);
 767 
 768   } else {
 769     ShouldNotReachHere();
 770   }
 771 
 772 }
 773 
 774 
 775 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 776   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 777   PatchingStub* patch = NULL;
 778   Register compressed_src = rscratch1;
 779 
 780   if (patch_code != lir_patch_none) {
 781     deoptimize_trap(info);
 782     return;
 783   }
 784 
 785   if (type == T_ARRAY || type == T_OBJECT) {
 786     __ verify_oop(src-&gt;as_register());
 787 
 788     if (UseCompressedOops &amp;&amp; !wide) {
 789       __ encode_heap_oop(compressed_src, src-&gt;as_register());
 790     } else {
 791       compressed_src = src-&gt;as_register();
 792     }
 793   }
 794 
 795   int null_check_here = code_offset();
 796   switch (type) {
 797     case T_FLOAT: {
 798       __ strs(src-&gt;as_float_reg(), as_Address(to_addr));
 799       break;
 800     }
 801 
 802     case T_DOUBLE: {
 803       __ strd(src-&gt;as_double_reg(), as_Address(to_addr));
 804       break;
 805     }
 806 
 807     case T_ARRAY:   // fall through
 808     case T_OBJECT:  // fall through
 809       if (UseCompressedOops &amp;&amp; !wide) {
 810         __ strw(compressed_src, as_Address(to_addr, rscratch2));
 811       } else {
 812          __ str(compressed_src, as_Address(to_addr));
 813       }
 814       break;
 815     case T_METADATA:
 816       // We get here to store a method pointer to the stack to pass to
 817       // a dtrace runtime call. This can&#39;t work on 64 bit with
 818       // compressed klass ptrs: T_METADATA can be a compressed klass
 819       // ptr or a 64 bit method pointer.
 820       ShouldNotReachHere();
 821       __ str(src-&gt;as_register(), as_Address(to_addr));
 822       break;
 823     case T_ADDRESS:
 824       __ str(src-&gt;as_register(), as_Address(to_addr));
 825       break;
 826     case T_INT:
 827       __ strw(src-&gt;as_register(), as_Address(to_addr));
 828       break;
 829 
 830     case T_LONG: {
 831       __ str(src-&gt;as_register_lo(), as_Address_lo(to_addr));
 832       break;
 833     }
 834 
 835     case T_BYTE:    // fall through
 836     case T_BOOLEAN: {
 837       __ strb(src-&gt;as_register(), as_Address(to_addr));
 838       break;
 839     }
 840 
 841     case T_CHAR:    // fall through
 842     case T_SHORT:
 843       __ strh(src-&gt;as_register(), as_Address(to_addr));
 844       break;
 845 
 846     default:
 847       ShouldNotReachHere();
 848   }
 849   if (info != NULL) {
 850     add_debug_info_for_null_check(null_check_here, info);
 851   }
 852 }
 853 
 854 
 855 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
 856   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
 857   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 858 
 859   if (dest-&gt;is_single_cpu()) {
 860     if (type == T_ARRAY || type == T_OBJECT) {
 861       __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
 862       __ verify_oop(dest-&gt;as_register());
 863     } else if (type == T_METADATA) {
 864       __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
 865     } else {
 866       __ ldrw(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
 867     }
 868 
 869   } else if (dest-&gt;is_double_cpu()) {
 870     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 871     __ ldr(dest-&gt;as_register_lo(), src_addr_LO);
 872 
 873   } else if (dest-&gt;is_single_fpu()) {
 874     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
 875     __ ldrs(dest-&gt;as_float_reg(), src_addr);
 876 
 877   } else if (dest-&gt;is_double_fpu()) {
 878     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
 879     __ ldrd(dest-&gt;as_double_reg(), src_addr);
 880 
 881   } else {
 882     ShouldNotReachHere();
 883   }
 884 }
 885 
 886 
 887 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 888   address target = NULL;
 889   relocInfo::relocType reloc_type = relocInfo::none;
 890 
 891   switch (patching_id(info)) {
 892   case PatchingStub::access_field_id:
 893     target = Runtime1::entry_for(Runtime1::access_field_patching_id);
 894     reloc_type = relocInfo::section_word_type;
 895     break;
 896   case PatchingStub::load_klass_id:
 897     target = Runtime1::entry_for(Runtime1::load_klass_patching_id);
 898     reloc_type = relocInfo::metadata_type;
 899     break;
 900   case PatchingStub::load_mirror_id:
 901     target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);
 902     reloc_type = relocInfo::oop_type;
 903     break;
 904   case PatchingStub::load_appendix_id:
 905     target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);
 906     reloc_type = relocInfo::oop_type;
 907     break;
 908   default: ShouldNotReachHere();
 909   }
 910 
 911   __ far_call(RuntimeAddress(target));
 912   add_call_info_here(info);
 913 }
 914 
 915 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
 916 
 917   LIR_Opr temp;
 918   if (type == T_LONG || type == T_DOUBLE)
 919     temp = FrameMap::rscratch1_long_opr;
 920   else
 921     temp = FrameMap::rscratch1_opr;
 922 
 923   stack2reg(src, temp, src-&gt;type());
 924   reg2stack(temp, dest, dest-&gt;type(), false);
 925 }
 926 
 927 
 928 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
 929   LIR_Address* addr = src-&gt;as_address_ptr();
 930   LIR_Address* from_addr = src-&gt;as_address_ptr();
 931 
 932   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
 933     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
 934   }
 935 
 936   if (patch_code != lir_patch_none) {
 937     deoptimize_trap(info);
 938     return;
 939   }
 940 
 941   if (info != NULL) {
 942     add_debug_info_for_null_check_here(info);
 943   }
 944   int null_check_here = code_offset();
 945   switch (type) {
 946     case T_FLOAT: {
 947       __ ldrs(dest-&gt;as_float_reg(), as_Address(from_addr));
 948       break;
 949     }
 950 
 951     case T_DOUBLE: {
 952       __ ldrd(dest-&gt;as_double_reg(), as_Address(from_addr));
 953       break;
 954     }
 955 
 956     case T_ARRAY:   // fall through
 957     case T_OBJECT:  // fall through
 958       if (UseCompressedOops &amp;&amp; !wide) {
 959         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 960       } else {
 961          __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 962       }
 963       break;
 964     case T_METADATA:
 965       // We get here to store a method pointer to the stack to pass to
 966       // a dtrace runtime call. This can&#39;t work on 64 bit with
 967       // compressed klass ptrs: T_METADATA can be a compressed klass
 968       // ptr or a 64 bit method pointer.
 969       ShouldNotReachHere();
 970       __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 971       break;
 972     case T_ADDRESS:
 973       // FIXME: OMG this is a horrible kludge.  Any offset from an
 974       // address that matches klass_offset_in_bytes() will be loaded
 975       // as a word, not a long.
 976       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
 977         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 978       } else {
 979         __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 980       }
 981       break;
 982     case T_INT:
 983       __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 984       break;
 985 
 986     case T_LONG: {
 987       __ ldr(dest-&gt;as_register_lo(), as_Address_lo(from_addr));
 988       break;
 989     }
 990 
 991     case T_BYTE:
 992       __ ldrsb(dest-&gt;as_register(), as_Address(from_addr));
 993       break;
 994     case T_BOOLEAN: {
 995       __ ldrb(dest-&gt;as_register(), as_Address(from_addr));
 996       break;
 997     }
 998 
 999     case T_CHAR:
1000       __ ldrh(dest-&gt;as_register(), as_Address(from_addr));
1001       break;
1002     case T_SHORT:
1003       __ ldrsh(dest-&gt;as_register(), as_Address(from_addr));
1004       break;
1005 
1006     default:
1007       ShouldNotReachHere();
1008   }
1009 
1010   if (type == T_ARRAY || type == T_OBJECT) {
1011     if (UseCompressedOops &amp;&amp; !wide) {
1012       __ decode_heap_oop(dest-&gt;as_register());
1013     }
1014     __ verify_oop(dest-&gt;as_register());
1015   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1016     if (UseCompressedClassPointers) {
1017       __ decode_klass_not_null(dest-&gt;as_register());
1018     }
1019   }
1020 }
1021 
1022 
1023 int LIR_Assembler::array_element_size(BasicType type) const {
1024   int elem_size = type2aelembytes(type);
1025   return exact_log2(elem_size);
1026 }
1027 
1028 
1029 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1030   switch (op-&gt;code()) {
1031   case lir_idiv:
1032   case lir_irem:
1033     arithmetic_idiv(op-&gt;code(),
1034                     op-&gt;in_opr1(),
1035                     op-&gt;in_opr2(),
1036                     op-&gt;in_opr3(),
1037                     op-&gt;result_opr(),
1038                     op-&gt;info());
1039     break;
1040   case lir_fmad:
1041     __ fmaddd(op-&gt;result_opr()-&gt;as_double_reg(),
1042               op-&gt;in_opr1()-&gt;as_double_reg(),
1043               op-&gt;in_opr2()-&gt;as_double_reg(),
1044               op-&gt;in_opr3()-&gt;as_double_reg());
1045     break;
1046   case lir_fmaf:
1047     __ fmadds(op-&gt;result_opr()-&gt;as_float_reg(),
1048               op-&gt;in_opr1()-&gt;as_float_reg(),
1049               op-&gt;in_opr2()-&gt;as_float_reg(),
1050               op-&gt;in_opr3()-&gt;as_float_reg());
1051     break;
1052   default:      ShouldNotReachHere(); break;
1053   }
1054 }
1055 
1056 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1057 #ifdef ASSERT
1058   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1059   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1060   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1061 #endif
1062 
1063   if (op-&gt;cond() == lir_cond_always) {
1064     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1065     __ b(*(op-&gt;label()));
1066   } else {
1067     Assembler::Condition acond;
1068     if (op-&gt;code() == lir_cond_float_branch) {
1069       bool is_unordered = (op-&gt;ublock() == op-&gt;block());
1070       // Assembler::EQ does not permit unordered branches, so we add
1071       // another branch here.  Likewise, Assembler::NE does not permit
1072       // ordered branches.
1073       if (is_unordered &amp;&amp; op-&gt;cond() == lir_cond_equal
1074           || !is_unordered &amp;&amp; op-&gt;cond() == lir_cond_notEqual)
1075         __ br(Assembler::VS, *(op-&gt;ublock()-&gt;label()));
1076       switch(op-&gt;cond()) {
1077       case lir_cond_equal:        acond = Assembler::EQ; break;
1078       case lir_cond_notEqual:     acond = Assembler::NE; break;
1079       case lir_cond_less:         acond = (is_unordered ? Assembler::LT : Assembler::LO); break;
1080       case lir_cond_lessEqual:    acond = (is_unordered ? Assembler::LE : Assembler::LS); break;
1081       case lir_cond_greaterEqual: acond = (is_unordered ? Assembler::HS : Assembler::GE); break;
1082       case lir_cond_greater:      acond = (is_unordered ? Assembler::HI : Assembler::GT); break;
1083       default:                    ShouldNotReachHere();
1084         acond = Assembler::EQ;  // unreachable
1085       }
1086     } else {
1087       switch (op-&gt;cond()) {
1088         case lir_cond_equal:        acond = Assembler::EQ; break;
1089         case lir_cond_notEqual:     acond = Assembler::NE; break;
1090         case lir_cond_less:         acond = Assembler::LT; break;
1091         case lir_cond_lessEqual:    acond = Assembler::LE; break;
1092         case lir_cond_greaterEqual: acond = Assembler::GE; break;
1093         case lir_cond_greater:      acond = Assembler::GT; break;
1094         case lir_cond_belowEqual:   acond = Assembler::LS; break;
1095         case lir_cond_aboveEqual:   acond = Assembler::HS; break;
1096         default:                    ShouldNotReachHere();
1097           acond = Assembler::EQ;  // unreachable
1098       }
1099     }
1100     __ br(acond,*(op-&gt;label()));
1101   }
1102 }
1103 
1104 
1105 
1106 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1107   LIR_Opr src  = op-&gt;in_opr();
1108   LIR_Opr dest = op-&gt;result_opr();
1109 
1110   switch (op-&gt;bytecode()) {
1111     case Bytecodes::_i2f:
1112       {
1113         __ scvtfws(dest-&gt;as_float_reg(), src-&gt;as_register());
1114         break;
1115       }
1116     case Bytecodes::_i2d:
1117       {
1118         __ scvtfwd(dest-&gt;as_double_reg(), src-&gt;as_register());
1119         break;
1120       }
1121     case Bytecodes::_l2d:
1122       {
1123         __ scvtfd(dest-&gt;as_double_reg(), src-&gt;as_register_lo());
1124         break;
1125       }
1126     case Bytecodes::_l2f:
1127       {
1128         __ scvtfs(dest-&gt;as_float_reg(), src-&gt;as_register_lo());
1129         break;
1130       }
1131     case Bytecodes::_f2d:
1132       {
1133         __ fcvts(dest-&gt;as_double_reg(), src-&gt;as_float_reg());
1134         break;
1135       }
1136     case Bytecodes::_d2f:
1137       {
1138         __ fcvtd(dest-&gt;as_float_reg(), src-&gt;as_double_reg());
1139         break;
1140       }
1141     case Bytecodes::_i2c:
1142       {
1143         __ ubfx(dest-&gt;as_register(), src-&gt;as_register(), 0, 16);
1144         break;
1145       }
1146     case Bytecodes::_i2l:
1147       {
1148         __ sxtw(dest-&gt;as_register_lo(), src-&gt;as_register());
1149         break;
1150       }
1151     case Bytecodes::_i2s:
1152       {
1153         __ sxth(dest-&gt;as_register(), src-&gt;as_register());
1154         break;
1155       }
1156     case Bytecodes::_i2b:
1157       {
1158         __ sxtb(dest-&gt;as_register(), src-&gt;as_register());
1159         break;
1160       }
1161     case Bytecodes::_l2i:
1162       {
1163         _masm-&gt;block_comment(&quot;FIXME: This could be a no-op&quot;);
1164         __ uxtw(dest-&gt;as_register(), src-&gt;as_register_lo());
1165         break;
1166       }
1167     case Bytecodes::_d2l:
1168       {
1169         __ fcvtzd(dest-&gt;as_register_lo(), src-&gt;as_double_reg());
1170         break;
1171       }
1172     case Bytecodes::_f2i:
1173       {
1174         __ fcvtzsw(dest-&gt;as_register(), src-&gt;as_float_reg());
1175         break;
1176       }
1177     case Bytecodes::_f2l:
1178       {
1179         __ fcvtzs(dest-&gt;as_register_lo(), src-&gt;as_float_reg());
1180         break;
1181       }
1182     case Bytecodes::_d2i:
1183       {
1184         __ fcvtzdw(dest-&gt;as_register(), src-&gt;as_double_reg());
1185         break;
1186       }
1187     default: ShouldNotReachHere();
1188   }
1189 }
1190 
1191 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1192   if (op-&gt;init_check()) {
1193     __ ldrb(rscratch1, Address(op-&gt;klass()-&gt;as_register(),
1194                                InstanceKlass::init_state_offset()));
1195     __ cmpw(rscratch1, InstanceKlass::fully_initialized);
1196     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1197     __ br(Assembler::NE, *op-&gt;stub()-&gt;entry());
1198   }
1199   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1200                      op-&gt;tmp1()-&gt;as_register(),
1201                      op-&gt;tmp2()-&gt;as_register(),
1202                      op-&gt;header_size(),
1203                      op-&gt;object_size(),
1204                      op-&gt;klass()-&gt;as_register(),
1205                      *op-&gt;stub()-&gt;entry());
1206   __ bind(*op-&gt;stub()-&gt;continuation());
1207 }
1208 
1209 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1210   Register len =  op-&gt;len()-&gt;as_register();
1211   __ uxtw(len, len);
1212 
1213   if (UseSlowPath ||
1214       (!UseFastNewObjectArray &amp;&amp; (op-&gt;type() == T_OBJECT || op-&gt;type() == T_ARRAY)) ||
1215       (!UseFastNewTypeArray   &amp;&amp; (op-&gt;type() != T_OBJECT &amp;&amp; op-&gt;type() != T_ARRAY))) {
1216     __ b(*op-&gt;stub()-&gt;entry());
1217   } else {
1218     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1219     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1220     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1221     if (len == tmp1) {
1222       tmp1 = tmp3;
1223     } else if (len == tmp2) {
1224       tmp2 = tmp3;
1225     } else if (len == tmp3) {
1226       // everything is ok
1227     } else {
1228       __ mov(tmp3, len);
1229     }
1230     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1231                       len,
1232                       tmp1,
1233                       tmp2,
1234                       arrayOopDesc::header_size(op-&gt;type()),
1235                       array_element_size(op-&gt;type()),
1236                       op-&gt;klass()-&gt;as_register(),
1237                       *op-&gt;stub()-&gt;entry());
1238   }
1239   __ bind(*op-&gt;stub()-&gt;continuation());
1240 }
1241 
1242 void LIR_Assembler::type_profile_helper(Register mdo,
1243                                         ciMethodData *md, ciProfileData *data,
1244                                         Register recv, Label* update_done) {
1245   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1246     Label next_test;
1247     // See if the receiver is receiver[n].
1248     __ lea(rscratch2, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1249     __ ldr(rscratch1, Address(rscratch2));
1250     __ cmp(recv, rscratch1);
1251     __ br(Assembler::NE, next_test);
1252     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1253     __ addptr(data_addr, DataLayout::counter_increment);
1254     __ b(*update_done);
1255     __ bind(next_test);
1256   }
1257 
1258   // Didn&#39;t find receiver; find next empty slot and fill it in
1259   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1260     Label next_test;
1261     __ lea(rscratch2,
1262            Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1263     Address recv_addr(rscratch2);
1264     __ ldr(rscratch1, recv_addr);
1265     __ cbnz(rscratch1, next_test);
1266     __ str(recv, recv_addr);
1267     __ mov(rscratch1, DataLayout::counter_increment);
1268     __ lea(rscratch2, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))));
1269     __ str(rscratch1, Address(rscratch2));
1270     __ b(*update_done);
1271     __ bind(next_test);
1272   }
1273 }
1274 
1275 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1276   // we always need a stub for the failure case.
1277   CodeStub* stub = op-&gt;stub();
1278   Register obj = op-&gt;object()-&gt;as_register();
1279   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1280   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1281   Register dst = op-&gt;result_opr()-&gt;as_register();
1282   ciKlass* k = op-&gt;klass();
1283   Register Rtmp1 = noreg;
1284 
1285   // check if it needs to be profiled
1286   ciMethodData* md;
1287   ciProfileData* data;
1288 
1289   const bool should_profile = op-&gt;should_profile();
1290 
1291   if (should_profile) {
1292     ciMethod* method = op-&gt;profiled_method();
1293     assert(method != NULL, &quot;Should have method&quot;);
1294     int bci = op-&gt;profiled_bci();
1295     md = method-&gt;method_data_or_null();
1296     assert(md != NULL, &quot;Sanity&quot;);
1297     data = md-&gt;bci_to_data(bci);
1298     assert(data != NULL,                &quot;need data for type check&quot;);
1299     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1300   }
1301   Label profile_cast_success, profile_cast_failure;
1302   Label *success_target = should_profile ? &amp;profile_cast_success : success;
1303   Label *failure_target = should_profile ? &amp;profile_cast_failure : failure;
1304 
1305   if (obj == k_RInfo) {
1306     k_RInfo = dst;
1307   } else if (obj == klass_RInfo) {
1308     klass_RInfo = dst;
1309   }
1310   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1311     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1312   } else {
1313     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1314     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1315   }
1316 
1317   assert_different_registers(obj, k_RInfo, klass_RInfo);
1318 
1319     if (should_profile) {
1320       Label not_null;
1321       __ cbnz(obj, not_null);
1322       // Object is null; update MDO and exit
1323       Register mdo  = klass_RInfo;
1324       __ mov_metadata(mdo, md-&gt;constant_encoding());
1325       Address data_addr
1326         = __ form_address(rscratch2, mdo,
1327                           md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()),
1328                           0);
1329       __ ldrb(rscratch1, data_addr);
1330       __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());
1331       __ strb(rscratch1, data_addr);
1332       __ b(*obj_is_null);
1333       __ bind(not_null);
1334     } else {
1335       __ cbz(obj, *obj_is_null);
1336     }
1337 
1338   if (!k-&gt;is_loaded()) {
1339     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1340   } else {
1341     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1342   }
1343   __ verify_oop(obj);
1344 
1345   if (op-&gt;fast_check()) {
1346     // get object class
1347     // not a safepoint as obj null check happens earlier
1348     __ load_klass(rscratch1, obj);
1349     __ cmp( rscratch1, k_RInfo);
1350 
1351     __ br(Assembler::NE, *failure_target);
1352     // successful cast, fall through to profile or jump
1353   } else {
1354     // get object class
1355     // not a safepoint as obj null check happens earlier
1356     __ load_klass(klass_RInfo, obj);
1357     if (k-&gt;is_loaded()) {
1358       // See if we get an immediate positive hit
1359       __ ldr(rscratch1, Address(klass_RInfo, long(k-&gt;super_check_offset())));
1360       __ cmp(k_RInfo, rscratch1);
1361       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1362         __ br(Assembler::NE, *failure_target);
1363         // successful cast, fall through to profile or jump
1364       } else {
1365         // See if we get an immediate positive hit
1366         __ br(Assembler::EQ, *success_target);
1367         // check for self
1368         __ cmp(klass_RInfo, k_RInfo);
1369         __ br(Assembler::EQ, *success_target);
1370 
1371         __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1372         __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1373         __ ldr(klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1374         // result is a boolean
1375         __ cbzw(klass_RInfo, *failure_target);
1376         // successful cast, fall through to profile or jump
1377       }
1378     } else {
1379       // perform the fast part of the checking logic
1380       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1381       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1382       __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1383       __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1384       __ ldp(k_RInfo, klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1385       // result is a boolean
1386       __ cbz(k_RInfo, *failure_target);
1387       // successful cast, fall through to profile or jump
1388     }
1389   }
1390   if (should_profile) {
1391     Register mdo  = klass_RInfo, recv = k_RInfo;
1392     __ bind(profile_cast_success);
1393     __ mov_metadata(mdo, md-&gt;constant_encoding());
1394     __ load_klass(recv, obj);
1395     Label update_done;
1396     type_profile_helper(mdo, md, data, recv, success);
1397     __ b(*success);
1398 
1399     __ bind(profile_cast_failure);
1400     __ mov_metadata(mdo, md-&gt;constant_encoding());
1401     Address counter_addr
1402       = __ form_address(rscratch2, mdo,
1403                         md-&gt;byte_offset_of_slot(data, CounterData::count_offset()),
1404                         0);
1405     __ ldr(rscratch1, counter_addr);
1406     __ sub(rscratch1, rscratch1, DataLayout::counter_increment);
1407     __ str(rscratch1, counter_addr);
1408     __ b(*failure);
1409   }
1410   __ b(*success);
1411 }
1412 
1413 
1414 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1415   const bool should_profile = op-&gt;should_profile();
1416 
1417   LIR_Code code = op-&gt;code();
1418   if (code == lir_store_check) {
1419     Register value = op-&gt;object()-&gt;as_register();
1420     Register array = op-&gt;array()-&gt;as_register();
1421     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1422     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1423     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1424 
1425     CodeStub* stub = op-&gt;stub();
1426 
1427     // check if it needs to be profiled
1428     ciMethodData* md;
1429     ciProfileData* data;
1430 
1431     if (should_profile) {
1432       ciMethod* method = op-&gt;profiled_method();
1433       assert(method != NULL, &quot;Should have method&quot;);
1434       int bci = op-&gt;profiled_bci();
1435       md = method-&gt;method_data_or_null();
1436       assert(md != NULL, &quot;Sanity&quot;);
1437       data = md-&gt;bci_to_data(bci);
1438       assert(data != NULL,                &quot;need data for type check&quot;);
1439       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1440     }
1441     Label profile_cast_success, profile_cast_failure, done;
1442     Label *success_target = should_profile ? &amp;profile_cast_success : &amp;done;
1443     Label *failure_target = should_profile ? &amp;profile_cast_failure : stub-&gt;entry();
1444 
1445     if (should_profile) {
1446       Label not_null;
1447       __ cbnz(value, not_null);
1448       // Object is null; update MDO and exit
1449       Register mdo  = klass_RInfo;
1450       __ mov_metadata(mdo, md-&gt;constant_encoding());
1451       Address data_addr
1452         = __ form_address(rscratch2, mdo,
1453                           md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()),
1454                           0);
1455       __ ldrb(rscratch1, data_addr);
1456       __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());
1457       __ strb(rscratch1, data_addr);
1458       __ b(done);
1459       __ bind(not_null);
1460     } else {
1461       __ cbz(value, done);
1462     }
1463 
1464     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1465     __ load_klass(k_RInfo, array);
1466     __ load_klass(klass_RInfo, value);
1467 
1468     // get instance klass (it&#39;s already uncompressed)
1469     __ ldr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1470     // perform the fast part of the checking logic
1471     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1472     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1473     __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1474     __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1475     __ ldp(k_RInfo, klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1476     // result is a boolean
1477     __ cbzw(k_RInfo, *failure_target);
1478     // fall through to the success case
1479 
1480     if (should_profile) {
1481       Register mdo  = klass_RInfo, recv = k_RInfo;
1482       __ bind(profile_cast_success);
1483       __ mov_metadata(mdo, md-&gt;constant_encoding());
1484       __ load_klass(recv, value);
1485       Label update_done;
1486       type_profile_helper(mdo, md, data, recv, &amp;done);
1487       __ b(done);
1488 
1489       __ bind(profile_cast_failure);
1490       __ mov_metadata(mdo, md-&gt;constant_encoding());
1491       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1492       __ lea(rscratch2, counter_addr);
1493       __ ldr(rscratch1, Address(rscratch2));
1494       __ sub(rscratch1, rscratch1, DataLayout::counter_increment);
1495       __ str(rscratch1, Address(rscratch2));
1496       __ b(*stub-&gt;entry());
1497     }
1498 
1499     __ bind(done);
1500   } else if (code == lir_checkcast) {
1501     Register obj = op-&gt;object()-&gt;as_register();
1502     Register dst = op-&gt;result_opr()-&gt;as_register();
1503     Label success;
1504     emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1505     __ bind(success);
1506     if (dst != obj) {
1507       __ mov(dst, obj);
1508     }
1509   } else if (code == lir_instanceof) {
1510     Register obj = op-&gt;object()-&gt;as_register();
1511     Register dst = op-&gt;result_opr()-&gt;as_register();
1512     Label success, failure, done;
1513     emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1514     __ bind(failure);
1515     __ mov(dst, zr);
1516     __ b(done);
1517     __ bind(success);
1518     __ mov(dst, 1);
1519     __ bind(done);
1520   } else {
1521     ShouldNotReachHere();
1522   }
1523 }
1524 
1525 void LIR_Assembler::casw(Register addr, Register newval, Register cmpval) {
1526   __ cmpxchg(addr, cmpval, newval, Assembler::word, /* acquire*/ true, /* release*/ true, /* weak*/ false, rscratch1);
1527   __ cset(rscratch1, Assembler::NE);
1528   __ membar(__ AnyAny);
1529 }
1530 
1531 void LIR_Assembler::casl(Register addr, Register newval, Register cmpval) {
1532   __ cmpxchg(addr, cmpval, newval, Assembler::xword, /* acquire*/ true, /* release*/ true, /* weak*/ false, rscratch1);
1533   __ cset(rscratch1, Assembler::NE);
1534   __ membar(__ AnyAny);
1535 }
1536 
1537 
1538 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
1539   assert(VM_Version::supports_cx8(), &quot;wrong machine&quot;);
1540   Register addr;
1541   if (op-&gt;addr()-&gt;is_register()) {
1542     addr = as_reg(op-&gt;addr());
1543   } else {
1544     assert(op-&gt;addr()-&gt;is_address(), &quot;what else?&quot;);
1545     LIR_Address* addr_ptr = op-&gt;addr()-&gt;as_address_ptr();
1546     assert(addr_ptr-&gt;disp() == 0, &quot;need 0 disp&quot;);
1547     assert(addr_ptr-&gt;index() == LIR_OprDesc::illegalOpr(), &quot;need 0 index&quot;);
1548     addr = as_reg(addr_ptr-&gt;base());
1549   }
1550   Register newval = as_reg(op-&gt;new_value());
1551   Register cmpval = as_reg(op-&gt;cmp_value());
1552 
1553   if (op-&gt;code() == lir_cas_obj) {
1554     if (UseCompressedOops) {
1555       Register t1 = op-&gt;tmp1()-&gt;as_register();
1556       assert(op-&gt;tmp1()-&gt;is_valid(), &quot;must be&quot;);
1557       __ encode_heap_oop(t1, cmpval);
1558       cmpval = t1;
1559       __ encode_heap_oop(rscratch2, newval);
1560       newval = rscratch2;
1561       casw(addr, newval, cmpval);
1562     } else {
1563       casl(addr, newval, cmpval);
1564     }
1565   } else if (op-&gt;code() == lir_cas_int) {
1566     casw(addr, newval, cmpval);
1567   } else {
1568     casl(addr, newval, cmpval);
1569   }
1570 }
1571 
1572 
1573 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1574 
1575   Assembler::Condition acond, ncond;
1576   switch (condition) {
1577   case lir_cond_equal:        acond = Assembler::EQ; ncond = Assembler::NE; break;
1578   case lir_cond_notEqual:     acond = Assembler::NE; ncond = Assembler::EQ; break;
1579   case lir_cond_less:         acond = Assembler::LT; ncond = Assembler::GE; break;
1580   case lir_cond_lessEqual:    acond = Assembler::LE; ncond = Assembler::GT; break;
1581   case lir_cond_greaterEqual: acond = Assembler::GE; ncond = Assembler::LT; break;
1582   case lir_cond_greater:      acond = Assembler::GT; ncond = Assembler::LE; break;
1583   case lir_cond_belowEqual:
1584   case lir_cond_aboveEqual:
1585   default:                    ShouldNotReachHere();
1586     acond = Assembler::EQ; ncond = Assembler::NE;  // unreachable
1587   }
1588 
1589   assert(result-&gt;is_single_cpu() || result-&gt;is_double_cpu(),
1590          &quot;expect single register for result&quot;);
1591   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_constant()
1592       &amp;&amp; opr1-&gt;type() == T_INT &amp;&amp; opr2-&gt;type() == T_INT) {
1593     jint val1 = opr1-&gt;as_jint();
1594     jint val2 = opr2-&gt;as_jint();
1595     if (val1 == 0 &amp;&amp; val2 == 1) {
1596       __ cset(result-&gt;as_register(), ncond);
1597       return;
1598     } else if (val1 == 1 &amp;&amp; val2 == 0) {
1599       __ cset(result-&gt;as_register(), acond);
1600       return;
1601     }
1602   }
1603 
1604   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_constant()
1605       &amp;&amp; opr1-&gt;type() == T_LONG &amp;&amp; opr2-&gt;type() == T_LONG) {
1606     jlong val1 = opr1-&gt;as_jlong();
1607     jlong val2 = opr2-&gt;as_jlong();
1608     if (val1 == 0 &amp;&amp; val2 == 1) {
1609       __ cset(result-&gt;as_register_lo(), ncond);
1610       return;
1611     } else if (val1 == 1 &amp;&amp; val2 == 0) {
1612       __ cset(result-&gt;as_register_lo(), acond);
1613       return;
1614     }
1615   }
1616 
1617   if (opr1-&gt;is_stack()) {
1618     stack2reg(opr1, FrameMap::rscratch1_opr, result-&gt;type());
1619     opr1 = FrameMap::rscratch1_opr;
1620   } else if (opr1-&gt;is_constant()) {
1621     LIR_Opr tmp
1622       = opr1-&gt;type() == T_LONG ? FrameMap::rscratch1_long_opr : FrameMap::rscratch1_opr;
1623     const2reg(opr1, tmp, lir_patch_none, NULL);
1624     opr1 = tmp;
1625   }
1626 
1627   if (opr2-&gt;is_stack()) {
1628     stack2reg(opr2, FrameMap::rscratch2_opr, result-&gt;type());
1629     opr2 = FrameMap::rscratch2_opr;
1630   } else if (opr2-&gt;is_constant()) {
1631     LIR_Opr tmp
1632       = opr2-&gt;type() == T_LONG ? FrameMap::rscratch2_long_opr : FrameMap::rscratch2_opr;
1633     const2reg(opr2, tmp, lir_patch_none, NULL);
1634     opr2 = tmp;
1635   }
1636 
1637   if (result-&gt;type() == T_LONG)
1638     __ csel(result-&gt;as_register_lo(), opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo(), acond);
1639   else
1640     __ csel(result-&gt;as_register(), opr1-&gt;as_register(), opr2-&gt;as_register(), acond);
1641 }
1642 
1643 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
1644   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
1645 
1646   if (left-&gt;is_single_cpu()) {
1647     Register lreg = left-&gt;as_register();
1648     Register dreg = as_reg(dest);
1649 
1650     if (right-&gt;is_single_cpu()) {
1651       // cpu register - cpu register
1652 
1653       assert(left-&gt;type() == T_INT &amp;&amp; right-&gt;type() == T_INT &amp;&amp; dest-&gt;type() == T_INT,
1654              &quot;should be&quot;);
1655       Register rreg = right-&gt;as_register();
1656       switch (code) {
1657       case lir_add: __ addw (dest-&gt;as_register(), lreg, rreg); break;
1658       case lir_sub: __ subw (dest-&gt;as_register(), lreg, rreg); break;
1659       case lir_mul: __ mulw (dest-&gt;as_register(), lreg, rreg); break;
1660       default:      ShouldNotReachHere();
1661       }
1662 
1663     } else if (right-&gt;is_double_cpu()) {
1664       Register rreg = right-&gt;as_register_lo();
1665       // single_cpu + double_cpu: can happen with obj+long
1666       assert(code == lir_add || code == lir_sub, &quot;mismatched arithmetic op&quot;);
1667       switch (code) {
1668       case lir_add: __ add(dreg, lreg, rreg); break;
1669       case lir_sub: __ sub(dreg, lreg, rreg); break;
1670       default: ShouldNotReachHere();
1671       }
1672     } else if (right-&gt;is_constant()) {
1673       // cpu register - constant
1674       jlong c;
1675 
1676       // FIXME.  This is fugly: we really need to factor all this logic.
1677       switch(right-&gt;type()) {
1678       case T_LONG:
1679         c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1680         break;
1681       case T_INT:
1682       case T_ADDRESS:
1683         c = right-&gt;as_constant_ptr()-&gt;as_jint();
1684         break;
1685       default:
1686         ShouldNotReachHere();
1687         c = 0;  // unreachable
1688         break;
1689       }
1690 
1691       assert(code == lir_add || code == lir_sub, &quot;mismatched arithmetic op&quot;);
1692       if (c == 0 &amp;&amp; dreg == lreg) {
1693         COMMENT(&quot;effective nop elided&quot;);
1694         return;
1695       }
1696       switch(left-&gt;type()) {
1697       case T_INT:
1698         switch (code) {
1699         case lir_add: __ addw(dreg, lreg, c); break;
1700         case lir_sub: __ subw(dreg, lreg, c); break;
1701         default: ShouldNotReachHere();
1702         }
1703         break;
1704       case T_OBJECT:
1705       case T_ADDRESS:
1706         switch (code) {
1707         case lir_add: __ add(dreg, lreg, c); break;
1708         case lir_sub: __ sub(dreg, lreg, c); break;
1709         default: ShouldNotReachHere();
1710         }
1711         break;
1712       default:
1713         ShouldNotReachHere();
1714       }
1715     } else {
1716       ShouldNotReachHere();
1717     }
1718 
1719   } else if (left-&gt;is_double_cpu()) {
1720     Register lreg_lo = left-&gt;as_register_lo();
1721 
1722     if (right-&gt;is_double_cpu()) {
1723       // cpu register - cpu register
1724       Register rreg_lo = right-&gt;as_register_lo();
1725       switch (code) {
1726       case lir_add: __ add (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1727       case lir_sub: __ sub (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1728       case lir_mul: __ mul (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1729       case lir_div: __ corrected_idivq(dest-&gt;as_register_lo(), lreg_lo, rreg_lo, false, rscratch1); break;
1730       case lir_rem: __ corrected_idivq(dest-&gt;as_register_lo(), lreg_lo, rreg_lo, true, rscratch1); break;
1731       default:
1732         ShouldNotReachHere();
1733       }
1734 
1735     } else if (right-&gt;is_constant()) {
1736       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1737       Register dreg = as_reg(dest);
1738       switch (code) {
1739         case lir_add:
1740         case lir_sub:
1741           if (c == 0 &amp;&amp; dreg == lreg_lo) {
1742             COMMENT(&quot;effective nop elided&quot;);
1743             return;
1744           }
1745           code == lir_add ? __ add(dreg, lreg_lo, c) : __ sub(dreg, lreg_lo, c);
1746           break;
1747         case lir_div:
1748           assert(c &gt; 0 &amp;&amp; is_power_of_2_long(c), &quot;divisor must be power-of-2 constant&quot;);
1749           if (c == 1) {
1750             // move lreg_lo to dreg if divisor is 1
1751             __ mov(dreg, lreg_lo);
1752           } else {
1753             unsigned int shift = exact_log2_long(c);
1754             // use rscratch1 as intermediate result register
1755             __ asr(rscratch1, lreg_lo, 63);
1756             __ add(rscratch1, lreg_lo, rscratch1, Assembler::LSR, 64 - shift);
1757             __ asr(dreg, rscratch1, shift);
1758           }
1759           break;
1760         case lir_rem:
1761           assert(c &gt; 0 &amp;&amp; is_power_of_2_long(c), &quot;divisor must be power-of-2 constant&quot;);
1762           if (c == 1) {
1763             // move 0 to dreg if divisor is 1
1764             __ mov(dreg, zr);
1765           } else {
1766             // use rscratch1 as intermediate result register
1767             __ negs(rscratch1, lreg_lo);
1768             __ andr(dreg, lreg_lo, c - 1);
1769             __ andr(rscratch1, rscratch1, c - 1);
1770             __ csneg(dreg, dreg, rscratch1, Assembler::MI);
1771           }
1772           break;
1773         default:
1774           ShouldNotReachHere();
1775       }
1776     } else {
1777       ShouldNotReachHere();
1778     }
1779   } else if (left-&gt;is_single_fpu()) {
1780     assert(right-&gt;is_single_fpu(), &quot;right hand side of float arithmetics needs to be float register&quot;);
1781     switch (code) {
1782     case lir_add: __ fadds (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1783     case lir_sub: __ fsubs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1784     case lir_mul: __ fmuls (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1785     case lir_div: __ fdivs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1786     default:
1787       ShouldNotReachHere();
1788     }
1789   } else if (left-&gt;is_double_fpu()) {
1790     if (right-&gt;is_double_fpu()) {
1791       // cpu register - cpu register
1792       switch (code) {
1793       case lir_add: __ faddd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1794       case lir_sub: __ fsubd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1795       case lir_mul: __ fmuld (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1796       case lir_div: __ fdivd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1797       default:
1798         ShouldNotReachHere();
1799       }
1800     } else {
1801       if (right-&gt;is_constant()) {
1802         ShouldNotReachHere();
1803       }
1804       ShouldNotReachHere();
1805     }
1806   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
1807     assert(left == dest, &quot;left and dest must be equal&quot;);
1808     ShouldNotReachHere();
1809   } else {
1810     ShouldNotReachHere();
1811   }
1812 }
1813 
1814 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) { Unimplemented(); }
1815 
1816 
1817 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op) {
1818   switch(code) {
1819   case lir_abs : __ fabsd(dest-&gt;as_double_reg(), value-&gt;as_double_reg()); break;
1820   case lir_sqrt: __ fsqrtd(dest-&gt;as_double_reg(), value-&gt;as_double_reg()); break;
1821   default      : ShouldNotReachHere();
1822   }
1823 }
1824 
1825 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
1826 
1827   assert(left-&gt;is_single_cpu() || left-&gt;is_double_cpu(), &quot;expect single or double register&quot;);
1828   Register Rleft = left-&gt;is_single_cpu() ? left-&gt;as_register() :
1829                                            left-&gt;as_register_lo();
1830    if (dst-&gt;is_single_cpu()) {
1831      Register Rdst = dst-&gt;as_register();
1832      if (right-&gt;is_constant()) {
1833        switch (code) {
1834          case lir_logic_and: __ andw (Rdst, Rleft, right-&gt;as_jint()); break;
1835          case lir_logic_or:  __ orrw (Rdst, Rleft, right-&gt;as_jint()); break;
1836          case lir_logic_xor: __ eorw (Rdst, Rleft, right-&gt;as_jint()); break;
1837          default: ShouldNotReachHere(); break;
1838        }
1839      } else {
1840        Register Rright = right-&gt;is_single_cpu() ? right-&gt;as_register() :
1841                                                   right-&gt;as_register_lo();
1842        switch (code) {
1843          case lir_logic_and: __ andw (Rdst, Rleft, Rright); break;
1844          case lir_logic_or:  __ orrw (Rdst, Rleft, Rright); break;
1845          case lir_logic_xor: __ eorw (Rdst, Rleft, Rright); break;
1846          default: ShouldNotReachHere(); break;
1847        }
1848      }
1849    } else {
1850      Register Rdst = dst-&gt;as_register_lo();
1851      if (right-&gt;is_constant()) {
1852        switch (code) {
1853          case lir_logic_and: __ andr (Rdst, Rleft, right-&gt;as_jlong()); break;
1854          case lir_logic_or:  __ orr (Rdst, Rleft, right-&gt;as_jlong()); break;
1855          case lir_logic_xor: __ eor (Rdst, Rleft, right-&gt;as_jlong()); break;
1856          default: ShouldNotReachHere(); break;
1857        }
1858      } else {
1859        Register Rright = right-&gt;is_single_cpu() ? right-&gt;as_register() :
1860                                                   right-&gt;as_register_lo();
1861        switch (code) {
1862          case lir_logic_and: __ andr (Rdst, Rleft, Rright); break;
1863          case lir_logic_or:  __ orr (Rdst, Rleft, Rright); break;
1864          case lir_logic_xor: __ eor (Rdst, Rleft, Rright); break;
1865          default: ShouldNotReachHere(); break;
1866        }
1867      }
1868    }
1869 }
1870 
1871 
1872 
1873 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr illegal, LIR_Opr result, CodeEmitInfo* info) {
1874 
1875   // opcode check
1876   assert((code == lir_idiv) || (code == lir_irem), &quot;opcode must be idiv or irem&quot;);
1877   bool is_irem = (code == lir_irem);
1878 
1879   // operand check
1880   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
1881   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
1882   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
1883   Register lreg = left-&gt;as_register();
1884   Register dreg = result-&gt;as_register();
1885 
1886   // power-of-2 constant check and codegen
1887   if (right-&gt;is_constant()) {
1888     int c = right-&gt;as_constant_ptr()-&gt;as_jint();
1889     assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
1890     if (is_irem) {
1891       if (c == 1) {
1892         // move 0 to dreg if divisor is 1
1893         __ movw(dreg, zr);
1894       } else {
1895         // use rscratch1 as intermediate result register
1896         __ negsw(rscratch1, lreg);
1897         __ andw(dreg, lreg, c - 1);
1898         __ andw(rscratch1, rscratch1, c - 1);
1899         __ csnegw(dreg, dreg, rscratch1, Assembler::MI);
1900       }
1901     } else {
1902       if (c == 1) {
1903         // move lreg to dreg if divisor is 1
1904         __ movw(dreg, lreg);
1905       } else {
1906         unsigned int shift = exact_log2(c);
1907         // use rscratch1 as intermediate result register
1908         __ asrw(rscratch1, lreg, 31);
1909         __ addw(rscratch1, lreg, rscratch1, Assembler::LSR, 32 - shift);
1910         __ asrw(dreg, rscratch1, shift);
1911       }
1912     }
1913   } else {
1914     Register rreg = right-&gt;as_register();
1915     __ corrected_idivl(dreg, lreg, rreg, is_irem, rscratch1);
1916   }
1917 }
1918 
1919 
1920 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1921   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_single_cpu()) {
1922     // tableswitch
1923     Register reg = as_reg(opr2);
1924     struct tableswitch &amp;table = switches[opr1-&gt;as_constant_ptr()-&gt;as_jint()];
1925     __ tableswitch(reg, table._first_key, table._last_key, table._branches, table._after);
1926   } else if (opr1-&gt;is_single_cpu() || opr1-&gt;is_double_cpu()) {
1927     Register reg1 = as_reg(opr1);
1928     if (opr2-&gt;is_single_cpu()) {
1929       // cpu register - cpu register
1930       Register reg2 = opr2-&gt;as_register();
1931       if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {
1932         __ cmpoop(reg1, reg2);
1933       } else {
1934         assert(opr2-&gt;type() != T_OBJECT &amp;&amp; opr2-&gt;type() != T_ARRAY, &quot;cmp int, oop?&quot;);
1935         __ cmpw(reg1, reg2);
1936       }
1937       return;
1938     }
1939     if (opr2-&gt;is_double_cpu()) {
1940       // cpu register - cpu register
1941       Register reg2 = opr2-&gt;as_register_lo();
1942       __ cmp(reg1, reg2);
1943       return;
1944     }
1945 
1946     if (opr2-&gt;is_constant()) {
1947       bool is_32bit = false; // width of register operand
1948       jlong imm;
1949 
1950       switch(opr2-&gt;type()) {
1951       case T_INT:
1952         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1953         is_32bit = true;
1954         break;
1955       case T_LONG:
1956         imm = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
1957         break;
1958       case T_ADDRESS:
1959         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1960         break;
1961       case T_OBJECT:
1962       case T_ARRAY:
1963         jobject2reg(opr2-&gt;as_constant_ptr()-&gt;as_jobject(), rscratch1);
1964         __ cmpoop(reg1, rscratch1);
1965         return;
1966       default:
1967         ShouldNotReachHere();
1968         imm = 0;  // unreachable
1969         break;
1970       }
1971 
1972       if (Assembler::operand_valid_for_add_sub_immediate(imm)) {
1973         if (is_32bit)
1974           __ cmpw(reg1, imm);
1975         else
1976           __ subs(zr, reg1, imm);
1977         return;
1978       } else {
1979         __ mov(rscratch1, imm);
1980         if (is_32bit)
1981           __ cmpw(reg1, rscratch1);
1982         else
1983           __ cmp(reg1, rscratch1);
1984         return;
1985       }
1986     } else
1987       ShouldNotReachHere();
1988   } else if (opr1-&gt;is_single_fpu()) {
1989     FloatRegister reg1 = opr1-&gt;as_float_reg();
1990     assert(opr2-&gt;is_single_fpu(), &quot;expect single float register&quot;);
1991     FloatRegister reg2 = opr2-&gt;as_float_reg();
1992     __ fcmps(reg1, reg2);
1993   } else if (opr1-&gt;is_double_fpu()) {
1994     FloatRegister reg1 = opr1-&gt;as_double_reg();
1995     assert(opr2-&gt;is_double_fpu(), &quot;expect double float register&quot;);
1996     FloatRegister reg2 = opr2-&gt;as_double_reg();
1997     __ fcmpd(reg1, reg2);
1998   } else {
1999     ShouldNotReachHere();
2000   }
2001 }
2002 
2003 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
2004   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2005     bool is_unordered_less = (code == lir_ucmp_fd2i);
2006     if (left-&gt;is_single_fpu()) {
2007       __ float_cmp(true, is_unordered_less ? -1 : 1, left-&gt;as_float_reg(), right-&gt;as_float_reg(), dst-&gt;as_register());
2008     } else if (left-&gt;is_double_fpu()) {
2009       __ float_cmp(false, is_unordered_less ? -1 : 1, left-&gt;as_double_reg(), right-&gt;as_double_reg(), dst-&gt;as_register());
2010     } else {
2011       ShouldNotReachHere();
2012     }
2013   } else if (code == lir_cmp_l2i) {
2014     Label done;
2015     __ cmp(left-&gt;as_register_lo(), right-&gt;as_register_lo());
2016     __ mov(dst-&gt;as_register(), (u_int64_t)-1L);
2017     __ br(Assembler::LT, done);
2018     __ csinc(dst-&gt;as_register(), zr, zr, Assembler::EQ);
2019     __ bind(done);
2020   } else {
2021     ShouldNotReachHere();
2022   }
2023 }
2024 
2025 
2026 void LIR_Assembler::align_call(LIR_Code code) {  }
2027 
2028 
2029 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
2030   address call = __ trampoline_call(Address(op-&gt;addr(), rtype));
2031   if (call == NULL) {
2032     bailout(&quot;trampoline stub overflow&quot;);
2033     return;
2034   }
2035   add_call_info(code_offset(), op-&gt;info());
2036 }
2037 
2038 
2039 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
2040   address call = __ ic_call(op-&gt;addr());
2041   if (call == NULL) {
2042     bailout(&quot;trampoline stub overflow&quot;);
2043     return;
2044   }
2045   add_call_info(code_offset(), op-&gt;info());
2046 }
2047 
2048 
2049 /* Currently, vtable-dispatch is only enabled for sparc platforms */
2050 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
2051   ShouldNotReachHere();
2052 }
2053 
2054 
2055 void LIR_Assembler::emit_static_call_stub() {
2056   address call_pc = __ pc();
2057   address stub = __ start_a_stub(call_stub_size());
2058   if (stub == NULL) {
2059     bailout(&quot;static call stub overflow&quot;);
2060     return;
2061   }
2062 
2063   int start = __ offset();
2064 
2065   __ relocate(static_stub_Relocation::spec(call_pc));
2066   __ mov_metadata(rmethod, (Metadata*)NULL);
2067   __ movptr(rscratch1, 0);
2068   __ br(rscratch1);
2069 
2070   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
2071   __ end_a_stub();
2072 }
2073 
2074 
2075 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2076   assert(exceptionOop-&gt;as_register() == r0, &quot;must match&quot;);
2077   assert(exceptionPC-&gt;as_register() == r3, &quot;must match&quot;);
2078 
2079   // exception object is not added to oop map by LinearScan
2080   // (LinearScan assumes that no oops are in fixed registers)
2081   info-&gt;add_register_oop(exceptionOop);
2082   Runtime1::StubID unwind_id;
2083 
2084   // get current pc information
2085   // pc is only needed if the method has an exception handler, the unwind code does not need it.
2086   int pc_for_athrow_offset = __ offset();
2087   InternalAddress pc_for_athrow(__ pc());
2088   __ adr(exceptionPC-&gt;as_register(), pc_for_athrow);
2089   add_call_info(pc_for_athrow_offset, info); // for exception handler
2090 
2091   __ verify_not_null_oop(r0);
2092   // search an exception handler (r0: exception oop, r3: throwing pc)
2093   if (compilation()-&gt;has_fpu_code()) {
2094     unwind_id = Runtime1::handle_exception_id;
2095   } else {
2096     unwind_id = Runtime1::handle_exception_nofpu_id;
2097   }
2098   __ far_call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
2099 
2100   // FIXME: enough room for two byte trap   ????
2101   __ nop();
2102 }
2103 
2104 
2105 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
2106   assert(exceptionOop-&gt;as_register() == r0, &quot;must match&quot;);
2107 
2108   __ b(_unwind_handler_entry);
2109 }
2110 
2111 
2112 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2113   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2114   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2115 
2116   switch (left-&gt;type()) {
2117     case T_INT: {
2118       switch (code) {
2119       case lir_shl:  __ lslvw (dreg, lreg, count-&gt;as_register()); break;
2120       case lir_shr:  __ asrvw (dreg, lreg, count-&gt;as_register()); break;
2121       case lir_ushr: __ lsrvw (dreg, lreg, count-&gt;as_register()); break;
2122       default:
2123         ShouldNotReachHere();
2124         break;
2125       }
2126       break;
2127     case T_LONG:
2128     case T_ADDRESS:
2129     case T_OBJECT:
2130       switch (code) {
2131       case lir_shl:  __ lslv (dreg, lreg, count-&gt;as_register()); break;
2132       case lir_shr:  __ asrv (dreg, lreg, count-&gt;as_register()); break;
2133       case lir_ushr: __ lsrv (dreg, lreg, count-&gt;as_register()); break;
2134       default:
2135         ShouldNotReachHere();
2136         break;
2137       }
2138       break;
2139     default:
2140       ShouldNotReachHere();
2141       break;
2142     }
2143   }
2144 }
2145 
2146 
2147 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2148   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2149   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2150 
2151   switch (left-&gt;type()) {
2152     case T_INT: {
2153       switch (code) {
2154       case lir_shl:  __ lslw (dreg, lreg, count); break;
2155       case lir_shr:  __ asrw (dreg, lreg, count); break;
2156       case lir_ushr: __ lsrw (dreg, lreg, count); break;
2157       default:
2158         ShouldNotReachHere();
2159         break;
2160       }
2161       break;
2162     case T_LONG:
2163     case T_ADDRESS:
2164     case T_OBJECT:
2165       switch (code) {
2166       case lir_shl:  __ lsl (dreg, lreg, count); break;
2167       case lir_shr:  __ asr (dreg, lreg, count); break;
2168       case lir_ushr: __ lsr (dreg, lreg, count); break;
2169       default:
2170         ShouldNotReachHere();
2171         break;
2172       }
2173       break;
2174     default:
2175       ShouldNotReachHere();
2176       break;
2177     }
2178   }
2179 }
2180 
2181 
2182 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
2183   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2184   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2185   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2186   __ str (r, Address(sp, offset_from_rsp_in_bytes));
2187 }
2188 
2189 
2190 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
2191   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2192   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2193   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2194   __ mov (rscratch1, c);
2195   __ str (rscratch1, Address(sp, offset_from_rsp_in_bytes));
2196 }
2197 
2198 
2199 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
2200   ShouldNotReachHere();
2201   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2202   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2203   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2204   __ lea(rscratch1, __ constant_oop_address(o));
2205   __ str(rscratch1, Address(sp, offset_from_rsp_in_bytes));
2206 }
2207 
2208 
2209 // This code replaces a call to arraycopy; no exception may
2210 // be thrown in this code, they must be thrown in the System.arraycopy
2211 // activation frame; we could save some checks if this would not be the case
2212 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
2213   ciArrayKlass* default_type = op-&gt;expected_type();
2214   Register src = op-&gt;src()-&gt;as_register();
2215   Register dst = op-&gt;dst()-&gt;as_register();
2216   Register src_pos = op-&gt;src_pos()-&gt;as_register();
2217   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
2218   Register length  = op-&gt;length()-&gt;as_register();
2219   Register tmp = op-&gt;tmp()-&gt;as_register();
2220 
2221   __ resolve(ACCESS_READ, src);
2222   __ resolve(ACCESS_WRITE, dst);
2223 
2224   CodeStub* stub = op-&gt;stub();
2225   int flags = op-&gt;flags();
2226   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
2227   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
2228 
2229   // if we don&#39;t know anything, just go through the generic arraycopy
2230   if (default_type == NULL // || basic_type == T_OBJECT
2231       ) {
2232     Label done;
2233     assert(src == r1 &amp;&amp; src_pos == r2, &quot;mismatch in calling convention&quot;);
2234 
2235     // Save the arguments in case the generic arraycopy fails and we
2236     // have to fall back to the JNI stub
2237     __ stp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2238     __ stp(length,  src_pos, Address(sp, 2*BytesPerWord));
2239     __ str(src,              Address(sp, 4*BytesPerWord));
2240 
2241     address copyfunc_addr = StubRoutines::generic_arraycopy();
2242     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
2243 
2244     // The arguments are in java calling convention so we shift them
2245     // to C convention
2246     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
2247     __ mov(c_rarg0, j_rarg0);
2248     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
2249     __ mov(c_rarg1, j_rarg1);
2250     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
2251     __ mov(c_rarg2, j_rarg2);
2252     assert_different_registers(c_rarg3, j_rarg4);
2253     __ mov(c_rarg3, j_rarg3);
2254     __ mov(c_rarg4, j_rarg4);
2255 #ifndef PRODUCT
2256     if (PrintC1Statistics) {
2257       __ incrementw(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
2258     }
2259 #endif
2260     __ far_call(RuntimeAddress(copyfunc_addr));
2261 
2262     __ cbz(r0, *stub-&gt;continuation());
2263 
2264     // Reload values from the stack so they are where the stub
2265     // expects them.
2266     __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2267     __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
2268     __ ldr(src,              Address(sp, 4*BytesPerWord));
2269 
2270     // r0 is -1^K where K == partial copied count
2271     __ eonw(rscratch1, r0, 0);
2272     // adjust length down and src/end pos up by partial copied count
2273     __ subw(length, length, rscratch1);
2274     __ addw(src_pos, src_pos, rscratch1);
2275     __ addw(dst_pos, dst_pos, rscratch1);
2276     __ b(*stub-&gt;entry());
2277 
2278     __ bind(*stub-&gt;continuation());
2279     return;
2280   }
2281 
2282   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
2283 
2284   int elem_size = type2aelembytes(basic_type);
2285   int shift_amount;
2286   int scale = exact_log2(elem_size);
2287 
2288   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
2289   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
2290   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
2291   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
2292 
2293   // test for NULL
2294   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
2295     __ cbz(src, *stub-&gt;entry());
2296   }
2297   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
2298     __ cbz(dst, *stub-&gt;entry());
2299   }
2300 
2301   // If the compiler was not able to prove that exact type of the source or the destination
2302   // of the arraycopy is an array type, check at runtime if the source or the destination is
2303   // an instance type.
2304   if (flags &amp; LIR_OpArrayCopy::type_check) {
2305     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::dst_objarray)) {
2306       __ load_klass(tmp, dst);
2307       __ ldrw(rscratch1, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2308       __ cmpw(rscratch1, Klass::_lh_neutral_value);
2309       __ br(Assembler::GE, *stub-&gt;entry());
2310     }
2311 
2312     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::src_objarray)) {
2313       __ load_klass(tmp, src);
2314       __ ldrw(rscratch1, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2315       __ cmpw(rscratch1, Klass::_lh_neutral_value);
2316       __ br(Assembler::GE, *stub-&gt;entry());
2317     }
2318   }
2319 
2320   // check if negative
2321   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
2322     __ cmpw(src_pos, 0);
2323     __ br(Assembler::LT, *stub-&gt;entry());
2324   }
2325   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
2326     __ cmpw(dst_pos, 0);
2327     __ br(Assembler::LT, *stub-&gt;entry());
2328   }
2329 
2330   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
2331     __ cmpw(length, 0);
2332     __ br(Assembler::LT, *stub-&gt;entry());
2333   }
2334 
2335   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
2336     __ addw(tmp, src_pos, length);
2337     __ ldrw(rscratch1, src_length_addr);
2338     __ cmpw(tmp, rscratch1);
2339     __ br(Assembler::HI, *stub-&gt;entry());
2340   }
2341   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
2342     __ addw(tmp, dst_pos, length);
2343     __ ldrw(rscratch1, dst_length_addr);
2344     __ cmpw(tmp, rscratch1);
2345     __ br(Assembler::HI, *stub-&gt;entry());
2346   }
2347 
2348   if (flags &amp; LIR_OpArrayCopy::type_check) {
2349     // We don&#39;t know the array types are compatible
2350     if (basic_type != T_OBJECT) {
2351       // Simple test for basic type arrays
2352       if (UseCompressedClassPointers) {
2353         __ ldrw(tmp, src_klass_addr);
2354         __ ldrw(rscratch1, dst_klass_addr);
2355         __ cmpw(tmp, rscratch1);
2356       } else {
2357         __ ldr(tmp, src_klass_addr);
2358         __ ldr(rscratch1, dst_klass_addr);
2359         __ cmp(tmp, rscratch1);
2360       }
2361       __ br(Assembler::NE, *stub-&gt;entry());
2362     } else {
2363       // For object arrays, if src is a sub class of dst then we can
2364       // safely do the copy.
2365       Label cont, slow;
2366 
2367 #define PUSH(r1, r2)                                    \
2368       stp(r1, r2, __ pre(sp, -2 * wordSize));
2369 
2370 #define POP(r1, r2)                                     \
2371       ldp(r1, r2, __ post(sp, 2 * wordSize));
2372 
2373       __ PUSH(src, dst);
2374 
2375       __ load_klass(src, src);
2376       __ load_klass(dst, dst);
2377 
2378       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
2379 
2380       __ PUSH(src, dst);
2381       __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
2382       __ POP(src, dst);
2383 
2384       __ cbnz(src, cont);
2385 
2386       __ bind(slow);
2387       __ POP(src, dst);
2388 
2389       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2390       if (copyfunc_addr != NULL) { // use stub if available
2391         // src is not a sub class of dst so we have to do a
2392         // per-element check.
2393 
2394         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2395         if ((flags &amp; mask) != mask) {
2396           // Check that at least both of them object arrays.
2397           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2398 
2399           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2400             __ load_klass(tmp, src);
2401           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2402             __ load_klass(tmp, dst);
2403           }
2404           int lh_offset = in_bytes(Klass::layout_helper_offset());
2405           Address klass_lh_addr(tmp, lh_offset);
2406           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2407           __ ldrw(rscratch1, klass_lh_addr);
2408           __ mov(rscratch2, objArray_lh);
2409           __ eorw(rscratch1, rscratch1, rscratch2);
2410           __ cbnzw(rscratch1, *stub-&gt;entry());
2411         }
2412 
2413        // Spill because stubs can use any register they like and it&#39;s
2414        // easier to restore just those that we care about.
2415         __ stp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2416         __ stp(length,  src_pos, Address(sp, 2*BytesPerWord));
2417         __ str(src,              Address(sp, 4*BytesPerWord));
2418 
2419         __ lea(c_rarg0, Address(src, src_pos, Address::uxtw(scale)));
2420         __ add(c_rarg0, c_rarg0, arrayOopDesc::base_offset_in_bytes(basic_type));
2421         assert_different_registers(c_rarg0, dst, dst_pos, length);
2422         __ lea(c_rarg1, Address(dst, dst_pos, Address::uxtw(scale)));
2423         __ add(c_rarg1, c_rarg1, arrayOopDesc::base_offset_in_bytes(basic_type));
2424         assert_different_registers(c_rarg1, dst, length);
2425         __ uxtw(c_rarg2, length);
2426         assert_different_registers(c_rarg2, dst);
2427 
2428         __ load_klass(c_rarg4, dst);
2429         __ ldr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
2430         __ ldrw(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
2431         __ far_call(RuntimeAddress(copyfunc_addr));
2432 
2433 #ifndef PRODUCT
2434         if (PrintC1Statistics) {
2435           Label failed;
2436           __ cbnz(r0, failed);
2437           __ incrementw(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
2438           __ bind(failed);
2439         }
2440 #endif
2441 
2442         __ cbz(r0, *stub-&gt;continuation());
2443 
2444 #ifndef PRODUCT
2445         if (PrintC1Statistics) {
2446           __ incrementw(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
2447         }
2448 #endif
2449         assert_different_registers(dst, dst_pos, length, src_pos, src, r0, rscratch1);
2450 
2451         // Restore previously spilled arguments
2452         __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2453         __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
2454         __ ldr(src,              Address(sp, 4*BytesPerWord));
2455 
2456         // return value is -1^K where K is partial copied count
2457         __ eonw(rscratch1, r0, zr);
2458         // adjust length down and src/end pos up by partial copied count
2459         __ subw(length, length, rscratch1);
2460         __ addw(src_pos, src_pos, rscratch1);
2461         __ addw(dst_pos, dst_pos, rscratch1);
2462       }
2463 
2464       __ b(*stub-&gt;entry());
2465 
2466       __ bind(cont);
2467       __ POP(src, dst);
2468     }
2469   }
2470 
2471 #ifdef ASSERT
2472   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2473     // Sanity check the known type with the incoming class.  For the
2474     // primitive case the types must match exactly with src.klass and
2475     // dst.klass each exactly matching the default type.  For the
2476     // object array case, if no type check is needed then either the
2477     // dst type is exactly the expected type and the src type is a
2478     // subtype which we can&#39;t check or src is the same array as dst
2479     // but not necessarily exactly of type default_type.
2480     Label known_ok, halt;
2481     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
2482     if (UseCompressedClassPointers) {
2483       __ encode_klass_not_null(tmp);
2484     }
2485 
2486     if (basic_type != T_OBJECT) {
2487 
2488       if (UseCompressedClassPointers) {
2489         __ ldrw(rscratch1, dst_klass_addr);
2490         __ cmpw(tmp, rscratch1);
2491       } else {
2492         __ ldr(rscratch1, dst_klass_addr);
2493         __ cmp(tmp, rscratch1);
2494       }
2495       __ br(Assembler::NE, halt);
2496       if (UseCompressedClassPointers) {
2497         __ ldrw(rscratch1, src_klass_addr);
2498         __ cmpw(tmp, rscratch1);
2499       } else {
2500         __ ldr(rscratch1, src_klass_addr);
2501         __ cmp(tmp, rscratch1);
2502       }
2503       __ br(Assembler::EQ, known_ok);
2504     } else {
2505       if (UseCompressedClassPointers) {
2506         __ ldrw(rscratch1, dst_klass_addr);
2507         __ cmpw(tmp, rscratch1);
2508       } else {
2509         __ ldr(rscratch1, dst_klass_addr);
2510         __ cmp(tmp, rscratch1);
2511       }
2512       __ br(Assembler::EQ, known_ok);
2513       __ cmp(src, dst);
2514       __ br(Assembler::EQ, known_ok);
2515     }
2516     __ bind(halt);
2517     __ stop(&quot;incorrect type information in arraycopy&quot;);
2518     __ bind(known_ok);
2519   }
2520 #endif
2521 
2522 #ifndef PRODUCT
2523   if (PrintC1Statistics) {
2524     __ incrementw(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
2525   }
2526 #endif
2527 
2528   __ lea(c_rarg0, Address(src, src_pos, Address::uxtw(scale)));
2529   __ add(c_rarg0, c_rarg0, arrayOopDesc::base_offset_in_bytes(basic_type));
2530   assert_different_registers(c_rarg0, dst, dst_pos, length);
2531   __ lea(c_rarg1, Address(dst, dst_pos, Address::uxtw(scale)));
2532   __ add(c_rarg1, c_rarg1, arrayOopDesc::base_offset_in_bytes(basic_type));
2533   assert_different_registers(c_rarg1, dst, length);
2534   __ uxtw(c_rarg2, length);
2535   assert_different_registers(c_rarg2, dst);
2536 
2537   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2538   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2539   const char *name;
2540   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2541 
2542  CodeBlob *cb = CodeCache::find_blob(entry);
2543  if (cb) {
2544    __ far_call(RuntimeAddress(entry));
2545  } else {
2546    __ call_VM_leaf(entry, 3);
2547  }
2548 
2549   __ bind(*stub-&gt;continuation());
2550 }
2551 
2552 
2553 
2554 
2555 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2556   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
2557   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2558   Register lock = op-&gt;lock_opr()-&gt;as_register();
2559   if (!UseFastLocking) {
2560     __ b(*op-&gt;stub()-&gt;entry());
2561   } else if (op-&gt;code() == lir_lock) {
2562     Register scratch = noreg;
2563     if (UseBiasedLocking) {
2564       scratch = op-&gt;scratch_opr()-&gt;as_register();
2565     }
2566     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2567     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
2568     // add debug info for NullPointerException only if one is possible
2569     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
2570     if (op-&gt;info() != NULL) {
2571       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
2572     }
2573     // done
2574   } else if (op-&gt;code() == lir_unlock) {
2575     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2576     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2577   } else {
2578     Unimplemented();
2579   }
2580   __ bind(*op-&gt;stub()-&gt;continuation());
2581 }
2582 
2583 
2584 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2585   ciMethod* method = op-&gt;profiled_method();
2586   int bci          = op-&gt;profiled_bci();
2587   ciMethod* callee = op-&gt;profiled_callee();
2588 
2589   // Update counter for all call types
2590   ciMethodData* md = method-&gt;method_data_or_null();
2591   assert(md != NULL, &quot;Sanity&quot;);
2592   ciProfileData* data = md-&gt;bci_to_data(bci);
2593   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2594   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2595   Register mdo  = op-&gt;mdo()-&gt;as_register();
2596   __ mov_metadata(mdo, md-&gt;constant_encoding());
2597   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
2598   // Perform additional virtual call profiling for invokevirtual and
2599   // invokeinterface bytecodes
2600   if (op-&gt;should_profile_receiver_type()) {
2601     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2602     Register recv = op-&gt;recv()-&gt;as_register();
2603     assert_different_registers(mdo, recv);
2604     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2605     ciKlass* known_klass = op-&gt;known_holder();
2606     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2607       // We know the type that will be seen at this call site; we can
2608       // statically update the MethodData* rather than needing to do
2609       // dynamic tests on the receiver type
2610 
2611       // NOTE: we should probably put a lock around this search to
2612       // avoid collisions by concurrent compilations
2613       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2614       uint i;
2615       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2616         ciKlass* receiver = vc_data-&gt;receiver(i);
2617         if (known_klass-&gt;equals(receiver)) {
2618           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2619           __ addptr(data_addr, DataLayout::counter_increment);
2620           return;
2621         }
2622       }
2623 
2624       // Receiver type not found in profile data; select an empty slot
2625 
2626       // Note that this is less efficient than it should be because it
2627       // always does a write to the receiver part of the
2628       // VirtualCallData rather than just the first time
2629       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2630         ciKlass* receiver = vc_data-&gt;receiver(i);
2631         if (receiver == NULL) {
2632           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
2633           __ mov_metadata(rscratch1, known_klass-&gt;constant_encoding());
2634           __ lea(rscratch2, recv_addr);
2635           __ str(rscratch1, Address(rscratch2));
2636           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2637           __ addptr(data_addr, DataLayout::counter_increment);
2638           return;
2639         }
2640       }
2641     } else {
2642       __ load_klass(recv, recv);
2643       Label update_done;
2644       type_profile_helper(mdo, md, data, recv, &amp;update_done);
2645       // Receiver did not match any saved receiver and there is no empty row for it.
2646       // Increment total counter to indicate polymorphic case.
2647       __ addptr(counter_addr, DataLayout::counter_increment);
2648 
2649       __ bind(update_done);
2650     }
2651   } else {
2652     // Static call
2653     __ addptr(counter_addr, DataLayout::counter_increment);
2654   }
2655 }
2656 
2657 
2658 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
2659   Unimplemented();
2660 }
2661 
2662 
2663 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
2664   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
2665 }
2666 
2667 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
2668   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
2669   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
2670   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
2671   Register crc = op-&gt;crc()-&gt;as_register();
2672   Register val = op-&gt;val()-&gt;as_register();
2673   Register res = op-&gt;result_opr()-&gt;as_register();
2674 
2675   assert_different_registers(val, crc, res);
2676   unsigned long offset;
2677   __ adrp(res, ExternalAddress(StubRoutines::crc_table_addr()), offset);
2678   if (offset) __ add(res, res, offset);
2679 
2680   __ mvnw(crc, crc); // ~crc
2681   __ update_byte_crc32(crc, val, res);
2682   __ mvnw(res, crc); // ~crc
2683 }
2684 
2685 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2686   COMMENT(&quot;emit_profile_type {&quot;);
2687   Register obj = op-&gt;obj()-&gt;as_register();
2688   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
2689   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2690   ciKlass* exact_klass = op-&gt;exact_klass();
2691   intptr_t current_klass = op-&gt;current_klass();
2692   bool not_null = op-&gt;not_null();
2693   bool no_conflict = op-&gt;no_conflict();
2694 
2695   Label update, next, none;
2696 
2697   bool do_null = !not_null;
2698   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2699   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2700 
2701   assert(do_null || do_update, &quot;why are we here?&quot;);
2702   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2703   assert(mdo_addr.base() != rscratch1, &quot;wrong register&quot;);
2704 
2705   __ verify_oop(obj);
2706 
2707   if (tmp != obj) {
2708     __ mov(tmp, obj);
2709   }
2710   if (do_null) {
2711     __ cbnz(tmp, update);
2712     if (!TypeEntries::was_null_seen(current_klass)) {
2713       __ ldr(rscratch2, mdo_addr);
2714       __ orr(rscratch2, rscratch2, TypeEntries::null_seen);
2715       __ str(rscratch2, mdo_addr);
2716     }
2717     if (do_update) {
2718 #ifndef ASSERT
2719       __ b(next);
2720     }
2721 #else
2722       __ b(next);
2723     }
2724   } else {
2725     __ cbnz(tmp, update);
2726     __ stop(&quot;unexpected null obj&quot;);
2727 #endif
2728   }
2729 
2730   __ bind(update);
2731 
2732   if (do_update) {
2733 #ifdef ASSERT
2734     if (exact_klass != NULL) {
2735       Label ok;
2736       __ load_klass(tmp, tmp);
2737       __ mov_metadata(rscratch1, exact_klass-&gt;constant_encoding());
2738       __ eor(rscratch1, tmp, rscratch1);
2739       __ cbz(rscratch1, ok);
2740       __ stop(&quot;exact klass and actual klass differ&quot;);
2741       __ bind(ok);
2742     }
2743 #endif
2744     if (!no_conflict) {
2745       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
2746         if (exact_klass != NULL) {
2747           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
2748         } else {
2749           __ load_klass(tmp, tmp);
2750         }
2751 
2752         __ ldr(rscratch2, mdo_addr);
2753         __ eor(tmp, tmp, rscratch2);
2754         __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2755         // klass seen before, nothing to do. The unknown bit may have been
2756         // set already but no need to check.
2757         __ cbz(rscratch1, next);
2758 
2759         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2760 
2761         if (TypeEntries::is_type_none(current_klass)) {
2762           __ cbz(rscratch2, none);
2763           __ cmp(rscratch2, (u1)TypeEntries::null_seen);
2764           __ br(Assembler::EQ, none);
2765           // There is a chance that the checks above (re-reading profiling
2766           // data from memory) fail if another thread has just set the
2767           // profiling to this obj&#39;s klass
2768           __ dmb(Assembler::ISHLD);
2769           __ ldr(rscratch2, mdo_addr);
2770           __ eor(tmp, tmp, rscratch2);
2771           __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2772           __ cbz(rscratch1, next);
2773         }
2774       } else {
2775         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2776                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
2777 
2778         __ ldr(tmp, mdo_addr);
2779         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2780       }
2781 
2782       // different than before. Cannot keep accurate profile.
2783       __ ldr(rscratch2, mdo_addr);
2784       __ orr(rscratch2, rscratch2, TypeEntries::type_unknown);
2785       __ str(rscratch2, mdo_addr);
2786 
2787       if (TypeEntries::is_type_none(current_klass)) {
2788         __ b(next);
2789 
2790         __ bind(none);
2791         // first time here. Set profile type.
2792         __ str(tmp, mdo_addr);
2793       }
2794     } else {
2795       // There&#39;s a single possible klass at this profile point
2796       assert(exact_klass != NULL, &quot;should be&quot;);
2797       if (TypeEntries::is_type_none(current_klass)) {
2798         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
2799         __ ldr(rscratch2, mdo_addr);
2800         __ eor(tmp, tmp, rscratch2);
2801         __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2802         __ cbz(rscratch1, next);
2803 #ifdef ASSERT
2804         {
2805           Label ok;
2806           __ ldr(rscratch1, mdo_addr);
2807           __ cbz(rscratch1, ok);
2808           __ cmp(rscratch1, (u1)TypeEntries::null_seen);
2809           __ br(Assembler::EQ, ok);
2810           // may have been set by another thread
2811           __ dmb(Assembler::ISHLD);
2812           __ mov_metadata(rscratch1, exact_klass-&gt;constant_encoding());
2813           __ ldr(rscratch2, mdo_addr);
2814           __ eor(rscratch2, rscratch1, rscratch2);
2815           __ andr(rscratch2, rscratch2, TypeEntries::type_mask);
2816           __ cbz(rscratch2, ok);
2817 
2818           __ stop(&quot;unexpected profiling mismatch&quot;);
2819           __ bind(ok);
2820         }
2821 #endif
2822         // first time here. Set profile type.
2823         __ ldr(tmp, mdo_addr);
2824       } else {
2825         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2826                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
2827 
2828         __ ldr(tmp, mdo_addr);
2829         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2830 
2831         __ orr(tmp, tmp, TypeEntries::type_unknown);
2832         __ str(tmp, mdo_addr);
2833         // FIXME: Write barrier needed here?
2834       }
2835     }
2836 
2837     __ bind(next);
2838   }
2839   COMMENT(&quot;} emit_profile_type&quot;);
2840 }
2841 
2842 
2843 void LIR_Assembler::align_backward_branch_target() {
2844 }
2845 
2846 
2847 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
2848   // tmp must be unused
2849   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2850 
2851   if (left-&gt;is_single_cpu()) {
2852     assert(dest-&gt;is_single_cpu(), &quot;expect single result reg&quot;);
2853     __ negw(dest-&gt;as_register(), left-&gt;as_register());
2854   } else if (left-&gt;is_double_cpu()) {
2855     assert(dest-&gt;is_double_cpu(), &quot;expect double result reg&quot;);
2856     __ neg(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
2857   } else if (left-&gt;is_single_fpu()) {
2858     assert(dest-&gt;is_single_fpu(), &quot;expect single float result reg&quot;);
2859     __ fnegs(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
2860   } else {
2861     assert(left-&gt;is_double_fpu(), &quot;expect double float operand reg&quot;);
2862     assert(dest-&gt;is_double_fpu(), &quot;expect double float result reg&quot;);
2863     __ fnegd(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
2864   }
2865 }
2866 
2867 
2868 void LIR_Assembler::leal(LIR_Opr addr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
2869   assert(patch_code == lir_patch_none, &quot;Patch code not supported&quot;);
2870   __ lea(dest-&gt;as_register_lo(), as_Address(addr-&gt;as_address_ptr()));
2871 }
2872 
2873 
2874 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
2875   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
2876 
2877   CodeBlob *cb = CodeCache::find_blob(dest);
2878   if (cb) {
2879     __ far_call(RuntimeAddress(dest));
2880   } else {
2881     __ mov(rscratch1, RuntimeAddress(dest));
2882     int len = args-&gt;length();
2883     int type = 0;
2884     if (! result-&gt;is_illegal()) {
2885       switch (result-&gt;type()) {
2886       case T_VOID:
2887         type = 0;
2888         break;
2889       case T_INT:
2890       case T_LONG:
2891       case T_OBJECT:
2892         type = 1;
2893         break;
2894       case T_FLOAT:
2895         type = 2;
2896         break;
2897       case T_DOUBLE:
2898         type = 3;
2899         break;
2900       default:
2901         ShouldNotReachHere();
2902         break;
2903       }
2904     }
2905     int num_gpargs = 0;
2906     int num_fpargs = 0;
2907     for (int i = 0; i &lt; args-&gt;length(); i++) {
2908       LIR_Opr arg = args-&gt;at(i);
2909       if (arg-&gt;type() == T_FLOAT || arg-&gt;type() == T_DOUBLE) {
2910         num_fpargs++;
2911       } else {
2912         num_gpargs++;
2913       }
2914     }
2915     __ blrt(rscratch1, num_gpargs, num_fpargs, type);
2916   }
2917 
2918   if (info != NULL) {
2919     add_call_info_here(info);
2920   }
2921   __ maybe_isb();
2922 }
2923 
2924 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
2925   if (dest-&gt;is_address() || src-&gt;is_address()) {
2926     move_op(src, dest, type, lir_patch_none, info,
2927             /*pop_fpu_stack*/false, /*unaligned*/false, /*wide*/false);
2928   } else {
2929     ShouldNotReachHere();
2930   }
2931 }
2932 
2933 #ifdef ASSERT
2934 // emit run-time assertion
2935 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
2936   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
2937 
2938   if (op-&gt;in_opr1()-&gt;is_valid()) {
2939     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
2940     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
2941   } else {
2942     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
2943     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
2944   }
2945 
2946   Label ok;
2947   if (op-&gt;condition() != lir_cond_always) {
2948     Assembler::Condition acond = Assembler::AL;
2949     switch (op-&gt;condition()) {
2950       case lir_cond_equal:        acond = Assembler::EQ;  break;
2951       case lir_cond_notEqual:     acond = Assembler::NE;  break;
2952       case lir_cond_less:         acond = Assembler::LT;  break;
2953       case lir_cond_lessEqual:    acond = Assembler::LE;  break;
2954       case lir_cond_greaterEqual: acond = Assembler::GE;  break;
2955       case lir_cond_greater:      acond = Assembler::GT;  break;
2956       case lir_cond_belowEqual:   acond = Assembler::LS;  break;
2957       case lir_cond_aboveEqual:   acond = Assembler::HS;  break;
2958       default:                    ShouldNotReachHere();
2959     }
2960     __ br(acond, ok);
2961   }
2962   if (op-&gt;halt()) {
2963     const char* str = __ code_string(op-&gt;msg());
2964     __ stop(str);
2965   } else {
2966     breakpoint();
2967   }
2968   __ bind(ok);
2969 }
2970 #endif
2971 
2972 #ifndef PRODUCT
2973 #define COMMENT(x)   do { __ block_comment(x); } while (0)
2974 #else
2975 #define COMMENT(x)
2976 #endif
2977 
2978 void LIR_Assembler::membar() {
2979   COMMENT(&quot;membar&quot;);
2980   __ membar(MacroAssembler::AnyAny);
2981 }
2982 
2983 void LIR_Assembler::membar_acquire() {
2984   __ membar(Assembler::LoadLoad|Assembler::LoadStore);
2985 }
2986 
2987 void LIR_Assembler::membar_release() {
2988   __ membar(Assembler::LoadStore|Assembler::StoreStore);
2989 }
2990 
2991 void LIR_Assembler::membar_loadload() {
2992   __ membar(Assembler::LoadLoad);
2993 }
2994 
2995 void LIR_Assembler::membar_storestore() {
2996   __ membar(MacroAssembler::StoreStore);
2997 }
2998 
2999 void LIR_Assembler::membar_loadstore() { __ membar(MacroAssembler::LoadStore); }
3000 
3001 void LIR_Assembler::membar_storeload() { __ membar(MacroAssembler::StoreLoad); }
3002 
3003 void LIR_Assembler::on_spin_wait() {
3004   Unimplemented();
3005 }
3006 
3007 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
3008   __ mov(result_reg-&gt;as_register(), rthread);
3009 }
3010 
3011 
3012 void LIR_Assembler::peephole(LIR_List *lir) {
3013 #if 0
3014   if (tableswitch_count &gt;= max_tableswitches)
3015     return;
3016 
3017   /*
3018     This finite-state automaton recognizes sequences of compare-and-
3019     branch instructions.  We will turn them into a tableswitch.  You
3020     could argue that C1 really shouldn&#39;t be doing this sort of
3021     optimization, but without it the code is really horrible.
3022   */
3023 
3024   enum { start_s, cmp1_s, beq_s, cmp_s } state;
3025   int first_key, last_key = -2147483648;
3026   int next_key = 0;
3027   int start_insn = -1;
3028   int last_insn = -1;
3029   Register reg = noreg;
3030   LIR_Opr reg_opr;
3031   state = start_s;
3032 
3033   LIR_OpList* inst = lir-&gt;instructions_list();
3034   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3035     LIR_Op* op = inst-&gt;at(i);
3036     switch (state) {
3037     case start_s:
3038       first_key = -1;
3039       start_insn = i;
3040       switch (op-&gt;code()) {
3041       case lir_cmp:
3042         LIR_Opr opr1 = op-&gt;as_Op2()-&gt;in_opr1();
3043         LIR_Opr opr2 = op-&gt;as_Op2()-&gt;in_opr2();
3044         if (opr1-&gt;is_cpu_register() &amp;&amp; opr1-&gt;is_single_cpu()
3045             &amp;&amp; opr2-&gt;is_constant()
3046             &amp;&amp; opr2-&gt;type() == T_INT) {
3047           reg_opr = opr1;
3048           reg = opr1-&gt;as_register();
3049           first_key = opr2-&gt;as_constant_ptr()-&gt;as_jint();
3050           next_key = first_key + 1;
3051           state = cmp_s;
3052           goto next_state;
3053         }
3054         break;
3055       }
3056       break;
3057     case cmp_s:
3058       switch (op-&gt;code()) {
3059       case lir_branch:
3060         if (op-&gt;as_OpBranch()-&gt;cond() == lir_cond_equal) {
3061           state = beq_s;
3062           last_insn = i;
3063           goto next_state;
3064         }
3065       }
3066       state = start_s;
3067       break;
3068     case beq_s:
3069       switch (op-&gt;code()) {
3070       case lir_cmp: {
3071         LIR_Opr opr1 = op-&gt;as_Op2()-&gt;in_opr1();
3072         LIR_Opr opr2 = op-&gt;as_Op2()-&gt;in_opr2();
3073         if (opr1-&gt;is_cpu_register() &amp;&amp; opr1-&gt;is_single_cpu()
3074             &amp;&amp; opr1-&gt;as_register() == reg
3075             &amp;&amp; opr2-&gt;is_constant()
3076             &amp;&amp; opr2-&gt;type() == T_INT
3077             &amp;&amp; opr2-&gt;as_constant_ptr()-&gt;as_jint() == next_key) {
3078           last_key = next_key;
3079           next_key++;
3080           state = cmp_s;
3081           goto next_state;
3082         }
3083       }
3084       }
3085       last_key = next_key;
3086       state = start_s;
3087       break;
3088     default:
3089       assert(false, &quot;impossible state&quot;);
3090     }
3091     if (state == start_s) {
3092       if (first_key &lt; last_key - 5L &amp;&amp; reg != noreg) {
3093         {
3094           // printf(&quot;found run register %d starting at insn %d low value %d high value %d\n&quot;,
3095           //        reg-&gt;encoding(),
3096           //        start_insn, first_key, last_key);
3097           //   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3098           //     inst-&gt;at(i)-&gt;print();
3099           //     tty-&gt;print(&quot;\n&quot;);
3100           //   }
3101           //   tty-&gt;print(&quot;\n&quot;);
3102         }
3103 
3104         struct tableswitch *sw = &amp;switches[tableswitch_count];
3105         sw-&gt;_insn_index = start_insn, sw-&gt;_first_key = first_key,
3106           sw-&gt;_last_key = last_key, sw-&gt;_reg = reg;
3107         inst-&gt;insert_before(last_insn + 1, new LIR_OpLabel(&amp;sw-&gt;_after));
3108         {
3109           // Insert the new table of branches
3110           int offset = last_insn;
3111           for (int n = first_key; n &lt; last_key; n++) {
3112             inst-&gt;insert_before
3113               (last_insn + 1,
3114                new LIR_OpBranch(lir_cond_always, T_ILLEGAL,
3115                                 inst-&gt;at(offset)-&gt;as_OpBranch()-&gt;label()));
3116             offset -= 2, i++;
3117           }
3118         }
3119         // Delete all the old compare-and-branch instructions
3120         for (int n = first_key; n &lt; last_key; n++) {
3121           inst-&gt;remove_at(start_insn);
3122           inst-&gt;remove_at(start_insn);
3123         }
3124         // Insert the tableswitch instruction
3125         inst-&gt;insert_before(start_insn,
3126                             new LIR_Op2(lir_cmp, lir_cond_always,
3127                                         LIR_OprFact::intConst(tableswitch_count),
3128                                         reg_opr));
3129         inst-&gt;insert_before(start_insn + 1, new LIR_OpLabel(&amp;sw-&gt;_branches));
3130         tableswitch_count++;
3131       }
3132       reg = noreg;
3133       last_key = -2147483648;
3134     }
3135   next_state:
3136     ;
3137   }
3138 #endif
3139 }
3140 
3141 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp_op) {
3142   Address addr = as_Address(src-&gt;as_address_ptr());
3143   BasicType type = src-&gt;type();
3144   bool is_oop = type == T_OBJECT || type == T_ARRAY;
3145 
3146   void (MacroAssembler::* add)(Register prev, RegisterOrConstant incr, Register addr);
3147   void (MacroAssembler::* xchg)(Register prev, Register newv, Register addr);
3148 
3149   switch(type) {
3150   case T_INT:
3151     xchg = &amp;MacroAssembler::atomic_xchgalw;
3152     add = &amp;MacroAssembler::atomic_addalw;
3153     break;
3154   case T_LONG:
3155     xchg = &amp;MacroAssembler::atomic_xchgal;
3156     add = &amp;MacroAssembler::atomic_addal;
3157     break;
3158   case T_OBJECT:
3159   case T_ARRAY:
3160     if (UseCompressedOops) {
3161       xchg = &amp;MacroAssembler::atomic_xchgalw;
3162       add = &amp;MacroAssembler::atomic_addalw;
3163     } else {
3164       xchg = &amp;MacroAssembler::atomic_xchgal;
3165       add = &amp;MacroAssembler::atomic_addal;
3166     }
3167     break;
3168   default:
3169     ShouldNotReachHere();
3170     xchg = &amp;MacroAssembler::atomic_xchgal;
3171     add = &amp;MacroAssembler::atomic_addal; // unreachable
3172   }
3173 
3174   switch (code) {
3175   case lir_xadd:
3176     {
3177       RegisterOrConstant inc;
3178       Register tmp = as_reg(tmp_op);
3179       Register dst = as_reg(dest);
3180       if (data-&gt;is_constant()) {
3181         inc = RegisterOrConstant(as_long(data));
3182         assert_different_registers(dst, addr.base(), tmp,
3183                                    rscratch1, rscratch2);
3184       } else {
3185         inc = RegisterOrConstant(as_reg(data));
3186         assert_different_registers(inc.as_register(), dst, addr.base(), tmp,
3187                                    rscratch1, rscratch2);
3188       }
3189       __ lea(tmp, addr);
3190       (_masm-&gt;*add)(dst, inc, tmp);
3191       break;
3192     }
3193   case lir_xchg:
3194     {
3195       Register tmp = tmp_op-&gt;as_register();
3196       Register obj = as_reg(data);
3197       Register dst = as_reg(dest);
3198       if (is_oop &amp;&amp; UseCompressedOops) {
3199         __ encode_heap_oop(rscratch2, obj);
3200         obj = rscratch2;
3201       }
3202       assert_different_registers(obj, addr.base(), tmp, rscratch1, dst);
3203       __ lea(tmp, addr);
3204       (_masm-&gt;*xchg)(dst, obj, tmp);
3205       if (is_oop &amp;&amp; UseCompressedOops) {
3206         __ decode_heap_oop(dst);
3207       }
3208     }
3209     break;
3210   default:
3211     ShouldNotReachHere();
3212   }
3213   __ membar(__ AnyAny);
3214 }
3215 
3216 #undef __
    </pre>
  </body>
</html>
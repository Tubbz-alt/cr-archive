<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRT_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;interpreter/interp_masm.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 31 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-removed"> 32 #include &quot;memory/universe.hpp&quot;</span>
 33 #include &quot;oops/method.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 #include &quot;runtime/icache.hpp&quot;
 37 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 38 #include &quot;runtime/signature.hpp&quot;
 39 
 40 #define __ _masm-&gt;
 41 
 42 // Implementation of SignatureHandlerGenerator
 43 Register InterpreterRuntime::SignatureHandlerGenerator::from() { return rlocals; }
 44 Register InterpreterRuntime::SignatureHandlerGenerator::to()   { return sp; }
 45 Register InterpreterRuntime::SignatureHandlerGenerator::temp() { return rscratch1; }
 46 
 47 InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 48       const methodHandle&amp; method, CodeBuffer* buffer) : NativeSignatureIterator(method) {
 49   _masm = new MacroAssembler(buffer);
 50   _num_int_args = (method-&gt;is_static() ? 1 : 0);
 51   _num_fp_args = 0;
 52   _stack_offset = 0;
</pre>
<hr />
<pre>
243  default:
244    {
245       __ add(r0, from(), Interpreter::local_offset_in_bytes(offset()));
246       __ ldr(temp(), r0);
247       Label L;
248       __ cbnz(temp(), L);
249       __ mov(r0, zr);
250       __ bind(L);
251       __ str(r0, Address(to(), _stack_offset));
252       _stack_offset += wordSize;
253       _num_int_args++;
254       break;
255    }
256   }
257 }
258 
259 void InterpreterRuntime::SignatureHandlerGenerator::generate(uint64_t fingerprint) {
260   // generate code to handle arguments
261   iterate(fingerprint);
262 
<span class="line-removed">263   // set the call format</span>
<span class="line-removed">264   // n.b. allow extra 1 for the JNI_Env in c_rarg0</span>
<span class="line-removed">265   unsigned int call_format = ((_num_int_args + 1) &lt;&lt; 6) | (_num_fp_args &lt;&lt; 2);</span>
<span class="line-removed">266 </span>
<span class="line-removed">267   switch (method()-&gt;result_type()) {</span>
<span class="line-removed">268   case T_VOID:</span>
<span class="line-removed">269     call_format |= MacroAssembler::ret_type_void;</span>
<span class="line-removed">270     break;</span>
<span class="line-removed">271   case T_FLOAT:</span>
<span class="line-removed">272     call_format |= MacroAssembler::ret_type_float;</span>
<span class="line-removed">273     break;</span>
<span class="line-removed">274   case T_DOUBLE:</span>
<span class="line-removed">275     call_format |= MacroAssembler::ret_type_double;</span>
<span class="line-removed">276     break;</span>
<span class="line-removed">277   default:</span>
<span class="line-removed">278     call_format |= MacroAssembler::ret_type_integral;</span>
<span class="line-removed">279     break;</span>
<span class="line-removed">280   }</span>
<span class="line-removed">281 </span>
<span class="line-removed">282   // // store the call format in the method</span>
<span class="line-removed">283   // __ movw(r0, call_format);</span>
<span class="line-removed">284   // __ str(r0, Address(rmethod, Method::call_format_offset()));</span>
<span class="line-removed">285 </span>
286   // return result handler
287   __ lea(r0, ExternalAddress(Interpreter::result_handler(method()-&gt;result_type())));
288   __ ret(lr);
289 
290   __ flush();
291 }
292 
293 
294 // Implementation of SignatureHandlerLibrary
295 
296 void SignatureHandlerLibrary::pd_set_handler(address handler) {}
297 
298 
299 class SlowSignatureHandler
300   : public NativeSignatureIterator {
301  private:
302   address   _from;
303   intptr_t* _to;
304   intptr_t* _int_args;
305   intptr_t* _fp_args;
</pre>
<hr />
<pre>
376       *_to++ = from_obj;
377       _num_fp_args++;
378     }
379   }
380 
381  public:
382   SlowSignatureHandler(const methodHandle&amp; method, address from, intptr_t* to)
383     : NativeSignatureIterator(method)
384   {
385     _from = from;
386     _to   = to;
387 
388     _int_args = to - (method-&gt;is_static() ? 16 : 17);
389     _fp_args =  to - 8;
390     _fp_identifiers = to - 9;
391     *(int*) _fp_identifiers = 0;
392     _num_int_args = (method-&gt;is_static() ? 1 : 0);
393     _num_fp_args = 0;
394   }
395 
<span class="line-removed">396   // n.b. allow extra 1 for the JNI_Env in c_rarg0</span>
<span class="line-removed">397   unsigned int get_call_format()</span>
<span class="line-removed">398   {</span>
<span class="line-removed">399     unsigned int call_format = ((_num_int_args + 1) &lt;&lt; 6) | (_num_fp_args &lt;&lt; 2);</span>
<span class="line-removed">400 </span>
<span class="line-removed">401     switch (method()-&gt;result_type()) {</span>
<span class="line-removed">402     case T_VOID:</span>
<span class="line-removed">403       call_format |= MacroAssembler::ret_type_void;</span>
<span class="line-removed">404       break;</span>
<span class="line-removed">405     case T_FLOAT:</span>
<span class="line-removed">406       call_format |= MacroAssembler::ret_type_float;</span>
<span class="line-removed">407       break;</span>
<span class="line-removed">408     case T_DOUBLE:</span>
<span class="line-removed">409       call_format |= MacroAssembler::ret_type_double;</span>
<span class="line-removed">410       break;</span>
<span class="line-removed">411     default:</span>
<span class="line-removed">412       call_format |= MacroAssembler::ret_type_integral;</span>
<span class="line-removed">413       break;</span>
<span class="line-removed">414     }</span>
<span class="line-removed">415 </span>
<span class="line-removed">416     return call_format;</span>
<span class="line-removed">417   }</span>
418 };
419 
420 
<span class="line-modified">421 IRT_ENTRY(address,</span>
422           InterpreterRuntime::slow_signature_handler(JavaThread* thread,
423                                                      Method* method,
424                                                      intptr_t* from,
425                                                      intptr_t* to))
426   methodHandle m(thread, (Method*)method);
427   assert(m-&gt;is_native(), &quot;sanity check&quot;);
428 
429   // handle arguments
430   SlowSignatureHandler ssh(m, (address)from, to);
431   ssh.iterate(UCONST64(-1));
432 
<span class="line-removed">433   // // set the call format</span>
<span class="line-removed">434   // method-&gt;set_call_format(ssh.get_call_format());</span>
<span class="line-removed">435 </span>
436   // return result handler
437   return Interpreter::result_handler(m-&gt;result_type());
<span class="line-modified">438 IRT_END</span>
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;interpreter/interp_masm.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 31 #include &quot;memory/allocation.inline.hpp&quot;

 32 #include &quot;oops/method.hpp&quot;
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/icache.hpp&quot;
 36 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 37 #include &quot;runtime/signature.hpp&quot;
 38 
 39 #define __ _masm-&gt;
 40 
 41 // Implementation of SignatureHandlerGenerator
 42 Register InterpreterRuntime::SignatureHandlerGenerator::from() { return rlocals; }
 43 Register InterpreterRuntime::SignatureHandlerGenerator::to()   { return sp; }
 44 Register InterpreterRuntime::SignatureHandlerGenerator::temp() { return rscratch1; }
 45 
 46 InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(
 47       const methodHandle&amp; method, CodeBuffer* buffer) : NativeSignatureIterator(method) {
 48   _masm = new MacroAssembler(buffer);
 49   _num_int_args = (method-&gt;is_static() ? 1 : 0);
 50   _num_fp_args = 0;
 51   _stack_offset = 0;
</pre>
<hr />
<pre>
242  default:
243    {
244       __ add(r0, from(), Interpreter::local_offset_in_bytes(offset()));
245       __ ldr(temp(), r0);
246       Label L;
247       __ cbnz(temp(), L);
248       __ mov(r0, zr);
249       __ bind(L);
250       __ str(r0, Address(to(), _stack_offset));
251       _stack_offset += wordSize;
252       _num_int_args++;
253       break;
254    }
255   }
256 }
257 
258 void InterpreterRuntime::SignatureHandlerGenerator::generate(uint64_t fingerprint) {
259   // generate code to handle arguments
260   iterate(fingerprint);
261 























262   // return result handler
263   __ lea(r0, ExternalAddress(Interpreter::result_handler(method()-&gt;result_type())));
264   __ ret(lr);
265 
266   __ flush();
267 }
268 
269 
270 // Implementation of SignatureHandlerLibrary
271 
272 void SignatureHandlerLibrary::pd_set_handler(address handler) {}
273 
274 
275 class SlowSignatureHandler
276   : public NativeSignatureIterator {
277  private:
278   address   _from;
279   intptr_t* _to;
280   intptr_t* _int_args;
281   intptr_t* _fp_args;
</pre>
<hr />
<pre>
352       *_to++ = from_obj;
353       _num_fp_args++;
354     }
355   }
356 
357  public:
358   SlowSignatureHandler(const methodHandle&amp; method, address from, intptr_t* to)
359     : NativeSignatureIterator(method)
360   {
361     _from = from;
362     _to   = to;
363 
364     _int_args = to - (method-&gt;is_static() ? 16 : 17);
365     _fp_args =  to - 8;
366     _fp_identifiers = to - 9;
367     *(int*) _fp_identifiers = 0;
368     _num_int_args = (method-&gt;is_static() ? 1 : 0);
369     _num_fp_args = 0;
370   }
371 






















372 };
373 
374 
<span class="line-modified">375 JRT_ENTRY(address,</span>
376           InterpreterRuntime::slow_signature_handler(JavaThread* thread,
377                                                      Method* method,
378                                                      intptr_t* from,
379                                                      intptr_t* to))
380   methodHandle m(thread, (Method*)method);
381   assert(m-&gt;is_native(), &quot;sanity check&quot;);
382 
383   // handle arguments
384   SlowSignatureHandler ssh(m, (address)from, to);
385   ssh.iterate(UCONST64(-1));
386 



387   // return result handler
388   return Interpreter::result_handler(m-&gt;result_type());
<span class="line-modified">389 JRT_END</span>
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRT_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
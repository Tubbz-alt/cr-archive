<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 28 #include &quot;c1/c1_Runtime1.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
 31 #include &quot;interpreter/interpreter.hpp&quot;
 32 #include &quot;oops/arrayOop.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 33 #include &quot;oops/markWord.hpp&quot;</span>
 34 #include &quot;runtime/basicLock.hpp&quot;
 35 #include &quot;runtime/biasedLocking.hpp&quot;
 36 #include &quot;runtime/os.hpp&quot;
 37 #include &quot;runtime/sharedRuntime.hpp&quot;
 38 #include &quot;runtime/stubRoutines.hpp&quot;
 39 
 40 void C1_MacroAssembler::float_cmp(bool is_float, int unordered_result,
 41                                   FloatRegister f0, FloatRegister f1,
 42                                   Register result)
 43 {
 44   Label done;
 45   if (is_float) {
 46     fcmps(f0, f1);
 47   } else {
 48     fcmpd(f0, f1);
 49   }
 50   if (unordered_result &lt; 0) {
 51     // we want -1 for unordered or less than, 0 for equal and 1 for
 52     // greater than.
 53     cset(result, NE);  // Not equal or unordered
 54     cneg(result, result, LT);  // Less than or unordered
 55   } else {
 56     // we want -1 for less than, 0 for equal and 1 for unordered or
 57     // greater than.
 58     cset(result, NE);  // Not equal or unordered
 59     cneg(result, result, LO);  // Less than
 60   }
 61 }
 62 
 63 int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register scratch, Label&amp; slow_case) {
 64   const int aligned_mask = BytesPerWord -1;
 65   const int hdr_offset = oopDesc::mark_offset_in_bytes();
 66   assert(hdr != obj &amp;&amp; hdr != disp_hdr &amp;&amp; obj != disp_hdr, &quot;registers must be different&quot;);
 67   Label done;
 68   int null_check_offset = -1;
 69 
 70   verify_oop(obj);
 71 
 72   // save object being locked into the BasicObjectLock
 73   str(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));
 74 
 75   if (UseBiasedLocking) {
 76     assert(scratch != noreg, &quot;should have scratch register at this point&quot;);
 77     null_check_offset = biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &amp;slow_case);
 78   } else {
 79     null_check_offset = offset();
 80   }
 81 
 82   // Load object header
 83   ldr(hdr, Address(obj, hdr_offset));
 84   // and mark it as unlocked
<a name="2" id="anc2"></a><span class="line-modified"> 85   orr(hdr, hdr, markWord::unlocked_value);</span>
 86   // save unlocked object header into the displaced header location on the stack
 87   str(hdr, Address(disp_hdr, 0));
 88   // test if object header is still the same (i.e. unlocked), and if so, store the
 89   // displaced header address in the object header - if it is not the same, get the
 90   // object header instead
 91   lea(rscratch2, Address(obj, hdr_offset));
 92   cmpxchgptr(hdr, disp_hdr, rscratch2, rscratch1, done, /*fallthough*/NULL);
 93   // if the object header was the same, we&#39;re done
 94   // if the object header was not the same, it is now in the hdr register
 95   // =&gt; test if it is a stack pointer into the same stack (recursive locking), i.e.:
 96   //
 97   // 1) (hdr &amp; aligned_mask) == 0
 98   // 2) sp &lt;= hdr
 99   // 3) hdr &lt;= sp + page_size
100   //
101   // these 3 tests can be done by evaluating the following expression:
102   //
103   // (hdr - sp) &amp; (aligned_mask - page_size)
104   //
105   // assuming both the stack pointer and page_size have their least
106   // significant 2 bits cleared and page_size is a power of 2
107   mov(rscratch1, sp);
108   sub(hdr, hdr, rscratch1);
109   ands(hdr, hdr, aligned_mask - os::vm_page_size());
110   // for recursive locking, the result is zero =&gt; save it in the displaced header
111   // location (NULL in the displaced hdr location indicates recursive locking)
112   str(hdr, Address(disp_hdr, 0));
113   // otherwise we don&#39;t care about the result and handle locking via runtime call
114   cbnz(hdr, slow_case);
115   // done
116   bind(done);
117   if (PrintBiasedLockingStatistics) {
118     lea(rscratch2, ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));
119     addmw(Address(rscratch2, 0), 1, rscratch1);
120   }
121   return null_check_offset;
122 }
123 
124 
125 void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label&amp; slow_case) {
126   const int aligned_mask = BytesPerWord -1;
127   const int hdr_offset = oopDesc::mark_offset_in_bytes();
128   assert(hdr != obj &amp;&amp; hdr != disp_hdr &amp;&amp; obj != disp_hdr, &quot;registers must be different&quot;);
129   Label done;
130 
131   if (UseBiasedLocking) {
132     // load object
133     ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));
134     biased_locking_exit(obj, hdr, done);
135   }
136 
137   // load displaced header
138   ldr(hdr, Address(disp_hdr, 0));
139   // if the loaded hdr is NULL we had recursive locking
140   // if we had recursive locking, we are done
141   cbz(hdr, done);
142   if (!UseBiasedLocking) {
143     // load object
144     ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));
145   }
146   verify_oop(obj);
147   // test if object header is pointing to the displaced header, and if so, restore
148   // the displaced header in the object - if the object header is not pointing to
149   // the displaced header, get the object header instead
150   // if the object header was not pointing to the displaced header,
151   // we do unlocking via runtime call
152   if (hdr_offset) {
153     lea(rscratch1, Address(obj, hdr_offset));
154     cmpxchgptr(disp_hdr, hdr, rscratch1, rscratch2, done, &amp;slow_case);
155   } else {
156     cmpxchgptr(disp_hdr, hdr, obj, rscratch2, done, &amp;slow_case);
157   }
158   // done
159   bind(done);
160 }
161 
162 
163 // Defines obj, preserves var_size_in_bytes
164 void C1_MacroAssembler::try_allocate(Register obj, Register var_size_in_bytes, int con_size_in_bytes, Register t1, Register t2, Label&amp; slow_case) {
165   if (UseTLAB) {
166     tlab_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
167   } else {
168     eden_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
169   }
170 }
171 
172 void C1_MacroAssembler::initialize_header(Register obj, Register klass, Register len, Register t1, Register t2) {
173   assert_different_registers(obj, klass, len);
174   if (UseBiasedLocking &amp;&amp; !len-&gt;is_valid()) {
175     assert_different_registers(obj, klass, len, t1, t2);
176     ldr(t1, Address(klass, Klass::prototype_header_offset()));
177   } else {
178     // This assumes that all prototype bits fit in an int32_t
<a name="3" id="anc3"></a><span class="line-modified">179     mov(t1, (int32_t)(intptr_t)markWord::prototype().value());</span>
180   }
181   str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));
182 
183   if (UseCompressedClassPointers) { // Take care not to kill klass
184     encode_klass_not_null(t1, klass);
185     strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));
186   } else {
187     str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));
188   }
189 
190   if (len-&gt;is_valid()) {
191     strw(len, Address(obj, arrayOopDesc::length_offset_in_bytes()));
192   } else if (UseCompressedClassPointers) {
193     store_klass_gap(obj, zr);
194   }
195 }
196 
197 // preserves obj, destroys len_in_bytes
198 void C1_MacroAssembler::initialize_body(Register obj, Register len_in_bytes, int hdr_size_in_bytes, Register t1) {
199   assert(hdr_size_in_bytes &gt;= 0, &quot;header size must be positive or 0&quot;);
200   Label done;
201 
202   // len_in_bytes is positive and ptr sized
203   subs(len_in_bytes, len_in_bytes, hdr_size_in_bytes);
204   br(Assembler::EQ, done);
205 
206   // Preserve obj
207   if (hdr_size_in_bytes)
208     add(obj, obj, hdr_size_in_bytes);
209   zero_memory(obj, len_in_bytes, t1);
210   if (hdr_size_in_bytes)
211     sub(obj, obj, hdr_size_in_bytes);
212 
213   bind(done);
214 }
215 
216 
217 void C1_MacroAssembler::allocate_object(Register obj, Register t1, Register t2, int header_size, int object_size, Register klass, Label&amp; slow_case) {
218   assert_different_registers(obj, t1, t2); // XXX really?
219   assert(header_size &gt;= 0 &amp;&amp; object_size &gt;= header_size, &quot;illegal sizes&quot;);
220 
221   try_allocate(obj, noreg, object_size * BytesPerWord, t1, t2, slow_case);
222 
223   initialize_object(obj, klass, noreg, object_size * HeapWordSize, t1, t2, UseTLAB);
224 }
225 
226 void C1_MacroAssembler::initialize_object(Register obj, Register klass, Register var_size_in_bytes, int con_size_in_bytes, Register t1, Register t2, bool is_tlab_allocated) {
227   assert((con_size_in_bytes &amp; MinObjAlignmentInBytesMask) == 0,
228          &quot;con_size_in_bytes is not multiple of alignment&quot;);
229   const int hdr_size_in_bytes = instanceOopDesc::header_size() * HeapWordSize;
230 
231   initialize_header(obj, klass, noreg, t1, t2);
232 
233   if (!(UseTLAB &amp;&amp; ZeroTLAB &amp;&amp; is_tlab_allocated)) {
234      // clear rest of allocated space
235      const Register index = t2;
236      const int threshold = 16 * BytesPerWord;   // approximate break even point for code size (see comments below)
237      if (var_size_in_bytes != noreg) {
238        mov(index, var_size_in_bytes);
239        initialize_body(obj, index, hdr_size_in_bytes, t1);
240      } else if (con_size_in_bytes &lt;= threshold) {
241        // use explicit null stores
242        int i = hdr_size_in_bytes;
243        if (i &lt; con_size_in_bytes &amp;&amp; (con_size_in_bytes % (2 * BytesPerWord))) {
244          str(zr, Address(obj, i));
245          i += BytesPerWord;
246        }
247        for (; i &lt; con_size_in_bytes; i += 2 * BytesPerWord)
248          stp(zr, zr, Address(obj, i));
249      } else if (con_size_in_bytes &gt; hdr_size_in_bytes) {
250        block_comment(&quot;zero memory&quot;);
251       // use loop to null out the fields
252 
253        int words = (con_size_in_bytes - hdr_size_in_bytes) / BytesPerWord;
254        mov(index,  words / 8);
255 
256        const int unroll = 8; // Number of str(zr) instructions we&#39;ll unroll
257        int remainder = words % unroll;
258        lea(rscratch1, Address(obj, hdr_size_in_bytes + remainder * BytesPerWord));
259 
260        Label entry_point, loop;
261        b(entry_point);
262 
263        bind(loop);
264        sub(index, index, 1);
265        for (int i = -unroll; i &lt; 0; i++) {
266          if (-i == remainder)
267            bind(entry_point);
268          str(zr, Address(rscratch1, i * wordSize));
269        }
270        if (remainder == 0)
271          bind(entry_point);
272        add(rscratch1, rscratch1, unroll * wordSize);
273        cbnz(index, loop);
274 
275      }
276   }
277 
278   membar(StoreStore);
279 
280   if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
281     assert(obj == r0, &quot;must be&quot;);
282     far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)));
283   }
284 
285   verify_oop(obj);
286 }
287 void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, int f, Register klass, Label&amp; slow_case) {
288   assert_different_registers(obj, len, t1, t2, klass);
289 
290   // determine alignment mask
291   assert(!(BytesPerWord &amp; 1), &quot;must be a multiple of 2 for masking code to work&quot;);
292 
293   // check for negative or excessive length
294   mov(rscratch1, (int32_t)max_array_allocation_length);
295   cmp(len, rscratch1);
296   br(Assembler::HS, slow_case);
297 
298   const Register arr_size = t2; // okay to be the same
299   // align object end
300   mov(arr_size, (int32_t)header_size * BytesPerWord + MinObjAlignmentInBytesMask);
301   add(arr_size, arr_size, len, ext::uxtw, f);
302   andr(arr_size, arr_size, ~MinObjAlignmentInBytesMask);
303 
304   try_allocate(obj, arr_size, 0, t1, t2, slow_case);
305 
306   initialize_header(obj, klass, len, t1, t2);
307 
308   // clear rest of allocated space
309   const Register len_zero = len;
310   initialize_body(obj, arr_size, header_size * BytesPerWord, len_zero);
311 
312   membar(StoreStore);
313 
314   if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
315     assert(obj == r0, &quot;must be&quot;);
316     far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)));
317   }
318 
319   verify_oop(obj);
320 }
321 
322 
323 void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
324   verify_oop(receiver);
325   // explicit NULL check not needed since load from [klass_offset] causes a trap
326   // check against inline cache
327   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), &quot;must add explicit null check&quot;);
328 
329   cmp_klass(receiver, iCache, rscratch1);
330 }
331 
332 
333 void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes) {
<a name="4" id="anc4"></a>




334   assert(bang_size_in_bytes &gt;= framesize, &quot;stack bang size incorrect&quot;);
335   // Make sure there is enough stack space for this method&#39;s activation.
336   // Note that we do this before doing an enter().
337   generate_stack_overflow_check(bang_size_in_bytes);
338   MacroAssembler::build_frame(framesize + 2 * wordSize);
<a name="5" id="anc5"></a>


339 }
340 
341 void C1_MacroAssembler::remove_frame(int framesize) {
342   MacroAssembler::remove_frame(framesize + 2 * wordSize);
<a name="6" id="anc6"></a>


343 }
344 
345 
346 void C1_MacroAssembler::verified_entry() {
<a name="7" id="anc7"></a><span class="line-added">347   // If we have to make this method not-entrant we&#39;ll overwrite its</span>
<span class="line-added">348   // first instruction with a jump.  For this action to be legal we</span>
<span class="line-added">349   // must ensure that this first instruction is a B, BL, NOP, BKPT,</span>
<span class="line-added">350   // SVC, HVC, or SMC.  Make it a NOP.</span>
<span class="line-added">351   nop();</span>
352 }
353 
354 void C1_MacroAssembler::load_parameter(int offset_in_words, Register reg) {
355   // rbp, + 0: link
356   //     + 1: return address
357   //     + 2: argument with offset 0
358   //     + 3: argument with offset 1
359   //     + 4: ...
360 
361   ldr(reg, Address(rfp, (offset_in_words + 2) * BytesPerWord));
362 }
363 
364 #ifndef PRODUCT
365 
366 void C1_MacroAssembler::verify_stack_oop(int stack_offset) {
367   if (!VerifyOops) return;
368   verify_oop_addr(Address(sp, stack_offset), &quot;oop&quot;);
369 }
370 
371 void C1_MacroAssembler::verify_not_null_oop(Register r) {
372   if (!VerifyOops) return;
373   Label not_null;
374   cbnz(r, not_null);
375   stop(&quot;non-null oop required&quot;);
376   bind(not_null);
377   verify_oop(r);
378 }
379 
380 void C1_MacroAssembler::invalidate_registers(bool inv_r0, bool inv_r19, bool inv_r2, bool inv_r3, bool inv_r4, bool inv_r5) {
381 #ifdef ASSERT
382   static int nn;
383   if (inv_r0) mov(r0, 0xDEAD);
384   if (inv_r19) mov(r19, 0xDEAD);
385   if (inv_r2) mov(r2, nn++);
386   if (inv_r3) mov(r3, 0xDEAD);
387   if (inv_r4) mov(r4, 0xDEAD);
388   if (inv_r5) mov(r5, 0xDEAD);
389 #endif
390 }
391 #endif // ifndef PRODUCT
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
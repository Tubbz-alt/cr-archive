<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler_aarch64.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
</pre>
<hr />
<pre>
<span class="line-old-header">*** 32,21 ***</span>
  #include &quot;c1/c1_MacroAssembler.hpp&quot;
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;c1/c1_ValueStack.hpp&quot;
  #include &quot;ci/ciArrayKlass.hpp&quot;
  #include &quot;ci/ciInstance.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;</span>
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;nativeInst_aarch64.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;vmreg_aarch64.inline.hpp&quot;
  
  
<span class="line-removed">- </span>
  #ifndef PRODUCT
  #define COMMENT(x)   do { __ block_comment(x); } while (0)
  #else
  #define COMMENT(x)
  #endif
<span class="line-new-header">--- 32,20 ---</span>
  #include &quot;c1/c1_MacroAssembler.hpp&quot;
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;c1/c1_ValueStack.hpp&quot;
  #include &quot;ci/ciArrayKlass.hpp&quot;
  #include &quot;ci/ciInstance.hpp&quot;
<span class="line-modified">! #include &quot;code/compiledIC.hpp&quot;</span>
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;nativeInst_aarch64.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;vmreg_aarch64.inline.hpp&quot;
  
  
  #ifndef PRODUCT
  #define COMMENT(x)   do { __ block_comment(x); } while (0)
  #else
  #define COMMENT(x)
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,22 ***</span>
    } else {
      return const_addr;
    }
  }
  
<span class="line-removed">- void LIR_Assembler::set_24bit_FPU() { Unimplemented(); }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::reset_FPU() { Unimplemented(); }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::fpop() { Unimplemented(); }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::fxch(int i) { Unimplemented(); }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::fld(int i) { Unimplemented(); }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::ffree(int i) { Unimplemented(); }</span>
<span class="line-removed">- </span>
  void LIR_Assembler::breakpoint() { Unimplemented(); }
  
  void LIR_Assembler::push(LIR_Opr opr) { Unimplemented(); }
  
  void LIR_Assembler::pop(LIR_Opr opr) { Unimplemented(); }
<span class="line-new-header">--- 136,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 313,10 ***</span>
<span class="line-new-header">--- 300,21 ---</span>
  
    __ bind(dont);
    return start_offset;
  }
  
<span class="line-added">+ void LIR_Assembler::clinit_barrier(ciMethod* method) {</span>
<span class="line-added">+   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);</span>
<span class="line-added">+   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Label L_skip_barrier;</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ mov_metadata(rscratch2, method-&gt;holder()-&gt;constant_encoding());</span>
<span class="line-added">+   __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added">+   __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>
<span class="line-added">+   __ bind(L_skip_barrier);</span>
<span class="line-added">+ }</span>
  
  void LIR_Assembler::jobject2reg(jobject o, Register reg) {
    if (o == NULL) {
      __ mov(reg, zr);
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 714,11 ***</span>
        __ verify_oop(src-&gt;as_register());
      }
      move_regs(src-&gt;as_register(), dest-&gt;as_register());
  
    } else if (dest-&gt;is_double_cpu()) {
<span class="line-modified">!     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_ARRAY) {</span>
        // Surprising to me but we can see move of a long to t_object
        __ verify_oop(src-&gt;as_register());
        move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
        return;
      }
<span class="line-new-header">--- 712,11 ---</span>
        __ verify_oop(src-&gt;as_register());
      }
      move_regs(src-&gt;as_register(), dest-&gt;as_register());
  
    } else if (dest-&gt;is_double_cpu()) {
<span class="line-modified">!     if (is_reference_type(src-&gt;type())) {</span>
        // Surprising to me but we can see move of a long to t_object
        __ verify_oop(src-&gt;as_register());
        move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
        return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 742,14 ***</span>
    }
  }
  
  void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
    if (src-&gt;is_single_cpu()) {
<span class="line-modified">!     if (type == T_ARRAY || type == T_OBJECT) {</span>
        __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
        __ verify_oop(src-&gt;as_register());
<span class="line-modified">!     } else if (type == T_METADATA || type == T_DOUBLE) {</span>
        __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
      } else {
        __ strw(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
      }
  
<span class="line-new-header">--- 740,14 ---</span>
    }
  }
  
  void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
    if (src-&gt;is_single_cpu()) {
<span class="line-modified">!     if (is_reference_type(type)) {</span>
        __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
        __ verify_oop(src-&gt;as_register());
<span class="line-modified">!     } else if (type == T_METADATA || type == T_DOUBLE || type == T_ADDRESS) {</span>
        __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
      } else {
        __ strw(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 780,11 ***</span>
    if (patch_code != lir_patch_none) {
      deoptimize_trap(info);
      return;
    }
  
<span class="line-modified">!   if (type == T_ARRAY || type == T_OBJECT) {</span>
      __ verify_oop(src-&gt;as_register());
  
      if (UseCompressedOops &amp;&amp; !wide) {
        __ encode_heap_oop(compressed_src, src-&gt;as_register());
      } else {
<span class="line-new-header">--- 778,11 ---</span>
    if (patch_code != lir_patch_none) {
      deoptimize_trap(info);
      return;
    }
  
<span class="line-modified">!   if (is_reference_type(type)) {</span>
      __ verify_oop(src-&gt;as_register());
  
      if (UseCompressedOops &amp;&amp; !wide) {
        __ encode_heap_oop(compressed_src, src-&gt;as_register());
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 855,14 ***</span>
  void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
    assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
    assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
  
    if (dest-&gt;is_single_cpu()) {
<span class="line-modified">!     if (type == T_ARRAY || type == T_OBJECT) {</span>
        __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
        __ verify_oop(dest-&gt;as_register());
<span class="line-modified">!     } else if (type == T_METADATA) {</span>
        __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
      } else {
        __ ldrw(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
      }
  
<span class="line-new-header">--- 853,14 ---</span>
  void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
    assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
    assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
  
    if (dest-&gt;is_single_cpu()) {
<span class="line-modified">!     if (is_reference_type(type)) {</span>
        __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
        __ verify_oop(dest-&gt;as_register());
<span class="line-modified">!     } else if (type == T_METADATA || type == T_ADDRESS) {</span>
        __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
      } else {
        __ ldrw(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1005,15 ***</span>
  
      default:
        ShouldNotReachHere();
    }
  
<span class="line-modified">!   if (type == T_ARRAY || type == T_OBJECT) {</span>
      if (UseCompressedOops &amp;&amp; !wide) {
        __ decode_heap_oop(dest-&gt;as_register());
      }
<span class="line-modified">!     __ verify_oop(dest-&gt;as_register());</span>
    } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
      if (UseCompressedClassPointers) {
        __ decode_klass_not_null(dest-&gt;as_register());
      }
    }
<span class="line-new-header">--- 1003,19 ---</span>
  
      default:
        ShouldNotReachHere();
    }
  
<span class="line-modified">!   if (is_reference_type(type)) {</span>
      if (UseCompressedOops &amp;&amp; !wide) {
        __ decode_heap_oop(dest-&gt;as_register());
      }
<span class="line-modified">! </span>
<span class="line-added">+     if (!UseZGC) {</span>
<span class="line-added">+       // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here</span>
<span class="line-added">+       __ verify_oop(dest-&gt;as_register());</span>
<span class="line-added">+     }</span>
    } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
      if (UseCompressedClassPointers) {
        __ decode_klass_not_null(dest-&gt;as_register());
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1068,12 ***</span>
      if (op-&gt;code() == lir_cond_float_branch) {
        bool is_unordered = (op-&gt;ublock() == op-&gt;block());
        // Assembler::EQ does not permit unordered branches, so we add
        // another branch here.  Likewise, Assembler::NE does not permit
        // ordered branches.
<span class="line-modified">!       if (is_unordered &amp;&amp; op-&gt;cond() == lir_cond_equal</span>
<span class="line-modified">!           || !is_unordered &amp;&amp; op-&gt;cond() == lir_cond_notEqual)</span>
          __ br(Assembler::VS, *(op-&gt;ublock()-&gt;label()));
        switch(op-&gt;cond()) {
        case lir_cond_equal:        acond = Assembler::EQ; break;
        case lir_cond_notEqual:     acond = Assembler::NE; break;
        case lir_cond_less:         acond = (is_unordered ? Assembler::LT : Assembler::LO); break;
<span class="line-new-header">--- 1070,12 ---</span>
      if (op-&gt;code() == lir_cond_float_branch) {
        bool is_unordered = (op-&gt;ublock() == op-&gt;block());
        // Assembler::EQ does not permit unordered branches, so we add
        // another branch here.  Likewise, Assembler::NE does not permit
        // ordered branches.
<span class="line-modified">!       if ((is_unordered &amp;&amp; op-&gt;cond() == lir_cond_equal)</span>
<span class="line-modified">!           || (!is_unordered &amp;&amp; op-&gt;cond() == lir_cond_notEqual))</span>
          __ br(Assembler::VS, *(op-&gt;ublock()-&gt;label()));
        switch(op-&gt;cond()) {
        case lir_cond_equal:        acond = Assembler::EQ; break;
        case lir_cond_notEqual:     acond = Assembler::NE; break;
        case lir_cond_less:         acond = (is_unordered ? Assembler::LT : Assembler::LO); break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1209,12 ***</span>
  void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
    Register len =  op-&gt;len()-&gt;as_register();
    __ uxtw(len, len);
  
    if (UseSlowPath ||
<span class="line-modified">!       (!UseFastNewObjectArray &amp;&amp; (op-&gt;type() == T_OBJECT || op-&gt;type() == T_ARRAY)) ||</span>
<span class="line-modified">!       (!UseFastNewTypeArray   &amp;&amp; (op-&gt;type() != T_OBJECT &amp;&amp; op-&gt;type() != T_ARRAY))) {</span>
      __ b(*op-&gt;stub()-&gt;entry());
    } else {
      Register tmp1 = op-&gt;tmp1()-&gt;as_register();
      Register tmp2 = op-&gt;tmp2()-&gt;as_register();
      Register tmp3 = op-&gt;tmp3()-&gt;as_register();
<span class="line-new-header">--- 1211,12 ---</span>
  void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
    Register len =  op-&gt;len()-&gt;as_register();
    __ uxtw(len, len);
  
    if (UseSlowPath ||
<span class="line-modified">!       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||</span>
<span class="line-modified">!       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {</span>
      __ b(*op-&gt;stub()-&gt;entry());
    } else {
      Register tmp1 = op-&gt;tmp1()-&gt;as_register();
      Register tmp2 = op-&gt;tmp2()-&gt;as_register();
      Register tmp3 = op-&gt;tmp3()-&gt;as_register();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1743,11 ***</span>
              return;
            }
            code == lir_add ? __ add(dreg, lreg_lo, c) : __ sub(dreg, lreg_lo, c);
            break;
          case lir_div:
<span class="line-modified">!           assert(c &gt; 0 &amp;&amp; is_power_of_2_long(c), &quot;divisor must be power-of-2 constant&quot;);</span>
            if (c == 1) {
              // move lreg_lo to dreg if divisor is 1
              __ mov(dreg, lreg_lo);
            } else {
              unsigned int shift = exact_log2_long(c);
<span class="line-new-header">--- 1745,11 ---</span>
              return;
            }
            code == lir_add ? __ add(dreg, lreg_lo, c) : __ sub(dreg, lreg_lo, c);
            break;
          case lir_div:
<span class="line-modified">!           assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);</span>
            if (c == 1) {
              // move lreg_lo to dreg if divisor is 1
              __ mov(dreg, lreg_lo);
            } else {
              unsigned int shift = exact_log2_long(c);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1756,11 ***</span>
              __ add(rscratch1, lreg_lo, rscratch1, Assembler::LSR, 64 - shift);
              __ asr(dreg, rscratch1, shift);
            }
            break;
          case lir_rem:
<span class="line-modified">!           assert(c &gt; 0 &amp;&amp; is_power_of_2_long(c), &quot;divisor must be power-of-2 constant&quot;);</span>
            if (c == 1) {
              // move 0 to dreg if divisor is 1
              __ mov(dreg, zr);
            } else {
              // use rscratch1 as intermediate result register
<span class="line-new-header">--- 1758,11 ---</span>
              __ add(rscratch1, lreg_lo, rscratch1, Assembler::LSR, 64 - shift);
              __ asr(dreg, rscratch1, shift);
            }
            break;
          case lir_rem:
<span class="line-modified">!           assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);</span>
            if (c == 1) {
              // move 0 to dreg if divisor is 1
              __ mov(dreg, zr);
            } else {
              // use rscratch1 as intermediate result register
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1779,22 ***</span>
    } else if (left-&gt;is_single_fpu()) {
      assert(right-&gt;is_single_fpu(), &quot;right hand side of float arithmetics needs to be float register&quot;);
      switch (code) {
      case lir_add: __ fadds (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
      case lir_sub: __ fsubs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
      case lir_mul: __ fmuls (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
      case lir_div: __ fdivs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
      default:
        ShouldNotReachHere();
      }
    } else if (left-&gt;is_double_fpu()) {
      if (right-&gt;is_double_fpu()) {
<span class="line-modified">!       // cpu register - cpu register</span>
        switch (code) {
        case lir_add: __ faddd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
        case lir_sub: __ fsubd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
        case lir_mul: __ fmuld (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
        case lir_div: __ fdivd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
        default:
          ShouldNotReachHere();
        }
      } else {
<span class="line-new-header">--- 1781,26 ---</span>
    } else if (left-&gt;is_single_fpu()) {
      assert(right-&gt;is_single_fpu(), &quot;right hand side of float arithmetics needs to be float register&quot;);
      switch (code) {
      case lir_add: __ fadds (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
      case lir_sub: __ fsubs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
<span class="line-added">+     case lir_mul_strictfp: // fall through</span>
      case lir_mul: __ fmuls (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
<span class="line-added">+     case lir_div_strictfp: // fall through</span>
      case lir_div: __ fdivs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
      default:
        ShouldNotReachHere();
      }
    } else if (left-&gt;is_double_fpu()) {
      if (right-&gt;is_double_fpu()) {
<span class="line-modified">!       // fpu register - fpu register</span>
        switch (code) {
        case lir_add: __ faddd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
        case lir_sub: __ fsubd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
<span class="line-added">+       case lir_mul_strictfp: // fall through</span>
        case lir_mul: __ fmuld (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
<span class="line-added">+       case lir_div_strictfp: // fall through</span>
        case lir_div: __ fdivd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
        default:
          ShouldNotReachHere();
        }
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1926,14 ***</span>
    } else if (opr1-&gt;is_single_cpu() || opr1-&gt;is_double_cpu()) {
      Register reg1 = as_reg(opr1);
      if (opr2-&gt;is_single_cpu()) {
        // cpu register - cpu register
        Register reg2 = opr2-&gt;as_register();
<span class="line-modified">!       if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {</span>
          __ cmpoop(reg1, reg2);
        } else {
<span class="line-modified">!         assert(opr2-&gt;type() != T_OBJECT &amp;&amp; opr2-&gt;type() != T_ARRAY, &quot;cmp int, oop?&quot;);</span>
          __ cmpw(reg1, reg2);
        }
        return;
      }
      if (opr2-&gt;is_double_cpu()) {
<span class="line-new-header">--- 1932,14 ---</span>
    } else if (opr1-&gt;is_single_cpu() || opr1-&gt;is_double_cpu()) {
      Register reg1 = as_reg(opr1);
      if (opr2-&gt;is_single_cpu()) {
        // cpu register - cpu register
        Register reg2 = opr2-&gt;as_register();
<span class="line-modified">!       if (is_reference_type(opr1-&gt;type())) {</span>
          __ cmpoop(reg1, reg2);
        } else {
<span class="line-modified">!         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);</span>
          __ cmpw(reg1, reg2);
        }
        return;
      }
      if (opr2-&gt;is_double_cpu()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1956,10 ***</span>
<span class="line-new-header">--- 1962,13 ---</span>
          imm = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
          break;
        case T_ADDRESS:
          imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
          break;
<span class="line-added">+       case T_METADATA:</span>
<span class="line-added">+         imm = (intptr_t)(opr2-&gt;as_constant_ptr()-&gt;as_metadata());</span>
<span class="line-added">+         break;</span>
        case T_OBJECT:
        case T_ARRAY:
          jobject2reg(opr2-&gt;as_constant_ptr()-&gt;as_jobject(), rscratch1);
          __ cmpoop(reg1, rscratch1);
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2061,15 ***</span>
    }
  
    int start = __ offset();
  
    __ relocate(static_stub_Relocation::spec(call_pc));
<span class="line-modified">!   __ mov_metadata(rmethod, (Metadata*)NULL);</span>
<span class="line-removed">-   __ movptr(rscratch1, 0);</span>
<span class="line-removed">-   __ br(rscratch1);</span>
  
<span class="line-modified">!   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);</span>
    __ end_a_stub();
  }
  
  
  void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
<span class="line-new-header">--- 2070,14 ---</span>
    }
  
    int start = __ offset();
  
    __ relocate(static_stub_Relocation::spec(call_pc));
<span class="line-modified">!   __ emit_static_call_stub();</span>
  
<span class="line-modified">!   assert(__ offset() - start + CompiledStaticCall::to_trampoline_stub_size()</span>
<span class="line-added">+         &lt;= call_stub_size(), &quot;stub too big&quot;);</span>
    __ end_a_stub();
  }
  
  
  void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2222,11 ***</span>
    __ resolve(ACCESS_WRITE, dst);
  
    CodeStub* stub = op-&gt;stub();
    int flags = op-&gt;flags();
    BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
<span class="line-modified">!   if (basic_type == T_ARRAY) basic_type = T_OBJECT;</span>
  
    // if we don&#39;t know anything, just go through the generic arraycopy
    if (default_type == NULL // || basic_type == T_OBJECT
        ) {
      Label done;
<span class="line-new-header">--- 2230,11 ---</span>
    __ resolve(ACCESS_WRITE, dst);
  
    CodeStub* stub = op-&gt;stub();
    int flags = op-&gt;flags();
    BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
<span class="line-modified">!   if (is_reference_type(basic_type)) basic_type = T_OBJECT;</span>
  
    // if we don&#39;t know anything, just go through the generic arraycopy
    if (default_type == NULL // || basic_type == T_OBJECT
        ) {
      Label done;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2266,11 ***</span>
      __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
      __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
      __ ldr(src,              Address(sp, 4*BytesPerWord));
  
      // r0 is -1^K where K == partial copied count
<span class="line-modified">!     __ eonw(rscratch1, r0, 0);</span>
      // adjust length down and src/end pos up by partial copied count
      __ subw(length, length, rscratch1);
      __ addw(src_pos, src_pos, rscratch1);
      __ addw(dst_pos, dst_pos, rscratch1);
      __ b(*stub-&gt;entry());
<span class="line-new-header">--- 2274,11 ---</span>
      __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
      __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
      __ ldr(src,              Address(sp, 4*BytesPerWord));
  
      // r0 is -1^K where K == partial copied count
<span class="line-modified">!     __ eonw(rscratch1, r0, zr);</span>
      // adjust length down and src/end pos up by partial copied count
      __ subw(length, length, rscratch1);
      __ addw(src_pos, src_pos, rscratch1);
      __ addw(dst_pos, dst_pos, rscratch1);
      __ b(*stub-&gt;entry());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2864,11 ***</span>
    }
  }
  
  
  void LIR_Assembler::leal(LIR_Opr addr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
<span class="line-modified">!   assert(patch_code == lir_patch_none, &quot;Patch code not supported&quot;);</span>
    __ lea(dest-&gt;as_register_lo(), as_Address(addr-&gt;as_address_ptr()));
  }
  
  
  void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
<span class="line-new-header">--- 2872,15 ---</span>
    }
  }
  
  
  void LIR_Assembler::leal(LIR_Opr addr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
<span class="line-modified">!   if (patch_code != lir_patch_none) {</span>
<span class="line-added">+     deoptimize_trap(info);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    __ lea(dest-&gt;as_register_lo(), as_Address(addr-&gt;as_address_ptr()));
  }
  
  
  void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2877,44 ***</span>
    CodeBlob *cb = CodeCache::find_blob(dest);
    if (cb) {
      __ far_call(RuntimeAddress(dest));
    } else {
      __ mov(rscratch1, RuntimeAddress(dest));
<span class="line-modified">!     int len = args-&gt;length();</span>
<span class="line-removed">-     int type = 0;</span>
<span class="line-removed">-     if (! result-&gt;is_illegal()) {</span>
<span class="line-removed">-       switch (result-&gt;type()) {</span>
<span class="line-removed">-       case T_VOID:</span>
<span class="line-removed">-         type = 0;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       case T_INT:</span>
<span class="line-removed">-       case T_LONG:</span>
<span class="line-removed">-       case T_OBJECT:</span>
<span class="line-removed">-         type = 1;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       case T_FLOAT:</span>
<span class="line-removed">-         type = 2;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       case T_DOUBLE:</span>
<span class="line-removed">-         type = 3;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       default:</span>
<span class="line-removed">-         ShouldNotReachHere();</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     int num_gpargs = 0;</span>
<span class="line-removed">-     int num_fpargs = 0;</span>
<span class="line-removed">-     for (int i = 0; i &lt; args-&gt;length(); i++) {</span>
<span class="line-removed">-       LIR_Opr arg = args-&gt;at(i);</span>
<span class="line-removed">-       if (arg-&gt;type() == T_FLOAT || arg-&gt;type() == T_DOUBLE) {</span>
<span class="line-removed">-         num_fpargs++;</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         num_gpargs++;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     __ blrt(rscratch1, num_gpargs, num_fpargs, type);</span>
    }
  
    if (info != NULL) {
      add_call_info_here(info);
    }
<span class="line-new-header">--- 2889,11 ---</span>
    CodeBlob *cb = CodeCache::find_blob(dest);
    if (cb) {
      __ far_call(RuntimeAddress(dest));
    } else {
      __ mov(rscratch1, RuntimeAddress(dest));
<span class="line-modified">!     __ blr(rscratch1);</span>
    }
  
    if (info != NULL) {
      add_call_info_here(info);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3139,11 ***</span>
  }
  
  void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp_op) {
    Address addr = as_Address(src-&gt;as_address_ptr());
    BasicType type = src-&gt;type();
<span class="line-modified">!   bool is_oop = type == T_OBJECT || type == T_ARRAY;</span>
  
    void (MacroAssembler::* add)(Register prev, RegisterOrConstant incr, Register addr);
    void (MacroAssembler::* xchg)(Register prev, Register newv, Register addr);
  
    switch(type) {
<span class="line-new-header">--- 3118,11 ---</span>
  }
  
  void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp_op) {
    Address addr = as_Address(src-&gt;as_address_ptr());
    BasicType type = src-&gt;type();
<span class="line-modified">!   bool is_oop = is_reference_type(type);</span>
  
    void (MacroAssembler::* add)(Register prev, RegisterOrConstant incr, Register addr);
    void (MacroAssembler::* xchg)(Register prev, Register newv, Register addr);
  
    switch(type) {
</pre>
<center><a href="c1_FrameMap_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler_aarch64.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="register_aarch64.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,11 ***</span>
<span class="line-new-header">--- 31,13 ---</span>
  #include &quot;code/vtableStubs.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/interp_masm.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;nativeInst_aarch64.hpp&quot;</span>
  #include &quot;oops/compiledICHolder.hpp&quot;
<span class="line-added">+ #include &quot;oops/klass.inline.hpp&quot;</span>
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/vframeArray.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;vmreg_aarch64.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,14 ***</span>
  #endif
  #if INCLUDE_JVMCI
  #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  #endif
  
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">- #include &quot;../../../../../../simulator/simulator.hpp&quot;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  #define __ masm-&gt;
  
  const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  
  class SimpleRuntimeFrame {
<span class="line-new-header">--- 50,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,45 ***</span>
    static void restore_result_registers(MacroAssembler* masm);
  
      // Capture info about frame layout
    enum layout {
                  fpu_state_off = 0,
<span class="line-modified">!                 fpu_state_end = fpu_state_off+FPUStateSizeInWords-1,</span>
                  // The frame sender code expects that rfp will be in
                  // the &quot;natural&quot; place and will override any oopMap
                  // setting for it. We must therefore force the layout
                  // so that it agrees with the frame sender code.
<span class="line-modified">!                 r0_off = fpu_state_off+FPUStateSizeInWords,</span>
<span class="line-modified">!                 rfp_off = r0_off + 30 * 2,</span>
<span class="line-modified">!                 return_off = rfp_off + 2,      // slot for return address</span>
<span class="line-modified">!                 reg_save_size = return_off + 2};</span>
  
  };
  
  OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {
  #if COMPILER2_OR_JVMCI
    if (save_vectors) {
      // Save upper half of vector registers
<span class="line-modified">!     int vect_words = 32 * 8 / wordSize;</span>
      additional_frame_words += vect_words;
    }
  #else
    assert(!save_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
  #endif
  
<span class="line-modified">!   int frame_size_in_bytes = align_up(additional_frame_words*wordSize +</span>
<span class="line-modified">!                                      reg_save_size*BytesPerInt, 16);</span>
    // OopMap frame size is in compiler stack slots (jint&#39;s) not bytes or words
    int frame_size_in_slots = frame_size_in_bytes / BytesPerInt;
    // The caller will allocate additional_frame_words
<span class="line-modified">!   int additional_frame_slots = additional_frame_words*wordSize / BytesPerInt;</span>
    // CodeBlob frame size is in words.
    int frame_size_in_words = frame_size_in_bytes / wordSize;
    *total_frame_words = frame_size_in_words;
  
<span class="line-modified">!   // Save registers, fpu state, and flags.</span>
<span class="line-removed">- </span>
    __ enter();
    __ push_CPU_state(save_vectors);
  
    // Set an oopmap for the call site.  This oopmap will map all
    // oop-registers and debug-info registers as callee-saved.  This
<span class="line-new-header">--- 98,45 ---</span>
    static void restore_result_registers(MacroAssembler* masm);
  
      // Capture info about frame layout
    enum layout {
                  fpu_state_off = 0,
<span class="line-modified">!                 fpu_state_end = fpu_state_off + FPUStateSizeInWords - 1,</span>
                  // The frame sender code expects that rfp will be in
                  // the &quot;natural&quot; place and will override any oopMap
                  // setting for it. We must therefore force the layout
                  // so that it agrees with the frame sender code.
<span class="line-modified">!                 r0_off = fpu_state_off + FPUStateSizeInWords,</span>
<span class="line-modified">!                 rfp_off = r0_off + (RegisterImpl::number_of_registers - 2) * RegisterImpl::max_slots_per_register,</span>
<span class="line-modified">!                 return_off = rfp_off + RegisterImpl::max_slots_per_register,      // slot for return address</span>
<span class="line-modified">!                 reg_save_size = return_off + RegisterImpl::max_slots_per_register};</span>
  
  };
  
  OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {
  #if COMPILER2_OR_JVMCI
    if (save_vectors) {
      // Save upper half of vector registers
<span class="line-modified">!     int vect_words = FloatRegisterImpl::number_of_registers * FloatRegisterImpl::extra_save_slots_per_register /</span>
<span class="line-added">+                      VMRegImpl::slots_per_word;</span>
      additional_frame_words += vect_words;
    }
  #else
    assert(!save_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
  #endif
  
<span class="line-modified">!   int frame_size_in_bytes = align_up(additional_frame_words * wordSize +</span>
<span class="line-modified">!                                      reg_save_size * BytesPerInt, 16);</span>
    // OopMap frame size is in compiler stack slots (jint&#39;s) not bytes or words
    int frame_size_in_slots = frame_size_in_bytes / BytesPerInt;
    // The caller will allocate additional_frame_words
<span class="line-modified">!   int additional_frame_slots = additional_frame_words * wordSize / BytesPerInt;</span>
    // CodeBlob frame size is in words.
    int frame_size_in_words = frame_size_in_bytes / wordSize;
    *total_frame_words = frame_size_in_words;
  
<span class="line-modified">!   // Save Integer and Float registers.</span>
    __ enter();
    __ push_CPU_state(save_vectors);
  
    // Set an oopmap for the call site.  This oopmap will map all
    // oop-registers and debug-info registers as callee-saved.  This
</pre>
<hr />
<pre>
<span class="line-old-header">*** 148,23 ***</span>
    OopMapSet *oop_maps = new OopMapSet();
    OopMap* oop_map = new OopMap(frame_size_in_slots, 0);
  
    for (int i = 0; i &lt; RegisterImpl::number_of_registers; i++) {
      Register r = as_Register(i);
<span class="line-modified">!     if (r &lt; rheapbase &amp;&amp; r != rscratch1 &amp;&amp; r != rscratch2) {</span>
<span class="line-modified">!       int sp_offset = 2 * (i + 32); // SP offsets are in 4-byte words,</span>
<span class="line-modified">!                                     // register slots are 8 bytes</span>
<span class="line-modified">!                                     // wide, 32 floating-point</span>
<span class="line-modified">!                                     // registers</span>
        oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset + additional_frame_slots),
                                  r-&gt;as_VMReg());
      }
    }
  
    for (int i = 0; i &lt; FloatRegisterImpl::number_of_registers; i++) {
      FloatRegister r = as_FloatRegister(i);
<span class="line-modified">!     int sp_offset = save_vectors ? (4 * i) : (2 * i);</span>
      oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
                                r-&gt;as_VMReg());
    }
  
    return oop_map;
<span class="line-new-header">--- 146,24 ---</span>
    OopMapSet *oop_maps = new OopMapSet();
    OopMap* oop_map = new OopMap(frame_size_in_slots, 0);
  
    for (int i = 0; i &lt; RegisterImpl::number_of_registers; i++) {
      Register r = as_Register(i);
<span class="line-modified">!     if (r &lt;= rfp &amp;&amp; r != rscratch1 &amp;&amp; r != rscratch2) {</span>
<span class="line-modified">!       // SP offsets are in 4-byte words.</span>
<span class="line-modified">!       // Register slots are 8 bytes wide, 32 floating-point registers.</span>
<span class="line-modified">!       int sp_offset = RegisterImpl::max_slots_per_register * i +</span>
<span class="line-modified">!                       FloatRegisterImpl::save_slots_per_register * FloatRegisterImpl::number_of_registers;</span>
        oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset + additional_frame_slots),
                                  r-&gt;as_VMReg());
      }
    }
  
    for (int i = 0; i &lt; FloatRegisterImpl::number_of_registers; i++) {
      FloatRegister r = as_FloatRegister(i);
<span class="line-modified">!     int sp_offset = save_vectors ? (FloatRegisterImpl::max_slots_per_register * i) :</span>
<span class="line-added">+                                    (FloatRegisterImpl::save_slots_per_register * i);</span>
      oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
                                r-&gt;as_VMReg());
    }
  
    return oop_map;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,11 ***</span>
  #endif
  
    __ mov(c_rarg0, rmethod);
    __ mov(c_rarg1, lr);
    __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
<span class="line-modified">!   __ blrt(rscratch1, 2, 0, 0);</span>
    __ maybe_isb();
  
    __ pop_CPU_state();
    // restore sp
    __ leave();
<span class="line-new-header">--- 340,11 ---</span>
  #endif
  
    __ mov(c_rarg0, rmethod);
    __ mov(c_rarg1, lr);
    __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
<span class="line-modified">!   __ blr(rscratch1);</span>
    __ maybe_isb();
  
    __ pop_CPU_state();
    // restore sp
    __ leave();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 661,97 ***</span>
    __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));
  
    __ br(rscratch1);
  }
  
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">- static void generate_i2c_adapter_name(char *result, int total_args_passed, const BasicType *sig_bt)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   strcpy(result, &quot;i2c(&quot;);</span>
<span class="line-removed">-   int idx = 4;</span>
<span class="line-removed">-   for (int i = 0; i &lt; total_args_passed; i++) {</span>
<span class="line-removed">-     switch(sig_bt[i]) {</span>
<span class="line-removed">-     case T_BOOLEAN:</span>
<span class="line-removed">-       result[idx++] = &#39;Z&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_CHAR:</span>
<span class="line-removed">-       result[idx++] = &#39;C&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_FLOAT:</span>
<span class="line-removed">-       result[idx++] = &#39;F&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_DOUBLE:</span>
<span class="line-removed">-       assert((i &lt; (total_args_passed - 1)) &amp;&amp; (sig_bt[i+1] == T_VOID),</span>
<span class="line-removed">-              &quot;double must be followed by void&quot;);</span>
<span class="line-removed">-       i++;</span>
<span class="line-removed">-       result[idx++] = &#39;D&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_BYTE:</span>
<span class="line-removed">-       result[idx++] = &#39;B&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_SHORT:</span>
<span class="line-removed">-       result[idx++] = &#39;S&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_INT:</span>
<span class="line-removed">-       result[idx++] = &#39;I&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_LONG:</span>
<span class="line-removed">-       assert((i &lt; (total_args_passed - 1)) &amp;&amp; (sig_bt[i+1] == T_VOID),</span>
<span class="line-removed">-              &quot;long must be followed by void&quot;);</span>
<span class="line-removed">-       i++;</span>
<span class="line-removed">-       result[idx++] = &#39;L&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_OBJECT:</span>
<span class="line-removed">-       result[idx++] = &#39;O&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_ARRAY:</span>
<span class="line-removed">-       result[idx++] = &#39;[&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_ADDRESS:</span>
<span class="line-removed">-       result[idx++] = &#39;P&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_NARROWOOP:</span>
<span class="line-removed">-       result[idx++] = &#39;N&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_METADATA:</span>
<span class="line-removed">-       result[idx++] = &#39;M&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case T_NARROWKLASS:</span>
<span class="line-removed">-       result[idx++] = &#39;K&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-       result[idx++] = &#39;?&#39;;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   result[idx++] = &#39;)&#39;;</span>
<span class="line-removed">-   result[idx] = &#39;\0&#39;;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  // ---------------------------------------------------------------
  AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
                                                              int total_args_passed,
                                                              int comp_args_on_stack,
                                                              const BasicType *sig_bt,
                                                              const VMRegPair *regs,
                                                              AdapterFingerPrint* fingerprint) {
    address i2c_entry = __ pc();
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   char *name = NULL;</span>
<span class="line-removed">-   AArch64Simulator *sim = NULL;</span>
<span class="line-removed">-   size_t len = 65536;</span>
<span class="line-removed">-   if (NotifySimulator) {</span>
<span class="line-removed">-     name = NEW_C_HEAP_ARRAY(char, len, mtInternal);</span>
<span class="line-removed">-   }</span>
  
<span class="line-removed">-   if (name) {</span>
<span class="line-removed">-     generate_i2c_adapter_name(name, total_args_passed, sig_bt);</span>
<span class="line-removed">-     sim = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed">-     sim-&gt;notifyCompile(name, i2c_entry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
    gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
  
    address c2i_unverified_entry = __ pc();
    Label skip_fixup;
  
<span class="line-new-header">--- 660,19 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 789,23 ***</span>
      __ block_comment(&quot;} c2i_unverified_entry&quot;);
    }
  
    address c2i_entry = __ pc();
  
<span class="line-modified">! #ifdef BUILTIN_SIM</span>
<span class="line-modified">!   if (name) {</span>
<span class="line-modified">!     name[0] = &#39;c&#39;;</span>
<span class="line-modified">!     name[2] = &#39;i&#39;;</span>
<span class="line-modified">!     sim-&gt;notifyCompile(name, c2i_entry);</span>
<span class="line-modified">!     FREE_C_HEAP_ARRAY(char, name, mtInternal);</span>
    }
<span class="line-removed">- #endif</span>
  
    gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
  
    __ flush();
<span class="line-modified">!   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);</span>
  }
  
  int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
                                           VMRegPair *regs,
                                           VMRegPair *regs2,
<span class="line-new-header">--- 710,33 ---</span>
      __ block_comment(&quot;} c2i_unverified_entry&quot;);
    }
  
    address c2i_entry = __ pc();
  
<span class="line-modified">!   // Class initialization barrier for static methods</span>
<span class="line-modified">!   address c2i_no_clinit_check_entry = NULL;</span>
<span class="line-modified">!   if (VM_Version::supports_fast_class_init_checks()) {</span>
<span class="line-modified">!     Label L_skip_barrier;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     { // Bypass the barrier for non-static methods</span>
<span class="line-added">+       __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));</span>
<span class="line-added">+       __ andsw(zr, rscratch1, JVM_ACC_STATIC);</span>
<span class="line-added">+       __ br(Assembler::EQ, L_skip_barrier); // non-static</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ load_method_holder(rscratch2, rmethod);</span>
<span class="line-added">+     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);</span>
<span class="line-added">+     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ bind(L_skip_barrier);</span>
<span class="line-added">+     c2i_no_clinit_check_entry = __ pc();</span>
    }
  
    gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
  
    __ flush();
<span class="line-modified">!   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>
  }
  
  int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
                                           VMRegPair *regs,
                                           VMRegPair *regs2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1199,12 ***</span>
      __ far_call(RuntimeAddress(dest));
    } else {
      assert((unsigned)gpargs &lt; 256, &quot;eek!&quot;);
      assert((unsigned)fpargs &lt; 32, &quot;eek!&quot;);
      __ lea(rscratch1, RuntimeAddress(dest));
<span class="line-modified">!     if (UseBuiltinSim)   __ mov(rscratch2, (gpargs &lt;&lt; 6) | (fpargs &lt;&lt; 2) | type);</span>
<span class="line-removed">-     __ blrt(rscratch1, rscratch2);</span>
      __ maybe_isb();
    }
  }
  
  static void verify_oop_args(MacroAssembler* masm,
<span class="line-new-header">--- 1130,11 ---</span>
      __ far_call(RuntimeAddress(dest));
    } else {
      assert((unsigned)gpargs &lt; 256, &quot;eek!&quot;);
      assert((unsigned)fpargs &lt; 32, &quot;eek!&quot;);
      __ lea(rscratch1, RuntimeAddress(dest));
<span class="line-modified">!     __ blr(rscratch1);</span>
      __ maybe_isb();
    }
  }
  
  static void verify_oop_args(MacroAssembler* masm,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1320,29 ***</span>
  nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
                                                  const methodHandle&amp; method,
                                                  int compile_id,
                                                  BasicType* in_sig_bt,
                                                  VMRegPair* in_regs,
<span class="line-modified">!                                                 BasicType ret_type) {</span>
<span class="line-modified">! #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   if (NotifySimulator) {</span>
<span class="line-removed">-     // Names are up to 65536 chars long.  UTF8-coded strings are up to</span>
<span class="line-removed">-     // 3 bytes per character.  We concatenate three such strings.</span>
<span class="line-removed">-     // Yes, I know this is ridiculous, but it&#39;s debug code and glibc</span>
<span class="line-removed">-     // allocates large arrays very efficiently.</span>
<span class="line-removed">-     size_t len = (65536 * 3) * 3;</span>
<span class="line-removed">-     char *name = new char[len];</span>
<span class="line-removed">- </span>
<span class="line-removed">-     strncpy(name, method()-&gt;method_holder()-&gt;name()-&gt;as_utf8(), len);</span>
<span class="line-removed">-     strncat(name, &quot;.&quot;, len);</span>
<span class="line-removed">-     strncat(name, method()-&gt;name()-&gt;as_utf8(), len);</span>
<span class="line-removed">-     strncat(name, method()-&gt;signature()-&gt;as_utf8(), len);</span>
<span class="line-removed">-     AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck)-&gt;notifyCompile(name, __ pc());</span>
<span class="line-removed">-     delete[] name;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
    if (method-&gt;is_method_handle_intrinsic()) {
      vmIntrinsics::ID iid = method-&gt;intrinsic_id();
      intptr_t start = (intptr_t)__ pc();
      int vep_offset = ((intptr_t)__ pc()) - start;
  
<span class="line-new-header">--- 1250,12 ---</span>
  nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
                                                  const methodHandle&amp; method,
                                                  int compile_id,
                                                  BasicType* in_sig_bt,
                                                  VMRegPair* in_regs,
<span class="line-modified">!                                                 BasicType ret_type,</span>
<span class="line-modified">!                                                 address critical_entry) {</span>
    if (method-&gt;is_method_handle_intrinsic()) {
      vmIntrinsics::ID iid = method-&gt;intrinsic_id();
      intptr_t start = (intptr_t)__ pc();
      int vep_offset = ((intptr_t)__ pc()) - start;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1364,11 ***</span>
                                         in_ByteSize(-1),
                                         in_ByteSize(-1),
                                         (OopMapSet*)NULL);
    }
    bool is_critical_native = true;
<span class="line-modified">!   address native_func = method-&gt;critical_native_function();</span>
    if (native_func == NULL) {
      native_func = method-&gt;native_function();
      is_critical_native = false;
    }
    assert(native_func != NULL, &quot;must have function&quot;);
<span class="line-new-header">--- 1277,11 ---</span>
                                         in_ByteSize(-1),
                                         in_ByteSize(-1),
                                         (OopMapSet*)NULL);
    }
    bool is_critical_native = true;
<span class="line-modified">!   address native_func = critical_entry;</span>
    if (native_func == NULL) {
      native_func = method-&gt;native_function();
      is_critical_native = false;
    }
    assert(native_func != NULL, &quot;must have function&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1411,40 ***</span>
  
      for (int i = 0; i &lt; total_in_args ; i++ ) {
        out_sig_bt[argc++] = in_sig_bt[i];
      }
    } else {
<span class="line-removed">-     Thread* THREAD = Thread::current();</span>
      in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
      SignatureStream ss(method-&gt;signature());
      for (int i = 0; i &lt; total_in_args ; i++ ) {
        if (in_sig_bt[i] == T_ARRAY) {
          // Arrays are passed as int, elem* pair
          out_sig_bt[argc++] = T_INT;
          out_sig_bt[argc++] = T_ADDRESS;
<span class="line-modified">!         Symbol* atype = ss.as_symbol(CHECK_NULL);</span>
<span class="line-modified">!         const char* at = atype-&gt;as_C_string();</span>
<span class="line-modified">!         if (strlen(at) == 2) {</span>
<span class="line-removed">-           assert(at[0] == &#39;[&#39;, &quot;must be&quot;);</span>
<span class="line-removed">-           switch (at[1]) {</span>
<span class="line-removed">-             case &#39;B&#39;: in_elem_bt[i]  = T_BYTE; break;</span>
<span class="line-removed">-             case &#39;C&#39;: in_elem_bt[i]  = T_CHAR; break;</span>
<span class="line-removed">-             case &#39;D&#39;: in_elem_bt[i]  = T_DOUBLE; break;</span>
<span class="line-removed">-             case &#39;F&#39;: in_elem_bt[i]  = T_FLOAT; break;</span>
<span class="line-removed">-             case &#39;I&#39;: in_elem_bt[i]  = T_INT; break;</span>
<span class="line-removed">-             case &#39;J&#39;: in_elem_bt[i]  = T_LONG; break;</span>
<span class="line-removed">-             case &#39;S&#39;: in_elem_bt[i]  = T_SHORT; break;</span>
<span class="line-removed">-             case &#39;Z&#39;: in_elem_bt[i]  = T_BOOLEAN; break;</span>
<span class="line-removed">-             default: ShouldNotReachHere();</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         }</span>
        } else {
          out_sig_bt[argc++] = in_sig_bt[i];
          in_elem_bt[i] = T_VOID;
        }
        if (in_sig_bt[i] != T_VOID) {
<span class="line-modified">!         assert(in_sig_bt[i] == ss.type(), &quot;must match&quot;);</span>
          ss.next();
        }
      }
    }
  
<span class="line-new-header">--- 1324,27 ---</span>
  
      for (int i = 0; i &lt; total_in_args ; i++ ) {
        out_sig_bt[argc++] = in_sig_bt[i];
      }
    } else {
      in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
      SignatureStream ss(method-&gt;signature());
      for (int i = 0; i &lt; total_in_args ; i++ ) {
        if (in_sig_bt[i] == T_ARRAY) {
          // Arrays are passed as int, elem* pair
          out_sig_bt[argc++] = T_INT;
          out_sig_bt[argc++] = T_ADDRESS;
<span class="line-modified">!         ss.skip_array_prefix(1);  // skip one &#39;[&#39;</span>
<span class="line-modified">!         assert(ss.is_primitive(), &quot;primitive type expected&quot;);</span>
<span class="line-modified">!         in_elem_bt[i] = ss.type();</span>
        } else {
          out_sig_bt[argc++] = in_sig_bt[i];
          in_elem_bt[i] = T_VOID;
        }
        if (in_sig_bt[i] != T_VOID) {
<span class="line-modified">!         assert(in_sig_bt[i] == ss.type() ||</span>
<span class="line-added">+                in_sig_bt[i] == T_ARRAY, &quot;must match&quot;);</span>
          ss.next();
        }
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1580,10 ***</span>
<span class="line-new-header">--- 1480,19 ---</span>
    // first instruction with a jump.  For this action to be legal we
    // must ensure that this first instruction is a B, BL, NOP, BKPT,
    // SVC, HVC, or SMC.  Make it a NOP.
    __ nop();
  
<span class="line-added">+   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {</span>
<span class="line-added">+     Label L_skip_barrier;</span>
<span class="line-added">+     __ mov_metadata(rscratch2, method-&gt;method_holder()); // InstanceKlass*</span>
<span class="line-added">+     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);</span>
<span class="line-added">+     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ bind(L_skip_barrier);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Generate stack overflow check
    if (UseStackBanging) {
      __ bang_stack_with_offset(JavaThread::stack_shadow_zone_size());
    } else {
      Unimplemented();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1595,15 ***</span>
    __ sub(sp, sp, stack_size - 2*wordSize);
  
    // Frame is now completed as far as size and linkage.
    int frame_complete = ((intptr_t)__ pc()) - start;
  
<span class="line-removed">-   // record entry into native wrapper code</span>
<span class="line-removed">-   if (NotifySimulator) {</span>
<span class="line-removed">-     __ notify(Assembler::method_entry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    // We use r20 as the oop handle for the receiver/klass
    // It is callee save so it survives the call to native
  
    const Register oop_handle_reg = r20;
  
<span class="line-new-header">--- 1504,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2038,11 ***</span>
    }
  
    __ reset_last_Java_frame(false);
  
    // Unbox oop result, e.g. JNIHandles::resolve result.
<span class="line-modified">!   if (ret_type == T_OBJECT || ret_type == T_ARRAY) {</span>
      __ resolve_jobject(r0, rthread, rscratch2);
    }
  
    if (CheckJNICalls) {
      // clear_pending_jni_exception_check
<span class="line-new-header">--- 1942,11 ---</span>
    }
  
    __ reset_last_Java_frame(false);
  
    // Unbox oop result, e.g. JNIHandles::resolve result.
<span class="line-modified">!   if (is_reference_type(ret_type)) {</span>
      __ resolve_jobject(r0, rthread, rscratch2);
    }
  
    if (CheckJNICalls) {
      // clear_pending_jni_exception_check
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2061,15 ***</span>
      // Any exception pending?
      __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
      __ cbnz(rscratch1, exception_pending);
    }
  
<span class="line-removed">-   // record exit from native wrapper code</span>
<span class="line-removed">-   if (NotifySimulator) {</span>
<span class="line-removed">-     __ notify(Assembler::method_reentry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    // We&#39;re done
    __ ret(lr);
  
    // Unexpected paths are out of line and go here
  
<span class="line-new-header">--- 1965,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2180,11 ***</span>
      if (!is_critical_native) {
        __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
      } else {
        __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)));
      }
<span class="line-modified">!     __ blrt(rscratch1, 1, 0, 1);</span>
      __ maybe_isb();
      // Restore any method result value
      restore_native_result(masm, ret_type, stack_slots);
  
      if (is_critical_native) {
<span class="line-new-header">--- 2079,11 ---</span>
      if (!is_critical_native) {
        __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
      } else {
        __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)));
      }
<span class="line-modified">!     __ blr(rscratch1);</span>
      __ maybe_isb();
      // Restore any method result value
      restore_native_result(masm, ret_type, stack_slots);
  
      if (is_critical_native) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2277,18 ***</span>
    MacroAssembler* masm = new MacroAssembler(&amp;buffer);
    int frame_size_in_words;
    OopMap* map = NULL;
    OopMapSet *oop_maps = new OopMapSet();
  
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   AArch64Simulator *simulator;</span>
<span class="line-removed">-   if (NotifySimulator) {</span>
<span class="line-removed">-     simulator = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed">-     simulator-&gt;notifyCompile(const_cast&lt;char*&gt;(&quot;SharedRuntime::deopt_blob&quot;), __ pc());</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
    // -------------
    // This code enters when returning to a de-optimized nmethod.  A return
    // address has been pushed on the the stack, and return values are in
    // registers.
    // If we are doing a normal deopt then we were called from the patched
<span class="line-new-header">--- 2176,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2373,11 ***</span>
      __ mov(c_rarg0, rthread);
      __ movw(c_rarg2, rcpool); // exec mode
      __ lea(rscratch1,
             RuntimeAddress(CAST_FROM_FN_PTR(address,
                                             Deoptimization::uncommon_trap)));
<span class="line-modified">!     __ blrt(rscratch1, 2, 0, MacroAssembler::ret_type_integral);</span>
      __ bind(retaddr);
      oop_maps-&gt;add_gc_map( __ pc()-start, map-&gt;deep_copy());
  
      __ reset_last_Java_frame(false);
  
<span class="line-new-header">--- 2264,11 ---</span>
      __ mov(c_rarg0, rthread);
      __ movw(c_rarg2, rcpool); // exec mode
      __ lea(rscratch1,
             RuntimeAddress(CAST_FROM_FN_PTR(address,
                                             Deoptimization::uncommon_trap)));
<span class="line-modified">!     __ blr(rscratch1);</span>
      __ bind(retaddr);
      oop_maps-&gt;add_gc_map( __ pc()-start, map-&gt;deep_copy());
  
      __ reset_last_Java_frame(false);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2465,11 ***</span>
    }
  #endif // ASSERT
    __ mov(c_rarg0, rthread);
    __ mov(c_rarg1, rcpool);
    __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)));
<span class="line-modified">!   __ blrt(rscratch1, 1, 0, 1);</span>
    __ bind(retaddr);
  
    // Need to have an oopmap that tells fetch_unroll_info where to
    // find any register it might need.
    oop_maps-&gt;add_gc_map(__ pc() - start, map);
<span class="line-new-header">--- 2356,11 ---</span>
    }
  #endif // ASSERT
    __ mov(c_rarg0, rthread);
    __ mov(c_rarg1, rcpool);
    __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)));
<span class="line-modified">!   __ blr(rscratch1);</span>
    __ bind(retaddr);
  
    // Need to have an oopmap that tells fetch_unroll_info where to
    // find any register it might need.
    oop_maps-&gt;add_gc_map(__ pc() - start, map);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2605,11 ***</span>
    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
  
    __ mov(c_rarg0, rthread);
    __ movw(c_rarg1, rcpool); // second arg: exec_mode
    __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
<span class="line-modified">!   __ blrt(rscratch1, 2, 0, 0);</span>
  
    // Set an oopmap for the call site
    // Use the same PC we used for the last java frame
    oop_maps-&gt;add_gc_map(the_pc - start,
                         new OopMap( frame_size_in_words, 0 ));
<span class="line-new-header">--- 2496,11 ---</span>
    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
  
    __ mov(c_rarg0, rthread);
    __ movw(c_rarg1, rcpool); // second arg: exec_mode
    __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
<span class="line-modified">!   __ blr(rscratch1);</span>
  
    // Set an oopmap for the call site
    // Use the same PC we used for the last java frame
    oop_maps-&gt;add_gc_map(the_pc - start,
                         new OopMap( frame_size_in_words, 0 ));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2638,16 ***</span>
    if (EnableJVMCI || UseAOT) {
      _deopt_blob-&gt;set_uncommon_trap_offset(uncommon_trap_offset);
      _deopt_blob-&gt;set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);
    }
  #endif
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   if (NotifySimulator) {</span>
<span class="line-removed">-     unsigned char *base = _deopt_blob-&gt;code_begin();</span>
<span class="line-removed">-     simulator-&gt;notifyRelocate(start, base - start);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
  }
  
  uint SharedRuntime::out_preserve_stack_slots() {
    return 0;
  }
<span class="line-new-header">--- 2529,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2659,18 ***</span>
    ResourceMark rm;
    // Setup code generation tools
    CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
    MacroAssembler* masm = new MacroAssembler(&amp;buffer);
  
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   AArch64Simulator *simulator;</span>
<span class="line-removed">-   if (NotifySimulator) {</span>
<span class="line-removed">-     simulator = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed">-     simulator-&gt;notifyCompile(const_cast&lt;char*&gt;(&quot;SharedRuntime:uncommon_trap_blob&quot;), __ pc());</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
    assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
  
    address start = __ pc();
  
    // Push self-frame.  We get here with a return address in LR
<span class="line-new-header">--- 2544,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2705,11 ***</span>
    __ mov(c_rarg0, rthread);
    __ movw(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);
    __ lea(rscratch1,
           RuntimeAddress(CAST_FROM_FN_PTR(address,
                                           Deoptimization::uncommon_trap)));
<span class="line-modified">!   __ blrt(rscratch1, 2, 0, MacroAssembler::ret_type_integral);</span>
    __ bind(retaddr);
  
    // Set an oopmap for the call site
    OopMapSet* oop_maps = new OopMapSet();
    OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);
<span class="line-new-header">--- 2582,11 ---</span>
    __ mov(c_rarg0, rthread);
    __ movw(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);
    __ lea(rscratch1,
           RuntimeAddress(CAST_FROM_FN_PTR(address,
                                           Deoptimization::uncommon_trap)));
<span class="line-modified">!   __ blr(rscratch1);</span>
    __ bind(retaddr);
  
    // Set an oopmap for the call site
    OopMapSet* oop_maps = new OopMapSet();
    OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2828,11 ***</span>
  
    // sp should already be aligned
    __ mov(c_rarg0, rthread);
    __ movw(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);
    __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
<span class="line-modified">!   __ blrt(rscratch1, 2, 0, MacroAssembler::ret_type_integral);</span>
  
    // Set an oopmap for the call site
    // Use the same PC we used for the last java frame
    oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
  
<span class="line-new-header">--- 2705,11 ---</span>
  
    // sp should already be aligned
    __ mov(c_rarg0, rthread);
    __ movw(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);
    __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
<span class="line-modified">!   __ blr(rscratch1);</span>
  
    // Set an oopmap for the call site
    // Use the same PC we used for the last java frame
    oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2848,17 ***</span>
    // Make sure all code is generated
    masm-&gt;flush();
  
    _uncommon_trap_blob =  UncommonTrapBlob::create(&amp;buffer, oop_maps,
                                                   SimpleRuntimeFrame::framesize &gt;&gt; 1);
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   if (NotifySimulator) {</span>
<span class="line-removed">-     unsigned char *base = _deopt_blob-&gt;code_begin();</span>
<span class="line-removed">-     simulator-&gt;notifyRelocate(start, base - start);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
  }
  #endif // COMPILER2_OR_JVMCI
  
  
  //------------------------------generate_handler_blob------
<span class="line-new-header">--- 2725,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2879,11 ***</span>
    address call_pc = NULL;
    int frame_size_in_words;
    bool cause_return = (poll_type == POLL_AT_RETURN);
    bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
  
<span class="line-modified">!   // Save registers, fpu state, and flags</span>
    map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words, save_vectors);
  
    // The following is basically a call_VM.  However, we need the precise
    // address of the call in order to generate an oopmap. Hence, we do all the
    // work outselves.
<span class="line-new-header">--- 2749,11 ---</span>
    address call_pc = NULL;
    int frame_size_in_words;
    bool cause_return = (poll_type == POLL_AT_RETURN);
    bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
  
<span class="line-modified">!   // Save Integer and Float registers.</span>
    map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words, save_vectors);
  
    // The following is basically a call_VM.  However, we need the precise
    // address of the call in order to generate an oopmap. Hence, we do all the
    // work outselves.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2904,11 ***</span>
    }
  
    // Do the call
    __ mov(c_rarg0, rthread);
    __ lea(rscratch1, RuntimeAddress(call_ptr));
<span class="line-modified">!   __ blrt(rscratch1, 1, 0, 1);</span>
    __ bind(retaddr);
  
    // Set an oopmap for the call site.  This oopmap will map all
    // oop-registers and debug-info registers as callee-saved.  This
    // will allow deoptimization at this safepoint to find all possible
<span class="line-new-header">--- 2774,11 ---</span>
    }
  
    // Do the call
    __ mov(c_rarg0, rthread);
    __ lea(rscratch1, RuntimeAddress(call_ptr));
<span class="line-modified">!   __ blr(rscratch1);</span>
    __ bind(retaddr);
  
    // Set an oopmap for the call site.  This oopmap will map all
    // oop-registers and debug-info registers as callee-saved.  This
    // will allow deoptimization at this safepoint to find all possible
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3009,11 ***</span>
      __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
  
      __ mov(c_rarg0, rthread);
      __ lea(rscratch1, RuntimeAddress(destination));
  
<span class="line-modified">!     __ blrt(rscratch1, 1, 0, 1);</span>
      __ bind(retaddr);
    }
  
    // Set an oopmap for the call site.
    // We need this not only for callee-saved registers, but also for volatile
<span class="line-new-header">--- 2879,11 ---</span>
      __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
  
      __ mov(c_rarg0, rthread);
      __ lea(rscratch1, RuntimeAddress(destination));
  
<span class="line-modified">!     __ blr(rscratch1);</span>
      __ bind(retaddr);
    }
  
    // Set an oopmap for the call site.
    // We need this not only for callee-saved registers, but also for volatile
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3141,11 ***</span>
    // the stack should always be aligned
    address the_pc = __ pc();
    __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);
    __ mov(c_rarg0, rthread);
    __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));
<span class="line-modified">!   __ blrt(rscratch1, 1, 0, MacroAssembler::ret_type_integral);</span>
    __ maybe_isb();
  
    // Set an oopmap for the call site.  This oopmap will only be used if we
    // are unwinding the stack.  Hence, all locations will be dead.
    // Callee-saved registers will be the same as the frame above (i.e.,
<span class="line-new-header">--- 3011,11 ---</span>
    // the stack should always be aligned
    address the_pc = __ pc();
    __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);
    __ mov(c_rarg0, rthread);
    __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));
<span class="line-modified">!   __ blr(rscratch1);</span>
    __ maybe_isb();
  
    // Set an oopmap for the call site.  This oopmap will only be used if we
    // are unwinding the stack.  Hence, all locations will be dead.
    // Callee-saved registers will be the same as the frame above (i.e.,
</pre>
<center><a href="register_aarch64.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
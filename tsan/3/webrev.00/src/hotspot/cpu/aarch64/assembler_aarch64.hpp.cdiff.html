<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/assembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_FrameMap_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/assembler_aarch64.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">!  * Copyright (c) 2014, 2015, Red Hat Inc. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">!  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 274,11 ***</span>
    }
  
    unsigned get(int msb = 31, int lsb = 0) {
      int nbits = msb - lsb + 1;
      unsigned mask = ((1U &lt;&lt; nbits) - 1) &lt;&lt; lsb;
<span class="line-modified">!     assert_cond(bits &amp; mask == mask);</span>
      return (insn &amp; mask) &gt;&gt; lsb;
    }
  
    void fixed(unsigned value, unsigned mask) {
      assert_cond ((mask &amp; bits) == 0);
<span class="line-new-header">--- 274,11 ---</span>
    }
  
    unsigned get(int msb = 31, int lsb = 0) {
      int nbits = msb - lsb + 1;
      unsigned mask = ((1U &lt;&lt; nbits) - 1) &lt;&lt; lsb;
<span class="line-modified">!     assert_cond((bits &amp; mask) == mask);</span>
      return (insn &amp; mask) &gt;&gt; lsb;
    }
  
    void fixed(unsigned value, unsigned mask) {
      assert_cond ((mask &amp; bits) == 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,14 ***</span>
  public:
    Pre(Register reg, int o) : PrePost(reg, o) { }
  };
  class Post : public PrePost {
    Register _idx;
  public:
<span class="line-modified">!   Post(Register reg, int o) : PrePost(reg, o) { _idx = NULL; }</span>
<span class="line-modified">!   Post(Register reg, Register idx) : PrePost(reg, 0) { _idx = idx; }</span>
    Register idx_reg() { return _idx; }
  };
  
  namespace ext
  {
    enum operation { uxtb, uxth, uxtw, uxtx, sxtb, sxth, sxtw, sxtx };
<span class="line-new-header">--- 304,16 ---</span>
  public:
    Pre(Register reg, int o) : PrePost(reg, o) { }
  };
  class Post : public PrePost {
    Register _idx;
<span class="line-added">+   bool _is_postreg;</span>
  public:
<span class="line-modified">!   Post(Register reg, int o) : PrePost(reg, o) { _idx = NULL; _is_postreg = false; }</span>
<span class="line-modified">!   Post(Register reg, Register idx) : PrePost(reg, 0) { _idx = idx; _is_postreg = true; }</span>
    Register idx_reg() { return _idx; }
<span class="line-added">+   bool is_postreg() {return _is_postreg; }</span>
  };
  
  namespace ext
  {
    enum operation { uxtb, uxth, uxtw, uxtx, sxtb, sxth, sxtw, sxtx };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 391,11 ***</span>
        _ext(ext), _target(0) { }
    Address(Pre p)
      : _base(p.reg()), _offset(p.offset()), _mode(pre) { }
    Address(Post p)
      : _base(p.reg()),  _index(p.idx_reg()), _offset(p.offset()),
<span class="line-modified">!       _mode(p.idx_reg() == NULL ? post : post_reg), _target(0) { }</span>
    Address(address target, RelocationHolder const&amp; rspec)
      : _mode(literal),
        _rspec(rspec),
        _is_lval(false),
        _target(target)  { }
<span class="line-new-header">--- 393,11 ---</span>
        _ext(ext), _target(0) { }
    Address(Pre p)
      : _base(p.reg()), _offset(p.offset()), _mode(pre) { }
    Address(Post p)
      : _base(p.reg()),  _index(p.idx_reg()), _offset(p.offset()),
<span class="line-modified">!       _mode(p.is_postreg() ? post_reg : post), _target(0) { }</span>
    Address(address target, RelocationHolder const&amp; rspec)
      : _mode(literal),
        _rspec(rspec),
        _is_lval(false),
        _target(target)  { }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 550,11 ***</span>
                &quot;Bad addressing mode for non-temporal op&quot;);
    }
  
    void lea(MacroAssembler *, Register) const;
  
<span class="line-modified">!   static bool offset_ok_for_immed(long offset, int shift = 0) {</span>
      unsigned mask = (1 &lt;&lt; shift) - 1;
      if (offset &lt; 0 || offset &amp; mask) {
        return (uabs(offset) &lt; (1 &lt;&lt; (20 - 12))); // Unscaled offset
      } else {
        return ((offset &gt;&gt; shift) &lt; (1 &lt;&lt; (21 - 10 + 1))); // Scaled, unsigned offset
<span class="line-new-header">--- 552,11 ---</span>
                &quot;Bad addressing mode for non-temporal op&quot;);
    }
  
    void lea(MacroAssembler *, Register) const;
  
<span class="line-modified">!   static bool offset_ok_for_immed(long offset, int shift) {</span>
      unsigned mask = (1 &lt;&lt; shift) - 1;
      if (offset &lt; 0 || offset &amp; mask) {
        return (uabs(offset) &lt; (1 &lt;&lt; (20 - 12))); // Unscaled offset
      } else {
        return ((offset &gt;&gt; shift) &lt; (1 &lt;&lt; (21 - 10 + 1))); // Scaled, unsigned offset
</pre>
<hr />
<pre>
<span class="line-old-header">*** 600,11 ***</span>
    public:
  
    InternalAddress(address target) : Address(target, relocInfo::internal_word_type) {}
  };
  
<span class="line-modified">! const int FPUStateSizeInWords = 32 * 2;</span>
  typedef enum {
    PLDL1KEEP = 0b00000, PLDL1STRM, PLDL2KEEP, PLDL2STRM, PLDL3KEEP, PLDL3STRM,
    PSTL1KEEP = 0b10000, PSTL1STRM, PSTL2KEEP, PSTL2STRM, PSTL3KEEP, PSTL3STRM,
    PLIL1KEEP = 0b01000, PLIL1STRM, PLIL2KEEP, PLIL2STRM, PLIL3KEEP, PLIL3STRM
  } prfop;
<span class="line-new-header">--- 602,13 ---</span>
    public:
  
    InternalAddress(address target) : Address(target, relocInfo::internal_word_type) {}
  };
  
<span class="line-modified">! const int FPUStateSizeInWords = FloatRegisterImpl::number_of_registers *</span>
<span class="line-added">+                                 FloatRegisterImpl::save_slots_per_register;</span>
<span class="line-added">+ </span>
  typedef enum {
    PLDL1KEEP = 0b00000, PLDL1STRM, PLDL2KEEP, PLDL2STRM, PLDL3KEEP, PLDL3STRM,
    PSTL1KEEP = 0b10000, PSTL1STRM, PSTL2KEEP, PSTL2STRM, PSTL3KEEP, PSTL3STRM,
    PLIL1KEEP = 0b01000, PLIL1STRM, PLIL2KEEP, PLIL2STRM, PLIL3KEEP, PLIL3STRM
  } prfop;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 627,10 ***</span>
<span class="line-new-header">--- 631,18 ---</span>
  
  public:
  
    enum { instruction_size = 4 };
  
<span class="line-added">+   //---&lt;  calculate length of instruction  &gt;---</span>
<span class="line-added">+   // We just use the values set above.</span>
<span class="line-added">+   // instruction must start at passed address</span>
<span class="line-added">+   static unsigned int instr_len(unsigned char *instr) { return instruction_size; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   //---&lt;  longest instructions  &gt;---</span>
<span class="line-added">+   static unsigned int instr_maxlen() { return instruction_size; }</span>
<span class="line-added">+ </span>
    Address adjust(Register base, int offset, bool preIncrement) {
      if (preIncrement)
        return Address(Pre(base, offset));
      else
        return Address(Post(base, offset));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 797,36 ***</span>
    INSN(movk, 0b111);
  
  #undef INSN
  
    // Bitfield
<span class="line-modified">! #define INSN(NAME, opcode)                                              \</span>
    void NAME(Register Rd, Register Rn, unsigned immr, unsigned imms) {   \
      starti;                                                             \
      f(opcode, 31, 22), f(immr, 21, 16), f(imms, 15, 10);                \
      zrf(Rn, 5), rf(Rd, 0);                                              \
    }
  
<span class="line-modified">!   INSN(sbfmw, 0b0001001100);</span>
<span class="line-modified">!   INSN(bfmw,  0b0011001100);</span>
<span class="line-modified">!   INSN(ubfmw, 0b0101001100);</span>
<span class="line-modified">!   INSN(sbfm,  0b1001001101);</span>
<span class="line-modified">!   INSN(bfm,   0b1011001101);</span>
<span class="line-modified">!   INSN(ubfm,  0b1101001101);</span>
  
  #undef INSN
  
    // Extract
<span class="line-modified">! #define INSN(NAME, opcode)                                              \</span>
    void NAME(Register Rd, Register Rn, Register Rm, unsigned imms) {     \
      starti;                                                             \
      f(opcode, 31, 21), f(imms, 15, 10);                                 \
<span class="line-modified">!     rf(Rm, 16), rf(Rn, 5), rf(Rd, 0);                                   \</span>
    }
  
<span class="line-modified">!   INSN(extrw, 0b00010011100);</span>
<span class="line-modified">!   INSN(extr,  0b10010011110);</span>
  
  #undef INSN
  
    // The maximum range of a branch is fixed for the AArch64
    // architecture.  In debug mode we shrink it in order to test
<span class="line-new-header">--- 809,38 ---</span>
    INSN(movk, 0b111);
  
  #undef INSN
  
    // Bitfield
<span class="line-modified">! #define INSN(NAME, opcode, size)                                        \</span>
    void NAME(Register Rd, Register Rn, unsigned immr, unsigned imms) {   \
      starti;                                                             \
<span class="line-added">+     guarantee(size == 1 || (immr &lt; 32 &amp;&amp; imms &lt; 32), &quot;incorrect immr/imms&quot;);\</span>
      f(opcode, 31, 22), f(immr, 21, 16), f(imms, 15, 10);                \
      zrf(Rn, 5), rf(Rd, 0);                                              \
    }
  
<span class="line-modified">!   INSN(sbfmw, 0b0001001100, 0);</span>
<span class="line-modified">!   INSN(bfmw,  0b0011001100, 0);</span>
<span class="line-modified">!   INSN(ubfmw, 0b0101001100, 0);</span>
<span class="line-modified">!   INSN(sbfm,  0b1001001101, 1);</span>
<span class="line-modified">!   INSN(bfm,   0b1011001101, 1);</span>
<span class="line-modified">!   INSN(ubfm,  0b1101001101, 1);</span>
  
  #undef INSN
  
    // Extract
<span class="line-modified">! #define INSN(NAME, opcode, size)                                        \</span>
    void NAME(Register Rd, Register Rn, Register Rm, unsigned imms) {     \
      starti;                                                             \
<span class="line-added">+     guarantee(size == 1 || imms &lt; 32, &quot;incorrect imms&quot;);                \</span>
      f(opcode, 31, 21), f(imms, 15, 10);                                 \
<span class="line-modified">!     zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                                \</span>
    }
  
<span class="line-modified">!   INSN(extrw, 0b00010011100, 0);</span>
<span class="line-modified">!   INSN(extr,  0b10010011110, 1);</span>
  
  #undef INSN
  
    // The maximum range of a branch is fixed for the AArch64
    // architecture.  In debug mode we shrink it in order to test
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1044,16 ***</span>
  
    // Only implement operations accessible from EL0 or higher, i.e.,
    //            op1    CRn    CRm    op2
    // IC IVAU     3      7      5      1
    // DC CVAC     3      7      10     1
    // DC CVAU     3      7      11     1
    // DC CIVAC    3      7      14     1
    // DC ZVA      3      7      4      1
    // So only deal with the CRm field.
    enum icache_maintenance {IVAU = 0b0101};
<span class="line-modified">!   enum dcache_maintenance {CVAC = 0b1010, CVAU = 0b1011, CIVAC = 0b1110, ZVA = 0b100};</span>
  
    void dc(dcache_maintenance cm, Register Rt) {
      sys(0b011, 0b0111, cm, 0b001, Rt);
    }
  
<span class="line-new-header">--- 1058,17 ---</span>
  
    // Only implement operations accessible from EL0 or higher, i.e.,
    //            op1    CRn    CRm    op2
    // IC IVAU     3      7      5      1
    // DC CVAC     3      7      10     1
<span class="line-added">+   // DC CVAP     3      7      12     1</span>
    // DC CVAU     3      7      11     1
    // DC CIVAC    3      7      14     1
    // DC ZVA      3      7      4      1
    // So only deal with the CRm field.
    enum icache_maintenance {IVAU = 0b0101};
<span class="line-modified">!   enum dcache_maintenance {CVAC = 0b1010, CVAP = 0b1100, CVAU = 0b1011, CIVAC = 0b1110, ZVA = 0b100};</span>
  
    void dc(dcache_maintenance cm, Register Rt) {
      sys(0b011, 0b0111, cm, 0b001, Rt);
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1116,11 ***</span>
  
    void load_store_exclusive(Register Rs, Register Rt1, Register Rt2,
      Register Rn, enum operand_size sz, int op, bool ordered) {
      starti;
      f(sz, 31, 30), f(0b001000, 29, 24), f(op, 23, 21);
<span class="line-modified">!     rf(Rs, 16), f(ordered, 15), rf(Rt2, 10), srf(Rn, 5), zrf(Rt1, 0);</span>
    }
  
    void load_exclusive(Register dst, Register addr,
                        enum operand_size sz, bool ordered) {
      load_store_exclusive(dummy_reg, dst, dummy_reg, addr,
<span class="line-new-header">--- 1131,11 ---</span>
  
    void load_store_exclusive(Register Rs, Register Rt1, Register Rt2,
      Register Rn, enum operand_size sz, int op, bool ordered) {
      starti;
      f(sz, 31, 30), f(0b001000, 29, 24), f(op, 23, 21);
<span class="line-modified">!     rf(Rs, 16), f(ordered, 15), zrf(Rt2, 10), srf(Rn, 5), zrf(Rt1, 0);</span>
    }
  
    void load_exclusive(Register dst, Register addr,
                        enum operand_size sz, bool ordered) {
      load_store_exclusive(dummy_reg, dst, dummy_reg, addr,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1209,12 ***</span>
      if (! not_pair) { // Pair
        assert(sz == word || sz == xword, &quot;invalid size&quot;);
        /* The size bit is in bit 30, not 31 */
        sz = (operand_size)(sz == word ? 0b00:0b01);
      }
<span class="line-modified">!     f(sz, 31, 30), f(0b001000, 29, 24), f(1, 23), f(a, 22), f(1, 21);</span>
<span class="line-modified">!     rf(Rs, 16), f(r, 15), f(0b11111, 14, 10), rf(Rn, 5), rf(Rt, 0);</span>
    }
  
    // CAS
  #define INSN(NAME, a, r)                                                \
    void NAME(operand_size sz, Register Rs, Register Rt, Register Rn) {   \
<span class="line-new-header">--- 1224,12 ---</span>
      if (! not_pair) { // Pair
        assert(sz == word || sz == xword, &quot;invalid size&quot;);
        /* The size bit is in bit 30, not 31 */
        sz = (operand_size)(sz == word ? 0b00:0b01);
      }
<span class="line-modified">!     f(sz, 31, 30), f(0b001000, 29, 24), f(not_pair ? 1 : 0, 23), f(a, 22), f(1, 21);</span>
<span class="line-modified">!     zrf(Rs, 16), f(r, 15), f(0b11111, 14, 10), srf(Rn, 5), zrf(Rt, 0);</span>
    }
  
    // CAS
  #define INSN(NAME, a, r)                                                \
    void NAME(operand_size sz, Register Rs, Register Rt, Register Rn) {   \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1245,11 ***</span>
    // 8.1 Atomic operations
    void lse_atomic(Register Rs, Register Rt, Register Rn,
                    enum operand_size sz, int op1, int op2, bool a, bool r) {
      starti;
      f(sz, 31, 30), f(0b111000, 29, 24), f(a, 23), f(r, 22), f(1, 21);
<span class="line-modified">!     rf(Rs, 16), f(op1, 15), f(op2, 14, 12), f(0, 11, 10), srf(Rn, 5), zrf(Rt, 0);</span>
    }
  
  #define INSN(NAME, NAME_A, NAME_L, NAME_AL, op1, op2)                   \
    void NAME(operand_size sz, Register Rs, Register Rt, Register Rn) {   \
      lse_atomic(Rs, Rt, Rn, sz, op1, op2, false, false);                 \
<span class="line-new-header">--- 1260,11 ---</span>
    // 8.1 Atomic operations
    void lse_atomic(Register Rs, Register Rt, Register Rn,
                    enum operand_size sz, int op1, int op2, bool a, bool r) {
      starti;
      f(sz, 31, 30), f(0b111000, 29, 24), f(a, 23), f(r, 22), f(1, 21);
<span class="line-modified">!     zrf(Rs, 16), f(op1, 15), f(op2, 14, 12), f(0, 11, 10), srf(Rn, 5), zrf(Rt, 0);</span>
    }
  
  #define INSN(NAME, NAME_A, NAME_L, NAME_AL, op1, op2)                   \
    void NAME(operand_size sz, Register Rs, Register Rt, Register Rn) {   \
      lse_atomic(Rs, Rt, Rn, sz, op1, op2, false, false);                 \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1467,10 ***</span>
<span class="line-new-header">--- 1482,11 ---</span>
    // Logical (shifted register)
  #define INSN(NAME, size, op, N)                                 \
    void NAME(Register Rd, Register Rn, Register Rm,              \
              enum shift_kind kind = LSL, unsigned shift = 0) {   \
      starti;                                                     \
<span class="line-added">+     guarantee(size == 1 || shift &lt; 32, &quot;incorrect shift&quot;);      \</span>
      f(N, 21);                                                   \
      zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                        \
      op_shifted_reg(0b01010, kind, shift, size, op);             \
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1481,10 ***</span>
<span class="line-new-header">--- 1497,29 ---</span>
    INSN(andw, 0, 0b00, 0);
    INSN(orrw, 0, 0b01, 0);
    INSN(eorw, 0, 0b10, 0);
    INSN(andsw, 0, 0b11, 0);
  
<span class="line-added">+ #undef INSN</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define INSN(NAME, size, op, N)                                         \</span>
<span class="line-added">+   void NAME(Register Rd, Register Rn, Register Rm,                      \</span>
<span class="line-added">+             enum shift_kind kind = LSL, unsigned shift = 0) {           \</span>
<span class="line-added">+     starti;                                                             \</span>
<span class="line-added">+     f(N, 21);                                                           \</span>
<span class="line-added">+     zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                                \</span>
<span class="line-added">+     op_shifted_reg(0b01010, kind, shift, size, op);                     \</span>
<span class="line-added">+   }                                                                     \</span>
<span class="line-added">+                                                                         \</span>
<span class="line-added">+   /* These instructions have no immediate form. Provide an overload so  \</span>
<span class="line-added">+      that if anyone does try to use an immediate operand -- this has    \</span>
<span class="line-added">+      happened! -- we&#39;ll get a compile-time error. */                    \</span>
<span class="line-added">+   void NAME(Register Rd, Register Rn, unsigned imm,                     \</span>
<span class="line-added">+             enum shift_kind kind = LSL, unsigned shift = 0) {           \</span>
<span class="line-added">+     assert(false, &quot; can&#39;t be used with immediate operand&quot;);             \</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    INSN(bic, 1, 0b00, 1);
    INSN(orn, 1, 0b01, 1);
    INSN(eon, 1, 0b10, 1);
    INSN(bics, 1, 0b11, 1);
    INSN(bicw, 0, 0b00, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1510,10 ***</span>
<span class="line-new-header">--- 1545,11 ---</span>
    void NAME(Register Rd, Register Rn, Register Rm,      \
              enum shift_kind kind, unsigned shift = 0) { \
      starti;                                             \
      f(0, 21);                                           \
      assert_cond(kind != ROR);                           \
<span class="line-added">+     guarantee(size == 1 || shift &lt; 32, &quot;incorrect shift&quot;);\</span>
      zrf(Rd, 0), zrf(Rn, 5), zrf(Rm, 16);                \
      op_shifted_reg(0b01011, kind, shift, size, op);     \
    }
  
    INSN(add, 1, 0b000);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1538,11 ***</span>
    }
  
    void add_sub_extended_reg(unsigned op, unsigned decode,
      Register Rd, Register Rn, Register Rm,
      unsigned opt, ext::operation option, unsigned imm) {
<span class="line-modified">!     guarantee(imm &lt;= 4, &quot;shift amount must be &lt; 4&quot;);</span>
      f(op, 31, 29), f(decode, 28, 24), f(opt, 23, 22), f(1, 21);
      f(option, 15, 13), f(imm, 12, 10);
    }
  
    INSN(addw, 0b000);
<span class="line-new-header">--- 1574,11 ---</span>
    }
  
    void add_sub_extended_reg(unsigned op, unsigned decode,
      Register Rd, Register Rn, Register Rm,
      unsigned opt, ext::operation option, unsigned imm) {
<span class="line-modified">!     guarantee(imm &lt;= 4, &quot;shift amount must be &lt;= 4&quot;);</span>
      f(op, 31, 29), f(decode, 28, 24), f(opt, 23, 22), f(1, 21);
      f(option, 15, 13), f(imm, 12, 10);
    }
  
    INSN(addw, 0b000);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1623,11 ***</span>
      f(cond, 15, 12);
      f(o1, 11);
      f(o2, 10);
      f(o3, 4);
      f(nzcv, 3, 0);
<span class="line-modified">!     f(imm5, 20, 16), rf(Rn, 5);</span>
    }
  
  #define INSN(NAME, op)                                                  \
    void NAME(Register Rn, Register Rm, int imm, Condition cond) {        \
      int regNumber = (Rm == zr ? 31 : (uintptr_t)Rm);                    \
<span class="line-new-header">--- 1659,11 ---</span>
      f(cond, 15, 12);
      f(o1, 11);
      f(o2, 10);
      f(o3, 4);
      f(nzcv, 3, 0);
<span class="line-modified">!     f(imm5, 20, 16), zrf(Rn, 5);</span>
    }
  
  #define INSN(NAME, op)                                                  \
    void NAME(Register Rn, Register Rm, int imm, Condition cond) {        \
      int regNumber = (Rm == zr ? 31 : (uintptr_t)Rm);                    \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2092,11 ***</span>
      f(op1, 29, 21), f(0, 20, 16), f(op2, 15, 12);
      f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
    }
    void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn,
               int imm, int op1, int op2, int regs) {
<span class="line-modified">!     guarantee(T &lt;= T1Q &amp;&amp; imm == SIMD_Size_in_bytes[T] * regs, &quot;bad offset&quot;);</span>
      starti;
      f(0,31), f((int)T &amp; 1, 30);
      f(op1 | 0b100, 29, 21), f(0b11111, 20, 16), f(op2, 15, 12);
      f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
    }
<span class="line-new-header">--- 2128,16 ---</span>
      f(op1, 29, 21), f(0, 20, 16), f(op2, 15, 12);
      f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
    }
    void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn,
               int imm, int op1, int op2, int regs) {
<span class="line-modified">! </span>
<span class="line-added">+     bool replicate = op2 &gt;&gt; 2 == 3;</span>
<span class="line-added">+     // post-index value (imm) is formed differently for replicate/non-replicate ld* instructions</span>
<span class="line-added">+     int expectedImmediate = replicate ? regs * (1 &lt;&lt; (T &gt;&gt; 1)) : SIMD_Size_in_bytes[T] * regs;</span>
<span class="line-added">+     guarantee(T &lt; T1Q , &quot;incorrect arrangement&quot;);</span>
<span class="line-added">+     guarantee(imm == expectedImmediate, &quot;bad offset&quot;);</span>
      starti;
      f(0,31), f((int)T &amp; 1, 30);
      f(op1 | 0b100, 29, 21), f(0b11111, 20, 16), f(op2, 15, 12);
      f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2199,46 ***</span>
    INSN(bsl,  0b101110011);
    INSN(orn,  0b001110111);
  
  #undef INSN
  
<span class="line-modified">! #define INSN(NAME, opc, opc2)                                                                 \</span>
    void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
      starti;                                                                             \
      f(0, 31), f((int)T &amp; 1, 30), f(opc, 29), f(0b01110, 28, 24);                        \
      f((int)T &gt;&gt; 1, 23, 22), f(1, 21), rf(Vm, 16), f(opc2, 15, 10);                      \
      rf(Vn, 5), rf(Vd, 0);                                                               \
    }
  
<span class="line-modified">!   INSN(addv,   0, 0b100001);</span>
<span class="line-modified">!   INSN(subv,   1, 0b100001);</span>
<span class="line-modified">!   INSN(mulv,   0, 0b100111);</span>
<span class="line-modified">!   INSN(mlav,   0, 0b100101);</span>
<span class="line-modified">!   INSN(mlsv,   1, 0b100101);</span>
<span class="line-modified">!   INSN(sshl,   0, 0b010001);</span>
<span class="line-modified">!   INSN(ushl,   1, 0b010001);</span>
<span class="line-modified">!   INSN(umullv, 1, 0b110000);</span>
<span class="line-modified">!   INSN(umlalv, 1, 0b100000);</span>
  
  #undef INSN
  
<span class="line-modified">! #define INSN(NAME, opc, opc2) \</span>
    void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                   \
      starti;                                                                             \
      f(0, 31), f((int)T &amp; 1, 30), f(opc, 29), f(0b01110, 28, 24);                        \
      f((int)T &gt;&gt; 1, 23, 22), f(opc2, 21, 10);                                            \
      rf(Vn, 5), rf(Vd, 0);                                                               \
    }
  
<span class="line-modified">!   INSN(absr,   0, 0b100000101110);</span>
<span class="line-modified">!   INSN(negr,   1, 0b100000101110);</span>
<span class="line-modified">!   INSN(notr,   1, 0b100000010110);</span>
<span class="line-modified">!   INSN(addv,   0, 0b110001101110);</span>
<span class="line-modified">!   INSN(cls,    0, 0b100000010010);</span>
<span class="line-modified">!   INSN(clz,    1, 0b100000010010);</span>
<span class="line-modified">!   INSN(cnt,    0, 0b100000010110);</span>
<span class="line-modified">!   INSN(uaddlv, 1, 0b110000001110);</span>
  
  #undef INSN
  
  #define INSN(NAME, opc) \
    void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                  \
<span class="line-new-header">--- 2240,51 ---</span>
    INSN(bsl,  0b101110011);
    INSN(orn,  0b001110111);
  
  #undef INSN
  
<span class="line-modified">! #define INSN(NAME, opc, opc2, acceptT2D)                                                \</span>
    void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
<span class="line-added">+     guarantee(T != T1Q &amp;&amp; T != T1D, &quot;incorrect arrangement&quot;);                           \</span>
<span class="line-added">+     if (!acceptT2D) guarantee(T != T2D, &quot;incorrect arrangement&quot;);                       \</span>
      starti;                                                                             \
      f(0, 31), f((int)T &amp; 1, 30), f(opc, 29), f(0b01110, 28, 24);                        \
      f((int)T &gt;&gt; 1, 23, 22), f(1, 21), rf(Vm, 16), f(opc2, 15, 10);                      \
      rf(Vn, 5), rf(Vd, 0);                                                               \
    }
  
<span class="line-modified">!   INSN(addv,   0, 0b100001, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D</span>
<span class="line-modified">!   INSN(subv,   1, 0b100001, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D</span>
<span class="line-modified">!   INSN(mulv,   0, 0b100111, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S</span>
<span class="line-modified">!   INSN(mlav,   0, 0b100101, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S</span>
<span class="line-modified">!   INSN(mlsv,   1, 0b100101, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S</span>
<span class="line-modified">!   INSN(sshl,   0, 0b010001, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D</span>
<span class="line-modified">!   INSN(ushl,   1, 0b010001, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D</span>
<span class="line-modified">!   INSN(umullv, 1, 0b110000, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S</span>
<span class="line-modified">!   INSN(umlalv, 1, 0b100000, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S</span>
  
  #undef INSN
  
<span class="line-modified">! #define INSN(NAME, opc, opc2, accepted) \</span>
    void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                   \
<span class="line-added">+     guarantee(T != T1Q &amp;&amp; T != T1D, &quot;incorrect arrangement&quot;);                           \</span>
<span class="line-added">+     if (accepted &lt; 2) guarantee(T != T2S &amp;&amp; T != T2D, &quot;incorrect arrangement&quot;);         \</span>
<span class="line-added">+     if (accepted == 0) guarantee(T == T8B || T == T16B, &quot;incorrect arrangement&quot;);       \</span>
      starti;                                                                             \
      f(0, 31), f((int)T &amp; 1, 30), f(opc, 29), f(0b01110, 28, 24);                        \
      f((int)T &gt;&gt; 1, 23, 22), f(opc2, 21, 10);                                            \
      rf(Vn, 5), rf(Vd, 0);                                                               \
    }
  
<span class="line-modified">!   INSN(absr,   0, 0b100000101110, 1); // accepted arrangements: T8B, T16B, T4H, T8H,      T4S</span>
<span class="line-modified">!   INSN(negr,   1, 0b100000101110, 2); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D</span>
<span class="line-modified">!   INSN(notr,   1, 0b100000010110, 0); // accepted arrangements: T8B, T16B</span>
<span class="line-modified">!   INSN(addv,   0, 0b110001101110, 1); // accepted arrangements: T8B, T16B, T4H, T8H,      T4S</span>
<span class="line-modified">!   INSN(cls,    0, 0b100000010010, 1); // accepted arrangements: T8B, T16B, T4H, T8H,      T4S</span>
<span class="line-modified">!   INSN(clz,    1, 0b100000010010, 1); // accepted arrangements: T8B, T16B, T4H, T8H,      T4S</span>
<span class="line-modified">!   INSN(cnt,    0, 0b100000010110, 0); // accepted arrangements: T8B, T16B</span>
<span class="line-modified">!   INSN(uaddlv, 1, 0b110000001110, 1); // accepted arrangements: T8B, T16B, T4H, T8H,      T4S</span>
  
  #undef INSN
  
  #define INSN(NAME, opc) \
    void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                  \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2258,11 ***</span>
      unsigned cmode = cmode0;                                                           \
      unsigned op = op0;                                                                 \
      starti;                                                                            \
      assert(lsl == 0 ||                                                                 \
             ((T == T4H || T == T8H) &amp;&amp; lsl == 8) ||                                     \
<span class="line-modified">!            ((T == T2S || T == T4S) &amp;&amp; ((lsl &gt;&gt; 3) &lt; 4)), &quot;invalid shift&quot;);             \</span>
      cmode |= lsl &gt;&gt; 2;                                                                 \
      if (T == T4H || T == T8H) cmode |= 0b1000;                                         \
      if (!(T == T4H || T == T8H || T == T2S || T == T4S)) {                             \
        assert(op == 0 &amp;&amp; cmode0 == 0, &quot;must be MOVI&quot;);                                  \
        cmode = 0b1110;                                                                  \
<span class="line-new-header">--- 2304,11 ---</span>
      unsigned cmode = cmode0;                                                           \
      unsigned op = op0;                                                                 \
      starti;                                                                            \
      assert(lsl == 0 ||                                                                 \
             ((T == T4H || T == T8H) &amp;&amp; lsl == 8) ||                                     \
<span class="line-modified">!            ((T == T2S || T == T4S) &amp;&amp; ((lsl &gt;&gt; 3) &lt; 4) &amp;&amp; ((lsl &amp; 7) == 0)), &quot;invalid shift&quot;);\</span>
      cmode |= lsl &gt;&gt; 2;                                                                 \
      if (T == T4H || T == T8H) cmode |= 0b1000;                                         \
      if (!(T == T4H || T == T8H || T == T2S || T == T4S)) {                             \
        assert(op == 0 &amp;&amp; cmode0 == 0, &quot;must be MOVI&quot;);                                  \
        cmode = 0b1110;                                                                  \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2419,11 ***</span>
    INSN(sshr, 0, 0b000001, /* isSHR = */ true);
    INSN(ushr, 1, 0b000001, /* isSHR = */ true);
  
  #undef INSN
  
<span class="line-modified">!   void ushll(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, SIMD_Arrangement Tb, int shift) {</span>
      starti;
      /* The encodings for the immh:immb fields (bits 22:16) are
       *   0001 xxx       8H, 8B/16b shift = xxx
       *   001x xxx       4S, 4H/8H  shift = xxxx
       *   01xx xxx       2D, 2S/4S  shift = xxxxx
<span class="line-new-header">--- 2465,12 ---</span>
    INSN(sshr, 0, 0b000001, /* isSHR = */ true);
    INSN(ushr, 1, 0b000001, /* isSHR = */ true);
  
  #undef INSN
  
<span class="line-modified">! private:</span>
<span class="line-added">+   void _ushll(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, SIMD_Arrangement Tb, int shift) {</span>
      starti;
      /* The encodings for the immh:immb fields (bits 22:16) are
       *   0001 xxx       8H, 8B/16b shift = xxx
       *   001x xxx       4S, 4H/8H  shift = xxxx
       *   01xx xxx       2D, 2S/4S  shift = xxxxx
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2432,42 ***</span>
      assert((Tb &gt;&gt; 1) + 1 == (Ta &gt;&gt; 1), &quot;Incompatible arrangement&quot;);
      assert((1 &lt;&lt; ((Tb&gt;&gt;1)+3)) &gt; shift, &quot;Invalid shift value&quot;);
      f(0, 31), f(Tb &amp; 1, 30), f(0b1011110, 29, 23), f((1 &lt;&lt; ((Tb&gt;&gt;1)+3))|shift, 22, 16);
      f(0b101001, 15, 10), rf(Vn, 5), rf(Vd, 0);
    }
    void ushll2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn,  SIMD_Arrangement Tb, int shift) {
<span class="line-modified">!     ushll(Vd, Ta, Vn, Tb, shift);</span>
    }
  
    // Move from general purpose register
    //   mov  Vd.T[index], Rn
    void mov(FloatRegister Vd, SIMD_Arrangement T, int index, Register Xn) {
      starti;
      f(0b01001110000, 31, 21), f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
<span class="line-modified">!     f(0b000111, 15, 10), rf(Xn, 5), rf(Vd, 0);</span>
    }
  
    // Move to general purpose register
    //   mov  Rd, Vn.T[index]
    void mov(Register Xd, FloatRegister Vn, SIMD_Arrangement T, int index) {
      starti;
      f(0, 31), f((T &gt;= T1D) ? 1:0, 30), f(0b001110000, 29, 21);
      f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
      f(0b001111, 15, 10), rf(Vn, 5), rf(Xd, 0);
    }
  
<span class="line-modified">!   void pmull(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {</span>
      starti;
      assert((Ta == T1Q &amp;&amp; (Tb == T1D || Tb == T2D)) ||
             (Ta == T8H &amp;&amp; (Tb == T8B || Tb == T16B)), &quot;Invalid Size specifier&quot;);
      int size = (Ta == T1Q) ? 0b11 : 0b00;
      f(0, 31), f(Tb &amp; 1, 30), f(0b001110, 29, 24), f(size, 23, 22);
      f(1, 21), rf(Vm, 16), f(0b111000, 15, 10), rf(Vn, 5), rf(Vd, 0);
    }
    void pmull2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {
      assert(Tb == T2D || Tb == T16B, &quot;pmull2 assumes T2D or T16B as the second size specifier&quot;);
<span class="line-modified">!     pmull(Vd, Ta, Vn, Vm, Tb);</span>
    }
  
    void uqxtn(FloatRegister Vd, SIMD_Arrangement Tb, FloatRegister Vn, SIMD_Arrangement Ta) {
      starti;
      int size_b = (int)Tb &gt;&gt; 1;
<span class="line-new-header">--- 2479,59 ---</span>
      assert((Tb &gt;&gt; 1) + 1 == (Ta &gt;&gt; 1), &quot;Incompatible arrangement&quot;);
      assert((1 &lt;&lt; ((Tb&gt;&gt;1)+3)) &gt; shift, &quot;Invalid shift value&quot;);
      f(0, 31), f(Tb &amp; 1, 30), f(0b1011110, 29, 23), f((1 &lt;&lt; ((Tb&gt;&gt;1)+3))|shift, 22, 16);
      f(0b101001, 15, 10), rf(Vn, 5), rf(Vd, 0);
    }
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   void ushll(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn,  SIMD_Arrangement Tb, int shift) {</span>
<span class="line-added">+     assert(Tb == T8B || Tb == T4H || Tb == T2S, &quot;invalid arrangement&quot;);</span>
<span class="line-added">+     _ushll(Vd, Ta, Vn, Tb, shift);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    void ushll2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn,  SIMD_Arrangement Tb, int shift) {
<span class="line-modified">!     assert(Tb == T16B || Tb == T8H || Tb == T4S, &quot;invalid arrangement&quot;);</span>
<span class="line-added">+     _ushll(Vd, Ta, Vn, Tb, shift);</span>
    }
  
    // Move from general purpose register
    //   mov  Vd.T[index], Rn
    void mov(FloatRegister Vd, SIMD_Arrangement T, int index, Register Xn) {
      starti;
      f(0b01001110000, 31, 21), f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
<span class="line-modified">!     f(0b000111, 15, 10), zrf(Xn, 5), rf(Vd, 0);</span>
    }
  
    // Move to general purpose register
    //   mov  Rd, Vn.T[index]
    void mov(Register Xd, FloatRegister Vn, SIMD_Arrangement T, int index) {
<span class="line-added">+     guarantee(T &gt;= T2S &amp;&amp; T &lt; T1Q, &quot;only D and S arrangements are supported&quot;);</span>
      starti;
      f(0, 31), f((T &gt;= T1D) ? 1:0, 30), f(0b001110000, 29, 21);
      f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
      f(0b001111, 15, 10), rf(Vn, 5), rf(Xd, 0);
    }
  
<span class="line-modified">! private:</span>
<span class="line-added">+   void _pmull(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {</span>
      starti;
      assert((Ta == T1Q &amp;&amp; (Tb == T1D || Tb == T2D)) ||
             (Ta == T8H &amp;&amp; (Tb == T8B || Tb == T16B)), &quot;Invalid Size specifier&quot;);
      int size = (Ta == T1Q) ? 0b11 : 0b00;
      f(0, 31), f(Tb &amp; 1, 30), f(0b001110, 29, 24), f(size, 23, 22);
      f(1, 21), rf(Vm, 16), f(0b111000, 15, 10), rf(Vn, 5), rf(Vd, 0);
    }
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   void pmull(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {</span>
<span class="line-added">+     assert(Tb == T1D || Tb == T8B, &quot;pmull assumes T1D or T8B as the second size specifier&quot;);</span>
<span class="line-added">+     _pmull(Vd, Ta, Vn, Vm, Tb);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    void pmull2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {
      assert(Tb == T2D || Tb == T16B, &quot;pmull2 assumes T2D or T16B as the second size specifier&quot;);
<span class="line-modified">!     _pmull(Vd, Ta, Vn, Vm, Tb);</span>
    }
  
    void uqxtn(FloatRegister Vd, SIMD_Arrangement Tb, FloatRegister Vn, SIMD_Arrangement Ta) {
      starti;
      int size_b = (int)Tb &gt;&gt; 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2480,11 ***</span>
    void dup(FloatRegister Vd, SIMD_Arrangement T, Register Xs)
    {
      starti;
      assert(T != T1D, &quot;reserved encoding&quot;);
      f(0,31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21);
<span class="line-modified">!     f((1 &lt;&lt; (T &gt;&gt; 1)), 20, 16), f(0b000011, 15, 10), rf(Xs, 5), rf(Vd, 0);</span>
    }
  
    void dup(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int index = 0)
    {
      starti;
<span class="line-new-header">--- 2544,11 ---</span>
    void dup(FloatRegister Vd, SIMD_Arrangement T, Register Xs)
    {
      starti;
      assert(T != T1D, &quot;reserved encoding&quot;);
      f(0,31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21);
<span class="line-modified">!     f((1 &lt;&lt; (T &gt;&gt; 1)), 20, 16), f(0b000011, 15, 10), zrf(Xs, 5), rf(Vd, 0);</span>
    }
  
    void dup(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int index = 0)
    {
      starti;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2495,10 ***</span>
<span class="line-new-header">--- 2559,11 ---</span>
    }
  
    // AdvSIMD ZIP/UZP/TRN
  #define INSN(NAME, opcode)                                              \
    void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
<span class="line-added">+     guarantee(T != T1D &amp;&amp; T != T1Q, &quot;invalid arrangement&quot;);             \</span>
      starti;                                                             \
      f(0, 31), f(0b001110, 29, 24), f(0, 21), f(0, 15);                  \
      f(opcode, 14, 12), f(0b10, 11, 10);                                 \
      rf(Vm, 16), rf(Vn, 5), rf(Vd, 0);                                   \
      f(T &amp; 1, 30), f(T &gt;&gt; 1, 23, 22);                                    \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2546,46 ***</span>
    INSN(tbx, 1);
  
  #undef INSN
  
    // AdvSIMD two-reg misc
<span class="line-modified">! #define INSN(NAME, U, opcode)                                                       \</span>
    void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {               \
         starti;                                                                      \
         assert((ASSERTION), MSG);                                                    \
         f(0, 31), f((int)T &amp; 1, 30), f(U, 29), f(0b01110, 28, 24);                   \
<span class="line-modified">!        f((int)(T &gt;&gt; 1), 23, 22), f(0b10000, 21, 17), f(opcode, 16, 12);             \</span>
<span class="line-modified">!        f(0b10, 11, 10), rf(Vn, 5), rf(Vd, 0);                                       \</span>
   }
  
  #define MSG &quot;invalid arrangement&quot;
  
  #define ASSERTION (T == T2S || T == T4S || T == T2D)
<span class="line-modified">!   INSN(fsqrt, 1, 0b11111);</span>
<span class="line-modified">!   INSN(fabs,  0, 0b01111);</span>
<span class="line-modified">!   INSN(fneg,  1, 0b01111);</span>
  #undef ASSERTION
  
  #define ASSERTION (T == T8B || T == T16B || T == T4H || T == T8H || T == T2S || T == T4S)
<span class="line-modified">!   INSN(rev64, 0, 0b00000);</span>
  #undef ASSERTION
  
  #define ASSERTION (T == T8B || T == T16B || T == T4H || T == T8H)
<span class="line-modified">!   INSN(rev32, 1, 0b00000);</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   INSN(_rbit, 1, 0b00101);</span>
<span class="line-removed">- public:</span>
<span class="line-removed">- </span>
  #undef ASSERTION
  
  #define ASSERTION (T == T8B || T == T16B)
<span class="line-modified">!   INSN(rev16, 0, 0b00001);</span>
<span class="line-modified">!   // RBIT only allows T8B and T16B but encodes them oddly.  Argh...</span>
<span class="line-removed">-   void rbit(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {</span>
<span class="line-removed">-     assert((ASSERTION), MSG);</span>
<span class="line-removed">-     _rbit(Vd, SIMD_Arrangement(T &amp; 1 | 0b010), Vn);</span>
<span class="line-removed">-   }</span>
  #undef ASSERTION
  
  #undef MSG
  
  #undef INSN
<span class="line-new-header">--- 2611,46 ---</span>
    INSN(tbx, 1);
  
  #undef INSN
  
    // AdvSIMD two-reg misc
<span class="line-modified">!   // In this instruction group, the 2 bits in the size field ([23:22]) may be</span>
<span class="line-added">+   // fixed or determined by the &quot;SIMD_Arrangement T&quot;, or both. The additional</span>
<span class="line-added">+   // parameter &quot;tmask&quot; is a 2-bit mask used to indicate which bits in the size</span>
<span class="line-added">+   // field are determined by the SIMD_Arrangement. The bit of &quot;tmask&quot; should be</span>
<span class="line-added">+   // set to 1 if corresponding bit marked as &quot;x&quot; in the ArmARM.</span>
<span class="line-added">+ #define INSN(NAME, U, size, tmask, opcode)                                          \</span>
    void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {               \
         starti;                                                                      \
         assert((ASSERTION), MSG);                                                    \
         f(0, 31), f((int)T &amp; 1, 30), f(U, 29), f(0b01110, 28, 24);                   \
<span class="line-modified">!        f(size | ((int)(T &gt;&gt; 1) &amp; tmask), 23, 22), f(0b10000, 21, 17);               \</span>
<span class="line-modified">!        f(opcode, 16, 12), f(0b10, 11, 10), rf(Vn, 5), rf(Vd, 0);                    \</span>
   }
  
  #define MSG &quot;invalid arrangement&quot;
  
  #define ASSERTION (T == T2S || T == T4S || T == T2D)
<span class="line-modified">!   INSN(fsqrt,  1, 0b10, 0b01, 0b11111);</span>
<span class="line-modified">!   INSN(fabs,   0, 0b10, 0b01, 0b01111);</span>
<span class="line-modified">!   INSN(fneg,   1, 0b10, 0b01, 0b01111);</span>
<span class="line-added">+   INSN(frintn, 0, 0b00, 0b01, 0b11000);</span>
<span class="line-added">+   INSN(frintm, 0, 0b00, 0b01, 0b11001);</span>
<span class="line-added">+   INSN(frintp, 0, 0b10, 0b01, 0b11000);</span>
  #undef ASSERTION
  
  #define ASSERTION (T == T8B || T == T16B || T == T4H || T == T8H || T == T2S || T == T4S)
<span class="line-modified">!   INSN(rev64, 0, 0b00, 0b11, 0b00000);</span>
  #undef ASSERTION
  
  #define ASSERTION (T == T8B || T == T16B || T == T4H || T == T8H)
<span class="line-modified">!   INSN(rev32, 1, 0b00, 0b11, 0b00000);</span>
  #undef ASSERTION
  
  #define ASSERTION (T == T8B || T == T16B)
<span class="line-modified">!   INSN(rev16, 0, 0b00, 0b11, 0b00001);</span>
<span class="line-modified">!   INSN(rbit,  1, 0b01, 0b00, 0b00101);</span>
  #undef ASSERTION
  
  #undef MSG
  
  #undef INSN
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2598,141 ***</span>
      f(0, 31), f((int)T &amp; 1, 30), f(0b101110000, 29, 21);
      rf(Vm, 16), f(0, 15), f(index, 14, 11);
      f(0, 10), rf(Vn, 5), rf(Vd, 0);
    }
  
<span class="line-removed">- /* Simulator extensions to the ISA</span>
<span class="line-removed">- </span>
<span class="line-removed">-    haltsim</span>
<span class="line-removed">- </span>
<span class="line-removed">-    takes no arguments, causes the sim to enter a debug break and then</span>
<span class="line-removed">-    return from the simulator run() call with STATUS_HALT? The linking</span>
<span class="line-removed">-    code will call fatal() when it sees STATUS_HALT.</span>
<span class="line-removed">- </span>
<span class="line-removed">-    blrt Xn, Wm</span>
<span class="line-removed">-    blrt Xn, #gpargs, #fpargs, #type</span>
<span class="line-removed">-    Xn holds the 64 bit x86 branch_address</span>
<span class="line-removed">-    call format is encoded either as immediate data in the call</span>
<span class="line-removed">-    or in register Wm. In the latter case</span>
<span class="line-removed">-      Wm[13..6] = #gpargs,</span>
<span class="line-removed">-      Wm[5..2] = #fpargs,</span>
<span class="line-removed">-      Wm[1,0] = #type</span>
<span class="line-removed">- </span>
<span class="line-removed">-    calls the x86 code address &#39;branch_address&#39; supplied in Xn passing</span>
<span class="line-removed">-    arguments taken from the general and floating point registers according</span>
<span class="line-removed">-    to the supplied counts &#39;gpargs&#39; and &#39;fpargs&#39;. may return a result in r0</span>
<span class="line-removed">-    or v0 according to the the return type #type&#39; where</span>
<span class="line-removed">- </span>
<span class="line-removed">-    address branch_address;</span>
<span class="line-removed">-    uimm4 gpargs;</span>
<span class="line-removed">-    uimm4 fpargs;</span>
<span class="line-removed">-    enum ReturnType type;</span>
<span class="line-removed">- </span>
<span class="line-removed">-    enum ReturnType</span>
<span class="line-removed">-      {</span>
<span class="line-removed">-        void_ret = 0,</span>
<span class="line-removed">-        int_ret = 1,</span>
<span class="line-removed">-        long_ret = 1,</span>
<span class="line-removed">-        obj_ret = 1, // i.e. same as long</span>
<span class="line-removed">-        float_ret = 2,</span>
<span class="line-removed">-        double_ret = 3</span>
<span class="line-removed">-      }</span>
<span class="line-removed">- </span>
<span class="line-removed">-    notify</span>
<span class="line-removed">- </span>
<span class="line-removed">-    notifies the simulator of a transfer of control. instr[14:0]</span>
<span class="line-removed">-    identifies the type of change of control.</span>
<span class="line-removed">- </span>
<span class="line-removed">-    0 ==&gt; initial entry to a method.</span>
<span class="line-removed">- </span>
<span class="line-removed">-    1 ==&gt; return into a method from a submethod call.</span>
<span class="line-removed">- </span>
<span class="line-removed">-    2 ==&gt; exit out of Java method code.</span>
<span class="line-removed">- </span>
<span class="line-removed">-    3 ==&gt; start execution for a new bytecode.</span>
<span class="line-removed">- </span>
<span class="line-removed">-    in cases 1 and 2 the simulator is expected to use a JVM callback to</span>
<span class="line-removed">-    identify the name of the specific method being executed. in case 4</span>
<span class="line-removed">-    the simulator is expected to use a JVM callback to identify the</span>
<span class="line-removed">-    bytecode index.</span>
<span class="line-removed">- </span>
<span class="line-removed">-    Instruction encodings</span>
<span class="line-removed">-    ---------------------</span>
<span class="line-removed">- </span>
<span class="line-removed">-    These are encoded in the space with instr[28:25] = 00 which is</span>
<span class="line-removed">-    unallocated. Encodings are</span>
<span class="line-removed">- </span>
<span class="line-removed">-                      10987654321098765432109876543210</span>
<span class="line-removed">-    PSEUDO_HALT   = 0x11100000000000000000000000000000</span>
<span class="line-removed">-    PSEUDO_BLRT  = 0x11000000000000000_______________</span>
<span class="line-removed">-    PSEUDO_BLRTR = 0x1100000000000000100000__________</span>
<span class="line-removed">-    PSEUDO_NOTIFY = 0x10100000000000000_______________</span>
<span class="line-removed">- </span>
<span class="line-removed">-    instr[31,29] = op1 : 111 ==&gt; HALT, 110 ==&gt; BLRT/BLRTR, 101 ==&gt; NOTIFY</span>
<span class="line-removed">- </span>
<span class="line-removed">-    for BLRT</span>
<span class="line-removed">-      instr[14,11] = #gpargs, instr[10,7] = #fpargs</span>
<span class="line-removed">-      instr[6,5] = #type, instr[4,0] = Rn</span>
<span class="line-removed">-    for BLRTR</span>
<span class="line-removed">-      instr[9,5] = Rm, instr[4,0] = Rn</span>
<span class="line-removed">-    for NOTIFY</span>
<span class="line-removed">-      instr[14:0] = type : 0 ==&gt; entry, 1 ==&gt; reentry, 2 ==&gt; exit, 3 ==&gt; bcstart</span>
<span class="line-removed">- */</span>
<span class="line-removed">- </span>
<span class="line-removed">-   enum NotifyType { method_entry, method_reentry, method_exit, bytecode_start };</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual void notify(int type) {</span>
<span class="line-removed">-     if (UseBuiltinSim) {</span>
<span class="line-removed">-       starti;</span>
<span class="line-removed">-       //  109</span>
<span class="line-removed">-       f(0b101, 31, 29);</span>
<span class="line-removed">-       //  87654321098765</span>
<span class="line-removed">-       f(0b00000000000000, 28, 15);</span>
<span class="line-removed">-       f(type, 14, 0);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void blrt(Register Rn, int gpargs, int fpargs, int type) {</span>
<span class="line-removed">-     if (UseBuiltinSim) {</span>
<span class="line-removed">-       starti;</span>
<span class="line-removed">-       f(0b110, 31 ,29);</span>
<span class="line-removed">-       f(0b00, 28, 25);</span>
<span class="line-removed">-       //  4321098765</span>
<span class="line-removed">-       f(0b0000000000, 24, 15);</span>
<span class="line-removed">-       f(gpargs, 14, 11);</span>
<span class="line-removed">-       f(fpargs, 10, 7);</span>
<span class="line-removed">-       f(type, 6, 5);</span>
<span class="line-removed">-       rf(Rn, 0);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       blr(Rn);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void blrt(Register Rn, Register Rm) {</span>
<span class="line-removed">-     if (UseBuiltinSim) {</span>
<span class="line-removed">-       starti;</span>
<span class="line-removed">-       f(0b110, 31 ,29);</span>
<span class="line-removed">-       f(0b00, 28, 25);</span>
<span class="line-removed">-       //  4321098765</span>
<span class="line-removed">-       f(0b0000000001, 24, 15);</span>
<span class="line-removed">-       //  43210</span>
<span class="line-removed">-       f(0b00000, 14, 10);</span>
<span class="line-removed">-       rf(Rm, 5);</span>
<span class="line-removed">-       rf(Rn, 0);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       blr(Rn);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void haltsim() {</span>
<span class="line-removed">-     starti;</span>
<span class="line-removed">-     f(0b111, 31 ,29);</span>
<span class="line-removed">-     f(0b00, 28, 27);</span>
<span class="line-removed">-     //  654321098765432109876543210</span>
<span class="line-removed">-     f(0b000000000000000000000000000, 26, 0);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    Assembler(CodeBuffer* code) : AbstractAssembler(code) {
    }
  
    virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
                                                  Register tmp,
<span class="line-new-header">--- 2663,10 ---</span>
</pre>
<center><a href="assembler_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_FrameMap_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="templateInterpreterGenerator_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 38,10 ***</span>
<span class="line-new-header">--- 38,11 ---</span>
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/synchronizer.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  #define __ _masm-&gt;
  
  // Platform-dependent initialization
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1476,12 ***</span>
      __ fdivs(v0, v1, v0);
      break;
    case rem:
      __ fmovs(v1, v0);
      __ pop_f(v0);
<span class="line-modified">!     __ call_VM_leaf_base1(CAST_FROM_FN_PTR(address, SharedRuntime::frem),</span>
<span class="line-removed">-                          0, 2, MacroAssembler::ret_type_float);</span>
      break;
    default:
      ShouldNotReachHere();
      break;
    }
<span class="line-new-header">--- 1477,11 ---</span>
      __ fdivs(v0, v1, v0);
      break;
    case rem:
      __ fmovs(v1, v0);
      __ pop_f(v0);
<span class="line-modified">!     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem));</span>
      break;
    default:
      ShouldNotReachHere();
      break;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1509,12 ***</span>
      __ fdivd(v0, v1, v0);
      break;
    case rem:
      __ fmovd(v1, v0);
      __ pop_d(v0);
<span class="line-modified">!     __ call_VM_leaf_base1(CAST_FROM_FN_PTR(address, SharedRuntime::drem),</span>
<span class="line-removed">-                          0, 2, MacroAssembler::ret_type_double);</span>
      break;
    default:
      ShouldNotReachHere();
      break;
    }
<span class="line-new-header">--- 1509,11 ---</span>
      __ fdivd(v0, v1, v0);
      break;
    case rem:
      __ fmovd(v1, v0);
      __ pop_d(v0);
<span class="line-modified">!     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem));</span>
      break;
    default:
      ShouldNotReachHere();
      break;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1651,24 ***</span>
      Label L_Okay;
      __ clear_fpsr();
      __ fcvtzsw(r0, v0);
      __ get_fpsr(r1);
      __ cbzw(r1, L_Okay);
<span class="line-modified">!     __ call_VM_leaf_base1(CAST_FROM_FN_PTR(address, SharedRuntime::f2i),</span>
<span class="line-removed">-                          0, 1, MacroAssembler::ret_type_integral);</span>
      __ bind(L_Okay);
    }
      break;
    case Bytecodes::_f2l:
    {
      Label L_Okay;
      __ clear_fpsr();
      __ fcvtzs(r0, v0);
      __ get_fpsr(r1);
      __ cbzw(r1, L_Okay);
<span class="line-modified">!     __ call_VM_leaf_base1(CAST_FROM_FN_PTR(address, SharedRuntime::f2l),</span>
<span class="line-removed">-                          0, 1, MacroAssembler::ret_type_integral);</span>
      __ bind(L_Okay);
    }
      break;
    case Bytecodes::_f2d:
      __ fcvts(v0, v0);
<span class="line-new-header">--- 1650,22 ---</span>
      Label L_Okay;
      __ clear_fpsr();
      __ fcvtzsw(r0, v0);
      __ get_fpsr(r1);
      __ cbzw(r1, L_Okay);
<span class="line-modified">!     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i));</span>
      __ bind(L_Okay);
    }
      break;
    case Bytecodes::_f2l:
    {
      Label L_Okay;
      __ clear_fpsr();
      __ fcvtzs(r0, v0);
      __ get_fpsr(r1);
      __ cbzw(r1, L_Okay);
<span class="line-modified">!     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l));</span>
      __ bind(L_Okay);
    }
      break;
    case Bytecodes::_f2d:
      __ fcvts(v0, v0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1678,24 ***</span>
      Label L_Okay;
      __ clear_fpsr();
      __ fcvtzdw(r0, v0);
      __ get_fpsr(r1);
      __ cbzw(r1, L_Okay);
<span class="line-modified">!     __ call_VM_leaf_base1(CAST_FROM_FN_PTR(address, SharedRuntime::d2i),</span>
<span class="line-removed">-                          0, 1, MacroAssembler::ret_type_integral);</span>
      __ bind(L_Okay);
    }
      break;
    case Bytecodes::_d2l:
    {
      Label L_Okay;
      __ clear_fpsr();
      __ fcvtzd(r0, v0);
      __ get_fpsr(r1);
      __ cbzw(r1, L_Okay);
<span class="line-modified">!     __ call_VM_leaf_base1(CAST_FROM_FN_PTR(address, SharedRuntime::d2l),</span>
<span class="line-removed">-                          0, 1, MacroAssembler::ret_type_integral);</span>
      __ bind(L_Okay);
    }
      break;
    case Bytecodes::_d2f:
      __ fcvtd(v0, v0);
<span class="line-new-header">--- 1675,22 ---</span>
      Label L_Okay;
      __ clear_fpsr();
      __ fcvtzdw(r0, v0);
      __ get_fpsr(r1);
      __ cbzw(r1, L_Okay);
<span class="line-modified">!     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i));</span>
      __ bind(L_Okay);
    }
      break;
    case Bytecodes::_d2l:
    {
      Label L_Okay;
      __ clear_fpsr();
      __ fcvtzd(r0, v0);
      __ get_fpsr(r1);
      __ cbzw(r1, L_Okay);
<span class="line-modified">!     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l));</span>
      __ bind(L_Okay);
    }
      break;
    case Bytecodes::_d2f:
      __ fcvtd(v0, v0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2321,11 ***</span>
                                              Register index,
                                              size_t index_size) {
    const Register temp = r19;
    assert_different_registers(Rcache, index, temp);
  
<span class="line-modified">!   Label resolved;</span>
  
    Bytecodes::Code code = bytecode();
    switch (code) {
    case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
    case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
<span class="line-new-header">--- 2316,11 ---</span>
                                              Register index,
                                              size_t index_size) {
    const Register temp = r19;
    assert_different_registers(Rcache, index, temp);
  
<span class="line-modified">!   Label resolved, clinit_barrier_slow;</span>
  
    Bytecodes::Code code = bytecode();
    switch (code) {
    case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
    case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2336,19 ***</span>
<span class="line-new-header">--- 2331,28 ---</span>
    __ get_cache_and_index_and_bytecode_at_bcp(Rcache, index, temp, byte_no, 1, index_size);
    __ subs(zr, temp, (int) code);  // have we resolved this bytecode?
    __ br(Assembler::EQ, resolved);
  
    // resolve first time through
<span class="line-added">+   // Class initialization barrier slow path lands here as well.</span>
<span class="line-added">+   __ bind(clinit_barrier_slow);</span>
    address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
    __ mov(temp, (int) code);
    __ call_VM(noreg, entry, temp);
  
    // Update registers with resolved info
    __ get_cache_and_index_at_bcp(Rcache, index, 1, index_size);
    // n.b. unlike x86 Rcache is now rcpool plus the indexed offset
    // so all clients ofthis method must be modified accordingly
    __ bind(resolved);
<span class="line-added">+ </span>
<span class="line-added">+   // Class initialization barrier for static methods</span>
<span class="line-added">+   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {</span>
<span class="line-added">+     __ load_resolved_method_at_index(byte_no, temp, Rcache);</span>
<span class="line-added">+     __ load_method_holder(temp, temp);</span>
<span class="line-added">+     __ clinit_barrier(temp, rscratch1, NULL, &amp;clinit_barrier_slow);</span>
<span class="line-added">+   }</span>
  }
  
  // The Rcache and index registers must be set before call
  // n.b unlike x86 cache already includes the index offset
  void TemplateTable::load_field_cp_cache_entry(Register obj,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2883,11 ***</span>
    __ bind(Done);
  
    {
      Label notVolatile;
      __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
<span class="line-modified">!     __ membar(MacroAssembler::StoreLoad);</span>
      __ bind(notVolatile);
    }
  }
  
  void TemplateTable::putfield(int byte_no)
<span class="line-new-header">--- 2887,11 ---</span>
    __ bind(Done);
  
    {
      Label notVolatile;
      __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
<span class="line-modified">!     __ membar(MacroAssembler::StoreLoad | MacroAssembler::StoreStore);</span>
      __ bind(notVolatile);
    }
  }
  
  void TemplateTable::putfield(int byte_no)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3027,11 ***</span>
    }
  
    {
      Label notVolatile;
      __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
<span class="line-modified">!     __ membar(MacroAssembler::StoreLoad);</span>
      __ bind(notVolatile);
    }
  }
  
  
<span class="line-new-header">--- 3031,11 ---</span>
    }
  
    {
      Label notVolatile;
      __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
<span class="line-modified">!     __ membar(MacroAssembler::StoreLoad | MacroAssembler::StoreStore);</span>
      __ bind(notVolatile);
    }
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3416,13 ***</span>
  
    // profile this call
    __ profile_virtual_call(r3, r13, r19);
  
    // Get declaring interface class from method, and itable index
<span class="line-modified">!   __ ldr(r0, Address(rmethod, Method::const_offset()));</span>
<span class="line-modified">!   __ ldr(r0, Address(r0, ConstMethod::constants_offset()));</span>
<span class="line-removed">-   __ ldr(r0, Address(r0, ConstantPool::pool_holder_offset_in_bytes()));</span>
    __ ldrw(rmethod, Address(rmethod, Method::itable_index_offset()));
    __ subw(rmethod, rmethod, Method::itable_index_max);
    __ negw(rmethod, rmethod);
  
    // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
<span class="line-new-header">--- 3420,12 ---</span>
  
    // profile this call
    __ profile_virtual_call(r3, r13, r19);
  
    // Get declaring interface class from method, and itable index
<span class="line-modified">! </span>
<span class="line-modified">!   __ load_method_holder(r0, rmethod);</span>
    __ ldrw(rmethod, Address(rmethod, Method::itable_index_offset()));
    __ subw(rmethod, rmethod, Method::itable_index_max);
    __ negw(rmethod, rmethod);
  
    // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3611,11 ***</span>
      // initialize object header only.
      __ bind(initialize_header);
      if (UseBiasedLocking) {
        __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));
      } else {
<span class="line-modified">!       __ mov(rscratch1, (intptr_t)markOopDesc::prototype());</span>
      }
      __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));
      __ store_klass_gap(r0, zr);  // zero klass gap for compressed oops
      __ store_klass(r0, r4);      // store klass last
  
<span class="line-new-header">--- 3614,11 ---</span>
      // initialize object header only.
      __ bind(initialize_header);
      if (UseBiasedLocking) {
        __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));
      } else {
<span class="line-modified">!       __ mov(rscratch1, (intptr_t)markWord::prototype().value());</span>
      }
      __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));
      __ store_klass_gap(r0, zr);  // zero klass gap for compressed oops
      __ store_klass(r0, r4);      // store klass last
  
</pre>
<center><a href="templateInterpreterGenerator_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
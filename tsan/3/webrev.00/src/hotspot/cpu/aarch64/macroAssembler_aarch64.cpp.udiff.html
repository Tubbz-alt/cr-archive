<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCodeInstaller_aarch64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,8 +1,8 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-removed">-  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -34,20 +34,22 @@</span>
  #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;compiler/disassembler.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;nativeInst_aarch64.hpp&quot;
  #include &quot;oops/accessDecorators.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/icache.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #ifdef COMPILER1
  #include &quot;c1/c1_LIRAssembler.hpp&quot;
  #endif
  #ifdef COMPILER2
  #include &quot;oops/oop.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -469,11 +471,11 @@</span>
  
    if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL)
      counters = BiasedLocking::counters();
  
    assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg, rscratch1, rscratch2, noreg);
<span class="udiff-line-modified-removed">-   assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);</span>
<span class="udiff-line-modified-added">+   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);</span>
    Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
    Address klass_addr     (obj_reg, oopDesc::klass_offset_in_bytes());
    Address saved_mark_addr(lock_reg, 0);
  
    // Biased locking
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -486,19 +488,19 @@</span>
    int null_check_offset = -1;
    if (!swap_reg_contains_mark) {
      null_check_offset = offset();
      ldr(swap_reg, mark_addr);
    }
<span class="udiff-line-modified-removed">-   andr(tmp_reg, swap_reg, markOopDesc::biased_lock_mask_in_place);</span>
<span class="udiff-line-modified-removed">-   cmp(tmp_reg, (u1)markOopDesc::biased_lock_pattern);</span>
<span class="udiff-line-modified-added">+   andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);</span>
<span class="udiff-line-modified-added">+   cmp(tmp_reg, (u1)markWord::biased_lock_pattern);</span>
    br(Assembler::NE, cas_label);
    // The bias pattern is present in the object&#39;s header. Need to check
    // whether the bias owner and the epoch are both still current.
    load_prototype_header(tmp_reg, obj_reg);
    orr(tmp_reg, tmp_reg, rthread);
    eor(tmp_reg, swap_reg, tmp_reg);
<span class="udiff-line-modified-removed">-   andr(tmp_reg, tmp_reg, ~((int) markOopDesc::age_mask_in_place));</span>
<span class="udiff-line-modified-added">+   andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));</span>
    if (counters != NULL) {
      Label around;
      cbnz(tmp_reg, around);
      atomic_incw(Address((address)counters-&gt;biased_lock_entry_count_addr()), tmp_reg, rscratch1, rscratch2);
      b(done);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -517,11 +519,11 @@</span>
    // header.
  
    // If the low three bits in the xor result aren&#39;t clear, that means
    // the prototype header is no longer biased and we have to revoke
    // the bias on this object.
<span class="udiff-line-modified-removed">-   andr(rscratch1, tmp_reg, markOopDesc::biased_lock_mask_in_place);</span>
<span class="udiff-line-modified-added">+   andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);</span>
    cbnz(rscratch1, try_revoke_bias);
  
    // Biasing is still enabled for this data type. See whether the
    // epoch of the current bias is still valid, meaning that the epoch
    // bits of the mark word are equal to the epoch bits of the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -529,22 +531,22 @@</span>
    // only change at a safepoint.) If not, attempt to rebias the object
    // toward the current thread. Note that we must be absolutely sure
    // that the current epoch is invalid in order to do this because
    // otherwise the manipulations it performs on the mark word are
    // illegal.
<span class="udiff-line-modified-removed">-   andr(rscratch1, tmp_reg, markOopDesc::epoch_mask_in_place);</span>
<span class="udiff-line-modified-added">+   andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);</span>
    cbnz(rscratch1, try_rebias);
  
    // The epoch of the current bias is still valid but we know nothing
    // about the owner; it might be set or it might be clear. Try to
    // acquire the bias of the object using an atomic operation. If this
    // fails we will go in to the runtime to revoke the object&#39;s bias.
    // Note that we first construct the presumed unbiased header so we
    // don&#39;t accidentally blow away another thread&#39;s valid bias.
    {
      Label here;
<span class="udiff-line-modified-removed">-     mov(rscratch1, markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place);</span>
<span class="udiff-line-modified-added">+     mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);</span>
      andr(swap_reg, swap_reg, rscratch1);
      orr(tmp_reg, swap_reg, rthread);
      cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);
      // If the biasing toward our thread failed, this means that
      // another thread succeeded in biasing it toward itself and we
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -625,12 +627,12 @@</span>
    // First, the interpreter checks for IllegalMonitorStateException at
    // a higher level. Second, if the bias was revoked while we held the
    // lock, the object could not be rebiased toward another thread, so
    // the bias bit would be clear.
    ldr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
<span class="udiff-line-modified-removed">-   andr(temp_reg, temp_reg, markOopDesc::biased_lock_mask_in_place);</span>
<span class="udiff-line-modified-removed">-   cmp(temp_reg, (u1)markOopDesc::biased_lock_pattern);</span>
<span class="udiff-line-modified-added">+   andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);</span>
<span class="udiff-line-modified-added">+   cmp(temp_reg, (u1)markWord::biased_lock_pattern);</span>
    br(Assembler::EQ, done);
  }
  
  static void pass_arg0(MacroAssembler* masm, Register arg) {
    if (c_rarg0 != arg ) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -810,10 +812,22 @@</span>
  
    end_a_stub();
    return stub_start_addr;
  }
  
<span class="udiff-line-added">+ void MacroAssembler::emit_static_call_stub() {</span>
<span class="udiff-line-added">+   // CompiledDirectStaticCall::set_to_interpreted knows the</span>
<span class="udiff-line-added">+   // exact layout of this stub.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   isb();</span>
<span class="udiff-line-added">+   mov_metadata(rmethod, (Metadata*)NULL);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Jump to the entry point of the i2c stub.</span>
<span class="udiff-line-added">+   movptr(rscratch1, 0);</span>
<span class="udiff-line-added">+   br(rscratch1);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void MacroAssembler::c2bool(Register x) {
    // implements x == 0 ? 0 : 1
    // note: must only look at least-significant byte of x
    //       since C-style booleans are stored in one byte
    //       only! (was bug)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -957,21 +971,10 @@</span>
      add(tmp, tmp, offset);
  
    return RegisterOrConstant(tmp);
  }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void MacroAssembler:: notify(int type) {</span>
<span class="udiff-line-removed">-   if (type == bytecode_start) {</span>
<span class="udiff-line-removed">-     // set_last_Java_frame(esp, rfp, (address)NULL);</span>
<span class="udiff-line-removed">-     Assembler:: notify(type);</span>
<span class="udiff-line-removed">-     // reset_last_Java_frame(true);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   else</span>
<span class="udiff-line-removed">-     Assembler:: notify(type);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  // Look up the method for a megamorphic invokeinterface call.
  // The target method is determined by &lt;intf_klass, itable_index&gt;.
  // The receiver klass is in recv_klass.
  // On success, the result will be in method_result, and execution falls through.
  // On failure, execution transfers to the given label.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1292,10 +1295,39 @@</span>
  #undef IS_A_TEMP
  
    bind(L_fallthrough);
  }
  
<span class="udiff-line-added">+ void MacroAssembler::clinit_barrier(Register klass, Register scratch, Label* L_fast_path, Label* L_slow_path) {</span>
<span class="udiff-line-added">+   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);</span>
<span class="udiff-line-added">+   assert_different_registers(klass, rthread, scratch);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Label L_fallthrough, L_tmp;</span>
<span class="udiff-line-added">+   if (L_fast_path == NULL) {</span>
<span class="udiff-line-added">+     L_fast_path = &amp;L_fallthrough;</span>
<span class="udiff-line-added">+   } else if (L_slow_path == NULL) {</span>
<span class="udiff-line-added">+     L_slow_path = &amp;L_fallthrough;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Fast path check: class is fully initialized</span>
<span class="udiff-line-added">+   ldrb(scratch, Address(klass, InstanceKlass::init_state_offset()));</span>
<span class="udiff-line-added">+   subs(zr, scratch, InstanceKlass::fully_initialized);</span>
<span class="udiff-line-added">+   br(Assembler::EQ, *L_fast_path);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Fast path check: current thread is initializer thread</span>
<span class="udiff-line-added">+   ldr(scratch, Address(klass, InstanceKlass::init_thread_offset()));</span>
<span class="udiff-line-added">+   cmp(rthread, scratch);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (L_slow_path == &amp;L_fallthrough) {</span>
<span class="udiff-line-added">+     br(Assembler::EQ, *L_fast_path);</span>
<span class="udiff-line-added">+     bind(*L_slow_path);</span>
<span class="udiff-line-added">+   } else if (L_fast_path == &amp;L_fallthrough) {</span>
<span class="udiff-line-added">+     br(Assembler::NE, *L_slow_path);</span>
<span class="udiff-line-added">+     bind(*L_fast_path);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     Unimplemented();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  void MacroAssembler::verify_oop(Register reg, const char* s) {
    if (!VerifyOops) return;
  
    // Pass register number to verify_oop_subroutine
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1381,26 +1413,16 @@</span>
  }
  
  void MacroAssembler::call_VM_leaf_base(address entry_point,
                                         int number_of_arguments,
                                         Label *retaddr) {
<span class="udiff-line-removed">-   call_VM_leaf_base1(entry_point, number_of_arguments, 0, ret_type_integral, retaddr);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void MacroAssembler::call_VM_leaf_base1(address entry_point,</span>
<span class="udiff-line-removed">-                                         int number_of_gp_arguments,</span>
<span class="udiff-line-removed">-                                         int number_of_fp_arguments,</span>
<span class="udiff-line-removed">-                                         ret_type type,</span>
<span class="udiff-line-removed">-                                         Label *retaddr) {</span>
    Label E, L;
  
    stp(rscratch1, rmethod, Address(pre(sp, -2 * wordSize)));
  
<span class="udiff-line-removed">-   // We add 1 to number_of_arguments because the thread in arg0 is</span>
<span class="udiff-line-removed">-   // not counted</span>
    mov(rscratch1, entry_point);
<span class="udiff-line-modified-removed">-   blrt(rscratch1, number_of_gp_arguments + 1, number_of_fp_arguments, type);</span>
<span class="udiff-line-modified-added">+   blr(rscratch1);</span>
    if (retaddr)
      bind(*retaddr);
  
    ldp(rscratch1, rmethod, Address(post(sp, 2 * wordSize)));
    maybe_isb();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1718,11 +1740,11 @@</span>
  
    // See if we can do this with two 12-bit offsets
    {
      unsigned long word_offset = byte_offset &gt;&gt; shift;
      unsigned long masked_offset = word_offset &amp; 0xfff000;
<span class="udiff-line-modified-removed">-     if (Address::offset_ok_for_immed(word_offset - masked_offset)</span>
<span class="udiff-line-modified-added">+     if (Address::offset_ok_for_immed(word_offset - masked_offset, 0)</span>
          &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(masked_offset &lt;&lt; shift)) {
        add(Rd, base, masked_offset &lt;&lt; shift);
        word_offset -= masked_offset;
        return Address(Rd, word_offset &lt;&lt; shift);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2109,19 +2131,78 @@</span>
  
    assert(words_pushed == count, &quot;oops, pushed != count&quot;);
  
    return count;
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Push lots of registers in the bit set supplied.  Don&#39;t push sp.</span>
<span class="udiff-line-added">+ // Return the number of words pushed</span>
<span class="udiff-line-added">+ int MacroAssembler::push_fp(unsigned int bitset, Register stack) {</span>
<span class="udiff-line-added">+   int words_pushed = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Scan bitset to accumulate register pairs</span>
<span class="udiff-line-added">+   unsigned char regs[32];</span>
<span class="udiff-line-added">+   int count = 0;</span>
<span class="udiff-line-added">+   for (int reg = 0; reg &lt;= 31; reg++) {</span>
<span class="udiff-line-added">+     if (1 &amp; bitset)</span>
<span class="udiff-line-added">+       regs[count++] = reg;</span>
<span class="udiff-line-added">+     bitset &gt;&gt;= 1;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   regs[count++] = zr-&gt;encoding_nocheck();</span>
<span class="udiff-line-added">+   count &amp;= ~1;  // Only push an even number of regs</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Always pushing full 128 bit registers.</span>
<span class="udiff-line-added">+   if (count) {</span>
<span class="udiff-line-added">+     stpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -count * wordSize * 2)));</span>
<span class="udiff-line-added">+     words_pushed += 2;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   for (int i = 2; i &lt; count; i += 2) {</span>
<span class="udiff-line-added">+     stpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));</span>
<span class="udiff-line-added">+     words_pushed += 2;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(words_pushed == count, &quot;oops, pushed != count&quot;);</span>
<span class="udiff-line-added">+   return count;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int MacroAssembler::pop_fp(unsigned int bitset, Register stack) {</span>
<span class="udiff-line-added">+   int words_pushed = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Scan bitset to accumulate register pairs</span>
<span class="udiff-line-added">+   unsigned char regs[32];</span>
<span class="udiff-line-added">+   int count = 0;</span>
<span class="udiff-line-added">+   for (int reg = 0; reg &lt;= 31; reg++) {</span>
<span class="udiff-line-added">+     if (1 &amp; bitset)</span>
<span class="udiff-line-added">+       regs[count++] = reg;</span>
<span class="udiff-line-added">+     bitset &gt;&gt;= 1;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   regs[count++] = zr-&gt;encoding_nocheck();</span>
<span class="udiff-line-added">+   count &amp;= ~1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int i = 2; i &lt; count; i += 2) {</span>
<span class="udiff-line-added">+     ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));</span>
<span class="udiff-line-added">+     words_pushed += 2;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (count) {</span>
<span class="udiff-line-added">+     ldpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, count * wordSize * 2)));</span>
<span class="udiff-line-added">+     words_pushed += 2;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(words_pushed == count, &quot;oops, pushed != count&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return count;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  #ifdef ASSERT
  void MacroAssembler::verify_heapbase(const char* msg) {
  #if 0
    assert (UseCompressedOops || UseCompressedClassPointers, &quot;should be compressed&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
    if (CheckCompressedOops) {
      Label ok;
      push(1 &lt;&lt; rscratch1-&gt;encoding(), sp); // cmpptr trashes rscratch1
<span class="udiff-line-modified-removed">-     cmpptr(rheapbase, ExternalAddress((address)Universe::narrow_ptrs_base_addr()));</span>
<span class="udiff-line-modified-added">+     cmpptr(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));</span>
      br(Assembler::EQ, ok);
      stop(msg);
      bind(ok);
      pop(1 &lt;&lt; rscratch1-&gt;encoding(), sp);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2154,20 +2235,19 @@</span>
    pusha();
    mov(c_rarg0, (address)msg);
    mov(c_rarg1, (address)ip);
    mov(c_rarg2, sp);
    mov(c_rarg3, CAST_FROM_FN_PTR(address, MacroAssembler::debug64));
<span class="udiff-line-modified-removed">-   // call(c_rarg3);</span>
<span class="udiff-line-removed">-   blrt(c_rarg3, 3, 0, 1);</span>
<span class="udiff-line-modified-added">+   blr(c_rarg3);</span>
    hlt(0);
  }
  
  void MacroAssembler::warn(const char* msg) {
    pusha();
    mov(c_rarg0, (address)msg);
    mov(lr, CAST_FROM_FN_PTR(address, warning));
<span class="udiff-line-modified-removed">-   blrt(lr, 1, 0, MacroAssembler::ret_type_void);</span>
<span class="udiff-line-modified-added">+   blr(lr);</span>
    popa();
  }
  
  void MacroAssembler::unimplemented(const char* what) {
    const char* buf = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2250,13 +2330,13 @@</span>
  
  void MacroAssembler::reinit_heapbase()
  {
    if (UseCompressedOops) {
      if (Universe::is_fully_initialized()) {
<span class="udiff-line-modified-removed">-       mov(rheapbase, Universe::narrow_ptrs_base());</span>
<span class="udiff-line-modified-added">+       mov(rheapbase, CompressedOops::ptrs_base());</span>
      } else {
<span class="udiff-line-modified-removed">-       lea(rheapbase, ExternalAddress((address)Universe::narrow_ptrs_base_addr()));</span>
<span class="udiff-line-modified-added">+       lea(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));</span>
        ldr(rheapbase, Address(rheapbase));
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2535,63 +2615,14 @@</span>
        tty-&gt;print_cr(&quot;r28 = 0x%016lx&quot;, regs[28]);
        tty-&gt;print_cr(&quot;r30 = 0x%016lx&quot;, regs[30]);
        tty-&gt;print_cr(&quot;r31 = 0x%016lx&quot;, regs[31]);
        BREAKPOINT;
      }
<span class="udiff-line-removed">-     ThreadStateTransition::transition(thread, _thread_in_vm, saved_state);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     ttyLocker ttyl;</span>
<span class="udiff-line-removed">-     ::tty-&gt;print_cr(&quot;=============== DEBUG MESSAGE: %s ================\n&quot;,</span>
<span class="udiff-line-removed">-                     msg);</span>
<span class="udiff-line-removed">-     assert(false, &quot;DEBUG MESSAGE: %s&quot;, msg);</span>
    }
<span class="udiff-line-added">+   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);</span>
  }
  
<span class="udiff-line-removed">- #ifdef BUILTIN_SIM</span>
<span class="udiff-line-removed">- // routine to generate an x86 prolog for a stub function which</span>
<span class="udiff-line-removed">- // bootstraps into the generated ARM code which directly follows the</span>
<span class="udiff-line-removed">- // stub</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // the argument encodes the number of general and fp registers</span>
<span class="udiff-line-removed">- // passed by the caller and the callng convention (currently just</span>
<span class="udiff-line-removed">- // the number of general registers and assumes C argument passing)</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- extern &quot;C&quot; {</span>
<span class="udiff-line-removed">- int aarch64_stub_prolog_size();</span>
<span class="udiff-line-removed">- void aarch64_stub_prolog();</span>
<span class="udiff-line-removed">- void aarch64_prolog();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void MacroAssembler::c_stub_prolog(int gp_arg_count, int fp_arg_count, int ret_type,</span>
<span class="udiff-line-removed">-                                    address *prolog_ptr)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   int calltype = (((ret_type &amp; 0x3) &lt;&lt; 8) |</span>
<span class="udiff-line-removed">-                   ((fp_arg_count &amp; 0xf) &lt;&lt; 4) |</span>
<span class="udiff-line-removed">-                   (gp_arg_count &amp; 0xf));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // the addresses for the x86 to ARM entry code we need to use</span>
<span class="udiff-line-removed">-   address start = pc();</span>
<span class="udiff-line-removed">-   // printf(&quot;start = %lx\n&quot;, start);</span>
<span class="udiff-line-removed">-   int byteCount =  aarch64_stub_prolog_size();</span>
<span class="udiff-line-removed">-   // printf(&quot;byteCount = %x\n&quot;, byteCount);</span>
<span class="udiff-line-removed">-   int instructionCount = (byteCount + 3)/ 4;</span>
<span class="udiff-line-removed">-   // printf(&quot;instructionCount = %x\n&quot;, instructionCount);</span>
<span class="udiff-line-removed">-   for (int i = 0; i &lt; instructionCount; i++) {</span>
<span class="udiff-line-removed">-     nop();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   memcpy(start, (void*)aarch64_stub_prolog, byteCount);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // write the address of the setup routine and the call format at the</span>
<span class="udiff-line-removed">-   // end of into the copied code</span>
<span class="udiff-line-removed">-   u_int64_t *patch_end = (u_int64_t *)(start + byteCount);</span>
<span class="udiff-line-removed">-   if (prolog_ptr)</span>
<span class="udiff-line-removed">-     patch_end[-2] = (u_int64_t)prolog_ptr;</span>
<span class="udiff-line-removed">-   patch_end[-1] = calltype;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  void MacroAssembler::push_call_clobbered_registers() {
    int step = 4 * wordSize;
    push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);
    sub(sp, sp, step);
    mov(rscratch1, -step);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2666,11 +2697,11 @@</span>
    //   Aligned - 12 bits unsigned offset shifted
    Register base = sp;
    if ((offset &amp; (size-1)) &amp;&amp; offset &gt;= (1&lt;&lt;8)) {
      add(tmp, base, offset &amp; ((1&lt;&lt;12)-1));
      base = tmp;
<span class="udiff-line-modified-removed">-     offset &amp;= -1&lt;&lt;12;</span>
<span class="udiff-line-modified-added">+     offset &amp;= -1u&lt;&lt;12;</span>
    }
  
    if (offset &gt;= (1&lt;&lt;12) * size) {
      add(tmp, base, offset &amp; (((1&lt;&lt;12)-1)&lt;&lt;12));
      base = tmp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3668,10 +3699,16 @@</span>
  void MacroAssembler::cmpoop(Register obj1, Register obj2) {
    BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
    bs-&gt;obj_equals(this, obj1, obj2);
  }
  
<span class="udiff-line-added">+ void MacroAssembler::load_method_holder(Register holder, Register method) {</span>
<span class="udiff-line-added">+   ldr(holder, Address(method, Method::const_offset()));                      // ConstMethod*</span>
<span class="udiff-line-added">+   ldr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*</span>
<span class="udiff-line-added">+   ldr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void MacroAssembler::load_klass(Register dst, Register src) {
    if (UseCompressedClassPointers) {
      ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));
      decode_klass_not_null(dst);
    } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3695,15 +3732,15 @@</span>
  }
  
  void MacroAssembler::cmp_klass(Register oop, Register trial_klass, Register tmp) {
    if (UseCompressedClassPointers) {
      ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));
<span class="udiff-line-modified-removed">-     if (Universe::narrow_klass_base() == NULL) {</span>
<span class="udiff-line-modified-removed">-       cmp(trial_klass, tmp, LSL, Universe::narrow_klass_shift());</span>
<span class="udiff-line-modified-added">+     if (CompressedKlassPointers::base() == NULL) {</span>
<span class="udiff-line-modified-added">+       cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());</span>
        return;
<span class="udiff-line-modified-removed">-     } else if (((uint64_t)Universe::narrow_klass_base() &amp; 0xffffffff) == 0</span>
<span class="udiff-line-modified-removed">-                &amp;&amp; Universe::narrow_klass_shift() == 0) {</span>
<span class="udiff-line-modified-added">+     } else if (((uint64_t)CompressedKlassPointers::base() &amp; 0xffffffff) == 0</span>
<span class="udiff-line-modified-added">+                &amp;&amp; CompressedKlassPointers::shift() == 0) {</span>
        // Only the bottom 32 bits matter
        cmpw(trial_klass, tmp);
        return;
      }
      decode_klass_not_null(tmp);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3740,13 +3777,13 @@</span>
  void MacroAssembler::encode_heap_oop(Register d, Register s) {
  #ifdef ASSERT
    verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
  #endif
    verify_oop(s, &quot;broken oop in encode_heap_oop&quot;);
<span class="udiff-line-modified-removed">-   if (Universe::narrow_oop_base() == NULL) {</span>
<span class="udiff-line-modified-removed">-     if (Universe::narrow_oop_shift() != 0) {</span>
<span class="udiff-line-modified-removed">-       assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
<span class="udiff-line-modified-added">+   if (CompressedOops::base() == NULL) {</span>
<span class="udiff-line-modified-added">+     if (CompressedOops::shift() != 0) {</span>
<span class="udiff-line-modified-added">+       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);</span>
        lsr(d, s, LogMinObjAlignmentInBytes);
      } else {
        mov(d, s);
      }
    } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3773,15 +3810,15 @@</span>
      stop(&quot;null oop passed to encode_heap_oop_not_null&quot;);
      bind(ok);
    }
  #endif
    verify_oop(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
<span class="udiff-line-modified-removed">-   if (Universe::narrow_oop_base() != NULL) {</span>
<span class="udiff-line-modified-added">+   if (CompressedOops::base() != NULL) {</span>
      sub(r, r, rheapbase);
    }
<span class="udiff-line-modified-removed">-   if (Universe::narrow_oop_shift() != 0) {</span>
<span class="udiff-line-modified-removed">-     assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
<span class="udiff-line-modified-added">+   if (CompressedOops::shift() != 0) {</span>
<span class="udiff-line-modified-added">+     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);</span>
      lsr(r, r, LogMinObjAlignmentInBytes);
    }
  }
  
  void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3795,16 +3832,16 @@</span>
    }
  #endif
    verify_oop(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
  
    Register data = src;
<span class="udiff-line-modified-removed">-   if (Universe::narrow_oop_base() != NULL) {</span>
<span class="udiff-line-modified-added">+   if (CompressedOops::base() != NULL) {</span>
      sub(dst, src, rheapbase);
      data = dst;
    }
<span class="udiff-line-modified-removed">-   if (Universe::narrow_oop_shift() != 0) {</span>
<span class="udiff-line-modified-removed">-     assert (LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
<span class="udiff-line-modified-added">+   if (CompressedOops::shift() != 0) {</span>
<span class="udiff-line-modified-added">+     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);</span>
      lsr(dst, data, LogMinObjAlignmentInBytes);
      data = dst;
    }
    if (data == src)
      mov(dst, src);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3812,13 +3849,13 @@</span>
  
  void  MacroAssembler::decode_heap_oop(Register d, Register s) {
  #ifdef ASSERT
    verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
  #endif
<span class="udiff-line-modified-removed">-   if (Universe::narrow_oop_base() == NULL) {</span>
<span class="udiff-line-modified-removed">-     if (Universe::narrow_oop_shift() != 0 || d != s) {</span>
<span class="udiff-line-modified-removed">-       lsl(d, s, Universe::narrow_oop_shift());</span>
<span class="udiff-line-modified-added">+   if (CompressedOops::base() == NULL) {</span>
<span class="udiff-line-modified-added">+     if (CompressedOops::shift() != 0 || d != s) {</span>
<span class="udiff-line-modified-added">+       lsl(d, s, CompressedOops::shift());</span>
      }
    } else {
      Label done;
      if (d != s)
        mov(d, s);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3833,133 +3870,153 @@</span>
    assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
    // Cannot assert, unverified entry point counts instructions (see .ad file)
    // vtableStubs also counts instructions in pd_code_size_limit.
    // Also do not verify_oop as this is called by verify_oop.
<span class="udiff-line-modified-removed">-   if (Universe::narrow_oop_shift() != 0) {</span>
<span class="udiff-line-modified-removed">-     assert(LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
<span class="udiff-line-modified-removed">-     if (Universe::narrow_oop_base() != NULL) {</span>
<span class="udiff-line-modified-added">+   if (CompressedOops::shift() != 0) {</span>
<span class="udiff-line-modified-added">+     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);</span>
<span class="udiff-line-modified-added">+     if (CompressedOops::base() != NULL) {</span>
        add(r, rheapbase, r, Assembler::LSL, LogMinObjAlignmentInBytes);
      } else {
        add(r, zr, r, Assembler::LSL, LogMinObjAlignmentInBytes);
      }
    } else {
<span class="udiff-line-modified-removed">-     assert (Universe::narrow_oop_base() == NULL, &quot;sanity&quot;);</span>
<span class="udiff-line-modified-added">+     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);</span>
    }
  }
  
  void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
    assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
    assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
    // Cannot assert, unverified entry point counts instructions (see .ad file)
    // vtableStubs also counts instructions in pd_code_size_limit.
    // Also do not verify_oop as this is called by verify_oop.
<span class="udiff-line-modified-removed">-   if (Universe::narrow_oop_shift() != 0) {</span>
<span class="udiff-line-modified-removed">-     assert(LogMinObjAlignmentInBytes == Universe::narrow_oop_shift(), &quot;decode alg wrong&quot;);</span>
<span class="udiff-line-modified-removed">-     if (Universe::narrow_oop_base() != NULL) {</span>
<span class="udiff-line-modified-added">+   if (CompressedOops::shift() != 0) {</span>
<span class="udiff-line-modified-added">+     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);</span>
<span class="udiff-line-modified-added">+     if (CompressedOops::base() != NULL) {</span>
        add(dst, rheapbase, src, Assembler::LSL, LogMinObjAlignmentInBytes);
      } else {
        add(dst, zr, src, Assembler::LSL, LogMinObjAlignmentInBytes);
      }
    } else {
<span class="udiff-line-modified-removed">-     assert (Universe::narrow_oop_base() == NULL, &quot;sanity&quot;);</span>
<span class="udiff-line-modified-added">+     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);</span>
      if (dst != src) {
        mov(dst, src);
      }
    }
  }
  
<span class="udiff-line-added">+ MacroAssembler::KlassDecodeMode MacroAssembler::_klass_decode_mode(KlassDecodeNone);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ MacroAssembler::KlassDecodeMode MacroAssembler::klass_decode_mode() {</span>
<span class="udiff-line-added">+   assert(UseCompressedClassPointers, &quot;not using compressed class pointers&quot;);</span>
<span class="udiff-line-added">+   assert(Metaspace::initialized(), &quot;metaspace not initialized yet&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (_klass_decode_mode != KlassDecodeNone) {</span>
<span class="udiff-line-added">+     return _klass_decode_mode;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift()</span>
<span class="udiff-line-added">+          || 0 == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (CompressedKlassPointers::base() == NULL) {</span>
<span class="udiff-line-added">+     return (_klass_decode_mode = KlassDecodeZero);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (operand_valid_for_logical_immediate(</span>
<span class="udiff-line-added">+         /*is32*/false, (uint64_t)CompressedKlassPointers::base())) {</span>
<span class="udiff-line-added">+     const uint64_t range_mask =</span>
<span class="udiff-line-added">+       (1UL &lt;&lt; log2_intptr(CompressedKlassPointers::range())) - 1;</span>
<span class="udiff-line-added">+     if (((uint64_t)CompressedKlassPointers::base() &amp; range_mask) == 0) {</span>
<span class="udiff-line-added">+       return (_klass_decode_mode = KlassDecodeXor);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const uint64_t shifted_base =</span>
<span class="udiff-line-added">+     (uint64_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift();</span>
<span class="udiff-line-added">+   guarantee((shifted_base &amp; 0xffff0000ffffffff) == 0,</span>
<span class="udiff-line-added">+             &quot;compressed class base bad alignment&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return (_klass_decode_mode = KlassDecodeMovk);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
<span class="udiff-line-modified-removed">-   if (Universe::narrow_klass_base() == NULL) {</span>
<span class="udiff-line-modified-removed">-     if (Universe::narrow_klass_shift() != 0) {</span>
<span class="udiff-line-modified-removed">-       assert (LogKlassAlignmentInBytes == Universe::narrow_klass_shift(), &quot;decode alg wrong&quot;);</span>
<span class="udiff-line-modified-added">+   switch (klass_decode_mode()) {</span>
<span class="udiff-line-modified-added">+   case KlassDecodeZero:</span>
<span class="udiff-line-modified-added">+     if (CompressedKlassPointers::shift() != 0) {</span>
        lsr(dst, src, LogKlassAlignmentInBytes);
      } else {
        if (dst != src) mov(dst, src);
      }
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+     break;</span>
  
<span class="udiff-line-modified-removed">-   if (use_XOR_for_compressed_class_base) {</span>
<span class="udiff-line-modified-removed">-     if (Universe::narrow_klass_shift() != 0) {</span>
<span class="udiff-line-modified-removed">-       eor(dst, src, (uint64_t)Universe::narrow_klass_base());</span>
<span class="udiff-line-modified-added">+   case KlassDecodeXor:</span>
<span class="udiff-line-modified-added">+     if (CompressedKlassPointers::shift() != 0) {</span>
<span class="udiff-line-modified-added">+       eor(dst, src, (uint64_t)CompressedKlassPointers::base());</span>
        lsr(dst, dst, LogKlassAlignmentInBytes);
      } else {
<span class="udiff-line-modified-removed">-       eor(dst, src, (uint64_t)Universe::narrow_klass_base());</span>
<span class="udiff-line-modified-added">+       eor(dst, src, (uint64_t)CompressedKlassPointers::base());</span>
      }
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (((uint64_t)Universe::narrow_klass_base() &amp; 0xffffffff) == 0</span>
<span class="udiff-line-removed">-       &amp;&amp; Universe::narrow_klass_shift() == 0) {</span>
<span class="udiff-line-removed">-     movw(dst, src);</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+     break;</span>
  
<span class="udiff-line-modified-removed">- #ifdef ASSERT</span>
<span class="udiff-line-modified-removed">-   verify_heapbase(&quot;MacroAssembler::encode_klass_not_null2: heap base corrupted?&quot;);</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+   case KlassDecodeMovk:</span>
<span class="udiff-line-modified-added">+     if (CompressedKlassPointers::shift() != 0) {</span>
<span class="udiff-line-modified-added">+       ubfx(dst, src, LogKlassAlignmentInBytes, 32);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       movw(dst, src);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     break;</span>
  
<span class="udiff-line-modified-removed">-   Register rbase = dst;</span>
<span class="udiff-line-modified-removed">-   if (dst == src) rbase = rheapbase;</span>
<span class="udiff-line-modified-removed">-   mov(rbase, (uint64_t)Universe::narrow_klass_base());</span>
<span class="udiff-line-removed">-   sub(dst, src, rbase);</span>
<span class="udiff-line-removed">-   if (Universe::narrow_klass_shift() != 0) {</span>
<span class="udiff-line-removed">-     assert (LogKlassAlignmentInBytes == Universe::narrow_klass_shift(), &quot;decode alg wrong&quot;);</span>
<span class="udiff-line-removed">-     lsr(dst, dst, LogKlassAlignmentInBytes);</span>
<span class="udiff-line-modified-added">+   case KlassDecodeNone:</span>
<span class="udiff-line-modified-added">+     ShouldNotReachHere();</span>
<span class="udiff-line-modified-added">+     break;</span>
    }
<span class="udiff-line-removed">-   if (dst == src) reinit_heapbase();</span>
  }
  
  void MacroAssembler::encode_klass_not_null(Register r) {
    encode_klass_not_null(r, r);
  }
  
  void  MacroAssembler::decode_klass_not_null(Register dst, Register src) {
<span class="udiff-line-removed">-   Register rbase = dst;</span>
    assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
  
<span class="udiff-line-modified-removed">-   if (Universe::narrow_klass_base() == NULL) {</span>
<span class="udiff-line-modified-removed">-     if (Universe::narrow_klass_shift() != 0) {</span>
<span class="udiff-line-modified-removed">-       assert(LogKlassAlignmentInBytes == Universe::narrow_klass_shift(), &quot;decode alg wrong&quot;);</span>
<span class="udiff-line-modified-added">+   switch (klass_decode_mode()) {</span>
<span class="udiff-line-modified-added">+   case KlassDecodeZero:</span>
<span class="udiff-line-modified-added">+     if (CompressedKlassPointers::shift() != 0) {</span>
        lsl(dst, src, LogKlassAlignmentInBytes);
      } else {
        if (dst != src) mov(dst, src);
      }
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+     break;</span>
  
<span class="udiff-line-modified-removed">-   if (use_XOR_for_compressed_class_base) {</span>
<span class="udiff-line-modified-removed">-     if (Universe::narrow_klass_shift() != 0) {</span>
<span class="udiff-line-modified-added">+   case KlassDecodeXor:</span>
<span class="udiff-line-modified-added">+     if (CompressedKlassPointers::shift() != 0) {</span>
        lsl(dst, src, LogKlassAlignmentInBytes);
<span class="udiff-line-modified-removed">-       eor(dst, dst, (uint64_t)Universe::narrow_klass_base());</span>
<span class="udiff-line-modified-added">+       eor(dst, dst, (uint64_t)CompressedKlassPointers::base());</span>
      } else {
<span class="udiff-line-modified-removed">-       eor(dst, src, (uint64_t)Universe::narrow_klass_base());</span>
<span class="udiff-line-modified-added">+       eor(dst, src, (uint64_t)CompressedKlassPointers::base());</span>
      }
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+     break;</span>
  
<span class="udiff-line-modified-removed">-   if (((uint64_t)Universe::narrow_klass_base() &amp; 0xffffffff) == 0</span>
<span class="udiff-line-modified-removed">-       &amp;&amp; Universe::narrow_klass_shift() == 0) {</span>
<span class="udiff-line-modified-removed">-     if (dst != src)</span>
<span class="udiff-line-modified-removed">-       movw(dst, src);</span>
<span class="udiff-line-modified-removed">-     movk(dst, (uint64_t)Universe::narrow_klass_base() &gt;&gt; 32, 32);</span>
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-added">+   case KlassDecodeMovk: {</span>
<span class="udiff-line-modified-added">+     const uint64_t shifted_base =</span>
<span class="udiff-line-modified-added">+       (uint64_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     if (dst != src) movw(dst, src);</span>
<span class="udiff-line-modified-added">+     movk(dst, shifted_base &gt;&gt; 32, 32);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (CompressedKlassPointers::shift() != 0) {</span>
<span class="udiff-line-added">+       lsl(dst, dst, LogKlassAlignmentInBytes);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     break;</span>
    }
  
<span class="udiff-line-modified-removed">-   // Cannot assert, unverified entry point counts instructions (see .ad file)</span>
<span class="udiff-line-modified-removed">-   // vtableStubs also counts instructions in pd_code_size_limit.</span>
<span class="udiff-line-modified-removed">-   // Also do not verify_oop as this is called by verify_oop.</span>
<span class="udiff-line-removed">-   if (dst == src) rbase = rheapbase;</span>
<span class="udiff-line-removed">-   mov(rbase, (uint64_t)Universe::narrow_klass_base());</span>
<span class="udiff-line-removed">-   if (Universe::narrow_klass_shift() != 0) {</span>
<span class="udiff-line-removed">-     assert(LogKlassAlignmentInBytes == Universe::narrow_klass_shift(), &quot;decode alg wrong&quot;);</span>
<span class="udiff-line-removed">-     add(dst, rbase, src, Assembler::LSL, LogKlassAlignmentInBytes);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     add(dst, rbase, src);</span>
<span class="udiff-line-modified-added">+   case KlassDecodeNone:</span>
<span class="udiff-line-modified-added">+     ShouldNotReachHere();</span>
<span class="udiff-line-modified-added">+     break;</span>
    }
<span class="udiff-line-removed">-   if (dst == src) reinit_heapbase();</span>
  }
  
  void  MacroAssembler::decode_klass_not_null(Register r) {
    decode_klass_not_null(r, r);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3969,11 +4026,11 @@</span>
    {
      ThreadInVMfromUnknown tiv;
      assert (UseCompressedOops, &quot;should only be used for compressed oops&quot;);
      assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
      assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
<span class="udiff-line-modified-removed">-     assert(Universe::heap()-&gt;is_in_reserved(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);</span>
<span class="udiff-line-modified-added">+     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);</span>
    }
  #endif
    int oop_index = oop_recorder()-&gt;find_index(obj);
    InstructionMark im(this);
    RelocationHolder rspec = oop_Relocation::spec(oop_index);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3984,16 +4041,16 @@</span>
  
  void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
    assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
    assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
    int index = oop_recorder()-&gt;find_index(k);
<span class="udiff-line-modified-removed">-   assert(! Universe::heap()-&gt;is_in_reserved(k), &quot;should not be an oop&quot;);</span>
<span class="udiff-line-modified-added">+   assert(! Universe::heap()-&gt;is_in(k), &quot;should not be an oop&quot;);</span>
  
    InstructionMark im(this);
    RelocationHolder rspec = metadata_Relocation::spec(index);
    code_section()-&gt;relocate(inst_mark(), rspec);
<span class="udiff-line-modified-removed">-   narrowKlass nk = Klass::encode_klass(k);</span>
<span class="udiff-line-modified-added">+   narrowKlass nk = CompressedKlassPointers::encode(k);</span>
    movz(dst, (nk &gt;&gt; 16), 16);
    movk(dst, nk &amp; 0xffff);
  }
  
  void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4068,11 +4125,11 @@</span>
      oop_index = oop_recorder()-&gt;allocate_oop_index(obj);
    } else {
  #ifdef ASSERT
      {
        ThreadInVMfromUnknown tiv;
<span class="udiff-line-modified-removed">-       assert(Universe::heap()-&gt;is_in_reserved(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);</span>
<span class="udiff-line-modified-added">+       assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);</span>
      }
  #endif
      oop_index = oop_recorder()-&gt;find_index(obj);
    }
    RelocationHolder rspec = oop_Relocation::spec(oop_index);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4098,11 +4155,11 @@</span>
  Address MacroAssembler::constant_oop_address(jobject obj) {
  #ifdef ASSERT
    {
      ThreadInVMfromUnknown tiv;
      assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
<span class="udiff-line-modified-removed">-     assert(Universe::heap()-&gt;is_in_reserved(JNIHandles::resolve(obj)), &quot;not an oop&quot;);</span>
<span class="udiff-line-modified-added">+     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);</span>
    }
  #endif
    int oop_index = oop_recorder()-&gt;find_index(obj);
    return Address((address)obj, oop_Relocation::spec(oop_index));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4861,15 +4918,19 @@</span>
      FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3, int ae) {
    Label DONE, SHORT_LOOP, SHORT_STRING, SHORT_LAST, TAIL, STUB,
        DIFFERENCE, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,
        SHORT_LOOP_START, TAIL_CHECK;
  
<span class="udiff-line-removed">-   const u1 STUB_THRESHOLD = 64 + 8;</span>
    bool isLL = ae == StrIntrinsicNode::LL;
    bool isLU = ae == StrIntrinsicNode::LU;
    bool isUL = ae == StrIntrinsicNode::UL;
  
<span class="udiff-line-added">+   // The stub threshold for LL strings is: 72 (64 + 8) chars</span>
<span class="udiff-line-added">+   // UU: 36 chars, or 72 bytes (valid for the 64-byte large loop with prefetch)</span>
<span class="udiff-line-added">+   // LU/UL: 24 chars, or 48 bytes (valid for the 16-character loop at least)</span>
<span class="udiff-line-added">+   const u1 stub_threshold = isLL ? 72 : ((isLU || isUL) ? 24 : 36);</span>
<span class="udiff-line-added">+ </span>
    bool str1_isL = isLL || isLU;
    bool str2_isL = isLL || isUL;
  
    int str1_chr_shift = str1_isL ? 0 : 1;
    int str2_chr_shift = str2_isL ? 0 : 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4906,23 +4967,21 @@</span>
      if (str1_isL == str2_isL) { // LL or UU
        ldr(tmp1, Address(str1));
        cmp(str1, str2);
        br(Assembler::EQ, DONE);
        ldr(tmp2, Address(str2));
<span class="udiff-line-modified-removed">-       cmp(cnt2, STUB_THRESHOLD);</span>
<span class="udiff-line-modified-added">+       cmp(cnt2, stub_threshold);</span>
        br(GE, STUB);
        subsw(cnt2, cnt2, minCharsInWord);
        br(EQ, TAIL_CHECK);
        lea(str2, Address(str2, cnt2, Address::uxtw(str2_chr_shift)));
        lea(str1, Address(str1, cnt2, Address::uxtw(str1_chr_shift)));
        sub(cnt2, zr, cnt2, LSL, str2_chr_shift);
      } else if (isLU) {
        ldrs(vtmp, Address(str1));
<span class="udiff-line-removed">-       cmp(str1, str2);</span>
<span class="udiff-line-removed">-       br(Assembler::EQ, DONE);</span>
        ldr(tmp2, Address(str2));
<span class="udiff-line-modified-removed">-       cmp(cnt2, STUB_THRESHOLD);</span>
<span class="udiff-line-modified-added">+       cmp(cnt2, stub_threshold);</span>
        br(GE, STUB);
        subw(cnt2, cnt2, 4);
        eor(vtmpZ, T16B, vtmpZ, vtmpZ);
        lea(str1, Address(str1, cnt2, Address::uxtw(str1_chr_shift)));
        lea(str2, Address(str2, cnt2, Address::uxtw(str2_chr_shift)));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4931,14 +4990,12 @@</span>
        sub(cnt2, zr, cnt2, LSL, str2_chr_shift);
        add(cnt1, cnt1, 4);
        fmovd(tmp1, vtmp);
      } else { // UL case
        ldr(tmp1, Address(str1));
<span class="udiff-line-removed">-       cmp(str1, str2);</span>
<span class="udiff-line-removed">-       br(Assembler::EQ, DONE);</span>
        ldrs(vtmp, Address(str2));
<span class="udiff-line-modified-removed">-       cmp(cnt2, STUB_THRESHOLD);</span>
<span class="udiff-line-modified-added">+       cmp(cnt2, stub_threshold);</span>
        br(GE, STUB);
        subw(cnt2, cnt2, 4);
        lea(str1, Address(str1, cnt2, Address::uxtw(str1_chr_shift)));
        eor(vtmpZ, T16B, vtmpZ, vtmpZ);
        lea(str2, Address(str2, cnt2, Address::uxtw(str2_chr_shift)));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5628,11 +5685,10 @@</span>
          NEXT_32_START, NEXT_32_PRFM_START;
      Register tmp1 = rscratch1, tmp2 = rscratch2;
  
        mov(result, len); // Save initial len
  
<span class="udiff-line-removed">- #ifndef BUILTIN_SIM</span>
        cmp(len, (u1)8); // handle shortest strings first
        br(LT, LOOP_1);
        cmp(len, (u1)32);
        br(LT, NEXT_8);
        // The following code uses the SIMD &#39;uzp1&#39; and &#39;uzp2&#39; instructions
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5704,11 +5760,11 @@</span>
        add(src, src, 16);
        cmp(len, (u1)8);
        br(GE, NEXT_8);
  
      BIND(LOOP_1);
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ </span>
      cbz(len, DONE);
      BIND(NEXT_1);
        ldrh(tmp1, Address(post(src, 2)));
        tst(tmp1, 0xff00);
        br(NE, SET_RESULT);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5843,12 +5899,34 @@</span>
  void MacroAssembler::get_thread(Register dst) {
    RegSet saved_regs = RegSet::range(r0, r1) + lr - dst;
    push(saved_regs, sp);
  
    mov(lr, CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper));
<span class="udiff-line-modified-removed">-   blrt(lr, 1, 0, 1);</span>
<span class="udiff-line-modified-added">+   blr(lr);</span>
    if (dst != c_rarg0) {
      mov(dst, c_rarg0);
    }
  
    pop(saved_regs, sp);
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MacroAssembler::cache_wb(Address line) {</span>
<span class="udiff-line-added">+   assert(line.getMode() == Address::base_plus_offset, &quot;mode should be base_plus_offset&quot;);</span>
<span class="udiff-line-added">+   assert(line.index() == noreg, &quot;index should be noreg&quot;);</span>
<span class="udiff-line-added">+   assert(line.offset() == 0, &quot;offset should be 0&quot;);</span>
<span class="udiff-line-added">+   // would like to assert this</span>
<span class="udiff-line-added">+   // assert(line._ext.shift == 0, &quot;shift should be zero&quot;);</span>
<span class="udiff-line-added">+   if (VM_Version::supports_dcpop()) {</span>
<span class="udiff-line-added">+     // writeback using clear virtual address to point of persistence</span>
<span class="udiff-line-added">+     dc(Assembler::CVAP, line.base());</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // no need to generate anything as Unsafe.writebackMemory should</span>
<span class="udiff-line-added">+     // never invoke this stub</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MacroAssembler::cache_wbsync(bool is_pre) {</span>
<span class="udiff-line-added">+   // we only need a barrier post sync</span>
<span class="udiff-line-added">+   if (!is_pre) {</span>
<span class="udiff-line-added">+     membar(Assembler::AnyAny);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
</pre>
<center><a href="jvmciCodeInstaller_aarch64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
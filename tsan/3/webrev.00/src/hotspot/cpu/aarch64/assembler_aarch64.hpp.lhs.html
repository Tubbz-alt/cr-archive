<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/assembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2014, 2015, Red Hat Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_AARCH64_ASSEMBLER_AARCH64_HPP
  27 #define CPU_AARCH64_ASSEMBLER_AARCH64_HPP
  28 
  29 #include &quot;asm/register.hpp&quot;
  30 
  31 // definitions of various symbolic names for machine registers
  32 
  33 // First intercalls between C and Java which use 8 general registers
  34 // and 8 floating registers
  35 
  36 // we also have to copy between x86 and ARM registers but that&#39;s a
  37 // secondary complication -- not all code employing C call convention
  38 // executes as x86 code though -- we generate some of it
  39 
  40 class Argument {
  41  public:
  42   enum {
  43     n_int_register_parameters_c   = 8,  // r0, r1, ... r7 (c_rarg0, c_rarg1, ...)
  44     n_float_register_parameters_c = 8,  // v0, v1, ... v7 (c_farg0, c_farg1, ... )
  45 
  46     n_int_register_parameters_j   = 8, // r1, ... r7, r0 (rj_rarg0, j_rarg1, ...
  47     n_float_register_parameters_j = 8  // v0, v1, ... v7 (j_farg0, j_farg1, ...
  48   };
  49 };
  50 
  51 REGISTER_DECLARATION(Register, c_rarg0, r0);
  52 REGISTER_DECLARATION(Register, c_rarg1, r1);
  53 REGISTER_DECLARATION(Register, c_rarg2, r2);
  54 REGISTER_DECLARATION(Register, c_rarg3, r3);
  55 REGISTER_DECLARATION(Register, c_rarg4, r4);
  56 REGISTER_DECLARATION(Register, c_rarg5, r5);
  57 REGISTER_DECLARATION(Register, c_rarg6, r6);
  58 REGISTER_DECLARATION(Register, c_rarg7, r7);
  59 
  60 REGISTER_DECLARATION(FloatRegister, c_farg0, v0);
  61 REGISTER_DECLARATION(FloatRegister, c_farg1, v1);
  62 REGISTER_DECLARATION(FloatRegister, c_farg2, v2);
  63 REGISTER_DECLARATION(FloatRegister, c_farg3, v3);
  64 REGISTER_DECLARATION(FloatRegister, c_farg4, v4);
  65 REGISTER_DECLARATION(FloatRegister, c_farg5, v5);
  66 REGISTER_DECLARATION(FloatRegister, c_farg6, v6);
  67 REGISTER_DECLARATION(FloatRegister, c_farg7, v7);
  68 
  69 // Symbolically name the register arguments used by the Java calling convention.
  70 // We have control over the convention for java so we can do what we please.
  71 // What pleases us is to offset the java calling convention so that when
  72 // we call a suitable jni method the arguments are lined up and we don&#39;t
  73 // have to do much shuffling. A suitable jni method is non-static and a
  74 // small number of arguments
  75 //
  76 //  |--------------------------------------------------------------------|
  77 //  | c_rarg0  c_rarg1  c_rarg2 c_rarg3 c_rarg4 c_rarg5 c_rarg6 c_rarg7  |
  78 //  |--------------------------------------------------------------------|
  79 //  | r0       r1       r2      r3      r4      r5      r6      r7       |
  80 //  |--------------------------------------------------------------------|
  81 //  | j_rarg7  j_rarg0  j_rarg1 j_rarg2 j_rarg3 j_rarg4 j_rarg5 j_rarg6  |
  82 //  |--------------------------------------------------------------------|
  83 
  84 
  85 REGISTER_DECLARATION(Register, j_rarg0, c_rarg1);
  86 REGISTER_DECLARATION(Register, j_rarg1, c_rarg2);
  87 REGISTER_DECLARATION(Register, j_rarg2, c_rarg3);
  88 REGISTER_DECLARATION(Register, j_rarg3, c_rarg4);
  89 REGISTER_DECLARATION(Register, j_rarg4, c_rarg5);
  90 REGISTER_DECLARATION(Register, j_rarg5, c_rarg6);
  91 REGISTER_DECLARATION(Register, j_rarg6, c_rarg7);
  92 REGISTER_DECLARATION(Register, j_rarg7, c_rarg0);
  93 
  94 // Java floating args are passed as per C
  95 
  96 REGISTER_DECLARATION(FloatRegister, j_farg0, v0);
  97 REGISTER_DECLARATION(FloatRegister, j_farg1, v1);
  98 REGISTER_DECLARATION(FloatRegister, j_farg2, v2);
  99 REGISTER_DECLARATION(FloatRegister, j_farg3, v3);
 100 REGISTER_DECLARATION(FloatRegister, j_farg4, v4);
 101 REGISTER_DECLARATION(FloatRegister, j_farg5, v5);
 102 REGISTER_DECLARATION(FloatRegister, j_farg6, v6);
 103 REGISTER_DECLARATION(FloatRegister, j_farg7, v7);
 104 
 105 // registers used to hold VM data either temporarily within a method
 106 // or across method calls
 107 
 108 // volatile (caller-save) registers
 109 
 110 // r8 is used for indirect result location return
 111 // we use it and r9 as scratch registers
 112 REGISTER_DECLARATION(Register, rscratch1, r8);
 113 REGISTER_DECLARATION(Register, rscratch2, r9);
 114 
 115 // current method -- must be in a call-clobbered register
 116 REGISTER_DECLARATION(Register, rmethod,   r12);
 117 
 118 // non-volatile (callee-save) registers are r16-29
 119 // of which the following are dedicated global state
 120 
 121 // link register
 122 REGISTER_DECLARATION(Register, lr,        r30);
 123 // frame pointer
 124 REGISTER_DECLARATION(Register, rfp,       r29);
 125 // current thread
 126 REGISTER_DECLARATION(Register, rthread,   r28);
 127 // base of heap
 128 REGISTER_DECLARATION(Register, rheapbase, r27);
 129 // constant pool cache
 130 REGISTER_DECLARATION(Register, rcpool,    r26);
 131 // monitors allocated on stack
 132 REGISTER_DECLARATION(Register, rmonitors, r25);
 133 // locals on stack
 134 REGISTER_DECLARATION(Register, rlocals,   r24);
 135 // bytecode pointer
 136 REGISTER_DECLARATION(Register, rbcp,      r22);
 137 // Dispatch table base
 138 REGISTER_DECLARATION(Register, rdispatch, r21);
 139 // Java stack pointer
 140 REGISTER_DECLARATION(Register, esp,      r20);
 141 
 142 #define assert_cond(ARG1) assert(ARG1, #ARG1)
 143 
 144 namespace asm_util {
 145   uint32_t encode_logical_immediate(bool is32, uint64_t imm);
 146 };
 147 
 148 using namespace asm_util;
 149 
 150 
 151 class Assembler;
 152 
 153 class Instruction_aarch64 {
 154   unsigned insn;
 155 #ifdef ASSERT
 156   unsigned bits;
 157 #endif
 158   Assembler *assem;
 159 
 160 public:
 161 
 162   Instruction_aarch64(class Assembler *as) {
 163 #ifdef ASSERT
 164     bits = 0;
 165 #endif
 166     insn = 0;
 167     assem = as;
 168   }
 169 
 170   inline ~Instruction_aarch64();
 171 
 172   unsigned &amp;get_insn() { return insn; }
 173 #ifdef ASSERT
 174   unsigned &amp;get_bits() { return bits; }
 175 #endif
 176 
 177   static inline int32_t extend(unsigned val, int hi = 31, int lo = 0) {
 178     union {
 179       unsigned u;
 180       int n;
 181     };
 182 
 183     u = val &lt;&lt; (31 - hi);
 184     n = n &gt;&gt; (31 - hi + lo);
 185     return n;
 186   }
 187 
 188   static inline uint32_t extract(uint32_t val, int msb, int lsb) {
 189     int nbits = msb - lsb + 1;
 190     assert_cond(msb &gt;= lsb);
 191     uint32_t mask = (1U &lt;&lt; nbits) - 1;
 192     uint32_t result = val &gt;&gt; lsb;
 193     result &amp;= mask;
 194     return result;
 195   }
 196 
 197   static inline int32_t sextract(uint32_t val, int msb, int lsb) {
 198     uint32_t uval = extract(val, msb, lsb);
 199     return extend(uval, msb - lsb);
 200   }
 201 
 202   static void patch(address a, int msb, int lsb, unsigned long val) {
 203     int nbits = msb - lsb + 1;
 204     guarantee(val &lt; (1U &lt;&lt; nbits), &quot;Field too big for insn&quot;);
 205     assert_cond(msb &gt;= lsb);
 206     unsigned mask = (1U &lt;&lt; nbits) - 1;
 207     val &lt;&lt;= lsb;
 208     mask &lt;&lt;= lsb;
 209     unsigned target = *(unsigned *)a;
 210     target &amp;= ~mask;
 211     target |= val;
 212     *(unsigned *)a = target;
 213   }
 214 
 215   static void spatch(address a, int msb, int lsb, long val) {
 216     int nbits = msb - lsb + 1;
 217     long chk = val &gt;&gt; (nbits - 1);
 218     guarantee (chk == -1 || chk == 0, &quot;Field too big for insn&quot;);
 219     unsigned uval = val;
 220     unsigned mask = (1U &lt;&lt; nbits) - 1;
 221     uval &amp;= mask;
 222     uval &lt;&lt;= lsb;
 223     mask &lt;&lt;= lsb;
 224     unsigned target = *(unsigned *)a;
 225     target &amp;= ~mask;
 226     target |= uval;
 227     *(unsigned *)a = target;
 228   }
 229 
 230   void f(unsigned val, int msb, int lsb) {
 231     int nbits = msb - lsb + 1;
 232     guarantee(val &lt; (1U &lt;&lt; nbits), &quot;Field too big for insn&quot;);
 233     assert_cond(msb &gt;= lsb);
 234     unsigned mask = (1U &lt;&lt; nbits) - 1;
 235     val &lt;&lt;= lsb;
 236     mask &lt;&lt;= lsb;
 237     insn |= val;
 238     assert_cond((bits &amp; mask) == 0);
 239 #ifdef ASSERT
 240     bits |= mask;
 241 #endif
 242   }
 243 
 244   void f(unsigned val, int bit) {
 245     f(val, bit, bit);
 246   }
 247 
 248   void sf(long val, int msb, int lsb) {
 249     int nbits = msb - lsb + 1;
 250     long chk = val &gt;&gt; (nbits - 1);
 251     guarantee (chk == -1 || chk == 0, &quot;Field too big for insn&quot;);
 252     unsigned uval = val;
 253     unsigned mask = (1U &lt;&lt; nbits) - 1;
 254     uval &amp;= mask;
 255     f(uval, lsb + nbits - 1, lsb);
 256   }
 257 
 258   void rf(Register r, int lsb) {
 259     f(r-&gt;encoding_nocheck(), lsb + 4, lsb);
 260   }
 261 
 262   // reg|ZR
 263   void zrf(Register r, int lsb) {
 264     f(r-&gt;encoding_nocheck() - (r == zr), lsb + 4, lsb);
 265   }
 266 
 267   // reg|SP
 268   void srf(Register r, int lsb) {
 269     f(r == sp ? 31 : r-&gt;encoding_nocheck(), lsb + 4, lsb);
 270   }
 271 
 272   void rf(FloatRegister r, int lsb) {
 273     f(r-&gt;encoding_nocheck(), lsb + 4, lsb);
 274   }
 275 
 276   unsigned get(int msb = 31, int lsb = 0) {
 277     int nbits = msb - lsb + 1;
 278     unsigned mask = ((1U &lt;&lt; nbits) - 1) &lt;&lt; lsb;
<a name="2" id="anc2"></a><span class="line-modified"> 279     assert_cond(bits &amp; mask == mask);</span>
 280     return (insn &amp; mask) &gt;&gt; lsb;
 281   }
 282 
 283   void fixed(unsigned value, unsigned mask) {
 284     assert_cond ((mask &amp; bits) == 0);
 285 #ifdef ASSERT
 286     bits |= mask;
 287 #endif
 288     insn |= value;
 289   }
 290 };
 291 
 292 #define starti Instruction_aarch64 do_not_use(this); set_current(&amp;do_not_use)
 293 
 294 class PrePost {
 295   int _offset;
 296   Register _r;
 297 public:
 298   PrePost(Register reg, int o) : _offset(o), _r(reg) { }
 299   int offset() { return _offset; }
 300   Register reg() { return _r; }
 301 };
 302 
 303 class Pre : public PrePost {
 304 public:
 305   Pre(Register reg, int o) : PrePost(reg, o) { }
 306 };
 307 class Post : public PrePost {
 308   Register _idx;
<a name="3" id="anc3"></a>
 309 public:
<a name="4" id="anc4"></a><span class="line-modified"> 310   Post(Register reg, int o) : PrePost(reg, o) { _idx = NULL; }</span>
<span class="line-modified"> 311   Post(Register reg, Register idx) : PrePost(reg, 0) { _idx = idx; }</span>
 312   Register idx_reg() { return _idx; }
<a name="5" id="anc5"></a>
 313 };
 314 
 315 namespace ext
 316 {
 317   enum operation { uxtb, uxth, uxtw, uxtx, sxtb, sxth, sxtw, sxtx };
 318 };
 319 
 320 // Addressing modes
 321 class Address {
 322  public:
 323 
 324   enum mode { no_mode, base_plus_offset, pre, post, post_reg, pcrel,
 325               base_plus_offset_reg, literal };
 326 
 327   // Shift and extend for base reg + reg offset addressing
 328   class extend {
 329     int _option, _shift;
 330     ext::operation _op;
 331   public:
 332     extend() { }
 333     extend(int s, int o, ext::operation op) : _option(o), _shift(s), _op(op) { }
 334     int option() const{ return _option; }
 335     int shift() const { return _shift; }
 336     ext::operation op() const { return _op; }
 337   };
 338   class uxtw : public extend {
 339   public:
 340     uxtw(int shift = -1): extend(shift, 0b010, ext::uxtw) { }
 341   };
 342   class lsl : public extend {
 343   public:
 344     lsl(int shift = -1): extend(shift, 0b011, ext::uxtx) { }
 345   };
 346   class sxtw : public extend {
 347   public:
 348     sxtw(int shift = -1): extend(shift, 0b110, ext::sxtw) { }
 349   };
 350   class sxtx : public extend {
 351   public:
 352     sxtx(int shift = -1): extend(shift, 0b111, ext::sxtx) { }
 353   };
 354 
 355  private:
 356   Register _base;
 357   Register _index;
 358   long _offset;
 359   enum mode _mode;
 360   extend _ext;
 361 
 362   RelocationHolder _rspec;
 363 
 364   // Typically we use AddressLiterals we want to use their rval
 365   // However in some situations we want the lval (effect address) of
 366   // the item.  We provide a special factory for making those lvals.
 367   bool _is_lval;
 368 
 369   // If the target is far we&#39;ll need to load the ea of this to a
 370   // register to reach it. Otherwise if near we can do PC-relative
 371   // addressing.
 372   address          _target;
 373 
 374  public:
 375   Address()
 376     : _mode(no_mode) { }
 377   Address(Register r)
 378     : _base(r), _index(noreg), _offset(0), _mode(base_plus_offset), _target(0) { }
 379   Address(Register r, int o)
 380     : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }
 381   Address(Register r, long o)
 382     : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }
 383   Address(Register r, unsigned long o)
 384     : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }
 385 #ifdef ASSERT
 386   Address(Register r, ByteSize disp)
 387     : _base(r), _index(noreg), _offset(in_bytes(disp)), _mode(base_plus_offset), _target(0) { }
 388 #endif
 389   Address(Register r, Register r1, extend ext = lsl())
 390     : _base(r), _index(r1), _offset(0), _mode(base_plus_offset_reg),
 391       _ext(ext), _target(0) { }
 392   Address(Pre p)
 393     : _base(p.reg()), _offset(p.offset()), _mode(pre) { }
 394   Address(Post p)
 395     : _base(p.reg()),  _index(p.idx_reg()), _offset(p.offset()),
<a name="6" id="anc6"></a><span class="line-modified"> 396       _mode(p.idx_reg() == NULL ? post : post_reg), _target(0) { }</span>
 397   Address(address target, RelocationHolder const&amp; rspec)
 398     : _mode(literal),
 399       _rspec(rspec),
 400       _is_lval(false),
 401       _target(target)  { }
 402   Address(address target, relocInfo::relocType rtype = relocInfo::external_word_type);
 403   Address(Register base, RegisterOrConstant index, extend ext = lsl())
 404     : _base (base),
 405       _offset(0), _ext(ext), _target(0) {
 406     if (index.is_register()) {
 407       _mode = base_plus_offset_reg;
 408       _index = index.as_register();
 409     } else {
 410       guarantee(ext.option() == ext::uxtx, &quot;should be&quot;);
 411       assert(index.is_constant(), &quot;should be&quot;);
 412       _mode = base_plus_offset;
 413       _offset = index.as_constant() &lt;&lt; ext.shift();
 414     }
 415   }
 416 
 417   Register base() const {
 418     guarantee((_mode == base_plus_offset | _mode == base_plus_offset_reg
 419                | _mode == post | _mode == post_reg),
 420               &quot;wrong mode&quot;);
 421     return _base;
 422   }
 423   long offset() const {
 424     return _offset;
 425   }
 426   Register index() const {
 427     return _index;
 428   }
 429   mode getMode() const {
 430     return _mode;
 431   }
 432   bool uses(Register reg) const { return _base == reg || _index == reg; }
 433   address target() const { return _target; }
 434   const RelocationHolder&amp; rspec() const { return _rspec; }
 435 
 436   void encode(Instruction_aarch64 *i) const {
 437     i-&gt;f(0b111, 29, 27);
 438     i-&gt;srf(_base, 5);
 439 
 440     switch(_mode) {
 441     case base_plus_offset:
 442       {
 443         unsigned size = i-&gt;get(31, 30);
 444         if (i-&gt;get(26, 26) &amp;&amp; i-&gt;get(23, 23)) {
 445           // SIMD Q Type - Size = 128 bits
 446           assert(size == 0, &quot;bad size&quot;);
 447           size = 0b100;
 448         }
 449         unsigned mask = (1 &lt;&lt; size) - 1;
 450         if (_offset &lt; 0 || _offset &amp; mask)
 451           {
 452             i-&gt;f(0b00, 25, 24);
 453             i-&gt;f(0, 21), i-&gt;f(0b00, 11, 10);
 454             i-&gt;sf(_offset, 20, 12);
 455           } else {
 456             i-&gt;f(0b01, 25, 24);
 457             i-&gt;f(_offset &gt;&gt; size, 21, 10);
 458           }
 459       }
 460       break;
 461 
 462     case base_plus_offset_reg:
 463       {
 464         i-&gt;f(0b00, 25, 24);
 465         i-&gt;f(1, 21);
 466         i-&gt;rf(_index, 16);
 467         i-&gt;f(_ext.option(), 15, 13);
 468         unsigned size = i-&gt;get(31, 30);
 469         if (i-&gt;get(26, 26) &amp;&amp; i-&gt;get(23, 23)) {
 470           // SIMD Q Type - Size = 128 bits
 471           assert(size == 0, &quot;bad size&quot;);
 472           size = 0b100;
 473         }
 474         if (size == 0) // It&#39;s a byte
 475           i-&gt;f(_ext.shift() &gt;= 0, 12);
 476         else {
 477           if (_ext.shift() &gt; 0)
 478             assert(_ext.shift() == (int)size, &quot;bad shift&quot;);
 479           i-&gt;f(_ext.shift() &gt; 0, 12);
 480         }
 481         i-&gt;f(0b10, 11, 10);
 482       }
 483       break;
 484 
 485     case pre:
 486       i-&gt;f(0b00, 25, 24);
 487       i-&gt;f(0, 21), i-&gt;f(0b11, 11, 10);
 488       i-&gt;sf(_offset, 20, 12);
 489       break;
 490 
 491     case post:
 492       i-&gt;f(0b00, 25, 24);
 493       i-&gt;f(0, 21), i-&gt;f(0b01, 11, 10);
 494       i-&gt;sf(_offset, 20, 12);
 495       break;
 496 
 497     default:
 498       ShouldNotReachHere();
 499     }
 500   }
 501 
 502   void encode_pair(Instruction_aarch64 *i) const {
 503     switch(_mode) {
 504     case base_plus_offset:
 505       i-&gt;f(0b010, 25, 23);
 506       break;
 507     case pre:
 508       i-&gt;f(0b011, 25, 23);
 509       break;
 510     case post:
 511       i-&gt;f(0b001, 25, 23);
 512       break;
 513     default:
 514       ShouldNotReachHere();
 515     }
 516 
 517     unsigned size; // Operand shift in 32-bit words
 518 
 519     if (i-&gt;get(26, 26)) { // float
 520       switch(i-&gt;get(31, 30)) {
 521       case 0b10:
 522         size = 2; break;
 523       case 0b01:
 524         size = 1; break;
 525       case 0b00:
 526         size = 0; break;
 527       default:
 528         ShouldNotReachHere();
 529         size = 0;  // unreachable
 530       }
 531     } else {
 532       size = i-&gt;get(31, 31);
 533     }
 534 
 535     size = 4 &lt;&lt; size;
 536     guarantee(_offset % size == 0, &quot;bad offset&quot;);
 537     i-&gt;sf(_offset / size, 21, 15);
 538     i-&gt;srf(_base, 5);
 539   }
 540 
 541   void encode_nontemporal_pair(Instruction_aarch64 *i) const {
 542     // Only base + offset is allowed
 543     i-&gt;f(0b000, 25, 23);
 544     unsigned size = i-&gt;get(31, 31);
 545     size = 4 &lt;&lt; size;
 546     guarantee(_offset % size == 0, &quot;bad offset&quot;);
 547     i-&gt;sf(_offset / size, 21, 15);
 548     i-&gt;srf(_base, 5);
 549     guarantee(_mode == Address::base_plus_offset,
 550               &quot;Bad addressing mode for non-temporal op&quot;);
 551   }
 552 
 553   void lea(MacroAssembler *, Register) const;
 554 
<a name="7" id="anc7"></a><span class="line-modified"> 555   static bool offset_ok_for_immed(long offset, int shift = 0) {</span>
 556     unsigned mask = (1 &lt;&lt; shift) - 1;
 557     if (offset &lt; 0 || offset &amp; mask) {
 558       return (uabs(offset) &lt; (1 &lt;&lt; (20 - 12))); // Unscaled offset
 559     } else {
 560       return ((offset &gt;&gt; shift) &lt; (1 &lt;&lt; (21 - 10 + 1))); // Scaled, unsigned offset
 561     }
 562   }
 563 };
 564 
 565 // Convience classes
 566 class RuntimeAddress: public Address {
 567 
 568   public:
 569 
 570   RuntimeAddress(address target) : Address(target, relocInfo::runtime_call_type) {}
 571 
 572 };
 573 
 574 class OopAddress: public Address {
 575 
 576   public:
 577 
 578   OopAddress(address target) : Address(target, relocInfo::oop_type){}
 579 
 580 };
 581 
 582 class ExternalAddress: public Address {
 583  private:
 584   static relocInfo::relocType reloc_for_target(address target) {
 585     // Sometimes ExternalAddress is used for values which aren&#39;t
 586     // exactly addresses, like the card table base.
 587     // external_word_type can&#39;t be used for values in the first page
 588     // so just skip the reloc in that case.
 589     return external_word_Relocation::can_be_relocated(target) ? relocInfo::external_word_type : relocInfo::none;
 590   }
 591 
 592  public:
 593 
 594   ExternalAddress(address target) : Address(target, reloc_for_target(target)) {}
 595 
 596 };
 597 
 598 class InternalAddress: public Address {
 599 
 600   public:
 601 
 602   InternalAddress(address target) : Address(target, relocInfo::internal_word_type) {}
 603 };
 604 
<a name="8" id="anc8"></a><span class="line-modified"> 605 const int FPUStateSizeInWords = 32 * 2;</span>


 606 typedef enum {
 607   PLDL1KEEP = 0b00000, PLDL1STRM, PLDL2KEEP, PLDL2STRM, PLDL3KEEP, PLDL3STRM,
 608   PSTL1KEEP = 0b10000, PSTL1STRM, PSTL2KEEP, PSTL2STRM, PSTL3KEEP, PSTL3STRM,
 609   PLIL1KEEP = 0b01000, PLIL1STRM, PLIL2KEEP, PLIL2STRM, PLIL3KEEP, PLIL3STRM
 610 } prfop;
 611 
 612 class Assembler : public AbstractAssembler {
 613 
 614 #ifndef PRODUCT
 615   static const unsigned long asm_bp;
 616 
 617   void emit_long(jint x) {
 618     if ((unsigned long)pc() == asm_bp)
 619       asm volatile (&quot;nop&quot;);
 620     AbstractAssembler::emit_int32(x);
 621   }
 622 #else
 623   void emit_long(jint x) {
 624     AbstractAssembler::emit_int32(x);
 625   }
 626 #endif
 627 
 628 public:
 629 
 630   enum { instruction_size = 4 };
 631 
<a name="9" id="anc9"></a>







 632   Address adjust(Register base, int offset, bool preIncrement) {
 633     if (preIncrement)
 634       return Address(Pre(base, offset));
 635     else
 636       return Address(Post(base, offset));
 637   }
 638 
 639   Address pre(Register base, int offset) {
 640     return adjust(base, offset, true);
 641   }
 642 
 643   Address post(Register base, int offset) {
 644     return adjust(base, offset, false);
 645   }
 646 
 647   Address post(Register base, Register idx) {
 648     return Address(Post(base, idx));
 649   }
 650 
 651   Instruction_aarch64* current;
 652 
 653   void set_current(Instruction_aarch64* i) { current = i; }
 654 
 655   void f(unsigned val, int msb, int lsb) {
 656     current-&gt;f(val, msb, lsb);
 657   }
 658   void f(unsigned val, int msb) {
 659     current-&gt;f(val, msb, msb);
 660   }
 661   void sf(long val, int msb, int lsb) {
 662     current-&gt;sf(val, msb, lsb);
 663   }
 664   void rf(Register reg, int lsb) {
 665     current-&gt;rf(reg, lsb);
 666   }
 667   void srf(Register reg, int lsb) {
 668     current-&gt;srf(reg, lsb);
 669   }
 670   void zrf(Register reg, int lsb) {
 671     current-&gt;zrf(reg, lsb);
 672   }
 673   void rf(FloatRegister reg, int lsb) {
 674     current-&gt;rf(reg, lsb);
 675   }
 676   void fixed(unsigned value, unsigned mask) {
 677     current-&gt;fixed(value, mask);
 678   }
 679 
 680   void emit() {
 681     emit_long(current-&gt;get_insn());
 682     assert_cond(current-&gt;get_bits() == 0xffffffff);
 683     current = NULL;
 684   }
 685 
 686   typedef void (Assembler::* uncond_branch_insn)(address dest);
 687   typedef void (Assembler::* compare_and_branch_insn)(Register Rt, address dest);
 688   typedef void (Assembler::* test_and_branch_insn)(Register Rt, int bitpos, address dest);
 689   typedef void (Assembler::* prefetch_insn)(address target, prfop);
 690 
 691   void wrap_label(Label &amp;L, uncond_branch_insn insn);
 692   void wrap_label(Register r, Label &amp;L, compare_and_branch_insn insn);
 693   void wrap_label(Register r, int bitpos, Label &amp;L, test_and_branch_insn insn);
 694   void wrap_label(Label &amp;L, prfop, prefetch_insn insn);
 695 
 696   // PC-rel. addressing
 697 
 698   void adr(Register Rd, address dest);
 699   void _adrp(Register Rd, address dest);
 700 
 701   void adr(Register Rd, const Address &amp;dest);
 702   void _adrp(Register Rd, const Address &amp;dest);
 703 
 704   void adr(Register Rd, Label &amp;L) {
 705     wrap_label(Rd, L, &amp;Assembler::Assembler::adr);
 706   }
 707   void _adrp(Register Rd, Label &amp;L) {
 708     wrap_label(Rd, L, &amp;Assembler::_adrp);
 709   }
 710 
 711   void adrp(Register Rd, const Address &amp;dest, unsigned long &amp;offset);
 712 
 713 #undef INSN
 714 
 715   void add_sub_immediate(Register Rd, Register Rn, unsigned uimm, int op,
 716                          int negated_op);
 717 
 718   // Add/subtract (immediate)
 719 #define INSN(NAME, decode, negated)                                     \
 720   void NAME(Register Rd, Register Rn, unsigned imm, unsigned shift) {   \
 721     starti;                                                             \
 722     f(decode, 31, 29), f(0b10001, 28, 24), f(shift, 23, 22), f(imm, 21, 10); \
 723     zrf(Rd, 0), srf(Rn, 5);                                             \
 724   }                                                                     \
 725                                                                         \
 726   void NAME(Register Rd, Register Rn, unsigned imm) {                   \
 727     starti;                                                             \
 728     add_sub_immediate(Rd, Rn, imm, decode, negated);                    \
 729   }
 730 
 731   INSN(addsw, 0b001, 0b011);
 732   INSN(subsw, 0b011, 0b001);
 733   INSN(adds,  0b101, 0b111);
 734   INSN(subs,  0b111, 0b101);
 735 
 736 #undef INSN
 737 
 738 #define INSN(NAME, decode, negated)                     \
 739   void NAME(Register Rd, Register Rn, unsigned imm) {   \
 740     starti;                                             \
 741     add_sub_immediate(Rd, Rn, imm, decode, negated);    \
 742   }
 743 
 744   INSN(addw, 0b000, 0b010);
 745   INSN(subw, 0b010, 0b000);
 746   INSN(add,  0b100, 0b110);
 747   INSN(sub,  0b110, 0b100);
 748 
 749 #undef INSN
 750 
 751  // Logical (immediate)
 752 #define INSN(NAME, decode, is32)                                \
 753   void NAME(Register Rd, Register Rn, uint64_t imm) {           \
 754     starti;                                                     \
 755     uint32_t val = encode_logical_immediate(is32, imm);         \
 756     f(decode, 31, 29), f(0b100100, 28, 23), f(val, 22, 10);     \
 757     srf(Rd, 0), zrf(Rn, 5);                                     \
 758   }
 759 
 760   INSN(andw, 0b000, true);
 761   INSN(orrw, 0b001, true);
 762   INSN(eorw, 0b010, true);
 763   INSN(andr,  0b100, false);
 764   INSN(orr,  0b101, false);
 765   INSN(eor,  0b110, false);
 766 
 767 #undef INSN
 768 
 769 #define INSN(NAME, decode, is32)                                \
 770   void NAME(Register Rd, Register Rn, uint64_t imm) {           \
 771     starti;                                                     \
 772     uint32_t val = encode_logical_immediate(is32, imm);         \
 773     f(decode, 31, 29), f(0b100100, 28, 23), f(val, 22, 10);     \
 774     zrf(Rd, 0), zrf(Rn, 5);                                     \
 775   }
 776 
 777   INSN(ands, 0b111, false);
 778   INSN(andsw, 0b011, true);
 779 
 780 #undef INSN
 781 
 782   // Move wide (immediate)
 783 #define INSN(NAME, opcode)                                              \
 784   void NAME(Register Rd, unsigned imm, unsigned shift = 0) {            \
 785     assert_cond((shift/16)*16 == shift);                                \
 786     starti;                                                             \
 787     f(opcode, 31, 29), f(0b100101, 28, 23), f(shift/16, 22, 21),        \
 788       f(imm, 20, 5);                                                    \
 789     rf(Rd, 0);                                                          \
 790   }
 791 
 792   INSN(movnw, 0b000);
 793   INSN(movzw, 0b010);
 794   INSN(movkw, 0b011);
 795   INSN(movn, 0b100);
 796   INSN(movz, 0b110);
 797   INSN(movk, 0b111);
 798 
 799 #undef INSN
 800 
 801   // Bitfield
<a name="10" id="anc10"></a><span class="line-modified"> 802 #define INSN(NAME, opcode)                                              \</span>
 803   void NAME(Register Rd, Register Rn, unsigned immr, unsigned imms) {   \
 804     starti;                                                             \
<a name="11" id="anc11"></a>
 805     f(opcode, 31, 22), f(immr, 21, 16), f(imms, 15, 10);                \
 806     zrf(Rn, 5), rf(Rd, 0);                                              \
 807   }
 808 
<a name="12" id="anc12"></a><span class="line-modified"> 809   INSN(sbfmw, 0b0001001100);</span>
<span class="line-modified"> 810   INSN(bfmw,  0b0011001100);</span>
<span class="line-modified"> 811   INSN(ubfmw, 0b0101001100);</span>
<span class="line-modified"> 812   INSN(sbfm,  0b1001001101);</span>
<span class="line-modified"> 813   INSN(bfm,   0b1011001101);</span>
<span class="line-modified"> 814   INSN(ubfm,  0b1101001101);</span>
 815 
 816 #undef INSN
 817 
 818   // Extract
<a name="13" id="anc13"></a><span class="line-modified"> 819 #define INSN(NAME, opcode)                                              \</span>
 820   void NAME(Register Rd, Register Rn, Register Rm, unsigned imms) {     \
 821     starti;                                                             \
<a name="14" id="anc14"></a>
 822     f(opcode, 31, 21), f(imms, 15, 10);                                 \
<a name="15" id="anc15"></a><span class="line-modified"> 823     rf(Rm, 16), rf(Rn, 5), rf(Rd, 0);                                   \</span>
 824   }
 825 
<a name="16" id="anc16"></a><span class="line-modified"> 826   INSN(extrw, 0b00010011100);</span>
<span class="line-modified"> 827   INSN(extr,  0b10010011110);</span>
 828 
 829 #undef INSN
 830 
 831   // The maximum range of a branch is fixed for the AArch64
 832   // architecture.  In debug mode we shrink it in order to test
 833   // trampolines, but not so small that branches in the interpreter
 834   // are out of range.
 835   static const unsigned long branch_range = NOT_DEBUG(128 * M) DEBUG_ONLY(2 * M);
 836 
 837   static bool reachable_from_branch_at(address branch, address target) {
 838     return uabs(target - branch) &lt; branch_range;
 839   }
 840 
 841   // Unconditional branch (immediate)
 842 #define INSN(NAME, opcode)                                              \
 843   void NAME(address dest) {                                             \
 844     starti;                                                             \
 845     long offset = (dest - pc()) &gt;&gt; 2;                                   \
 846     DEBUG_ONLY(assert(reachable_from_branch_at(pc(), dest), &quot;debug only&quot;)); \
 847     f(opcode, 31), f(0b00101, 30, 26), sf(offset, 25, 0);               \
 848   }                                                                     \
 849   void NAME(Label &amp;L) {                                                 \
 850     wrap_label(L, &amp;Assembler::NAME);                                    \
 851   }                                                                     \
 852   void NAME(const Address &amp;dest);
 853 
 854   INSN(b, 0);
 855   INSN(bl, 1);
 856 
 857 #undef INSN
 858 
 859   // Compare &amp; branch (immediate)
 860 #define INSN(NAME, opcode)                              \
 861   void NAME(Register Rt, address dest) {                \
 862     long offset = (dest - pc()) &gt;&gt; 2;                   \
 863     starti;                                             \
 864     f(opcode, 31, 24), sf(offset, 23, 5), rf(Rt, 0);    \
 865   }                                                     \
 866   void NAME(Register Rt, Label &amp;L) {                    \
 867     wrap_label(Rt, L, &amp;Assembler::NAME);                \
 868   }
 869 
 870   INSN(cbzw,  0b00110100);
 871   INSN(cbnzw, 0b00110101);
 872   INSN(cbz,   0b10110100);
 873   INSN(cbnz,  0b10110101);
 874 
 875 #undef INSN
 876 
 877   // Test &amp; branch (immediate)
 878 #define INSN(NAME, opcode)                                              \
 879   void NAME(Register Rt, int bitpos, address dest) {                    \
 880     long offset = (dest - pc()) &gt;&gt; 2;                                   \
 881     int b5 = bitpos &gt;&gt; 5;                                               \
 882     bitpos &amp;= 0x1f;                                                     \
 883     starti;                                                             \
 884     f(b5, 31), f(opcode, 30, 24), f(bitpos, 23, 19), sf(offset, 18, 5); \
 885     rf(Rt, 0);                                                          \
 886   }                                                                     \
 887   void NAME(Register Rt, int bitpos, Label &amp;L) {                        \
 888     wrap_label(Rt, bitpos, L, &amp;Assembler::NAME);                        \
 889   }
 890 
 891   INSN(tbz,  0b0110110);
 892   INSN(tbnz, 0b0110111);
 893 
 894 #undef INSN
 895 
 896   // Conditional branch (immediate)
 897   enum Condition
 898     {EQ, NE, HS, CS=HS, LO, CC=LO, MI, PL, VS, VC, HI, LS, GE, LT, GT, LE, AL, NV};
 899 
 900   void br(Condition  cond, address dest) {
 901     long offset = (dest - pc()) &gt;&gt; 2;
 902     starti;
 903     f(0b0101010, 31, 25), f(0, 24), sf(offset, 23, 5), f(0, 4), f(cond, 3, 0);
 904   }
 905 
 906 #define INSN(NAME, cond)                        \
 907   void NAME(address dest) {                     \
 908     br(cond, dest);                             \
 909   }
 910 
 911   INSN(beq, EQ);
 912   INSN(bne, NE);
 913   INSN(bhs, HS);
 914   INSN(bcs, CS);
 915   INSN(blo, LO);
 916   INSN(bcc, CC);
 917   INSN(bmi, MI);
 918   INSN(bpl, PL);
 919   INSN(bvs, VS);
 920   INSN(bvc, VC);
 921   INSN(bhi, HI);
 922   INSN(bls, LS);
 923   INSN(bge, GE);
 924   INSN(blt, LT);
 925   INSN(bgt, GT);
 926   INSN(ble, LE);
 927   INSN(bal, AL);
 928   INSN(bnv, NV);
 929 
 930   void br(Condition cc, Label &amp;L);
 931 
 932 #undef INSN
 933 
 934   // Exception generation
 935   void generate_exception(int opc, int op2, int LL, unsigned imm) {
 936     starti;
 937     f(0b11010100, 31, 24);
 938     f(opc, 23, 21), f(imm, 20, 5), f(op2, 4, 2), f(LL, 1, 0);
 939   }
 940 
 941 #define INSN(NAME, opc, op2, LL)                \
 942   void NAME(unsigned imm) {                     \
 943     generate_exception(opc, op2, LL, imm);      \
 944   }
 945 
 946   INSN(svc, 0b000, 0, 0b01);
 947   INSN(hvc, 0b000, 0, 0b10);
 948   INSN(smc, 0b000, 0, 0b11);
 949   INSN(brk, 0b001, 0, 0b00);
 950   INSN(hlt, 0b010, 0, 0b00);
 951   INSN(dpcs1, 0b101, 0, 0b01);
 952   INSN(dpcs2, 0b101, 0, 0b10);
 953   INSN(dpcs3, 0b101, 0, 0b11);
 954 
 955 #undef INSN
 956 
 957   // System
 958   void system(int op0, int op1, int CRn, int CRm, int op2,
 959               Register rt = dummy_reg)
 960   {
 961     starti;
 962     f(0b11010101000, 31, 21);
 963     f(op0, 20, 19);
 964     f(op1, 18, 16);
 965     f(CRn, 15, 12);
 966     f(CRm, 11, 8);
 967     f(op2, 7, 5);
 968     rf(rt, 0);
 969   }
 970 
 971   void hint(int imm) {
 972     system(0b00, 0b011, 0b0010, 0b0000, imm);
 973   }
 974 
 975   void nop() {
 976     hint(0);
 977   }
 978 
 979   void yield() {
 980     hint(1);
 981   }
 982 
 983   void wfe() {
 984     hint(2);
 985   }
 986 
 987   void wfi() {
 988     hint(3);
 989   }
 990 
 991   void sev() {
 992     hint(4);
 993   }
 994 
 995   void sevl() {
 996     hint(5);
 997   }
 998 
 999   // we only provide mrs and msr for the special purpose system
1000   // registers where op1 (instr[20:19]) == 11 and, (currently) only
1001   // use it for FPSR n.b msr has L (instr[21]) == 0 mrs has L == 1
1002 
1003   void msr(int op1, int CRn, int CRm, int op2, Register rt) {
1004     starti;
1005     f(0b1101010100011, 31, 19);
1006     f(op1, 18, 16);
1007     f(CRn, 15, 12);
1008     f(CRm, 11, 8);
1009     f(op2, 7, 5);
1010     // writing zr is ok
1011     zrf(rt, 0);
1012   }
1013 
1014   void mrs(int op1, int CRn, int CRm, int op2, Register rt) {
1015     starti;
1016     f(0b1101010100111, 31, 19);
1017     f(op1, 18, 16);
1018     f(CRn, 15, 12);
1019     f(CRm, 11, 8);
1020     f(op2, 7, 5);
1021     // reading to zr is a mistake
1022     rf(rt, 0);
1023   }
1024 
1025   enum barrier {OSHLD = 0b0001, OSHST, OSH, NSHLD=0b0101, NSHST, NSH,
1026                 ISHLD = 0b1001, ISHST, ISH, LD=0b1101, ST, SY};
1027 
1028   void dsb(barrier imm) {
1029     system(0b00, 0b011, 0b00011, imm, 0b100);
1030   }
1031 
1032   void dmb(barrier imm) {
1033     system(0b00, 0b011, 0b00011, imm, 0b101);
1034   }
1035 
1036   void isb() {
1037     system(0b00, 0b011, 0b00011, SY, 0b110);
1038   }
1039 
1040   void sys(int op1, int CRn, int CRm, int op2,
1041            Register rt = (Register)0b11111) {
1042     system(0b01, op1, CRn, CRm, op2, rt);
1043   }
1044 
1045   // Only implement operations accessible from EL0 or higher, i.e.,
1046   //            op1    CRn    CRm    op2
1047   // IC IVAU     3      7      5      1
1048   // DC CVAC     3      7      10     1
<a name="17" id="anc17"></a>
1049   // DC CVAU     3      7      11     1
1050   // DC CIVAC    3      7      14     1
1051   // DC ZVA      3      7      4      1
1052   // So only deal with the CRm field.
1053   enum icache_maintenance {IVAU = 0b0101};
<a name="18" id="anc18"></a><span class="line-modified">1054   enum dcache_maintenance {CVAC = 0b1010, CVAU = 0b1011, CIVAC = 0b1110, ZVA = 0b100};</span>
1055 
1056   void dc(dcache_maintenance cm, Register Rt) {
1057     sys(0b011, 0b0111, cm, 0b001, Rt);
1058   }
1059 
1060   void ic(icache_maintenance cm, Register Rt) {
1061     sys(0b011, 0b0111, cm, 0b001, Rt);
1062   }
1063 
1064   // A more convenient access to dmb for our purposes
1065   enum Membar_mask_bits {
1066     // We can use ISH for a barrier because the ARM ARM says &quot;This
1067     // architecture assumes that all Processing Elements that use the
1068     // same operating system or hypervisor are in the same Inner
1069     // Shareable shareability domain.&quot;
1070     StoreStore = ISHST,
1071     LoadStore  = ISHLD,
1072     LoadLoad   = ISHLD,
1073     StoreLoad  = ISH,
1074     AnyAny     = ISH
1075   };
1076 
1077   void membar(Membar_mask_bits order_constraint) {
1078     dmb(Assembler::barrier(order_constraint));
1079   }
1080 
1081   // Unconditional branch (register)
1082   void branch_reg(Register R, int opc) {
1083     starti;
1084     f(0b1101011, 31, 25);
1085     f(opc, 24, 21);
1086     f(0b11111000000, 20, 10);
1087     rf(R, 5);
1088     f(0b00000, 4, 0);
1089   }
1090 
1091 #define INSN(NAME, opc)                         \
1092   void NAME(Register R) {                       \
1093     branch_reg(R, opc);                         \
1094   }
1095 
1096   INSN(br, 0b0000);
1097   INSN(blr, 0b0001);
1098   INSN(ret, 0b0010);
1099 
1100   void ret(void *p); // This forces a compile-time error for ret(0)
1101 
1102 #undef INSN
1103 
1104 #define INSN(NAME, opc)                         \
1105   void NAME() {                 \
1106     branch_reg(dummy_reg, opc);         \
1107   }
1108 
1109   INSN(eret, 0b0100);
1110   INSN(drps, 0b0101);
1111 
1112 #undef INSN
1113 
1114   // Load/store exclusive
1115   enum operand_size { byte, halfword, word, xword };
1116 
1117   void load_store_exclusive(Register Rs, Register Rt1, Register Rt2,
1118     Register Rn, enum operand_size sz, int op, bool ordered) {
1119     starti;
1120     f(sz, 31, 30), f(0b001000, 29, 24), f(op, 23, 21);
<a name="19" id="anc19"></a><span class="line-modified">1121     rf(Rs, 16), f(ordered, 15), rf(Rt2, 10), srf(Rn, 5), zrf(Rt1, 0);</span>
1122   }
1123 
1124   void load_exclusive(Register dst, Register addr,
1125                       enum operand_size sz, bool ordered) {
1126     load_store_exclusive(dummy_reg, dst, dummy_reg, addr,
1127                          sz, 0b010, ordered);
1128   }
1129 
1130   void store_exclusive(Register status, Register new_val, Register addr,
1131                        enum operand_size sz, bool ordered) {
1132     load_store_exclusive(status, new_val, dummy_reg, addr,
1133                          sz, 0b000, ordered);
1134   }
1135 
1136 #define INSN4(NAME, sz, op, o0) /* Four registers */                    \
1137   void NAME(Register Rs, Register Rt1, Register Rt2, Register Rn) {     \
1138     guarantee(Rs != Rn &amp;&amp; Rs != Rt1 &amp;&amp; Rs != Rt2, &quot;unpredictable instruction&quot;); \
1139     load_store_exclusive(Rs, Rt1, Rt2, Rn, sz, op, o0);                 \
1140   }
1141 
1142 #define INSN3(NAME, sz, op, o0) /* Three registers */                   \
1143   void NAME(Register Rs, Register Rt, Register Rn) {                    \
1144     guarantee(Rs != Rn &amp;&amp; Rs != Rt, &quot;unpredictable instruction&quot;);       \
1145     load_store_exclusive(Rs, Rt, dummy_reg, Rn, sz, op, o0); \
1146   }
1147 
1148 #define INSN2(NAME, sz, op, o0) /* Two registers */                     \
1149   void NAME(Register Rt, Register Rn) {                                 \
1150     load_store_exclusive(dummy_reg, Rt, dummy_reg, \
1151                          Rn, sz, op, o0);                               \
1152   }
1153 
1154 #define INSN_FOO(NAME, sz, op, o0) /* Three registers, encoded differently */ \
1155   void NAME(Register Rt1, Register Rt2, Register Rn) {                  \
1156     guarantee(Rt1 != Rt2, &quot;unpredictable instruction&quot;);                 \
1157     load_store_exclusive(dummy_reg, Rt1, Rt2, Rn, sz, op, o0);          \
1158   }
1159 
1160   // bytes
1161   INSN3(stxrb, byte, 0b000, 0);
1162   INSN3(stlxrb, byte, 0b000, 1);
1163   INSN2(ldxrb, byte, 0b010, 0);
1164   INSN2(ldaxrb, byte, 0b010, 1);
1165   INSN2(stlrb, byte, 0b100, 1);
1166   INSN2(ldarb, byte, 0b110, 1);
1167 
1168   // halfwords
1169   INSN3(stxrh, halfword, 0b000, 0);
1170   INSN3(stlxrh, halfword, 0b000, 1);
1171   INSN2(ldxrh, halfword, 0b010, 0);
1172   INSN2(ldaxrh, halfword, 0b010, 1);
1173   INSN2(stlrh, halfword, 0b100, 1);
1174   INSN2(ldarh, halfword, 0b110, 1);
1175 
1176   // words
1177   INSN3(stxrw, word, 0b000, 0);
1178   INSN3(stlxrw, word, 0b000, 1);
1179   INSN4(stxpw, word, 0b001, 0);
1180   INSN4(stlxpw, word, 0b001, 1);
1181   INSN2(ldxrw, word, 0b010, 0);
1182   INSN2(ldaxrw, word, 0b010, 1);
1183   INSN_FOO(ldxpw, word, 0b011, 0);
1184   INSN_FOO(ldaxpw, word, 0b011, 1);
1185   INSN2(stlrw, word, 0b100, 1);
1186   INSN2(ldarw, word, 0b110, 1);
1187 
1188   // xwords
1189   INSN3(stxr, xword, 0b000, 0);
1190   INSN3(stlxr, xword, 0b000, 1);
1191   INSN4(stxp, xword, 0b001, 0);
1192   INSN4(stlxp, xword, 0b001, 1);
1193   INSN2(ldxr, xword, 0b010, 0);
1194   INSN2(ldaxr, xword, 0b010, 1);
1195   INSN_FOO(ldxp, xword, 0b011, 0);
1196   INSN_FOO(ldaxp, xword, 0b011, 1);
1197   INSN2(stlr, xword, 0b100, 1);
1198   INSN2(ldar, xword, 0b110, 1);
1199 
1200 #undef INSN2
1201 #undef INSN3
1202 #undef INSN4
1203 #undef INSN_FOO
1204 
1205   // 8.1 Compare and swap extensions
1206   void lse_cas(Register Rs, Register Rt, Register Rn,
1207                         enum operand_size sz, bool a, bool r, bool not_pair) {
1208     starti;
1209     if (! not_pair) { // Pair
1210       assert(sz == word || sz == xword, &quot;invalid size&quot;);
1211       /* The size bit is in bit 30, not 31 */
1212       sz = (operand_size)(sz == word ? 0b00:0b01);
1213     }
<a name="20" id="anc20"></a><span class="line-modified">1214     f(sz, 31, 30), f(0b001000, 29, 24), f(1, 23), f(a, 22), f(1, 21);</span>
<span class="line-modified">1215     rf(Rs, 16), f(r, 15), f(0b11111, 14, 10), rf(Rn, 5), rf(Rt, 0);</span>
1216   }
1217 
1218   // CAS
1219 #define INSN(NAME, a, r)                                                \
1220   void NAME(operand_size sz, Register Rs, Register Rt, Register Rn) {   \
1221     assert(Rs != Rn &amp;&amp; Rs != Rt, &quot;unpredictable instruction&quot;);          \
1222     lse_cas(Rs, Rt, Rn, sz, a, r, true);                                \
1223   }
1224   INSN(cas,    false, false)
1225   INSN(casa,   true,  false)
1226   INSN(casl,   false, true)
1227   INSN(casal,  true,  true)
1228 #undef INSN
1229 
1230   // CASP
1231 #define INSN(NAME, a, r)                                                \
1232   void NAME(operand_size sz, Register Rs, Register Rs1,                 \
1233             Register Rt, Register Rt1, Register Rn) {                   \
1234     assert((Rs-&gt;encoding() &amp; 1) == 0 &amp;&amp; (Rt-&gt;encoding() &amp; 1) == 0 &amp;&amp;    \
1235            Rs-&gt;successor() == Rs1 &amp;&amp; Rt-&gt;successor() == Rt1 &amp;&amp;          \
1236            Rs != Rn &amp;&amp; Rs1 != Rn &amp;&amp; Rs != Rt, &quot;invalid registers&quot;);     \
1237     lse_cas(Rs, Rt, Rn, sz, a, r, false);                               \
1238   }
1239   INSN(casp,    false, false)
1240   INSN(caspa,   true,  false)
1241   INSN(caspl,   false, true)
1242   INSN(caspal,  true,  true)
1243 #undef INSN
1244 
1245   // 8.1 Atomic operations
1246   void lse_atomic(Register Rs, Register Rt, Register Rn,
1247                   enum operand_size sz, int op1, int op2, bool a, bool r) {
1248     starti;
1249     f(sz, 31, 30), f(0b111000, 29, 24), f(a, 23), f(r, 22), f(1, 21);
<a name="21" id="anc21"></a><span class="line-modified">1250     rf(Rs, 16), f(op1, 15), f(op2, 14, 12), f(0, 11, 10), srf(Rn, 5), zrf(Rt, 0);</span>
1251   }
1252 
1253 #define INSN(NAME, NAME_A, NAME_L, NAME_AL, op1, op2)                   \
1254   void NAME(operand_size sz, Register Rs, Register Rt, Register Rn) {   \
1255     lse_atomic(Rs, Rt, Rn, sz, op1, op2, false, false);                 \
1256   }                                                                     \
1257   void NAME_A(operand_size sz, Register Rs, Register Rt, Register Rn) { \
1258     lse_atomic(Rs, Rt, Rn, sz, op1, op2, true, false);                  \
1259   }                                                                     \
1260   void NAME_L(operand_size sz, Register Rs, Register Rt, Register Rn) { \
1261     lse_atomic(Rs, Rt, Rn, sz, op1, op2, false, true);                  \
1262   }                                                                     \
1263   void NAME_AL(operand_size sz, Register Rs, Register Rt, Register Rn) {\
1264     lse_atomic(Rs, Rt, Rn, sz, op1, op2, true, true);                   \
1265   }
1266   INSN(ldadd,  ldadda,  ldaddl,  ldaddal,  0, 0b000);
1267   INSN(ldbic,  ldbica,  ldbicl,  ldbical,  0, 0b001);
1268   INSN(ldeor,  ldeora,  ldeorl,  ldeoral,  0, 0b010);
1269   INSN(ldorr,  ldorra,  ldorrl,  ldorral,  0, 0b011);
1270   INSN(ldsmax, ldsmaxa, ldsmaxl, ldsmaxal, 0, 0b100);
1271   INSN(ldsmin, ldsmina, ldsminl, ldsminal, 0, 0b101);
1272   INSN(ldumax, ldumaxa, ldumaxl, ldumaxal, 0, 0b110);
1273   INSN(ldumin, ldumina, lduminl, lduminal, 0, 0b111);
1274   INSN(swp,    swpa,    swpl,    swpal,    1, 0b000);
1275 #undef INSN
1276 
1277   // Load register (literal)
1278 #define INSN(NAME, opc, V)                                              \
1279   void NAME(Register Rt, address dest) {                                \
1280     long offset = (dest - pc()) &gt;&gt; 2;                                   \
1281     starti;                                                             \
1282     f(opc, 31, 30), f(0b011, 29, 27), f(V, 26), f(0b00, 25, 24),        \
1283       sf(offset, 23, 5);                                                \
1284     rf(Rt, 0);                                                          \
1285   }                                                                     \
1286   void NAME(Register Rt, address dest, relocInfo::relocType rtype) {    \
1287     InstructionMark im(this);                                           \
1288     guarantee(rtype == relocInfo::internal_word_type,                   \
1289               &quot;only internal_word_type relocs make sense here&quot;);        \
1290     code_section()-&gt;relocate(inst_mark(), InternalAddress(dest).rspec()); \
1291     NAME(Rt, dest);                                                     \
1292   }                                                                     \
1293   void NAME(Register Rt, Label &amp;L) {                                    \
1294     wrap_label(Rt, L, &amp;Assembler::NAME);                                \
1295   }
1296 
1297   INSN(ldrw, 0b00, 0);
1298   INSN(ldr, 0b01, 0);
1299   INSN(ldrsw, 0b10, 0);
1300 
1301 #undef INSN
1302 
1303 #define INSN(NAME, opc, V)                                              \
1304   void NAME(FloatRegister Rt, address dest) {                           \
1305     long offset = (dest - pc()) &gt;&gt; 2;                                   \
1306     starti;                                                             \
1307     f(opc, 31, 30), f(0b011, 29, 27), f(V, 26), f(0b00, 25, 24),        \
1308       sf(offset, 23, 5);                                                \
1309     rf((Register)Rt, 0);                                                \
1310   }
1311 
1312   INSN(ldrs, 0b00, 1);
1313   INSN(ldrd, 0b01, 1);
1314   INSN(ldrq, 0b10, 1);
1315 
1316 #undef INSN
1317 
1318 #define INSN(NAME, opc, V)                                              \
1319   void NAME(address dest, prfop op = PLDL1KEEP) {                       \
1320     long offset = (dest - pc()) &gt;&gt; 2;                                   \
1321     starti;                                                             \
1322     f(opc, 31, 30), f(0b011, 29, 27), f(V, 26), f(0b00, 25, 24),        \
1323       sf(offset, 23, 5);                                                \
1324     f(op, 4, 0);                                                        \
1325   }                                                                     \
1326   void NAME(Label &amp;L, prfop op = PLDL1KEEP) {                           \
1327     wrap_label(L, op, &amp;Assembler::NAME);                                \
1328   }
1329 
1330   INSN(prfm, 0b11, 0);
1331 
1332 #undef INSN
1333 
1334   // Load/store
1335   void ld_st1(int opc, int p1, int V, int L,
1336               Register Rt1, Register Rt2, Address adr, bool no_allocate) {
1337     starti;
1338     f(opc, 31, 30), f(p1, 29, 27), f(V, 26), f(L, 22);
1339     zrf(Rt2, 10), zrf(Rt1, 0);
1340     if (no_allocate) {
1341       adr.encode_nontemporal_pair(current);
1342     } else {
1343       adr.encode_pair(current);
1344     }
1345   }
1346 
1347   // Load/store register pair (offset)
1348 #define INSN(NAME, size, p1, V, L, no_allocate)         \
1349   void NAME(Register Rt1, Register Rt2, Address adr) {  \
1350     ld_st1(size, p1, V, L, Rt1, Rt2, adr, no_allocate); \
1351    }
1352 
1353   INSN(stpw, 0b00, 0b101, 0, 0, false);
1354   INSN(ldpw, 0b00, 0b101, 0, 1, false);
1355   INSN(ldpsw, 0b01, 0b101, 0, 1, false);
1356   INSN(stp, 0b10, 0b101, 0, 0, false);
1357   INSN(ldp, 0b10, 0b101, 0, 1, false);
1358 
1359   // Load/store no-allocate pair (offset)
1360   INSN(stnpw, 0b00, 0b101, 0, 0, true);
1361   INSN(ldnpw, 0b00, 0b101, 0, 1, true);
1362   INSN(stnp, 0b10, 0b101, 0, 0, true);
1363   INSN(ldnp, 0b10, 0b101, 0, 1, true);
1364 
1365 #undef INSN
1366 
1367 #define INSN(NAME, size, p1, V, L, no_allocate)                         \
1368   void NAME(FloatRegister Rt1, FloatRegister Rt2, Address adr) {        \
1369     ld_st1(size, p1, V, L, (Register)Rt1, (Register)Rt2, adr, no_allocate); \
1370    }
1371 
1372   INSN(stps, 0b00, 0b101, 1, 0, false);
1373   INSN(ldps, 0b00, 0b101, 1, 1, false);
1374   INSN(stpd, 0b01, 0b101, 1, 0, false);
1375   INSN(ldpd, 0b01, 0b101, 1, 1, false);
1376   INSN(stpq, 0b10, 0b101, 1, 0, false);
1377   INSN(ldpq, 0b10, 0b101, 1, 1, false);
1378 
1379 #undef INSN
1380 
1381   // Load/store register (all modes)
1382   void ld_st2(Register Rt, const Address &amp;adr, int size, int op, int V = 0) {
1383     starti;
1384 
1385     f(V, 26); // general reg?
1386     zrf(Rt, 0);
1387 
1388     // Encoding for literal loads is done here (rather than pushed
1389     // down into Address::encode) because the encoding of this
1390     // instruction is too different from all of the other forms to
1391     // make it worth sharing.
1392     if (adr.getMode() == Address::literal) {
1393       assert(size == 0b10 || size == 0b11, &quot;bad operand size in ldr&quot;);
1394       assert(op == 0b01, &quot;literal form can only be used with loads&quot;);
1395       f(size &amp; 0b01, 31, 30), f(0b011, 29, 27), f(0b00, 25, 24);
1396       long offset = (adr.target() - pc()) &gt;&gt; 2;
1397       sf(offset, 23, 5);
1398       code_section()-&gt;relocate(pc(), adr.rspec());
1399       return;
1400     }
1401 
1402     f(size, 31, 30);
1403     f(op, 23, 22); // str
1404     adr.encode(current);
1405   }
1406 
1407 #define INSN(NAME, size, op)                            \
1408   void NAME(Register Rt, const Address &amp;adr) {          \
1409     ld_st2(Rt, adr, size, op);                          \
1410   }                                                     \
1411 
1412   INSN(str, 0b11, 0b00);
1413   INSN(strw, 0b10, 0b00);
1414   INSN(strb, 0b00, 0b00);
1415   INSN(strh, 0b01, 0b00);
1416 
1417   INSN(ldr, 0b11, 0b01);
1418   INSN(ldrw, 0b10, 0b01);
1419   INSN(ldrb, 0b00, 0b01);
1420   INSN(ldrh, 0b01, 0b01);
1421 
1422   INSN(ldrsb, 0b00, 0b10);
1423   INSN(ldrsbw, 0b00, 0b11);
1424   INSN(ldrsh, 0b01, 0b10);
1425   INSN(ldrshw, 0b01, 0b11);
1426   INSN(ldrsw, 0b10, 0b10);
1427 
1428 #undef INSN
1429 
1430 #define INSN(NAME, size, op)                                    \
1431   void NAME(const Address &amp;adr, prfop pfop = PLDL1KEEP) {       \
1432     ld_st2((Register)pfop, adr, size, op);                      \
1433   }
1434 
1435   INSN(prfm, 0b11, 0b10); // FIXME: PRFM should not be used with
1436                           // writeback modes, but the assembler
1437                           // doesn&#39;t enfore that.
1438 
1439 #undef INSN
1440 
1441 #define INSN(NAME, size, op)                            \
1442   void NAME(FloatRegister Rt, const Address &amp;adr) {     \
1443     ld_st2((Register)Rt, adr, size, op, 1);             \
1444   }
1445 
1446   INSN(strd, 0b11, 0b00);
1447   INSN(strs, 0b10, 0b00);
1448   INSN(ldrd, 0b11, 0b01);
1449   INSN(ldrs, 0b10, 0b01);
1450   INSN(strq, 0b00, 0b10);
1451   INSN(ldrq, 0x00, 0b11);
1452 
1453 #undef INSN
1454 
1455   enum shift_kind { LSL, LSR, ASR, ROR };
1456 
1457   void op_shifted_reg(unsigned decode,
1458                       enum shift_kind kind, unsigned shift,
1459                       unsigned size, unsigned op) {
1460     f(size, 31);
1461     f(op, 30, 29);
1462     f(decode, 28, 24);
1463     f(shift, 15, 10);
1464     f(kind, 23, 22);
1465   }
1466 
1467   // Logical (shifted register)
1468 #define INSN(NAME, size, op, N)                                 \
1469   void NAME(Register Rd, Register Rn, Register Rm,              \
1470             enum shift_kind kind = LSL, unsigned shift = 0) {   \
1471     starti;                                                     \
<a name="22" id="anc22"></a>
1472     f(N, 21);                                                   \
1473     zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                        \
1474     op_shifted_reg(0b01010, kind, shift, size, op);             \
1475   }
1476 
1477   INSN(andr, 1, 0b00, 0);
1478   INSN(orr, 1, 0b01, 0);
1479   INSN(eor, 1, 0b10, 0);
1480   INSN(ands, 1, 0b11, 0);
1481   INSN(andw, 0, 0b00, 0);
1482   INSN(orrw, 0, 0b01, 0);
1483   INSN(eorw, 0, 0b10, 0);
1484   INSN(andsw, 0, 0b11, 0);
1485 
<a name="23" id="anc23"></a>


















1486   INSN(bic, 1, 0b00, 1);
1487   INSN(orn, 1, 0b01, 1);
1488   INSN(eon, 1, 0b10, 1);
1489   INSN(bics, 1, 0b11, 1);
1490   INSN(bicw, 0, 0b00, 1);
1491   INSN(ornw, 0, 0b01, 1);
1492   INSN(eonw, 0, 0b10, 1);
1493   INSN(bicsw, 0, 0b11, 1);
1494 
1495 #undef INSN
1496 
1497   // Aliases for short forms of orn
1498 void mvn(Register Rd, Register Rm,
1499             enum shift_kind kind = LSL, unsigned shift = 0) {
1500   orn(Rd, zr, Rm, kind, shift);
1501 }
1502 
1503 void mvnw(Register Rd, Register Rm,
1504             enum shift_kind kind = LSL, unsigned shift = 0) {
1505   ornw(Rd, zr, Rm, kind, shift);
1506 }
1507 
1508   // Add/subtract (shifted register)
1509 #define INSN(NAME, size, op)                            \
1510   void NAME(Register Rd, Register Rn, Register Rm,      \
1511             enum shift_kind kind, unsigned shift = 0) { \
1512     starti;                                             \
1513     f(0, 21);                                           \
1514     assert_cond(kind != ROR);                           \
<a name="24" id="anc24"></a>
1515     zrf(Rd, 0), zrf(Rn, 5), zrf(Rm, 16);                \
1516     op_shifted_reg(0b01011, kind, shift, size, op);     \
1517   }
1518 
1519   INSN(add, 1, 0b000);
1520   INSN(sub, 1, 0b10);
1521   INSN(addw, 0, 0b000);
1522   INSN(subw, 0, 0b10);
1523 
1524   INSN(adds, 1, 0b001);
1525   INSN(subs, 1, 0b11);
1526   INSN(addsw, 0, 0b001);
1527   INSN(subsw, 0, 0b11);
1528 
1529 #undef INSN
1530 
1531   // Add/subtract (extended register)
1532 #define INSN(NAME, op)                                                  \
1533   void NAME(Register Rd, Register Rn, Register Rm,                      \
1534            ext::operation option, int amount = 0) {                     \
1535     starti;                                                             \
1536     zrf(Rm, 16), srf(Rn, 5), srf(Rd, 0);                                \
1537     add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \
1538   }
1539 
1540   void add_sub_extended_reg(unsigned op, unsigned decode,
1541     Register Rd, Register Rn, Register Rm,
1542     unsigned opt, ext::operation option, unsigned imm) {
<a name="25" id="anc25"></a><span class="line-modified">1543     guarantee(imm &lt;= 4, &quot;shift amount must be &lt; 4&quot;);</span>
1544     f(op, 31, 29), f(decode, 28, 24), f(opt, 23, 22), f(1, 21);
1545     f(option, 15, 13), f(imm, 12, 10);
1546   }
1547 
1548   INSN(addw, 0b000);
1549   INSN(subw, 0b010);
1550   INSN(add, 0b100);
1551   INSN(sub, 0b110);
1552 
1553 #undef INSN
1554 
1555 #define INSN(NAME, op)                                                  \
1556   void NAME(Register Rd, Register Rn, Register Rm,                      \
1557            ext::operation option, int amount = 0) {                     \
1558     starti;                                                             \
1559     zrf(Rm, 16), srf(Rn, 5), zrf(Rd, 0);                                \
1560     add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \
1561   }
1562 
1563   INSN(addsw, 0b001);
1564   INSN(subsw, 0b011);
1565   INSN(adds, 0b101);
1566   INSN(subs, 0b111);
1567 
1568 #undef INSN
1569 
1570   // Aliases for short forms of add and sub
1571 #define INSN(NAME)                                      \
1572   void NAME(Register Rd, Register Rn, Register Rm) {    \
1573     if (Rd == sp || Rn == sp)                           \
1574       NAME(Rd, Rn, Rm, ext::uxtx);                      \
1575     else                                                \
1576       NAME(Rd, Rn, Rm, LSL);                            \
1577   }
1578 
1579   INSN(addw);
1580   INSN(subw);
1581   INSN(add);
1582   INSN(sub);
1583 
1584   INSN(addsw);
1585   INSN(subsw);
1586   INSN(adds);
1587   INSN(subs);
1588 
1589 #undef INSN
1590 
1591   // Add/subtract (with carry)
1592   void add_sub_carry(unsigned op, Register Rd, Register Rn, Register Rm) {
1593     starti;
1594     f(op, 31, 29);
1595     f(0b11010000, 28, 21);
1596     f(0b000000, 15, 10);
1597     zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);
1598   }
1599 
1600   #define INSN(NAME, op)                                \
1601     void NAME(Register Rd, Register Rn, Register Rm) {  \
1602       add_sub_carry(op, Rd, Rn, Rm);                    \
1603     }
1604 
1605   INSN(adcw, 0b000);
1606   INSN(adcsw, 0b001);
1607   INSN(sbcw, 0b010);
1608   INSN(sbcsw, 0b011);
1609   INSN(adc, 0b100);
1610   INSN(adcs, 0b101);
1611   INSN(sbc,0b110);
1612   INSN(sbcs, 0b111);
1613 
1614 #undef INSN
1615 
1616   // Conditional compare (both kinds)
1617   void conditional_compare(unsigned op, int o1, int o2, int o3,
1618                            Register Rn, unsigned imm5, unsigned nzcv,
1619                            unsigned cond) {
1620     starti;
1621     f(op, 31, 29);
1622     f(0b11010010, 28, 21);
1623     f(cond, 15, 12);
1624     f(o1, 11);
1625     f(o2, 10);
1626     f(o3, 4);
1627     f(nzcv, 3, 0);
<a name="26" id="anc26"></a><span class="line-modified">1628     f(imm5, 20, 16), rf(Rn, 5);</span>
1629   }
1630 
1631 #define INSN(NAME, op)                                                  \
1632   void NAME(Register Rn, Register Rm, int imm, Condition cond) {        \
1633     int regNumber = (Rm == zr ? 31 : (uintptr_t)Rm);                    \
1634     conditional_compare(op, 0, 0, 0, Rn, regNumber, imm, cond);         \
1635   }                                                                     \
1636                                                                         \
1637   void NAME(Register Rn, int imm5, int imm, Condition cond) {           \
1638     conditional_compare(op, 1, 0, 0, Rn, imm5, imm, cond);              \
1639   }
1640 
1641   INSN(ccmnw, 0b001);
1642   INSN(ccmpw, 0b011);
1643   INSN(ccmn, 0b101);
1644   INSN(ccmp, 0b111);
1645 
1646 #undef INSN
1647 
1648   // Conditional select
1649   void conditional_select(unsigned op, unsigned op2,
1650                           Register Rd, Register Rn, Register Rm,
1651                           unsigned cond) {
1652     starti;
1653     f(op, 31, 29);
1654     f(0b11010100, 28, 21);
1655     f(cond, 15, 12);
1656     f(op2, 11, 10);
1657     zrf(Rm, 16), zrf(Rn, 5), rf(Rd, 0);
1658   }
1659 
1660 #define INSN(NAME, op, op2)                                             \
1661   void NAME(Register Rd, Register Rn, Register Rm, Condition cond) { \
1662     conditional_select(op, op2, Rd, Rn, Rm, cond);                      \
1663   }
1664 
1665   INSN(cselw, 0b000, 0b00);
1666   INSN(csincw, 0b000, 0b01);
1667   INSN(csinvw, 0b010, 0b00);
1668   INSN(csnegw, 0b010, 0b01);
1669   INSN(csel, 0b100, 0b00);
1670   INSN(csinc, 0b100, 0b01);
1671   INSN(csinv, 0b110, 0b00);
1672   INSN(csneg, 0b110, 0b01);
1673 
1674 #undef INSN
1675 
1676   // Data processing
1677   void data_processing(unsigned op29, unsigned opcode,
1678                        Register Rd, Register Rn) {
1679     f(op29, 31, 29), f(0b11010110, 28, 21);
1680     f(opcode, 15, 10);
1681     rf(Rn, 5), rf(Rd, 0);
1682   }
1683 
1684   // (1 source)
1685 #define INSN(NAME, op29, opcode2, opcode)       \
1686   void NAME(Register Rd, Register Rn) {         \
1687     starti;                                     \
1688     f(opcode2, 20, 16);                         \
1689     data_processing(op29, opcode, Rd, Rn);      \
1690   }
1691 
1692   INSN(rbitw,  0b010, 0b00000, 0b00000);
1693   INSN(rev16w, 0b010, 0b00000, 0b00001);
1694   INSN(revw,   0b010, 0b00000, 0b00010);
1695   INSN(clzw,   0b010, 0b00000, 0b00100);
1696   INSN(clsw,   0b010, 0b00000, 0b00101);
1697 
1698   INSN(rbit,   0b110, 0b00000, 0b00000);
1699   INSN(rev16,  0b110, 0b00000, 0b00001);
1700   INSN(rev32,  0b110, 0b00000, 0b00010);
1701   INSN(rev,    0b110, 0b00000, 0b00011);
1702   INSN(clz,    0b110, 0b00000, 0b00100);
1703   INSN(cls,    0b110, 0b00000, 0b00101);
1704 
1705 #undef INSN
1706 
1707   // (2 sources)
1708 #define INSN(NAME, op29, opcode)                        \
1709   void NAME(Register Rd, Register Rn, Register Rm) {    \
1710     starti;                                             \
1711     rf(Rm, 16);                                         \
1712     data_processing(op29, opcode, Rd, Rn);              \
1713   }
1714 
1715   INSN(udivw, 0b000, 0b000010);
1716   INSN(sdivw, 0b000, 0b000011);
1717   INSN(lslvw, 0b000, 0b001000);
1718   INSN(lsrvw, 0b000, 0b001001);
1719   INSN(asrvw, 0b000, 0b001010);
1720   INSN(rorvw, 0b000, 0b001011);
1721 
1722   INSN(udiv, 0b100, 0b000010);
1723   INSN(sdiv, 0b100, 0b000011);
1724   INSN(lslv, 0b100, 0b001000);
1725   INSN(lsrv, 0b100, 0b001001);
1726   INSN(asrv, 0b100, 0b001010);
1727   INSN(rorv, 0b100, 0b001011);
1728 
1729 #undef INSN
1730 
1731   // (3 sources)
1732   void data_processing(unsigned op54, unsigned op31, unsigned o0,
1733                        Register Rd, Register Rn, Register Rm,
1734                        Register Ra) {
1735     starti;
1736     f(op54, 31, 29), f(0b11011, 28, 24);
1737     f(op31, 23, 21), f(o0, 15);
1738     zrf(Rm, 16), zrf(Ra, 10), zrf(Rn, 5), zrf(Rd, 0);
1739   }
1740 
1741 #define INSN(NAME, op54, op31, o0)                                      \
1742   void NAME(Register Rd, Register Rn, Register Rm, Register Ra) {       \
1743     data_processing(op54, op31, o0, Rd, Rn, Rm, Ra);                    \
1744   }
1745 
1746   INSN(maddw, 0b000, 0b000, 0);
1747   INSN(msubw, 0b000, 0b000, 1);
1748   INSN(madd, 0b100, 0b000, 0);
1749   INSN(msub, 0b100, 0b000, 1);
1750   INSN(smaddl, 0b100, 0b001, 0);
1751   INSN(smsubl, 0b100, 0b001, 1);
1752   INSN(umaddl, 0b100, 0b101, 0);
1753   INSN(umsubl, 0b100, 0b101, 1);
1754 
1755 #undef INSN
1756 
1757 #define INSN(NAME, op54, op31, o0)                      \
1758   void NAME(Register Rd, Register Rn, Register Rm) {    \
1759     data_processing(op54, op31, o0, Rd, Rn, Rm, (Register)31);  \
1760   }
1761 
1762   INSN(smulh, 0b100, 0b010, 0);
1763   INSN(umulh, 0b100, 0b110, 0);
1764 
1765 #undef INSN
1766 
1767   // Floating-point data-processing (1 source)
1768   void data_processing(unsigned op31, unsigned type, unsigned opcode,
1769                        FloatRegister Vd, FloatRegister Vn) {
1770     starti;
1771     f(op31, 31, 29);
1772     f(0b11110, 28, 24);
1773     f(type, 23, 22), f(1, 21), f(opcode, 20, 15), f(0b10000, 14, 10);
1774     rf(Vn, 5), rf(Vd, 0);
1775   }
1776 
1777 #define INSN(NAME, op31, type, opcode)                  \
1778   void NAME(FloatRegister Vd, FloatRegister Vn) {       \
1779     data_processing(op31, type, opcode, Vd, Vn);        \
1780   }
1781 
1782 private:
1783   INSN(i_fmovs, 0b000, 0b00, 0b000000);
1784 public:
1785   INSN(fabss, 0b000, 0b00, 0b000001);
1786   INSN(fnegs, 0b000, 0b00, 0b000010);
1787   INSN(fsqrts, 0b000, 0b00, 0b000011);
1788   INSN(fcvts, 0b000, 0b00, 0b000101);   // Single-precision to double-precision
1789 
1790 private:
1791   INSN(i_fmovd, 0b000, 0b01, 0b000000);
1792 public:
1793   INSN(fabsd, 0b000, 0b01, 0b000001);
1794   INSN(fnegd, 0b000, 0b01, 0b000010);
1795   INSN(fsqrtd, 0b000, 0b01, 0b000011);
1796   INSN(fcvtd, 0b000, 0b01, 0b000100);   // Double-precision to single-precision
1797 
1798   void fmovd(FloatRegister Vd, FloatRegister Vn) {
1799     assert(Vd != Vn, &quot;should be&quot;);
1800     i_fmovd(Vd, Vn);
1801   }
1802 
1803   void fmovs(FloatRegister Vd, FloatRegister Vn) {
1804     assert(Vd != Vn, &quot;should be&quot;);
1805     i_fmovs(Vd, Vn);
1806   }
1807 
1808 #undef INSN
1809 
1810   // Floating-point data-processing (2 source)
1811   void data_processing(unsigned op31, unsigned type, unsigned opcode,
1812                        FloatRegister Vd, FloatRegister Vn, FloatRegister Vm) {
1813     starti;
1814     f(op31, 31, 29);
1815     f(0b11110, 28, 24);
1816     f(type, 23, 22), f(1, 21), f(opcode, 15, 12), f(0b10, 11, 10);
1817     rf(Vm, 16), rf(Vn, 5), rf(Vd, 0);
1818   }
1819 
1820 #define INSN(NAME, op31, type, opcode)                  \
1821   void NAME(FloatRegister Vd, FloatRegister Vn, FloatRegister Vm) {     \
1822     data_processing(op31, type, opcode, Vd, Vn, Vm);    \
1823   }
1824 
1825   INSN(fmuls, 0b000, 0b00, 0b0000);
1826   INSN(fdivs, 0b000, 0b00, 0b0001);
1827   INSN(fadds, 0b000, 0b00, 0b0010);
1828   INSN(fsubs, 0b000, 0b00, 0b0011);
1829   INSN(fmaxs, 0b000, 0b00, 0b0100);
1830   INSN(fmins, 0b000, 0b00, 0b0101);
1831   INSN(fnmuls, 0b000, 0b00, 0b1000);
1832 
1833   INSN(fmuld, 0b000, 0b01, 0b0000);
1834   INSN(fdivd, 0b000, 0b01, 0b0001);
1835   INSN(faddd, 0b000, 0b01, 0b0010);
1836   INSN(fsubd, 0b000, 0b01, 0b0011);
1837   INSN(fmaxd, 0b000, 0b01, 0b0100);
1838   INSN(fmind, 0b000, 0b01, 0b0101);
1839   INSN(fnmuld, 0b000, 0b01, 0b1000);
1840 
1841 #undef INSN
1842 
1843    // Floating-point data-processing (3 source)
1844   void data_processing(unsigned op31, unsigned type, unsigned o1, unsigned o0,
1845                        FloatRegister Vd, FloatRegister Vn, FloatRegister Vm,
1846                        FloatRegister Va) {
1847     starti;
1848     f(op31, 31, 29);
1849     f(0b11111, 28, 24);
1850     f(type, 23, 22), f(o1, 21), f(o0, 15);
1851     rf(Vm, 16), rf(Va, 10), rf(Vn, 5), rf(Vd, 0);
1852   }
1853 
1854 #define INSN(NAME, op31, type, o1, o0)                                  \
1855   void NAME(FloatRegister Vd, FloatRegister Vn, FloatRegister Vm,       \
1856             FloatRegister Va) {                                         \
1857     data_processing(op31, type, o1, o0, Vd, Vn, Vm, Va);                \
1858   }
1859 
1860   INSN(fmadds, 0b000, 0b00, 0, 0);
1861   INSN(fmsubs, 0b000, 0b00, 0, 1);
1862   INSN(fnmadds, 0b000, 0b00, 1, 0);
1863   INSN(fnmsubs, 0b000, 0b00, 1, 1);
1864 
1865   INSN(fmaddd, 0b000, 0b01, 0, 0);
1866   INSN(fmsubd, 0b000, 0b01, 0, 1);
1867   INSN(fnmaddd, 0b000, 0b01, 1, 0);
1868   INSN(fnmsub, 0b000, 0b01, 1, 1);
1869 
1870 #undef INSN
1871 
1872    // Floating-point conditional select
1873   void fp_conditional_select(unsigned op31, unsigned type,
1874                              unsigned op1, unsigned op2,
1875                              Condition cond, FloatRegister Vd,
1876                              FloatRegister Vn, FloatRegister Vm) {
1877     starti;
1878     f(op31, 31, 29);
1879     f(0b11110, 28, 24);
1880     f(type, 23, 22);
1881     f(op1, 21, 21);
1882     f(op2, 11, 10);
1883     f(cond, 15, 12);
1884     rf(Vm, 16), rf(Vn, 5), rf(Vd, 0);
1885   }
1886 
1887 #define INSN(NAME, op31, type, op1, op2)                                \
1888   void NAME(FloatRegister Vd, FloatRegister Vn,                         \
1889             FloatRegister Vm, Condition cond) {                         \
1890     fp_conditional_select(op31, type, op1, op2, cond, Vd, Vn, Vm);      \
1891   }
1892 
1893   INSN(fcsels, 0b000, 0b00, 0b1, 0b11);
1894   INSN(fcseld, 0b000, 0b01, 0b1, 0b11);
1895 
1896 #undef INSN
1897 
1898    // Floating-point&lt;-&gt;integer conversions
1899   void float_int_convert(unsigned op31, unsigned type,
1900                          unsigned rmode, unsigned opcode,
1901                          Register Rd, Register Rn) {
1902     starti;
1903     f(op31, 31, 29);
1904     f(0b11110, 28, 24);
1905     f(type, 23, 22), f(1, 21), f(rmode, 20, 19);
1906     f(opcode, 18, 16), f(0b000000, 15, 10);
1907     zrf(Rn, 5), zrf(Rd, 0);
1908   }
1909 
1910 #define INSN(NAME, op31, type, rmode, opcode)                           \
1911   void NAME(Register Rd, FloatRegister Vn) {                            \
1912     float_int_convert(op31, type, rmode, opcode, Rd, (Register)Vn);     \
1913   }
1914 
1915   INSN(fcvtzsw, 0b000, 0b00, 0b11, 0b000);
1916   INSN(fcvtzs,  0b100, 0b00, 0b11, 0b000);
1917   INSN(fcvtzdw, 0b000, 0b01, 0b11, 0b000);
1918   INSN(fcvtzd,  0b100, 0b01, 0b11, 0b000);
1919 
1920   INSN(fmovs, 0b000, 0b00, 0b00, 0b110);
1921   INSN(fmovd, 0b100, 0b01, 0b00, 0b110);
1922 
1923   // INSN(fmovhid, 0b100, 0b10, 0b01, 0b110);
1924 
1925 #undef INSN
1926 
1927 #define INSN(NAME, op31, type, rmode, opcode)                           \
1928   void NAME(FloatRegister Vd, Register Rn) {                            \
1929     float_int_convert(op31, type, rmode, opcode, (Register)Vd, Rn);     \
1930   }
1931 
1932   INSN(fmovs, 0b000, 0b00, 0b00, 0b111);
1933   INSN(fmovd, 0b100, 0b01, 0b00, 0b111);
1934 
1935   INSN(scvtfws, 0b000, 0b00, 0b00, 0b010);
1936   INSN(scvtfs,  0b100, 0b00, 0b00, 0b010);
1937   INSN(scvtfwd, 0b000, 0b01, 0b00, 0b010);
1938   INSN(scvtfd,  0b100, 0b01, 0b00, 0b010);
1939 
1940   // INSN(fmovhid, 0b100, 0b10, 0b01, 0b111);
1941 
1942 #undef INSN
1943 
1944   // Floating-point compare
1945   void float_compare(unsigned op31, unsigned type,
1946                      unsigned op, unsigned op2,
1947                      FloatRegister Vn, FloatRegister Vm = (FloatRegister)0) {
1948     starti;
1949     f(op31, 31, 29);
1950     f(0b11110, 28, 24);
1951     f(type, 23, 22), f(1, 21);
1952     f(op, 15, 14), f(0b1000, 13, 10), f(op2, 4, 0);
1953     rf(Vn, 5), rf(Vm, 16);
1954   }
1955 
1956 
1957 #define INSN(NAME, op31, type, op, op2)                 \
1958   void NAME(FloatRegister Vn, FloatRegister Vm) {       \
1959     float_compare(op31, type, op, op2, Vn, Vm);         \
1960   }
1961 
1962 #define INSN1(NAME, op31, type, op, op2)        \
1963   void NAME(FloatRegister Vn, double d) {       \
1964     assert_cond(d == 0.0);                      \
1965     float_compare(op31, type, op, op2, Vn);     \
1966   }
1967 
1968   INSN(fcmps, 0b000, 0b00, 0b00, 0b00000);
1969   INSN1(fcmps, 0b000, 0b00, 0b00, 0b01000);
1970   // INSN(fcmpes, 0b000, 0b00, 0b00, 0b10000);
1971   // INSN1(fcmpes, 0b000, 0b00, 0b00, 0b11000);
1972 
1973   INSN(fcmpd, 0b000,   0b01, 0b00, 0b00000);
1974   INSN1(fcmpd, 0b000,  0b01, 0b00, 0b01000);
1975   // INSN(fcmped, 0b000,  0b01, 0b00, 0b10000);
1976   // INSN1(fcmped, 0b000, 0b01, 0b00, 0b11000);
1977 
1978 #undef INSN
1979 #undef INSN1
1980 
1981   // Floating-point Move (immediate)
1982 private:
1983   unsigned pack(double value);
1984 
1985   void fmov_imm(FloatRegister Vn, double value, unsigned size) {
1986     starti;
1987     f(0b00011110, 31, 24), f(size, 23, 22), f(1, 21);
1988     f(pack(value), 20, 13), f(0b10000000, 12, 5);
1989     rf(Vn, 0);
1990   }
1991 
1992 public:
1993 
1994   void fmovs(FloatRegister Vn, double value) {
1995     if (value)
1996       fmov_imm(Vn, value, 0b00);
1997     else
1998       fmovs(Vn, zr);
1999   }
2000   void fmovd(FloatRegister Vn, double value) {
2001     if (value)
2002       fmov_imm(Vn, value, 0b01);
2003     else
2004       fmovd(Vn, zr);
2005   }
2006 
2007    // Floating-point rounding
2008    // type: half-precision = 11
2009    //       single         = 00
2010    //       double         = 01
2011    // rmode: A = Away     = 100
2012    //        I = current  = 111
2013    //        M = MinusInf = 010
2014    //        N = eveN     = 000
2015    //        P = PlusInf  = 001
2016    //        X = eXact    = 110
2017    //        Z = Zero     = 011
2018   void float_round(unsigned type, unsigned rmode, FloatRegister Rd, FloatRegister Rn) {
2019     starti;
2020     f(0b00011110, 31, 24);
2021     f(type, 23, 22);
2022     f(0b1001, 21, 18);
2023     f(rmode, 17, 15);
2024     f(0b10000, 14, 10);
2025     rf(Rn, 5), rf(Rd, 0);
2026   }
2027 #define INSN(NAME, type, rmode)                   \
2028   void NAME(FloatRegister Vd, FloatRegister Vn) { \
2029     float_round(type, rmode, Vd, Vn);             \
2030   }
2031 
2032 public:
2033   INSN(frintah, 0b11, 0b100);
2034   INSN(frintih, 0b11, 0b111);
2035   INSN(frintmh, 0b11, 0b010);
2036   INSN(frintnh, 0b11, 0b000);
2037   INSN(frintph, 0b11, 0b001);
2038   INSN(frintxh, 0b11, 0b110);
2039   INSN(frintzh, 0b11, 0b011);
2040 
2041   INSN(frintas, 0b00, 0b100);
2042   INSN(frintis, 0b00, 0b111);
2043   INSN(frintms, 0b00, 0b010);
2044   INSN(frintns, 0b00, 0b000);
2045   INSN(frintps, 0b00, 0b001);
2046   INSN(frintxs, 0b00, 0b110);
2047   INSN(frintzs, 0b00, 0b011);
2048 
2049   INSN(frintad, 0b01, 0b100);
2050   INSN(frintid, 0b01, 0b111);
2051   INSN(frintmd, 0b01, 0b010);
2052   INSN(frintnd, 0b01, 0b000);
2053   INSN(frintpd, 0b01, 0b001);
2054   INSN(frintxd, 0b01, 0b110);
2055   INSN(frintzd, 0b01, 0b011);
2056 #undef INSN
2057 
2058 /* SIMD extensions
2059  *
2060  * We just use FloatRegister in the following. They are exactly the same
2061  * as SIMD registers.
2062  */
2063  public:
2064 
2065   enum SIMD_Arrangement {
2066        T8B, T16B, T4H, T8H, T2S, T4S, T1D, T2D, T1Q
2067   };
2068 
2069   enum SIMD_RegVariant {
2070        B, H, S, D, Q
2071   };
2072 
2073 private:
2074   static short SIMD_Size_in_bytes[];
2075 
2076 public:
2077 #define INSN(NAME, op)                                            \
2078   void NAME(FloatRegister Rt, SIMD_RegVariant T, const Address &amp;adr) {   \
2079     ld_st2((Register)Rt, adr, (int)T &amp; 3, op + ((T==Q) ? 0b10:0b00), 1); \
2080   }                                                                      \
2081 
2082   INSN(ldr, 1);
2083   INSN(str, 0);
2084 
2085 #undef INSN
2086 
2087  private:
2088 
2089   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn, int op1, int op2) {
2090     starti;
2091     f(0,31), f((int)T &amp; 1, 30);
2092     f(op1, 29, 21), f(0, 20, 16), f(op2, 15, 12);
2093     f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
2094   }
2095   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn,
2096              int imm, int op1, int op2, int regs) {
<a name="27" id="anc27"></a><span class="line-modified">2097     guarantee(T &lt;= T1Q &amp;&amp; imm == SIMD_Size_in_bytes[T] * regs, &quot;bad offset&quot;);</span>





2098     starti;
2099     f(0,31), f((int)T &amp; 1, 30);
2100     f(op1 | 0b100, 29, 21), f(0b11111, 20, 16), f(op2, 15, 12);
2101     f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
2102   }
2103   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn,
2104              Register Xm, int op1, int op2) {
2105     starti;
2106     f(0,31), f((int)T &amp; 1, 30);
2107     f(op1 | 0b100, 29, 21), rf(Xm, 16), f(op2, 15, 12);
2108     f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
2109   }
2110 
2111   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Address a, int op1, int op2, int regs) {
2112     switch (a.getMode()) {
2113     case Address::base_plus_offset:
2114       guarantee(a.offset() == 0, &quot;no offset allowed here&quot;);
2115       ld_st(Vt, T, a.base(), op1, op2);
2116       break;
2117     case Address::post:
2118       ld_st(Vt, T, a.base(), a.offset(), op1, op2, regs);
2119       break;
2120     case Address::post_reg:
2121       ld_st(Vt, T, a.base(), a.index(), op1, op2);
2122       break;
2123     default:
2124       ShouldNotReachHere();
2125     }
2126   }
2127 
2128  public:
2129 
2130 #define INSN1(NAME, op1, op2)                                           \
2131   void NAME(FloatRegister Vt, SIMD_Arrangement T, const Address &amp;a) {   \
2132     ld_st(Vt, T, a, op1, op2, 1);                                       \
2133  }
2134 
2135 #define INSN2(NAME, op1, op2)                                           \
2136   void NAME(FloatRegister Vt, FloatRegister Vt2, SIMD_Arrangement T, const Address &amp;a) { \
2137     assert(Vt-&gt;successor() == Vt2, &quot;Registers must be ordered&quot;);        \
2138     ld_st(Vt, T, a, op1, op2, 2);                                       \
2139   }
2140 
2141 #define INSN3(NAME, op1, op2)                                           \
2142   void NAME(FloatRegister Vt, FloatRegister Vt2, FloatRegister Vt3,     \
2143             SIMD_Arrangement T, const Address &amp;a) {                     \
2144     assert(Vt-&gt;successor() == Vt2 &amp;&amp; Vt2-&gt;successor() == Vt3,           \
2145            &quot;Registers must be ordered&quot;);                                \
2146     ld_st(Vt, T, a, op1, op2, 3);                                       \
2147   }
2148 
2149 #define INSN4(NAME, op1, op2)                                           \
2150   void NAME(FloatRegister Vt, FloatRegister Vt2, FloatRegister Vt3,     \
2151             FloatRegister Vt4, SIMD_Arrangement T, const Address &amp;a) {  \
2152     assert(Vt-&gt;successor() == Vt2 &amp;&amp; Vt2-&gt;successor() == Vt3 &amp;&amp;         \
2153            Vt3-&gt;successor() == Vt4, &quot;Registers must be ordered&quot;);       \
2154     ld_st(Vt, T, a, op1, op2, 4);                                       \
2155   }
2156 
2157   INSN1(ld1,  0b001100010, 0b0111);
2158   INSN2(ld1,  0b001100010, 0b1010);
2159   INSN3(ld1,  0b001100010, 0b0110);
2160   INSN4(ld1,  0b001100010, 0b0010);
2161 
2162   INSN2(ld2,  0b001100010, 0b1000);
2163   INSN3(ld3,  0b001100010, 0b0100);
2164   INSN4(ld4,  0b001100010, 0b0000);
2165 
2166   INSN1(st1,  0b001100000, 0b0111);
2167   INSN2(st1,  0b001100000, 0b1010);
2168   INSN3(st1,  0b001100000, 0b0110);
2169   INSN4(st1,  0b001100000, 0b0010);
2170 
2171   INSN2(st2,  0b001100000, 0b1000);
2172   INSN3(st3,  0b001100000, 0b0100);
2173   INSN4(st4,  0b001100000, 0b0000);
2174 
2175   INSN1(ld1r, 0b001101010, 0b1100);
2176   INSN2(ld2r, 0b001101011, 0b1100);
2177   INSN3(ld3r, 0b001101010, 0b1110);
2178   INSN4(ld4r, 0b001101011, 0b1110);
2179 
2180 #undef INSN1
2181 #undef INSN2
2182 #undef INSN3
2183 #undef INSN4
2184 
2185 #define INSN(NAME, opc)                                                                 \
2186   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
2187     starti;                                                                             \
2188     assert(T == T8B || T == T16B, &quot;must be T8B or T16B&quot;);                               \
2189     f(0, 31), f((int)T &amp; 1, 30), f(opc, 29, 21);                                        \
2190     rf(Vm, 16), f(0b000111, 15, 10), rf(Vn, 5), rf(Vd, 0);                              \
2191   }
2192 
2193   INSN(eor,  0b101110001);
2194   INSN(orr,  0b001110101);
2195   INSN(andr, 0b001110001);
2196   INSN(bic,  0b001110011);
2197   INSN(bif,  0b101110111);
2198   INSN(bit,  0b101110101);
2199   INSN(bsl,  0b101110011);
2200   INSN(orn,  0b001110111);
2201 
2202 #undef INSN
2203 
<a name="28" id="anc28"></a><span class="line-modified">2204 #define INSN(NAME, opc, opc2)                                                                 \</span>
2205   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
<a name="29" id="anc29"></a>

2206     starti;                                                                             \
2207     f(0, 31), f((int)T &amp; 1, 30), f(opc, 29), f(0b01110, 28, 24);                        \
2208     f((int)T &gt;&gt; 1, 23, 22), f(1, 21), rf(Vm, 16), f(opc2, 15, 10);                      \
2209     rf(Vn, 5), rf(Vd, 0);                                                               \
2210   }
2211 
<a name="30" id="anc30"></a><span class="line-modified">2212   INSN(addv,   0, 0b100001);</span>
<span class="line-modified">2213   INSN(subv,   1, 0b100001);</span>
<span class="line-modified">2214   INSN(mulv,   0, 0b100111);</span>
<span class="line-modified">2215   INSN(mlav,   0, 0b100101);</span>
<span class="line-modified">2216   INSN(mlsv,   1, 0b100101);</span>
<span class="line-modified">2217   INSN(sshl,   0, 0b010001);</span>
<span class="line-modified">2218   INSN(ushl,   1, 0b010001);</span>
<span class="line-modified">2219   INSN(umullv, 1, 0b110000);</span>
<span class="line-modified">2220   INSN(umlalv, 1, 0b100000);</span>
2221 
2222 #undef INSN
2223 
<a name="31" id="anc31"></a><span class="line-modified">2224 #define INSN(NAME, opc, opc2) \</span>
2225   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                   \
<a name="32" id="anc32"></a>


2226     starti;                                                                             \
2227     f(0, 31), f((int)T &amp; 1, 30), f(opc, 29), f(0b01110, 28, 24);                        \
2228     f((int)T &gt;&gt; 1, 23, 22), f(opc2, 21, 10);                                            \
2229     rf(Vn, 5), rf(Vd, 0);                                                               \
2230   }
2231 
<a name="33" id="anc33"></a><span class="line-modified">2232   INSN(absr,   0, 0b100000101110);</span>
<span class="line-modified">2233   INSN(negr,   1, 0b100000101110);</span>
<span class="line-modified">2234   INSN(notr,   1, 0b100000010110);</span>
<span class="line-modified">2235   INSN(addv,   0, 0b110001101110);</span>
<span class="line-modified">2236   INSN(cls,    0, 0b100000010010);</span>
<span class="line-modified">2237   INSN(clz,    1, 0b100000010010);</span>
<span class="line-modified">2238   INSN(cnt,    0, 0b100000010110);</span>
<span class="line-modified">2239   INSN(uaddlv, 1, 0b110000001110);</span>
2240 
2241 #undef INSN
2242 
2243 #define INSN(NAME, opc) \
2244   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                  \
2245     starti;                                                                            \
2246     assert(T == T4S, &quot;arrangement must be T4S&quot;);                                       \
2247     f(0, 31), f((int)T &amp; 1, 30), f(0b101110, 29, 24), f(opc, 23),                      \
2248     f(T == T4S ? 0 : 1, 22), f(0b110000111110, 21, 10); rf(Vn, 5), rf(Vd, 0);          \
2249   }
2250 
2251   INSN(fmaxv, 0);
2252   INSN(fminv, 1);
2253 
2254 #undef INSN
2255 
2256 #define INSN(NAME, op0, cmode0) \
2257   void NAME(FloatRegister Vd, SIMD_Arrangement T, unsigned imm8, unsigned lsl = 0) {   \
2258     unsigned cmode = cmode0;                                                           \
2259     unsigned op = op0;                                                                 \
2260     starti;                                                                            \
2261     assert(lsl == 0 ||                                                                 \
2262            ((T == T4H || T == T8H) &amp;&amp; lsl == 8) ||                                     \
<a name="34" id="anc34"></a><span class="line-modified">2263            ((T == T2S || T == T4S) &amp;&amp; ((lsl &gt;&gt; 3) &lt; 4)), &quot;invalid shift&quot;);             \</span>
2264     cmode |= lsl &gt;&gt; 2;                                                                 \
2265     if (T == T4H || T == T8H) cmode |= 0b1000;                                         \
2266     if (!(T == T4H || T == T8H || T == T2S || T == T4S)) {                             \
2267       assert(op == 0 &amp;&amp; cmode0 == 0, &quot;must be MOVI&quot;);                                  \
2268       cmode = 0b1110;                                                                  \
2269       if (T == T1D || T == T2D) op = 1;                                                \
2270     }                                                                                  \
2271     f(0, 31), f((int)T &amp; 1, 30), f(op, 29), f(0b0111100000, 28, 19);                   \
2272     f(imm8 &gt;&gt; 5, 18, 16), f(cmode, 15, 12), f(0x01, 11, 10), f(imm8 &amp; 0b11111, 9, 5);  \
2273     rf(Vd, 0);                                                                         \
2274   }
2275 
2276   INSN(movi, 0, 0);
2277   INSN(orri, 0, 1);
2278   INSN(mvni, 1, 0);
2279   INSN(bici, 1, 1);
2280 
2281 #undef INSN
2282 
2283 #define INSN(NAME, op1, op2, op3) \
2284   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
2285     starti;                                                                             \
2286     assert(T == T2S || T == T4S || T == T2D, &quot;invalid arrangement&quot;);                    \
2287     f(0, 31), f((int)T &amp; 1, 30), f(op1, 29), f(0b01110, 28, 24), f(op2, 23);            \
2288     f(T==T2D ? 1:0, 22); f(1, 21), rf(Vm, 16), f(op3, 15, 10), rf(Vn, 5), rf(Vd, 0);    \
2289   }
2290 
2291   INSN(fadd, 0, 0, 0b110101);
2292   INSN(fdiv, 1, 0, 0b111111);
2293   INSN(fmul, 1, 0, 0b110111);
2294   INSN(fsub, 0, 1, 0b110101);
2295   INSN(fmla, 0, 0, 0b110011);
2296   INSN(fmls, 0, 1, 0b110011);
2297   INSN(fmax, 0, 0, 0b111101);
2298   INSN(fmin, 0, 1, 0b111101);
2299 
2300 #undef INSN
2301 
2302 #define INSN(NAME, opc)                                                                 \
2303   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
2304     starti;                                                                             \
2305     assert(T == T4S, &quot;arrangement must be T4S&quot;);                                        \
2306     f(0b01011110000, 31, 21), rf(Vm, 16), f(opc, 15, 10), rf(Vn, 5), rf(Vd, 0);         \
2307   }
2308 
2309   INSN(sha1c,     0b000000);
2310   INSN(sha1m,     0b001000);
2311   INSN(sha1p,     0b000100);
2312   INSN(sha1su0,   0b001100);
2313   INSN(sha256h2,  0b010100);
2314   INSN(sha256h,   0b010000);
2315   INSN(sha256su1, 0b011000);
2316 
2317 #undef INSN
2318 
2319 #define INSN(NAME, opc)                                                                 \
2320   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                   \
2321     starti;                                                                             \
2322     assert(T == T4S, &quot;arrangement must be T4S&quot;);                                        \
2323     f(0b0101111000101000, 31, 16), f(opc, 15, 10), rf(Vn, 5), rf(Vd, 0);                \
2324   }
2325 
2326   INSN(sha1h,     0b000010);
2327   INSN(sha1su1,   0b000110);
2328   INSN(sha256su0, 0b001010);
2329 
2330 #undef INSN
2331 
2332 #define INSN(NAME, opc)                           \
2333   void NAME(FloatRegister Vd, FloatRegister Vn) { \
2334     starti;                                       \
2335     f(opc, 31, 10), rf(Vn, 5), rf(Vd, 0);         \
2336   }
2337 
2338   INSN(aese, 0b0100111000101000010010);
2339   INSN(aesd, 0b0100111000101000010110);
2340   INSN(aesmc, 0b0100111000101000011010);
2341   INSN(aesimc, 0b0100111000101000011110);
2342 
2343 #undef INSN
2344 
2345 #define INSN(NAME, op1, op2) \
2346   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm, int index = 0) { \
2347     starti;                                                                                            \
2348     assert(T == T2S || T == T4S || T == T2D, &quot;invalid arrangement&quot;);                                   \
2349     assert(index &gt;= 0 &amp;&amp; ((T == T2D &amp;&amp; index &lt;= 1) || (T != T2D &amp;&amp; index &lt;= 3)), &quot;invalid index&quot;);     \
2350     f(0, 31), f((int)T &amp; 1, 30), f(op1, 29); f(0b011111, 28, 23);                                      \
2351     f(T == T2D ? 1 : 0, 22), f(T == T2D ? 0 : index &amp; 1, 21), rf(Vm, 16);                              \
2352     f(op2, 15, 12), f(T == T2D ? index : (index &gt;&gt; 1), 11), f(0, 10);                                  \
2353     rf(Vn, 5), rf(Vd, 0);                                                                              \
2354   }
2355 
2356   // FMLA/FMLS - Vector - Scalar
2357   INSN(fmlavs, 0, 0b0001);
2358   INSN(fmlsvs, 0, 0b0101);
2359   // FMULX - Vector - Scalar
2360   INSN(fmulxvs, 1, 0b1001);
2361 
2362 #undef INSN
2363 
2364   // Floating-point Reciprocal Estimate
2365   void frecpe(FloatRegister Vd, FloatRegister Vn, SIMD_RegVariant type) {
2366     assert(type == D || type == S, &quot;Wrong type for frecpe&quot;);
2367     starti;
2368     f(0b010111101, 31, 23);
2369     f(type == D ? 1 : 0, 22);
2370     f(0b100001110110, 21, 10);
2371     rf(Vn, 5), rf(Vd, 0);
2372   }
2373 
2374   // (double) {a, b} -&gt; (a + b)
2375   void faddpd(FloatRegister Vd, FloatRegister Vn) {
2376     starti;
2377     f(0b0111111001110000110110, 31, 10);
2378     rf(Vn, 5), rf(Vd, 0);
2379   }
2380 
2381   void ins(FloatRegister Vd, SIMD_RegVariant T, FloatRegister Vn, int didx, int sidx) {
2382     starti;
2383     assert(T != Q, &quot;invalid register variant&quot;);
2384     f(0b01101110000, 31, 21), f(((didx&lt;&lt;1)|1)&lt;&lt;(int)T, 20, 16), f(0, 15);
2385     f(sidx&lt;&lt;(int)T, 14, 11), f(1, 10), rf(Vn, 5), rf(Vd, 0);
2386   }
2387 
2388   void umov(Register Rd, FloatRegister Vn, SIMD_RegVariant T, int idx) {
2389     starti;
2390     f(0, 31), f(T==D ? 1:0, 30), f(0b001110000, 29, 21);
2391     f(((idx&lt;&lt;1)|1)&lt;&lt;(int)T, 20, 16), f(0b001111, 15, 10);
2392     rf(Vn, 5), rf(Rd, 0);
2393   }
2394 
2395 #define INSN(NAME, opc, opc2, isSHR)                                    \
2396   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int shift){ \
2397     starti;                                                             \
2398     /* The encodings for the immh:immb fields (bits 22:16) in *SHR are  \
2399      *   0001 xxx       8B/16B, shift = 16  - UInt(immh:immb)           \
2400      *   001x xxx       4H/8H,  shift = 32  - UInt(immh:immb)           \
2401      *   01xx xxx       2S/4S,  shift = 64  - UInt(immh:immb)           \
2402      *   1xxx xxx       1D/2D,  shift = 128 - UInt(immh:immb)           \
2403      *   (1D is RESERVED)                                               \
2404      * for SHL shift is calculated as:                                  \
2405      *   0001 xxx       8B/16B, shift = UInt(immh:immb) - 8             \
2406      *   001x xxx       4H/8H,  shift = UInt(immh:immb) - 16            \
2407      *   01xx xxx       2S/4S,  shift = UInt(immh:immb) - 32            \
2408      *   1xxx xxx       1D/2D,  shift = UInt(immh:immb) - 64            \
2409      *   (1D is RESERVED)                                               \
2410      */                                                                 \
2411     assert((1 &lt;&lt; ((T&gt;&gt;1)+3)) &gt; shift, &quot;Invalid Shift value&quot;);           \
2412     int cVal = (1 &lt;&lt; (((T &gt;&gt; 1) + 3) + (isSHR ? 1 : 0)));               \
2413     int encodedShift = isSHR ? cVal - shift : cVal + shift;             \
2414     f(0, 31), f(T &amp; 1, 30), f(opc, 29), f(0b011110, 28, 23),            \
2415     f(encodedShift, 22, 16); f(opc2, 15, 10), rf(Vn, 5), rf(Vd, 0);     \
2416   }
2417 
2418   INSN(shl,  0, 0b010101, /* isSHR = */ false);
2419   INSN(sshr, 0, 0b000001, /* isSHR = */ true);
2420   INSN(ushr, 1, 0b000001, /* isSHR = */ true);
2421 
2422 #undef INSN
2423 
<a name="35" id="anc35"></a><span class="line-modified">2424   void ushll(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, SIMD_Arrangement Tb, int shift) {</span>

2425     starti;
2426     /* The encodings for the immh:immb fields (bits 22:16) are
2427      *   0001 xxx       8H, 8B/16b shift = xxx
2428      *   001x xxx       4S, 4H/8H  shift = xxxx
2429      *   01xx xxx       2D, 2S/4S  shift = xxxxx
2430      *   1xxx xxx       RESERVED
2431      */
2432     assert((Tb &gt;&gt; 1) + 1 == (Ta &gt;&gt; 1), &quot;Incompatible arrangement&quot;);
2433     assert((1 &lt;&lt; ((Tb&gt;&gt;1)+3)) &gt; shift, &quot;Invalid shift value&quot;);
2434     f(0, 31), f(Tb &amp; 1, 30), f(0b1011110, 29, 23), f((1 &lt;&lt; ((Tb&gt;&gt;1)+3))|shift, 22, 16);
2435     f(0b101001, 15, 10), rf(Vn, 5), rf(Vd, 0);
2436   }
<a name="36" id="anc36"></a>






2437   void ushll2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn,  SIMD_Arrangement Tb, int shift) {
<a name="37" id="anc37"></a><span class="line-modified">2438     ushll(Vd, Ta, Vn, Tb, shift);</span>

2439   }
2440 
2441   // Move from general purpose register
2442   //   mov  Vd.T[index], Rn
2443   void mov(FloatRegister Vd, SIMD_Arrangement T, int index, Register Xn) {
2444     starti;
2445     f(0b01001110000, 31, 21), f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
<a name="38" id="anc38"></a><span class="line-modified">2446     f(0b000111, 15, 10), rf(Xn, 5), rf(Vd, 0);</span>
2447   }
2448 
2449   // Move to general purpose register
2450   //   mov  Rd, Vn.T[index]
2451   void mov(Register Xd, FloatRegister Vn, SIMD_Arrangement T, int index) {
<a name="39" id="anc39"></a>
2452     starti;
2453     f(0, 31), f((T &gt;= T1D) ? 1:0, 30), f(0b001110000, 29, 21);
2454     f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
2455     f(0b001111, 15, 10), rf(Vn, 5), rf(Xd, 0);
2456   }
2457 
<a name="40" id="anc40"></a><span class="line-modified">2458   void pmull(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {</span>

2459     starti;
2460     assert((Ta == T1Q &amp;&amp; (Tb == T1D || Tb == T2D)) ||
2461            (Ta == T8H &amp;&amp; (Tb == T8B || Tb == T16B)), &quot;Invalid Size specifier&quot;);
2462     int size = (Ta == T1Q) ? 0b11 : 0b00;
2463     f(0, 31), f(Tb &amp; 1, 30), f(0b001110, 29, 24), f(size, 23, 22);
2464     f(1, 21), rf(Vm, 16), f(0b111000, 15, 10), rf(Vn, 5), rf(Vd, 0);
2465   }
<a name="41" id="anc41"></a>






2466   void pmull2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {
2467     assert(Tb == T2D || Tb == T16B, &quot;pmull2 assumes T2D or T16B as the second size specifier&quot;);
<a name="42" id="anc42"></a><span class="line-modified">2468     pmull(Vd, Ta, Vn, Vm, Tb);</span>
2469   }
2470 
2471   void uqxtn(FloatRegister Vd, SIMD_Arrangement Tb, FloatRegister Vn, SIMD_Arrangement Ta) {
2472     starti;
2473     int size_b = (int)Tb &gt;&gt; 1;
2474     int size_a = (int)Ta &gt;&gt; 1;
2475     assert(size_b &lt; 3 &amp;&amp; size_b == size_a - 1, &quot;Invalid size specifier&quot;);
2476     f(0, 31), f(Tb &amp; 1, 30), f(0b101110, 29, 24), f(size_b, 23, 22);
2477     f(0b100001010010, 21, 10), rf(Vn, 5), rf(Vd, 0);
2478   }
2479 
2480   void dup(FloatRegister Vd, SIMD_Arrangement T, Register Xs)
2481   {
2482     starti;
2483     assert(T != T1D, &quot;reserved encoding&quot;);
2484     f(0,31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21);
<a name="43" id="anc43"></a><span class="line-modified">2485     f((1 &lt;&lt; (T &gt;&gt; 1)), 20, 16), f(0b000011, 15, 10), rf(Xs, 5), rf(Vd, 0);</span>
2486   }
2487 
2488   void dup(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int index = 0)
2489   {
2490     starti;
2491     assert(T != T1D, &quot;reserved encoding&quot;);
2492     f(0, 31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21);
2493     f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
2494     f(0b000001, 15, 10), rf(Vn, 5), rf(Vd, 0);
2495   }
2496 
2497   // AdvSIMD ZIP/UZP/TRN
2498 #define INSN(NAME, opcode)                                              \
2499   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
<a name="44" id="anc44"></a>
2500     starti;                                                             \
2501     f(0, 31), f(0b001110, 29, 24), f(0, 21), f(0, 15);                  \
2502     f(opcode, 14, 12), f(0b10, 11, 10);                                 \
2503     rf(Vm, 16), rf(Vn, 5), rf(Vd, 0);                                   \
2504     f(T &amp; 1, 30), f(T &gt;&gt; 1, 23, 22);                                    \
2505   }
2506 
2507   INSN(uzp1, 0b001);
2508   INSN(trn1, 0b010);
2509   INSN(zip1, 0b011);
2510   INSN(uzp2, 0b101);
2511   INSN(trn2, 0b110);
2512   INSN(zip2, 0b111);
2513 
2514 #undef INSN
2515 
2516   // CRC32 instructions
2517 #define INSN(NAME, c, sf, sz)                                             \
2518   void NAME(Register Rd, Register Rn, Register Rm) {                      \
2519     starti;                                                               \
2520     f(sf, 31), f(0b0011010110, 30, 21), f(0b010, 15, 13), f(c, 12);       \
2521     f(sz, 11, 10), rf(Rm, 16), rf(Rn, 5), rf(Rd, 0);                      \
2522   }
2523 
2524   INSN(crc32b,  0, 0, 0b00);
2525   INSN(crc32h,  0, 0, 0b01);
2526   INSN(crc32w,  0, 0, 0b10);
2527   INSN(crc32x,  0, 1, 0b11);
2528   INSN(crc32cb, 1, 0, 0b00);
2529   INSN(crc32ch, 1, 0, 0b01);
2530   INSN(crc32cw, 1, 0, 0b10);
2531   INSN(crc32cx, 1, 1, 0b11);
2532 
2533 #undef INSN
2534 
2535   // Table vector lookup
2536 #define INSN(NAME, op)                                                  \
2537   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, unsigned registers, FloatRegister Vm) { \
2538     starti;                                                             \
2539     assert(T == T8B || T == T16B, &quot;invalid arrangement&quot;);               \
2540     assert(0 &lt; registers &amp;&amp; registers &lt;= 4, &quot;invalid number of registers&quot;); \
2541     f(0, 31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21), rf(Vm, 16), f(0, 15); \
2542     f(registers - 1, 14, 13), f(op, 12),f(0b00, 11, 10), rf(Vn, 5), rf(Vd, 0); \
2543   }
2544 
2545   INSN(tbl, 0);
2546   INSN(tbx, 1);
2547 
2548 #undef INSN
2549 
2550   // AdvSIMD two-reg misc
<a name="45" id="anc45"></a><span class="line-modified">2551 #define INSN(NAME, U, opcode)                                                       \</span>





2552   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {               \
2553        starti;                                                                      \
2554        assert((ASSERTION), MSG);                                                    \
2555        f(0, 31), f((int)T &amp; 1, 30), f(U, 29), f(0b01110, 28, 24);                   \
<a name="46" id="anc46"></a><span class="line-modified">2556        f((int)(T &gt;&gt; 1), 23, 22), f(0b10000, 21, 17), f(opcode, 16, 12);             \</span>
<span class="line-modified">2557        f(0b10, 11, 10), rf(Vn, 5), rf(Vd, 0);                                       \</span>
2558  }
2559 
2560 #define MSG &quot;invalid arrangement&quot;
2561 
2562 #define ASSERTION (T == T2S || T == T4S || T == T2D)
<a name="47" id="anc47"></a><span class="line-modified">2563   INSN(fsqrt, 1, 0b11111);</span>
<span class="line-modified">2564   INSN(fabs,  0, 0b01111);</span>
<span class="line-modified">2565   INSN(fneg,  1, 0b01111);</span>



2566 #undef ASSERTION
2567 
2568 #define ASSERTION (T == T8B || T == T16B || T == T4H || T == T8H || T == T2S || T == T4S)
<a name="48" id="anc48"></a><span class="line-modified">2569   INSN(rev64, 0, 0b00000);</span>
2570 #undef ASSERTION
2571 
2572 #define ASSERTION (T == T8B || T == T16B || T == T4H || T == T8H)
<a name="49" id="anc49"></a><span class="line-modified">2573   INSN(rev32, 1, 0b00000);</span>
<span class="line-removed">2574 private:</span>
<span class="line-removed">2575   INSN(_rbit, 1, 0b00101);</span>
<span class="line-removed">2576 public:</span>
<span class="line-removed">2577 </span>
2578 #undef ASSERTION
2579 
2580 #define ASSERTION (T == T8B || T == T16B)
<a name="50" id="anc50"></a><span class="line-modified">2581   INSN(rev16, 0, 0b00001);</span>
<span class="line-modified">2582   // RBIT only allows T8B and T16B but encodes them oddly.  Argh...</span>
<span class="line-removed">2583   void rbit(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {</span>
<span class="line-removed">2584     assert((ASSERTION), MSG);</span>
<span class="line-removed">2585     _rbit(Vd, SIMD_Arrangement(T &amp; 1 | 0b010), Vn);</span>
<span class="line-removed">2586   }</span>
2587 #undef ASSERTION
2588 
2589 #undef MSG
2590 
2591 #undef INSN
2592 
2593 void ext(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm, int index)
2594   {
2595     starti;
2596     assert(T == T8B || T == T16B, &quot;invalid arrangement&quot;);
2597     assert((T == T8B &amp;&amp; index &lt;= 0b0111) || (T == T16B &amp;&amp; index &lt;= 0b1111), &quot;Invalid index value&quot;);
2598     f(0, 31), f((int)T &amp; 1, 30), f(0b101110000, 29, 21);
2599     rf(Vm, 16), f(0, 15), f(index, 14, 11);
2600     f(0, 10), rf(Vn, 5), rf(Vd, 0);
2601   }
2602 
<a name="51" id="anc51"></a><span class="line-removed">2603 /* Simulator extensions to the ISA</span>
<span class="line-removed">2604 </span>
<span class="line-removed">2605    haltsim</span>
<span class="line-removed">2606 </span>
<span class="line-removed">2607    takes no arguments, causes the sim to enter a debug break and then</span>
<span class="line-removed">2608    return from the simulator run() call with STATUS_HALT? The linking</span>
<span class="line-removed">2609    code will call fatal() when it sees STATUS_HALT.</span>
<span class="line-removed">2610 </span>
<span class="line-removed">2611    blrt Xn, Wm</span>
<span class="line-removed">2612    blrt Xn, #gpargs, #fpargs, #type</span>
<span class="line-removed">2613    Xn holds the 64 bit x86 branch_address</span>
<span class="line-removed">2614    call format is encoded either as immediate data in the call</span>
<span class="line-removed">2615    or in register Wm. In the latter case</span>
<span class="line-removed">2616      Wm[13..6] = #gpargs,</span>
<span class="line-removed">2617      Wm[5..2] = #fpargs,</span>
<span class="line-removed">2618      Wm[1,0] = #type</span>
<span class="line-removed">2619 </span>
<span class="line-removed">2620    calls the x86 code address &#39;branch_address&#39; supplied in Xn passing</span>
<span class="line-removed">2621    arguments taken from the general and floating point registers according</span>
<span class="line-removed">2622    to the supplied counts &#39;gpargs&#39; and &#39;fpargs&#39;. may return a result in r0</span>
<span class="line-removed">2623    or v0 according to the the return type #type&#39; where</span>
<span class="line-removed">2624 </span>
<span class="line-removed">2625    address branch_address;</span>
<span class="line-removed">2626    uimm4 gpargs;</span>
<span class="line-removed">2627    uimm4 fpargs;</span>
<span class="line-removed">2628    enum ReturnType type;</span>
<span class="line-removed">2629 </span>
<span class="line-removed">2630    enum ReturnType</span>
<span class="line-removed">2631      {</span>
<span class="line-removed">2632        void_ret = 0,</span>
<span class="line-removed">2633        int_ret = 1,</span>
<span class="line-removed">2634        long_ret = 1,</span>
<span class="line-removed">2635        obj_ret = 1, // i.e. same as long</span>
<span class="line-removed">2636        float_ret = 2,</span>
<span class="line-removed">2637        double_ret = 3</span>
<span class="line-removed">2638      }</span>
<span class="line-removed">2639 </span>
<span class="line-removed">2640    notify</span>
<span class="line-removed">2641 </span>
<span class="line-removed">2642    notifies the simulator of a transfer of control. instr[14:0]</span>
<span class="line-removed">2643    identifies the type of change of control.</span>
<span class="line-removed">2644 </span>
<span class="line-removed">2645    0 ==&gt; initial entry to a method.</span>
<span class="line-removed">2646 </span>
<span class="line-removed">2647    1 ==&gt; return into a method from a submethod call.</span>
<span class="line-removed">2648 </span>
<span class="line-removed">2649    2 ==&gt; exit out of Java method code.</span>
<span class="line-removed">2650 </span>
<span class="line-removed">2651    3 ==&gt; start execution for a new bytecode.</span>
<span class="line-removed">2652 </span>
<span class="line-removed">2653    in cases 1 and 2 the simulator is expected to use a JVM callback to</span>
<span class="line-removed">2654    identify the name of the specific method being executed. in case 4</span>
<span class="line-removed">2655    the simulator is expected to use a JVM callback to identify the</span>
<span class="line-removed">2656    bytecode index.</span>
<span class="line-removed">2657 </span>
<span class="line-removed">2658    Instruction encodings</span>
<span class="line-removed">2659    ---------------------</span>
<span class="line-removed">2660 </span>
<span class="line-removed">2661    These are encoded in the space with instr[28:25] = 00 which is</span>
<span class="line-removed">2662    unallocated. Encodings are</span>
<span class="line-removed">2663 </span>
<span class="line-removed">2664                      10987654321098765432109876543210</span>
<span class="line-removed">2665    PSEUDO_HALT   = 0x11100000000000000000000000000000</span>
<span class="line-removed">2666    PSEUDO_BLRT  = 0x11000000000000000_______________</span>
<span class="line-removed">2667    PSEUDO_BLRTR = 0x1100000000000000100000__________</span>
<span class="line-removed">2668    PSEUDO_NOTIFY = 0x10100000000000000_______________</span>
<span class="line-removed">2669 </span>
<span class="line-removed">2670    instr[31,29] = op1 : 111 ==&gt; HALT, 110 ==&gt; BLRT/BLRTR, 101 ==&gt; NOTIFY</span>
<span class="line-removed">2671 </span>
<span class="line-removed">2672    for BLRT</span>
<span class="line-removed">2673      instr[14,11] = #gpargs, instr[10,7] = #fpargs</span>
<span class="line-removed">2674      instr[6,5] = #type, instr[4,0] = Rn</span>
<span class="line-removed">2675    for BLRTR</span>
<span class="line-removed">2676      instr[9,5] = Rm, instr[4,0] = Rn</span>
<span class="line-removed">2677    for NOTIFY</span>
<span class="line-removed">2678      instr[14:0] = type : 0 ==&gt; entry, 1 ==&gt; reentry, 2 ==&gt; exit, 3 ==&gt; bcstart</span>
<span class="line-removed">2679 */</span>
<span class="line-removed">2680 </span>
<span class="line-removed">2681   enum NotifyType { method_entry, method_reentry, method_exit, bytecode_start };</span>
<span class="line-removed">2682 </span>
<span class="line-removed">2683   virtual void notify(int type) {</span>
<span class="line-removed">2684     if (UseBuiltinSim) {</span>
<span class="line-removed">2685       starti;</span>
<span class="line-removed">2686       //  109</span>
<span class="line-removed">2687       f(0b101, 31, 29);</span>
<span class="line-removed">2688       //  87654321098765</span>
<span class="line-removed">2689       f(0b00000000000000, 28, 15);</span>
<span class="line-removed">2690       f(type, 14, 0);</span>
<span class="line-removed">2691     }</span>
<span class="line-removed">2692   }</span>
<span class="line-removed">2693 </span>
<span class="line-removed">2694   void blrt(Register Rn, int gpargs, int fpargs, int type) {</span>
<span class="line-removed">2695     if (UseBuiltinSim) {</span>
<span class="line-removed">2696       starti;</span>
<span class="line-removed">2697       f(0b110, 31 ,29);</span>
<span class="line-removed">2698       f(0b00, 28, 25);</span>
<span class="line-removed">2699       //  4321098765</span>
<span class="line-removed">2700       f(0b0000000000, 24, 15);</span>
<span class="line-removed">2701       f(gpargs, 14, 11);</span>
<span class="line-removed">2702       f(fpargs, 10, 7);</span>
<span class="line-removed">2703       f(type, 6, 5);</span>
<span class="line-removed">2704       rf(Rn, 0);</span>
<span class="line-removed">2705     } else {</span>
<span class="line-removed">2706       blr(Rn);</span>
<span class="line-removed">2707     }</span>
<span class="line-removed">2708   }</span>
<span class="line-removed">2709 </span>
<span class="line-removed">2710   void blrt(Register Rn, Register Rm) {</span>
<span class="line-removed">2711     if (UseBuiltinSim) {</span>
<span class="line-removed">2712       starti;</span>
<span class="line-removed">2713       f(0b110, 31 ,29);</span>
<span class="line-removed">2714       f(0b00, 28, 25);</span>
<span class="line-removed">2715       //  4321098765</span>
<span class="line-removed">2716       f(0b0000000001, 24, 15);</span>
<span class="line-removed">2717       //  43210</span>
<span class="line-removed">2718       f(0b00000, 14, 10);</span>
<span class="line-removed">2719       rf(Rm, 5);</span>
<span class="line-removed">2720       rf(Rn, 0);</span>
<span class="line-removed">2721     } else {</span>
<span class="line-removed">2722       blr(Rn);</span>
<span class="line-removed">2723     }</span>
<span class="line-removed">2724   }</span>
<span class="line-removed">2725 </span>
<span class="line-removed">2726   void haltsim() {</span>
<span class="line-removed">2727     starti;</span>
<span class="line-removed">2728     f(0b111, 31 ,29);</span>
<span class="line-removed">2729     f(0b00, 28, 27);</span>
<span class="line-removed">2730     //  654321098765432109876543210</span>
<span class="line-removed">2731     f(0b000000000000000000000000000, 26, 0);</span>
<span class="line-removed">2732   }</span>
<span class="line-removed">2733 </span>
2734   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
2735   }
2736 
2737   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
2738                                                 Register tmp,
2739                                                 int offset) {
2740     ShouldNotCallThis();
2741     return RegisterOrConstant();
2742   }
2743 
2744   // Stack overflow checking
2745   virtual void bang_stack_with_offset(int offset);
2746 
2747   static bool operand_valid_for_logical_immediate(bool is32, uint64_t imm);
2748   static bool operand_valid_for_add_sub_immediate(long imm);
2749   static bool operand_valid_for_float_immediate(double imm);
2750 
2751   void emit_data64(jlong data, relocInfo::relocType rtype, int format = 0);
2752   void emit_data64(jlong data, RelocationHolder const&amp; rspec, int format = 0);
2753 };
2754 
2755 inline Assembler::Membar_mask_bits operator|(Assembler::Membar_mask_bits a,
2756                                              Assembler::Membar_mask_bits b) {
2757   return Assembler::Membar_mask_bits(unsigned(a)|unsigned(b));
2758 }
2759 
2760 Instruction_aarch64::~Instruction_aarch64() {
2761   assem-&gt;emit();
2762 }
2763 
2764 #undef starti
2765 
2766 // Invert a condition
2767 inline const Assembler::Condition operator~(const Assembler::Condition cond) {
2768   return Assembler::Condition(int(cond) ^ 1);
2769 }
2770 
2771 class BiasedLockingCounters;
2772 
2773 extern &quot;C&quot; void das(uint64_t start, int len);
2774 
2775 #endif // CPU_AARCH64_ASSEMBLER_AARCH64_HPP
<a name="52" id="anc52"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="52" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/nativeInst_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64_trig.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/nativeInst_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;code/compiledIC.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;nativeInst_aarch64.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/handles.hpp&quot;

 33 #include &quot;runtime/sharedRuntime.hpp&quot;
 34 #include &quot;runtime/stubRoutines.hpp&quot;
 35 #include &quot;utilities/ostream.hpp&quot;
 36 #ifdef COMPILER1
 37 #include &quot;c1/c1_Runtime1.hpp&quot;
 38 #endif
 39 
 40 void NativeCall::verify() {
 41   assert(NativeCall::is_call_at((address)this), &quot;unexpected code at call site&quot;);
 42 }
 43 
 44 void NativeInstruction::wrote(int offset) {
 45   ICache::invalidate_word(addr_at(offset));
 46 }
 47 
 48 void NativeLoadGot::report_and_fail() const {
 49   tty-&gt;print_cr(&quot;Addr: &quot; INTPTR_FORMAT, p2i(instruction_address()));
 50   fatal(&quot;not a indirect rip mov to rbx&quot;);
 51 }
 52 
</pre>
<hr />
<pre>
215 
216   address bl_destination
217     = MacroAssembler::pd_call_destination(call_addr);
218   if (code-&gt;contains(bl_destination) &amp;&amp;
219       is_NativeCallTrampolineStub_at(bl_destination))
220     return bl_destination;
221 
222   if (code-&gt;is_nmethod()) {
223     return trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);
224   }
225 
226   return NULL;
227 }
228 
229 // Inserts a native call instruction at a given pc
230 void NativeCall::insert(address code_pos, address entry) { Unimplemented(); }
231 
232 //-------------------------------------------------------------------
233 
234 void NativeMovConstReg::verify() {
<span class="line-modified">235   // make sure code pattern is actually mov reg64, imm64 instructions</span>




236 }
237 
238 
239 intptr_t NativeMovConstReg::data() const {
240   // das(uint64_t(instruction_address()),2);
241   address addr = MacroAssembler::target_addr_for_insn(instruction_address());
242   if (maybe_cpool_ref(instruction_address())) {
243     return *(intptr_t*)addr;
244   } else {
245     return (intptr_t)addr;
246   }
247 }
248 
249 void NativeMovConstReg::set_data(intptr_t x) {
250   if (maybe_cpool_ref(instruction_address())) {
251     address addr = MacroAssembler::target_addr_for_insn(instruction_address());
252     *(intptr_t*)addr = x;
253   } else {
254     // Store x into the instruction stream.
255     MacroAssembler::pd_patch_instruction(instruction_address(), (address)x);
</pre>
<hr />
<pre>
266       if (iter.type() == relocInfo::oop_type) {
267         oop* oop_addr = iter.oop_reloc()-&gt;oop_addr();
268         *oop_addr = cast_to_oop(x);
269         break;
270       } else if (iter.type() == relocInfo::metadata_type) {
271         Metadata** metadata_addr = iter.metadata_reloc()-&gt;metadata_addr();
272         *metadata_addr = (Metadata*)x;
273         break;
274       }
275     }
276   }
277 }
278 
279 void NativeMovConstReg::print() {
280   tty-&gt;print_cr(PTR_FORMAT &quot;: mov reg, &quot; INTPTR_FORMAT,
281                 p2i(instruction_address()), data());
282 }
283 
284 //-------------------------------------------------------------------
285 
<span class="line-removed">286 address NativeMovRegMem::instruction_address() const      { return addr_at(instruction_offset); }</span>
<span class="line-removed">287 </span>
288 int NativeMovRegMem::offset() const  {
289   address pc = instruction_address();
290   unsigned insn = *(unsigned*)pc;
291   if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
292     address addr = MacroAssembler::target_addr_for_insn(pc);
293     return *addr;
294   } else {
295     return (int)(intptr_t)MacroAssembler::target_addr_for_insn(instruction_address());
296   }
297 }
298 
299 void NativeMovRegMem::set_offset(int x) {
300   address pc = instruction_address();
301   unsigned insn = *(unsigned*)pc;
302   if (maybe_cpool_ref(pc)) {
303     address addr = MacroAssembler::target_addr_for_insn(pc);
304     *(long*)addr = x;
305   } else {
306     MacroAssembler::pd_patch_instruction(pc, (address)intptr_t(x));
307     ICache::invalidate_range(instruction_address(), instruction_size);
</pre>
<hr />
<pre>
311 void NativeMovRegMem::verify() {
312 #ifdef ASSERT
313   address dest = MacroAssembler::target_addr_for_insn(instruction_address());
314 #endif
315 }
316 
317 //--------------------------------------------------------------------------------
318 
319 void NativeJump::verify() { ; }
320 
321 
322 void NativeJump::check_verified_entry_alignment(address entry, address verified_entry) {
323 }
324 
325 
326 address NativeJump::jump_destination() const          {
327   address dest = MacroAssembler::target_addr_for_insn(instruction_address());
328 
329   // We use jump to self as the unresolved address which the inline
330   // cache code (and relocs) know about



331 
<span class="line-modified">332   // return -1 if jump to self</span>
<span class="line-modified">333   dest = (dest == (address) this) ? (address) -1 : dest;</span>


334   return dest;
335 }
336 
337 void NativeJump::set_jump_destination(address dest) {
338   // We use jump to self as the unresolved address which the inline
339   // cache code (and relocs) know about
340   if (dest == (address) -1)
341     dest = instruction_address();
342 
343   MacroAssembler::pd_patch_instruction(instruction_address(), dest);
344   ICache::invalidate_range(instruction_address(), instruction_size);
345 };
346 
347 //-------------------------------------------------------------------
348 
349 address NativeGeneralJump::jump_destination() const {
350   NativeMovConstReg* move = nativeMovConstReg_at(instruction_address());
351   address dest = (address) move-&gt;data();
352 
353   // We use jump to self as the unresolved address which the inline
354   // cache code (and relocs) know about


355 
<span class="line-modified">356   // return -1 if jump to self</span>
<span class="line-modified">357   dest = (dest == (address) this) ? (address) -1 : dest;</span>


358   return dest;
359 }
360 
361 void NativeGeneralJump::set_jump_destination(address dest) {
362   NativeMovConstReg* move = nativeMovConstReg_at(instruction_address());
363 
364   // We use jump to self as the unresolved address which the inline
365   // cache code (and relocs) know about
366   if (dest == (address) -1) {
367     dest = instruction_address();
368   }
369 
370   move-&gt;set_data((uintptr_t) dest);
371 };
372 
373 //-------------------------------------------------------------------
374 
375 bool NativeInstruction::is_safepoint_poll() {
376   // a safepoint_poll is implemented in two steps as either
377   //
</pre>
</td>
<td>
<hr />
<pre>
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;code/compiledIC.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;nativeInst_aarch64.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/handles.hpp&quot;
<span class="line-added"> 33 #include &quot;runtime/orderAccess.hpp&quot;</span>
 34 #include &quot;runtime/sharedRuntime.hpp&quot;
 35 #include &quot;runtime/stubRoutines.hpp&quot;
 36 #include &quot;utilities/ostream.hpp&quot;
 37 #ifdef COMPILER1
 38 #include &quot;c1/c1_Runtime1.hpp&quot;
 39 #endif
 40 
 41 void NativeCall::verify() {
 42   assert(NativeCall::is_call_at((address)this), &quot;unexpected code at call site&quot;);
 43 }
 44 
 45 void NativeInstruction::wrote(int offset) {
 46   ICache::invalidate_word(addr_at(offset));
 47 }
 48 
 49 void NativeLoadGot::report_and_fail() const {
 50   tty-&gt;print_cr(&quot;Addr: &quot; INTPTR_FORMAT, p2i(instruction_address()));
 51   fatal(&quot;not a indirect rip mov to rbx&quot;);
 52 }
 53 
</pre>
<hr />
<pre>
216 
217   address bl_destination
218     = MacroAssembler::pd_call_destination(call_addr);
219   if (code-&gt;contains(bl_destination) &amp;&amp;
220       is_NativeCallTrampolineStub_at(bl_destination))
221     return bl_destination;
222 
223   if (code-&gt;is_nmethod()) {
224     return trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);
225   }
226 
227   return NULL;
228 }
229 
230 // Inserts a native call instruction at a given pc
231 void NativeCall::insert(address code_pos, address entry) { Unimplemented(); }
232 
233 //-------------------------------------------------------------------
234 
235 void NativeMovConstReg::verify() {
<span class="line-modified">236   if (! (nativeInstruction_at(instruction_address())-&gt;is_movz() ||</span>
<span class="line-added">237         is_adrp_at(instruction_address()) ||</span>
<span class="line-added">238         is_ldr_literal_at(instruction_address())) ) {</span>
<span class="line-added">239     fatal(&quot;should be MOVZ or ADRP or LDR (literal)&quot;);</span>
<span class="line-added">240   }</span>
241 }
242 
243 
244 intptr_t NativeMovConstReg::data() const {
245   // das(uint64_t(instruction_address()),2);
246   address addr = MacroAssembler::target_addr_for_insn(instruction_address());
247   if (maybe_cpool_ref(instruction_address())) {
248     return *(intptr_t*)addr;
249   } else {
250     return (intptr_t)addr;
251   }
252 }
253 
254 void NativeMovConstReg::set_data(intptr_t x) {
255   if (maybe_cpool_ref(instruction_address())) {
256     address addr = MacroAssembler::target_addr_for_insn(instruction_address());
257     *(intptr_t*)addr = x;
258   } else {
259     // Store x into the instruction stream.
260     MacroAssembler::pd_patch_instruction(instruction_address(), (address)x);
</pre>
<hr />
<pre>
271       if (iter.type() == relocInfo::oop_type) {
272         oop* oop_addr = iter.oop_reloc()-&gt;oop_addr();
273         *oop_addr = cast_to_oop(x);
274         break;
275       } else if (iter.type() == relocInfo::metadata_type) {
276         Metadata** metadata_addr = iter.metadata_reloc()-&gt;metadata_addr();
277         *metadata_addr = (Metadata*)x;
278         break;
279       }
280     }
281   }
282 }
283 
284 void NativeMovConstReg::print() {
285   tty-&gt;print_cr(PTR_FORMAT &quot;: mov reg, &quot; INTPTR_FORMAT,
286                 p2i(instruction_address()), data());
287 }
288 
289 //-------------------------------------------------------------------
290 


291 int NativeMovRegMem::offset() const  {
292   address pc = instruction_address();
293   unsigned insn = *(unsigned*)pc;
294   if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
295     address addr = MacroAssembler::target_addr_for_insn(pc);
296     return *addr;
297   } else {
298     return (int)(intptr_t)MacroAssembler::target_addr_for_insn(instruction_address());
299   }
300 }
301 
302 void NativeMovRegMem::set_offset(int x) {
303   address pc = instruction_address();
304   unsigned insn = *(unsigned*)pc;
305   if (maybe_cpool_ref(pc)) {
306     address addr = MacroAssembler::target_addr_for_insn(pc);
307     *(long*)addr = x;
308   } else {
309     MacroAssembler::pd_patch_instruction(pc, (address)intptr_t(x));
310     ICache::invalidate_range(instruction_address(), instruction_size);
</pre>
<hr />
<pre>
314 void NativeMovRegMem::verify() {
315 #ifdef ASSERT
316   address dest = MacroAssembler::target_addr_for_insn(instruction_address());
317 #endif
318 }
319 
320 //--------------------------------------------------------------------------------
321 
322 void NativeJump::verify() { ; }
323 
324 
325 void NativeJump::check_verified_entry_alignment(address entry, address verified_entry) {
326 }
327 
328 
329 address NativeJump::jump_destination() const          {
330   address dest = MacroAssembler::target_addr_for_insn(instruction_address());
331 
332   // We use jump to self as the unresolved address which the inline
333   // cache code (and relocs) know about
<span class="line-added">334   // As a special case we also use sequence movptr(r,0); br(r);</span>
<span class="line-added">335   // i.e. jump to 0 when we need leave space for a wide immediate</span>
<span class="line-added">336   // load</span>
337 
<span class="line-modified">338   // return -1 if jump to self or to 0</span>
<span class="line-modified">339   if ((dest == (address)this) || dest == 0) {</span>
<span class="line-added">340     dest = (address) -1;</span>
<span class="line-added">341   }</span>
342   return dest;
343 }
344 
345 void NativeJump::set_jump_destination(address dest) {
346   // We use jump to self as the unresolved address which the inline
347   // cache code (and relocs) know about
348   if (dest == (address) -1)
349     dest = instruction_address();
350 
351   MacroAssembler::pd_patch_instruction(instruction_address(), dest);
352   ICache::invalidate_range(instruction_address(), instruction_size);
353 };
354 
355 //-------------------------------------------------------------------
356 
357 address NativeGeneralJump::jump_destination() const {
358   NativeMovConstReg* move = nativeMovConstReg_at(instruction_address());
359   address dest = (address) move-&gt;data();
360 
361   // We use jump to self as the unresolved address which the inline
362   // cache code (and relocs) know about
<span class="line-added">363   // As a special case we also use jump to 0 when first generating</span>
<span class="line-added">364   // a general jump</span>
365 
<span class="line-modified">366   // return -1 if jump to self or to 0</span>
<span class="line-modified">367   if ((dest == (address)this) || dest == 0) {</span>
<span class="line-added">368     dest = (address) -1;</span>
<span class="line-added">369   }</span>
370   return dest;
371 }
372 
373 void NativeGeneralJump::set_jump_destination(address dest) {
374   NativeMovConstReg* move = nativeMovConstReg_at(instruction_address());
375 
376   // We use jump to self as the unresolved address which the inline
377   // cache code (and relocs) know about
378   if (dest == (address) -1) {
379     dest = instruction_address();
380   }
381 
382   move-&gt;set_data((uintptr_t) dest);
383 };
384 
385 //-------------------------------------------------------------------
386 
387 bool NativeInstruction::is_safepoint_poll() {
388   // a safepoint_poll is implemented in two steps as either
389   //
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_aarch64_trig.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
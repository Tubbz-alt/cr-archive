<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/vtableStubs_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vmreg_aarch64.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../arm/abstractInterpreter_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/vtableStubs_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
153   int       slop_delta = 0;
154 
155   ResourceMark    rm;
156   CodeBuffer      cb(s-&gt;entry_point(), stub_code_length);
157   MacroAssembler* masm = new MacroAssembler(&amp;cb);
158 
159 #if (!defined(PRODUCT) &amp;&amp; defined(COMPILER2))
160   if (CountCompiledCalls) {
161     __ lea(r10, ExternalAddress((address) SharedRuntime::nof_megamorphic_calls_addr()));
162     __ incrementw(Address(r10));
163   }
164 #endif
165 
166   // get receiver (need to skip return address on top of stack)
167   assert(VtableStub::receiver_location() == j_rarg0-&gt;as_VMReg(), &quot;receiver expected in j_rarg0&quot;);
168 
169   // Entry arguments:
170   //  rscratch2: CompiledICHolder
171   //  j_rarg0: Receiver
172 
<span class="line-modified">173   // Most registers are in use; we&#39;ll use r16, rmethod, r10, r11</span>

174   const Register recv_klass_reg     = r10;
175   const Register holder_klass_reg   = r16; // declaring interface klass (DECC)
176   const Register resolved_klass_reg = rmethod; // resolved interface klass (REFC)
177   const Register temp_reg           = r11;

178   const Register icholder_reg       = rscratch2;
179 
180   Label L_no_such_interface;
181 
182   __ ldr(resolved_klass_reg, Address(icholder_reg, CompiledICHolder::holder_klass_offset()));
183   __ ldr(holder_klass_reg,   Address(icholder_reg, CompiledICHolder::holder_metadata_offset()));
184 
185   start_pc = __ pc();
186 
187   // get receiver klass (also an implicit null-check)
188   address npe_addr = __ pc();
189   __ load_klass(recv_klass_reg, j_rarg0);
190 
191   // Receiver subtype check against REFC.
<span class="line-removed">192   // Destroys recv_klass_reg value.</span>
193   __ lookup_interface_method(// inputs: rec. class, interface
194                              recv_klass_reg, resolved_klass_reg, noreg,
195                              // outputs:  scan temp. reg1, scan temp. reg2
<span class="line-modified">196                              recv_klass_reg, temp_reg,</span>
197                              L_no_such_interface,
198                              /*return_method=*/false);
199 
200   const ptrdiff_t  typecheckSize = __ pc() - start_pc;
201   start_pc = __ pc();
202 
203   // Get selected method from declaring class and itable index
<span class="line-removed">204   __ load_klass(recv_klass_reg, j_rarg0);   // restore recv_klass_reg</span>
205   __ lookup_interface_method(// inputs: rec. class, interface, itable index
206                              recv_klass_reg, holder_klass_reg, itable_index,
207                              // outputs: method, scan temp. reg
208                              rmethod, temp_reg,
209                              L_no_such_interface);
210 
211   const ptrdiff_t lookupSize = __ pc() - start_pc;
212 
213   // Reduce &quot;estimate&quot; such that &quot;padding&quot; does not drop below 8.
<span class="line-modified">214   const ptrdiff_t estimate = 152;</span>
215   const ptrdiff_t codesize = typecheckSize + lookupSize;
216   slop_delta  = (int)(estimate - codesize);
217   slop_bytes += slop_delta;
218   assert(slop_delta &gt;= 0, &quot;itable #%d: Code size estimate (%d) for lookup_interface_method too small, required: %d&quot;, itable_index, (int)estimate, (int)codesize);
219 
220 #ifdef ASSERT
221   if (DebugVtables) {
222     Label L2;
223     __ cbz(rmethod, L2);
224     __ ldr(rscratch1, Address(rmethod, Method::from_compiled_offset()));
225     __ cbnz(rscratch1, L2);
226     __ stop(&quot;compiler entrypoint is null&quot;);
227     __ bind(L2);
228   }
229 #endif // ASSERT
230 
231   // rmethod: Method*
232   // j_rarg0: receiver
233   address ame_addr = __ pc();
234   __ ldr(rscratch1, Address(rmethod, Method::from_compiled_offset()));
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
153   int       slop_delta = 0;
154 
155   ResourceMark    rm;
156   CodeBuffer      cb(s-&gt;entry_point(), stub_code_length);
157   MacroAssembler* masm = new MacroAssembler(&amp;cb);
158 
159 #if (!defined(PRODUCT) &amp;&amp; defined(COMPILER2))
160   if (CountCompiledCalls) {
161     __ lea(r10, ExternalAddress((address) SharedRuntime::nof_megamorphic_calls_addr()));
162     __ incrementw(Address(r10));
163   }
164 #endif
165 
166   // get receiver (need to skip return address on top of stack)
167   assert(VtableStub::receiver_location() == j_rarg0-&gt;as_VMReg(), &quot;receiver expected in j_rarg0&quot;);
168 
169   // Entry arguments:
170   //  rscratch2: CompiledICHolder
171   //  j_rarg0: Receiver
172 
<span class="line-modified">173   // This stub is called from compiled code which has no callee-saved registers,</span>
<span class="line-added">174   // so all registers except arguments are free at this point.</span>
175   const Register recv_klass_reg     = r10;
176   const Register holder_klass_reg   = r16; // declaring interface klass (DECC)
177   const Register resolved_klass_reg = rmethod; // resolved interface klass (REFC)
178   const Register temp_reg           = r11;
<span class="line-added">179   const Register temp_reg2          = r15;</span>
180   const Register icholder_reg       = rscratch2;
181 
182   Label L_no_such_interface;
183 
184   __ ldr(resolved_klass_reg, Address(icholder_reg, CompiledICHolder::holder_klass_offset()));
185   __ ldr(holder_klass_reg,   Address(icholder_reg, CompiledICHolder::holder_metadata_offset()));
186 
187   start_pc = __ pc();
188 
189   // get receiver klass (also an implicit null-check)
190   address npe_addr = __ pc();
191   __ load_klass(recv_klass_reg, j_rarg0);
192 
193   // Receiver subtype check against REFC.

194   __ lookup_interface_method(// inputs: rec. class, interface
195                              recv_klass_reg, resolved_klass_reg, noreg,
196                              // outputs:  scan temp. reg1, scan temp. reg2
<span class="line-modified">197                              temp_reg2, temp_reg,</span>
198                              L_no_such_interface,
199                              /*return_method=*/false);
200 
201   const ptrdiff_t  typecheckSize = __ pc() - start_pc;
202   start_pc = __ pc();
203 
204   // Get selected method from declaring class and itable index

205   __ lookup_interface_method(// inputs: rec. class, interface, itable index
206                              recv_klass_reg, holder_klass_reg, itable_index,
207                              // outputs: method, scan temp. reg
208                              rmethod, temp_reg,
209                              L_no_such_interface);
210 
211   const ptrdiff_t lookupSize = __ pc() - start_pc;
212 
213   // Reduce &quot;estimate&quot; such that &quot;padding&quot; does not drop below 8.
<span class="line-modified">214   const ptrdiff_t estimate = 124;</span>
215   const ptrdiff_t codesize = typecheckSize + lookupSize;
216   slop_delta  = (int)(estimate - codesize);
217   slop_bytes += slop_delta;
218   assert(slop_delta &gt;= 0, &quot;itable #%d: Code size estimate (%d) for lookup_interface_method too small, required: %d&quot;, itable_index, (int)estimate, (int)codesize);
219 
220 #ifdef ASSERT
221   if (DebugVtables) {
222     Label L2;
223     __ cbz(rmethod, L2);
224     __ ldr(rscratch1, Address(rmethod, Method::from_compiled_offset()));
225     __ cbnz(rscratch1, L2);
226     __ stop(&quot;compiler entrypoint is null&quot;);
227     __ bind(L2);
228   }
229 #endif // ASSERT
230 
231   // rmethod: Method*
232   // j_rarg0: receiver
233   address ame_addr = __ pc();
234   __ ldr(rscratch1, Address(rmethod, Method::from_compiled_offset()));
</pre>
</td>
</tr>
</table>
<center><a href="vmreg_aarch64.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../arm/abstractInterpreter_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
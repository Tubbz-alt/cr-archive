<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/interp_masm_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRT_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/interp_masm_aarch64.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_AARCH64_INTERP_MASM_AARCH64_HPP
 27 #define CPU_AARCH64_INTERP_MASM_AARCH64_HPP
 28 
 29 #include &quot;asm/macroAssembler.hpp&quot;
 30 #include &quot;interpreter/invocationCounter.hpp&quot;
 31 #include &quot;runtime/frame.hpp&quot;
 32 
 33 // This file specializes the assember with interpreter-specific macros
 34 
 35 typedef ByteSize (*OffsetFunction)(uint);
 36 
 37 class InterpreterMacroAssembler: public MacroAssembler {
 38  protected:
 39 
 40  protected:
<span class="line-removed"> 41   using MacroAssembler::call_VM_leaf_base;</span>
<span class="line-removed"> 42 </span>
 43   // Interpreter specific version of call_VM_base
 44   using MacroAssembler::call_VM_leaf_base;
 45 
 46   virtual void call_VM_leaf_base(address entry_point,
 47                                  int number_of_arguments);
 48 
 49   virtual void call_VM_base(Register oop_result,
 50                             Register java_thread,
 51                             Register last_java_sp,
 52                             address  entry_point,
 53                             int number_of_arguments,
 54                             bool check_exceptions);
 55 
 56   // base routine for all dispatches
 57   void dispatch_base(TosState state, address* table,
 58                      bool verifyoop = true, bool generate_poll = false);
 59 
 60  public:
 61   InterpreterMacroAssembler(CodeBuffer* code) : MacroAssembler(code) {}
 62 
</pre>
<hr />
<pre>
109   }
110 
111   void get_cpool_and_tags(Register cpool, Register tags) {
112     get_constant_pool(cpool);
113     ldr(tags, Address(cpool, ConstantPool::tags_offset_in_bytes()));
114   }
115 
116   void get_unsigned_2_byte_index_at_bcp(Register reg, int bcp_offset);
117   void get_cache_and_index_at_bcp(Register cache, Register index, int bcp_offset, size_t index_size = sizeof(u2));
118   void get_cache_and_index_and_bytecode_at_bcp(Register cache, Register index, Register bytecode, int byte_no, int bcp_offset, size_t index_size = sizeof(u2));
119   void get_cache_entry_pointer_at_bcp(Register cache, Register tmp, int bcp_offset, size_t index_size = sizeof(u2));
120   void get_cache_index_at_bcp(Register index, int bcp_offset, size_t index_size = sizeof(u2));
121   void get_method_counters(Register method, Register mcs, Label&amp; skip);
122 
123   // load cpool-&gt;resolved_references(index);
124   void load_resolved_reference_at_index(Register result, Register index, Register tmp = r5);
125 
126   // load cpool-&gt;resolved_klass_at(index);
127   void load_resolved_klass_at_offset(Register cpool, Register index, Register klass, Register temp);
128 


129   void pop_ptr(Register r = r0);
130   void pop_i(Register r = r0);
131   void pop_l(Register r = r0);
132   void pop_f(FloatRegister r = v0);
133   void pop_d(FloatRegister r = v0);
134   void push_ptr(Register r = r0);
135   void push_i(Register r = r0);
136   void push_l(Register r = r0);
137   void push_f(FloatRegister r = v0);
138   void push_d(FloatRegister r = v0);
139 
140   void pop(Register r ) { ((MacroAssembler*)this)-&gt;pop(r); }
141 
142   void push(Register r ) { ((MacroAssembler*)this)-&gt;push(r); }
143 
144   void pop(TosState state); // transition vtos -&gt; state
145   void push(TosState state); // transition state -&gt; vtos
146 
147   void pop(RegSet regs, Register stack) { ((MacroAssembler*)this)-&gt;pop(regs, stack); }
148   void push(RegSet regs, Register stack) { ((MacroAssembler*)this)-&gt;push(regs, stack); }
</pre>
</td>
<td>
<hr />
<pre>
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_AARCH64_INTERP_MASM_AARCH64_HPP
 27 #define CPU_AARCH64_INTERP_MASM_AARCH64_HPP
 28 
 29 #include &quot;asm/macroAssembler.hpp&quot;
 30 #include &quot;interpreter/invocationCounter.hpp&quot;
 31 #include &quot;runtime/frame.hpp&quot;
 32 
 33 // This file specializes the assember with interpreter-specific macros
 34 
 35 typedef ByteSize (*OffsetFunction)(uint);
 36 
 37 class InterpreterMacroAssembler: public MacroAssembler {
 38  protected:
 39 
 40  protected:


 41   // Interpreter specific version of call_VM_base
 42   using MacroAssembler::call_VM_leaf_base;
 43 
 44   virtual void call_VM_leaf_base(address entry_point,
 45                                  int number_of_arguments);
 46 
 47   virtual void call_VM_base(Register oop_result,
 48                             Register java_thread,
 49                             Register last_java_sp,
 50                             address  entry_point,
 51                             int number_of_arguments,
 52                             bool check_exceptions);
 53 
 54   // base routine for all dispatches
 55   void dispatch_base(TosState state, address* table,
 56                      bool verifyoop = true, bool generate_poll = false);
 57 
 58  public:
 59   InterpreterMacroAssembler(CodeBuffer* code) : MacroAssembler(code) {}
 60 
</pre>
<hr />
<pre>
107   }
108 
109   void get_cpool_and_tags(Register cpool, Register tags) {
110     get_constant_pool(cpool);
111     ldr(tags, Address(cpool, ConstantPool::tags_offset_in_bytes()));
112   }
113 
114   void get_unsigned_2_byte_index_at_bcp(Register reg, int bcp_offset);
115   void get_cache_and_index_at_bcp(Register cache, Register index, int bcp_offset, size_t index_size = sizeof(u2));
116   void get_cache_and_index_and_bytecode_at_bcp(Register cache, Register index, Register bytecode, int byte_no, int bcp_offset, size_t index_size = sizeof(u2));
117   void get_cache_entry_pointer_at_bcp(Register cache, Register tmp, int bcp_offset, size_t index_size = sizeof(u2));
118   void get_cache_index_at_bcp(Register index, int bcp_offset, size_t index_size = sizeof(u2));
119   void get_method_counters(Register method, Register mcs, Label&amp; skip);
120 
121   // load cpool-&gt;resolved_references(index);
122   void load_resolved_reference_at_index(Register result, Register index, Register tmp = r5);
123 
124   // load cpool-&gt;resolved_klass_at(index);
125   void load_resolved_klass_at_offset(Register cpool, Register index, Register klass, Register temp);
126 
<span class="line-added">127   void load_resolved_method_at_index(int byte_no, Register method, Register cache);</span>
<span class="line-added">128 </span>
129   void pop_ptr(Register r = r0);
130   void pop_i(Register r = r0);
131   void pop_l(Register r = r0);
132   void pop_f(FloatRegister r = v0);
133   void pop_d(FloatRegister r = v0);
134   void push_ptr(Register r = r0);
135   void push_i(Register r = r0);
136   void push_l(Register r = r0);
137   void push_f(FloatRegister r = v0);
138   void push_d(FloatRegister r = v0);
139 
140   void pop(Register r ) { ((MacroAssembler*)this)-&gt;pop(r); }
141 
142   void push(Register r ) { ((MacroAssembler*)this)-&gt;push(r); }
143 
144   void pop(TosState state); // transition vtos -&gt; state
145   void push(TosState state); // transition state -&gt; vtos
146 
147   void pop(RegSet regs, Register stack) { ((MacroAssembler*)this)-&gt;pop(regs, stack); }
148   void push(RegSet regs, Register stack) { ((MacroAssembler*)this)-&gt;push(regs, stack); }
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRT_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
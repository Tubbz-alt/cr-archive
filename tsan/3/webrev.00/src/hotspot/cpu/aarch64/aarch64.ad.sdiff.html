<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../.mx.jvmci/suite.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aarch64Test.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">    3 // Copyright (c) 2014, 2019, Red Hat, Inc. All rights reserved.</span>
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
</pre>
<hr />
<pre>
  111 reg_def R17     ( SOC, SOC, Op_RegI, 17, r17-&gt;as_VMReg()        );
  112 reg_def R17_H   ( SOC, SOC, Op_RegI, 17, r17-&gt;as_VMReg()-&gt;next());
  113 reg_def R18     ( SOC, SOC, Op_RegI, 18, r18-&gt;as_VMReg()        );
  114 reg_def R18_H   ( SOC, SOC, Op_RegI, 18, r18-&gt;as_VMReg()-&gt;next());
  115 reg_def R19     ( SOC, SOE, Op_RegI, 19, r19-&gt;as_VMReg()        );
  116 reg_def R19_H   ( SOC, SOE, Op_RegI, 19, r19-&gt;as_VMReg()-&gt;next());
  117 reg_def R20     ( SOC, SOE, Op_RegI, 20, r20-&gt;as_VMReg()        ); // caller esp
  118 reg_def R20_H   ( SOC, SOE, Op_RegI, 20, r20-&gt;as_VMReg()-&gt;next());
  119 reg_def R21     ( SOC, SOE, Op_RegI, 21, r21-&gt;as_VMReg()        );
  120 reg_def R21_H   ( SOC, SOE, Op_RegI, 21, r21-&gt;as_VMReg()-&gt;next());
  121 reg_def R22     ( SOC, SOE, Op_RegI, 22, r22-&gt;as_VMReg()        );
  122 reg_def R22_H   ( SOC, SOE, Op_RegI, 22, r22-&gt;as_VMReg()-&gt;next());
  123 reg_def R23     ( SOC, SOE, Op_RegI, 23, r23-&gt;as_VMReg()        );
  124 reg_def R23_H   ( SOC, SOE, Op_RegI, 23, r23-&gt;as_VMReg()-&gt;next());
  125 reg_def R24     ( SOC, SOE, Op_RegI, 24, r24-&gt;as_VMReg()        );
  126 reg_def R24_H   ( SOC, SOE, Op_RegI, 24, r24-&gt;as_VMReg()-&gt;next());
  127 reg_def R25     ( SOC, SOE, Op_RegI, 25, r25-&gt;as_VMReg()        );
  128 reg_def R25_H   ( SOC, SOE, Op_RegI, 25, r25-&gt;as_VMReg()-&gt;next());
  129 reg_def R26     ( SOC, SOE, Op_RegI, 26, r26-&gt;as_VMReg()        );
  130 reg_def R26_H   ( SOC, SOE, Op_RegI, 26, r26-&gt;as_VMReg()-&gt;next());
<span class="line-modified">  131 reg_def R27     (  NS, SOE, Op_RegI, 27, r27-&gt;as_VMReg()        ); // heapbase</span>
<span class="line-modified">  132 reg_def R27_H   (  NS, SOE, Op_RegI, 27, r27-&gt;as_VMReg()-&gt;next());</span>
  133 reg_def R28     (  NS, SOE, Op_RegI, 28, r28-&gt;as_VMReg()        ); // thread
  134 reg_def R28_H   (  NS, SOE, Op_RegI, 28, r28-&gt;as_VMReg()-&gt;next());
  135 reg_def R29     (  NS,  NS, Op_RegI, 29, r29-&gt;as_VMReg()        ); // fp
  136 reg_def R29_H   (  NS,  NS, Op_RegI, 29, r29-&gt;as_VMReg()-&gt;next());
  137 reg_def R30     (  NS,  NS, Op_RegI, 30, r30-&gt;as_VMReg()        ); // lr
  138 reg_def R30_H   (  NS,  NS, Op_RegI, 30, r30-&gt;as_VMReg()-&gt;next());
  139 reg_def R31     (  NS,  NS, Op_RegI, 31, r31_sp-&gt;as_VMReg()     ); // sp
  140 reg_def R31_H   (  NS,  NS, Op_RegI, 31, r31_sp-&gt;as_VMReg()-&gt;next());
  141 
  142 // ----------------------------
  143 // Float/Double Registers
  144 // ----------------------------
  145 
  146 // Double Registers
  147 
  148 // The rules of ADL require that double registers be defined in pairs.
  149 // Each pair must be two 32-bit values, but not necessarily a pair of
  150 // single float registers. In each pair, ADLC-assigned register numbers
  151 // must be adjacent, with the lower number even. Finally, when the
  152 // CPU stores such a register pair to memory, the word associated with
</pre>
<hr />
<pre>
  418     V9, V9_H, V9_J, V9_K,
  419     V10, V10_H, V10_J, V10_K,
  420     V11, V11_H, V11_J, V11_K,
  421     V12, V12_H, V12_J, V12_K,
  422     V13, V13_H, V13_J, V13_K,
  423     V14, V14_H, V14_J, V14_K,
  424     V15, V15_H, V15_J, V15_K,
  425 );
  426 
  427 alloc_class chunk2(RFLAGS);
  428 
  429 //----------Architecture Description Register Classes--------------------------
  430 // Several register classes are automatically defined based upon information in
  431 // this architecture description.
  432 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  433 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  434 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  435 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  436 //
  437 
<span class="line-modified">  438 // Class for all 32 bit integer registers -- excludes SP which will</span>
<span class="line-modified">  439 // never be used as an integer register</span>
<span class="line-removed">  440 reg_class any_reg32(</span>
  441     R0,
  442     R1,
  443     R2,
  444     R3,
  445     R4,
  446     R5,
  447     R6,
  448     R7,
  449     R10,
  450     R11,
  451     R12,
  452     R13,
  453     R14,
  454     R15,
  455     R16,
  456     R17,
  457     R18,
  458     R19,
  459     R20,
  460     R21,
  461     R22,
  462     R23,
  463     R24,
  464     R25,
  465     R26,
  466     R27,
  467     R28,
  468     R29,
<span class="line-modified">  469     R30</span>

  470 );
  471 







  472 // Singleton class for R0 int register
  473 reg_class int_r0_reg(R0);
  474 
  475 // Singleton class for R2 int register
  476 reg_class int_r2_reg(R2);
  477 
  478 // Singleton class for R3 int register
  479 reg_class int_r3_reg(R3);
  480 
  481 // Singleton class for R4 int register
  482 reg_class int_r4_reg(R4);
  483 
<span class="line-modified">  484 // Class for all long integer registers (including RSP)</span>
<span class="line-modified">  485 reg_class any_reg(</span>



  486     R0, R0_H,
  487     R1, R1_H,
  488     R2, R2_H,
  489     R3, R3_H,
  490     R4, R4_H,
  491     R5, R5_H,
  492     R6, R6_H,
  493     R7, R7_H,
  494     R10, R10_H,
  495     R11, R11_H,
  496     R12, R12_H,
  497     R13, R13_H,
  498     R14, R14_H,
  499     R15, R15_H,
  500     R16, R16_H,
  501     R17, R17_H,
  502     R18, R18_H,
  503     R19, R19_H,
  504     R20, R20_H,
  505     R21, R21_H,
  506     R22, R22_H,
  507     R23, R23_H,
  508     R24, R24_H,
  509     R25, R25_H,
  510     R26, R26_H,
  511     R27, R27_H,
  512     R28, R28_H,
  513     R29, R29_H,
  514     R30, R30_H,
  515     R31, R31_H
  516 );
  517 
<span class="line-modified">  518 // Class for all non-special integer registers</span>
<span class="line-modified">  519 reg_class no_special_reg32_no_fp(</span>
<span class="line-modified">  520     R0,</span>
<span class="line-modified">  521     R1,</span>
<span class="line-removed">  522     R2,</span>
<span class="line-removed">  523     R3,</span>
<span class="line-removed">  524     R4,</span>
<span class="line-removed">  525     R5,</span>
<span class="line-removed">  526     R6,</span>
<span class="line-removed">  527     R7,</span>
<span class="line-removed">  528     R10,</span>
<span class="line-removed">  529     R11,</span>
<span class="line-removed">  530     R12,                        // rmethod</span>
<span class="line-removed">  531     R13,</span>
<span class="line-removed">  532     R14,</span>
<span class="line-removed">  533     R15,</span>
<span class="line-removed">  534     R16,</span>
<span class="line-removed">  535     R17,</span>
<span class="line-removed">  536     R18,</span>
<span class="line-removed">  537     R19,</span>
<span class="line-removed">  538     R20,</span>
<span class="line-removed">  539     R21,</span>
<span class="line-removed">  540     R22,</span>
<span class="line-removed">  541     R23,</span>
<span class="line-removed">  542     R24,</span>
<span class="line-removed">  543     R25,</span>
<span class="line-removed">  544     R26</span>
<span class="line-removed">  545  /* R27, */                     // heapbase</span>
<span class="line-removed">  546  /* R28, */                     // thread</span>
<span class="line-removed">  547  /* R29, */                     // fp</span>
<span class="line-removed">  548  /* R30, */                     // lr</span>
<span class="line-removed">  549  /* R31 */                      // sp</span>
<span class="line-removed">  550 );</span>
  551 
<span class="line-modified">  552 reg_class no_special_reg32_with_fp(</span>
<span class="line-modified">  553     R0,</span>
<span class="line-modified">  554     R1,</span>
<span class="line-modified">  555     R2,</span>
<span class="line-modified">  556     R3,</span>
<span class="line-removed">  557     R4,</span>
<span class="line-removed">  558     R5,</span>
<span class="line-removed">  559     R6,</span>
<span class="line-removed">  560     R7,</span>
<span class="line-removed">  561     R10,</span>
<span class="line-removed">  562     R11,</span>
<span class="line-removed">  563     R12,                        // rmethod</span>
<span class="line-removed">  564     R13,</span>
<span class="line-removed">  565     R14,</span>
<span class="line-removed">  566     R15,</span>
<span class="line-removed">  567     R16,</span>
<span class="line-removed">  568     R17,</span>
<span class="line-removed">  569     R18,</span>
<span class="line-removed">  570     R19,</span>
<span class="line-removed">  571     R20,</span>
<span class="line-removed">  572     R21,</span>
<span class="line-removed">  573     R22,</span>
<span class="line-removed">  574     R23,</span>
<span class="line-removed">  575     R24,</span>
<span class="line-removed">  576     R25,</span>
<span class="line-removed">  577     R26</span>
<span class="line-removed">  578  /* R27, */                     // heapbase</span>
<span class="line-removed">  579  /* R28, */                     // thread</span>
<span class="line-removed">  580     R29,                        // fp</span>
<span class="line-removed">  581  /* R30, */                     // lr</span>
<span class="line-removed">  582  /* R31 */                      // sp</span>
  583 );
  584 
<span class="line-modified">  585 reg_class_dynamic no_special_reg32(no_special_reg32_no_fp, no_special_reg32_with_fp, %{ PreserveFramePointer %});</span>
<span class="line-modified">  586 </span>
<span class="line-modified">  587 // Class for all non-special long integer registers</span>
<span class="line-modified">  588 reg_class no_special_reg_no_fp(</span>
<span class="line-modified">  589     R0, R0_H,</span>
<span class="line-removed">  590     R1, R1_H,</span>
<span class="line-removed">  591     R2, R2_H,</span>
<span class="line-removed">  592     R3, R3_H,</span>
<span class="line-removed">  593     R4, R4_H,</span>
<span class="line-removed">  594     R5, R5_H,</span>
<span class="line-removed">  595     R6, R6_H,</span>
<span class="line-removed">  596     R7, R7_H,</span>
<span class="line-removed">  597     R10, R10_H,</span>
<span class="line-removed">  598     R11, R11_H,</span>
<span class="line-removed">  599     R12, R12_H,                 // rmethod</span>
<span class="line-removed">  600     R13, R13_H,</span>
<span class="line-removed">  601     R14, R14_H,</span>
<span class="line-removed">  602     R15, R15_H,</span>
<span class="line-removed">  603     R16, R16_H,</span>
<span class="line-removed">  604     R17, R17_H,</span>
<span class="line-removed">  605     R18, R18_H,</span>
<span class="line-removed">  606     R19, R19_H,</span>
<span class="line-removed">  607     R20, R20_H,</span>
<span class="line-removed">  608     R21, R21_H,</span>
<span class="line-removed">  609     R22, R22_H,</span>
<span class="line-removed">  610     R23, R23_H,</span>
<span class="line-removed">  611     R24, R24_H,</span>
<span class="line-removed">  612     R25, R25_H,</span>
<span class="line-removed">  613     R26, R26_H,</span>
<span class="line-removed">  614  /* R27, R27_H, */              // heapbase</span>
<span class="line-removed">  615  /* R28, R28_H, */              // thread</span>
<span class="line-removed">  616  /* R29, R29_H, */              // fp</span>
<span class="line-removed">  617  /* R30, R30_H, */              // lr</span>
<span class="line-removed">  618  /* R31, R31_H */               // sp</span>
  619 );
  620 
<span class="line-modified">  621 reg_class no_special_reg_with_fp(</span>
<span class="line-modified">  622     R0, R0_H,</span>
<span class="line-modified">  623     R1, R1_H,</span>
<span class="line-modified">  624     R2, R2_H,</span>
<span class="line-removed">  625     R3, R3_H,</span>
<span class="line-removed">  626     R4, R4_H,</span>
<span class="line-removed">  627     R5, R5_H,</span>
<span class="line-removed">  628     R6, R6_H,</span>
<span class="line-removed">  629     R7, R7_H,</span>
<span class="line-removed">  630     R10, R10_H,</span>
<span class="line-removed">  631     R11, R11_H,</span>
<span class="line-removed">  632     R12, R12_H,                 // rmethod</span>
<span class="line-removed">  633     R13, R13_H,</span>
<span class="line-removed">  634     R14, R14_H,</span>
<span class="line-removed">  635     R15, R15_H,</span>
<span class="line-removed">  636     R16, R16_H,</span>
<span class="line-removed">  637     R17, R17_H,</span>
<span class="line-removed">  638     R18, R18_H,</span>
<span class="line-removed">  639     R19, R19_H,</span>
<span class="line-removed">  640     R20, R20_H,</span>
<span class="line-removed">  641     R21, R21_H,</span>
<span class="line-removed">  642     R22, R22_H,</span>
<span class="line-removed">  643     R23, R23_H,</span>
<span class="line-removed">  644     R24, R24_H,</span>
<span class="line-removed">  645     R25, R25_H,</span>
<span class="line-removed">  646     R26, R26_H,</span>
<span class="line-removed">  647  /* R27, R27_H, */              // heapbase</span>
<span class="line-removed">  648  /* R28, R28_H, */              // thread</span>
<span class="line-removed">  649     R29, R29_H,                 // fp</span>
<span class="line-removed">  650  /* R30, R30_H, */              // lr</span>
<span class="line-removed">  651  /* R31, R31_H */               // sp</span>
<span class="line-removed">  652 );</span>
  653 
<span class="line-modified">  654 reg_class_dynamic no_special_reg(no_special_reg_no_fp, no_special_reg_with_fp, %{ PreserveFramePointer %});</span>



  655 
  656 // Class for 64 bit register r0
  657 reg_class r0_reg(
  658     R0, R0_H
  659 );
  660 
  661 // Class for 64 bit register r1
  662 reg_class r1_reg(
  663     R1, R1_H
  664 );
  665 
  666 // Class for 64 bit register r2
  667 reg_class r2_reg(
  668     R2, R2_H
  669 );
  670 
  671 // Class for 64 bit register r3
  672 reg_class r3_reg(
  673     R3, R3_H
  674 );
</pre>
<hr />
<pre>
  707 reg_class thread_reg(
  708     R28, R28_H
  709 );
  710 
  711 // Class for frame pointer register
  712 reg_class fp_reg(
  713     R29, R29_H
  714 );
  715 
  716 // Class for link register
  717 reg_class lr_reg(
  718     R30, R30_H
  719 );
  720 
  721 // Class for long sp register
  722 reg_class sp_reg(
  723   R31, R31_H
  724 );
  725 
  726 // Class for all pointer registers
<span class="line-modified">  727 reg_class ptr_reg(</span>
<span class="line-modified">  728     R0, R0_H,</span>
<span class="line-modified">  729     R1, R1_H,</span>
<span class="line-removed">  730     R2, R2_H,</span>
<span class="line-removed">  731     R3, R3_H,</span>
<span class="line-removed">  732     R4, R4_H,</span>
<span class="line-removed">  733     R5, R5_H,</span>
<span class="line-removed">  734     R6, R6_H,</span>
<span class="line-removed">  735     R7, R7_H,</span>
<span class="line-removed">  736     R10, R10_H,</span>
<span class="line-removed">  737     R11, R11_H,</span>
<span class="line-removed">  738     R12, R12_H,</span>
<span class="line-removed">  739     R13, R13_H,</span>
<span class="line-removed">  740     R14, R14_H,</span>
<span class="line-removed">  741     R15, R15_H,</span>
<span class="line-removed">  742     R16, R16_H,</span>
<span class="line-removed">  743     R17, R17_H,</span>
<span class="line-removed">  744     R18, R18_H,</span>
<span class="line-removed">  745     R19, R19_H,</span>
<span class="line-removed">  746     R20, R20_H,</span>
<span class="line-removed">  747     R21, R21_H,</span>
<span class="line-removed">  748     R22, R22_H,</span>
<span class="line-removed">  749     R23, R23_H,</span>
<span class="line-removed">  750     R24, R24_H,</span>
<span class="line-removed">  751     R25, R25_H,</span>
<span class="line-removed">  752     R26, R26_H,</span>
<span class="line-removed">  753     R27, R27_H,</span>
<span class="line-removed">  754     R28, R28_H,</span>
<span class="line-removed">  755     R29, R29_H,</span>
<span class="line-removed">  756     R30, R30_H,</span>
<span class="line-removed">  757     R31, R31_H</span>
<span class="line-removed">  758 );</span>
  759 
  760 // Class for all non_special pointer registers
<span class="line-modified">  761 reg_class no_special_ptr_reg(</span>
<span class="line-modified">  762     R0, R0_H,</span>
<span class="line-modified">  763     R1, R1_H,</span>
<span class="line-removed">  764     R2, R2_H,</span>
<span class="line-removed">  765     R3, R3_H,</span>
<span class="line-removed">  766     R4, R4_H,</span>
<span class="line-removed">  767     R5, R5_H,</span>
<span class="line-removed">  768     R6, R6_H,</span>
<span class="line-removed">  769     R7, R7_H,</span>
<span class="line-removed">  770     R10, R10_H,</span>
<span class="line-removed">  771     R11, R11_H,</span>
<span class="line-removed">  772     R12, R12_H,</span>
<span class="line-removed">  773     R13, R13_H,</span>
<span class="line-removed">  774     R14, R14_H,</span>
<span class="line-removed">  775     R15, R15_H,</span>
<span class="line-removed">  776     R16, R16_H,</span>
<span class="line-removed">  777     R17, R17_H,</span>
<span class="line-removed">  778     R18, R18_H,</span>
<span class="line-removed">  779     R19, R19_H,</span>
<span class="line-removed">  780     R20, R20_H,</span>
<span class="line-removed">  781     R21, R21_H,</span>
<span class="line-removed">  782     R22, R22_H,</span>
<span class="line-removed">  783     R23, R23_H,</span>
<span class="line-removed">  784     R24, R24_H,</span>
<span class="line-removed">  785     R25, R25_H,</span>
<span class="line-removed">  786     R26, R26_H,</span>
<span class="line-removed">  787  /* R27, R27_H, */              // heapbase</span>
<span class="line-removed">  788  /* R28, R28_H, */              // thread</span>
<span class="line-removed">  789  /* R29, R29_H, */              // fp</span>
<span class="line-removed">  790  /* R30, R30_H, */              // lr</span>
<span class="line-removed">  791  /* R31, R31_H */               // sp</span>
<span class="line-removed">  792 );</span>
  793 
  794 // Class for all float registers
  795 reg_class float_reg(
  796     V0,
  797     V1,
  798     V2,
  799     V3,
  800     V4,
  801     V5,
  802     V6,
  803     V7,
  804     V8,
  805     V9,
  806     V10,
  807     V11,
  808     V12,
  809     V13,
  810     V14,
  811     V15,
  812     V16,
</pre>
<hr />
<pre>
  940 // Class for 128 bit register v0
  941 reg_class v0_reg(
  942     V0, V0_H
  943 );
  944 
  945 // Class for 128 bit register v1
  946 reg_class v1_reg(
  947     V1, V1_H
  948 );
  949 
  950 // Class for 128 bit register v2
  951 reg_class v2_reg(
  952     V2, V2_H
  953 );
  954 
  955 // Class for 128 bit register v3
  956 reg_class v3_reg(
  957     V3, V3_H
  958 );
  959 












































































































































  960 // Singleton class for condition codes
  961 reg_class int_flags(RFLAGS);
  962 
  963 %}
  964 
  965 //----------DEFINITION BLOCK---------------------------------------------------
  966 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
  967 // Current support includes integer values in the range [0, 0x7FFFFFFF]
  968 // Format:
  969 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
  970 // Generated Code in ad_&lt;arch&gt;.hpp
  971 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  972 //        // value == &lt;int_value&gt;
  973 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  974 //        assert( &lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  975 //
  976 
  977 // we follow the ppc-aix port in using a simple cost model which ranks
  978 // register operations as cheap, memory ops as more expensive and
  979 // branches as most expensive. the first two have a low as well as a
</pre>
<hr />
<pre>
  983 definitions %{
  984   // The default cost (of a register move instruction).
  985   int_def INSN_COST            (    100,     100);
  986   int_def BRANCH_COST          (    200,     2 * INSN_COST);
  987   int_def CALL_COST            (    200,     2 * INSN_COST);
  988   int_def VOLATILE_REF_COST    (   1000,     10 * INSN_COST);
  989 %}
  990 
  991 
  992 //----------SOURCE BLOCK-------------------------------------------------------
  993 // This is a block of C++ code which provides values, functions, and
  994 // definitions necessary in the rest of the architecture description
  995 
  996 source_hpp %{
  997 
  998 #include &quot;asm/macroAssembler.hpp&quot;
  999 #include &quot;gc/shared/cardTable.hpp&quot;
 1000 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 1001 #include &quot;gc/shared/collectedHeap.hpp&quot;
 1002 #include &quot;opto/addnode.hpp&quot;








 1003 
 1004 class CallStubImpl {
 1005 
 1006   //--------------------------------------------------------------
 1007   //---&lt;  Used for optimization in Compile::shorten_branches  &gt;---
 1008   //--------------------------------------------------------------
 1009 
 1010  public:
 1011   // Size of call trampoline stub.
 1012   static uint size_call_trampoline() {
 1013     return 0; // no call trampolines on this platform
 1014   }
 1015 
 1016   // number of relocations needed by a call trampoline stub
 1017   static uint reloc_call_trampoline() {
 1018     return 0; // no call trampolines on this platform
 1019   }
 1020 };
 1021 
 1022 class HandlerImpl {
</pre>
<hr />
<pre>
 1035     return 4 * NativeInstruction::instruction_size;
 1036   }
 1037 };
 1038 
 1039  bool is_CAS(int opcode, bool maybe_volatile);
 1040 
 1041   // predicates controlling emit of ldr&lt;x&gt;/ldar&lt;x&gt; and associated dmb
 1042 
 1043   bool unnecessary_acquire(const Node *barrier);
 1044   bool needs_acquiring_load(const Node *load);
 1045 
 1046   // predicates controlling emit of str&lt;x&gt;/stlr&lt;x&gt; and associated dmbs
 1047 
 1048   bool unnecessary_release(const Node *barrier);
 1049   bool unnecessary_volatile(const Node *barrier);
 1050   bool needs_releasing_store(const Node *store);
 1051 
 1052   // predicate controlling translation of CompareAndSwapX
 1053   bool needs_acquiring_load_exclusive(const Node *load);
 1054 
<span class="line-removed"> 1055   // predicate controlling translation of StoreCM</span>
<span class="line-removed"> 1056   bool unnecessary_storestore(const Node *storecm);</span>
<span class="line-removed"> 1057 </span>
 1058   // predicate controlling addressing modes
 1059   bool size_fits_all_mem_uses(AddPNode* addp, int shift);
 1060 %}
 1061 
 1062 source %{
 1063 














































 1064   // Optimizaton of volatile gets and puts
 1065   // -------------------------------------
 1066   //
 1067   // AArch64 has ldar&lt;x&gt; and stlr&lt;x&gt; instructions which we can safely
 1068   // use to implement volatile reads and writes. For a volatile read
 1069   // we simply need
 1070   //
 1071   //   ldar&lt;x&gt;
 1072   //
 1073   // and for a volatile write we need
 1074   //
 1075   //   stlr&lt;x&gt;
 1076   //
 1077   // Alternatively, we can implement them by pairing a normal
 1078   // load/store with a memory barrier. For a volatile read we need
 1079   //
 1080   //   ldr&lt;x&gt;
 1081   //   dmb ishld
 1082   //
 1083   // for a volatile write
</pre>
<hr />
<pre>
 1426 // returns true if CAS needs to use an acquiring load otherwise false
 1427 
 1428 bool needs_acquiring_load_exclusive(const Node *n)
 1429 {
 1430   assert(is_CAS(n-&gt;Opcode(), true), &quot;expecting a compare and swap&quot;);
 1431   if (UseBarriersForVolatile) {
 1432     return false;
 1433   }
 1434 
 1435   LoadStoreNode* ldst = n-&gt;as_LoadStore();
 1436   if (is_CAS(n-&gt;Opcode(), false)) {
 1437     assert(ldst-&gt;trailing_membar() != NULL, &quot;expected trailing membar&quot;);
 1438   } else {
 1439     return ldst-&gt;trailing_membar() != NULL;
 1440   }
 1441 
 1442   // so we can just return true here
 1443   return true;
 1444 }
 1445 
<span class="line-removed"> 1446 // predicate controlling translation of StoreCM</span>
<span class="line-removed"> 1447 //</span>
<span class="line-removed"> 1448 // returns true if a StoreStore must precede the card write otherwise</span>
<span class="line-removed"> 1449 // false</span>
<span class="line-removed"> 1450 </span>
<span class="line-removed"> 1451 bool unnecessary_storestore(const Node *storecm)</span>
<span class="line-removed"> 1452 {</span>
<span class="line-removed"> 1453   assert(storecm-&gt;Opcode()  == Op_StoreCM, &quot;expecting a StoreCM&quot;);</span>
<span class="line-removed"> 1454 </span>
<span class="line-removed"> 1455   // we need to generate a dmb ishst between an object put and the</span>
<span class="line-removed"> 1456   // associated card mark when we are using CMS without conditional</span>
<span class="line-removed"> 1457   // card marking</span>
<span class="line-removed"> 1458 </span>
<span class="line-removed"> 1459   if (UseConcMarkSweepGC &amp;&amp; !UseCondCardMark) {</span>
<span class="line-removed"> 1460     return false;</span>
<span class="line-removed"> 1461   }</span>
<span class="line-removed"> 1462 </span>
<span class="line-removed"> 1463   // a storestore is unnecesary in all other cases</span>
<span class="line-removed"> 1464 </span>
<span class="line-removed"> 1465   return true;</span>
<span class="line-removed"> 1466 }</span>
<span class="line-removed"> 1467 </span>
<span class="line-removed"> 1468 </span>
 1469 #define __ _masm.
 1470 
 1471 // advance declarations for helper functions to convert register
 1472 // indices to register objects
 1473 
 1474 // the ad file has to provide implementations of certain methods
 1475 // expected by the generic code
 1476 //
 1477 // REQUIRED FUNCTIONALITY
 1478 
 1479 //=============================================================================
 1480 
 1481 // !!!!! Special hack to get all types of calls to specify the byte offset
 1482 //       from the start of the call to the point where the return address
 1483 //       will point.
 1484 
 1485 int MachCallStaticJavaNode::ret_addr_offset()
 1486 {
 1487   // call should be a simple bl
 1488   int off = 4;
 1489   return off;
 1490 }
 1491 
 1492 int MachCallDynamicJavaNode::ret_addr_offset()
 1493 {
 1494   return 16; // movz, movk, movk, bl
 1495 }
 1496 
 1497 int MachCallRuntimeNode::ret_addr_offset() {
 1498   // for generated stubs the call will be
 1499   //   far_call(addr)
 1500   // for real runtime callouts it will be six instructions
 1501   // see aarch64_enc_java_to_runtime
 1502   //   adr(rscratch2, retaddr)
 1503   //   lea(rscratch1, RuntimeAddress(addr)
 1504   //   stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)))
<span class="line-modified"> 1505   //   blrt rscratch1</span>
 1506   CodeBlob *cb = CodeCache::find_blob(_entry_point);
 1507   if (cb) {
 1508     return MacroAssembler::far_branch_size();
 1509   } else {
 1510     return 6 * NativeInstruction::instruction_size;
 1511   }
 1512 }
 1513 
 1514 // Indicate if the safepoint node needs the polling page as an input
 1515 
 1516 // the shared code plants the oop data at the start of the generated
 1517 // code for the safepoint node and that needs ot be at the load
 1518 // instruction itself. so we cannot plant a mov of the safepoint poll
 1519 // address followed by a load. setting this to true means the mov is
 1520 // scheduled as a prior instruction. that&#39;s better for scheduling
 1521 // anyway.
 1522 
 1523 bool SafePointNode::needs_polling_address_input()
 1524 {
 1525   return true;
</pre>
<hr />
<pre>
 1604     st-&gt;print(&quot;stp  lr, rfp, [sp, #%d]!\n\t&quot;, -(2 * wordSize));
 1605     if (PreserveFramePointer) st-&gt;print(&quot;mov  rfp, sp\n\t&quot;);
 1606     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1607     st-&gt;print(&quot;sub  sp, sp, rscratch1&quot;);
 1608   }
 1609 }
 1610 #endif
 1611 
 1612 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1613   Compile* C = ra_-&gt;C;
 1614   MacroAssembler _masm(&amp;cbuf);
 1615 
 1616   // n.b. frame size includes space for return pc and rfp
 1617   const long framesize = C-&gt;frame_size_in_bytes();
 1618   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1619 
 1620   // insert a nop at the start of the prolog so we can patch in a
 1621   // branch if we need to invalidate the method later
 1622   __ nop();
 1623 
<span class="line-modified"> 1624   int bangsize = C-&gt;bang_size_in_bytes();</span>
<span class="line-modified"> 1625   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
<span class="line-removed"> 1626     __ generate_stack_overflow_check(bangsize);</span>
 1627 
<span class="line-modified"> 1628   __ build_frame(framesize);</span>
 1629 
<span class="line-modified"> 1630   if (NotifySimulator) {</span>
<span class="line-modified"> 1631     __ notify(Assembler::method_entry);</span>


 1632   }
 1633 






 1634   if (VerifyStackAtCalls) {
 1635     Unimplemented();
 1636   }
 1637 
 1638   C-&gt;set_frame_complete(cbuf.insts_size());
 1639 
 1640   if (C-&gt;has_mach_constant_base_node()) {
 1641     // NOTE: We set the table base offset here because users might be
 1642     // emitted before MachConstantBaseNode.
 1643     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
 1644     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1645   }
 1646 }
 1647 
 1648 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 1649 {
 1650   return MachNode::size(ra_); // too many variables; just compute it
 1651                               // the hard way
 1652 }
 1653 
</pre>
<hr />
<pre>
 1674     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1675     st-&gt;print(&quot;add  sp, sp, rscratch1\n\t&quot;);
 1676     st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
 1677   }
 1678 
 1679   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1680     st-&gt;print(&quot;# touch polling page\n\t&quot;);
 1681     st-&gt;print(&quot;mov  rscratch1, #0x%lx\n\t&quot;, p2i(os::get_polling_page()));
 1682     st-&gt;print(&quot;ldr zr, [rscratch1]&quot;);
 1683   }
 1684 }
 1685 #endif
 1686 
 1687 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1688   Compile* C = ra_-&gt;C;
 1689   MacroAssembler _masm(&amp;cbuf);
 1690   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
 1691 
 1692   __ remove_frame(framesize);
 1693 
<span class="line-removed"> 1694   if (NotifySimulator) {</span>
<span class="line-removed"> 1695     __ notify(Assembler::method_reentry);</span>
<span class="line-removed"> 1696   }</span>
<span class="line-removed"> 1697 </span>
 1698   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1699     __ reserved_stack_check();
 1700   }
 1701 
 1702   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1703     __ read_polling_page(rscratch1, os::get_polling_page(), relocInfo::poll_return_type);
 1704   }
 1705 }
 1706 
 1707 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1708   // Variable size. Determine dynamically.
 1709   return MachNode::size(ra_);
 1710 }
 1711 
 1712 int MachEpilogNode::reloc() const {
 1713   // Return number of relocatable values contained in this instruction.
 1714   return 1; // 1 for polling page.
 1715 }
 1716 
 1717 const Pipeline * MachEpilogNode::pipeline() const {
</pre>
<hr />
<pre>
 1723 // get rid of it?
 1724 int MachEpilogNode::safepoint_offset() const {
 1725   assert(do_polling(), &quot;no return for this epilog node&quot;);
 1726   return 4;
 1727 }
 1728 
 1729 //=============================================================================
 1730 
 1731 // Figure out which register class each belongs in: rc_int, rc_float or
 1732 // rc_stack.
 1733 enum RC { rc_bad, rc_int, rc_float, rc_stack };
 1734 
 1735 static enum RC rc_class(OptoReg::Name reg) {
 1736 
 1737   if (reg == OptoReg::Bad) {
 1738     return rc_bad;
 1739   }
 1740 
 1741   // we have 30 int registers * 2 halves
 1742   // (rscratch1 and rscratch2 are omitted)

 1743 
<span class="line-modified"> 1744   if (reg &lt; 60) {</span>
 1745     return rc_int;
 1746   }
 1747 
<span class="line-modified"> 1748   // we have 32 float register * 2 halves</span>
<span class="line-modified"> 1749   if (reg &lt; 60 + 128) {</span>
 1750     return rc_float;
 1751   }
 1752 
 1753   // Between float regs &amp; stack is the flags regs.
 1754   assert(OptoReg::is_stack(reg), &quot;blow up if spilling flags&quot;);
 1755 
 1756   return rc_stack;
 1757 }
 1758 
 1759 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {
 1760   Compile* C = ra_-&gt;C;
 1761 
 1762   // Get registers to move.
 1763   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1764   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1765   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1766   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1767 
 1768   enum RC src_hi_rc = rc_class(src_hi);
 1769   enum RC src_lo_rc = rc_class(src_lo);
</pre>
<hr />
<pre>
 1945   if (Assembler::operand_valid_for_add_sub_immediate(offset)) {
 1946     __ add(as_Register(reg), sp, offset);
 1947   } else {
 1948     ShouldNotReachHere();
 1949   }
 1950 }
 1951 
 1952 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1953   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_).
 1954   return 4;
 1955 }
 1956 
 1957 //=============================================================================
 1958 
 1959 #ifndef PRODUCT
 1960 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1961 {
 1962   st-&gt;print_cr(&quot;# MachUEPNode&quot;);
 1963   if (UseCompressedClassPointers) {
 1964     st-&gt;print_cr(&quot;\tldrw rscratch1, j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
<span class="line-modified"> 1965     if (Universe::narrow_klass_shift() != 0) {</span>
 1966       st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1967     }
 1968   } else {
 1969    st-&gt;print_cr(&quot;\tldr rscratch1, j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1970   }
 1971   st-&gt;print_cr(&quot;\tcmp r0, rscratch1\t # Inline cache check&quot;);
 1972   st-&gt;print_cr(&quot;\tbne, SharedRuntime::_ic_miss_stub&quot;);
 1973 }
 1974 #endif
 1975 
 1976 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1977 {
 1978   // This is the unverified entry point.
 1979   MacroAssembler _masm(&amp;cbuf);
 1980 
 1981   __ cmp_klass(j_rarg0, rscratch2, rscratch1);
 1982   Label skip;
 1983   // TODO
 1984   // can we avoid this skip and still use a reloc?
 1985   __ br(Assembler::EQ, skip);
</pre>
<hr />
<pre>
 2025   address base = __ start_a_stub(size_deopt_handler());
 2026   if (base == NULL) {
 2027     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2028     return 0;  // CodeBuffer::expand failed
 2029   }
 2030   int offset = __ offset();
 2031 
 2032   __ adr(lr, __ pc());
 2033   __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 2034 
 2035   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
 2036   __ end_a_stub();
 2037   return offset;
 2038 }
 2039 
 2040 // REQUIRED MATCHER CODE
 2041 
 2042 //=============================================================================
 2043 
 2044 const bool Matcher::match_rule_supported(int opcode) {


 2045 

 2046   switch (opcode) {
<span class="line-modified"> 2047   default:</span>
<span class="line-modified"> 2048     break;</span>
<span class="line-modified"> 2049   }</span>
<span class="line-modified"> 2050 </span>
<span class="line-modified"> 2051   if (!has_match_rule(opcode)) {</span>
<span class="line-modified"> 2052     return false;</span>

 2053   }
 2054 
<span class="line-modified"> 2055   return true;  // Per default match rules are supported.</span>
 2056 }
 2057 
<span class="line-modified"> 2058 const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {</span>
 2059 
 2060   // TODO
 2061   // identify extra cases that we might want to provide match rules for
 2062   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 2063   bool ret_value = match_rule_supported(opcode);
 2064   // Add rules here.
 2065 
 2066   return ret_value;  // Per default match rules are supported.
 2067 }
 2068 
 2069 const bool Matcher::has_predicated_vectors(void) {
 2070   return false;
 2071 }
 2072 
 2073 const int Matcher::float_pressure(int default_pressure_threshold) {
 2074   return default_pressure_threshold;
 2075 }
 2076 
 2077 int Matcher::regnum_to_fpu_offset(int regnum)
 2078 {
</pre>
<hr />
<pre>
 2155 const bool Matcher::init_array_count_is_in_bytes = false;
 2156 
 2157 // Use conditional move (CMOVL)
 2158 const int Matcher::long_cmove_cost() {
 2159   // long cmoves are no more expensive than int cmoves
 2160   return 0;
 2161 }
 2162 
 2163 const int Matcher::float_cmove_cost() {
 2164   // float cmoves are no more expensive than int cmoves
 2165   return 0;
 2166 }
 2167 
 2168 // Does the CPU require late expand (see block.cpp for description of late expand)?
 2169 const bool Matcher::require_postalloc_expand = false;
 2170 
 2171 // Do we need to mask the count passed to shift instructions or does
 2172 // the cpu only look at the lower 5/6 bits anyway?
 2173 const bool Matcher::need_masked_shift_count = false;
 2174 


















 2175 // This affects two different things:
 2176 //  - how Decode nodes are matched
 2177 //  - how ImplicitNullCheck opportunities are recognized
 2178 // If true, the matcher will try to remove all Decodes and match them
 2179 // (as operands) into nodes. NullChecks are not prepared to deal with
 2180 // Decodes by final_graph_reshaping().
 2181 // If false, final_graph_reshaping() forces the decode behind the Cmp
 2182 // for a NullCheck. The matcher matches the Decode node into a register.
 2183 // Implicit_null_check optimization moves the Decode along with the
 2184 // memory operation back up before the NullCheck.
 2185 bool Matcher::narrow_oop_use_complex_address() {
<span class="line-modified"> 2186   return Universe::narrow_oop_shift() == 0;</span>
 2187 }
 2188 
 2189 bool Matcher::narrow_klass_use_complex_address() {
 2190 // TODO
 2191 // decide whether we need to set this to true
 2192   return false;
 2193 }
 2194 
 2195 bool Matcher::const_oop_prefer_decode() {
 2196   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="line-modified"> 2197   return Universe::narrow_oop_base() == NULL;</span>
 2198 }
 2199 
 2200 bool Matcher::const_klass_prefer_decode() {
 2201   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified"> 2202   return Universe::narrow_klass_base() == NULL;</span>
 2203 }
 2204 
 2205 // Is it better to copy float constants, or load them directly from
 2206 // memory?  Intel can load a float constant from a direct address,
 2207 // requiring no extra registers.  Most RISCs will have to materialize
 2208 // an address into a register first, so they would do better to copy
 2209 // the constant from stack.
 2210 const bool Matcher::rematerialize_float_constants = false;
 2211 
 2212 // If CPU can load and store mis-aligned doubles directly then no
 2213 // fixup is needed.  Else we split the double into 2 integer pieces
 2214 // and move it piece-by-piece.  Only happens when passing doubles into
 2215 // C code as the Java calling convention forces doubles to be aligned.
 2216 const bool Matcher::misaligned_doubles_ok = true;
 2217 
 2218 // No-op on amd64
 2219 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2220   Unimplemented();
 2221 }
 2222 
<span class="line-modified"> 2223 // Advertise here if the CPU requires explicit rounding operations to</span>
<span class="line-removed"> 2224 // implement the UseStrictFP mode.</span>
 2225 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2226 
 2227 // Are floats converted to double when stored to stack during
 2228 // deoptimization?
 2229 bool Matcher::float_in_double() { return false; }
 2230 
 2231 // Do ints take an entire long register or just half?
 2232 // The relevant question is how the int is callee-saved:
 2233 // the whole long is written but de-opt&#39;ing will have to extract
 2234 // the relevant 32 bits.
 2235 const bool Matcher::int_in_long = true;
 2236 
 2237 // Return whether or not this register is ever used as an argument.
 2238 // This function is used on startup to build the trampoline stubs in
 2239 // generateOptoStub.  Registers not mentioned will be killed by the VM
 2240 // call in the trampoline, and arguments in those registers not be
 2241 // available to the callee.
 2242 bool Matcher::can_be_java_arg(int reg)
 2243 {
 2244   return
</pre>
<hr />
<pre>
 2339     address_visited.test_set(m-&gt;_idx); // Flag as address_visited
 2340     mstack.push(m-&gt;in(AddPNode::Address), Pre_Visit);
 2341     mstack.push(m-&gt;in(AddPNode::Base), Pre_Visit);
 2342     return true;
 2343   } else if (off-&gt;Opcode() == Op_ConvI2L &amp;&amp;
 2344              // Are there other uses besides address expressions?
 2345              !is_visited(off)) {
 2346     address_visited.test_set(m-&gt;_idx); // Flag as address_visited
 2347     address_visited.set(off-&gt;_idx); // Flag as address_visited
 2348     mstack.push(off-&gt;in(1), Pre_Visit);
 2349     mstack.push(m-&gt;in(AddPNode::Address), Pre_Visit);
 2350     mstack.push(m-&gt;in(AddPNode::Base), Pre_Visit);
 2351     return true;
 2352   }
 2353   return false;
 2354 }
 2355 
 2356 void Compile::reshape_address(AddPNode* addp) {
 2357 }
 2358 
<span class="line-removed"> 2359 // helper for encoding java_to_runtime calls on sim</span>
<span class="line-removed"> 2360 //</span>
<span class="line-removed"> 2361 // this is needed to compute the extra arguments required when</span>
<span class="line-removed"> 2362 // planting a call to the simulator blrt instruction. the TypeFunc</span>
<span class="line-removed"> 2363 // can be queried to identify the counts for integral, and floating</span>
<span class="line-removed"> 2364 // arguments and the return type</span>
<span class="line-removed"> 2365 </span>
<span class="line-removed"> 2366 static void getCallInfo(const TypeFunc *tf, int &amp;gpcnt, int &amp;fpcnt, int &amp;rtype)</span>
<span class="line-removed"> 2367 {</span>
<span class="line-removed"> 2368   int gps = 0;</span>
<span class="line-removed"> 2369   int fps = 0;</span>
<span class="line-removed"> 2370   const TypeTuple *domain = tf-&gt;domain();</span>
<span class="line-removed"> 2371   int max = domain-&gt;cnt();</span>
<span class="line-removed"> 2372   for (int i = TypeFunc::Parms; i &lt; max; i++) {</span>
<span class="line-removed"> 2373     const Type *t = domain-&gt;field_at(i);</span>
<span class="line-removed"> 2374     switch(t-&gt;basic_type()) {</span>
<span class="line-removed"> 2375     case T_FLOAT:</span>
<span class="line-removed"> 2376     case T_DOUBLE:</span>
<span class="line-removed"> 2377       fps++;</span>
<span class="line-removed"> 2378     default:</span>
<span class="line-removed"> 2379       gps++;</span>
<span class="line-removed"> 2380     }</span>
<span class="line-removed"> 2381   }</span>
<span class="line-removed"> 2382   gpcnt = gps;</span>
<span class="line-removed"> 2383   fpcnt = fps;</span>
<span class="line-removed"> 2384   BasicType rt = tf-&gt;return_type();</span>
<span class="line-removed"> 2385   switch (rt) {</span>
<span class="line-removed"> 2386   case T_VOID:</span>
<span class="line-removed"> 2387     rtype = MacroAssembler::ret_type_void;</span>
<span class="line-removed"> 2388     break;</span>
<span class="line-removed"> 2389   default:</span>
<span class="line-removed"> 2390     rtype = MacroAssembler::ret_type_integral;</span>
<span class="line-removed"> 2391     break;</span>
<span class="line-removed"> 2392   case T_FLOAT:</span>
<span class="line-removed"> 2393     rtype = MacroAssembler::ret_type_float;</span>
<span class="line-removed"> 2394     break;</span>
<span class="line-removed"> 2395   case T_DOUBLE:</span>
<span class="line-removed"> 2396     rtype = MacroAssembler::ret_type_double;</span>
<span class="line-removed"> 2397     break;</span>
<span class="line-removed"> 2398   }</span>
<span class="line-removed"> 2399 }</span>
 2400 
 2401 #define MOV_VOLATILE(REG, BASE, INDEX, SCALE, DISP, SCRATCH, INSN)      \
 2402   MacroAssembler _masm(&amp;cbuf);                                          \
 2403   {                                                                     \
 2404     guarantee(INDEX == -1, &quot;mode not permitted for volatile&quot;);          \
 2405     guarantee(DISP == 0, &quot;mode not permitted for volatile&quot;);            \
 2406     guarantee(SCALE == 0, &quot;mode not permitted for volatile&quot;);           \
 2407     __ INSN(REG, as_Register(BASE));                                    \
 2408   }
 2409 
<span class="line-removed"> 2410 typedef void (MacroAssembler::* mem_insn)(Register Rt, const Address &amp;adr);</span>
<span class="line-removed"> 2411 typedef void (MacroAssembler::* mem_float_insn)(FloatRegister Rt, const Address &amp;adr);</span>
<span class="line-removed"> 2412 typedef void (MacroAssembler::* mem_vector_insn)(FloatRegister Rt,</span>
<span class="line-removed"> 2413                                   MacroAssembler::SIMD_RegVariant T, const Address &amp;adr);</span>
 2414 
<span class="line-modified"> 2415   // Used for all non-volatile memory accesses.  The use of</span>
<span class="line-removed"> 2416   // $mem-&gt;opcode() to discover whether this pattern uses sign-extended</span>
<span class="line-removed"> 2417   // offsets is something of a kludge.</span>
<span class="line-removed"> 2418   static void loadStore(MacroAssembler masm, mem_insn insn,</span>
<span class="line-removed"> 2419                          Register reg, int opcode,</span>
<span class="line-removed"> 2420                          Register base, int index, int size, int disp)</span>
 2421   {
 2422     Address::extend scale;
 2423 
 2424     // Hooboy, this is fugly.  We need a way to communicate to the
 2425     // encoder that the index needs to be sign extended, so we have to
 2426     // enumerate all the cases.
 2427     switch (opcode) {
 2428     case INDINDEXSCALEDI2L:
 2429     case INDINDEXSCALEDI2LN:
 2430     case INDINDEXI2L:
 2431     case INDINDEXI2LN:
 2432       scale = Address::sxtw(size);
 2433       break;
 2434     default:
 2435       scale = Address::lsl(size);
 2436     }
 2437 
 2438     if (index == -1) {
<span class="line-modified"> 2439       (masm.*insn)(reg, Address(base, disp));</span>
 2440     } else {
 2441       assert(disp == 0, &quot;unsupported address mode: disp = %d&quot;, disp);
<span class="line-modified"> 2442       (masm.*insn)(reg, Address(base, as_Register(index), scale));</span>




























 2443     }

 2444   }
 2445 
 2446   static void loadStore(MacroAssembler masm, mem_float_insn insn,
<span class="line-modified"> 2447                          FloatRegister reg, int opcode,</span>
<span class="line-modified"> 2448                          Register base, int index, int size, int disp)</span>

 2449   {
 2450     Address::extend scale;
 2451 
 2452     switch (opcode) {
 2453     case INDINDEXSCALEDI2L:
 2454     case INDINDEXSCALEDI2LN:
 2455       scale = Address::sxtw(size);
 2456       break;
 2457     default:
 2458       scale = Address::lsl(size);
 2459     }
 2460 
<span class="line-modified"> 2461      if (index == -1) {</span>
<span class="line-modified"> 2462       (masm.*insn)(reg, Address(base, disp));</span>







 2463     } else {
 2464       assert(disp == 0, &quot;unsupported address mode: disp = %d&quot;, disp);
 2465       (masm.*insn)(reg, Address(base, as_Register(index), scale));
 2466     }
 2467   }
 2468 
 2469   static void loadStore(MacroAssembler masm, mem_vector_insn insn,
<span class="line-modified"> 2470                          FloatRegister reg, MacroAssembler::SIMD_RegVariant T,</span>
<span class="line-modified"> 2471                          int opcode, Register base, int index, int size, int disp)</span>
 2472   {
 2473     if (index == -1) {
 2474       (masm.*insn)(reg, T, Address(base, disp));
 2475     } else {
 2476       assert(disp == 0, &quot;unsupported address mode&quot;);
 2477       (masm.*insn)(reg, T, Address(base, as_Register(index), Address::lsl(size)));
 2478     }
 2479   }
 2480 
 2481 %}
 2482 
 2483 
 2484 
 2485 //----------ENCODING BLOCK-----------------------------------------------------
 2486 // This block specifies the encoding classes used by the compiler to
 2487 // output byte streams.  Encoding classes are parameterized macros
 2488 // used by Machine Instruction Nodes in order to generate the bit
 2489 // encoding of the instruction.  Operands specify their base encoding
 2490 // interface with the interface keyword.  There are currently
 2491 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
</pre>
<hr />
<pre>
 2508 // opcode keyword to specify, in order, their primary, secondary, and
 2509 // tertiary opcode.  Only the opcode sections which a particular
 2510 // instruction needs for encoding need to be specified.
 2511 encode %{
 2512   // Build emit functions for each basic byte or larger field in the
 2513   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 2514   // from C++ code in the enc_class source block.  Emit functions will
 2515   // live in the main source block for now.  In future, we can
 2516   // generalize this by adding a syntax that specifies the sizes of
 2517   // fields in an order, so that the adlc can build the emit functions
 2518   // automagically
 2519 
 2520   // catch all for unimplemented encodings
 2521   enc_class enc_unimplemented %{
 2522     MacroAssembler _masm(&amp;cbuf);
 2523     __ unimplemented(&quot;C2 catch all&quot;);
 2524   %}
 2525 
 2526   // BEGIN Non-volatile memory access
 2527 
<span class="line-modified"> 2528   enc_class aarch64_enc_ldrsbw(iRegI dst, memory mem) %{</span>


 2529     Register dst_reg = as_Register($dst$$reg);
 2530     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsbw, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2531                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2532   %}
 2533 
<span class="line-modified"> 2534   enc_class aarch64_enc_ldrsb(iRegI dst, memory mem) %{</span>


 2535     Register dst_reg = as_Register($dst$$reg);
 2536     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsb, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2537                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2538   %}
 2539 
<span class="line-modified"> 2540   enc_class aarch64_enc_ldrb(iRegI dst, memory mem) %{</span>


 2541     Register dst_reg = as_Register($dst$$reg);
 2542     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2543                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2544   %}
 2545 
<span class="line-modified"> 2546   enc_class aarch64_enc_ldrb(iRegL dst, memory mem) %{</span>


 2547     Register dst_reg = as_Register($dst$$reg);
 2548     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2549                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2550   %}
 2551 
<span class="line-modified"> 2552   enc_class aarch64_enc_ldrshw(iRegI dst, memory mem) %{</span>


 2553     Register dst_reg = as_Register($dst$$reg);
 2554     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrshw, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2555                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2556   %}
 2557 
<span class="line-modified"> 2558   enc_class aarch64_enc_ldrsh(iRegI dst, memory mem) %{</span>


 2559     Register dst_reg = as_Register($dst$$reg);
 2560     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsh, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2561                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2562   %}
 2563 
<span class="line-modified"> 2564   enc_class aarch64_enc_ldrh(iRegI dst, memory mem) %{</span>


 2565     Register dst_reg = as_Register($dst$$reg);
 2566     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2567                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2568   %}
 2569 
<span class="line-modified"> 2570   enc_class aarch64_enc_ldrh(iRegL dst, memory mem) %{</span>


 2571     Register dst_reg = as_Register($dst$$reg);
 2572     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2573                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2574   %}
 2575 
<span class="line-modified"> 2576   enc_class aarch64_enc_ldrw(iRegI dst, memory mem) %{</span>


 2577     Register dst_reg = as_Register($dst$$reg);
 2578     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2579                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2580   %}
 2581 
<span class="line-modified"> 2582   enc_class aarch64_enc_ldrw(iRegL dst, memory mem) %{</span>


 2583     Register dst_reg = as_Register($dst$$reg);
 2584     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2585                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2586   %}
 2587 
<span class="line-modified"> 2588   enc_class aarch64_enc_ldrsw(iRegL dst, memory mem) %{</span>


 2589     Register dst_reg = as_Register($dst$$reg);
 2590     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsw, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2591                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2592   %}
 2593 
<span class="line-modified"> 2594   enc_class aarch64_enc_ldr(iRegL dst, memory mem) %{</span>


 2595     Register dst_reg = as_Register($dst$$reg);
 2596     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2597                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2598   %}
 2599 
<span class="line-modified"> 2600   enc_class aarch64_enc_ldrs(vRegF dst, memory mem) %{</span>


 2601     FloatRegister dst_reg = as_FloatRegister($dst$$reg);
 2602     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2603                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2604   %}
 2605 
<span class="line-modified"> 2606   enc_class aarch64_enc_ldrd(vRegD dst, memory mem) %{</span>


 2607     FloatRegister dst_reg = as_FloatRegister($dst$$reg);
 2608     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2609                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="line-removed"> 2610   %}</span>
<span class="line-removed"> 2611 </span>
<span class="line-removed"> 2612   enc_class aarch64_enc_ldrvS(vecD dst, memory mem) %{</span>
<span class="line-removed"> 2613     FloatRegister dst_reg = as_FloatRegister($dst$$reg);</span>
<span class="line-removed"> 2614     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::S,</span>
<span class="line-removed"> 2615        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="line-removed"> 2616   %}</span>
<span class="line-removed"> 2617 </span>
<span class="line-removed"> 2618   enc_class aarch64_enc_ldrvD(vecD dst, memory mem) %{</span>
<span class="line-removed"> 2619     FloatRegister dst_reg = as_FloatRegister($dst$$reg);</span>
<span class="line-removed"> 2620     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::D,</span>
<span class="line-removed"> 2621        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="line-removed"> 2622   %}</span>
<span class="line-removed"> 2623 </span>
<span class="line-removed"> 2624   enc_class aarch64_enc_ldrvQ(vecX dst, memory mem) %{</span>
<span class="line-removed"> 2625     FloatRegister dst_reg = as_FloatRegister($dst$$reg);</span>
<span class="line-removed"> 2626     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::Q,</span>
<span class="line-removed"> 2627        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2628   %}
 2629 
<span class="line-modified"> 2630   enc_class aarch64_enc_strb(iRegI src, memory mem) %{</span>


 2631     Register src_reg = as_Register($src$$reg);
 2632     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strb, src_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2633                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="line-removed"> 2634   %}</span>
<span class="line-removed"> 2635 </span>
<span class="line-removed"> 2636   enc_class aarch64_enc_strb0(memory mem) %{</span>
<span class="line-removed"> 2637     MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-removed"> 2638     loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),</span>
<span class="line-removed"> 2639                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2640   %}
 2641 
<span class="line-modified"> 2642   enc_class aarch64_enc_strb0_ordered(memory mem) %{</span>


 2643     MacroAssembler _masm(&amp;cbuf);
<span class="line-removed"> 2644     __ membar(Assembler::StoreStore);</span>
 2645     loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),
<span class="line-modified"> 2646                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2647   %}
 2648 
<span class="line-modified"> 2649   enc_class aarch64_enc_strh(iRegI src, memory mem) %{</span>


 2650     Register src_reg = as_Register($src$$reg);
 2651     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strh, src_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2652                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2653   %}
 2654 
<span class="line-modified"> 2655   enc_class aarch64_enc_strh0(memory mem) %{</span>


 2656     MacroAssembler _masm(&amp;cbuf);
 2657     loadStore(_masm, &amp;MacroAssembler::strh, zr, $mem-&gt;opcode(),
<span class="line-modified"> 2658                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2659   %}
 2660 
<span class="line-modified"> 2661   enc_class aarch64_enc_strw(iRegI src, memory mem) %{</span>


 2662     Register src_reg = as_Register($src$$reg);
 2663     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strw, src_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2664                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2665   %}
 2666 
<span class="line-modified"> 2667   enc_class aarch64_enc_strw0(memory mem) %{</span>


 2668     MacroAssembler _masm(&amp;cbuf);
 2669     loadStore(_masm, &amp;MacroAssembler::strw, zr, $mem-&gt;opcode(),
<span class="line-modified"> 2670                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2671   %}
 2672 
<span class="line-modified"> 2673   enc_class aarch64_enc_str(iRegL src, memory mem) %{</span>


 2674     Register src_reg = as_Register($src$$reg);
 2675     // we sometimes get asked to store the stack pointer into the
 2676     // current thread -- we cannot do that directly on AArch64
 2677     if (src_reg == r31_sp) {
 2678       MacroAssembler _masm(&amp;cbuf);
 2679       assert(as_Register($mem$$base) == rthread, &quot;unexpected store for sp&quot;);
 2680       __ mov(rscratch2, sp);
 2681       src_reg = rscratch2;
 2682     }
 2683     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2684                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2685   %}
 2686 
<span class="line-modified"> 2687   enc_class aarch64_enc_str0(memory mem) %{</span>


 2688     MacroAssembler _masm(&amp;cbuf);
 2689     loadStore(_masm, &amp;MacroAssembler::str, zr, $mem-&gt;opcode(),
<span class="line-modified"> 2690                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2691   %}
 2692 
<span class="line-modified"> 2693   enc_class aarch64_enc_strs(vRegF src, memory mem) %{</span>


 2694     FloatRegister src_reg = as_FloatRegister($src$$reg);
 2695     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strs, src_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2696                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2697   %}
 2698 
<span class="line-modified"> 2699   enc_class aarch64_enc_strd(vRegD src, memory mem) %{</span>


 2700     FloatRegister src_reg = as_FloatRegister($src$$reg);
 2701     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strd, src_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2702                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
























































 2703   %}
 2704 
 2705   enc_class aarch64_enc_strvS(vecD src, memory mem) %{
 2706     FloatRegister src_reg = as_FloatRegister($src$$reg);
 2707     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::S,
 2708        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
 2709   %}
 2710 
 2711   enc_class aarch64_enc_strvD(vecD src, memory mem) %{
 2712     FloatRegister src_reg = as_FloatRegister($src$$reg);
 2713     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::D,
 2714        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
 2715   %}
 2716 
 2717   enc_class aarch64_enc_strvQ(vecX src, memory mem) %{
 2718     FloatRegister src_reg = as_FloatRegister($src$$reg);
 2719     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::Q,
 2720        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
 2721   %}
 2722 
<span class="line-removed"> 2723   // END Non-volatile memory access</span>
<span class="line-removed"> 2724 </span>
 2725   // volatile loads and stores
 2726 
 2727   enc_class aarch64_enc_stlrb(iRegI src, memory mem) %{
 2728     MOV_VOLATILE(as_Register($src$$reg), $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
 2729                  rscratch1, stlrb);
 2730   %}
 2731 
 2732   enc_class aarch64_enc_stlrh(iRegI src, memory mem) %{
 2733     MOV_VOLATILE(as_Register($src$$reg), $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
 2734                  rscratch1, stlrh);
 2735   %}
 2736 
 2737   enc_class aarch64_enc_stlrw(iRegI src, memory mem) %{
 2738     MOV_VOLATILE(as_Register($src$$reg), $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
 2739                  rscratch1, stlrw);
 2740   %}
 2741 
 2742 
 2743   enc_class aarch64_enc_ldarsbw(iRegI dst, memory mem) %{
 2744     Register dst_reg = as_Register($dst$$reg);
</pre>
<hr />
<pre>
 2834       MacroAssembler _masm(&amp;cbuf);
 2835       FloatRegister src_reg = as_FloatRegister($src$$reg);
 2836       __ fmovs(rscratch2, src_reg);
 2837     }
 2838     MOV_VOLATILE(rscratch2, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
 2839                  rscratch1, stlrw);
 2840   %}
 2841 
 2842   enc_class aarch64_enc_fstlrd(vRegD src, memory mem) %{
 2843     {
 2844       MacroAssembler _masm(&amp;cbuf);
 2845       FloatRegister src_reg = as_FloatRegister($src$$reg);
 2846       __ fmovd(rscratch2, src_reg);
 2847     }
 2848     MOV_VOLATILE(rscratch2, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
 2849                  rscratch1, stlr);
 2850   %}
 2851 
 2852   // synchronized read/update encodings
 2853 
<span class="line-modified"> 2854   enc_class aarch64_enc_ldaxr(iRegL dst, memory mem) %{</span>
 2855     MacroAssembler _masm(&amp;cbuf);
 2856     Register dst_reg = as_Register($dst$$reg);
 2857     Register base = as_Register($mem$$base);
 2858     int index = $mem$$index;
 2859     int scale = $mem$$scale;
 2860     int disp = $mem$$disp;
 2861     if (index == -1) {
 2862        if (disp != 0) {
 2863         __ lea(rscratch1, Address(base, disp));
 2864         __ ldaxr(dst_reg, rscratch1);
 2865       } else {
 2866         // TODO
 2867         // should we ever get anything other than this case?
 2868         __ ldaxr(dst_reg, base);
 2869       }
 2870     } else {
 2871       Register index_reg = as_Register(index);
 2872       if (disp == 0) {
 2873         __ lea(rscratch1, Address(base, index_reg, Address::lsl(scale)));
 2874         __ ldaxr(dst_reg, rscratch1);
 2875       } else {
 2876         __ lea(rscratch1, Address(base, disp));
 2877         __ lea(rscratch1, Address(rscratch1, index_reg, Address::lsl(scale)));
 2878         __ ldaxr(dst_reg, rscratch1);
 2879       }
 2880     }
 2881   %}
 2882 
<span class="line-modified"> 2883   enc_class aarch64_enc_stlxr(iRegLNoSp src, memory mem) %{</span>
 2884     MacroAssembler _masm(&amp;cbuf);
 2885     Register src_reg = as_Register($src$$reg);
 2886     Register base = as_Register($mem$$base);
 2887     int index = $mem$$index;
 2888     int scale = $mem$$scale;
 2889     int disp = $mem$$disp;
 2890     if (index == -1) {
 2891        if (disp != 0) {
 2892         __ lea(rscratch2, Address(base, disp));
 2893         __ stlxr(rscratch1, src_reg, rscratch2);
 2894       } else {
 2895         // TODO
 2896         // should we ever get anything other than this case?
 2897         __ stlxr(rscratch1, src_reg, base);
 2898       }
 2899     } else {
 2900       Register index_reg = as_Register(index);
 2901       if (disp == 0) {
 2902         __ lea(rscratch2, Address(base, index_reg, Address::lsl(scale)));
 2903         __ stlxr(rscratch1, src_reg, rscratch2);
</pre>
<hr />
<pre>
 3329     address call = __ ic_call((address)$meth$$method, method_index);
 3330     if (call == NULL) {
 3331       ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 3332       return;
 3333     }
 3334   %}
 3335 
 3336   enc_class aarch64_enc_call_epilog() %{
 3337     MacroAssembler _masm(&amp;cbuf);
 3338     if (VerifyStackAtCalls) {
 3339       // Check that stack depth is unchanged: find majik cookie on stack
 3340       __ call_Unimplemented();
 3341     }
 3342   %}
 3343 
 3344   enc_class aarch64_enc_java_to_runtime(method meth) %{
 3345     MacroAssembler _masm(&amp;cbuf);
 3346 
 3347     // some calls to generated routines (arraycopy code) are scheduled
 3348     // by C2 as runtime calls. if so we can call them using a br (they
<span class="line-modified"> 3349     // will be in a reachable segment) otherwise we have to use a blrt</span>
 3350     // which loads the absolute address into a register.
 3351     address entry = (address)$meth$$method;
 3352     CodeBlob *cb = CodeCache::find_blob(entry);
 3353     if (cb) {
 3354       address call = __ trampoline_call(Address(entry, relocInfo::runtime_call_type));
 3355       if (call == NULL) {
 3356         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 3357         return;
 3358       }
 3359     } else {
<span class="line-removed"> 3360       int gpcnt;</span>
<span class="line-removed"> 3361       int fpcnt;</span>
<span class="line-removed"> 3362       int rtype;</span>
<span class="line-removed"> 3363       getCallInfo(tf(), gpcnt, fpcnt, rtype);</span>
 3364       Label retaddr;
 3365       __ adr(rscratch2, retaddr);
 3366       __ lea(rscratch1, RuntimeAddress(entry));
 3367       // Leave a breadcrumb for JavaFrameAnchor::capture_last_Java_pc()
 3368       __ stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)));
<span class="line-modified"> 3369       __ blrt(rscratch1, gpcnt, fpcnt, rtype);</span>
 3370       __ bind(retaddr);
 3371       __ add(sp, sp, 2 * wordSize);
 3372     }
 3373   %}
 3374 
 3375   enc_class aarch64_enc_rethrow() %{
 3376     MacroAssembler _masm(&amp;cbuf);
 3377     __ far_jump(RuntimeAddress(OptoRuntime::rethrow_stub()));
 3378   %}
 3379 
 3380   enc_class aarch64_enc_ret() %{
 3381     MacroAssembler _masm(&amp;cbuf);
 3382     __ ret(lr);
 3383   %}
 3384 
 3385   enc_class aarch64_enc_tail_call(iRegP jump_target) %{
 3386     MacroAssembler _masm(&amp;cbuf);
 3387     Register target_reg = as_Register($jump_target$$reg);
 3388     __ br(target_reg);
 3389   %}
</pre>
<hr />
<pre>
 3393     Register target_reg = as_Register($jump_target$$reg);
 3394     // exception oop should be in r0
 3395     // ret addr has been popped into lr
 3396     // callee expects it in r3
 3397     __ mov(r3, lr);
 3398     __ br(target_reg);
 3399   %}
 3400 
 3401   enc_class aarch64_enc_fast_lock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{
 3402     MacroAssembler _masm(&amp;cbuf);
 3403     Register oop = as_Register($object$$reg);
 3404     Register box = as_Register($box$$reg);
 3405     Register disp_hdr = as_Register($tmp$$reg);
 3406     Register tmp = as_Register($tmp2$$reg);
 3407     Label cont;
 3408     Label object_has_monitor;
 3409     Label cas_failed;
 3410 
 3411     assert_different_registers(oop, box, tmp, disp_hdr);
 3412 
<span class="line-modified"> 3413     // Load markOop from object into displaced_header.</span>
 3414     __ ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));
 3415 
 3416     if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
 3417       __ biased_locking_enter(box, oop, disp_hdr, tmp, true, cont);
 3418     }
 3419 
 3420     // Check for existing monitor
<span class="line-modified"> 3421     __ tbnz(disp_hdr, exact_log2(markOopDesc::monitor_value), object_has_monitor);</span>
 3422 
<span class="line-modified"> 3423     // Set tmp to be (markOop of object | UNLOCK_VALUE).</span>
<span class="line-modified"> 3424     __ orr(tmp, disp_hdr, markOopDesc::unlocked_value);</span>
 3425 
 3426     // Initialize the box. (Must happen before we update the object mark!)
 3427     __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));
 3428 
<span class="line-modified"> 3429     // Compare object markOop with an unlocked value (tmp) and if</span>
<span class="line-modified"> 3430     // equal exchange the stack address of our box with object markOop.</span>
<span class="line-modified"> 3431     // On failure disp_hdr contains the possibly locked markOop.</span>
 3432     __ cmpxchg(oop, tmp, box, Assembler::xword, /*acquire*/ true,
 3433                /*release*/ true, /*weak*/ false, disp_hdr);
 3434     __ br(Assembler::EQ, cont);
 3435 
 3436     assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
 3437 
 3438     // If the compare-and-exchange succeeded, then we found an unlocked
 3439     // object, will have now locked it will continue at label cont
 3440 
 3441     __ bind(cas_failed);
 3442     // We did not see an unlocked object so try the fast recursive case.
 3443 
 3444     // Check if the owner is self by comparing the value in the
<span class="line-modified"> 3445     // markOop of object (disp_hdr) with the stack pointer.</span>
 3446     __ mov(rscratch1, sp);
 3447     __ sub(disp_hdr, disp_hdr, rscratch1);
<span class="line-modified"> 3448     __ mov(tmp, (address) (~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place));</span>
 3449     // If condition is true we are cont and hence we can store 0 as the
 3450     // displaced header in the box, which indicates that it is a recursive lock.
 3451     __ ands(tmp/*==0?*/, disp_hdr, tmp);   // Sets flags for result
 3452     __ str(tmp/*==0, perhaps*/, Address(box, BasicLock::displaced_header_offset_in_bytes()));
 3453 
 3454     __ b(cont);
 3455 
 3456     // Handle existing monitor.
 3457     __ bind(object_has_monitor);
 3458 
 3459     // The object&#39;s monitor m is unlocked iff m-&gt;owner == NULL,
 3460     // otherwise m-&gt;owner may contain a thread or a stack address.
 3461     //
 3462     // Try to CAS m-&gt;owner from NULL to current thread.
<span class="line-modified"> 3463     __ add(tmp, disp_hdr, (ObjectMonitor::owner_offset_in_bytes()-markOopDesc::monitor_value));</span>
 3464     __ cmpxchg(tmp, zr, rthread, Assembler::xword, /*acquire*/ true,
 3465                /*release*/ true, /*weak*/ false, noreg); // Sets flags for result
 3466 
 3467     // Store a non-null value into the box to avoid looking like a re-entrant
 3468     // lock. The fast-path monitor unlock code checks for
<span class="line-modified"> 3469     // markOopDesc::monitor_value so use markOopDesc::unused_mark which has the</span>
<span class="line-modified"> 3470     // relevant bit set, and also matches ObjectSynchronizer::slow_enter.</span>
<span class="line-modified"> 3471     __ mov(tmp, (address)markOopDesc::unused_mark());</span>
 3472     __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));
 3473 
 3474     __ bind(cont);
 3475     // flag == EQ indicates success
 3476     // flag == NE indicates failure
 3477   %}
 3478 
 3479   enc_class aarch64_enc_fast_unlock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{
 3480     MacroAssembler _masm(&amp;cbuf);
 3481     Register oop = as_Register($object$$reg);
 3482     Register box = as_Register($box$$reg);
 3483     Register disp_hdr = as_Register($tmp$$reg);
 3484     Register tmp = as_Register($tmp2$$reg);
 3485     Label cont;
 3486     Label object_has_monitor;
 3487 
 3488     assert_different_registers(oop, box, tmp, disp_hdr);
 3489 
 3490     if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
 3491       __ biased_locking_exit(oop, tmp, cont);
 3492     }
 3493 
 3494     // Find the lock address and load the displaced header from the stack.
 3495     __ ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));
 3496 
 3497     // If the displaced header is 0, we have a recursive unlock.
 3498     __ cmp(disp_hdr, zr);
 3499     __ br(Assembler::EQ, cont);
 3500 
 3501     // Handle existing monitor.
 3502     __ ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));
<span class="line-modified"> 3503     __ tbnz(disp_hdr, exact_log2(markOopDesc::monitor_value), object_has_monitor);</span>
 3504 
 3505     // Check if it is still a light weight lock, this is is true if we
<span class="line-modified"> 3506     // see the stack address of the basicLock in the markOop of the</span>
 3507     // object.
 3508 
 3509     __ cmpxchg(oop, box, disp_hdr, Assembler::xword, /*acquire*/ false,
 3510                /*release*/ true, /*weak*/ false, tmp);
 3511     __ b(cont);
 3512 
 3513     assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
 3514 
 3515     // Handle existing monitor.
 3516     __ bind(object_has_monitor);
<span class="line-modified"> 3517     __ add(tmp, tmp, -markOopDesc::monitor_value); // monitor</span>

 3518     __ ldr(rscratch1, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));
 3519     __ ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));
 3520     __ eor(rscratch1, rscratch1, rthread); // Will be 0 if we are the owner.
 3521     __ orr(rscratch1, rscratch1, disp_hdr); // Will be 0 if there are 0 recursions
 3522     __ cmp(rscratch1, zr); // Sets flags for result
 3523     __ br(Assembler::NE, cont);
 3524 
 3525     __ ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset_in_bytes()));
 3526     __ ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset_in_bytes()));
 3527     __ orr(rscratch1, rscratch1, disp_hdr); // Will be 0 if both are 0.
 3528     __ cmp(rscratch1, zr); // Sets flags for result
 3529     __ cbnz(rscratch1, cont);
 3530     // need a release store here
 3531     __ lea(tmp, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));
 3532     __ stlr(zr, tmp); // set unowned
 3533 
 3534     __ bind(cont);
 3535     // flag == EQ indicates success
 3536     // flag == NE indicates failure
 3537   %}
</pre>
<hr />
<pre>
 3671   return_value
 3672   %{
 3673     // TODO do we allow ideal_reg == Op_RegN???
 3674     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 3675            &quot;only return normal values&quot;);
 3676 
 3677     static const int lo[Op_RegL + 1] = { // enum name
 3678       0,                                 // Op_Node
 3679       0,                                 // Op_Set
 3680       R0_num,                            // Op_RegN
 3681       R0_num,                            // Op_RegI
 3682       R0_num,                            // Op_RegP
 3683       V0_num,                            // Op_RegF
 3684       V0_num,                            // Op_RegD
 3685       R0_num                             // Op_RegL
 3686     };
 3687 
 3688     static const int hi[Op_RegL + 1] = { // enum name
 3689       0,                                 // Op_Node
 3690       0,                                 // Op_Set
<span class="line-modified"> 3691       OptoReg::Bad,                       // Op_RegN</span>
 3692       OptoReg::Bad,                      // Op_RegI
 3693       R0_H_num,                          // Op_RegP
 3694       OptoReg::Bad,                      // Op_RegF
 3695       V0_H_num,                          // Op_RegD
 3696       R0_H_num                           // Op_RegL
 3697     };
 3698 
 3699     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 3700   %}
 3701 %}
 3702 
 3703 //----------ATTRIBUTES---------------------------------------------------------
 3704 //----------Operand Attributes-------------------------------------------------
 3705 op_attrib op_cost(1);        // Required cost attribute
 3706 
 3707 //----------Instruction Attributes---------------------------------------------
 3708 ins_attrib ins_cost(INSN_COST); // Required cost attribute
 3709 ins_attrib ins_size(32);        // Required size attribute (in bits)
 3710 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 3711                                 // a non-matching short branch variant
</pre>
<hr />
<pre>
 3915   predicate(n-&gt;get_long() == 65535L);
 3916   match(ConL);
 3917 
 3918   op_cost(0);
 3919   format %{ %}
 3920   interface(CONST_INTER);
 3921 %}
 3922 
 3923 operand immL_4294967295()
 3924 %{
 3925   predicate(n-&gt;get_long() == 4294967295L);
 3926   match(ConL);
 3927 
 3928   op_cost(0);
 3929   format %{ %}
 3930   interface(CONST_INTER);
 3931 %}
 3932 
 3933 operand immL_bitmask()
 3934 %{
<span class="line-modified"> 3935   predicate(((n-&gt;get_long() &amp; 0xc000000000000000l) == 0)</span>

 3936             &amp;&amp; is_power_of_2(n-&gt;get_long() + 1));
 3937   match(ConL);
 3938 
 3939   op_cost(0);
 3940   format %{ %}
 3941   interface(CONST_INTER);
 3942 %}
 3943 
 3944 operand immI_bitmask()
 3945 %{
<span class="line-modified"> 3946   predicate(((n-&gt;get_int() &amp; 0xc0000000) == 0)</span>

 3947             &amp;&amp; is_power_of_2(n-&gt;get_int() + 1));
 3948   match(ConI);
 3949 
 3950   op_cost(0);
 3951   format %{ %}
 3952   interface(CONST_INTER);
 3953 %}
 3954 
 3955 // Scale values for scaled offset addressing modes (up to long but not quad)
 3956 operand immIScale()
 3957 %{
 3958   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 3959   match(ConI);
 3960 
 3961   op_cost(0);
 3962   format %{ %}
 3963   interface(CONST_INTER);
 3964 %}
 3965 
 3966 // 26 bit signed offset -- for pc-relative branches
</pre>
<hr />
<pre>
 3992   match(ConI);
 3993 
 3994   op_cost(0);
 3995   format %{ %}
 3996   interface(CONST_INTER);
 3997 %}
 3998 
 3999 operand immLU12()
 4000 %{
 4001   predicate((0 &lt;= n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() &lt; (1 &lt;&lt; 12)));
 4002   match(ConL);
 4003 
 4004   op_cost(0);
 4005   format %{ %}
 4006   interface(CONST_INTER);
 4007 %}
 4008 
 4009 // Offset for scaled or unscaled immediate loads and stores
 4010 operand immIOffset()
 4011 %{
<span class="line-modified"> 4012   predicate(Address::offset_ok_for_immed(n-&gt;get_int()));</span>




















 4013   match(ConI);
 4014 
 4015   op_cost(0);
 4016   format %{ %}
 4017   interface(CONST_INTER);
 4018 %}
 4019 
 4020 operand immIOffset4()
 4021 %{
 4022   predicate(Address::offset_ok_for_immed(n-&gt;get_int(), 2));
 4023   match(ConI);
 4024 
 4025   op_cost(0);
 4026   format %{ %}
 4027   interface(CONST_INTER);
 4028 %}
 4029 
 4030 operand immIOffset8()
 4031 %{
 4032   predicate(Address::offset_ok_for_immed(n-&gt;get_int(), 3));
 4033   match(ConI);
 4034 
 4035   op_cost(0);
 4036   format %{ %}
 4037   interface(CONST_INTER);
 4038 %}
 4039 
 4040 operand immIOffset16()
 4041 %{
 4042   predicate(Address::offset_ok_for_immed(n-&gt;get_int(), 4));
 4043   match(ConI);
 4044 
 4045   op_cost(0);
 4046   format %{ %}
 4047   interface(CONST_INTER);
 4048 %}
 4049 
 4050 operand immLoffset()
 4051 %{
<span class="line-modified"> 4052   predicate(Address::offset_ok_for_immed(n-&gt;get_long()));</span>




















 4053   match(ConL);
 4054 
 4055   op_cost(0);
 4056   format %{ %}
 4057   interface(CONST_INTER);
 4058 %}
 4059 
 4060 operand immLoffset4()
 4061 %{
 4062   predicate(Address::offset_ok_for_immed(n-&gt;get_long(), 2));
 4063   match(ConL);
 4064 
 4065   op_cost(0);
 4066   format %{ %}
 4067   interface(CONST_INTER);
 4068 %}
 4069 
 4070 operand immLoffset8()
 4071 %{
 4072   predicate(Address::offset_ok_for_immed(n-&gt;get_long(), 3));
</pre>
<hr />
<pre>
 4615   match(RegI);
 4616   match(iRegINoSp);
 4617   op_cost(0);
 4618   format %{ %}
 4619   interface(REG_INTER);
 4620 %}
 4621 
 4622 
 4623 // Register R4 only
 4624 operand iRegI_R4()
 4625 %{
 4626   constraint(ALLOC_IN_RC(int_r4_reg));
 4627   match(RegI);
 4628   match(iRegINoSp);
 4629   op_cost(0);
 4630   format %{ %}
 4631   interface(REG_INTER);
 4632 %}
 4633 
 4634 
<span class="line-modified"> 4635 // Pointer Register Operands</span>
<span class="line-modified"> 4636 // Narrow Pointer Register</span>
<span class="line-modified"> 4637 operand iRegN()</span>








































































































































































































































































 4638 %{
<span class="line-modified"> 4639   constraint(ALLOC_IN_RC(any_reg32));</span>
<span class="line-modified"> 4640   match(RegN);</span>
<span class="line-removed"> 4641   match(iRegNNoSp);</span>
 4642   op_cost(0);
 4643   format %{ %}
 4644   interface(REG_INTER);
 4645 %}
 4646 
<span class="line-modified"> 4647 operand iRegN_R0()</span>
 4648 %{
<span class="line-modified"> 4649   constraint(ALLOC_IN_RC(r0_reg));</span>
<span class="line-modified"> 4650   match(iRegN);</span>
 4651   op_cost(0);
 4652   format %{ %}
 4653   interface(REG_INTER);
 4654 %}
 4655 
<span class="line-modified"> 4656 operand iRegN_R2()</span>
 4657 %{
<span class="line-modified"> 4658   constraint(ALLOC_IN_RC(r2_reg));</span>
<span class="line-modified"> 4659   match(iRegN);</span>
 4660   op_cost(0);
 4661   format %{ %}
 4662   interface(REG_INTER);
 4663 %}
 4664 
<span class="line-modified"> 4665 operand iRegN_R3()</span>
 4666 %{
<span class="line-modified"> 4667   constraint(ALLOC_IN_RC(r3_reg));</span>
<span class="line-modified"> 4668   match(iRegN);</span>
 4669   op_cost(0);
 4670   format %{ %}
 4671   interface(REG_INTER);
 4672 %}
 4673 
<span class="line-modified"> 4674 // Integer 64 bit Register not Special</span>
<span class="line-removed"> 4675 operand iRegNNoSp()</span>
 4676 %{
<span class="line-modified"> 4677   constraint(ALLOC_IN_RC(no_special_reg32));</span>
<span class="line-modified"> 4678   match(RegN);</span>
 4679   op_cost(0);
 4680   format %{ %}
 4681   interface(REG_INTER);
 4682 %}
 4683 
<span class="line-modified"> 4684 // heap base register -- used for encoding immN0</span>
<span class="line-removed"> 4685 </span>
<span class="line-removed"> 4686 operand iRegIHeapbase()</span>
 4687 %{
<span class="line-modified"> 4688   constraint(ALLOC_IN_RC(heapbase_reg));</span>
<span class="line-modified"> 4689   match(RegI);</span>
 4690   op_cost(0);
 4691   format %{ %}
 4692   interface(REG_INTER);
 4693 %}
 4694 
<span class="line-modified"> 4695 // Float Register</span>
<span class="line-removed"> 4696 // Float register operands</span>
<span class="line-removed"> 4697 operand vRegF()</span>
 4698 %{
<span class="line-modified"> 4699   constraint(ALLOC_IN_RC(float_reg));</span>
<span class="line-modified"> 4700   match(RegF);</span>
<span class="line-removed"> 4701 </span>
 4702   op_cost(0);
 4703   format %{ %}
 4704   interface(REG_INTER);
 4705 %}
 4706 
<span class="line-modified"> 4707 // Double Register</span>
<span class="line-removed"> 4708 // Double register operands</span>
<span class="line-removed"> 4709 operand vRegD()</span>
 4710 %{
<span class="line-modified"> 4711   constraint(ALLOC_IN_RC(double_reg));</span>
 4712   match(RegD);
<span class="line-removed"> 4713 </span>
 4714   op_cost(0);
 4715   format %{ %}
 4716   interface(REG_INTER);
 4717 %}
 4718 
<span class="line-modified"> 4719 operand vecD()</span>
 4720 %{
<span class="line-modified"> 4721   constraint(ALLOC_IN_RC(vectord_reg));</span>
<span class="line-modified"> 4722   match(VecD);</span>
<span class="line-removed"> 4723 </span>
 4724   op_cost(0);
 4725   format %{ %}
 4726   interface(REG_INTER);
 4727 %}
 4728 
<span class="line-modified"> 4729 operand vecX()</span>
 4730 %{
<span class="line-modified"> 4731   constraint(ALLOC_IN_RC(vectorx_reg));</span>
<span class="line-modified"> 4732   match(VecX);</span>
<span class="line-removed"> 4733 </span>
 4734   op_cost(0);
 4735   format %{ %}
 4736   interface(REG_INTER);
 4737 %}
 4738 
<span class="line-modified"> 4739 operand vRegD_V0()</span>
 4740 %{
<span class="line-modified"> 4741   constraint(ALLOC_IN_RC(v0_reg));</span>
 4742   match(RegD);
 4743   op_cost(0);
 4744   format %{ %}
 4745   interface(REG_INTER);
 4746 %}
 4747 
<span class="line-modified"> 4748 operand vRegD_V1()</span>
 4749 %{
<span class="line-modified"> 4750   constraint(ALLOC_IN_RC(v1_reg));</span>
 4751   match(RegD);
 4752   op_cost(0);
 4753   format %{ %}
 4754   interface(REG_INTER);
 4755 %}
 4756 
<span class="line-modified"> 4757 operand vRegD_V2()</span>
 4758 %{
<span class="line-modified"> 4759   constraint(ALLOC_IN_RC(v2_reg));</span>
 4760   match(RegD);
 4761   op_cost(0);
 4762   format %{ %}
 4763   interface(REG_INTER);
 4764 %}
 4765 
<span class="line-modified"> 4766 operand vRegD_V3()</span>
 4767 %{
<span class="line-modified"> 4768   constraint(ALLOC_IN_RC(v3_reg));</span>
 4769   match(RegD);
 4770   op_cost(0);
 4771   format %{ %}
 4772   interface(REG_INTER);
 4773 %}
 4774 
 4775 // Flags register, used as output of signed compare instructions
 4776 
 4777 // note that on AArch64 we also use this register as the output for
 4778 // for floating point compare instructions (CmpF CmpD). this ensures
 4779 // that ordered inequality tests use GT, GE, LT or LE none of which
 4780 // pass through cases where the result is unordered i.e. one or both
 4781 // inputs to the compare is a NaN. this means that the ideal code can
 4782 // replace e.g. a GT with an LE and not end up capturing the NaN case
 4783 // (where the comparison should always fail). EQ and NE tests are
 4784 // always generated in ideal code so that unordered folds into the NE
 4785 // case, matching the behaviour of AArch64 NE.
 4786 //
 4787 // This differs from x86 where the outputs of FP compares use a
 4788 // special FP flags registers and where compares based on this
</pre>
<hr />
<pre>
 4925     index($lreg);
 4926     scale(0x0);
 4927     disp(0x0);
 4928   %}
 4929 %}
 4930 
 4931 operand indOffI(iRegP reg, immIOffset off)
 4932 %{
 4933   constraint(ALLOC_IN_RC(ptr_reg));
 4934   match(AddP reg off);
 4935   op_cost(0);
 4936   format %{ &quot;[$reg, $off]&quot; %}
 4937   interface(MEMORY_INTER) %{
 4938     base($reg);
 4939     index(0xffffffff);
 4940     scale(0x0);
 4941     disp($off);
 4942   %}
 4943 %}
 4944 




























 4945 operand indOffI4(iRegP reg, immIOffset4 off)
 4946 %{
 4947   constraint(ALLOC_IN_RC(ptr_reg));
 4948   match(AddP reg off);
 4949   op_cost(0);
 4950   format %{ &quot;[$reg, $off]&quot; %}
 4951   interface(MEMORY_INTER) %{
 4952     base($reg);
 4953     index(0xffffffff);
 4954     scale(0x0);
 4955     disp($off);
 4956   %}
 4957 %}
 4958 
 4959 operand indOffI8(iRegP reg, immIOffset8 off)
 4960 %{
 4961   constraint(ALLOC_IN_RC(ptr_reg));
 4962   match(AddP reg off);
 4963   op_cost(0);
 4964   format %{ &quot;[$reg, $off]&quot; %}
</pre>
<hr />
<pre>
 4981     index(0xffffffff);
 4982     scale(0x0);
 4983     disp($off);
 4984   %}
 4985 %}
 4986 
 4987 operand indOffL(iRegP reg, immLoffset off)
 4988 %{
 4989   constraint(ALLOC_IN_RC(ptr_reg));
 4990   match(AddP reg off);
 4991   op_cost(0);
 4992   format %{ &quot;[$reg, $off]&quot; %}
 4993   interface(MEMORY_INTER) %{
 4994     base($reg);
 4995     index(0xffffffff);
 4996     scale(0x0);
 4997     disp($off);
 4998   %}
 4999 %}
 5000 




























 5001 operand indOffL4(iRegP reg, immLoffset4 off)
 5002 %{
 5003   constraint(ALLOC_IN_RC(ptr_reg));
 5004   match(AddP reg off);
 5005   op_cost(0);
 5006   format %{ &quot;[$reg, $off]&quot; %}
 5007   interface(MEMORY_INTER) %{
 5008     base($reg);
 5009     index(0xffffffff);
 5010     scale(0x0);
 5011     disp($off);
 5012   %}
 5013 %}
 5014 
 5015 operand indOffL8(iRegP reg, immLoffset8 off)
 5016 %{
 5017   constraint(ALLOC_IN_RC(ptr_reg));
 5018   match(AddP reg off);
 5019   op_cost(0);
 5020   format %{ &quot;[$reg, $off]&quot; %}
</pre>
<hr />
<pre>
 5025     disp($off);
 5026   %}
 5027 %}
 5028 
 5029 operand indOffL16(iRegP reg, immLoffset16 off)
 5030 %{
 5031   constraint(ALLOC_IN_RC(ptr_reg));
 5032   match(AddP reg off);
 5033   op_cost(0);
 5034   format %{ &quot;[$reg, $off]&quot; %}
 5035   interface(MEMORY_INTER) %{
 5036     base($reg);
 5037     index(0xffffffff);
 5038     scale(0x0);
 5039     disp($off);
 5040   %}
 5041 %}
 5042 
 5043 operand indirectN(iRegN reg)
 5044 %{
<span class="line-modified"> 5045   predicate(Universe::narrow_oop_shift() == 0);</span>
 5046   constraint(ALLOC_IN_RC(ptr_reg));
 5047   match(DecodeN reg);
 5048   op_cost(0);
 5049   format %{ &quot;[$reg]\t# narrow&quot; %}
 5050   interface(MEMORY_INTER) %{
 5051     base($reg);
 5052     index(0xffffffff);
 5053     scale(0x0);
 5054     disp(0x0);
 5055   %}
 5056 %}
 5057 
 5058 operand indIndexScaledI2LN(iRegN reg, iRegI ireg, immIScale scale)
 5059 %{
<span class="line-modified"> 5060   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; size_fits_all_mem_uses(n-&gt;as_AddP(), n-&gt;in(AddPNode::Offset)-&gt;in(2)-&gt;get_int()));</span>
 5061   constraint(ALLOC_IN_RC(ptr_reg));
 5062   match(AddP (DecodeN reg) (LShiftL (ConvI2L ireg) scale));
 5063   op_cost(0);
 5064   format %{ &quot;$reg, $ireg sxtw($scale), 0, I2L\t# narrow&quot; %}
 5065   interface(MEMORY_INTER) %{
 5066     base($reg);
 5067     index($ireg);
 5068     scale($scale);
 5069     disp(0x0);
 5070   %}
 5071 %}
 5072 
 5073 operand indIndexScaledN(iRegN reg, iRegL lreg, immIScale scale)
 5074 %{
<span class="line-modified"> 5075   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; size_fits_all_mem_uses(n-&gt;as_AddP(), n-&gt;in(AddPNode::Offset)-&gt;in(2)-&gt;get_int()));</span>
 5076   constraint(ALLOC_IN_RC(ptr_reg));
 5077   match(AddP (DecodeN reg) (LShiftL lreg scale));
 5078   op_cost(0);
 5079   format %{ &quot;$reg, $lreg lsl($scale)\t# narrow&quot; %}
 5080   interface(MEMORY_INTER) %{
 5081     base($reg);
 5082     index($lreg);
 5083     scale($scale);
 5084     disp(0x0);
 5085   %}
 5086 %}
 5087 
 5088 operand indIndexI2LN(iRegN reg, iRegI ireg)
 5089 %{
<span class="line-modified"> 5090   predicate(Universe::narrow_oop_shift() == 0);</span>
 5091   constraint(ALLOC_IN_RC(ptr_reg));
 5092   match(AddP (DecodeN reg) (ConvI2L ireg));
 5093   op_cost(0);
 5094   format %{ &quot;$reg, $ireg, 0, I2L\t# narrow&quot; %}
 5095   interface(MEMORY_INTER) %{
 5096     base($reg);
 5097     index($ireg);
 5098     scale(0x0);
 5099     disp(0x0);
 5100   %}
 5101 %}
 5102 
 5103 operand indIndexN(iRegN reg, iRegL lreg)
 5104 %{
<span class="line-modified"> 5105   predicate(Universe::narrow_oop_shift() == 0);</span>
 5106   constraint(ALLOC_IN_RC(ptr_reg));
 5107   match(AddP (DecodeN reg) lreg);
 5108   op_cost(0);
 5109   format %{ &quot;$reg, $lreg\t# narrow&quot; %}
 5110   interface(MEMORY_INTER) %{
 5111     base($reg);
 5112     index($lreg);
 5113     scale(0x0);
 5114     disp(0x0);
 5115   %}
 5116 %}
 5117 
 5118 operand indOffIN(iRegN reg, immIOffset off)
 5119 %{
<span class="line-modified"> 5120   predicate(Universe::narrow_oop_shift() == 0);</span>
 5121   constraint(ALLOC_IN_RC(ptr_reg));
 5122   match(AddP (DecodeN reg) off);
 5123   op_cost(0);
 5124   format %{ &quot;[$reg, $off]\t# narrow&quot; %}
 5125   interface(MEMORY_INTER) %{
 5126     base($reg);
 5127     index(0xffffffff);
 5128     scale(0x0);
 5129     disp($off);
 5130   %}
 5131 %}
 5132 
 5133 operand indOffLN(iRegN reg, immLoffset off)
 5134 %{
<span class="line-modified"> 5135   predicate(Universe::narrow_oop_shift() == 0);</span>
 5136   constraint(ALLOC_IN_RC(ptr_reg));
 5137   match(AddP (DecodeN reg) off);
 5138   op_cost(0);
 5139   format %{ &quot;[$reg, $off]\t# narrow&quot; %}
 5140   interface(MEMORY_INTER) %{
 5141     base($reg);
 5142     index(0xffffffff);
 5143     scale(0x0);
 5144     disp($off);
 5145   %}
 5146 %}
 5147 
 5148 
 5149 
 5150 // AArch64 opto stubs need to write to the pc slot in the thread anchor
 5151 operand thread_anchor_pc(thread_RegP reg, immL_pc_off off)
 5152 %{
 5153   constraint(ALLOC_IN_RC(ptr_reg));
 5154   match(AddP reg off);
 5155   op_cost(0);
</pre>
<hr />
<pre>
 5282 
 5283   format %{ &quot;&quot; %}
 5284   interface(COND_INTER) %{
 5285     equal(0x0, &quot;eq&quot;);
 5286     not_equal(0x1, &quot;ne&quot;);
 5287     less(0x3, &quot;lo&quot;);
 5288     greater_equal(0x2, &quot;hs&quot;);
 5289     less_equal(0x9, &quot;ls&quot;);
 5290     greater(0x8, &quot;hi&quot;);
 5291     overflow(0x6, &quot;vs&quot;);
 5292     no_overflow(0x7, &quot;vc&quot;);
 5293   %}
 5294 %}
 5295 
 5296 // used for certain integral comparisons which can be
 5297 // converted to cbxx or tbxx instructions
 5298 
 5299 operand cmpOpEqNe()
 5300 %{
 5301   match(Bool);
<span class="line-removed"> 5302   match(CmpOp);</span>
 5303   op_cost(0);
 5304   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne
 5305             || n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 5306 
 5307   format %{ &quot;&quot; %}
 5308   interface(COND_INTER) %{
 5309     equal(0x0, &quot;eq&quot;);
 5310     not_equal(0x1, &quot;ne&quot;);
 5311     less(0xb, &quot;lt&quot;);
 5312     greater_equal(0xa, &quot;ge&quot;);
 5313     less_equal(0xd, &quot;le&quot;);
 5314     greater(0xc, &quot;gt&quot;);
 5315     overflow(0x6, &quot;vs&quot;);
 5316     no_overflow(0x7, &quot;vc&quot;);
 5317   %}
 5318 %}
 5319 
 5320 // used for certain integral comparisons which can be
 5321 // converted to cbxx or tbxx instructions
 5322 
 5323 operand cmpOpLtGe()
 5324 %{
 5325   match(Bool);
<span class="line-removed"> 5326   match(CmpOp);</span>
 5327   op_cost(0);
 5328 
 5329   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt
 5330             || n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 5331 
 5332   format %{ &quot;&quot; %}
 5333   interface(COND_INTER) %{
 5334     equal(0x0, &quot;eq&quot;);
 5335     not_equal(0x1, &quot;ne&quot;);
 5336     less(0xb, &quot;lt&quot;);
 5337     greater_equal(0xa, &quot;ge&quot;);
 5338     less_equal(0xd, &quot;le&quot;);
 5339     greater(0xc, &quot;gt&quot;);
 5340     overflow(0x6, &quot;vs&quot;);
 5341     no_overflow(0x7, &quot;vc&quot;);
 5342   %}
 5343 %}
 5344 
 5345 // used for certain unsigned integral comparisons which can be
 5346 // converted to cbxx or tbxx instructions
 5347 
 5348 operand cmpOpUEqNeLtGe()
 5349 %{
 5350   match(Bool);
<span class="line-removed"> 5351   match(CmpOp);</span>
 5352   op_cost(0);
 5353 
 5354   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq
 5355             || n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne
 5356             || n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt
 5357             || n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 5358 
 5359   format %{ &quot;&quot; %}
 5360   interface(COND_INTER) %{
 5361     equal(0x0, &quot;eq&quot;);
 5362     not_equal(0x1, &quot;ne&quot;);
 5363     less(0xb, &quot;lt&quot;);
 5364     greater_equal(0xa, &quot;ge&quot;);
 5365     less_equal(0xd, &quot;le&quot;);
 5366     greater(0xc, &quot;gt&quot;);
 5367     overflow(0x6, &quot;vs&quot;);
 5368     no_overflow(0x7, &quot;vc&quot;);
 5369   %}
 5370 %}
 5371 
</pre>
<hr />
<pre>
 5379 
 5380   format %{ &quot;l2i($reg)&quot; %}
 5381 
 5382   interface(REG_INTER)
 5383 %}
 5384 
 5385 opclass vmem4(indirect, indIndex, indOffI4, indOffL4);
 5386 opclass vmem8(indirect, indIndex, indOffI8, indOffL8);
 5387 opclass vmem16(indirect, indIndex, indOffI16, indOffL16);
 5388 
 5389 //----------OPERAND CLASSES----------------------------------------------------
 5390 // Operand Classes are groups of operands that are used as to simplify
 5391 // instruction definitions by not requiring the AD writer to specify
 5392 // separate instructions for every form of operand when the
 5393 // instruction accepts multiple operand types with the same basic
 5394 // encoding and format. The classic case of this is memory operands.
 5395 
 5396 // memory is used to define read/write location for load/store
 5397 // instruction defs. we can turn a memory op into an Address
 5398 
<span class="line-modified"> 5399 opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI, indOffL,</span>









 5400                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);
 5401 






 5402 // iRegIorL2I is used for src inputs in rules for 32 bit int (I)
 5403 // operations. it allows the src to be either an iRegI or a (ConvL2I
 5404 // iRegL). in the latter case the l2i normally planted for a ConvL2I
 5405 // can be elided because the 32-bit instruction will just employ the
 5406 // lower 32 bits anyway.
 5407 //
 5408 // n.b. this does not elide all L2I conversions. if the truncated
 5409 // value is consumed by more than one operation then the ConvL2I
 5410 // cannot be bundled into the consuming nodes so an l2i gets planted
 5411 // (actually a movw $dst $src) and the downstream instructions consume
 5412 // the result of the l2i as an iRegI input. That&#39;s a shame since the
 5413 // movw is actually redundant but its not too costly.
 5414 
 5415 opclass iRegIorL2I(iRegI, iRegL2I);
 5416 
 5417 //----------PIPELINE-----------------------------------------------------------
 5418 // Rules which define the behavior of the target architectures pipeline.
 5419 
 5420 // For specific pipelines, eg A53, define the stages of that pipeline
 5421 //pipe_desc(ISS, EX1, EX2, WR);
</pre>
<hr />
<pre>
 6365 //               instructions.
 6366 // format     -- A string providing the disassembly for this instruction.
 6367 //               The value of an instruction&#39;s operand may be inserted
 6368 //               by referring to it with a &#39;$&#39; prefix.
 6369 // opcode     -- Three instruction opcodes may be provided.  These are referred
 6370 //               to within an encode class as $primary, $secondary, and $tertiary
 6371 //               rrspectively.  The primary opcode is commonly used to
 6372 //               indicate the type of machine instruction, while secondary
 6373 //               and tertiary are often used for prefix options or addressing
 6374 //               modes.
 6375 // ins_encode -- A list of encode classes with parameters. The encode class
 6376 //               name must have been defined in an &#39;enc_class&#39; specification
 6377 //               in the encode section of the architecture description.
 6378 
 6379 // ============================================================================
 6380 // Memory (Load/Store) Instructions
 6381 
 6382 // Load Instructions
 6383 
 6384 // Load Byte (8 bit signed)
<span class="line-modified"> 6385 instruct loadB(iRegINoSp dst, memory mem)</span>
 6386 %{
 6387   match(Set dst (LoadB mem));
 6388   predicate(!needs_acquiring_load(n));
 6389 
 6390   ins_cost(4 * INSN_COST);
 6391   format %{ &quot;ldrsbw  $dst, $mem\t# byte&quot; %}
 6392 
 6393   ins_encode(aarch64_enc_ldrsbw(dst, mem));
 6394 
 6395   ins_pipe(iload_reg_mem);
 6396 %}
 6397 
 6398 // Load Byte (8 bit signed) into long
<span class="line-modified"> 6399 instruct loadB2L(iRegLNoSp dst, memory mem)</span>
 6400 %{
 6401   match(Set dst (ConvI2L (LoadB mem)));
 6402   predicate(!needs_acquiring_load(n-&gt;in(1)));
 6403 
 6404   ins_cost(4 * INSN_COST);
 6405   format %{ &quot;ldrsb  $dst, $mem\t# byte&quot; %}
 6406 
 6407   ins_encode(aarch64_enc_ldrsb(dst, mem));
 6408 
 6409   ins_pipe(iload_reg_mem);
 6410 %}
 6411 
 6412 // Load Byte (8 bit unsigned)
<span class="line-modified"> 6413 instruct loadUB(iRegINoSp dst, memory mem)</span>
 6414 %{
 6415   match(Set dst (LoadUB mem));
 6416   predicate(!needs_acquiring_load(n));
 6417 
 6418   ins_cost(4 * INSN_COST);
 6419   format %{ &quot;ldrbw  $dst, $mem\t# byte&quot; %}
 6420 
 6421   ins_encode(aarch64_enc_ldrb(dst, mem));
 6422 
 6423   ins_pipe(iload_reg_mem);
 6424 %}
 6425 
 6426 // Load Byte (8 bit unsigned) into long
<span class="line-modified"> 6427 instruct loadUB2L(iRegLNoSp dst, memory mem)</span>
 6428 %{
 6429   match(Set dst (ConvI2L (LoadUB mem)));
 6430   predicate(!needs_acquiring_load(n-&gt;in(1)));
 6431 
 6432   ins_cost(4 * INSN_COST);
 6433   format %{ &quot;ldrb  $dst, $mem\t# byte&quot; %}
 6434 
 6435   ins_encode(aarch64_enc_ldrb(dst, mem));
 6436 
 6437   ins_pipe(iload_reg_mem);
 6438 %}
 6439 
 6440 // Load Short (16 bit signed)
<span class="line-modified"> 6441 instruct loadS(iRegINoSp dst, memory mem)</span>
 6442 %{
 6443   match(Set dst (LoadS mem));
 6444   predicate(!needs_acquiring_load(n));
 6445 
 6446   ins_cost(4 * INSN_COST);
 6447   format %{ &quot;ldrshw  $dst, $mem\t# short&quot; %}
 6448 
 6449   ins_encode(aarch64_enc_ldrshw(dst, mem));
 6450 
 6451   ins_pipe(iload_reg_mem);
 6452 %}
 6453 
 6454 // Load Short (16 bit signed) into long
<span class="line-modified"> 6455 instruct loadS2L(iRegLNoSp dst, memory mem)</span>
 6456 %{
 6457   match(Set dst (ConvI2L (LoadS mem)));
 6458   predicate(!needs_acquiring_load(n-&gt;in(1)));
 6459 
 6460   ins_cost(4 * INSN_COST);
 6461   format %{ &quot;ldrsh  $dst, $mem\t# short&quot; %}
 6462 
 6463   ins_encode(aarch64_enc_ldrsh(dst, mem));
 6464 
 6465   ins_pipe(iload_reg_mem);
 6466 %}
 6467 
 6468 // Load Char (16 bit unsigned)
<span class="line-modified"> 6469 instruct loadUS(iRegINoSp dst, memory mem)</span>
 6470 %{
 6471   match(Set dst (LoadUS mem));
 6472   predicate(!needs_acquiring_load(n));
 6473 
 6474   ins_cost(4 * INSN_COST);
 6475   format %{ &quot;ldrh  $dst, $mem\t# short&quot; %}
 6476 
 6477   ins_encode(aarch64_enc_ldrh(dst, mem));
 6478 
 6479   ins_pipe(iload_reg_mem);
 6480 %}
 6481 
 6482 // Load Short/Char (16 bit unsigned) into long
<span class="line-modified"> 6483 instruct loadUS2L(iRegLNoSp dst, memory mem)</span>
 6484 %{
 6485   match(Set dst (ConvI2L (LoadUS mem)));
 6486   predicate(!needs_acquiring_load(n-&gt;in(1)));
 6487 
 6488   ins_cost(4 * INSN_COST);
 6489   format %{ &quot;ldrh  $dst, $mem\t# short&quot; %}
 6490 
 6491   ins_encode(aarch64_enc_ldrh(dst, mem));
 6492 
 6493   ins_pipe(iload_reg_mem);
 6494 %}
 6495 
 6496 // Load Integer (32 bit signed)
<span class="line-modified"> 6497 instruct loadI(iRegINoSp dst, memory mem)</span>
 6498 %{
 6499   match(Set dst (LoadI mem));
 6500   predicate(!needs_acquiring_load(n));
 6501 
 6502   ins_cost(4 * INSN_COST);
 6503   format %{ &quot;ldrw  $dst, $mem\t# int&quot; %}
 6504 
 6505   ins_encode(aarch64_enc_ldrw(dst, mem));
 6506 
 6507   ins_pipe(iload_reg_mem);
 6508 %}
 6509 
 6510 // Load Integer (32 bit signed) into long
<span class="line-modified"> 6511 instruct loadI2L(iRegLNoSp dst, memory mem)</span>
 6512 %{
 6513   match(Set dst (ConvI2L (LoadI mem)));
 6514   predicate(!needs_acquiring_load(n-&gt;in(1)));
 6515 
 6516   ins_cost(4 * INSN_COST);
 6517   format %{ &quot;ldrsw  $dst, $mem\t# int&quot; %}
 6518 
 6519   ins_encode(aarch64_enc_ldrsw(dst, mem));
 6520 
 6521   ins_pipe(iload_reg_mem);
 6522 %}
 6523 
 6524 // Load Integer (32 bit unsigned) into long
<span class="line-modified"> 6525 instruct loadUI2L(iRegLNoSp dst, memory mem, immL_32bits mask)</span>
 6526 %{
 6527   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 6528   predicate(!needs_acquiring_load(n-&gt;in(1)-&gt;in(1)-&gt;as_Load()));
 6529 
 6530   ins_cost(4 * INSN_COST);
 6531   format %{ &quot;ldrw  $dst, $mem\t# int&quot; %}
 6532 
 6533   ins_encode(aarch64_enc_ldrw(dst, mem));
 6534 
 6535   ins_pipe(iload_reg_mem);
 6536 %}
 6537 
 6538 // Load Long (64 bit signed)
<span class="line-modified"> 6539 instruct loadL(iRegLNoSp dst, memory mem)</span>
 6540 %{
 6541   match(Set dst (LoadL mem));
 6542   predicate(!needs_acquiring_load(n));
 6543 
 6544   ins_cost(4 * INSN_COST);
 6545   format %{ &quot;ldr  $dst, $mem\t# int&quot; %}
 6546 
 6547   ins_encode(aarch64_enc_ldr(dst, mem));
 6548 
 6549   ins_pipe(iload_reg_mem);
 6550 %}
 6551 
 6552 // Load Range
<span class="line-modified"> 6553 instruct loadRange(iRegINoSp dst, memory mem)</span>
 6554 %{
 6555   match(Set dst (LoadRange mem));
 6556 
 6557   ins_cost(4 * INSN_COST);
 6558   format %{ &quot;ldrw  $dst, $mem\t# range&quot; %}
 6559 
 6560   ins_encode(aarch64_enc_ldrw(dst, mem));
 6561 
 6562   ins_pipe(iload_reg_mem);
 6563 %}
 6564 
 6565 // Load Pointer
<span class="line-modified"> 6566 instruct loadP(iRegPNoSp dst, memory mem)</span>
 6567 %{
 6568   match(Set dst (LoadP mem));
<span class="line-modified"> 6569   predicate(!needs_acquiring_load(n));</span>
 6570 
 6571   ins_cost(4 * INSN_COST);
 6572   format %{ &quot;ldr  $dst, $mem\t# ptr&quot; %}
 6573 
 6574   ins_encode(aarch64_enc_ldr(dst, mem));
 6575 
 6576   ins_pipe(iload_reg_mem);
 6577 %}
 6578 
 6579 // Load Compressed Pointer
<span class="line-modified"> 6580 instruct loadN(iRegNNoSp dst, memory mem)</span>
 6581 %{
 6582   match(Set dst (LoadN mem));
 6583   predicate(!needs_acquiring_load(n));
 6584 
 6585   ins_cost(4 * INSN_COST);
 6586   format %{ &quot;ldrw  $dst, $mem\t# compressed ptr&quot; %}
 6587 
 6588   ins_encode(aarch64_enc_ldrw(dst, mem));
 6589 
 6590   ins_pipe(iload_reg_mem);
 6591 %}
 6592 
 6593 // Load Klass Pointer
<span class="line-modified"> 6594 instruct loadKlass(iRegPNoSp dst, memory mem)</span>
 6595 %{
 6596   match(Set dst (LoadKlass mem));
 6597   predicate(!needs_acquiring_load(n));
 6598 
 6599   ins_cost(4 * INSN_COST);
 6600   format %{ &quot;ldr  $dst, $mem\t# class&quot; %}
 6601 
 6602   ins_encode(aarch64_enc_ldr(dst, mem));
 6603 
 6604   ins_pipe(iload_reg_mem);
 6605 %}
 6606 
 6607 // Load Narrow Klass Pointer
<span class="line-modified"> 6608 instruct loadNKlass(iRegNNoSp dst, memory mem)</span>
 6609 %{
 6610   match(Set dst (LoadNKlass mem));
 6611   predicate(!needs_acquiring_load(n));
 6612 
 6613   ins_cost(4 * INSN_COST);
 6614   format %{ &quot;ldrw  $dst, $mem\t# compressed class ptr&quot; %}
 6615 
 6616   ins_encode(aarch64_enc_ldrw(dst, mem));
 6617 
 6618   ins_pipe(iload_reg_mem);
 6619 %}
 6620 
 6621 // Load Float
<span class="line-modified"> 6622 instruct loadF(vRegF dst, memory mem)</span>
 6623 %{
 6624   match(Set dst (LoadF mem));
 6625   predicate(!needs_acquiring_load(n));
 6626 
 6627   ins_cost(4 * INSN_COST);
 6628   format %{ &quot;ldrs  $dst, $mem\t# float&quot; %}
 6629 
 6630   ins_encode( aarch64_enc_ldrs(dst, mem) );
 6631 
 6632   ins_pipe(pipe_class_memory);
 6633 %}
 6634 
 6635 // Load Double
<span class="line-modified"> 6636 instruct loadD(vRegD dst, memory mem)</span>
 6637 %{
 6638   match(Set dst (LoadD mem));
 6639   predicate(!needs_acquiring_load(n));
 6640 
 6641   ins_cost(4 * INSN_COST);
 6642   format %{ &quot;ldrd  $dst, $mem\t# double&quot; %}
 6643 
 6644   ins_encode( aarch64_enc_ldrd(dst, mem) );
 6645 
 6646   ins_pipe(pipe_class_memory);
 6647 %}
 6648 
 6649 
 6650 // Load Int Constant
 6651 instruct loadConI(iRegINoSp dst, immI src)
 6652 %{
 6653   match(Set dst src);
 6654 
 6655   ins_cost(INSN_COST);
 6656   format %{ &quot;mov $dst, $src\t# int&quot; %}
</pre>
<hr />
<pre>
 6834 // Load Double Constant
 6835 
 6836 instruct loadConD(vRegD dst, immD con) %{
 6837   match(Set dst con);
 6838 
 6839   ins_cost(INSN_COST * 5);
 6840   format %{
 6841     &quot;ldrd $dst, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
 6842   %}
 6843 
 6844   ins_encode %{
 6845     __ ldrd(as_FloatRegister($dst$$reg), $constantaddress($con));
 6846   %}
 6847 
 6848   ins_pipe(fp_load_constant_d);
 6849 %}
 6850 
 6851 // Store Instructions
 6852 
 6853 // Store CMS card-mark Immediate
<span class="line-modified"> 6854 instruct storeimmCM0(immI0 zero, memory mem)</span>
 6855 %{
 6856   match(Set mem (StoreCM mem zero));
<span class="line-removed"> 6857   predicate(unnecessary_storestore(n));</span>
 6858 
 6859   ins_cost(INSN_COST);
 6860   format %{ &quot;storestore (elided)\n\t&quot;
 6861             &quot;strb zr, $mem\t# byte&quot; %}
 6862 
 6863   ins_encode(aarch64_enc_strb0(mem));
 6864 
 6865   ins_pipe(istore_mem);
 6866 %}
 6867 
 6868 // Store CMS card-mark Immediate with intervening StoreStore
 6869 // needed when using CMS with no conditional card marking
<span class="line-modified"> 6870 instruct storeimmCM0_ordered(immI0 zero, memory mem)</span>
 6871 %{
 6872   match(Set mem (StoreCM mem zero));
 6873 
 6874   ins_cost(INSN_COST * 2);
 6875   format %{ &quot;storestore\n\t&quot;
 6876             &quot;dmb ishst&quot;
 6877             &quot;\n\tstrb zr, $mem\t# byte&quot; %}
 6878 
 6879   ins_encode(aarch64_enc_strb0_ordered(mem));
 6880 
 6881   ins_pipe(istore_mem);
 6882 %}
 6883 
 6884 // Store Byte
<span class="line-modified"> 6885 instruct storeB(iRegIorL2I src, memory mem)</span>
 6886 %{
 6887   match(Set mem (StoreB mem src));
 6888   predicate(!needs_releasing_store(n));
 6889 
 6890   ins_cost(INSN_COST);
 6891   format %{ &quot;strb  $src, $mem\t# byte&quot; %}
 6892 
 6893   ins_encode(aarch64_enc_strb(src, mem));
 6894 
 6895   ins_pipe(istore_reg_mem);
 6896 %}
 6897 
 6898 
<span class="line-modified"> 6899 instruct storeimmB0(immI0 zero, memory mem)</span>
 6900 %{
 6901   match(Set mem (StoreB mem zero));
 6902   predicate(!needs_releasing_store(n));
 6903 
 6904   ins_cost(INSN_COST);
 6905   format %{ &quot;strb rscractch2, $mem\t# byte&quot; %}
 6906 
 6907   ins_encode(aarch64_enc_strb0(mem));
 6908 
 6909   ins_pipe(istore_mem);
 6910 %}
 6911 
 6912 // Store Char/Short
<span class="line-modified"> 6913 instruct storeC(iRegIorL2I src, memory mem)</span>
 6914 %{
 6915   match(Set mem (StoreC mem src));
 6916   predicate(!needs_releasing_store(n));
 6917 
 6918   ins_cost(INSN_COST);
 6919   format %{ &quot;strh  $src, $mem\t# short&quot; %}
 6920 
 6921   ins_encode(aarch64_enc_strh(src, mem));
 6922 
 6923   ins_pipe(istore_reg_mem);
 6924 %}
 6925 
<span class="line-modified"> 6926 instruct storeimmC0(immI0 zero, memory mem)</span>
 6927 %{
 6928   match(Set mem (StoreC mem zero));
 6929   predicate(!needs_releasing_store(n));
 6930 
 6931   ins_cost(INSN_COST);
 6932   format %{ &quot;strh  zr, $mem\t# short&quot; %}
 6933 
 6934   ins_encode(aarch64_enc_strh0(mem));
 6935 
 6936   ins_pipe(istore_mem);
 6937 %}
 6938 
 6939 // Store Integer
 6940 
<span class="line-modified"> 6941 instruct storeI(iRegIorL2I src, memory mem)</span>
 6942 %{
 6943   match(Set mem(StoreI mem src));
 6944   predicate(!needs_releasing_store(n));
 6945 
 6946   ins_cost(INSN_COST);
 6947   format %{ &quot;strw  $src, $mem\t# int&quot; %}
 6948 
 6949   ins_encode(aarch64_enc_strw(src, mem));
 6950 
 6951   ins_pipe(istore_reg_mem);
 6952 %}
 6953 
<span class="line-modified"> 6954 instruct storeimmI0(immI0 zero, memory mem)</span>
 6955 %{
 6956   match(Set mem(StoreI mem zero));
 6957   predicate(!needs_releasing_store(n));
 6958 
 6959   ins_cost(INSN_COST);
 6960   format %{ &quot;strw  zr, $mem\t# int&quot; %}
 6961 
 6962   ins_encode(aarch64_enc_strw0(mem));
 6963 
 6964   ins_pipe(istore_mem);
 6965 %}
 6966 
 6967 // Store Long (64 bit signed)
<span class="line-modified"> 6968 instruct storeL(iRegL src, memory mem)</span>
 6969 %{
 6970   match(Set mem (StoreL mem src));
 6971   predicate(!needs_releasing_store(n));
 6972 
 6973   ins_cost(INSN_COST);
 6974   format %{ &quot;str  $src, $mem\t# int&quot; %}
 6975 
 6976   ins_encode(aarch64_enc_str(src, mem));
 6977 
 6978   ins_pipe(istore_reg_mem);
 6979 %}
 6980 
 6981 // Store Long (64 bit signed)
<span class="line-modified"> 6982 instruct storeimmL0(immL0 zero, memory mem)</span>
 6983 %{
 6984   match(Set mem (StoreL mem zero));
 6985   predicate(!needs_releasing_store(n));
 6986 
 6987   ins_cost(INSN_COST);
 6988   format %{ &quot;str  zr, $mem\t# int&quot; %}
 6989 
 6990   ins_encode(aarch64_enc_str0(mem));
 6991 
 6992   ins_pipe(istore_mem);
 6993 %}
 6994 
 6995 // Store Pointer
<span class="line-modified"> 6996 instruct storeP(iRegP src, memory mem)</span>
 6997 %{
 6998   match(Set mem (StoreP mem src));
 6999   predicate(!needs_releasing_store(n));
 7000 
 7001   ins_cost(INSN_COST);
 7002   format %{ &quot;str  $src, $mem\t# ptr&quot; %}
 7003 
 7004   ins_encode(aarch64_enc_str(src, mem));
 7005 
 7006   ins_pipe(istore_reg_mem);
 7007 %}
 7008 
 7009 // Store Pointer
<span class="line-modified"> 7010 instruct storeimmP0(immP0 zero, memory mem)</span>
 7011 %{
 7012   match(Set mem (StoreP mem zero));
 7013   predicate(!needs_releasing_store(n));
 7014 
 7015   ins_cost(INSN_COST);
 7016   format %{ &quot;str zr, $mem\t# ptr&quot; %}
 7017 
 7018   ins_encode(aarch64_enc_str0(mem));
 7019 
 7020   ins_pipe(istore_mem);
 7021 %}
 7022 
 7023 // Store Compressed Pointer
<span class="line-modified"> 7024 instruct storeN(iRegN src, memory mem)</span>
 7025 %{
 7026   match(Set mem (StoreN mem src));
 7027   predicate(!needs_releasing_store(n));
 7028 
 7029   ins_cost(INSN_COST);
 7030   format %{ &quot;strw  $src, $mem\t# compressed ptr&quot; %}
 7031 
 7032   ins_encode(aarch64_enc_strw(src, mem));
 7033 
 7034   ins_pipe(istore_reg_mem);
 7035 %}
 7036 
<span class="line-modified"> 7037 instruct storeImmN0(iRegIHeapbase heapbase, immN0 zero, memory mem)</span>
 7038 %{
 7039   match(Set mem (StoreN mem zero));
<span class="line-modified"> 7040   predicate(Universe::narrow_oop_base() == NULL &amp;&amp;</span>
<span class="line-modified"> 7041             Universe::narrow_klass_base() == NULL &amp;&amp;</span>
 7042             (!needs_releasing_store(n)));
 7043 
 7044   ins_cost(INSN_COST);
 7045   format %{ &quot;strw  rheapbase, $mem\t# compressed ptr (rheapbase==0)&quot; %}
 7046 
 7047   ins_encode(aarch64_enc_strw(heapbase, mem));
 7048 
 7049   ins_pipe(istore_reg_mem);
 7050 %}
 7051 
 7052 // Store Float
<span class="line-modified"> 7053 instruct storeF(vRegF src, memory mem)</span>
 7054 %{
 7055   match(Set mem (StoreF mem src));
 7056   predicate(!needs_releasing_store(n));
 7057 
 7058   ins_cost(INSN_COST);
 7059   format %{ &quot;strs  $src, $mem\t# float&quot; %}
 7060 
 7061   ins_encode( aarch64_enc_strs(src, mem) );
 7062 
 7063   ins_pipe(pipe_class_memory);
 7064 %}
 7065 
 7066 // TODO
 7067 // implement storeImmF0 and storeFImmPacked
 7068 
 7069 // Store Double
<span class="line-modified"> 7070 instruct storeD(vRegD src, memory mem)</span>
 7071 %{
 7072   match(Set mem (StoreD mem src));
 7073   predicate(!needs_releasing_store(n));
 7074 
 7075   ins_cost(INSN_COST);
 7076   format %{ &quot;strd  $src, $mem\t# double&quot; %}
 7077 
 7078   ins_encode( aarch64_enc_strd(src, mem) );
 7079 
 7080   ins_pipe(pipe_class_memory);
 7081 %}
 7082 
 7083 // Store Compressed Klass Pointer
<span class="line-modified"> 7084 instruct storeNKlass(iRegN src, memory mem)</span>
 7085 %{
 7086   predicate(!needs_releasing_store(n));
 7087   match(Set mem (StoreNKlass mem src));
 7088 
 7089   ins_cost(INSN_COST);
 7090   format %{ &quot;strw  $src, $mem\t# compressed klass ptr&quot; %}
 7091 
 7092   ins_encode(aarch64_enc_strw(src, mem));
 7093 
 7094   ins_pipe(istore_reg_mem);
 7095 %}
 7096 
 7097 // TODO
 7098 // implement storeImmD0 and storeDImmPacked
 7099 
 7100 // prefetch instructions
 7101 // Must be safe to execute with invalid address (cannot fault).
 7102 
<span class="line-modified"> 7103 instruct prefetchalloc( memory mem ) %{</span>
 7104   match(PrefetchAllocation mem);
 7105 
 7106   ins_cost(INSN_COST);
 7107   format %{ &quot;prfm $mem, PSTL1KEEP\t# Prefetch into level 1 cache write keep&quot; %}
 7108 
 7109   ins_encode( aarch64_enc_prefetchw(mem) );
 7110 
 7111   ins_pipe(iload_prefetch);
 7112 %}
 7113 
 7114 //  ---------------- volatile loads and stores ----------------
 7115 
 7116 // Load Byte (8 bit signed)
 7117 instruct loadB_volatile(iRegINoSp dst, /* sync_memory*/indirect mem)
 7118 %{
 7119   match(Set dst (LoadB mem));
 7120 
 7121   ins_cost(VOLATILE_REF_COST);
 7122   format %{ &quot;ldarsb  $dst, $mem\t# byte&quot; %}
 7123 
</pre>
<hr />
<pre>
 7242   ins_pipe(pipe_serial);
 7243 %}
 7244 
 7245 // Load Long (64 bit signed)
 7246 instruct loadL_volatile(iRegLNoSp dst, /* sync_memory*/indirect mem)
 7247 %{
 7248   match(Set dst (LoadL mem));
 7249 
 7250   ins_cost(VOLATILE_REF_COST);
 7251   format %{ &quot;ldar  $dst, $mem\t# int&quot; %}
 7252 
 7253   ins_encode(aarch64_enc_ldar(dst, mem));
 7254 
 7255   ins_pipe(pipe_serial);
 7256 %}
 7257 
 7258 // Load Pointer
 7259 instruct loadP_volatile(iRegPNoSp dst, /* sync_memory*/indirect mem)
 7260 %{
 7261   match(Set dst (LoadP mem));

 7262 
 7263   ins_cost(VOLATILE_REF_COST);
 7264   format %{ &quot;ldar  $dst, $mem\t# ptr&quot; %}
 7265 
 7266   ins_encode(aarch64_enc_ldar(dst, mem));
 7267 
 7268   ins_pipe(pipe_serial);
 7269 %}
 7270 
 7271 // Load Compressed Pointer
 7272 instruct loadN_volatile(iRegNNoSp dst, /* sync_memory*/indirect mem)
 7273 %{
 7274   match(Set dst (LoadN mem));
 7275 
 7276   ins_cost(VOLATILE_REF_COST);
 7277   format %{ &quot;ldarw  $dst, $mem\t# compressed ptr&quot; %}
 7278 
 7279   ins_encode(aarch64_enc_ldarw(dst, mem));
 7280 
 7281   ins_pipe(pipe_serial);
</pre>
<hr />
<pre>
 7400 %}
 7401 
 7402 // TODO
 7403 // implement storeImmF0 and storeFImmPacked
 7404 
 7405 // Store Double
 7406 instruct storeD_volatile(vRegD src, /* sync_memory*/indirect mem)
 7407 %{
 7408   match(Set mem (StoreD mem src));
 7409 
 7410   ins_cost(VOLATILE_REF_COST);
 7411   format %{ &quot;stlrd  $src, $mem\t# double&quot; %}
 7412 
 7413   ins_encode( aarch64_enc_fstlrd(src, mem) );
 7414 
 7415   ins_pipe(pipe_class_memory);
 7416 %}
 7417 
 7418 //  ---------------- end of volatile loads and stores ----------------
 7419 









































 7420 // ============================================================================
 7421 // BSWAP Instructions
 7422 
 7423 instruct bytes_reverse_int(iRegINoSp dst, iRegIorL2I src) %{
 7424   match(Set dst (ReverseBytesI src));
 7425 
 7426   ins_cost(INSN_COST);
 7427   format %{ &quot;revw  $dst, $src&quot; %}
 7428 
 7429   ins_encode %{
 7430     __ revw(as_Register($dst$$reg), as_Register($src$$reg));
 7431   %}
 7432 
 7433   ins_pipe(ialu_reg);
 7434 %}
 7435 
 7436 instruct bytes_reverse_long(iRegLNoSp dst, iRegL src) %{
 7437   match(Set dst (ReverseBytesL src));
 7438 
 7439   ins_cost(INSN_COST);
</pre>
<hr />
<pre>
 7537   match(Set dst (PopCountI src));
 7538   effect(TEMP tmp);
 7539   ins_cost(INSN_COST * 13);
 7540 
 7541   format %{ &quot;movw   $src, $src\n\t&quot;
 7542             &quot;mov    $tmp, $src\t# vector (1D)\n\t&quot;
 7543             &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
 7544             &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
 7545             &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
 7546   ins_encode %{
 7547     __ movw($src$$Register, $src$$Register); // ensure top 32 bits 0
 7548     __ mov($tmp$$FloatRegister, __ T1D, 0, $src$$Register);
 7549     __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 7550     __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 7551     __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
 7552   %}
 7553 
 7554   ins_pipe(pipe_class_default);
 7555 %}
 7556 
<span class="line-modified"> 7557 instruct popCountI_mem(iRegINoSp dst, memory mem, vRegF tmp) %{</span>
 7558   predicate(UsePopCountInstruction);
 7559   match(Set dst (PopCountI (LoadI mem)));
 7560   effect(TEMP tmp);
 7561   ins_cost(INSN_COST * 13);
 7562 
 7563   format %{ &quot;ldrs   $tmp, $mem\n\t&quot;
 7564             &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
 7565             &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
 7566             &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
 7567   ins_encode %{
 7568     FloatRegister tmp_reg = as_FloatRegister($tmp$$reg);
 7569     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, tmp_reg, $mem-&gt;opcode(),
<span class="line-modified"> 7570                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 7571     __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 7572     __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 7573     __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
 7574   %}
 7575 
 7576   ins_pipe(pipe_class_default);
 7577 %}
 7578 
 7579 // Note: Long.bitCount(long) returns an int.
 7580 instruct popCountL(iRegINoSp dst, iRegL src, vRegD tmp) %{
 7581   predicate(UsePopCountInstruction);
 7582   match(Set dst (PopCountL src));
 7583   effect(TEMP tmp);
 7584   ins_cost(INSN_COST * 13);
 7585 
 7586   format %{ &quot;mov    $tmp, $src\t# vector (1D)\n\t&quot;
 7587             &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
 7588             &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
 7589             &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
 7590   ins_encode %{
 7591     __ mov($tmp$$FloatRegister, __ T1D, 0, $src$$Register);
 7592     __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 7593     __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 7594     __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
 7595   %}
 7596 
 7597   ins_pipe(pipe_class_default);
 7598 %}
 7599 
<span class="line-modified"> 7600 instruct popCountL_mem(iRegINoSp dst, memory mem, vRegD tmp) %{</span>
 7601   predicate(UsePopCountInstruction);
 7602   match(Set dst (PopCountL (LoadL mem)));
 7603   effect(TEMP tmp);
 7604   ins_cost(INSN_COST * 13);
 7605 
 7606   format %{ &quot;ldrd   $tmp, $mem\n\t&quot;
 7607             &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
 7608             &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
 7609             &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
 7610   ins_encode %{
 7611     FloatRegister tmp_reg = as_FloatRegister($tmp$$reg);
 7612     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, tmp_reg, $mem-&gt;opcode(),
<span class="line-modified"> 7613                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 7614     __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 7615     __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 7616     __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
 7617   %}
 7618 
 7619   ins_pipe(pipe_class_default);
 7620 %}
 7621 
 7622 // ============================================================================
 7623 // MemBar Instruction
 7624 
 7625 instruct load_fence() %{
 7626   match(LoadFence);
 7627   ins_cost(VOLATILE_REF_COST);
 7628 
 7629   format %{ &quot;load_fence&quot; %}
 7630 
 7631   ins_encode %{
 7632     __ membar(Assembler::LoadLoad|Assembler::LoadStore);
 7633   %}
</pre>
<hr />
<pre>
 7803   ins_pipe(ialu_reg);
 7804 %}
 7805 
 7806 // Convert oop into int for vectors alignment masking
 7807 instruct convP2I(iRegINoSp dst, iRegP src) %{
 7808   match(Set dst (ConvL2I (CastP2X src)));
 7809 
 7810   ins_cost(INSN_COST);
 7811   format %{ &quot;movw $dst, $src\t# ptr -&gt; int&quot; %}
 7812   ins_encode %{
 7813     __ movw($dst$$Register, $src$$Register);
 7814   %}
 7815 
 7816   ins_pipe(ialu_reg);
 7817 %}
 7818 
 7819 // Convert compressed oop into int for vectors alignment masking
 7820 // in case of 32bit oops (heap &lt; 4Gb).
 7821 instruct convN2I(iRegINoSp dst, iRegN src)
 7822 %{
<span class="line-modified"> 7823   predicate(Universe::narrow_oop_shift() == 0);</span>
 7824   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 7825 
 7826   ins_cost(INSN_COST);
 7827   format %{ &quot;mov dst, $src\t# compressed ptr -&gt; int&quot; %}
 7828   ins_encode %{
 7829     __ movw($dst$$Register, $src$$Register);
 7830   %}
 7831 
 7832   ins_pipe(ialu_reg);
 7833 %}
 7834 
 7835 
 7836 // Convert oop pointer into compressed form
 7837 instruct encodeHeapOop(iRegNNoSp dst, iRegP src, rFlagsReg cr) %{
 7838   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 7839   match(Set dst (EncodeP src));
 7840   effect(KILL cr);
 7841   ins_cost(INSN_COST * 3);
 7842   format %{ &quot;encode_heap_oop $dst, $src&quot; %}
 7843   ins_encode %{
</pre>
<hr />
<pre>
 7939 %{
 7940   match(Set dst (CastPP dst));
 7941 
 7942   size(0);
 7943   format %{ &quot;# castPP of $dst&quot; %}
 7944   ins_encode(/* empty encoding */);
 7945   ins_pipe(pipe_class_empty);
 7946 %}
 7947 
 7948 instruct castII(iRegI dst)
 7949 %{
 7950   match(Set dst (CastII dst));
 7951 
 7952   size(0);
 7953   format %{ &quot;# castII of $dst&quot; %}
 7954   ins_encode(/* empty encoding */);
 7955   ins_cost(0);
 7956   ins_pipe(pipe_class_empty);
 7957 %}
 7958 











 7959 // ============================================================================
 7960 // Atomic operation instructions
 7961 //
 7962 // Intel and SPARC both implement Ideal Node LoadPLocked and
 7963 // Store{PIL}Conditional instructions using a normal load for the
 7964 // LoadPLocked and a CAS for the Store{PIL}Conditional.
 7965 //
 7966 // The ideal code appears only to use LoadPLocked/StorePLocked as a
 7967 // pair to lock object allocations from Eden space when not using
 7968 // TLABs.
 7969 //
 7970 // There does not appear to be a Load{IL}Locked Ideal Node and the
 7971 // Ideal code appears to use Store{IL}Conditional as an alias for CAS
 7972 // and to use StoreIConditional only for 32-bit and StoreLConditional
 7973 // only for 64-bit.
 7974 //
 7975 // We implement LoadPLocked and StorePLocked instructions using,
 7976 // respectively the AArch64 hw load-exclusive and store-conditional
 7977 // instructions. Whereas we must implement each of
 7978 // Store{IL}Conditional using a CAS which employs a pair of
</pre>
<hr />
<pre>
 7985 // implemented using ldaxr on AArch64
 7986 
 7987 instruct loadPLocked(iRegPNoSp dst, indirect mem)
 7988 %{
 7989   match(Set dst (LoadPLocked mem));
 7990 
 7991   ins_cost(VOLATILE_REF_COST);
 7992 
 7993   format %{ &quot;ldaxr $dst, $mem\t# ptr linked acquire&quot; %}
 7994 
 7995   ins_encode(aarch64_enc_ldaxr(dst, mem));
 7996 
 7997   ins_pipe(pipe_serial);
 7998 %}
 7999 
 8000 // Conditional-store of the updated heap-top.
 8001 // Used during allocation of the shared heap.
 8002 // Sets flag (EQ) on success.
 8003 // implemented using stlxr on AArch64.
 8004 
<span class="line-modified"> 8005 instruct storePConditional(memory heap_top_ptr, iRegP oldval, iRegP newval, rFlagsReg cr)</span>
 8006 %{
 8007   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 8008 
 8009   ins_cost(VOLATILE_REF_COST);
 8010 
 8011  // TODO
 8012  // do we need to do a store-conditional release or can we just use a
 8013  // plain store-conditional?
 8014 
 8015   format %{
 8016     &quot;stlxr rscratch1, $newval, $heap_top_ptr\t# ptr cond release&quot;
 8017     &quot;cmpw rscratch1, zr\t# EQ on successful write&quot;
 8018   %}
 8019 
 8020   ins_encode(aarch64_enc_stlxr(newval, heap_top_ptr));
 8021 
 8022   ins_pipe(pipe_serial);
 8023 %}
 8024 
 8025 
</pre>
<hr />
<pre>
 8126 
 8127   match(Set res (CompareAndSwapL mem (Binary oldval newval)));
 8128   ins_cost(2 * VOLATILE_REF_COST);
 8129 
 8130   effect(KILL cr);
 8131 
 8132  format %{
 8133     &quot;cmpxchg $mem, $oldval, $newval\t# (long) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8134     &quot;cset $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 8135  %}
 8136 
 8137  ins_encode(aarch64_enc_cmpxchg(mem, oldval, newval),
 8138             aarch64_enc_cset_eq(res));
 8139 
 8140   ins_pipe(pipe_slow);
 8141 %}
 8142 
 8143 instruct compareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
 8144 
 8145   match(Set res (CompareAndSwapP mem (Binary oldval newval)));

 8146   ins_cost(2 * VOLATILE_REF_COST);
 8147 
 8148   effect(KILL cr);
 8149 
 8150  format %{
 8151     &quot;cmpxchg $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8152     &quot;cset $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 8153  %}
 8154 
 8155  ins_encode(aarch64_enc_cmpxchg(mem, oldval, newval),
 8156             aarch64_enc_cset_eq(res));
 8157 
 8158   ins_pipe(pipe_slow);
 8159 %}
 8160 
 8161 instruct compareAndSwapN(iRegINoSp res, indirect mem, iRegNNoSp oldval, iRegNNoSp newval, rFlagsReg cr) %{
 8162 
 8163   match(Set res (CompareAndSwapN mem (Binary oldval newval)));
 8164   ins_cost(2 * VOLATILE_REF_COST);
 8165 
</pre>
<hr />
<pre>
 8239 
 8240   predicate(needs_acquiring_load_exclusive(n));
 8241   match(Set res (CompareAndSwapL mem (Binary oldval newval)));
 8242   ins_cost(VOLATILE_REF_COST);
 8243 
 8244   effect(KILL cr);
 8245 
 8246  format %{
 8247     &quot;cmpxchg_acq $mem, $oldval, $newval\t# (long) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8248     &quot;cset $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 8249  %}
 8250 
 8251  ins_encode(aarch64_enc_cmpxchg_acq(mem, oldval, newval),
 8252             aarch64_enc_cset_eq(res));
 8253 
 8254   ins_pipe(pipe_slow);
 8255 %}
 8256 
 8257 instruct compareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
 8258 
<span class="line-modified"> 8259   predicate(needs_acquiring_load_exclusive(n));</span>
 8260   match(Set res (CompareAndSwapP mem (Binary oldval newval)));
 8261   ins_cost(VOLATILE_REF_COST);
 8262 
 8263   effect(KILL cr);
 8264 
 8265  format %{
 8266     &quot;cmpxchg_acq $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8267     &quot;cset $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 8268  %}
 8269 
 8270  ins_encode(aarch64_enc_cmpxchg_acq(mem, oldval, newval),
 8271             aarch64_enc_cset_eq(res));
 8272 
 8273   ins_pipe(pipe_slow);
 8274 %}
 8275 
 8276 instruct compareAndSwapNAcq(iRegINoSp res, indirect mem, iRegNNoSp oldval, iRegNNoSp newval, rFlagsReg cr) %{
 8277 
 8278   predicate(needs_acquiring_load_exclusive(n));
 8279   match(Set res (CompareAndSwapN mem (Binary oldval newval)));
</pre>
<hr />
<pre>
 8370   %}
 8371   ins_pipe(pipe_slow);
 8372 %}
 8373 
 8374 instruct compareAndExchangeN(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
 8375   match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
 8376   ins_cost(2 * VOLATILE_REF_COST);
 8377   effect(TEMP_DEF res, KILL cr);
 8378   format %{
 8379     &quot;cmpxchgw $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8380   %}
 8381   ins_encode %{
 8382     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 8383                Assembler::word, /*acquire*/ false, /*release*/ true,
 8384                /*weak*/ false, $res$$Register);
 8385   %}
 8386   ins_pipe(pipe_slow);
 8387 %}
 8388 
 8389 instruct compareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{

 8390   match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
 8391   ins_cost(2 * VOLATILE_REF_COST);
 8392   effect(TEMP_DEF res, KILL cr);
 8393   format %{
 8394     &quot;cmpxchg $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8395   %}
 8396   ins_encode %{
 8397     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 8398                Assembler::xword, /*acquire*/ false, /*release*/ true,
 8399                /*weak*/ false, $res$$Register);
 8400   %}
 8401   ins_pipe(pipe_slow);
 8402 %}
 8403 
 8404 instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
 8405   predicate(needs_acquiring_load_exclusive(n));
 8406   match(Set res (CompareAndExchangeB mem (Binary oldval newval)));
 8407   ins_cost(VOLATILE_REF_COST);
 8408   effect(TEMP_DEF res, KILL cr);
 8409   format %{
</pre>
<hr />
<pre>
 8469 %}
 8470 
 8471 
 8472 instruct compareAndExchangeNAcq(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
 8473   predicate(needs_acquiring_load_exclusive(n));
 8474   match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
 8475   ins_cost(VOLATILE_REF_COST);
 8476   effect(TEMP_DEF res, KILL cr);
 8477   format %{
 8478     &quot;cmpxchgw_acq $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8479   %}
 8480   ins_encode %{
 8481     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 8482                Assembler::word, /*acquire*/ true, /*release*/ true,
 8483                /*weak*/ false, $res$$Register);
 8484   %}
 8485   ins_pipe(pipe_slow);
 8486 %}
 8487 
 8488 instruct compareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
<span class="line-modified"> 8489   predicate(needs_acquiring_load_exclusive(n));</span>
 8490   match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
 8491   ins_cost(VOLATILE_REF_COST);
 8492   effect(TEMP_DEF res, KILL cr);
 8493   format %{
 8494     &quot;cmpxchg_acq $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8495   %}
 8496   ins_encode %{
 8497     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 8498                Assembler::xword, /*acquire*/ true, /*release*/ true,
 8499                /*weak*/ false, $res$$Register);
 8500   %}
 8501   ins_pipe(pipe_slow);
 8502 %}
 8503 
 8504 instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
 8505   match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));
 8506   ins_cost(2 * VOLATILE_REF_COST);
 8507   effect(KILL cr);
 8508   format %{
 8509     &quot;cmpxchgb $res = $mem, $oldval, $newval\t# (byte, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
</pre>
<hr />
<pre>
 8570 %}
 8571 
 8572 instruct weakCompareAndSwapN(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
 8573   match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
 8574   ins_cost(2 * VOLATILE_REF_COST);
 8575   effect(KILL cr);
 8576   format %{
 8577     &quot;cmpxchgw $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8578     &quot;csetw $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 8579   %}
 8580   ins_encode %{
 8581     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 8582                Assembler::word, /*acquire*/ false, /*release*/ true,
 8583                /*weak*/ true, noreg);
 8584     __ csetw($res$$Register, Assembler::EQ);
 8585   %}
 8586   ins_pipe(pipe_slow);
 8587 %}
 8588 
 8589 instruct weakCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{

 8590   match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
 8591   ins_cost(2 * VOLATILE_REF_COST);
 8592   effect(KILL cr);
 8593   format %{
 8594     &quot;cmpxchg $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8595     &quot;csetw $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 8596   %}
 8597   ins_encode %{
 8598     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 8599                Assembler::xword, /*acquire*/ false, /*release*/ true,
 8600                /*weak*/ true, noreg);
 8601     __ csetw($res$$Register, Assembler::EQ);
 8602   %}
 8603   ins_pipe(pipe_slow);
 8604 %}
 8605 
 8606 instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
 8607   predicate(needs_acquiring_load_exclusive(n));
 8608   match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));
 8609   ins_cost(VOLATILE_REF_COST);
</pre>
<hr />
<pre>
 8677 
 8678 instruct weakCompareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
 8679   predicate(needs_acquiring_load_exclusive(n));
 8680   match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
 8681   ins_cost(VOLATILE_REF_COST);
 8682   effect(KILL cr);
 8683   format %{
 8684     &quot;cmpxchgw_acq $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8685     &quot;csetw $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 8686   %}
 8687   ins_encode %{
 8688     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 8689                Assembler::word, /*acquire*/ true, /*release*/ true,
 8690                /*weak*/ true, noreg);
 8691     __ csetw($res$$Register, Assembler::EQ);
 8692   %}
 8693   ins_pipe(pipe_slow);
 8694 %}
 8695 
 8696 instruct weakCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
<span class="line-removed"> 8697   predicate(needs_acquiring_load_exclusive(n));</span>
 8698   match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));

 8699   ins_cost(VOLATILE_REF_COST);
 8700   effect(KILL cr);
 8701   format %{
 8702     &quot;cmpxchg_acq $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8703     &quot;csetw $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 8704   %}
 8705   ins_encode %{
 8706     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 8707                Assembler::xword, /*acquire*/ true, /*release*/ true,
 8708                /*weak*/ true, noreg);
 8709     __ csetw($res$$Register, Assembler::EQ);
 8710   %}
 8711   ins_pipe(pipe_slow);
 8712 %}
 8713 
 8714 // END This section of the file is automatically generated. Do not edit --------------
 8715 // ---------------------------------------------------------------------
 8716 
 8717 instruct get_and_setI(indirect mem, iRegI newv, iRegINoSp prev) %{
 8718   match(Set prev (GetAndSetI mem newv));
</pre>
<hr />
<pre>
 8728   match(Set prev (GetAndSetL mem newv));
 8729   ins_cost(2 * VOLATILE_REF_COST);
 8730   format %{ &quot;atomic_xchg  $prev, $newv, [$mem]&quot; %}
 8731   ins_encode %{
 8732     __ atomic_xchg($prev$$Register, $newv$$Register, as_Register($mem$$base));
 8733   %}
 8734   ins_pipe(pipe_serial);
 8735 %}
 8736 
 8737 instruct get_and_setN(indirect mem, iRegN newv, iRegINoSp prev) %{
 8738   match(Set prev (GetAndSetN mem newv));
 8739   ins_cost(2 * VOLATILE_REF_COST);
 8740   format %{ &quot;atomic_xchgw $prev, $newv, [$mem]&quot; %}
 8741   ins_encode %{
 8742     __ atomic_xchgw($prev$$Register, $newv$$Register, as_Register($mem$$base));
 8743   %}
 8744   ins_pipe(pipe_serial);
 8745 %}
 8746 
 8747 instruct get_and_setP(indirect mem, iRegP newv, iRegPNoSp prev) %{

 8748   match(Set prev (GetAndSetP mem newv));
 8749   ins_cost(2 * VOLATILE_REF_COST);
 8750   format %{ &quot;atomic_xchg  $prev, $newv, [$mem]&quot; %}
 8751   ins_encode %{
 8752     __ atomic_xchg($prev$$Register, $newv$$Register, as_Register($mem$$base));
 8753   %}
 8754   ins_pipe(pipe_serial);
 8755 %}
 8756 
 8757 instruct get_and_setIAcq(indirect mem, iRegI newv, iRegINoSp prev) %{
 8758   predicate(needs_acquiring_load_exclusive(n));
 8759   match(Set prev (GetAndSetI mem newv));
 8760   ins_cost(VOLATILE_REF_COST);
 8761   format %{ &quot;atomic_xchgw_acq  $prev, $newv, [$mem]&quot; %}
 8762   ins_encode %{
 8763     __ atomic_xchgalw($prev$$Register, $newv$$Register, as_Register($mem$$base));
 8764   %}
 8765   ins_pipe(pipe_serial);
 8766 %}
 8767 
</pre>
<hr />
<pre>
 8771   ins_cost(VOLATILE_REF_COST);
 8772   format %{ &quot;atomic_xchg_acq  $prev, $newv, [$mem]&quot; %}
 8773   ins_encode %{
 8774     __ atomic_xchgal($prev$$Register, $newv$$Register, as_Register($mem$$base));
 8775   %}
 8776   ins_pipe(pipe_serial);
 8777 %}
 8778 
 8779 instruct get_and_setNAcq(indirect mem, iRegN newv, iRegINoSp prev) %{
 8780   predicate(needs_acquiring_load_exclusive(n));
 8781   match(Set prev (GetAndSetN mem newv));
 8782   ins_cost(VOLATILE_REF_COST);
 8783   format %{ &quot;atomic_xchgw_acq $prev, $newv, [$mem]&quot; %}
 8784   ins_encode %{
 8785     __ atomic_xchgalw($prev$$Register, $newv$$Register, as_Register($mem$$base));
 8786   %}
 8787   ins_pipe(pipe_serial);
 8788 %}
 8789 
 8790 instruct get_and_setPAcq(indirect mem, iRegP newv, iRegPNoSp prev) %{
<span class="line-modified"> 8791   predicate(needs_acquiring_load_exclusive(n));</span>
 8792   match(Set prev (GetAndSetP mem newv));
 8793   ins_cost(VOLATILE_REF_COST);
 8794   format %{ &quot;atomic_xchg_acq  $prev, $newv, [$mem]&quot; %}
 8795   ins_encode %{
 8796     __ atomic_xchgal($prev$$Register, $newv$$Register, as_Register($mem$$base));
 8797   %}
 8798   ins_pipe(pipe_serial);
 8799 %}
 8800 
 8801 
 8802 instruct get_and_addL(indirect mem, iRegLNoSp newval, iRegL incr) %{
 8803   match(Set newval (GetAndAddL mem incr));
 8804   ins_cost(2 * VOLATILE_REF_COST + 1);
 8805   format %{ &quot;get_and_addL $newval, [$mem], $incr&quot; %}
 8806   ins_encode %{
 8807     __ atomic_add($newval$$Register, $incr$$Register, as_Register($mem$$base));
 8808   %}
 8809   ins_pipe(pipe_serial);
 8810 %}
 8811 
</pre>
<hr />
<pre>
 9973 %}
 9974 
 9975 // Combined Long Multiply &amp; Neg
 9976 
 9977 instruct mnegL(iRegLNoSp dst, iRegL src1, iRegL src2, immL0 zero) %{
 9978   match(Set dst (MulL (SubL zero src1) src2));
 9979   match(Set dst (MulL src1 (SubL zero src2)));
 9980 
 9981   ins_cost(INSN_COST * 5);
 9982   format %{ &quot;mneg  $dst, $src1, $src2&quot; %}
 9983 
 9984   ins_encode %{
 9985     __ mneg(as_Register($dst$$reg),
 9986             as_Register($src1$$reg),
 9987             as_Register($src2$$reg));
 9988   %}
 9989 
 9990   ins_pipe(lmac_reg_reg);
 9991 %}
 9992 


















































 9993 // Integer Divide
 9994 
 9995 instruct divI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{
 9996   match(Set dst (DivI src1 src2));
 9997 
 9998   ins_cost(INSN_COST * 19);
 9999   format %{ &quot;sdivw  $dst, $src1, $src2&quot; %}
10000 
10001   ins_encode(aarch64_enc_divw(dst, src1, src2));
10002   ins_pipe(idiv_reg_reg);
10003 %}
10004 
10005 instruct signExtract(iRegINoSp dst, iRegIorL2I src1, immI_31 div1, immI_31 div2) %{
10006   match(Set dst (URShiftI (RShiftI src1 div1) div2));
10007   ins_cost(INSN_COST);
10008   format %{ &quot;lsrw $dst, $src1, $div1&quot; %}
10009   ins_encode %{
10010     __ lsrw(as_Register($dst$$reg), as_Register($src1$$reg), 31);
10011   %}
10012   ins_pipe(ialu_reg_shift);
</pre>
<hr />
<pre>
11324   format %{ &quot;sub  $dst, $src1, $src2, LSL $src3&quot; %}
11325 
11326   ins_encode %{
11327     __ sub(as_Register($dst$$reg),
11328               as_Register($src1$$reg),
11329               as_Register($src2$$reg),
11330               Assembler::LSL,
11331               $src3$$constant &amp; 0x3f);
11332   %}
11333 
11334   ins_pipe(ialu_reg_reg_shift);
11335 %}
11336 
11337 
11338 
11339 // Shift Left followed by Shift Right.
11340 // This idiom is used by the compiler for the i2b bytecode etc.
11341 instruct sbfmL(iRegLNoSp dst, iRegL src, immI lshift_count, immI rshift_count)
11342 %{
11343   match(Set dst (RShiftL (LShiftL src lshift_count) rshift_count));
<span class="line-removed">11344   // Make sure we are not going to exceed what sbfm can do.</span>
<span class="line-removed">11345   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 63</span>
<span class="line-removed">11346             &amp;&amp; (unsigned int)n-&gt;in(1)-&gt;in(2)-&gt;get_int() &lt;= 63);</span>
<span class="line-removed">11347 </span>
11348   ins_cost(INSN_COST * 2);
11349   format %{ &quot;sbfm  $dst, $src, $rshift_count - $lshift_count, #63 - $lshift_count&quot; %}
11350   ins_encode %{
<span class="line-modified">11351     int lshift = $lshift_count$$constant, rshift = $rshift_count$$constant;</span>

11352     int s = 63 - lshift;
11353     int r = (rshift - lshift) &amp; 63;
11354     __ sbfm(as_Register($dst$$reg),
11355             as_Register($src$$reg),
11356             r, s);
11357   %}
11358 
11359   ins_pipe(ialu_reg_shift);
11360 %}
11361 
11362 // Shift Left followed by Shift Right.
11363 // This idiom is used by the compiler for the i2b bytecode etc.
11364 instruct sbfmwI(iRegINoSp dst, iRegIorL2I src, immI lshift_count, immI rshift_count)
11365 %{
11366   match(Set dst (RShiftI (LShiftI src lshift_count) rshift_count));
<span class="line-removed">11367   // Make sure we are not going to exceed what sbfmw can do.</span>
<span class="line-removed">11368   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 31</span>
<span class="line-removed">11369             &amp;&amp; (unsigned int)n-&gt;in(1)-&gt;in(2)-&gt;get_int() &lt;= 31);</span>
<span class="line-removed">11370 </span>
11371   ins_cost(INSN_COST * 2);
11372   format %{ &quot;sbfmw  $dst, $src, $rshift_count - $lshift_count, #31 - $lshift_count&quot; %}
11373   ins_encode %{
<span class="line-modified">11374     int lshift = $lshift_count$$constant, rshift = $rshift_count$$constant;</span>

11375     int s = 31 - lshift;
11376     int r = (rshift - lshift) &amp; 31;
11377     __ sbfmw(as_Register($dst$$reg),
11378             as_Register($src$$reg),
11379             r, s);
11380   %}
11381 
11382   ins_pipe(ialu_reg_shift);
11383 %}
11384 
11385 // Shift Left followed by Shift Right.
11386 // This idiom is used by the compiler for the i2b bytecode etc.
11387 instruct ubfmL(iRegLNoSp dst, iRegL src, immI lshift_count, immI rshift_count)
11388 %{
11389   match(Set dst (URShiftL (LShiftL src lshift_count) rshift_count));
<span class="line-removed">11390   // Make sure we are not going to exceed what ubfm can do.</span>
<span class="line-removed">11391   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 63</span>
<span class="line-removed">11392             &amp;&amp; (unsigned int)n-&gt;in(1)-&gt;in(2)-&gt;get_int() &lt;= 63);</span>
<span class="line-removed">11393 </span>
11394   ins_cost(INSN_COST * 2);
11395   format %{ &quot;ubfm  $dst, $src, $rshift_count - $lshift_count, #63 - $lshift_count&quot; %}
11396   ins_encode %{
<span class="line-modified">11397     int lshift = $lshift_count$$constant, rshift = $rshift_count$$constant;</span>

11398     int s = 63 - lshift;
11399     int r = (rshift - lshift) &amp; 63;
11400     __ ubfm(as_Register($dst$$reg),
11401             as_Register($src$$reg),
11402             r, s);
11403   %}
11404 
11405   ins_pipe(ialu_reg_shift);
11406 %}
11407 
11408 // Shift Left followed by Shift Right.
11409 // This idiom is used by the compiler for the i2b bytecode etc.
11410 instruct ubfmwI(iRegINoSp dst, iRegIorL2I src, immI lshift_count, immI rshift_count)
11411 %{
11412   match(Set dst (URShiftI (LShiftI src lshift_count) rshift_count));
<span class="line-removed">11413   // Make sure we are not going to exceed what ubfmw can do.</span>
<span class="line-removed">11414   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 31</span>
<span class="line-removed">11415             &amp;&amp; (unsigned int)n-&gt;in(1)-&gt;in(2)-&gt;get_int() &lt;= 31);</span>
<span class="line-removed">11416 </span>
11417   ins_cost(INSN_COST * 2);
11418   format %{ &quot;ubfmw  $dst, $src, $rshift_count - $lshift_count, #31 - $lshift_count&quot; %}
11419   ins_encode %{
<span class="line-modified">11420     int lshift = $lshift_count$$constant, rshift = $rshift_count$$constant;</span>

11421     int s = 31 - lshift;
11422     int r = (rshift - lshift) &amp; 31;
11423     __ ubfmw(as_Register($dst$$reg),
11424             as_Register($src$$reg),
11425             r, s);
11426   %}
11427 
11428   ins_pipe(ialu_reg_shift);
11429 %}
11430 // Bitfield extract with shift &amp; mask
11431 
11432 instruct ubfxwI(iRegINoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
11433 %{
11434   match(Set dst (AndI (URShiftI src rshift) mask));


11435 
11436   ins_cost(INSN_COST);
11437   format %{ &quot;ubfxw $dst, $src, $rshift, $mask&quot; %}
11438   ins_encode %{
<span class="line-modified">11439     int rshift = $rshift$$constant;</span>
11440     long mask = $mask$$constant;
11441     int width = exact_log2(mask+1);
11442     __ ubfxw(as_Register($dst$$reg),
11443             as_Register($src$$reg), rshift, width);
11444   %}
11445   ins_pipe(ialu_reg_shift);
11446 %}
11447 instruct ubfxL(iRegLNoSp dst, iRegL src, immI rshift, immL_bitmask mask)
11448 %{
11449   match(Set dst (AndL (URShiftL src rshift) mask));


11450 
11451   ins_cost(INSN_COST);
11452   format %{ &quot;ubfx $dst, $src, $rshift, $mask&quot; %}
11453   ins_encode %{
<span class="line-modified">11454     int rshift = $rshift$$constant;</span>
11455     long mask = $mask$$constant;
<span class="line-modified">11456     int width = exact_log2(mask+1);</span>
11457     __ ubfx(as_Register($dst$$reg),
11458             as_Register($src$$reg), rshift, width);
11459   %}
11460   ins_pipe(ialu_reg_shift);
11461 %}
11462 
11463 // We can use ubfx when extending an And with a mask when we know mask
11464 // is positive.  We know that because immI_bitmask guarantees it.
11465 instruct ubfxIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
11466 %{
11467   match(Set dst (ConvI2L (AndI (URShiftI src rshift) mask)));


11468 
11469   ins_cost(INSN_COST * 2);
11470   format %{ &quot;ubfx $dst, $src, $rshift, $mask&quot; %}
11471   ins_encode %{
<span class="line-modified">11472     int rshift = $rshift$$constant;</span>
11473     long mask = $mask$$constant;
11474     int width = exact_log2(mask+1);
11475     __ ubfx(as_Register($dst$$reg),
11476             as_Register($src$$reg), rshift, width);
11477   %}
11478   ins_pipe(ialu_reg_shift);
11479 %}
11480 
11481 // We can use ubfiz when masking by a positive number and then left shifting the result.
11482 // We know that the mask is positive because immI_bitmask guarantees it.
11483 instruct ubfizwI(iRegINoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
11484 %{
11485   match(Set dst (LShiftI (AndI src mask) lshift));
<span class="line-modified">11486   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 31 &amp;&amp;</span>
<span class="line-removed">11487     (exact_log2(n-&gt;in(1)-&gt;in(2)-&gt;get_int()+1) + (unsigned int)n-&gt;in(2)-&gt;get_int()) &lt;= (31+1));</span>
11488 
11489   ins_cost(INSN_COST);
11490   format %{ &quot;ubfizw $dst, $src, $lshift, $mask&quot; %}
11491   ins_encode %{
<span class="line-modified">11492     int lshift = $lshift$$constant;</span>
11493     long mask = $mask$$constant;
11494     int width = exact_log2(mask+1);
11495     __ ubfizw(as_Register($dst$$reg),
11496           as_Register($src$$reg), lshift, width);
11497   %}
11498   ins_pipe(ialu_reg_shift);
11499 %}
11500 // We can use ubfiz when masking by a positive number and then left shifting the result.
11501 // We know that the mask is positive because immL_bitmask guarantees it.
11502 instruct ubfizL(iRegLNoSp dst, iRegL src, immI lshift, immL_bitmask mask)
11503 %{
11504   match(Set dst (LShiftL (AndL src mask) lshift));
<span class="line-modified">11505   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 63 &amp;&amp;</span>
<span class="line-removed">11506     (exact_log2_long(n-&gt;in(1)-&gt;in(2)-&gt;get_long()+1) + (unsigned int)n-&gt;in(2)-&gt;get_int()) &lt;= (63+1));</span>
11507 
11508   ins_cost(INSN_COST);
11509   format %{ &quot;ubfiz $dst, $src, $lshift, $mask&quot; %}
11510   ins_encode %{
<span class="line-modified">11511     int lshift = $lshift$$constant;</span>
11512     long mask = $mask$$constant;
<span class="line-modified">11513     int width = exact_log2(mask+1);</span>
11514     __ ubfiz(as_Register($dst$$reg),
11515           as_Register($src$$reg), lshift, width);
11516   %}
11517   ins_pipe(ialu_reg_shift);
11518 %}
11519 
11520 // If there is a convert I to L block between and AndI and a LShiftL, we can also match ubfiz
11521 instruct ubfizIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
11522 %{
<span class="line-modified">11523   match(Set dst (LShiftL (ConvI2L(AndI src mask)) lshift));</span>
<span class="line-modified">11524   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 31 &amp;&amp;</span>
<span class="line-removed">11525     (exact_log2((unsigned int)n-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;get_int()+1) + (unsigned int)n-&gt;in(2)-&gt;get_int()) &lt;= 32);</span>
11526 
11527   ins_cost(INSN_COST);
11528   format %{ &quot;ubfiz $dst, $src, $lshift, $mask&quot; %}
11529   ins_encode %{
<span class="line-modified">11530     int lshift = $lshift$$constant;</span>
11531     long mask = $mask$$constant;
11532     int width = exact_log2(mask+1);
11533     __ ubfiz(as_Register($dst$$reg),
11534              as_Register($src$$reg), lshift, width);
11535   %}
11536   ins_pipe(ialu_reg_shift);
11537 %}
11538 
11539 // Rotations
11540 
11541 instruct extrOrL(iRegLNoSp dst, iRegL src1, iRegL src2, immI lshift, immI rshift, rFlagsReg cr)
11542 %{
11543   match(Set dst (OrL (LShiftL src1 lshift) (URShiftL src2 rshift)));
<span class="line-modified">11544   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 63));</span>
11545 
11546   ins_cost(INSN_COST);
11547   format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
11548 
11549   ins_encode %{
11550     __ extr(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg),
11551             $rshift$$constant &amp; 63);
11552   %}
11553   ins_pipe(ialu_reg_reg_extr);
11554 %}
11555 
11556 instruct extrOrI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI lshift, immI rshift, rFlagsReg cr)
11557 %{
11558   match(Set dst (OrI (LShiftI src1 lshift) (URShiftI src2 rshift)));
<span class="line-modified">11559   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 31));</span>
11560 
11561   ins_cost(INSN_COST);
11562   format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
11563 
11564   ins_encode %{
11565     __ extrw(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg),
11566             $rshift$$constant &amp; 31);
11567   %}
11568   ins_pipe(ialu_reg_reg_extr);
11569 %}
11570 
11571 instruct extrAddL(iRegLNoSp dst, iRegL src1, iRegL src2, immI lshift, immI rshift, rFlagsReg cr)
11572 %{
11573   match(Set dst (AddL (LShiftL src1 lshift) (URShiftL src2 rshift)));
<span class="line-modified">11574   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 63));</span>
11575 
11576   ins_cost(INSN_COST);
11577   format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
11578 
11579   ins_encode %{
11580     __ extr(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg),
11581             $rshift$$constant &amp; 63);
11582   %}
11583   ins_pipe(ialu_reg_reg_extr);
11584 %}
11585 
11586 instruct extrAddI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI lshift, immI rshift, rFlagsReg cr)
11587 %{
11588   match(Set dst (AddI (LShiftI src1 lshift) (URShiftI src2 rshift)));
<span class="line-modified">11589   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 31));</span>
11590 
11591   ins_cost(INSN_COST);
11592   format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
11593 
11594   ins_encode %{
11595     __ extrw(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg),
11596             $rshift$$constant &amp; 31);
11597   %}
11598   ins_pipe(ialu_reg_reg_extr);
11599 %}
11600 
11601 
11602 // rol expander
11603 
11604 instruct rolL_rReg(iRegLNoSp dst, iRegL src, iRegI shift, rFlagsReg cr)
11605 %{
11606   effect(DEF dst, USE src, USE shift);
11607 
11608   format %{ &quot;rol    $dst, $src, $shift&quot; %}
11609   ins_cost(INSN_COST * 3);
</pre>
<hr />
<pre>
12659     __ fsqrtd(as_FloatRegister($dst$$reg),
12660              as_FloatRegister($src$$reg));
12661   %}
12662 
12663   ins_pipe(fp_div_s);
12664 %}
12665 
12666 instruct sqrtF_reg(vRegF dst, vRegF src) %{
12667   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
12668 
12669   ins_cost(INSN_COST * 50);
12670   format %{ &quot;fsqrts  $dst, $src&quot; %}
12671   ins_encode %{
12672     __ fsqrts(as_FloatRegister($dst$$reg),
12673              as_FloatRegister($src$$reg));
12674   %}
12675 
12676   ins_pipe(fp_div_d);
12677 %}
12678 























12679 // ============================================================================
12680 // Logical Instructions
12681 
12682 // Integer Logical Instructions
12683 
12684 // And Instructions
12685 
12686 
12687 instruct andI_reg_reg(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, rFlagsReg cr) %{
12688   match(Set dst (AndI src1 src2));
12689 
12690   format %{ &quot;andw  $dst, $src1, $src2\t# int&quot; %}
12691 
12692   ins_cost(INSN_COST);
12693   ins_encode %{
12694     __ andw(as_Register($dst$$reg),
12695             as_Register($src1$$reg),
12696             as_Register($src2$$reg));
12697   %}
12698 
</pre>
<hr />
<pre>
13853   match(Set cr (CmpF src1 src2));
13854 
13855   ins_cost(3 * INSN_COST);
13856   format %{ &quot;fcmps $src1, $src2&quot; %}
13857 
13858   ins_encode %{
13859     __ fcmps(as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
13860   %}
13861 
13862   ins_pipe(pipe_class_compare);
13863 %}
13864 
13865 instruct compF_reg_zero(rFlagsReg cr, vRegF src1, immF0 src2)
13866 %{
13867   match(Set cr (CmpF src1 src2));
13868 
13869   ins_cost(3 * INSN_COST);
13870   format %{ &quot;fcmps $src1, 0.0&quot; %}
13871 
13872   ins_encode %{
<span class="line-modified">13873     __ fcmps(as_FloatRegister($src1$$reg), 0.0D);</span>
13874   %}
13875 
13876   ins_pipe(pipe_class_compare);
13877 %}
13878 // FROM HERE
13879 
13880 instruct compD_reg_reg(rFlagsReg cr, vRegD src1, vRegD src2)
13881 %{
13882   match(Set cr (CmpD src1 src2));
13883 
13884   ins_cost(3 * INSN_COST);
13885   format %{ &quot;fcmpd $src1, $src2&quot; %}
13886 
13887   ins_encode %{
13888     __ fcmpd(as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
13889   %}
13890 
13891   ins_pipe(pipe_class_compare);
13892 %}
13893 
13894 instruct compD_reg_zero(rFlagsReg cr, vRegD src1, immD0 src2)
13895 %{
13896   match(Set cr (CmpD src1 src2));
13897 
13898   ins_cost(3 * INSN_COST);
13899   format %{ &quot;fcmpd $src1, 0.0&quot; %}
13900 
13901   ins_encode %{
<span class="line-modified">13902     __ fcmpd(as_FloatRegister($src1$$reg), 0.0D);</span>
13903   %}
13904 
13905   ins_pipe(pipe_class_compare);
13906 %}
13907 
13908 instruct compF3_reg_reg(iRegINoSp dst, vRegF src1, vRegF src2, rFlagsReg cr)
13909 %{
13910   match(Set dst (CmpF3 src1 src2));
13911   effect(KILL cr);
13912 
13913   ins_cost(5 * INSN_COST);
13914   format %{ &quot;fcmps $src1, $src2\n\t&quot;
13915             &quot;csinvw($dst, zr, zr, eq\n\t&quot;
13916             &quot;csnegw($dst, $dst, $dst, lt)&quot;
13917   %}
13918 
13919   ins_encode %{
13920     Label done;
13921     FloatRegister s1 = as_FloatRegister($src1$$reg);
13922     FloatRegister s2 = as_FloatRegister($src2$$reg);
</pre>
<hr />
<pre>
13958   %}
13959   ins_pipe(pipe_class_default);
13960 
13961 %}
13962 
13963 instruct compF3_reg_immF0(iRegINoSp dst, vRegF src1, immF0 zero, rFlagsReg cr)
13964 %{
13965   match(Set dst (CmpF3 src1 zero));
13966   effect(KILL cr);
13967 
13968   ins_cost(5 * INSN_COST);
13969   format %{ &quot;fcmps $src1, 0.0\n\t&quot;
13970             &quot;csinvw($dst, zr, zr, eq\n\t&quot;
13971             &quot;csnegw($dst, $dst, $dst, lt)&quot;
13972   %}
13973 
13974   ins_encode %{
13975     Label done;
13976     FloatRegister s1 = as_FloatRegister($src1$$reg);
13977     Register d = as_Register($dst$$reg);
<span class="line-modified">13978     __ fcmps(s1, 0.0D);</span>
13979     // installs 0 if EQ else -1
13980     __ csinvw(d, zr, zr, Assembler::EQ);
13981     // keeps -1 if less or unordered else installs 1
13982     __ csnegw(d, d, d, Assembler::LT);
13983     __ bind(done);
13984   %}
13985 
13986   ins_pipe(pipe_class_default);
13987 
13988 %}
13989 
13990 instruct compD3_reg_immD0(iRegINoSp dst, vRegD src1, immD0 zero, rFlagsReg cr)
13991 %{
13992   match(Set dst (CmpD3 src1 zero));
13993   effect(KILL cr);
13994 
13995   ins_cost(5 * INSN_COST);
13996   format %{ &quot;fcmpd $src1, 0.0\n\t&quot;
13997             &quot;csinvw($dst, zr, zr, eq\n\t&quot;
13998             &quot;csnegw($dst, $dst, $dst, lt)&quot;
13999   %}
14000 
14001   ins_encode %{
14002     Label done;
14003     FloatRegister s1 = as_FloatRegister($src1$$reg);
14004     Register d = as_Register($dst$$reg);
<span class="line-modified">14005     __ fcmpd(s1, 0.0D);</span>
14006     // installs 0 if EQ else -1
14007     __ csinvw(d, zr, zr, Assembler::EQ);
14008     // keeps -1 if less or unordered else installs 1
14009     __ csnegw(d, d, d, Assembler::LT);
14010     __ bind(done);
14011   %}
14012   ins_pipe(pipe_class_default);
14013 
14014 %}
14015 
14016 instruct cmpLTMask_reg_reg(iRegINoSp dst, iRegIorL2I p, iRegIorL2I q, rFlagsReg cr)
14017 %{
14018   match(Set dst (CmpLTMask p q));
14019   effect(KILL cr);
14020 
14021   ins_cost(3 * INSN_COST);
14022 
14023   format %{ &quot;cmpw $p, $q\t# cmpLTMask\n\t&quot;
14024             &quot;csetw $dst, lt\n\t&quot;
14025             &quot;subw $dst, zr, $dst&quot;
</pre>
<hr />
<pre>
14036 
14037 instruct cmpLTMask_reg_zero(iRegINoSp dst, iRegIorL2I src, immI0 zero, rFlagsReg cr)
14038 %{
14039   match(Set dst (CmpLTMask src zero));
14040   effect(KILL cr);
14041 
14042   ins_cost(INSN_COST);
14043 
14044   format %{ &quot;asrw $dst, $src, #31\t# cmpLTMask0&quot; %}
14045 
14046   ins_encode %{
14047     __ asrw(as_Register($dst$$reg), as_Register($src$$reg), 31);
14048   %}
14049 
14050   ins_pipe(ialu_reg_shift);
14051 %}
14052 
14053 // ============================================================================
14054 // Max and Min
14055 
<span class="line-modified">14056 instruct minI_rReg(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)</span>
14057 %{
<span class="line-modified">14058   match(Set dst (MinI src1 src2));</span>
<span class="line-removed">14059 </span>
<span class="line-removed">14060   effect(DEF dst, USE src1, USE src2, KILL cr);</span>
<span class="line-removed">14061   size(8);</span>
14062 
<span class="line-modified">14063   ins_cost(INSN_COST * 3);</span>
<span class="line-modified">14064   format %{</span>
<span class="line-removed">14065     &quot;cmpw $src1 $src2\t signed int\n\t&quot;</span>
<span class="line-removed">14066     &quot;cselw $dst, $src1, $src2 lt\t&quot;</span>
<span class="line-removed">14067   %}</span>
14068 
14069   ins_encode %{
<span class="line-removed">14070     __ cmpw(as_Register($src1$$reg),</span>
<span class="line-removed">14071             as_Register($src2$$reg));</span>
14072     __ cselw(as_Register($dst$$reg),
14073              as_Register($src1$$reg),
14074              as_Register($src2$$reg),
14075              Assembler::LT);
14076   %}
14077 
<span class="line-modified">14078   ins_pipe(ialu_reg_reg);</span>
14079 %}
<span class="line-removed">14080 // FROM HERE</span>
14081 
<span class="line-modified">14082 instruct maxI_rReg(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)</span>
14083 %{
<span class="line-modified">14084   match(Set dst (MaxI src1 src2));</span>
<span class="line-removed">14085 </span>
<span class="line-removed">14086   effect(DEF dst, USE src1, USE src2, KILL cr);</span>
<span class="line-removed">14087   size(8);</span>
<span class="line-removed">14088 </span>
14089   ins_cost(INSN_COST * 3);
<span class="line-modified">14090   format %{</span>
<span class="line-modified">14091     &quot;cmpw $src1 $src2\t signed int\n\t&quot;</span>
<span class="line-modified">14092     &quot;cselw $dst, $src1, $src2 gt\t&quot;</span>


14093   %}
14094 










14095   ins_encode %{
<span class="line-removed">14096     __ cmpw(as_Register($src1$$reg),</span>
<span class="line-removed">14097             as_Register($src2$$reg));</span>
14098     __ cselw(as_Register($dst$$reg),
14099              as_Register($src1$$reg),
14100              as_Register($src2$$reg),
14101              Assembler::GT);
14102   %}
14103 
<span class="line-modified">14104   ins_pipe(ialu_reg_reg);</span>











14105 %}
14106 
14107 // ============================================================================
14108 // Branch Instructions
14109 
14110 // Direct Branch.
14111 instruct branch(label lbl)
14112 %{
14113   match(Goto);
14114 
14115   effect(USE lbl);
14116 
14117   ins_cost(BRANCH_COST);
14118   format %{ &quot;b  $lbl&quot; %}
14119 
14120   ins_encode(aarch64_enc_b(lbl));
14121 
14122   ins_pipe(pipe_branch);
14123 %}
14124 
</pre>
<hr />
<pre>
14533 instruct cmpFastUnlock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)
14534 %{
14535   match(Set cr (FastUnlock object box));
14536   effect(TEMP tmp, TEMP tmp2);
14537 
14538   ins_cost(5 * INSN_COST);
14539   format %{ &quot;fastunlock $object,$box\t! kills $tmp, $tmp2&quot; %}
14540 
14541   ins_encode(aarch64_enc_fast_unlock(object, box, tmp, tmp2));
14542 
14543   ins_pipe(pipe_serial);
14544 %}
14545 
14546 
14547 // ============================================================================
14548 // Safepoint Instructions
14549 
14550 // TODO
14551 // provide a near and far version of this code
14552 
<span class="line-modified">14553 instruct safePoint(iRegP poll)</span>
14554 %{
14555   match(SafePoint poll);

14556 
14557   format %{
14558     &quot;ldrw zr, [$poll]\t# Safepoint: poll for GC&quot;
14559   %}
14560   ins_encode %{
14561     __ read_polling_page(as_Register($poll$$reg), relocInfo::poll_type);
14562   %}
14563   ins_pipe(pipe_serial); // ins_pipe(iload_reg_mem);
14564 %}
14565 
14566 
14567 // ============================================================================
14568 // Procedure Call/Return Instructions
14569 
14570 // Call Java Static Instruction
14571 
14572 instruct CallStaticJavaDirect(method meth)
14573 %{
14574   match(CallStaticJava);
14575 
</pre>
<hr />
<pre>
16707 instruct vsrl16B(vecX dst, vecX src, vecX shift, vecX tmp) %{
16708   predicate(n-&gt;as_Vector()-&gt;length() == 16);
16709   match(Set dst (URShiftVB src shift));
16710   ins_cost(INSN_COST);
16711   effect(TEMP tmp);
16712   format %{ &quot;negr  $tmp,$shift\t&quot;
16713             &quot;ushl  $dst,$src,$tmp\t# vector (16B)&quot; %}
16714   ins_encode %{
16715     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
16716             as_FloatRegister($shift$$reg));
16717     __ ushl(as_FloatRegister($dst$$reg), __ T16B,
16718             as_FloatRegister($src$$reg),
16719             as_FloatRegister($tmp$$reg));
16720   %}
16721   ins_pipe(vshift128);
16722 %}
16723 
16724 instruct vsll8B_imm(vecD dst, vecD src, immI shift) %{
16725   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
16726             n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">16727   match(Set dst (LShiftVB src shift));</span>
16728   ins_cost(INSN_COST);
16729   format %{ &quot;shl    $dst, $src, $shift\t# vector (8B)&quot; %}
16730   ins_encode %{
16731     int sh = (int)$shift$$constant;
16732     if (sh &gt;= 8) {
16733       __ eor(as_FloatRegister($dst$$reg), __ T8B,
16734              as_FloatRegister($src$$reg),
16735              as_FloatRegister($src$$reg));
16736     } else {
16737       __ shl(as_FloatRegister($dst$$reg), __ T8B,
16738              as_FloatRegister($src$$reg), sh);
16739     }
16740   %}
16741   ins_pipe(vshift64_imm);
16742 %}
16743 
16744 instruct vsll16B_imm(vecX dst, vecX src, immI shift) %{
16745   predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">16746   match(Set dst (LShiftVB src shift));</span>
16747   ins_cost(INSN_COST);
16748   format %{ &quot;shl    $dst, $src, $shift\t# vector (16B)&quot; %}
16749   ins_encode %{
16750     int sh = (int)$shift$$constant;
16751     if (sh &gt;= 8) {
16752       __ eor(as_FloatRegister($dst$$reg), __ T16B,
16753              as_FloatRegister($src$$reg),
16754              as_FloatRegister($src$$reg));
16755     } else {
16756       __ shl(as_FloatRegister($dst$$reg), __ T16B,
16757              as_FloatRegister($src$$reg), sh);
16758     }
16759   %}
16760   ins_pipe(vshift128_imm);
16761 %}
16762 
16763 instruct vsra8B_imm(vecD dst, vecD src, immI shift) %{
16764   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
16765             n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">16766   match(Set dst (RShiftVB src shift));</span>
16767   ins_cost(INSN_COST);
16768   format %{ &quot;sshr    $dst, $src, $shift\t# vector (8B)&quot; %}
16769   ins_encode %{
16770     int sh = (int)$shift$$constant;
16771     if (sh &gt;= 8) sh = 7;
16772     __ sshr(as_FloatRegister($dst$$reg), __ T8B,
16773            as_FloatRegister($src$$reg), sh);
16774   %}
16775   ins_pipe(vshift64_imm);
16776 %}
16777 
16778 instruct vsra16B_imm(vecX dst, vecX src, immI shift) %{
16779   predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">16780   match(Set dst (RShiftVB src shift));</span>
16781   ins_cost(INSN_COST);
16782   format %{ &quot;sshr    $dst, $src, $shift\t# vector (16B)&quot; %}
16783   ins_encode %{
16784     int sh = (int)$shift$$constant;
16785     if (sh &gt;= 8) sh = 7;
16786     __ sshr(as_FloatRegister($dst$$reg), __ T16B,
16787            as_FloatRegister($src$$reg), sh);
16788   %}
16789   ins_pipe(vshift128_imm);
16790 %}
16791 
16792 instruct vsrl8B_imm(vecD dst, vecD src, immI shift) %{
16793   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
16794             n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">16795   match(Set dst (URShiftVB src shift));</span>
16796   ins_cost(INSN_COST);
16797   format %{ &quot;ushr    $dst, $src, $shift\t# vector (8B)&quot; %}
16798   ins_encode %{
16799     int sh = (int)$shift$$constant;
16800     if (sh &gt;= 8) {
16801       __ eor(as_FloatRegister($dst$$reg), __ T8B,
16802              as_FloatRegister($src$$reg),
16803              as_FloatRegister($src$$reg));
16804     } else {
16805       __ ushr(as_FloatRegister($dst$$reg), __ T8B,
16806              as_FloatRegister($src$$reg), sh);
16807     }
16808   %}
16809   ins_pipe(vshift64_imm);
16810 %}
16811 
16812 instruct vsrl16B_imm(vecX dst, vecX src, immI shift) %{
16813   predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">16814   match(Set dst (URShiftVB src shift));</span>
16815   ins_cost(INSN_COST);
16816   format %{ &quot;ushr    $dst, $src, $shift\t# vector (16B)&quot; %}
16817   ins_encode %{
16818     int sh = (int)$shift$$constant;
16819     if (sh &gt;= 8) {
16820       __ eor(as_FloatRegister($dst$$reg), __ T16B,
16821              as_FloatRegister($src$$reg),
16822              as_FloatRegister($src$$reg));
16823     } else {
16824       __ ushr(as_FloatRegister($dst$$reg), __ T16B,
16825              as_FloatRegister($src$$reg), sh);
16826     }
16827   %}
16828   ins_pipe(vshift128_imm);
16829 %}
16830 
16831 instruct vsll4S(vecD dst, vecD src, vecD shift) %{
16832   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
16833             n-&gt;as_Vector()-&gt;length() == 4);
16834   match(Set dst (LShiftVS src shift));
</pre>
<hr />
<pre>
16911 instruct vsrl8S(vecX dst, vecX src, vecX shift, vecX tmp) %{
16912   predicate(n-&gt;as_Vector()-&gt;length() == 8);
16913   match(Set dst (URShiftVS src shift));
16914   ins_cost(INSN_COST);
16915   effect(TEMP tmp);
16916   format %{ &quot;negr  $tmp,$shift\t&quot;
16917             &quot;ushl  $dst,$src,$tmp\t# vector (8H)&quot; %}
16918   ins_encode %{
16919     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
16920             as_FloatRegister($shift$$reg));
16921     __ ushl(as_FloatRegister($dst$$reg), __ T8H,
16922             as_FloatRegister($src$$reg),
16923             as_FloatRegister($tmp$$reg));
16924   %}
16925   ins_pipe(vshift128);
16926 %}
16927 
16928 instruct vsll4S_imm(vecD dst, vecD src, immI shift) %{
16929   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
16930             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">16931   match(Set dst (LShiftVS src shift));</span>
16932   ins_cost(INSN_COST);
16933   format %{ &quot;shl    $dst, $src, $shift\t# vector (4H)&quot; %}
16934   ins_encode %{
16935     int sh = (int)$shift$$constant;
16936     if (sh &gt;= 16) {
16937       __ eor(as_FloatRegister($dst$$reg), __ T8B,
16938              as_FloatRegister($src$$reg),
16939              as_FloatRegister($src$$reg));
16940     } else {
16941       __ shl(as_FloatRegister($dst$$reg), __ T4H,
16942              as_FloatRegister($src$$reg), sh);
16943     }
16944   %}
16945   ins_pipe(vshift64_imm);
16946 %}
16947 
16948 instruct vsll8S_imm(vecX dst, vecX src, immI shift) %{
16949   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">16950   match(Set dst (LShiftVS src shift));</span>
16951   ins_cost(INSN_COST);
16952   format %{ &quot;shl    $dst, $src, $shift\t# vector (8H)&quot; %}
16953   ins_encode %{
16954     int sh = (int)$shift$$constant;
16955     if (sh &gt;= 16) {
16956       __ eor(as_FloatRegister($dst$$reg), __ T16B,
16957              as_FloatRegister($src$$reg),
16958              as_FloatRegister($src$$reg));
16959     } else {
16960       __ shl(as_FloatRegister($dst$$reg), __ T8H,
16961              as_FloatRegister($src$$reg), sh);
16962     }
16963   %}
16964   ins_pipe(vshift128_imm);
16965 %}
16966 
16967 instruct vsra4S_imm(vecD dst, vecD src, immI shift) %{
16968   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
16969             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">16970   match(Set dst (RShiftVS src shift));</span>
16971   ins_cost(INSN_COST);
16972   format %{ &quot;sshr    $dst, $src, $shift\t# vector (4H)&quot; %}
16973   ins_encode %{
16974     int sh = (int)$shift$$constant;
16975     if (sh &gt;= 16) sh = 15;
16976     __ sshr(as_FloatRegister($dst$$reg), __ T4H,
16977            as_FloatRegister($src$$reg), sh);
16978   %}
16979   ins_pipe(vshift64_imm);
16980 %}
16981 
16982 instruct vsra8S_imm(vecX dst, vecX src, immI shift) %{
16983   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">16984   match(Set dst (RShiftVS src shift));</span>
16985   ins_cost(INSN_COST);
16986   format %{ &quot;sshr    $dst, $src, $shift\t# vector (8H)&quot; %}
16987   ins_encode %{
16988     int sh = (int)$shift$$constant;
16989     if (sh &gt;= 16) sh = 15;
16990     __ sshr(as_FloatRegister($dst$$reg), __ T8H,
16991            as_FloatRegister($src$$reg), sh);
16992   %}
16993   ins_pipe(vshift128_imm);
16994 %}
16995 
16996 instruct vsrl4S_imm(vecD dst, vecD src, immI shift) %{
16997   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
16998             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">16999   match(Set dst (URShiftVS src shift));</span>
17000   ins_cost(INSN_COST);
17001   format %{ &quot;ushr    $dst, $src, $shift\t# vector (4H)&quot; %}
17002   ins_encode %{
17003     int sh = (int)$shift$$constant;
17004     if (sh &gt;= 16) {
17005       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17006              as_FloatRegister($src$$reg),
17007              as_FloatRegister($src$$reg));
17008     } else {
17009       __ ushr(as_FloatRegister($dst$$reg), __ T4H,
17010              as_FloatRegister($src$$reg), sh);
17011     }
17012   %}
17013   ins_pipe(vshift64_imm);
17014 %}
17015 
17016 instruct vsrl8S_imm(vecX dst, vecX src, immI shift) %{
17017   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17018   match(Set dst (URShiftVS src shift));</span>
17019   ins_cost(INSN_COST);
17020   format %{ &quot;ushr    $dst, $src, $shift\t# vector (8H)&quot; %}
17021   ins_encode %{
17022     int sh = (int)$shift$$constant;
17023     if (sh &gt;= 16) {
17024       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17025              as_FloatRegister($src$$reg),
17026              as_FloatRegister($src$$reg));
17027     } else {
17028       __ ushr(as_FloatRegister($dst$$reg), __ T8H,
17029              as_FloatRegister($src$$reg), sh);
17030     }
17031   %}
17032   ins_pipe(vshift128_imm);
17033 %}
17034 
17035 instruct vsll2I(vecD dst, vecD src, vecD shift) %{
17036   predicate(n-&gt;as_Vector()-&gt;length() == 2);
17037   match(Set dst (LShiftVI src shift));
17038   ins_cost(INSN_COST);
</pre>
<hr />
<pre>
17111 
17112 instruct vsrl4I(vecX dst, vecX src, vecX shift, vecX tmp) %{
17113   predicate(n-&gt;as_Vector()-&gt;length() == 4);
17114   match(Set dst (URShiftVI src shift));
17115   ins_cost(INSN_COST);
17116   effect(TEMP tmp);
17117   format %{ &quot;negr  $tmp,$shift\t&quot;
17118             &quot;ushl  $dst,$src,$tmp\t# vector (4S)&quot; %}
17119   ins_encode %{
17120     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17121             as_FloatRegister($shift$$reg));
17122     __ ushl(as_FloatRegister($dst$$reg), __ T4S,
17123             as_FloatRegister($src$$reg),
17124             as_FloatRegister($tmp$$reg));
17125   %}
17126   ins_pipe(vshift128);
17127 %}
17128 
17129 instruct vsll2I_imm(vecD dst, vecD src, immI shift) %{
17130   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17131   match(Set dst (LShiftVI src shift));</span>
17132   ins_cost(INSN_COST);
17133   format %{ &quot;shl    $dst, $src, $shift\t# vector (2S)&quot; %}
17134   ins_encode %{
17135     __ shl(as_FloatRegister($dst$$reg), __ T2S,
17136            as_FloatRegister($src$$reg),
17137            (int)$shift$$constant);
17138   %}
17139   ins_pipe(vshift64_imm);
17140 %}
17141 
17142 instruct vsll4I_imm(vecX dst, vecX src, immI shift) %{
17143   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17144   match(Set dst (LShiftVI src shift));</span>
17145   ins_cost(INSN_COST);
17146   format %{ &quot;shl    $dst, $src, $shift\t# vector (4S)&quot; %}
17147   ins_encode %{
17148     __ shl(as_FloatRegister($dst$$reg), __ T4S,
17149            as_FloatRegister($src$$reg),
17150            (int)$shift$$constant);
17151   %}
17152   ins_pipe(vshift128_imm);
17153 %}
17154 
17155 instruct vsra2I_imm(vecD dst, vecD src, immI shift) %{
17156   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17157   match(Set dst (RShiftVI src shift));</span>
17158   ins_cost(INSN_COST);
17159   format %{ &quot;sshr    $dst, $src, $shift\t# vector (2S)&quot; %}
17160   ins_encode %{
17161     __ sshr(as_FloatRegister($dst$$reg), __ T2S,
17162             as_FloatRegister($src$$reg),
17163             (int)$shift$$constant);
17164   %}
17165   ins_pipe(vshift64_imm);
17166 %}
17167 
17168 instruct vsra4I_imm(vecX dst, vecX src, immI shift) %{
17169   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17170   match(Set dst (RShiftVI src shift));</span>
17171   ins_cost(INSN_COST);
17172   format %{ &quot;sshr    $dst, $src, $shift\t# vector (4S)&quot; %}
17173   ins_encode %{
17174     __ sshr(as_FloatRegister($dst$$reg), __ T4S,
17175             as_FloatRegister($src$$reg),
17176             (int)$shift$$constant);
17177   %}
17178   ins_pipe(vshift128_imm);
17179 %}
17180 
17181 instruct vsrl2I_imm(vecD dst, vecD src, immI shift) %{
17182   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17183   match(Set dst (URShiftVI src shift));</span>
17184   ins_cost(INSN_COST);
17185   format %{ &quot;ushr    $dst, $src, $shift\t# vector (2S)&quot; %}
17186   ins_encode %{
17187     __ ushr(as_FloatRegister($dst$$reg), __ T2S,
17188             as_FloatRegister($src$$reg),
17189             (int)$shift$$constant);
17190   %}
17191   ins_pipe(vshift64_imm);
17192 %}
17193 
17194 instruct vsrl4I_imm(vecX dst, vecX src, immI shift) %{
17195   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17196   match(Set dst (URShiftVI src shift));</span>
17197   ins_cost(INSN_COST);
17198   format %{ &quot;ushr    $dst, $src, $shift\t# vector (4S)&quot; %}
17199   ins_encode %{
17200     __ ushr(as_FloatRegister($dst$$reg), __ T4S,
17201             as_FloatRegister($src$$reg),
17202             (int)$shift$$constant);
17203   %}
17204   ins_pipe(vshift128_imm);
17205 %}
17206 
17207 instruct vsll2L(vecX dst, vecX src, vecX shift) %{
17208   predicate(n-&gt;as_Vector()-&gt;length() == 2);
17209   match(Set dst (LShiftVL src shift));
17210   ins_cost(INSN_COST);
17211   format %{ &quot;sshl  $dst,$src,$shift\t# vector (2D)&quot; %}
17212   ins_encode %{
17213     __ sshl(as_FloatRegister($dst$$reg), __ T2D,
17214             as_FloatRegister($src$$reg),
17215             as_FloatRegister($shift$$reg));
17216   %}
</pre>
<hr />
<pre>
17236 
17237 instruct vsrl2L(vecX dst, vecX src, vecX shift, vecX tmp) %{
17238   predicate(n-&gt;as_Vector()-&gt;length() == 2);
17239   match(Set dst (URShiftVL src shift));
17240   ins_cost(INSN_COST);
17241   effect(TEMP tmp);
17242   format %{ &quot;negr  $tmp,$shift\t&quot;
17243             &quot;ushl  $dst,$src,$tmp\t# vector (2D)&quot; %}
17244   ins_encode %{
17245     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17246             as_FloatRegister($shift$$reg));
17247     __ ushl(as_FloatRegister($dst$$reg), __ T2D,
17248             as_FloatRegister($src$$reg),
17249             as_FloatRegister($tmp$$reg));
17250   %}
17251   ins_pipe(vshift128);
17252 %}
17253 
17254 instruct vsll2L_imm(vecX dst, vecX src, immI shift) %{
17255   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17256   match(Set dst (LShiftVL src shift));</span>
17257   ins_cost(INSN_COST);
17258   format %{ &quot;shl    $dst, $src, $shift\t# vector (2D)&quot; %}
17259   ins_encode %{
17260     __ shl(as_FloatRegister($dst$$reg), __ T2D,
17261            as_FloatRegister($src$$reg),
17262            (int)$shift$$constant);
17263   %}
17264   ins_pipe(vshift128_imm);
17265 %}
17266 
17267 instruct vsra2L_imm(vecX dst, vecX src, immI shift) %{
17268   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17269   match(Set dst (RShiftVL src shift));</span>
17270   ins_cost(INSN_COST);
17271   format %{ &quot;sshr    $dst, $src, $shift\t# vector (2D)&quot; %}
17272   ins_encode %{
17273     __ sshr(as_FloatRegister($dst$$reg), __ T2D,
17274             as_FloatRegister($src$$reg),
17275             (int)$shift$$constant);
17276   %}
17277   ins_pipe(vshift128_imm);
17278 %}
17279 
17280 instruct vsrl2L_imm(vecX dst, vecX src, immI shift) %{
17281   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17282   match(Set dst (URShiftVL src shift));</span>
17283   ins_cost(INSN_COST);
17284   format %{ &quot;ushr    $dst, $src, $shift\t# vector (2D)&quot; %}
17285   ins_encode %{
17286     __ ushr(as_FloatRegister($dst$$reg), __ T2D,
17287             as_FloatRegister($src$$reg),
17288             (int)$shift$$constant);
17289   %}
17290   ins_pipe(vshift128_imm);
17291 %}
17292 
17293 instruct vmax2F(vecD dst, vecD src1, vecD src2)
17294 %{
17295   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; n-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
17296   match(Set dst (MaxV src1 src2));
17297   ins_cost(INSN_COST);
17298   format %{ &quot;fmax  $dst,$src1,$src2\t# vector (2F)&quot; %}
17299   ins_encode %{
17300     __ fmax(as_FloatRegister($dst$$reg), __ T2S,
17301             as_FloatRegister($src1$$reg),
17302             as_FloatRegister($src2$$reg));
</pre>
<hr />
<pre>
17357             as_FloatRegister($src1$$reg),
17358             as_FloatRegister($src2$$reg));
17359   %}
17360   ins_pipe(vdop_fp128);
17361 %}
17362 
17363 instruct vmin2D(vecX dst, vecX src1, vecX src2)
17364 %{
17365   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; n-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_DOUBLE);
17366   match(Set dst (MinV src1 src2));
17367   ins_cost(INSN_COST);
17368   format %{ &quot;fmin  $dst,$src1,$src2\t# vector (2D)&quot; %}
17369   ins_encode %{
17370     __ fmin(as_FloatRegister($dst$$reg), __ T2D,
17371             as_FloatRegister($src1$$reg),
17372             as_FloatRegister($src2$$reg));
17373   %}
17374   ins_pipe(vdop_fp128);
17375 %}
17376 























17377 //----------PEEPHOLE RULES-----------------------------------------------------
17378 // These must follow all instruction definitions as they use the names
17379 // defined in the instructions definitions.
17380 //
17381 // peepmatch ( root_instr_name [preceding_instruction]* );
17382 //
17383 // peepconstraint %{
17384 // (instruction_number.operand_name relational_op instruction_number.operand_name
17385 //  [, ...] );
17386 // // instruction numbers are zero-based using left to right order in peepmatch
17387 //
17388 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
17389 // // provide an instruction_number.operand_name for each operand that appears
17390 // // in the replacement instruction&#39;s match rule
17391 //
17392 // ---------VM FLAGS---------------------------------------------------------
17393 //
17394 // All peephole optimizations can be turned off using -XX:-OptoPeephole
17395 //
17396 // Each peephole rule is given an identifying number starting with zero and
</pre>
</td>
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">    3 // Copyright (c) 2014, 2020, Red Hat, Inc. All rights reserved.</span>
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
</pre>
<hr />
<pre>
  111 reg_def R17     ( SOC, SOC, Op_RegI, 17, r17-&gt;as_VMReg()        );
  112 reg_def R17_H   ( SOC, SOC, Op_RegI, 17, r17-&gt;as_VMReg()-&gt;next());
  113 reg_def R18     ( SOC, SOC, Op_RegI, 18, r18-&gt;as_VMReg()        );
  114 reg_def R18_H   ( SOC, SOC, Op_RegI, 18, r18-&gt;as_VMReg()-&gt;next());
  115 reg_def R19     ( SOC, SOE, Op_RegI, 19, r19-&gt;as_VMReg()        );
  116 reg_def R19_H   ( SOC, SOE, Op_RegI, 19, r19-&gt;as_VMReg()-&gt;next());
  117 reg_def R20     ( SOC, SOE, Op_RegI, 20, r20-&gt;as_VMReg()        ); // caller esp
  118 reg_def R20_H   ( SOC, SOE, Op_RegI, 20, r20-&gt;as_VMReg()-&gt;next());
  119 reg_def R21     ( SOC, SOE, Op_RegI, 21, r21-&gt;as_VMReg()        );
  120 reg_def R21_H   ( SOC, SOE, Op_RegI, 21, r21-&gt;as_VMReg()-&gt;next());
  121 reg_def R22     ( SOC, SOE, Op_RegI, 22, r22-&gt;as_VMReg()        );
  122 reg_def R22_H   ( SOC, SOE, Op_RegI, 22, r22-&gt;as_VMReg()-&gt;next());
  123 reg_def R23     ( SOC, SOE, Op_RegI, 23, r23-&gt;as_VMReg()        );
  124 reg_def R23_H   ( SOC, SOE, Op_RegI, 23, r23-&gt;as_VMReg()-&gt;next());
  125 reg_def R24     ( SOC, SOE, Op_RegI, 24, r24-&gt;as_VMReg()        );
  126 reg_def R24_H   ( SOC, SOE, Op_RegI, 24, r24-&gt;as_VMReg()-&gt;next());
  127 reg_def R25     ( SOC, SOE, Op_RegI, 25, r25-&gt;as_VMReg()        );
  128 reg_def R25_H   ( SOC, SOE, Op_RegI, 25, r25-&gt;as_VMReg()-&gt;next());
  129 reg_def R26     ( SOC, SOE, Op_RegI, 26, r26-&gt;as_VMReg()        );
  130 reg_def R26_H   ( SOC, SOE, Op_RegI, 26, r26-&gt;as_VMReg()-&gt;next());
<span class="line-modified">  131 reg_def R27     ( SOC, SOE, Op_RegI, 27, r27-&gt;as_VMReg()        ); // heapbase</span>
<span class="line-modified">  132 reg_def R27_H   ( SOC, SOE, Op_RegI, 27, r27-&gt;as_VMReg()-&gt;next());</span>
  133 reg_def R28     (  NS, SOE, Op_RegI, 28, r28-&gt;as_VMReg()        ); // thread
  134 reg_def R28_H   (  NS, SOE, Op_RegI, 28, r28-&gt;as_VMReg()-&gt;next());
  135 reg_def R29     (  NS,  NS, Op_RegI, 29, r29-&gt;as_VMReg()        ); // fp
  136 reg_def R29_H   (  NS,  NS, Op_RegI, 29, r29-&gt;as_VMReg()-&gt;next());
  137 reg_def R30     (  NS,  NS, Op_RegI, 30, r30-&gt;as_VMReg()        ); // lr
  138 reg_def R30_H   (  NS,  NS, Op_RegI, 30, r30-&gt;as_VMReg()-&gt;next());
  139 reg_def R31     (  NS,  NS, Op_RegI, 31, r31_sp-&gt;as_VMReg()     ); // sp
  140 reg_def R31_H   (  NS,  NS, Op_RegI, 31, r31_sp-&gt;as_VMReg()-&gt;next());
  141 
  142 // ----------------------------
  143 // Float/Double Registers
  144 // ----------------------------
  145 
  146 // Double Registers
  147 
  148 // The rules of ADL require that double registers be defined in pairs.
  149 // Each pair must be two 32-bit values, but not necessarily a pair of
  150 // single float registers. In each pair, ADLC-assigned register numbers
  151 // must be adjacent, with the lower number even. Finally, when the
  152 // CPU stores such a register pair to memory, the word associated with
</pre>
<hr />
<pre>
  418     V9, V9_H, V9_J, V9_K,
  419     V10, V10_H, V10_J, V10_K,
  420     V11, V11_H, V11_J, V11_K,
  421     V12, V12_H, V12_J, V12_K,
  422     V13, V13_H, V13_J, V13_K,
  423     V14, V14_H, V14_J, V14_K,
  424     V15, V15_H, V15_J, V15_K,
  425 );
  426 
  427 alloc_class chunk2(RFLAGS);
  428 
  429 //----------Architecture Description Register Classes--------------------------
  430 // Several register classes are automatically defined based upon information in
  431 // this architecture description.
  432 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  433 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  434 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  435 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  436 //
  437 
<span class="line-modified">  438 // Class for all 32 bit general purpose registers</span>
<span class="line-modified">  439 reg_class all_reg32(</span>

  440     R0,
  441     R1,
  442     R2,
  443     R3,
  444     R4,
  445     R5,
  446     R6,
  447     R7,
  448     R10,
  449     R11,
  450     R12,
  451     R13,
  452     R14,
  453     R15,
  454     R16,
  455     R17,
  456     R18,
  457     R19,
  458     R20,
  459     R21,
  460     R22,
  461     R23,
  462     R24,
  463     R25,
  464     R26,
  465     R27,
  466     R28,
  467     R29,
<span class="line-modified">  468     R30,</span>
<span class="line-added">  469     R31</span>
  470 );
  471 
<span class="line-added">  472 </span>
<span class="line-added">  473 // Class for all 32 bit integer registers (excluding SP which</span>
<span class="line-added">  474 // will never be used as an integer register)</span>
<span class="line-added">  475 reg_class any_reg32 %{</span>
<span class="line-added">  476   return _ANY_REG32_mask;</span>
<span class="line-added">  477 %}</span>
<span class="line-added">  478 </span>
  479 // Singleton class for R0 int register
  480 reg_class int_r0_reg(R0);
  481 
  482 // Singleton class for R2 int register
  483 reg_class int_r2_reg(R2);
  484 
  485 // Singleton class for R3 int register
  486 reg_class int_r3_reg(R3);
  487 
  488 // Singleton class for R4 int register
  489 reg_class int_r4_reg(R4);
  490 
<span class="line-modified">  491 // Singleton class for R31 int register</span>
<span class="line-modified">  492 reg_class int_r31_reg(R31);</span>
<span class="line-added">  493 </span>
<span class="line-added">  494 // Class for all 64 bit general purpose registers</span>
<span class="line-added">  495 reg_class all_reg(</span>
  496     R0, R0_H,
  497     R1, R1_H,
  498     R2, R2_H,
  499     R3, R3_H,
  500     R4, R4_H,
  501     R5, R5_H,
  502     R6, R6_H,
  503     R7, R7_H,
  504     R10, R10_H,
  505     R11, R11_H,
  506     R12, R12_H,
  507     R13, R13_H,
  508     R14, R14_H,
  509     R15, R15_H,
  510     R16, R16_H,
  511     R17, R17_H,
  512     R18, R18_H,
  513     R19, R19_H,
  514     R20, R20_H,
  515     R21, R21_H,
  516     R22, R22_H,
  517     R23, R23_H,
  518     R24, R24_H,
  519     R25, R25_H,
  520     R26, R26_H,
  521     R27, R27_H,
  522     R28, R28_H,
  523     R29, R29_H,
  524     R30, R30_H,
  525     R31, R31_H
  526 );
  527 
<span class="line-modified">  528 // Class for all long integer registers (including SP)</span>
<span class="line-modified">  529 reg_class any_reg %{</span>
<span class="line-modified">  530   return _ANY_REG_mask;</span>
<span class="line-modified">  531 %}</span>





























  532 
<span class="line-modified">  533 // Class for non-allocatable 32 bit registers</span>
<span class="line-modified">  534 reg_class non_allocatable_reg32(</span>
<span class="line-modified">  535     R28,                        // thread</span>
<span class="line-modified">  536     R30,                        // lr</span>
<span class="line-modified">  537     R31                         // sp</span>


























  538 );
  539 
<span class="line-modified">  540 // Class for non-allocatable 64 bit registers</span>
<span class="line-modified">  541 reg_class non_allocatable_reg(</span>
<span class="line-modified">  542     R28, R28_H,                 // thread</span>
<span class="line-modified">  543     R30, R30_H,                 // lr</span>
<span class="line-modified">  544     R31, R31_H                  // sp</span>





























  545 );
  546 
<span class="line-modified">  547 // Class for all non-special integer registers</span>
<span class="line-modified">  548 reg_class no_special_reg32 %{</span>
<span class="line-modified">  549   return _NO_SPECIAL_REG32_mask;</span>
<span class="line-modified">  550 %}</span>




























  551 
<span class="line-modified">  552 // Class for all non-special long integer registers</span>
<span class="line-added">  553 reg_class no_special_reg %{</span>
<span class="line-added">  554   return _NO_SPECIAL_REG_mask;</span>
<span class="line-added">  555 %}</span>
  556 
  557 // Class for 64 bit register r0
  558 reg_class r0_reg(
  559     R0, R0_H
  560 );
  561 
  562 // Class for 64 bit register r1
  563 reg_class r1_reg(
  564     R1, R1_H
  565 );
  566 
  567 // Class for 64 bit register r2
  568 reg_class r2_reg(
  569     R2, R2_H
  570 );
  571 
  572 // Class for 64 bit register r3
  573 reg_class r3_reg(
  574     R3, R3_H
  575 );
</pre>
<hr />
<pre>
  608 reg_class thread_reg(
  609     R28, R28_H
  610 );
  611 
  612 // Class for frame pointer register
  613 reg_class fp_reg(
  614     R29, R29_H
  615 );
  616 
  617 // Class for link register
  618 reg_class lr_reg(
  619     R30, R30_H
  620 );
  621 
  622 // Class for long sp register
  623 reg_class sp_reg(
  624   R31, R31_H
  625 );
  626 
  627 // Class for all pointer registers
<span class="line-modified">  628 reg_class ptr_reg %{</span>
<span class="line-modified">  629   return _PTR_REG_mask;</span>
<span class="line-modified">  630 %}</span>





























  631 
  632 // Class for all non_special pointer registers
<span class="line-modified">  633 reg_class no_special_ptr_reg %{</span>
<span class="line-modified">  634   return _NO_SPECIAL_PTR_REG_mask;</span>
<span class="line-modified">  635 %}</span>





























  636 
  637 // Class for all float registers
  638 reg_class float_reg(
  639     V0,
  640     V1,
  641     V2,
  642     V3,
  643     V4,
  644     V5,
  645     V6,
  646     V7,
  647     V8,
  648     V9,
  649     V10,
  650     V11,
  651     V12,
  652     V13,
  653     V14,
  654     V15,
  655     V16,
</pre>
<hr />
<pre>
  783 // Class for 128 bit register v0
  784 reg_class v0_reg(
  785     V0, V0_H
  786 );
  787 
  788 // Class for 128 bit register v1
  789 reg_class v1_reg(
  790     V1, V1_H
  791 );
  792 
  793 // Class for 128 bit register v2
  794 reg_class v2_reg(
  795     V2, V2_H
  796 );
  797 
  798 // Class for 128 bit register v3
  799 reg_class v3_reg(
  800     V3, V3_H
  801 );
  802 
<span class="line-added">  803 // Class for 128 bit register v4</span>
<span class="line-added">  804 reg_class v4_reg(</span>
<span class="line-added">  805     V4, V4_H</span>
<span class="line-added">  806 );</span>
<span class="line-added">  807 </span>
<span class="line-added">  808 // Class for 128 bit register v5</span>
<span class="line-added">  809 reg_class v5_reg(</span>
<span class="line-added">  810     V5, V5_H</span>
<span class="line-added">  811 );</span>
<span class="line-added">  812 </span>
<span class="line-added">  813 // Class for 128 bit register v6</span>
<span class="line-added">  814 reg_class v6_reg(</span>
<span class="line-added">  815     V6, V6_H</span>
<span class="line-added">  816 );</span>
<span class="line-added">  817 </span>
<span class="line-added">  818 // Class for 128 bit register v7</span>
<span class="line-added">  819 reg_class v7_reg(</span>
<span class="line-added">  820     V7, V7_H</span>
<span class="line-added">  821 );</span>
<span class="line-added">  822 </span>
<span class="line-added">  823 // Class for 128 bit register v8</span>
<span class="line-added">  824 reg_class v8_reg(</span>
<span class="line-added">  825     V8, V8_H</span>
<span class="line-added">  826 );</span>
<span class="line-added">  827 </span>
<span class="line-added">  828 // Class for 128 bit register v9</span>
<span class="line-added">  829 reg_class v9_reg(</span>
<span class="line-added">  830     V9, V9_H</span>
<span class="line-added">  831 );</span>
<span class="line-added">  832 </span>
<span class="line-added">  833 // Class for 128 bit register v10</span>
<span class="line-added">  834 reg_class v10_reg(</span>
<span class="line-added">  835     V10, V10_H</span>
<span class="line-added">  836 );</span>
<span class="line-added">  837 </span>
<span class="line-added">  838 // Class for 128 bit register v11</span>
<span class="line-added">  839 reg_class v11_reg(</span>
<span class="line-added">  840     V11, V11_H</span>
<span class="line-added">  841 );</span>
<span class="line-added">  842 </span>
<span class="line-added">  843 // Class for 128 bit register v12</span>
<span class="line-added">  844 reg_class v12_reg(</span>
<span class="line-added">  845     V12, V12_H</span>
<span class="line-added">  846 );</span>
<span class="line-added">  847 </span>
<span class="line-added">  848 // Class for 128 bit register v13</span>
<span class="line-added">  849 reg_class v13_reg(</span>
<span class="line-added">  850     V13, V13_H</span>
<span class="line-added">  851 );</span>
<span class="line-added">  852 </span>
<span class="line-added">  853 // Class for 128 bit register v14</span>
<span class="line-added">  854 reg_class v14_reg(</span>
<span class="line-added">  855     V14, V14_H</span>
<span class="line-added">  856 );</span>
<span class="line-added">  857 </span>
<span class="line-added">  858 // Class for 128 bit register v15</span>
<span class="line-added">  859 reg_class v15_reg(</span>
<span class="line-added">  860     V15, V15_H</span>
<span class="line-added">  861 );</span>
<span class="line-added">  862 </span>
<span class="line-added">  863 // Class for 128 bit register v16</span>
<span class="line-added">  864 reg_class v16_reg(</span>
<span class="line-added">  865     V16, V16_H</span>
<span class="line-added">  866 );</span>
<span class="line-added">  867 </span>
<span class="line-added">  868 // Class for 128 bit register v17</span>
<span class="line-added">  869 reg_class v17_reg(</span>
<span class="line-added">  870     V17, V17_H</span>
<span class="line-added">  871 );</span>
<span class="line-added">  872 </span>
<span class="line-added">  873 // Class for 128 bit register v18</span>
<span class="line-added">  874 reg_class v18_reg(</span>
<span class="line-added">  875     V18, V18_H</span>
<span class="line-added">  876 );</span>
<span class="line-added">  877 </span>
<span class="line-added">  878 // Class for 128 bit register v19</span>
<span class="line-added">  879 reg_class v19_reg(</span>
<span class="line-added">  880     V19, V19_H</span>
<span class="line-added">  881 );</span>
<span class="line-added">  882 </span>
<span class="line-added">  883 // Class for 128 bit register v20</span>
<span class="line-added">  884 reg_class v20_reg(</span>
<span class="line-added">  885     V20, V20_H</span>
<span class="line-added">  886 );</span>
<span class="line-added">  887 </span>
<span class="line-added">  888 // Class for 128 bit register v21</span>
<span class="line-added">  889 reg_class v21_reg(</span>
<span class="line-added">  890     V21, V21_H</span>
<span class="line-added">  891 );</span>
<span class="line-added">  892 </span>
<span class="line-added">  893 // Class for 128 bit register v22</span>
<span class="line-added">  894 reg_class v22_reg(</span>
<span class="line-added">  895     V22, V22_H</span>
<span class="line-added">  896 );</span>
<span class="line-added">  897 </span>
<span class="line-added">  898 // Class for 128 bit register v23</span>
<span class="line-added">  899 reg_class v23_reg(</span>
<span class="line-added">  900     V23, V23_H</span>
<span class="line-added">  901 );</span>
<span class="line-added">  902 </span>
<span class="line-added">  903 // Class for 128 bit register v24</span>
<span class="line-added">  904 reg_class v24_reg(</span>
<span class="line-added">  905     V24, V24_H</span>
<span class="line-added">  906 );</span>
<span class="line-added">  907 </span>
<span class="line-added">  908 // Class for 128 bit register v25</span>
<span class="line-added">  909 reg_class v25_reg(</span>
<span class="line-added">  910     V25, V25_H</span>
<span class="line-added">  911 );</span>
<span class="line-added">  912 </span>
<span class="line-added">  913 // Class for 128 bit register v26</span>
<span class="line-added">  914 reg_class v26_reg(</span>
<span class="line-added">  915     V26, V26_H</span>
<span class="line-added">  916 );</span>
<span class="line-added">  917 </span>
<span class="line-added">  918 // Class for 128 bit register v27</span>
<span class="line-added">  919 reg_class v27_reg(</span>
<span class="line-added">  920     V27, V27_H</span>
<span class="line-added">  921 );</span>
<span class="line-added">  922 </span>
<span class="line-added">  923 // Class for 128 bit register v28</span>
<span class="line-added">  924 reg_class v28_reg(</span>
<span class="line-added">  925     V28, V28_H</span>
<span class="line-added">  926 );</span>
<span class="line-added">  927 </span>
<span class="line-added">  928 // Class for 128 bit register v29</span>
<span class="line-added">  929 reg_class v29_reg(</span>
<span class="line-added">  930     V29, V29_H</span>
<span class="line-added">  931 );</span>
<span class="line-added">  932 </span>
<span class="line-added">  933 // Class for 128 bit register v30</span>
<span class="line-added">  934 reg_class v30_reg(</span>
<span class="line-added">  935     V30, V30_H</span>
<span class="line-added">  936 );</span>
<span class="line-added">  937 </span>
<span class="line-added">  938 // Class for 128 bit register v31</span>
<span class="line-added">  939 reg_class v31_reg(</span>
<span class="line-added">  940     V31, V31_H</span>
<span class="line-added">  941 );</span>
<span class="line-added">  942 </span>
  943 // Singleton class for condition codes
  944 reg_class int_flags(RFLAGS);
  945 
  946 %}
  947 
  948 //----------DEFINITION BLOCK---------------------------------------------------
  949 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
  950 // Current support includes integer values in the range [0, 0x7FFFFFFF]
  951 // Format:
  952 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
  953 // Generated Code in ad_&lt;arch&gt;.hpp
  954 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  955 //        // value == &lt;int_value&gt;
  956 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  957 //        assert( &lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  958 //
  959 
  960 // we follow the ppc-aix port in using a simple cost model which ranks
  961 // register operations as cheap, memory ops as more expensive and
  962 // branches as most expensive. the first two have a low as well as a
</pre>
<hr />
<pre>
  966 definitions %{
  967   // The default cost (of a register move instruction).
  968   int_def INSN_COST            (    100,     100);
  969   int_def BRANCH_COST          (    200,     2 * INSN_COST);
  970   int_def CALL_COST            (    200,     2 * INSN_COST);
  971   int_def VOLATILE_REF_COST    (   1000,     10 * INSN_COST);
  972 %}
  973 
  974 
  975 //----------SOURCE BLOCK-------------------------------------------------------
  976 // This is a block of C++ code which provides values, functions, and
  977 // definitions necessary in the rest of the architecture description
  978 
  979 source_hpp %{
  980 
  981 #include &quot;asm/macroAssembler.hpp&quot;
  982 #include &quot;gc/shared/cardTable.hpp&quot;
  983 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  984 #include &quot;gc/shared/collectedHeap.hpp&quot;
  985 #include &quot;opto/addnode.hpp&quot;
<span class="line-added">  986 #include &quot;opto/convertnode.hpp&quot;</span>
<span class="line-added">  987 </span>
<span class="line-added">  988 extern RegMask _ANY_REG32_mask;</span>
<span class="line-added">  989 extern RegMask _ANY_REG_mask;</span>
<span class="line-added">  990 extern RegMask _PTR_REG_mask;</span>
<span class="line-added">  991 extern RegMask _NO_SPECIAL_REG32_mask;</span>
<span class="line-added">  992 extern RegMask _NO_SPECIAL_REG_mask;</span>
<span class="line-added">  993 extern RegMask _NO_SPECIAL_PTR_REG_mask;</span>
  994 
  995 class CallStubImpl {
  996 
  997   //--------------------------------------------------------------
  998   //---&lt;  Used for optimization in Compile::shorten_branches  &gt;---
  999   //--------------------------------------------------------------
 1000 
 1001  public:
 1002   // Size of call trampoline stub.
 1003   static uint size_call_trampoline() {
 1004     return 0; // no call trampolines on this platform
 1005   }
 1006 
 1007   // number of relocations needed by a call trampoline stub
 1008   static uint reloc_call_trampoline() {
 1009     return 0; // no call trampolines on this platform
 1010   }
 1011 };
 1012 
 1013 class HandlerImpl {
</pre>
<hr />
<pre>
 1026     return 4 * NativeInstruction::instruction_size;
 1027   }
 1028 };
 1029 
 1030  bool is_CAS(int opcode, bool maybe_volatile);
 1031 
 1032   // predicates controlling emit of ldr&lt;x&gt;/ldar&lt;x&gt; and associated dmb
 1033 
 1034   bool unnecessary_acquire(const Node *barrier);
 1035   bool needs_acquiring_load(const Node *load);
 1036 
 1037   // predicates controlling emit of str&lt;x&gt;/stlr&lt;x&gt; and associated dmbs
 1038 
 1039   bool unnecessary_release(const Node *barrier);
 1040   bool unnecessary_volatile(const Node *barrier);
 1041   bool needs_releasing_store(const Node *store);
 1042 
 1043   // predicate controlling translation of CompareAndSwapX
 1044   bool needs_acquiring_load_exclusive(const Node *load);
 1045 



 1046   // predicate controlling addressing modes
 1047   bool size_fits_all_mem_uses(AddPNode* addp, int shift);
 1048 %}
 1049 
 1050 source %{
 1051 
<span class="line-added"> 1052   // Derived RegMask with conditionally allocatable registers</span>
<span class="line-added"> 1053 </span>
<span class="line-added"> 1054   RegMask _ANY_REG32_mask;</span>
<span class="line-added"> 1055   RegMask _ANY_REG_mask;</span>
<span class="line-added"> 1056   RegMask _PTR_REG_mask;</span>
<span class="line-added"> 1057   RegMask _NO_SPECIAL_REG32_mask;</span>
<span class="line-added"> 1058   RegMask _NO_SPECIAL_REG_mask;</span>
<span class="line-added"> 1059   RegMask _NO_SPECIAL_PTR_REG_mask;</span>
<span class="line-added"> 1060 </span>
<span class="line-added"> 1061   void reg_mask_init() {</span>
<span class="line-added"> 1062     // We derive below RegMask(s) from the ones which are auto-generated from</span>
<span class="line-added"> 1063     // adlc register classes to make AArch64 rheapbase (r27) and rfp (r29)</span>
<span class="line-added"> 1064     // registers conditionally reserved.</span>
<span class="line-added"> 1065 </span>
<span class="line-added"> 1066     _ANY_REG32_mask = _ALL_REG32_mask;</span>
<span class="line-added"> 1067     _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r31_sp-&gt;as_VMReg()));</span>
<span class="line-added"> 1068 </span>
<span class="line-added"> 1069     _ANY_REG_mask = _ALL_REG_mask;</span>
<span class="line-added"> 1070 </span>
<span class="line-added"> 1071     _PTR_REG_mask = _ALL_REG_mask;</span>
<span class="line-added"> 1072 </span>
<span class="line-added"> 1073     _NO_SPECIAL_REG32_mask = _ALL_REG32_mask;</span>
<span class="line-added"> 1074     _NO_SPECIAL_REG32_mask.SUBTRACT(_NON_ALLOCATABLE_REG32_mask);</span>
<span class="line-added"> 1075 </span>
<span class="line-added"> 1076     _NO_SPECIAL_REG_mask = _ALL_REG_mask;</span>
<span class="line-added"> 1077     _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);</span>
<span class="line-added"> 1078 </span>
<span class="line-added"> 1079     _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;</span>
<span class="line-added"> 1080     _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);</span>
<span class="line-added"> 1081 </span>
<span class="line-added"> 1082     // r27 is not allocatable when compressed oops is on, compressed klass</span>
<span class="line-added"> 1083     // pointers doesn&#39;t use r27 after JDK-8234794</span>
<span class="line-added"> 1084     if (UseCompressedOops) {</span>
<span class="line-added"> 1085       _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r27-&gt;as_VMReg()));</span>
<span class="line-added"> 1086       _NO_SPECIAL_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);</span>
<span class="line-added"> 1087       _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);</span>
<span class="line-added"> 1088     }</span>
<span class="line-added"> 1089 </span>
<span class="line-added"> 1090     // r29 is not allocatable when PreserveFramePointer is on</span>
<span class="line-added"> 1091     if (PreserveFramePointer) {</span>
<span class="line-added"> 1092       _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r29-&gt;as_VMReg()));</span>
<span class="line-added"> 1093       _NO_SPECIAL_REG_mask.SUBTRACT(_FP_REG_mask);</span>
<span class="line-added"> 1094       _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_FP_REG_mask);</span>
<span class="line-added"> 1095     }</span>
<span class="line-added"> 1096   }</span>
<span class="line-added"> 1097 </span>
 1098   // Optimizaton of volatile gets and puts
 1099   // -------------------------------------
 1100   //
 1101   // AArch64 has ldar&lt;x&gt; and stlr&lt;x&gt; instructions which we can safely
 1102   // use to implement volatile reads and writes. For a volatile read
 1103   // we simply need
 1104   //
 1105   //   ldar&lt;x&gt;
 1106   //
 1107   // and for a volatile write we need
 1108   //
 1109   //   stlr&lt;x&gt;
 1110   //
 1111   // Alternatively, we can implement them by pairing a normal
 1112   // load/store with a memory barrier. For a volatile read we need
 1113   //
 1114   //   ldr&lt;x&gt;
 1115   //   dmb ishld
 1116   //
 1117   // for a volatile write
</pre>
<hr />
<pre>
 1460 // returns true if CAS needs to use an acquiring load otherwise false
 1461 
 1462 bool needs_acquiring_load_exclusive(const Node *n)
 1463 {
 1464   assert(is_CAS(n-&gt;Opcode(), true), &quot;expecting a compare and swap&quot;);
 1465   if (UseBarriersForVolatile) {
 1466     return false;
 1467   }
 1468 
 1469   LoadStoreNode* ldst = n-&gt;as_LoadStore();
 1470   if (is_CAS(n-&gt;Opcode(), false)) {
 1471     assert(ldst-&gt;trailing_membar() != NULL, &quot;expected trailing membar&quot;);
 1472   } else {
 1473     return ldst-&gt;trailing_membar() != NULL;
 1474   }
 1475 
 1476   // so we can just return true here
 1477   return true;
 1478 }
 1479 























 1480 #define __ _masm.
 1481 
 1482 // advance declarations for helper functions to convert register
 1483 // indices to register objects
 1484 
 1485 // the ad file has to provide implementations of certain methods
 1486 // expected by the generic code
 1487 //
 1488 // REQUIRED FUNCTIONALITY
 1489 
 1490 //=============================================================================
 1491 
 1492 // !!!!! Special hack to get all types of calls to specify the byte offset
 1493 //       from the start of the call to the point where the return address
 1494 //       will point.
 1495 
 1496 int MachCallStaticJavaNode::ret_addr_offset()
 1497 {
 1498   // call should be a simple bl
 1499   int off = 4;
 1500   return off;
 1501 }
 1502 
 1503 int MachCallDynamicJavaNode::ret_addr_offset()
 1504 {
 1505   return 16; // movz, movk, movk, bl
 1506 }
 1507 
 1508 int MachCallRuntimeNode::ret_addr_offset() {
 1509   // for generated stubs the call will be
 1510   //   far_call(addr)
 1511   // for real runtime callouts it will be six instructions
 1512   // see aarch64_enc_java_to_runtime
 1513   //   adr(rscratch2, retaddr)
 1514   //   lea(rscratch1, RuntimeAddress(addr)
 1515   //   stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)))
<span class="line-modified"> 1516   //   blr(rscratch1)</span>
 1517   CodeBlob *cb = CodeCache::find_blob(_entry_point);
 1518   if (cb) {
 1519     return MacroAssembler::far_branch_size();
 1520   } else {
 1521     return 6 * NativeInstruction::instruction_size;
 1522   }
 1523 }
 1524 
 1525 // Indicate if the safepoint node needs the polling page as an input
 1526 
 1527 // the shared code plants the oop data at the start of the generated
 1528 // code for the safepoint node and that needs ot be at the load
 1529 // instruction itself. so we cannot plant a mov of the safepoint poll
 1530 // address followed by a load. setting this to true means the mov is
 1531 // scheduled as a prior instruction. that&#39;s better for scheduling
 1532 // anyway.
 1533 
 1534 bool SafePointNode::needs_polling_address_input()
 1535 {
 1536   return true;
</pre>
<hr />
<pre>
 1615     st-&gt;print(&quot;stp  lr, rfp, [sp, #%d]!\n\t&quot;, -(2 * wordSize));
 1616     if (PreserveFramePointer) st-&gt;print(&quot;mov  rfp, sp\n\t&quot;);
 1617     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1618     st-&gt;print(&quot;sub  sp, sp, rscratch1&quot;);
 1619   }
 1620 }
 1621 #endif
 1622 
 1623 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1624   Compile* C = ra_-&gt;C;
 1625   MacroAssembler _masm(&amp;cbuf);
 1626 
 1627   // n.b. frame size includes space for return pc and rfp
 1628   const long framesize = C-&gt;frame_size_in_bytes();
 1629   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1630 
 1631   // insert a nop at the start of the prolog so we can patch in a
 1632   // branch if we need to invalidate the method later
 1633   __ nop();
 1634 
<span class="line-modified"> 1635   if (C-&gt;clinit_barrier_on_entry()) {</span>
<span class="line-modified"> 1636     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>

 1637 
<span class="line-modified"> 1638     Label L_skip_barrier;</span>
 1639 
<span class="line-modified"> 1640     __ mov_metadata(rscratch2, C-&gt;method()-&gt;holder()-&gt;constant_encoding());</span>
<span class="line-modified"> 1641     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);</span>
<span class="line-added"> 1642     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>
<span class="line-added"> 1643     __ bind(L_skip_barrier);</span>
 1644   }
 1645 
<span class="line-added"> 1646   int bangsize = C-&gt;bang_size_in_bytes();</span>
<span class="line-added"> 1647   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
<span class="line-added"> 1648     __ generate_stack_overflow_check(bangsize);</span>
<span class="line-added"> 1649 </span>
<span class="line-added"> 1650   __ build_frame(framesize);</span>
<span class="line-added"> 1651 </span>
 1652   if (VerifyStackAtCalls) {
 1653     Unimplemented();
 1654   }
 1655 
 1656   C-&gt;set_frame_complete(cbuf.insts_size());
 1657 
 1658   if (C-&gt;has_mach_constant_base_node()) {
 1659     // NOTE: We set the table base offset here because users might be
 1660     // emitted before MachConstantBaseNode.
 1661     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
 1662     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1663   }
 1664 }
 1665 
 1666 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 1667 {
 1668   return MachNode::size(ra_); // too many variables; just compute it
 1669                               // the hard way
 1670 }
 1671 
</pre>
<hr />
<pre>
 1692     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1693     st-&gt;print(&quot;add  sp, sp, rscratch1\n\t&quot;);
 1694     st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
 1695   }
 1696 
 1697   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1698     st-&gt;print(&quot;# touch polling page\n\t&quot;);
 1699     st-&gt;print(&quot;mov  rscratch1, #0x%lx\n\t&quot;, p2i(os::get_polling_page()));
 1700     st-&gt;print(&quot;ldr zr, [rscratch1]&quot;);
 1701   }
 1702 }
 1703 #endif
 1704 
 1705 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1706   Compile* C = ra_-&gt;C;
 1707   MacroAssembler _masm(&amp;cbuf);
 1708   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
 1709 
 1710   __ remove_frame(framesize);
 1711 




 1712   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1713     __ reserved_stack_check();
 1714   }
 1715 
 1716   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1717     __ read_polling_page(rscratch1, os::get_polling_page(), relocInfo::poll_return_type);
 1718   }
 1719 }
 1720 
 1721 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1722   // Variable size. Determine dynamically.
 1723   return MachNode::size(ra_);
 1724 }
 1725 
 1726 int MachEpilogNode::reloc() const {
 1727   // Return number of relocatable values contained in this instruction.
 1728   return 1; // 1 for polling page.
 1729 }
 1730 
 1731 const Pipeline * MachEpilogNode::pipeline() const {
</pre>
<hr />
<pre>
 1737 // get rid of it?
 1738 int MachEpilogNode::safepoint_offset() const {
 1739   assert(do_polling(), &quot;no return for this epilog node&quot;);
 1740   return 4;
 1741 }
 1742 
 1743 //=============================================================================
 1744 
 1745 // Figure out which register class each belongs in: rc_int, rc_float or
 1746 // rc_stack.
 1747 enum RC { rc_bad, rc_int, rc_float, rc_stack };
 1748 
 1749 static enum RC rc_class(OptoReg::Name reg) {
 1750 
 1751   if (reg == OptoReg::Bad) {
 1752     return rc_bad;
 1753   }
 1754 
 1755   // we have 30 int registers * 2 halves
 1756   // (rscratch1 and rscratch2 are omitted)
<span class="line-added"> 1757   int slots_of_int_registers = RegisterImpl::max_slots_per_register * (RegisterImpl::number_of_registers - 2);</span>
 1758 
<span class="line-modified"> 1759   if (reg &lt; slots_of_int_registers) {</span>
 1760     return rc_int;
 1761   }
 1762 
<span class="line-modified"> 1763   // we have 32 float register * 4 halves</span>
<span class="line-modified"> 1764   if (reg &lt; slots_of_int_registers + FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers) {</span>
 1765     return rc_float;
 1766   }
 1767 
 1768   // Between float regs &amp; stack is the flags regs.
 1769   assert(OptoReg::is_stack(reg), &quot;blow up if spilling flags&quot;);
 1770 
 1771   return rc_stack;
 1772 }
 1773 
 1774 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {
 1775   Compile* C = ra_-&gt;C;
 1776 
 1777   // Get registers to move.
 1778   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1779   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1780   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1781   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1782 
 1783   enum RC src_hi_rc = rc_class(src_hi);
 1784   enum RC src_lo_rc = rc_class(src_lo);
</pre>
<hr />
<pre>
 1960   if (Assembler::operand_valid_for_add_sub_immediate(offset)) {
 1961     __ add(as_Register(reg), sp, offset);
 1962   } else {
 1963     ShouldNotReachHere();
 1964   }
 1965 }
 1966 
 1967 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1968   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_).
 1969   return 4;
 1970 }
 1971 
 1972 //=============================================================================
 1973 
 1974 #ifndef PRODUCT
 1975 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1976 {
 1977   st-&gt;print_cr(&quot;# MachUEPNode&quot;);
 1978   if (UseCompressedClassPointers) {
 1979     st-&gt;print_cr(&quot;\tldrw rscratch1, j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
<span class="line-modified"> 1980     if (CompressedKlassPointers::shift() != 0) {</span>
 1981       st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1982     }
 1983   } else {
 1984    st-&gt;print_cr(&quot;\tldr rscratch1, j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1985   }
 1986   st-&gt;print_cr(&quot;\tcmp r0, rscratch1\t # Inline cache check&quot;);
 1987   st-&gt;print_cr(&quot;\tbne, SharedRuntime::_ic_miss_stub&quot;);
 1988 }
 1989 #endif
 1990 
 1991 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1992 {
 1993   // This is the unverified entry point.
 1994   MacroAssembler _masm(&amp;cbuf);
 1995 
 1996   __ cmp_klass(j_rarg0, rscratch2, rscratch1);
 1997   Label skip;
 1998   // TODO
 1999   // can we avoid this skip and still use a reloc?
 2000   __ br(Assembler::EQ, skip);
</pre>
<hr />
<pre>
 2040   address base = __ start_a_stub(size_deopt_handler());
 2041   if (base == NULL) {
 2042     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2043     return 0;  // CodeBuffer::expand failed
 2044   }
 2045   int offset = __ offset();
 2046 
 2047   __ adr(lr, __ pc());
 2048   __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 2049 
 2050   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
 2051   __ end_a_stub();
 2052   return offset;
 2053 }
 2054 
 2055 // REQUIRED MATCHER CODE
 2056 
 2057 //=============================================================================
 2058 
 2059 const bool Matcher::match_rule_supported(int opcode) {
<span class="line-added"> 2060   if (!has_match_rule(opcode))</span>
<span class="line-added"> 2061     return false;</span>
 2062 
<span class="line-added"> 2063   bool ret_value = true;</span>
 2064   switch (opcode) {
<span class="line-modified"> 2065     case Op_CacheWB:</span>
<span class="line-modified"> 2066     case Op_CacheWBPreSync:</span>
<span class="line-modified"> 2067     case Op_CacheWBPostSync:</span>
<span class="line-modified"> 2068       if (!VM_Version::supports_data_cache_line_flush()) {</span>
<span class="line-modified"> 2069         ret_value = false;</span>
<span class="line-modified"> 2070       }</span>
<span class="line-added"> 2071       break;</span>
 2072   }
 2073 
<span class="line-modified"> 2074   return ret_value; // Per default match rules are supported.</span>
 2075 }
 2076 
<span class="line-modified"> 2077 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {</span>
 2078 
 2079   // TODO
 2080   // identify extra cases that we might want to provide match rules for
 2081   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 2082   bool ret_value = match_rule_supported(opcode);
 2083   // Add rules here.
 2084 
 2085   return ret_value;  // Per default match rules are supported.
 2086 }
 2087 
 2088 const bool Matcher::has_predicated_vectors(void) {
 2089   return false;
 2090 }
 2091 
 2092 const int Matcher::float_pressure(int default_pressure_threshold) {
 2093   return default_pressure_threshold;
 2094 }
 2095 
 2096 int Matcher::regnum_to_fpu_offset(int regnum)
 2097 {
</pre>
<hr />
<pre>
 2174 const bool Matcher::init_array_count_is_in_bytes = false;
 2175 
 2176 // Use conditional move (CMOVL)
 2177 const int Matcher::long_cmove_cost() {
 2178   // long cmoves are no more expensive than int cmoves
 2179   return 0;
 2180 }
 2181 
 2182 const int Matcher::float_cmove_cost() {
 2183   // float cmoves are no more expensive than int cmoves
 2184   return 0;
 2185 }
 2186 
 2187 // Does the CPU require late expand (see block.cpp for description of late expand)?
 2188 const bool Matcher::require_postalloc_expand = false;
 2189 
 2190 // Do we need to mask the count passed to shift instructions or does
 2191 // the cpu only look at the lower 5/6 bits anyway?
 2192 const bool Matcher::need_masked_shift_count = false;
 2193 
<span class="line-added"> 2194 // No support for generic vector operands.</span>
<span class="line-added"> 2195 const bool Matcher::supports_generic_vector_operands  = false;</span>
<span class="line-added"> 2196 </span>
<span class="line-added"> 2197 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {</span>
<span class="line-added"> 2198   ShouldNotReachHere(); // generic vector operands not supported</span>
<span class="line-added"> 2199   return NULL;</span>
<span class="line-added"> 2200 }</span>
<span class="line-added"> 2201 </span>
<span class="line-added"> 2202 bool Matcher::is_generic_reg2reg_move(MachNode* m) {</span>
<span class="line-added"> 2203   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added"> 2204   return false;</span>
<span class="line-added"> 2205 }</span>
<span class="line-added"> 2206 </span>
<span class="line-added"> 2207 bool Matcher::is_generic_vector(MachOper* opnd)  {</span>
<span class="line-added"> 2208   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added"> 2209   return false;</span>
<span class="line-added"> 2210 }</span>
<span class="line-added"> 2211 </span>
 2212 // This affects two different things:
 2213 //  - how Decode nodes are matched
 2214 //  - how ImplicitNullCheck opportunities are recognized
 2215 // If true, the matcher will try to remove all Decodes and match them
 2216 // (as operands) into nodes. NullChecks are not prepared to deal with
 2217 // Decodes by final_graph_reshaping().
 2218 // If false, final_graph_reshaping() forces the decode behind the Cmp
 2219 // for a NullCheck. The matcher matches the Decode node into a register.
 2220 // Implicit_null_check optimization moves the Decode along with the
 2221 // memory operation back up before the NullCheck.
 2222 bool Matcher::narrow_oop_use_complex_address() {
<span class="line-modified"> 2223   return CompressedOops::shift() == 0;</span>
 2224 }
 2225 
 2226 bool Matcher::narrow_klass_use_complex_address() {
 2227 // TODO
 2228 // decide whether we need to set this to true
 2229   return false;
 2230 }
 2231 
 2232 bool Matcher::const_oop_prefer_decode() {
 2233   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="line-modified"> 2234   return CompressedOops::base() == NULL;</span>
 2235 }
 2236 
 2237 bool Matcher::const_klass_prefer_decode() {
 2238   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified"> 2239   return CompressedKlassPointers::base() == NULL;</span>
 2240 }
 2241 
 2242 // Is it better to copy float constants, or load them directly from
 2243 // memory?  Intel can load a float constant from a direct address,
 2244 // requiring no extra registers.  Most RISCs will have to materialize
 2245 // an address into a register first, so they would do better to copy
 2246 // the constant from stack.
 2247 const bool Matcher::rematerialize_float_constants = false;
 2248 
 2249 // If CPU can load and store mis-aligned doubles directly then no
 2250 // fixup is needed.  Else we split the double into 2 integer pieces
 2251 // and move it piece-by-piece.  Only happens when passing doubles into
 2252 // C code as the Java calling convention forces doubles to be aligned.
 2253 const bool Matcher::misaligned_doubles_ok = true;
 2254 
 2255 // No-op on amd64
 2256 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2257   Unimplemented();
 2258 }
 2259 
<span class="line-modified"> 2260 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>

 2261 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2262 
 2263 // Are floats converted to double when stored to stack during
 2264 // deoptimization?
 2265 bool Matcher::float_in_double() { return false; }
 2266 
 2267 // Do ints take an entire long register or just half?
 2268 // The relevant question is how the int is callee-saved:
 2269 // the whole long is written but de-opt&#39;ing will have to extract
 2270 // the relevant 32 bits.
 2271 const bool Matcher::int_in_long = true;
 2272 
 2273 // Return whether or not this register is ever used as an argument.
 2274 // This function is used on startup to build the trampoline stubs in
 2275 // generateOptoStub.  Registers not mentioned will be killed by the VM
 2276 // call in the trampoline, and arguments in those registers not be
 2277 // available to the callee.
 2278 bool Matcher::can_be_java_arg(int reg)
 2279 {
 2280   return
</pre>
<hr />
<pre>
 2375     address_visited.test_set(m-&gt;_idx); // Flag as address_visited
 2376     mstack.push(m-&gt;in(AddPNode::Address), Pre_Visit);
 2377     mstack.push(m-&gt;in(AddPNode::Base), Pre_Visit);
 2378     return true;
 2379   } else if (off-&gt;Opcode() == Op_ConvI2L &amp;&amp;
 2380              // Are there other uses besides address expressions?
 2381              !is_visited(off)) {
 2382     address_visited.test_set(m-&gt;_idx); // Flag as address_visited
 2383     address_visited.set(off-&gt;_idx); // Flag as address_visited
 2384     mstack.push(off-&gt;in(1), Pre_Visit);
 2385     mstack.push(m-&gt;in(AddPNode::Address), Pre_Visit);
 2386     mstack.push(m-&gt;in(AddPNode::Base), Pre_Visit);
 2387     return true;
 2388   }
 2389   return false;
 2390 }
 2391 
 2392 void Compile::reshape_address(AddPNode* addp) {
 2393 }
 2394 









































 2395 
 2396 #define MOV_VOLATILE(REG, BASE, INDEX, SCALE, DISP, SCRATCH, INSN)      \
 2397   MacroAssembler _masm(&amp;cbuf);                                          \
 2398   {                                                                     \
 2399     guarantee(INDEX == -1, &quot;mode not permitted for volatile&quot;);          \
 2400     guarantee(DISP == 0, &quot;mode not permitted for volatile&quot;);            \
 2401     guarantee(SCALE == 0, &quot;mode not permitted for volatile&quot;);           \
 2402     __ INSN(REG, as_Register(BASE));                                    \
 2403   }
 2404 




 2405 
<span class="line-modified"> 2406 static Address mem2address(int opcode, Register base, int index, int size, int disp)</span>





 2407   {
 2408     Address::extend scale;
 2409 
 2410     // Hooboy, this is fugly.  We need a way to communicate to the
 2411     // encoder that the index needs to be sign extended, so we have to
 2412     // enumerate all the cases.
 2413     switch (opcode) {
 2414     case INDINDEXSCALEDI2L:
 2415     case INDINDEXSCALEDI2LN:
 2416     case INDINDEXI2L:
 2417     case INDINDEXI2LN:
 2418       scale = Address::sxtw(size);
 2419       break;
 2420     default:
 2421       scale = Address::lsl(size);
 2422     }
 2423 
 2424     if (index == -1) {
<span class="line-modified"> 2425       return Address(base, disp);</span>
 2426     } else {
 2427       assert(disp == 0, &quot;unsupported address mode: disp = %d&quot;, disp);
<span class="line-modified"> 2428       return Address(base, as_Register(index), scale);</span>
<span class="line-added"> 2429     }</span>
<span class="line-added"> 2430   }</span>
<span class="line-added"> 2431 </span>
<span class="line-added"> 2432 </span>
<span class="line-added"> 2433 typedef void (MacroAssembler::* mem_insn)(Register Rt, const Address &amp;adr);</span>
<span class="line-added"> 2434 typedef void (MacroAssembler::* mem_insn2)(Register Rt, Register adr);</span>
<span class="line-added"> 2435 typedef void (MacroAssembler::* mem_float_insn)(FloatRegister Rt, const Address &amp;adr);</span>
<span class="line-added"> 2436 typedef void (MacroAssembler::* mem_vector_insn)(FloatRegister Rt,</span>
<span class="line-added"> 2437                                   MacroAssembler::SIMD_RegVariant T, const Address &amp;adr);</span>
<span class="line-added"> 2438 </span>
<span class="line-added"> 2439   // Used for all non-volatile memory accesses.  The use of</span>
<span class="line-added"> 2440   // $mem-&gt;opcode() to discover whether this pattern uses sign-extended</span>
<span class="line-added"> 2441   // offsets is something of a kludge.</span>
<span class="line-added"> 2442   static void loadStore(MacroAssembler masm, mem_insn insn,</span>
<span class="line-added"> 2443                         Register reg, int opcode,</span>
<span class="line-added"> 2444                         Register base, int index, int scale, int disp,</span>
<span class="line-added"> 2445                         int size_in_memory)</span>
<span class="line-added"> 2446   {</span>
<span class="line-added"> 2447     Address addr = mem2address(opcode, base, index, scale, disp);</span>
<span class="line-added"> 2448     if (addr.getMode() == Address::base_plus_offset) {</span>
<span class="line-added"> 2449       /* If we get an out-of-range offset it is a bug in the compiler,</span>
<span class="line-added"> 2450          so we assert here. */</span>
<span class="line-added"> 2451       assert(Address::offset_ok_for_immed(addr.offset(), exact_log2(size_in_memory)),</span>
<span class="line-added"> 2452              &quot;c2 compiler bug&quot;);</span>
<span class="line-added"> 2453       /* Fix up any out-of-range offsets. */</span>
<span class="line-added"> 2454       assert_different_registers(rscratch1, base);</span>
<span class="line-added"> 2455       assert_different_registers(rscratch1, reg);</span>
<span class="line-added"> 2456       addr = masm.legitimize_address(addr, size_in_memory, rscratch1);</span>
 2457     }
<span class="line-added"> 2458     (masm.*insn)(reg, addr);</span>
 2459   }
 2460 
 2461   static void loadStore(MacroAssembler masm, mem_float_insn insn,
<span class="line-modified"> 2462                         FloatRegister reg, int opcode,</span>
<span class="line-modified"> 2463                         Register base, int index, int size, int disp,</span>
<span class="line-added"> 2464                         int size_in_memory)</span>
 2465   {
 2466     Address::extend scale;
 2467 
 2468     switch (opcode) {
 2469     case INDINDEXSCALEDI2L:
 2470     case INDINDEXSCALEDI2LN:
 2471       scale = Address::sxtw(size);
 2472       break;
 2473     default:
 2474       scale = Address::lsl(size);
 2475     }
 2476 
<span class="line-modified"> 2477     if (index == -1) {</span>
<span class="line-modified"> 2478       /* If we get an out-of-range offset it is a bug in the compiler,</span>
<span class="line-added"> 2479          so we assert here. */</span>
<span class="line-added"> 2480       assert(Address::offset_ok_for_immed(disp, exact_log2(size_in_memory)), &quot;c2 compiler bug&quot;);</span>
<span class="line-added"> 2481       /* Fix up any out-of-range offsets. */</span>
<span class="line-added"> 2482       assert_different_registers(rscratch1, base);</span>
<span class="line-added"> 2483       Address addr = Address(base, disp);</span>
<span class="line-added"> 2484       addr = masm.legitimize_address(addr, size_in_memory, rscratch1);</span>
<span class="line-added"> 2485       (masm.*insn)(reg, addr);</span>
 2486     } else {
 2487       assert(disp == 0, &quot;unsupported address mode: disp = %d&quot;, disp);
 2488       (masm.*insn)(reg, Address(base, as_Register(index), scale));
 2489     }
 2490   }
 2491 
 2492   static void loadStore(MacroAssembler masm, mem_vector_insn insn,
<span class="line-modified"> 2493                         FloatRegister reg, MacroAssembler::SIMD_RegVariant T,</span>
<span class="line-modified"> 2494                         int opcode, Register base, int index, int size, int disp)</span>
 2495   {
 2496     if (index == -1) {
 2497       (masm.*insn)(reg, T, Address(base, disp));
 2498     } else {
 2499       assert(disp == 0, &quot;unsupported address mode&quot;);
 2500       (masm.*insn)(reg, T, Address(base, as_Register(index), Address::lsl(size)));
 2501     }
 2502   }
 2503 
 2504 %}
 2505 
 2506 
 2507 
 2508 //----------ENCODING BLOCK-----------------------------------------------------
 2509 // This block specifies the encoding classes used by the compiler to
 2510 // output byte streams.  Encoding classes are parameterized macros
 2511 // used by Machine Instruction Nodes in order to generate the bit
 2512 // encoding of the instruction.  Operands specify their base encoding
 2513 // interface with the interface keyword.  There are currently
 2514 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
</pre>
<hr />
<pre>
 2531 // opcode keyword to specify, in order, their primary, secondary, and
 2532 // tertiary opcode.  Only the opcode sections which a particular
 2533 // instruction needs for encoding need to be specified.
 2534 encode %{
 2535   // Build emit functions for each basic byte or larger field in the
 2536   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 2537   // from C++ code in the enc_class source block.  Emit functions will
 2538   // live in the main source block for now.  In future, we can
 2539   // generalize this by adding a syntax that specifies the sizes of
 2540   // fields in an order, so that the adlc can build the emit functions
 2541   // automagically
 2542 
 2543   // catch all for unimplemented encodings
 2544   enc_class enc_unimplemented %{
 2545     MacroAssembler _masm(&amp;cbuf);
 2546     __ unimplemented(&quot;C2 catch all&quot;);
 2547   %}
 2548 
 2549   // BEGIN Non-volatile memory access
 2550 
<span class="line-modified"> 2551   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2552   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2553   enc_class aarch64_enc_ldrsbw(iRegI dst, memory1 mem) %{</span>
 2554     Register dst_reg = as_Register($dst$$reg);
 2555     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsbw, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2556                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
 2557   %}
 2558 
<span class="line-modified"> 2559   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2560   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2561   enc_class aarch64_enc_ldrsb(iRegI dst, memory1 mem) %{</span>
 2562     Register dst_reg = as_Register($dst$$reg);
 2563     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsb, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2564                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
 2565   %}
 2566 
<span class="line-modified"> 2567   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2568   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2569   enc_class aarch64_enc_ldrb(iRegI dst, memory1 mem) %{</span>
 2570     Register dst_reg = as_Register($dst$$reg);
 2571     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2572                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
 2573   %}
 2574 
<span class="line-modified"> 2575   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2576   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2577   enc_class aarch64_enc_ldrb(iRegL dst, memory1 mem) %{</span>
 2578     Register dst_reg = as_Register($dst$$reg);
 2579     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2580                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
 2581   %}
 2582 
<span class="line-modified"> 2583   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2584   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2585   enc_class aarch64_enc_ldrshw(iRegI dst, memory2 mem) %{</span>
 2586     Register dst_reg = as_Register($dst$$reg);
 2587     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrshw, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2588                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);</span>
 2589   %}
 2590 
<span class="line-modified"> 2591   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2592   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2593   enc_class aarch64_enc_ldrsh(iRegI dst, memory2 mem) %{</span>
 2594     Register dst_reg = as_Register($dst$$reg);
 2595     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsh, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2596                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);</span>
 2597   %}
 2598 
<span class="line-modified"> 2599   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2600   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2601   enc_class aarch64_enc_ldrh(iRegI dst, memory2 mem) %{</span>
 2602     Register dst_reg = as_Register($dst$$reg);
 2603     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2604                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);</span>
 2605   %}
 2606 
<span class="line-modified"> 2607   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2608   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2609   enc_class aarch64_enc_ldrh(iRegL dst, memory2 mem) %{</span>
 2610     Register dst_reg = as_Register($dst$$reg);
 2611     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2612                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);</span>
 2613   %}
 2614 
<span class="line-modified"> 2615   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2616   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2617   enc_class aarch64_enc_ldrw(iRegI dst, memory4 mem) %{</span>
 2618     Register dst_reg = as_Register($dst$$reg);
 2619     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2620                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
 2621   %}
 2622 
<span class="line-modified"> 2623   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2624   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2625   enc_class aarch64_enc_ldrw(iRegL dst, memory4 mem) %{</span>
 2626     Register dst_reg = as_Register($dst$$reg);
 2627     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2628                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
 2629   %}
 2630 
<span class="line-modified"> 2631   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2632   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2633   enc_class aarch64_enc_ldrsw(iRegL dst, memory4 mem) %{</span>
 2634     Register dst_reg = as_Register($dst$$reg);
 2635     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsw, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2636                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
 2637   %}
 2638 
<span class="line-modified"> 2639   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2640   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2641   enc_class aarch64_enc_ldr(iRegL dst, memory8 mem) %{</span>
 2642     Register dst_reg = as_Register($dst$$reg);
 2643     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2644                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);</span>
 2645   %}
 2646 
<span class="line-modified"> 2647   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2648   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2649   enc_class aarch64_enc_ldrs(vRegF dst, memory4 mem) %{</span>
 2650     FloatRegister dst_reg = as_FloatRegister($dst$$reg);
 2651     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2652                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
 2653   %}
 2654 
<span class="line-modified"> 2655   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2656   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2657   enc_class aarch64_enc_ldrd(vRegD dst, memory8 mem) %{</span>
 2658     FloatRegister dst_reg = as_FloatRegister($dst$$reg);
 2659     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, dst_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2660                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);</span>


















 2661   %}
 2662 
<span class="line-modified"> 2663   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2664   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2665   enc_class aarch64_enc_strb(iRegI src, memory1 mem) %{</span>
 2666     Register src_reg = as_Register($src$$reg);
 2667     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strb, src_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2668                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>






 2669   %}
 2670 
<span class="line-modified"> 2671   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2672   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2673   enc_class aarch64_enc_strb0(memory1 mem) %{</span>
 2674     MacroAssembler _masm(&amp;cbuf);

 2675     loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),
<span class="line-modified"> 2676                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
 2677   %}
 2678 
<span class="line-modified"> 2679   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2680   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2681   enc_class aarch64_enc_strh(iRegI src, memory2 mem) %{</span>
 2682     Register src_reg = as_Register($src$$reg);
 2683     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strh, src_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2684                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);</span>
 2685   %}
 2686 
<span class="line-modified"> 2687   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2688   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2689   enc_class aarch64_enc_strh0(memory2 mem) %{</span>
 2690     MacroAssembler _masm(&amp;cbuf);
 2691     loadStore(_masm, &amp;MacroAssembler::strh, zr, $mem-&gt;opcode(),
<span class="line-modified"> 2692                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);</span>
 2693   %}
 2694 
<span class="line-modified"> 2695   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2696   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2697   enc_class aarch64_enc_strw(iRegI src, memory4 mem) %{</span>
 2698     Register src_reg = as_Register($src$$reg);
 2699     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strw, src_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2700                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
 2701   %}
 2702 
<span class="line-modified"> 2703   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2704   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2705   enc_class aarch64_enc_strw0(memory4 mem) %{</span>
 2706     MacroAssembler _masm(&amp;cbuf);
 2707     loadStore(_masm, &amp;MacroAssembler::strw, zr, $mem-&gt;opcode(),
<span class="line-modified"> 2708                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
 2709   %}
 2710 
<span class="line-modified"> 2711   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2712   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2713   enc_class aarch64_enc_str(iRegL src, memory8 mem) %{</span>
 2714     Register src_reg = as_Register($src$$reg);
 2715     // we sometimes get asked to store the stack pointer into the
 2716     // current thread -- we cannot do that directly on AArch64
 2717     if (src_reg == r31_sp) {
 2718       MacroAssembler _masm(&amp;cbuf);
 2719       assert(as_Register($mem$$base) == rthread, &quot;unexpected store for sp&quot;);
 2720       __ mov(rscratch2, sp);
 2721       src_reg = rscratch2;
 2722     }
 2723     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2724                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);</span>
 2725   %}
 2726 
<span class="line-modified"> 2727   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2728   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2729   enc_class aarch64_enc_str0(memory8 mem) %{</span>
 2730     MacroAssembler _masm(&amp;cbuf);
 2731     loadStore(_masm, &amp;MacroAssembler::str, zr, $mem-&gt;opcode(),
<span class="line-modified"> 2732                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);</span>
 2733   %}
 2734 
<span class="line-modified"> 2735   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2736   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2737   enc_class aarch64_enc_strs(vRegF src, memory4 mem) %{</span>
 2738     FloatRegister src_reg = as_FloatRegister($src$$reg);
 2739     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strs, src_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2740                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
 2741   %}
 2742 
<span class="line-modified"> 2743   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2744   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2745   enc_class aarch64_enc_strd(vRegD src, memory8 mem) %{</span>
 2746     FloatRegister src_reg = as_FloatRegister($src$$reg);
 2747     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strd, src_reg, $mem-&gt;opcode(),
<span class="line-modified"> 2748                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);</span>
<span class="line-added"> 2749   %}</span>
<span class="line-added"> 2750 </span>
<span class="line-added"> 2751   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2752   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2753   enc_class aarch64_enc_strw_immn(immN src, memory1 mem) %{</span>
<span class="line-added"> 2754     MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-added"> 2755     address con = (address)$src$$constant;</span>
<span class="line-added"> 2756     // need to do this the hard way until we can manage relocs</span>
<span class="line-added"> 2757     // for 32 bit constants</span>
<span class="line-added"> 2758     __ movoop(rscratch2, (jobject)con);</span>
<span class="line-added"> 2759     if (con) __ encode_heap_oop_not_null(rscratch2);</span>
<span class="line-added"> 2760     loadStore(_masm, &amp;MacroAssembler::strw, rscratch2, $mem-&gt;opcode(),</span>
<span class="line-added"> 2761                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
<span class="line-added"> 2762   %}</span>
<span class="line-added"> 2763 </span>
<span class="line-added"> 2764   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2765   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2766   enc_class aarch64_enc_strw_immnk(immN src, memory4 mem) %{</span>
<span class="line-added"> 2767     MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-added"> 2768     address con = (address)$src$$constant;</span>
<span class="line-added"> 2769     // need to do this the hard way until we can manage relocs</span>
<span class="line-added"> 2770     // for 32 bit constants</span>
<span class="line-added"> 2771     __ movoop(rscratch2, (jobject)con);</span>
<span class="line-added"> 2772     __ encode_klass_not_null(rscratch2);</span>
<span class="line-added"> 2773     loadStore(_masm, &amp;MacroAssembler::strw, rscratch2, $mem-&gt;opcode(),</span>
<span class="line-added"> 2774                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
<span class="line-added"> 2775   %}</span>
<span class="line-added"> 2776 </span>
<span class="line-added"> 2777   // This encoding class is generated automatically from ad_encode.m4.</span>
<span class="line-added"> 2778   // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE</span>
<span class="line-added"> 2779   enc_class aarch64_enc_strb0_ordered(memory4 mem) %{</span>
<span class="line-added"> 2780       MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-added"> 2781       __ membar(Assembler::StoreStore);</span>
<span class="line-added"> 2782       loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),</span>
<span class="line-added"> 2783                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);</span>
<span class="line-added"> 2784   %}</span>
<span class="line-added"> 2785 </span>
<span class="line-added"> 2786   // END Non-volatile memory access</span>
<span class="line-added"> 2787 </span>
<span class="line-added"> 2788   // Vector loads and stores</span>
<span class="line-added"> 2789   enc_class aarch64_enc_ldrvS(vecD dst, memory mem) %{</span>
<span class="line-added"> 2790     FloatRegister dst_reg = as_FloatRegister($dst$$reg);</span>
<span class="line-added"> 2791     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::S,</span>
<span class="line-added"> 2792        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="line-added"> 2793   %}</span>
<span class="line-added"> 2794 </span>
<span class="line-added"> 2795   enc_class aarch64_enc_ldrvD(vecD dst, memory mem) %{</span>
<span class="line-added"> 2796     FloatRegister dst_reg = as_FloatRegister($dst$$reg);</span>
<span class="line-added"> 2797     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::D,</span>
<span class="line-added"> 2798        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
<span class="line-added"> 2799   %}</span>
<span class="line-added"> 2800 </span>
<span class="line-added"> 2801   enc_class aarch64_enc_ldrvQ(vecX dst, memory mem) %{</span>
<span class="line-added"> 2802     FloatRegister dst_reg = as_FloatRegister($dst$$reg);</span>
<span class="line-added"> 2803     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::Q,</span>
<span class="line-added"> 2804        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);</span>
 2805   %}
 2806 
 2807   enc_class aarch64_enc_strvS(vecD src, memory mem) %{
 2808     FloatRegister src_reg = as_FloatRegister($src$$reg);
 2809     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::S,
 2810        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
 2811   %}
 2812 
 2813   enc_class aarch64_enc_strvD(vecD src, memory mem) %{
 2814     FloatRegister src_reg = as_FloatRegister($src$$reg);
 2815     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::D,
 2816        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
 2817   %}
 2818 
 2819   enc_class aarch64_enc_strvQ(vecX src, memory mem) %{
 2820     FloatRegister src_reg = as_FloatRegister($src$$reg);
 2821     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::Q,
 2822        $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
 2823   %}
 2824 


 2825   // volatile loads and stores
 2826 
 2827   enc_class aarch64_enc_stlrb(iRegI src, memory mem) %{
 2828     MOV_VOLATILE(as_Register($src$$reg), $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
 2829                  rscratch1, stlrb);
 2830   %}
 2831 
 2832   enc_class aarch64_enc_stlrh(iRegI src, memory mem) %{
 2833     MOV_VOLATILE(as_Register($src$$reg), $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
 2834                  rscratch1, stlrh);
 2835   %}
 2836 
 2837   enc_class aarch64_enc_stlrw(iRegI src, memory mem) %{
 2838     MOV_VOLATILE(as_Register($src$$reg), $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
 2839                  rscratch1, stlrw);
 2840   %}
 2841 
 2842 
 2843   enc_class aarch64_enc_ldarsbw(iRegI dst, memory mem) %{
 2844     Register dst_reg = as_Register($dst$$reg);
</pre>
<hr />
<pre>
 2934       MacroAssembler _masm(&amp;cbuf);
 2935       FloatRegister src_reg = as_FloatRegister($src$$reg);
 2936       __ fmovs(rscratch2, src_reg);
 2937     }
 2938     MOV_VOLATILE(rscratch2, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
 2939                  rscratch1, stlrw);
 2940   %}
 2941 
 2942   enc_class aarch64_enc_fstlrd(vRegD src, memory mem) %{
 2943     {
 2944       MacroAssembler _masm(&amp;cbuf);
 2945       FloatRegister src_reg = as_FloatRegister($src$$reg);
 2946       __ fmovd(rscratch2, src_reg);
 2947     }
 2948     MOV_VOLATILE(rscratch2, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
 2949                  rscratch1, stlr);
 2950   %}
 2951 
 2952   // synchronized read/update encodings
 2953 
<span class="line-modified"> 2954   enc_class aarch64_enc_ldaxr(iRegL dst, memory8 mem) %{</span>
 2955     MacroAssembler _masm(&amp;cbuf);
 2956     Register dst_reg = as_Register($dst$$reg);
 2957     Register base = as_Register($mem$$base);
 2958     int index = $mem$$index;
 2959     int scale = $mem$$scale;
 2960     int disp = $mem$$disp;
 2961     if (index == -1) {
 2962        if (disp != 0) {
 2963         __ lea(rscratch1, Address(base, disp));
 2964         __ ldaxr(dst_reg, rscratch1);
 2965       } else {
 2966         // TODO
 2967         // should we ever get anything other than this case?
 2968         __ ldaxr(dst_reg, base);
 2969       }
 2970     } else {
 2971       Register index_reg = as_Register(index);
 2972       if (disp == 0) {
 2973         __ lea(rscratch1, Address(base, index_reg, Address::lsl(scale)));
 2974         __ ldaxr(dst_reg, rscratch1);
 2975       } else {
 2976         __ lea(rscratch1, Address(base, disp));
 2977         __ lea(rscratch1, Address(rscratch1, index_reg, Address::lsl(scale)));
 2978         __ ldaxr(dst_reg, rscratch1);
 2979       }
 2980     }
 2981   %}
 2982 
<span class="line-modified"> 2983   enc_class aarch64_enc_stlxr(iRegLNoSp src, memory8 mem) %{</span>
 2984     MacroAssembler _masm(&amp;cbuf);
 2985     Register src_reg = as_Register($src$$reg);
 2986     Register base = as_Register($mem$$base);
 2987     int index = $mem$$index;
 2988     int scale = $mem$$scale;
 2989     int disp = $mem$$disp;
 2990     if (index == -1) {
 2991        if (disp != 0) {
 2992         __ lea(rscratch2, Address(base, disp));
 2993         __ stlxr(rscratch1, src_reg, rscratch2);
 2994       } else {
 2995         // TODO
 2996         // should we ever get anything other than this case?
 2997         __ stlxr(rscratch1, src_reg, base);
 2998       }
 2999     } else {
 3000       Register index_reg = as_Register(index);
 3001       if (disp == 0) {
 3002         __ lea(rscratch2, Address(base, index_reg, Address::lsl(scale)));
 3003         __ stlxr(rscratch1, src_reg, rscratch2);
</pre>
<hr />
<pre>
 3429     address call = __ ic_call((address)$meth$$method, method_index);
 3430     if (call == NULL) {
 3431       ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 3432       return;
 3433     }
 3434   %}
 3435 
 3436   enc_class aarch64_enc_call_epilog() %{
 3437     MacroAssembler _masm(&amp;cbuf);
 3438     if (VerifyStackAtCalls) {
 3439       // Check that stack depth is unchanged: find majik cookie on stack
 3440       __ call_Unimplemented();
 3441     }
 3442   %}
 3443 
 3444   enc_class aarch64_enc_java_to_runtime(method meth) %{
 3445     MacroAssembler _masm(&amp;cbuf);
 3446 
 3447     // some calls to generated routines (arraycopy code) are scheduled
 3448     // by C2 as runtime calls. if so we can call them using a br (they
<span class="line-modified"> 3449     // will be in a reachable segment) otherwise we have to use a blr</span>
 3450     // which loads the absolute address into a register.
 3451     address entry = (address)$meth$$method;
 3452     CodeBlob *cb = CodeCache::find_blob(entry);
 3453     if (cb) {
 3454       address call = __ trampoline_call(Address(entry, relocInfo::runtime_call_type));
 3455       if (call == NULL) {
 3456         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 3457         return;
 3458       }
 3459     } else {




 3460       Label retaddr;
 3461       __ adr(rscratch2, retaddr);
 3462       __ lea(rscratch1, RuntimeAddress(entry));
 3463       // Leave a breadcrumb for JavaFrameAnchor::capture_last_Java_pc()
 3464       __ stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)));
<span class="line-modified"> 3465       __ blr(rscratch1);</span>
 3466       __ bind(retaddr);
 3467       __ add(sp, sp, 2 * wordSize);
 3468     }
 3469   %}
 3470 
 3471   enc_class aarch64_enc_rethrow() %{
 3472     MacroAssembler _masm(&amp;cbuf);
 3473     __ far_jump(RuntimeAddress(OptoRuntime::rethrow_stub()));
 3474   %}
 3475 
 3476   enc_class aarch64_enc_ret() %{
 3477     MacroAssembler _masm(&amp;cbuf);
 3478     __ ret(lr);
 3479   %}
 3480 
 3481   enc_class aarch64_enc_tail_call(iRegP jump_target) %{
 3482     MacroAssembler _masm(&amp;cbuf);
 3483     Register target_reg = as_Register($jump_target$$reg);
 3484     __ br(target_reg);
 3485   %}
</pre>
<hr />
<pre>
 3489     Register target_reg = as_Register($jump_target$$reg);
 3490     // exception oop should be in r0
 3491     // ret addr has been popped into lr
 3492     // callee expects it in r3
 3493     __ mov(r3, lr);
 3494     __ br(target_reg);
 3495   %}
 3496 
 3497   enc_class aarch64_enc_fast_lock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{
 3498     MacroAssembler _masm(&amp;cbuf);
 3499     Register oop = as_Register($object$$reg);
 3500     Register box = as_Register($box$$reg);
 3501     Register disp_hdr = as_Register($tmp$$reg);
 3502     Register tmp = as_Register($tmp2$$reg);
 3503     Label cont;
 3504     Label object_has_monitor;
 3505     Label cas_failed;
 3506 
 3507     assert_different_registers(oop, box, tmp, disp_hdr);
 3508 
<span class="line-modified"> 3509     // Load markWord from object into displaced_header.</span>
 3510     __ ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));
 3511 
 3512     if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
 3513       __ biased_locking_enter(box, oop, disp_hdr, tmp, true, cont);
 3514     }
 3515 
 3516     // Check for existing monitor
<span class="line-modified"> 3517     __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);</span>
 3518 
<span class="line-modified"> 3519     // Set tmp to be (markWord of object | UNLOCK_VALUE).</span>
<span class="line-modified"> 3520     __ orr(tmp, disp_hdr, markWord::unlocked_value);</span>
 3521 
 3522     // Initialize the box. (Must happen before we update the object mark!)
 3523     __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));
 3524 
<span class="line-modified"> 3525     // Compare object markWord with an unlocked value (tmp) and if</span>
<span class="line-modified"> 3526     // equal exchange the stack address of our box with object markWord.</span>
<span class="line-modified"> 3527     // On failure disp_hdr contains the possibly locked markWord.</span>
 3528     __ cmpxchg(oop, tmp, box, Assembler::xword, /*acquire*/ true,
 3529                /*release*/ true, /*weak*/ false, disp_hdr);
 3530     __ br(Assembler::EQ, cont);
 3531 
 3532     assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
 3533 
 3534     // If the compare-and-exchange succeeded, then we found an unlocked
 3535     // object, will have now locked it will continue at label cont
 3536 
 3537     __ bind(cas_failed);
 3538     // We did not see an unlocked object so try the fast recursive case.
 3539 
 3540     // Check if the owner is self by comparing the value in the
<span class="line-modified"> 3541     // markWord of object (disp_hdr) with the stack pointer.</span>
 3542     __ mov(rscratch1, sp);
 3543     __ sub(disp_hdr, disp_hdr, rscratch1);
<span class="line-modified"> 3544     __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));</span>
 3545     // If condition is true we are cont and hence we can store 0 as the
 3546     // displaced header in the box, which indicates that it is a recursive lock.
 3547     __ ands(tmp/*==0?*/, disp_hdr, tmp);   // Sets flags for result
 3548     __ str(tmp/*==0, perhaps*/, Address(box, BasicLock::displaced_header_offset_in_bytes()));
 3549 
 3550     __ b(cont);
 3551 
 3552     // Handle existing monitor.
 3553     __ bind(object_has_monitor);
 3554 
 3555     // The object&#39;s monitor m is unlocked iff m-&gt;owner == NULL,
 3556     // otherwise m-&gt;owner may contain a thread or a stack address.
 3557     //
 3558     // Try to CAS m-&gt;owner from NULL to current thread.
<span class="line-modified"> 3559     __ add(tmp, disp_hdr, (ObjectMonitor::owner_offset_in_bytes()-markWord::monitor_value));</span>
 3560     __ cmpxchg(tmp, zr, rthread, Assembler::xword, /*acquire*/ true,
 3561                /*release*/ true, /*weak*/ false, noreg); // Sets flags for result
 3562 
 3563     // Store a non-null value into the box to avoid looking like a re-entrant
 3564     // lock. The fast-path monitor unlock code checks for
<span class="line-modified"> 3565     // markWord::monitor_value so use markWord::unused_mark which has the</span>
<span class="line-modified"> 3566     // relevant bit set, and also matches ObjectSynchronizer::enter.</span>
<span class="line-modified"> 3567     __ mov(tmp, (address)markWord::unused_mark().value());</span>
 3568     __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));
 3569 
 3570     __ bind(cont);
 3571     // flag == EQ indicates success
 3572     // flag == NE indicates failure
 3573   %}
 3574 
 3575   enc_class aarch64_enc_fast_unlock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{
 3576     MacroAssembler _masm(&amp;cbuf);
 3577     Register oop = as_Register($object$$reg);
 3578     Register box = as_Register($box$$reg);
 3579     Register disp_hdr = as_Register($tmp$$reg);
 3580     Register tmp = as_Register($tmp2$$reg);
 3581     Label cont;
 3582     Label object_has_monitor;
 3583 
 3584     assert_different_registers(oop, box, tmp, disp_hdr);
 3585 
 3586     if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
 3587       __ biased_locking_exit(oop, tmp, cont);
 3588     }
 3589 
 3590     // Find the lock address and load the displaced header from the stack.
 3591     __ ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));
 3592 
 3593     // If the displaced header is 0, we have a recursive unlock.
 3594     __ cmp(disp_hdr, zr);
 3595     __ br(Assembler::EQ, cont);
 3596 
 3597     // Handle existing monitor.
 3598     __ ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));
<span class="line-modified"> 3599     __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);</span>
 3600 
 3601     // Check if it is still a light weight lock, this is is true if we
<span class="line-modified"> 3602     // see the stack address of the basicLock in the markWord of the</span>
 3603     // object.
 3604 
 3605     __ cmpxchg(oop, box, disp_hdr, Assembler::xword, /*acquire*/ false,
 3606                /*release*/ true, /*weak*/ false, tmp);
 3607     __ b(cont);
 3608 
 3609     assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
 3610 
 3611     // Handle existing monitor.
 3612     __ bind(object_has_monitor);
<span class="line-modified"> 3613     STATIC_ASSERT(markWord::monitor_value &lt;= INT_MAX);</span>
<span class="line-added"> 3614     __ add(tmp, tmp, -(int)markWord::monitor_value); // monitor</span>
 3615     __ ldr(rscratch1, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));
 3616     __ ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));
 3617     __ eor(rscratch1, rscratch1, rthread); // Will be 0 if we are the owner.
 3618     __ orr(rscratch1, rscratch1, disp_hdr); // Will be 0 if there are 0 recursions
 3619     __ cmp(rscratch1, zr); // Sets flags for result
 3620     __ br(Assembler::NE, cont);
 3621 
 3622     __ ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset_in_bytes()));
 3623     __ ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset_in_bytes()));
 3624     __ orr(rscratch1, rscratch1, disp_hdr); // Will be 0 if both are 0.
 3625     __ cmp(rscratch1, zr); // Sets flags for result
 3626     __ cbnz(rscratch1, cont);
 3627     // need a release store here
 3628     __ lea(tmp, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));
 3629     __ stlr(zr, tmp); // set unowned
 3630 
 3631     __ bind(cont);
 3632     // flag == EQ indicates success
 3633     // flag == NE indicates failure
 3634   %}
</pre>
<hr />
<pre>
 3768   return_value
 3769   %{
 3770     // TODO do we allow ideal_reg == Op_RegN???
 3771     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 3772            &quot;only return normal values&quot;);
 3773 
 3774     static const int lo[Op_RegL + 1] = { // enum name
 3775       0,                                 // Op_Node
 3776       0,                                 // Op_Set
 3777       R0_num,                            // Op_RegN
 3778       R0_num,                            // Op_RegI
 3779       R0_num,                            // Op_RegP
 3780       V0_num,                            // Op_RegF
 3781       V0_num,                            // Op_RegD
 3782       R0_num                             // Op_RegL
 3783     };
 3784 
 3785     static const int hi[Op_RegL + 1] = { // enum name
 3786       0,                                 // Op_Node
 3787       0,                                 // Op_Set
<span class="line-modified"> 3788       OptoReg::Bad,                      // Op_RegN</span>
 3789       OptoReg::Bad,                      // Op_RegI
 3790       R0_H_num,                          // Op_RegP
 3791       OptoReg::Bad,                      // Op_RegF
 3792       V0_H_num,                          // Op_RegD
 3793       R0_H_num                           // Op_RegL
 3794     };
 3795 
 3796     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 3797   %}
 3798 %}
 3799 
 3800 //----------ATTRIBUTES---------------------------------------------------------
 3801 //----------Operand Attributes-------------------------------------------------
 3802 op_attrib op_cost(1);        // Required cost attribute
 3803 
 3804 //----------Instruction Attributes---------------------------------------------
 3805 ins_attrib ins_cost(INSN_COST); // Required cost attribute
 3806 ins_attrib ins_size(32);        // Required size attribute (in bits)
 3807 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 3808                                 // a non-matching short branch variant
</pre>
<hr />
<pre>
 4012   predicate(n-&gt;get_long() == 65535L);
 4013   match(ConL);
 4014 
 4015   op_cost(0);
 4016   format %{ %}
 4017   interface(CONST_INTER);
 4018 %}
 4019 
 4020 operand immL_4294967295()
 4021 %{
 4022   predicate(n-&gt;get_long() == 4294967295L);
 4023   match(ConL);
 4024 
 4025   op_cost(0);
 4026   format %{ %}
 4027   interface(CONST_INTER);
 4028 %}
 4029 
 4030 operand immL_bitmask()
 4031 %{
<span class="line-modified"> 4032   predicate((n-&gt;get_long() != 0)</span>
<span class="line-added"> 4033             &amp;&amp; ((n-&gt;get_long() &amp; 0xc000000000000000l) == 0)</span>
 4034             &amp;&amp; is_power_of_2(n-&gt;get_long() + 1));
 4035   match(ConL);
 4036 
 4037   op_cost(0);
 4038   format %{ %}
 4039   interface(CONST_INTER);
 4040 %}
 4041 
 4042 operand immI_bitmask()
 4043 %{
<span class="line-modified"> 4044   predicate((n-&gt;get_int() != 0)</span>
<span class="line-added"> 4045             &amp;&amp; ((n-&gt;get_int() &amp; 0xc0000000) == 0)</span>
 4046             &amp;&amp; is_power_of_2(n-&gt;get_int() + 1));
 4047   match(ConI);
 4048 
 4049   op_cost(0);
 4050   format %{ %}
 4051   interface(CONST_INTER);
 4052 %}
 4053 
 4054 // Scale values for scaled offset addressing modes (up to long but not quad)
 4055 operand immIScale()
 4056 %{
 4057   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 4058   match(ConI);
 4059 
 4060   op_cost(0);
 4061   format %{ %}
 4062   interface(CONST_INTER);
 4063 %}
 4064 
 4065 // 26 bit signed offset -- for pc-relative branches
</pre>
<hr />
<pre>
 4091   match(ConI);
 4092 
 4093   op_cost(0);
 4094   format %{ %}
 4095   interface(CONST_INTER);
 4096 %}
 4097 
 4098 operand immLU12()
 4099 %{
 4100   predicate((0 &lt;= n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() &lt; (1 &lt;&lt; 12)));
 4101   match(ConL);
 4102 
 4103   op_cost(0);
 4104   format %{ %}
 4105   interface(CONST_INTER);
 4106 %}
 4107 
 4108 // Offset for scaled or unscaled immediate loads and stores
 4109 operand immIOffset()
 4110 %{
<span class="line-modified"> 4111   predicate(Address::offset_ok_for_immed(n-&gt;get_int(), 0));</span>
<span class="line-added"> 4112   match(ConI);</span>
<span class="line-added"> 4113 </span>
<span class="line-added"> 4114   op_cost(0);</span>
<span class="line-added"> 4115   format %{ %}</span>
<span class="line-added"> 4116   interface(CONST_INTER);</span>
<span class="line-added"> 4117 %}</span>
<span class="line-added"> 4118 </span>
<span class="line-added"> 4119 operand immIOffset1()</span>
<span class="line-added"> 4120 %{</span>
<span class="line-added"> 4121   predicate(Address::offset_ok_for_immed(n-&gt;get_int(), 0));</span>
<span class="line-added"> 4122   match(ConI);</span>
<span class="line-added"> 4123 </span>
<span class="line-added"> 4124   op_cost(0);</span>
<span class="line-added"> 4125   format %{ %}</span>
<span class="line-added"> 4126   interface(CONST_INTER);</span>
<span class="line-added"> 4127 %}</span>
<span class="line-added"> 4128 </span>
<span class="line-added"> 4129 operand immIOffset2()</span>
<span class="line-added"> 4130 %{</span>
<span class="line-added"> 4131   predicate(Address::offset_ok_for_immed(n-&gt;get_int(), 1));</span>
 4132   match(ConI);
 4133 
 4134   op_cost(0);
 4135   format %{ %}
 4136   interface(CONST_INTER);
 4137 %}
 4138 
 4139 operand immIOffset4()
 4140 %{
 4141   predicate(Address::offset_ok_for_immed(n-&gt;get_int(), 2));
 4142   match(ConI);
 4143 
 4144   op_cost(0);
 4145   format %{ %}
 4146   interface(CONST_INTER);
 4147 %}
 4148 
 4149 operand immIOffset8()
 4150 %{
 4151   predicate(Address::offset_ok_for_immed(n-&gt;get_int(), 3));
 4152   match(ConI);
 4153 
 4154   op_cost(0);
 4155   format %{ %}
 4156   interface(CONST_INTER);
 4157 %}
 4158 
 4159 operand immIOffset16()
 4160 %{
 4161   predicate(Address::offset_ok_for_immed(n-&gt;get_int(), 4));
 4162   match(ConI);
 4163 
 4164   op_cost(0);
 4165   format %{ %}
 4166   interface(CONST_INTER);
 4167 %}
 4168 
 4169 operand immLoffset()
 4170 %{
<span class="line-modified"> 4171   predicate(Address::offset_ok_for_immed(n-&gt;get_long(), 0));</span>
<span class="line-added"> 4172   match(ConL);</span>
<span class="line-added"> 4173 </span>
<span class="line-added"> 4174   op_cost(0);</span>
<span class="line-added"> 4175   format %{ %}</span>
<span class="line-added"> 4176   interface(CONST_INTER);</span>
<span class="line-added"> 4177 %}</span>
<span class="line-added"> 4178 </span>
<span class="line-added"> 4179 operand immLoffset1()</span>
<span class="line-added"> 4180 %{</span>
<span class="line-added"> 4181   predicate(Address::offset_ok_for_immed(n-&gt;get_long(), 0));</span>
<span class="line-added"> 4182   match(ConL);</span>
<span class="line-added"> 4183 </span>
<span class="line-added"> 4184   op_cost(0);</span>
<span class="line-added"> 4185   format %{ %}</span>
<span class="line-added"> 4186   interface(CONST_INTER);</span>
<span class="line-added"> 4187 %}</span>
<span class="line-added"> 4188 </span>
<span class="line-added"> 4189 operand immLoffset2()</span>
<span class="line-added"> 4190 %{</span>
<span class="line-added"> 4191   predicate(Address::offset_ok_for_immed(n-&gt;get_long(), 1));</span>
 4192   match(ConL);
 4193 
 4194   op_cost(0);
 4195   format %{ %}
 4196   interface(CONST_INTER);
 4197 %}
 4198 
 4199 operand immLoffset4()
 4200 %{
 4201   predicate(Address::offset_ok_for_immed(n-&gt;get_long(), 2));
 4202   match(ConL);
 4203 
 4204   op_cost(0);
 4205   format %{ %}
 4206   interface(CONST_INTER);
 4207 %}
 4208 
 4209 operand immLoffset8()
 4210 %{
 4211   predicate(Address::offset_ok_for_immed(n-&gt;get_long(), 3));
</pre>
<hr />
<pre>
 4754   match(RegI);
 4755   match(iRegINoSp);
 4756   op_cost(0);
 4757   format %{ %}
 4758   interface(REG_INTER);
 4759 %}
 4760 
 4761 
 4762 // Register R4 only
 4763 operand iRegI_R4()
 4764 %{
 4765   constraint(ALLOC_IN_RC(int_r4_reg));
 4766   match(RegI);
 4767   match(iRegINoSp);
 4768   op_cost(0);
 4769   format %{ %}
 4770   interface(REG_INTER);
 4771 %}
 4772 
 4773 
<span class="line-modified"> 4774 // Pointer Register Operands</span>
<span class="line-modified"> 4775 // Narrow Pointer Register</span>
<span class="line-modified"> 4776 operand iRegN()</span>
<span class="line-added"> 4777 %{</span>
<span class="line-added"> 4778   constraint(ALLOC_IN_RC(any_reg32));</span>
<span class="line-added"> 4779   match(RegN);</span>
<span class="line-added"> 4780   match(iRegNNoSp);</span>
<span class="line-added"> 4781   op_cost(0);</span>
<span class="line-added"> 4782   format %{ %}</span>
<span class="line-added"> 4783   interface(REG_INTER);</span>
<span class="line-added"> 4784 %}</span>
<span class="line-added"> 4785 </span>
<span class="line-added"> 4786 operand iRegN_R0()</span>
<span class="line-added"> 4787 %{</span>
<span class="line-added"> 4788   constraint(ALLOC_IN_RC(r0_reg));</span>
<span class="line-added"> 4789   match(iRegN);</span>
<span class="line-added"> 4790   op_cost(0);</span>
<span class="line-added"> 4791   format %{ %}</span>
<span class="line-added"> 4792   interface(REG_INTER);</span>
<span class="line-added"> 4793 %}</span>
<span class="line-added"> 4794 </span>
<span class="line-added"> 4795 operand iRegN_R2()</span>
<span class="line-added"> 4796 %{</span>
<span class="line-added"> 4797   constraint(ALLOC_IN_RC(r2_reg));</span>
<span class="line-added"> 4798   match(iRegN);</span>
<span class="line-added"> 4799   op_cost(0);</span>
<span class="line-added"> 4800   format %{ %}</span>
<span class="line-added"> 4801   interface(REG_INTER);</span>
<span class="line-added"> 4802 %}</span>
<span class="line-added"> 4803 </span>
<span class="line-added"> 4804 operand iRegN_R3()</span>
<span class="line-added"> 4805 %{</span>
<span class="line-added"> 4806   constraint(ALLOC_IN_RC(r3_reg));</span>
<span class="line-added"> 4807   match(iRegN);</span>
<span class="line-added"> 4808   op_cost(0);</span>
<span class="line-added"> 4809   format %{ %}</span>
<span class="line-added"> 4810   interface(REG_INTER);</span>
<span class="line-added"> 4811 %}</span>
<span class="line-added"> 4812 </span>
<span class="line-added"> 4813 // Integer 64 bit Register not Special</span>
<span class="line-added"> 4814 operand iRegNNoSp()</span>
<span class="line-added"> 4815 %{</span>
<span class="line-added"> 4816   constraint(ALLOC_IN_RC(no_special_reg32));</span>
<span class="line-added"> 4817   match(RegN);</span>
<span class="line-added"> 4818   op_cost(0);</span>
<span class="line-added"> 4819   format %{ %}</span>
<span class="line-added"> 4820   interface(REG_INTER);</span>
<span class="line-added"> 4821 %}</span>
<span class="line-added"> 4822 </span>
<span class="line-added"> 4823 // heap base register -- used for encoding immN0</span>
<span class="line-added"> 4824 </span>
<span class="line-added"> 4825 operand iRegIHeapbase()</span>
<span class="line-added"> 4826 %{</span>
<span class="line-added"> 4827   constraint(ALLOC_IN_RC(heapbase_reg));</span>
<span class="line-added"> 4828   match(RegI);</span>
<span class="line-added"> 4829   op_cost(0);</span>
<span class="line-added"> 4830   format %{ %}</span>
<span class="line-added"> 4831   interface(REG_INTER);</span>
<span class="line-added"> 4832 %}</span>
<span class="line-added"> 4833 </span>
<span class="line-added"> 4834 // Float Register</span>
<span class="line-added"> 4835 // Float register operands</span>
<span class="line-added"> 4836 operand vRegF()</span>
<span class="line-added"> 4837 %{</span>
<span class="line-added"> 4838   constraint(ALLOC_IN_RC(float_reg));</span>
<span class="line-added"> 4839   match(RegF);</span>
<span class="line-added"> 4840 </span>
<span class="line-added"> 4841   op_cost(0);</span>
<span class="line-added"> 4842   format %{ %}</span>
<span class="line-added"> 4843   interface(REG_INTER);</span>
<span class="line-added"> 4844 %}</span>
<span class="line-added"> 4845 </span>
<span class="line-added"> 4846 // Double Register</span>
<span class="line-added"> 4847 // Double register operands</span>
<span class="line-added"> 4848 operand vRegD()</span>
<span class="line-added"> 4849 %{</span>
<span class="line-added"> 4850   constraint(ALLOC_IN_RC(double_reg));</span>
<span class="line-added"> 4851   match(RegD);</span>
<span class="line-added"> 4852 </span>
<span class="line-added"> 4853   op_cost(0);</span>
<span class="line-added"> 4854   format %{ %}</span>
<span class="line-added"> 4855   interface(REG_INTER);</span>
<span class="line-added"> 4856 %}</span>
<span class="line-added"> 4857 </span>
<span class="line-added"> 4858 operand vecD()</span>
<span class="line-added"> 4859 %{</span>
<span class="line-added"> 4860   constraint(ALLOC_IN_RC(vectord_reg));</span>
<span class="line-added"> 4861   match(VecD);</span>
<span class="line-added"> 4862 </span>
<span class="line-added"> 4863   op_cost(0);</span>
<span class="line-added"> 4864   format %{ %}</span>
<span class="line-added"> 4865   interface(REG_INTER);</span>
<span class="line-added"> 4866 %}</span>
<span class="line-added"> 4867 </span>
<span class="line-added"> 4868 operand vecX()</span>
<span class="line-added"> 4869 %{</span>
<span class="line-added"> 4870   constraint(ALLOC_IN_RC(vectorx_reg));</span>
<span class="line-added"> 4871   match(VecX);</span>
<span class="line-added"> 4872 </span>
<span class="line-added"> 4873   op_cost(0);</span>
<span class="line-added"> 4874   format %{ %}</span>
<span class="line-added"> 4875   interface(REG_INTER);</span>
<span class="line-added"> 4876 %}</span>
<span class="line-added"> 4877 </span>
<span class="line-added"> 4878 operand vRegD_V0()</span>
<span class="line-added"> 4879 %{</span>
<span class="line-added"> 4880   constraint(ALLOC_IN_RC(v0_reg));</span>
<span class="line-added"> 4881   match(RegD);</span>
<span class="line-added"> 4882   op_cost(0);</span>
<span class="line-added"> 4883   format %{ %}</span>
<span class="line-added"> 4884   interface(REG_INTER);</span>
<span class="line-added"> 4885 %}</span>
<span class="line-added"> 4886 </span>
<span class="line-added"> 4887 operand vRegD_V1()</span>
<span class="line-added"> 4888 %{</span>
<span class="line-added"> 4889   constraint(ALLOC_IN_RC(v1_reg));</span>
<span class="line-added"> 4890   match(RegD);</span>
<span class="line-added"> 4891   op_cost(0);</span>
<span class="line-added"> 4892   format %{ %}</span>
<span class="line-added"> 4893   interface(REG_INTER);</span>
<span class="line-added"> 4894 %}</span>
<span class="line-added"> 4895 </span>
<span class="line-added"> 4896 operand vRegD_V2()</span>
<span class="line-added"> 4897 %{</span>
<span class="line-added"> 4898   constraint(ALLOC_IN_RC(v2_reg));</span>
<span class="line-added"> 4899   match(RegD);</span>
<span class="line-added"> 4900   op_cost(0);</span>
<span class="line-added"> 4901   format %{ %}</span>
<span class="line-added"> 4902   interface(REG_INTER);</span>
<span class="line-added"> 4903 %}</span>
<span class="line-added"> 4904 </span>
<span class="line-added"> 4905 operand vRegD_V3()</span>
<span class="line-added"> 4906 %{</span>
<span class="line-added"> 4907   constraint(ALLOC_IN_RC(v3_reg));</span>
<span class="line-added"> 4908   match(RegD);</span>
<span class="line-added"> 4909   op_cost(0);</span>
<span class="line-added"> 4910   format %{ %}</span>
<span class="line-added"> 4911   interface(REG_INTER);</span>
<span class="line-added"> 4912 %}</span>
<span class="line-added"> 4913 </span>
<span class="line-added"> 4914 operand vRegD_V4()</span>
<span class="line-added"> 4915 %{</span>
<span class="line-added"> 4916   constraint(ALLOC_IN_RC(v4_reg));</span>
<span class="line-added"> 4917   match(RegD);</span>
<span class="line-added"> 4918   op_cost(0);</span>
<span class="line-added"> 4919   format %{ %}</span>
<span class="line-added"> 4920   interface(REG_INTER);</span>
<span class="line-added"> 4921 %}</span>
<span class="line-added"> 4922 </span>
<span class="line-added"> 4923 operand vRegD_V5()</span>
<span class="line-added"> 4924 %{</span>
<span class="line-added"> 4925   constraint(ALLOC_IN_RC(v5_reg));</span>
<span class="line-added"> 4926   match(RegD);</span>
<span class="line-added"> 4927   op_cost(0);</span>
<span class="line-added"> 4928   format %{ %}</span>
<span class="line-added"> 4929   interface(REG_INTER);</span>
<span class="line-added"> 4930 %}</span>
<span class="line-added"> 4931 </span>
<span class="line-added"> 4932 operand vRegD_V6()</span>
<span class="line-added"> 4933 %{</span>
<span class="line-added"> 4934   constraint(ALLOC_IN_RC(v6_reg));</span>
<span class="line-added"> 4935   match(RegD);</span>
<span class="line-added"> 4936   op_cost(0);</span>
<span class="line-added"> 4937   format %{ %}</span>
<span class="line-added"> 4938   interface(REG_INTER);</span>
<span class="line-added"> 4939 %}</span>
<span class="line-added"> 4940 </span>
<span class="line-added"> 4941 operand vRegD_V7()</span>
<span class="line-added"> 4942 %{</span>
<span class="line-added"> 4943   constraint(ALLOC_IN_RC(v7_reg));</span>
<span class="line-added"> 4944   match(RegD);</span>
<span class="line-added"> 4945   op_cost(0);</span>
<span class="line-added"> 4946   format %{ %}</span>
<span class="line-added"> 4947   interface(REG_INTER);</span>
<span class="line-added"> 4948 %}</span>
<span class="line-added"> 4949 </span>
<span class="line-added"> 4950 operand vRegD_V8()</span>
<span class="line-added"> 4951 %{</span>
<span class="line-added"> 4952   constraint(ALLOC_IN_RC(v8_reg));</span>
<span class="line-added"> 4953   match(RegD);</span>
<span class="line-added"> 4954   op_cost(0);</span>
<span class="line-added"> 4955   format %{ %}</span>
<span class="line-added"> 4956   interface(REG_INTER);</span>
<span class="line-added"> 4957 %}</span>
<span class="line-added"> 4958 </span>
<span class="line-added"> 4959 operand vRegD_V9()</span>
<span class="line-added"> 4960 %{</span>
<span class="line-added"> 4961   constraint(ALLOC_IN_RC(v9_reg));</span>
<span class="line-added"> 4962   match(RegD);</span>
<span class="line-added"> 4963   op_cost(0);</span>
<span class="line-added"> 4964   format %{ %}</span>
<span class="line-added"> 4965   interface(REG_INTER);</span>
<span class="line-added"> 4966 %}</span>
<span class="line-added"> 4967 </span>
<span class="line-added"> 4968 operand vRegD_V10()</span>
<span class="line-added"> 4969 %{</span>
<span class="line-added"> 4970   constraint(ALLOC_IN_RC(v10_reg));</span>
<span class="line-added"> 4971   match(RegD);</span>
<span class="line-added"> 4972   op_cost(0);</span>
<span class="line-added"> 4973   format %{ %}</span>
<span class="line-added"> 4974   interface(REG_INTER);</span>
<span class="line-added"> 4975 %}</span>
<span class="line-added"> 4976 </span>
<span class="line-added"> 4977 operand vRegD_V11()</span>
<span class="line-added"> 4978 %{</span>
<span class="line-added"> 4979   constraint(ALLOC_IN_RC(v11_reg));</span>
<span class="line-added"> 4980   match(RegD);</span>
<span class="line-added"> 4981   op_cost(0);</span>
<span class="line-added"> 4982   format %{ %}</span>
<span class="line-added"> 4983   interface(REG_INTER);</span>
<span class="line-added"> 4984 %}</span>
<span class="line-added"> 4985 </span>
<span class="line-added"> 4986 operand vRegD_V12()</span>
<span class="line-added"> 4987 %{</span>
<span class="line-added"> 4988   constraint(ALLOC_IN_RC(v12_reg));</span>
<span class="line-added"> 4989   match(RegD);</span>
<span class="line-added"> 4990   op_cost(0);</span>
<span class="line-added"> 4991   format %{ %}</span>
<span class="line-added"> 4992   interface(REG_INTER);</span>
<span class="line-added"> 4993 %}</span>
<span class="line-added"> 4994 </span>
<span class="line-added"> 4995 operand vRegD_V13()</span>
<span class="line-added"> 4996 %{</span>
<span class="line-added"> 4997   constraint(ALLOC_IN_RC(v13_reg));</span>
<span class="line-added"> 4998   match(RegD);</span>
<span class="line-added"> 4999   op_cost(0);</span>
<span class="line-added"> 5000   format %{ %}</span>
<span class="line-added"> 5001   interface(REG_INTER);</span>
<span class="line-added"> 5002 %}</span>
<span class="line-added"> 5003 </span>
<span class="line-added"> 5004 operand vRegD_V14()</span>
<span class="line-added"> 5005 %{</span>
<span class="line-added"> 5006   constraint(ALLOC_IN_RC(v14_reg));</span>
<span class="line-added"> 5007   match(RegD);</span>
<span class="line-added"> 5008   op_cost(0);</span>
<span class="line-added"> 5009   format %{ %}</span>
<span class="line-added"> 5010   interface(REG_INTER);</span>
<span class="line-added"> 5011 %}</span>
<span class="line-added"> 5012 </span>
<span class="line-added"> 5013 operand vRegD_V15()</span>
<span class="line-added"> 5014 %{</span>
<span class="line-added"> 5015   constraint(ALLOC_IN_RC(v15_reg));</span>
<span class="line-added"> 5016   match(RegD);</span>
<span class="line-added"> 5017   op_cost(0);</span>
<span class="line-added"> 5018   format %{ %}</span>
<span class="line-added"> 5019   interface(REG_INTER);</span>
<span class="line-added"> 5020 %}</span>
<span class="line-added"> 5021 </span>
<span class="line-added"> 5022 operand vRegD_V16()</span>
<span class="line-added"> 5023 %{</span>
<span class="line-added"> 5024   constraint(ALLOC_IN_RC(v16_reg));</span>
<span class="line-added"> 5025   match(RegD);</span>
<span class="line-added"> 5026   op_cost(0);</span>
<span class="line-added"> 5027   format %{ %}</span>
<span class="line-added"> 5028   interface(REG_INTER);</span>
<span class="line-added"> 5029 %}</span>
<span class="line-added"> 5030 </span>
<span class="line-added"> 5031 operand vRegD_V17()</span>
<span class="line-added"> 5032 %{</span>
<span class="line-added"> 5033   constraint(ALLOC_IN_RC(v17_reg));</span>
<span class="line-added"> 5034   match(RegD);</span>
<span class="line-added"> 5035   op_cost(0);</span>
<span class="line-added"> 5036   format %{ %}</span>
<span class="line-added"> 5037   interface(REG_INTER);</span>
<span class="line-added"> 5038 %}</span>
<span class="line-added"> 5039 </span>
<span class="line-added"> 5040 operand vRegD_V18()</span>
 5041 %{
<span class="line-modified"> 5042   constraint(ALLOC_IN_RC(v18_reg));</span>
<span class="line-modified"> 5043   match(RegD);</span>

 5044   op_cost(0);
 5045   format %{ %}
 5046   interface(REG_INTER);
 5047 %}
 5048 
<span class="line-modified"> 5049 operand vRegD_V19()</span>
 5050 %{
<span class="line-modified"> 5051   constraint(ALLOC_IN_RC(v19_reg));</span>
<span class="line-modified"> 5052   match(RegD);</span>
 5053   op_cost(0);
 5054   format %{ %}
 5055   interface(REG_INTER);
 5056 %}
 5057 
<span class="line-modified"> 5058 operand vRegD_V20()</span>
 5059 %{
<span class="line-modified"> 5060   constraint(ALLOC_IN_RC(v20_reg));</span>
<span class="line-modified"> 5061   match(RegD);</span>
 5062   op_cost(0);
 5063   format %{ %}
 5064   interface(REG_INTER);
 5065 %}
 5066 
<span class="line-modified"> 5067 operand vRegD_V21()</span>
 5068 %{
<span class="line-modified"> 5069   constraint(ALLOC_IN_RC(v21_reg));</span>
<span class="line-modified"> 5070   match(RegD);</span>
 5071   op_cost(0);
 5072   format %{ %}
 5073   interface(REG_INTER);
 5074 %}
 5075 
<span class="line-modified"> 5076 operand vRegD_V22()</span>

 5077 %{
<span class="line-modified"> 5078   constraint(ALLOC_IN_RC(v22_reg));</span>
<span class="line-modified"> 5079   match(RegD);</span>
 5080   op_cost(0);
 5081   format %{ %}
 5082   interface(REG_INTER);
 5083 %}
 5084 
<span class="line-modified"> 5085 operand vRegD_V23()</span>


 5086 %{
<span class="line-modified"> 5087   constraint(ALLOC_IN_RC(v23_reg));</span>
<span class="line-modified"> 5088   match(RegD);</span>
 5089   op_cost(0);
 5090   format %{ %}
 5091   interface(REG_INTER);
 5092 %}
 5093 
<span class="line-modified"> 5094 operand vRegD_V24()</span>


 5095 %{
<span class="line-modified"> 5096   constraint(ALLOC_IN_RC(v24_reg));</span>
<span class="line-modified"> 5097   match(RegD);</span>

 5098   op_cost(0);
 5099   format %{ %}
 5100   interface(REG_INTER);
 5101 %}
 5102 
<span class="line-modified"> 5103 operand vRegD_V25()</span>


 5104 %{
<span class="line-modified"> 5105   constraint(ALLOC_IN_RC(v25_reg));</span>
 5106   match(RegD);

 5107   op_cost(0);
 5108   format %{ %}
 5109   interface(REG_INTER);
 5110 %}
 5111 
<span class="line-modified"> 5112 operand vRegD_V26()</span>
 5113 %{
<span class="line-modified"> 5114   constraint(ALLOC_IN_RC(v26_reg));</span>
<span class="line-modified"> 5115   match(RegD);</span>

 5116   op_cost(0);
 5117   format %{ %}
 5118   interface(REG_INTER);
 5119 %}
 5120 
<span class="line-modified"> 5121 operand vRegD_V27()</span>
 5122 %{
<span class="line-modified"> 5123   constraint(ALLOC_IN_RC(v27_reg));</span>
<span class="line-modified"> 5124   match(RegD);</span>

 5125   op_cost(0);
 5126   format %{ %}
 5127   interface(REG_INTER);
 5128 %}
 5129 
<span class="line-modified"> 5130 operand vRegD_V28()</span>
 5131 %{
<span class="line-modified"> 5132   constraint(ALLOC_IN_RC(v28_reg));</span>
 5133   match(RegD);
 5134   op_cost(0);
 5135   format %{ %}
 5136   interface(REG_INTER);
 5137 %}
 5138 
<span class="line-modified"> 5139 operand vRegD_V29()</span>
 5140 %{
<span class="line-modified"> 5141   constraint(ALLOC_IN_RC(v29_reg));</span>
 5142   match(RegD);
 5143   op_cost(0);
 5144   format %{ %}
 5145   interface(REG_INTER);
 5146 %}
 5147 
<span class="line-modified"> 5148 operand vRegD_V30()</span>
 5149 %{
<span class="line-modified"> 5150   constraint(ALLOC_IN_RC(v30_reg));</span>
 5151   match(RegD);
 5152   op_cost(0);
 5153   format %{ %}
 5154   interface(REG_INTER);
 5155 %}
 5156 
<span class="line-modified"> 5157 operand vRegD_V31()</span>
 5158 %{
<span class="line-modified"> 5159   constraint(ALLOC_IN_RC(v31_reg));</span>
 5160   match(RegD);
 5161   op_cost(0);
 5162   format %{ %}
 5163   interface(REG_INTER);
 5164 %}
 5165 
 5166 // Flags register, used as output of signed compare instructions
 5167 
 5168 // note that on AArch64 we also use this register as the output for
 5169 // for floating point compare instructions (CmpF CmpD). this ensures
 5170 // that ordered inequality tests use GT, GE, LT or LE none of which
 5171 // pass through cases where the result is unordered i.e. one or both
 5172 // inputs to the compare is a NaN. this means that the ideal code can
 5173 // replace e.g. a GT with an LE and not end up capturing the NaN case
 5174 // (where the comparison should always fail). EQ and NE tests are
 5175 // always generated in ideal code so that unordered folds into the NE
 5176 // case, matching the behaviour of AArch64 NE.
 5177 //
 5178 // This differs from x86 where the outputs of FP compares use a
 5179 // special FP flags registers and where compares based on this
</pre>
<hr />
<pre>
 5316     index($lreg);
 5317     scale(0x0);
 5318     disp(0x0);
 5319   %}
 5320 %}
 5321 
 5322 operand indOffI(iRegP reg, immIOffset off)
 5323 %{
 5324   constraint(ALLOC_IN_RC(ptr_reg));
 5325   match(AddP reg off);
 5326   op_cost(0);
 5327   format %{ &quot;[$reg, $off]&quot; %}
 5328   interface(MEMORY_INTER) %{
 5329     base($reg);
 5330     index(0xffffffff);
 5331     scale(0x0);
 5332     disp($off);
 5333   %}
 5334 %}
 5335 
<span class="line-added"> 5336 operand indOffI1(iRegP reg, immIOffset1 off)</span>
<span class="line-added"> 5337 %{</span>
<span class="line-added"> 5338   constraint(ALLOC_IN_RC(ptr_reg));</span>
<span class="line-added"> 5339   match(AddP reg off);</span>
<span class="line-added"> 5340   op_cost(0);</span>
<span class="line-added"> 5341   format %{ &quot;[$reg, $off]&quot; %}</span>
<span class="line-added"> 5342   interface(MEMORY_INTER) %{</span>
<span class="line-added"> 5343     base($reg);</span>
<span class="line-added"> 5344     index(0xffffffff);</span>
<span class="line-added"> 5345     scale(0x0);</span>
<span class="line-added"> 5346     disp($off);</span>
<span class="line-added"> 5347   %}</span>
<span class="line-added"> 5348 %}</span>
<span class="line-added"> 5349 </span>
<span class="line-added"> 5350 operand indOffI2(iRegP reg, immIOffset2 off)</span>
<span class="line-added"> 5351 %{</span>
<span class="line-added"> 5352   constraint(ALLOC_IN_RC(ptr_reg));</span>
<span class="line-added"> 5353   match(AddP reg off);</span>
<span class="line-added"> 5354   op_cost(0);</span>
<span class="line-added"> 5355   format %{ &quot;[$reg, $off]&quot; %}</span>
<span class="line-added"> 5356   interface(MEMORY_INTER) %{</span>
<span class="line-added"> 5357     base($reg);</span>
<span class="line-added"> 5358     index(0xffffffff);</span>
<span class="line-added"> 5359     scale(0x0);</span>
<span class="line-added"> 5360     disp($off);</span>
<span class="line-added"> 5361   %}</span>
<span class="line-added"> 5362 %}</span>
<span class="line-added"> 5363 </span>
 5364 operand indOffI4(iRegP reg, immIOffset4 off)
 5365 %{
 5366   constraint(ALLOC_IN_RC(ptr_reg));
 5367   match(AddP reg off);
 5368   op_cost(0);
 5369   format %{ &quot;[$reg, $off]&quot; %}
 5370   interface(MEMORY_INTER) %{
 5371     base($reg);
 5372     index(0xffffffff);
 5373     scale(0x0);
 5374     disp($off);
 5375   %}
 5376 %}
 5377 
 5378 operand indOffI8(iRegP reg, immIOffset8 off)
 5379 %{
 5380   constraint(ALLOC_IN_RC(ptr_reg));
 5381   match(AddP reg off);
 5382   op_cost(0);
 5383   format %{ &quot;[$reg, $off]&quot; %}
</pre>
<hr />
<pre>
 5400     index(0xffffffff);
 5401     scale(0x0);
 5402     disp($off);
 5403   %}
 5404 %}
 5405 
 5406 operand indOffL(iRegP reg, immLoffset off)
 5407 %{
 5408   constraint(ALLOC_IN_RC(ptr_reg));
 5409   match(AddP reg off);
 5410   op_cost(0);
 5411   format %{ &quot;[$reg, $off]&quot; %}
 5412   interface(MEMORY_INTER) %{
 5413     base($reg);
 5414     index(0xffffffff);
 5415     scale(0x0);
 5416     disp($off);
 5417   %}
 5418 %}
 5419 
<span class="line-added"> 5420 operand indOffL1(iRegP reg, immLoffset1 off)</span>
<span class="line-added"> 5421 %{</span>
<span class="line-added"> 5422   constraint(ALLOC_IN_RC(ptr_reg));</span>
<span class="line-added"> 5423   match(AddP reg off);</span>
<span class="line-added"> 5424   op_cost(0);</span>
<span class="line-added"> 5425   format %{ &quot;[$reg, $off]&quot; %}</span>
<span class="line-added"> 5426   interface(MEMORY_INTER) %{</span>
<span class="line-added"> 5427     base($reg);</span>
<span class="line-added"> 5428     index(0xffffffff);</span>
<span class="line-added"> 5429     scale(0x0);</span>
<span class="line-added"> 5430     disp($off);</span>
<span class="line-added"> 5431   %}</span>
<span class="line-added"> 5432 %}</span>
<span class="line-added"> 5433 </span>
<span class="line-added"> 5434 operand indOffL2(iRegP reg, immLoffset2 off)</span>
<span class="line-added"> 5435 %{</span>
<span class="line-added"> 5436   constraint(ALLOC_IN_RC(ptr_reg));</span>
<span class="line-added"> 5437   match(AddP reg off);</span>
<span class="line-added"> 5438   op_cost(0);</span>
<span class="line-added"> 5439   format %{ &quot;[$reg, $off]&quot; %}</span>
<span class="line-added"> 5440   interface(MEMORY_INTER) %{</span>
<span class="line-added"> 5441     base($reg);</span>
<span class="line-added"> 5442     index(0xffffffff);</span>
<span class="line-added"> 5443     scale(0x0);</span>
<span class="line-added"> 5444     disp($off);</span>
<span class="line-added"> 5445   %}</span>
<span class="line-added"> 5446 %}</span>
<span class="line-added"> 5447 </span>
 5448 operand indOffL4(iRegP reg, immLoffset4 off)
 5449 %{
 5450   constraint(ALLOC_IN_RC(ptr_reg));
 5451   match(AddP reg off);
 5452   op_cost(0);
 5453   format %{ &quot;[$reg, $off]&quot; %}
 5454   interface(MEMORY_INTER) %{
 5455     base($reg);
 5456     index(0xffffffff);
 5457     scale(0x0);
 5458     disp($off);
 5459   %}
 5460 %}
 5461 
 5462 operand indOffL8(iRegP reg, immLoffset8 off)
 5463 %{
 5464   constraint(ALLOC_IN_RC(ptr_reg));
 5465   match(AddP reg off);
 5466   op_cost(0);
 5467   format %{ &quot;[$reg, $off]&quot; %}
</pre>
<hr />
<pre>
 5472     disp($off);
 5473   %}
 5474 %}
 5475 
 5476 operand indOffL16(iRegP reg, immLoffset16 off)
 5477 %{
 5478   constraint(ALLOC_IN_RC(ptr_reg));
 5479   match(AddP reg off);
 5480   op_cost(0);
 5481   format %{ &quot;[$reg, $off]&quot; %}
 5482   interface(MEMORY_INTER) %{
 5483     base($reg);
 5484     index(0xffffffff);
 5485     scale(0x0);
 5486     disp($off);
 5487   %}
 5488 %}
 5489 
 5490 operand indirectN(iRegN reg)
 5491 %{
<span class="line-modified"> 5492   predicate(CompressedOops::shift() == 0);</span>
 5493   constraint(ALLOC_IN_RC(ptr_reg));
 5494   match(DecodeN reg);
 5495   op_cost(0);
 5496   format %{ &quot;[$reg]\t# narrow&quot; %}
 5497   interface(MEMORY_INTER) %{
 5498     base($reg);
 5499     index(0xffffffff);
 5500     scale(0x0);
 5501     disp(0x0);
 5502   %}
 5503 %}
 5504 
 5505 operand indIndexScaledI2LN(iRegN reg, iRegI ireg, immIScale scale)
 5506 %{
<span class="line-modified"> 5507   predicate(CompressedOops::shift() == 0 &amp;&amp; size_fits_all_mem_uses(n-&gt;as_AddP(), n-&gt;in(AddPNode::Offset)-&gt;in(2)-&gt;get_int()));</span>
 5508   constraint(ALLOC_IN_RC(ptr_reg));
 5509   match(AddP (DecodeN reg) (LShiftL (ConvI2L ireg) scale));
 5510   op_cost(0);
 5511   format %{ &quot;$reg, $ireg sxtw($scale), 0, I2L\t# narrow&quot; %}
 5512   interface(MEMORY_INTER) %{
 5513     base($reg);
 5514     index($ireg);
 5515     scale($scale);
 5516     disp(0x0);
 5517   %}
 5518 %}
 5519 
 5520 operand indIndexScaledN(iRegN reg, iRegL lreg, immIScale scale)
 5521 %{
<span class="line-modified"> 5522   predicate(CompressedOops::shift() == 0 &amp;&amp; size_fits_all_mem_uses(n-&gt;as_AddP(), n-&gt;in(AddPNode::Offset)-&gt;in(2)-&gt;get_int()));</span>
 5523   constraint(ALLOC_IN_RC(ptr_reg));
 5524   match(AddP (DecodeN reg) (LShiftL lreg scale));
 5525   op_cost(0);
 5526   format %{ &quot;$reg, $lreg lsl($scale)\t# narrow&quot; %}
 5527   interface(MEMORY_INTER) %{
 5528     base($reg);
 5529     index($lreg);
 5530     scale($scale);
 5531     disp(0x0);
 5532   %}
 5533 %}
 5534 
 5535 operand indIndexI2LN(iRegN reg, iRegI ireg)
 5536 %{
<span class="line-modified"> 5537   predicate(CompressedOops::shift() == 0);</span>
 5538   constraint(ALLOC_IN_RC(ptr_reg));
 5539   match(AddP (DecodeN reg) (ConvI2L ireg));
 5540   op_cost(0);
 5541   format %{ &quot;$reg, $ireg, 0, I2L\t# narrow&quot; %}
 5542   interface(MEMORY_INTER) %{
 5543     base($reg);
 5544     index($ireg);
 5545     scale(0x0);
 5546     disp(0x0);
 5547   %}
 5548 %}
 5549 
 5550 operand indIndexN(iRegN reg, iRegL lreg)
 5551 %{
<span class="line-modified"> 5552   predicate(CompressedOops::shift() == 0);</span>
 5553   constraint(ALLOC_IN_RC(ptr_reg));
 5554   match(AddP (DecodeN reg) lreg);
 5555   op_cost(0);
 5556   format %{ &quot;$reg, $lreg\t# narrow&quot; %}
 5557   interface(MEMORY_INTER) %{
 5558     base($reg);
 5559     index($lreg);
 5560     scale(0x0);
 5561     disp(0x0);
 5562   %}
 5563 %}
 5564 
 5565 operand indOffIN(iRegN reg, immIOffset off)
 5566 %{
<span class="line-modified"> 5567   predicate(CompressedOops::shift() == 0);</span>
 5568   constraint(ALLOC_IN_RC(ptr_reg));
 5569   match(AddP (DecodeN reg) off);
 5570   op_cost(0);
 5571   format %{ &quot;[$reg, $off]\t# narrow&quot; %}
 5572   interface(MEMORY_INTER) %{
 5573     base($reg);
 5574     index(0xffffffff);
 5575     scale(0x0);
 5576     disp($off);
 5577   %}
 5578 %}
 5579 
 5580 operand indOffLN(iRegN reg, immLoffset off)
 5581 %{
<span class="line-modified"> 5582   predicate(CompressedOops::shift() == 0);</span>
 5583   constraint(ALLOC_IN_RC(ptr_reg));
 5584   match(AddP (DecodeN reg) off);
 5585   op_cost(0);
 5586   format %{ &quot;[$reg, $off]\t# narrow&quot; %}
 5587   interface(MEMORY_INTER) %{
 5588     base($reg);
 5589     index(0xffffffff);
 5590     scale(0x0);
 5591     disp($off);
 5592   %}
 5593 %}
 5594 
 5595 
 5596 
 5597 // AArch64 opto stubs need to write to the pc slot in the thread anchor
 5598 operand thread_anchor_pc(thread_RegP reg, immL_pc_off off)
 5599 %{
 5600   constraint(ALLOC_IN_RC(ptr_reg));
 5601   match(AddP reg off);
 5602   op_cost(0);
</pre>
<hr />
<pre>
 5729 
 5730   format %{ &quot;&quot; %}
 5731   interface(COND_INTER) %{
 5732     equal(0x0, &quot;eq&quot;);
 5733     not_equal(0x1, &quot;ne&quot;);
 5734     less(0x3, &quot;lo&quot;);
 5735     greater_equal(0x2, &quot;hs&quot;);
 5736     less_equal(0x9, &quot;ls&quot;);
 5737     greater(0x8, &quot;hi&quot;);
 5738     overflow(0x6, &quot;vs&quot;);
 5739     no_overflow(0x7, &quot;vc&quot;);
 5740   %}
 5741 %}
 5742 
 5743 // used for certain integral comparisons which can be
 5744 // converted to cbxx or tbxx instructions
 5745 
 5746 operand cmpOpEqNe()
 5747 %{
 5748   match(Bool);

 5749   op_cost(0);
 5750   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne
 5751             || n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 5752 
 5753   format %{ &quot;&quot; %}
 5754   interface(COND_INTER) %{
 5755     equal(0x0, &quot;eq&quot;);
 5756     not_equal(0x1, &quot;ne&quot;);
 5757     less(0xb, &quot;lt&quot;);
 5758     greater_equal(0xa, &quot;ge&quot;);
 5759     less_equal(0xd, &quot;le&quot;);
 5760     greater(0xc, &quot;gt&quot;);
 5761     overflow(0x6, &quot;vs&quot;);
 5762     no_overflow(0x7, &quot;vc&quot;);
 5763   %}
 5764 %}
 5765 
 5766 // used for certain integral comparisons which can be
 5767 // converted to cbxx or tbxx instructions
 5768 
 5769 operand cmpOpLtGe()
 5770 %{
 5771   match(Bool);

 5772   op_cost(0);
 5773 
 5774   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt
 5775             || n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 5776 
 5777   format %{ &quot;&quot; %}
 5778   interface(COND_INTER) %{
 5779     equal(0x0, &quot;eq&quot;);
 5780     not_equal(0x1, &quot;ne&quot;);
 5781     less(0xb, &quot;lt&quot;);
 5782     greater_equal(0xa, &quot;ge&quot;);
 5783     less_equal(0xd, &quot;le&quot;);
 5784     greater(0xc, &quot;gt&quot;);
 5785     overflow(0x6, &quot;vs&quot;);
 5786     no_overflow(0x7, &quot;vc&quot;);
 5787   %}
 5788 %}
 5789 
 5790 // used for certain unsigned integral comparisons which can be
 5791 // converted to cbxx or tbxx instructions
 5792 
 5793 operand cmpOpUEqNeLtGe()
 5794 %{
 5795   match(Bool);

 5796   op_cost(0);
 5797 
 5798   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq
 5799             || n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne
 5800             || n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt
 5801             || n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 5802 
 5803   format %{ &quot;&quot; %}
 5804   interface(COND_INTER) %{
 5805     equal(0x0, &quot;eq&quot;);
 5806     not_equal(0x1, &quot;ne&quot;);
 5807     less(0xb, &quot;lt&quot;);
 5808     greater_equal(0xa, &quot;ge&quot;);
 5809     less_equal(0xd, &quot;le&quot;);
 5810     greater(0xc, &quot;gt&quot;);
 5811     overflow(0x6, &quot;vs&quot;);
 5812     no_overflow(0x7, &quot;vc&quot;);
 5813   %}
 5814 %}
 5815 
</pre>
<hr />
<pre>
 5823 
 5824   format %{ &quot;l2i($reg)&quot; %}
 5825 
 5826   interface(REG_INTER)
 5827 %}
 5828 
 5829 opclass vmem4(indirect, indIndex, indOffI4, indOffL4);
 5830 opclass vmem8(indirect, indIndex, indOffI8, indOffL8);
 5831 opclass vmem16(indirect, indIndex, indOffI16, indOffL16);
 5832 
 5833 //----------OPERAND CLASSES----------------------------------------------------
 5834 // Operand Classes are groups of operands that are used as to simplify
 5835 // instruction definitions by not requiring the AD writer to specify
 5836 // separate instructions for every form of operand when the
 5837 // instruction accepts multiple operand types with the same basic
 5838 // encoding and format. The classic case of this is memory operands.
 5839 
 5840 // memory is used to define read/write location for load/store
 5841 // instruction defs. we can turn a memory op into an Address
 5842 
<span class="line-modified"> 5843 opclass memory1(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI1, indOffL1,</span>
<span class="line-added"> 5844                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);</span>
<span class="line-added"> 5845 </span>
<span class="line-added"> 5846 opclass memory2(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI2, indOffL2,</span>
<span class="line-added"> 5847                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);</span>
<span class="line-added"> 5848 </span>
<span class="line-added"> 5849 opclass memory4(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI4, indOffL4,</span>
<span class="line-added"> 5850                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);</span>
<span class="line-added"> 5851 </span>
<span class="line-added"> 5852 opclass memory8(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI8, indOffL8,</span>
 5853                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);
 5854 
<span class="line-added"> 5855 // All of the memory operands. For the pipeline description.</span>
<span class="line-added"> 5856 opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex,</span>
<span class="line-added"> 5857                indOffI1, indOffL1, indOffI2, indOffL2, indOffI4, indOffL4, indOffI8, indOffL8,</span>
<span class="line-added"> 5858                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);</span>
<span class="line-added"> 5859 </span>
<span class="line-added"> 5860 </span>
 5861 // iRegIorL2I is used for src inputs in rules for 32 bit int (I)
 5862 // operations. it allows the src to be either an iRegI or a (ConvL2I
 5863 // iRegL). in the latter case the l2i normally planted for a ConvL2I
 5864 // can be elided because the 32-bit instruction will just employ the
 5865 // lower 32 bits anyway.
 5866 //
 5867 // n.b. this does not elide all L2I conversions. if the truncated
 5868 // value is consumed by more than one operation then the ConvL2I
 5869 // cannot be bundled into the consuming nodes so an l2i gets planted
 5870 // (actually a movw $dst $src) and the downstream instructions consume
 5871 // the result of the l2i as an iRegI input. That&#39;s a shame since the
 5872 // movw is actually redundant but its not too costly.
 5873 
 5874 opclass iRegIorL2I(iRegI, iRegL2I);
 5875 
 5876 //----------PIPELINE-----------------------------------------------------------
 5877 // Rules which define the behavior of the target architectures pipeline.
 5878 
 5879 // For specific pipelines, eg A53, define the stages of that pipeline
 5880 //pipe_desc(ISS, EX1, EX2, WR);
</pre>
<hr />
<pre>
 6824 //               instructions.
 6825 // format     -- A string providing the disassembly for this instruction.
 6826 //               The value of an instruction&#39;s operand may be inserted
 6827 //               by referring to it with a &#39;$&#39; prefix.
 6828 // opcode     -- Three instruction opcodes may be provided.  These are referred
 6829 //               to within an encode class as $primary, $secondary, and $tertiary
 6830 //               rrspectively.  The primary opcode is commonly used to
 6831 //               indicate the type of machine instruction, while secondary
 6832 //               and tertiary are often used for prefix options or addressing
 6833 //               modes.
 6834 // ins_encode -- A list of encode classes with parameters. The encode class
 6835 //               name must have been defined in an &#39;enc_class&#39; specification
 6836 //               in the encode section of the architecture description.
 6837 
 6838 // ============================================================================
 6839 // Memory (Load/Store) Instructions
 6840 
 6841 // Load Instructions
 6842 
 6843 // Load Byte (8 bit signed)
<span class="line-modified"> 6844 instruct loadB(iRegINoSp dst, memory1 mem)</span>
 6845 %{
 6846   match(Set dst (LoadB mem));
 6847   predicate(!needs_acquiring_load(n));
 6848 
 6849   ins_cost(4 * INSN_COST);
 6850   format %{ &quot;ldrsbw  $dst, $mem\t# byte&quot; %}
 6851 
 6852   ins_encode(aarch64_enc_ldrsbw(dst, mem));
 6853 
 6854   ins_pipe(iload_reg_mem);
 6855 %}
 6856 
 6857 // Load Byte (8 bit signed) into long
<span class="line-modified"> 6858 instruct loadB2L(iRegLNoSp dst, memory1 mem)</span>
 6859 %{
 6860   match(Set dst (ConvI2L (LoadB mem)));
 6861   predicate(!needs_acquiring_load(n-&gt;in(1)));
 6862 
 6863   ins_cost(4 * INSN_COST);
 6864   format %{ &quot;ldrsb  $dst, $mem\t# byte&quot; %}
 6865 
 6866   ins_encode(aarch64_enc_ldrsb(dst, mem));
 6867 
 6868   ins_pipe(iload_reg_mem);
 6869 %}
 6870 
 6871 // Load Byte (8 bit unsigned)
<span class="line-modified"> 6872 instruct loadUB(iRegINoSp dst, memory1 mem)</span>
 6873 %{
 6874   match(Set dst (LoadUB mem));
 6875   predicate(!needs_acquiring_load(n));
 6876 
 6877   ins_cost(4 * INSN_COST);
 6878   format %{ &quot;ldrbw  $dst, $mem\t# byte&quot; %}
 6879 
 6880   ins_encode(aarch64_enc_ldrb(dst, mem));
 6881 
 6882   ins_pipe(iload_reg_mem);
 6883 %}
 6884 
 6885 // Load Byte (8 bit unsigned) into long
<span class="line-modified"> 6886 instruct loadUB2L(iRegLNoSp dst, memory1 mem)</span>
 6887 %{
 6888   match(Set dst (ConvI2L (LoadUB mem)));
 6889   predicate(!needs_acquiring_load(n-&gt;in(1)));
 6890 
 6891   ins_cost(4 * INSN_COST);
 6892   format %{ &quot;ldrb  $dst, $mem\t# byte&quot; %}
 6893 
 6894   ins_encode(aarch64_enc_ldrb(dst, mem));
 6895 
 6896   ins_pipe(iload_reg_mem);
 6897 %}
 6898 
 6899 // Load Short (16 bit signed)
<span class="line-modified"> 6900 instruct loadS(iRegINoSp dst, memory2 mem)</span>
 6901 %{
 6902   match(Set dst (LoadS mem));
 6903   predicate(!needs_acquiring_load(n));
 6904 
 6905   ins_cost(4 * INSN_COST);
 6906   format %{ &quot;ldrshw  $dst, $mem\t# short&quot; %}
 6907 
 6908   ins_encode(aarch64_enc_ldrshw(dst, mem));
 6909 
 6910   ins_pipe(iload_reg_mem);
 6911 %}
 6912 
 6913 // Load Short (16 bit signed) into long
<span class="line-modified"> 6914 instruct loadS2L(iRegLNoSp dst, memory2 mem)</span>
 6915 %{
 6916   match(Set dst (ConvI2L (LoadS mem)));
 6917   predicate(!needs_acquiring_load(n-&gt;in(1)));
 6918 
 6919   ins_cost(4 * INSN_COST);
 6920   format %{ &quot;ldrsh  $dst, $mem\t# short&quot; %}
 6921 
 6922   ins_encode(aarch64_enc_ldrsh(dst, mem));
 6923 
 6924   ins_pipe(iload_reg_mem);
 6925 %}
 6926 
 6927 // Load Char (16 bit unsigned)
<span class="line-modified"> 6928 instruct loadUS(iRegINoSp dst, memory2 mem)</span>
 6929 %{
 6930   match(Set dst (LoadUS mem));
 6931   predicate(!needs_acquiring_load(n));
 6932 
 6933   ins_cost(4 * INSN_COST);
 6934   format %{ &quot;ldrh  $dst, $mem\t# short&quot; %}
 6935 
 6936   ins_encode(aarch64_enc_ldrh(dst, mem));
 6937 
 6938   ins_pipe(iload_reg_mem);
 6939 %}
 6940 
 6941 // Load Short/Char (16 bit unsigned) into long
<span class="line-modified"> 6942 instruct loadUS2L(iRegLNoSp dst, memory2 mem)</span>
 6943 %{
 6944   match(Set dst (ConvI2L (LoadUS mem)));
 6945   predicate(!needs_acquiring_load(n-&gt;in(1)));
 6946 
 6947   ins_cost(4 * INSN_COST);
 6948   format %{ &quot;ldrh  $dst, $mem\t# short&quot; %}
 6949 
 6950   ins_encode(aarch64_enc_ldrh(dst, mem));
 6951 
 6952   ins_pipe(iload_reg_mem);
 6953 %}
 6954 
 6955 // Load Integer (32 bit signed)
<span class="line-modified"> 6956 instruct loadI(iRegINoSp dst, memory4 mem)</span>
 6957 %{
 6958   match(Set dst (LoadI mem));
 6959   predicate(!needs_acquiring_load(n));
 6960 
 6961   ins_cost(4 * INSN_COST);
 6962   format %{ &quot;ldrw  $dst, $mem\t# int&quot; %}
 6963 
 6964   ins_encode(aarch64_enc_ldrw(dst, mem));
 6965 
 6966   ins_pipe(iload_reg_mem);
 6967 %}
 6968 
 6969 // Load Integer (32 bit signed) into long
<span class="line-modified"> 6970 instruct loadI2L(iRegLNoSp dst, memory4 mem)</span>
 6971 %{
 6972   match(Set dst (ConvI2L (LoadI mem)));
 6973   predicate(!needs_acquiring_load(n-&gt;in(1)));
 6974 
 6975   ins_cost(4 * INSN_COST);
 6976   format %{ &quot;ldrsw  $dst, $mem\t# int&quot; %}
 6977 
 6978   ins_encode(aarch64_enc_ldrsw(dst, mem));
 6979 
 6980   ins_pipe(iload_reg_mem);
 6981 %}
 6982 
 6983 // Load Integer (32 bit unsigned) into long
<span class="line-modified"> 6984 instruct loadUI2L(iRegLNoSp dst, memory4 mem, immL_32bits mask)</span>
 6985 %{
 6986   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 6987   predicate(!needs_acquiring_load(n-&gt;in(1)-&gt;in(1)-&gt;as_Load()));
 6988 
 6989   ins_cost(4 * INSN_COST);
 6990   format %{ &quot;ldrw  $dst, $mem\t# int&quot; %}
 6991 
 6992   ins_encode(aarch64_enc_ldrw(dst, mem));
 6993 
 6994   ins_pipe(iload_reg_mem);
 6995 %}
 6996 
 6997 // Load Long (64 bit signed)
<span class="line-modified"> 6998 instruct loadL(iRegLNoSp dst, memory8 mem)</span>
 6999 %{
 7000   match(Set dst (LoadL mem));
 7001   predicate(!needs_acquiring_load(n));
 7002 
 7003   ins_cost(4 * INSN_COST);
 7004   format %{ &quot;ldr  $dst, $mem\t# int&quot; %}
 7005 
 7006   ins_encode(aarch64_enc_ldr(dst, mem));
 7007 
 7008   ins_pipe(iload_reg_mem);
 7009 %}
 7010 
 7011 // Load Range
<span class="line-modified"> 7012 instruct loadRange(iRegINoSp dst, memory4 mem)</span>
 7013 %{
 7014   match(Set dst (LoadRange mem));
 7015 
 7016   ins_cost(4 * INSN_COST);
 7017   format %{ &quot;ldrw  $dst, $mem\t# range&quot; %}
 7018 
 7019   ins_encode(aarch64_enc_ldrw(dst, mem));
 7020 
 7021   ins_pipe(iload_reg_mem);
 7022 %}
 7023 
 7024 // Load Pointer
<span class="line-modified"> 7025 instruct loadP(iRegPNoSp dst, memory8 mem)</span>
 7026 %{
 7027   match(Set dst (LoadP mem));
<span class="line-modified"> 7028   predicate(!needs_acquiring_load(n) &amp;&amp; (n-&gt;as_Load()-&gt;barrier_data() == 0));</span>
 7029 
 7030   ins_cost(4 * INSN_COST);
 7031   format %{ &quot;ldr  $dst, $mem\t# ptr&quot; %}
 7032 
 7033   ins_encode(aarch64_enc_ldr(dst, mem));
 7034 
 7035   ins_pipe(iload_reg_mem);
 7036 %}
 7037 
 7038 // Load Compressed Pointer
<span class="line-modified"> 7039 instruct loadN(iRegNNoSp dst, memory4 mem)</span>
 7040 %{
 7041   match(Set dst (LoadN mem));
 7042   predicate(!needs_acquiring_load(n));
 7043 
 7044   ins_cost(4 * INSN_COST);
 7045   format %{ &quot;ldrw  $dst, $mem\t# compressed ptr&quot; %}
 7046 
 7047   ins_encode(aarch64_enc_ldrw(dst, mem));
 7048 
 7049   ins_pipe(iload_reg_mem);
 7050 %}
 7051 
 7052 // Load Klass Pointer
<span class="line-modified"> 7053 instruct loadKlass(iRegPNoSp dst, memory8 mem)</span>
 7054 %{
 7055   match(Set dst (LoadKlass mem));
 7056   predicate(!needs_acquiring_load(n));
 7057 
 7058   ins_cost(4 * INSN_COST);
 7059   format %{ &quot;ldr  $dst, $mem\t# class&quot; %}
 7060 
 7061   ins_encode(aarch64_enc_ldr(dst, mem));
 7062 
 7063   ins_pipe(iload_reg_mem);
 7064 %}
 7065 
 7066 // Load Narrow Klass Pointer
<span class="line-modified"> 7067 instruct loadNKlass(iRegNNoSp dst, memory4 mem)</span>
 7068 %{
 7069   match(Set dst (LoadNKlass mem));
 7070   predicate(!needs_acquiring_load(n));
 7071 
 7072   ins_cost(4 * INSN_COST);
 7073   format %{ &quot;ldrw  $dst, $mem\t# compressed class ptr&quot; %}
 7074 
 7075   ins_encode(aarch64_enc_ldrw(dst, mem));
 7076 
 7077   ins_pipe(iload_reg_mem);
 7078 %}
 7079 
 7080 // Load Float
<span class="line-modified"> 7081 instruct loadF(vRegF dst, memory4 mem)</span>
 7082 %{
 7083   match(Set dst (LoadF mem));
 7084   predicate(!needs_acquiring_load(n));
 7085 
 7086   ins_cost(4 * INSN_COST);
 7087   format %{ &quot;ldrs  $dst, $mem\t# float&quot; %}
 7088 
 7089   ins_encode( aarch64_enc_ldrs(dst, mem) );
 7090 
 7091   ins_pipe(pipe_class_memory);
 7092 %}
 7093 
 7094 // Load Double
<span class="line-modified"> 7095 instruct loadD(vRegD dst, memory8 mem)</span>
 7096 %{
 7097   match(Set dst (LoadD mem));
 7098   predicate(!needs_acquiring_load(n));
 7099 
 7100   ins_cost(4 * INSN_COST);
 7101   format %{ &quot;ldrd  $dst, $mem\t# double&quot; %}
 7102 
 7103   ins_encode( aarch64_enc_ldrd(dst, mem) );
 7104 
 7105   ins_pipe(pipe_class_memory);
 7106 %}
 7107 
 7108 
 7109 // Load Int Constant
 7110 instruct loadConI(iRegINoSp dst, immI src)
 7111 %{
 7112   match(Set dst src);
 7113 
 7114   ins_cost(INSN_COST);
 7115   format %{ &quot;mov $dst, $src\t# int&quot; %}
</pre>
<hr />
<pre>
 7293 // Load Double Constant
 7294 
 7295 instruct loadConD(vRegD dst, immD con) %{
 7296   match(Set dst con);
 7297 
 7298   ins_cost(INSN_COST * 5);
 7299   format %{
 7300     &quot;ldrd $dst, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
 7301   %}
 7302 
 7303   ins_encode %{
 7304     __ ldrd(as_FloatRegister($dst$$reg), $constantaddress($con));
 7305   %}
 7306 
 7307   ins_pipe(fp_load_constant_d);
 7308 %}
 7309 
 7310 // Store Instructions
 7311 
 7312 // Store CMS card-mark Immediate
<span class="line-modified"> 7313 instruct storeimmCM0(immI0 zero, memory1 mem)</span>
 7314 %{
 7315   match(Set mem (StoreCM mem zero));

 7316 
 7317   ins_cost(INSN_COST);
 7318   format %{ &quot;storestore (elided)\n\t&quot;
 7319             &quot;strb zr, $mem\t# byte&quot; %}
 7320 
 7321   ins_encode(aarch64_enc_strb0(mem));
 7322 
 7323   ins_pipe(istore_mem);
 7324 %}
 7325 
 7326 // Store CMS card-mark Immediate with intervening StoreStore
 7327 // needed when using CMS with no conditional card marking
<span class="line-modified"> 7328 instruct storeimmCM0_ordered(immI0 zero, memory1 mem)</span>
 7329 %{
 7330   match(Set mem (StoreCM mem zero));
 7331 
 7332   ins_cost(INSN_COST * 2);
 7333   format %{ &quot;storestore\n\t&quot;
 7334             &quot;dmb ishst&quot;
 7335             &quot;\n\tstrb zr, $mem\t# byte&quot; %}
 7336 
 7337   ins_encode(aarch64_enc_strb0_ordered(mem));
 7338 
 7339   ins_pipe(istore_mem);
 7340 %}
 7341 
 7342 // Store Byte
<span class="line-modified"> 7343 instruct storeB(iRegIorL2I src, memory1 mem)</span>
 7344 %{
 7345   match(Set mem (StoreB mem src));
 7346   predicate(!needs_releasing_store(n));
 7347 
 7348   ins_cost(INSN_COST);
 7349   format %{ &quot;strb  $src, $mem\t# byte&quot; %}
 7350 
 7351   ins_encode(aarch64_enc_strb(src, mem));
 7352 
 7353   ins_pipe(istore_reg_mem);
 7354 %}
 7355 
 7356 
<span class="line-modified"> 7357 instruct storeimmB0(immI0 zero, memory1 mem)</span>
 7358 %{
 7359   match(Set mem (StoreB mem zero));
 7360   predicate(!needs_releasing_store(n));
 7361 
 7362   ins_cost(INSN_COST);
 7363   format %{ &quot;strb rscractch2, $mem\t# byte&quot; %}
 7364 
 7365   ins_encode(aarch64_enc_strb0(mem));
 7366 
 7367   ins_pipe(istore_mem);
 7368 %}
 7369 
 7370 // Store Char/Short
<span class="line-modified"> 7371 instruct storeC(iRegIorL2I src, memory2 mem)</span>
 7372 %{
 7373   match(Set mem (StoreC mem src));
 7374   predicate(!needs_releasing_store(n));
 7375 
 7376   ins_cost(INSN_COST);
 7377   format %{ &quot;strh  $src, $mem\t# short&quot; %}
 7378 
 7379   ins_encode(aarch64_enc_strh(src, mem));
 7380 
 7381   ins_pipe(istore_reg_mem);
 7382 %}
 7383 
<span class="line-modified"> 7384 instruct storeimmC0(immI0 zero, memory2 mem)</span>
 7385 %{
 7386   match(Set mem (StoreC mem zero));
 7387   predicate(!needs_releasing_store(n));
 7388 
 7389   ins_cost(INSN_COST);
 7390   format %{ &quot;strh  zr, $mem\t# short&quot; %}
 7391 
 7392   ins_encode(aarch64_enc_strh0(mem));
 7393 
 7394   ins_pipe(istore_mem);
 7395 %}
 7396 
 7397 // Store Integer
 7398 
<span class="line-modified"> 7399 instruct storeI(iRegIorL2I src, memory4 mem)</span>
 7400 %{
 7401   match(Set mem(StoreI mem src));
 7402   predicate(!needs_releasing_store(n));
 7403 
 7404   ins_cost(INSN_COST);
 7405   format %{ &quot;strw  $src, $mem\t# int&quot; %}
 7406 
 7407   ins_encode(aarch64_enc_strw(src, mem));
 7408 
 7409   ins_pipe(istore_reg_mem);
 7410 %}
 7411 
<span class="line-modified"> 7412 instruct storeimmI0(immI0 zero, memory4 mem)</span>
 7413 %{
 7414   match(Set mem(StoreI mem zero));
 7415   predicate(!needs_releasing_store(n));
 7416 
 7417   ins_cost(INSN_COST);
 7418   format %{ &quot;strw  zr, $mem\t# int&quot; %}
 7419 
 7420   ins_encode(aarch64_enc_strw0(mem));
 7421 
 7422   ins_pipe(istore_mem);
 7423 %}
 7424 
 7425 // Store Long (64 bit signed)
<span class="line-modified"> 7426 instruct storeL(iRegL src, memory8 mem)</span>
 7427 %{
 7428   match(Set mem (StoreL mem src));
 7429   predicate(!needs_releasing_store(n));
 7430 
 7431   ins_cost(INSN_COST);
 7432   format %{ &quot;str  $src, $mem\t# int&quot; %}
 7433 
 7434   ins_encode(aarch64_enc_str(src, mem));
 7435 
 7436   ins_pipe(istore_reg_mem);
 7437 %}
 7438 
 7439 // Store Long (64 bit signed)
<span class="line-modified"> 7440 instruct storeimmL0(immL0 zero, memory8 mem)</span>
 7441 %{
 7442   match(Set mem (StoreL mem zero));
 7443   predicate(!needs_releasing_store(n));
 7444 
 7445   ins_cost(INSN_COST);
 7446   format %{ &quot;str  zr, $mem\t# int&quot; %}
 7447 
 7448   ins_encode(aarch64_enc_str0(mem));
 7449 
 7450   ins_pipe(istore_mem);
 7451 %}
 7452 
 7453 // Store Pointer
<span class="line-modified"> 7454 instruct storeP(iRegP src, memory8 mem)</span>
 7455 %{
 7456   match(Set mem (StoreP mem src));
 7457   predicate(!needs_releasing_store(n));
 7458 
 7459   ins_cost(INSN_COST);
 7460   format %{ &quot;str  $src, $mem\t# ptr&quot; %}
 7461 
 7462   ins_encode(aarch64_enc_str(src, mem));
 7463 
 7464   ins_pipe(istore_reg_mem);
 7465 %}
 7466 
 7467 // Store Pointer
<span class="line-modified"> 7468 instruct storeimmP0(immP0 zero, memory8 mem)</span>
 7469 %{
 7470   match(Set mem (StoreP mem zero));
 7471   predicate(!needs_releasing_store(n));
 7472 
 7473   ins_cost(INSN_COST);
 7474   format %{ &quot;str zr, $mem\t# ptr&quot; %}
 7475 
 7476   ins_encode(aarch64_enc_str0(mem));
 7477 
 7478   ins_pipe(istore_mem);
 7479 %}
 7480 
 7481 // Store Compressed Pointer
<span class="line-modified"> 7482 instruct storeN(iRegN src, memory4 mem)</span>
 7483 %{
 7484   match(Set mem (StoreN mem src));
 7485   predicate(!needs_releasing_store(n));
 7486 
 7487   ins_cost(INSN_COST);
 7488   format %{ &quot;strw  $src, $mem\t# compressed ptr&quot; %}
 7489 
 7490   ins_encode(aarch64_enc_strw(src, mem));
 7491 
 7492   ins_pipe(istore_reg_mem);
 7493 %}
 7494 
<span class="line-modified"> 7495 instruct storeImmN0(iRegIHeapbase heapbase, immN0 zero, memory4 mem)</span>
 7496 %{
 7497   match(Set mem (StoreN mem zero));
<span class="line-modified"> 7498   predicate(CompressedOops::base() == NULL &amp;&amp;</span>
<span class="line-modified"> 7499             CompressedKlassPointers::base() == NULL &amp;&amp;</span>
 7500             (!needs_releasing_store(n)));
 7501 
 7502   ins_cost(INSN_COST);
 7503   format %{ &quot;strw  rheapbase, $mem\t# compressed ptr (rheapbase==0)&quot; %}
 7504 
 7505   ins_encode(aarch64_enc_strw(heapbase, mem));
 7506 
 7507   ins_pipe(istore_reg_mem);
 7508 %}
 7509 
 7510 // Store Float
<span class="line-modified"> 7511 instruct storeF(vRegF src, memory4 mem)</span>
 7512 %{
 7513   match(Set mem (StoreF mem src));
 7514   predicate(!needs_releasing_store(n));
 7515 
 7516   ins_cost(INSN_COST);
 7517   format %{ &quot;strs  $src, $mem\t# float&quot; %}
 7518 
 7519   ins_encode( aarch64_enc_strs(src, mem) );
 7520 
 7521   ins_pipe(pipe_class_memory);
 7522 %}
 7523 
 7524 // TODO
 7525 // implement storeImmF0 and storeFImmPacked
 7526 
 7527 // Store Double
<span class="line-modified"> 7528 instruct storeD(vRegD src, memory8 mem)</span>
 7529 %{
 7530   match(Set mem (StoreD mem src));
 7531   predicate(!needs_releasing_store(n));
 7532 
 7533   ins_cost(INSN_COST);
 7534   format %{ &quot;strd  $src, $mem\t# double&quot; %}
 7535 
 7536   ins_encode( aarch64_enc_strd(src, mem) );
 7537 
 7538   ins_pipe(pipe_class_memory);
 7539 %}
 7540 
 7541 // Store Compressed Klass Pointer
<span class="line-modified"> 7542 instruct storeNKlass(iRegN src, memory4 mem)</span>
 7543 %{
 7544   predicate(!needs_releasing_store(n));
 7545   match(Set mem (StoreNKlass mem src));
 7546 
 7547   ins_cost(INSN_COST);
 7548   format %{ &quot;strw  $src, $mem\t# compressed klass ptr&quot; %}
 7549 
 7550   ins_encode(aarch64_enc_strw(src, mem));
 7551 
 7552   ins_pipe(istore_reg_mem);
 7553 %}
 7554 
 7555 // TODO
 7556 // implement storeImmD0 and storeDImmPacked
 7557 
 7558 // prefetch instructions
 7559 // Must be safe to execute with invalid address (cannot fault).
 7560 
<span class="line-modified"> 7561 instruct prefetchalloc( memory8 mem ) %{</span>
 7562   match(PrefetchAllocation mem);
 7563 
 7564   ins_cost(INSN_COST);
 7565   format %{ &quot;prfm $mem, PSTL1KEEP\t# Prefetch into level 1 cache write keep&quot; %}
 7566 
 7567   ins_encode( aarch64_enc_prefetchw(mem) );
 7568 
 7569   ins_pipe(iload_prefetch);
 7570 %}
 7571 
 7572 //  ---------------- volatile loads and stores ----------------
 7573 
 7574 // Load Byte (8 bit signed)
 7575 instruct loadB_volatile(iRegINoSp dst, /* sync_memory*/indirect mem)
 7576 %{
 7577   match(Set dst (LoadB mem));
 7578 
 7579   ins_cost(VOLATILE_REF_COST);
 7580   format %{ &quot;ldarsb  $dst, $mem\t# byte&quot; %}
 7581 
</pre>
<hr />
<pre>
 7700   ins_pipe(pipe_serial);
 7701 %}
 7702 
 7703 // Load Long (64 bit signed)
 7704 instruct loadL_volatile(iRegLNoSp dst, /* sync_memory*/indirect mem)
 7705 %{
 7706   match(Set dst (LoadL mem));
 7707 
 7708   ins_cost(VOLATILE_REF_COST);
 7709   format %{ &quot;ldar  $dst, $mem\t# int&quot; %}
 7710 
 7711   ins_encode(aarch64_enc_ldar(dst, mem));
 7712 
 7713   ins_pipe(pipe_serial);
 7714 %}
 7715 
 7716 // Load Pointer
 7717 instruct loadP_volatile(iRegPNoSp dst, /* sync_memory*/indirect mem)
 7718 %{
 7719   match(Set dst (LoadP mem));
<span class="line-added"> 7720   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);</span>
 7721 
 7722   ins_cost(VOLATILE_REF_COST);
 7723   format %{ &quot;ldar  $dst, $mem\t# ptr&quot; %}
 7724 
 7725   ins_encode(aarch64_enc_ldar(dst, mem));
 7726 
 7727   ins_pipe(pipe_serial);
 7728 %}
 7729 
 7730 // Load Compressed Pointer
 7731 instruct loadN_volatile(iRegNNoSp dst, /* sync_memory*/indirect mem)
 7732 %{
 7733   match(Set dst (LoadN mem));
 7734 
 7735   ins_cost(VOLATILE_REF_COST);
 7736   format %{ &quot;ldarw  $dst, $mem\t# compressed ptr&quot; %}
 7737 
 7738   ins_encode(aarch64_enc_ldarw(dst, mem));
 7739 
 7740   ins_pipe(pipe_serial);
</pre>
<hr />
<pre>
 7859 %}
 7860 
 7861 // TODO
 7862 // implement storeImmF0 and storeFImmPacked
 7863 
 7864 // Store Double
 7865 instruct storeD_volatile(vRegD src, /* sync_memory*/indirect mem)
 7866 %{
 7867   match(Set mem (StoreD mem src));
 7868 
 7869   ins_cost(VOLATILE_REF_COST);
 7870   format %{ &quot;stlrd  $src, $mem\t# double&quot; %}
 7871 
 7872   ins_encode( aarch64_enc_fstlrd(src, mem) );
 7873 
 7874   ins_pipe(pipe_class_memory);
 7875 %}
 7876 
 7877 //  ---------------- end of volatile loads and stores ----------------
 7878 
<span class="line-added"> 7879 instruct cacheWB(indirect addr)</span>
<span class="line-added"> 7880 %{</span>
<span class="line-added"> 7881   predicate(VM_Version::supports_data_cache_line_flush());</span>
<span class="line-added"> 7882   match(CacheWB addr);</span>
<span class="line-added"> 7883 </span>
<span class="line-added"> 7884   ins_cost(100);</span>
<span class="line-added"> 7885   format %{&quot;cache wb $addr&quot; %}</span>
<span class="line-added"> 7886   ins_encode %{</span>
<span class="line-added"> 7887     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);</span>
<span class="line-added"> 7888     assert($addr$$disp == 0, &quot;should be&quot;);</span>
<span class="line-added"> 7889     __ cache_wb(Address($addr$$base$$Register, 0));</span>
<span class="line-added"> 7890   %}</span>
<span class="line-added"> 7891   ins_pipe(pipe_slow); // XXX</span>
<span class="line-added"> 7892 %}</span>
<span class="line-added"> 7893 </span>
<span class="line-added"> 7894 instruct cacheWBPreSync()</span>
<span class="line-added"> 7895 %{</span>
<span class="line-added"> 7896   predicate(VM_Version::supports_data_cache_line_flush());</span>
<span class="line-added"> 7897   match(CacheWBPreSync);</span>
<span class="line-added"> 7898 </span>
<span class="line-added"> 7899   ins_cost(100);</span>
<span class="line-added"> 7900   format %{&quot;cache wb presync&quot; %}</span>
<span class="line-added"> 7901   ins_encode %{</span>
<span class="line-added"> 7902     __ cache_wbsync(true);</span>
<span class="line-added"> 7903   %}</span>
<span class="line-added"> 7904   ins_pipe(pipe_slow); // XXX</span>
<span class="line-added"> 7905 %}</span>
<span class="line-added"> 7906 </span>
<span class="line-added"> 7907 instruct cacheWBPostSync()</span>
<span class="line-added"> 7908 %{</span>
<span class="line-added"> 7909   predicate(VM_Version::supports_data_cache_line_flush());</span>
<span class="line-added"> 7910   match(CacheWBPostSync);</span>
<span class="line-added"> 7911 </span>
<span class="line-added"> 7912   ins_cost(100);</span>
<span class="line-added"> 7913   format %{&quot;cache wb postsync&quot; %}</span>
<span class="line-added"> 7914   ins_encode %{</span>
<span class="line-added"> 7915     __ cache_wbsync(false);</span>
<span class="line-added"> 7916   %}</span>
<span class="line-added"> 7917   ins_pipe(pipe_slow); // XXX</span>
<span class="line-added"> 7918 %}</span>
<span class="line-added"> 7919 </span>
 7920 // ============================================================================
 7921 // BSWAP Instructions
 7922 
 7923 instruct bytes_reverse_int(iRegINoSp dst, iRegIorL2I src) %{
 7924   match(Set dst (ReverseBytesI src));
 7925 
 7926   ins_cost(INSN_COST);
 7927   format %{ &quot;revw  $dst, $src&quot; %}
 7928 
 7929   ins_encode %{
 7930     __ revw(as_Register($dst$$reg), as_Register($src$$reg));
 7931   %}
 7932 
 7933   ins_pipe(ialu_reg);
 7934 %}
 7935 
 7936 instruct bytes_reverse_long(iRegLNoSp dst, iRegL src) %{
 7937   match(Set dst (ReverseBytesL src));
 7938 
 7939   ins_cost(INSN_COST);
</pre>
<hr />
<pre>
 8037   match(Set dst (PopCountI src));
 8038   effect(TEMP tmp);
 8039   ins_cost(INSN_COST * 13);
 8040 
 8041   format %{ &quot;movw   $src, $src\n\t&quot;
 8042             &quot;mov    $tmp, $src\t# vector (1D)\n\t&quot;
 8043             &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
 8044             &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
 8045             &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
 8046   ins_encode %{
 8047     __ movw($src$$Register, $src$$Register); // ensure top 32 bits 0
 8048     __ mov($tmp$$FloatRegister, __ T1D, 0, $src$$Register);
 8049     __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 8050     __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 8051     __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
 8052   %}
 8053 
 8054   ins_pipe(pipe_class_default);
 8055 %}
 8056 
<span class="line-modified"> 8057 instruct popCountI_mem(iRegINoSp dst, memory4 mem, vRegF tmp) %{</span>
 8058   predicate(UsePopCountInstruction);
 8059   match(Set dst (PopCountI (LoadI mem)));
 8060   effect(TEMP tmp);
 8061   ins_cost(INSN_COST * 13);
 8062 
 8063   format %{ &quot;ldrs   $tmp, $mem\n\t&quot;
 8064             &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
 8065             &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
 8066             &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
 8067   ins_encode %{
 8068     FloatRegister tmp_reg = as_FloatRegister($tmp$$reg);
 8069     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, tmp_reg, $mem-&gt;opcode(),
<span class="line-modified"> 8070               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);</span>
 8071     __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 8072     __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 8073     __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
 8074   %}
 8075 
 8076   ins_pipe(pipe_class_default);
 8077 %}
 8078 
 8079 // Note: Long.bitCount(long) returns an int.
 8080 instruct popCountL(iRegINoSp dst, iRegL src, vRegD tmp) %{
 8081   predicate(UsePopCountInstruction);
 8082   match(Set dst (PopCountL src));
 8083   effect(TEMP tmp);
 8084   ins_cost(INSN_COST * 13);
 8085 
 8086   format %{ &quot;mov    $tmp, $src\t# vector (1D)\n\t&quot;
 8087             &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
 8088             &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
 8089             &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
 8090   ins_encode %{
 8091     __ mov($tmp$$FloatRegister, __ T1D, 0, $src$$Register);
 8092     __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 8093     __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 8094     __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
 8095   %}
 8096 
 8097   ins_pipe(pipe_class_default);
 8098 %}
 8099 
<span class="line-modified"> 8100 instruct popCountL_mem(iRegINoSp dst, memory8 mem, vRegD tmp) %{</span>
 8101   predicate(UsePopCountInstruction);
 8102   match(Set dst (PopCountL (LoadL mem)));
 8103   effect(TEMP tmp);
 8104   ins_cost(INSN_COST * 13);
 8105 
 8106   format %{ &quot;ldrd   $tmp, $mem\n\t&quot;
 8107             &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
 8108             &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
 8109             &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
 8110   ins_encode %{
 8111     FloatRegister tmp_reg = as_FloatRegister($tmp$$reg);
 8112     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, tmp_reg, $mem-&gt;opcode(),
<span class="line-modified"> 8113               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);</span>
 8114     __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 8115     __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
 8116     __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
 8117   %}
 8118 
 8119   ins_pipe(pipe_class_default);
 8120 %}
 8121 
 8122 // ============================================================================
 8123 // MemBar Instruction
 8124 
 8125 instruct load_fence() %{
 8126   match(LoadFence);
 8127   ins_cost(VOLATILE_REF_COST);
 8128 
 8129   format %{ &quot;load_fence&quot; %}
 8130 
 8131   ins_encode %{
 8132     __ membar(Assembler::LoadLoad|Assembler::LoadStore);
 8133   %}
</pre>
<hr />
<pre>
 8303   ins_pipe(ialu_reg);
 8304 %}
 8305 
 8306 // Convert oop into int for vectors alignment masking
 8307 instruct convP2I(iRegINoSp dst, iRegP src) %{
 8308   match(Set dst (ConvL2I (CastP2X src)));
 8309 
 8310   ins_cost(INSN_COST);
 8311   format %{ &quot;movw $dst, $src\t# ptr -&gt; int&quot; %}
 8312   ins_encode %{
 8313     __ movw($dst$$Register, $src$$Register);
 8314   %}
 8315 
 8316   ins_pipe(ialu_reg);
 8317 %}
 8318 
 8319 // Convert compressed oop into int for vectors alignment masking
 8320 // in case of 32bit oops (heap &lt; 4Gb).
 8321 instruct convN2I(iRegINoSp dst, iRegN src)
 8322 %{
<span class="line-modified"> 8323   predicate(CompressedOops::shift() == 0);</span>
 8324   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 8325 
 8326   ins_cost(INSN_COST);
 8327   format %{ &quot;mov dst, $src\t# compressed ptr -&gt; int&quot; %}
 8328   ins_encode %{
 8329     __ movw($dst$$Register, $src$$Register);
 8330   %}
 8331 
 8332   ins_pipe(ialu_reg);
 8333 %}
 8334 
 8335 
 8336 // Convert oop pointer into compressed form
 8337 instruct encodeHeapOop(iRegNNoSp dst, iRegP src, rFlagsReg cr) %{
 8338   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 8339   match(Set dst (EncodeP src));
 8340   effect(KILL cr);
 8341   ins_cost(INSN_COST * 3);
 8342   format %{ &quot;encode_heap_oop $dst, $src&quot; %}
 8343   ins_encode %{
</pre>
<hr />
<pre>
 8439 %{
 8440   match(Set dst (CastPP dst));
 8441 
 8442   size(0);
 8443   format %{ &quot;# castPP of $dst&quot; %}
 8444   ins_encode(/* empty encoding */);
 8445   ins_pipe(pipe_class_empty);
 8446 %}
 8447 
 8448 instruct castII(iRegI dst)
 8449 %{
 8450   match(Set dst (CastII dst));
 8451 
 8452   size(0);
 8453   format %{ &quot;# castII of $dst&quot; %}
 8454   ins_encode(/* empty encoding */);
 8455   ins_cost(0);
 8456   ins_pipe(pipe_class_empty);
 8457 %}
 8458 
<span class="line-added"> 8459 instruct castLL(iRegL dst)</span>
<span class="line-added"> 8460 %{</span>
<span class="line-added"> 8461   match(Set dst (CastLL dst));</span>
<span class="line-added"> 8462 </span>
<span class="line-added"> 8463   size(0);</span>
<span class="line-added"> 8464   format %{ &quot;# castLL of $dst&quot; %}</span>
<span class="line-added"> 8465   ins_encode(/* empty encoding */);</span>
<span class="line-added"> 8466   ins_cost(0);</span>
<span class="line-added"> 8467   ins_pipe(pipe_class_empty);</span>
<span class="line-added"> 8468 %}</span>
<span class="line-added"> 8469 </span>
 8470 // ============================================================================
 8471 // Atomic operation instructions
 8472 //
 8473 // Intel and SPARC both implement Ideal Node LoadPLocked and
 8474 // Store{PIL}Conditional instructions using a normal load for the
 8475 // LoadPLocked and a CAS for the Store{PIL}Conditional.
 8476 //
 8477 // The ideal code appears only to use LoadPLocked/StorePLocked as a
 8478 // pair to lock object allocations from Eden space when not using
 8479 // TLABs.
 8480 //
 8481 // There does not appear to be a Load{IL}Locked Ideal Node and the
 8482 // Ideal code appears to use Store{IL}Conditional as an alias for CAS
 8483 // and to use StoreIConditional only for 32-bit and StoreLConditional
 8484 // only for 64-bit.
 8485 //
 8486 // We implement LoadPLocked and StorePLocked instructions using,
 8487 // respectively the AArch64 hw load-exclusive and store-conditional
 8488 // instructions. Whereas we must implement each of
 8489 // Store{IL}Conditional using a CAS which employs a pair of
</pre>
<hr />
<pre>
 8496 // implemented using ldaxr on AArch64
 8497 
 8498 instruct loadPLocked(iRegPNoSp dst, indirect mem)
 8499 %{
 8500   match(Set dst (LoadPLocked mem));
 8501 
 8502   ins_cost(VOLATILE_REF_COST);
 8503 
 8504   format %{ &quot;ldaxr $dst, $mem\t# ptr linked acquire&quot; %}
 8505 
 8506   ins_encode(aarch64_enc_ldaxr(dst, mem));
 8507 
 8508   ins_pipe(pipe_serial);
 8509 %}
 8510 
 8511 // Conditional-store of the updated heap-top.
 8512 // Used during allocation of the shared heap.
 8513 // Sets flag (EQ) on success.
 8514 // implemented using stlxr on AArch64.
 8515 
<span class="line-modified"> 8516 instruct storePConditional(memory8 heap_top_ptr, iRegP oldval, iRegP newval, rFlagsReg cr)</span>
 8517 %{
 8518   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 8519 
 8520   ins_cost(VOLATILE_REF_COST);
 8521 
 8522  // TODO
 8523  // do we need to do a store-conditional release or can we just use a
 8524  // plain store-conditional?
 8525 
 8526   format %{
 8527     &quot;stlxr rscratch1, $newval, $heap_top_ptr\t# ptr cond release&quot;
 8528     &quot;cmpw rscratch1, zr\t# EQ on successful write&quot;
 8529   %}
 8530 
 8531   ins_encode(aarch64_enc_stlxr(newval, heap_top_ptr));
 8532 
 8533   ins_pipe(pipe_serial);
 8534 %}
 8535 
 8536 
</pre>
<hr />
<pre>
 8637 
 8638   match(Set res (CompareAndSwapL mem (Binary oldval newval)));
 8639   ins_cost(2 * VOLATILE_REF_COST);
 8640 
 8641   effect(KILL cr);
 8642 
 8643  format %{
 8644     &quot;cmpxchg $mem, $oldval, $newval\t# (long) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8645     &quot;cset $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 8646  %}
 8647 
 8648  ins_encode(aarch64_enc_cmpxchg(mem, oldval, newval),
 8649             aarch64_enc_cset_eq(res));
 8650 
 8651   ins_pipe(pipe_slow);
 8652 %}
 8653 
 8654 instruct compareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
 8655 
 8656   match(Set res (CompareAndSwapP mem (Binary oldval newval)));
<span class="line-added"> 8657   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
 8658   ins_cost(2 * VOLATILE_REF_COST);
 8659 
 8660   effect(KILL cr);
 8661 
 8662  format %{
 8663     &quot;cmpxchg $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8664     &quot;cset $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 8665  %}
 8666 
 8667  ins_encode(aarch64_enc_cmpxchg(mem, oldval, newval),
 8668             aarch64_enc_cset_eq(res));
 8669 
 8670   ins_pipe(pipe_slow);
 8671 %}
 8672 
 8673 instruct compareAndSwapN(iRegINoSp res, indirect mem, iRegNNoSp oldval, iRegNNoSp newval, rFlagsReg cr) %{
 8674 
 8675   match(Set res (CompareAndSwapN mem (Binary oldval newval)));
 8676   ins_cost(2 * VOLATILE_REF_COST);
 8677 
</pre>
<hr />
<pre>
 8751 
 8752   predicate(needs_acquiring_load_exclusive(n));
 8753   match(Set res (CompareAndSwapL mem (Binary oldval newval)));
 8754   ins_cost(VOLATILE_REF_COST);
 8755 
 8756   effect(KILL cr);
 8757 
 8758  format %{
 8759     &quot;cmpxchg_acq $mem, $oldval, $newval\t# (long) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8760     &quot;cset $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 8761  %}
 8762 
 8763  ins_encode(aarch64_enc_cmpxchg_acq(mem, oldval, newval),
 8764             aarch64_enc_cset_eq(res));
 8765 
 8766   ins_pipe(pipe_slow);
 8767 %}
 8768 
 8769 instruct compareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
 8770 
<span class="line-modified"> 8771   predicate(needs_acquiring_load_exclusive(n) &amp;&amp; (n-&gt;as_LoadStore()-&gt;barrier_data() == 0));</span>
 8772   match(Set res (CompareAndSwapP mem (Binary oldval newval)));
 8773   ins_cost(VOLATILE_REF_COST);
 8774 
 8775   effect(KILL cr);
 8776 
 8777  format %{
 8778     &quot;cmpxchg_acq $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8779     &quot;cset $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 8780  %}
 8781 
 8782  ins_encode(aarch64_enc_cmpxchg_acq(mem, oldval, newval),
 8783             aarch64_enc_cset_eq(res));
 8784 
 8785   ins_pipe(pipe_slow);
 8786 %}
 8787 
 8788 instruct compareAndSwapNAcq(iRegINoSp res, indirect mem, iRegNNoSp oldval, iRegNNoSp newval, rFlagsReg cr) %{
 8789 
 8790   predicate(needs_acquiring_load_exclusive(n));
 8791   match(Set res (CompareAndSwapN mem (Binary oldval newval)));
</pre>
<hr />
<pre>
 8882   %}
 8883   ins_pipe(pipe_slow);
 8884 %}
 8885 
 8886 instruct compareAndExchangeN(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
 8887   match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
 8888   ins_cost(2 * VOLATILE_REF_COST);
 8889   effect(TEMP_DEF res, KILL cr);
 8890   format %{
 8891     &quot;cmpxchgw $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8892   %}
 8893   ins_encode %{
 8894     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 8895                Assembler::word, /*acquire*/ false, /*release*/ true,
 8896                /*weak*/ false, $res$$Register);
 8897   %}
 8898   ins_pipe(pipe_slow);
 8899 %}
 8900 
 8901 instruct compareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
<span class="line-added"> 8902   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
 8903   match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
 8904   ins_cost(2 * VOLATILE_REF_COST);
 8905   effect(TEMP_DEF res, KILL cr);
 8906   format %{
 8907     &quot;cmpxchg $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8908   %}
 8909   ins_encode %{
 8910     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 8911                Assembler::xword, /*acquire*/ false, /*release*/ true,
 8912                /*weak*/ false, $res$$Register);
 8913   %}
 8914   ins_pipe(pipe_slow);
 8915 %}
 8916 
 8917 instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
 8918   predicate(needs_acquiring_load_exclusive(n));
 8919   match(Set res (CompareAndExchangeB mem (Binary oldval newval)));
 8920   ins_cost(VOLATILE_REF_COST);
 8921   effect(TEMP_DEF res, KILL cr);
 8922   format %{
</pre>
<hr />
<pre>
 8982 %}
 8983 
 8984 
 8985 instruct compareAndExchangeNAcq(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
 8986   predicate(needs_acquiring_load_exclusive(n));
 8987   match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
 8988   ins_cost(VOLATILE_REF_COST);
 8989   effect(TEMP_DEF res, KILL cr);
 8990   format %{
 8991     &quot;cmpxchgw_acq $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 8992   %}
 8993   ins_encode %{
 8994     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 8995                Assembler::word, /*acquire*/ true, /*release*/ true,
 8996                /*weak*/ false, $res$$Register);
 8997   %}
 8998   ins_pipe(pipe_slow);
 8999 %}
 9000 
 9001 instruct compareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
<span class="line-modified"> 9002   predicate(needs_acquiring_load_exclusive(n) &amp;&amp; (n-&gt;as_LoadStore()-&gt;barrier_data() == 0));</span>
 9003   match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
 9004   ins_cost(VOLATILE_REF_COST);
 9005   effect(TEMP_DEF res, KILL cr);
 9006   format %{
 9007     &quot;cmpxchg_acq $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 9008   %}
 9009   ins_encode %{
 9010     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 9011                Assembler::xword, /*acquire*/ true, /*release*/ true,
 9012                /*weak*/ false, $res$$Register);
 9013   %}
 9014   ins_pipe(pipe_slow);
 9015 %}
 9016 
 9017 instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
 9018   match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));
 9019   ins_cost(2 * VOLATILE_REF_COST);
 9020   effect(KILL cr);
 9021   format %{
 9022     &quot;cmpxchgb $res = $mem, $oldval, $newval\t# (byte, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
</pre>
<hr />
<pre>
 9083 %}
 9084 
 9085 instruct weakCompareAndSwapN(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
 9086   match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
 9087   ins_cost(2 * VOLATILE_REF_COST);
 9088   effect(KILL cr);
 9089   format %{
 9090     &quot;cmpxchgw $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 9091     &quot;csetw $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 9092   %}
 9093   ins_encode %{
 9094     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 9095                Assembler::word, /*acquire*/ false, /*release*/ true,
 9096                /*weak*/ true, noreg);
 9097     __ csetw($res$$Register, Assembler::EQ);
 9098   %}
 9099   ins_pipe(pipe_slow);
 9100 %}
 9101 
 9102 instruct weakCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
<span class="line-added"> 9103   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
 9104   match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
 9105   ins_cost(2 * VOLATILE_REF_COST);
 9106   effect(KILL cr);
 9107   format %{
 9108     &quot;cmpxchg $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 9109     &quot;csetw $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 9110   %}
 9111   ins_encode %{
 9112     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 9113                Assembler::xword, /*acquire*/ false, /*release*/ true,
 9114                /*weak*/ true, noreg);
 9115     __ csetw($res$$Register, Assembler::EQ);
 9116   %}
 9117   ins_pipe(pipe_slow);
 9118 %}
 9119 
 9120 instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
 9121   predicate(needs_acquiring_load_exclusive(n));
 9122   match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));
 9123   ins_cost(VOLATILE_REF_COST);
</pre>
<hr />
<pre>
 9191 
 9192 instruct weakCompareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
 9193   predicate(needs_acquiring_load_exclusive(n));
 9194   match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
 9195   ins_cost(VOLATILE_REF_COST);
 9196   effect(KILL cr);
 9197   format %{
 9198     &quot;cmpxchgw_acq $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 9199     &quot;csetw $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 9200   %}
 9201   ins_encode %{
 9202     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 9203                Assembler::word, /*acquire*/ true, /*release*/ true,
 9204                /*weak*/ true, noreg);
 9205     __ csetw($res$$Register, Assembler::EQ);
 9206   %}
 9207   ins_pipe(pipe_slow);
 9208 %}
 9209 
 9210 instruct weakCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{

 9211   match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
<span class="line-added"> 9212   predicate(needs_acquiring_load_exclusive(n) &amp;&amp; (n-&gt;as_LoadStore()-&gt;barrier_data() == 0));</span>
 9213   ins_cost(VOLATILE_REF_COST);
 9214   effect(KILL cr);
 9215   format %{
 9216     &quot;cmpxchg_acq $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem &lt;-- $newval&quot;
 9217     &quot;csetw $res, EQ\t# $res &lt;-- (EQ ? 1 : 0)&quot;
 9218   %}
 9219   ins_encode %{
 9220     __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
 9221                Assembler::xword, /*acquire*/ true, /*release*/ true,
 9222                /*weak*/ true, noreg);
 9223     __ csetw($res$$Register, Assembler::EQ);
 9224   %}
 9225   ins_pipe(pipe_slow);
 9226 %}
 9227 
 9228 // END This section of the file is automatically generated. Do not edit --------------
 9229 // ---------------------------------------------------------------------
 9230 
 9231 instruct get_and_setI(indirect mem, iRegI newv, iRegINoSp prev) %{
 9232   match(Set prev (GetAndSetI mem newv));
</pre>
<hr />
<pre>
 9242   match(Set prev (GetAndSetL mem newv));
 9243   ins_cost(2 * VOLATILE_REF_COST);
 9244   format %{ &quot;atomic_xchg  $prev, $newv, [$mem]&quot; %}
 9245   ins_encode %{
 9246     __ atomic_xchg($prev$$Register, $newv$$Register, as_Register($mem$$base));
 9247   %}
 9248   ins_pipe(pipe_serial);
 9249 %}
 9250 
 9251 instruct get_and_setN(indirect mem, iRegN newv, iRegINoSp prev) %{
 9252   match(Set prev (GetAndSetN mem newv));
 9253   ins_cost(2 * VOLATILE_REF_COST);
 9254   format %{ &quot;atomic_xchgw $prev, $newv, [$mem]&quot; %}
 9255   ins_encode %{
 9256     __ atomic_xchgw($prev$$Register, $newv$$Register, as_Register($mem$$base));
 9257   %}
 9258   ins_pipe(pipe_serial);
 9259 %}
 9260 
 9261 instruct get_and_setP(indirect mem, iRegP newv, iRegPNoSp prev) %{
<span class="line-added"> 9262   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
 9263   match(Set prev (GetAndSetP mem newv));
 9264   ins_cost(2 * VOLATILE_REF_COST);
 9265   format %{ &quot;atomic_xchg  $prev, $newv, [$mem]&quot; %}
 9266   ins_encode %{
 9267     __ atomic_xchg($prev$$Register, $newv$$Register, as_Register($mem$$base));
 9268   %}
 9269   ins_pipe(pipe_serial);
 9270 %}
 9271 
 9272 instruct get_and_setIAcq(indirect mem, iRegI newv, iRegINoSp prev) %{
 9273   predicate(needs_acquiring_load_exclusive(n));
 9274   match(Set prev (GetAndSetI mem newv));
 9275   ins_cost(VOLATILE_REF_COST);
 9276   format %{ &quot;atomic_xchgw_acq  $prev, $newv, [$mem]&quot; %}
 9277   ins_encode %{
 9278     __ atomic_xchgalw($prev$$Register, $newv$$Register, as_Register($mem$$base));
 9279   %}
 9280   ins_pipe(pipe_serial);
 9281 %}
 9282 
</pre>
<hr />
<pre>
 9286   ins_cost(VOLATILE_REF_COST);
 9287   format %{ &quot;atomic_xchg_acq  $prev, $newv, [$mem]&quot; %}
 9288   ins_encode %{
 9289     __ atomic_xchgal($prev$$Register, $newv$$Register, as_Register($mem$$base));
 9290   %}
 9291   ins_pipe(pipe_serial);
 9292 %}
 9293 
 9294 instruct get_and_setNAcq(indirect mem, iRegN newv, iRegINoSp prev) %{
 9295   predicate(needs_acquiring_load_exclusive(n));
 9296   match(Set prev (GetAndSetN mem newv));
 9297   ins_cost(VOLATILE_REF_COST);
 9298   format %{ &quot;atomic_xchgw_acq $prev, $newv, [$mem]&quot; %}
 9299   ins_encode %{
 9300     __ atomic_xchgalw($prev$$Register, $newv$$Register, as_Register($mem$$base));
 9301   %}
 9302   ins_pipe(pipe_serial);
 9303 %}
 9304 
 9305 instruct get_and_setPAcq(indirect mem, iRegP newv, iRegPNoSp prev) %{
<span class="line-modified"> 9306   predicate(needs_acquiring_load_exclusive(n) &amp;&amp; (n-&gt;as_LoadStore()-&gt;barrier_data() == 0));</span>
 9307   match(Set prev (GetAndSetP mem newv));
 9308   ins_cost(VOLATILE_REF_COST);
 9309   format %{ &quot;atomic_xchg_acq  $prev, $newv, [$mem]&quot; %}
 9310   ins_encode %{
 9311     __ atomic_xchgal($prev$$Register, $newv$$Register, as_Register($mem$$base));
 9312   %}
 9313   ins_pipe(pipe_serial);
 9314 %}
 9315 
 9316 
 9317 instruct get_and_addL(indirect mem, iRegLNoSp newval, iRegL incr) %{
 9318   match(Set newval (GetAndAddL mem incr));
 9319   ins_cost(2 * VOLATILE_REF_COST + 1);
 9320   format %{ &quot;get_and_addL $newval, [$mem], $incr&quot; %}
 9321   ins_encode %{
 9322     __ atomic_add($newval$$Register, $incr$$Register, as_Register($mem$$base));
 9323   %}
 9324   ins_pipe(pipe_serial);
 9325 %}
 9326 
</pre>
<hr />
<pre>
10488 %}
10489 
10490 // Combined Long Multiply &amp; Neg
10491 
10492 instruct mnegL(iRegLNoSp dst, iRegL src1, iRegL src2, immL0 zero) %{
10493   match(Set dst (MulL (SubL zero src1) src2));
10494   match(Set dst (MulL src1 (SubL zero src2)));
10495 
10496   ins_cost(INSN_COST * 5);
10497   format %{ &quot;mneg  $dst, $src1, $src2&quot; %}
10498 
10499   ins_encode %{
10500     __ mneg(as_Register($dst$$reg),
10501             as_Register($src1$$reg),
10502             as_Register($src2$$reg));
10503   %}
10504 
10505   ins_pipe(lmac_reg_reg);
10506 %}
10507 
<span class="line-added">10508 // Combine Integer Signed Multiply &amp; Add/Sub/Neg Long</span>
<span class="line-added">10509 </span>
<span class="line-added">10510 instruct smaddL(iRegLNoSp dst, iRegIorL2I src1, iRegIorL2I src2, iRegLNoSp src3) %{</span>
<span class="line-added">10511   match(Set dst (AddL src3 (MulL (ConvI2L src1) (ConvI2L src2))));</span>
<span class="line-added">10512 </span>
<span class="line-added">10513   ins_cost(INSN_COST * 3);</span>
<span class="line-added">10514   format %{ &quot;smaddl  $dst, $src1, $src2, $src3&quot; %}</span>
<span class="line-added">10515 </span>
<span class="line-added">10516   ins_encode %{</span>
<span class="line-added">10517     __ smaddl(as_Register($dst$$reg),</span>
<span class="line-added">10518               as_Register($src1$$reg),</span>
<span class="line-added">10519               as_Register($src2$$reg),</span>
<span class="line-added">10520               as_Register($src3$$reg));</span>
<span class="line-added">10521   %}</span>
<span class="line-added">10522 </span>
<span class="line-added">10523   ins_pipe(imac_reg_reg);</span>
<span class="line-added">10524 %}</span>
<span class="line-added">10525 </span>
<span class="line-added">10526 instruct smsubL(iRegLNoSp dst, iRegIorL2I src1, iRegIorL2I src2, iRegLNoSp src3) %{</span>
<span class="line-added">10527   match(Set dst (SubL src3 (MulL (ConvI2L src1) (ConvI2L src2))));</span>
<span class="line-added">10528 </span>
<span class="line-added">10529   ins_cost(INSN_COST * 3);</span>
<span class="line-added">10530   format %{ &quot;smsubl  $dst, $src1, $src2, $src3&quot; %}</span>
<span class="line-added">10531 </span>
<span class="line-added">10532   ins_encode %{</span>
<span class="line-added">10533     __ smsubl(as_Register($dst$$reg),</span>
<span class="line-added">10534               as_Register($src1$$reg),</span>
<span class="line-added">10535               as_Register($src2$$reg),</span>
<span class="line-added">10536               as_Register($src3$$reg));</span>
<span class="line-added">10537   %}</span>
<span class="line-added">10538 </span>
<span class="line-added">10539   ins_pipe(imac_reg_reg);</span>
<span class="line-added">10540 %}</span>
<span class="line-added">10541 </span>
<span class="line-added">10542 instruct smnegL(iRegLNoSp dst, iRegIorL2I src1, iRegIorL2I src2, immL0 zero) %{</span>
<span class="line-added">10543   match(Set dst (MulL (SubL zero (ConvI2L src1)) (ConvI2L src2)));</span>
<span class="line-added">10544   match(Set dst (MulL (ConvI2L src1) (SubL zero (ConvI2L src2))));</span>
<span class="line-added">10545 </span>
<span class="line-added">10546   ins_cost(INSN_COST * 3);</span>
<span class="line-added">10547   format %{ &quot;smnegl  $dst, $src1, $src2&quot; %}</span>
<span class="line-added">10548 </span>
<span class="line-added">10549   ins_encode %{</span>
<span class="line-added">10550     __ smnegl(as_Register($dst$$reg),</span>
<span class="line-added">10551               as_Register($src1$$reg),</span>
<span class="line-added">10552               as_Register($src2$$reg));</span>
<span class="line-added">10553   %}</span>
<span class="line-added">10554 </span>
<span class="line-added">10555   ins_pipe(imac_reg_reg);</span>
<span class="line-added">10556 %}</span>
<span class="line-added">10557 </span>
10558 // Integer Divide
10559 
10560 instruct divI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{
10561   match(Set dst (DivI src1 src2));
10562 
10563   ins_cost(INSN_COST * 19);
10564   format %{ &quot;sdivw  $dst, $src1, $src2&quot; %}
10565 
10566   ins_encode(aarch64_enc_divw(dst, src1, src2));
10567   ins_pipe(idiv_reg_reg);
10568 %}
10569 
10570 instruct signExtract(iRegINoSp dst, iRegIorL2I src1, immI_31 div1, immI_31 div2) %{
10571   match(Set dst (URShiftI (RShiftI src1 div1) div2));
10572   ins_cost(INSN_COST);
10573   format %{ &quot;lsrw $dst, $src1, $div1&quot; %}
10574   ins_encode %{
10575     __ lsrw(as_Register($dst$$reg), as_Register($src1$$reg), 31);
10576   %}
10577   ins_pipe(ialu_reg_shift);
</pre>
<hr />
<pre>
11889   format %{ &quot;sub  $dst, $src1, $src2, LSL $src3&quot; %}
11890 
11891   ins_encode %{
11892     __ sub(as_Register($dst$$reg),
11893               as_Register($src1$$reg),
11894               as_Register($src2$$reg),
11895               Assembler::LSL,
11896               $src3$$constant &amp; 0x3f);
11897   %}
11898 
11899   ins_pipe(ialu_reg_reg_shift);
11900 %}
11901 
11902 
11903 
11904 // Shift Left followed by Shift Right.
11905 // This idiom is used by the compiler for the i2b bytecode etc.
11906 instruct sbfmL(iRegLNoSp dst, iRegL src, immI lshift_count, immI rshift_count)
11907 %{
11908   match(Set dst (RShiftL (LShiftL src lshift_count) rshift_count));




11909   ins_cost(INSN_COST * 2);
11910   format %{ &quot;sbfm  $dst, $src, $rshift_count - $lshift_count, #63 - $lshift_count&quot; %}
11911   ins_encode %{
<span class="line-modified">11912     int lshift = $lshift_count$$constant &amp; 63;</span>
<span class="line-added">11913     int rshift = $rshift_count$$constant &amp; 63;</span>
11914     int s = 63 - lshift;
11915     int r = (rshift - lshift) &amp; 63;
11916     __ sbfm(as_Register($dst$$reg),
11917             as_Register($src$$reg),
11918             r, s);
11919   %}
11920 
11921   ins_pipe(ialu_reg_shift);
11922 %}
11923 
11924 // Shift Left followed by Shift Right.
11925 // This idiom is used by the compiler for the i2b bytecode etc.
11926 instruct sbfmwI(iRegINoSp dst, iRegIorL2I src, immI lshift_count, immI rshift_count)
11927 %{
11928   match(Set dst (RShiftI (LShiftI src lshift_count) rshift_count));




11929   ins_cost(INSN_COST * 2);
11930   format %{ &quot;sbfmw  $dst, $src, $rshift_count - $lshift_count, #31 - $lshift_count&quot; %}
11931   ins_encode %{
<span class="line-modified">11932     int lshift = $lshift_count$$constant &amp; 31;</span>
<span class="line-added">11933     int rshift = $rshift_count$$constant &amp; 31;</span>
11934     int s = 31 - lshift;
11935     int r = (rshift - lshift) &amp; 31;
11936     __ sbfmw(as_Register($dst$$reg),
11937             as_Register($src$$reg),
11938             r, s);
11939   %}
11940 
11941   ins_pipe(ialu_reg_shift);
11942 %}
11943 
11944 // Shift Left followed by Shift Right.
11945 // This idiom is used by the compiler for the i2b bytecode etc.
11946 instruct ubfmL(iRegLNoSp dst, iRegL src, immI lshift_count, immI rshift_count)
11947 %{
11948   match(Set dst (URShiftL (LShiftL src lshift_count) rshift_count));




11949   ins_cost(INSN_COST * 2);
11950   format %{ &quot;ubfm  $dst, $src, $rshift_count - $lshift_count, #63 - $lshift_count&quot; %}
11951   ins_encode %{
<span class="line-modified">11952     int lshift = $lshift_count$$constant &amp; 63;</span>
<span class="line-added">11953     int rshift = $rshift_count$$constant &amp; 63;</span>
11954     int s = 63 - lshift;
11955     int r = (rshift - lshift) &amp; 63;
11956     __ ubfm(as_Register($dst$$reg),
11957             as_Register($src$$reg),
11958             r, s);
11959   %}
11960 
11961   ins_pipe(ialu_reg_shift);
11962 %}
11963 
11964 // Shift Left followed by Shift Right.
11965 // This idiom is used by the compiler for the i2b bytecode etc.
11966 instruct ubfmwI(iRegINoSp dst, iRegIorL2I src, immI lshift_count, immI rshift_count)
11967 %{
11968   match(Set dst (URShiftI (LShiftI src lshift_count) rshift_count));




11969   ins_cost(INSN_COST * 2);
11970   format %{ &quot;ubfmw  $dst, $src, $rshift_count - $lshift_count, #31 - $lshift_count&quot; %}
11971   ins_encode %{
<span class="line-modified">11972     int lshift = $lshift_count$$constant &amp; 31;</span>
<span class="line-added">11973     int rshift = $rshift_count$$constant &amp; 31;</span>
11974     int s = 31 - lshift;
11975     int r = (rshift - lshift) &amp; 31;
11976     __ ubfmw(as_Register($dst$$reg),
11977             as_Register($src$$reg),
11978             r, s);
11979   %}
11980 
11981   ins_pipe(ialu_reg_shift);
11982 %}
11983 // Bitfield extract with shift &amp; mask
11984 
11985 instruct ubfxwI(iRegINoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
11986 %{
11987   match(Set dst (AndI (URShiftI src rshift) mask));
<span class="line-added">11988   // Make sure we are not going to exceed what ubfxw can do.</span>
<span class="line-added">11989   predicate((exact_log2(n-&gt;in(2)-&gt;get_int() + 1) + (n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 31)) &lt;= (31 + 1));</span>
11990 
11991   ins_cost(INSN_COST);
11992   format %{ &quot;ubfxw $dst, $src, $rshift, $mask&quot; %}
11993   ins_encode %{
<span class="line-modified">11994     int rshift = $rshift$$constant &amp; 31;</span>
11995     long mask = $mask$$constant;
11996     int width = exact_log2(mask+1);
11997     __ ubfxw(as_Register($dst$$reg),
11998             as_Register($src$$reg), rshift, width);
11999   %}
12000   ins_pipe(ialu_reg_shift);
12001 %}
12002 instruct ubfxL(iRegLNoSp dst, iRegL src, immI rshift, immL_bitmask mask)
12003 %{
12004   match(Set dst (AndL (URShiftL src rshift) mask));
<span class="line-added">12005   // Make sure we are not going to exceed what ubfx can do.</span>
<span class="line-added">12006   predicate((exact_log2_long(n-&gt;in(2)-&gt;get_long() + 1) + (n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 63)) &lt;= (63 + 1));</span>
12007 
12008   ins_cost(INSN_COST);
12009   format %{ &quot;ubfx $dst, $src, $rshift, $mask&quot; %}
12010   ins_encode %{
<span class="line-modified">12011     int rshift = $rshift$$constant &amp; 63;</span>
12012     long mask = $mask$$constant;
<span class="line-modified">12013     int width = exact_log2_long(mask+1);</span>
12014     __ ubfx(as_Register($dst$$reg),
12015             as_Register($src$$reg), rshift, width);
12016   %}
12017   ins_pipe(ialu_reg_shift);
12018 %}
12019 
12020 // We can use ubfx when extending an And with a mask when we know mask
12021 // is positive.  We know that because immI_bitmask guarantees it.
12022 instruct ubfxIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
12023 %{
12024   match(Set dst (ConvI2L (AndI (URShiftI src rshift) mask)));
<span class="line-added">12025   // Make sure we are not going to exceed what ubfxw can do.</span>
<span class="line-added">12026   predicate((exact_log2(n-&gt;in(1)-&gt;in(2)-&gt;get_int() + 1) + (n-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 31)) &lt;= (31 + 1));</span>
12027 
12028   ins_cost(INSN_COST * 2);
12029   format %{ &quot;ubfx $dst, $src, $rshift, $mask&quot; %}
12030   ins_encode %{
<span class="line-modified">12031     int rshift = $rshift$$constant &amp; 31;</span>
12032     long mask = $mask$$constant;
12033     int width = exact_log2(mask+1);
12034     __ ubfx(as_Register($dst$$reg),
12035             as_Register($src$$reg), rshift, width);
12036   %}
12037   ins_pipe(ialu_reg_shift);
12038 %}
12039 
12040 // We can use ubfiz when masking by a positive number and then left shifting the result.
12041 // We know that the mask is positive because immI_bitmask guarantees it.
12042 instruct ubfizwI(iRegINoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
12043 %{
12044   match(Set dst (LShiftI (AndI src mask) lshift));
<span class="line-modified">12045   predicate((exact_log2(n-&gt;in(1)-&gt;in(2)-&gt;get_int() + 1) + (n-&gt;in(2)-&gt;get_int() &amp; 31)) &lt;= (31 + 1));</span>

12046 
12047   ins_cost(INSN_COST);
12048   format %{ &quot;ubfizw $dst, $src, $lshift, $mask&quot; %}
12049   ins_encode %{
<span class="line-modified">12050     int lshift = $lshift$$constant &amp; 31;</span>
12051     long mask = $mask$$constant;
12052     int width = exact_log2(mask+1);
12053     __ ubfizw(as_Register($dst$$reg),
12054           as_Register($src$$reg), lshift, width);
12055   %}
12056   ins_pipe(ialu_reg_shift);
12057 %}
12058 // We can use ubfiz when masking by a positive number and then left shifting the result.
12059 // We know that the mask is positive because immL_bitmask guarantees it.
12060 instruct ubfizL(iRegLNoSp dst, iRegL src, immI lshift, immL_bitmask mask)
12061 %{
12062   match(Set dst (LShiftL (AndL src mask) lshift));
<span class="line-modified">12063   predicate((exact_log2_long(n-&gt;in(1)-&gt;in(2)-&gt;get_long() + 1) + (n-&gt;in(2)-&gt;get_int() &amp; 63)) &lt;= (63 + 1));</span>

12064 
12065   ins_cost(INSN_COST);
12066   format %{ &quot;ubfiz $dst, $src, $lshift, $mask&quot; %}
12067   ins_encode %{
<span class="line-modified">12068     int lshift = $lshift$$constant &amp; 63;</span>
12069     long mask = $mask$$constant;
<span class="line-modified">12070     int width = exact_log2_long(mask+1);</span>
12071     __ ubfiz(as_Register($dst$$reg),
12072           as_Register($src$$reg), lshift, width);
12073   %}
12074   ins_pipe(ialu_reg_shift);
12075 %}
12076 
12077 // If there is a convert I to L block between and AndI and a LShiftL, we can also match ubfiz
12078 instruct ubfizIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
12079 %{
<span class="line-modified">12080   match(Set dst (LShiftL (ConvI2L (AndI src mask)) lshift));</span>
<span class="line-modified">12081   predicate((exact_log2(n-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;get_int() + 1) + (n-&gt;in(2)-&gt;get_int() &amp; 63)) &lt;= (63 + 1));</span>

12082 
12083   ins_cost(INSN_COST);
12084   format %{ &quot;ubfiz $dst, $src, $lshift, $mask&quot; %}
12085   ins_encode %{
<span class="line-modified">12086     int lshift = $lshift$$constant &amp; 63;</span>
12087     long mask = $mask$$constant;
12088     int width = exact_log2(mask+1);
12089     __ ubfiz(as_Register($dst$$reg),
12090              as_Register($src$$reg), lshift, width);
12091   %}
12092   ins_pipe(ialu_reg_shift);
12093 %}
12094 
12095 // Rotations
12096 
12097 instruct extrOrL(iRegLNoSp dst, iRegL src1, iRegL src2, immI lshift, immI rshift, rFlagsReg cr)
12098 %{
12099   match(Set dst (OrL (LShiftL src1 lshift) (URShiftL src2 rshift)));
<span class="line-modified">12100   predicate(0 == (((n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 63) + (n-&gt;in(2)-&gt;in(2)-&gt;get_int() &amp; 63)) &amp; 63));</span>
12101 
12102   ins_cost(INSN_COST);
12103   format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
12104 
12105   ins_encode %{
12106     __ extr(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg),
12107             $rshift$$constant &amp; 63);
12108   %}
12109   ins_pipe(ialu_reg_reg_extr);
12110 %}
12111 
12112 instruct extrOrI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI lshift, immI rshift, rFlagsReg cr)
12113 %{
12114   match(Set dst (OrI (LShiftI src1 lshift) (URShiftI src2 rshift)));
<span class="line-modified">12115   predicate(0 == (((n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 31) + (n-&gt;in(2)-&gt;in(2)-&gt;get_int() &amp; 31)) &amp; 31));</span>
12116 
12117   ins_cost(INSN_COST);
12118   format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
12119 
12120   ins_encode %{
12121     __ extrw(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg),
12122             $rshift$$constant &amp; 31);
12123   %}
12124   ins_pipe(ialu_reg_reg_extr);
12125 %}
12126 
12127 instruct extrAddL(iRegLNoSp dst, iRegL src1, iRegL src2, immI lshift, immI rshift, rFlagsReg cr)
12128 %{
12129   match(Set dst (AddL (LShiftL src1 lshift) (URShiftL src2 rshift)));
<span class="line-modified">12130   predicate(0 == (((n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 63) + (n-&gt;in(2)-&gt;in(2)-&gt;get_int() &amp; 63)) &amp; 63));</span>
12131 
12132   ins_cost(INSN_COST);
12133   format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
12134 
12135   ins_encode %{
12136     __ extr(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg),
12137             $rshift$$constant &amp; 63);
12138   %}
12139   ins_pipe(ialu_reg_reg_extr);
12140 %}
12141 
12142 instruct extrAddI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI lshift, immI rshift, rFlagsReg cr)
12143 %{
12144   match(Set dst (AddI (LShiftI src1 lshift) (URShiftI src2 rshift)));
<span class="line-modified">12145   predicate(0 == (((n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 31) + (n-&gt;in(2)-&gt;in(2)-&gt;get_int() &amp; 31)) &amp; 31));</span>
12146 
12147   ins_cost(INSN_COST);
12148   format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
12149 
12150   ins_encode %{
12151     __ extrw(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg),
12152             $rshift$$constant &amp; 31);
12153   %}
12154   ins_pipe(ialu_reg_reg_extr);
12155 %}
12156 
12157 
12158 // rol expander
12159 
12160 instruct rolL_rReg(iRegLNoSp dst, iRegL src, iRegI shift, rFlagsReg cr)
12161 %{
12162   effect(DEF dst, USE src, USE shift);
12163 
12164   format %{ &quot;rol    $dst, $src, $shift&quot; %}
12165   ins_cost(INSN_COST * 3);
</pre>
<hr />
<pre>
13215     __ fsqrtd(as_FloatRegister($dst$$reg),
13216              as_FloatRegister($src$$reg));
13217   %}
13218 
13219   ins_pipe(fp_div_s);
13220 %}
13221 
13222 instruct sqrtF_reg(vRegF dst, vRegF src) %{
13223   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
13224 
13225   ins_cost(INSN_COST * 50);
13226   format %{ &quot;fsqrts  $dst, $src&quot; %}
13227   ins_encode %{
13228     __ fsqrts(as_FloatRegister($dst$$reg),
13229              as_FloatRegister($src$$reg));
13230   %}
13231 
13232   ins_pipe(fp_div_d);
13233 %}
13234 
<span class="line-added">13235 // Math.rint, floor, ceil</span>
<span class="line-added">13236 instruct roundD_reg(vRegD dst, vRegD src, immI rmode) %{</span>
<span class="line-added">13237   match(Set dst (RoundDoubleMode src rmode));</span>
<span class="line-added">13238   format %{ &quot;frint  $dst, $src, $rmode&quot; %}</span>
<span class="line-added">13239   ins_encode %{</span>
<span class="line-added">13240     switch ($rmode$$constant) {</span>
<span class="line-added">13241       case RoundDoubleModeNode::rmode_rint:</span>
<span class="line-added">13242         __ frintnd(as_FloatRegister($dst$$reg),</span>
<span class="line-added">13243                    as_FloatRegister($src$$reg));</span>
<span class="line-added">13244         break;</span>
<span class="line-added">13245       case RoundDoubleModeNode::rmode_floor:</span>
<span class="line-added">13246         __ frintmd(as_FloatRegister($dst$$reg),</span>
<span class="line-added">13247                    as_FloatRegister($src$$reg));</span>
<span class="line-added">13248         break;</span>
<span class="line-added">13249       case RoundDoubleModeNode::rmode_ceil:</span>
<span class="line-added">13250         __ frintpd(as_FloatRegister($dst$$reg),</span>
<span class="line-added">13251                    as_FloatRegister($src$$reg));</span>
<span class="line-added">13252         break;</span>
<span class="line-added">13253     }</span>
<span class="line-added">13254   %}</span>
<span class="line-added">13255   ins_pipe(fp_uop_d);</span>
<span class="line-added">13256 %}</span>
<span class="line-added">13257 </span>
13258 // ============================================================================
13259 // Logical Instructions
13260 
13261 // Integer Logical Instructions
13262 
13263 // And Instructions
13264 
13265 
13266 instruct andI_reg_reg(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, rFlagsReg cr) %{
13267   match(Set dst (AndI src1 src2));
13268 
13269   format %{ &quot;andw  $dst, $src1, $src2\t# int&quot; %}
13270 
13271   ins_cost(INSN_COST);
13272   ins_encode %{
13273     __ andw(as_Register($dst$$reg),
13274             as_Register($src1$$reg),
13275             as_Register($src2$$reg));
13276   %}
13277 
</pre>
<hr />
<pre>
14432   match(Set cr (CmpF src1 src2));
14433 
14434   ins_cost(3 * INSN_COST);
14435   format %{ &quot;fcmps $src1, $src2&quot; %}
14436 
14437   ins_encode %{
14438     __ fcmps(as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
14439   %}
14440 
14441   ins_pipe(pipe_class_compare);
14442 %}
14443 
14444 instruct compF_reg_zero(rFlagsReg cr, vRegF src1, immF0 src2)
14445 %{
14446   match(Set cr (CmpF src1 src2));
14447 
14448   ins_cost(3 * INSN_COST);
14449   format %{ &quot;fcmps $src1, 0.0&quot; %}
14450 
14451   ins_encode %{
<span class="line-modified">14452     __ fcmps(as_FloatRegister($src1$$reg), 0.0);</span>
14453   %}
14454 
14455   ins_pipe(pipe_class_compare);
14456 %}
14457 // FROM HERE
14458 
14459 instruct compD_reg_reg(rFlagsReg cr, vRegD src1, vRegD src2)
14460 %{
14461   match(Set cr (CmpD src1 src2));
14462 
14463   ins_cost(3 * INSN_COST);
14464   format %{ &quot;fcmpd $src1, $src2&quot; %}
14465 
14466   ins_encode %{
14467     __ fcmpd(as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
14468   %}
14469 
14470   ins_pipe(pipe_class_compare);
14471 %}
14472 
14473 instruct compD_reg_zero(rFlagsReg cr, vRegD src1, immD0 src2)
14474 %{
14475   match(Set cr (CmpD src1 src2));
14476 
14477   ins_cost(3 * INSN_COST);
14478   format %{ &quot;fcmpd $src1, 0.0&quot; %}
14479 
14480   ins_encode %{
<span class="line-modified">14481     __ fcmpd(as_FloatRegister($src1$$reg), 0.0);</span>
14482   %}
14483 
14484   ins_pipe(pipe_class_compare);
14485 %}
14486 
14487 instruct compF3_reg_reg(iRegINoSp dst, vRegF src1, vRegF src2, rFlagsReg cr)
14488 %{
14489   match(Set dst (CmpF3 src1 src2));
14490   effect(KILL cr);
14491 
14492   ins_cost(5 * INSN_COST);
14493   format %{ &quot;fcmps $src1, $src2\n\t&quot;
14494             &quot;csinvw($dst, zr, zr, eq\n\t&quot;
14495             &quot;csnegw($dst, $dst, $dst, lt)&quot;
14496   %}
14497 
14498   ins_encode %{
14499     Label done;
14500     FloatRegister s1 = as_FloatRegister($src1$$reg);
14501     FloatRegister s2 = as_FloatRegister($src2$$reg);
</pre>
<hr />
<pre>
14537   %}
14538   ins_pipe(pipe_class_default);
14539 
14540 %}
14541 
14542 instruct compF3_reg_immF0(iRegINoSp dst, vRegF src1, immF0 zero, rFlagsReg cr)
14543 %{
14544   match(Set dst (CmpF3 src1 zero));
14545   effect(KILL cr);
14546 
14547   ins_cost(5 * INSN_COST);
14548   format %{ &quot;fcmps $src1, 0.0\n\t&quot;
14549             &quot;csinvw($dst, zr, zr, eq\n\t&quot;
14550             &quot;csnegw($dst, $dst, $dst, lt)&quot;
14551   %}
14552 
14553   ins_encode %{
14554     Label done;
14555     FloatRegister s1 = as_FloatRegister($src1$$reg);
14556     Register d = as_Register($dst$$reg);
<span class="line-modified">14557     __ fcmps(s1, 0.0);</span>
14558     // installs 0 if EQ else -1
14559     __ csinvw(d, zr, zr, Assembler::EQ);
14560     // keeps -1 if less or unordered else installs 1
14561     __ csnegw(d, d, d, Assembler::LT);
14562     __ bind(done);
14563   %}
14564 
14565   ins_pipe(pipe_class_default);
14566 
14567 %}
14568 
14569 instruct compD3_reg_immD0(iRegINoSp dst, vRegD src1, immD0 zero, rFlagsReg cr)
14570 %{
14571   match(Set dst (CmpD3 src1 zero));
14572   effect(KILL cr);
14573 
14574   ins_cost(5 * INSN_COST);
14575   format %{ &quot;fcmpd $src1, 0.0\n\t&quot;
14576             &quot;csinvw($dst, zr, zr, eq\n\t&quot;
14577             &quot;csnegw($dst, $dst, $dst, lt)&quot;
14578   %}
14579 
14580   ins_encode %{
14581     Label done;
14582     FloatRegister s1 = as_FloatRegister($src1$$reg);
14583     Register d = as_Register($dst$$reg);
<span class="line-modified">14584     __ fcmpd(s1, 0.0);</span>
14585     // installs 0 if EQ else -1
14586     __ csinvw(d, zr, zr, Assembler::EQ);
14587     // keeps -1 if less or unordered else installs 1
14588     __ csnegw(d, d, d, Assembler::LT);
14589     __ bind(done);
14590   %}
14591   ins_pipe(pipe_class_default);
14592 
14593 %}
14594 
14595 instruct cmpLTMask_reg_reg(iRegINoSp dst, iRegIorL2I p, iRegIorL2I q, rFlagsReg cr)
14596 %{
14597   match(Set dst (CmpLTMask p q));
14598   effect(KILL cr);
14599 
14600   ins_cost(3 * INSN_COST);
14601 
14602   format %{ &quot;cmpw $p, $q\t# cmpLTMask\n\t&quot;
14603             &quot;csetw $dst, lt\n\t&quot;
14604             &quot;subw $dst, zr, $dst&quot;
</pre>
<hr />
<pre>
14615 
14616 instruct cmpLTMask_reg_zero(iRegINoSp dst, iRegIorL2I src, immI0 zero, rFlagsReg cr)
14617 %{
14618   match(Set dst (CmpLTMask src zero));
14619   effect(KILL cr);
14620 
14621   ins_cost(INSN_COST);
14622 
14623   format %{ &quot;asrw $dst, $src, #31\t# cmpLTMask0&quot; %}
14624 
14625   ins_encode %{
14626     __ asrw(as_Register($dst$$reg), as_Register($src$$reg), 31);
14627   %}
14628 
14629   ins_pipe(ialu_reg_shift);
14630 %}
14631 
14632 // ============================================================================
14633 // Max and Min
14634 
<span class="line-modified">14635 instruct cmovI_reg_reg_lt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)</span>
14636 %{
<span class="line-modified">14637   effect( DEF dst, USE src1, USE src2, USE cr );</span>



14638 
<span class="line-modified">14639   ins_cost(INSN_COST * 2);</span>
<span class="line-modified">14640   format %{ &quot;cselw $dst, $src1, $src2 lt\t&quot;  %}</span>



14641 
14642   ins_encode %{


14643     __ cselw(as_Register($dst$$reg),
14644              as_Register($src1$$reg),
14645              as_Register($src2$$reg),
14646              Assembler::LT);
14647   %}
14648 
<span class="line-modified">14649   ins_pipe(icond_reg_reg);</span>
14650 %}

14651 
<span class="line-modified">14652 instruct minI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)</span>
14653 %{
<span class="line-modified">14654   match(Set dst (MinI src1 src2));</span>




14655   ins_cost(INSN_COST * 3);
<span class="line-modified">14656 </span>
<span class="line-modified">14657   expand %{</span>
<span class="line-modified">14658     rFlagsReg cr;</span>
<span class="line-added">14659     compI_reg_reg(cr, src1, src2);</span>
<span class="line-added">14660     cmovI_reg_reg_lt(dst, src1, src2, cr);</span>
14661   %}
14662 
<span class="line-added">14663 %}</span>
<span class="line-added">14664 // FROM HERE</span>
<span class="line-added">14665 </span>
<span class="line-added">14666 instruct cmovI_reg_reg_gt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)</span>
<span class="line-added">14667 %{</span>
<span class="line-added">14668   effect( DEF dst, USE src1, USE src2, USE cr );</span>
<span class="line-added">14669 </span>
<span class="line-added">14670   ins_cost(INSN_COST * 2);</span>
<span class="line-added">14671   format %{ &quot;cselw $dst, $src1, $src2 gt\t&quot;  %}</span>
<span class="line-added">14672 </span>
14673   ins_encode %{


14674     __ cselw(as_Register($dst$$reg),
14675              as_Register($src1$$reg),
14676              as_Register($src2$$reg),
14677              Assembler::GT);
14678   %}
14679 
<span class="line-modified">14680   ins_pipe(icond_reg_reg);</span>
<span class="line-added">14681 %}</span>
<span class="line-added">14682 </span>
<span class="line-added">14683 instruct maxI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)</span>
<span class="line-added">14684 %{</span>
<span class="line-added">14685   match(Set dst (MaxI src1 src2));</span>
<span class="line-added">14686   ins_cost(INSN_COST * 3);</span>
<span class="line-added">14687   expand %{</span>
<span class="line-added">14688     rFlagsReg cr;</span>
<span class="line-added">14689     compI_reg_reg(cr, src1, src2);</span>
<span class="line-added">14690     cmovI_reg_reg_gt(dst, src1, src2, cr);</span>
<span class="line-added">14691   %}</span>
14692 %}
14693 
14694 // ============================================================================
14695 // Branch Instructions
14696 
14697 // Direct Branch.
14698 instruct branch(label lbl)
14699 %{
14700   match(Goto);
14701 
14702   effect(USE lbl);
14703 
14704   ins_cost(BRANCH_COST);
14705   format %{ &quot;b  $lbl&quot; %}
14706 
14707   ins_encode(aarch64_enc_b(lbl));
14708 
14709   ins_pipe(pipe_branch);
14710 %}
14711 
</pre>
<hr />
<pre>
15120 instruct cmpFastUnlock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)
15121 %{
15122   match(Set cr (FastUnlock object box));
15123   effect(TEMP tmp, TEMP tmp2);
15124 
15125   ins_cost(5 * INSN_COST);
15126   format %{ &quot;fastunlock $object,$box\t! kills $tmp, $tmp2&quot; %}
15127 
15128   ins_encode(aarch64_enc_fast_unlock(object, box, tmp, tmp2));
15129 
15130   ins_pipe(pipe_serial);
15131 %}
15132 
15133 
15134 // ============================================================================
15135 // Safepoint Instructions
15136 
15137 // TODO
15138 // provide a near and far version of this code
15139 
<span class="line-modified">15140 instruct safePoint(rFlagsReg cr, iRegP poll)</span>
15141 %{
15142   match(SafePoint poll);
<span class="line-added">15143   effect(KILL cr);</span>
15144 
15145   format %{
15146     &quot;ldrw zr, [$poll]\t# Safepoint: poll for GC&quot;
15147   %}
15148   ins_encode %{
15149     __ read_polling_page(as_Register($poll$$reg), relocInfo::poll_type);
15150   %}
15151   ins_pipe(pipe_serial); // ins_pipe(iload_reg_mem);
15152 %}
15153 
15154 
15155 // ============================================================================
15156 // Procedure Call/Return Instructions
15157 
15158 // Call Java Static Instruction
15159 
15160 instruct CallStaticJavaDirect(method meth)
15161 %{
15162   match(CallStaticJava);
15163 
</pre>
<hr />
<pre>
17295 instruct vsrl16B(vecX dst, vecX src, vecX shift, vecX tmp) %{
17296   predicate(n-&gt;as_Vector()-&gt;length() == 16);
17297   match(Set dst (URShiftVB src shift));
17298   ins_cost(INSN_COST);
17299   effect(TEMP tmp);
17300   format %{ &quot;negr  $tmp,$shift\t&quot;
17301             &quot;ushl  $dst,$src,$tmp\t# vector (16B)&quot; %}
17302   ins_encode %{
17303     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17304             as_FloatRegister($shift$$reg));
17305     __ ushl(as_FloatRegister($dst$$reg), __ T16B,
17306             as_FloatRegister($src$$reg),
17307             as_FloatRegister($tmp$$reg));
17308   %}
17309   ins_pipe(vshift128);
17310 %}
17311 
17312 instruct vsll8B_imm(vecD dst, vecD src, immI shift) %{
17313   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
17314             n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17315   match(Set dst (LShiftVB src (LShiftCntV shift)));</span>
17316   ins_cost(INSN_COST);
17317   format %{ &quot;shl    $dst, $src, $shift\t# vector (8B)&quot; %}
17318   ins_encode %{
17319     int sh = (int)$shift$$constant;
17320     if (sh &gt;= 8) {
17321       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17322              as_FloatRegister($src$$reg),
17323              as_FloatRegister($src$$reg));
17324     } else {
17325       __ shl(as_FloatRegister($dst$$reg), __ T8B,
17326              as_FloatRegister($src$$reg), sh);
17327     }
17328   %}
17329   ins_pipe(vshift64_imm);
17330 %}
17331 
17332 instruct vsll16B_imm(vecX dst, vecX src, immI shift) %{
17333   predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">17334   match(Set dst (LShiftVB src (LShiftCntV shift)));</span>
17335   ins_cost(INSN_COST);
17336   format %{ &quot;shl    $dst, $src, $shift\t# vector (16B)&quot; %}
17337   ins_encode %{
17338     int sh = (int)$shift$$constant;
17339     if (sh &gt;= 8) {
17340       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17341              as_FloatRegister($src$$reg),
17342              as_FloatRegister($src$$reg));
17343     } else {
17344       __ shl(as_FloatRegister($dst$$reg), __ T16B,
17345              as_FloatRegister($src$$reg), sh);
17346     }
17347   %}
17348   ins_pipe(vshift128_imm);
17349 %}
17350 
17351 instruct vsra8B_imm(vecD dst, vecD src, immI shift) %{
17352   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
17353             n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17354   match(Set dst (RShiftVB src (RShiftCntV shift)));</span>
17355   ins_cost(INSN_COST);
17356   format %{ &quot;sshr    $dst, $src, $shift\t# vector (8B)&quot; %}
17357   ins_encode %{
17358     int sh = (int)$shift$$constant;
17359     if (sh &gt;= 8) sh = 7;
17360     __ sshr(as_FloatRegister($dst$$reg), __ T8B,
17361            as_FloatRegister($src$$reg), sh);
17362   %}
17363   ins_pipe(vshift64_imm);
17364 %}
17365 
17366 instruct vsra16B_imm(vecX dst, vecX src, immI shift) %{
17367   predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">17368   match(Set dst (RShiftVB src (RShiftCntV shift)));</span>
17369   ins_cost(INSN_COST);
17370   format %{ &quot;sshr    $dst, $src, $shift\t# vector (16B)&quot; %}
17371   ins_encode %{
17372     int sh = (int)$shift$$constant;
17373     if (sh &gt;= 8) sh = 7;
17374     __ sshr(as_FloatRegister($dst$$reg), __ T16B,
17375            as_FloatRegister($src$$reg), sh);
17376   %}
17377   ins_pipe(vshift128_imm);
17378 %}
17379 
17380 instruct vsrl8B_imm(vecD dst, vecD src, immI shift) %{
17381   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
17382             n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17383   match(Set dst (URShiftVB src (RShiftCntV shift)));</span>
17384   ins_cost(INSN_COST);
17385   format %{ &quot;ushr    $dst, $src, $shift\t# vector (8B)&quot; %}
17386   ins_encode %{
17387     int sh = (int)$shift$$constant;
17388     if (sh &gt;= 8) {
17389       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17390              as_FloatRegister($src$$reg),
17391              as_FloatRegister($src$$reg));
17392     } else {
17393       __ ushr(as_FloatRegister($dst$$reg), __ T8B,
17394              as_FloatRegister($src$$reg), sh);
17395     }
17396   %}
17397   ins_pipe(vshift64_imm);
17398 %}
17399 
17400 instruct vsrl16B_imm(vecX dst, vecX src, immI shift) %{
17401   predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">17402   match(Set dst (URShiftVB src (RShiftCntV shift)));</span>
17403   ins_cost(INSN_COST);
17404   format %{ &quot;ushr    $dst, $src, $shift\t# vector (16B)&quot; %}
17405   ins_encode %{
17406     int sh = (int)$shift$$constant;
17407     if (sh &gt;= 8) {
17408       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17409              as_FloatRegister($src$$reg),
17410              as_FloatRegister($src$$reg));
17411     } else {
17412       __ ushr(as_FloatRegister($dst$$reg), __ T16B,
17413              as_FloatRegister($src$$reg), sh);
17414     }
17415   %}
17416   ins_pipe(vshift128_imm);
17417 %}
17418 
17419 instruct vsll4S(vecD dst, vecD src, vecD shift) %{
17420   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17421             n-&gt;as_Vector()-&gt;length() == 4);
17422   match(Set dst (LShiftVS src shift));
</pre>
<hr />
<pre>
17499 instruct vsrl8S(vecX dst, vecX src, vecX shift, vecX tmp) %{
17500   predicate(n-&gt;as_Vector()-&gt;length() == 8);
17501   match(Set dst (URShiftVS src shift));
17502   ins_cost(INSN_COST);
17503   effect(TEMP tmp);
17504   format %{ &quot;negr  $tmp,$shift\t&quot;
17505             &quot;ushl  $dst,$src,$tmp\t# vector (8H)&quot; %}
17506   ins_encode %{
17507     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17508             as_FloatRegister($shift$$reg));
17509     __ ushl(as_FloatRegister($dst$$reg), __ T8H,
17510             as_FloatRegister($src$$reg),
17511             as_FloatRegister($tmp$$reg));
17512   %}
17513   ins_pipe(vshift128);
17514 %}
17515 
17516 instruct vsll4S_imm(vecD dst, vecD src, immI shift) %{
17517   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17518             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17519   match(Set dst (LShiftVS src (LShiftCntV shift)));</span>
17520   ins_cost(INSN_COST);
17521   format %{ &quot;shl    $dst, $src, $shift\t# vector (4H)&quot; %}
17522   ins_encode %{
17523     int sh = (int)$shift$$constant;
17524     if (sh &gt;= 16) {
17525       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17526              as_FloatRegister($src$$reg),
17527              as_FloatRegister($src$$reg));
17528     } else {
17529       __ shl(as_FloatRegister($dst$$reg), __ T4H,
17530              as_FloatRegister($src$$reg), sh);
17531     }
17532   %}
17533   ins_pipe(vshift64_imm);
17534 %}
17535 
17536 instruct vsll8S_imm(vecX dst, vecX src, immI shift) %{
17537   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17538   match(Set dst (LShiftVS src (LShiftCntV shift)));</span>
17539   ins_cost(INSN_COST);
17540   format %{ &quot;shl    $dst, $src, $shift\t# vector (8H)&quot; %}
17541   ins_encode %{
17542     int sh = (int)$shift$$constant;
17543     if (sh &gt;= 16) {
17544       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17545              as_FloatRegister($src$$reg),
17546              as_FloatRegister($src$$reg));
17547     } else {
17548       __ shl(as_FloatRegister($dst$$reg), __ T8H,
17549              as_FloatRegister($src$$reg), sh);
17550     }
17551   %}
17552   ins_pipe(vshift128_imm);
17553 %}
17554 
17555 instruct vsra4S_imm(vecD dst, vecD src, immI shift) %{
17556   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17557             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17558   match(Set dst (RShiftVS src (LShiftCntV shift)));</span>
17559   ins_cost(INSN_COST);
17560   format %{ &quot;sshr    $dst, $src, $shift\t# vector (4H)&quot; %}
17561   ins_encode %{
17562     int sh = (int)$shift$$constant;
17563     if (sh &gt;= 16) sh = 15;
17564     __ sshr(as_FloatRegister($dst$$reg), __ T4H,
17565            as_FloatRegister($src$$reg), sh);
17566   %}
17567   ins_pipe(vshift64_imm);
17568 %}
17569 
17570 instruct vsra8S_imm(vecX dst, vecX src, immI shift) %{
17571   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17572   match(Set dst (RShiftVS src (LShiftCntV shift)));</span>
17573   ins_cost(INSN_COST);
17574   format %{ &quot;sshr    $dst, $src, $shift\t# vector (8H)&quot; %}
17575   ins_encode %{
17576     int sh = (int)$shift$$constant;
17577     if (sh &gt;= 16) sh = 15;
17578     __ sshr(as_FloatRegister($dst$$reg), __ T8H,
17579            as_FloatRegister($src$$reg), sh);
17580   %}
17581   ins_pipe(vshift128_imm);
17582 %}
17583 
17584 instruct vsrl4S_imm(vecD dst, vecD src, immI shift) %{
17585   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17586             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17587   match(Set dst (URShiftVS src (RShiftCntV shift)));</span>
17588   ins_cost(INSN_COST);
17589   format %{ &quot;ushr    $dst, $src, $shift\t# vector (4H)&quot; %}
17590   ins_encode %{
17591     int sh = (int)$shift$$constant;
17592     if (sh &gt;= 16) {
17593       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17594              as_FloatRegister($src$$reg),
17595              as_FloatRegister($src$$reg));
17596     } else {
17597       __ ushr(as_FloatRegister($dst$$reg), __ T4H,
17598              as_FloatRegister($src$$reg), sh);
17599     }
17600   %}
17601   ins_pipe(vshift64_imm);
17602 %}
17603 
17604 instruct vsrl8S_imm(vecX dst, vecX src, immI shift) %{
17605   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17606   match(Set dst (URShiftVS src (RShiftCntV shift)));</span>
17607   ins_cost(INSN_COST);
17608   format %{ &quot;ushr    $dst, $src, $shift\t# vector (8H)&quot; %}
17609   ins_encode %{
17610     int sh = (int)$shift$$constant;
17611     if (sh &gt;= 16) {
17612       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17613              as_FloatRegister($src$$reg),
17614              as_FloatRegister($src$$reg));
17615     } else {
17616       __ ushr(as_FloatRegister($dst$$reg), __ T8H,
17617              as_FloatRegister($src$$reg), sh);
17618     }
17619   %}
17620   ins_pipe(vshift128_imm);
17621 %}
17622 
17623 instruct vsll2I(vecD dst, vecD src, vecD shift) %{
17624   predicate(n-&gt;as_Vector()-&gt;length() == 2);
17625   match(Set dst (LShiftVI src shift));
17626   ins_cost(INSN_COST);
</pre>
<hr />
<pre>
17699 
17700 instruct vsrl4I(vecX dst, vecX src, vecX shift, vecX tmp) %{
17701   predicate(n-&gt;as_Vector()-&gt;length() == 4);
17702   match(Set dst (URShiftVI src shift));
17703   ins_cost(INSN_COST);
17704   effect(TEMP tmp);
17705   format %{ &quot;negr  $tmp,$shift\t&quot;
17706             &quot;ushl  $dst,$src,$tmp\t# vector (4S)&quot; %}
17707   ins_encode %{
17708     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17709             as_FloatRegister($shift$$reg));
17710     __ ushl(as_FloatRegister($dst$$reg), __ T4S,
17711             as_FloatRegister($src$$reg),
17712             as_FloatRegister($tmp$$reg));
17713   %}
17714   ins_pipe(vshift128);
17715 %}
17716 
17717 instruct vsll2I_imm(vecD dst, vecD src, immI shift) %{
17718   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17719   match(Set dst (LShiftVI src (LShiftCntV shift)));</span>
17720   ins_cost(INSN_COST);
17721   format %{ &quot;shl    $dst, $src, $shift\t# vector (2S)&quot; %}
17722   ins_encode %{
17723     __ shl(as_FloatRegister($dst$$reg), __ T2S,
17724            as_FloatRegister($src$$reg),
17725            (int)$shift$$constant);
17726   %}
17727   ins_pipe(vshift64_imm);
17728 %}
17729 
17730 instruct vsll4I_imm(vecX dst, vecX src, immI shift) %{
17731   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17732   match(Set dst (LShiftVI src (LShiftCntV shift)));</span>
17733   ins_cost(INSN_COST);
17734   format %{ &quot;shl    $dst, $src, $shift\t# vector (4S)&quot; %}
17735   ins_encode %{
17736     __ shl(as_FloatRegister($dst$$reg), __ T4S,
17737            as_FloatRegister($src$$reg),
17738            (int)$shift$$constant);
17739   %}
17740   ins_pipe(vshift128_imm);
17741 %}
17742 
17743 instruct vsra2I_imm(vecD dst, vecD src, immI shift) %{
17744   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17745   match(Set dst (RShiftVI src (RShiftCntV shift)));</span>
17746   ins_cost(INSN_COST);
17747   format %{ &quot;sshr    $dst, $src, $shift\t# vector (2S)&quot; %}
17748   ins_encode %{
17749     __ sshr(as_FloatRegister($dst$$reg), __ T2S,
17750             as_FloatRegister($src$$reg),
17751             (int)$shift$$constant);
17752   %}
17753   ins_pipe(vshift64_imm);
17754 %}
17755 
17756 instruct vsra4I_imm(vecX dst, vecX src, immI shift) %{
17757   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17758   match(Set dst (RShiftVI src (RShiftCntV shift)));</span>
17759   ins_cost(INSN_COST);
17760   format %{ &quot;sshr    $dst, $src, $shift\t# vector (4S)&quot; %}
17761   ins_encode %{
17762     __ sshr(as_FloatRegister($dst$$reg), __ T4S,
17763             as_FloatRegister($src$$reg),
17764             (int)$shift$$constant);
17765   %}
17766   ins_pipe(vshift128_imm);
17767 %}
17768 
17769 instruct vsrl2I_imm(vecD dst, vecD src, immI shift) %{
17770   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17771   match(Set dst (URShiftVI src (RShiftCntV shift)));</span>
17772   ins_cost(INSN_COST);
17773   format %{ &quot;ushr    $dst, $src, $shift\t# vector (2S)&quot; %}
17774   ins_encode %{
17775     __ ushr(as_FloatRegister($dst$$reg), __ T2S,
17776             as_FloatRegister($src$$reg),
17777             (int)$shift$$constant);
17778   %}
17779   ins_pipe(vshift64_imm);
17780 %}
17781 
17782 instruct vsrl4I_imm(vecX dst, vecX src, immI shift) %{
17783   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17784   match(Set dst (URShiftVI src (RShiftCntV shift)));</span>
17785   ins_cost(INSN_COST);
17786   format %{ &quot;ushr    $dst, $src, $shift\t# vector (4S)&quot; %}
17787   ins_encode %{
17788     __ ushr(as_FloatRegister($dst$$reg), __ T4S,
17789             as_FloatRegister($src$$reg),
17790             (int)$shift$$constant);
17791   %}
17792   ins_pipe(vshift128_imm);
17793 %}
17794 
17795 instruct vsll2L(vecX dst, vecX src, vecX shift) %{
17796   predicate(n-&gt;as_Vector()-&gt;length() == 2);
17797   match(Set dst (LShiftVL src shift));
17798   ins_cost(INSN_COST);
17799   format %{ &quot;sshl  $dst,$src,$shift\t# vector (2D)&quot; %}
17800   ins_encode %{
17801     __ sshl(as_FloatRegister($dst$$reg), __ T2D,
17802             as_FloatRegister($src$$reg),
17803             as_FloatRegister($shift$$reg));
17804   %}
</pre>
<hr />
<pre>
17824 
17825 instruct vsrl2L(vecX dst, vecX src, vecX shift, vecX tmp) %{
17826   predicate(n-&gt;as_Vector()-&gt;length() == 2);
17827   match(Set dst (URShiftVL src shift));
17828   ins_cost(INSN_COST);
17829   effect(TEMP tmp);
17830   format %{ &quot;negr  $tmp,$shift\t&quot;
17831             &quot;ushl  $dst,$src,$tmp\t# vector (2D)&quot; %}
17832   ins_encode %{
17833     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17834             as_FloatRegister($shift$$reg));
17835     __ ushl(as_FloatRegister($dst$$reg), __ T2D,
17836             as_FloatRegister($src$$reg),
17837             as_FloatRegister($tmp$$reg));
17838   %}
17839   ins_pipe(vshift128);
17840 %}
17841 
17842 instruct vsll2L_imm(vecX dst, vecX src, immI shift) %{
17843   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17844   match(Set dst (LShiftVL src (LShiftCntV shift)));</span>
17845   ins_cost(INSN_COST);
17846   format %{ &quot;shl    $dst, $src, $shift\t# vector (2D)&quot; %}
17847   ins_encode %{
17848     __ shl(as_FloatRegister($dst$$reg), __ T2D,
17849            as_FloatRegister($src$$reg),
17850            (int)$shift$$constant);
17851   %}
17852   ins_pipe(vshift128_imm);
17853 %}
17854 
17855 instruct vsra2L_imm(vecX dst, vecX src, immI shift) %{
17856   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17857   match(Set dst (RShiftVL src (RShiftCntV shift)));</span>
17858   ins_cost(INSN_COST);
17859   format %{ &quot;sshr    $dst, $src, $shift\t# vector (2D)&quot; %}
17860   ins_encode %{
17861     __ sshr(as_FloatRegister($dst$$reg), __ T2D,
17862             as_FloatRegister($src$$reg),
17863             (int)$shift$$constant);
17864   %}
17865   ins_pipe(vshift128_imm);
17866 %}
17867 
17868 instruct vsrl2L_imm(vecX dst, vecX src, immI shift) %{
17869   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17870   match(Set dst (URShiftVL src (RShiftCntV shift)));</span>
17871   ins_cost(INSN_COST);
17872   format %{ &quot;ushr    $dst, $src, $shift\t# vector (2D)&quot; %}
17873   ins_encode %{
17874     __ ushr(as_FloatRegister($dst$$reg), __ T2D,
17875             as_FloatRegister($src$$reg),
17876             (int)$shift$$constant);
17877   %}
17878   ins_pipe(vshift128_imm);
17879 %}
17880 
17881 instruct vmax2F(vecD dst, vecD src1, vecD src2)
17882 %{
17883   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; n-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
17884   match(Set dst (MaxV src1 src2));
17885   ins_cost(INSN_COST);
17886   format %{ &quot;fmax  $dst,$src1,$src2\t# vector (2F)&quot; %}
17887   ins_encode %{
17888     __ fmax(as_FloatRegister($dst$$reg), __ T2S,
17889             as_FloatRegister($src1$$reg),
17890             as_FloatRegister($src2$$reg));
</pre>
<hr />
<pre>
17945             as_FloatRegister($src1$$reg),
17946             as_FloatRegister($src2$$reg));
17947   %}
17948   ins_pipe(vdop_fp128);
17949 %}
17950 
17951 instruct vmin2D(vecX dst, vecX src1, vecX src2)
17952 %{
17953   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; n-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_DOUBLE);
17954   match(Set dst (MinV src1 src2));
17955   ins_cost(INSN_COST);
17956   format %{ &quot;fmin  $dst,$src1,$src2\t# vector (2D)&quot; %}
17957   ins_encode %{
17958     __ fmin(as_FloatRegister($dst$$reg), __ T2D,
17959             as_FloatRegister($src1$$reg),
17960             as_FloatRegister($src2$$reg));
17961   %}
17962   ins_pipe(vdop_fp128);
17963 %}
17964 
<span class="line-added">17965 instruct vround2D_reg(vecX dst, vecX src, immI rmode) %{</span>
<span class="line-added">17966   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; n-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_DOUBLE);</span>
<span class="line-added">17967   match(Set dst (RoundDoubleModeV src rmode));</span>
<span class="line-added">17968   format %{ &quot;frint  $dst, $src, $rmode&quot; %}</span>
<span class="line-added">17969   ins_encode %{</span>
<span class="line-added">17970     switch ($rmode$$constant) {</span>
<span class="line-added">17971       case RoundDoubleModeNode::rmode_rint:</span>
<span class="line-added">17972         __ frintn(as_FloatRegister($dst$$reg), __ T2D,</span>
<span class="line-added">17973                   as_FloatRegister($src$$reg));</span>
<span class="line-added">17974         break;</span>
<span class="line-added">17975       case RoundDoubleModeNode::rmode_floor:</span>
<span class="line-added">17976         __ frintm(as_FloatRegister($dst$$reg), __ T2D,</span>
<span class="line-added">17977                   as_FloatRegister($src$$reg));</span>
<span class="line-added">17978         break;</span>
<span class="line-added">17979       case RoundDoubleModeNode::rmode_ceil:</span>
<span class="line-added">17980         __ frintp(as_FloatRegister($dst$$reg), __ T2D,</span>
<span class="line-added">17981                   as_FloatRegister($src$$reg));</span>
<span class="line-added">17982         break;</span>
<span class="line-added">17983     }</span>
<span class="line-added">17984   %}</span>
<span class="line-added">17985   ins_pipe(vdop_fp128);</span>
<span class="line-added">17986 %}</span>
<span class="line-added">17987 </span>
17988 //----------PEEPHOLE RULES-----------------------------------------------------
17989 // These must follow all instruction definitions as they use the names
17990 // defined in the instructions definitions.
17991 //
17992 // peepmatch ( root_instr_name [preceding_instruction]* );
17993 //
17994 // peepconstraint %{
17995 // (instruction_number.operand_name relational_op instruction_number.operand_name
17996 //  [, ...] );
17997 // // instruction numbers are zero-based using left to right order in peepmatch
17998 //
17999 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
18000 // // provide an instruction_number.operand_name for each operand that appears
18001 // // in the replacement instruction&#39;s match rule
18002 //
18003 // ---------VM FLAGS---------------------------------------------------------
18004 //
18005 // All peephole optimizations can be turned off using -XX:-OptoPeephole
18006 //
18007 // Each peephole rule is given an identifying number starting with zero and
</pre>
</td>
</tr>
</table>
<center><a href="../../.mx.jvmci/suite.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aarch64Test.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
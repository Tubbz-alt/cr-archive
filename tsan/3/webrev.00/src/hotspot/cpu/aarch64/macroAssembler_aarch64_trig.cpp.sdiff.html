<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64_trig.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64_log.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64_trig.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 364       subw(jv, ix, rscratch1, LSL, 20);            // ix - (e0&lt;&lt;20)
 365       lsl(jv, jv, 32);
 366       subw(rscratch2, rscratch1, 3);
 367       bfm(jv, X, 0, 31);                           // jv = z
 368       movw(i, 24);
 369       fmovd(v26, jv);                              // v26 = z
 370 
 371       block_comment(&quot;unrolled for(i=0;i&lt;2;i++) {tx[i] = (double)((int)(z));z = (z-tx[i])*two24A;}&quot;); {
 372         // tx[0,1,2] = v6,v7,v26
 373         frintzd(v6, v26);                          // v6 = (double)((int)v26)
 374         sdivw(jv, rscratch2, i);                   // jv = (e0 - 3)/24
 375         fsubd(v26, v26, v6);
 376         sub(sp, sp, 560);
 377         fmuld(v26, v26, v10);
 378         frintzd(v7, v26);                          // v7 = (double)((int)v26)
 379         movw(jx, 2); // calculate jx as nx - 1, which is initially 2. Not a part of unrolled loop
 380         fsubd(v26, v26, v7);
 381       }
 382 
 383       block_comment(&quot;nx calculation with unrolled while(tx[nx-1]==zeroA) nx--;&quot;); {
<span class="line-modified"> 384         fcmpd(v26, 0.0d);                          // if NE then jx == 2. else it&#39;s 1 or 0</span>
 385         add(iqBase, sp, 480);                      // base of iq[]
 386         fmuld(v3, v26, v10);
 387         br(NE, NX_SET);
<span class="line-modified"> 388         fcmpd(v7, 0.0d);                           // v7 == 0 =&gt; jx = 0. Else jx = 1</span>
 389         csetw(jx, NE);
 390       }
 391     bind(NX_SET);
 392       generate__kernel_rem_pio2(two_over_pi, pio2);
 393       // now we have y[0] = v4, y[1] = v5 and n = r2
 394       cmp(X, zr);
 395       br(GE, REDUCTION_DONE);
 396       fnegd(v4, v4);
 397       fnegd(v5, v5);
 398       negw(n, n);
 399   }
 400   bind(REDUCTION_DONE);
 401 }
 402 
 403 ///*
 404 // * __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)
 405 // * double x[],y[]; int e0,nx,prec; int ipio2[];
 406 // *
 407 // * __kernel_rem_pio2 return the last three digits of N with
 408 // *              y = x - N*pi/2
</pre>
<hr />
<pre>
 679 // NOTE: general purpose register names match local variable names in C code
 680 // NOTE: fpu registers are actively reused. See comments in code about their usage
 681 void MacroAssembler::generate__kernel_rem_pio2(address two_over_pi, address pio2) {
 682   Label Q_DONE, JX_IS_0, JX_IS_2, COMP_INNER_LOOP, RECOMP_FOR2, Q0_ZERO_CMP_LT,
 683       RECOMP_CHECK_DONE_NOT_ZERO, Q0_ZERO_CMP_DONE, COMP_FOR, Q0_ZERO_CMP_EQ,
 684       INIT_F_ZERO, RECOMPUTE, IH_FOR_INCREMENT, IH_FOR_STORE, RECOMP_CHECK_DONE,
 685       Z_IS_LESS_THAN_TWO24B, Z_IS_ZERO, FW_Y1_NO_NEGATION,
 686       RECOMP_FW_UPDATED, Z_ZERO_CHECK_DONE, FW_FOR1, IH_AFTER_SWITCH, IH_HANDLED,
 687       CONVERTION_FOR, FW_Y0_NO_NEGATION, FW_FOR1_DONE, FW_FOR2, FW_FOR2_DONE,
 688       IH_FOR, SKIP_F_LOAD, RECOMP_FOR1, RECOMP_FIRST_FOR, INIT_F_COPY,
 689       RECOMP_FOR1_CHECK;
 690   Register tmp2 = r1, n = r2, jv = r4, tmp5 = r5, jx = r6,
 691       tmp3 = r7, iqBase = r10, ih = r11, tmp4 = r12, tmp1 = r13,
 692       jz = r14, j = r15, twoOverPiBase = r16, i = r17, qBase = r18;
 693     // jp = jk == init_jk[prec] = init_jk[2] == {2,3,4,6}[2] == 4
 694     // jx = nx - 1
 695     lea(twoOverPiBase, ExternalAddress(two_over_pi));
 696     cmpw(jv, zr);
 697     addw(tmp4, jx, 4); // tmp4 = m = jx + jk = jx + 4. jx is in {0,1,2} so m is in [4,5,6]
 698     cselw(jv, jv, zr, GE);
<span class="line-modified"> 699     fmovd(v26, 0.0d);</span>
 700     addw(tmp5, jv, 1);                    // jv+1
 701     subsw(j, jv, jx);
 702     add(qBase, sp, 320);                  // base of q[]
 703     msubw(rscratch1, i, tmp5, rscratch1); // q0 =  e0-24*(jv+1)
 704     // use double f[20], fq[20], q[20], iq[20] on stack, which is
 705     // (20 + 20 + 20) x 8 + 20 x 4 = 560 bytes. From lower to upper addresses it
 706     // will contain f[20], fq[20], q[20], iq[20]
 707     // now initialize f[20] indexes 0..m (inclusive)
 708     // for(i=0;i&lt;=m;i++,j++) f[i] = (j&lt;0)? zeroB : /* NOTE: converted to double */ ipio2[j]; // (double) ipio2[j];
 709     mov(tmp5, sp);
 710 
 711     block_comment(&quot;for(i=0;i&lt;=m;i++,j++) f[i] = (j&lt;0)? zeroB : /* NOTE: converted to double */ ipio2[j]; // (double) ipio2[j];&quot;); {
 712         eorw(i, i, i);
 713         br(GE, INIT_F_COPY);
 714       bind(INIT_F_ZERO);
 715         stpq(v26, v26, Address(post(tmp5, 32)));
 716         addw(i, i, 4);
 717         addsw(j, j, 4);
 718         br(LT, INIT_F_ZERO);
 719         subw(i, i, j);
</pre>
<hr />
<pre>
 802       fmulxvs(v29, T2D, v19, v3);              // f[2,3] * x[2]
 803       fmuld(v30, v20, v3);                     // f[4] * x[2]
 804       fmlavs(v28, T2D, v26, v7, 0);
 805       fmlavs(v29, T2D, v27, v7, 0);
 806       fmlavs(v30, T2D, v7, v20, 1);            // v30 += f[5] * x[1]
 807       fmlavs(v28, T2D, v19, v6, 0);
 808       fmlavs(v29, T2D, v20, v6, 0);
 809       fmlavs(v30, T2D, v6, v21, 0);            // v30 += f[6] * x[0]
 810       b(Q_DONE);
 811     bind(JX_IS_0);
 812       fmulxvs(v28, T2D, v18, v6);              // f[0,1] * x[0]
 813       fmulxvs(v29, T2D, v19, v6);              // f[2,3] * x[0]
 814       fmuld(v30, v20, v6);                     // f[4] * x[0]
 815     bind(Q_DONE);
 816       st1(v28, v29, v30, T2D, Address(qBase)); // save calculated q[0]...q[jk]
 817   }
 818   movz(i, 0x3E70, 48);
 819   movw(jz, 4);
 820   fmovd(v17, i);                               // v17 = twon24
 821   fmovd(v30, tmp5);                            // 2^q0
<span class="line-modified"> 822   fmovd(v21, 0.125d);</span>
<span class="line-modified"> 823   fmovd(v20, 8.0d);</span>
 824   fmovd(v22, tmp4);                            // 2^-q0
 825 
 826   block_comment(&quot;recompute loop&quot;); {
 827     bind(RECOMPUTE);
 828       //  for(i=0,j=jz,z=q[jz];j&gt;0;i++,j--) {
 829       //    fw    =  (double)((int)(twon24* z));
 830       //    iq[i] =  (int)(z-two24A*fw);
 831       //    z     =  q[j-1]+fw;
 832       //  }
 833       block_comment(&quot;distill q[] into iq[] reversingly&quot;); {
 834           eorw(i, i, i);
 835           movw(j, jz);
 836           add(tmp2, qBase, jz, LSL, 3);                    // q[jz] address
 837           ldrd(v18, post(tmp2, -8));                       // z = q[j] and moving address to q[j-1]
 838         bind(RECOMP_FIRST_FOR);
 839           ldrd(v27, post(tmp2, -8));
 840           fmuld(v29, v17, v18);                            // twon24*z
 841           frintzd(v29, v29);                               // (double)(int)
 842           fmsubd(v28, v10, v29, v18);                      // v28 = z-two24A*fw
 843           fcvtzdw(tmp1, v28);                              // (int)(z-two24A*fw)
</pre>
<hr />
<pre>
 860       block_comment(&quot;q0-dependent initialization&quot;); {
 861           cmpw(rscratch1, 0);                              // if (q0 &gt; 0)
 862           br(LT, Q0_ZERO_CMP_LT);
 863           subw(j, jz, 1);                                  // j = jz - 1
 864           ldrw(tmp2, Address(iqBase, j, Address::lsl(2))); // tmp2 = iq[jz-1]
 865           br(EQ, Q0_ZERO_CMP_EQ);
 866           movw(tmp4, 24);
 867           subw(tmp4, tmp4, rscratch1);                     // == 24 - q0
 868           lsrvw(i, tmp2, tmp4);                            // i = iq[jz-1] &gt;&gt; (24-q0)
 869           lslvw(tmp5, i, tmp4);
 870           subw(tmp2, tmp2, tmp5);                          // iq[jz-1] -= i&lt;&lt;(24-q0);
 871           strw(tmp2, Address(iqBase, j, Address::lsl(2))); // store iq[jz-1]
 872           subw(rscratch2, tmp4, 1);                        // == 23 - q0
 873           addw(n, n, i);                                   // n+=i
 874           lsrvw(ih, tmp2, rscratch2);                      // ih = iq[jz-1] &gt;&gt; (23-q0)
 875           b(Q0_ZERO_CMP_DONE);
 876         bind(Q0_ZERO_CMP_EQ);
 877           lsr(ih, tmp2, 23);                               // ih = iq[z-1] &gt;&gt; 23
 878           b(Q0_ZERO_CMP_DONE);
 879         bind(Q0_ZERO_CMP_LT);
<span class="line-modified"> 880           fmovd(v4, 0.5d);</span>
 881           fcmpd(v18, v4);
 882           cselw(ih, zr, ih, LT);                           // if (z&lt;0.5) ih = 0
 883       }
 884     bind(Q0_ZERO_CMP_DONE);
 885       cmpw(ih, zr);
 886       br(LE, IH_HANDLED);
 887 
 888     block_comment(&quot;if(ih&gt;) {&quot;); {
 889       // use rscratch2 as carry
 890 
 891       block_comment(&quot;for(i=0;i&lt;jz ;i++) {...}&quot;); {
 892           addw(n, n, 1);
 893           eorw(i, i, i);
 894           eorw(rscratch2, rscratch2, rscratch2);
 895         bind(IH_FOR);
 896           ldrw(j, Address(iqBase, i, Address::lsl(2)));    // j = iq[i]
 897           movw(tmp3, 0x1000000);
 898           subw(tmp3, tmp3, rscratch2);
 899           cbnzw(rscratch2, IH_FOR_STORE);
 900           cbzw(j, IH_FOR_INCREMENT);
</pre>
<hr />
<pre>
 907           cmpw(i, jz);
 908           br(LT, IH_FOR);
 909       }
 910 
 911       block_comment(&quot;if(q0&gt;0) {&quot;); {
 912         cmpw(rscratch1, zr);
 913         br(LE, IH_AFTER_SWITCH);
 914         // tmp3 still has iq[jz-1] value. no need to reload
 915         // now, zero high tmp3 bits (rscratch1 number of bits)
 916         movw(j, -1);
 917         subw(i, jz, 1);                                    // set i to jz-1
 918         lsrv(j, j, rscratch1);
 919         andw(tmp3, tmp3, j, LSR, 8);                       // we have 24-bit-based constants
 920         strw(tmp3, Address(iqBase, i, Address::lsl(2)));   // save iq[jz-1]
 921       }
 922       bind(IH_AFTER_SWITCH);
 923         cmpw(ih, 2);
 924         br(NE, IH_HANDLED);
 925 
 926         block_comment(&quot;if(ih==2) {&quot;); {
<span class="line-modified"> 927           fmovd(v25, 1.0d);</span>
 928           fsubd(v18, v25, v18);                            // z = one - z;
 929           cbzw(rscratch2, IH_HANDLED);
 930           fsubd(v18, v18, v30);                            // z -= scalbnA(one,q0);
 931         }
 932     }
 933     bind(IH_HANDLED);
 934       // check if recomputation is needed
<span class="line-modified"> 935       fcmpd(v18, 0.0d);</span>
 936       br(NE, RECOMP_CHECK_DONE_NOT_ZERO);
 937 
 938       block_comment(&quot;if(z==zeroB) {&quot;); {
 939 
 940         block_comment(&quot;for (i=jz-1;i&gt;=jk;i--) j |= iq[i];&quot;); {
 941             subw(i, jz, 1);
 942             eorw(j, j, j);
 943             b(RECOMP_FOR1_CHECK);
 944           bind(RECOMP_FOR1);
 945             ldrw(tmp1, Address(iqBase, i, Address::lsl(2)));
 946             orrw(j, j, tmp1);
 947             subw(i, i, 1);
 948           bind(RECOMP_FOR1_CHECK);
 949             cmpw(i, 4);
 950             br(GE, RECOMP_FOR1);
 951         }
 952         cbnzw(j, RECOMP_CHECK_DONE);
 953 
 954         block_comment(&quot;if(j==0) {&quot;); {
 955             // for(k=1;iq[jk-k]==0;k++); // let&#39;s unroll it. jk == 4. So, read
</pre>
<hr />
<pre>
 977               add(tmp2, sp, tmp2, ext::uxtx, 3); // address of f[jx+i]
 978               ldpd(v4, v5, Address(tmp2, -16)); // load f[jx+i-2] and f[jx+i-1]
 979               fmuld(v26, v6, v29); // initial fw
 980               cbzw(jx, RECOMP_FW_UPDATED);
 981               fmaddd(v26, v7, v5, v26);
 982               cmpw(jx, 1);
 983               br(EQ, RECOMP_FW_UPDATED);
 984               fmaddd(v26, v3, v4, v26);
 985             bind(RECOMP_FW_UPDATED);
 986               strd(v26, Address(qBase, i, Address::lsl(3))); // q[i] = fw;
 987               addw(i, i, 1);
 988               cmpw(i, jz);                                   // jz here is &quot;old jz&quot; + k
 989               br(LE, RECOMP_FOR2);
 990           }
 991             b(RECOMPUTE);
 992         }
 993       }
 994     }
 995     bind(RECOMP_CHECK_DONE);
 996       // chop off zero terms
<span class="line-modified"> 997       fcmpd(v18, 0.0d);</span>
 998       br(EQ, Z_IS_ZERO);
 999 
1000       block_comment(&quot;else block of if(z==0.0) {&quot;); {
1001         bind(RECOMP_CHECK_DONE_NOT_ZERO);
1002           fmuld(v18, v18, v22);
1003           fcmpd(v18, v10);                                   // v10 is stil two24A
1004           br(LT, Z_IS_LESS_THAN_TWO24B);
1005           fmuld(v1, v18, v17);                               // twon24*z
1006           frintzd(v1, v1);                                   // v1 = (double)(int)(v1)
1007           fmsubd(v2, v10, v1, v18);
1008           fcvtzdw(tmp3, v1);                                 // (int)fw
1009           fcvtzdw(tmp2, v2);                                 // double to int
1010           strw(tmp2, Address(iqBase, jz, Address::lsl(2)));
1011           addw(rscratch1, rscratch1, 24);
1012           addw(jz, jz, 1);
1013           strw(tmp3, Address(iqBase, jz, Address::lsl(2)));  // iq[jz] = (int) fw
1014           b(Z_ZERO_CHECK_DONE);
1015         bind(Z_IS_LESS_THAN_TWO24B);
1016           fcvtzdw(tmp3, v18);                                // (int)z
1017           strw(tmp3, Address(iqBase, jz, Address::lsl(2)));  // iq[jz] = (int) z
</pre>
<hr />
<pre>
1036 
1037         block_comment(&quot;for(i=jz;i&gt;=0;i--) {q[i] = fw*(double)iq[i]; fw*=twon24;}&quot;); {
1038           bind(CONVERTION_FOR);
1039             ldrw(tmp1, Address(iqBase, i, Address::lsl(2)));
1040             scvtfwd(v31, tmp1);
1041             fmuld(v31, v31, v30);
1042             strd(v31, Address(qBase, i, Address::lsl(3)));
1043             fmuld(v30, v30, v17);
1044             subsw(i, i, 1);
1045             br(GE, CONVERTION_FOR);
1046         }
1047         add(rscratch2, sp, 160); // base for fq
1048         // reusing twoOverPiBase
1049         lea(twoOverPiBase, ExternalAddress(pio2));
1050 
1051       block_comment(&quot;compute PIo2[0,...,jp]*q[jz,...,0]. for(i=jz;i&gt;=0;i--) {...}&quot;); {
1052           movw(i, jz);
1053           movw(tmp2, zr); // tmp2 will keep jz - i == 0 at start
1054         bind(COMP_FOR);
1055           // for(fw=0.0,k=0;k&lt;=jp&amp;&amp;k&lt;=jz-i;k++) fw += PIo2[k]*q[i+k];
<span class="line-modified">1056           fmovd(v30, 0.0d);</span>
1057           add(tmp5, qBase, i, LSL, 3); // address of q[i+k] for k==0
1058           movw(tmp3, 4);
1059           movw(tmp4, zr);              // used as k
1060           cmpw(tmp2, 4);
1061           add(tmp1, qBase, i, LSL, 3); // used as q[i] address
1062           cselw(tmp3, tmp2, tmp3, LE); // min(jz - i, jp)
1063 
1064           block_comment(&quot;for(fw=0.0,k=0;k&lt;=jp&amp;&amp;k&lt;=jz-i;k++) fw += PIo2[k]*q[i+k];&quot;); {
1065             bind(COMP_INNER_LOOP);
1066               ldrd(v18, Address(tmp1, tmp4, Address::lsl(3)));          // q[i+k]
1067               ldrd(v19, Address(twoOverPiBase, tmp4, Address::lsl(3))); // PIo2[k]
1068               fmaddd(v30, v18, v19, v30);                               // fw += PIo2[k]*q[i+k];
1069               addw(tmp4, tmp4, 1);                                      // k++
1070               cmpw(tmp4, tmp3);
1071               br(LE, COMP_INNER_LOOP);
1072           }
1073           strd(v30, Address(rscratch2, tmp2, Address::lsl(3)));         // fq[jz-i]
1074           add(tmp2, tmp2, 1);
1075           subsw(i, i, 1);
1076           br(GE, COMP_FOR);
1077       }
1078 
1079       block_comment(&quot;switch(prec) {...}. case 2:&quot;); {
1080         // compress fq into y[]
1081         // remember prec == 2
1082 
1083         block_comment(&quot;for (i=jz;i&gt;=0;i--) fw += fq[i];&quot;); {
<span class="line-modified">1084             fmovd(v4, 0.0d);</span>
1085             mov(i, jz);
1086           bind(FW_FOR1);
1087             ldrd(v1, Address(rscratch2, i, Address::lsl(3)));
1088             subsw(i, i, 1);
1089             faddd(v4, v4, v1);
1090             br(GE, FW_FOR1);
1091         }
1092         bind(FW_FOR1_DONE);
1093           // v1 contains fq[0]. so, keep it so far
1094           fsubd(v5, v1, v4); // fw = fq[0] - fw
1095           cbzw(ih, FW_Y0_NO_NEGATION);
1096           fnegd(v4, v4);
1097         bind(FW_Y0_NO_NEGATION);
1098 
1099         block_comment(&quot;for (i=1;i&lt;=jz;i++) fw += fq[i];&quot;); {
1100             movw(i, 1);
1101               cmpw(jz, 1);
1102             br(LT, FW_FOR2_DONE);
1103           bind(FW_FOR2);
1104             ldrd(v1, Address(rscratch2, i, Address::lsl(3)));
</pre>
<hr />
<pre>
1302 //
1303 // Changes between fdlibm and intrinsic:
1304 //     1. Removed |x| &lt; 2**-27 check, because if was done earlier in dsin/dcos
1305 //     2. Constants are now loaded from table dcos_coef
1306 // Input and output:
1307 //     1. Input for generated function: X argument = x
1308 //     2. Input for generator: x = register to read argument from, dcos_coef
1309 //        = coefficients table address
1310 //     2. Return cos(x) value in v0
1311 void MacroAssembler::generate_kernel_cos(FloatRegister x, address dcos_coef) {
1312   Register ix = r3;
1313   FloatRegister qx = v1, h = v2, a = v3, y = v5, z = v6, r = v7, C1 = v18,
1314       C2 = v19, C3 = v20, C4 = v21, C5 = v22, C6 = v23, one = v25, half = v26;
1315   Label IX_IS_LARGE, SET_QX_CONST, DONE, QX_SET;
1316     lea(rscratch2, ExternalAddress(dcos_coef));
1317     ldpd(C5, C6, Address(rscratch2, 32));         // load C5, C6
1318     fmuld(z, x, x);                               // z=x^2
1319     ld1(C1, C2, C3, C4, T1D, Address(rscratch2)); // load C1..C3\4
1320     block_comment(&quot;calculate r = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))))&quot;); {
1321       fmaddd(r, z, C6, C5);
<span class="line-modified">1322       fmovd(half, 0.5d);</span>
1323       fmaddd(r, z, r, C4);
1324       fmuld(y, x, y);
1325       fmaddd(r, z, r, C3);
1326       mov(rscratch1, 0x3FD33333);
1327       fmaddd(r, z, r, C2);
1328       fmuld(x, z, z);                             // x = z^2
1329       fmaddd(r, z, r, C1);                        // r = C1+z(C2+z(C4+z(C5+z*C6)))
1330     }
1331     // need to multiply r by z to have &quot;final&quot; r value
<span class="line-modified">1332     fmovd(one, 1.0d);</span>
1333     cmp(ix, rscratch1);
1334     br(GT, IX_IS_LARGE);
1335     block_comment(&quot;if(ix &lt; 0x3FD33333) return one - (0.5*z - (z*r - x*y))&quot;); {
1336       // return 1.0 - (0.5*z - (z*r - x*y)) = 1.0 - (0.5*z + (x*y - z*r))
1337       fmsubd(v0, x, r, y);
1338       fmaddd(v0, half, z, v0);
1339       fsubd(v0, one, v0);
1340       b(DONE);
1341     }
1342   block_comment(&quot;if(ix &gt;= 0x3FD33333)&quot;); {
1343     bind(IX_IS_LARGE);
1344       movz(rscratch2, 0x3FE9, 16);
1345       cmp(ix, rscratch2);
1346       br(GT, SET_QX_CONST);
1347       block_comment(&quot;set_high(&amp;qx, ix-0x00200000); set_low(&amp;qx, 0);&quot;); {
1348         subw(rscratch2, ix, 0x00200000);
1349         lsl(rscratch2, rscratch2, 32);
1350         fmovd(qx, rscratch2);
1351       }
1352       b(QX_SET);
1353     bind(SET_QX_CONST);
1354       block_comment(&quot;if(ix &gt; 0x3fe90000) qx = 0.28125;&quot;); {
<span class="line-modified">1355         fmovd(qx, 0.28125d);</span>
1356       }
1357     bind(QX_SET);
1358       fnmsub(C6, x, r, y);    // z*r - xy
1359       fnmsub(h, half, z, qx); // h = 0.5*z - qx
1360       fsubd(a, one, qx);      // a = 1-qx
1361       fsubd(C6, h, C6);       // = h - (z*r - x*y)
1362       fsubd(v0, a, C6);
1363   }
1364   bind(DONE);
1365 }
1366 
1367 // generate_dsin_dcos creates stub for dsin and dcos
1368 // Generation is done via single call because dsin and dcos code is almost the
1369 // same(see C code below). These functions work as follows:
1370 // 1) handle corner cases: |x| ~&lt; pi/4, x is NaN or INF, |x| &lt; 2**-27
1371 // 2) perform argument reduction if required
1372 // 3) call kernel_sin or kernel_cos which approximate sin/cos via polynomial
1373 //
1374 // BEGIN dsin/dcos PSEUDO CODE
1375 //
</pre>
<hr />
<pre>
1426       mov(rscratch2, 0x3e400000);
1427       mov(rscratch1, 0x3fe921fb00000000);            // pi/4. shifted to reuse later
1428       ubfm(absX, X, 0, 62);                          // absX
1429       movz(r10, POSITIVE_INFINITY_OR_NAN_PREFIX, 48);
1430       cmp(rscratch2, absX, LSR, 32);
1431       lsr(ix, absX, 32);                             // set ix
1432       br(GT, TINY_X);                                // handle tiny x (|x| &lt; 2^-27)
1433       cmp(ix, rscratch1, LSR, 32);
1434       br(LE, EARLY_CASE);                            // if(ix &lt;= 0x3fe921fb) return
1435       cmp(absX, r10);
1436       br(LT, ARG_REDUCTION);
1437       // X is NaN or INF(i.e. 0x7FF* or 0xFFF*). Return NaN (mantissa != 0).
1438       // Set last bit unconditionally to make it NaN
1439       orr(r10, r10, 1);
1440       fmovd(v0, r10);
1441       ret(lr);
1442     }
1443   block_comment(&quot;kernel_sin/kernel_cos: if(ix&lt;0x3e400000) {&lt;fast return&gt;}&quot;); {
1444     bind(TINY_X);
1445       if (isCos) {
<span class="line-modified">1446         fmovd(v0, 1.0d);</span>
1447       }
1448       ret(lr);
1449   }
1450   bind(ARG_REDUCTION); /* argument reduction needed */
1451     block_comment(&quot;n = __ieee754_rem_pio2(x,y);&quot;); {
1452       generate__ieee754_rem_pio2(npio2_hw, two_over_pi, pio2);
1453     }
1454     block_comment(&quot;switch(n&amp;3) {case ... }&quot;); {
1455       if (isCos) {
1456         eorw(absX, n, n, LSR, 1);
1457         tbnz(n, 0, RETURN_SIN);
1458       } else {
1459         tbz(n, 0, RETURN_SIN);
1460       }
1461       generate_kernel_cos(y0, dcos_coef);
1462       if (isCos) {
1463         tbz(absX, 0, DONE);
1464       } else {
1465         tbz(n, 1, DONE);
1466       }
</pre>
</td>
<td>
<hr />
<pre>
 364       subw(jv, ix, rscratch1, LSL, 20);            // ix - (e0&lt;&lt;20)
 365       lsl(jv, jv, 32);
 366       subw(rscratch2, rscratch1, 3);
 367       bfm(jv, X, 0, 31);                           // jv = z
 368       movw(i, 24);
 369       fmovd(v26, jv);                              // v26 = z
 370 
 371       block_comment(&quot;unrolled for(i=0;i&lt;2;i++) {tx[i] = (double)((int)(z));z = (z-tx[i])*two24A;}&quot;); {
 372         // tx[0,1,2] = v6,v7,v26
 373         frintzd(v6, v26);                          // v6 = (double)((int)v26)
 374         sdivw(jv, rscratch2, i);                   // jv = (e0 - 3)/24
 375         fsubd(v26, v26, v6);
 376         sub(sp, sp, 560);
 377         fmuld(v26, v26, v10);
 378         frintzd(v7, v26);                          // v7 = (double)((int)v26)
 379         movw(jx, 2); // calculate jx as nx - 1, which is initially 2. Not a part of unrolled loop
 380         fsubd(v26, v26, v7);
 381       }
 382 
 383       block_comment(&quot;nx calculation with unrolled while(tx[nx-1]==zeroA) nx--;&quot;); {
<span class="line-modified"> 384         fcmpd(v26, 0.0);                           // if NE then jx == 2. else it&#39;s 1 or 0</span>
 385         add(iqBase, sp, 480);                      // base of iq[]
 386         fmuld(v3, v26, v10);
 387         br(NE, NX_SET);
<span class="line-modified"> 388         fcmpd(v7, 0.0);                            // v7 == 0 =&gt; jx = 0. Else jx = 1</span>
 389         csetw(jx, NE);
 390       }
 391     bind(NX_SET);
 392       generate__kernel_rem_pio2(two_over_pi, pio2);
 393       // now we have y[0] = v4, y[1] = v5 and n = r2
 394       cmp(X, zr);
 395       br(GE, REDUCTION_DONE);
 396       fnegd(v4, v4);
 397       fnegd(v5, v5);
 398       negw(n, n);
 399   }
 400   bind(REDUCTION_DONE);
 401 }
 402 
 403 ///*
 404 // * __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)
 405 // * double x[],y[]; int e0,nx,prec; int ipio2[];
 406 // *
 407 // * __kernel_rem_pio2 return the last three digits of N with
 408 // *              y = x - N*pi/2
</pre>
<hr />
<pre>
 679 // NOTE: general purpose register names match local variable names in C code
 680 // NOTE: fpu registers are actively reused. See comments in code about their usage
 681 void MacroAssembler::generate__kernel_rem_pio2(address two_over_pi, address pio2) {
 682   Label Q_DONE, JX_IS_0, JX_IS_2, COMP_INNER_LOOP, RECOMP_FOR2, Q0_ZERO_CMP_LT,
 683       RECOMP_CHECK_DONE_NOT_ZERO, Q0_ZERO_CMP_DONE, COMP_FOR, Q0_ZERO_CMP_EQ,
 684       INIT_F_ZERO, RECOMPUTE, IH_FOR_INCREMENT, IH_FOR_STORE, RECOMP_CHECK_DONE,
 685       Z_IS_LESS_THAN_TWO24B, Z_IS_ZERO, FW_Y1_NO_NEGATION,
 686       RECOMP_FW_UPDATED, Z_ZERO_CHECK_DONE, FW_FOR1, IH_AFTER_SWITCH, IH_HANDLED,
 687       CONVERTION_FOR, FW_Y0_NO_NEGATION, FW_FOR1_DONE, FW_FOR2, FW_FOR2_DONE,
 688       IH_FOR, SKIP_F_LOAD, RECOMP_FOR1, RECOMP_FIRST_FOR, INIT_F_COPY,
 689       RECOMP_FOR1_CHECK;
 690   Register tmp2 = r1, n = r2, jv = r4, tmp5 = r5, jx = r6,
 691       tmp3 = r7, iqBase = r10, ih = r11, tmp4 = r12, tmp1 = r13,
 692       jz = r14, j = r15, twoOverPiBase = r16, i = r17, qBase = r18;
 693     // jp = jk == init_jk[prec] = init_jk[2] == {2,3,4,6}[2] == 4
 694     // jx = nx - 1
 695     lea(twoOverPiBase, ExternalAddress(two_over_pi));
 696     cmpw(jv, zr);
 697     addw(tmp4, jx, 4); // tmp4 = m = jx + jk = jx + 4. jx is in {0,1,2} so m is in [4,5,6]
 698     cselw(jv, jv, zr, GE);
<span class="line-modified"> 699     fmovd(v26, 0.0);</span>
 700     addw(tmp5, jv, 1);                    // jv+1
 701     subsw(j, jv, jx);
 702     add(qBase, sp, 320);                  // base of q[]
 703     msubw(rscratch1, i, tmp5, rscratch1); // q0 =  e0-24*(jv+1)
 704     // use double f[20], fq[20], q[20], iq[20] on stack, which is
 705     // (20 + 20 + 20) x 8 + 20 x 4 = 560 bytes. From lower to upper addresses it
 706     // will contain f[20], fq[20], q[20], iq[20]
 707     // now initialize f[20] indexes 0..m (inclusive)
 708     // for(i=0;i&lt;=m;i++,j++) f[i] = (j&lt;0)? zeroB : /* NOTE: converted to double */ ipio2[j]; // (double) ipio2[j];
 709     mov(tmp5, sp);
 710 
 711     block_comment(&quot;for(i=0;i&lt;=m;i++,j++) f[i] = (j&lt;0)? zeroB : /* NOTE: converted to double */ ipio2[j]; // (double) ipio2[j];&quot;); {
 712         eorw(i, i, i);
 713         br(GE, INIT_F_COPY);
 714       bind(INIT_F_ZERO);
 715         stpq(v26, v26, Address(post(tmp5, 32)));
 716         addw(i, i, 4);
 717         addsw(j, j, 4);
 718         br(LT, INIT_F_ZERO);
 719         subw(i, i, j);
</pre>
<hr />
<pre>
 802       fmulxvs(v29, T2D, v19, v3);              // f[2,3] * x[2]
 803       fmuld(v30, v20, v3);                     // f[4] * x[2]
 804       fmlavs(v28, T2D, v26, v7, 0);
 805       fmlavs(v29, T2D, v27, v7, 0);
 806       fmlavs(v30, T2D, v7, v20, 1);            // v30 += f[5] * x[1]
 807       fmlavs(v28, T2D, v19, v6, 0);
 808       fmlavs(v29, T2D, v20, v6, 0);
 809       fmlavs(v30, T2D, v6, v21, 0);            // v30 += f[6] * x[0]
 810       b(Q_DONE);
 811     bind(JX_IS_0);
 812       fmulxvs(v28, T2D, v18, v6);              // f[0,1] * x[0]
 813       fmulxvs(v29, T2D, v19, v6);              // f[2,3] * x[0]
 814       fmuld(v30, v20, v6);                     // f[4] * x[0]
 815     bind(Q_DONE);
 816       st1(v28, v29, v30, T2D, Address(qBase)); // save calculated q[0]...q[jk]
 817   }
 818   movz(i, 0x3E70, 48);
 819   movw(jz, 4);
 820   fmovd(v17, i);                               // v17 = twon24
 821   fmovd(v30, tmp5);                            // 2^q0
<span class="line-modified"> 822   fmovd(v21, 0.125);</span>
<span class="line-modified"> 823   fmovd(v20, 8.0);</span>
 824   fmovd(v22, tmp4);                            // 2^-q0
 825 
 826   block_comment(&quot;recompute loop&quot;); {
 827     bind(RECOMPUTE);
 828       //  for(i=0,j=jz,z=q[jz];j&gt;0;i++,j--) {
 829       //    fw    =  (double)((int)(twon24* z));
 830       //    iq[i] =  (int)(z-two24A*fw);
 831       //    z     =  q[j-1]+fw;
 832       //  }
 833       block_comment(&quot;distill q[] into iq[] reversingly&quot;); {
 834           eorw(i, i, i);
 835           movw(j, jz);
 836           add(tmp2, qBase, jz, LSL, 3);                    // q[jz] address
 837           ldrd(v18, post(tmp2, -8));                       // z = q[j] and moving address to q[j-1]
 838         bind(RECOMP_FIRST_FOR);
 839           ldrd(v27, post(tmp2, -8));
 840           fmuld(v29, v17, v18);                            // twon24*z
 841           frintzd(v29, v29);                               // (double)(int)
 842           fmsubd(v28, v10, v29, v18);                      // v28 = z-two24A*fw
 843           fcvtzdw(tmp1, v28);                              // (int)(z-two24A*fw)
</pre>
<hr />
<pre>
 860       block_comment(&quot;q0-dependent initialization&quot;); {
 861           cmpw(rscratch1, 0);                              // if (q0 &gt; 0)
 862           br(LT, Q0_ZERO_CMP_LT);
 863           subw(j, jz, 1);                                  // j = jz - 1
 864           ldrw(tmp2, Address(iqBase, j, Address::lsl(2))); // tmp2 = iq[jz-1]
 865           br(EQ, Q0_ZERO_CMP_EQ);
 866           movw(tmp4, 24);
 867           subw(tmp4, tmp4, rscratch1);                     // == 24 - q0
 868           lsrvw(i, tmp2, tmp4);                            // i = iq[jz-1] &gt;&gt; (24-q0)
 869           lslvw(tmp5, i, tmp4);
 870           subw(tmp2, tmp2, tmp5);                          // iq[jz-1] -= i&lt;&lt;(24-q0);
 871           strw(tmp2, Address(iqBase, j, Address::lsl(2))); // store iq[jz-1]
 872           subw(rscratch2, tmp4, 1);                        // == 23 - q0
 873           addw(n, n, i);                                   // n+=i
 874           lsrvw(ih, tmp2, rscratch2);                      // ih = iq[jz-1] &gt;&gt; (23-q0)
 875           b(Q0_ZERO_CMP_DONE);
 876         bind(Q0_ZERO_CMP_EQ);
 877           lsr(ih, tmp2, 23);                               // ih = iq[z-1] &gt;&gt; 23
 878           b(Q0_ZERO_CMP_DONE);
 879         bind(Q0_ZERO_CMP_LT);
<span class="line-modified"> 880           fmovd(v4, 0.5);</span>
 881           fcmpd(v18, v4);
 882           cselw(ih, zr, ih, LT);                           // if (z&lt;0.5) ih = 0
 883       }
 884     bind(Q0_ZERO_CMP_DONE);
 885       cmpw(ih, zr);
 886       br(LE, IH_HANDLED);
 887 
 888     block_comment(&quot;if(ih&gt;) {&quot;); {
 889       // use rscratch2 as carry
 890 
 891       block_comment(&quot;for(i=0;i&lt;jz ;i++) {...}&quot;); {
 892           addw(n, n, 1);
 893           eorw(i, i, i);
 894           eorw(rscratch2, rscratch2, rscratch2);
 895         bind(IH_FOR);
 896           ldrw(j, Address(iqBase, i, Address::lsl(2)));    // j = iq[i]
 897           movw(tmp3, 0x1000000);
 898           subw(tmp3, tmp3, rscratch2);
 899           cbnzw(rscratch2, IH_FOR_STORE);
 900           cbzw(j, IH_FOR_INCREMENT);
</pre>
<hr />
<pre>
 907           cmpw(i, jz);
 908           br(LT, IH_FOR);
 909       }
 910 
 911       block_comment(&quot;if(q0&gt;0) {&quot;); {
 912         cmpw(rscratch1, zr);
 913         br(LE, IH_AFTER_SWITCH);
 914         // tmp3 still has iq[jz-1] value. no need to reload
 915         // now, zero high tmp3 bits (rscratch1 number of bits)
 916         movw(j, -1);
 917         subw(i, jz, 1);                                    // set i to jz-1
 918         lsrv(j, j, rscratch1);
 919         andw(tmp3, tmp3, j, LSR, 8);                       // we have 24-bit-based constants
 920         strw(tmp3, Address(iqBase, i, Address::lsl(2)));   // save iq[jz-1]
 921       }
 922       bind(IH_AFTER_SWITCH);
 923         cmpw(ih, 2);
 924         br(NE, IH_HANDLED);
 925 
 926         block_comment(&quot;if(ih==2) {&quot;); {
<span class="line-modified"> 927           fmovd(v25, 1.0);</span>
 928           fsubd(v18, v25, v18);                            // z = one - z;
 929           cbzw(rscratch2, IH_HANDLED);
 930           fsubd(v18, v18, v30);                            // z -= scalbnA(one,q0);
 931         }
 932     }
 933     bind(IH_HANDLED);
 934       // check if recomputation is needed
<span class="line-modified"> 935       fcmpd(v18, 0.0);</span>
 936       br(NE, RECOMP_CHECK_DONE_NOT_ZERO);
 937 
 938       block_comment(&quot;if(z==zeroB) {&quot;); {
 939 
 940         block_comment(&quot;for (i=jz-1;i&gt;=jk;i--) j |= iq[i];&quot;); {
 941             subw(i, jz, 1);
 942             eorw(j, j, j);
 943             b(RECOMP_FOR1_CHECK);
 944           bind(RECOMP_FOR1);
 945             ldrw(tmp1, Address(iqBase, i, Address::lsl(2)));
 946             orrw(j, j, tmp1);
 947             subw(i, i, 1);
 948           bind(RECOMP_FOR1_CHECK);
 949             cmpw(i, 4);
 950             br(GE, RECOMP_FOR1);
 951         }
 952         cbnzw(j, RECOMP_CHECK_DONE);
 953 
 954         block_comment(&quot;if(j==0) {&quot;); {
 955             // for(k=1;iq[jk-k]==0;k++); // let&#39;s unroll it. jk == 4. So, read
</pre>
<hr />
<pre>
 977               add(tmp2, sp, tmp2, ext::uxtx, 3); // address of f[jx+i]
 978               ldpd(v4, v5, Address(tmp2, -16)); // load f[jx+i-2] and f[jx+i-1]
 979               fmuld(v26, v6, v29); // initial fw
 980               cbzw(jx, RECOMP_FW_UPDATED);
 981               fmaddd(v26, v7, v5, v26);
 982               cmpw(jx, 1);
 983               br(EQ, RECOMP_FW_UPDATED);
 984               fmaddd(v26, v3, v4, v26);
 985             bind(RECOMP_FW_UPDATED);
 986               strd(v26, Address(qBase, i, Address::lsl(3))); // q[i] = fw;
 987               addw(i, i, 1);
 988               cmpw(i, jz);                                   // jz here is &quot;old jz&quot; + k
 989               br(LE, RECOMP_FOR2);
 990           }
 991             b(RECOMPUTE);
 992         }
 993       }
 994     }
 995     bind(RECOMP_CHECK_DONE);
 996       // chop off zero terms
<span class="line-modified"> 997       fcmpd(v18, 0.0);</span>
 998       br(EQ, Z_IS_ZERO);
 999 
1000       block_comment(&quot;else block of if(z==0.0) {&quot;); {
1001         bind(RECOMP_CHECK_DONE_NOT_ZERO);
1002           fmuld(v18, v18, v22);
1003           fcmpd(v18, v10);                                   // v10 is stil two24A
1004           br(LT, Z_IS_LESS_THAN_TWO24B);
1005           fmuld(v1, v18, v17);                               // twon24*z
1006           frintzd(v1, v1);                                   // v1 = (double)(int)(v1)
1007           fmsubd(v2, v10, v1, v18);
1008           fcvtzdw(tmp3, v1);                                 // (int)fw
1009           fcvtzdw(tmp2, v2);                                 // double to int
1010           strw(tmp2, Address(iqBase, jz, Address::lsl(2)));
1011           addw(rscratch1, rscratch1, 24);
1012           addw(jz, jz, 1);
1013           strw(tmp3, Address(iqBase, jz, Address::lsl(2)));  // iq[jz] = (int) fw
1014           b(Z_ZERO_CHECK_DONE);
1015         bind(Z_IS_LESS_THAN_TWO24B);
1016           fcvtzdw(tmp3, v18);                                // (int)z
1017           strw(tmp3, Address(iqBase, jz, Address::lsl(2)));  // iq[jz] = (int) z
</pre>
<hr />
<pre>
1036 
1037         block_comment(&quot;for(i=jz;i&gt;=0;i--) {q[i] = fw*(double)iq[i]; fw*=twon24;}&quot;); {
1038           bind(CONVERTION_FOR);
1039             ldrw(tmp1, Address(iqBase, i, Address::lsl(2)));
1040             scvtfwd(v31, tmp1);
1041             fmuld(v31, v31, v30);
1042             strd(v31, Address(qBase, i, Address::lsl(3)));
1043             fmuld(v30, v30, v17);
1044             subsw(i, i, 1);
1045             br(GE, CONVERTION_FOR);
1046         }
1047         add(rscratch2, sp, 160); // base for fq
1048         // reusing twoOverPiBase
1049         lea(twoOverPiBase, ExternalAddress(pio2));
1050 
1051       block_comment(&quot;compute PIo2[0,...,jp]*q[jz,...,0]. for(i=jz;i&gt;=0;i--) {...}&quot;); {
1052           movw(i, jz);
1053           movw(tmp2, zr); // tmp2 will keep jz - i == 0 at start
1054         bind(COMP_FOR);
1055           // for(fw=0.0,k=0;k&lt;=jp&amp;&amp;k&lt;=jz-i;k++) fw += PIo2[k]*q[i+k];
<span class="line-modified">1056           fmovd(v30, 0.0);</span>
1057           add(tmp5, qBase, i, LSL, 3); // address of q[i+k] for k==0
1058           movw(tmp3, 4);
1059           movw(tmp4, zr);              // used as k
1060           cmpw(tmp2, 4);
1061           add(tmp1, qBase, i, LSL, 3); // used as q[i] address
1062           cselw(tmp3, tmp2, tmp3, LE); // min(jz - i, jp)
1063 
1064           block_comment(&quot;for(fw=0.0,k=0;k&lt;=jp&amp;&amp;k&lt;=jz-i;k++) fw += PIo2[k]*q[i+k];&quot;); {
1065             bind(COMP_INNER_LOOP);
1066               ldrd(v18, Address(tmp1, tmp4, Address::lsl(3)));          // q[i+k]
1067               ldrd(v19, Address(twoOverPiBase, tmp4, Address::lsl(3))); // PIo2[k]
1068               fmaddd(v30, v18, v19, v30);                               // fw += PIo2[k]*q[i+k];
1069               addw(tmp4, tmp4, 1);                                      // k++
1070               cmpw(tmp4, tmp3);
1071               br(LE, COMP_INNER_LOOP);
1072           }
1073           strd(v30, Address(rscratch2, tmp2, Address::lsl(3)));         // fq[jz-i]
1074           add(tmp2, tmp2, 1);
1075           subsw(i, i, 1);
1076           br(GE, COMP_FOR);
1077       }
1078 
1079       block_comment(&quot;switch(prec) {...}. case 2:&quot;); {
1080         // compress fq into y[]
1081         // remember prec == 2
1082 
1083         block_comment(&quot;for (i=jz;i&gt;=0;i--) fw += fq[i];&quot;); {
<span class="line-modified">1084             fmovd(v4, 0.0);</span>
1085             mov(i, jz);
1086           bind(FW_FOR1);
1087             ldrd(v1, Address(rscratch2, i, Address::lsl(3)));
1088             subsw(i, i, 1);
1089             faddd(v4, v4, v1);
1090             br(GE, FW_FOR1);
1091         }
1092         bind(FW_FOR1_DONE);
1093           // v1 contains fq[0]. so, keep it so far
1094           fsubd(v5, v1, v4); // fw = fq[0] - fw
1095           cbzw(ih, FW_Y0_NO_NEGATION);
1096           fnegd(v4, v4);
1097         bind(FW_Y0_NO_NEGATION);
1098 
1099         block_comment(&quot;for (i=1;i&lt;=jz;i++) fw += fq[i];&quot;); {
1100             movw(i, 1);
1101               cmpw(jz, 1);
1102             br(LT, FW_FOR2_DONE);
1103           bind(FW_FOR2);
1104             ldrd(v1, Address(rscratch2, i, Address::lsl(3)));
</pre>
<hr />
<pre>
1302 //
1303 // Changes between fdlibm and intrinsic:
1304 //     1. Removed |x| &lt; 2**-27 check, because if was done earlier in dsin/dcos
1305 //     2. Constants are now loaded from table dcos_coef
1306 // Input and output:
1307 //     1. Input for generated function: X argument = x
1308 //     2. Input for generator: x = register to read argument from, dcos_coef
1309 //        = coefficients table address
1310 //     2. Return cos(x) value in v0
1311 void MacroAssembler::generate_kernel_cos(FloatRegister x, address dcos_coef) {
1312   Register ix = r3;
1313   FloatRegister qx = v1, h = v2, a = v3, y = v5, z = v6, r = v7, C1 = v18,
1314       C2 = v19, C3 = v20, C4 = v21, C5 = v22, C6 = v23, one = v25, half = v26;
1315   Label IX_IS_LARGE, SET_QX_CONST, DONE, QX_SET;
1316     lea(rscratch2, ExternalAddress(dcos_coef));
1317     ldpd(C5, C6, Address(rscratch2, 32));         // load C5, C6
1318     fmuld(z, x, x);                               // z=x^2
1319     ld1(C1, C2, C3, C4, T1D, Address(rscratch2)); // load C1..C3\4
1320     block_comment(&quot;calculate r = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))))&quot;); {
1321       fmaddd(r, z, C6, C5);
<span class="line-modified">1322       fmovd(half, 0.5);</span>
1323       fmaddd(r, z, r, C4);
1324       fmuld(y, x, y);
1325       fmaddd(r, z, r, C3);
1326       mov(rscratch1, 0x3FD33333);
1327       fmaddd(r, z, r, C2);
1328       fmuld(x, z, z);                             // x = z^2
1329       fmaddd(r, z, r, C1);                        // r = C1+z(C2+z(C4+z(C5+z*C6)))
1330     }
1331     // need to multiply r by z to have &quot;final&quot; r value
<span class="line-modified">1332     fmovd(one, 1.0);</span>
1333     cmp(ix, rscratch1);
1334     br(GT, IX_IS_LARGE);
1335     block_comment(&quot;if(ix &lt; 0x3FD33333) return one - (0.5*z - (z*r - x*y))&quot;); {
1336       // return 1.0 - (0.5*z - (z*r - x*y)) = 1.0 - (0.5*z + (x*y - z*r))
1337       fmsubd(v0, x, r, y);
1338       fmaddd(v0, half, z, v0);
1339       fsubd(v0, one, v0);
1340       b(DONE);
1341     }
1342   block_comment(&quot;if(ix &gt;= 0x3FD33333)&quot;); {
1343     bind(IX_IS_LARGE);
1344       movz(rscratch2, 0x3FE9, 16);
1345       cmp(ix, rscratch2);
1346       br(GT, SET_QX_CONST);
1347       block_comment(&quot;set_high(&amp;qx, ix-0x00200000); set_low(&amp;qx, 0);&quot;); {
1348         subw(rscratch2, ix, 0x00200000);
1349         lsl(rscratch2, rscratch2, 32);
1350         fmovd(qx, rscratch2);
1351       }
1352       b(QX_SET);
1353     bind(SET_QX_CONST);
1354       block_comment(&quot;if(ix &gt; 0x3fe90000) qx = 0.28125;&quot;); {
<span class="line-modified">1355         fmovd(qx, 0.28125);</span>
1356       }
1357     bind(QX_SET);
1358       fnmsub(C6, x, r, y);    // z*r - xy
1359       fnmsub(h, half, z, qx); // h = 0.5*z - qx
1360       fsubd(a, one, qx);      // a = 1-qx
1361       fsubd(C6, h, C6);       // = h - (z*r - x*y)
1362       fsubd(v0, a, C6);
1363   }
1364   bind(DONE);
1365 }
1366 
1367 // generate_dsin_dcos creates stub for dsin and dcos
1368 // Generation is done via single call because dsin and dcos code is almost the
1369 // same(see C code below). These functions work as follows:
1370 // 1) handle corner cases: |x| ~&lt; pi/4, x is NaN or INF, |x| &lt; 2**-27
1371 // 2) perform argument reduction if required
1372 // 3) call kernel_sin or kernel_cos which approximate sin/cos via polynomial
1373 //
1374 // BEGIN dsin/dcos PSEUDO CODE
1375 //
</pre>
<hr />
<pre>
1426       mov(rscratch2, 0x3e400000);
1427       mov(rscratch1, 0x3fe921fb00000000);            // pi/4. shifted to reuse later
1428       ubfm(absX, X, 0, 62);                          // absX
1429       movz(r10, POSITIVE_INFINITY_OR_NAN_PREFIX, 48);
1430       cmp(rscratch2, absX, LSR, 32);
1431       lsr(ix, absX, 32);                             // set ix
1432       br(GT, TINY_X);                                // handle tiny x (|x| &lt; 2^-27)
1433       cmp(ix, rscratch1, LSR, 32);
1434       br(LE, EARLY_CASE);                            // if(ix &lt;= 0x3fe921fb) return
1435       cmp(absX, r10);
1436       br(LT, ARG_REDUCTION);
1437       // X is NaN or INF(i.e. 0x7FF* or 0xFFF*). Return NaN (mantissa != 0).
1438       // Set last bit unconditionally to make it NaN
1439       orr(r10, r10, 1);
1440       fmovd(v0, r10);
1441       ret(lr);
1442     }
1443   block_comment(&quot;kernel_sin/kernel_cos: if(ix&lt;0x3e400000) {&lt;fast return&gt;}&quot;); {
1444     bind(TINY_X);
1445       if (isCos) {
<span class="line-modified">1446         fmovd(v0, 1.0);</span>
1447       }
1448       ret(lr);
1449   }
1450   bind(ARG_REDUCTION); /* argument reduction needed */
1451     block_comment(&quot;n = __ieee754_rem_pio2(x,y);&quot;); {
1452       generate__ieee754_rem_pio2(npio2_hw, two_over_pi, pio2);
1453     }
1454     block_comment(&quot;switch(n&amp;3) {case ... }&quot;); {
1455       if (isCos) {
1456         eorw(absX, n, n, LSR, 1);
1457         tbnz(n, 0, RETURN_SIN);
1458       } else {
1459         tbz(n, 0, RETURN_SIN);
1460       }
1461       generate_kernel_cos(y0, dcos_coef);
1462       if (isCos) {
1463         tbz(absX, 0, DONE);
1464       } else {
1465         tbz(n, 1, DONE);
1466       }
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_aarch64_log.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
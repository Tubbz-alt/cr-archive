<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/gc/g1/g1BarrierSetAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.inline.hpp&quot;
 27 #include &quot;gc/g1/g1BarrierSet.hpp&quot;
 28 #include &quot;gc/g1/g1BarrierSetAssembler.hpp&quot;
 29 #include &quot;gc/g1/g1BarrierSetRuntime.hpp&quot;
 30 #include &quot;gc/g1/g1CardTable.hpp&quot;
 31 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
 32 #include &quot;gc/g1/heapRegion.hpp&quot;
 33 #include &quot;gc/shared/collectedHeap.hpp&quot;
 34 #include &quot;runtime/sharedRuntime.hpp&quot;
 35 #include &quot;runtime/thread.hpp&quot;
 36 #include &quot;interpreter/interp_masm.hpp&quot;
 37 #include &quot;runtime/sharedRuntime.hpp&quot;
 38 #ifdef COMPILER1
 39 #include &quot;c1/c1_LIRAssembler.hpp&quot;
 40 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 41 #include &quot;gc/g1/c1/g1BarrierSetC1.hpp&quot;
 42 #endif
 43 
 44 #define __ masm-&gt;
 45 
 46 void G1BarrierSetAssembler::gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,
 47                                                             Register addr, Register count, RegSet saved_regs) {
 48   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
 49   if (!dest_uninitialized) {
 50     __ push(saved_regs, sp);
 51     if (count == c_rarg0) {
 52       if (addr == c_rarg1) {
 53         // exactly backwards!!
 54         __ mov(rscratch1, c_rarg0);
 55         __ mov(c_rarg0, c_rarg1);
 56         __ mov(c_rarg1, rscratch1);
 57       } else {
 58         __ mov(c_rarg1, count);
 59         __ mov(c_rarg0, addr);
 60       }
 61     } else {
 62       __ mov(c_rarg0, addr);
 63       __ mov(c_rarg1, count);
 64     }
 65     if (UseCompressedOops) {
 66       __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_array_pre_narrow_oop_entry), 2);
 67     } else {
 68       __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_array_pre_oop_entry), 2);
 69     }
 70     __ pop(saved_regs, sp);
 71   }
 72 }
 73 
 74 void G1BarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,
 75                                                              Register start, Register end, Register scratch, RegSet saved_regs) {
 76   __ push(saved_regs, sp);
 77   // must compute element count unless barrier set interface is changed (other platforms supply count)
 78   assert_different_registers(start, end, scratch);
 79   __ lea(scratch, Address(end, BytesPerHeapOop));
 80   __ sub(scratch, scratch, start);               // subtract start to get #bytes
 81   __ lsr(scratch, scratch, LogBytesPerHeapOop);  // convert to element count
 82   __ mov(c_rarg0, start);
 83   __ mov(c_rarg1, scratch);
 84   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_array_post_entry), 2);
 85   __ pop(saved_regs, sp);
 86 }
 87 
 88 void G1BarrierSetAssembler::g1_write_barrier_pre(MacroAssembler* masm,
 89                                                  Register obj,
 90                                                  Register pre_val,
 91                                                  Register thread,
 92                                                  Register tmp,
 93                                                  bool tosca_live,
 94                                                  bool expand_call) {
 95   // If expand_call is true then we expand the call_VM_leaf macro
 96   // directly to skip generating the check by
 97   // InterpreterMacroAssembler::call_VM_leaf_base that checks _last_sp.
 98 
 99   assert(thread == rthread, &quot;must be&quot;);
100 
101   Label done;
102   Label runtime;
103 
104   assert_different_registers(obj, pre_val, tmp, rscratch1);
105   assert(pre_val != noreg &amp;&amp;  tmp != noreg, &quot;expecting a register&quot;);
106 
107   Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));
108   Address index(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));
109   Address buffer(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));
110 
111   // Is marking active?
112   if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {
113     __ ldrw(tmp, in_progress);
114   } else {
115     assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, &quot;Assumption&quot;);
116     __ ldrb(tmp, in_progress);
117   }
118   __ cbzw(tmp, done);
119 
120   // Do we need to load the previous value?
121   if (obj != noreg) {
122     __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);
123   }
124 
125   // Is the previous value null?
126   __ cbz(pre_val, done);
127 
128   // Can we store original value in the thread&#39;s buffer?
129   // Is index == 0?
130   // (The index field is typed as size_t.)
131 
132   __ ldr(tmp, index);                      // tmp := *index_adr
133   __ cbz(tmp, runtime);                    // tmp == 0?
134                                         // If yes, goto runtime
135 
136   __ sub(tmp, tmp, wordSize);              // tmp := tmp - wordSize
137   __ str(tmp, index);                      // *index_adr := tmp
138   __ ldr(rscratch1, buffer);
139   __ add(tmp, tmp, rscratch1);             // tmp := tmp + *buffer_adr
140 
141   // Record the previous value
142   __ str(pre_val, Address(tmp, 0));
143   __ b(done);
144 
145   __ bind(runtime);
146   // save the live input values
147   RegSet saved = RegSet::of(pre_val);
148   if (tosca_live) saved += RegSet::of(r0);
149   if (obj != noreg) saved += RegSet::of(obj);
150 
151   __ push(saved, sp);
152 
153   // Calling the runtime using the regular call_VM_leaf mechanism generates
154   // code (generated by InterpreterMacroAssember::call_VM_leaf_base)
155   // that checks that the *(rfp+frame::interpreter_frame_last_sp) == NULL.
156   //
157   // If we care generating the pre-barrier without a frame (e.g. in the
158   // intrinsified Reference.get() routine) then ebp might be pointing to
159   // the caller frame and so this check will most likely fail at runtime.
160   //
161   // Expanding the call directly bypasses the generation of the check.
162   // So when we do not have have a full interpreter frame on the stack
163   // expand_call should be passed true.
164 
165   if (expand_call) {
166     assert(pre_val != c_rarg1, &quot;smashed arg&quot;);
167     __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), pre_val, thread);
168   } else {
169     __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), pre_val, thread);
170   }
171 
172   __ pop(saved, sp);
173 
174   __ bind(done);
175 
176 }
177 
178 void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm,
179                                                   Register store_addr,
180                                                   Register new_val,
181                                                   Register thread,
182                                                   Register tmp,
183                                                   Register tmp2) {
184   assert(thread == rthread, &quot;must be&quot;);
185   assert_different_registers(store_addr, new_val, thread, tmp, tmp2,
186                              rscratch1);
187   assert(store_addr != noreg &amp;&amp; new_val != noreg &amp;&amp; tmp != noreg
188          &amp;&amp; tmp2 != noreg, &quot;expecting a register&quot;);
189 
190   Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));
191   Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));
192 
193   BarrierSet* bs = BarrierSet::barrier_set();
194   CardTableBarrierSet* ctbs = barrier_set_cast&lt;CardTableBarrierSet&gt;(bs);
195   CardTable* ct = ctbs-&gt;card_table();
196 
197   Label done;
198   Label runtime;
199 
200   // Does store cross heap regions?
201 
202   __ eor(tmp, store_addr, new_val);
203   __ lsr(tmp, tmp, HeapRegion::LogOfHRGrainBytes);
204   __ cbz(tmp, done);
205 
206   // crosses regions, storing NULL?
207 
208   __ cbz(new_val, done);
209 
210   // storing region crossing non-NULL, is card already dirty?
211 
212   ExternalAddress cardtable((address) ct-&gt;byte_map_base());
213   const Register card_addr = tmp;
214 
215   __ lsr(card_addr, store_addr, CardTable::card_shift);
216 
217   // get the address of the card
218   __ load_byte_map_base(tmp2);
219   __ add(card_addr, card_addr, tmp2);
220   __ ldrb(tmp2, Address(card_addr));
221   __ cmpw(tmp2, (int)G1CardTable::g1_young_card_val());
222   __ br(Assembler::EQ, done);
223 
224   assert((int)CardTable::dirty_card_val() == 0, &quot;must be 0&quot;);
225 
226   __ membar(Assembler::StoreLoad);
227 
228   __ ldrb(tmp2, Address(card_addr));
229   __ cbzw(tmp2, done);
230 
231   // storing a region crossing, non-NULL oop, card is clean.
232   // dirty card and log.
233 
234   __ strb(zr, Address(card_addr));
235 
236   __ ldr(rscratch1, queue_index);
237   __ cbz(rscratch1, runtime);
238   __ sub(rscratch1, rscratch1, wordSize);
239   __ str(rscratch1, queue_index);
240 
241   __ ldr(tmp2, buffer);
242   __ str(card_addr, Address(tmp2, rscratch1));
243   __ b(done);
244 
245   __ bind(runtime);
246   // save the live input values
247   RegSet saved = RegSet::of(store_addr, new_val);
248   __ push(saved, sp);
249   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);
250   __ pop(saved, sp);
251 
252   __ bind(done);
253 }
254 
255 void G1BarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
256                                     Register dst, Address src, Register tmp1, Register tmp_thread) {
257   bool on_oop = type == T_OBJECT || type == T_ARRAY;
258   bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;
259   bool on_phantom = (decorators &amp; ON_PHANTOM_OOP_REF) != 0;
260   bool on_reference = on_weak || on_phantom;
261   ModRefBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);
262   if (on_oop &amp;&amp; on_reference) {
263     // LR is live.  It must be saved around calls.
264     __ enter(); // barrier may call runtime
265     // Generate the G1 pre-barrier code to log the value of
266     // the referent field in an SATB buffer.
267     g1_write_barrier_pre(masm /* masm */,
268                          noreg /* obj */,
269                          dst /* pre_val */,
270                          rthread /* thread */,
271                          tmp1 /* tmp */,
272                          true /* tosca_live */,
273                          true /* expand_call */);
274     __ leave();
275   }
276 }
277 
278 void G1BarrierSetAssembler::oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
279                                          Address dst, Register val, Register tmp1, Register tmp2) {
280   // flatten object address if needed
281   if (dst.index() == noreg &amp;&amp; dst.offset() == 0) {
282     if (dst.base() != r3) {
283       __ mov(r3, dst.base());
284     }
285   } else {
286     __ lea(r3, dst);
287   }
288 
289   g1_write_barrier_pre(masm,
290                        r3 /* obj */,
291                        tmp2 /* pre_val */,
292                        rthread /* thread */,
293                        tmp1  /* tmp */,
294                        val != noreg /* tosca_live */,
295                        false /* expand_call */);
296 
297   if (val == noreg) {
298     BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), noreg, noreg, noreg);
299   } else {
300     // G1 barrier needs uncompressed oop for region cross check.
301     Register new_val = val;
302     if (UseCompressedOops) {
303       new_val = rscratch2;
304       __ mov(new_val, val);
305     }
306     BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), val, noreg, noreg);
307     g1_write_barrier_post(masm,
308                           r3 /* store_adr */,
309                           new_val /* new_val */,
310                           rthread /* thread */,
311                           tmp1 /* tmp */,
312                           tmp2 /* tmp2 */);
313   }
314 
315 }
316 
317 #ifdef COMPILER1
318 
319 #undef __
320 #define __ ce-&gt;masm()-&gt;
321 
322 void G1BarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, G1PreBarrierStub* stub) {
323   G1BarrierSetC1* bs = (G1BarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
324   // At this point we know that marking is in progress.
325   // If do_load() is true then we have to emit the
326   // load of the previous value; otherwise it has already
327   // been loaded into _pre_val.
328 
329   __ bind(*stub-&gt;entry());
330 
331   assert(stub-&gt;pre_val()-&gt;is_register(), &quot;Precondition.&quot;);
332 
333   Register pre_val_reg = stub-&gt;pre_val()-&gt;as_register();
334 
335   if (stub-&gt;do_load()) {
336     ce-&gt;mem2reg(stub-&gt;addr(), stub-&gt;pre_val(), T_OBJECT, stub-&gt;patch_code(), stub-&gt;info(), false /*wide*/, false /*unaligned*/);
337   }
338   __ cbz(pre_val_reg, *stub-&gt;continuation());
339   ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
340   __ far_call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
341   __ b(*stub-&gt;continuation());
342 }
343 
344 void G1BarrierSetAssembler::gen_post_barrier_stub(LIR_Assembler* ce, G1PostBarrierStub* stub) {
345   G1BarrierSetC1* bs = (G1BarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
346   __ bind(*stub-&gt;entry());
347   assert(stub-&gt;addr()-&gt;is_register(), &quot;Precondition.&quot;);
348   assert(stub-&gt;new_val()-&gt;is_register(), &quot;Precondition.&quot;);
349   Register new_val_reg = stub-&gt;new_val()-&gt;as_register();
350   __ cbz(new_val_reg, *stub-&gt;continuation());
351   ce-&gt;store_parameter(stub-&gt;addr()-&gt;as_pointer_register(), 0);
352   __ far_call(RuntimeAddress(bs-&gt;post_barrier_c1_runtime_code_blob()-&gt;code_begin()));
353   __ b(*stub-&gt;continuation());
354 }
355 
356 #undef __
357 
358 #define __ sasm-&gt;
359 
360 void G1BarrierSetAssembler::generate_c1_pre_barrier_runtime_stub(StubAssembler* sasm) {
361   __ prologue(&quot;g1_pre_barrier&quot;, false);
362 
363   // arg0 : previous value of memory
364 
365   BarrierSet* bs = BarrierSet::barrier_set();
366 
367   const Register pre_val = r0;
368   const Register thread = rthread;
369   const Register tmp = rscratch1;
370 
371   Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));
372   Address queue_index(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));
373   Address buffer(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));
374 
375   Label done;
376   Label runtime;
377 
378   // Is marking still active?
379   if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {
380     __ ldrw(tmp, in_progress);
381   } else {
382     assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, &quot;Assumption&quot;);
383     __ ldrb(tmp, in_progress);
384   }
385   __ cbzw(tmp, done);
386 
387   // Can we store original value in the thread&#39;s buffer?
388   __ ldr(tmp, queue_index);
389   __ cbz(tmp, runtime);
390 
391   __ sub(tmp, tmp, wordSize);
392   __ str(tmp, queue_index);
393   __ ldr(rscratch2, buffer);
394   __ add(tmp, tmp, rscratch2);
395   __ load_parameter(0, rscratch2);
396   __ str(rscratch2, Address(tmp, 0));
397   __ b(done);
398 
399   __ bind(runtime);
400   __ push_call_clobbered_registers();
401   __ load_parameter(0, pre_val);
402   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), pre_val, thread);
403   __ pop_call_clobbered_registers();
404   __ bind(done);
405 
406   __ epilogue();
407 }
408 
409 void G1BarrierSetAssembler::generate_c1_post_barrier_runtime_stub(StubAssembler* sasm) {
410   __ prologue(&quot;g1_post_barrier&quot;, false);
411 
412   // arg0: store_address
413   Address store_addr(rfp, 2*BytesPerWord);
414 
415   BarrierSet* bs = BarrierSet::barrier_set();
416   CardTableBarrierSet* ctbs = barrier_set_cast&lt;CardTableBarrierSet&gt;(bs);
417   CardTable* ct = ctbs-&gt;card_table();
418 
419   Label done;
420   Label runtime;
421 
422   // At this point we know new_value is non-NULL and the new_value crosses regions.
423   // Must check to see if card is already dirty
424 
425   const Register thread = rthread;
426 
427   Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));
428   Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));
429 
430   const Register card_offset = rscratch2;
431   // LR is free here, so we can use it to hold the byte_map_base.
432   const Register byte_map_base = lr;
433 
434   assert_different_registers(card_offset, byte_map_base, rscratch1);
435 
436   __ load_parameter(0, card_offset);
437   __ lsr(card_offset, card_offset, CardTable::card_shift);
438   __ load_byte_map_base(byte_map_base);
439   __ ldrb(rscratch1, Address(byte_map_base, card_offset));
440   __ cmpw(rscratch1, (int)G1CardTable::g1_young_card_val());
441   __ br(Assembler::EQ, done);
442 
443   assert((int)CardTable::dirty_card_val() == 0, &quot;must be 0&quot;);
444 
445   __ membar(Assembler::StoreLoad);
446   __ ldrb(rscratch1, Address(byte_map_base, card_offset));
447   __ cbzw(rscratch1, done);
448 
449   // storing region crossing non-NULL, card is clean.
450   // dirty card and log.
451   __ strb(zr, Address(byte_map_base, card_offset));
452 
453   // Convert card offset into an address in card_addr
454   Register card_addr = card_offset;
455   __ add(card_addr, byte_map_base, card_addr);
456 
457   __ ldr(rscratch1, queue_index);
458   __ cbz(rscratch1, runtime);
459   __ sub(rscratch1, rscratch1, wordSize);
460   __ str(rscratch1, queue_index);
461 
462   // Reuse LR to hold buffer_addr
463   const Register buffer_addr = lr;
464 
465   __ ldr(buffer_addr, buffer);
466   __ str(card_addr, Address(buffer_addr, rscratch1));
467   __ b(done);
468 
469   __ bind(runtime);
470   __ push_call_clobbered_registers();
471   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);
472   __ pop_call_clobbered_registers();
473   __ bind(done);
474   __ epilogue();
475 }
476 
477 #undef __
478 
479 #endif // COMPILER1
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/gc/shared/cardTableBarrierSetAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.inline.hpp&quot;
 27 #include &quot;gc/shared/barrierSet.hpp&quot;
 28 #include &quot;gc/shared/cardTable.hpp&quot;
 29 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 30 #include &quot;gc/shared/cardTableBarrierSetAssembler.hpp&quot;
 31 #include &quot;interpreter/interp_masm.hpp&quot;
 32 
 33 #define __ masm-&gt;
 34 
 35 void CardTableBarrierSetAssembler::store_check(MacroAssembler* masm, Register obj, Address dst) {
 36 
 37   BarrierSet* bs = BarrierSet::barrier_set();
 38   assert(bs-&gt;kind() == BarrierSet::CardTableBarrierSet, &quot;Wrong barrier set kind&quot;);
 39 
 40   CardTableBarrierSet* ctbs = barrier_set_cast&lt;CardTableBarrierSet&gt;(bs);
 41   CardTable* ct = ctbs-&gt;card_table();
 42 
 43   __ lsr(obj, obj, CardTable::card_shift);
 44 
 45   assert(CardTable::dirty_card_val() == 0, &quot;must be&quot;);
 46 
 47   __ load_byte_map_base(rscratch1);
 48 
 49   if (UseCondCardMark) {
 50     Label L_already_dirty;
 51     __ membar(Assembler::StoreLoad);
 52     __ ldrb(rscratch2,  Address(obj, rscratch1));
 53     __ cbz(rscratch2, L_already_dirty);
 54     __ strb(zr, Address(obj, rscratch1));
 55     __ bind(L_already_dirty);
 56   } else {
 57     if (ct-&gt;scanned_concurrently()) {
 58       __ membar(Assembler::StoreStore);
 59     }
 60     __ strb(zr, Address(obj, rscratch1));
 61   }
 62 }
 63 
 64 void CardTableBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,
 65                                                                     Register start, Register end, Register scratch, RegSet saved_regs) {
 66   BarrierSet* bs = BarrierSet::barrier_set();
 67   CardTableBarrierSet* ctbs = barrier_set_cast&lt;CardTableBarrierSet&gt;(bs);
 68   CardTable* ct = ctbs-&gt;card_table();
 69 
 70   Label L_loop;
 71 
 72   __ lsr(start, start, CardTable::card_shift);
 73   __ lsr(end, end, CardTable::card_shift);
 74   __ sub(end, end, start); // number of bytes to copy
 75 
 76   const Register count = end; // &#39;end&#39; register contains bytes count now
 77   __ load_byte_map_base(scratch);
 78   __ add(start, start, scratch);
 79   if (ct-&gt;scanned_concurrently()) {
 80     __ membar(__ StoreStore);
 81   }
 82   __ bind(L_loop);
 83   __ strb(zr, Address(start, count));
 84   __ subs(count, count, 1);
 85   __ br(Assembler::GE, L_loop);
 86 }
 87 
 88 void CardTableBarrierSetAssembler::oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
 89                                                 Address dst, Register val, Register tmp1, Register tmp2) {
 90   bool in_heap = (decorators &amp; IN_HEAP) != 0;
 91   bool is_array = (decorators &amp; IS_ARRAY) != 0;
 92   bool on_anonymous = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 93   bool precise = is_array || on_anonymous;
 94 
 95   bool needs_post_barrier = val != noreg &amp;&amp; in_heap;
 96   BarrierSetAssembler::store_at(masm, decorators, type, dst, val, noreg, noreg);
 97   if (needs_post_barrier) {
 98     // flatten object address if needed
 99     if (!precise || (dst.index() == noreg &amp;&amp; dst.offset() == 0)) {
100       store_check(masm, dst.base(), dst);
101     } else {
102       __ lea(r3, dst);
103       store_check(masm, r3, dst);
104     }
105   }
106 }
    </pre>
  </body>
</html>
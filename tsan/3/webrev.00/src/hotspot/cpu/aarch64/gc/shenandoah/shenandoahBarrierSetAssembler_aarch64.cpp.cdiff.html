<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/gc/shenandoah/shenandoahBarrierSetAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../shared/modRefBarrierSetAssembler_aarch64.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler_aarch64.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/gc/shenandoah/shenandoahBarrierSetAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,12 ***</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
<span class="line-new-header">--- 21,14 ---</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,58 ***</span>
  #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
  #endif
  
  #define __ masm-&gt;
  
<span class="line-modified">! address ShenandoahBarrierSetAssembler::_shenandoah_wb = NULL;</span>
  
  void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,
<span class="line-modified">!                                                        Register addr, Register count, RegSet saved_regs) {</span>
    if (is_oop) {
      bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
<span class="line-modified">!     if (!dest_uninitialized &amp;&amp; !ShenandoahHeap::heap()-&gt;heuristics()-&gt;can_do_traversal_gc()) {</span>
<span class="line-modified">!       __ push(saved_regs, sp);</span>
<span class="line-modified">!       if (count == c_rarg0) {</span>
<span class="line-modified">!         if (addr == c_rarg1) {</span>
<span class="line-modified">!           // exactly backwards!!</span>
<span class="line-modified">!           __ mov(rscratch1, c_rarg0);</span>
<span class="line-modified">!           __ mov(c_rarg0, c_rarg1);</span>
<span class="line-modified">!           __ mov(c_rarg1, rscratch1);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!           __ mov(c_rarg1, count);</span>
<span class="line-modified">!           __ mov(c_rarg0, addr);</span>
<span class="line-modified">!         }</span>
        } else {
<span class="line-modified">!         __ mov(c_rarg0, addr);</span>
<span class="line-modified">!         __ mov(c_rarg1, count);</span>
        }
        if (UseCompressedOops) {
<span class="line-modified">!         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_narrow_oop_entry), 2);</span>
        } else {
<span class="line-modified">!         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry), 2);</span>
        }
        __ pop(saved_regs, sp);
      }
    }
  }
  
<span class="line-removed">- void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,</span>
<span class="line-removed">-                                                        Register start, Register end, Register scratch, RegSet saved_regs) {</span>
<span class="line-removed">-   if (is_oop) {</span>
<span class="line-removed">-     __ push(saved_regs, sp);</span>
<span class="line-removed">-     // must compute element count unless barrier set interface is changed (other platforms supply count)</span>
<span class="line-removed">-     assert_different_registers(start, end, scratch);</span>
<span class="line-removed">-     __ lea(scratch, Address(end, BytesPerHeapOop));</span>
<span class="line-removed">-     __ sub(scratch, scratch, start);               // subtract start to get #bytes</span>
<span class="line-removed">-     __ lsr(scratch, scratch, LogBytesPerHeapOop);  // convert to element count</span>
<span class="line-removed">-     __ mov(c_rarg0, start);</span>
<span class="line-removed">-     __ mov(c_rarg1, scratch);</span>
<span class="line-removed">-     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_post_entry), 2);</span>
<span class="line-removed">-     __ pop(saved_regs, sp);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
                                                                   Register obj,
                                                                   Register pre_val,
                                                                   Register thread,
                                                                   Register tmp,
<span class="line-new-header">--- 41,54 ---</span>
  #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
  #endif
  
  #define __ masm-&gt;
  
<span class="line-modified">! address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;</span>
  
  void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,
<span class="line-modified">!                                                        Register src, Register dst, Register count, RegSet saved_regs) {</span>
    if (is_oop) {
      bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
<span class="line-modified">!     if ((ShenandoahSATBBarrier &amp;&amp; !dest_uninitialized) || ShenandoahLoadRefBarrier) {</span>
<span class="line-modified">! </span>
<span class="line-modified">!       Label done;</span>
<span class="line-modified">! </span>
<span class="line-modified">!       // Avoid calling runtime if count == 0</span>
<span class="line-modified">!       __ cbz(count, done);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       // Is marking active?</span>
<span class="line-modified">!       Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-modified">!       __ ldrb(rscratch1, gc_state);</span>
<span class="line-modified">!       if (dest_uninitialized) {</span>
<span class="line-modified">!         __ tbz(rscratch1, ShenandoahHeap::HAS_FORWARDED_BITPOS, done);</span>
        } else {
<span class="line-modified">!         __ mov(rscratch2, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::MARKING);</span>
<span class="line-modified">!         __ tst(rscratch1, rscratch2);</span>
<span class="line-added">+         __ br(Assembler::EQ, done);</span>
        }
<span class="line-added">+ </span>
<span class="line-added">+       __ push(saved_regs, sp);</span>
        if (UseCompressedOops) {
<span class="line-modified">!         if (dest_uninitialized) {</span>
<span class="line-added">+           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_duinit_narrow_oop_entry), src, dst, count);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_narrow_oop_entry), src, dst, count);</span>
<span class="line-added">+         }</span>
        } else {
<span class="line-modified">!         if (dest_uninitialized) {</span>
<span class="line-added">+           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_duinit_oop_entry), src, dst, count);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry), src, dst, count);</span>
<span class="line-added">+         }</span>
        }
        __ pop(saved_regs, sp);
<span class="line-added">+       __ bind(done);</span>
      }
    }
  }
  
  void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
                                                                   Register obj,
                                                                   Register pre_val,
                                                                   Register thread,
                                                                   Register tmp,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,87 ***</span>
    __ pop(saved, sp);
  
    __ bind(done);
  }
  
<span class="line-modified">! void ShenandoahBarrierSetAssembler::read_barrier(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">!   if (ShenandoahReadBarrier) {</span>
<span class="line-removed">-     read_barrier_impl(masm, dst);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ShenandoahBarrierSetAssembler::read_barrier_impl(MacroAssembler* masm, Register dst) {</span>
<span class="line-removed">-   assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier || ShenandoahCASBarrier), &quot;should be enabled&quot;);</span>
    Label is_null;
    __ cbz(dst, is_null);
<span class="line-modified">!   read_barrier_not_null_impl(masm, dst);</span>
    __ bind(is_null);
  }
  
<span class="line-modified">! void ShenandoahBarrierSetAssembler::read_barrier_not_null(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">!   if (ShenandoahReadBarrier) {</span>
<span class="line-modified">!     read_barrier_not_null_impl(masm, dst);</span>
    }
<span class="line-removed">- }</span>
  
  
<span class="line-modified">! void ShenandoahBarrierSetAssembler::read_barrier_not_null_impl(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">!   assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier || ShenandoahCASBarrier), &quot;should be enabled&quot;);</span>
<span class="line-modified">!   __ ldr(dst, Address(dst, ShenandoahBrooksPointer::byte_offset()));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void ShenandoahBarrierSetAssembler::write_barrier(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">!   if (ShenandoahWriteBarrier) {</span>
<span class="line-removed">-     write_barrier_impl(masm, dst);</span>
    }
  }
  
<span class="line-modified">! void ShenandoahBarrierSetAssembler::write_barrier_impl(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">!   assert(UseShenandoahGC &amp;&amp; (ShenandoahWriteBarrier || ShenandoahStoreValEnqueueBarrier), &quot;Should be enabled&quot;);</span>
<span class="line-removed">-   assert(dst != rscratch1, &quot;need rscratch1&quot;);</span>
    assert(dst != rscratch2, &quot;need rscratch2&quot;);
  
    Label done;
<span class="line-modified">! </span>
    Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
<span class="line-modified">!   __ ldrb(rscratch1, gc_state);</span>
  
    // Check for heap stability
<span class="line-modified">!   __ mov(rscratch2, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);</span>
<span class="line-removed">-   __ tst(rscratch1, rscratch2);</span>
<span class="line-removed">-   __ br(Assembler::EQ, done);</span>
  
<span class="line-modified">!   // Heap is unstable, need to perform the read-barrier even if WB is inactive</span>
<span class="line-modified">!   __ ldr(dst, Address(dst, ShenandoahBrooksPointer::byte_offset()));</span>
  
<span class="line-modified">!   // Check for evacuation-in-progress and jump to WB slow-path if needed</span>
<span class="line-modified">!   __ mov(rscratch2, ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);</span>
<span class="line-modified">!   __ tst(rscratch1, rscratch2);</span>
<span class="line-modified">!   __ br(Assembler::EQ, done);</span>
  
<span class="line-modified">!   RegSet to_save = RegSet::of(r0);</span>
<span class="line-removed">-   if (dst != r0) {</span>
<span class="line-removed">-     __ push(to_save, sp);</span>
<span class="line-removed">-     __ mov(r0, dst);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   __ far_call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_wb())));</span>
  
<span class="line-modified">!   if (dst != r0) {</span>
<span class="line-modified">!     __ mov(dst, r0);</span>
<span class="line-modified">!     __ pop(to_save, sp);</span>
    }
  
    __ bind(done);
  }
  
  void ShenandoahBarrierSetAssembler::storeval_barrier(MacroAssembler* masm, Register dst, Register tmp) {
    if (ShenandoahStoreValEnqueueBarrier) {
<span class="line-removed">-     Label is_null;</span>
<span class="line-removed">-     __ cbz(dst, is_null);</span>
<span class="line-removed">-     write_barrier_impl(masm, dst);</span>
<span class="line-removed">-     __ bind(is_null);</span>
      // Save possibly live regs.
      RegSet live_regs = RegSet::range(r0, r4) - dst;
      __ push(live_regs, sp);
      __ strd(v0, __ pre(sp, 2 * -wordSize));
  
<span class="line-new-header">--- 186,132 ---</span>
    __ pop(saved, sp);
  
    __ bind(done);
  }
  
<span class="line-modified">! void ShenandoahBarrierSetAssembler::resolve_forward_pointer(MacroAssembler* masm, Register dst, Register tmp) {</span>
<span class="line-modified">!   assert(ShenandoahLoadRefBarrier || ShenandoahCASBarrier, &quot;Should be enabled&quot;);</span>
    Label is_null;
    __ cbz(dst, is_null);
<span class="line-modified">!   resolve_forward_pointer_not_null(masm, dst, tmp);</span>
    __ bind(is_null);
  }
  
<span class="line-modified">! // IMPORTANT: This must preserve all registers, even rscratch1 and rscratch2, except those explicitely</span>
<span class="line-modified">! // passed in.</span>
<span class="line-modified">! void ShenandoahBarrierSetAssembler::resolve_forward_pointer_not_null(MacroAssembler* masm, Register dst, Register tmp) {</span>
<span class="line-added">+   assert(ShenandoahLoadRefBarrier || ShenandoahCASBarrier, &quot;Should be enabled&quot;);</span>
<span class="line-added">+   // The below loads the mark word, checks if the lowest two bits are</span>
<span class="line-added">+   // set, and if so, clear the lowest two bits and copy the result</span>
<span class="line-added">+   // to dst. Otherwise it leaves dst alone.</span>
<span class="line-added">+   // Implementing this is surprisingly awkward. I do it here by:</span>
<span class="line-added">+   // - Inverting the mark word</span>
<span class="line-added">+   // - Test lowest two bits == 0</span>
<span class="line-added">+   // - If so, set the lowest two bits</span>
<span class="line-added">+   // - Invert the result back, and copy to dst</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool borrow_reg = (tmp == noreg);</span>
<span class="line-added">+   if (borrow_reg) {</span>
<span class="line-added">+     // No free registers available. Make one useful.</span>
<span class="line-added">+     tmp = rscratch1;</span>
<span class="line-added">+     if (tmp == dst) {</span>
<span class="line-added">+       tmp = rscratch2;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     __ push(RegSet::of(tmp), sp);</span>
    }
  
<span class="line-added">+   assert_different_registers(tmp, dst);</span>
  
<span class="line-modified">!   Label done;</span>
<span class="line-modified">!   __ ldr(tmp, Address(dst, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-modified">!   __ eon(tmp, tmp, zr);</span>
<span class="line-modified">!   __ ands(zr, tmp, markWord::lock_mask_in_place);</span>
<span class="line-added">+   __ br(Assembler::NE, done);</span>
<span class="line-added">+   __ orr(tmp, tmp, markWord::marked_value);</span>
<span class="line-added">+   __ eon(dst, tmp, zr);</span>
<span class="line-added">+   __ bind(done);</span>
  
<span class="line-modified">!   if (borrow_reg) {</span>
<span class="line-modified">!     __ pop(RegSet::of(tmp), sp);</span>
    }
  }
  
<span class="line-modified">! void ShenandoahBarrierSetAssembler::load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address load_addr) {</span>
<span class="line-modified">!   assert(ShenandoahLoadRefBarrier, &quot;Should be enabled&quot;);</span>
    assert(dst != rscratch2, &quot;need rscratch2&quot;);
<span class="line-added">+   assert_different_registers(load_addr.base(), load_addr.index(), rscratch1, rscratch2);</span>
  
    Label done;
<span class="line-modified">!   __ enter();</span>
    Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
<span class="line-modified">!   __ ldrb(rscratch2, gc_state);</span>
  
    // Check for heap stability
<span class="line-modified">!   __ tbz(rscratch2, ShenandoahHeap::HAS_FORWARDED_BITPOS, done);</span>
  
<span class="line-modified">!   // use r1 for load address</span>
<span class="line-modified">!   Register result_dst = dst;</span>
<span class="line-added">+   if (dst == r1) {</span>
<span class="line-added">+     __ mov(rscratch1, dst);</span>
<span class="line-added">+     dst = rscratch1;</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   // Save r0 and r1, unless it is an output register</span>
<span class="line-modified">!   RegSet to_save = RegSet::of(r0, r1) - result_dst;</span>
<span class="line-modified">!   __ push(to_save, sp);</span>
<span class="line-modified">!   __ lea(r1, load_addr);</span>
<span class="line-added">+   __ mov(r0, dst);</span>
  
<span class="line-modified">!   __ far_call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_lrb())));</span>
  
<span class="line-modified">!   __ mov(result_dst, r0);</span>
<span class="line-added">+   __ pop(to_save, sp);</span>
  
<span class="line-modified">!   __ bind(done);</span>
<span class="line-modified">!   __ leave();</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address load_addr) {</span>
<span class="line-added">+   if (!ShenandoahLoadRefBarrier) {</span>
<span class="line-added">+     return;</span>
    }
  
<span class="line-added">+   assert(dst != rscratch2, &quot;need rscratch2&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Label is_null;</span>
<span class="line-added">+   Label done;</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ block_comment(&quot;load_reference_barrier_native { &quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ cbz(dst, is_null);</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ enter();</span>
<span class="line-added">+ </span>
<span class="line-added">+   Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-added">+   __ ldrb(rscratch2, gc_state);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Check for heap in evacuation phase</span>
<span class="line-added">+   __ tbz(rscratch2, ShenandoahHeap::EVACUATION_BITPOS, done);</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ mov(rscratch2, dst);</span>
<span class="line-added">+   __ push_call_clobbered_registers();</span>
<span class="line-added">+   __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));</span>
<span class="line-added">+   __ lea(r1, load_addr);</span>
<span class="line-added">+   __ mov(r0, rscratch2);</span>
<span class="line-added">+   __ blr(lr);</span>
<span class="line-added">+   __ mov(rscratch2, r0);</span>
<span class="line-added">+   __ pop_call_clobbered_registers();</span>
<span class="line-added">+   __ mov(dst, rscratch2);</span>
<span class="line-added">+ </span>
    __ bind(done);
<span class="line-added">+   __ leave();</span>
<span class="line-added">+   __ bind(is_null);</span>
<span class="line-added">+   __ block_comment(&quot;} load_reference_barrier_native&quot;);</span>
  }
  
  void ShenandoahBarrierSetAssembler::storeval_barrier(MacroAssembler* masm, Register dst, Register tmp) {
    if (ShenandoahStoreValEnqueueBarrier) {
      // Save possibly live regs.
      RegSet live_regs = RegSet::range(r0, r4) - dst;
      __ push(live_regs, sp);
      __ strd(v0, __ pre(sp, 2 * -wordSize));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,29 ***</span>
  
      // Restore possibly live regs.
      __ ldrd(v0, __ post(sp, 2 * wordSize));
      __ pop(live_regs, sp);
    }
<span class="line-modified">!   if (ShenandoahStoreValReadBarrier) {</span>
<span class="line-modified">!     read_barrier_impl(masm, dst);</span>
    }
  }
  
  void ShenandoahBarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
                                              Register dst, Address src, Register tmp1, Register tmp_thread) {
<span class="line-modified">!   bool on_oop = type == T_OBJECT || type == T_ARRAY;</span>
<span class="line-modified">!   bool in_heap = (decorators &amp; IN_HEAP) != 0;</span>
<span class="line-modified">!   bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;</span>
<span class="line-modified">!   bool on_phantom = (decorators &amp; ON_PHANTOM_OOP_REF) != 0;</span>
<span class="line-modified">!   bool on_reference = on_weak || on_phantom;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (in_heap) {</span>
<span class="line-modified">!     read_barrier_not_null(masm, src.base());</span>
    }
  
<span class="line-modified">!   BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-modified">!   if (ShenandoahKeepAliveBarrier &amp;&amp; on_oop &amp;&amp; on_reference) {</span>
      __ enter();
      satb_write_barrier_pre(masm /* masm */,
                             noreg /* obj */,
                             dst /* pre_val */,
                             rthread /* thread */,
<span class="line-new-header">--- 319,72 ---</span>
  
      // Restore possibly live regs.
      __ ldrd(v0, __ post(sp, 2 * wordSize));
      __ pop(live_regs, sp);
    }
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address load_addr) {</span>
<span class="line-added">+   if (ShenandoahLoadRefBarrier) {</span>
<span class="line-added">+     Label is_null;</span>
<span class="line-added">+     __ cbz(dst, is_null);</span>
<span class="line-added">+     load_reference_barrier_not_null(masm, dst, load_addr);</span>
<span class="line-added">+     __ bind(is_null);</span>
    }
  }
  
<span class="line-added">+ //</span>
<span class="line-added">+ // Arguments:</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // Inputs:</span>
<span class="line-added">+ //   src:        oop location to load from, might be clobbered</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // Output:</span>
<span class="line-added">+ //   dst:        oop loaded from src location</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // Kill:</span>
<span class="line-added">+ //   rscratch1 (scratch reg)</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // Alias:</span>
<span class="line-added">+ //   dst: rscratch1 (might use rscratch1 as temporary output register to avoid clobbering src)</span>
<span class="line-added">+ //</span>
  void ShenandoahBarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
                                              Register dst, Address src, Register tmp1, Register tmp_thread) {
<span class="line-modified">!   // 1: non-reference load, no additional barrier is needed</span>
<span class="line-modified">!   if (!is_reference_type(type)) {</span>
<span class="line-modified">!     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // 2: load a reference from src location and apply LRB if needed</span>
<span class="line-modified">!   if (ShenandoahBarrierSet::need_load_reference_barrier(decorators, type)) {</span>
<span class="line-added">+     Register result_dst = dst;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Preserve src location for LRB</span>
<span class="line-added">+     if (dst == src.base() || dst == src.index()) {</span>
<span class="line-added">+       dst = rscratch1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     assert_different_registers(dst, src.base(), src.index());</span>
<span class="line-added">+ </span>
<span class="line-added">+     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type)) {</span>
<span class="line-added">+       load_reference_barrier_native(masm, dst, src);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       load_reference_barrier(masm, dst, src);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (dst != result_dst) {</span>
<span class="line-added">+       __ mov(result_dst, dst);</span>
<span class="line-added">+       dst = result_dst;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
    }
  
<span class="line-modified">!   // 3: apply keep-alive barrier if needed</span>
<span class="line-modified">!   if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {</span>
      __ enter();
      satb_write_barrier_pre(masm /* masm */,
                             noreg /* obj */,
                             dst /* pre_val */,
                             rthread /* thread */,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,15 ***</span>
    }
  }
  
  void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
                                               Address dst, Register val, Register tmp1, Register tmp2) {
<span class="line-modified">!   bool on_oop = type == T_OBJECT || type == T_ARRAY;</span>
<span class="line-removed">-   bool in_heap = (decorators &amp; IN_HEAP) != 0;</span>
<span class="line-removed">-   if (in_heap) {</span>
<span class="line-removed">-     write_barrier(masm, dst.base());</span>
<span class="line-removed">-   }</span>
    if (!on_oop) {
      BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);
      return;
    }
  
<span class="line-new-header">--- 395,11 ---</span>
    }
  }
  
  void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
                                               Address dst, Register val, Register tmp1, Register tmp2) {
<span class="line-modified">!   bool on_oop = is_reference_type(type);</span>
    if (!on_oop) {
      BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);
      return;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,79 ***</span>
      BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), val, noreg, noreg);
    }
  
  }
  
<span class="line-modified">! void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm, Register op1, Register op2) {</span>
<span class="line-modified">!   __ cmp(op1, op2);</span>
<span class="line-modified">!   if (ShenandoahAcmpBarrier) {</span>
<span class="line-modified">!     Label done;</span>
<span class="line-modified">!     __ br(Assembler::EQ, done);</span>
<span class="line-removed">-     // The object may have been evacuated, but we won&#39;t see it without a</span>
<span class="line-removed">-     // membar here.</span>
<span class="line-removed">-     __ membar(Assembler::LoadStore| Assembler::LoadLoad);</span>
<span class="line-removed">-     read_barrier(masm, op1);</span>
<span class="line-removed">-     read_barrier(masm, op2);</span>
<span class="line-removed">-     __ cmp(op1, op2);</span>
<span class="line-removed">-     __ bind(done);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ShenandoahBarrierSetAssembler::tlab_allocate(MacroAssembler* masm, Register obj,</span>
<span class="line-removed">-                                                   Register var_size_in_bytes,</span>
<span class="line-removed">-                                                   int con_size_in_bytes,</span>
<span class="line-removed">-                                                   Register t1,</span>
<span class="line-removed">-                                                   Register t2,</span>
<span class="line-removed">-                                                   Label&amp; slow_case) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert_different_registers(obj, t2);</span>
<span class="line-removed">-   assert_different_registers(obj, var_size_in_bytes);</span>
<span class="line-removed">-   Register end = t2;</span>
  
<span class="line-modified">!   __ ldr(obj, Address(rthread, JavaThread::tlab_top_offset()));</span>
<span class="line-modified">!   if (var_size_in_bytes == noreg) {</span>
<span class="line-removed">-     __ lea(end, Address(obj, (int) (con_size_in_bytes + ShenandoahBrooksPointer::byte_size())));</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     __ add(var_size_in_bytes, var_size_in_bytes, ShenandoahBrooksPointer::byte_size());</span>
<span class="line-removed">-     __ lea(end, Address(obj, var_size_in_bytes));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   __ ldr(rscratch1, Address(rthread, JavaThread::tlab_end_offset()));</span>
<span class="line-removed">-   __ cmp(end, rscratch1);</span>
<span class="line-removed">-   __ br(Assembler::HI, slow_case);</span>
  
<span class="line-modified">!   // update the tlab top pointer</span>
<span class="line-modified">!   __ str(end, Address(rthread, JavaThread::tlab_top_offset()));</span>
  
<span class="line-modified">!   __ add(obj, obj, ShenandoahBrooksPointer::byte_size());</span>
<span class="line-modified">!   __ str(obj, Address(obj, ShenandoahBrooksPointer::byte_offset()));</span>
  
<span class="line-modified">!   // recover var_size_in_bytes if necessary</span>
<span class="line-removed">-   if (var_size_in_bytes == end) {</span>
<span class="line-removed">-     __ sub(var_size_in_bytes, var_size_in_bytes, obj);</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-removed">- void ShenandoahBarrierSetAssembler::resolve(MacroAssembler* masm, DecoratorSet decorators, Register obj) {</span>
<span class="line-removed">-   bool oop_not_null = (decorators &amp; IS_NOT_NULL) != 0;</span>
<span class="line-removed">-   bool is_write = (decorators &amp; ACCESS_WRITE) != 0;</span>
<span class="line-removed">-   if (is_write) {</span>
<span class="line-removed">-     if (oop_not_null) {</span>
<span class="line-removed">-       write_barrier(masm, obj);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       Label done;</span>
<span class="line-removed">-       __ cbz(obj, done);</span>
<span class="line-removed">-       write_barrier(masm, obj);</span>
<span class="line-removed">-       __ bind(done);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     if (oop_not_null) {</span>
<span class="line-removed">-       read_barrier_not_null(masm, obj);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       read_barrier(masm, obj);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
  
  void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm, Register addr, Register expected, Register new_val,
                                                  bool acquire, bool release, bool weak, bool is_cae,
                                                  Register result) {
    Register tmp1 = rscratch1;
<span class="line-new-header">--- 433,30 ---</span>
      BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), val, noreg, noreg);
    }
  
  }
  
<span class="line-modified">! void ShenandoahBarrierSetAssembler::try_resolve_jobject_in_native(MacroAssembler* masm, Register jni_env,</span>
<span class="line-modified">!                                                                   Register obj, Register tmp, Label&amp; slowpath) {</span>
<span class="line-modified">!   Label done;</span>
<span class="line-modified">!   // Resolve jobject</span>
<span class="line-modified">!   BarrierSetAssembler::try_resolve_jobject_in_native(masm, jni_env, obj, tmp, slowpath);</span>
  
<span class="line-modified">!   // Check for null.</span>
<span class="line-modified">!   __ cbz(obj, done);</span>
  
<span class="line-modified">!   assert(obj != rscratch2, &quot;need rscratch2&quot;);</span>
<span class="line-modified">!   Address gc_state(jni_env, ShenandoahThreadLocalData::gc_state_offset() - JavaThread::jni_environment_offset());</span>
<span class="line-added">+   __ lea(rscratch2, gc_state);</span>
<span class="line-added">+   __ ldrb(rscratch2, Address(rscratch2));</span>
  
<span class="line-modified">!   // Check for heap in evacuation phase</span>
<span class="line-modified">!   __ tbnz(rscratch2, ShenandoahHeap::EVACUATION_BITPOS, slowpath);</span>
  
<span class="line-modified">!   __ bind(done);</span>
  }
  
  
  void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm, Register addr, Register expected, Register new_val,
                                                  bool acquire, bool release, bool weak, bool is_cae,
                                                  Register result) {
    Register tmp1 = rscratch1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 458,12 ***</span>
    __ mov(expected, tmp1);
    if (is_narrow) {
      __ decode_heap_oop(tmp1, tmp1);
      __ decode_heap_oop(tmp2, tmp2);
    }
<span class="line-modified">!   read_barrier_impl(masm, tmp1);</span>
<span class="line-modified">!   read_barrier_impl(masm, tmp2);</span>
    __ cmp(tmp1, tmp2);
    // Retry with expected now being the value we just loaded from addr.
    __ br(Assembler::EQ, retry);
    if (is_cae &amp;&amp; is_narrow) {
      // For cmp-and-exchange and narrow oops, we need to restore
<span class="line-new-header">--- 492,12 ---</span>
    __ mov(expected, tmp1);
    if (is_narrow) {
      __ decode_heap_oop(tmp1, tmp1);
      __ decode_heap_oop(tmp2, tmp2);
    }
<span class="line-modified">!   resolve_forward_pointer(masm, tmp1);</span>
<span class="line-modified">!   resolve_forward_pointer(masm, tmp2);</span>
    __ cmp(tmp1, tmp2);
    // Retry with expected now being the value we just loaded from addr.
    __ br(Assembler::EQ, retry);
    if (is_cae &amp;&amp; is_narrow) {
      // For cmp-and-exchange and narrow oops, we need to restore
</pre>
<hr />
<pre>
<span class="line-old-header">*** 477,13 ***</span>
    } else {
      __ cset(result, Assembler::EQ);
    }
  }
  
  #ifdef COMPILER1
  
<span class="line-removed">- #undef __</span>
  #define __ ce-&gt;masm()-&gt;
  
  void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
    ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
    // At this point we know that marking is in progress.
<span class="line-new-header">--- 511,14 ---</span>
    } else {
      __ cset(result, Assembler::EQ);
    }
  }
  
<span class="line-added">+ #undef __</span>
<span class="line-added">+ </span>
  #ifdef COMPILER1
  
  #define __ ce-&gt;masm()-&gt;
  
  void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
    ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
    // At this point we know that marking is in progress.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 504,30 ***</span>
    ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
    __ far_call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
    __ b(*stub-&gt;continuation());
  }
  
<span class="line-modified">! void ShenandoahBarrierSetAssembler::gen_write_barrier_stub(LIR_Assembler* ce, ShenandoahWriteBarrierStub* stub) {</span>
  
    Register obj = stub-&gt;obj()-&gt;as_register();
    Register res = stub-&gt;result()-&gt;as_register();
  
<span class="line-modified">!   Label done;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   __ bind(*stub-&gt;entry());</span>
  
    if (res != obj) {
      __ mov(res, obj);
    }
    // Check for null.
<span class="line-modified">!   if (stub-&gt;needs_null_check()) {</span>
<span class="line-modified">!     __ cbz(res, done);</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   write_barrier(ce-&gt;masm(), res);</span>
  
<span class="line-removed">-   __ bind(done);</span>
    __ b(*stub-&gt;continuation());
  }
  
  #undef __
  
<span class="line-new-header">--- 539,56 ---</span>
    ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
    __ far_call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
    __ b(*stub-&gt;continuation());
  }
  
<span class="line-modified">! void ShenandoahBarrierSetAssembler::gen_load_reference_barrier_stub(LIR_Assembler* ce, ShenandoahLoadReferenceBarrierStub* stub) {</span>
<span class="line-added">+   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();</span>
<span class="line-added">+   __ bind(*stub-&gt;entry());</span>
  
    Register obj = stub-&gt;obj()-&gt;as_register();
    Register res = stub-&gt;result()-&gt;as_register();
<span class="line-added">+   Register addr = stub-&gt;addr()-&gt;as_pointer_register();</span>
<span class="line-added">+   Register tmp1 = stub-&gt;tmp1()-&gt;as_register();</span>
<span class="line-added">+   Register tmp2 = stub-&gt;tmp2()-&gt;as_register();</span>
  
<span class="line-modified">!   assert(res == r0, &quot;result must arrive in r0&quot;);</span>
  
    if (res != obj) {
      __ mov(res, obj);
    }
<span class="line-added">+ </span>
    // Check for null.
<span class="line-modified">!   __ cbz(res, *stub-&gt;continuation());</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Check for object in cset.</span>
<span class="line-added">+   __ mov(tmp2, ShenandoahHeap::in_cset_fast_test_addr());</span>
<span class="line-added">+   __ lsr(tmp1, res, ShenandoahHeapRegion::region_size_bytes_shift_jint());</span>
<span class="line-added">+   __ ldrb(tmp2, Address(tmp2, tmp1));</span>
<span class="line-added">+   __ cbz(tmp2, *stub-&gt;continuation());</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Check if object is already forwarded.</span>
<span class="line-added">+   Label slow_path;</span>
<span class="line-added">+   __ ldr(tmp1, Address(res, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">+   __ eon(tmp1, tmp1, zr);</span>
<span class="line-added">+   __ ands(zr, tmp1, markWord::lock_mask_in_place);</span>
<span class="line-added">+   __ br(Assembler::NE, slow_path);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Decode forwarded object.</span>
<span class="line-added">+   __ orr(tmp1, tmp1, markWord::marked_value);</span>
<span class="line-added">+   __ eon(res, tmp1, zr);</span>
<span class="line-added">+   __ b(*stub-&gt;continuation());</span>
  
<span class="line-modified">!   __ bind(slow_path);</span>
<span class="line-added">+   ce-&gt;store_parameter(res, 0);</span>
<span class="line-added">+   ce-&gt;store_parameter(addr, 1);</span>
<span class="line-added">+   if (stub-&gt;is_native()) {</span>
<span class="line-added">+     __ far_call(RuntimeAddress(bs-&gt;load_reference_barrier_native_rt_code_blob()-&gt;code_begin()));</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     __ far_call(RuntimeAddress(bs-&gt;load_reference_barrier_rt_code_blob()-&gt;code_begin()));</span>
<span class="line-added">+   }</span>
  
    __ b(*stub-&gt;continuation());
  }
  
  #undef __
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 577,69 ***</span>
    __ bind(done);
  
    __ epilogue();
  }
  
  #undef __
  
  #endif // COMPILER1
  
<span class="line-modified">! address ShenandoahBarrierSetAssembler::shenandoah_wb() {</span>
<span class="line-modified">!   assert(_shenandoah_wb != NULL, &quot;need write barrier stub&quot;);</span>
<span class="line-modified">!   return _shenandoah_wb;</span>
  }
  
  #define __ cgen-&gt;assembler()-&gt;
  
<span class="line-modified">! // Shenandoah write barrier.</span>
  //
  // Input:
  //   r0: OOP to evacuate.  Not null.
  //
  // Output:
  //   r0: Pointer to evacuated OOP.
  //
  // Trash rscratch1, rscratch2.  Preserve everything else.
<span class="line-modified">! address ShenandoahBarrierSetAssembler::generate_shenandoah_wb(StubCodeGenerator* cgen) {</span>
  
    __ align(6);
<span class="line-modified">!   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_wb&quot;);</span>
    address start = __ pc();
  
<span class="line-modified">!   Label work;</span>
    __ mov(rscratch2, ShenandoahHeap::in_cset_fast_test_addr());
    __ lsr(rscratch1, r0, ShenandoahHeapRegion::region_size_bytes_shift_jint());
    __ ldrb(rscratch2, Address(rscratch2, rscratch1));
    __ tbnz(rscratch2, 0, work);
    __ ret(lr);
    __ bind(work);
  
<span class="line-modified">!   Register obj = r0;</span>
  
    __ enter(); // required for proper stackwalking of RuntimeStub frame
  
    __ push_call_clobbered_registers();
  
<span class="line-modified">!   __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_JRT));</span>
<span class="line-modified">!   __ blrt(lr, 1, 0, MacroAssembler::ret_type_integral);</span>
<span class="line-modified">!   __ mov(rscratch1, obj);</span>
    __ pop_call_clobbered_registers();
<span class="line-modified">!   __ mov(obj, rscratch1);</span>
  
    __ leave(); // required for proper stackwalking of RuntimeStub frame
    __ ret(lr);
  
    return start;
  }
  
  #undef __
  
  void ShenandoahBarrierSetAssembler::barrier_stubs_init() {
<span class="line-modified">!   if (ShenandoahWriteBarrier || ShenandoahStoreValEnqueueBarrier) {</span>
      int stub_code_size = 2048;
      ResourceMark rm;
      BufferBlob* bb = BufferBlob::create(&quot;shenandoah_barrier_stubs&quot;, stub_code_size);
      CodeBuffer buf(bb);
      StubCodeGenerator cgen(&amp;buf);
<span class="line-modified">!     _shenandoah_wb = generate_shenandoah_wb(&amp;cgen);</span>
    }
  }
<span class="line-new-header">--- 638,107 ---</span>
    __ bind(done);
  
    __ epilogue();
  }
  
<span class="line-added">+ void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native) {</span>
<span class="line-added">+   __ prologue(&quot;shenandoah_load_reference_barrier&quot;, false);</span>
<span class="line-added">+   // arg0 : object to be resolved</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ push_call_clobbered_registers();</span>
<span class="line-added">+   __ load_parameter(0, r0);</span>
<span class="line-added">+   __ load_parameter(1, r1);</span>
<span class="line-added">+   if (is_native) {</span>
<span class="line-added">+     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));</span>
<span class="line-added">+   } else if (UseCompressedOops) {</span>
<span class="line-added">+     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow));</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   __ blr(lr);</span>
<span class="line-added">+   __ mov(rscratch1, r0);</span>
<span class="line-added">+   __ pop_call_clobbered_registers();</span>
<span class="line-added">+   __ mov(r0, rscratch1);</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ epilogue();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #undef __
  
  #endif // COMPILER1
  
<span class="line-modified">! address ShenandoahBarrierSetAssembler::shenandoah_lrb() {</span>
<span class="line-modified">!   assert(_shenandoah_lrb != NULL, &quot;need load reference barrier stub&quot;);</span>
<span class="line-modified">!   return _shenandoah_lrb;</span>
  }
  
  #define __ cgen-&gt;assembler()-&gt;
  
<span class="line-modified">! // Shenandoah load reference barrier.</span>
  //
  // Input:
  //   r0: OOP to evacuate.  Not null.
<span class="line-added">+ //   r1: load address</span>
  //
  // Output:
  //   r0: Pointer to evacuated OOP.
  //
  // Trash rscratch1, rscratch2.  Preserve everything else.
<span class="line-modified">! address ShenandoahBarrierSetAssembler::generate_shenandoah_lrb(StubCodeGenerator* cgen) {</span>
  
    __ align(6);
<span class="line-modified">!   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_lrb&quot;);</span>
    address start = __ pc();
  
<span class="line-modified">!   Label work, done;</span>
    __ mov(rscratch2, ShenandoahHeap::in_cset_fast_test_addr());
    __ lsr(rscratch1, r0, ShenandoahHeapRegion::region_size_bytes_shift_jint());
    __ ldrb(rscratch2, Address(rscratch2, rscratch1));
    __ tbnz(rscratch2, 0, work);
    __ ret(lr);
    __ bind(work);
  
<span class="line-modified">!   Label slow_path;</span>
<span class="line-added">+   __ ldr(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">+   __ eon(rscratch1, rscratch1, zr);</span>
<span class="line-added">+   __ ands(zr, rscratch1, markWord::lock_mask_in_place);</span>
<span class="line-added">+   __ br(Assembler::NE, slow_path);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Decode forwarded object.</span>
<span class="line-added">+   __ orr(rscratch1, rscratch1, markWord::marked_value);</span>
<span class="line-added">+   __ eon(r0, rscratch1, zr);</span>
<span class="line-added">+   __ ret(lr);</span>
  
<span class="line-added">+   __ bind(slow_path);</span>
    __ enter(); // required for proper stackwalking of RuntimeStub frame
  
    __ push_call_clobbered_registers();
  
<span class="line-modified">!   if (UseCompressedOops) {</span>
<span class="line-modified">!     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow));</span>
<span class="line-modified">!   } else {</span>
<span class="line-added">+     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   __ blr(lr);</span>
<span class="line-added">+   __ mov(rscratch1, r0);</span>
    __ pop_call_clobbered_registers();
<span class="line-modified">!   __ mov(r0, rscratch1);</span>
  
    __ leave(); // required for proper stackwalking of RuntimeStub frame
<span class="line-added">+   __ bind(done);</span>
    __ ret(lr);
  
    return start;
  }
  
  #undef __
  
  void ShenandoahBarrierSetAssembler::barrier_stubs_init() {
<span class="line-modified">!   if (ShenandoahLoadRefBarrier) {</span>
      int stub_code_size = 2048;
      ResourceMark rm;
      BufferBlob* bb = BufferBlob::create(&quot;shenandoah_barrier_stubs&quot;, stub_code_size);
      CodeBuffer buf(bb);
      StubCodeGenerator cgen(&amp;buf);
<span class="line-modified">!     _shenandoah_lrb = generate_shenandoah_lrb(&amp;cgen);</span>
    }
  }
</pre>
<center><a href="../shared/modRefBarrierSetAssembler_aarch64.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler_aarch64.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
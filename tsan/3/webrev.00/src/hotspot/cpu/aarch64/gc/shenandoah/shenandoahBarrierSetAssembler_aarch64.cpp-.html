<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/gc/shenandoah/shenandoahBarrierSetAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
 26 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
 31 #include &quot;interpreter/interpreter.hpp&quot;
 32 #include &quot;interpreter/interp_masm.hpp&quot;
 33 #include &quot;runtime/sharedRuntime.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 #ifdef COMPILER1
 36 #include &quot;c1/c1_LIRAssembler.hpp&quot;
 37 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 38 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
 39 #endif
 40 
 41 #define __ masm-&gt;
 42 
 43 address ShenandoahBarrierSetAssembler::_shenandoah_wb = NULL;
 44 
 45 void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,
 46                                                        Register addr, Register count, RegSet saved_regs) {
 47   if (is_oop) {
 48     bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
 49     if (!dest_uninitialized &amp;&amp; !ShenandoahHeap::heap()-&gt;heuristics()-&gt;can_do_traversal_gc()) {
 50       __ push(saved_regs, sp);
 51       if (count == c_rarg0) {
 52         if (addr == c_rarg1) {
 53           // exactly backwards!!
 54           __ mov(rscratch1, c_rarg0);
 55           __ mov(c_rarg0, c_rarg1);
 56           __ mov(c_rarg1, rscratch1);
 57         } else {
 58           __ mov(c_rarg1, count);
 59           __ mov(c_rarg0, addr);
 60         }
 61       } else {
 62         __ mov(c_rarg0, addr);
 63         __ mov(c_rarg1, count);
 64       }
 65       if (UseCompressedOops) {
 66         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_narrow_oop_entry), 2);
 67       } else {
 68         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry), 2);
 69       }
 70       __ pop(saved_regs, sp);
 71     }
 72   }
 73 }
 74 
 75 void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,
 76                                                        Register start, Register end, Register scratch, RegSet saved_regs) {
 77   if (is_oop) {
 78     __ push(saved_regs, sp);
 79     // must compute element count unless barrier set interface is changed (other platforms supply count)
 80     assert_different_registers(start, end, scratch);
 81     __ lea(scratch, Address(end, BytesPerHeapOop));
 82     __ sub(scratch, scratch, start);               // subtract start to get #bytes
 83     __ lsr(scratch, scratch, LogBytesPerHeapOop);  // convert to element count
 84     __ mov(c_rarg0, start);
 85     __ mov(c_rarg1, scratch);
 86     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_post_entry), 2);
 87     __ pop(saved_regs, sp);
 88   }
 89 }
 90 
 91 void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
 92                                                                  Register obj,
 93                                                                  Register pre_val,
 94                                                                  Register thread,
 95                                                                  Register tmp,
 96                                                                  bool tosca_live,
 97                                                                  bool expand_call) {
 98   if (ShenandoahSATBBarrier) {
 99     satb_write_barrier_pre(masm, obj, pre_val, thread, tmp, tosca_live, expand_call);
100   }
101 }
102 
103 void ShenandoahBarrierSetAssembler::satb_write_barrier_pre(MacroAssembler* masm,
104                                                            Register obj,
105                                                            Register pre_val,
106                                                            Register thread,
107                                                            Register tmp,
108                                                            bool tosca_live,
109                                                            bool expand_call) {
110   // If expand_call is true then we expand the call_VM_leaf macro
111   // directly to skip generating the check by
112   // InterpreterMacroAssembler::call_VM_leaf_base that checks _last_sp.
113 
114   assert(thread == rthread, &quot;must be&quot;);
115 
116   Label done;
117   Label runtime;
118 
119   assert_different_registers(obj, pre_val, tmp, rscratch1);
120   assert(pre_val != noreg &amp;&amp;  tmp != noreg, &quot;expecting a register&quot;);
121 
122   Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));
123   Address index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
124   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
125 
126   // Is marking active?
127   if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {
128     __ ldrw(tmp, in_progress);
129   } else {
130     assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, &quot;Assumption&quot;);
131     __ ldrb(tmp, in_progress);
132   }
133   __ cbzw(tmp, done);
134 
135   // Do we need to load the previous value?
136   if (obj != noreg) {
137     __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);
138   }
139 
140   // Is the previous value null?
141   __ cbz(pre_val, done);
142 
143   // Can we store original value in the thread&#39;s buffer?
144   // Is index == 0?
145   // (The index field is typed as size_t.)
146 
147   __ ldr(tmp, index);                      // tmp := *index_adr
148   __ cbz(tmp, runtime);                    // tmp == 0?
149                                         // If yes, goto runtime
150 
151   __ sub(tmp, tmp, wordSize);              // tmp := tmp - wordSize
152   __ str(tmp, index);                      // *index_adr := tmp
153   __ ldr(rscratch1, buffer);
154   __ add(tmp, tmp, rscratch1);             // tmp := tmp + *buffer_adr
155 
156   // Record the previous value
157   __ str(pre_val, Address(tmp, 0));
158   __ b(done);
159 
160   __ bind(runtime);
161   // save the live input values
162   RegSet saved = RegSet::of(pre_val);
163   if (tosca_live) saved += RegSet::of(r0);
164   if (obj != noreg) saved += RegSet::of(obj);
165 
166   __ push(saved, sp);
167 
168   // Calling the runtime using the regular call_VM_leaf mechanism generates
169   // code (generated by InterpreterMacroAssember::call_VM_leaf_base)
170   // that checks that the *(rfp+frame::interpreter_frame_last_sp) == NULL.
171   //
172   // If we care generating the pre-barrier without a frame (e.g. in the
173   // intrinsified Reference.get() routine) then ebp might be pointing to
174   // the caller frame and so this check will most likely fail at runtime.
175   //
176   // Expanding the call directly bypasses the generation of the check.
177   // So when we do not have have a full interpreter frame on the stack
178   // expand_call should be passed true.
179 
180   if (expand_call) {
181     assert(pre_val != c_rarg1, &quot;smashed arg&quot;);
182     __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);
183   } else {
184     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);
185   }
186 
187   __ pop(saved, sp);
188 
189   __ bind(done);
190 }
191 
192 void ShenandoahBarrierSetAssembler::read_barrier(MacroAssembler* masm, Register dst) {
193   if (ShenandoahReadBarrier) {
194     read_barrier_impl(masm, dst);
195   }
196 }
197 
198 void ShenandoahBarrierSetAssembler::read_barrier_impl(MacroAssembler* masm, Register dst) {
199   assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier || ShenandoahCASBarrier), &quot;should be enabled&quot;);
200   Label is_null;
201   __ cbz(dst, is_null);
202   read_barrier_not_null_impl(masm, dst);
203   __ bind(is_null);
204 }
205 
206 void ShenandoahBarrierSetAssembler::read_barrier_not_null(MacroAssembler* masm, Register dst) {
207   if (ShenandoahReadBarrier) {
208     read_barrier_not_null_impl(masm, dst);
209   }
210 }
211 
212 
213 void ShenandoahBarrierSetAssembler::read_barrier_not_null_impl(MacroAssembler* masm, Register dst) {
214   assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier || ShenandoahCASBarrier), &quot;should be enabled&quot;);
215   __ ldr(dst, Address(dst, ShenandoahBrooksPointer::byte_offset()));
216 }
217 
218 void ShenandoahBarrierSetAssembler::write_barrier(MacroAssembler* masm, Register dst) {
219   if (ShenandoahWriteBarrier) {
220     write_barrier_impl(masm, dst);
221   }
222 }
223 
224 void ShenandoahBarrierSetAssembler::write_barrier_impl(MacroAssembler* masm, Register dst) {
225   assert(UseShenandoahGC &amp;&amp; (ShenandoahWriteBarrier || ShenandoahStoreValEnqueueBarrier), &quot;Should be enabled&quot;);
226   assert(dst != rscratch1, &quot;need rscratch1&quot;);
227   assert(dst != rscratch2, &quot;need rscratch2&quot;);
228 
229   Label done;
230 
231   Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
232   __ ldrb(rscratch1, gc_state);
233 
234   // Check for heap stability
235   __ mov(rscratch2, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);
236   __ tst(rscratch1, rscratch2);
237   __ br(Assembler::EQ, done);
238 
239   // Heap is unstable, need to perform the read-barrier even if WB is inactive
240   __ ldr(dst, Address(dst, ShenandoahBrooksPointer::byte_offset()));
241 
242   // Check for evacuation-in-progress and jump to WB slow-path if needed
243   __ mov(rscratch2, ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);
244   __ tst(rscratch1, rscratch2);
245   __ br(Assembler::EQ, done);
246 
247   RegSet to_save = RegSet::of(r0);
248   if (dst != r0) {
249     __ push(to_save, sp);
250     __ mov(r0, dst);
251   }
252 
253   __ far_call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_wb())));
254 
255   if (dst != r0) {
256     __ mov(dst, r0);
257     __ pop(to_save, sp);
258   }
259 
260   __ bind(done);
261 }
262 
263 void ShenandoahBarrierSetAssembler::storeval_barrier(MacroAssembler* masm, Register dst, Register tmp) {
264   if (ShenandoahStoreValEnqueueBarrier) {
265     Label is_null;
266     __ cbz(dst, is_null);
267     write_barrier_impl(masm, dst);
268     __ bind(is_null);
269     // Save possibly live regs.
270     RegSet live_regs = RegSet::range(r0, r4) - dst;
271     __ push(live_regs, sp);
272     __ strd(v0, __ pre(sp, 2 * -wordSize));
273 
274     satb_write_barrier_pre(masm, noreg, dst, rthread, tmp, true, false);
275 
276     // Restore possibly live regs.
277     __ ldrd(v0, __ post(sp, 2 * wordSize));
278     __ pop(live_regs, sp);
279   }
280   if (ShenandoahStoreValReadBarrier) {
281     read_barrier_impl(masm, dst);
282   }
283 }
284 
285 void ShenandoahBarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
286                                             Register dst, Address src, Register tmp1, Register tmp_thread) {
287   bool on_oop = type == T_OBJECT || type == T_ARRAY;
288   bool in_heap = (decorators &amp; IN_HEAP) != 0;
289   bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;
290   bool on_phantom = (decorators &amp; ON_PHANTOM_OOP_REF) != 0;
291   bool on_reference = on_weak || on_phantom;
292 
293   if (in_heap) {
294     read_barrier_not_null(masm, src.base());
295   }
296 
297   BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);
298   if (ShenandoahKeepAliveBarrier &amp;&amp; on_oop &amp;&amp; on_reference) {
299     __ enter();
300     satb_write_barrier_pre(masm /* masm */,
301                            noreg /* obj */,
302                            dst /* pre_val */,
303                            rthread /* thread */,
304                            tmp1 /* tmp */,
305                            true /* tosca_live */,
306                            true /* expand_call */);
307     __ leave();
308   }
309 }
310 
311 void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
312                                              Address dst, Register val, Register tmp1, Register tmp2) {
313   bool on_oop = type == T_OBJECT || type == T_ARRAY;
314   bool in_heap = (decorators &amp; IN_HEAP) != 0;
315   if (in_heap) {
316     write_barrier(masm, dst.base());
317   }
318   if (!on_oop) {
319     BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);
320     return;
321   }
322 
323   // flatten object address if needed
324   if (dst.index() == noreg &amp;&amp; dst.offset() == 0) {
325     if (dst.base() != r3) {
326       __ mov(r3, dst.base());
327     }
328   } else {
329     __ lea(r3, dst);
330   }
331 
332   shenandoah_write_barrier_pre(masm,
333                                r3 /* obj */,
334                                tmp2 /* pre_val */,
335                                rthread /* thread */,
336                                tmp1  /* tmp */,
337                                val != noreg /* tosca_live */,
338                                false /* expand_call */);
339 
340   if (val == noreg) {
341     BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), noreg, noreg, noreg);
342   } else {
343     storeval_barrier(masm, val, tmp1);
344     // G1 barrier needs uncompressed oop for region cross check.
345     Register new_val = val;
346     if (UseCompressedOops) {
347       new_val = rscratch2;
348       __ mov(new_val, val);
349     }
350     BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), val, noreg, noreg);
351   }
352 
353 }
354 
355 void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm, Register op1, Register op2) {
356   __ cmp(op1, op2);
357   if (ShenandoahAcmpBarrier) {
358     Label done;
359     __ br(Assembler::EQ, done);
360     // The object may have been evacuated, but we won&#39;t see it without a
361     // membar here.
362     __ membar(Assembler::LoadStore| Assembler::LoadLoad);
363     read_barrier(masm, op1);
364     read_barrier(masm, op2);
365     __ cmp(op1, op2);
366     __ bind(done);
367   }
368 }
369 
370 void ShenandoahBarrierSetAssembler::tlab_allocate(MacroAssembler* masm, Register obj,
371                                                   Register var_size_in_bytes,
372                                                   int con_size_in_bytes,
373                                                   Register t1,
374                                                   Register t2,
375                                                   Label&amp; slow_case) {
376 
377   assert_different_registers(obj, t2);
378   assert_different_registers(obj, var_size_in_bytes);
379   Register end = t2;
380 
381   __ ldr(obj, Address(rthread, JavaThread::tlab_top_offset()));
382   if (var_size_in_bytes == noreg) {
383     __ lea(end, Address(obj, (int) (con_size_in_bytes + ShenandoahBrooksPointer::byte_size())));
384   } else {
385     __ add(var_size_in_bytes, var_size_in_bytes, ShenandoahBrooksPointer::byte_size());
386     __ lea(end, Address(obj, var_size_in_bytes));
387   }
388   __ ldr(rscratch1, Address(rthread, JavaThread::tlab_end_offset()));
389   __ cmp(end, rscratch1);
390   __ br(Assembler::HI, slow_case);
391 
392   // update the tlab top pointer
393   __ str(end, Address(rthread, JavaThread::tlab_top_offset()));
394 
395   __ add(obj, obj, ShenandoahBrooksPointer::byte_size());
396   __ str(obj, Address(obj, ShenandoahBrooksPointer::byte_offset()));
397 
398   // recover var_size_in_bytes if necessary
399   if (var_size_in_bytes == end) {
400     __ sub(var_size_in_bytes, var_size_in_bytes, obj);
401   }
402 }
403 
404 void ShenandoahBarrierSetAssembler::resolve(MacroAssembler* masm, DecoratorSet decorators, Register obj) {
405   bool oop_not_null = (decorators &amp; IS_NOT_NULL) != 0;
406   bool is_write = (decorators &amp; ACCESS_WRITE) != 0;
407   if (is_write) {
408     if (oop_not_null) {
409       write_barrier(masm, obj);
410     } else {
411       Label done;
412       __ cbz(obj, done);
413       write_barrier(masm, obj);
414       __ bind(done);
415     }
416   } else {
417     if (oop_not_null) {
418       read_barrier_not_null(masm, obj);
419     } else {
420       read_barrier(masm, obj);
421     }
422   }
423 }
424 
425 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm, Register addr, Register expected, Register new_val,
426                                                 bool acquire, bool release, bool weak, bool is_cae,
427                                                 Register result) {
428   Register tmp1 = rscratch1;
429   Register tmp2 = rscratch2;
430   bool is_narrow = UseCompressedOops;
431   Assembler::operand_size size = is_narrow ? Assembler::word : Assembler::xword;
432 
433   assert_different_registers(addr, expected, new_val, tmp1, tmp2);
434 
435   Label retry, done, fail;
436 
437   // CAS, using LL/SC pair.
438   __ bind(retry);
439   __ load_exclusive(tmp1, addr, size, acquire);
440   if (is_narrow) {
441     __ cmpw(tmp1, expected);
442   } else {
443     __ cmp(tmp1, expected);
444   }
445   __ br(Assembler::NE, fail);
446   __ store_exclusive(tmp2, new_val, addr, size, release);
447   if (weak) {
448     __ cmpw(tmp2, 0u); // If the store fails, return NE to our caller
449   } else {
450     __ cbnzw(tmp2, retry);
451   }
452   __ b(done);
453 
454  __  bind(fail);
455   // Check if rb(expected)==rb(tmp1)
456   // Shuffle registers so that we have memory value ready for next expected.
457   __ mov(tmp2, expected);
458   __ mov(expected, tmp1);
459   if (is_narrow) {
460     __ decode_heap_oop(tmp1, tmp1);
461     __ decode_heap_oop(tmp2, tmp2);
462   }
463   read_barrier_impl(masm, tmp1);
464   read_barrier_impl(masm, tmp2);
465   __ cmp(tmp1, tmp2);
466   // Retry with expected now being the value we just loaded from addr.
467   __ br(Assembler::EQ, retry);
468   if (is_cae &amp;&amp; is_narrow) {
469     // For cmp-and-exchange and narrow oops, we need to restore
470     // the compressed old-value. We moved it to &#39;expected&#39; a few lines up.
471     __ mov(tmp1, expected);
472   }
473   __ bind(done);
474 
475   if (is_cae) {
476     __ mov(result, tmp1);
477   } else {
478     __ cset(result, Assembler::EQ);
479   }
480 }
481 
482 #ifdef COMPILER1
483 
484 #undef __
485 #define __ ce-&gt;masm()-&gt;
486 
487 void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
488   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
489   // At this point we know that marking is in progress.
490   // If do_load() is true then we have to emit the
491   // load of the previous value; otherwise it has already
492   // been loaded into _pre_val.
493 
494   __ bind(*stub-&gt;entry());
495 
496   assert(stub-&gt;pre_val()-&gt;is_register(), &quot;Precondition.&quot;);
497 
498   Register pre_val_reg = stub-&gt;pre_val()-&gt;as_register();
499 
500   if (stub-&gt;do_load()) {
501     ce-&gt;mem2reg(stub-&gt;addr(), stub-&gt;pre_val(), T_OBJECT, stub-&gt;patch_code(), stub-&gt;info(), false /*wide*/, false /*unaligned*/);
502   }
503   __ cbz(pre_val_reg, *stub-&gt;continuation());
504   ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
505   __ far_call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
506   __ b(*stub-&gt;continuation());
507 }
508 
509 void ShenandoahBarrierSetAssembler::gen_write_barrier_stub(LIR_Assembler* ce, ShenandoahWriteBarrierStub* stub) {
510 
511   Register obj = stub-&gt;obj()-&gt;as_register();
512   Register res = stub-&gt;result()-&gt;as_register();
513 
514   Label done;
515 
516   __ bind(*stub-&gt;entry());
517 
518   if (res != obj) {
519     __ mov(res, obj);
520   }
521   // Check for null.
522   if (stub-&gt;needs_null_check()) {
523     __ cbz(res, done);
524   }
525 
526   write_barrier(ce-&gt;masm(), res);
527 
528   __ bind(done);
529   __ b(*stub-&gt;continuation());
530 }
531 
532 #undef __
533 
534 #define __ sasm-&gt;
535 
536 void ShenandoahBarrierSetAssembler::generate_c1_pre_barrier_runtime_stub(StubAssembler* sasm) {
537   __ prologue(&quot;shenandoah_pre_barrier&quot;, false);
538 
539   // arg0 : previous value of memory
540 
541   BarrierSet* bs = BarrierSet::barrier_set();
542 
543   const Register pre_val = r0;
544   const Register thread = rthread;
545   const Register tmp = rscratch1;
546 
547   Address queue_index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
548   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
549 
550   Label done;
551   Label runtime;
552 
553   // Is marking still active?
554   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
555   __ ldrb(tmp, gc_state);
556   __ mov(rscratch2, ShenandoahHeap::MARKING | ShenandoahHeap::TRAVERSAL);
557   __ tst(tmp, rscratch2);
558   __ br(Assembler::EQ, done);
559 
560   // Can we store original value in the thread&#39;s buffer?
561   __ ldr(tmp, queue_index);
562   __ cbz(tmp, runtime);
563 
564   __ sub(tmp, tmp, wordSize);
565   __ str(tmp, queue_index);
566   __ ldr(rscratch2, buffer);
567   __ add(tmp, tmp, rscratch2);
568   __ load_parameter(0, rscratch2);
569   __ str(rscratch2, Address(tmp, 0));
570   __ b(done);
571 
572   __ bind(runtime);
573   __ push_call_clobbered_registers();
574   __ load_parameter(0, pre_val);
575   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);
576   __ pop_call_clobbered_registers();
577   __ bind(done);
578 
579   __ epilogue();
580 }
581 
582 #undef __
583 
584 #endif // COMPILER1
585 
586 address ShenandoahBarrierSetAssembler::shenandoah_wb() {
587   assert(_shenandoah_wb != NULL, &quot;need write barrier stub&quot;);
588   return _shenandoah_wb;
589 }
590 
591 #define __ cgen-&gt;assembler()-&gt;
592 
593 // Shenandoah write barrier.
594 //
595 // Input:
596 //   r0: OOP to evacuate.  Not null.
597 //
598 // Output:
599 //   r0: Pointer to evacuated OOP.
600 //
601 // Trash rscratch1, rscratch2.  Preserve everything else.
602 address ShenandoahBarrierSetAssembler::generate_shenandoah_wb(StubCodeGenerator* cgen) {
603 
604   __ align(6);
605   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_wb&quot;);
606   address start = __ pc();
607 
608   Label work;
609   __ mov(rscratch2, ShenandoahHeap::in_cset_fast_test_addr());
610   __ lsr(rscratch1, r0, ShenandoahHeapRegion::region_size_bytes_shift_jint());
611   __ ldrb(rscratch2, Address(rscratch2, rscratch1));
612   __ tbnz(rscratch2, 0, work);
613   __ ret(lr);
614   __ bind(work);
615 
616   Register obj = r0;
617 
618   __ enter(); // required for proper stackwalking of RuntimeStub frame
619 
620   __ push_call_clobbered_registers();
621 
622   __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_JRT));
623   __ blrt(lr, 1, 0, MacroAssembler::ret_type_integral);
624   __ mov(rscratch1, obj);
625   __ pop_call_clobbered_registers();
626   __ mov(obj, rscratch1);
627 
628   __ leave(); // required for proper stackwalking of RuntimeStub frame
629   __ ret(lr);
630 
631   return start;
632 }
633 
634 #undef __
635 
636 void ShenandoahBarrierSetAssembler::barrier_stubs_init() {
637   if (ShenandoahWriteBarrier || ShenandoahStoreValEnqueueBarrier) {
638     int stub_code_size = 2048;
639     ResourceMark rm;
640     BufferBlob* bb = BufferBlob::create(&quot;shenandoah_barrier_stubs&quot;, stub_code_size);
641     CodeBuffer buf(bb);
642     StubCodeGenerator cgen(&amp;buf);
643     _shenandoah_wb = generate_shenandoah_wb(&amp;cgen);
644   }
645 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/gc/shenandoah/shenandoahBarrierSetAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../shared/modRefBarrierSetAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/gc/shenandoah/shenandoahBarrierSetAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;

 25 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<span class="line-modified"> 26 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;</span>

 27 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
 31 #include &quot;interpreter/interpreter.hpp&quot;
 32 #include &quot;interpreter/interp_masm.hpp&quot;
 33 #include &quot;runtime/sharedRuntime.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 #ifdef COMPILER1
 36 #include &quot;c1/c1_LIRAssembler.hpp&quot;
 37 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 38 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
 39 #endif
 40 
 41 #define __ masm-&gt;
 42 
<span class="line-modified"> 43 address ShenandoahBarrierSetAssembler::_shenandoah_wb = NULL;</span>
 44 
 45 void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,
<span class="line-modified"> 46                                                        Register addr, Register count, RegSet saved_regs) {</span>
 47   if (is_oop) {
 48     bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
<span class="line-modified"> 49     if (!dest_uninitialized &amp;&amp; !ShenandoahHeap::heap()-&gt;heuristics()-&gt;can_do_traversal_gc()) {</span>
<span class="line-modified"> 50       __ push(saved_regs, sp);</span>
<span class="line-modified"> 51       if (count == c_rarg0) {</span>
<span class="line-modified"> 52         if (addr == c_rarg1) {</span>
<span class="line-modified"> 53           // exactly backwards!!</span>
<span class="line-modified"> 54           __ mov(rscratch1, c_rarg0);</span>
<span class="line-modified"> 55           __ mov(c_rarg0, c_rarg1);</span>
<span class="line-modified"> 56           __ mov(c_rarg1, rscratch1);</span>
<span class="line-modified"> 57         } else {</span>
<span class="line-modified"> 58           __ mov(c_rarg1, count);</span>
<span class="line-modified"> 59           __ mov(c_rarg0, addr);</span>
<span class="line-modified"> 60         }</span>
 61       } else {
<span class="line-modified"> 62         __ mov(c_rarg0, addr);</span>
<span class="line-modified"> 63         __ mov(c_rarg1, count);</span>

 64       }


 65       if (UseCompressedOops) {
<span class="line-modified"> 66         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_narrow_oop_entry), 2);</span>




 67       } else {
<span class="line-modified"> 68         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry), 2);</span>




 69       }
 70       __ pop(saved_regs, sp);

 71     }
 72   }
 73 }
 74 
<span class="line-removed"> 75 void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,</span>
<span class="line-removed"> 76                                                        Register start, Register end, Register scratch, RegSet saved_regs) {</span>
<span class="line-removed"> 77   if (is_oop) {</span>
<span class="line-removed"> 78     __ push(saved_regs, sp);</span>
<span class="line-removed"> 79     // must compute element count unless barrier set interface is changed (other platforms supply count)</span>
<span class="line-removed"> 80     assert_different_registers(start, end, scratch);</span>
<span class="line-removed"> 81     __ lea(scratch, Address(end, BytesPerHeapOop));</span>
<span class="line-removed"> 82     __ sub(scratch, scratch, start);               // subtract start to get #bytes</span>
<span class="line-removed"> 83     __ lsr(scratch, scratch, LogBytesPerHeapOop);  // convert to element count</span>
<span class="line-removed"> 84     __ mov(c_rarg0, start);</span>
<span class="line-removed"> 85     __ mov(c_rarg1, scratch);</span>
<span class="line-removed"> 86     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_post_entry), 2);</span>
<span class="line-removed"> 87     __ pop(saved_regs, sp);</span>
<span class="line-removed"> 88   }</span>
<span class="line-removed"> 89 }</span>
<span class="line-removed"> 90 </span>
 91 void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
 92                                                                  Register obj,
 93                                                                  Register pre_val,
 94                                                                  Register thread,
 95                                                                  Register tmp,
 96                                                                  bool tosca_live,
 97                                                                  bool expand_call) {
 98   if (ShenandoahSATBBarrier) {
 99     satb_write_barrier_pre(masm, obj, pre_val, thread, tmp, tosca_live, expand_call);
100   }
101 }
102 
103 void ShenandoahBarrierSetAssembler::satb_write_barrier_pre(MacroAssembler* masm,
104                                                            Register obj,
105                                                            Register pre_val,
106                                                            Register thread,
107                                                            Register tmp,
108                                                            bool tosca_live,
109                                                            bool expand_call) {
110   // If expand_call is true then we expand the call_VM_leaf macro
</pre>
<hr />
<pre>
172   // If we care generating the pre-barrier without a frame (e.g. in the
173   // intrinsified Reference.get() routine) then ebp might be pointing to
174   // the caller frame and so this check will most likely fail at runtime.
175   //
176   // Expanding the call directly bypasses the generation of the check.
177   // So when we do not have have a full interpreter frame on the stack
178   // expand_call should be passed true.
179 
180   if (expand_call) {
181     assert(pre_val != c_rarg1, &quot;smashed arg&quot;);
182     __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);
183   } else {
184     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);
185   }
186 
187   __ pop(saved, sp);
188 
189   __ bind(done);
190 }
191 
<span class="line-modified">192 void ShenandoahBarrierSetAssembler::read_barrier(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">193   if (ShenandoahReadBarrier) {</span>
<span class="line-removed">194     read_barrier_impl(masm, dst);</span>
<span class="line-removed">195   }</span>
<span class="line-removed">196 }</span>
<span class="line-removed">197 </span>
<span class="line-removed">198 void ShenandoahBarrierSetAssembler::read_barrier_impl(MacroAssembler* masm, Register dst) {</span>
<span class="line-removed">199   assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier || ShenandoahCASBarrier), &quot;should be enabled&quot;);</span>
200   Label is_null;
201   __ cbz(dst, is_null);
<span class="line-modified">202   read_barrier_not_null_impl(masm, dst);</span>
203   __ bind(is_null);
204 }
205 
<span class="line-modified">206 void ShenandoahBarrierSetAssembler::read_barrier_not_null(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">207   if (ShenandoahReadBarrier) {</span>
<span class="line-modified">208     read_barrier_not_null_impl(masm, dst);</span>


















209   }
<span class="line-removed">210 }</span>
211 

212 
<span class="line-modified">213 void ShenandoahBarrierSetAssembler::read_barrier_not_null_impl(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">214   assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier || ShenandoahCASBarrier), &quot;should be enabled&quot;);</span>
<span class="line-modified">215   __ ldr(dst, Address(dst, ShenandoahBrooksPointer::byte_offset()));</span>
<span class="line-modified">216 }</span>




217 
<span class="line-modified">218 void ShenandoahBarrierSetAssembler::write_barrier(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">219   if (ShenandoahWriteBarrier) {</span>
<span class="line-removed">220     write_barrier_impl(masm, dst);</span>
221   }
222 }
223 
<span class="line-modified">224 void ShenandoahBarrierSetAssembler::write_barrier_impl(MacroAssembler* masm, Register dst) {</span>
<span class="line-modified">225   assert(UseShenandoahGC &amp;&amp; (ShenandoahWriteBarrier || ShenandoahStoreValEnqueueBarrier), &quot;Should be enabled&quot;);</span>
<span class="line-removed">226   assert(dst != rscratch1, &quot;need rscratch1&quot;);</span>
227   assert(dst != rscratch2, &quot;need rscratch2&quot;);

228 
229   Label done;
<span class="line-modified">230 </span>
231   Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
<span class="line-modified">232   __ ldrb(rscratch1, gc_state);</span>
233 
234   // Check for heap stability
<span class="line-modified">235   __ mov(rscratch2, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);</span>
<span class="line-removed">236   __ tst(rscratch1, rscratch2);</span>
<span class="line-removed">237   __ br(Assembler::EQ, done);</span>
238 
<span class="line-modified">239   // Heap is unstable, need to perform the read-barrier even if WB is inactive</span>
<span class="line-modified">240   __ ldr(dst, Address(dst, ShenandoahBrooksPointer::byte_offset()));</span>




241 
<span class="line-modified">242   // Check for evacuation-in-progress and jump to WB slow-path if needed</span>
<span class="line-modified">243   __ mov(rscratch2, ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);</span>
<span class="line-modified">244   __ tst(rscratch1, rscratch2);</span>
<span class="line-modified">245   __ br(Assembler::EQ, done);</span>

246 
<span class="line-modified">247   RegSet to_save = RegSet::of(r0);</span>
<span class="line-removed">248   if (dst != r0) {</span>
<span class="line-removed">249     __ push(to_save, sp);</span>
<span class="line-removed">250     __ mov(r0, dst);</span>
<span class="line-removed">251   }</span>
252 
<span class="line-modified">253   __ far_call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_wb())));</span>

254 
<span class="line-modified">255   if (dst != r0) {</span>
<span class="line-modified">256     __ mov(dst, r0);</span>
<span class="line-modified">257     __ pop(to_save, sp);</span>




258   }
259 



























260   __ bind(done);



261 }
262 
263 void ShenandoahBarrierSetAssembler::storeval_barrier(MacroAssembler* masm, Register dst, Register tmp) {
264   if (ShenandoahStoreValEnqueueBarrier) {
<span class="line-removed">265     Label is_null;</span>
<span class="line-removed">266     __ cbz(dst, is_null);</span>
<span class="line-removed">267     write_barrier_impl(masm, dst);</span>
<span class="line-removed">268     __ bind(is_null);</span>
269     // Save possibly live regs.
270     RegSet live_regs = RegSet::range(r0, r4) - dst;
271     __ push(live_regs, sp);
272     __ strd(v0, __ pre(sp, 2 * -wordSize));
273 
274     satb_write_barrier_pre(masm, noreg, dst, rthread, tmp, true, false);
275 
276     // Restore possibly live regs.
277     __ ldrd(v0, __ post(sp, 2 * wordSize));
278     __ pop(live_regs, sp);
279   }
<span class="line-modified">280   if (ShenandoahStoreValReadBarrier) {</span>
<span class="line-modified">281     read_barrier_impl(masm, dst);</span>






282   }
283 }
284 















285 void ShenandoahBarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
286                                             Register dst, Address src, Register tmp1, Register tmp_thread) {
<span class="line-modified">287   bool on_oop = type == T_OBJECT || type == T_ARRAY;</span>
<span class="line-modified">288   bool in_heap = (decorators &amp; IN_HEAP) != 0;</span>
<span class="line-modified">289   bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;</span>
<span class="line-modified">290   bool on_phantom = (decorators &amp; ON_PHANTOM_OOP_REF) != 0;</span>
<span class="line-modified">291   bool on_reference = on_weak || on_phantom;</span>
<span class="line-modified">292 </span>
<span class="line-modified">293   if (in_heap) {</span>
<span class="line-modified">294     read_barrier_not_null(masm, src.base());</span>






















295   }
296 
<span class="line-modified">297   BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-modified">298   if (ShenandoahKeepAliveBarrier &amp;&amp; on_oop &amp;&amp; on_reference) {</span>
299     __ enter();
300     satb_write_barrier_pre(masm /* masm */,
301                            noreg /* obj */,
302                            dst /* pre_val */,
303                            rthread /* thread */,
304                            tmp1 /* tmp */,
305                            true /* tosca_live */,
306                            true /* expand_call */);
307     __ leave();
308   }
309 }
310 
311 void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
312                                              Address dst, Register val, Register tmp1, Register tmp2) {
<span class="line-modified">313   bool on_oop = type == T_OBJECT || type == T_ARRAY;</span>
<span class="line-removed">314   bool in_heap = (decorators &amp; IN_HEAP) != 0;</span>
<span class="line-removed">315   if (in_heap) {</span>
<span class="line-removed">316     write_barrier(masm, dst.base());</span>
<span class="line-removed">317   }</span>
318   if (!on_oop) {
319     BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);
320     return;
321   }
322 
323   // flatten object address if needed
324   if (dst.index() == noreg &amp;&amp; dst.offset() == 0) {
325     if (dst.base() != r3) {
326       __ mov(r3, dst.base());
327     }
328   } else {
329     __ lea(r3, dst);
330   }
331 
332   shenandoah_write_barrier_pre(masm,
333                                r3 /* obj */,
334                                tmp2 /* pre_val */,
335                                rthread /* thread */,
336                                tmp1  /* tmp */,
337                                val != noreg /* tosca_live */,
338                                false /* expand_call */);
339 
340   if (val == noreg) {
341     BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), noreg, noreg, noreg);
342   } else {
343     storeval_barrier(masm, val, tmp1);
344     // G1 barrier needs uncompressed oop for region cross check.
345     Register new_val = val;
346     if (UseCompressedOops) {
347       new_val = rscratch2;
348       __ mov(new_val, val);
349     }
350     BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), val, noreg, noreg);
351   }
352 
353 }
354 
<span class="line-modified">355 void ShenandoahBarrierSetAssembler::obj_equals(MacroAssembler* masm, Register op1, Register op2) {</span>
<span class="line-modified">356   __ cmp(op1, op2);</span>
<span class="line-modified">357   if (ShenandoahAcmpBarrier) {</span>
<span class="line-modified">358     Label done;</span>
<span class="line-modified">359     __ br(Assembler::EQ, done);</span>
<span class="line-removed">360     // The object may have been evacuated, but we won&#39;t see it without a</span>
<span class="line-removed">361     // membar here.</span>
<span class="line-removed">362     __ membar(Assembler::LoadStore| Assembler::LoadLoad);</span>
<span class="line-removed">363     read_barrier(masm, op1);</span>
<span class="line-removed">364     read_barrier(masm, op2);</span>
<span class="line-removed">365     __ cmp(op1, op2);</span>
<span class="line-removed">366     __ bind(done);</span>
<span class="line-removed">367   }</span>
<span class="line-removed">368 }</span>
<span class="line-removed">369 </span>
<span class="line-removed">370 void ShenandoahBarrierSetAssembler::tlab_allocate(MacroAssembler* masm, Register obj,</span>
<span class="line-removed">371                                                   Register var_size_in_bytes,</span>
<span class="line-removed">372                                                   int con_size_in_bytes,</span>
<span class="line-removed">373                                                   Register t1,</span>
<span class="line-removed">374                                                   Register t2,</span>
<span class="line-removed">375                                                   Label&amp; slow_case) {</span>
<span class="line-removed">376 </span>
<span class="line-removed">377   assert_different_registers(obj, t2);</span>
<span class="line-removed">378   assert_different_registers(obj, var_size_in_bytes);</span>
<span class="line-removed">379   Register end = t2;</span>
380 
<span class="line-modified">381   __ ldr(obj, Address(rthread, JavaThread::tlab_top_offset()));</span>
<span class="line-modified">382   if (var_size_in_bytes == noreg) {</span>
<span class="line-removed">383     __ lea(end, Address(obj, (int) (con_size_in_bytes + ShenandoahBrooksPointer::byte_size())));</span>
<span class="line-removed">384   } else {</span>
<span class="line-removed">385     __ add(var_size_in_bytes, var_size_in_bytes, ShenandoahBrooksPointer::byte_size());</span>
<span class="line-removed">386     __ lea(end, Address(obj, var_size_in_bytes));</span>
<span class="line-removed">387   }</span>
<span class="line-removed">388   __ ldr(rscratch1, Address(rthread, JavaThread::tlab_end_offset()));</span>
<span class="line-removed">389   __ cmp(end, rscratch1);</span>
<span class="line-removed">390   __ br(Assembler::HI, slow_case);</span>
391 
<span class="line-modified">392   // update the tlab top pointer</span>
<span class="line-modified">393   __ str(end, Address(rthread, JavaThread::tlab_top_offset()));</span>


394 
<span class="line-modified">395   __ add(obj, obj, ShenandoahBrooksPointer::byte_size());</span>
<span class="line-modified">396   __ str(obj, Address(obj, ShenandoahBrooksPointer::byte_offset()));</span>
397 
<span class="line-modified">398   // recover var_size_in_bytes if necessary</span>
<span class="line-removed">399   if (var_size_in_bytes == end) {</span>
<span class="line-removed">400     __ sub(var_size_in_bytes, var_size_in_bytes, obj);</span>
<span class="line-removed">401   }</span>
402 }
403 
<span class="line-removed">404 void ShenandoahBarrierSetAssembler::resolve(MacroAssembler* masm, DecoratorSet decorators, Register obj) {</span>
<span class="line-removed">405   bool oop_not_null = (decorators &amp; IS_NOT_NULL) != 0;</span>
<span class="line-removed">406   bool is_write = (decorators &amp; ACCESS_WRITE) != 0;</span>
<span class="line-removed">407   if (is_write) {</span>
<span class="line-removed">408     if (oop_not_null) {</span>
<span class="line-removed">409       write_barrier(masm, obj);</span>
<span class="line-removed">410     } else {</span>
<span class="line-removed">411       Label done;</span>
<span class="line-removed">412       __ cbz(obj, done);</span>
<span class="line-removed">413       write_barrier(masm, obj);</span>
<span class="line-removed">414       __ bind(done);</span>
<span class="line-removed">415     }</span>
<span class="line-removed">416   } else {</span>
<span class="line-removed">417     if (oop_not_null) {</span>
<span class="line-removed">418       read_barrier_not_null(masm, obj);</span>
<span class="line-removed">419     } else {</span>
<span class="line-removed">420       read_barrier(masm, obj);</span>
<span class="line-removed">421     }</span>
<span class="line-removed">422   }</span>
<span class="line-removed">423 }</span>
424 
425 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm, Register addr, Register expected, Register new_val,
426                                                 bool acquire, bool release, bool weak, bool is_cae,
427                                                 Register result) {
428   Register tmp1 = rscratch1;
429   Register tmp2 = rscratch2;
430   bool is_narrow = UseCompressedOops;
431   Assembler::operand_size size = is_narrow ? Assembler::word : Assembler::xword;
432 
433   assert_different_registers(addr, expected, new_val, tmp1, tmp2);
434 
435   Label retry, done, fail;
436 
437   // CAS, using LL/SC pair.
438   __ bind(retry);
439   __ load_exclusive(tmp1, addr, size, acquire);
440   if (is_narrow) {
441     __ cmpw(tmp1, expected);
442   } else {
443     __ cmp(tmp1, expected);
444   }
445   __ br(Assembler::NE, fail);
446   __ store_exclusive(tmp2, new_val, addr, size, release);
447   if (weak) {
448     __ cmpw(tmp2, 0u); // If the store fails, return NE to our caller
449   } else {
450     __ cbnzw(tmp2, retry);
451   }
452   __ b(done);
453 
454  __  bind(fail);
455   // Check if rb(expected)==rb(tmp1)
456   // Shuffle registers so that we have memory value ready for next expected.
457   __ mov(tmp2, expected);
458   __ mov(expected, tmp1);
459   if (is_narrow) {
460     __ decode_heap_oop(tmp1, tmp1);
461     __ decode_heap_oop(tmp2, tmp2);
462   }
<span class="line-modified">463   read_barrier_impl(masm, tmp1);</span>
<span class="line-modified">464   read_barrier_impl(masm, tmp2);</span>
465   __ cmp(tmp1, tmp2);
466   // Retry with expected now being the value we just loaded from addr.
467   __ br(Assembler::EQ, retry);
468   if (is_cae &amp;&amp; is_narrow) {
469     // For cmp-and-exchange and narrow oops, we need to restore
470     // the compressed old-value. We moved it to &#39;expected&#39; a few lines up.
471     __ mov(tmp1, expected);
472   }
473   __ bind(done);
474 
475   if (is_cae) {
476     __ mov(result, tmp1);
477   } else {
478     __ cset(result, Assembler::EQ);
479   }
480 }
481 


482 #ifdef COMPILER1
483 
<span class="line-removed">484 #undef __</span>
485 #define __ ce-&gt;masm()-&gt;
486 
487 void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
488   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
489   // At this point we know that marking is in progress.
490   // If do_load() is true then we have to emit the
491   // load of the previous value; otherwise it has already
492   // been loaded into _pre_val.
493 
494   __ bind(*stub-&gt;entry());
495 
496   assert(stub-&gt;pre_val()-&gt;is_register(), &quot;Precondition.&quot;);
497 
498   Register pre_val_reg = stub-&gt;pre_val()-&gt;as_register();
499 
500   if (stub-&gt;do_load()) {
501     ce-&gt;mem2reg(stub-&gt;addr(), stub-&gt;pre_val(), T_OBJECT, stub-&gt;patch_code(), stub-&gt;info(), false /*wide*/, false /*unaligned*/);
502   }
503   __ cbz(pre_val_reg, *stub-&gt;continuation());
504   ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
505   __ far_call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
506   __ b(*stub-&gt;continuation());
507 }
508 
<span class="line-modified">509 void ShenandoahBarrierSetAssembler::gen_write_barrier_stub(LIR_Assembler* ce, ShenandoahWriteBarrierStub* stub) {</span>


510 
511   Register obj = stub-&gt;obj()-&gt;as_register();
512   Register res = stub-&gt;result()-&gt;as_register();



513 
<span class="line-modified">514   Label done;</span>
<span class="line-removed">515 </span>
<span class="line-removed">516   __ bind(*stub-&gt;entry());</span>
517 
518   if (res != obj) {
519     __ mov(res, obj);
520   }

521   // Check for null.
<span class="line-modified">522   if (stub-&gt;needs_null_check()) {</span>
<span class="line-modified">523     __ cbz(res, done);</span>
<span class="line-modified">524   }</span>
















525 
<span class="line-modified">526   write_barrier(ce-&gt;masm(), res);</span>







527 
<span class="line-removed">528   __ bind(done);</span>
529   __ b(*stub-&gt;continuation());
530 }
531 
532 #undef __
533 
534 #define __ sasm-&gt;
535 
536 void ShenandoahBarrierSetAssembler::generate_c1_pre_barrier_runtime_stub(StubAssembler* sasm) {
537   __ prologue(&quot;shenandoah_pre_barrier&quot;, false);
538 
539   // arg0 : previous value of memory
540 
541   BarrierSet* bs = BarrierSet::barrier_set();
542 
543   const Register pre_val = r0;
544   const Register thread = rthread;
545   const Register tmp = rscratch1;
546 
547   Address queue_index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
548   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
</pre>
<hr />
<pre>
562   __ cbz(tmp, runtime);
563 
564   __ sub(tmp, tmp, wordSize);
565   __ str(tmp, queue_index);
566   __ ldr(rscratch2, buffer);
567   __ add(tmp, tmp, rscratch2);
568   __ load_parameter(0, rscratch2);
569   __ str(rscratch2, Address(tmp, 0));
570   __ b(done);
571 
572   __ bind(runtime);
573   __ push_call_clobbered_registers();
574   __ load_parameter(0, pre_val);
575   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);
576   __ pop_call_clobbered_registers();
577   __ bind(done);
578 
579   __ epilogue();
580 }
581 






















582 #undef __
583 
584 #endif // COMPILER1
585 
<span class="line-modified">586 address ShenandoahBarrierSetAssembler::shenandoah_wb() {</span>
<span class="line-modified">587   assert(_shenandoah_wb != NULL, &quot;need write barrier stub&quot;);</span>
<span class="line-modified">588   return _shenandoah_wb;</span>
589 }
590 
591 #define __ cgen-&gt;assembler()-&gt;
592 
<span class="line-modified">593 // Shenandoah write barrier.</span>
594 //
595 // Input:
596 //   r0: OOP to evacuate.  Not null.

597 //
598 // Output:
599 //   r0: Pointer to evacuated OOP.
600 //
601 // Trash rscratch1, rscratch2.  Preserve everything else.
<span class="line-modified">602 address ShenandoahBarrierSetAssembler::generate_shenandoah_wb(StubCodeGenerator* cgen) {</span>
603 
604   __ align(6);
<span class="line-modified">605   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_wb&quot;);</span>
606   address start = __ pc();
607 
<span class="line-modified">608   Label work;</span>
609   __ mov(rscratch2, ShenandoahHeap::in_cset_fast_test_addr());
610   __ lsr(rscratch1, r0, ShenandoahHeapRegion::region_size_bytes_shift_jint());
611   __ ldrb(rscratch2, Address(rscratch2, rscratch1));
612   __ tbnz(rscratch2, 0, work);
613   __ ret(lr);
614   __ bind(work);
615 
<span class="line-modified">616   Register obj = r0;</span>









617 

618   __ enter(); // required for proper stackwalking of RuntimeStub frame
619 
620   __ push_call_clobbered_registers();
621 
<span class="line-modified">622   __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_JRT));</span>
<span class="line-modified">623   __ blrt(lr, 1, 0, MacroAssembler::ret_type_integral);</span>
<span class="line-modified">624   __ mov(rscratch1, obj);</span>




625   __ pop_call_clobbered_registers();
<span class="line-modified">626   __ mov(obj, rscratch1);</span>
627 
628   __ leave(); // required for proper stackwalking of RuntimeStub frame

629   __ ret(lr);
630 
631   return start;
632 }
633 
634 #undef __
635 
636 void ShenandoahBarrierSetAssembler::barrier_stubs_init() {
<span class="line-modified">637   if (ShenandoahWriteBarrier || ShenandoahStoreValEnqueueBarrier) {</span>
638     int stub_code_size = 2048;
639     ResourceMark rm;
640     BufferBlob* bb = BufferBlob::create(&quot;shenandoah_barrier_stubs&quot;, stub_code_size);
641     CodeBuffer buf(bb);
642     StubCodeGenerator cgen(&amp;buf);
<span class="line-modified">643     _shenandoah_wb = generate_shenandoah_wb(&amp;cgen);</span>
644   }
645 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
<span class="line-added"> 26 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;</span>
 27 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<span class="line-modified"> 28 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;</span>
<span class="line-added"> 29 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;</span>
 30 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;interpreter/interp_masm.hpp&quot;
 36 #include &quot;runtime/sharedRuntime.hpp&quot;
 37 #include &quot;runtime/thread.hpp&quot;
 38 #ifdef COMPILER1
 39 #include &quot;c1/c1_LIRAssembler.hpp&quot;
 40 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 41 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
 42 #endif
 43 
 44 #define __ masm-&gt;
 45 
<span class="line-modified"> 46 address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;</span>
 47 
 48 void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,
<span class="line-modified"> 49                                                        Register src, Register dst, Register count, RegSet saved_regs) {</span>
 50   if (is_oop) {
 51     bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
<span class="line-modified"> 52     if ((ShenandoahSATBBarrier &amp;&amp; !dest_uninitialized) || ShenandoahLoadRefBarrier) {</span>
<span class="line-modified"> 53 </span>
<span class="line-modified"> 54       Label done;</span>
<span class="line-modified"> 55 </span>
<span class="line-modified"> 56       // Avoid calling runtime if count == 0</span>
<span class="line-modified"> 57       __ cbz(count, done);</span>
<span class="line-modified"> 58 </span>
<span class="line-modified"> 59       // Is marking active?</span>
<span class="line-modified"> 60       Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-modified"> 61       __ ldrb(rscratch1, gc_state);</span>
<span class="line-modified"> 62       if (dest_uninitialized) {</span>
<span class="line-modified"> 63         __ tbz(rscratch1, ShenandoahHeap::HAS_FORWARDED_BITPOS, done);</span>
 64       } else {
<span class="line-modified"> 65         __ mov(rscratch2, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::MARKING);</span>
<span class="line-modified"> 66         __ tst(rscratch1, rscratch2);</span>
<span class="line-added"> 67         __ br(Assembler::EQ, done);</span>
 68       }
<span class="line-added"> 69 </span>
<span class="line-added"> 70       __ push(saved_regs, sp);</span>
 71       if (UseCompressedOops) {
<span class="line-modified"> 72         if (dest_uninitialized) {</span>
<span class="line-added"> 73           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_duinit_narrow_oop_entry), src, dst, count);</span>
<span class="line-added"> 74         } else {</span>
<span class="line-added"> 75           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_narrow_oop_entry), src, dst, count);</span>
<span class="line-added"> 76         }</span>
 77       } else {
<span class="line-modified"> 78         if (dest_uninitialized) {</span>
<span class="line-added"> 79           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_duinit_oop_entry), src, dst, count);</span>
<span class="line-added"> 80         } else {</span>
<span class="line-added"> 81           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry), src, dst, count);</span>
<span class="line-added"> 82         }</span>
 83       }
 84       __ pop(saved_regs, sp);
<span class="line-added"> 85       __ bind(done);</span>
 86     }
 87   }
 88 }
 89 
















 90 void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
 91                                                                  Register obj,
 92                                                                  Register pre_val,
 93                                                                  Register thread,
 94                                                                  Register tmp,
 95                                                                  bool tosca_live,
 96                                                                  bool expand_call) {
 97   if (ShenandoahSATBBarrier) {
 98     satb_write_barrier_pre(masm, obj, pre_val, thread, tmp, tosca_live, expand_call);
 99   }
100 }
101 
102 void ShenandoahBarrierSetAssembler::satb_write_barrier_pre(MacroAssembler* masm,
103                                                            Register obj,
104                                                            Register pre_val,
105                                                            Register thread,
106                                                            Register tmp,
107                                                            bool tosca_live,
108                                                            bool expand_call) {
109   // If expand_call is true then we expand the call_VM_leaf macro
</pre>
<hr />
<pre>
171   // If we care generating the pre-barrier without a frame (e.g. in the
172   // intrinsified Reference.get() routine) then ebp might be pointing to
173   // the caller frame and so this check will most likely fail at runtime.
174   //
175   // Expanding the call directly bypasses the generation of the check.
176   // So when we do not have have a full interpreter frame on the stack
177   // expand_call should be passed true.
178 
179   if (expand_call) {
180     assert(pre_val != c_rarg1, &quot;smashed arg&quot;);
181     __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);
182   } else {
183     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);
184   }
185 
186   __ pop(saved, sp);
187 
188   __ bind(done);
189 }
190 
<span class="line-modified">191 void ShenandoahBarrierSetAssembler::resolve_forward_pointer(MacroAssembler* masm, Register dst, Register tmp) {</span>
<span class="line-modified">192   assert(ShenandoahLoadRefBarrier || ShenandoahCASBarrier, &quot;Should be enabled&quot;);</span>






193   Label is_null;
194   __ cbz(dst, is_null);
<span class="line-modified">195   resolve_forward_pointer_not_null(masm, dst, tmp);</span>
196   __ bind(is_null);
197 }
198 
<span class="line-modified">199 // IMPORTANT: This must preserve all registers, even rscratch1 and rscratch2, except those explicitely</span>
<span class="line-modified">200 // passed in.</span>
<span class="line-modified">201 void ShenandoahBarrierSetAssembler::resolve_forward_pointer_not_null(MacroAssembler* masm, Register dst, Register tmp) {</span>
<span class="line-added">202   assert(ShenandoahLoadRefBarrier || ShenandoahCASBarrier, &quot;Should be enabled&quot;);</span>
<span class="line-added">203   // The below loads the mark word, checks if the lowest two bits are</span>
<span class="line-added">204   // set, and if so, clear the lowest two bits and copy the result</span>
<span class="line-added">205   // to dst. Otherwise it leaves dst alone.</span>
<span class="line-added">206   // Implementing this is surprisingly awkward. I do it here by:</span>
<span class="line-added">207   // - Inverting the mark word</span>
<span class="line-added">208   // - Test lowest two bits == 0</span>
<span class="line-added">209   // - If so, set the lowest two bits</span>
<span class="line-added">210   // - Invert the result back, and copy to dst</span>
<span class="line-added">211 </span>
<span class="line-added">212   bool borrow_reg = (tmp == noreg);</span>
<span class="line-added">213   if (borrow_reg) {</span>
<span class="line-added">214     // No free registers available. Make one useful.</span>
<span class="line-added">215     tmp = rscratch1;</span>
<span class="line-added">216     if (tmp == dst) {</span>
<span class="line-added">217       tmp = rscratch2;</span>
<span class="line-added">218     }</span>
<span class="line-added">219     __ push(RegSet::of(tmp), sp);</span>
220   }

221 
<span class="line-added">222   assert_different_registers(tmp, dst);</span>
223 
<span class="line-modified">224   Label done;</span>
<span class="line-modified">225   __ ldr(tmp, Address(dst, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-modified">226   __ eon(tmp, tmp, zr);</span>
<span class="line-modified">227   __ ands(zr, tmp, markWord::lock_mask_in_place);</span>
<span class="line-added">228   __ br(Assembler::NE, done);</span>
<span class="line-added">229   __ orr(tmp, tmp, markWord::marked_value);</span>
<span class="line-added">230   __ eon(dst, tmp, zr);</span>
<span class="line-added">231   __ bind(done);</span>
232 
<span class="line-modified">233   if (borrow_reg) {</span>
<span class="line-modified">234     __ pop(RegSet::of(tmp), sp);</span>

235   }
236 }
237 
<span class="line-modified">238 void ShenandoahBarrierSetAssembler::load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address load_addr) {</span>
<span class="line-modified">239   assert(ShenandoahLoadRefBarrier, &quot;Should be enabled&quot;);</span>

240   assert(dst != rscratch2, &quot;need rscratch2&quot;);
<span class="line-added">241   assert_different_registers(load_addr.base(), load_addr.index(), rscratch1, rscratch2);</span>
242 
243   Label done;
<span class="line-modified">244   __ enter();</span>
245   Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
<span class="line-modified">246   __ ldrb(rscratch2, gc_state);</span>
247 
248   // Check for heap stability
<span class="line-modified">249   __ tbz(rscratch2, ShenandoahHeap::HAS_FORWARDED_BITPOS, done);</span>


250 
<span class="line-modified">251   // use r1 for load address</span>
<span class="line-modified">252   Register result_dst = dst;</span>
<span class="line-added">253   if (dst == r1) {</span>
<span class="line-added">254     __ mov(rscratch1, dst);</span>
<span class="line-added">255     dst = rscratch1;</span>
<span class="line-added">256   }</span>
257 
<span class="line-modified">258   // Save r0 and r1, unless it is an output register</span>
<span class="line-modified">259   RegSet to_save = RegSet::of(r0, r1) - result_dst;</span>
<span class="line-modified">260   __ push(to_save, sp);</span>
<span class="line-modified">261   __ lea(r1, load_addr);</span>
<span class="line-added">262   __ mov(r0, dst);</span>
263 
<span class="line-modified">264   __ far_call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_lrb())));</span>




265 
<span class="line-modified">266   __ mov(result_dst, r0);</span>
<span class="line-added">267   __ pop(to_save, sp);</span>
268 
<span class="line-modified">269   __ bind(done);</span>
<span class="line-modified">270   __ leave();</span>
<span class="line-modified">271 }</span>
<span class="line-added">272 </span>
<span class="line-added">273 void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address load_addr) {</span>
<span class="line-added">274   if (!ShenandoahLoadRefBarrier) {</span>
<span class="line-added">275     return;</span>
276   }
277 
<span class="line-added">278   assert(dst != rscratch2, &quot;need rscratch2&quot;);</span>
<span class="line-added">279 </span>
<span class="line-added">280   Label is_null;</span>
<span class="line-added">281   Label done;</span>
<span class="line-added">282 </span>
<span class="line-added">283   __ block_comment(&quot;load_reference_barrier_native { &quot;);</span>
<span class="line-added">284 </span>
<span class="line-added">285   __ cbz(dst, is_null);</span>
<span class="line-added">286 </span>
<span class="line-added">287   __ enter();</span>
<span class="line-added">288 </span>
<span class="line-added">289   Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-added">290   __ ldrb(rscratch2, gc_state);</span>
<span class="line-added">291 </span>
<span class="line-added">292   // Check for heap in evacuation phase</span>
<span class="line-added">293   __ tbz(rscratch2, ShenandoahHeap::EVACUATION_BITPOS, done);</span>
<span class="line-added">294 </span>
<span class="line-added">295   __ mov(rscratch2, dst);</span>
<span class="line-added">296   __ push_call_clobbered_registers();</span>
<span class="line-added">297   __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));</span>
<span class="line-added">298   __ lea(r1, load_addr);</span>
<span class="line-added">299   __ mov(r0, rscratch2);</span>
<span class="line-added">300   __ blr(lr);</span>
<span class="line-added">301   __ mov(rscratch2, r0);</span>
<span class="line-added">302   __ pop_call_clobbered_registers();</span>
<span class="line-added">303   __ mov(dst, rscratch2);</span>
<span class="line-added">304 </span>
305   __ bind(done);
<span class="line-added">306   __ leave();</span>
<span class="line-added">307   __ bind(is_null);</span>
<span class="line-added">308   __ block_comment(&quot;} load_reference_barrier_native&quot;);</span>
309 }
310 
311 void ShenandoahBarrierSetAssembler::storeval_barrier(MacroAssembler* masm, Register dst, Register tmp) {
312   if (ShenandoahStoreValEnqueueBarrier) {




313     // Save possibly live regs.
314     RegSet live_regs = RegSet::range(r0, r4) - dst;
315     __ push(live_regs, sp);
316     __ strd(v0, __ pre(sp, 2 * -wordSize));
317 
318     satb_write_barrier_pre(masm, noreg, dst, rthread, tmp, true, false);
319 
320     // Restore possibly live regs.
321     __ ldrd(v0, __ post(sp, 2 * wordSize));
322     __ pop(live_regs, sp);
323   }
<span class="line-modified">324 }</span>
<span class="line-modified">325 </span>
<span class="line-added">326 void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address load_addr) {</span>
<span class="line-added">327   if (ShenandoahLoadRefBarrier) {</span>
<span class="line-added">328     Label is_null;</span>
<span class="line-added">329     __ cbz(dst, is_null);</span>
<span class="line-added">330     load_reference_barrier_not_null(masm, dst, load_addr);</span>
<span class="line-added">331     __ bind(is_null);</span>
332   }
333 }
334 
<span class="line-added">335 //</span>
<span class="line-added">336 // Arguments:</span>
<span class="line-added">337 //</span>
<span class="line-added">338 // Inputs:</span>
<span class="line-added">339 //   src:        oop location to load from, might be clobbered</span>
<span class="line-added">340 //</span>
<span class="line-added">341 // Output:</span>
<span class="line-added">342 //   dst:        oop loaded from src location</span>
<span class="line-added">343 //</span>
<span class="line-added">344 // Kill:</span>
<span class="line-added">345 //   rscratch1 (scratch reg)</span>
<span class="line-added">346 //</span>
<span class="line-added">347 // Alias:</span>
<span class="line-added">348 //   dst: rscratch1 (might use rscratch1 as temporary output register to avoid clobbering src)</span>
<span class="line-added">349 //</span>
350 void ShenandoahBarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
351                                             Register dst, Address src, Register tmp1, Register tmp_thread) {
<span class="line-modified">352   // 1: non-reference load, no additional barrier is needed</span>
<span class="line-modified">353   if (!is_reference_type(type)) {</span>
<span class="line-modified">354     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-modified">355     return;</span>
<span class="line-modified">356   }</span>
<span class="line-modified">357 </span>
<span class="line-modified">358   // 2: load a reference from src location and apply LRB if needed</span>
<span class="line-modified">359   if (ShenandoahBarrierSet::need_load_reference_barrier(decorators, type)) {</span>
<span class="line-added">360     Register result_dst = dst;</span>
<span class="line-added">361 </span>
<span class="line-added">362     // Preserve src location for LRB</span>
<span class="line-added">363     if (dst == src.base() || dst == src.index()) {</span>
<span class="line-added">364       dst = rscratch1;</span>
<span class="line-added">365     }</span>
<span class="line-added">366     assert_different_registers(dst, src.base(), src.index());</span>
<span class="line-added">367 </span>
<span class="line-added">368     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
<span class="line-added">369 </span>
<span class="line-added">370     if (ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type)) {</span>
<span class="line-added">371       load_reference_barrier_native(masm, dst, src);</span>
<span class="line-added">372     } else {</span>
<span class="line-added">373       load_reference_barrier(masm, dst, src);</span>
<span class="line-added">374     }</span>
<span class="line-added">375 </span>
<span class="line-added">376     if (dst != result_dst) {</span>
<span class="line-added">377       __ mov(result_dst, dst);</span>
<span class="line-added">378       dst = result_dst;</span>
<span class="line-added">379     }</span>
<span class="line-added">380   } else {</span>
<span class="line-added">381     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);</span>
382   }
383 
<span class="line-modified">384   // 3: apply keep-alive barrier if needed</span>
<span class="line-modified">385   if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {</span>
386     __ enter();
387     satb_write_barrier_pre(masm /* masm */,
388                            noreg /* obj */,
389                            dst /* pre_val */,
390                            rthread /* thread */,
391                            tmp1 /* tmp */,
392                            true /* tosca_live */,
393                            true /* expand_call */);
394     __ leave();
395   }
396 }
397 
398 void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
399                                              Address dst, Register val, Register tmp1, Register tmp2) {
<span class="line-modified">400   bool on_oop = is_reference_type(type);</span>




401   if (!on_oop) {
402     BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);
403     return;
404   }
405 
406   // flatten object address if needed
407   if (dst.index() == noreg &amp;&amp; dst.offset() == 0) {
408     if (dst.base() != r3) {
409       __ mov(r3, dst.base());
410     }
411   } else {
412     __ lea(r3, dst);
413   }
414 
415   shenandoah_write_barrier_pre(masm,
416                                r3 /* obj */,
417                                tmp2 /* pre_val */,
418                                rthread /* thread */,
419                                tmp1  /* tmp */,
420                                val != noreg /* tosca_live */,
421                                false /* expand_call */);
422 
423   if (val == noreg) {
424     BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), noreg, noreg, noreg);
425   } else {
426     storeval_barrier(masm, val, tmp1);
427     // G1 barrier needs uncompressed oop for region cross check.
428     Register new_val = val;
429     if (UseCompressedOops) {
430       new_val = rscratch2;
431       __ mov(new_val, val);
432     }
433     BarrierSetAssembler::store_at(masm, decorators, type, Address(r3, 0), val, noreg, noreg);
434   }
435 
436 }
437 
<span class="line-modified">438 void ShenandoahBarrierSetAssembler::try_resolve_jobject_in_native(MacroAssembler* masm, Register jni_env,</span>
<span class="line-modified">439                                                                   Register obj, Register tmp, Label&amp; slowpath) {</span>
<span class="line-modified">440   Label done;</span>
<span class="line-modified">441   // Resolve jobject</span>
<span class="line-modified">442   BarrierSetAssembler::try_resolve_jobject_in_native(masm, jni_env, obj, tmp, slowpath);</span>




















443 
<span class="line-modified">444   // Check for null.</span>
<span class="line-modified">445   __ cbz(obj, done);</span>








446 
<span class="line-modified">447   assert(obj != rscratch2, &quot;need rscratch2&quot;);</span>
<span class="line-modified">448   Address gc_state(jni_env, ShenandoahThreadLocalData::gc_state_offset() - JavaThread::jni_environment_offset());</span>
<span class="line-added">449   __ lea(rscratch2, gc_state);</span>
<span class="line-added">450   __ ldrb(rscratch2, Address(rscratch2));</span>
451 
<span class="line-modified">452   // Check for heap in evacuation phase</span>
<span class="line-modified">453   __ tbnz(rscratch2, ShenandoahHeap::EVACUATION_BITPOS, slowpath);</span>
454 
<span class="line-modified">455   __ bind(done);</span>



456 }
457 




















458 
459 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm, Register addr, Register expected, Register new_val,
460                                                 bool acquire, bool release, bool weak, bool is_cae,
461                                                 Register result) {
462   Register tmp1 = rscratch1;
463   Register tmp2 = rscratch2;
464   bool is_narrow = UseCompressedOops;
465   Assembler::operand_size size = is_narrow ? Assembler::word : Assembler::xword;
466 
467   assert_different_registers(addr, expected, new_val, tmp1, tmp2);
468 
469   Label retry, done, fail;
470 
471   // CAS, using LL/SC pair.
472   __ bind(retry);
473   __ load_exclusive(tmp1, addr, size, acquire);
474   if (is_narrow) {
475     __ cmpw(tmp1, expected);
476   } else {
477     __ cmp(tmp1, expected);
478   }
479   __ br(Assembler::NE, fail);
480   __ store_exclusive(tmp2, new_val, addr, size, release);
481   if (weak) {
482     __ cmpw(tmp2, 0u); // If the store fails, return NE to our caller
483   } else {
484     __ cbnzw(tmp2, retry);
485   }
486   __ b(done);
487 
488  __  bind(fail);
489   // Check if rb(expected)==rb(tmp1)
490   // Shuffle registers so that we have memory value ready for next expected.
491   __ mov(tmp2, expected);
492   __ mov(expected, tmp1);
493   if (is_narrow) {
494     __ decode_heap_oop(tmp1, tmp1);
495     __ decode_heap_oop(tmp2, tmp2);
496   }
<span class="line-modified">497   resolve_forward_pointer(masm, tmp1);</span>
<span class="line-modified">498   resolve_forward_pointer(masm, tmp2);</span>
499   __ cmp(tmp1, tmp2);
500   // Retry with expected now being the value we just loaded from addr.
501   __ br(Assembler::EQ, retry);
502   if (is_cae &amp;&amp; is_narrow) {
503     // For cmp-and-exchange and narrow oops, we need to restore
504     // the compressed old-value. We moved it to &#39;expected&#39; a few lines up.
505     __ mov(tmp1, expected);
506   }
507   __ bind(done);
508 
509   if (is_cae) {
510     __ mov(result, tmp1);
511   } else {
512     __ cset(result, Assembler::EQ);
513   }
514 }
515 
<span class="line-added">516 #undef __</span>
<span class="line-added">517 </span>
518 #ifdef COMPILER1
519 

520 #define __ ce-&gt;masm()-&gt;
521 
522 void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
523   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
524   // At this point we know that marking is in progress.
525   // If do_load() is true then we have to emit the
526   // load of the previous value; otherwise it has already
527   // been loaded into _pre_val.
528 
529   __ bind(*stub-&gt;entry());
530 
531   assert(stub-&gt;pre_val()-&gt;is_register(), &quot;Precondition.&quot;);
532 
533   Register pre_val_reg = stub-&gt;pre_val()-&gt;as_register();
534 
535   if (stub-&gt;do_load()) {
536     ce-&gt;mem2reg(stub-&gt;addr(), stub-&gt;pre_val(), T_OBJECT, stub-&gt;patch_code(), stub-&gt;info(), false /*wide*/, false /*unaligned*/);
537   }
538   __ cbz(pre_val_reg, *stub-&gt;continuation());
539   ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
540   __ far_call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
541   __ b(*stub-&gt;continuation());
542 }
543 
<span class="line-modified">544 void ShenandoahBarrierSetAssembler::gen_load_reference_barrier_stub(LIR_Assembler* ce, ShenandoahLoadReferenceBarrierStub* stub) {</span>
<span class="line-added">545   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();</span>
<span class="line-added">546   __ bind(*stub-&gt;entry());</span>
547 
548   Register obj = stub-&gt;obj()-&gt;as_register();
549   Register res = stub-&gt;result()-&gt;as_register();
<span class="line-added">550   Register addr = stub-&gt;addr()-&gt;as_pointer_register();</span>
<span class="line-added">551   Register tmp1 = stub-&gt;tmp1()-&gt;as_register();</span>
<span class="line-added">552   Register tmp2 = stub-&gt;tmp2()-&gt;as_register();</span>
553 
<span class="line-modified">554   assert(res == r0, &quot;result must arrive in r0&quot;);</span>


555 
556   if (res != obj) {
557     __ mov(res, obj);
558   }
<span class="line-added">559 </span>
560   // Check for null.
<span class="line-modified">561   __ cbz(res, *stub-&gt;continuation());</span>
<span class="line-modified">562 </span>
<span class="line-modified">563   // Check for object in cset.</span>
<span class="line-added">564   __ mov(tmp2, ShenandoahHeap::in_cset_fast_test_addr());</span>
<span class="line-added">565   __ lsr(tmp1, res, ShenandoahHeapRegion::region_size_bytes_shift_jint());</span>
<span class="line-added">566   __ ldrb(tmp2, Address(tmp2, tmp1));</span>
<span class="line-added">567   __ cbz(tmp2, *stub-&gt;continuation());</span>
<span class="line-added">568 </span>
<span class="line-added">569   // Check if object is already forwarded.</span>
<span class="line-added">570   Label slow_path;</span>
<span class="line-added">571   __ ldr(tmp1, Address(res, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">572   __ eon(tmp1, tmp1, zr);</span>
<span class="line-added">573   __ ands(zr, tmp1, markWord::lock_mask_in_place);</span>
<span class="line-added">574   __ br(Assembler::NE, slow_path);</span>
<span class="line-added">575 </span>
<span class="line-added">576   // Decode forwarded object.</span>
<span class="line-added">577   __ orr(tmp1, tmp1, markWord::marked_value);</span>
<span class="line-added">578   __ eon(res, tmp1, zr);</span>
<span class="line-added">579   __ b(*stub-&gt;continuation());</span>
580 
<span class="line-modified">581   __ bind(slow_path);</span>
<span class="line-added">582   ce-&gt;store_parameter(res, 0);</span>
<span class="line-added">583   ce-&gt;store_parameter(addr, 1);</span>
<span class="line-added">584   if (stub-&gt;is_native()) {</span>
<span class="line-added">585     __ far_call(RuntimeAddress(bs-&gt;load_reference_barrier_native_rt_code_blob()-&gt;code_begin()));</span>
<span class="line-added">586   } else {</span>
<span class="line-added">587     __ far_call(RuntimeAddress(bs-&gt;load_reference_barrier_rt_code_blob()-&gt;code_begin()));</span>
<span class="line-added">588   }</span>
589 

590   __ b(*stub-&gt;continuation());
591 }
592 
593 #undef __
594 
595 #define __ sasm-&gt;
596 
597 void ShenandoahBarrierSetAssembler::generate_c1_pre_barrier_runtime_stub(StubAssembler* sasm) {
598   __ prologue(&quot;shenandoah_pre_barrier&quot;, false);
599 
600   // arg0 : previous value of memory
601 
602   BarrierSet* bs = BarrierSet::barrier_set();
603 
604   const Register pre_val = r0;
605   const Register thread = rthread;
606   const Register tmp = rscratch1;
607 
608   Address queue_index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
609   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
</pre>
<hr />
<pre>
623   __ cbz(tmp, runtime);
624 
625   __ sub(tmp, tmp, wordSize);
626   __ str(tmp, queue_index);
627   __ ldr(rscratch2, buffer);
628   __ add(tmp, tmp, rscratch2);
629   __ load_parameter(0, rscratch2);
630   __ str(rscratch2, Address(tmp, 0));
631   __ b(done);
632 
633   __ bind(runtime);
634   __ push_call_clobbered_registers();
635   __ load_parameter(0, pre_val);
636   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, thread);
637   __ pop_call_clobbered_registers();
638   __ bind(done);
639 
640   __ epilogue();
641 }
642 
<span class="line-added">643 void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native) {</span>
<span class="line-added">644   __ prologue(&quot;shenandoah_load_reference_barrier&quot;, false);</span>
<span class="line-added">645   // arg0 : object to be resolved</span>
<span class="line-added">646 </span>
<span class="line-added">647   __ push_call_clobbered_registers();</span>
<span class="line-added">648   __ load_parameter(0, r0);</span>
<span class="line-added">649   __ load_parameter(1, r1);</span>
<span class="line-added">650   if (is_native) {</span>
<span class="line-added">651     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));</span>
<span class="line-added">652   } else if (UseCompressedOops) {</span>
<span class="line-added">653     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow));</span>
<span class="line-added">654   } else {</span>
<span class="line-added">655     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier));</span>
<span class="line-added">656   }</span>
<span class="line-added">657   __ blr(lr);</span>
<span class="line-added">658   __ mov(rscratch1, r0);</span>
<span class="line-added">659   __ pop_call_clobbered_registers();</span>
<span class="line-added">660   __ mov(r0, rscratch1);</span>
<span class="line-added">661 </span>
<span class="line-added">662   __ epilogue();</span>
<span class="line-added">663 }</span>
<span class="line-added">664 </span>
665 #undef __
666 
667 #endif // COMPILER1
668 
<span class="line-modified">669 address ShenandoahBarrierSetAssembler::shenandoah_lrb() {</span>
<span class="line-modified">670   assert(_shenandoah_lrb != NULL, &quot;need load reference barrier stub&quot;);</span>
<span class="line-modified">671   return _shenandoah_lrb;</span>
672 }
673 
674 #define __ cgen-&gt;assembler()-&gt;
675 
<span class="line-modified">676 // Shenandoah load reference barrier.</span>
677 //
678 // Input:
679 //   r0: OOP to evacuate.  Not null.
<span class="line-added">680 //   r1: load address</span>
681 //
682 // Output:
683 //   r0: Pointer to evacuated OOP.
684 //
685 // Trash rscratch1, rscratch2.  Preserve everything else.
<span class="line-modified">686 address ShenandoahBarrierSetAssembler::generate_shenandoah_lrb(StubCodeGenerator* cgen) {</span>
687 
688   __ align(6);
<span class="line-modified">689   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_lrb&quot;);</span>
690   address start = __ pc();
691 
<span class="line-modified">692   Label work, done;</span>
693   __ mov(rscratch2, ShenandoahHeap::in_cset_fast_test_addr());
694   __ lsr(rscratch1, r0, ShenandoahHeapRegion::region_size_bytes_shift_jint());
695   __ ldrb(rscratch2, Address(rscratch2, rscratch1));
696   __ tbnz(rscratch2, 0, work);
697   __ ret(lr);
698   __ bind(work);
699 
<span class="line-modified">700   Label slow_path;</span>
<span class="line-added">701   __ ldr(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">702   __ eon(rscratch1, rscratch1, zr);</span>
<span class="line-added">703   __ ands(zr, rscratch1, markWord::lock_mask_in_place);</span>
<span class="line-added">704   __ br(Assembler::NE, slow_path);</span>
<span class="line-added">705 </span>
<span class="line-added">706   // Decode forwarded object.</span>
<span class="line-added">707   __ orr(rscratch1, rscratch1, markWord::marked_value);</span>
<span class="line-added">708   __ eon(r0, rscratch1, zr);</span>
<span class="line-added">709   __ ret(lr);</span>
710 
<span class="line-added">711   __ bind(slow_path);</span>
712   __ enter(); // required for proper stackwalking of RuntimeStub frame
713 
714   __ push_call_clobbered_registers();
715 
<span class="line-modified">716   if (UseCompressedOops) {</span>
<span class="line-modified">717     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow));</span>
<span class="line-modified">718   } else {</span>
<span class="line-added">719     __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier));</span>
<span class="line-added">720   }</span>
<span class="line-added">721   __ blr(lr);</span>
<span class="line-added">722   __ mov(rscratch1, r0);</span>
723   __ pop_call_clobbered_registers();
<span class="line-modified">724   __ mov(r0, rscratch1);</span>
725 
726   __ leave(); // required for proper stackwalking of RuntimeStub frame
<span class="line-added">727   __ bind(done);</span>
728   __ ret(lr);
729 
730   return start;
731 }
732 
733 #undef __
734 
735 void ShenandoahBarrierSetAssembler::barrier_stubs_init() {
<span class="line-modified">736   if (ShenandoahLoadRefBarrier) {</span>
737     int stub_code_size = 2048;
738     ResourceMark rm;
739     BufferBlob* bb = BufferBlob::create(&quot;shenandoah_barrier_stubs&quot;, stub_code_size);
740     CodeBuffer buf(bb);
741     StubCodeGenerator cgen(&amp;buf);
<span class="line-modified">742     _shenandoah_lrb = generate_shenandoah_lrb(&amp;cgen);</span>
743   }
744 }
</pre>
</td>
</tr>
</table>
<center><a href="../shared/modRefBarrierSetAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
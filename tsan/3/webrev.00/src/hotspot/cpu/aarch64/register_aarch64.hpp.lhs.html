<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/register_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_AARCH64_REGISTER_AARCH64_HPP
 27 #define CPU_AARCH64_REGISTER_AARCH64_HPP
 28 
 29 #include &quot;asm/register.hpp&quot;
 30 
 31 class VMRegImpl;
 32 typedef VMRegImpl* VMReg;
 33 
 34 // Use Register as shortcut
 35 class RegisterImpl;
 36 typedef RegisterImpl* Register;
 37 
 38 inline Register as_Register(int encoding) {
 39   return (Register)(intptr_t) encoding;
 40 }
 41 
 42 class RegisterImpl: public AbstractRegisterImpl {
 43  public:
 44   enum {
 45     number_of_registers         =   32,
 46     number_of_byte_registers      = 32,
<a name="1" id="anc1"></a><span class="line-modified"> 47     number_of_registers_for_jvmci = 34   // Including SP and ZR.</span>

 48   };
 49 
 50   // derived registers, offsets, and addresses
 51   Register successor() const                          { return as_Register(encoding() + 1); }
 52 
 53   // construction
 54   inline friend Register as_Register(int encoding);
 55 
 56   VMReg as_VMReg();
 57 
 58   // accessors
 59   int   encoding() const                         { assert(is_valid(), &quot;invalid register&quot;); return (intptr_t)this; }
 60   bool  is_valid() const                         { return 0 &lt;= (intptr_t)this &amp;&amp; (intptr_t)this &lt; number_of_registers; }
 61   bool  has_byte_register() const                { return 0 &lt;= (intptr_t)this &amp;&amp; (intptr_t)this &lt; number_of_byte_registers; }
 62   const char* name() const;
 63   int   encoding_nocheck() const                 { return (intptr_t)this; }
 64 
 65   // Return the bit which represents this register.  This is intended
 66   // to be ORed into a bitmask: for usage see class RegSet below.
 67   unsigned long bit(bool should_set = true) const { return should_set ? 1 &lt;&lt; encoding() : 0; }
 68 };
 69 
 70 // The integer registers of the aarch64 architecture
 71 
 72 CONSTANT_REGISTER_DECLARATION(Register, noreg, (-1));
 73 
 74 
 75 CONSTANT_REGISTER_DECLARATION(Register, r0,    (0));
 76 CONSTANT_REGISTER_DECLARATION(Register, r1,    (1));
 77 CONSTANT_REGISTER_DECLARATION(Register, r2,    (2));
 78 CONSTANT_REGISTER_DECLARATION(Register, r3,    (3));
 79 CONSTANT_REGISTER_DECLARATION(Register, r4,    (4));
 80 CONSTANT_REGISTER_DECLARATION(Register, r5,    (5));
 81 CONSTANT_REGISTER_DECLARATION(Register, r6,    (6));
 82 CONSTANT_REGISTER_DECLARATION(Register, r7,    (7));
 83 CONSTANT_REGISTER_DECLARATION(Register, r8,    (8));
 84 CONSTANT_REGISTER_DECLARATION(Register, r9,    (9));
 85 CONSTANT_REGISTER_DECLARATION(Register, r10,  (10));
 86 CONSTANT_REGISTER_DECLARATION(Register, r11,  (11));
 87 CONSTANT_REGISTER_DECLARATION(Register, r12,  (12));
 88 CONSTANT_REGISTER_DECLARATION(Register, r13,  (13));
 89 CONSTANT_REGISTER_DECLARATION(Register, r14,  (14));
 90 CONSTANT_REGISTER_DECLARATION(Register, r15,  (15));
 91 CONSTANT_REGISTER_DECLARATION(Register, r16,  (16));
 92 CONSTANT_REGISTER_DECLARATION(Register, r17,  (17));
 93 CONSTANT_REGISTER_DECLARATION(Register, r18,  (18));
 94 CONSTANT_REGISTER_DECLARATION(Register, r19,  (19));
 95 CONSTANT_REGISTER_DECLARATION(Register, r20,  (20));
 96 CONSTANT_REGISTER_DECLARATION(Register, r21,  (21));
 97 CONSTANT_REGISTER_DECLARATION(Register, r22,  (22));
 98 CONSTANT_REGISTER_DECLARATION(Register, r23,  (23));
 99 CONSTANT_REGISTER_DECLARATION(Register, r24,  (24));
100 CONSTANT_REGISTER_DECLARATION(Register, r25,  (25));
101 CONSTANT_REGISTER_DECLARATION(Register, r26,  (26));
102 CONSTANT_REGISTER_DECLARATION(Register, r27,  (27));
103 CONSTANT_REGISTER_DECLARATION(Register, r28,  (28));
104 CONSTANT_REGISTER_DECLARATION(Register, r29,  (29));
105 CONSTANT_REGISTER_DECLARATION(Register, r30,  (30));
106 
107 
108 // r31 is not a general purpose register, but represents either the
109 // stack pointer or the zero/discard register depending on the
110 // instruction.
111 CONSTANT_REGISTER_DECLARATION(Register, r31_sp, (31));
112 CONSTANT_REGISTER_DECLARATION(Register, zr,  (32));
113 CONSTANT_REGISTER_DECLARATION(Register, sp,  (33));
114 
115 // Used as a filler in instructions where a register field is unused.
116 const Register dummy_reg = r31_sp;
117 
118 // Use FloatRegister as shortcut
119 class FloatRegisterImpl;
120 typedef FloatRegisterImpl* FloatRegister;
121 
122 inline FloatRegister as_FloatRegister(int encoding) {
123   return (FloatRegister)(intptr_t) encoding;
124 }
125 
126 // The implementation of floating point registers for the architecture
127 class FloatRegisterImpl: public AbstractRegisterImpl {
128  public:
129   enum {
<a name="2" id="anc2"></a><span class="line-modified">130     number_of_registers = 32</span>



131   };
132 
133   // construction
134   inline friend FloatRegister as_FloatRegister(int encoding);
135 
136   VMReg as_VMReg();
137 
138   // derived registers, offsets, and addresses
<a name="3" id="anc3"></a><span class="line-modified">139   FloatRegister successor() const                          { return as_FloatRegister(encoding() + 1); }</span>
140 
141   // accessors
142   int   encoding() const                          { assert(is_valid(), &quot;invalid register&quot;); return (intptr_t)this; }
143   int   encoding_nocheck() const                         { return (intptr_t)this; }
144   bool  is_valid() const                          { return 0 &lt;= (intptr_t)this &amp;&amp; (intptr_t)this &lt; number_of_registers; }
145   const char* name() const;
146 
147 };
148 
149 // The float registers of the AARCH64 architecture
150 
151 CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg , (-1));
152 
153 CONSTANT_REGISTER_DECLARATION(FloatRegister, v0     , ( 0));
154 CONSTANT_REGISTER_DECLARATION(FloatRegister, v1     , ( 1));
155 CONSTANT_REGISTER_DECLARATION(FloatRegister, v2     , ( 2));
156 CONSTANT_REGISTER_DECLARATION(FloatRegister, v3     , ( 3));
157 CONSTANT_REGISTER_DECLARATION(FloatRegister, v4     , ( 4));
158 CONSTANT_REGISTER_DECLARATION(FloatRegister, v5     , ( 5));
159 CONSTANT_REGISTER_DECLARATION(FloatRegister, v6     , ( 6));
160 CONSTANT_REGISTER_DECLARATION(FloatRegister, v7     , ( 7));
161 CONSTANT_REGISTER_DECLARATION(FloatRegister, v8     , ( 8));
162 CONSTANT_REGISTER_DECLARATION(FloatRegister, v9     , ( 9));
163 CONSTANT_REGISTER_DECLARATION(FloatRegister, v10    , (10));
164 CONSTANT_REGISTER_DECLARATION(FloatRegister, v11    , (11));
165 CONSTANT_REGISTER_DECLARATION(FloatRegister, v12    , (12));
166 CONSTANT_REGISTER_DECLARATION(FloatRegister, v13    , (13));
167 CONSTANT_REGISTER_DECLARATION(FloatRegister, v14    , (14));
168 CONSTANT_REGISTER_DECLARATION(FloatRegister, v15    , (15));
169 CONSTANT_REGISTER_DECLARATION(FloatRegister, v16    , (16));
170 CONSTANT_REGISTER_DECLARATION(FloatRegister, v17    , (17));
171 CONSTANT_REGISTER_DECLARATION(FloatRegister, v18    , (18));
172 CONSTANT_REGISTER_DECLARATION(FloatRegister, v19    , (19));
173 CONSTANT_REGISTER_DECLARATION(FloatRegister, v20    , (20));
174 CONSTANT_REGISTER_DECLARATION(FloatRegister, v21    , (21));
175 CONSTANT_REGISTER_DECLARATION(FloatRegister, v22    , (22));
176 CONSTANT_REGISTER_DECLARATION(FloatRegister, v23    , (23));
177 CONSTANT_REGISTER_DECLARATION(FloatRegister, v24    , (24));
178 CONSTANT_REGISTER_DECLARATION(FloatRegister, v25    , (25));
179 CONSTANT_REGISTER_DECLARATION(FloatRegister, v26    , (26));
180 CONSTANT_REGISTER_DECLARATION(FloatRegister, v27    , (27));
181 CONSTANT_REGISTER_DECLARATION(FloatRegister, v28    , (28));
182 CONSTANT_REGISTER_DECLARATION(FloatRegister, v29    , (29));
183 CONSTANT_REGISTER_DECLARATION(FloatRegister, v30    , (30));
184 CONSTANT_REGISTER_DECLARATION(FloatRegister, v31    , (31));
185 
186 // Need to know the total number of registers of all sorts for SharedInfo.
187 // Define a class that exports it.
188 class ConcreteRegisterImpl : public AbstractRegisterImpl {
189  public:
190   enum {
191   // A big enough number for C2: all the registers plus flags
192   // This number must be large enough to cover REG_COUNT (defined by c2) registers.
193   // There is no requirement that any ordering here matches any ordering c2 gives
194   // it&#39;s optoregs.
195 
<a name="4" id="anc4"></a><span class="line-modified">196     number_of_registers = (2 * RegisterImpl::number_of_registers +</span>
<span class="line-modified">197                            4 * FloatRegisterImpl::number_of_registers +</span>
198                            1) // flags
199   };
200 
201   // added to make it compile
202   static const int max_gpr;
203   static const int max_fpr;
204 };
205 
206 // A set of registers
207 class RegSet {
208   uint32_t _bitset;
209 
210   RegSet(uint32_t bitset) : _bitset(bitset) { }
211 
212 public:
213 
214   RegSet() : _bitset(0) { }
215 
216   RegSet(Register r1) : _bitset(r1-&gt;bit()) { }
217 
218   RegSet operator+(const RegSet aSet) const {
219     RegSet result(_bitset | aSet._bitset);
220     return result;
221   }
222 
223   RegSet operator-(const RegSet aSet) const {
224     RegSet result(_bitset &amp; ~aSet._bitset);
225     return result;
226   }
227 
228   RegSet &amp;operator+=(const RegSet aSet) {
229     *this = *this + aSet;
230     return *this;
231   }
232 
<a name="5" id="anc5"></a>




233   static RegSet of(Register r1) {
234     return RegSet(r1);
235   }
236 
237   static RegSet of(Register r1, Register r2) {
238     return of(r1) + r2;
239   }
240 
241   static RegSet of(Register r1, Register r2, Register r3) {
242     return of(r1, r2) + r3;
243   }
244 
245   static RegSet of(Register r1, Register r2, Register r3, Register r4) {
246     return of(r1, r2, r3) + r4;
247   }
248 
249   static RegSet range(Register start, Register end) {
250     uint32_t bits = ~0;
251     bits &lt;&lt;= start-&gt;encoding();
252     bits &lt;&lt;= 31 - end-&gt;encoding();
253     bits &gt;&gt;= 31 - end-&gt;encoding();
254 
255     return RegSet(bits);
256   }
257 
258   uint32_t bits() const { return _bitset; }
259 };
260 
261 #endif // CPU_AARCH64_REGISTER_AARCH64_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
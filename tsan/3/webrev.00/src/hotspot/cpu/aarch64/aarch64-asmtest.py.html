<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/aarch64/aarch64-asmtest.py</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 import random
   2 
   3 AARCH64_AS = &quot;&lt;PATH-TO-AS&gt;&quot;
   4 AARCH64_OBJDUMP = &quot;&lt;PATH-TO-OBJDUMP&gt;&quot;
   5 AARCH64_OBJCOPY = &quot;&lt;PATH-TO-OBJCOPY&gt;&quot;
   6 
   7 class Operand(object):
   8 
   9      def generate(self):
  10         return self
  11 
  12 class Register(Operand):
  13 
  14     def generate(self):
  15         self.number = random.randint(0, 30)
  16         return self
  17 
  18     def astr(self, prefix):
  19         return prefix + str(self.number)
  20 
  21 class FloatRegister(Register):
  22 
  23     def __str__(self):
  24         return self.astr(&quot;v&quot;)
  25 
  26     def nextReg(self):
  27         next = FloatRegister()
  28         next.number = (self.number + 1) % 32
  29         return next
  30 
  31 class GeneralRegister(Register):
  32 
  33     def __str__(self):
  34         return self.astr(&quot;r&quot;)
  35 
  36 class GeneralRegisterOrZr(Register):
  37 
  38     def generate(self):
  39         self.number = random.randint(0, 31)
  40         return self
  41 
  42     def astr(self, prefix = &quot;&quot;):
  43         if (self.number == 31):
  44             return prefix + &quot;zr&quot;
  45         else:
  46             return prefix + str(self.number)
  47 
  48     def __str__(self):
  49         if (self.number == 31):
  50             return self.astr()
  51         else:
  52             return self.astr(&quot;r&quot;)
  53 
  54 class GeneralRegisterOrSp(Register):
  55     def generate(self):
  56         self.number = random.randint(0, 31)
  57         return self
  58 
  59     def astr(self, prefix = &quot;&quot;):
  60         if (self.number == 31):
  61             return &quot;sp&quot;
  62         else:
  63             return prefix + str(self.number)
  64 
  65     def __str__(self):
  66         if (self.number == 31):
  67             return self.astr()
  68         else:
  69             return self.astr(&quot;r&quot;)
  70 
  71 class FloatZero(Operand):
  72 
  73     def __str__(self):
  74         return &quot;0.0&quot;
  75 
  76     def astr(self, ignored):
  77         return &quot;#0.0&quot;
  78 
  79 class OperandFactory:
  80 
  81     _modes = {&#39;x&#39; : GeneralRegister,
  82               &#39;w&#39; : GeneralRegister,
  83               &#39;s&#39; : FloatRegister,
  84               &#39;d&#39; : FloatRegister,
  85               &#39;z&#39; : FloatZero}
  86 
  87     @classmethod
  88     def create(cls, mode):
  89         return OperandFactory._modes[mode]()
  90 
  91 class ShiftKind:
  92 
  93     def generate(self):
  94         self.kind = [&quot;LSL&quot;, &quot;LSR&quot;, &quot;ASR&quot;][random.randint(0,2)]
  95         return self
  96 
  97     def cstr(self):
  98         return self.kind
  99 
 100 class Instruction(object):
 101 
 102     def __init__(self, name):
 103         self._name = name
 104         self.isWord = name.endswith(&quot;w&quot;) | name.endswith(&quot;wi&quot;)
 105         self.asmRegPrefix = [&quot;x&quot;, &quot;w&quot;][self.isWord]
 106 
 107     def aname(self):
 108         if (self._name.endswith(&quot;wi&quot;)):
 109             return self._name[:len(self._name)-2]
 110         else:
 111             if (self._name.endswith(&quot;i&quot;) | self._name.endswith(&quot;w&quot;)):
 112                 return self._name[:len(self._name)-1]
 113             else:
 114                 return self._name
 115 
 116     def emit(self) :
 117         pass
 118 
 119     def compare(self) :
 120         pass
 121 
 122     def generate(self) :
 123         return self
 124 
 125     def cstr(self):
 126         return &#39;__ %s(&#39; % self.name()
 127 
 128     def astr(self):
 129         return &#39;%s\t&#39; % self.aname()
 130 
 131     def name(self):
 132         name = self._name
 133         if name == &quot;and&quot;:
 134             name = &quot;andr&quot; # Special case: the name &quot;and&quot; can&#39;t be used
 135                           # in HotSpot, even for a member.
 136         return name
 137 
 138     def multipleForms(self):
 139          return 0
 140 
 141 class InstructionWithModes(Instruction):
 142 
 143     def __init__(self, name, mode):
 144         Instruction.__init__(self, name)
 145         self.mode = mode
 146         self.isFloat = (mode == &#39;d&#39;) | (mode == &#39;s&#39;)
 147         if self.isFloat:
 148             self.isWord = mode != &#39;d&#39;
 149             self.asmRegPrefix = [&quot;d&quot;, &quot;s&quot;][self.isWord] 
 150         else:
 151             self.isWord = mode != &#39;x&#39;
 152             self.asmRegPrefix = [&quot;x&quot;, &quot;w&quot;][self.isWord]
 153        
 154     def name(self):
 155         return self._name + (self.mode if self.mode != &#39;x&#39; else &#39;&#39;)
 156             
 157     def aname(self):
 158         return (self._name+mode if (mode == &#39;b&#39; or mode == &#39;h&#39;) 
 159             else self._name)
 160 
 161 class ThreeRegInstruction(Instruction):
 162 
 163     def generate(self):
 164         self.reg = [GeneralRegister().generate(), GeneralRegister().generate(),
 165                     GeneralRegister().generate()]
 166         return self
 167 
 168 
 169     def cstr(self):
 170         return (super(ThreeRegInstruction, self).cstr()
 171                 + (&#39;%s, %s, %s&#39; 
 172                    % (self.reg[0],
 173                       self.reg[1], self.reg[2])))
 174                 
 175     def astr(self):
 176         prefix = self.asmRegPrefix
 177         return (super(ThreeRegInstruction, self).astr()
 178                 + (&#39;%s, %s, %s&#39; 
 179                    % (self.reg[0].astr(prefix),
 180                       self.reg[1].astr(prefix), self.reg[2].astr(prefix))))
 181                 
 182 class FourRegInstruction(ThreeRegInstruction):
 183 
 184     def generate(self):
 185         self.reg = ThreeRegInstruction.generate(self).reg + [GeneralRegister().generate()]
 186         return self
 187 
 188 
 189     def cstr(self):
 190         return (super(FourRegInstruction, self).cstr()
 191                 + (&#39;, %s&#39; % self.reg[3]))
 192                 
 193     def astr(self):
 194         prefix = self.asmRegPrefix
 195         return (super(FourRegInstruction, self).astr()
 196                 + (&#39;, %s&#39; % self.reg[3].astr(prefix)))
 197                 
 198 class TwoRegInstruction(Instruction):
 199 
 200     def generate(self):
 201         self.reg = [GeneralRegister().generate(), GeneralRegister().generate()]
 202         return self
 203 
 204     def cstr(self):
 205         return (super(TwoRegInstruction, self).cstr()
 206                 + &#39;%s, %s&#39; % (self.reg[0],
 207                               self.reg[1]))
 208 
 209     def astr(self):
 210         prefix = self.asmRegPrefix
 211         return (super(TwoRegInstruction, self).astr()
 212                 + (&#39;%s, %s&#39; 
 213                    % (self.reg[0].astr(prefix),
 214                       self.reg[1].astr(prefix))))
 215                 
 216 class TwoRegImmedInstruction(TwoRegInstruction):
 217 
 218     def generate(self):
 219         super(TwoRegImmedInstruction, self).generate()
 220         self.immed = random.randint(0, 1&lt;&lt;11 -1)
 221         return self
 222         
 223     def cstr(self):
 224         return (super(TwoRegImmedInstruction, self).cstr()
 225                 + &#39;, %su&#39; % self.immed)
 226 
 227     def astr(self):
 228         return (super(TwoRegImmedInstruction, self).astr()
 229                 + &#39;, #%s&#39; % self.immed)
 230 
 231 class OneRegOp(Instruction):
 232 
 233     def generate(self):
 234         self.reg = GeneralRegister().generate()
 235         return self
 236 
 237     def cstr(self):
 238         return (super(OneRegOp, self).cstr()
 239                 + &#39;%s);&#39; % self.reg)
 240 
 241     def astr(self):
 242         return (super(OneRegOp, self).astr()
 243                 + &#39;%s&#39; % self.reg.astr(self.asmRegPrefix))
 244 
 245 class ArithOp(ThreeRegInstruction):
 246 
 247     def generate(self):
 248         super(ArithOp, self).generate()
 249         self.kind = ShiftKind().generate()
 250         self.distance = random.randint(0, (1&lt;&lt;5)-1 if self.isWord else (1&lt;&lt;6)-1)
 251         return self
 252         
 253     def cstr(self):
 254         return (&#39;%s, Assembler::%s, %s);&#39; 
 255                 % (ThreeRegInstruction.cstr(self),
 256                    self.kind.cstr(), self.distance))
 257 
 258     def astr(self):
 259         return (&#39;%s, %s #%s&#39;
 260                 % (ThreeRegInstruction.astr(self),
 261                    self.kind.cstr(),
 262                    self.distance))
 263 
 264 class AddSubCarryOp(ThreeRegInstruction):
 265     
 266     def cstr(self):
 267         return (&#39;%s);&#39; 
 268                 % (ThreeRegInstruction.cstr(self)))
 269 
 270 class AddSubExtendedOp(ThreeRegInstruction):
 271 
 272     uxtb, uxth, uxtw, uxtx, sxtb, sxth, sxtw, sxtx = range(8)
 273     optNames = [&quot;uxtb&quot;, &quot;uxth&quot;, &quot;uxtw&quot;, &quot;uxtx&quot;, &quot;sxtb&quot;, &quot;sxth&quot;, &quot;sxtw&quot;, &quot;sxtx&quot;]
 274 
 275     def generate(self):
 276         super(AddSubExtendedOp, self).generate()
 277         self.amount = random.randint(1, 4)
 278         self.option = random.randint(0, 7)
 279         return self
 280 
 281     def cstr(self):
 282         return (super(AddSubExtendedOp, self).cstr()
 283                 + (&quot;, ext::&quot; + AddSubExtendedOp.optNames[self.option] 
 284                    + &quot;, &quot; + str(self.amount) + &quot;);&quot;))
 285                 
 286     def astr(self):
 287         return (super(AddSubExtendedOp, self).astr()
 288                 + (&quot;, &quot; + AddSubExtendedOp.optNames[self.option] 
 289                    + &quot; #&quot; + str(self.amount)))
 290 
 291 class AddSubImmOp(TwoRegImmedInstruction):
 292 
 293     def cstr(self):
 294          return super(AddSubImmOp, self).cstr() + &quot;);&quot;
 295     
 296 class LogicalImmOp(AddSubImmOp):
 297 
 298      # These tables are legal immediate logical operands
 299      immediates32 \
 300          = [0x1, 0x3f, 0x1f0, 0x7e0, 
 301             0x1c00, 0x3ff0, 0x8000, 0x1e000, 
 302             0x3e000, 0x78000, 0xe0000, 0x100000, 
 303             0x1fffe0, 0x3fe000, 0x780000, 0x7ffff8, 
 304             0xff8000, 0x1800180, 0x1fffc00, 0x3c003c0, 
 305             0x3ffff00, 0x7c00000, 0x7fffe00, 0xf000f00, 
 306             0xfffe000, 0x18181818, 0x1ffc0000, 0x1ffffffe, 
 307             0x3f003f00, 0x3fffe000, 0x60006000, 0x7f807f80, 
 308             0x7ffffc00, 0x800001ff, 0x803fffff, 0x9f9f9f9f, 
 309             0xc0000fff, 0xc0c0c0c0, 0xe0000000, 0xe003e003, 
 310             0xe3ffffff, 0xf0000fff, 0xf0f0f0f0, 0xf80000ff, 
 311             0xf83ff83f, 0xfc00007f, 0xfc1fffff, 0xfe0001ff, 
 312             0xfe3fffff, 0xff003fff, 0xff800003, 0xff87ff87, 
 313             0xffc00fff, 0xffe0000f, 0xffefffef, 0xfff1fff1, 
 314             0xfff83fff, 0xfffc0fff, 0xfffe0fff, 0xffff3fff, 
 315             0xffffc007, 0xffffe1ff, 0xfffff80f, 0xfffffe07, 
 316             0xffffffbf, 0xfffffffd]
 317 
 318      immediates \
 319          = [0x1, 0x1f80, 0x3fff0, 0x3ffffc, 
 320             0x3fe0000, 0x1ffc0000, 0xf8000000, 0x3ffffc000, 
 321             0xffffffe00, 0x3ffffff800, 0xffffc00000, 0x3f000000000, 
 322             0x7fffffff800, 0x1fe000001fe0, 0x3ffffff80000, 0xc00000000000, 
 323             0x1ffc000000000, 0x3ffff0003ffff, 0x7ffffffe00000, 0xfffffffffc000, 
 324             0x1ffffffffffc00, 0x3fffffffffff00, 0x7ffffffffffc00, 0xffffffffff8000, 
 325             0x1ffffffff800000, 0x3fffffc03fffffc, 0x7fffc0000000000, 0xff80ff80ff80ff8, 
 326             0x1c00000000000000, 0x1fffffffffff0000, 0x3fffff803fffff80, 0x7fc000007fc00000, 
 327             0x8000000000000000, 0x803fffff803fffff, 0xc000007fc000007f, 0xe00000000000ffff, 
 328             0xe3ffffffffffffff, 0xf007f007f007f007, 0xf80003ffffffffff, 0xfc000003fc000003, 
 329             0xfe000000007fffff, 0xff00000000007fff, 0xff800000000003ff, 0xffc00000000000ff, 
 330             0xffe00000000003ff, 0xfff0000000003fff, 0xfff80000001fffff, 0xfffc0000fffc0000, 
 331             0xfffe003fffffffff, 0xffff3fffffffffff, 0xffffc0000007ffff, 0xffffe01fffffe01f, 
 332             0xfffff800000007ff, 0xfffffc0fffffffff, 0xffffff00003fffff, 0xffffffc0000007ff, 
 333             0xfffffff0000001ff, 0xfffffffc00003fff, 0xffffffff07ffffff, 0xffffffffe003ffff, 
 334             0xfffffffffc01ffff, 0xffffffffffc00003, 0xfffffffffffc000f, 0xffffffffffffe07f]
 335 
 336      def generate(self):
 337           AddSubImmOp.generate(self)
 338           self.immed = \
 339               self.immediates32[random.randint(0, len(self.immediates32)-1)] \
 340               	if self.isWord \
 341               else \
 342               	self.immediates[random.randint(0, len(self.immediates)-1)]
 343               
 344           return self
 345                   
 346      def astr(self):
 347           return (super(TwoRegImmedInstruction, self).astr()
 348                   + &#39;, #0x%x&#39; % self.immed)
 349 
 350      def cstr(self):
 351           return super(AddSubImmOp, self).cstr() + &quot;l);&quot;
 352     
 353 class MultiOp():
 354 
 355     def multipleForms(self):
 356          return 3
 357 
 358     def forms(self):
 359          return [&quot;__ pc()&quot;, &quot;back&quot;, &quot;forth&quot;]
 360 
 361     def aforms(self):
 362          return [&quot;.&quot;, &quot;back&quot;, &quot;forth&quot;]
 363 
 364 class AbsOp(MultiOp, Instruction):
 365 
 366     def cstr(self):
 367         return super(AbsOp, self).cstr() + &quot;%s);&quot;
 368 
 369     def astr(self):
 370         return Instruction.astr(self) + &quot;%s&quot;
 371 
 372 class RegAndAbsOp(MultiOp, Instruction):
 373     
 374     def multipleForms(self):
 375         if self.name() == &quot;adrp&quot;: 
 376             # We can only test one form of adrp because anything other
 377             # than &quot;adrp .&quot; requires relocs in the assembler output
 378             return 1
 379         return 3
 380 
 381     def generate(self):
 382         Instruction.generate(self)
 383         self.reg = GeneralRegister().generate()
 384         return self
 385     
 386     def cstr(self):
 387         if self.name() == &quot;adrp&quot;:
 388             return &quot;__ _adrp(&quot; + &quot;%s, %s);&quot; % (self.reg, &quot;%s&quot;)
 389         return (super(RegAndAbsOp, self).cstr() 
 390                 + &quot;%s, %s);&quot; % (self.reg, &quot;%s&quot;))
 391 
 392     def astr(self):
 393         return (super(RegAndAbsOp, self).astr()
 394                 + self.reg.astr(self.asmRegPrefix) + &quot;, %s&quot;)
 395 
 396 class RegImmAbsOp(RegAndAbsOp):
 397     
 398     def cstr(self):
 399         return (Instruction.cstr(self)
 400                 + &quot;%s, %s, %s);&quot; % (self.reg, self.immed, &quot;%s&quot;))
 401 
 402     def astr(self):
 403         return (Instruction.astr(self)
 404                 + (&quot;%s, #%s, %s&quot; 
 405                    % (self.reg.astr(self.asmRegPrefix), self.immed, &quot;%s&quot;)))
 406 
 407     def generate(self):
 408         super(RegImmAbsOp, self).generate()
 409         self.immed = random.randint(0, 1&lt;&lt;5 -1)
 410         return self
 411 
 412 class MoveWideImmOp(RegImmAbsOp):
 413     
 414     def multipleForms(self):
 415          return 0
 416 
 417     def cstr(self):
 418         return (Instruction.cstr(self)
 419                 + &quot;%s, %s, %s);&quot; % (self.reg, self.immed, self.shift))
 420 
 421     def astr(self):
 422         return (Instruction.astr(self)
 423                 + (&quot;%s, #%s, lsl %s&quot; 
 424                    % (self.reg.astr(self.asmRegPrefix), 
 425                       self.immed, self.shift)))
 426 
 427     def generate(self):
 428         super(RegImmAbsOp, self).generate()
 429         self.immed = random.randint(0, 1&lt;&lt;16 -1)
 430         if self.isWord:
 431             self.shift = random.randint(0, 1) * 16
 432         else:
 433             self.shift = random.randint(0, 3) * 16
 434         return self
 435 
 436 class BitfieldOp(TwoRegInstruction):
 437     
 438     def cstr(self):
 439         return (Instruction.cstr(self)
 440                 + (&quot;%s, %s, %s, %s);&quot;
 441                    % (self.reg[0], self.reg[1], self.immr, self.imms)))
 442 
 443     def astr(self):
 444         return (TwoRegInstruction.astr(self)
 445                 + (&quot;, #%s, #%s&quot;
 446                    % (self.immr, self.imms)))
 447 
 448     def generate(self):
 449         TwoRegInstruction.generate(self)
 450         self.immr = random.randint(0, 31)
 451         self.imms = random.randint(0, 31)
 452         return self
 453 
 454 class ExtractOp(ThreeRegInstruction):
 455 
 456     def generate(self):
 457         super(ExtractOp, self).generate()
 458         self.lsb = random.randint(0, (1&lt;&lt;5)-1 if self.isWord else (1&lt;&lt;6)-1)
 459         return self
 460 
 461     def cstr(self):
 462         return (ThreeRegInstruction.cstr(self)
 463                 + (&quot;, %s);&quot; % self.lsb))
 464     
 465     def astr(self):
 466         return (ThreeRegInstruction.astr(self)
 467                 + (&quot;, #%s&quot; % self.lsb))
 468     
 469 class CondBranchOp(MultiOp, Instruction):
 470 
 471     def cstr(self):
 472         return &quot;__ br(Assembler::&quot; + self.name() + &quot;, %s);&quot;
 473         
 474     def astr(self):
 475         return &quot;b.&quot; + self.name() + &quot;\t%s&quot;
 476 
 477 class ImmOp(Instruction):
 478 
 479     def cstr(self):
 480         return &quot;%s%s);&quot; % (Instruction.cstr(self), self.immed)
 481         
 482     def astr(self):
 483         return Instruction.astr(self) + &quot;#&quot; + str(self.immed)
 484         
 485     def generate(self):
 486         self.immed = random.randint(0, 1&lt;&lt;16 -1)
 487         return self
 488 
 489 class Op(Instruction):
 490 
 491     def cstr(self):
 492         return Instruction.cstr(self) + &quot;);&quot;
 493 
 494 class SystemOp(Instruction):
 495 
 496      def __init__(self, op):
 497           Instruction.__init__(self, op[0])
 498           self.barriers = op[1]
 499 
 500      def generate(self):
 501           Instruction.generate(self)
 502           self.barrier \
 503               = self.barriers[random.randint(0, len(self.barriers)-1)]
 504           return self
 505 
 506      def cstr(self):
 507           return Instruction.cstr(self) + &quot;Assembler::&quot; + self.barrier + &quot;);&quot;
 508 
 509      def astr(self):
 510           return Instruction.astr(self) + self.barrier
 511 
 512 conditionCodes = [&quot;EQ&quot;, &quot;NE&quot;, &quot;HS&quot;, &quot;CS&quot;, &quot;LO&quot;, &quot;CC&quot;, &quot;MI&quot;, &quot;PL&quot;, &quot;VS&quot;, \
 513                        &quot;VC&quot;, &quot;HI&quot;, &quot;LS&quot;, &quot;GE&quot;, &quot;LT&quot;, &quot;GT&quot;, &quot;LE&quot;, &quot;AL&quot;, &quot;NV&quot;]
 514 
 515 class ConditionalCompareOp(TwoRegImmedInstruction):
 516 
 517     def generate(self):
 518         TwoRegImmedInstruction.generate(self)
 519         self.cond = random.randint(0, 15)
 520         self.immed = random.randint(0, 15)
 521         return self
 522 
 523     def cstr(self):
 524         return (super(ConditionalCompareOp, self).cstr() + &quot;, &quot; 
 525                 + &quot;Assembler::&quot; + conditionCodes[self.cond] + &quot;);&quot;)
 526 
 527     def astr(self):
 528         return (super(ConditionalCompareOp, self).astr() + 
 529                  &quot;, &quot; + conditionCodes[self.cond])
 530 
 531 class ConditionalCompareImmedOp(Instruction):
 532 
 533     def generate(self):
 534         self.reg = GeneralRegister().generate()
 535         self.cond = random.randint(0, 15)
 536         self.immed2 = random.randint(0, 15)
 537         self.immed = random.randint(0, 31)
 538         return self
 539 
 540     def cstr(self):
 541         return (Instruction.cstr(self) + str(self.reg) + &quot;, &quot;
 542                 + str(self.immed) + &quot;, &quot;
 543                 + str(self.immed2) + &quot;, &quot;
 544                 + &quot;Assembler::&quot; + conditionCodes[self.cond] + &quot;);&quot;)
 545 
 546     def astr(self):
 547         return (Instruction.astr(self) 
 548                 + self.reg.astr(self.asmRegPrefix) 
 549                 + &quot;, #&quot; + str(self.immed)
 550                 + &quot;, #&quot; + str(self.immed2)
 551                 + &quot;, &quot; + conditionCodes[self.cond])
 552 
 553 class TwoRegOp(TwoRegInstruction):
 554     
 555     def cstr(self):
 556         return TwoRegInstruction.cstr(self) + &quot;);&quot;
 557 
 558 class ThreeRegOp(ThreeRegInstruction):
 559     
 560     def cstr(self):
 561         return ThreeRegInstruction.cstr(self) + &quot;);&quot;
 562 
 563 class FourRegMulOp(FourRegInstruction):
 564     
 565     def cstr(self):
 566         return FourRegInstruction.cstr(self) + &quot;);&quot;
 567 
 568     def astr(self):
 569         isMaddsub = self.name().startswith(&quot;madd&quot;) | self.name().startswith(&quot;msub&quot;)
 570         midPrefix = self.asmRegPrefix if isMaddsub else &quot;w&quot;
 571         return (Instruction.astr(self) 
 572                 + self.reg[0].astr(self.asmRegPrefix) 
 573                 + &quot;, &quot; + self.reg[1].astr(midPrefix) 
 574                 + &quot;, &quot; + self.reg[2].astr(midPrefix)
 575                 + &quot;, &quot; + self.reg[3].astr(self.asmRegPrefix))
 576 
 577 class ConditionalSelectOp(ThreeRegInstruction):
 578 
 579     def generate(self):
 580         ThreeRegInstruction.generate(self)
 581         self.cond = random.randint(0, 15)
 582         return self
 583 
 584     def cstr(self):
 585         return (ThreeRegInstruction.cstr(self) + &quot;, &quot;
 586                 + &quot;Assembler::&quot; + conditionCodes[self.cond] + &quot;);&quot;)
 587 
 588     def astr(self):
 589         return (ThreeRegInstruction.astr(self) 
 590                 + &quot;, &quot; + conditionCodes[self.cond])    
 591 
 592 class LoadStoreExclusiveOp(InstructionWithModes):
 593 
 594     def __init__(self, op): # op is a tuple of [&quot;name&quot;, &quot;mode&quot;, registers]
 595         InstructionWithModes.__init__(self, op[0], op[1])
 596         self.num_registers = op[2]
 597 
 598     def astr(self):
 599         result = self.aname() + &#39;\t&#39;
 600         regs = list(self.regs)
 601         index = regs.pop() # The last reg is the index register
 602         prefix = (&#39;x&#39; if (self.mode == &#39;x&#39;) 
 603                   &amp; ((self.name().startswith(&quot;ld&quot;))
 604                      | (self.name().startswith(&quot;stlr&quot;))) # Ewww :-(
 605                   else &#39;w&#39;)
 606         result = result + regs.pop(0).astr(prefix) + &quot;, &quot;
 607         for s in regs:
 608             result = result + s.astr(self.asmRegPrefix) + &quot;, &quot;
 609         result = result + &quot;[&quot; + index.astr(&quot;x&quot;) + &quot;]&quot;
 610         return result
 611 
 612     def cstr(self):
 613         result = InstructionWithModes.cstr(self)
 614         regs = list(self.regs)
 615         index = regs.pop() # The last reg is the index register
 616         for s in regs:
 617             result = result + str(s) + &quot;, &quot;
 618         result = result + str(index) + &quot;);&quot;
 619         return result
 620 
 621     def appendUniqueReg(self):
 622         result = 0
 623         while result == 0:
 624             newReg = GeneralRegister().generate()
 625             result = 1
 626             for i in self.regs:
 627                 result = result and (i.number != newReg.number)
 628         self.regs.append(newReg)
 629 
 630     def generate(self):
 631         self.regs = []
 632         for i in range(self.num_registers):
 633             self.appendUniqueReg()
 634         return self
 635 
 636     def name(self):
 637         if self.mode == &#39;x&#39;:
 638             return self._name
 639         else:
 640             return self._name + self.mode
 641 
 642     def aname(self):
 643         if (self.mode == &#39;b&#39;) | (self.mode == &#39;h&#39;):
 644             return self._name + self.mode
 645         else:
 646             return self._name
 647 
 648 class Address(object):
 649     
 650     base_plus_unscaled_offset, pre, post, base_plus_reg, \
 651         base_plus_scaled_offset, pcrel, post_reg, base_only = range(8)
 652     kinds = [&quot;base_plus_unscaled_offset&quot;, &quot;pre&quot;, &quot;post&quot;, &quot;base_plus_reg&quot;, 
 653              &quot;base_plus_scaled_offset&quot;, &quot;pcrel&quot;, &quot;post_reg&quot;, &quot;base_only&quot;]
 654     extend_kinds = [&quot;uxtw&quot;, &quot;lsl&quot;, &quot;sxtw&quot;, &quot;sxtx&quot;]
 655 
 656     @classmethod
 657     def kindToStr(cls, i):
 658          return cls.kinds[i]
 659     
 660     def generate(self, kind, shift_distance):
 661         self.kind = kind
 662         self.base = GeneralRegister().generate()
 663         self.index = GeneralRegister().generate()
 664         self.offset = {
 665             Address.base_plus_unscaled_offset: random.randint(-1&lt;&lt;8, 1&lt;&lt;8-1) | 1,
 666             Address.pre: random.randint(-1&lt;&lt;8, 1&lt;&lt;8-1),
 667             Address.post: random.randint(-1&lt;&lt;8, 1&lt;&lt;8-1),
 668             Address.pcrel: random.randint(0, 2),
 669             Address.base_plus_reg: 0,
 670             Address.base_plus_scaled_offset: (random.randint(0, 1&lt;&lt;11-1) | (3 &lt;&lt; 9))*8,
 671             Address.post_reg: 0,
 672             Address.base_only: 0} [kind]
 673         self.offset &gt;&gt;= (3 - shift_distance)
 674         self.extend_kind = Address.extend_kinds[random.randint(0, 3)]
 675         self.shift_distance = random.randint(0, 1) * shift_distance
 676         return self
 677 
 678     def __str__(self):
 679         result = {
 680             Address.base_plus_unscaled_offset: &quot;Address(%s, %s)&quot; \
 681                 % (str(self.base), self.offset),
 682             Address.pre: &quot;Address(__ pre(%s, %s))&quot; % (str(self.base), self.offset),
 683             Address.post: &quot;Address(__ post(%s, %s))&quot; % (str(self.base), self.offset),
 684             Address.post_reg: &quot;Address(__ post(%s, %s))&quot; % (str(self.base), self.index),
 685             Address.base_only: &quot;Address(%s)&quot; % (str(self.base)),
 686             Address.pcrel: &quot;&quot;,
 687             Address.base_plus_reg: &quot;Address(%s, %s, Address::%s(%s))&quot; \
 688                 % (self.base, self.index, self.extend_kind, self.shift_distance),
 689             Address.base_plus_scaled_offset: 
 690             &quot;Address(%s, %s)&quot; % (self.base, self.offset) } [self.kind]
 691         if (self.kind == Address.pcrel):
 692             result = [&quot;__ pc()&quot;, &quot;back&quot;, &quot;forth&quot;][self.offset]
 693         return result
 694 
 695     def astr(self, prefix):
 696         extend_prefix = prefix
 697         if self.kind == Address.base_plus_reg:
 698             if self.extend_kind.endswith(&quot;w&quot;):
 699                 extend_prefix = &quot;w&quot;
 700         result = {
 701             Address.base_plus_unscaled_offset: &quot;[%s, %s]&quot; \
 702                  % (self.base.astr(prefix), self.offset),
 703             Address.pre: &quot;[%s, %s]!&quot; % (self.base.astr(prefix), self.offset),
 704             Address.post: &quot;[%s], %s&quot; % (self.base.astr(prefix), self.offset),
 705             Address.post_reg: &quot;[%s], %s&quot; % (self.base.astr(prefix), self.index.astr(prefix)),
 706             Address.base_only: &quot;[%s]&quot; %  (self.base.astr(prefix)),
 707             Address.pcrel: &quot;&quot;,
 708             Address.base_plus_reg: &quot;[%s, %s, %s #%s]&quot; \
 709                 % (self.base.astr(prefix), self.index.astr(extend_prefix), 
 710                    self.extend_kind, self.shift_distance),
 711             Address.base_plus_scaled_offset: \
 712                 &quot;[%s, %s]&quot; \
 713                 % (self.base.astr(prefix), self.offset)
 714             } [self.kind]
 715         if (self.kind == Address.pcrel):
 716             result = [&quot;.&quot;, &quot;back&quot;, &quot;forth&quot;][self.offset]
 717         return result
 718         
 719 class LoadStoreOp(InstructionWithModes):
 720 
 721     def __init__(self, args):
 722         name, self.asmname, self.kind, mode = args
 723         InstructionWithModes.__init__(self, name, mode)
 724 
 725     def generate(self):
 726 
 727         # This is something of a kludge, but the offset needs to be
 728         # scaled by the memory datamode somehow.
 729         shift = 3
 730         if (self.mode == &#39;b&#39;) | (self.asmname.endswith(&quot;b&quot;)):
 731             shift = 0
 732         elif (self.mode == &#39;h&#39;) | (self.asmname.endswith(&quot;h&quot;)):
 733             shift = 1
 734         elif (self.mode == &#39;w&#39;) | (self.asmname.endswith(&quot;w&quot;)) \
 735                 | (self.mode == &#39;s&#39;) :
 736             shift = 2
 737 
 738         self.adr = Address().generate(self.kind, shift)
 739 
 740         isFloat = (self.mode == &#39;d&#39;) | (self.mode == &#39;s&#39;)
 741 
 742         regMode = FloatRegister if isFloat else GeneralRegister
 743         self.reg = regMode().generate()
 744         return self
 745 
 746     def cstr(self):
 747         if not(self._name.startswith(&quot;prfm&quot;)):
 748             return &quot;%s%s, %s);&quot; % (Instruction.cstr(self), str(self.reg), str(self.adr))
 749         else: # No target register for a prefetch
 750             return &quot;%s%s);&quot; % (Instruction.cstr(self), str(self.adr))
 751 
 752     def astr(self):
 753         if not(self._name.startswith(&quot;prfm&quot;)):
 754             return &quot;%s\t%s, %s&quot; % (self.aname(), self.reg.astr(self.asmRegPrefix),
 755                                      self.adr.astr(&quot;x&quot;))
 756         else: # No target register for a prefetch
 757             return &quot;%s %s&quot; % (self.aname(),
 758                                      self.adr.astr(&quot;x&quot;))
 759 
 760     def aname(self):
 761          result = self.asmname
 762          # if self.kind == Address.base_plus_unscaled_offset:
 763          #      result = result.replace(&quot;ld&quot;, &quot;ldu&quot;, 1)
 764          #      result = result.replace(&quot;st&quot;, &quot;stu&quot;, 1)
 765          return result
 766 
 767 class LoadStorePairOp(InstructionWithModes):
 768 
 769      numRegs = 2
 770      
 771      def __init__(self, args):
 772           name, self.asmname, self.kind, mode = args
 773           InstructionWithModes.__init__(self, name, mode)
 774           self.offset = random.randint(-1&lt;&lt;4, 1&lt;&lt;4-1) &lt;&lt; 4
 775           
 776      def generate(self):
 777           self.reg = [OperandFactory.create(self.mode).generate() 
 778                       for i in range(self.numRegs)]
 779           self.base = OperandFactory.create(&#39;x&#39;).generate()
 780           return self
 781 
 782      def astr(self):
 783           address = [&quot;[%s, #%s]&quot;, &quot;[%s, #%s]!&quot;, &quot;[%s], #%s&quot;][self.kind]
 784           address = address % (self.base.astr(&#39;x&#39;), self.offset)
 785           result = &quot;%s\t%s, %s, %s&quot; \
 786               % (self.asmname, 
 787                  self.reg[0].astr(self.asmRegPrefix), 
 788                  self.reg[1].astr(self.asmRegPrefix), address)
 789           return result
 790 
 791      def cstr(self):
 792           address = {
 793                Address.base_plus_unscaled_offset: &quot;Address(%s, %s)&quot; \
 794                     % (str(self.base), self.offset),
 795                Address.pre: &quot;Address(__ pre(%s, %s))&quot; % (str(self.base), self.offset),
 796                Address.post: &quot;Address(__ post(%s, %s))&quot; % (str(self.base), self.offset),
 797                } [self.kind]
 798           result = &quot;__ %s(%s, %s, %s);&quot; \
 799               % (self.name(), self.reg[0], self.reg[1], address)
 800           return result
 801 
 802 class FloatInstruction(Instruction):
 803 
 804     def aname(self):
 805         if (self._name.endswith(&quot;s&quot;) | self._name.endswith(&quot;d&quot;)):
 806             return self._name[:len(self._name)-1]
 807         else:
 808             return self._name
 809 
 810     def __init__(self, args):
 811         name, self.modes = args
 812         Instruction.__init__(self, name)
 813 
 814     def generate(self):
 815         self.reg = [OperandFactory.create(self.modes[i]).generate() 
 816                     for i in range(self.numRegs)]
 817         return self
 818 
 819     def cstr(self):
 820         formatStr = &quot;%s%s&quot; + &#39;&#39;.join([&quot;, %s&quot; for i in range(1, self.numRegs)] + [&quot;);&quot;])
 821         return (formatStr
 822                 % tuple([Instruction.cstr(self)] +
 823                         [str(self.reg[i]) for i in range(self.numRegs)])) # Yowza
 824     
 825     def astr(self):
 826         formatStr = &quot;%s%s&quot; + &#39;&#39;.join([&quot;, %s&quot; for i in range(1, self.numRegs)])
 827         return (formatStr
 828                 % tuple([Instruction.astr(self)] +
 829                         [(self.reg[i].astr(self.modes[i])) for i in range(self.numRegs)]))
 830 
 831 class LdStSIMDOp(Instruction):
 832     def __init__(self, args):
 833         self._name, self.regnum, self.arrangement, self.addresskind = args
 834 
 835     def generate(self):
 836         self.address = Address().generate(self.addresskind, 0)
 837         self._firstSIMDreg = FloatRegister().generate()
 838         if (self.addresskind  == Address.post):
 839             if (self._name in [&quot;ld1r&quot;, &quot;ld2r&quot;, &quot;ld3r&quot;, &quot;ld4r&quot;]):
 840                 elem_size = {&quot;8B&quot; : 1, &quot;16B&quot; : 1, &quot;4H&quot; : 2, &quot;8H&quot; : 2, &quot;2S&quot; : 4, &quot;4S&quot; : 4, &quot;1D&quot; : 8, &quot;2D&quot; : 8} [self.arrangement]
 841                 self.address.offset = self.regnum * elem_size
 842             else:
 843                 if (self.arrangement in [&quot;8B&quot;, &quot;4H&quot;, &quot;2S&quot;, &quot;1D&quot;]):
 844                     self.address.offset = self.regnum * 8
 845                 else:
 846                     self.address.offset = self.regnum * 16
 847         return self
 848 
 849     def cstr(self):
 850         buf = super(LdStSIMDOp, self).cstr() + str(self._firstSIMDreg)
 851         current = self._firstSIMDreg
 852         for cnt in range(1, self.regnum):
 853             buf = &#39;%s, %s&#39; % (buf, current.nextReg())
 854             current = current.nextReg()
 855         return &#39;%s, __ T%s, %s);&#39; % (buf, self.arrangement, str(self.address))
 856 
 857     def astr(self):
 858         buf = &#39;%s\t{%s.%s&#39; % (self._name, self._firstSIMDreg, self.arrangement)
 859         current = self._firstSIMDreg
 860         for cnt in range(1, self.regnum):
 861             buf = &#39;%s, %s.%s&#39; % (buf, current.nextReg(), self.arrangement)
 862             current = current.nextReg()
 863         return  &#39;%s}, %s&#39; % (buf, self.address.astr(&quot;x&quot;))
 864 
 865     def aname(self):
 866          return self._name
 867 
 868 class LSEOp(Instruction):
 869     def __init__(self, args):
 870         self._name, self.asmname, self.size, self.suffix = args
 871 
 872     def generate(self):
 873         self._name = &quot;%s%s&quot; % (self._name, self.suffix)
 874         self.asmname = &quot;%s%s&quot; % (self.asmname, self.suffix)
 875         self.srcReg = GeneralRegisterOrZr().generate()
 876         self.tgtReg = GeneralRegisterOrZr().generate()
 877         self.adrReg = GeneralRegisterOrSp().generate()
 878 
 879         return self
 880 
 881     def cstr(self):
 882         sizeSpec = {&quot;x&quot; : &quot;Assembler::xword&quot;, &quot;w&quot; : &quot;Assembler::word&quot;} [self.size]
 883         return super(LSEOp, self).cstr() + &quot;%s, %s, %s, %s);&quot; % (sizeSpec, self.srcReg, self.tgtReg, self.adrReg)
 884 
 885     def astr(self):
 886         return &quot;%s\t%s, %s, [%s]&quot; % (self.asmname, self.srcReg.astr(self.size), self.tgtReg.astr(self.size), self.adrReg.astr(&quot;x&quot;))
 887 
 888     def aname(self):
 889          return self.asmname
 890 
 891 class TwoRegFloatOp(FloatInstruction):
 892     numRegs = 2
 893 
 894 class ThreeRegFloatOp(TwoRegFloatOp):
 895     numRegs = 3
 896 
 897 class FourRegFloatOp(TwoRegFloatOp):
 898     numRegs = 4
 899 
 900 class FloatConvertOp(TwoRegFloatOp):
 901 
 902     def __init__(self, args):
 903         self._cname, self._aname, modes = args
 904         TwoRegFloatOp.__init__(self, [self._cname, modes])
 905 
 906     def aname(self):
 907         return self._aname
 908 
 909     def cname(self):
 910         return self._cname
 911 
 912 class SpecialCases(Instruction):
 913     def __init__(self, data):
 914         self._name = data[0]
 915         self._cstr = data[1]
 916         self._astr = data[2]
 917 
 918     def cstr(self):
 919         return self._cstr
 920 
 921     def astr(self):
 922         return self._astr
 923 
 924 def generate(kind, names):
 925     outfile.write(&quot;# &quot; + kind.__name__ + &quot;\n&quot;);
 926     print &quot;\n// &quot; + kind.__name__
 927     for name in names:
 928         for i in range(1):
 929              op = kind(name).generate()
 930              if op.multipleForms():
 931                   forms = op.forms()
 932                   aforms = op.aforms()
 933                   for i in range(op.multipleForms()):
 934                        cstr = op.cstr() % forms[i]
 935                        astr = op.astr() % aforms[i]
 936                        print &quot;    %-50s //\t%s&quot; % (cstr, astr)
 937                        outfile.write(&quot;\t&quot; + astr + &quot;\n&quot;)
 938              else:
 939                   print &quot;    %-50s //\t%s&quot; % (op.cstr(), op.astr())
 940                   outfile.write(&quot;\t&quot; + op.astr() + &quot;\n&quot;)
 941 
 942 outfile = open(&quot;aarch64ops.s&quot;, &quot;w&quot;)
 943 
 944 print &quot;// BEGIN  Generated code -- do not edit&quot;
 945 print &quot;// Generated by aarch64-asmtest.py&quot;
 946 
 947 print &quot;    Label back, forth;&quot;
 948 print &quot;    __ bind(back);&quot;
 949 
 950 outfile.write(&quot;back:\n&quot;)
 951 
 952 generate (ArithOp, 
 953           [ &quot;add&quot;, &quot;sub&quot;, &quot;adds&quot;, &quot;subs&quot;,
 954             &quot;addw&quot;, &quot;subw&quot;, &quot;addsw&quot;, &quot;subsw&quot;,
 955             &quot;and&quot;, &quot;orr&quot;, &quot;eor&quot;, &quot;ands&quot;,
 956             &quot;andw&quot;, &quot;orrw&quot;, &quot;eorw&quot;, &quot;andsw&quot;, 
 957             &quot;bic&quot;, &quot;orn&quot;, &quot;eon&quot;, &quot;bics&quot;, 
 958             &quot;bicw&quot;, &quot;ornw&quot;, &quot;eonw&quot;, &quot;bicsw&quot; ])
 959 
 960 generate (AddSubImmOp, 
 961           [ &quot;addw&quot;, &quot;addsw&quot;, &quot;subw&quot;, &quot;subsw&quot;,
 962             &quot;add&quot;, &quot;adds&quot;, &quot;sub&quot;, &quot;subs&quot;])
 963 generate (LogicalImmOp, 
 964           [ &quot;andw&quot;, &quot;orrw&quot;, &quot;eorw&quot;, &quot;andsw&quot;,
 965             &quot;and&quot;, &quot;orr&quot;, &quot;eor&quot;, &quot;ands&quot;])
 966 
 967 generate (AbsOp, [ &quot;b&quot;, &quot;bl&quot; ])
 968 
 969 generate (RegAndAbsOp, [&quot;cbzw&quot;, &quot;cbnzw&quot;, &quot;cbz&quot;, &quot;cbnz&quot;, &quot;adr&quot;, &quot;adrp&quot;])
 970 
 971 generate (RegImmAbsOp, [&quot;tbz&quot;, &quot;tbnz&quot;])
 972 
 973 generate (MoveWideImmOp, [&quot;movnw&quot;, &quot;movzw&quot;, &quot;movkw&quot;, &quot;movn&quot;, &quot;movz&quot;, &quot;movk&quot;])
 974 
 975 generate (BitfieldOp, [&quot;sbfm&quot;, &quot;bfmw&quot;, &quot;ubfmw&quot;, &quot;sbfm&quot;, &quot;bfm&quot;, &quot;ubfm&quot;])
 976 
 977 generate (ExtractOp, [&quot;extrw&quot;, &quot;extr&quot;])
 978 
 979 generate (CondBranchOp, [&quot;EQ&quot;, &quot;NE&quot;, &quot;HS&quot;, &quot;CS&quot;, &quot;LO&quot;, &quot;CC&quot;, &quot;MI&quot;, &quot;PL&quot;, &quot;VS&quot;, &quot;VC&quot;,
 980                         &quot;HI&quot;, &quot;LS&quot;, &quot;GE&quot;, &quot;LT&quot;, &quot;GT&quot;, &quot;LE&quot;, &quot;AL&quot;, &quot;NV&quot; ])
 981 
 982 generate (ImmOp, [&quot;svc&quot;, &quot;hvc&quot;, &quot;smc&quot;, &quot;brk&quot;, &quot;hlt&quot;, # &quot;dpcs1&quot;,  &quot;dpcs2&quot;,  &quot;dpcs3&quot;
 983                ])
 984 
 985 generate (Op, [&quot;nop&quot;, &quot;eret&quot;, &quot;drps&quot;, &quot;isb&quot;])
 986 
 987 barriers = [&quot;OSHLD&quot;, &quot;OSHST&quot;, &quot;OSH&quot;, &quot;NSHLD&quot;, &quot;NSHST&quot;, &quot;NSH&quot;,
 988             &quot;ISHLD&quot;, &quot;ISHST&quot;, &quot;ISH&quot;, &quot;LD&quot;, &quot;ST&quot;, &quot;SY&quot;]
 989 
 990 generate (SystemOp, [[&quot;dsb&quot;, barriers], [&quot;dmb&quot;, barriers]])
 991 
 992 generate (OneRegOp, [&quot;br&quot;, &quot;blr&quot;])
 993 
 994 for mode in &#39;xwhb&#39;:
 995     generate (LoadStoreExclusiveOp, [[&quot;stxr&quot;, mode, 3], [&quot;stlxr&quot;, mode, 3],
 996                                      [&quot;ldxr&quot;, mode, 2], [&quot;ldaxr&quot;, mode, 2],
 997                                      [&quot;stlr&quot;, mode, 2], [&quot;ldar&quot;, mode, 2]])
 998 
 999 for mode in &#39;xw&#39;:
1000     generate (LoadStoreExclusiveOp, [[&quot;ldxp&quot;, mode, 3], [&quot;ldaxp&quot;, mode, 3],
1001                                      [&quot;stxp&quot;, mode, 4], [&quot;stlxp&quot;, mode, 4]])
1002 
1003 for kind in range(6):
1004     print &quot;\n// &quot; + Address.kindToStr(kind),
1005     if kind != Address.pcrel:
1006         generate (LoadStoreOp, 
1007                   [[&quot;str&quot;, &quot;str&quot;, kind, &quot;x&quot;], [&quot;str&quot;, &quot;str&quot;, kind, &quot;w&quot;], 
1008                    [&quot;str&quot;, &quot;strb&quot;, kind, &quot;b&quot;], [&quot;str&quot;, &quot;strh&quot;, kind, &quot;h&quot;],
1009                    [&quot;ldr&quot;, &quot;ldr&quot;, kind, &quot;x&quot;], [&quot;ldr&quot;, &quot;ldr&quot;, kind, &quot;w&quot;], 
1010                    [&quot;ldr&quot;, &quot;ldrb&quot;, kind, &quot;b&quot;], [&quot;ldr&quot;, &quot;ldrh&quot;, kind, &quot;h&quot;],
1011                    [&quot;ldrsb&quot;, &quot;ldrsb&quot;, kind, &quot;x&quot;], [&quot;ldrsh&quot;, &quot;ldrsh&quot;, kind, &quot;x&quot;], 
1012                    [&quot;ldrsh&quot;, &quot;ldrsh&quot;, kind, &quot;w&quot;], [&quot;ldrsw&quot;, &quot;ldrsw&quot;, kind, &quot;x&quot;],
1013                    [&quot;ldr&quot;, &quot;ldr&quot;, kind, &quot;d&quot;], [&quot;ldr&quot;, &quot;ldr&quot;, kind, &quot;s&quot;], 
1014                    [&quot;str&quot;, &quot;str&quot;, kind, &quot;d&quot;], [&quot;str&quot;, &quot;str&quot;, kind, &quot;s&quot;], 
1015                    ])
1016     else:
1017         generate (LoadStoreOp, 
1018                   [[&quot;ldr&quot;, &quot;ldr&quot;, kind, &quot;x&quot;], [&quot;ldr&quot;, &quot;ldr&quot;, kind, &quot;w&quot;]])
1019         
1020 
1021 for kind in (Address.base_plus_unscaled_offset, Address.pcrel, Address.base_plus_reg, \
1022                  Address.base_plus_scaled_offset):
1023     generate (LoadStoreOp, 
1024               [[&quot;prfm&quot;, &quot;prfm\tPLDL1KEEP,&quot;, kind, &quot;x&quot;]])
1025 
1026 generate(AddSubCarryOp, [&quot;adcw&quot;, &quot;adcsw&quot;, &quot;sbcw&quot;, &quot;sbcsw&quot;, &quot;adc&quot;, &quot;adcs&quot;, &quot;sbc&quot;, &quot;sbcs&quot;])
1027 
1028 generate(AddSubExtendedOp, [&quot;addw&quot;, &quot;addsw&quot;, &quot;sub&quot;, &quot;subsw&quot;, &quot;add&quot;, &quot;adds&quot;, &quot;sub&quot;, &quot;subs&quot;])
1029 
1030 generate(ConditionalCompareOp, [&quot;ccmnw&quot;, &quot;ccmpw&quot;, &quot;ccmn&quot;, &quot;ccmp&quot;])
1031 generate(ConditionalCompareImmedOp, [&quot;ccmnw&quot;, &quot;ccmpw&quot;, &quot;ccmn&quot;, &quot;ccmp&quot;])
1032 generate(ConditionalSelectOp, 
1033          [&quot;cselw&quot;, &quot;csincw&quot;, &quot;csinvw&quot;, &quot;csnegw&quot;, &quot;csel&quot;, &quot;csinc&quot;, &quot;csinv&quot;, &quot;csneg&quot;])
1034 
1035 generate(TwoRegOp, 
1036          [&quot;rbitw&quot;, &quot;rev16w&quot;, &quot;revw&quot;, &quot;clzw&quot;, &quot;clsw&quot;, &quot;rbit&quot;, 
1037           &quot;rev16&quot;, &quot;rev32&quot;, &quot;rev&quot;, &quot;clz&quot;, &quot;cls&quot;])
1038 generate(ThreeRegOp, 
1039          [&quot;udivw&quot;, &quot;sdivw&quot;, &quot;lslvw&quot;, &quot;lsrvw&quot;, &quot;asrvw&quot;, &quot;rorvw&quot;, &quot;udiv&quot;, &quot;sdiv&quot;, 
1040           &quot;lslv&quot;, &quot;lsrv&quot;, &quot;asrv&quot;, &quot;rorv&quot;, &quot;umulh&quot;, &quot;smulh&quot;])
1041 generate(FourRegMulOp, 
1042          [&quot;maddw&quot;, &quot;msubw&quot;, &quot;madd&quot;, &quot;msub&quot;, &quot;smaddl&quot;, &quot;smsubl&quot;, &quot;umaddl&quot;, &quot;umsubl&quot;])
1043 
1044 generate(ThreeRegFloatOp, 
1045          [[&quot;fmuls&quot;, &quot;sss&quot;], [&quot;fdivs&quot;, &quot;sss&quot;], [&quot;fadds&quot;, &quot;sss&quot;], [&quot;fsubs&quot;, &quot;sss&quot;], 
1046           [&quot;fmuls&quot;, &quot;sss&quot;],
1047           [&quot;fmuld&quot;, &quot;ddd&quot;], [&quot;fdivd&quot;, &quot;ddd&quot;], [&quot;faddd&quot;, &quot;ddd&quot;], [&quot;fsubd&quot;, &quot;ddd&quot;], 
1048           [&quot;fmuld&quot;, &quot;ddd&quot;]])
1049 
1050 generate(FourRegFloatOp, 
1051          [[&quot;fmadds&quot;, &quot;ssss&quot;], [&quot;fmsubs&quot;, &quot;ssss&quot;], [&quot;fnmadds&quot;, &quot;ssss&quot;], [&quot;fnmadds&quot;, &quot;ssss&quot;], 
1052           [&quot;fmaddd&quot;, &quot;dddd&quot;], [&quot;fmsubd&quot;, &quot;dddd&quot;], [&quot;fnmaddd&quot;, &quot;dddd&quot;], [&quot;fnmaddd&quot;, &quot;dddd&quot;],])
1053 
1054 generate(TwoRegFloatOp, 
1055          [[&quot;fmovs&quot;, &quot;ss&quot;], [&quot;fabss&quot;, &quot;ss&quot;], [&quot;fnegs&quot;, &quot;ss&quot;], [&quot;fsqrts&quot;, &quot;ss&quot;], 
1056           [&quot;fcvts&quot;, &quot;ds&quot;],
1057           [&quot;fmovd&quot;, &quot;dd&quot;], [&quot;fabsd&quot;, &quot;dd&quot;], [&quot;fnegd&quot;, &quot;dd&quot;], [&quot;fsqrtd&quot;, &quot;dd&quot;], 
1058           [&quot;fcvtd&quot;, &quot;sd&quot;],
1059           ])
1060 
1061 generate(FloatConvertOp, [[&quot;fcvtzsw&quot;, &quot;fcvtzs&quot;, &quot;ws&quot;], [&quot;fcvtzs&quot;, &quot;fcvtzs&quot;, &quot;xs&quot;],
1062                           [&quot;fcvtzdw&quot;, &quot;fcvtzs&quot;, &quot;wd&quot;], [&quot;fcvtzd&quot;, &quot;fcvtzs&quot;, &quot;xd&quot;],
1063                           [&quot;scvtfws&quot;, &quot;scvtf&quot;, &quot;sw&quot;], [&quot;scvtfs&quot;, &quot;scvtf&quot;, &quot;sx&quot;],
1064                           [&quot;scvtfwd&quot;, &quot;scvtf&quot;, &quot;dw&quot;], [&quot;scvtfd&quot;, &quot;scvtf&quot;, &quot;dx&quot;],
1065                           [&quot;fmovs&quot;, &quot;fmov&quot;, &quot;ws&quot;], [&quot;fmovd&quot;, &quot;fmov&quot;, &quot;xd&quot;],
1066                           [&quot;fmovs&quot;, &quot;fmov&quot;, &quot;sw&quot;], [&quot;fmovd&quot;, &quot;fmov&quot;, &quot;dx&quot;]])
1067 
1068 generate(TwoRegFloatOp, [[&quot;fcmps&quot;, &quot;ss&quot;], [&quot;fcmpd&quot;, &quot;dd&quot;], 
1069                          [&quot;fcmps&quot;, &quot;sz&quot;], [&quot;fcmpd&quot;, &quot;dz&quot;]])
1070 
1071 for kind in range(3):
1072      generate(LoadStorePairOp, [[&quot;stp&quot;, &quot;stp&quot;, kind, &quot;w&quot;], [&quot;ldp&quot;, &quot;ldp&quot;, kind, &quot;w&quot;],
1073                                 [&quot;ldpsw&quot;, &quot;ldpsw&quot;, kind, &quot;x&quot;], 
1074                                 [&quot;stp&quot;, &quot;stp&quot;, kind, &quot;x&quot;], [&quot;ldp&quot;, &quot;ldp&quot;, kind, &quot;x&quot;]
1075                                 ])
1076 generate(LoadStorePairOp, [[&quot;stnp&quot;, &quot;stnp&quot;, 0, &quot;w&quot;], [&quot;ldnp&quot;, &quot;ldnp&quot;, 0, &quot;w&quot;],
1077                            [&quot;stnp&quot;, &quot;stnp&quot;, 0, &quot;x&quot;], [&quot;ldnp&quot;, &quot;ldnp&quot;, 0, &quot;x&quot;]])
1078 
1079 generate(LdStSIMDOp, [[&quot;ld1&quot;,  1, &quot;8B&quot;,  Address.base_only],
1080                       [&quot;ld1&quot;,  2, &quot;16B&quot;, Address.post],
1081                       [&quot;ld1&quot;,  3, &quot;1D&quot;,  Address.post_reg],
1082                       [&quot;ld1&quot;,  4, &quot;8H&quot;,  Address.post],
1083                       [&quot;ld1r&quot;, 1, &quot;8B&quot;,  Address.base_only],
1084                       [&quot;ld1r&quot;, 1, &quot;4S&quot;,  Address.post],
1085                       [&quot;ld1r&quot;, 1, &quot;1D&quot;,  Address.post_reg],
1086                       [&quot;ld2&quot;,  2, &quot;2D&quot;,  Address.base_only],
1087                       [&quot;ld2&quot;,  2, &quot;4H&quot;,  Address.post],
1088                       [&quot;ld2r&quot;, 2, &quot;16B&quot;, Address.base_only],
1089                       [&quot;ld2r&quot;, 2, &quot;2S&quot;,  Address.post],
1090                       [&quot;ld2r&quot;, 2, &quot;2D&quot;,  Address.post_reg],
1091                       [&quot;ld3&quot;,  3, &quot;4S&quot;,  Address.post_reg],
1092                       [&quot;ld3&quot;,  3, &quot;2S&quot;,  Address.base_only],
1093                       [&quot;ld3r&quot;, 3, &quot;8H&quot;,  Address.base_only],
1094                       [&quot;ld3r&quot;, 3, &quot;4S&quot;,  Address.post],
1095                       [&quot;ld3r&quot;, 3, &quot;1D&quot;,  Address.post_reg],
1096                       [&quot;ld4&quot;,  4, &quot;8H&quot;,  Address.post],
1097                       [&quot;ld4&quot;,  4, &quot;8B&quot;,  Address.post_reg],
1098                       [&quot;ld4r&quot;, 4, &quot;8B&quot;,  Address.base_only],
1099                       [&quot;ld4r&quot;, 4, &quot;4H&quot;,  Address.post],
1100                       [&quot;ld4r&quot;, 4, &quot;2S&quot;,  Address.post_reg],
1101 ])
1102 
1103 generate(SpecialCases, [[&quot;ccmn&quot;,   &quot;__ ccmn(zr, zr, 3u, Assembler::LE);&quot;,                &quot;ccmn\txzr, xzr, #3, LE&quot;],
1104                         [&quot;ccmnw&quot;,  &quot;__ ccmnw(zr, zr, 5u, Assembler::EQ);&quot;,               &quot;ccmn\twzr, wzr, #5, EQ&quot;],
1105                         [&quot;ccmp&quot;,   &quot;__ ccmp(zr, 1, 4u, Assembler::NE);&quot;,                 &quot;ccmp\txzr, 1, #4, NE&quot;],
1106                         [&quot;ccmpw&quot;,  &quot;__ ccmpw(zr, 2, 2, Assembler::GT);&quot;,                 &quot;ccmp\twzr, 2, #2, GT&quot;],
1107                         [&quot;extr&quot;,   &quot;__ extr(zr, zr, zr, 0);&quot;,                            &quot;extr\txzr, xzr, xzr, 0&quot;],
1108                         [&quot;stlxp&quot;,  &quot;__ stlxp(r0, zr, zr, sp);&quot;,                          &quot;stlxp\tw0, xzr, xzr, [sp]&quot;],
1109                         [&quot;stlxpw&quot;, &quot;__ stlxpw(r2, zr, zr, r3);&quot;,                         &quot;stlxp\tw2, wzr, wzr, [x3]&quot;],
1110                         [&quot;stxp&quot;,   &quot;__ stxp(r4, zr, zr, r5);&quot;,                           &quot;stxp\tw4, xzr, xzr, [x5]&quot;],
1111                         [&quot;stxpw&quot;,  &quot;__ stxpw(r6, zr, zr, sp);&quot;,                          &quot;stxp\tw6, wzr, wzr, [sp]&quot;],
1112                         [&quot;dup&quot;,    &quot;__ dup(v0, __ T16B, zr);&quot;,                           &quot;dup\tv0.16b, wzr&quot;],
1113                         [&quot;mov&quot;,    &quot;__ mov(v1, __ T1D, 0, zr);&quot;,                         &quot;mov\tv1.d[0], xzr&quot;],
1114                         [&quot;mov&quot;,    &quot;__ mov(v1, __ T2S, 1, zr);&quot;,                         &quot;mov\tv1.s[1], wzr&quot;],
1115                         [&quot;mov&quot;,    &quot;__ mov(v1, __ T4H, 2, zr);&quot;,                         &quot;mov\tv1.h[2], wzr&quot;],
1116                         [&quot;mov&quot;,    &quot;__ mov(v1, __ T8B, 3, zr);&quot;,                         &quot;mov\tv1.b[3], wzr&quot;],
1117                         [&quot;ld1&quot;,    &quot;__ ld1(v31, v0, __ T2D, Address(__ post(r1, r0)));&quot;, &quot;ld1\t{v31.2d, v0.2d}, [x1], x0&quot;]])
1118 
1119 print &quot;\n// FloatImmediateOp&quot;
1120 for float in (&quot;2.0&quot;, &quot;2.125&quot;, &quot;4.0&quot;, &quot;4.25&quot;, &quot;8.0&quot;, &quot;8.5&quot;, &quot;16.0&quot;, &quot;17.0&quot;, &quot;0.125&quot;, 
1121               &quot;0.1328125&quot;, &quot;0.25&quot;, &quot;0.265625&quot;, &quot;0.5&quot;, &quot;0.53125&quot;, &quot;1.0&quot;, &quot;1.0625&quot;, 
1122               &quot;-2.0&quot;, &quot;-2.125&quot;, &quot;-4.0&quot;, &quot;-4.25&quot;, &quot;-8.0&quot;, &quot;-8.5&quot;, &quot;-16.0&quot;, &quot;-17.0&quot;, 
1123               &quot;-0.125&quot;, &quot;-0.1328125&quot;, &quot;-0.25&quot;, &quot;-0.265625&quot;, &quot;-0.5&quot;, &quot;-0.53125&quot;, &quot;-1.0&quot;, &quot;-1.0625&quot;):
1124     astr = &quot;fmov d0, #&quot; + float
1125     cstr = &quot;__ fmovd(v0, &quot; + float + &quot;);&quot;
1126     print &quot;    %-50s //\t%s&quot; % (cstr, astr)
1127     outfile.write(&quot;\t&quot; + astr + &quot;\n&quot;)
1128 
1129 # ARMv8.1A
1130 for size in (&quot;x&quot;, &quot;w&quot;):
1131     for suffix in (&quot;&quot;, &quot;a&quot;, &quot;al&quot;, &quot;l&quot;):
1132         generate(LSEOp, [[&quot;swp&quot;, &quot;swp&quot;, size, suffix],
1133                          [&quot;ldadd&quot;, &quot;ldadd&quot;, size, suffix],
1134                          [&quot;ldbic&quot;, &quot;ldclr&quot;, size, suffix],
1135                          [&quot;ldeor&quot;, &quot;ldeor&quot;, size, suffix],
1136                          [&quot;ldorr&quot;, &quot;ldset&quot;, size, suffix],
1137                          [&quot;ldsmin&quot;, &quot;ldsmin&quot;, size, suffix],
1138                          [&quot;ldsmax&quot;, &quot;ldsmax&quot;, size, suffix],
1139                          [&quot;ldumin&quot;, &quot;ldumin&quot;, size, suffix],
1140                          [&quot;ldumax&quot;, &quot;ldumax&quot;, size, suffix]]);
1141 
1142 print &quot;\n    __ bind(forth);&quot;
1143 outfile.write(&quot;forth:\n&quot;)
1144 
1145 outfile.close()
1146 
1147 import subprocess
1148 import sys
1149 
1150 # compile for 8.1 because of lse atomics
1151 subprocess.check_call([AARCH64_AS, &quot;-march=armv8.1-a&quot;, &quot;aarch64ops.s&quot;, &quot;-o&quot;, &quot;aarch64ops.o&quot;])
1152 
1153 print
1154 print &quot;/*&quot;,
1155 sys.stdout.flush()
1156 subprocess.check_call([AARCH64_OBJDUMP, &quot;-d&quot;, &quot;aarch64ops.o&quot;])
1157 print &quot;*/&quot;
1158 
1159 subprocess.check_call([AARCH64_OBJCOPY, &quot;-O&quot;, &quot;binary&quot;, &quot;-j&quot;, &quot;.text&quot;, &quot;aarch64ops.o&quot;, &quot;aarch64ops.bin&quot;])
1160 
1161 infile = open(&quot;aarch64ops.bin&quot;, &quot;r&quot;)
1162 bytes = bytearray(infile.read())
1163 
1164 print
1165 print &quot;  static const unsigned int insns[] =&quot;
1166 print &quot;  {&quot;
1167 
1168 i = 0
1169 while i &lt; len(bytes):
1170      print &quot;    0x%02x%02x%02x%02x,&quot; % (bytes[i+3], bytes[i+2], bytes[i+1], bytes[i]),
1171      i += 4
1172      if i%16 == 0:
1173           print
1174 print &quot;\n  };&quot;
1175 print &quot;// END  Generated code -- do not edit&quot;
1176 
1177 
    </pre>
  </body>
</html>
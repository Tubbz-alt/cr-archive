<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/aarch64_ad.m4</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="aarch64Test.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="abstractInterpreter_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64_ad.m4</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 152,18 ***</span>
  // Shift Left followed by Shift Right.
  // This idiom is used by the compiler for the i2b bytecode etc.
  instruct $4$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src, immI lshift_count, immI rshift_count)
  %{
    match(Set dst EXTEND($1, $3, src, lshift_count, rshift_count));
<span class="line-removed">-   // Make sure we are not going to exceed what $4 can do.</span>
<span class="line-removed">-   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= $2</span>
<span class="line-removed">-             &amp;&amp; (unsigned int)n-&gt;in(1)-&gt;in(2)-&gt;get_int() &lt;= $2);</span>
<span class="line-removed">- </span>
    ins_cost(INSN_COST * 2);
    format %{ &quot;$4  $dst, $src, $rshift_count - $lshift_count, #$2 - $lshift_count&quot; %}
    ins_encode %{
<span class="line-modified">!     int lshift = $lshift_count$$constant, rshift = $rshift_count$$constant;</span>
      int s = $2 - lshift;
      int r = (rshift - lshift) &amp; $2;
      __ $4(as_Register($dst$$reg),
              as_Register($src$$reg),
              r, s);
<span class="line-new-header">--- 152,15 ---</span>
  // Shift Left followed by Shift Right.
  // This idiom is used by the compiler for the i2b bytecode etc.
  instruct $4$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src, immI lshift_count, immI rshift_count)
  %{
    match(Set dst EXTEND($1, $3, src, lshift_count, rshift_count));
    ins_cost(INSN_COST * 2);
    format %{ &quot;$4  $dst, $src, $rshift_count - $lshift_count, #$2 - $lshift_count&quot; %}
    ins_encode %{
<span class="line-modified">!     int lshift = $lshift_count$$constant &amp; $2;</span>
<span class="line-added">+     int rshift = $rshift_count$$constant &amp; $2;</span>
      int s = $2 - lshift;
      int r = (rshift - lshift) &amp; $2;
      __ $4(as_Register($dst$$reg),
              as_Register($src$$reg),
              r, s);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 179,35 ***</span>
  // Bitfield extract with shift &amp; mask
  define(`BFX_INSN&#39;,
  `instruct $3$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src, immI rshift, imm$1_bitmask mask)
  %{
    match(Set dst (And$1 ($2$1 src rshift) mask));
  
    ins_cost(INSN_COST);
    format %{ &quot;$3 $dst, $src, $rshift, $mask&quot; %}
    ins_encode %{
<span class="line-modified">!     int rshift = $rshift$$constant;</span>
      long mask = $mask$$constant;
<span class="line-modified">!     int width = exact_log2(mask+1);</span>
      __ $3(as_Register($dst$$reg),
              as_Register($src$$reg), rshift, width);
    %}
    ins_pipe(ialu_reg_shift);
  %}&#39;)
<span class="line-modified">! BFX_INSN(I,URShift,ubfxw)</span>
<span class="line-modified">! BFX_INSN(L,URShift,ubfx)</span>
  
  // We can use ubfx when extending an And with a mask when we know mask
  // is positive.  We know that because immI_bitmask guarantees it.
  instruct ubfxIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
  %{
    match(Set dst (ConvI2L (AndI (URShiftI src rshift) mask)));
  
    ins_cost(INSN_COST * 2);
    format %{ &quot;ubfx $dst, $src, $rshift, $mask&quot; %}
    ins_encode %{
<span class="line-modified">!     int rshift = $rshift$$constant;</span>
      long mask = $mask$$constant;
      int width = exact_log2(mask+1);
      __ ubfx(as_Register($dst$$reg),
              as_Register($src$$reg), rshift, width);
    %}
<span class="line-new-header">--- 176,39 ---</span>
  // Bitfield extract with shift &amp; mask
  define(`BFX_INSN&#39;,
  `instruct $3$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src, immI rshift, imm$1_bitmask mask)
  %{
    match(Set dst (And$1 ($2$1 src rshift) mask));
<span class="line-added">+   // Make sure we are not going to exceed what $3 can do.</span>
<span class="line-added">+   predicate((exact_log2$6(n-&gt;in(2)-&gt;get_$5() + 1) + (n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; $4)) &lt;= ($4 + 1));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;$3 $dst, $src, $rshift, $mask&quot; %}
    ins_encode %{
<span class="line-modified">!     int rshift = $rshift$$constant &amp; $4;</span>
      long mask = $mask$$constant;
<span class="line-modified">!     int width = exact_log2$6(mask+1);</span>
      __ $3(as_Register($dst$$reg),
              as_Register($src$$reg), rshift, width);
    %}
    ins_pipe(ialu_reg_shift);
  %}&#39;)
<span class="line-modified">! BFX_INSN(I, URShift, ubfxw, 31, int)</span>
<span class="line-modified">! BFX_INSN(L, URShift, ubfx,  63, long, _long)</span>
  
  // We can use ubfx when extending an And with a mask when we know mask
  // is positive.  We know that because immI_bitmask guarantees it.
  instruct ubfxIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
  %{
    match(Set dst (ConvI2L (AndI (URShiftI src rshift) mask)));
<span class="line-added">+   // Make sure we are not going to exceed what ubfxw can do.</span>
<span class="line-added">+   predicate((exact_log2(n-&gt;in(1)-&gt;in(2)-&gt;get_int() + 1) + (n-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 31)) &lt;= (31 + 1));</span>
  
    ins_cost(INSN_COST * 2);
    format %{ &quot;ubfx $dst, $src, $rshift, $mask&quot; %}
    ins_encode %{
<span class="line-modified">!     int rshift = $rshift$$constant &amp; 31;</span>
      long mask = $mask$$constant;
      int width = exact_log2(mask+1);
      __ ubfx(as_Register($dst$$reg),
              as_Register($src$$reg), rshift, width);
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 218,38 ***</span>
  // We can use ubfiz when masking by a positive number and then left shifting the result.
  // We know that the mask is positive because imm$1_bitmask guarantees it.
  `instruct $2$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src, immI lshift, imm$1_bitmask mask)
  %{
    match(Set dst (LShift$1 (And$1 src mask) lshift));
<span class="line-modified">!   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= $3 &amp;&amp;</span>
<span class="line-removed">-     (exact_log2$5(n-&gt;in(1)-&gt;in(2)-&gt;get_$4()+1) + (unsigned int)n-&gt;in(2)-&gt;get_int()) &lt;= ($3+1));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;$2 $dst, $src, $lshift, $mask&quot; %}
    ins_encode %{
<span class="line-modified">!     int lshift = $lshift$$constant;</span>
      long mask = $mask$$constant;
<span class="line-modified">!     int width = exact_log2(mask+1);</span>
      __ $2(as_Register($dst$$reg),
            as_Register($src$$reg), lshift, width);
    %}
    ins_pipe(ialu_reg_shift);
  %}&#39;)
  UBFIZ_INSN(I, ubfizw, 31, int)
<span class="line-modified">! UBFIZ_INSN(L, ubfiz, 63, long, _long)</span>
  
  // If there is a convert I to L block between and AndI and a LShiftL, we can also match ubfiz
  instruct ubfizIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
  %{
<span class="line-modified">!   match(Set dst (LShiftL (ConvI2L(AndI src mask)) lshift));</span>
<span class="line-modified">!   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 31 &amp;&amp;</span>
<span class="line-removed">-     (exact_log2((unsigned int)n-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;get_int()+1) + (unsigned int)n-&gt;in(2)-&gt;get_int()) &lt;= 32);</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;ubfiz $dst, $src, $lshift, $mask&quot; %}
    ins_encode %{
<span class="line-modified">!     int lshift = $lshift$$constant;</span>
      long mask = $mask$$constant;
      int width = exact_log2(mask+1);
      __ ubfiz(as_Register($dst$$reg),
               as_Register($src$$reg), lshift, width);
    %}
<span class="line-new-header">--- 219,36 ---</span>
  // We can use ubfiz when masking by a positive number and then left shifting the result.
  // We know that the mask is positive because imm$1_bitmask guarantees it.
  `instruct $2$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src, immI lshift, imm$1_bitmask mask)
  %{
    match(Set dst (LShift$1 (And$1 src mask) lshift));
<span class="line-modified">!   predicate((exact_log2$5(n-&gt;in(1)-&gt;in(2)-&gt;get_$4() + 1) + (n-&gt;in(2)-&gt;get_int() &amp; $3)) &lt;= ($3 + 1));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;$2 $dst, $src, $lshift, $mask&quot; %}
    ins_encode %{
<span class="line-modified">!     int lshift = $lshift$$constant &amp; $3;</span>
      long mask = $mask$$constant;
<span class="line-modified">!     int width = exact_log2$5(mask+1);</span>
      __ $2(as_Register($dst$$reg),
            as_Register($src$$reg), lshift, width);
    %}
    ins_pipe(ialu_reg_shift);
  %}&#39;)
  UBFIZ_INSN(I, ubfizw, 31, int)
<span class="line-modified">! UBFIZ_INSN(L, ubfiz,  63, long, _long)</span>
  
  // If there is a convert I to L block between and AndI and a LShiftL, we can also match ubfiz
  instruct ubfizIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
  %{
<span class="line-modified">!   match(Set dst (LShiftL (ConvI2L (AndI src mask)) lshift));</span>
<span class="line-modified">!   predicate((exact_log2(n-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;get_int() + 1) + (n-&gt;in(2)-&gt;get_int() &amp; 63)) &lt;= (63 + 1));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;ubfiz $dst, $src, $lshift, $mask&quot; %}
    ins_encode %{
<span class="line-modified">!     int lshift = $lshift$$constant &amp; 63;</span>
      long mask = $mask$$constant;
      int width = exact_log2(mask+1);
      __ ubfiz(as_Register($dst$$reg),
               as_Register($src$$reg), lshift, width);
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 260,11 ***</span>
  
  define(`EXTRACT_INSN&#39;,
  `instruct extr$3$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src1, iReg$1`&#39;ORL2I($1) src2, immI lshift, immI rshift, rFlagsReg cr)
  %{
    match(Set dst ($3$1 (LShift$1 src1 lshift) (URShift$1 src2 rshift)));
<span class="line-modified">!   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; $2));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
  
    ins_encode %{
<span class="line-new-header">--- 259,11 ---</span>
  
  define(`EXTRACT_INSN&#39;,
  `instruct extr$3$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src1, iReg$1`&#39;ORL2I($1) src2, immI lshift, immI rshift, rFlagsReg cr)
  %{
    match(Set dst ($3$1 (LShift$1 src1 lshift) (URShift$1 src2 rshift)));
<span class="line-modified">!   predicate(0 == (((n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; $2) + (n-&gt;in(2)-&gt;in(2)-&gt;get_int() &amp; $2)) &amp; $2));</span>
  
    ins_cost(INSN_COST);
    format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
  
    ins_encode %{
</pre>
<center><a href="aarch64Test.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="abstractInterpreter_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
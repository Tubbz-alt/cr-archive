<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubRoutines_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  32 #include &quot;interpreter/interp_masm.hpp&quot;
  33 #include &quot;interpreter/templateInterpreterGenerator.hpp&quot;
  34 #include &quot;interpreter/templateTable.hpp&quot;
  35 #include &quot;interpreter/bytecodeTracer.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/arrayOop.hpp&quot;
  38 #include &quot;oops/methodData.hpp&quot;
  39 #include &quot;oops/method.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;prims/jvmtiExport.hpp&quot;
  42 #include &quot;prims/jvmtiThreadState.hpp&quot;
  43 #include &quot;runtime/arguments.hpp&quot;
  44 #include &quot;runtime/deoptimization.hpp&quot;
  45 #include &quot;runtime/frame.inline.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;runtime/stubRoutines.hpp&quot;
  48 #include &quot;runtime/synchronizer.hpp&quot;
  49 #include &quot;runtime/timer.hpp&quot;
  50 #include &quot;runtime/vframeArray.hpp&quot;
  51 #include &quot;utilities/debug.hpp&quot;

  52 #include &lt;sys/types.h&gt;
  53 
  54 #ifndef PRODUCT
  55 #include &quot;oops/method.hpp&quot;
  56 #endif // !PRODUCT
  57 
<span class="line-removed">  58 #ifdef BUILTIN_SIM</span>
<span class="line-removed">  59 #include &quot;../../../../../../simulator/simulator.hpp&quot;</span>
<span class="line-removed">  60 #endif</span>
<span class="line-removed">  61 </span>
  62 // Size of interpreter code.  Increase if too small.  Interpreter will
  63 // fail with a guarantee (&quot;not enough space for interpreter generation&quot;);
  64 // if too small.
  65 // Run with +PrintInterpreter to get the VM to print out the size.
  66 // Max size with JVMTI
  67 int TemplateInterpreter::InterpreterCodeSize = 200 * 1024;
  68 
  69 #define __ _masm-&gt;
  70 
  71 //-----------------------------------------------------------------------------
  72 
  73 extern &quot;C&quot; void entry(CodeBuffer*);
  74 
  75 //-----------------------------------------------------------------------------
  76 
  77 address TemplateInterpreterGenerator::generate_slow_signature_handler() {
  78   address entry = __ pc();
  79 
  80   __ andr(esp, esp, -16);
  81   __ mov(c_rarg3, esp);
</pre>
<hr />
<pre>
 272       fn = CAST_FROM_FN_PTR(address, SharedRuntime::dlog);
 273     } else {
 274       fn = CAST_FROM_FN_PTR(address, StubRoutines::dlog());
 275     }
 276     break;
 277   case Interpreter::java_lang_math_log10 :
 278     if (StubRoutines::dlog10() == NULL) {
 279       fn = CAST_FROM_FN_PTR(address, SharedRuntime::dlog10);
 280     } else {
 281       fn = CAST_FROM_FN_PTR(address, StubRoutines::dlog10());
 282     }
 283     break;
 284   case Interpreter::java_lang_math_exp :
 285     if (StubRoutines::dexp() == NULL) {
 286       fn = CAST_FROM_FN_PTR(address, SharedRuntime::dexp);
 287     } else {
 288       fn = CAST_FROM_FN_PTR(address, StubRoutines::dexp());
 289     }
 290     break;
 291   case Interpreter::java_lang_math_pow :
<span class="line-removed"> 292     fpargs = 2;</span>
 293     if (StubRoutines::dpow() == NULL) {
 294       fn = CAST_FROM_FN_PTR(address, SharedRuntime::dpow);
 295     } else {
 296       fn = CAST_FROM_FN_PTR(address, StubRoutines::dpow());
 297     }
 298     break;
 299   default:
 300     ShouldNotReachHere();
 301     fn = NULL;  // unreachable
 302   }
<span class="line-removed"> 303   const int gpargs = 0, rtype = 3;</span>
 304   __ mov(rscratch1, fn);
<span class="line-modified"> 305   __ blrt(rscratch1, gpargs, fpargs, rtype);</span>
 306 }
 307 
 308 // Abstract method entry
 309 // Attempt to execute abstract method. Throw exception
 310 address TemplateInterpreterGenerator::generate_abstract_entry(void) {
 311   // rmethod: Method*
 312   // r13: sender SP
 313 
 314   address entry_point = __ pc();
 315 
 316   // abstract method entry
 317 
 318   //  pop return address, reset last_sp to NULL
 319   __ empty_expression_stack();
 320   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
 321   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
 322 
 323   // throw exception
 324   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
 325                                      InterpreterRuntime::throw_AbstractMethodErrorWithMethod),
</pre>
<hr />
<pre>
 432   __ b(address(Interpreter::throw_exception_entry()));
 433   return entry;
 434 }
 435 
 436 address TemplateInterpreterGenerator::generate_return_entry_for(TosState state, int step, size_t index_size) {
 437   address entry = __ pc();
 438 
 439   // Restore stack bottom in case i2c adjusted stack
 440   __ ldr(esp, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
 441   // and NULL it as marker that esp is now tos until next java call
 442   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
 443   __ restore_bcp();
 444   __ restore_locals();
 445   __ restore_constant_pool_cache();
 446   __ get_method(rmethod);
 447 
 448   if (state == atos) {
 449     Register obj = r0;
 450     Register mdp = r1;
 451     Register tmp = r2;
<span class="line-removed"> 452     __ ldr(mdp, Address(rmethod, Method::method_data_offset()));</span>
 453     __ profile_return_type(mdp, obj, tmp);
 454   }
 455 
 456   // Pop N words from the stack
 457   __ get_cache_and_index_at_bcp(r1, r2, 1, index_size);
 458   __ ldr(r1, Address(r1, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));
 459   __ andr(r1, r1, ConstantPoolCacheEntry::parameter_size_mask);
 460 
 461   __ add(esp, esp, r1, Assembler::LSL, 3);
 462 
 463   // Restore machine SP
 464   __ ldr(rscratch1, Address(rmethod, Method::const_offset()));
 465   __ ldrh(rscratch1, Address(rscratch1, ConstMethod::max_stack_offset()));
 466   __ add(rscratch1, rscratch1, frame::interpreter_frame_monitor_size() + 2);
 467   __ ldr(rscratch2,
 468          Address(rfp, frame::interpreter_frame_initial_sp_offset * wordSize));
 469   __ sub(rscratch1, rscratch2, rscratch1, ext::uxtw, 3);
 470   __ andr(sp, rscratch1, -16);
 471 
<span class="line-removed"> 472 #ifndef PRODUCT</span>
<span class="line-removed"> 473   // tell the simulator that the method has been reentered</span>
<span class="line-removed"> 474   if (NotifySimulator) {</span>
<span class="line-removed"> 475     __ notify(Assembler::method_reentry);</span>
<span class="line-removed"> 476   }</span>
<span class="line-removed"> 477 #endif</span>
<span class="line-removed"> 478 </span>
 479  __ check_and_handle_popframe(rthread);
 480  __ check_and_handle_earlyret(rthread);
 481 
 482   __ get_dispatch();
 483   __ dispatch_next(state, step);
 484 
 485   return entry;
 486 }
 487 
 488 address TemplateInterpreterGenerator::generate_deopt_entry_for(TosState state,
 489                                                                int step,
 490                                                                address continuation) {
 491   address entry = __ pc();
 492   __ restore_bcp();
 493   __ restore_locals();
 494   __ restore_constant_pool_cache();
 495   __ get_method(rmethod);
 496   __ get_dispatch();
 497 
 498   // Calculate stack limit
 499   __ ldr(rscratch1, Address(rmethod, Method::const_offset()));
 500   __ ldrh(rscratch1, Address(rscratch1, ConstMethod::max_stack_offset()));
 501   __ add(rscratch1, rscratch1, frame::interpreter_frame_monitor_size() + 2);
 502   __ ldr(rscratch2,
 503          Address(rfp, frame::interpreter_frame_initial_sp_offset * wordSize));
 504   __ sub(rscratch1, rscratch2, rscratch1, ext::uxtx, 3);
 505   __ andr(sp, rscratch1, -16);
 506 
 507   // Restore expression stack pointer
 508   __ ldr(esp, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
 509   // NULL last_sp until next java call
 510   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
 511 
 512 #if INCLUDE_JVMCI
 513   // Check if we need to take lock at entry of synchronized method.  This can
 514   // only occur on method entry so emit it only for vtos with step 0.
 515   if ((EnableJVMCI || UseAOT) &amp;&amp; state == vtos &amp;&amp; step == 0) {
 516     Label L;
<span class="line-modified"> 517     __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));</span>
 518     __ cbz(rscratch1, L);
 519     // Clear flag.
 520     __ strb(zr, Address(rthread, JavaThread::pending_monitorenter_offset()));
 521     // Take lock.
 522     lock_method();
 523     __ bind(L);
 524   } else {
 525 #ifdef ASSERT
 526     if (EnableJVMCI) {
 527       Label L;
<span class="line-modified"> 528       __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));</span>
 529       __ cbz(rscratch1, L);
 530       __ stop(&quot;unexpected pending monitor in deopt entry&quot;);
 531       __ bind(L);
 532     }
 533 #endif
 534   }
 535 #endif
 536   // handle exceptions
 537   {
 538     Label L;
 539     __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
 540     __ cbz(rscratch1, L);
 541     __ call_VM(noreg,
 542                CAST_FROM_FN_PTR(address,
 543                                 InterpreterRuntime::throw_pending_exception));
 544     __ should_not_reach_here();
 545     __ bind(L);
 546   }
 547 
 548   if (continuation == NULL) {
</pre>
<hr />
<pre>
 869     __ stp(zr, zr, Address(sp, 12 * wordSize));
 870   } else {
 871     __ sub(esp, sp, 12 *  wordSize);
 872     __ ldr(rscratch1, Address(rmethod, Method::const_offset()));      // get ConstMethod
 873     __ add(rbcp, rscratch1, in_bytes(ConstMethod::codes_offset())); // get codebase
 874     __ stp(esp, rbcp, Address(__ pre(sp, -12 * wordSize)));
 875   }
 876 
 877   if (ProfileInterpreter) {
 878     Label method_data_continue;
 879     __ ldr(rscratch1, Address(rmethod, Method::method_data_offset()));
 880     __ cbz(rscratch1, method_data_continue);
 881     __ lea(rscratch1, Address(rscratch1, in_bytes(MethodData::data_offset())));
 882     __ bind(method_data_continue);
 883     __ stp(rscratch1, rmethod, Address(sp, 6 * wordSize));  // save Method* and mdp (method data pointer)
 884   } else {
 885     __ stp(zr, rmethod, Address(sp, 6 * wordSize));        // save Method* (no mdp)
 886   }
 887 
 888   // Get mirror and store it in the frame as GC root for this Method*
<span class="line-modified"> 889   __ load_mirror(rscratch1, rmethod);</span>
<span class="line-modified"> 890   __ stp(rscratch1, zr, Address(sp, 4 * wordSize));</span>
 891 
 892   __ ldr(rcpool, Address(rmethod, Method::const_offset()));
 893   __ ldr(rcpool, Address(rcpool, ConstMethod::constants_offset()));
 894   __ ldr(rcpool, Address(rcpool, ConstantPool::cache_offset_in_bytes()));
 895   __ stp(rlocals, rcpool, Address(sp, 2 * wordSize));
 896 
 897   __ stp(rfp, lr, Address(sp, 10 * wordSize));
 898   __ lea(rfp, Address(sp, 10 * wordSize));
 899 
 900   // set sender sp
 901   // leave last_sp as null
 902   __ stp(zr, r13, Address(sp, 8 * wordSize));
 903 
 904   // Move SP out of the way
 905   if (! native_call) {
 906     __ ldr(rscratch1, Address(rmethod, Method::const_offset()));
 907     __ ldrh(rscratch1, Address(rscratch1, ConstMethod::max_stack_offset()));
 908     __ add(rscratch1, rscratch1, frame::interpreter_frame_monitor_size() + 2);
 909     __ sub(rscratch1, sp, rscratch1, ext::uxtw, 3);
 910     __ andr(sp, rscratch1, -16);
</pre>
<hr />
<pre>
1168 
1169   // Native calls don&#39;t need the stack size check since they have no
1170   // expression stack and the arguments are already on the stack and
1171   // we only add a handful of words to the stack.
1172 
1173   // rmethod: Method*
1174   // r2: size of parameters
1175   // rscratch1: sender sp
1176 
1177   // for natives the size of locals is zero
1178 
1179   // compute beginning of parameters (rlocals)
1180   __ add(rlocals, esp, r2, ext::uxtx, 3);
1181   __ add(rlocals, rlocals, -wordSize);
1182 
1183   // Pull SP back to minimum size: this avoids holes in the stack
1184   __ andr(sp, esp, -16);
1185 
1186   // initialize fixed part of activation frame
1187   generate_fixed_frame(true);
<span class="line-removed">1188 #ifndef PRODUCT</span>
<span class="line-removed">1189   // tell the simulator that a method has been entered</span>
<span class="line-removed">1190   if (NotifySimulator) {</span>
<span class="line-removed">1191     __ notify(Assembler::method_entry);</span>
<span class="line-removed">1192   }</span>
<span class="line-removed">1193 #endif</span>
1194 
1195   // make sure method is native &amp; not abstract
1196 #ifdef ASSERT
1197   __ ldrw(r0, access_flags);
1198   {
1199     Label L;
1200     __ tst(r0, JVM_ACC_NATIVE);
1201     __ br(Assembler::NE, L);
1202     __ stop(&quot;tried to execute non-native method as native&quot;);
1203     __ bind(L);
1204   }
1205   {
1206     Label L;
1207     __ tst(r0, JVM_ACC_ABSTRACT);
1208     __ br(Assembler::EQ, L);
1209     __ stop(&quot;tried to execute abstract method in interpreter&quot;);
1210     __ bind(L);
1211   }
1212 #endif
1213 
</pre>
<hr />
<pre>
1358   __ set_last_Java_frame(esp, rfp, native_return, rscratch1);
1359 
1360   // change thread state
1361 #ifdef ASSERT
1362   {
1363     Label L;
1364     __ ldrw(t, Address(rthread, JavaThread::thread_state_offset()));
1365     __ cmp(t, (u1)_thread_in_Java);
1366     __ br(Assembler::EQ, L);
1367     __ stop(&quot;Wrong thread state in native stub&quot;);
1368     __ bind(L);
1369   }
1370 #endif
1371 
1372   // Change state to native
1373   __ mov(rscratch1, _thread_in_native);
1374   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1375   __ stlrw(rscratch1, rscratch2);
1376 
1377   // Call the native method.
<span class="line-modified">1378   __ blrt(r10, rscratch1);</span>
1379   __ bind(native_return);
1380   __ maybe_isb();
1381   __ get_method(rmethod);
1382   // result potentially in r0 or v0
1383 
1384   // make room for the pushes we&#39;re about to do
1385   __ sub(rscratch1, esp, 4 * wordSize);
1386   __ andr(sp, rscratch1, -16);
1387 
1388   // NOTE: The order of these pushes is known to frame::interpreter_frame_result
1389   // in order to extract the result of a method call. If the order of these
1390   // pushes change or anything else is added to the stack then the code in
1391   // interpreter_frame_result must also change.
1392   __ push(dtos);
1393   __ push(ltos);
1394 
1395   // change thread state
1396   __ mov(rscratch1, _thread_in_native_trans);
1397   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1398   __ stlrw(rscratch1, rscratch2);
1399 
1400   // Force this write out before the read below
1401   __ dmb(Assembler::ISH);
1402 
1403   // check for safepoint operation in progress and/or pending suspend requests
1404   {
1405     Label L, Continue;
1406     __ safepoint_poll_acquire(L);
1407     __ ldrw(rscratch2, Address(rthread, JavaThread::suspend_flags_offset()));
1408     __ cbz(rscratch2, Continue);
1409     __ bind(L);
1410 
1411     // Don&#39;t use call_VM as it will see a possible pending exception
1412     // and forward it and never return here preventing us from
1413     // clearing _last_native_pc down below. So we do a runtime call by
1414     // hand.
1415     //
1416     __ mov(c_rarg0, rthread);
1417     __ mov(rscratch2, CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));
<span class="line-modified">1418     __ blrt(rscratch2, 1, 0, 0);</span>
1419     __ maybe_isb();
1420     __ get_method(rmethod);
1421     __ reinit_heapbase();
1422     __ bind(Continue);
1423   }
1424 
1425   // change thread state
1426   __ mov(rscratch1, _thread_in_Java);
1427   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1428   __ stlrw(rscratch1, rscratch2);
1429 
1430   // reset_last_Java_frame
1431   __ reset_last_Java_frame(true);
1432 
1433   if (CheckJNICalls) {
1434     // clear_pending_jni_exception_check
1435     __ str(zr, Address(rthread, JavaThread::pending_jni_exception_check_fn_offset()));
1436   }
1437 
1438   // reset handle block
</pre>
<hr />
<pre>
1449     __ br(Assembler::NE, no_oop);
1450     // Unbox oop result, e.g. JNIHandles::resolve result.
1451     __ pop(ltos);
1452     __ resolve_jobject(r0, rthread, t);
1453     __ str(r0, Address(rfp, frame::interpreter_frame_oop_temp_offset*wordSize));
1454     // keep stack depth as expected by pushing oop which will eventually be discarded
1455     __ push(ltos);
1456     __ bind(no_oop);
1457   }
1458 
1459   {
1460     Label no_reguard;
1461     __ lea(rscratch1, Address(rthread, in_bytes(JavaThread::stack_guard_state_offset())));
1462     __ ldrw(rscratch1, Address(rscratch1));
1463     __ cmp(rscratch1, (u1)JavaThread::stack_guard_yellow_reserved_disabled);
1464     __ br(Assembler::NE, no_reguard);
1465 
1466     __ pusha(); // XXX only save smashed registers
1467     __ mov(c_rarg0, rthread);
1468     __ mov(rscratch2, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));
<span class="line-modified">1469     __ blrt(rscratch2, 0, 0, 0);</span>
1470     __ popa(); // XXX only restore smashed registers
1471     __ bind(no_reguard);
1472   }
1473 
1474   // The method register is junk from after the thread_in_native transition
1475   // until here.  Also can&#39;t call_VM until the bcp has been
1476   // restored.  Need bcp for throwing exception below so get it now.
1477   __ get_method(rmethod);
1478 
1479   // restore bcp to have legal interpreter frame, i.e., bci == 0 &lt;=&gt;
1480   // rbcp == code_base()
1481   __ ldr(rbcp, Address(rmethod, Method::const_offset()));   // get ConstMethod*
1482   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));          // get codebase
1483   // handle exceptions (exception handling will handle unlocking!)
1484   {
1485     Label L;
1486     __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
1487     __ cbz(rscratch1, L);
1488     // Note: At some point we may want to unify this with the code
1489     // used in call_VM_base(); i.e., we should use the
</pre>
<hr />
<pre>
1604 
1605   // r3 - # of additional locals
1606   // allocate space for locals
1607   // explicitly initialize locals
1608   {
1609     Label exit, loop;
1610     __ ands(zr, r3, r3);
1611     __ br(Assembler::LE, exit); // do nothing if r3 &lt;= 0
1612     __ bind(loop);
1613     __ str(zr, Address(__ post(rscratch1, wordSize)));
1614     __ sub(r3, r3, 1); // until everything initialized
1615     __ cbnz(r3, loop);
1616     __ bind(exit);
1617   }
1618 
1619   // And the base dispatch table
1620   __ get_dispatch();
1621 
1622   // initialize fixed part of activation frame
1623   generate_fixed_frame(false);
<span class="line-modified">1624 #ifndef PRODUCT</span>
<span class="line-removed">1625   // tell the simulator that a method has been entered</span>
<span class="line-removed">1626   if (NotifySimulator) {</span>
<span class="line-removed">1627     __ notify(Assembler::method_entry);</span>
<span class="line-removed">1628   }</span>
<span class="line-removed">1629 #endif</span>
1630   // make sure method is not native &amp; not abstract
1631 #ifdef ASSERT
1632   __ ldrw(r0, access_flags);
1633   {
1634     Label L;
1635     __ tst(r0, JVM_ACC_NATIVE);
1636     __ br(Assembler::EQ, L);
1637     __ stop(&quot;tried to execute native method as non-native&quot;);
1638     __ bind(L);
1639   }
1640  {
1641     Label L;
1642     __ tst(r0, JVM_ACC_ABSTRACT);
1643     __ br(Assembler::EQ, L);
1644     __ stop(&quot;tried to execute abstract method in interpreter&quot;);
1645     __ bind(L);
1646   }
1647 #endif
1648 
1649   // Since at this point in the method invocation the exception
1650   // handler would try to exit the monitor of synchronized methods
1651   // which hasn&#39;t been entered yet, we set the thread local variable
1652   // _do_not_unlock_if_synchronized to true. The remove_activation
1653   // will check this flag.
1654 
1655    const Address do_not_unlock_if_synchronized(rthread,
1656         in_bytes(JavaThread::do_not_unlock_if_synchronized_offset()));
1657   __ mov(rscratch2, true);
1658   __ strb(rscratch2, do_not_unlock_if_synchronized);
1659 
<span class="line-removed">1660   Label no_mdp;</span>
1661   Register mdp = r3;
<span class="line-removed">1662   __ ldr(mdp, Address(rmethod, Method::method_data_offset()));</span>
<span class="line-removed">1663   __ cbz(mdp, no_mdp);</span>
<span class="line-removed">1664   __ add(mdp, mdp, in_bytes(MethodData::data_offset()));</span>
1665   __ profile_parameters_type(mdp, r1, r2);
<span class="line-removed">1666   __ bind(no_mdp);</span>
1667 
1668   // increment invocation count &amp; check for overflow
1669   Label invocation_counter_overflow;
1670   Label profile_method;
1671   Label profile_method_continue;
1672   if (inc_counter) {
1673     generate_counter_incr(&amp;invocation_counter_overflow,
1674                           &amp;profile_method,
1675                           &amp;profile_method_continue);
1676     if (ProfileInterpreter) {
1677       __ bind(profile_method_continue);
1678     }
1679   }
1680 
1681   Label continue_after_compile;
1682   __ bind(continue_after_compile);
1683 
1684   bang_stack_shadow_pages(false);
1685 
1686   // reset the _do_not_unlock_if_synchronized flag
</pre>
<hr />
<pre>
1745 }
1746 
1747 //-----------------------------------------------------------------------------
1748 // Exceptions
1749 
1750 void TemplateInterpreterGenerator::generate_throw_exception() {
1751   // Entry point in previous activation (i.e., if the caller was
1752   // interpreted)
1753   Interpreter::_rethrow_exception_entry = __ pc();
1754   // Restore sp to interpreter_frame_last_sp even though we are going
1755   // to empty the expression stack for the exception processing.
1756   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
1757   // r0: exception
1758   // r3: return address/pc that threw exception
1759   __ restore_bcp();    // rbcp points to call/send
1760   __ restore_locals();
1761   __ restore_constant_pool_cache();
1762   __ reinit_heapbase();  // restore rheapbase as heapbase.
1763   __ get_dispatch();
1764 
<span class="line-removed">1765 #ifndef PRODUCT</span>
<span class="line-removed">1766   // tell the simulator that the caller method has been reentered</span>
<span class="line-removed">1767   if (NotifySimulator) {</span>
<span class="line-removed">1768     __ get_method(rmethod);</span>
<span class="line-removed">1769     __ notify(Assembler::method_reentry);</span>
<span class="line-removed">1770   }</span>
<span class="line-removed">1771 #endif</span>
1772   // Entry point for exceptions thrown within interpreter code
1773   Interpreter::_throw_exception_entry = __ pc();
1774   // If we came here via a NullPointerException on the receiver of a
1775   // method, rmethod may be corrupt.
1776   __ get_method(rmethod);
1777   // expression stack is undefined here
1778   // r0: exception
1779   // rbcp: exception bcp
1780   __ verify_oop(r0);
1781   __ mov(c_rarg1, r0);
1782 
1783   // expression stack must be empty before entering the VM in case of
1784   // an exception
1785   __ empty_expression_stack();
1786   // find exception handler address and preserve exception oop
1787   __ call_VM(r3,
1788              CAST_FROM_FN_PTR(address,
1789                           InterpreterRuntime::exception_handler_for_exception),
1790              c_rarg1);
1791 
</pre>
<hr />
<pre>
2069   assert(Interpreter::trace_code(t-&gt;tos_in()) != NULL,
2070          &quot;entry must have been generated&quot;);
2071   __ bl(Interpreter::trace_code(t-&gt;tos_in()));
2072   __ reinit_heapbase();
2073 }
2074 
2075 
2076 void TemplateInterpreterGenerator::stop_interpreter_at() {
2077   Label L;
2078   __ push(rscratch1);
2079   __ mov(rscratch1, (address) &amp;BytecodeCounter::_counter_value);
2080   __ ldr(rscratch1, Address(rscratch1));
2081   __ mov(rscratch2, StopInterpreterAt);
2082   __ cmpw(rscratch1, rscratch2);
2083   __ br(Assembler::NE, L);
2084   __ brk(0);
2085   __ bind(L);
2086   __ pop(rscratch1);
2087 }
2088 
<span class="line-removed">2089 #ifdef BUILTIN_SIM</span>
<span class="line-removed">2090 </span>
<span class="line-removed">2091 #include &lt;sys/mman.h&gt;</span>
<span class="line-removed">2092 #include &lt;unistd.h&gt;</span>
<span class="line-removed">2093 </span>
<span class="line-removed">2094 extern &quot;C&quot; {</span>
<span class="line-removed">2095   static int PAGESIZE = getpagesize();</span>
<span class="line-removed">2096   int is_mapped_address(u_int64_t address)</span>
<span class="line-removed">2097   {</span>
<span class="line-removed">2098     address = (address &amp; ~((u_int64_t)PAGESIZE - 1));</span>
<span class="line-removed">2099     if (msync((void *)address, PAGESIZE, MS_ASYNC) == 0) {</span>
<span class="line-removed">2100       return true;</span>
<span class="line-removed">2101     }</span>
<span class="line-removed">2102     if (errno != ENOMEM) {</span>
<span class="line-removed">2103       return true;</span>
<span class="line-removed">2104     }</span>
<span class="line-removed">2105     return false;</span>
<span class="line-removed">2106   }</span>
<span class="line-removed">2107 </span>
<span class="line-removed">2108   void bccheck1(u_int64_t pc, u_int64_t fp, char *method, int *bcidx, int *framesize, char *decode)</span>
<span class="line-removed">2109   {</span>
<span class="line-removed">2110     if (method != 0) {</span>
<span class="line-removed">2111       method[0] = &#39;\0&#39;;</span>
<span class="line-removed">2112     }</span>
<span class="line-removed">2113     if (bcidx != 0) {</span>
<span class="line-removed">2114       *bcidx = -2;</span>
<span class="line-removed">2115     }</span>
<span class="line-removed">2116     if (decode != 0) {</span>
<span class="line-removed">2117       decode[0] = 0;</span>
<span class="line-removed">2118     }</span>
<span class="line-removed">2119 </span>
<span class="line-removed">2120     if (framesize != 0) {</span>
<span class="line-removed">2121       *framesize = -1;</span>
<span class="line-removed">2122     }</span>
<span class="line-removed">2123 </span>
<span class="line-removed">2124     if (Interpreter::contains((address)pc)) {</span>
<span class="line-removed">2125       AArch64Simulator *sim = AArch64Simulator::get_current(UseSimulatorCache, DisableBCCheck);</span>
<span class="line-removed">2126       Method* meth;</span>
<span class="line-removed">2127       address bcp;</span>
<span class="line-removed">2128       if (fp) {</span>
<span class="line-removed">2129 #define FRAME_SLOT_METHOD 3</span>
<span class="line-removed">2130 #define FRAME_SLOT_BCP 7</span>
<span class="line-removed">2131         meth = (Method*)sim-&gt;getMemory()-&gt;loadU64(fp - (FRAME_SLOT_METHOD &lt;&lt; 3));</span>
<span class="line-removed">2132         bcp = (address)sim-&gt;getMemory()-&gt;loadU64(fp - (FRAME_SLOT_BCP &lt;&lt; 3));</span>
<span class="line-removed">2133 #undef FRAME_SLOT_METHOD</span>
<span class="line-removed">2134 #undef FRAME_SLOT_BCP</span>
<span class="line-removed">2135       } else {</span>
<span class="line-removed">2136         meth = (Method*)sim-&gt;getCPUState().xreg(RMETHOD, 0);</span>
<span class="line-removed">2137         bcp = (address)sim-&gt;getCPUState().xreg(RBCP, 0);</span>
<span class="line-removed">2138       }</span>
<span class="line-removed">2139       if (meth-&gt;is_native()) {</span>
<span class="line-removed">2140         return;</span>
<span class="line-removed">2141       }</span>
<span class="line-removed">2142       if(method &amp;&amp; meth-&gt;is_method()) {</span>
<span class="line-removed">2143         ResourceMark rm;</span>
<span class="line-removed">2144         method[0] = &#39;I&#39;;</span>
<span class="line-removed">2145         method[1] = &#39; &#39;;</span>
<span class="line-removed">2146         meth-&gt;name_and_sig_as_C_string(method + 2, 398);</span>
<span class="line-removed">2147       }</span>
<span class="line-removed">2148       if (bcidx) {</span>
<span class="line-removed">2149         if (meth-&gt;contains(bcp)) {</span>
<span class="line-removed">2150           *bcidx = meth-&gt;bci_from(bcp);</span>
<span class="line-removed">2151         } else {</span>
<span class="line-removed">2152           *bcidx = -2;</span>
<span class="line-removed">2153         }</span>
<span class="line-removed">2154       }</span>
<span class="line-removed">2155       if (decode) {</span>
<span class="line-removed">2156         if (!BytecodeTracer::closure()) {</span>
<span class="line-removed">2157           BytecodeTracer::set_closure(BytecodeTracer::std_closure());</span>
<span class="line-removed">2158         }</span>
<span class="line-removed">2159         stringStream str(decode, 400);</span>
<span class="line-removed">2160         BytecodeTracer::trace(meth, bcp, &amp;str);</span>
<span class="line-removed">2161       }</span>
<span class="line-removed">2162     } else {</span>
<span class="line-removed">2163       if (method) {</span>
<span class="line-removed">2164         CodeBlob *cb = CodeCache::find_blob((address)pc);</span>
<span class="line-removed">2165         if (cb != NULL) {</span>
<span class="line-removed">2166           if (cb-&gt;is_nmethod()) {</span>
<span class="line-removed">2167             ResourceMark rm;</span>
<span class="line-removed">2168             nmethod* nm = (nmethod*)cb;</span>
<span class="line-removed">2169             method[0] = &#39;C&#39;;</span>
<span class="line-removed">2170             method[1] = &#39; &#39;;</span>
<span class="line-removed">2171             nm-&gt;method()-&gt;name_and_sig_as_C_string(method + 2, 398);</span>
<span class="line-removed">2172           } else if (cb-&gt;is_adapter_blob()) {</span>
<span class="line-removed">2173             strcpy(method, &quot;B adapter blob&quot;);</span>
<span class="line-removed">2174           } else if (cb-&gt;is_runtime_stub()) {</span>
<span class="line-removed">2175             strcpy(method, &quot;B runtime stub&quot;);</span>
<span class="line-removed">2176           } else if (cb-&gt;is_exception_stub()) {</span>
<span class="line-removed">2177             strcpy(method, &quot;B exception stub&quot;);</span>
<span class="line-removed">2178           } else if (cb-&gt;is_deoptimization_stub()) {</span>
<span class="line-removed">2179             strcpy(method, &quot;B deoptimization stub&quot;);</span>
<span class="line-removed">2180           } else if (cb-&gt;is_safepoint_stub()) {</span>
<span class="line-removed">2181             strcpy(method, &quot;B safepoint stub&quot;);</span>
<span class="line-removed">2182           } else if (cb-&gt;is_uncommon_trap_stub()) {</span>
<span class="line-removed">2183             strcpy(method, &quot;B uncommon trap stub&quot;);</span>
<span class="line-removed">2184           } else if (cb-&gt;contains((address)StubRoutines::call_stub())) {</span>
<span class="line-removed">2185             strcpy(method, &quot;B call stub&quot;);</span>
<span class="line-removed">2186           } else {</span>
<span class="line-removed">2187             strcpy(method, &quot;B unknown blob : &quot;);</span>
<span class="line-removed">2188             strcat(method, cb-&gt;name());</span>
<span class="line-removed">2189           }</span>
<span class="line-removed">2190           if (framesize != NULL) {</span>
<span class="line-removed">2191             *framesize = cb-&gt;frame_size();</span>
<span class="line-removed">2192           }</span>
<span class="line-removed">2193         }</span>
<span class="line-removed">2194       }</span>
<span class="line-removed">2195     }</span>
<span class="line-removed">2196   }</span>
<span class="line-removed">2197 </span>
<span class="line-removed">2198 </span>
<span class="line-removed">2199   JNIEXPORT void bccheck(u_int64_t pc, u_int64_t fp, char *method, int *bcidx, int *framesize, char *decode)</span>
<span class="line-removed">2200   {</span>
<span class="line-removed">2201     bccheck1(pc, fp, method, bcidx, framesize, decode);</span>
<span class="line-removed">2202   }</span>
<span class="line-removed">2203 }</span>
<span class="line-removed">2204 </span>
<span class="line-removed">2205 #endif // BUILTIN_SIM</span>
2206 #endif // !PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
  32 #include &quot;interpreter/interp_masm.hpp&quot;
  33 #include &quot;interpreter/templateInterpreterGenerator.hpp&quot;
  34 #include &quot;interpreter/templateTable.hpp&quot;
  35 #include &quot;interpreter/bytecodeTracer.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/arrayOop.hpp&quot;
  38 #include &quot;oops/methodData.hpp&quot;
  39 #include &quot;oops/method.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;prims/jvmtiExport.hpp&quot;
  42 #include &quot;prims/jvmtiThreadState.hpp&quot;
  43 #include &quot;runtime/arguments.hpp&quot;
  44 #include &quot;runtime/deoptimization.hpp&quot;
  45 #include &quot;runtime/frame.inline.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;runtime/stubRoutines.hpp&quot;
  48 #include &quot;runtime/synchronizer.hpp&quot;
  49 #include &quot;runtime/timer.hpp&quot;
  50 #include &quot;runtime/vframeArray.hpp&quot;
  51 #include &quot;utilities/debug.hpp&quot;
<span class="line-added">  52 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  53 #include &lt;sys/types.h&gt;
  54 
  55 #ifndef PRODUCT
  56 #include &quot;oops/method.hpp&quot;
  57 #endif // !PRODUCT
  58 




  59 // Size of interpreter code.  Increase if too small.  Interpreter will
  60 // fail with a guarantee (&quot;not enough space for interpreter generation&quot;);
  61 // if too small.
  62 // Run with +PrintInterpreter to get the VM to print out the size.
  63 // Max size with JVMTI
  64 int TemplateInterpreter::InterpreterCodeSize = 200 * 1024;
  65 
  66 #define __ _masm-&gt;
  67 
  68 //-----------------------------------------------------------------------------
  69 
  70 extern &quot;C&quot; void entry(CodeBuffer*);
  71 
  72 //-----------------------------------------------------------------------------
  73 
  74 address TemplateInterpreterGenerator::generate_slow_signature_handler() {
  75   address entry = __ pc();
  76 
  77   __ andr(esp, esp, -16);
  78   __ mov(c_rarg3, esp);
</pre>
<hr />
<pre>
 269       fn = CAST_FROM_FN_PTR(address, SharedRuntime::dlog);
 270     } else {
 271       fn = CAST_FROM_FN_PTR(address, StubRoutines::dlog());
 272     }
 273     break;
 274   case Interpreter::java_lang_math_log10 :
 275     if (StubRoutines::dlog10() == NULL) {
 276       fn = CAST_FROM_FN_PTR(address, SharedRuntime::dlog10);
 277     } else {
 278       fn = CAST_FROM_FN_PTR(address, StubRoutines::dlog10());
 279     }
 280     break;
 281   case Interpreter::java_lang_math_exp :
 282     if (StubRoutines::dexp() == NULL) {
 283       fn = CAST_FROM_FN_PTR(address, SharedRuntime::dexp);
 284     } else {
 285       fn = CAST_FROM_FN_PTR(address, StubRoutines::dexp());
 286     }
 287     break;
 288   case Interpreter::java_lang_math_pow :

 289     if (StubRoutines::dpow() == NULL) {
 290       fn = CAST_FROM_FN_PTR(address, SharedRuntime::dpow);
 291     } else {
 292       fn = CAST_FROM_FN_PTR(address, StubRoutines::dpow());
 293     }
 294     break;
 295   default:
 296     ShouldNotReachHere();
 297     fn = NULL;  // unreachable
 298   }

 299   __ mov(rscratch1, fn);
<span class="line-modified"> 300   __ blr(rscratch1);</span>
 301 }
 302 
 303 // Abstract method entry
 304 // Attempt to execute abstract method. Throw exception
 305 address TemplateInterpreterGenerator::generate_abstract_entry(void) {
 306   // rmethod: Method*
 307   // r13: sender SP
 308 
 309   address entry_point = __ pc();
 310 
 311   // abstract method entry
 312 
 313   //  pop return address, reset last_sp to NULL
 314   __ empty_expression_stack();
 315   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
 316   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
 317 
 318   // throw exception
 319   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
 320                                      InterpreterRuntime::throw_AbstractMethodErrorWithMethod),
</pre>
<hr />
<pre>
 427   __ b(address(Interpreter::throw_exception_entry()));
 428   return entry;
 429 }
 430 
 431 address TemplateInterpreterGenerator::generate_return_entry_for(TosState state, int step, size_t index_size) {
 432   address entry = __ pc();
 433 
 434   // Restore stack bottom in case i2c adjusted stack
 435   __ ldr(esp, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
 436   // and NULL it as marker that esp is now tos until next java call
 437   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
 438   __ restore_bcp();
 439   __ restore_locals();
 440   __ restore_constant_pool_cache();
 441   __ get_method(rmethod);
 442 
 443   if (state == atos) {
 444     Register obj = r0;
 445     Register mdp = r1;
 446     Register tmp = r2;

 447     __ profile_return_type(mdp, obj, tmp);
 448   }
 449 
 450   // Pop N words from the stack
 451   __ get_cache_and_index_at_bcp(r1, r2, 1, index_size);
 452   __ ldr(r1, Address(r1, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));
 453   __ andr(r1, r1, ConstantPoolCacheEntry::parameter_size_mask);
 454 
 455   __ add(esp, esp, r1, Assembler::LSL, 3);
 456 
 457   // Restore machine SP
 458   __ ldr(rscratch1, Address(rmethod, Method::const_offset()));
 459   __ ldrh(rscratch1, Address(rscratch1, ConstMethod::max_stack_offset()));
 460   __ add(rscratch1, rscratch1, frame::interpreter_frame_monitor_size() + 2);
 461   __ ldr(rscratch2,
 462          Address(rfp, frame::interpreter_frame_initial_sp_offset * wordSize));
 463   __ sub(rscratch1, rscratch2, rscratch1, ext::uxtw, 3);
 464   __ andr(sp, rscratch1, -16);
 465 







 466  __ check_and_handle_popframe(rthread);
 467  __ check_and_handle_earlyret(rthread);
 468 
 469   __ get_dispatch();
 470   __ dispatch_next(state, step);
 471 
 472   return entry;
 473 }
 474 
 475 address TemplateInterpreterGenerator::generate_deopt_entry_for(TosState state,
 476                                                                int step,
 477                                                                address continuation) {
 478   address entry = __ pc();
 479   __ restore_bcp();
 480   __ restore_locals();
 481   __ restore_constant_pool_cache();
 482   __ get_method(rmethod);
 483   __ get_dispatch();
 484 
 485   // Calculate stack limit
 486   __ ldr(rscratch1, Address(rmethod, Method::const_offset()));
 487   __ ldrh(rscratch1, Address(rscratch1, ConstMethod::max_stack_offset()));
 488   __ add(rscratch1, rscratch1, frame::interpreter_frame_monitor_size() + 2);
 489   __ ldr(rscratch2,
 490          Address(rfp, frame::interpreter_frame_initial_sp_offset * wordSize));
 491   __ sub(rscratch1, rscratch2, rscratch1, ext::uxtx, 3);
 492   __ andr(sp, rscratch1, -16);
 493 
 494   // Restore expression stack pointer
 495   __ ldr(esp, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
 496   // NULL last_sp until next java call
 497   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
 498 
 499 #if INCLUDE_JVMCI
 500   // Check if we need to take lock at entry of synchronized method.  This can
 501   // only occur on method entry so emit it only for vtos with step 0.
 502   if ((EnableJVMCI || UseAOT) &amp;&amp; state == vtos &amp;&amp; step == 0) {
 503     Label L;
<span class="line-modified"> 504     __ ldrb(rscratch1, Address(rthread, JavaThread::pending_monitorenter_offset()));</span>
 505     __ cbz(rscratch1, L);
 506     // Clear flag.
 507     __ strb(zr, Address(rthread, JavaThread::pending_monitorenter_offset()));
 508     // Take lock.
 509     lock_method();
 510     __ bind(L);
 511   } else {
 512 #ifdef ASSERT
 513     if (EnableJVMCI) {
 514       Label L;
<span class="line-modified"> 515       __ ldrb(rscratch1, Address(rthread, JavaThread::pending_monitorenter_offset()));</span>
 516       __ cbz(rscratch1, L);
 517       __ stop(&quot;unexpected pending monitor in deopt entry&quot;);
 518       __ bind(L);
 519     }
 520 #endif
 521   }
 522 #endif
 523   // handle exceptions
 524   {
 525     Label L;
 526     __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
 527     __ cbz(rscratch1, L);
 528     __ call_VM(noreg,
 529                CAST_FROM_FN_PTR(address,
 530                                 InterpreterRuntime::throw_pending_exception));
 531     __ should_not_reach_here();
 532     __ bind(L);
 533   }
 534 
 535   if (continuation == NULL) {
</pre>
<hr />
<pre>
 856     __ stp(zr, zr, Address(sp, 12 * wordSize));
 857   } else {
 858     __ sub(esp, sp, 12 *  wordSize);
 859     __ ldr(rscratch1, Address(rmethod, Method::const_offset()));      // get ConstMethod
 860     __ add(rbcp, rscratch1, in_bytes(ConstMethod::codes_offset())); // get codebase
 861     __ stp(esp, rbcp, Address(__ pre(sp, -12 * wordSize)));
 862   }
 863 
 864   if (ProfileInterpreter) {
 865     Label method_data_continue;
 866     __ ldr(rscratch1, Address(rmethod, Method::method_data_offset()));
 867     __ cbz(rscratch1, method_data_continue);
 868     __ lea(rscratch1, Address(rscratch1, in_bytes(MethodData::data_offset())));
 869     __ bind(method_data_continue);
 870     __ stp(rscratch1, rmethod, Address(sp, 6 * wordSize));  // save Method* and mdp (method data pointer)
 871   } else {
 872     __ stp(zr, rmethod, Address(sp, 6 * wordSize));        // save Method* (no mdp)
 873   }
 874 
 875   // Get mirror and store it in the frame as GC root for this Method*
<span class="line-modified"> 876   __ load_mirror(r10, rmethod);</span>
<span class="line-modified"> 877   __ stp(r10, zr, Address(sp, 4 * wordSize));</span>
 878 
 879   __ ldr(rcpool, Address(rmethod, Method::const_offset()));
 880   __ ldr(rcpool, Address(rcpool, ConstMethod::constants_offset()));
 881   __ ldr(rcpool, Address(rcpool, ConstantPool::cache_offset_in_bytes()));
 882   __ stp(rlocals, rcpool, Address(sp, 2 * wordSize));
 883 
 884   __ stp(rfp, lr, Address(sp, 10 * wordSize));
 885   __ lea(rfp, Address(sp, 10 * wordSize));
 886 
 887   // set sender sp
 888   // leave last_sp as null
 889   __ stp(zr, r13, Address(sp, 8 * wordSize));
 890 
 891   // Move SP out of the way
 892   if (! native_call) {
 893     __ ldr(rscratch1, Address(rmethod, Method::const_offset()));
 894     __ ldrh(rscratch1, Address(rscratch1, ConstMethod::max_stack_offset()));
 895     __ add(rscratch1, rscratch1, frame::interpreter_frame_monitor_size() + 2);
 896     __ sub(rscratch1, sp, rscratch1, ext::uxtw, 3);
 897     __ andr(sp, rscratch1, -16);
</pre>
<hr />
<pre>
1155 
1156   // Native calls don&#39;t need the stack size check since they have no
1157   // expression stack and the arguments are already on the stack and
1158   // we only add a handful of words to the stack.
1159 
1160   // rmethod: Method*
1161   // r2: size of parameters
1162   // rscratch1: sender sp
1163 
1164   // for natives the size of locals is zero
1165 
1166   // compute beginning of parameters (rlocals)
1167   __ add(rlocals, esp, r2, ext::uxtx, 3);
1168   __ add(rlocals, rlocals, -wordSize);
1169 
1170   // Pull SP back to minimum size: this avoids holes in the stack
1171   __ andr(sp, esp, -16);
1172 
1173   // initialize fixed part of activation frame
1174   generate_fixed_frame(true);






1175 
1176   // make sure method is native &amp; not abstract
1177 #ifdef ASSERT
1178   __ ldrw(r0, access_flags);
1179   {
1180     Label L;
1181     __ tst(r0, JVM_ACC_NATIVE);
1182     __ br(Assembler::NE, L);
1183     __ stop(&quot;tried to execute non-native method as native&quot;);
1184     __ bind(L);
1185   }
1186   {
1187     Label L;
1188     __ tst(r0, JVM_ACC_ABSTRACT);
1189     __ br(Assembler::EQ, L);
1190     __ stop(&quot;tried to execute abstract method in interpreter&quot;);
1191     __ bind(L);
1192   }
1193 #endif
1194 
</pre>
<hr />
<pre>
1339   __ set_last_Java_frame(esp, rfp, native_return, rscratch1);
1340 
1341   // change thread state
1342 #ifdef ASSERT
1343   {
1344     Label L;
1345     __ ldrw(t, Address(rthread, JavaThread::thread_state_offset()));
1346     __ cmp(t, (u1)_thread_in_Java);
1347     __ br(Assembler::EQ, L);
1348     __ stop(&quot;Wrong thread state in native stub&quot;);
1349     __ bind(L);
1350   }
1351 #endif
1352 
1353   // Change state to native
1354   __ mov(rscratch1, _thread_in_native);
1355   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1356   __ stlrw(rscratch1, rscratch2);
1357 
1358   // Call the native method.
<span class="line-modified">1359   __ blr(r10);</span>
1360   __ bind(native_return);
1361   __ maybe_isb();
1362   __ get_method(rmethod);
1363   // result potentially in r0 or v0
1364 
1365   // make room for the pushes we&#39;re about to do
1366   __ sub(rscratch1, esp, 4 * wordSize);
1367   __ andr(sp, rscratch1, -16);
1368 
1369   // NOTE: The order of these pushes is known to frame::interpreter_frame_result
1370   // in order to extract the result of a method call. If the order of these
1371   // pushes change or anything else is added to the stack then the code in
1372   // interpreter_frame_result must also change.
1373   __ push(dtos);
1374   __ push(ltos);
1375 
1376   // change thread state
1377   __ mov(rscratch1, _thread_in_native_trans);
1378   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1379   __ stlrw(rscratch1, rscratch2);
1380 
1381   // Force this write out before the read below
1382   __ dmb(Assembler::ISH);
1383 
1384   // check for safepoint operation in progress and/or pending suspend requests
1385   {
1386     Label L, Continue;
1387     __ safepoint_poll_acquire(L);
1388     __ ldrw(rscratch2, Address(rthread, JavaThread::suspend_flags_offset()));
1389     __ cbz(rscratch2, Continue);
1390     __ bind(L);
1391 
1392     // Don&#39;t use call_VM as it will see a possible pending exception
1393     // and forward it and never return here preventing us from
1394     // clearing _last_native_pc down below. So we do a runtime call by
1395     // hand.
1396     //
1397     __ mov(c_rarg0, rthread);
1398     __ mov(rscratch2, CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));
<span class="line-modified">1399     __ blr(rscratch2);</span>
1400     __ maybe_isb();
1401     __ get_method(rmethod);
1402     __ reinit_heapbase();
1403     __ bind(Continue);
1404   }
1405 
1406   // change thread state
1407   __ mov(rscratch1, _thread_in_Java);
1408   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1409   __ stlrw(rscratch1, rscratch2);
1410 
1411   // reset_last_Java_frame
1412   __ reset_last_Java_frame(true);
1413 
1414   if (CheckJNICalls) {
1415     // clear_pending_jni_exception_check
1416     __ str(zr, Address(rthread, JavaThread::pending_jni_exception_check_fn_offset()));
1417   }
1418 
1419   // reset handle block
</pre>
<hr />
<pre>
1430     __ br(Assembler::NE, no_oop);
1431     // Unbox oop result, e.g. JNIHandles::resolve result.
1432     __ pop(ltos);
1433     __ resolve_jobject(r0, rthread, t);
1434     __ str(r0, Address(rfp, frame::interpreter_frame_oop_temp_offset*wordSize));
1435     // keep stack depth as expected by pushing oop which will eventually be discarded
1436     __ push(ltos);
1437     __ bind(no_oop);
1438   }
1439 
1440   {
1441     Label no_reguard;
1442     __ lea(rscratch1, Address(rthread, in_bytes(JavaThread::stack_guard_state_offset())));
1443     __ ldrw(rscratch1, Address(rscratch1));
1444     __ cmp(rscratch1, (u1)JavaThread::stack_guard_yellow_reserved_disabled);
1445     __ br(Assembler::NE, no_reguard);
1446 
1447     __ pusha(); // XXX only save smashed registers
1448     __ mov(c_rarg0, rthread);
1449     __ mov(rscratch2, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));
<span class="line-modified">1450     __ blr(rscratch2);</span>
1451     __ popa(); // XXX only restore smashed registers
1452     __ bind(no_reguard);
1453   }
1454 
1455   // The method register is junk from after the thread_in_native transition
1456   // until here.  Also can&#39;t call_VM until the bcp has been
1457   // restored.  Need bcp for throwing exception below so get it now.
1458   __ get_method(rmethod);
1459 
1460   // restore bcp to have legal interpreter frame, i.e., bci == 0 &lt;=&gt;
1461   // rbcp == code_base()
1462   __ ldr(rbcp, Address(rmethod, Method::const_offset()));   // get ConstMethod*
1463   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));          // get codebase
1464   // handle exceptions (exception handling will handle unlocking!)
1465   {
1466     Label L;
1467     __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
1468     __ cbz(rscratch1, L);
1469     // Note: At some point we may want to unify this with the code
1470     // used in call_VM_base(); i.e., we should use the
</pre>
<hr />
<pre>
1585 
1586   // r3 - # of additional locals
1587   // allocate space for locals
1588   // explicitly initialize locals
1589   {
1590     Label exit, loop;
1591     __ ands(zr, r3, r3);
1592     __ br(Assembler::LE, exit); // do nothing if r3 &lt;= 0
1593     __ bind(loop);
1594     __ str(zr, Address(__ post(rscratch1, wordSize)));
1595     __ sub(r3, r3, 1); // until everything initialized
1596     __ cbnz(r3, loop);
1597     __ bind(exit);
1598   }
1599 
1600   // And the base dispatch table
1601   __ get_dispatch();
1602 
1603   // initialize fixed part of activation frame
1604   generate_fixed_frame(false);
<span class="line-modified">1605 </span>





1606   // make sure method is not native &amp; not abstract
1607 #ifdef ASSERT
1608   __ ldrw(r0, access_flags);
1609   {
1610     Label L;
1611     __ tst(r0, JVM_ACC_NATIVE);
1612     __ br(Assembler::EQ, L);
1613     __ stop(&quot;tried to execute native method as non-native&quot;);
1614     __ bind(L);
1615   }
1616  {
1617     Label L;
1618     __ tst(r0, JVM_ACC_ABSTRACT);
1619     __ br(Assembler::EQ, L);
1620     __ stop(&quot;tried to execute abstract method in interpreter&quot;);
1621     __ bind(L);
1622   }
1623 #endif
1624 
1625   // Since at this point in the method invocation the exception
1626   // handler would try to exit the monitor of synchronized methods
1627   // which hasn&#39;t been entered yet, we set the thread local variable
1628   // _do_not_unlock_if_synchronized to true. The remove_activation
1629   // will check this flag.
1630 
1631    const Address do_not_unlock_if_synchronized(rthread,
1632         in_bytes(JavaThread::do_not_unlock_if_synchronized_offset()));
1633   __ mov(rscratch2, true);
1634   __ strb(rscratch2, do_not_unlock_if_synchronized);
1635 

1636   Register mdp = r3;



1637   __ profile_parameters_type(mdp, r1, r2);

1638 
1639   // increment invocation count &amp; check for overflow
1640   Label invocation_counter_overflow;
1641   Label profile_method;
1642   Label profile_method_continue;
1643   if (inc_counter) {
1644     generate_counter_incr(&amp;invocation_counter_overflow,
1645                           &amp;profile_method,
1646                           &amp;profile_method_continue);
1647     if (ProfileInterpreter) {
1648       __ bind(profile_method_continue);
1649     }
1650   }
1651 
1652   Label continue_after_compile;
1653   __ bind(continue_after_compile);
1654 
1655   bang_stack_shadow_pages(false);
1656 
1657   // reset the _do_not_unlock_if_synchronized flag
</pre>
<hr />
<pre>
1716 }
1717 
1718 //-----------------------------------------------------------------------------
1719 // Exceptions
1720 
1721 void TemplateInterpreterGenerator::generate_throw_exception() {
1722   // Entry point in previous activation (i.e., if the caller was
1723   // interpreted)
1724   Interpreter::_rethrow_exception_entry = __ pc();
1725   // Restore sp to interpreter_frame_last_sp even though we are going
1726   // to empty the expression stack for the exception processing.
1727   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
1728   // r0: exception
1729   // r3: return address/pc that threw exception
1730   __ restore_bcp();    // rbcp points to call/send
1731   __ restore_locals();
1732   __ restore_constant_pool_cache();
1733   __ reinit_heapbase();  // restore rheapbase as heapbase.
1734   __ get_dispatch();
1735 







1736   // Entry point for exceptions thrown within interpreter code
1737   Interpreter::_throw_exception_entry = __ pc();
1738   // If we came here via a NullPointerException on the receiver of a
1739   // method, rmethod may be corrupt.
1740   __ get_method(rmethod);
1741   // expression stack is undefined here
1742   // r0: exception
1743   // rbcp: exception bcp
1744   __ verify_oop(r0);
1745   __ mov(c_rarg1, r0);
1746 
1747   // expression stack must be empty before entering the VM in case of
1748   // an exception
1749   __ empty_expression_stack();
1750   // find exception handler address and preserve exception oop
1751   __ call_VM(r3,
1752              CAST_FROM_FN_PTR(address,
1753                           InterpreterRuntime::exception_handler_for_exception),
1754              c_rarg1);
1755 
</pre>
<hr />
<pre>
2033   assert(Interpreter::trace_code(t-&gt;tos_in()) != NULL,
2034          &quot;entry must have been generated&quot;);
2035   __ bl(Interpreter::trace_code(t-&gt;tos_in()));
2036   __ reinit_heapbase();
2037 }
2038 
2039 
2040 void TemplateInterpreterGenerator::stop_interpreter_at() {
2041   Label L;
2042   __ push(rscratch1);
2043   __ mov(rscratch1, (address) &amp;BytecodeCounter::_counter_value);
2044   __ ldr(rscratch1, Address(rscratch1));
2045   __ mov(rscratch2, StopInterpreterAt);
2046   __ cmpw(rscratch1, rscratch2);
2047   __ br(Assembler::NE, L);
2048   __ brk(0);
2049   __ bind(L);
2050   __ pop(rscratch1);
2051 }
2052 





















































































































2053 #endif // !PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="stubRoutines_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
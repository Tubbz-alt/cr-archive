<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/aarch64_ad.m4</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="aarch64Test.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="abstractInterpreter_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64_ad.m4</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
137 BOTH_INVERTED_INSNS(And, bic)
138 BOTH_INVERTED_INSNS(Or, orn)
139 BOTH_INVERTED_INSNS(Xor, eon)
140 ALL_INVERTED_SHIFT_KINDS(And, bic)
141 ALL_INVERTED_SHIFT_KINDS(Xor, eon)
142 ALL_INVERTED_SHIFT_KINDS(Or, orn)
143 ALL_SHIFT_KINDS(And, andr)
144 ALL_SHIFT_KINDS(Xor, eor)
145 ALL_SHIFT_KINDS(Or, orr)
146 ALL_SHIFT_KINDS(Add, add)
147 ALL_SHIFT_KINDS(Sub, sub)
148 dnl
149 dnl EXTEND mode, rshift_op, src, lshift_count, rshift_count
150 define(`EXTEND&#39;, `($2$1 (LShift$1 $3 $4) $5)&#39;)
151 define(`BFM_INSN&#39;,`
152 // Shift Left followed by Shift Right.
153 // This idiom is used by the compiler for the i2b bytecode etc.
154 instruct $4$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src, immI lshift_count, immI rshift_count)
155 %{
156   match(Set dst EXTEND($1, $3, src, lshift_count, rshift_count));
<span class="line-removed">157   // Make sure we are not going to exceed what $4 can do.</span>
<span class="line-removed">158   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= $2</span>
<span class="line-removed">159             &amp;&amp; (unsigned int)n-&gt;in(1)-&gt;in(2)-&gt;get_int() &lt;= $2);</span>
<span class="line-removed">160 </span>
161   ins_cost(INSN_COST * 2);
162   format %{ &quot;$4  $dst, $src, $rshift_count - $lshift_count, #$2 - $lshift_count&quot; %}
163   ins_encode %{
<span class="line-modified">164     int lshift = $lshift_count$$constant, rshift = $rshift_count$$constant;</span>

165     int s = $2 - lshift;
166     int r = (rshift - lshift) &amp; $2;
167     __ $4(as_Register($dst$$reg),
168             as_Register($src$$reg),
169             r, s);
170   %}
171 
172   ins_pipe(ialu_reg_shift);
173 %}&#39;)
174 BFM_INSN(L, 63, RShift, sbfm)
175 BFM_INSN(I, 31, RShift, sbfmw)
176 BFM_INSN(L, 63, URShift, ubfm)
177 BFM_INSN(I, 31, URShift, ubfmw)
178 dnl
179 // Bitfield extract with shift &amp; mask
180 define(`BFX_INSN&#39;,
181 `instruct $3$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src, immI rshift, imm$1_bitmask mask)
182 %{
183   match(Set dst (And$1 ($2$1 src rshift) mask));


184 
185   ins_cost(INSN_COST);
186   format %{ &quot;$3 $dst, $src, $rshift, $mask&quot; %}
187   ins_encode %{
<span class="line-modified">188     int rshift = $rshift$$constant;</span>
189     long mask = $mask$$constant;
<span class="line-modified">190     int width = exact_log2(mask+1);</span>
191     __ $3(as_Register($dst$$reg),
192             as_Register($src$$reg), rshift, width);
193   %}
194   ins_pipe(ialu_reg_shift);
195 %}&#39;)
<span class="line-modified">196 BFX_INSN(I,URShift,ubfxw)</span>
<span class="line-modified">197 BFX_INSN(L,URShift,ubfx)</span>
198 
199 // We can use ubfx when extending an And with a mask when we know mask
200 // is positive.  We know that because immI_bitmask guarantees it.
201 instruct ubfxIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
202 %{
203   match(Set dst (ConvI2L (AndI (URShiftI src rshift) mask)));


204 
205   ins_cost(INSN_COST * 2);
206   format %{ &quot;ubfx $dst, $src, $rshift, $mask&quot; %}
207   ins_encode %{
<span class="line-modified">208     int rshift = $rshift$$constant;</span>
209     long mask = $mask$$constant;
210     int width = exact_log2(mask+1);
211     __ ubfx(as_Register($dst$$reg),
212             as_Register($src$$reg), rshift, width);
213   %}
214   ins_pipe(ialu_reg_shift);
215 %}
216 
217 define(`UBFIZ_INSN&#39;,
218 // We can use ubfiz when masking by a positive number and then left shifting the result.
219 // We know that the mask is positive because imm$1_bitmask guarantees it.
220 `instruct $2$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src, immI lshift, imm$1_bitmask mask)
221 %{
222   match(Set dst (LShift$1 (And$1 src mask) lshift));
<span class="line-modified">223   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= $3 &amp;&amp;</span>
<span class="line-removed">224     (exact_log2$5(n-&gt;in(1)-&gt;in(2)-&gt;get_$4()+1) + (unsigned int)n-&gt;in(2)-&gt;get_int()) &lt;= ($3+1));</span>
225 
226   ins_cost(INSN_COST);
227   format %{ &quot;$2 $dst, $src, $lshift, $mask&quot; %}
228   ins_encode %{
<span class="line-modified">229     int lshift = $lshift$$constant;</span>
230     long mask = $mask$$constant;
<span class="line-modified">231     int width = exact_log2(mask+1);</span>
232     __ $2(as_Register($dst$$reg),
233           as_Register($src$$reg), lshift, width);
234   %}
235   ins_pipe(ialu_reg_shift);
236 %}&#39;)
237 UBFIZ_INSN(I, ubfizw, 31, int)
<span class="line-modified">238 UBFIZ_INSN(L, ubfiz, 63, long, _long)</span>
239 
240 // If there is a convert I to L block between and AndI and a LShiftL, we can also match ubfiz
241 instruct ubfizIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
242 %{
<span class="line-modified">243   match(Set dst (LShiftL (ConvI2L(AndI src mask)) lshift));</span>
<span class="line-modified">244   predicate((unsigned int)n-&gt;in(2)-&gt;get_int() &lt;= 31 &amp;&amp;</span>
<span class="line-removed">245     (exact_log2((unsigned int)n-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;get_int()+1) + (unsigned int)n-&gt;in(2)-&gt;get_int()) &lt;= 32);</span>
246 
247   ins_cost(INSN_COST);
248   format %{ &quot;ubfiz $dst, $src, $lshift, $mask&quot; %}
249   ins_encode %{
<span class="line-modified">250     int lshift = $lshift$$constant;</span>
251     long mask = $mask$$constant;
252     int width = exact_log2(mask+1);
253     __ ubfiz(as_Register($dst$$reg),
254              as_Register($src$$reg), lshift, width);
255   %}
256   ins_pipe(ialu_reg_shift);
257 %}
258 
259 // Rotations
260 
261 define(`EXTRACT_INSN&#39;,
262 `instruct extr$3$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src1, iReg$1`&#39;ORL2I($1) src2, immI lshift, immI rshift, rFlagsReg cr)
263 %{
264   match(Set dst ($3$1 (LShift$1 src1 lshift) (URShift$1 src2 rshift)));
<span class="line-modified">265   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; $2));</span>
266 
267   ins_cost(INSN_COST);
268   format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
269 
270   ins_encode %{
271     __ $4(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg),
272             $rshift$$constant &amp; $2);
273   %}
274   ins_pipe(ialu_reg_reg_extr);
275 %}
276 &#39;)dnl
277 EXTRACT_INSN(L, 63, Or, extr)
278 EXTRACT_INSN(I, 31, Or, extrw)
279 EXTRACT_INSN(L, 63, Add, extr)
280 EXTRACT_INSN(I, 31, Add, extrw)
281 define(`ROL_EXPAND&#39;, `
282 // $2 expander
283 
284 instruct $2$1_rReg(iReg$1NoSp dst, iReg$1 src, iRegI shift, rFlagsReg cr)
285 %{
</pre>
</td>
<td>
<hr />
<pre>
137 BOTH_INVERTED_INSNS(And, bic)
138 BOTH_INVERTED_INSNS(Or, orn)
139 BOTH_INVERTED_INSNS(Xor, eon)
140 ALL_INVERTED_SHIFT_KINDS(And, bic)
141 ALL_INVERTED_SHIFT_KINDS(Xor, eon)
142 ALL_INVERTED_SHIFT_KINDS(Or, orn)
143 ALL_SHIFT_KINDS(And, andr)
144 ALL_SHIFT_KINDS(Xor, eor)
145 ALL_SHIFT_KINDS(Or, orr)
146 ALL_SHIFT_KINDS(Add, add)
147 ALL_SHIFT_KINDS(Sub, sub)
148 dnl
149 dnl EXTEND mode, rshift_op, src, lshift_count, rshift_count
150 define(`EXTEND&#39;, `($2$1 (LShift$1 $3 $4) $5)&#39;)
151 define(`BFM_INSN&#39;,`
152 // Shift Left followed by Shift Right.
153 // This idiom is used by the compiler for the i2b bytecode etc.
154 instruct $4$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src, immI lshift_count, immI rshift_count)
155 %{
156   match(Set dst EXTEND($1, $3, src, lshift_count, rshift_count));




157   ins_cost(INSN_COST * 2);
158   format %{ &quot;$4  $dst, $src, $rshift_count - $lshift_count, #$2 - $lshift_count&quot; %}
159   ins_encode %{
<span class="line-modified">160     int lshift = $lshift_count$$constant &amp; $2;</span>
<span class="line-added">161     int rshift = $rshift_count$$constant &amp; $2;</span>
162     int s = $2 - lshift;
163     int r = (rshift - lshift) &amp; $2;
164     __ $4(as_Register($dst$$reg),
165             as_Register($src$$reg),
166             r, s);
167   %}
168 
169   ins_pipe(ialu_reg_shift);
170 %}&#39;)
171 BFM_INSN(L, 63, RShift, sbfm)
172 BFM_INSN(I, 31, RShift, sbfmw)
173 BFM_INSN(L, 63, URShift, ubfm)
174 BFM_INSN(I, 31, URShift, ubfmw)
175 dnl
176 // Bitfield extract with shift &amp; mask
177 define(`BFX_INSN&#39;,
178 `instruct $3$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src, immI rshift, imm$1_bitmask mask)
179 %{
180   match(Set dst (And$1 ($2$1 src rshift) mask));
<span class="line-added">181   // Make sure we are not going to exceed what $3 can do.</span>
<span class="line-added">182   predicate((exact_log2$6(n-&gt;in(2)-&gt;get_$5() + 1) + (n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; $4)) &lt;= ($4 + 1));</span>
183 
184   ins_cost(INSN_COST);
185   format %{ &quot;$3 $dst, $src, $rshift, $mask&quot; %}
186   ins_encode %{
<span class="line-modified">187     int rshift = $rshift$$constant &amp; $4;</span>
188     long mask = $mask$$constant;
<span class="line-modified">189     int width = exact_log2$6(mask+1);</span>
190     __ $3(as_Register($dst$$reg),
191             as_Register($src$$reg), rshift, width);
192   %}
193   ins_pipe(ialu_reg_shift);
194 %}&#39;)
<span class="line-modified">195 BFX_INSN(I, URShift, ubfxw, 31, int)</span>
<span class="line-modified">196 BFX_INSN(L, URShift, ubfx,  63, long, _long)</span>
197 
198 // We can use ubfx when extending an And with a mask when we know mask
199 // is positive.  We know that because immI_bitmask guarantees it.
200 instruct ubfxIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
201 %{
202   match(Set dst (ConvI2L (AndI (URShiftI src rshift) mask)));
<span class="line-added">203   // Make sure we are not going to exceed what ubfxw can do.</span>
<span class="line-added">204   predicate((exact_log2(n-&gt;in(1)-&gt;in(2)-&gt;get_int() + 1) + (n-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; 31)) &lt;= (31 + 1));</span>
205 
206   ins_cost(INSN_COST * 2);
207   format %{ &quot;ubfx $dst, $src, $rshift, $mask&quot; %}
208   ins_encode %{
<span class="line-modified">209     int rshift = $rshift$$constant &amp; 31;</span>
210     long mask = $mask$$constant;
211     int width = exact_log2(mask+1);
212     __ ubfx(as_Register($dst$$reg),
213             as_Register($src$$reg), rshift, width);
214   %}
215   ins_pipe(ialu_reg_shift);
216 %}
217 
218 define(`UBFIZ_INSN&#39;,
219 // We can use ubfiz when masking by a positive number and then left shifting the result.
220 // We know that the mask is positive because imm$1_bitmask guarantees it.
221 `instruct $2$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src, immI lshift, imm$1_bitmask mask)
222 %{
223   match(Set dst (LShift$1 (And$1 src mask) lshift));
<span class="line-modified">224   predicate((exact_log2$5(n-&gt;in(1)-&gt;in(2)-&gt;get_$4() + 1) + (n-&gt;in(2)-&gt;get_int() &amp; $3)) &lt;= ($3 + 1));</span>

225 
226   ins_cost(INSN_COST);
227   format %{ &quot;$2 $dst, $src, $lshift, $mask&quot; %}
228   ins_encode %{
<span class="line-modified">229     int lshift = $lshift$$constant &amp; $3;</span>
230     long mask = $mask$$constant;
<span class="line-modified">231     int width = exact_log2$5(mask+1);</span>
232     __ $2(as_Register($dst$$reg),
233           as_Register($src$$reg), lshift, width);
234   %}
235   ins_pipe(ialu_reg_shift);
236 %}&#39;)
237 UBFIZ_INSN(I, ubfizw, 31, int)
<span class="line-modified">238 UBFIZ_INSN(L, ubfiz,  63, long, _long)</span>
239 
240 // If there is a convert I to L block between and AndI and a LShiftL, we can also match ubfiz
241 instruct ubfizIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
242 %{
<span class="line-modified">243   match(Set dst (LShiftL (ConvI2L (AndI src mask)) lshift));</span>
<span class="line-modified">244   predicate((exact_log2(n-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;get_int() + 1) + (n-&gt;in(2)-&gt;get_int() &amp; 63)) &lt;= (63 + 1));</span>

245 
246   ins_cost(INSN_COST);
247   format %{ &quot;ubfiz $dst, $src, $lshift, $mask&quot; %}
248   ins_encode %{
<span class="line-modified">249     int lshift = $lshift$$constant &amp; 63;</span>
250     long mask = $mask$$constant;
251     int width = exact_log2(mask+1);
252     __ ubfiz(as_Register($dst$$reg),
253              as_Register($src$$reg), lshift, width);
254   %}
255   ins_pipe(ialu_reg_shift);
256 %}
257 
258 // Rotations
259 
260 define(`EXTRACT_INSN&#39;,
261 `instruct extr$3$1(iReg$1NoSp dst, iReg$1`&#39;ORL2I($1) src1, iReg$1`&#39;ORL2I($1) src2, immI lshift, immI rshift, rFlagsReg cr)
262 %{
263   match(Set dst ($3$1 (LShift$1 src1 lshift) (URShift$1 src2 rshift)));
<span class="line-modified">264   predicate(0 == (((n-&gt;in(1)-&gt;in(2)-&gt;get_int() &amp; $2) + (n-&gt;in(2)-&gt;in(2)-&gt;get_int() &amp; $2)) &amp; $2));</span>
265 
266   ins_cost(INSN_COST);
267   format %{ &quot;extr $dst, $src1, $src2, #$rshift&quot; %}
268 
269   ins_encode %{
270     __ $4(as_Register($dst$$reg), as_Register($src1$$reg), as_Register($src2$$reg),
271             $rshift$$constant &amp; $2);
272   %}
273   ins_pipe(ialu_reg_reg_extr);
274 %}
275 &#39;)dnl
276 EXTRACT_INSN(L, 63, Or, extr)
277 EXTRACT_INSN(I, 31, Or, extrw)
278 EXTRACT_INSN(L, 63, Add, extr)
279 EXTRACT_INSN(I, 31, Add, extrw)
280 define(`ROL_EXPAND&#39;, `
281 // $2 expander
282 
283 instruct $2$1_rReg(iReg$1NoSp dst, iReg$1 src, iRegI shift, rFlagsReg cr)
284 %{
</pre>
</td>
</tr>
</table>
<center><a href="aarch64Test.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="abstractInterpreter_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
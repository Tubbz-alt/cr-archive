<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os_cpu/solaris_x86/os_solaris_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // no precompiled headers
 26 #include &quot;jvm.h&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;code/codeCache.hpp&quot;
 32 #include &quot;code/icBuffer.hpp&quot;
 33 #include &quot;code/vtableStubs.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;os_share_solaris.hpp&quot;
 38 #include &quot;prims/jniFastGetField.hpp&quot;
 39 #include &quot;prims/jvm_misc.hpp&quot;
 40 #include &quot;runtime/arguments.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 41 #include &quot;runtime/atomic.hpp&quot;</span>
 42 #include &quot;runtime/extendedPC.hpp&quot;
 43 #include &quot;runtime/frame.inline.hpp&quot;
 44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 45 #include &quot;runtime/java.hpp&quot;
 46 #include &quot;runtime/javaCalls.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/osThread.hpp&quot;
 49 #include &quot;runtime/sharedRuntime.hpp&quot;
 50 #include &quot;runtime/stubRoutines.hpp&quot;
 51 #include &quot;runtime/thread.inline.hpp&quot;
 52 #include &quot;runtime/timer.hpp&quot;
 53 #include &quot;utilities/align.hpp&quot;
 54 #include &quot;utilities/events.hpp&quot;
 55 #include &quot;utilities/vmError.hpp&quot;
 56 
 57 // put OS-includes here
 58 # include &lt;sys/types.h&gt;
 59 # include &lt;sys/mman.h&gt;
 60 # include &lt;pthread.h&gt;
 61 # include &lt;signal.h&gt;
 62 # include &lt;setjmp.h&gt;
 63 # include &lt;errno.h&gt;
 64 # include &lt;dlfcn.h&gt;
 65 # include &lt;stdio.h&gt;
 66 # include &lt;unistd.h&gt;
 67 # include &lt;sys/resource.h&gt;
 68 # include &lt;thread.h&gt;
 69 # include &lt;sys/stat.h&gt;
 70 # include &lt;sys/time.h&gt;
 71 # include &lt;sys/filio.h&gt;
 72 # include &lt;sys/utsname.h&gt;
 73 # include &lt;sys/systeminfo.h&gt;
 74 # include &lt;sys/socket.h&gt;
 75 # include &lt;sys/trap.h&gt;
 76 # include &lt;sys/lwp.h&gt;
 77 # include &lt;poll.h&gt;
 78 # include &lt;sys/lwp.h&gt;
 79 # include &lt;procfs.h&gt;     //  see comment in &lt;sys/procfs.h&gt;
 80 
 81 #ifndef AMD64
 82 // QQQ seems useless at this point
 83 # define _STRUCTURED_PROC 1  //  this gets us the new structured proc interfaces of 5.6 &amp; later
 84 #endif // AMD64
 85 # include &lt;sys/procfs.h&gt;     //  see comment in &lt;sys/procfs.h&gt;
 86 
 87 
 88 #define MAX_PATH (2 * K)
 89 
 90 // Minimum usable stack sizes required to get to user code. Space for
 91 // HotSpot guard pages is added later.
 92 #ifdef _LP64
 93 // The adlc generated method &#39;State::MachNodeGenerator(int)&#39; used by the C2 compiler
 94 // threads requires a large stack with the Solaris Studio C++ compiler version 5.13
 95 // and product VM builds (debug builds require significantly less stack space).
 96 size_t os::Posix::_compiler_thread_min_stack_allowed = 325 * K;
 97 size_t os::Posix::_java_thread_min_stack_allowed = 48 * K;
 98 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 224 * K;
 99 #else
100 size_t os::Posix::_compiler_thread_min_stack_allowed = 32 * K;
101 size_t os::Posix::_java_thread_min_stack_allowed = 32 * K;
102 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 64 * K;
103 #endif // _LP64
104 
105 #ifdef AMD64
106 #define REG_SP REG_RSP
107 #define REG_PC REG_RIP
108 #define REG_FP REG_RBP
109 #else
110 #define REG_SP UESP
111 #define REG_PC EIP
112 #define REG_FP EBP
113 // 4900493 counter to prevent runaway LDTR refresh attempt
114 
115 static volatile int ldtr_refresh = 0;
116 // the libthread instruction that faults because of the stale LDTR
117 
118 static const unsigned char movlfs[] = { 0x8e, 0xe0    // movl %eax,%fs
119                        };
120 #endif // AMD64
121 
122 char* os::non_memory_address_word() {
123   // Must never look like an address returned by reserve_memory,
124   // even in its subfields (as defined by the CPU immediate fields,
125   // if the CPU splits constants across multiple instructions).
126   return (char*) -1;
127 }
128 
129 //
130 // Validate a ucontext retrieved from walking a uc_link of a ucontext.
131 // There are issues with libthread giving out uc_links for different threads
132 // on the same uc_link chain and bad or circular links.
133 //
134 bool os::Solaris::valid_ucontext(Thread* thread, const ucontext_t* valid, const ucontext_t* suspect) {
135   if (valid &gt;= suspect ||
136       valid-&gt;uc_stack.ss_flags != suspect-&gt;uc_stack.ss_flags ||
137       valid-&gt;uc_stack.ss_sp    != suspect-&gt;uc_stack.ss_sp    ||
138       valid-&gt;uc_stack.ss_size  != suspect-&gt;uc_stack.ss_size) {
139     DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: failed test 1&quot;);)
140     return false;
141   }
142 
143   if (thread-&gt;is_Java_thread()) {
144     if (!valid_stack_address(thread, (address)suspect)) {
145       DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: uc_link not in thread stack&quot;);)
146       return false;
147     }
148     if (!valid_stack_address(thread,  (address) suspect-&gt;uc_mcontext.gregs[REG_SP])) {
149       DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: stackpointer not in thread stack&quot;);)
150       return false;
151     }
152   }
153   return true;
154 }
155 
156 // We will only follow one level of uc_link since there are libthread
157 // issues with ucontext linking and it is better to be safe and just
158 // let caller retry later.
159 const ucontext_t* os::Solaris::get_valid_uc_in_signal_handler(Thread *thread,
160   const ucontext_t *uc) {
161 
162   const ucontext_t *retuc = NULL;
163 
164   if (uc != NULL) {
165     if (uc-&gt;uc_link == NULL) {
166       // cannot validate without uc_link so accept current ucontext
167       retuc = uc;
168     } else if (os::Solaris::valid_ucontext(thread, uc, uc-&gt;uc_link)) {
169       // first ucontext is valid so try the next one
170       uc = uc-&gt;uc_link;
171       if (uc-&gt;uc_link == NULL) {
172         // cannot validate without uc_link so accept current ucontext
173         retuc = uc;
174       } else if (os::Solaris::valid_ucontext(thread, uc, uc-&gt;uc_link)) {
175         // the ucontext one level down is also valid so return it
176         retuc = uc;
177       }
178     }
179   }
180   return retuc;
181 }
182 
183 // Assumes ucontext is valid
184 ExtendedPC os::Solaris::ucontext_get_ExtendedPC(const ucontext_t *uc) {
185   return ExtendedPC((address)uc-&gt;uc_mcontext.gregs[REG_PC]);
186 }
187 
188 void os::Solaris::ucontext_set_pc(ucontext_t* uc, address pc) {
189   uc-&gt;uc_mcontext.gregs [REG_PC]  = (greg_t) pc;
190 }
191 
192 // Assumes ucontext is valid
193 intptr_t* os::Solaris::ucontext_get_sp(const ucontext_t *uc) {
194   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_SP];
195 }
196 
197 // Assumes ucontext is valid
198 intptr_t* os::Solaris::ucontext_get_fp(const ucontext_t *uc) {
199   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_FP];
200 }
201 
202 address os::Solaris::ucontext_get_pc(const ucontext_t *uc) {
203   return (address) uc-&gt;uc_mcontext.gregs[REG_PC];
204 }
205 
206 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
207 // is currently interrupted by SIGPROF.
208 //
209 // The difference between this and os::fetch_frame_from_context() is that
210 // here we try to skip nested signal frames.
211 // This method is also used for stack overflow signal handling.
212 ExtendedPC os::Solaris::fetch_frame_from_ucontext(Thread* thread,
213   const ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {
214 
215   assert(thread != NULL, &quot;just checking&quot;);
216   assert(ret_sp != NULL, &quot;just checking&quot;);
217   assert(ret_fp != NULL, &quot;just checking&quot;);
218 
219   const ucontext_t *luc = os::Solaris::get_valid_uc_in_signal_handler(thread, uc);
220   return os::fetch_frame_from_context(luc, ret_sp, ret_fp);
221 }
222 
223 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
224                     intptr_t** ret_sp, intptr_t** ret_fp) {
225 
226   ExtendedPC  epc;
227   const ucontext_t *uc = (const ucontext_t*)ucVoid;
228 
229   if (uc != NULL) {
230     epc = os::Solaris::ucontext_get_ExtendedPC(uc);
231     if (ret_sp) *ret_sp = os::Solaris::ucontext_get_sp(uc);
232     if (ret_fp) *ret_fp = os::Solaris::ucontext_get_fp(uc);
233   } else {
234     // construct empty ExtendedPC for return value checking
235     epc = ExtendedPC(NULL);
236     if (ret_sp) *ret_sp = (intptr_t *)NULL;
237     if (ret_fp) *ret_fp = (intptr_t *)NULL;
238   }
239 
240   return epc;
241 }
242 
243 frame os::fetch_frame_from_context(const void* ucVoid) {
244   intptr_t* sp;
245   intptr_t* fp;
246   ExtendedPC epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);
247   return frame(sp, fp, epc.pc());
248 }
249 
250 frame os::fetch_frame_from_ucontext(Thread* thread, void* ucVoid) {
251   intptr_t* sp;
252   intptr_t* fp;
253   ExtendedPC epc = os::Solaris::fetch_frame_from_ucontext(thread, (ucontext_t*)ucVoid, &amp;sp, &amp;fp);
254   return frame(sp, fp, epc.pc());
255 }
256 
257 bool os::Solaris::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
258  address pc = (address) os::Solaris::ucontext_get_pc(uc);
259   if (Interpreter::contains(pc)) {
260     // interpreter performs stack banging after the fixed frame header has
261     // been generated while the compilers perform it before. To maintain
262     // semantic consistency between interpreted and compiled frames, the
263     // method returns the Java sender of the current frame.
264     *fr = os::fetch_frame_from_ucontext(thread, uc);
265     if (!fr-&gt;is_first_java_frame()) {
266       // get_frame_at_stack_banging_point() is only called when we
267       // have well defined stacks so java_sender() calls do not need
268       // to assert safe_for_sender() first.
269       *fr = fr-&gt;java_sender();
270     }
271   } else {
272     // more complex code with compiled code
273     assert(!Interpreter::contains(pc), &quot;Interpreted methods should have been handled above&quot;);
274     CodeBlob* cb = CodeCache::find_blob(pc);
275     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {
276       // Not sure where the pc points to, fallback to default
277       // stack overflow handling
278       return false;
279     } else {
280       // in compiled code, the stack banging is performed just after the return pc
281       // has been pushed on the stack
282       intptr_t* fp = os::Solaris::ucontext_get_fp(uc);
283       intptr_t* sp = os::Solaris::ucontext_get_sp(uc);
284       *fr = frame(sp + 1, fp, (address)*sp);
285       if (!fr-&gt;is_java_frame()) {
286         // See java_sender() comment above.
287         *fr = fr-&gt;java_sender();
288       }
289     }
290   }
291   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
292   return true;
293 }
294 
295 frame os::get_sender_for_C_frame(frame* fr) {
296   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());
297 }
298 
299 extern &quot;C&quot; intptr_t *_get_current_sp();  // in .il file
300 
301 address os::current_stack_pointer() {
302   return (address)_get_current_sp();
303 }
304 
305 extern &quot;C&quot; intptr_t *_get_current_fp();  // in .il file
306 
307 frame os::current_frame() {
308   intptr_t* fp = _get_current_fp();  // it&#39;s inlined so want current fp
309   // fp is for os::current_frame. We want the fp for our caller.
310   frame myframe((intptr_t*)os::current_stack_pointer(),
311                 (intptr_t*)fp,
312                 CAST_FROM_FN_PTR(address, os::current_frame));
313   frame caller_frame = os::get_sender_for_C_frame(&amp;myframe);
314 
315   if (os::is_first_C_frame(&amp;caller_frame)) {
316     // stack is not walkable
317     frame ret; // This will be a null useless frame
318     return ret;
319   } else {
320     // return frame for our caller&#39;s caller
321     return os::get_sender_for_C_frame(&amp;caller_frame);
322   }
323 }
324 
325 #ifndef AMD64
326 
327 // Detecting SSE support by OS
328 // From solaris_i486.s
329 extern &quot;C&quot; bool sse_check();
330 extern &quot;C&quot; bool sse_unavailable();
331 
332 enum { SSE_UNKNOWN, SSE_NOT_SUPPORTED, SSE_SUPPORTED};
333 static int sse_status = SSE_UNKNOWN;
334 
335 
336 static void  check_for_sse_support() {
337   if (!VM_Version::supports_sse()) {
338     sse_status = SSE_NOT_SUPPORTED;
339     return;
340   }
341   // looking for _sse_hw in libc.so, if it does not exist or
342   // the value (int) is 0, OS has no support for SSE
343   int *sse_hwp;
344   void *h;
345 
346   if ((h=dlopen(&quot;/usr/lib/libc.so&quot;, RTLD_LAZY)) == NULL) {
347     //open failed, presume no support for SSE
348     sse_status = SSE_NOT_SUPPORTED;
349     return;
350   }
351   if ((sse_hwp = (int *)dlsym(h, &quot;_sse_hw&quot;)) == NULL) {
352     sse_status = SSE_NOT_SUPPORTED;
353   } else if (*sse_hwp == 0) {
354     sse_status = SSE_NOT_SUPPORTED;
355   }
356   dlclose(h);
357 
358   if (sse_status == SSE_UNKNOWN) {
359     bool (*try_sse)() = (bool (*)())sse_check;
360     sse_status = (*try_sse)() ? SSE_SUPPORTED : SSE_NOT_SUPPORTED;
361   }
362 
363 }
364 
365 #endif // AMD64
366 
367 bool os::supports_sse() {
368 #ifdef AMD64
369   return true;
370 #else
371   if (sse_status == SSE_UNKNOWN)
372     check_for_sse_support();
373   return sse_status == SSE_SUPPORTED;
374 #endif // AMD64
375 }
376 
377 bool os::is_allocatable(size_t bytes) {
378 #ifdef AMD64
379   return true;
380 #else
381 
382   if (bytes &lt; 2 * G) {
383     return true;
384   }
385 
386   char* addr = reserve_memory(bytes, NULL);
387 
388   if (addr != NULL) {
389     release_memory(addr, bytes);
390   }
391 
392   return addr != NULL;
393 #endif // AMD64
394 
395 }
396 
397 extern &quot;C&quot; JNIEXPORT int
398 JVM_handle_solaris_signal(int sig, siginfo_t* info, void* ucVoid,
399                           int abort_if_unrecognized) {
400   ucontext_t* uc = (ucontext_t*) ucVoid;
401 
402 #ifndef AMD64
403   if (sig == SIGILL &amp;&amp; info-&gt;si_addr == (caddr_t)sse_check) {
404     // the SSE instruction faulted. supports_sse() need return false.
405     uc-&gt;uc_mcontext.gregs[EIP] = (greg_t)sse_unavailable;
406     return true;
407   }
408 #endif // !AMD64
409 
410   Thread* t = Thread::current_or_null_safe();
411 
412   // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away
413   // (no destructors can be run)
414   os::ThreadCrashProtection::check_crash_protection(sig, t);
415 
416   SignalHandlerMark shm(t);
417 
418   if(sig == SIGPIPE || sig == SIGXFSZ) {
419     if (os::Solaris::chained_handler(sig, info, ucVoid)) {
420       return true;
421     } else {
422       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
423       return true;
424     }
425   }
426 
427   JavaThread* thread = NULL;
428   VMThread* vmthread = NULL;
429 
430   if (os::Solaris::signal_handlers_are_installed) {
431     if (t != NULL ){
432       if(t-&gt;is_Java_thread()) {
433         thread = (JavaThread*)t;
434       }
435       else if(t-&gt;is_VM_thread()){
436         vmthread = (VMThread *)t;
437       }
438     }
439   }
440 
441   if (sig == ASYNC_SIGNAL) {
442     if(thread || vmthread){
443       OSThread::SR_handler(t, uc);
444       return true;
445     } else if (os::Solaris::chained_handler(sig, info, ucVoid)) {
446       return true;
447     } else {
448       // If ASYNC_SIGNAL not chained, and this is a non-vm and
449       // non-java thread
450       return true;
451     }
452   }
453 
454   if (info == NULL || info-&gt;si_code &lt;= 0 || info-&gt;si_code == SI_NOINFO) {
455     // can&#39;t decode this kind of signal
456     info = NULL;
457   } else {
458     assert(sig == info-&gt;si_signo, &quot;bad siginfo&quot;);
459   }
460 
461   // decide if this trap can be handled by a stub
462   address stub = NULL;
463 
464   address pc          = NULL;
465 
466   //%note os_trap_1
467   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
468     // factor me: getPCfromContext
469     pc = (address) uc-&gt;uc_mcontext.gregs[REG_PC];
470 
471     if (StubRoutines::is_safefetch_fault(pc)) {
472       os::Solaris::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
473       return true;
474     }
475 
476     // Handle ALL stack overflow variations here
477     if (sig == SIGSEGV &amp;&amp; info-&gt;si_code == SEGV_ACCERR) {
478       address addr = (address) info-&gt;si_addr;
479       if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
480         if (thread-&gt;thread_state() == _thread_in_Java) {
481           if (thread-&gt;in_stack_reserved_zone(addr)) {
482             frame fr;
483             if (os::Solaris::get_frame_at_stack_banging_point(thread, uc, &amp;fr)) {
484               assert(fr.is_java_frame(), &quot;Must be Java frame&quot;);
485               frame activation = SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
486               if (activation.sp() != NULL) {
487                 thread-&gt;disable_stack_reserved_zone();
488                 if (activation.is_interpreted_frame()) {
489                   thread-&gt;set_reserved_stack_activation((address)(
490                     activation.fp() + frame::interpreter_frame_initial_sp_offset));
491                 } else {
492                   thread-&gt;set_reserved_stack_activation((address)activation.unextended_sp());
493                 }
494                 return true;
495               }
496             }
497           }
498           // Throw a stack overflow exception.  Guard pages will be reenabled
499           // while unwinding the stack.
500           thread-&gt;disable_stack_yellow_reserved_zone();
501           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
502         } else {
503           // Thread was in the vm or native code.  Return and try to finish.
504           thread-&gt;disable_stack_yellow_reserved_zone();
505           return true;
506         }
507       } else if (thread-&gt;in_stack_red_zone(addr)) {
508         // Fatal red zone violation.  Disable the guard pages and fall through
509         // to handle_unexpected_exception way down below.
510         thread-&gt;disable_stack_red_zone();
511         tty-&gt;print_raw_cr(&quot;An irrecoverable stack overflow has occurred.&quot;);
512       }
513     }
514 
515     if ((sig == SIGSEGV) &amp;&amp; VM_Version::is_cpuinfo_segv_addr(pc)) {
516       // Verify that OS save/restore AVX registers.
517       stub = VM_Version::cpuinfo_cont_addr();
518     }
519 
<a name="3" id="anc3"></a><span class="line-modified">520     if (thread-&gt;thread_state() == _thread_in_vm) {</span>

521       if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR &amp;&amp; thread-&gt;doing_unsafe_access()) {
522         address next_pc = Assembler::locate_next_instruction(pc);
<a name="4" id="anc4"></a>


523         stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
524       }
525     }
526 
527     if (thread-&gt;thread_state() == _thread_in_Java) {
528       // Support Safepoint Polling
529       if ( sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {
530         stub = SharedRuntime::get_poll_stub(pc);
531       }
532       else if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR) {
533         // BugId 4454115: A read from a MappedByteBuffer can fault
534         // here if the underlying file has been truncated.
535         // Do not crash the VM in such a case.
536         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
537         if (cb != NULL) {
538           CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
<a name="5" id="anc5"></a><span class="line-modified">539           if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {</span>

540             address next_pc = Assembler::locate_next_instruction(pc);
<a name="6" id="anc6"></a>


541             stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
542           }
543         }
544       }
545       else
546       if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_INTDIV) {
547         // integer divide by zero
548         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
549       }
550 #ifndef AMD64
551       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTDIV) {
552         // floating-point divide by zero
553         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
554       }
555       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTINV) {
556         // The encoding of D2I in i486.ad can cause an exception prior
557         // to the fist instruction if there was an invalid operation
558         // pending. We want to dismiss that exception. From the win_32
559         // side it also seems that if it really was the fist causing
560         // the exception that we do the d2i by hand with different
561         // rounding. Seems kind of weird. QQQ TODO
562         // Note that we take the exception at the NEXT floating point instruction.
563         if (pc[0] == 0xDB) {
564             assert(pc[0] == 0xDB, &quot;not a FIST opcode&quot;);
565             assert(pc[1] == 0x14, &quot;not a FIST opcode&quot;);
566             assert(pc[2] == 0x24, &quot;not a FIST opcode&quot;);
567             return true;
568         } else {
569             assert(pc[-3] == 0xDB, &quot;not an flt invalid opcode&quot;);
570             assert(pc[-2] == 0x14, &quot;not an flt invalid opcode&quot;);
571             assert(pc[-1] == 0x24, &quot;not an flt invalid opcode&quot;);
572         }
573       }
574       else if (sig == SIGFPE ) {
575         tty-&gt;print_cr(&quot;caught SIGFPE, info 0x%x.&quot;, info-&gt;si_code);
576       }
577 #endif // !AMD64
578 
579         // QQQ It doesn&#39;t seem that we need to do this on x86 because we should be able
580         // to return properly from the handler without this extra stuff on the back side.
581 
582       else if (sig == SIGSEGV &amp;&amp; info-&gt;si_code &gt; 0 &amp;&amp;
583                MacroAssembler::uses_implicit_null_check(info-&gt;si_addr)) {
584         // Determination of interpreter/vtable stub/compiled code null exception
585         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
586       }
587     }
588 
589     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in
590     // and the heap gets shrunk before the field access.
591     if ((sig == SIGSEGV) || (sig == SIGBUS)) {
592       address addr = JNI_FastGetField::find_slowcase_pc(pc);
593       if (addr != (address)-1) {
594         stub = addr;
595       }
596     }
597   }
598 
599   // Execution protection violation
600   //
601   // Preventative code for future versions of Solaris which may
602   // enable execution protection when running the 32-bit VM on AMD64.
603   //
604   // This should be kept as the last step in the triage.  We don&#39;t
605   // have a dedicated trap number for a no-execute fault, so be
606   // conservative and allow other handlers the first shot.
607   //
608   // Note: We don&#39;t test that info-&gt;si_code == SEGV_ACCERR here.
609   // this si_code is so generic that it is almost meaningless; and
610   // the si_code for this condition may change in the future.
611   // Furthermore, a false-positive should be harmless.
612   if (UnguardOnExecutionViolation &gt; 0 &amp;&amp;
613       (sig == SIGSEGV || sig == SIGBUS) &amp;&amp;
614       uc-&gt;uc_mcontext.gregs[TRAPNO] == T_PGFLT) {  // page fault
615     int page_size = os::vm_page_size();
616     address addr = (address) info-&gt;si_addr;
617     address pc = (address) uc-&gt;uc_mcontext.gregs[REG_PC];
618     // Make sure the pc and the faulting address are sane.
619     //
620     // If an instruction spans a page boundary, and the page containing
621     // the beginning of the instruction is executable but the following
622     // page is not, the pc and the faulting address might be slightly
623     // different - we still want to unguard the 2nd page in this case.
624     //
625     // 15 bytes seems to be a (very) safe value for max instruction size.
626     bool pc_is_near_addr =
627       (pointer_delta((void*) addr, (void*) pc, sizeof(char)) &lt; 15);
628     bool instr_spans_page_boundary =
629       (align_down((intptr_t) pc ^ (intptr_t) addr,
630                        (intptr_t) page_size) &gt; 0);
631 
632     if (pc == addr || (pc_is_near_addr &amp;&amp; instr_spans_page_boundary)) {
633       static volatile address last_addr =
634         (address) os::non_memory_address_word();
635 
636       // In conservative mode, don&#39;t unguard unless the address is in the VM
637       if (addr != last_addr &amp;&amp;
638           (UnguardOnExecutionViolation &gt; 1 || os::address_is_in_vm(addr))) {
639 
640         // Make memory rwx and retry
641         address page_start = align_down(addr, page_size);
642         bool res = os::protect_memory((char*) page_start, page_size,
643                                       os::MEM_PROT_RWX);
644 
645         log_debug(os)(&quot;Execution protection violation &quot;
646                       &quot;at &quot; INTPTR_FORMAT
647                       &quot;, unguarding &quot; INTPTR_FORMAT &quot;: %s, errno=%d&quot;, p2i(addr),
648                       p2i(page_start), (res ? &quot;success&quot; : &quot;failed&quot;), errno);
649         stub = pc;
650 
651         // Set last_addr so if we fault again at the same address, we don&#39;t end
652         // up in an endless loop.
653         //
654         // There are two potential complications here.  Two threads trapping at
655         // the same address at the same time could cause one of the threads to
656         // think it already unguarded, and abort the VM.  Likely very rare.
657         //
658         // The other race involves two threads alternately trapping at
659         // different addresses and failing to unguard the page, resulting in
660         // an endless loop.  This condition is probably even more unlikely than
661         // the first.
662         //
663         // Although both cases could be avoided by using locks or thread local
664         // last_addr, these solutions are unnecessary complication: this
665         // handler is a best-effort safety net, not a complete solution.  It is
666         // disabled by default and should only be used as a workaround in case
667         // we missed any no-execute-unsafe VM code.
668 
669         last_addr = addr;
670       }
671     }
672   }
673 
674   if (stub != NULL) {
675     // save all thread context in case we need to restore it
676 
677     if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);
678     // 12/02/99: On Sparc it appears that the full context is also saved
679     // but as yet, no one looks at or restores that saved context
680     os::Solaris::ucontext_set_pc(uc, stub);
681     return true;
682   }
683 
684   // signal-chaining
685   if (os::Solaris::chained_handler(sig, info, ucVoid)) {
686     return true;
687   }
688 
689   if (!abort_if_unrecognized) {
690     // caller wants another chance, so give it to him
691     return false;
692   }
693 
694   if (!os::Solaris::libjsig_is_loaded) {
695     struct sigaction oldAct;
696     sigaction(sig, (struct sigaction *)0, &amp;oldAct);
697     if (oldAct.sa_sigaction != signalHandler) {
698       void* sighand = oldAct.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)
699                                           : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);
700       warning(&quot;Unexpected Signal %d occurred under user-defined signal handler %#lx&quot;, sig, (long)sighand);
701     }
702   }
703 
704   if (pc == NULL &amp;&amp; uc != NULL) {
705     pc = (address) uc-&gt;uc_mcontext.gregs[REG_PC];
706   }
707 
708   // unmask current signal
709   sigset_t newset;
710   sigemptyset(&amp;newset);
711   sigaddset(&amp;newset, sig);
712   sigprocmask(SIG_UNBLOCK, &amp;newset, NULL);
713 
714   // Determine which sort of error to throw.  Out of swap may signal
715   // on the thread stack, which could get a mapping error when touched.
716   address addr = (address) info-&gt;si_addr;
717   if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR &amp;&amp; info-&gt;si_errno == ENOMEM) {
718     vm_exit_out_of_memory(0, OOM_MMAP_ERROR, &quot;Out of swap space to map in thread stack.&quot;);
719   }
720 
721   VMError::report_and_die(t, sig, pc, info, ucVoid);
722 
723   ShouldNotReachHere();
724   return false;
725 }
726 
727 void os::print_context(outputStream *st, const void *context) {
728   if (context == NULL) return;
729 
730   const ucontext_t *uc = (const ucontext_t*)context;
731   st-&gt;print_cr(&quot;Registers:&quot;);
732 #ifdef AMD64
733   st-&gt;print(  &quot;RAX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RAX]);
734   st-&gt;print(&quot;, RBX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBX]);
735   st-&gt;print(&quot;, RCX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RCX]);
736   st-&gt;print(&quot;, RDX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDX]);
737   st-&gt;cr();
738   st-&gt;print(  &quot;RSP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSP]);
739   st-&gt;print(&quot;, RBP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBP]);
740   st-&gt;print(&quot;, RSI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSI]);
741   st-&gt;print(&quot;, RDI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDI]);
742   st-&gt;cr();
743   st-&gt;print(  &quot;R8 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R8]);
744   st-&gt;print(&quot;, R9 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R9]);
745   st-&gt;print(&quot;, R10=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R10]);
746   st-&gt;print(&quot;, R11=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R11]);
747   st-&gt;cr();
748   st-&gt;print(  &quot;R12=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R12]);
749   st-&gt;print(&quot;, R13=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R13]);
750   st-&gt;print(&quot;, R14=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R14]);
751   st-&gt;print(&quot;, R15=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R15]);
752   st-&gt;cr();
753   st-&gt;print(  &quot;RIP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RIP]);
754   st-&gt;print(&quot;, RFLAGS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RFL]);
755 #else
756   st-&gt;print(  &quot;EAX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EAX]);
757   st-&gt;print(&quot;, EBX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EBX]);
758   st-&gt;print(&quot;, ECX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[ECX]);
759   st-&gt;print(&quot;, EDX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EDX]);
760   st-&gt;cr();
761   st-&gt;print(  &quot;ESP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[UESP]);
762   st-&gt;print(&quot;, EBP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EBP]);
763   st-&gt;print(&quot;, ESI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[ESI]);
764   st-&gt;print(&quot;, EDI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EDI]);
765   st-&gt;cr();
766   st-&gt;print(  &quot;EIP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EIP]);
767   st-&gt;print(&quot;, EFLAGS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EFL]);
768 #endif // AMD64
769   st-&gt;cr();
770   st-&gt;cr();
771 
772   intptr_t *sp = (intptr_t *)os::Solaris::ucontext_get_sp(uc);
773   st-&gt;print_cr(&quot;Top of Stack: (sp=&quot; PTR_FORMAT &quot;)&quot;, sp);
774   print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));
775   st-&gt;cr();
776 
777   // Note: it may be unsafe to inspect memory near pc. For example, pc may
778   // point to garbage if entry point in an nmethod is corrupted. Leave
779   // this at the end, and hope for the best.
780   ExtendedPC epc = os::Solaris::ucontext_get_ExtendedPC(uc);
781   address pc = epc.pc();
782   print_instructions(st, pc, sizeof(char));
783   st-&gt;cr();
784 }
785 
786 void os::print_register_info(outputStream *st, const void *context) {
787   if (context == NULL) return;
788 
789   const ucontext_t *uc = (const ucontext_t*)context;
790 
791   st-&gt;print_cr(&quot;Register to memory mapping:&quot;);
792   st-&gt;cr();
793 
794   // this is horrendously verbose but the layout of the registers in the
795   // context does not match how we defined our abstract Register set, so
796   // we can&#39;t just iterate through the gregs area
797 
798   // this is only for the &quot;general purpose&quot; registers
799 
800 #ifdef AMD64
801   st-&gt;print(&quot;RAX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RAX]);
802   st-&gt;print(&quot;RBX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RBX]);
803   st-&gt;print(&quot;RCX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RCX]);
804   st-&gt;print(&quot;RDX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RDX]);
805   st-&gt;print(&quot;RSP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RSP]);
806   st-&gt;print(&quot;RBP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RBP]);
807   st-&gt;print(&quot;RSI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RSI]);
808   st-&gt;print(&quot;RDI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RDI]);
809   st-&gt;print(&quot;R8 =&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R8]);
810   st-&gt;print(&quot;R9 =&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R9]);
811   st-&gt;print(&quot;R10=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R10]);
812   st-&gt;print(&quot;R11=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R11]);
813   st-&gt;print(&quot;R12=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R12]);
814   st-&gt;print(&quot;R13=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R13]);
815   st-&gt;print(&quot;R14=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R14]);
816   st-&gt;print(&quot;R15=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R15]);
817 #else
818   st-&gt;print(&quot;EAX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EAX]);
819   st-&gt;print(&quot;EBX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EBX]);
820   st-&gt;print(&quot;ECX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[ECX]);
821   st-&gt;print(&quot;EDX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EDX]);
822   st-&gt;print(&quot;ESP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[UESP]);
823   st-&gt;print(&quot;EBP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EBP]);
824   st-&gt;print(&quot;ESI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[ESI]);
825   st-&gt;print(&quot;EDI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EDI]);
826 #endif
827 
828   st-&gt;cr();
829 }
830 
831 
832 #ifdef AMD64
833 void os::Solaris::init_thread_fpu_state(void) {
834   // Nothing to do
835 }
836 #else
837 // From solaris_i486.s
838 extern &quot;C&quot; void fixcw();
839 
840 void os::Solaris::init_thread_fpu_state(void) {
841   // Set fpu to 53 bit precision. This happens too early to use a stub.
842   fixcw();
843 }
844 
845 // These routines are the initial value of atomic_xchg_entry(),
846 // atomic_cmpxchg_entry(), atomic_inc_entry() and fence_entry()
847 // until initialization is complete.
848 // TODO - replace with .il implementation when compiler supports it.
849 
850 typedef int32_t  xchg_func_t        (int32_t,  volatile int32_t*);
851 typedef int32_t  cmpxchg_func_t     (int32_t,  volatile int32_t*,  int32_t);
852 typedef int64_t  cmpxchg_long_func_t(int64_t,  volatile int64_t*,  int64_t);
853 typedef int32_t  add_func_t         (int32_t,  volatile int32_t*);
854 
855 int32_t os::atomic_xchg_bootstrap(int32_t exchange_value, volatile int32_t* dest) {
856   // try to use the stub:
857   xchg_func_t* func = CAST_TO_FN_PTR(xchg_func_t*, StubRoutines::atomic_xchg_entry());
858 
859   if (func != NULL) {
860     os::atomic_xchg_func = func;
861     return (*func)(exchange_value, dest);
862   }
863   assert(Threads::number_of_threads() == 0, &quot;for bootstrap only&quot;);
864 
865   int32_t old_value = *dest;
866   *dest = exchange_value;
867   return old_value;
868 }
869 
870 int32_t os::atomic_cmpxchg_bootstrap(int32_t exchange_value, volatile int32_t* dest, int32_t compare_value) {
871   // try to use the stub:
872   cmpxchg_func_t* func = CAST_TO_FN_PTR(cmpxchg_func_t*, StubRoutines::atomic_cmpxchg_entry());
873 
874   if (func != NULL) {
875     os::atomic_cmpxchg_func = func;
876     return (*func)(exchange_value, dest, compare_value);
877   }
878   assert(Threads::number_of_threads() == 0, &quot;for bootstrap only&quot;);
879 
880   int32_t old_value = *dest;
881   if (old_value == compare_value)
882     *dest = exchange_value;
883   return old_value;
884 }
885 
886 int64_t os::atomic_cmpxchg_long_bootstrap(int64_t exchange_value, volatile int64_t* dest, int64_t compare_value) {
887   // try to use the stub:
888   cmpxchg_long_func_t* func = CAST_TO_FN_PTR(cmpxchg_long_func_t*, StubRoutines::atomic_cmpxchg_long_entry());
889 
890   if (func != NULL) {
891     os::atomic_cmpxchg_long_func = func;
892     return (*func)(exchange_value, dest, compare_value);
893   }
894   assert(Threads::number_of_threads() == 0, &quot;for bootstrap only&quot;);
895 
896   int64_t old_value = *dest;
897   if (old_value == compare_value)
898     *dest = exchange_value;
899   return old_value;
900 }
901 
902 int32_t os::atomic_add_bootstrap(int32_t add_value, volatile int32_t* dest) {
903   // try to use the stub:
904   add_func_t* func = CAST_TO_FN_PTR(add_func_t*, StubRoutines::atomic_add_entry());
905 
906   if (func != NULL) {
907     os::atomic_add_func = func;
908     return (*func)(add_value, dest);
909   }
910   assert(Threads::number_of_threads() == 0, &quot;for bootstrap only&quot;);
911 
912   return (*dest) += add_value;
913 }
914 
915 xchg_func_t*         os::atomic_xchg_func         = os::atomic_xchg_bootstrap;
916 cmpxchg_func_t*      os::atomic_cmpxchg_func      = os::atomic_cmpxchg_bootstrap;
917 cmpxchg_long_func_t* os::atomic_cmpxchg_long_func = os::atomic_cmpxchg_long_bootstrap;
918 add_func_t*          os::atomic_add_func          = os::atomic_add_bootstrap;
919 
920 extern &quot;C&quot; void _solaris_raw_setup_fpu(address ptr);
921 void os::setup_fpu() {
922   address fpu_cntrl = StubRoutines::addr_fpu_cntrl_wrd_std();
923   _solaris_raw_setup_fpu(fpu_cntrl);
924 }
925 #endif // AMD64
926 
927 #ifndef PRODUCT
928 void os::verify_stack_alignment() {
929 #ifdef AMD64
930   assert(((intptr_t)os::current_stack_pointer() &amp; (StackAlignmentInBytes-1)) == 0, &quot;incorrect stack alignment&quot;);
931 #endif
932 }
933 #endif
934 
935 int os::extra_bang_size_in_bytes() {
936   // JDK-8050147 requires the full cache line bang for x86.
937   return VM_Version::L1_line_size();
938 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
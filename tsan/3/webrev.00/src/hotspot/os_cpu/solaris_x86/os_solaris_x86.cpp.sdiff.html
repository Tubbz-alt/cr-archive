<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/solaris_x86/os_solaris_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess_solaris_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="solaris_x86_64.il.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/solaris_x86/os_solaris_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // no precompiled headers
 26 #include &quot;jvm.h&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;code/codeCache.hpp&quot;
 32 #include &quot;code/icBuffer.hpp&quot;
 33 #include &quot;code/vtableStubs.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;os_share_solaris.hpp&quot;
 38 #include &quot;prims/jniFastGetField.hpp&quot;
 39 #include &quot;prims/jvm_misc.hpp&quot;
 40 #include &quot;runtime/arguments.hpp&quot;
<span class="line-removed"> 41 #include &quot;runtime/atomic.hpp&quot;</span>
 42 #include &quot;runtime/extendedPC.hpp&quot;
 43 #include &quot;runtime/frame.inline.hpp&quot;
 44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 45 #include &quot;runtime/java.hpp&quot;
 46 #include &quot;runtime/javaCalls.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/osThread.hpp&quot;
 49 #include &quot;runtime/sharedRuntime.hpp&quot;
 50 #include &quot;runtime/stubRoutines.hpp&quot;
 51 #include &quot;runtime/thread.inline.hpp&quot;
 52 #include &quot;runtime/timer.hpp&quot;
 53 #include &quot;utilities/align.hpp&quot;
 54 #include &quot;utilities/events.hpp&quot;
 55 #include &quot;utilities/vmError.hpp&quot;
 56 
 57 // put OS-includes here
 58 # include &lt;sys/types.h&gt;
 59 # include &lt;sys/mman.h&gt;
 60 # include &lt;pthread.h&gt;
 61 # include &lt;signal.h&gt;
</pre>
<hr />
<pre>
500           thread-&gt;disable_stack_yellow_reserved_zone();
501           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
502         } else {
503           // Thread was in the vm or native code.  Return and try to finish.
504           thread-&gt;disable_stack_yellow_reserved_zone();
505           return true;
506         }
507       } else if (thread-&gt;in_stack_red_zone(addr)) {
508         // Fatal red zone violation.  Disable the guard pages and fall through
509         // to handle_unexpected_exception way down below.
510         thread-&gt;disable_stack_red_zone();
511         tty-&gt;print_raw_cr(&quot;An irrecoverable stack overflow has occurred.&quot;);
512       }
513     }
514 
515     if ((sig == SIGSEGV) &amp;&amp; VM_Version::is_cpuinfo_segv_addr(pc)) {
516       // Verify that OS save/restore AVX registers.
517       stub = VM_Version::cpuinfo_cont_addr();
518     }
519 
<span class="line-modified">520     if (thread-&gt;thread_state() == _thread_in_vm) {</span>

521       if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR &amp;&amp; thread-&gt;doing_unsafe_access()) {
522         address next_pc = Assembler::locate_next_instruction(pc);



523         stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
524       }
525     }
526 
527     if (thread-&gt;thread_state() == _thread_in_Java) {
528       // Support Safepoint Polling
529       if ( sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {
530         stub = SharedRuntime::get_poll_stub(pc);
531       }
532       else if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR) {
533         // BugId 4454115: A read from a MappedByteBuffer can fault
534         // here if the underlying file has been truncated.
535         // Do not crash the VM in such a case.
536         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
537         if (cb != NULL) {
538           CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
<span class="line-modified">539           if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {</span>

540             address next_pc = Assembler::locate_next_instruction(pc);



541             stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
542           }
543         }
544       }
545       else
546       if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_INTDIV) {
547         // integer divide by zero
548         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
549       }
550 #ifndef AMD64
551       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTDIV) {
552         // floating-point divide by zero
553         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
554       }
555       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTINV) {
556         // The encoding of D2I in i486.ad can cause an exception prior
557         // to the fist instruction if there was an invalid operation
558         // pending. We want to dismiss that exception. From the win_32
559         // side it also seems that if it really was the fist causing
560         // the exception that we do the d2i by hand with different
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // no precompiled headers
 26 #include &quot;jvm.h&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;code/codeCache.hpp&quot;
 32 #include &quot;code/icBuffer.hpp&quot;
 33 #include &quot;code/vtableStubs.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;os_share_solaris.hpp&quot;
 38 #include &quot;prims/jniFastGetField.hpp&quot;
 39 #include &quot;prims/jvm_misc.hpp&quot;
 40 #include &quot;runtime/arguments.hpp&quot;

 41 #include &quot;runtime/extendedPC.hpp&quot;
 42 #include &quot;runtime/frame.inline.hpp&quot;
 43 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 44 #include &quot;runtime/java.hpp&quot;
 45 #include &quot;runtime/javaCalls.hpp&quot;
 46 #include &quot;runtime/mutexLocker.hpp&quot;
 47 #include &quot;runtime/osThread.hpp&quot;
 48 #include &quot;runtime/sharedRuntime.hpp&quot;
 49 #include &quot;runtime/stubRoutines.hpp&quot;
 50 #include &quot;runtime/thread.inline.hpp&quot;
 51 #include &quot;runtime/timer.hpp&quot;
 52 #include &quot;utilities/align.hpp&quot;
 53 #include &quot;utilities/events.hpp&quot;
 54 #include &quot;utilities/vmError.hpp&quot;
 55 
 56 // put OS-includes here
 57 # include &lt;sys/types.h&gt;
 58 # include &lt;sys/mman.h&gt;
 59 # include &lt;pthread.h&gt;
 60 # include &lt;signal.h&gt;
</pre>
<hr />
<pre>
499           thread-&gt;disable_stack_yellow_reserved_zone();
500           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
501         } else {
502           // Thread was in the vm or native code.  Return and try to finish.
503           thread-&gt;disable_stack_yellow_reserved_zone();
504           return true;
505         }
506       } else if (thread-&gt;in_stack_red_zone(addr)) {
507         // Fatal red zone violation.  Disable the guard pages and fall through
508         // to handle_unexpected_exception way down below.
509         thread-&gt;disable_stack_red_zone();
510         tty-&gt;print_raw_cr(&quot;An irrecoverable stack overflow has occurred.&quot;);
511       }
512     }
513 
514     if ((sig == SIGSEGV) &amp;&amp; VM_Version::is_cpuinfo_segv_addr(pc)) {
515       // Verify that OS save/restore AVX registers.
516       stub = VM_Version::cpuinfo_cont_addr();
517     }
518 
<span class="line-modified">519     if (thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">520          thread-&gt;thread_state() == _thread_in_native) {</span>
521       if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR &amp;&amp; thread-&gt;doing_unsafe_access()) {
522         address next_pc = Assembler::locate_next_instruction(pc);
<span class="line-added">523         if (UnsafeCopyMemory::contains_pc(pc)) {</span>
<span class="line-added">524           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">525         }</span>
526         stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
527       }
528     }
529 
530     if (thread-&gt;thread_state() == _thread_in_Java) {
531       // Support Safepoint Polling
532       if ( sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {
533         stub = SharedRuntime::get_poll_stub(pc);
534       }
535       else if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR) {
536         // BugId 4454115: A read from a MappedByteBuffer can fault
537         // here if the underlying file has been truncated.
538         // Do not crash the VM in such a case.
539         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
540         if (cb != NULL) {
541           CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
<span class="line-modified">542           bool is_unsafe_arraycopy = thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc);</span>
<span class="line-added">543           if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {</span>
544             address next_pc = Assembler::locate_next_instruction(pc);
<span class="line-added">545             if (is_unsafe_arraycopy) {</span>
<span class="line-added">546               next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">547             }</span>
548             stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
549           }
550         }
551       }
552       else
553       if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_INTDIV) {
554         // integer divide by zero
555         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
556       }
557 #ifndef AMD64
558       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTDIV) {
559         // floating-point divide by zero
560         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
561       }
562       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTINV) {
563         // The encoding of D2I in i486.ad can cause an exception prior
564         // to the fist instruction if there was an invalid operation
565         // pending. We want to dismiss that exception. From the win_32
566         // side it also seems that if it really was the fist causing
567         // the exception that we do the d2i by hand with different
</pre>
</td>
</tr>
</table>
<center><a href="orderAccess_solaris_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="solaris_x86_64.il.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
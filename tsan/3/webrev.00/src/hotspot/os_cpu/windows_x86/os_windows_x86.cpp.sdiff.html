<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/windows_x86/os_windows_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess_windows_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_windows_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/windows_x86/os_windows_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
448   }
449 
450   return epc;
451 }
452 
453 frame os::fetch_frame_from_context(const void* ucVoid) {
454   intptr_t* sp;
455   intptr_t* fp;
456   ExtendedPC epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);
457   return frame(sp, fp, epc.pc());
458 }
459 
460 // VC++ does not save frame pointer on stack in optimized build. It
461 // can be turned off by /Oy-. If we really want to walk C frames,
462 // we can use the StackWalk() API.
463 frame os::get_sender_for_C_frame(frame* fr) {
464   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());
465 }
466 
467 #ifndef AMD64



468 // Returns an estimate of the current stack pointer. Result must be guaranteed
469 // to point into the calling threads stack, and be no lower than the current
470 // stack pointer.
471 address os::current_stack_pointer() {
472   int dummy;
473   address sp = (address)&amp;dummy;
474   return sp;
475 }

476 #else
477 // Returns the current stack pointer. Accurate value needed for
478 // os::verify_stack_alignment().
479 address os::current_stack_pointer() {
480   typedef address get_sp_func();
481   get_sp_func* func = CAST_TO_FN_PTR(get_sp_func*,
482                                      StubRoutines::x86::get_previous_sp_entry());
483   return (*func)();
484 }
485 #endif
486 
487 
488 #ifndef AMD64
489 intptr_t* _get_previous_fp() {
490   intptr_t **frameptr;
491   __asm {
492     mov frameptr, ebp
493   };
494   // ebp (frameptr) is for this frame (_get_previous_fp). We want the ebp for the
495   // caller of os::current_frame*(), so go up two frames. However, for
</pre>
</td>
<td>
<hr />
<pre>
448   }
449 
450   return epc;
451 }
452 
453 frame os::fetch_frame_from_context(const void* ucVoid) {
454   intptr_t* sp;
455   intptr_t* fp;
456   ExtendedPC epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);
457   return frame(sp, fp, epc.pc());
458 }
459 
460 // VC++ does not save frame pointer on stack in optimized build. It
461 // can be turned off by /Oy-. If we really want to walk C frames,
462 // we can use the StackWalk() API.
463 frame os::get_sender_for_C_frame(frame* fr) {
464   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());
465 }
466 
467 #ifndef AMD64
<span class="line-added">468 // Ignore &quot;C4172: returning address of local variable or temporary&quot; on 32bit</span>
<span class="line-added">469 PRAGMA_DIAG_PUSH</span>
<span class="line-added">470 PRAGMA_DISABLE_MSVC_WARNING(4172)</span>
471 // Returns an estimate of the current stack pointer. Result must be guaranteed
472 // to point into the calling threads stack, and be no lower than the current
473 // stack pointer.
474 address os::current_stack_pointer() {
475   int dummy;
476   address sp = (address)&amp;dummy;
477   return sp;
478 }
<span class="line-added">479 PRAGMA_DIAG_POP</span>
480 #else
481 // Returns the current stack pointer. Accurate value needed for
482 // os::verify_stack_alignment().
483 address os::current_stack_pointer() {
484   typedef address get_sp_func();
485   get_sp_func* func = CAST_TO_FN_PTR(get_sp_func*,
486                                      StubRoutines::x86::get_previous_sp_entry());
487   return (*func)();
488 }
489 #endif
490 
491 
492 #ifndef AMD64
493 intptr_t* _get_previous_fp() {
494   intptr_t **frameptr;
495   __asm {
496     mov frameptr, ebp
497   };
498   // ebp (frameptr) is for this frame (_get_previous_fp). We want the ebp for the
499   // caller of os::current_frame*(), so go up two frames. However, for
</pre>
</td>
</tr>
</table>
<center><a href="orderAccess_windows_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_windows_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
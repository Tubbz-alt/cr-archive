<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/solaris_sparc/os_solaris_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess_solaris_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_solaris_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/solaris_sparc/os_solaris_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 69 # include &lt;sys/time.h&gt;
 70 # include &lt;sys/filio.h&gt;
 71 # include &lt;sys/utsname.h&gt;
 72 # include &lt;sys/systeminfo.h&gt;
 73 # include &lt;sys/socket.h&gt;
 74 # include &lt;sys/lwp.h&gt;
 75 # include &lt;poll.h&gt;
 76 # include &lt;sys/lwp.h&gt;
 77 
 78 # define _STRUCTURED_PROC 1  //  this gets us the new structured proc interfaces of 5.6 &amp; later
 79 # include &lt;sys/procfs.h&gt;     //  see comment in &lt;sys/procfs.h&gt;
 80 
 81 #define MAX_PATH (2 * K)
 82 
 83 // Minimum usable stack sizes required to get to user code. Space for
 84 // HotSpot guard pages is added later.
 85 size_t os::Posix::_compiler_thread_min_stack_allowed = 104 * K;
 86 size_t os::Posix::_java_thread_min_stack_allowed = 86 * K;
 87 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 128 * K;
 88 
<span class="line-removed"> 89 int os::Solaris::max_register_window_saves_before_flushing() {</span>
<span class="line-removed"> 90   // We should detect this at run time. For now, filling</span>
<span class="line-removed"> 91   // in with a constant.</span>
<span class="line-removed"> 92   return 8;</span>
<span class="line-removed"> 93 }</span>
<span class="line-removed"> 94 </span>
 95 static void handle_unflushed_register_windows(gwindows_t *win) {
 96   int restore_count = win-&gt;wbcnt;
 97   int i;
 98 
 99   for(i=0; i&lt;restore_count; i++) {
100     address sp = ((address)win-&gt;spbuf[i]) + STACK_BIAS;
101     address reg_win = (address)&amp;win-&gt;wbuf[i];
102     memcpy(sp,reg_win,sizeof(struct rwindow));
103   }
104 }
105 
106 char* os::non_memory_address_word() {
107   // Must never look like an address returned by reserve_memory,
108   // even in its subfields (as defined by the CPU immediate fields,
109   // if the CPU splits constants across multiple instructions).
110   // On SPARC, 0 != %hi(any real address), because there is no
111   // allocation in the first 1Kb of the virtual address space.
112   return (char*) 0;
113 }
114 
</pre>
<hr />
<pre>
419           thread-&gt;disable_stack_yellow_reserved_zone();
420           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
421         } else {
422           // Thread was in the vm or native code.  Return and try to finish.
423           thread-&gt;disable_stack_yellow_reserved_zone();
424           return true;
425         }
426       } else if (thread-&gt;in_stack_red_zone(addr)) {
427         // Fatal red zone violation.  Disable the guard pages and fall through
428         // to handle_unexpected_exception way down below.
429         thread-&gt;disable_stack_red_zone();
430         tty-&gt;print_raw_cr(&quot;An irrecoverable stack overflow has occurred.&quot;);
431         // Sometimes the register windows are not properly flushed.
432         if(uc-&gt;uc_mcontext.gwins != NULL) {
433           ::handle_unflushed_register_windows(uc-&gt;uc_mcontext.gwins);
434         }
435       }
436     }
437 
438 
<span class="line-modified">439     if (thread-&gt;thread_state() == _thread_in_vm) {</span>

440       if (sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {



441         stub = SharedRuntime::handle_unsafe_access(thread, npc);
442       }
443     }
444 
445     else if (thread-&gt;thread_state() == _thread_in_Java) {
446       // Java thread running in Java code =&gt; find exception handler if any
447       // a fault inside compiled code, the interpreter, or a stub
448 
449       // Support Safepoint Polling
450       if (sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {
451         stub = SharedRuntime::get_poll_stub(pc);
452       }
453 
454       // Not needed on x86 solaris because verify_oops doesn&#39;t generate
455       // SEGV/BUS like sparc does.
456       if ( (sig == SIGSEGV || sig == SIGBUS)
457            &amp;&amp; pc &gt;= MacroAssembler::_verify_oop_implicit_branch[0]
458            &amp;&amp; pc &lt;  MacroAssembler::_verify_oop_implicit_branch[1] ) {
459         stub     =  MacroAssembler::_verify_oop_implicit_branch[2];
460         warning(&quot;fixed up memory fault in +VerifyOops at address &quot; INTPTR_FORMAT, info-&gt;si_addr);
461       }
462 
463       // This is not factored because on x86 solaris the patching for
464       // zombies does not generate a SEGV.
465       else if (sig == SIGSEGV &amp;&amp; nativeInstruction_at(pc)-&gt;is_zombie()) {
466         // zombie method (ld [%g0],%o7 instruction)
467         stub = SharedRuntime::get_handle_wrong_method_stub();
468 
469         // At the stub it needs to look like a call from the caller of this
470         // method (not a call from the segv site).
471         pc = (address)uc-&gt;uc_mcontext.gregs[REG_O7];
472       }
473       else if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR) {
474         // BugId 4454115: A read from a MappedByteBuffer can fault
475         // here if the underlying file has been truncated.
476         // Do not crash the VM in such a case.
477         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
478         CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
<span class="line-modified">479         if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {</span>




480           stub = SharedRuntime::handle_unsafe_access(thread, npc);
481         }
482       }
483 
484       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_INTDIV) {
485         // integer divide by zero
486         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
487       }
488       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTDIV) {
489         // floating-point divide by zero
490         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
491       }
492 #ifdef COMPILER2
493       else if (sig == SIGILL &amp;&amp; nativeInstruction_at(pc)-&gt;is_ic_miss_trap()) {
494 #ifdef ASSERT
495   #ifdef TIERED
496         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
497         assert(cb-&gt;is_compiled_by_c2(), &quot;Wrong compiler&quot;);
498   #endif // TIERED
499 #endif // ASSERT
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 69 # include &lt;sys/time.h&gt;
 70 # include &lt;sys/filio.h&gt;
 71 # include &lt;sys/utsname.h&gt;
 72 # include &lt;sys/systeminfo.h&gt;
 73 # include &lt;sys/socket.h&gt;
 74 # include &lt;sys/lwp.h&gt;
 75 # include &lt;poll.h&gt;
 76 # include &lt;sys/lwp.h&gt;
 77 
 78 # define _STRUCTURED_PROC 1  //  this gets us the new structured proc interfaces of 5.6 &amp; later
 79 # include &lt;sys/procfs.h&gt;     //  see comment in &lt;sys/procfs.h&gt;
 80 
 81 #define MAX_PATH (2 * K)
 82 
 83 // Minimum usable stack sizes required to get to user code. Space for
 84 // HotSpot guard pages is added later.
 85 size_t os::Posix::_compiler_thread_min_stack_allowed = 104 * K;
 86 size_t os::Posix::_java_thread_min_stack_allowed = 86 * K;
 87 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 128 * K;
 88 






 89 static void handle_unflushed_register_windows(gwindows_t *win) {
 90   int restore_count = win-&gt;wbcnt;
 91   int i;
 92 
 93   for(i=0; i&lt;restore_count; i++) {
 94     address sp = ((address)win-&gt;spbuf[i]) + STACK_BIAS;
 95     address reg_win = (address)&amp;win-&gt;wbuf[i];
 96     memcpy(sp,reg_win,sizeof(struct rwindow));
 97   }
 98 }
 99 
100 char* os::non_memory_address_word() {
101   // Must never look like an address returned by reserve_memory,
102   // even in its subfields (as defined by the CPU immediate fields,
103   // if the CPU splits constants across multiple instructions).
104   // On SPARC, 0 != %hi(any real address), because there is no
105   // allocation in the first 1Kb of the virtual address space.
106   return (char*) 0;
107 }
108 
</pre>
<hr />
<pre>
413           thread-&gt;disable_stack_yellow_reserved_zone();
414           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
415         } else {
416           // Thread was in the vm or native code.  Return and try to finish.
417           thread-&gt;disable_stack_yellow_reserved_zone();
418           return true;
419         }
420       } else if (thread-&gt;in_stack_red_zone(addr)) {
421         // Fatal red zone violation.  Disable the guard pages and fall through
422         // to handle_unexpected_exception way down below.
423         thread-&gt;disable_stack_red_zone();
424         tty-&gt;print_raw_cr(&quot;An irrecoverable stack overflow has occurred.&quot;);
425         // Sometimes the register windows are not properly flushed.
426         if(uc-&gt;uc_mcontext.gwins != NULL) {
427           ::handle_unflushed_register_windows(uc-&gt;uc_mcontext.gwins);
428         }
429       }
430     }
431 
432 
<span class="line-modified">433     if (thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">434         thread-&gt;thread_state() == _thread_in_native) {</span>
435       if (sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
<span class="line-added">436         if (UnsafeCopyMemory::contains_pc(pc)) {</span>
<span class="line-added">437           npc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">438         }</span>
439         stub = SharedRuntime::handle_unsafe_access(thread, npc);
440       }
441     }
442 
443     else if (thread-&gt;thread_state() == _thread_in_Java) {
444       // Java thread running in Java code =&gt; find exception handler if any
445       // a fault inside compiled code, the interpreter, or a stub
446 
447       // Support Safepoint Polling
448       if (sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {
449         stub = SharedRuntime::get_poll_stub(pc);
450       }
451 
452       // Not needed on x86 solaris because verify_oops doesn&#39;t generate
453       // SEGV/BUS like sparc does.
454       if ( (sig == SIGSEGV || sig == SIGBUS)
455            &amp;&amp; pc &gt;= MacroAssembler::_verify_oop_implicit_branch[0]
456            &amp;&amp; pc &lt;  MacroAssembler::_verify_oop_implicit_branch[1] ) {
457         stub     =  MacroAssembler::_verify_oop_implicit_branch[2];
458         warning(&quot;fixed up memory fault in +VerifyOops at address &quot; INTPTR_FORMAT, info-&gt;si_addr);
459       }
460 
461       // This is not factored because on x86 solaris the patching for
462       // zombies does not generate a SEGV.
463       else if (sig == SIGSEGV &amp;&amp; nativeInstruction_at(pc)-&gt;is_zombie()) {
464         // zombie method (ld [%g0],%o7 instruction)
465         stub = SharedRuntime::get_handle_wrong_method_stub();
466 
467         // At the stub it needs to look like a call from the caller of this
468         // method (not a call from the segv site).
469         pc = (address)uc-&gt;uc_mcontext.gregs[REG_O7];
470       }
471       else if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR) {
472         // BugId 4454115: A read from a MappedByteBuffer can fault
473         // here if the underlying file has been truncated.
474         // Do not crash the VM in such a case.
475         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
476         CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
<span class="line-modified">477         bool is_unsafe_arraycopy = (thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc));</span>
<span class="line-added">478         if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {</span>
<span class="line-added">479           if (is_unsafe_arraycopy) {</span>
<span class="line-added">480             npc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">481           }</span>
482           stub = SharedRuntime::handle_unsafe_access(thread, npc);
483         }
484       }
485 
486       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_INTDIV) {
487         // integer divide by zero
488         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
489       }
490       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTDIV) {
491         // floating-point divide by zero
492         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
493       }
494 #ifdef COMPILER2
495       else if (sig == SIGILL &amp;&amp; nativeInstruction_at(pc)-&gt;is_ic_miss_trap()) {
496 #ifdef ASSERT
497   #ifdef TIERED
498         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
499         assert(cb-&gt;is_compiled_by_c2(), &quot;Wrong compiler&quot;);
500   #endif // TIERED
501 #endif // ASSERT
</pre>
</td>
</tr>
</table>
<center><a href="orderAccess_solaris_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_solaris_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/os_cpu/solaris_sparc/atomic_solaris_sparc.hpp b/src/hotspot/os_cpu/solaris_sparc/atomic_solaris_sparc.hpp
--- a/src/hotspot/os_cpu/solaris_sparc/atomic_solaris_sparc.hpp
+++ b/src/hotspot/os_cpu/solaris_sparc/atomic_solaris_sparc.hpp
@@ -28,27 +28,32 @@
 // Implementation of class atomic
 
 // Implement ADD using a CAS loop.
 template<size_t byte_size>
 struct Atomic::PlatformAdd {
-  template<typename I, typename D>
-  inline D operator()(I add_value, D volatile* dest, atomic_memory_order order) const {
+  template<typename D, typename I>
+  inline D add_and_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {
     D old_value = *dest;
     while (true) {
       D new_value = old_value + add_value;
-      D result = cmpxchg(new_value, dest, old_value);
+      D result = cmpxchg(dest, old_value, new_value);
       if (result == old_value) break;
       old_value = result;
     }
     return old_value + add_value;
   }
+
+  template<typename D, typename I>
+  inline D fetch_and_add(D volatile* dest, I add_value, atomic_memory_order order) const {
+    return add_and_fetch(dest, add_value, order) - add_value;
+  }
 };
 
 template<>
 template<typename T>
-inline T Atomic::PlatformXchg<4>::operator()(T exchange_value,
-                                             T volatile* dest,
+inline T Atomic::PlatformXchg<4>::operator()(T volatile* dest,
+                                             T exchange_value,
                                              atomic_memory_order order) const {
   STATIC_ASSERT(4 == sizeof(T));
   __asm__ volatile (  "swap [%2],%0"
                     : "=r" (exchange_value)
                     : "0" (exchange_value), "r" (dest)
@@ -56,17 +61,17 @@
   return exchange_value;
 }
 
 template<>
 template<typename T>
-inline T Atomic::PlatformXchg<8>::operator()(T exchange_value,
-                                             T volatile* dest,
+inline T Atomic::PlatformXchg<8>::operator()(T volatile* dest,
+                                             T exchange_value,
                                              atomic_memory_order order) const {
   STATIC_ASSERT(8 == sizeof(T));
   T old_value = *dest;
   while (true) {
-    T result = cmpxchg(exchange_value, dest, old_value);
+    T result = cmpxchg(dest, old_value, exchange_value);
     if (result == old_value) break;
     old_value = result;
   }
   return old_value;
 }
@@ -75,13 +80,13 @@
 template<>
 struct Atomic::PlatformCmpxchg<1> : Atomic::CmpxchgByteUsingInt {};
 
 template<>
 template<typename T>
-inline T Atomic::PlatformCmpxchg<4>::operator()(T exchange_value,
-                                                T volatile* dest,
+inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest,
                                                 T compare_value,
+                                                T exchange_value,
                                                 atomic_memory_order order) const {
   STATIC_ASSERT(4 == sizeof(T));
   T rv;
   __asm__ volatile(
     " cas    [%2], %3, %0"
@@ -91,13 +96,13 @@
   return rv;
 }
 
 template<>
 template<typename T>
-inline T Atomic::PlatformCmpxchg<8>::operator()(T exchange_value,
-                                                T volatile* dest,
+inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,
                                                 T compare_value,
+                                                T exchange_value,
                                                 atomic_memory_order order) const {
   STATIC_ASSERT(8 == sizeof(T));
   T rv;
   __asm__ volatile(
     " casx   [%2], %3, %0"

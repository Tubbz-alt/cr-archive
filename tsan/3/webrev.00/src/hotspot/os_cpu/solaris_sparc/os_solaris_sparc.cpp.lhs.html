<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os_cpu/solaris_sparc/os_solaris_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // no precompiled headers
 26 #include &quot;jvm.h&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;macroAssembler_sparc.hpp&quot;
 29 #include &quot;classfile/classLoader.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;classfile/vmSymbols.hpp&quot;
 32 #include &quot;code/codeCache.hpp&quot;
 33 #include &quot;code/icBuffer.hpp&quot;
 34 #include &quot;code/vtableStubs.hpp&quot;
 35 #include &quot;interpreter/interpreter.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;nativeInst_sparc.hpp&quot;
 38 #include &quot;os_share_solaris.hpp&quot;
 39 #include &quot;prims/jniFastGetField.hpp&quot;
 40 #include &quot;prims/jvm_misc.hpp&quot;
 41 #include &quot;runtime/arguments.hpp&quot;
 42 #include &quot;runtime/extendedPC.hpp&quot;
 43 #include &quot;runtime/frame.inline.hpp&quot;
 44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 45 #include &quot;runtime/java.hpp&quot;
 46 #include &quot;runtime/javaCalls.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/osThread.hpp&quot;
 49 #include &quot;runtime/sharedRuntime.hpp&quot;
 50 #include &quot;runtime/stubRoutines.hpp&quot;
 51 #include &quot;runtime/thread.inline.hpp&quot;
 52 #include &quot;runtime/timer.hpp&quot;
 53 #include &quot;utilities/events.hpp&quot;
 54 #include &quot;utilities/vmError.hpp&quot;
 55 
 56 # include &lt;signal.h&gt;        // needed first to avoid name collision for &quot;std&quot; with SC 5.0
 57 
 58 // put OS-includes here
 59 # include &lt;sys/types.h&gt;
 60 # include &lt;sys/mman.h&gt;
 61 # include &lt;pthread.h&gt;
 62 # include &lt;errno.h&gt;
 63 # include &lt;dlfcn.h&gt;
 64 # include &lt;stdio.h&gt;
 65 # include &lt;unistd.h&gt;
 66 # include &lt;sys/resource.h&gt;
 67 # include &lt;thread.h&gt;
 68 # include &lt;sys/stat.h&gt;
 69 # include &lt;sys/time.h&gt;
 70 # include &lt;sys/filio.h&gt;
 71 # include &lt;sys/utsname.h&gt;
 72 # include &lt;sys/systeminfo.h&gt;
 73 # include &lt;sys/socket.h&gt;
 74 # include &lt;sys/lwp.h&gt;
 75 # include &lt;poll.h&gt;
 76 # include &lt;sys/lwp.h&gt;
 77 
 78 # define _STRUCTURED_PROC 1  //  this gets us the new structured proc interfaces of 5.6 &amp; later
 79 # include &lt;sys/procfs.h&gt;     //  see comment in &lt;sys/procfs.h&gt;
 80 
 81 #define MAX_PATH (2 * K)
 82 
 83 // Minimum usable stack sizes required to get to user code. Space for
 84 // HotSpot guard pages is added later.
 85 size_t os::Posix::_compiler_thread_min_stack_allowed = 104 * K;
 86 size_t os::Posix::_java_thread_min_stack_allowed = 86 * K;
 87 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 128 * K;
 88 
<a name="2" id="anc2"></a><span class="line-removed"> 89 int os::Solaris::max_register_window_saves_before_flushing() {</span>
<span class="line-removed"> 90   // We should detect this at run time. For now, filling</span>
<span class="line-removed"> 91   // in with a constant.</span>
<span class="line-removed"> 92   return 8;</span>
<span class="line-removed"> 93 }</span>
<span class="line-removed"> 94 </span>
 95 static void handle_unflushed_register_windows(gwindows_t *win) {
 96   int restore_count = win-&gt;wbcnt;
 97   int i;
 98 
 99   for(i=0; i&lt;restore_count; i++) {
100     address sp = ((address)win-&gt;spbuf[i]) + STACK_BIAS;
101     address reg_win = (address)&amp;win-&gt;wbuf[i];
102     memcpy(sp,reg_win,sizeof(struct rwindow));
103   }
104 }
105 
106 char* os::non_memory_address_word() {
107   // Must never look like an address returned by reserve_memory,
108   // even in its subfields (as defined by the CPU immediate fields,
109   // if the CPU splits constants across multiple instructions).
110   // On SPARC, 0 != %hi(any real address), because there is no
111   // allocation in the first 1Kb of the virtual address space.
112   return (char*) 0;
113 }
114 
115 // Validate a ucontext retrieved from walking a uc_link of a ucontext.
116 // There are issues with libthread giving out uc_links for different threads
117 // on the same uc_link chain and bad or circular links.
118 //
119 bool os::Solaris::valid_ucontext(Thread* thread, const ucontext_t* valid, const ucontext_t* suspect) {
120   if (valid &gt;= suspect ||
121       valid-&gt;uc_stack.ss_flags != suspect-&gt;uc_stack.ss_flags ||
122       valid-&gt;uc_stack.ss_sp    != suspect-&gt;uc_stack.ss_sp    ||
123       valid-&gt;uc_stack.ss_size  != suspect-&gt;uc_stack.ss_size) {
124     DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: failed test 1&quot;);)
125     return false;
126   }
127 
128   if (thread-&gt;is_Java_thread()) {
129     if (!valid_stack_address(thread, (address)suspect)) {
130       DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: uc_link not in thread stack&quot;);)
131       return false;
132     }
133     address _sp   = (address)((intptr_t)suspect-&gt;uc_mcontext.gregs[REG_SP] + STACK_BIAS);
134     if (!valid_stack_address(thread, _sp) ||
135         !frame::is_valid_stack_pointer(((JavaThread*)thread)-&gt;base_of_stack_pointer(), (intptr_t*)_sp)) {
136       DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: stackpointer not in thread stack&quot;);)
137       return false;
138     }
139   }
140   return true;
141 }
142 
143 // We will only follow one level of uc_link since there are libthread
144 // issues with ucontext linking and it is better to be safe and just
145 // let caller retry later.
146 const ucontext_t* os::Solaris::get_valid_uc_in_signal_handler(Thread *thread,
147   const ucontext_t *uc) {
148 
149   const ucontext_t *retuc = NULL;
150 
151   // Sometimes the topmost register windows are not properly flushed.
152   // i.e., if the kernel would have needed to take a page fault
153   if (uc != NULL &amp;&amp; uc-&gt;uc_mcontext.gwins != NULL) {
154     ::handle_unflushed_register_windows(uc-&gt;uc_mcontext.gwins);
155   }
156 
157   if (uc != NULL) {
158     if (uc-&gt;uc_link == NULL) {
159       // cannot validate without uc_link so accept current ucontext
160       retuc = uc;
161     } else if (os::Solaris::valid_ucontext(thread, uc, uc-&gt;uc_link)) {
162       // first ucontext is valid so try the next one
163       uc = uc-&gt;uc_link;
164       if (uc-&gt;uc_link == NULL) {
165         // cannot validate without uc_link so accept current ucontext
166         retuc = uc;
167       } else if (os::Solaris::valid_ucontext(thread, uc, uc-&gt;uc_link)) {
168         // the ucontext one level down is also valid so return it
169         retuc = uc;
170       }
171     }
172   }
173   return retuc;
174 }
175 
176 // Assumes ucontext is valid
177 ExtendedPC os::Solaris::ucontext_get_ExtendedPC(const ucontext_t *uc) {
178   address pc = (address)uc-&gt;uc_mcontext.gregs[REG_PC];
179   // set npc to zero to avoid using it for safepoint, good for profiling only
180   return ExtendedPC(pc);
181 }
182 
183 void os::Solaris::ucontext_set_pc(ucontext_t* uc, address pc) {
184   uc-&gt;uc_mcontext.gregs [REG_PC]  = (greg_t) pc;
185   uc-&gt;uc_mcontext.gregs [REG_nPC] = (greg_t) (pc + 4);
186 }
187 
188 // Assumes ucontext is valid
189 intptr_t* os::Solaris::ucontext_get_sp(const ucontext_t *uc) {
190   return (intptr_t*)((intptr_t)uc-&gt;uc_mcontext.gregs[REG_SP] + STACK_BIAS);
191 }
192 
193 // Solaris X86 only
194 intptr_t* os::Solaris::ucontext_get_fp(const ucontext_t *uc) {
195   ShouldNotReachHere();
196   return NULL;
197 }
198 
199 address os::Solaris::ucontext_get_pc(const ucontext_t *uc) {
200   return (address) uc-&gt;uc_mcontext.gregs[REG_PC];
201 }
202 
203 
204 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
205 // is currently interrupted by SIGPROF.
206 //
207 // ret_fp parameter is only used by Solaris X86.
208 //
209 // The difference between this and os::fetch_frame_from_context() is that
210 // here we try to skip nested signal frames.
211 // This method is also used for stack overflow signal handling.
212 ExtendedPC os::Solaris::fetch_frame_from_ucontext(Thread* thread,
213   const ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {
214 
215   assert(thread != NULL, &quot;just checking&quot;);
216   assert(ret_sp != NULL, &quot;just checking&quot;);
217   assert(ret_fp == NULL, &quot;just checking&quot;);
218 
219   const ucontext_t *luc = os::Solaris::get_valid_uc_in_signal_handler(thread, uc);
220 
221   return os::fetch_frame_from_context(luc, ret_sp, ret_fp);
222 }
223 
224 
225 // ret_fp parameter is only used by Solaris X86.
226 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
227                     intptr_t** ret_sp, intptr_t** ret_fp) {
228 
229   ExtendedPC  epc;
230   const ucontext_t *uc = (const ucontext_t*)ucVoid;
231 
232   if (uc != NULL) {
233     epc = os::Solaris::ucontext_get_ExtendedPC(uc);
234     if (ret_sp) *ret_sp = os::Solaris::ucontext_get_sp(uc);
235   } else {
236     // construct empty ExtendedPC for return value checking
237     epc = ExtendedPC(NULL);
238     if (ret_sp) *ret_sp = (intptr_t *)NULL;
239   }
240 
241   return epc;
242 }
243 
244 frame os::fetch_frame_from_context(const void* ucVoid) {
245   intptr_t* sp;
246   intptr_t* fp;
247   ExtendedPC epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);
248   return frame(sp, frame::unpatchable, epc.pc());
249 }
250 
251 frame os::fetch_frame_from_ucontext(Thread* thread, void* ucVoid) {
252   intptr_t* sp;
253   ExtendedPC epc = os::Solaris::fetch_frame_from_ucontext(thread, (ucontext_t*)ucVoid, &amp;sp, NULL);
254   return frame(sp, frame::unpatchable, epc.pc());
255 }
256 
257 bool os::Solaris::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
258   address pc = (address) os::Solaris::ucontext_get_pc(uc);
259   if (Interpreter::contains(pc)) {
260     *fr = os::fetch_frame_from_ucontext(thread, uc);
261     if (!fr-&gt;is_first_java_frame()) {
262       assert(fr-&gt;safe_for_sender(thread), &quot;Safety check&quot;);
263       *fr = fr-&gt;java_sender();
264     }
265   } else {
266     // more complex code with compiled code
267     assert(!Interpreter::contains(pc), &quot;Interpreted methods should have been handled above&quot;);
268     CodeBlob* cb = CodeCache::find_blob(pc);
269     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {
270       // Not sure where the pc points to, fallback to default
271       // stack overflow handling
272       return false;
273     } else {
274       // Returned frame will be the caller of the method that faults on the stack bang.
275       // Register window not yet rotated (happens at SAVE after stack bang), so there is no new
276       // frame to go with the faulting PC. Using caller SP that is still in SP, and caller PC
277       // that was written to O7 at call.
278       intptr_t* sp = os::Solaris::ucontext_get_sp(uc);
279       address pc = (address)uc-&gt;uc_mcontext.gregs[REG_O7];
280       *fr = frame(sp, frame::unpatchable, pc);
281 
282       if (!fr-&gt;is_java_frame()) {
283         assert(fr-&gt;safe_for_sender(thread), &quot;Safety check&quot;);
284         *fr = fr-&gt;java_sender();
285       }
286     }
287   }
288   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
289   return true;
290 }
291 
292 frame os::get_sender_for_C_frame(frame* fr) {
293   return frame(fr-&gt;sender_sp(), frame::unpatchable, fr-&gt;sender_pc());
294 }
295 
296 // Returns an estimate of the current stack pointer. Result must be guaranteed to
297 // point into the calling threads stack, and be no lower than the current stack
298 // pointer.
299 address os::current_stack_pointer() {
300   volatile int dummy;
301   address sp = (address)&amp;dummy + 8;     // %%%% need to confirm if this is right
302   return sp;
303 }
304 
305 frame os::current_frame() {
306   intptr_t* sp = StubRoutines::Sparc::flush_callers_register_windows_func()();
307   frame myframe(sp, frame::unpatchable,
308                 CAST_FROM_FN_PTR(address, os::current_frame));
309   if (os::is_first_C_frame(&amp;myframe)) {
310     // stack is not walkable
311     return frame(NULL, NULL, false);
312   } else {
313     return os::get_sender_for_C_frame(&amp;myframe);
314   }
315 }
316 
317 bool os::is_allocatable(size_t bytes) {
318    return true;
319 }
320 
321 extern &quot;C&quot; JNIEXPORT int
322 JVM_handle_solaris_signal(int sig, siginfo_t* info, void* ucVoid,
323                           int abort_if_unrecognized) {
324   ucontext_t* uc = (ucontext_t*) ucVoid;
325 
326   Thread* t = Thread::current_or_null_safe();
327 
328   // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away
329   // (no destructors can be run)
330   os::ThreadCrashProtection::check_crash_protection(sig, t);
331 
332   SignalHandlerMark shm(t);
333 
334   if(sig == SIGPIPE || sig == SIGXFSZ) {
335     if (os::Solaris::chained_handler(sig, info, ucVoid)) {
336       return true;
337     } else {
338       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
339       return true;
340     }
341   }
342 
343   JavaThread* thread = NULL;
344   VMThread* vmthread = NULL;
345   if (os::Solaris::signal_handlers_are_installed) {
346     if (t != NULL ){
347       if(t-&gt;is_Java_thread()) {
348         thread = (JavaThread*)t;
349       }
350       else if(t-&gt;is_VM_thread()){
351         vmthread = (VMThread *)t;
352       }
353     }
354   }
355 
356   if (sig == ASYNC_SIGNAL) {
357     if (thread || vmthread) {
358       OSThread::SR_handler(t, uc);
359       return true;
360     } else if (os::Solaris::chained_handler(sig, info, ucVoid)) {
361       return true;
362     } else {
363       // If ASYNC_SIGNAL not chained, and this is a non-vm and
364       // non-java thread
365       return true;
366     }
367   }
368 
369   if (info == NULL || info-&gt;si_code &lt;= 0 || info-&gt;si_code == SI_NOINFO) {
370     // can&#39;t decode this kind of signal
371     info = NULL;
372   } else {
373     assert(sig == info-&gt;si_signo, &quot;bad siginfo&quot;);
374   }
375 
376   // decide if this trap can be handled by a stub
377   address stub = NULL;
378 
379   address pc          = NULL;
380   address npc         = NULL;
381 
382   //%note os_trap_1
383   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
384     // factor me: getPCfromContext
385     pc  = (address) uc-&gt;uc_mcontext.gregs[REG_PC];
386     npc = (address) uc-&gt;uc_mcontext.gregs[REG_nPC];
387 
388     // SafeFetch() support
389     if (StubRoutines::is_safefetch_fault(pc)) {
390       os::Solaris::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
391       return 1;
392     }
393 
394     // Handle ALL stack overflow variations here
395     if (sig == SIGSEGV &amp;&amp; info-&gt;si_code == SEGV_ACCERR) {
396       address addr = (address) info-&gt;si_addr;
397       if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
398         // Sometimes the register windows are not properly flushed.
399         if(uc-&gt;uc_mcontext.gwins != NULL) {
400           ::handle_unflushed_register_windows(uc-&gt;uc_mcontext.gwins);
401         }
402         if (thread-&gt;thread_state() == _thread_in_Java) {
403           if (thread-&gt;in_stack_reserved_zone(addr)) {
404             frame fr;
405             if (os::Solaris::get_frame_at_stack_banging_point(thread, uc, &amp;fr)) {
406               assert(fr.is_java_frame(), &quot;Must be a Java frame&quot;);
407               frame activation = SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
408               if (activation.sp() != NULL) {
409                 thread-&gt;disable_stack_reserved_zone();
410                 RegisterMap map(thread);
411                 int frame_size = activation.frame_size(&amp;map);
412                 thread-&gt;set_reserved_stack_activation((address)(((address)activation.sp()) - STACK_BIAS));
413                 return true;
414               }
415             }
416           }
417           // Throw a stack overflow exception.  Guard pages will be reenabled
418           // while unwinding the stack.
419           thread-&gt;disable_stack_yellow_reserved_zone();
420           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
421         } else {
422           // Thread was in the vm or native code.  Return and try to finish.
423           thread-&gt;disable_stack_yellow_reserved_zone();
424           return true;
425         }
426       } else if (thread-&gt;in_stack_red_zone(addr)) {
427         // Fatal red zone violation.  Disable the guard pages and fall through
428         // to handle_unexpected_exception way down below.
429         thread-&gt;disable_stack_red_zone();
430         tty-&gt;print_raw_cr(&quot;An irrecoverable stack overflow has occurred.&quot;);
431         // Sometimes the register windows are not properly flushed.
432         if(uc-&gt;uc_mcontext.gwins != NULL) {
433           ::handle_unflushed_register_windows(uc-&gt;uc_mcontext.gwins);
434         }
435       }
436     }
437 
438 
<a name="3" id="anc3"></a><span class="line-modified">439     if (thread-&gt;thread_state() == _thread_in_vm) {</span>

440       if (sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
<a name="4" id="anc4"></a>


441         stub = SharedRuntime::handle_unsafe_access(thread, npc);
442       }
443     }
444 
445     else if (thread-&gt;thread_state() == _thread_in_Java) {
446       // Java thread running in Java code =&gt; find exception handler if any
447       // a fault inside compiled code, the interpreter, or a stub
448 
449       // Support Safepoint Polling
450       if (sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {
451         stub = SharedRuntime::get_poll_stub(pc);
452       }
453 
454       // Not needed on x86 solaris because verify_oops doesn&#39;t generate
455       // SEGV/BUS like sparc does.
456       if ( (sig == SIGSEGV || sig == SIGBUS)
457            &amp;&amp; pc &gt;= MacroAssembler::_verify_oop_implicit_branch[0]
458            &amp;&amp; pc &lt;  MacroAssembler::_verify_oop_implicit_branch[1] ) {
459         stub     =  MacroAssembler::_verify_oop_implicit_branch[2];
460         warning(&quot;fixed up memory fault in +VerifyOops at address &quot; INTPTR_FORMAT, info-&gt;si_addr);
461       }
462 
463       // This is not factored because on x86 solaris the patching for
464       // zombies does not generate a SEGV.
465       else if (sig == SIGSEGV &amp;&amp; nativeInstruction_at(pc)-&gt;is_zombie()) {
466         // zombie method (ld [%g0],%o7 instruction)
467         stub = SharedRuntime::get_handle_wrong_method_stub();
468 
469         // At the stub it needs to look like a call from the caller of this
470         // method (not a call from the segv site).
471         pc = (address)uc-&gt;uc_mcontext.gregs[REG_O7];
472       }
473       else if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR) {
474         // BugId 4454115: A read from a MappedByteBuffer can fault
475         // here if the underlying file has been truncated.
476         // Do not crash the VM in such a case.
477         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
478         CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
<a name="5" id="anc5"></a><span class="line-modified">479         if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {</span>




480           stub = SharedRuntime::handle_unsafe_access(thread, npc);
481         }
482       }
483 
484       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_INTDIV) {
485         // integer divide by zero
486         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
487       }
488       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTDIV) {
489         // floating-point divide by zero
490         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
491       }
492 #ifdef COMPILER2
493       else if (sig == SIGILL &amp;&amp; nativeInstruction_at(pc)-&gt;is_ic_miss_trap()) {
494 #ifdef ASSERT
495   #ifdef TIERED
496         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
497         assert(cb-&gt;is_compiled_by_c2(), &quot;Wrong compiler&quot;);
498   #endif // TIERED
499 #endif // ASSERT
500         // Inline cache missed and user trap &quot;Tne G0+ST_RESERVED_FOR_USER_0+2&quot; taken.
501         stub = SharedRuntime::get_ic_miss_stub();
502         // At the stub it needs to look like a call from the caller of this
503         // method (not a call from the segv site).
504         pc = (address)uc-&gt;uc_mcontext.gregs[REG_O7];
505       }
506 #endif  // COMPILER2
507 
508       else if (sig == SIGSEGV &amp;&amp; info-&gt;si_code &gt; 0 &amp;&amp; MacroAssembler::uses_implicit_null_check(info-&gt;si_addr)) {
509         // Determination of interpreter/vtable stub/compiled code null exception
510         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
511       }
512     }
513 
514     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in
515     // and the heap gets shrunk before the field access.
516     if ((sig == SIGSEGV) || (sig == SIGBUS)) {
517       address addr = JNI_FastGetField::find_slowcase_pc(pc);
518       if (addr != (address)-1) {
519         stub = addr;
520       }
521     }
522   }
523 
524   if (stub != NULL) {
525     // save all thread context in case we need to restore it
526 
527     thread-&gt;set_saved_exception_pc(pc);
528     thread-&gt;set_saved_exception_npc(npc);
529 
530     // simulate a branch to the stub (a &quot;call&quot; in the safepoint stub case)
531     // factor me: setPC
532     os::Solaris::ucontext_set_pc(uc, stub);
533 
534     return true;
535   }
536 
537   // signal-chaining
538   if (os::Solaris::chained_handler(sig, info, ucVoid)) {
539     return true;
540   }
541 
542   if (!abort_if_unrecognized) {
543     // caller wants another chance, so give it to him
544     return false;
545   }
546 
547   if (!os::Solaris::libjsig_is_loaded) {
548     struct sigaction oldAct;
549     sigaction(sig, (struct sigaction *)0, &amp;oldAct);
550     if (oldAct.sa_sigaction != signalHandler) {
551       void* sighand = oldAct.sa_sigaction ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)
552                                           : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);
553       warning(&quot;Unexpected Signal %d occurred under user-defined signal handler &quot; INTPTR_FORMAT, sig, (intptr_t)sighand);
554     }
555   }
556 
557   if (pc == NULL &amp;&amp; uc != NULL) {
558     pc = (address) uc-&gt;uc_mcontext.gregs[REG_PC];
559   }
560 
561   // Sometimes the register windows are not properly flushed.
562   if(uc-&gt;uc_mcontext.gwins != NULL) {
563     ::handle_unflushed_register_windows(uc-&gt;uc_mcontext.gwins);
564   }
565 
566   // unmask current signal
567   sigset_t newset;
568   sigemptyset(&amp;newset);
569   sigaddset(&amp;newset, sig);
570   sigprocmask(SIG_UNBLOCK, &amp;newset, NULL);
571 
572   // Determine which sort of error to throw.  Out of swap may signal
573   // on the thread stack, which could get a mapping error when touched.
574   address addr = (address) info-&gt;si_addr;
575   if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR &amp;&amp; info-&gt;si_errno == ENOMEM) {
576     vm_exit_out_of_memory(0, OOM_MMAP_ERROR, &quot;Out of swap space to map in thread stack.&quot;);
577   }
578 
579   VMError::report_and_die(t, sig, pc, info, ucVoid);
580 
581   ShouldNotReachHere();
582   return false;
583 }
584 
585 void os::print_context(outputStream *st, const void *context) {
586   if (context == NULL) return;
587 
588   const ucontext_t *uc = (const ucontext_t*)context;
589   st-&gt;print_cr(&quot;Registers:&quot;);
590 
591   st-&gt;print_cr(&quot; G1=&quot; INTPTR_FORMAT &quot; G2=&quot; INTPTR_FORMAT
592                &quot; G3=&quot; INTPTR_FORMAT &quot; G4=&quot; INTPTR_FORMAT,
593             uc-&gt;uc_mcontext.gregs[REG_G1],
594             uc-&gt;uc_mcontext.gregs[REG_G2],
595             uc-&gt;uc_mcontext.gregs[REG_G3],
596             uc-&gt;uc_mcontext.gregs[REG_G4]);
597   st-&gt;print_cr(&quot; G5=&quot; INTPTR_FORMAT &quot; G6=&quot; INTPTR_FORMAT
598                &quot; G7=&quot; INTPTR_FORMAT &quot; Y=&quot; INTPTR_FORMAT,
599             uc-&gt;uc_mcontext.gregs[REG_G5],
600             uc-&gt;uc_mcontext.gregs[REG_G6],
601             uc-&gt;uc_mcontext.gregs[REG_G7],
602             uc-&gt;uc_mcontext.gregs[REG_Y]);
603   st-&gt;print_cr(&quot; O0=&quot; INTPTR_FORMAT &quot; O1=&quot; INTPTR_FORMAT
604                &quot; O2=&quot; INTPTR_FORMAT &quot; O3=&quot; INTPTR_FORMAT,
605                  uc-&gt;uc_mcontext.gregs[REG_O0],
606                  uc-&gt;uc_mcontext.gregs[REG_O1],
607                  uc-&gt;uc_mcontext.gregs[REG_O2],
608                  uc-&gt;uc_mcontext.gregs[REG_O3]);
609   st-&gt;print_cr(&quot; O4=&quot; INTPTR_FORMAT &quot; O5=&quot; INTPTR_FORMAT
610                &quot; O6=&quot; INTPTR_FORMAT &quot; O7=&quot; INTPTR_FORMAT,
611             uc-&gt;uc_mcontext.gregs[REG_O4],
612             uc-&gt;uc_mcontext.gregs[REG_O5],
613             uc-&gt;uc_mcontext.gregs[REG_O6],
614             uc-&gt;uc_mcontext.gregs[REG_O7]);
615 
616 
617   intptr_t *sp = (intptr_t *)os::Solaris::ucontext_get_sp(uc);
618   st-&gt;print_cr(&quot; L0=&quot; INTPTR_FORMAT &quot; L1=&quot; INTPTR_FORMAT
619                &quot; L2=&quot; INTPTR_FORMAT &quot; L3=&quot; INTPTR_FORMAT,
620                sp[L0-&gt;sp_offset_in_saved_window()],
621                sp[L1-&gt;sp_offset_in_saved_window()],
622                sp[L2-&gt;sp_offset_in_saved_window()],
623                sp[L3-&gt;sp_offset_in_saved_window()]);
624   st-&gt;print_cr(&quot; L4=&quot; INTPTR_FORMAT &quot; L5=&quot; INTPTR_FORMAT
625                &quot; L6=&quot; INTPTR_FORMAT &quot; L7=&quot; INTPTR_FORMAT,
626                sp[L4-&gt;sp_offset_in_saved_window()],
627                sp[L5-&gt;sp_offset_in_saved_window()],
628                sp[L6-&gt;sp_offset_in_saved_window()],
629                sp[L7-&gt;sp_offset_in_saved_window()]);
630   st-&gt;print_cr(&quot; I0=&quot; INTPTR_FORMAT &quot; I1=&quot; INTPTR_FORMAT
631                &quot; I2=&quot; INTPTR_FORMAT &quot; I3=&quot; INTPTR_FORMAT,
632                sp[I0-&gt;sp_offset_in_saved_window()],
633                sp[I1-&gt;sp_offset_in_saved_window()],
634                sp[I2-&gt;sp_offset_in_saved_window()],
635                sp[I3-&gt;sp_offset_in_saved_window()]);
636   st-&gt;print_cr(&quot; I4=&quot; INTPTR_FORMAT &quot; I5=&quot; INTPTR_FORMAT
637                &quot; I6=&quot; INTPTR_FORMAT &quot; I7=&quot; INTPTR_FORMAT,
638                sp[I4-&gt;sp_offset_in_saved_window()],
639                sp[I5-&gt;sp_offset_in_saved_window()],
640                sp[I6-&gt;sp_offset_in_saved_window()],
641                sp[I7-&gt;sp_offset_in_saved_window()]);
642 
643   st-&gt;print_cr(&quot; PC=&quot; INTPTR_FORMAT &quot; nPC=&quot; INTPTR_FORMAT,
644             uc-&gt;uc_mcontext.gregs[REG_PC],
645             uc-&gt;uc_mcontext.gregs[REG_nPC]);
646   st-&gt;cr();
647   st-&gt;cr();
648 
649   st-&gt;print_cr(&quot;Top of Stack: (sp=&quot; PTR_FORMAT &quot;)&quot;, sp);
650   print_hex_dump(st, (address)sp, (address)(sp + 32), sizeof(intptr_t));
651   st-&gt;cr();
652 
653   // Note: it may be unsafe to inspect memory near pc. For example, pc may
654   // point to garbage if entry point in an nmethod is corrupted. Leave
655   // this at the end, and hope for the best.
656   ExtendedPC epc = os::Solaris::ucontext_get_ExtendedPC(uc);
657   address pc = epc.pc();
658   print_instructions(st, pc, sizeof(char));
659   st-&gt;cr();
660 }
661 
662 void os::print_register_info(outputStream *st, const void *context) {
663   if (context == NULL) return;
664 
665   const ucontext_t *uc = (const ucontext_t*)context;
666   intptr_t *sp = (intptr_t *)os::Solaris::ucontext_get_sp(uc);
667 
668   st-&gt;print_cr(&quot;Register to memory mapping:&quot;);
669   st-&gt;cr();
670 
671   // this is only for the &quot;general purpose&quot; registers
672   st-&gt;print(&quot;G1=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_G1]);
673   st-&gt;print(&quot;G2=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_G2]);
674   st-&gt;print(&quot;G3=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_G3]);
675   st-&gt;print(&quot;G4=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_G4]);
676   st-&gt;print(&quot;G5=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_G5]);
677   st-&gt;print(&quot;G6=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_G6]);
678   st-&gt;print(&quot;G7=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_G7]);
679   st-&gt;cr();
680 
681   st-&gt;print(&quot;O0=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_O0]);
682   st-&gt;print(&quot;O1=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_O1]);
683   st-&gt;print(&quot;O2=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_O2]);
684   st-&gt;print(&quot;O3=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_O3]);
685   st-&gt;print(&quot;O4=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_O4]);
686   st-&gt;print(&quot;O5=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_O5]);
687   st-&gt;print(&quot;O6=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_O6]);
688   st-&gt;print(&quot;O7=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_O7]);
689   st-&gt;cr();
690 
691   st-&gt;print(&quot;L0=&quot;); print_location(st, sp[L0-&gt;sp_offset_in_saved_window()]);
692   st-&gt;print(&quot;L1=&quot;); print_location(st, sp[L1-&gt;sp_offset_in_saved_window()]);
693   st-&gt;print(&quot;L2=&quot;); print_location(st, sp[L2-&gt;sp_offset_in_saved_window()]);
694   st-&gt;print(&quot;L3=&quot;); print_location(st, sp[L3-&gt;sp_offset_in_saved_window()]);
695   st-&gt;print(&quot;L4=&quot;); print_location(st, sp[L4-&gt;sp_offset_in_saved_window()]);
696   st-&gt;print(&quot;L5=&quot;); print_location(st, sp[L5-&gt;sp_offset_in_saved_window()]);
697   st-&gt;print(&quot;L6=&quot;); print_location(st, sp[L6-&gt;sp_offset_in_saved_window()]);
698   st-&gt;print(&quot;L7=&quot;); print_location(st, sp[L7-&gt;sp_offset_in_saved_window()]);
699   st-&gt;cr();
700 
701   st-&gt;print(&quot;I0=&quot;); print_location(st, sp[I0-&gt;sp_offset_in_saved_window()]);
702   st-&gt;print(&quot;I1=&quot;); print_location(st, sp[I1-&gt;sp_offset_in_saved_window()]);
703   st-&gt;print(&quot;I2=&quot;); print_location(st, sp[I2-&gt;sp_offset_in_saved_window()]);
704   st-&gt;print(&quot;I3=&quot;); print_location(st, sp[I3-&gt;sp_offset_in_saved_window()]);
705   st-&gt;print(&quot;I4=&quot;); print_location(st, sp[I4-&gt;sp_offset_in_saved_window()]);
706   st-&gt;print(&quot;I5=&quot;); print_location(st, sp[I5-&gt;sp_offset_in_saved_window()]);
707   st-&gt;print(&quot;I6=&quot;); print_location(st, sp[I6-&gt;sp_offset_in_saved_window()]);
708   st-&gt;print(&quot;I7=&quot;); print_location(st, sp[I7-&gt;sp_offset_in_saved_window()]);
709   st-&gt;cr();
710 }
711 
712 void os::Solaris::init_thread_fpu_state(void) {
713     // Nothing needed on Sparc.
714 }
715 
716 #ifndef PRODUCT
717 void os::verify_stack_alignment() {
718 }
719 #endif
720 
721 int os::extra_bang_size_in_bytes() {
722   // SPARC does not require an additional stack bang.
723   return 0;
724 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
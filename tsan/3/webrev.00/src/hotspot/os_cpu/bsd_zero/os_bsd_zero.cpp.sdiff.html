<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/bsd_zero/os_bsd_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess_bsd_zero.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_bsd_zero.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/bsd_zero/os_bsd_zero.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright 2007, 2008, 2009, 2010 Red Hat, Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
176     if (sig == SIGSEGV || sig == SIGBUS) {
177       address addr = (address) info-&gt;si_addr;
178 
179       // check if fault address is within thread stack
180       if (thread-&gt;on_local_stack(addr)) {
181         // stack overflow
182         if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
183           thread-&gt;disable_stack_yellow_reserved_zone();
184           ShouldNotCallThis();
185         }
186         else if (thread-&gt;in_stack_red_zone(addr)) {
187           thread-&gt;disable_stack_red_zone();
188           ShouldNotCallThis();
189         }
190       }
191     }
192 
193     /*if (thread-&gt;thread_state() == _thread_in_Java) {
194       ShouldNotCallThis();
195     }
<span class="line-modified">196     else*/ if (thread-&gt;thread_state() == _thread_in_vm &amp;&amp;</span>

197                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
198       ShouldNotCallThis();
199     }
200 
201     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC
202     // kicks in and the heap gets shrunk before the field access.
203     /*if (sig == SIGSEGV || sig == SIGBUS) {
204       address addr = JNI_FastGetField::find_slowcase_pc(pc);
205       if (addr != (address)-1) {
206         stub = addr;
207       }
208     }*/
209   }
210 
211   // signal-chaining
212   if (os::Bsd::chained_handler(sig, info, ucVoid)) {
213      return true;
214   }
215 
216   if (!abort_if_unrecognized) {
</pre>
<hr />
<pre>
348 /////////////////////////////////////////////////////////////////////////////
349 // helper functions for fatal error handler
350 
351 void os::print_context(outputStream* st, const void* context) {
352   ShouldNotCallThis();
353 }
354 
355 void os::print_register_info(outputStream *st, const void *context) {
356   ShouldNotCallThis();
357 }
358 
359 /////////////////////////////////////////////////////////////////////////////
360 // Stubs for things that would be in bsd_zero.s if it existed.
361 // You probably want to disassemble these monkeys to check they&#39;re ok.
362 
363 extern &quot;C&quot; {
364   int SpinPause() {
365     return 1;
366   }
367 
<span class="line-modified">368   void _Copy_conjoint_jshorts_atomic(jshort* from, jshort* to, size_t count) {</span>
369     if (from &gt; to) {
<span class="line-modified">370       jshort *end = from + count;</span>
371       while (from &lt; end)
372         *(to++) = *(from++);
373     }
374     else if (from &lt; to) {
<span class="line-modified">375       jshort *end = from;</span>
376       from += count - 1;
377       to   += count - 1;
378       while (from &gt;= end)
379         *(to--) = *(from--);
380     }
381   }
<span class="line-modified">382   void _Copy_conjoint_jints_atomic(jint* from, jint* to, size_t count) {</span>
383     if (from &gt; to) {
<span class="line-modified">384       jint *end = from + count;</span>
385       while (from &lt; end)
386         *(to++) = *(from++);
387     }
388     else if (from &lt; to) {
<span class="line-modified">389       jint *end = from;</span>
390       from += count - 1;
391       to   += count - 1;
392       while (from &gt;= end)
393         *(to--) = *(from--);
394     }
395   }
<span class="line-modified">396   void _Copy_conjoint_jlongs_atomic(jlong* from, jlong* to, size_t count) {</span>
397     if (from &gt; to) {
<span class="line-modified">398       jlong *end = from + count;</span>
399       while (from &lt; end)
400         os::atomic_copy64(from++, to++);
401     }
402     else if (from &lt; to) {
<span class="line-modified">403       jlong *end = from;</span>
404       from += count - 1;
405       to   += count - 1;
406       while (from &gt;= end)
407         os::atomic_copy64(from--, to--);
408     }
409   }
410 
<span class="line-modified">411   void _Copy_arrayof_conjoint_bytes(HeapWord* from,</span>
412                                     HeapWord* to,
413                                     size_t    count) {
414     memmove(to, from, count);
415   }
<span class="line-modified">416   void _Copy_arrayof_conjoint_jshorts(HeapWord* from,</span>
417                                       HeapWord* to,
418                                       size_t    count) {
419     memmove(to, from, count * 2);
420   }
<span class="line-modified">421   void _Copy_arrayof_conjoint_jints(HeapWord* from,</span>
422                                     HeapWord* to,
423                                     size_t    count) {
424     memmove(to, from, count * 4);
425   }
<span class="line-modified">426   void _Copy_arrayof_conjoint_jlongs(HeapWord* from,</span>
427                                      HeapWord* to,
428                                      size_t    count) {
429     memmove(to, from, count * 8);
430   }
431 };
432 
433 /////////////////////////////////////////////////////////////////////////////
434 // Implementations of atomic operations not supported by processors.
435 //  -- http://gcc.gnu.org/onlinedocs/gcc-4.2.1/gcc/Atomic-Builtins.html
436 
437 #ifndef _LP64
438 extern &quot;C&quot; {
439   long long unsigned int __sync_val_compare_and_swap_8(
440     volatile void *ptr,
441     long long unsigned int oldval,
442     long long unsigned int newval) {
443     ShouldNotCallThis();
444   }
445 };
446 #endif // !_LP64
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright 2007, 2008, 2009, 2010 Red Hat, Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
176     if (sig == SIGSEGV || sig == SIGBUS) {
177       address addr = (address) info-&gt;si_addr;
178 
179       // check if fault address is within thread stack
180       if (thread-&gt;on_local_stack(addr)) {
181         // stack overflow
182         if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
183           thread-&gt;disable_stack_yellow_reserved_zone();
184           ShouldNotCallThis();
185         }
186         else if (thread-&gt;in_stack_red_zone(addr)) {
187           thread-&gt;disable_stack_red_zone();
188           ShouldNotCallThis();
189         }
190       }
191     }
192 
193     /*if (thread-&gt;thread_state() == _thread_in_Java) {
194       ShouldNotCallThis();
195     }
<span class="line-modified">196     else*/ if ((thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">197                thread-&gt;thread_state() == _thread_in_native) &amp;&amp;</span>
198                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
199       ShouldNotCallThis();
200     }
201 
202     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC
203     // kicks in and the heap gets shrunk before the field access.
204     /*if (sig == SIGSEGV || sig == SIGBUS) {
205       address addr = JNI_FastGetField::find_slowcase_pc(pc);
206       if (addr != (address)-1) {
207         stub = addr;
208       }
209     }*/
210   }
211 
212   // signal-chaining
213   if (os::Bsd::chained_handler(sig, info, ucVoid)) {
214      return true;
215   }
216 
217   if (!abort_if_unrecognized) {
</pre>
<hr />
<pre>
349 /////////////////////////////////////////////////////////////////////////////
350 // helper functions for fatal error handler
351 
352 void os::print_context(outputStream* st, const void* context) {
353   ShouldNotCallThis();
354 }
355 
356 void os::print_register_info(outputStream *st, const void *context) {
357   ShouldNotCallThis();
358 }
359 
360 /////////////////////////////////////////////////////////////////////////////
361 // Stubs for things that would be in bsd_zero.s if it existed.
362 // You probably want to disassemble these monkeys to check they&#39;re ok.
363 
364 extern &quot;C&quot; {
365   int SpinPause() {
366     return 1;
367   }
368 
<span class="line-modified">369   void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {</span>
370     if (from &gt; to) {
<span class="line-modified">371       const jshort *end = from + count;</span>
372       while (from &lt; end)
373         *(to++) = *(from++);
374     }
375     else if (from &lt; to) {
<span class="line-modified">376       const jshort *end = from;</span>
377       from += count - 1;
378       to   += count - 1;
379       while (from &gt;= end)
380         *(to--) = *(from--);
381     }
382   }
<span class="line-modified">383   void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {</span>
384     if (from &gt; to) {
<span class="line-modified">385       const jint *end = from + count;</span>
386       while (from &lt; end)
387         *(to++) = *(from++);
388     }
389     else if (from &lt; to) {
<span class="line-modified">390       const jint *end = from;</span>
391       from += count - 1;
392       to   += count - 1;
393       while (from &gt;= end)
394         *(to--) = *(from--);
395     }
396   }
<span class="line-modified">397   void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {</span>
398     if (from &gt; to) {
<span class="line-modified">399       const jlong *end = from + count;</span>
400       while (from &lt; end)
401         os::atomic_copy64(from++, to++);
402     }
403     else if (from &lt; to) {
<span class="line-modified">404       const jlong *end = from;</span>
405       from += count - 1;
406       to   += count - 1;
407       while (from &gt;= end)
408         os::atomic_copy64(from--, to--);
409     }
410   }
411 
<span class="line-modified">412   void _Copy_arrayof_conjoint_bytes(const HeapWord* from,</span>
413                                     HeapWord* to,
414                                     size_t    count) {
415     memmove(to, from, count);
416   }
<span class="line-modified">417   void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,</span>
418                                       HeapWord* to,
419                                       size_t    count) {
420     memmove(to, from, count * 2);
421   }
<span class="line-modified">422   void _Copy_arrayof_conjoint_jints(const HeapWord* from,</span>
423                                     HeapWord* to,
424                                     size_t    count) {
425     memmove(to, from, count * 4);
426   }
<span class="line-modified">427   void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,</span>
428                                      HeapWord* to,
429                                      size_t    count) {
430     memmove(to, from, count * 8);
431   }
432 };
433 
434 /////////////////////////////////////////////////////////////////////////////
435 // Implementations of atomic operations not supported by processors.
436 //  -- http://gcc.gnu.org/onlinedocs/gcc-4.2.1/gcc/Atomic-Builtins.html
437 
438 #ifndef _LP64
439 extern &quot;C&quot; {
440   long long unsigned int __sync_val_compare_and_swap_8(
441     volatile void *ptr,
442     long long unsigned int oldval,
443     long long unsigned int newval) {
444     ShouldNotCallThis();
445   }
446 };
447 #endif // !_LP64
</pre>
</td>
</tr>
</table>
<center><a href="orderAccess_bsd_zero.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_bsd_zero.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
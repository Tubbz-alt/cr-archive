<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/os_cpu/bsd_zero/os_bsd_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright 2007, 2008, 2009, 2010 Red Hat, Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #if !defined(__APPLE__) &amp;&amp; !defined(__NetBSD__)
 27 #include &lt;pthread.h&gt;
 28 # include &lt;pthread_np.h&gt; /* For pthread_attr_get_np */
 29 #endif
 30 
 31 // no precompiled headers
 32 #include &quot;jvm.h&quot;
 33 #include &quot;assembler_zero.inline.hpp&quot;
 34 #include &quot;classfile/classLoader.hpp&quot;
 35 #include &quot;classfile/systemDictionary.hpp&quot;
 36 #include &quot;classfile/vmSymbols.hpp&quot;
 37 #include &quot;code/icBuffer.hpp&quot;
 38 #include &quot;code/vtableStubs.hpp&quot;
 39 #include &quot;interpreter/interpreter.hpp&quot;
 40 #include &quot;memory/allocation.inline.hpp&quot;
 41 #include &quot;nativeInst_zero.hpp&quot;
 42 #include &quot;os_share_bsd.hpp&quot;
 43 #include &quot;prims/jniFastGetField.hpp&quot;
 44 #include &quot;prims/jvm_misc.hpp&quot;
 45 #include &quot;runtime/arguments.hpp&quot;
 46 #include &quot;runtime/extendedPC.hpp&quot;
 47 #include &quot;runtime/frame.inline.hpp&quot;
 48 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 49 #include &quot;runtime/java.hpp&quot;
 50 #include &quot;runtime/javaCalls.hpp&quot;
 51 #include &quot;runtime/mutexLocker.hpp&quot;
 52 #include &quot;runtime/osThread.hpp&quot;
 53 #include &quot;runtime/sharedRuntime.hpp&quot;
 54 #include &quot;runtime/stubRoutines.hpp&quot;
 55 #include &quot;runtime/thread.inline.hpp&quot;
 56 #include &quot;runtime/timer.hpp&quot;
 57 #include &quot;utilities/events.hpp&quot;
 58 #include &quot;utilities/vmError.hpp&quot;
 59 
 60 // See stubGenerator_zero.cpp
 61 #include &lt;setjmp.h&gt;
 62 extern sigjmp_buf* get_jmp_buf_for_continuation();
 63 
 64 address os::current_stack_pointer() {
 65   address dummy = (address) &amp;dummy;
 66   return dummy;
 67 }
 68 
 69 frame os::get_sender_for_C_frame(frame* fr) {
 70   ShouldNotCallThis();
 71   return frame();
 72 }
 73 
 74 frame os::current_frame() {
 75   // The only thing that calls this is the stack printing code in
 76   // VMError::report:
 77   //   - Step 110 (printing stack bounds) uses the sp in the frame
 78   //     to determine the amount of free space on the stack.  We
 79   //     set the sp to a close approximation of the real value in
 80   //     order to allow this step to complete.
 81   //   - Step 120 (printing native stack) tries to walk the stack.
 82   //     The frame we create has a NULL pc, which is ignored as an
 83   //     invalid frame.
 84   frame dummy = frame();
 85   dummy.set_sp((intptr_t *) current_stack_pointer());
 86   return dummy;
 87 }
 88 
 89 char* os::non_memory_address_word() {
 90   // Must never look like an address returned by reserve_memory,
 91   // even in its subfields (as defined by the CPU immediate fields,
 92   // if the CPU splits constants across multiple instructions).
 93 #ifdef SPARC
 94   // On SPARC, 0 != %hi(any real address), because there is no
 95   // allocation in the first 1Kb of the virtual address space.
 96   return (char *) 0;
 97 #else
 98   // This is the value for x86; works pretty well for PPC too.
 99   return (char *) -1;
100 #endif // SPARC
101 }
102 
103 address os::Bsd::ucontext_get_pc(const ucontext_t* uc) {
104   ShouldNotCallThis();
105   return NULL;
106 }
107 
108 void os::Bsd::ucontext_set_pc(ucontext_t * uc, address pc) {
109   ShouldNotCallThis();
110 }
111 
112 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
113                                         intptr_t** ret_sp,
114                                         intptr_t** ret_fp) {
115   ShouldNotCallThis();
116   return ExtendedPC();
117 }
118 
119 frame os::fetch_frame_from_context(const void* ucVoid) {
120   ShouldNotCallThis();
121   return frame();
122 }
123 
124 extern &quot;C&quot; JNIEXPORT int
125 JVM_handle_bsd_signal(int sig,
126                         siginfo_t* info,
127                         void* ucVoid,
128                         int abort_if_unrecognized) {
129   ucontext_t* uc = (ucontext_t*) ucVoid;
130 
131   Thread* t = Thread::current_or_null_safe();
132 
133   SignalHandlerMark shm(t);
134 
135   // handle SafeFetch faults
136   if (sig == SIGSEGV || sig == SIGBUS) {
137     sigjmp_buf* const pjb = get_jmp_buf_for_continuation();
138     if (pjb) {
139       siglongjmp(*pjb, 1);
140     }
141   }
142 
143   // Note: it&#39;s not uncommon that JNI code uses signal/sigset to
144   // install then restore certain signal handler (e.g. to temporarily
145   // block SIGPIPE, or have a SIGILL handler when detecting CPU
146   // type). When that happens, JVM_handle_bsd_signal() might be
147   // invoked with junk info/ucVoid. To avoid unnecessary crash when
148   // libjsig is not preloaded, try handle signals that do not require
149   // siginfo/ucontext first.
150 
151   if (sig == SIGPIPE || sig == SIGXFSZ) {
152     // allow chained handler to go first
153     if (os::Bsd::chained_handler(sig, info, ucVoid)) {
154       return true;
155     } else {
156       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
157       return true;
158     }
159   }
160 
161   JavaThread* thread = NULL;
162   VMThread* vmthread = NULL;
163   if (os::Bsd::signal_handlers_are_installed) {
164     if (t != NULL ){
165       if(t-&gt;is_Java_thread()) {
166         thread = (JavaThread*)t;
167       }
168       else if(t-&gt;is_VM_thread()){
169         vmthread = (VMThread *)t;
170       }
171     }
172   }
173 
174   if (info != NULL &amp;&amp; thread != NULL) {
175     // Handle ALL stack overflow variations here
176     if (sig == SIGSEGV || sig == SIGBUS) {
177       address addr = (address) info-&gt;si_addr;
178 
179       // check if fault address is within thread stack
180       if (thread-&gt;on_local_stack(addr)) {
181         // stack overflow
182         if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
183           thread-&gt;disable_stack_yellow_reserved_zone();
184           ShouldNotCallThis();
185         }
186         else if (thread-&gt;in_stack_red_zone(addr)) {
187           thread-&gt;disable_stack_red_zone();
188           ShouldNotCallThis();
189         }
190       }
191     }
192 
193     /*if (thread-&gt;thread_state() == _thread_in_Java) {
194       ShouldNotCallThis();
195     }
196     else*/ if (thread-&gt;thread_state() == _thread_in_vm &amp;&amp;
197                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
198       ShouldNotCallThis();
199     }
200 
201     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC
202     // kicks in and the heap gets shrunk before the field access.
203     /*if (sig == SIGSEGV || sig == SIGBUS) {
204       address addr = JNI_FastGetField::find_slowcase_pc(pc);
205       if (addr != (address)-1) {
206         stub = addr;
207       }
208     }*/
209   }
210 
211   // signal-chaining
212   if (os::Bsd::chained_handler(sig, info, ucVoid)) {
213      return true;
214   }
215 
216   if (!abort_if_unrecognized) {
217     // caller wants another chance, so give it to him
218     return false;
219   }
220 
221 #ifndef PRODUCT
222   if (sig == SIGSEGV) {
223     fatal(&quot;\n#&quot;
224           &quot;\n#    /--------------------\\&quot;
225           &quot;\n#    | segmentation fault |&quot;
226           &quot;\n#    \\---\\ /--------------/&quot;
227           &quot;\n#        /&quot;
228           &quot;\n#    [-]        |\\_/|    &quot;
229           &quot;\n#    (+)=C      |o o|__  &quot;
230           &quot;\n#    | |        =-*-=__\\ &quot;
231           &quot;\n#    OOO        c_c_(___)&quot;);
232   }
233 #endif // !PRODUCT
234 
235   const char *fmt =
236       &quot;caught unhandled signal &quot; INT32_FORMAT &quot; at address &quot; PTR_FORMAT;
237   char buf[128];
238 
239   sprintf(buf, fmt, sig, info-&gt;si_addr);
240   fatal(buf);
241   return false;
242 }
243 
244 void os::Bsd::init_thread_fpu_state(void) {
245   // Nothing to do
246 }
247 
248 bool os::is_allocatable(size_t bytes) {
249 #ifdef _LP64
250   return true;
251 #else
252   if (bytes &lt; 2 * G) {
253     return true;
254   }
255 
256   char* addr = reserve_memory(bytes, NULL);
257 
258   if (addr != NULL) {
259     release_memory(addr, bytes);
260   }
261 
262   return addr != NULL;
263 #endif // _LP64
264 }
265 
266 ///////////////////////////////////////////////////////////////////////////////
267 // thread stack
268 
269 size_t os::Posix::_compiler_thread_min_stack_allowed = 64 * K;
270 size_t os::Posix::_java_thread_min_stack_allowed = 64 * K;
271 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 64 * K;
272 
273 size_t os::Posix::default_stack_size(os::ThreadType thr_type) {
274 #ifdef _LP64
275   size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);
276 #else
277   size_t s = (thr_type == os::compiler_thread ? 2 * M : 512 * K);
278 #endif // _LP64
279   return s;
280 }
281 
282 static void current_stack_region(address *bottom, size_t *size) {
283   address stack_bottom;
284   address stack_top;
285   size_t stack_bytes;
286 
287 #ifdef __APPLE__
288   pthread_t self = pthread_self();
289   stack_top = (address) pthread_get_stackaddr_np(self);
290   stack_bytes = pthread_get_stacksize_np(self);
291   stack_bottom = stack_top - stack_bytes;
292 #elif defined(__OpenBSD__)
293   stack_t ss;
294   int rslt = pthread_stackseg_np(pthread_self(), &amp;ss);
295 
296   if (rslt != 0)
297     fatal(&quot;pthread_stackseg_np failed with error = &quot; INT32_FORMAT, rslt);
298 
299   stack_top = (address) ss.ss_sp;
300   stack_bytes  = ss.ss_size;
301   stack_bottom = stack_top - stack_bytes;
302 #else
303   pthread_attr_t attr;
304 
305   int rslt = pthread_attr_init(&amp;attr);
306 
307   // JVM needs to know exact stack location, abort if it fails
308   if (rslt != 0)
309     fatal(&quot;pthread_attr_init failed with error = &quot; INT32_FORMAT, rslt);
310 
311   rslt = pthread_attr_get_np(pthread_self(), &amp;attr);
312 
313   if (rslt != 0)
314     fatal(&quot;pthread_attr_get_np failed with error = &quot; INT32_FORMAT, rslt);
315 
316   if (pthread_attr_getstackaddr(&amp;attr, (void **) &amp;stack_bottom) != 0 ||
317       pthread_attr_getstacksize(&amp;attr, &amp;stack_bytes) != 0) {
318     fatal(&quot;Can not locate current stack attributes!&quot;);
319   }
320 
321   pthread_attr_destroy(&amp;attr);
322 
323   stack_top = stack_bottom + stack_bytes;
324 #endif
325 
326   assert(os::current_stack_pointer() &gt;= stack_bottom, &quot;should do&quot;);
327   assert(os::current_stack_pointer() &lt; stack_top, &quot;should do&quot;);
328 
329   *bottom = stack_bottom;
330   *size = stack_top - stack_bottom;
331 }
332 
333 address os::current_stack_base() {
334   address bottom;
335   size_t size;
336   current_stack_region(&amp;bottom, &amp;size);
337   return bottom + size;
338 }
339 
340 size_t os::current_stack_size() {
341   // stack size includes normal stack and HotSpot guard pages
342   address bottom;
343   size_t size;
344   current_stack_region(&amp;bottom, &amp;size);
345   return size;
346 }
347 
348 /////////////////////////////////////////////////////////////////////////////
349 // helper functions for fatal error handler
350 
351 void os::print_context(outputStream* st, const void* context) {
352   ShouldNotCallThis();
353 }
354 
355 void os::print_register_info(outputStream *st, const void *context) {
356   ShouldNotCallThis();
357 }
358 
359 /////////////////////////////////////////////////////////////////////////////
360 // Stubs for things that would be in bsd_zero.s if it existed.
361 // You probably want to disassemble these monkeys to check they&#39;re ok.
362 
363 extern &quot;C&quot; {
364   int SpinPause() {
365     return 1;
366   }
367 
368   void _Copy_conjoint_jshorts_atomic(jshort* from, jshort* to, size_t count) {
369     if (from &gt; to) {
370       jshort *end = from + count;
371       while (from &lt; end)
372         *(to++) = *(from++);
373     }
374     else if (from &lt; to) {
375       jshort *end = from;
376       from += count - 1;
377       to   += count - 1;
378       while (from &gt;= end)
379         *(to--) = *(from--);
380     }
381   }
382   void _Copy_conjoint_jints_atomic(jint* from, jint* to, size_t count) {
383     if (from &gt; to) {
384       jint *end = from + count;
385       while (from &lt; end)
386         *(to++) = *(from++);
387     }
388     else if (from &lt; to) {
389       jint *end = from;
390       from += count - 1;
391       to   += count - 1;
392       while (from &gt;= end)
393         *(to--) = *(from--);
394     }
395   }
396   void _Copy_conjoint_jlongs_atomic(jlong* from, jlong* to, size_t count) {
397     if (from &gt; to) {
398       jlong *end = from + count;
399       while (from &lt; end)
400         os::atomic_copy64(from++, to++);
401     }
402     else if (from &lt; to) {
403       jlong *end = from;
404       from += count - 1;
405       to   += count - 1;
406       while (from &gt;= end)
407         os::atomic_copy64(from--, to--);
408     }
409   }
410 
411   void _Copy_arrayof_conjoint_bytes(HeapWord* from,
412                                     HeapWord* to,
413                                     size_t    count) {
414     memmove(to, from, count);
415   }
416   void _Copy_arrayof_conjoint_jshorts(HeapWord* from,
417                                       HeapWord* to,
418                                       size_t    count) {
419     memmove(to, from, count * 2);
420   }
421   void _Copy_arrayof_conjoint_jints(HeapWord* from,
422                                     HeapWord* to,
423                                     size_t    count) {
424     memmove(to, from, count * 4);
425   }
426   void _Copy_arrayof_conjoint_jlongs(HeapWord* from,
427                                      HeapWord* to,
428                                      size_t    count) {
429     memmove(to, from, count * 8);
430   }
431 };
432 
433 /////////////////////////////////////////////////////////////////////////////
434 // Implementations of atomic operations not supported by processors.
435 //  -- http://gcc.gnu.org/onlinedocs/gcc-4.2.1/gcc/Atomic-Builtins.html
436 
437 #ifndef _LP64
438 extern &quot;C&quot; {
439   long long unsigned int __sync_val_compare_and_swap_8(
440     volatile void *ptr,
441     long long unsigned int oldval,
442     long long unsigned int newval) {
443     ShouldNotCallThis();
444   }
445 };
446 #endif // !_LP64
447 
448 #ifndef PRODUCT
449 void os::verify_stack_alignment() {
450 }
451 #endif
452 
453 int os::extra_bang_size_in_bytes() {
454   // Zero does not require an additional stack bang.
455   return 0;
456 }
    </pre>
  </body>
</html>
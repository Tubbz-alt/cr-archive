<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os_cpu/bsd_zero/atomic_bsd_zero.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright 2007, 2008, 2011, 2015, Red Hat, Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef OS_CPU_BSD_ZERO_ATOMIC_BSD_ZERO_HPP
 27 #define OS_CPU_BSD_ZERO_ATOMIC_BSD_ZERO_HPP
 28 
 29 #include &quot;runtime/os.hpp&quot;
 30 
 31 // Implementation of class atomic
 32 
 33 #ifdef M68K
 34 
 35 /*
 36  * __m68k_cmpxchg
 37  *
 38  * Atomically store newval in *ptr if *ptr is equal to oldval for user space.
 39  * Returns newval on success and oldval if no exchange happened.
 40  * This implementation is processor specific and works on
 41  * 68020 68030 68040 and 68060.
 42  *
 43  * It will not work on ColdFire, 68000 and 68010 since they lack the CAS
 44  * instruction.
 45  * Using a kernelhelper would be better for arch complete implementation.
 46  *
 47  */
 48 
 49 static inline int __m68k_cmpxchg(int oldval, int newval, volatile int *ptr) {
 50   int ret;
 51   __asm __volatile (&quot;cas%.l %0,%2,%1&quot;
 52                    : &quot;=d&quot; (ret), &quot;+m&quot; (*(ptr))
 53                    : &quot;d&quot; (newval), &quot;0&quot; (oldval));
 54   return ret;
 55 }
 56 
 57 /* Perform an atomic compare and swap: if the current value of `*PTR&#39;
 58    is OLDVAL, then write NEWVAL into `*PTR&#39;.  Return the contents of
 59    `*PTR&#39; before the operation.*/
 60 static inline int m68k_compare_and_swap(int newval,
 61                                         volatile int *ptr,
 62                                         int oldval) {
 63   for (;;) {
 64       int prev = *ptr;
 65       if (prev != oldval)
 66         return prev;
 67 
 68       if (__m68k_cmpxchg (prev, newval, ptr) == newval)
 69         // Success.
 70         return prev;
 71 
 72       // We failed even though prev == oldval.  Try again.
 73     }
 74 }
 75 
 76 /* Atomically add an int to memory.  */
 77 static inline int m68k_add_and_fetch(int add_value, volatile int *ptr) {
 78   for (;;) {
 79       // Loop until success.
 80 
 81       int prev = *ptr;
 82 
 83       if (__m68k_cmpxchg (prev, prev + add_value, ptr) == prev + add_value)
 84         return prev + add_value;
 85     }
 86 }
 87 
 88 /* Atomically write VALUE into `*PTR&#39; and returns the previous
 89    contents of `*PTR&#39;.  */
 90 static inline int m68k_lock_test_and_set(int newval, volatile int *ptr) {
 91   for (;;) {
 92       // Loop until success.
 93       int prev = *ptr;
 94 
 95       if (__m68k_cmpxchg (prev, newval, ptr) == prev)
 96         return prev;
 97     }
 98 }
 99 #endif // M68K
100 
101 #ifdef ARM
102 
103 /*
104  * __kernel_cmpxchg
105  *
106  * Atomically store newval in *ptr if *ptr is equal to oldval for user space.
107  * Return zero if *ptr was changed or non-zero if no exchange happened.
108  * The C flag is also set if *ptr was changed to allow for assembly
109  * optimization in the calling code.
110  *
111  */
112 
113 typedef int (__kernel_cmpxchg_t)(int oldval, int newval, volatile int *ptr);
114 #define __kernel_cmpxchg (*(__kernel_cmpxchg_t *) 0xffff0fc0)
115 
116 
117 
118 /* Perform an atomic compare and swap: if the current value of `*PTR&#39;
119    is OLDVAL, then write NEWVAL into `*PTR&#39;.  Return the contents of
120    `*PTR&#39; before the operation.*/
121 static inline int arm_compare_and_swap(int newval,
122                                        volatile int *ptr,
123                                        int oldval) {
124   for (;;) {
125       int prev = *ptr;
126       if (prev != oldval)
127         return prev;
128 
129       if (__kernel_cmpxchg (prev, newval, ptr) == 0)
130         // Success.
131         return prev;
132 
133       // We failed even though prev == oldval.  Try again.
134     }
135 }
136 
137 /* Atomically add an int to memory.  */
138 static inline int arm_add_and_fetch(int add_value, volatile int *ptr) {
139   for (;;) {
140       // Loop until a __kernel_cmpxchg succeeds.
141 
142       int prev = *ptr;
143 
144       if (__kernel_cmpxchg (prev, prev + add_value, ptr) == 0)
145         return prev + add_value;
146     }
147 }
148 
149 /* Atomically write VALUE into `*PTR&#39; and returns the previous
150    contents of `*PTR&#39;.  */
151 static inline int arm_lock_test_and_set(int newval, volatile int *ptr) {
152   for (;;) {
153       // Loop until a __kernel_cmpxchg succeeds.
154       int prev = *ptr;
155 
156       if (__kernel_cmpxchg (prev, newval, ptr) == 0)
157         return prev;
158     }
159 }
160 #endif // ARM
161 
162 template&lt;size_t byte_size&gt;
<a name="1" id="anc1"></a><span class="line-modified">163 struct Atomic::PlatformAdd</span>
<span class="line-modified">164   : Atomic::AddAndFetch&lt;Atomic::PlatformAdd&lt;byte_size&gt; &gt;</span>
<span class="line-modified">165 {</span>
<span class="line-modified">166   template&lt;typename I, typename D&gt;</span>
<span class="line-modified">167   D add_and_fetch(I add_value, D volatile* dest, atomic_memory_order order) const;</span>



168 };
169 
170 template&lt;&gt;
<a name="2" id="anc2"></a><span class="line-modified">171 template&lt;typename I, typename D&gt;</span>
<span class="line-modified">172 inline D Atomic::PlatformAdd&lt;4&gt;::add_and_fetch(I add_value, D volatile* dest,</span>
173                                                atomic_memory_order order) const {
174   STATIC_ASSERT(4 == sizeof(I));
175   STATIC_ASSERT(4 == sizeof(D));
176 
177 #ifdef ARM
<a name="3" id="anc3"></a><span class="line-modified">178   return add_using_helper&lt;int&gt;(arm_add_and_fetch, add_value, dest);</span>
179 #else
180 #ifdef M68K
<a name="4" id="anc4"></a><span class="line-modified">181   return add_using_helper&lt;int&gt;(m68k_add_and_fetch, add_value, dest);</span>
182 #else
183   return __sync_add_and_fetch(dest, add_value);
184 #endif // M68K
185 #endif // ARM
186 }
187 
188 template&lt;&gt;
<a name="5" id="anc5"></a><span class="line-modified">189 template&lt;typename I, typename D&gt;</span>
<span class="line-modified">190 inline D Atomic::PlatformAdd&lt;8&gt;::add_and_fetch(I add_value, D volatile* dest,</span>
191                                                atomic_memory_order order) const {
192   STATIC_ASSERT(8 == sizeof(I));
193   STATIC_ASSERT(8 == sizeof(D));
194 
195   return __sync_add_and_fetch(dest, add_value);
196 }
197 
198 template&lt;&gt;
199 template&lt;typename T&gt;
<a name="6" id="anc6"></a><span class="line-modified">200 inline T Atomic::PlatformXchg&lt;4&gt;::operator()(T exchange_value,</span>
<span class="line-modified">201                                              T volatile* dest,</span>
202                                              atomic_memory_order order) const {
203   STATIC_ASSERT(4 == sizeof(T));
204 #ifdef ARM
<a name="7" id="anc7"></a><span class="line-modified">205   return xchg_using_helper&lt;int&gt;(arm_lock_test_and_set, exchange_value, dest);</span>
206 #else
207 #ifdef M68K
<a name="8" id="anc8"></a><span class="line-modified">208   return xchg_using_helper&lt;int&gt;(m68k_lock_test_and_set, exchange_value, dest);</span>
209 #else
210   // __sync_lock_test_and_set is a bizarrely named atomic exchange
211   // operation.  Note that some platforms only support this with the
212   // limitation that the only valid value to store is the immediate
213   // constant 1.  There is a test for this in JNI_CreateJavaVM().
214   T result = __sync_lock_test_and_set (dest, exchange_value);
215   // All atomic operations are expected to be full memory barriers
216   // (see atomic.hpp). However, __sync_lock_test_and_set is not
217   // a full memory barrier, but an acquire barrier. Hence, this added
218   // barrier.
219   __sync_synchronize();
220   return result;
221 #endif // M68K
222 #endif // ARM
223 }
224 
225 template&lt;&gt;
226 template&lt;typename T&gt;
<a name="9" id="anc9"></a><span class="line-modified">227 inline T Atomic::PlatformXchg&lt;8&gt;::operator()(T exchange_value,</span>
<span class="line-modified">228                                              T volatile* dest,</span>
229                                              atomic_memory_order order) const {
230   STATIC_ASSERT(8 == sizeof(T));
231   T result = __sync_lock_test_and_set (dest, exchange_value);
232   __sync_synchronize();
233   return result;
234 }
235 
236 // No direct support for cmpxchg of bytes; emulate using int.
237 template&lt;&gt;
238 struct Atomic::PlatformCmpxchg&lt;1&gt; : Atomic::CmpxchgByteUsingInt {};
239 
240 template&lt;&gt;
241 template&lt;typename T&gt;
<a name="10" id="anc10"></a><span class="line-modified">242 inline T Atomic::PlatformCmpxchg&lt;4&gt;::operator()(T exchange_value,</span>
<span class="line-removed">243                                                 T volatile* dest,</span>
244                                                 T compare_value,
<a name="11" id="anc11"></a>
245                                                 atomic_memory_order order) const {
246   STATIC_ASSERT(4 == sizeof(T));
247 #ifdef ARM
<a name="12" id="anc12"></a><span class="line-modified">248   return cmpxchg_using_helper&lt;int&gt;(arm_compare_and_swap, exchange_value, dest, compare_value);</span>
249 #else
250 #ifdef M68K
<a name="13" id="anc13"></a><span class="line-modified">251   return cmpxchg_using_helper&lt;int&gt;(m68k_compare_and_swap, exchange_value, dest, compare_value);</span>
252 #else
253   return __sync_val_compare_and_swap(dest, compare_value, exchange_value);
254 #endif // M68K
255 #endif // ARM
256 }
257 
258 template&lt;&gt;
259 template&lt;typename T&gt;
<a name="14" id="anc14"></a><span class="line-modified">260 inline T Atomic::PlatformCmpxchg&lt;8&gt;::operator()(T exchange_value,</span>
<span class="line-removed">261                                                 T volatile* dest,</span>
262                                                 T compare_value,
<a name="15" id="anc15"></a>
263                                                 atomic_memory_order order) const {
264   STATIC_ASSERT(8 == sizeof(T));
265   return __sync_val_compare_and_swap(dest, compare_value, exchange_value);
266 }
267 
268 template&lt;&gt;
269 template&lt;typename T&gt;
270 inline T Atomic::PlatformLoad&lt;8&gt;::operator()(T const volatile* src) const {
271   STATIC_ASSERT(8 == sizeof(T));
272   volatile int64_t dest;
273   os::atomic_copy64(reinterpret_cast&lt;const volatile int64_t*&gt;(src), reinterpret_cast&lt;volatile int64_t*&gt;(&amp;dest));
274   return PrimitiveConversions::cast&lt;T&gt;(dest);
275 }
276 
277 template&lt;&gt;
278 template&lt;typename T&gt;
<a name="16" id="anc16"></a><span class="line-modified">279 inline void Atomic::PlatformStore&lt;8&gt;::operator()(T store_value,</span>
<span class="line-modified">280                                                  T volatile* dest) const {</span>
281   STATIC_ASSERT(8 == sizeof(T));
282   os::atomic_copy64(reinterpret_cast&lt;const volatile int64_t*&gt;(&amp;store_value), reinterpret_cast&lt;volatile int64_t*&gt;(dest));
283 }
284 
285 #endif // OS_CPU_BSD_ZERO_ATOMIC_BSD_ZERO_HPP
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
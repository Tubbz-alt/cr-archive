<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os_cpu/linux_zero/os_linux_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright 2007, 2008, 2009, 2010 Red Hat, Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 // no precompiled headers
 27 #include &quot;jvm.h&quot;
 28 #include &quot;assembler_zero.inline.hpp&quot;
 29 #include &quot;classfile/classLoader.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;classfile/vmSymbols.hpp&quot;
 32 #include &quot;code/icBuffer.hpp&quot;
 33 #include &quot;code/vtableStubs.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;memory/allocation.inline.hpp&quot;
 36 #include &quot;nativeInst_zero.hpp&quot;
 37 #include &quot;os_share_linux.hpp&quot;
 38 #include &quot;prims/jniFastGetField.hpp&quot;
 39 #include &quot;prims/jvm_misc.hpp&quot;
 40 #include &quot;runtime/arguments.hpp&quot;
 41 #include &quot;runtime/extendedPC.hpp&quot;
 42 #include &quot;runtime/frame.inline.hpp&quot;
 43 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 44 #include &quot;runtime/java.hpp&quot;
 45 #include &quot;runtime/javaCalls.hpp&quot;
 46 #include &quot;runtime/mutexLocker.hpp&quot;
 47 #include &quot;runtime/osThread.hpp&quot;
 48 #include &quot;runtime/sharedRuntime.hpp&quot;
 49 #include &quot;runtime/stubRoutines.hpp&quot;
 50 #include &quot;runtime/thread.inline.hpp&quot;
 51 #include &quot;runtime/timer.hpp&quot;
 52 #include &quot;utilities/align.hpp&quot;
 53 #include &quot;utilities/events.hpp&quot;
 54 #include &quot;utilities/vmError.hpp&quot;
 55 
 56 // See stubGenerator_zero.cpp
 57 #include &lt;setjmp.h&gt;
 58 extern sigjmp_buf* get_jmp_buf_for_continuation();
 59 
 60 address os::current_stack_pointer() {
 61   // return the address of the current function
 62   return (address)__builtin_frame_address(0);
 63 }
 64 
 65 frame os::get_sender_for_C_frame(frame* fr) {
 66   ShouldNotCallThis();
 67   return frame(NULL, NULL); // silence compile warning.
 68 }
 69 
 70 frame os::current_frame() {
 71   // The only thing that calls this is the stack printing code in
 72   // VMError::report:
 73   //   - Step 110 (printing stack bounds) uses the sp in the frame
 74   //     to determine the amount of free space on the stack.  We
 75   //     set the sp to a close approximation of the real value in
 76   //     order to allow this step to complete.
 77   //   - Step 120 (printing native stack) tries to walk the stack.
 78   //     The frame we create has a NULL pc, which is ignored as an
 79   //     invalid frame.
 80   frame dummy = frame();
 81   dummy.set_sp((intptr_t *) current_stack_pointer());
 82   return dummy;
 83 }
 84 
 85 char* os::non_memory_address_word() {
 86   // Must never look like an address returned by reserve_memory,
 87   // even in its subfields (as defined by the CPU immediate fields,
 88   // if the CPU splits constants across multiple instructions).
 89 #ifdef SPARC
 90   // On SPARC, 0 != %hi(any real address), because there is no
 91   // allocation in the first 1Kb of the virtual address space.
 92   return (char *) 0;
 93 #else
 94   // This is the value for x86; works pretty well for PPC too.
 95   return (char *) -1;
 96 #endif // SPARC
 97 }
 98 
 99 address os::Linux::ucontext_get_pc(const ucontext_t* uc) {
100   ShouldNotCallThis();
101   return NULL; // silence compile warnings
102 }
103 
104 void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {
105   ShouldNotCallThis();
106 }
107 
108 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
109                                         intptr_t** ret_sp,
110                                         intptr_t** ret_fp) {
111   ShouldNotCallThis();
112   return NULL; // silence compile warnings
113 }
114 
115 frame os::fetch_frame_from_context(const void* ucVoid) {
116   ShouldNotCallThis();
117   return frame(NULL, NULL); // silence compile warnings
118 }
119 
120 extern &quot;C&quot; JNIEXPORT int
121 JVM_handle_linux_signal(int sig,
122                         siginfo_t* info,
123                         void* ucVoid,
124                         int abort_if_unrecognized) {
125   ucontext_t* uc = (ucontext_t*) ucVoid;
126 
127   Thread* t = Thread::current_or_null_safe();
128 
129   SignalHandlerMark shm(t);
130 
131   // handle SafeFetch faults
132   if (sig == SIGSEGV || sig == SIGBUS) {
133     sigjmp_buf* const pjb = get_jmp_buf_for_continuation();
134     if (pjb) {
135       siglongjmp(*pjb, 1);
136     }
137   }
138 
139   // Note: it&#39;s not uncommon that JNI code uses signal/sigset to
140   // install then restore certain signal handler (e.g. to temporarily
141   // block SIGPIPE, or have a SIGILL handler when detecting CPU
142   // type). When that happens, JVM_handle_linux_signal() might be
143   // invoked with junk info/ucVoid. To avoid unnecessary crash when
144   // libjsig is not preloaded, try handle signals that do not require
145   // siginfo/ucontext first.
146 
147   if (sig == SIGPIPE || sig == SIGXFSZ) {
148     // allow chained handler to go first
149     if (os::Linux::chained_handler(sig, info, ucVoid)) {
150       return true;
151     } else {
152       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
153       return true;
154     }
155   }
156 
157   JavaThread* thread = NULL;
158   VMThread* vmthread = NULL;
159   if (os::Linux::signal_handlers_are_installed) {
160     if (t != NULL ){
161       if(t-&gt;is_Java_thread()) {
162         thread = (JavaThread*)t;
163       }
164       else if(t-&gt;is_VM_thread()){
165         vmthread = (VMThread *)t;
166       }
167     }
168   }
169 
170   if (info != NULL &amp;&amp; thread != NULL) {
171     // Handle ALL stack overflow variations here
172     if (sig == SIGSEGV) {
173       address addr = (address) info-&gt;si_addr;
174 
175       // check if fault address is within thread stack
176       if (thread-&gt;on_local_stack(addr)) {
177         // stack overflow
178         if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
179           thread-&gt;disable_stack_yellow_reserved_zone();
180           ShouldNotCallThis();
181         }
182         else if (thread-&gt;in_stack_red_zone(addr)) {
183           thread-&gt;disable_stack_red_zone();
184           ShouldNotCallThis();
185         }
186         else {
187           // Accessing stack address below sp may cause SEGV if
188           // current thread has MAP_GROWSDOWN stack. This should
189           // only happen when current thread was created by user
190           // code with MAP_GROWSDOWN flag and then attached to VM.
191           // See notes in os_linux.cpp.
192           if (thread-&gt;osthread()-&gt;expanding_stack() == 0) {
193             thread-&gt;osthread()-&gt;set_expanding_stack();
194             if (os::Linux::manually_expand_stack(thread, addr)) {
195               thread-&gt;osthread()-&gt;clear_expanding_stack();
196               return true;
197             }
198             thread-&gt;osthread()-&gt;clear_expanding_stack();
199           }
200           else {
201             fatal(&quot;recursive segv. expanding stack.&quot;);
202           }
203         }
204       }
205     }
206 
207     /*if (thread-&gt;thread_state() == _thread_in_Java) {
208       ShouldNotCallThis();
209     }
<a name="2" id="anc2"></a><span class="line-modified">210     else*/ if (thread-&gt;thread_state() == _thread_in_vm &amp;&amp;</span>

211                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
212       ShouldNotCallThis();
213     }
214 
215     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC
216     // kicks in and the heap gets shrunk before the field access.
217     /*if (sig == SIGSEGV || sig == SIGBUS) {
218       address addr = JNI_FastGetField::find_slowcase_pc(pc);
219       if (addr != (address)-1) {
220         stub = addr;
221       }
222     }*/
223   }
224 
225   // signal-chaining
226   if (os::Linux::chained_handler(sig, info, ucVoid)) {
227      return true;
228   }
229 
230   if (!abort_if_unrecognized) {
231     // caller wants another chance, so give it to him
232     return false;
233   }
234 
235 #ifndef PRODUCT
236   if (sig == SIGSEGV) {
237     fatal(&quot;\n#&quot;
238           &quot;\n#    /--------------------\\&quot;
239           &quot;\n#    | segmentation fault |&quot;
240           &quot;\n#    \\---\\ /--------------/&quot;
241           &quot;\n#        /&quot;
242           &quot;\n#    [-]        |\\_/|    &quot;
243           &quot;\n#    (+)=C      |o o|__  &quot;
244           &quot;\n#    | |        =-*-=__\\ &quot;
245           &quot;\n#    OOO        c_c_(___)&quot;);
246   }
247 #endif // !PRODUCT
248 
249   char buf[64];
250 
251   sprintf(buf, &quot;caught unhandled signal %d&quot;, sig);
252 
253 // Silence -Wformat-security warning for fatal()
254 PRAGMA_DIAG_PUSH
255 PRAGMA_FORMAT_NONLITERAL_IGNORED
256   fatal(buf);
257 PRAGMA_DIAG_POP
258   return true; // silence compiler warnings
259 }
260 
261 void os::Linux::init_thread_fpu_state(void) {
262   // Nothing to do
263 }
264 
265 int os::Linux::get_fpu_control_word() {
266   ShouldNotCallThis();
267   return -1; // silence compile warnings
268 }
269 
270 void os::Linux::set_fpu_control_word(int fpu) {
271   ShouldNotCallThis();
272 }
273 
274 bool os::is_allocatable(size_t bytes) {
275 #ifdef _LP64
276   return true;
277 #else
278   if (bytes &lt; 2 * G) {
279     return true;
280   }
281 
282   char* addr = reserve_memory(bytes, NULL);
283 
284   if (addr != NULL) {
285     release_memory(addr, bytes);
286   }
287 
288   return addr != NULL;
289 #endif // _LP64
290 }
291 
292 ///////////////////////////////////////////////////////////////////////////////
293 // thread stack
294 
295 size_t os::Posix::_compiler_thread_min_stack_allowed = 64 * K;
296 size_t os::Posix::_java_thread_min_stack_allowed = 64 * K;
297 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 64 * K;
298 
299 size_t os::Posix::default_stack_size(os::ThreadType thr_type) {
300 #ifdef _LP64
301   size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);
302 #else
303   size_t s = (thr_type == os::compiler_thread ? 2 * M : 512 * K);
304 #endif // _LP64
305   return s;
306 }
307 
308 static void current_stack_region(address *bottom, size_t *size) {
309   pthread_attr_t attr;
310   int res = pthread_getattr_np(pthread_self(), &amp;attr);
311   if (res != 0) {
312     if (res == ENOMEM) {
313       vm_exit_out_of_memory(0, OOM_MMAP_ERROR, &quot;pthread_getattr_np&quot;);
314     }
315     else {
316       fatal(&quot;pthread_getattr_np failed with error = %d&quot;, res);
317     }
318   }
319 
320   address stack_bottom;
321   size_t stack_bytes;
322   res = pthread_attr_getstack(&amp;attr, (void **) &amp;stack_bottom, &amp;stack_bytes);
323   if (res != 0) {
324     fatal(&quot;pthread_attr_getstack failed with error = %d&quot;, res);
325   }
326   address stack_top = stack_bottom + stack_bytes;
327 
328   // The block of memory returned by pthread_attr_getstack() includes
329   // guard pages where present.  We need to trim these off.
330   size_t page_bytes = os::Linux::page_size();
331   assert(((intptr_t) stack_bottom &amp; (page_bytes - 1)) == 0, &quot;unaligned stack&quot;);
332 
333   size_t guard_bytes;
334   res = pthread_attr_getguardsize(&amp;attr, &amp;guard_bytes);
335   if (res != 0) {
336     fatal(&quot;pthread_attr_getguardsize failed with errno = %d&quot;, res);
337   }
338   int guard_pages = align_up(guard_bytes, page_bytes) / page_bytes;
339   assert(guard_bytes == guard_pages * page_bytes, &quot;unaligned guard&quot;);
340 
341 #ifdef IA64
342   // IA64 has two stacks sharing the same area of memory, a normal
343   // stack growing downwards and a register stack growing upwards.
344   // Guard pages, if present, are in the centre.  This code splits
345   // the stack in two even without guard pages, though in theory
346   // there&#39;s nothing to stop us allocating more to the normal stack
347   // or more to the register stack if one or the other were found
348   // to grow faster.
349   int total_pages = align_down(stack_bytes, page_bytes) / page_bytes;
350   stack_bottom += (total_pages - guard_pages) / 2 * page_bytes;
351 #endif // IA64
352 
353   stack_bottom += guard_bytes;
354 
355   pthread_attr_destroy(&amp;attr);
356 
357   // The initial thread has a growable stack, and the size reported
358   // by pthread_attr_getstack is the maximum size it could possibly
359   // be given what currently mapped.  This can be huge, so we cap it.
360   if (os::is_primordial_thread()) {
361     stack_bytes = stack_top - stack_bottom;
362 
363     if (stack_bytes &gt; JavaThread::stack_size_at_create())
364       stack_bytes = JavaThread::stack_size_at_create();
365 
366     stack_bottom = stack_top - stack_bytes;
367   }
368 
369   assert(os::current_stack_pointer() &gt;= stack_bottom, &quot;should do&quot;);
370   assert(os::current_stack_pointer() &lt; stack_top, &quot;should do&quot;);
371 
372   *bottom = stack_bottom;
373   *size = stack_top - stack_bottom;
374 }
375 
376 address os::current_stack_base() {
377   address bottom;
378   size_t size;
379   current_stack_region(&amp;bottom, &amp;size);
380   return bottom + size;
381 }
382 
383 size_t os::current_stack_size() {
384   // stack size includes normal stack and HotSpot guard pages
385   address bottom;
386   size_t size;
387   current_stack_region(&amp;bottom, &amp;size);
388   return size;
389 }
390 
391 /////////////////////////////////////////////////////////////////////////////
392 // helper functions for fatal error handler
393 
394 void os::print_context(outputStream* st, const void* context) {
395   ShouldNotCallThis();
396 }
397 
398 void os::print_register_info(outputStream *st, const void *context) {
399   ShouldNotCallThis();
400 }
401 
402 /////////////////////////////////////////////////////////////////////////////
403 // Stubs for things that would be in linux_zero.s if it existed.
404 // You probably want to disassemble these monkeys to check they&#39;re ok.
405 
406 extern &quot;C&quot; {
407   int SpinPause() {
408       return -1; // silence compile warnings
409   }
410 
411 
<a name="3" id="anc3"></a><span class="line-modified">412   void _Copy_conjoint_jshorts_atomic(jshort* from, jshort* to, size_t count) {</span>
413     if (from &gt; to) {
<a name="4" id="anc4"></a><span class="line-modified">414       jshort *end = from + count;</span>
415       while (from &lt; end)
416         *(to++) = *(from++);
417     }
418     else if (from &lt; to) {
<a name="5" id="anc5"></a><span class="line-modified">419       jshort *end = from;</span>
420       from += count - 1;
421       to   += count - 1;
422       while (from &gt;= end)
423         *(to--) = *(from--);
424     }
425   }
<a name="6" id="anc6"></a><span class="line-modified">426   void _Copy_conjoint_jints_atomic(jint* from, jint* to, size_t count) {</span>
427     if (from &gt; to) {
<a name="7" id="anc7"></a><span class="line-modified">428       jint *end = from + count;</span>
429       while (from &lt; end)
430         *(to++) = *(from++);
431     }
432     else if (from &lt; to) {
<a name="8" id="anc8"></a><span class="line-modified">433       jint *end = from;</span>
434       from += count - 1;
435       to   += count - 1;
436       while (from &gt;= end)
437         *(to--) = *(from--);
438     }
439   }
<a name="9" id="anc9"></a><span class="line-modified">440   void _Copy_conjoint_jlongs_atomic(jlong* from, jlong* to, size_t count) {</span>
441     if (from &gt; to) {
<a name="10" id="anc10"></a><span class="line-modified">442       jlong *end = from + count;</span>
443       while (from &lt; end)
444         os::atomic_copy64(from++, to++);
445     }
446     else if (from &lt; to) {
<a name="11" id="anc11"></a><span class="line-modified">447       jlong *end = from;</span>
448       from += count - 1;
449       to   += count - 1;
450       while (from &gt;= end)
451         os::atomic_copy64(from--, to--);
452     }
453   }
454 
<a name="12" id="anc12"></a><span class="line-modified">455   void _Copy_arrayof_conjoint_bytes(HeapWord* from,</span>
456                                     HeapWord* to,
457                                     size_t    count) {
458     memmove(to, from, count);
459   }
<a name="13" id="anc13"></a><span class="line-modified">460   void _Copy_arrayof_conjoint_jshorts(HeapWord* from,</span>
461                                       HeapWord* to,
462                                       size_t    count) {
463     memmove(to, from, count * 2);
464   }
<a name="14" id="anc14"></a><span class="line-modified">465   void _Copy_arrayof_conjoint_jints(HeapWord* from,</span>
466                                     HeapWord* to,
467                                     size_t    count) {
468     memmove(to, from, count * 4);
469   }
<a name="15" id="anc15"></a><span class="line-modified">470   void _Copy_arrayof_conjoint_jlongs(HeapWord* from,</span>
471                                      HeapWord* to,
472                                      size_t    count) {
473     memmove(to, from, count * 8);
474   }
475 };
476 
477 /////////////////////////////////////////////////////////////////////////////
478 // Implementations of atomic operations not supported by processors.
479 //  -- http://gcc.gnu.org/onlinedocs/gcc-4.2.1/gcc/Atomic-Builtins.html
480 
481 #ifndef _LP64
482 extern &quot;C&quot; {
483   long long unsigned int __sync_val_compare_and_swap_8(
484     volatile void *ptr,
485     long long unsigned int oldval,
486     long long unsigned int newval) {
487     ShouldNotCallThis();
488   }
489 };
490 #endif // !_LP64
491 
492 #ifndef PRODUCT
493 void os::verify_stack_alignment() {
494 }
495 #endif
496 
497 int os::extra_bang_size_in_bytes() {
498   // Zero does not require an additional stack banging.
499   return 0;
500 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
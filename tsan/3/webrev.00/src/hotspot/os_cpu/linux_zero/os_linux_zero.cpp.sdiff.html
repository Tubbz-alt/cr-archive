<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/linux_zero/os_linux_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess_linux_zero.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_linux_zero.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_zero/os_linux_zero.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright 2007, 2008, 2009, 2010 Red Hat, Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
190           // code with MAP_GROWSDOWN flag and then attached to VM.
191           // See notes in os_linux.cpp.
192           if (thread-&gt;osthread()-&gt;expanding_stack() == 0) {
193             thread-&gt;osthread()-&gt;set_expanding_stack();
194             if (os::Linux::manually_expand_stack(thread, addr)) {
195               thread-&gt;osthread()-&gt;clear_expanding_stack();
196               return true;
197             }
198             thread-&gt;osthread()-&gt;clear_expanding_stack();
199           }
200           else {
201             fatal(&quot;recursive segv. expanding stack.&quot;);
202           }
203         }
204       }
205     }
206 
207     /*if (thread-&gt;thread_state() == _thread_in_Java) {
208       ShouldNotCallThis();
209     }
<span class="line-modified">210     else*/ if (thread-&gt;thread_state() == _thread_in_vm &amp;&amp;</span>

211                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
212       ShouldNotCallThis();
213     }
214 
215     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC
216     // kicks in and the heap gets shrunk before the field access.
217     /*if (sig == SIGSEGV || sig == SIGBUS) {
218       address addr = JNI_FastGetField::find_slowcase_pc(pc);
219       if (addr != (address)-1) {
220         stub = addr;
221       }
222     }*/
223   }
224 
225   // signal-chaining
226   if (os::Linux::chained_handler(sig, info, ucVoid)) {
227      return true;
228   }
229 
230   if (!abort_if_unrecognized) {
</pre>
<hr />
<pre>
392 // helper functions for fatal error handler
393 
394 void os::print_context(outputStream* st, const void* context) {
395   ShouldNotCallThis();
396 }
397 
398 void os::print_register_info(outputStream *st, const void *context) {
399   ShouldNotCallThis();
400 }
401 
402 /////////////////////////////////////////////////////////////////////////////
403 // Stubs for things that would be in linux_zero.s if it existed.
404 // You probably want to disassemble these monkeys to check they&#39;re ok.
405 
406 extern &quot;C&quot; {
407   int SpinPause() {
408       return -1; // silence compile warnings
409   }
410 
411 
<span class="line-modified">412   void _Copy_conjoint_jshorts_atomic(jshort* from, jshort* to, size_t count) {</span>
413     if (from &gt; to) {
<span class="line-modified">414       jshort *end = from + count;</span>
415       while (from &lt; end)
416         *(to++) = *(from++);
417     }
418     else if (from &lt; to) {
<span class="line-modified">419       jshort *end = from;</span>
420       from += count - 1;
421       to   += count - 1;
422       while (from &gt;= end)
423         *(to--) = *(from--);
424     }
425   }
<span class="line-modified">426   void _Copy_conjoint_jints_atomic(jint* from, jint* to, size_t count) {</span>
427     if (from &gt; to) {
<span class="line-modified">428       jint *end = from + count;</span>
429       while (from &lt; end)
430         *(to++) = *(from++);
431     }
432     else if (from &lt; to) {
<span class="line-modified">433       jint *end = from;</span>
434       from += count - 1;
435       to   += count - 1;
436       while (from &gt;= end)
437         *(to--) = *(from--);
438     }
439   }
<span class="line-modified">440   void _Copy_conjoint_jlongs_atomic(jlong* from, jlong* to, size_t count) {</span>
441     if (from &gt; to) {
<span class="line-modified">442       jlong *end = from + count;</span>
443       while (from &lt; end)
444         os::atomic_copy64(from++, to++);
445     }
446     else if (from &lt; to) {
<span class="line-modified">447       jlong *end = from;</span>
448       from += count - 1;
449       to   += count - 1;
450       while (from &gt;= end)
451         os::atomic_copy64(from--, to--);
452     }
453   }
454 
<span class="line-modified">455   void _Copy_arrayof_conjoint_bytes(HeapWord* from,</span>
456                                     HeapWord* to,
457                                     size_t    count) {
458     memmove(to, from, count);
459   }
<span class="line-modified">460   void _Copy_arrayof_conjoint_jshorts(HeapWord* from,</span>
461                                       HeapWord* to,
462                                       size_t    count) {
463     memmove(to, from, count * 2);
464   }
<span class="line-modified">465   void _Copy_arrayof_conjoint_jints(HeapWord* from,</span>
466                                     HeapWord* to,
467                                     size_t    count) {
468     memmove(to, from, count * 4);
469   }
<span class="line-modified">470   void _Copy_arrayof_conjoint_jlongs(HeapWord* from,</span>
471                                      HeapWord* to,
472                                      size_t    count) {
473     memmove(to, from, count * 8);
474   }
475 };
476 
477 /////////////////////////////////////////////////////////////////////////////
478 // Implementations of atomic operations not supported by processors.
479 //  -- http://gcc.gnu.org/onlinedocs/gcc-4.2.1/gcc/Atomic-Builtins.html
480 
481 #ifndef _LP64
482 extern &quot;C&quot; {
483   long long unsigned int __sync_val_compare_and_swap_8(
484     volatile void *ptr,
485     long long unsigned int oldval,
486     long long unsigned int newval) {
487     ShouldNotCallThis();
488   }
489 };
490 #endif // !_LP64
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright 2007, 2008, 2009, 2010 Red Hat, Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
190           // code with MAP_GROWSDOWN flag and then attached to VM.
191           // See notes in os_linux.cpp.
192           if (thread-&gt;osthread()-&gt;expanding_stack() == 0) {
193             thread-&gt;osthread()-&gt;set_expanding_stack();
194             if (os::Linux::manually_expand_stack(thread, addr)) {
195               thread-&gt;osthread()-&gt;clear_expanding_stack();
196               return true;
197             }
198             thread-&gt;osthread()-&gt;clear_expanding_stack();
199           }
200           else {
201             fatal(&quot;recursive segv. expanding stack.&quot;);
202           }
203         }
204       }
205     }
206 
207     /*if (thread-&gt;thread_state() == _thread_in_Java) {
208       ShouldNotCallThis();
209     }
<span class="line-modified">210     else*/ if ((thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">211                thread-&gt;thread_state() == _thread_in_native) &amp;&amp;</span>
212                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
213       ShouldNotCallThis();
214     }
215 
216     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC
217     // kicks in and the heap gets shrunk before the field access.
218     /*if (sig == SIGSEGV || sig == SIGBUS) {
219       address addr = JNI_FastGetField::find_slowcase_pc(pc);
220       if (addr != (address)-1) {
221         stub = addr;
222       }
223     }*/
224   }
225 
226   // signal-chaining
227   if (os::Linux::chained_handler(sig, info, ucVoid)) {
228      return true;
229   }
230 
231   if (!abort_if_unrecognized) {
</pre>
<hr />
<pre>
393 // helper functions for fatal error handler
394 
395 void os::print_context(outputStream* st, const void* context) {
396   ShouldNotCallThis();
397 }
398 
399 void os::print_register_info(outputStream *st, const void *context) {
400   ShouldNotCallThis();
401 }
402 
403 /////////////////////////////////////////////////////////////////////////////
404 // Stubs for things that would be in linux_zero.s if it existed.
405 // You probably want to disassemble these monkeys to check they&#39;re ok.
406 
407 extern &quot;C&quot; {
408   int SpinPause() {
409       return -1; // silence compile warnings
410   }
411 
412 
<span class="line-modified">413   void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {</span>
414     if (from &gt; to) {
<span class="line-modified">415       const jshort *end = from + count;</span>
416       while (from &lt; end)
417         *(to++) = *(from++);
418     }
419     else if (from &lt; to) {
<span class="line-modified">420       const jshort *end = from;</span>
421       from += count - 1;
422       to   += count - 1;
423       while (from &gt;= end)
424         *(to--) = *(from--);
425     }
426   }
<span class="line-modified">427   void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {</span>
428     if (from &gt; to) {
<span class="line-modified">429       const jint *end = from + count;</span>
430       while (from &lt; end)
431         *(to++) = *(from++);
432     }
433     else if (from &lt; to) {
<span class="line-modified">434       const jint *end = from;</span>
435       from += count - 1;
436       to   += count - 1;
437       while (from &gt;= end)
438         *(to--) = *(from--);
439     }
440   }
<span class="line-modified">441   void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {</span>
442     if (from &gt; to) {
<span class="line-modified">443       const jlong *end = from + count;</span>
444       while (from &lt; end)
445         os::atomic_copy64(from++, to++);
446     }
447     else if (from &lt; to) {
<span class="line-modified">448       const jlong *end = from;</span>
449       from += count - 1;
450       to   += count - 1;
451       while (from &gt;= end)
452         os::atomic_copy64(from--, to--);
453     }
454   }
455 
<span class="line-modified">456   void _Copy_arrayof_conjoint_bytes(const HeapWord* from,</span>
457                                     HeapWord* to,
458                                     size_t    count) {
459     memmove(to, from, count);
460   }
<span class="line-modified">461   void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,</span>
462                                       HeapWord* to,
463                                       size_t    count) {
464     memmove(to, from, count * 2);
465   }
<span class="line-modified">466   void _Copy_arrayof_conjoint_jints(const HeapWord* from,</span>
467                                     HeapWord* to,
468                                     size_t    count) {
469     memmove(to, from, count * 4);
470   }
<span class="line-modified">471   void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,</span>
472                                      HeapWord* to,
473                                      size_t    count) {
474     memmove(to, from, count * 8);
475   }
476 };
477 
478 /////////////////////////////////////////////////////////////////////////////
479 // Implementations of atomic operations not supported by processors.
480 //  -- http://gcc.gnu.org/onlinedocs/gcc-4.2.1/gcc/Atomic-Builtins.html
481 
482 #ifndef _LP64
483 extern &quot;C&quot; {
484   long long unsigned int __sync_val_compare_and_swap_8(
485     volatile void *ptr,
486     long long unsigned int oldval,
487     long long unsigned int newval) {
488     ShouldNotCallThis();
489   }
490 };
491 #endif // !_LP64
</pre>
</td>
</tr>
</table>
<center><a href="orderAccess_linux_zero.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_linux_zero.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
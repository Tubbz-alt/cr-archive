<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/linux_ppc/os_linux_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess_linux_ppc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread_linux_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_ppc/os_linux_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">  3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
</pre>
<hr />
<pre>
115 // modify PC in ucontext.
116 // Note: Only use this for an ucontext handed down to a signal handler. See comment
117 // in ucontext_get_pc.
118 void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {
119   guarantee(uc-&gt;uc_mcontext.regs != NULL, &quot;only use ucontext_set_pc in sigaction context&quot;);
120   uc-&gt;uc_mcontext.regs-&gt;nip = (unsigned long)pc;
121 }
122 
123 static address ucontext_get_lr(const ucontext_t * uc) {
124   return (address)uc-&gt;uc_mcontext.regs-&gt;link;
125 }
126 
127 intptr_t* os::Linux::ucontext_get_sp(const ucontext_t * uc) {
128   return (intptr_t*)uc-&gt;uc_mcontext.regs-&gt;gpr[1/*REG_SP*/];
129 }
130 
131 intptr_t* os::Linux::ucontext_get_fp(const ucontext_t * uc) {
132   return NULL;
133 }
134 




135 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
136                     intptr_t** ret_sp, intptr_t** ret_fp) {
137 
138   ExtendedPC  epc;
139   const ucontext_t* uc = (const ucontext_t*)ucVoid;
140 
141   if (uc != NULL) {
142     epc = ExtendedPC(os::Linux::ucontext_get_pc(uc));
143     if (ret_sp) *ret_sp = os::Linux::ucontext_get_sp(uc);
144     if (ret_fp) *ret_fp = os::Linux::ucontext_get_fp(uc);
145   } else {
146     // construct empty ExtendedPC for return value checking
147     epc = ExtendedPC(NULL);
148     if (ret_sp) *ret_sp = (intptr_t *)NULL;
149     if (ret_fp) *ret_fp = (intptr_t *)NULL;
150   }
151 
152   return epc;
153 }
154 
</pre>
<hr />
<pre>
250   // section &quot;Signals&quot;.
251   if (uc &amp;&amp; uc-&gt;uc_link) {
252     ucontext_t* second_uc = uc-&gt;uc_link;
253 
254     // MSR TS bits are 29 and 30 (Power ISA, v2.07B, Book III-S, pp. 857-858,
255     // 3.2.1 &quot;Machine State Register&quot;), however note that ISA notation for bit
256     // numbering is MSB 0, so for normal bit numbering (LSB 0) they come to be
257     // bits 33 and 34. It&#39;s not related to endianness, just a notation matter.
258     if (second_uc-&gt;uc_mcontext.regs-&gt;msr &amp; 0x600000000) {
259       if (TraceTraps) {
260         tty-&gt;print_cr(&quot;caught signal in transaction, &quot;
261                         &quot;ignoring to jump to abort handler&quot;);
262       }
263       // Return control to the HTM abort handler.
264       return true;
265     }
266   }
267 
268 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
269   if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
<span class="line-modified">270     handle_assert_poison_fault(ucVoid, info-&gt;si_addr);</span>
<span class="line-modified">271     return 1;</span>

272   }
273 #endif
274 
275   JavaThread* thread = NULL;
276   VMThread* vmthread = NULL;
277   if (os::Linux::signal_handlers_are_installed) {
278     if (t != NULL) {
279       if(t-&gt;is_Java_thread()) {
280         thread = (JavaThread*)t;
281       } else if(t-&gt;is_VM_thread()) {
282         vmthread = (VMThread *)t;
283       }
284     }
285   }
286 
287   // Moved SafeFetch32 handling outside thread!=NULL conditional block to make
288   // it work if no associated JavaThread object exists.
289   if (uc) {
290     address const pc = os::Linux::ucontext_get_pc(uc);
291     if (pc &amp;&amp; StubRoutines::is_safefetch_fault(pc)) {
292       os::Linux::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
293       return true;
294     }
295   }
296 
297   // decide if this trap can be handled by a stub
298   address stub = NULL;
299   address pc   = NULL;
300 
<span class="line-removed">301   //%note os_trap_1</span>
302   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
303     pc = (address) os::Linux::ucontext_get_pc(uc);
304 
305     // Handle ALL stack overflow variations here
306     if (sig == SIGSEGV) {
<span class="line-modified">307       // Si_addr may not be valid due to a bug in the linux-ppc64 kernel (see</span>
308       // comment below). Use get_stack_bang_address instead of si_addr.
<span class="line-modified">309       address addr = ((NativeInstruction*)pc)-&gt;get_stack_bang_address(uc);</span>













310 
311       // Check if fault address is within thread stack.
312       if (thread-&gt;on_local_stack(addr)) {
313         // stack overflow
314         if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
315           if (thread-&gt;thread_state() == _thread_in_Java) {
316             if (thread-&gt;in_stack_reserved_zone(addr)) {
317               frame fr;
318               if (os::Linux::get_frame_at_stack_banging_point(thread, uc, &amp;fr)) {
319                 assert(fr.is_java_frame(), &quot;Must be a Javac frame&quot;);
320                 frame activation =
321                   SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
322                 if (activation.sp() != NULL) {
323                   thread-&gt;disable_stack_reserved_zone();
324                   if (activation.is_interpreted_frame()) {
325                     thread-&gt;set_reserved_stack_activation((address)activation.fp());
326                   } else {
327                     thread-&gt;set_reserved_stack_activation((address)activation.unextended_sp());
328                   }
329                   return 1;
</pre>
<hr />
<pre>
436           tty-&gt;print_cr(&quot;trap: null_check at &quot; INTPTR_FORMAT &quot; (SIGSEGV)&quot;, p2i(pc));
437         }
438         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
439       }
440 
441 #ifdef COMPILER2
442       // SIGTRAP-based implicit range check in compiled code.
443       else if (sig == SIGTRAP &amp;&amp; TrapBasedRangeChecks &amp;&amp;
444                nativeInstruction_at(pc)-&gt;is_sigtrap_range_check()) {
445         if (TraceTraps) {
446           tty-&gt;print_cr(&quot;trap: range_check at &quot; INTPTR_FORMAT &quot; (SIGTRAP)&quot;, p2i(pc));
447         }
448         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
449       }
450 #endif
451       else if (sig == SIGBUS) {
452         // BugId 4454115: A read from a MappedByteBuffer can fault here if the
453         // underlying file has been truncated. Do not crash the VM in such a case.
454         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
455         CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
<span class="line-modified">456         if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {</span>

457           address next_pc = pc + 4;



458           next_pc = SharedRuntime::handle_unsafe_access(thread, next_pc);
459           os::Linux::ucontext_set_pc(uc, next_pc);
460           return true;
461         }
462       }
463     }
464 
465     else { // thread-&gt;thread_state() != _thread_in_Java
466       if (sig == SIGILL &amp;&amp; VM_Version::is_determine_features_test_running()) {
467         // SIGILL must be caused by VM_Version::determine_features().
468         *(int *)pc = 0; // patch instruction to 0 to indicate that it causes a SIGILL,
469                         // flushing of icache is not necessary.
470         stub = pc + 4;  // continue with next instruction.
471       }
<span class="line-modified">472       else if (thread-&gt;thread_state() == _thread_in_vm &amp;&amp;</span>

473                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
474         address next_pc = pc + 4;



475         next_pc = SharedRuntime::handle_unsafe_access(thread, next_pc);
<span class="line-modified">476         os::Linux::ucontext_set_pc(uc, pc + 4);</span>
477         return true;
478       }
479     }









480   }
481 
482   if (stub != NULL) {
483     // Save all thread context in case we need to restore it.
484     if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);
485     os::Linux::ucontext_set_pc(uc, stub);
486     return true;
487   }
488 
489   // signal-chaining
490   if (os::Linux::chained_handler(sig, info, ucVoid)) {
491     return true;
492   }
493 
494   if (!abort_if_unrecognized) {
495     // caller wants another chance, so give it to him
496     return false;
497   }
498 
499   if (pc == NULL &amp;&amp; uc != NULL) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">  3  * Copyright (c) 2012, 2019 SAP SE. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
</pre>
<hr />
<pre>
115 // modify PC in ucontext.
116 // Note: Only use this for an ucontext handed down to a signal handler. See comment
117 // in ucontext_get_pc.
118 void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {
119   guarantee(uc-&gt;uc_mcontext.regs != NULL, &quot;only use ucontext_set_pc in sigaction context&quot;);
120   uc-&gt;uc_mcontext.regs-&gt;nip = (unsigned long)pc;
121 }
122 
123 static address ucontext_get_lr(const ucontext_t * uc) {
124   return (address)uc-&gt;uc_mcontext.regs-&gt;link;
125 }
126 
127 intptr_t* os::Linux::ucontext_get_sp(const ucontext_t * uc) {
128   return (intptr_t*)uc-&gt;uc_mcontext.regs-&gt;gpr[1/*REG_SP*/];
129 }
130 
131 intptr_t* os::Linux::ucontext_get_fp(const ucontext_t * uc) {
132   return NULL;
133 }
134 
<span class="line-added">135 static unsigned long ucontext_get_trap(const ucontext_t * uc) {</span>
<span class="line-added">136   return uc-&gt;uc_mcontext.regs-&gt;trap;</span>
<span class="line-added">137 }</span>
<span class="line-added">138 </span>
139 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
140                     intptr_t** ret_sp, intptr_t** ret_fp) {
141 
142   ExtendedPC  epc;
143   const ucontext_t* uc = (const ucontext_t*)ucVoid;
144 
145   if (uc != NULL) {
146     epc = ExtendedPC(os::Linux::ucontext_get_pc(uc));
147     if (ret_sp) *ret_sp = os::Linux::ucontext_get_sp(uc);
148     if (ret_fp) *ret_fp = os::Linux::ucontext_get_fp(uc);
149   } else {
150     // construct empty ExtendedPC for return value checking
151     epc = ExtendedPC(NULL);
152     if (ret_sp) *ret_sp = (intptr_t *)NULL;
153     if (ret_fp) *ret_fp = (intptr_t *)NULL;
154   }
155 
156   return epc;
157 }
158 
</pre>
<hr />
<pre>
254   // section &quot;Signals&quot;.
255   if (uc &amp;&amp; uc-&gt;uc_link) {
256     ucontext_t* second_uc = uc-&gt;uc_link;
257 
258     // MSR TS bits are 29 and 30 (Power ISA, v2.07B, Book III-S, pp. 857-858,
259     // 3.2.1 &quot;Machine State Register&quot;), however note that ISA notation for bit
260     // numbering is MSB 0, so for normal bit numbering (LSB 0) they come to be
261     // bits 33 and 34. It&#39;s not related to endianness, just a notation matter.
262     if (second_uc-&gt;uc_mcontext.regs-&gt;msr &amp; 0x600000000) {
263       if (TraceTraps) {
264         tty-&gt;print_cr(&quot;caught signal in transaction, &quot;
265                         &quot;ignoring to jump to abort handler&quot;);
266       }
267       // Return control to the HTM abort handler.
268       return true;
269     }
270   }
271 
272 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
273   if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
<span class="line-modified">274     if (handle_assert_poison_fault(ucVoid, info-&gt;si_addr)) {</span>
<span class="line-modified">275       return 1;</span>
<span class="line-added">276     }</span>
277   }
278 #endif
279 
280   JavaThread* thread = NULL;
281   VMThread* vmthread = NULL;
282   if (os::Linux::signal_handlers_are_installed) {
283     if (t != NULL) {
284       if(t-&gt;is_Java_thread()) {
285         thread = (JavaThread*)t;
286       } else if(t-&gt;is_VM_thread()) {
287         vmthread = (VMThread *)t;
288       }
289     }
290   }
291 
292   // Moved SafeFetch32 handling outside thread!=NULL conditional block to make
293   // it work if no associated JavaThread object exists.
294   if (uc) {
295     address const pc = os::Linux::ucontext_get_pc(uc);
296     if (pc &amp;&amp; StubRoutines::is_safefetch_fault(pc)) {
297       os::Linux::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
298       return true;
299     }
300   }
301 
302   // decide if this trap can be handled by a stub
303   address stub = NULL;
304   address pc   = NULL;
305 

306   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
307     pc = (address) os::Linux::ucontext_get_pc(uc);
308 
309     // Handle ALL stack overflow variations here
310     if (sig == SIGSEGV) {
<span class="line-modified">311       // si_addr may not be valid due to a bug in the linux-ppc64 kernel (see</span>
312       // comment below). Use get_stack_bang_address instead of si_addr.
<span class="line-modified">313       // If SIGSEGV is caused due to a branch to an invalid address an</span>
<span class="line-added">314       // &quot;Instruction Storage Interrupt&quot; is generated and &#39;pc&#39; (NIP) already</span>
<span class="line-added">315       // contains the invalid address. Otherwise, the SIGSEGV is caused due to</span>
<span class="line-added">316       // load/store instruction trying to load/store from/to an invalid address</span>
<span class="line-added">317       // and causing a &quot;Data Storage Interrupt&quot;, so we inspect the intruction</span>
<span class="line-added">318       // in order to extract the faulty data addresss.</span>
<span class="line-added">319       address addr;</span>
<span class="line-added">320       if ((ucontext_get_trap(uc) &amp; 0x0F00 /* no IRQ reply bits */) == 0x0400) {</span>
<span class="line-added">321         // Instruction Storage Interrupt (ISI)</span>
<span class="line-added">322         addr = pc;</span>
<span class="line-added">323       } else {</span>
<span class="line-added">324         // Data Storage Interrupt (DSI), i.e. 0x0300: extract faulty data address</span>
<span class="line-added">325         addr = ((NativeInstruction*)pc)-&gt;get_stack_bang_address(uc);</span>
<span class="line-added">326       }</span>
327 
328       // Check if fault address is within thread stack.
329       if (thread-&gt;on_local_stack(addr)) {
330         // stack overflow
331         if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
332           if (thread-&gt;thread_state() == _thread_in_Java) {
333             if (thread-&gt;in_stack_reserved_zone(addr)) {
334               frame fr;
335               if (os::Linux::get_frame_at_stack_banging_point(thread, uc, &amp;fr)) {
336                 assert(fr.is_java_frame(), &quot;Must be a Javac frame&quot;);
337                 frame activation =
338                   SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
339                 if (activation.sp() != NULL) {
340                   thread-&gt;disable_stack_reserved_zone();
341                   if (activation.is_interpreted_frame()) {
342                     thread-&gt;set_reserved_stack_activation((address)activation.fp());
343                   } else {
344                     thread-&gt;set_reserved_stack_activation((address)activation.unextended_sp());
345                   }
346                   return 1;
</pre>
<hr />
<pre>
453           tty-&gt;print_cr(&quot;trap: null_check at &quot; INTPTR_FORMAT &quot; (SIGSEGV)&quot;, p2i(pc));
454         }
455         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
456       }
457 
458 #ifdef COMPILER2
459       // SIGTRAP-based implicit range check in compiled code.
460       else if (sig == SIGTRAP &amp;&amp; TrapBasedRangeChecks &amp;&amp;
461                nativeInstruction_at(pc)-&gt;is_sigtrap_range_check()) {
462         if (TraceTraps) {
463           tty-&gt;print_cr(&quot;trap: range_check at &quot; INTPTR_FORMAT &quot; (SIGTRAP)&quot;, p2i(pc));
464         }
465         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
466       }
467 #endif
468       else if (sig == SIGBUS) {
469         // BugId 4454115: A read from a MappedByteBuffer can fault here if the
470         // underlying file has been truncated. Do not crash the VM in such a case.
471         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
472         CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
<span class="line-modified">473         bool is_unsafe_arraycopy = (thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc));</span>
<span class="line-added">474         if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {</span>
475           address next_pc = pc + 4;
<span class="line-added">476           if (is_unsafe_arraycopy) {</span>
<span class="line-added">477             next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">478           }</span>
479           next_pc = SharedRuntime::handle_unsafe_access(thread, next_pc);
480           os::Linux::ucontext_set_pc(uc, next_pc);
481           return true;
482         }
483       }
484     }
485 
486     else { // thread-&gt;thread_state() != _thread_in_Java
487       if (sig == SIGILL &amp;&amp; VM_Version::is_determine_features_test_running()) {
488         // SIGILL must be caused by VM_Version::determine_features().
489         *(int *)pc = 0; // patch instruction to 0 to indicate that it causes a SIGILL,
490                         // flushing of icache is not necessary.
491         stub = pc + 4;  // continue with next instruction.
492       }
<span class="line-modified">493       else if ((thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">494                 thread-&gt;thread_state() == _thread_in_native) &amp;&amp;</span>
495                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
496         address next_pc = pc + 4;
<span class="line-added">497         if (UnsafeCopyMemory::contains_pc(pc)) {</span>
<span class="line-added">498           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">499         }</span>
500         next_pc = SharedRuntime::handle_unsafe_access(thread, next_pc);
<span class="line-modified">501         os::Linux::ucontext_set_pc(uc, next_pc);</span>
502         return true;
503       }
504     }
<span class="line-added">505 </span>
<span class="line-added">506     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in</span>
<span class="line-added">507     // and the heap gets shrunk before the field access.</span>
<span class="line-added">508     if ((sig == SIGSEGV) || (sig == SIGBUS)) {</span>
<span class="line-added">509       address addr = JNI_FastGetField::find_slowcase_pc(pc);</span>
<span class="line-added">510       if (addr != (address)-1) {</span>
<span class="line-added">511         stub = addr;</span>
<span class="line-added">512       }</span>
<span class="line-added">513     }</span>
514   }
515 
516   if (stub != NULL) {
517     // Save all thread context in case we need to restore it.
518     if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);
519     os::Linux::ucontext_set_pc(uc, stub);
520     return true;
521   }
522 
523   // signal-chaining
524   if (os::Linux::chained_handler(sig, info, ucVoid)) {
525     return true;
526   }
527 
528   if (!abort_if_unrecognized) {
529     // caller wants another chance, so give it to him
530     return false;
531   }
532 
533   if (pc == NULL &amp;&amp; uc != NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="orderAccess_linux_ppc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread_linux_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
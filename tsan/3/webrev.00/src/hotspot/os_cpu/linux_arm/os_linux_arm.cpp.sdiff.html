<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/linux_arm/os_linux_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess_linux_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread_linux_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_arm/os_linux_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
231   frame myframe((intptr_t*)os::current_stack_pointer(), fp + os::C_frame_offset,
232                  CAST_FROM_FN_PTR(address, os::current_frame));
233   frame caller_frame = os::get_sender_for_C_frame(&amp;myframe);
234 
235   if (os::is_first_C_frame(&amp;caller_frame)) {
236     // stack is not walkable
237     // Assert below was added because it does not seem like this can ever happen.
238     // How can this frame ever be the first C frame since it is called from C code?
239     // If it does ever happen, undo the assert and comment here on when/why it happens.
240     assert(false, &quot;this should never happen&quot;);
241     return frame();
242   }
243 
244   // return frame for our caller&#39;s caller
245   return os::get_sender_for_C_frame(&amp;caller_frame);
246 #endif
247 }
248 
249 extern &quot;C&quot; address check_vfp_fault_instr;
250 extern &quot;C&quot; address check_vfp3_32_fault_instr;


251 
252 address check_vfp_fault_instr = NULL;
253 address check_vfp3_32_fault_instr = NULL;
<span class="line-removed">254 extern &quot;C&quot; address check_simd_fault_instr;</span>
255 address check_simd_fault_instr = NULL;

256 
257 // Utility functions
258 
259 extern &quot;C&quot; int JVM_handle_linux_signal(int sig, siginfo_t* info,
260                                        void* ucVoid, int abort_if_unrecognized) {
261   ucontext_t* uc = (ucontext_t*) ucVoid;
262 
263   Thread* t = Thread::current_or_null_safe();
264 
265   // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away
266   // (no destructors can be run)
267   os::ThreadCrashProtection::check_crash_protection(sig, t);
268 
269   SignalHandlerMark shm(t);
270 
271   if (sig == SIGILL &amp;&amp;
272       ((info-&gt;si_addr == (caddr_t)check_simd_fault_instr)
273        || info-&gt;si_addr == (caddr_t)check_vfp_fault_instr
<span class="line-modified">274        || info-&gt;si_addr == (caddr_t)check_vfp3_32_fault_instr)) {</span>

275     // skip faulty instruction + instruction that sets return value to
276     // success and set return value to failure.
277     os::Linux::ucontext_set_pc(uc, (address)info-&gt;si_addr + 8);
278     uc-&gt;uc_mcontext.arm_r0 = 0;
279     return true;
280   }
281 
282   // Note: it&#39;s not uncommon that JNI code uses signal/sigset to install
283   // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
284   // or have a SIGILL handler when detecting CPU type). When that happens,
285   // JVM_handle_linux_signal() might be invoked with junk info/ucVoid. To
286   // avoid unnecessary crash when libjsig is not preloaded, try handle signals
287   // that do not require siginfo/ucontext first.
288 
289   if (sig == SIGPIPE || sig == SIGXFSZ) {
290     // allow chained handler to go first
291     if (os::Linux::chained_handler(sig, info, ucVoid)) {
292       return true;
293     } else {
294       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
295       return true;
296     }
297   }
298 
299 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
300   if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
<span class="line-modified">301     handle_assert_poison_fault(ucVoid, info-&gt;si_addr);</span>
<span class="line-modified">302     return 1;</span>

303   }
304 #endif
305 
306   JavaThread* thread = NULL;
307   VMThread* vmthread = NULL;
308   if (os::Linux::signal_handlers_are_installed) {
309     if (t != NULL ){
310       if(t-&gt;is_Java_thread()) {
311         thread = (JavaThread*)t;
312       }
313       else if(t-&gt;is_VM_thread()){
314         vmthread = (VMThread *)t;
315       }
316     }
317   }
318 
319   address stub = NULL;
320   address pc = NULL;
321   bool unsafe_access = false;
322 
323   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
324     pc = (address) os::Linux::ucontext_get_pc(uc);
325 
326     // Handle ALL stack overflow variations here
327     if (sig == SIGSEGV) {
328       address addr = (address) info-&gt;si_addr;
329 
330       if (StubRoutines::is_safefetch_fault(pc)) {
331         os::Linux::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
332         return 1;
333       }
334       // check if fault address is within thread stack
<span class="line-modified">335       if (addr &lt; thread-&gt;stack_base() &amp;&amp;</span>
<span class="line-removed">336           addr &gt;= thread-&gt;stack_base() - thread-&gt;stack_size()) {</span>
337         // stack overflow
338         if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
339           thread-&gt;disable_stack_yellow_reserved_zone();
340           if (thread-&gt;thread_state() == _thread_in_Java) {
341             // Throw a stack overflow exception.  Guard pages will be reenabled
342             // while unwinding the stack.
343             stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
344           } else {
345             // Thread was in the vm or native code.  Return and try to finish.
346             return 1;
347           }
348         } else if (thread-&gt;in_stack_red_zone(addr)) {
349           // Fatal red zone violation.  Disable the guard pages and fall through
350           // to handle_unexpected_exception way down below.
351           thread-&gt;disable_stack_red_zone();
352           tty-&gt;print_raw_cr(&quot;An irrecoverable stack overflow has occurred.&quot;);
353         } else {
354           // Accessing stack address below sp may cause SEGV if current
355           // thread has MAP_GROWSDOWN stack. This should only happen when
356           // current thread was created by user code with MAP_GROWSDOWN flag
</pre>
<hr />
<pre>
364              thread-&gt;osthread()-&gt;clear_expanding_stack();
365           } else {
366              fatal(&quot;recursive segv. expanding stack.&quot;);
367           }
368         }
369       }
370     }
371 
372     if (thread-&gt;thread_state() == _thread_in_Java) {
373       // Java thread running in Java code =&gt; find exception handler if any
374       // a fault inside compiled code, the interpreter, or a stub
375 
376       if (sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {
377         stub = SharedRuntime::get_poll_stub(pc);
378       } else if (sig == SIGBUS) {
379         // BugId 4454115: A read from a MappedByteBuffer can fault
380         // here if the underlying file has been truncated.
381         // Do not crash the VM in such a case.
382         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
383         CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
<span class="line-modified">384         if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {</span>
385           unsafe_access = true;
386         }
387       } else if (sig == SIGSEGV &amp;&amp;
388                  MacroAssembler::uses_implicit_null_check(info-&gt;si_addr)) {
389           // Determination of interpreter/vtable stub/compiled code null exception
390           CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
391           if (cb != NULL) {
392             stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
393           }
394       } else if (sig == SIGILL &amp;&amp; *(int *)pc == NativeInstruction::zombie_illegal_instruction) {
395         // Zombie
396         stub = SharedRuntime::get_handle_wrong_method_stub();
397       }
<span class="line-modified">398     } else if (thread-&gt;thread_state() == _thread_in_vm &amp;&amp;</span>

399                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
400         unsafe_access = true;
401     }
402 
403     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in
404     // and the heap gets shrunk before the field access.
405     if (sig == SIGSEGV || sig == SIGBUS) {
406       address addr = JNI_FastGetField::find_slowcase_pc(pc);
407       if (addr != (address)-1) {
408         stub = addr;
409       }
410     }
411   }
412 
413   if (unsafe_access &amp;&amp; stub == NULL) {
414     // it can be an unsafe access and we haven&#39;t found
415     // any other suitable exception reason,
416     // so assume it is an unsafe access.
417     address next_pc = pc + Assembler::InstructionSize;



418 #ifdef __thumb__
419     if (uc-&gt;uc_mcontext.arm_cpsr &amp; PSR_T_BIT) {
420       next_pc = (address)((intptr_t)next_pc | 0x1);
421     }
422 #endif
423 
424     stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
425   }
426 
427   if (stub != NULL) {
428 #ifdef __thumb__
429     if (uc-&gt;uc_mcontext.arm_cpsr &amp; PSR_T_BIT) {
430       intptr_t p = (intptr_t)pc | 0x1;
431       pc = (address)p;
432 
433       // Clear Thumb mode bit if we&#39;re redirected into the ARM ISA based code
434       if (((intptr_t)stub &amp; 0x1) == 0) {
435         uc-&gt;uc_mcontext.arm_cpsr &amp;= ~PSR_T_BIT;
436       }
437     } else {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
231   frame myframe((intptr_t*)os::current_stack_pointer(), fp + os::C_frame_offset,
232                  CAST_FROM_FN_PTR(address, os::current_frame));
233   frame caller_frame = os::get_sender_for_C_frame(&amp;myframe);
234 
235   if (os::is_first_C_frame(&amp;caller_frame)) {
236     // stack is not walkable
237     // Assert below was added because it does not seem like this can ever happen.
238     // How can this frame ever be the first C frame since it is called from C code?
239     // If it does ever happen, undo the assert and comment here on when/why it happens.
240     assert(false, &quot;this should never happen&quot;);
241     return frame();
242   }
243 
244   // return frame for our caller&#39;s caller
245   return os::get_sender_for_C_frame(&amp;caller_frame);
246 #endif
247 }
248 
249 extern &quot;C&quot; address check_vfp_fault_instr;
250 extern &quot;C&quot; address check_vfp3_32_fault_instr;
<span class="line-added">251 extern &quot;C&quot; address check_simd_fault_instr;</span>
<span class="line-added">252 extern &quot;C&quot; address check_mp_ext_fault_instr;</span>
253 
254 address check_vfp_fault_instr = NULL;
255 address check_vfp3_32_fault_instr = NULL;

256 address check_simd_fault_instr = NULL;
<span class="line-added">257 address check_mp_ext_fault_instr = NULL;</span>
258 
259 // Utility functions
260 
261 extern &quot;C&quot; int JVM_handle_linux_signal(int sig, siginfo_t* info,
262                                        void* ucVoid, int abort_if_unrecognized) {
263   ucontext_t* uc = (ucontext_t*) ucVoid;
264 
265   Thread* t = Thread::current_or_null_safe();
266 
267   // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away
268   // (no destructors can be run)
269   os::ThreadCrashProtection::check_crash_protection(sig, t);
270 
271   SignalHandlerMark shm(t);
272 
273   if (sig == SIGILL &amp;&amp;
274       ((info-&gt;si_addr == (caddr_t)check_simd_fault_instr)
275        || info-&gt;si_addr == (caddr_t)check_vfp_fault_instr
<span class="line-modified">276        || info-&gt;si_addr == (caddr_t)check_vfp3_32_fault_instr</span>
<span class="line-added">277        || info-&gt;si_addr == (caddr_t)check_mp_ext_fault_instr)) {</span>
278     // skip faulty instruction + instruction that sets return value to
279     // success and set return value to failure.
280     os::Linux::ucontext_set_pc(uc, (address)info-&gt;si_addr + 8);
281     uc-&gt;uc_mcontext.arm_r0 = 0;
282     return true;
283   }
284 
285   // Note: it&#39;s not uncommon that JNI code uses signal/sigset to install
286   // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
287   // or have a SIGILL handler when detecting CPU type). When that happens,
288   // JVM_handle_linux_signal() might be invoked with junk info/ucVoid. To
289   // avoid unnecessary crash when libjsig is not preloaded, try handle signals
290   // that do not require siginfo/ucontext first.
291 
292   if (sig == SIGPIPE || sig == SIGXFSZ) {
293     // allow chained handler to go first
294     if (os::Linux::chained_handler(sig, info, ucVoid)) {
295       return true;
296     } else {
297       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
298       return true;
299     }
300   }
301 
302 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
303   if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
<span class="line-modified">304     if (handle_assert_poison_fault(ucVoid, info-&gt;si_addr)) {</span>
<span class="line-modified">305       return 1;</span>
<span class="line-added">306     }</span>
307   }
308 #endif
309 
310   JavaThread* thread = NULL;
311   VMThread* vmthread = NULL;
312   if (os::Linux::signal_handlers_are_installed) {
313     if (t != NULL ){
314       if(t-&gt;is_Java_thread()) {
315         thread = (JavaThread*)t;
316       }
317       else if(t-&gt;is_VM_thread()){
318         vmthread = (VMThread *)t;
319       }
320     }
321   }
322 
323   address stub = NULL;
324   address pc = NULL;
325   bool unsafe_access = false;
326 
327   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
328     pc = (address) os::Linux::ucontext_get_pc(uc);
329 
330     // Handle ALL stack overflow variations here
331     if (sig == SIGSEGV) {
332       address addr = (address) info-&gt;si_addr;
333 
334       if (StubRoutines::is_safefetch_fault(pc)) {
335         os::Linux::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
336         return 1;
337       }
338       // check if fault address is within thread stack
<span class="line-modified">339       if (thread-&gt;on_local_stack(addr)) {</span>

340         // stack overflow
341         if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
342           thread-&gt;disable_stack_yellow_reserved_zone();
343           if (thread-&gt;thread_state() == _thread_in_Java) {
344             // Throw a stack overflow exception.  Guard pages will be reenabled
345             // while unwinding the stack.
346             stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
347           } else {
348             // Thread was in the vm or native code.  Return and try to finish.
349             return 1;
350           }
351         } else if (thread-&gt;in_stack_red_zone(addr)) {
352           // Fatal red zone violation.  Disable the guard pages and fall through
353           // to handle_unexpected_exception way down below.
354           thread-&gt;disable_stack_red_zone();
355           tty-&gt;print_raw_cr(&quot;An irrecoverable stack overflow has occurred.&quot;);
356         } else {
357           // Accessing stack address below sp may cause SEGV if current
358           // thread has MAP_GROWSDOWN stack. This should only happen when
359           // current thread was created by user code with MAP_GROWSDOWN flag
</pre>
<hr />
<pre>
367              thread-&gt;osthread()-&gt;clear_expanding_stack();
368           } else {
369              fatal(&quot;recursive segv. expanding stack.&quot;);
370           }
371         }
372       }
373     }
374 
375     if (thread-&gt;thread_state() == _thread_in_Java) {
376       // Java thread running in Java code =&gt; find exception handler if any
377       // a fault inside compiled code, the interpreter, or a stub
378 
379       if (sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {
380         stub = SharedRuntime::get_poll_stub(pc);
381       } else if (sig == SIGBUS) {
382         // BugId 4454115: A read from a MappedByteBuffer can fault
383         // here if the underlying file has been truncated.
384         // Do not crash the VM in such a case.
385         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
386         CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
<span class="line-modified">387         if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || (thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc))) {</span>
388           unsafe_access = true;
389         }
390       } else if (sig == SIGSEGV &amp;&amp;
391                  MacroAssembler::uses_implicit_null_check(info-&gt;si_addr)) {
392           // Determination of interpreter/vtable stub/compiled code null exception
393           CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
394           if (cb != NULL) {
395             stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
396           }
397       } else if (sig == SIGILL &amp;&amp; *(int *)pc == NativeInstruction::zombie_illegal_instruction) {
398         // Zombie
399         stub = SharedRuntime::get_handle_wrong_method_stub();
400       }
<span class="line-modified">401     } else if ((thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">402                 thread-&gt;thread_state() == _thread_in_native) &amp;&amp;</span>
403                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
404         unsafe_access = true;
405     }
406 
407     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in
408     // and the heap gets shrunk before the field access.
409     if (sig == SIGSEGV || sig == SIGBUS) {
410       address addr = JNI_FastGetField::find_slowcase_pc(pc);
411       if (addr != (address)-1) {
412         stub = addr;
413       }
414     }
415   }
416 
417   if (unsafe_access &amp;&amp; stub == NULL) {
418     // it can be an unsafe access and we haven&#39;t found
419     // any other suitable exception reason,
420     // so assume it is an unsafe access.
421     address next_pc = pc + Assembler::InstructionSize;
<span class="line-added">422     if (UnsafeCopyMemory::contains_pc(pc)) {</span>
<span class="line-added">423       next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">424     }</span>
425 #ifdef __thumb__
426     if (uc-&gt;uc_mcontext.arm_cpsr &amp; PSR_T_BIT) {
427       next_pc = (address)((intptr_t)next_pc | 0x1);
428     }
429 #endif
430 
431     stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
432   }
433 
434   if (stub != NULL) {
435 #ifdef __thumb__
436     if (uc-&gt;uc_mcontext.arm_cpsr &amp; PSR_T_BIT) {
437       intptr_t p = (intptr_t)pc | 0x1;
438       pc = (address)p;
439 
440       // Clear Thumb mode bit if we&#39;re redirected into the ARM ISA based code
441       if (((intptr_t)stub &amp; 0x1) == 0) {
442         uc-&gt;uc_mcontext.arm_cpsr &amp;= ~PSR_T_BIT;
443       }
444     } else {
</pre>
</td>
</tr>
</table>
<center><a href="orderAccess_linux_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread_linux_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
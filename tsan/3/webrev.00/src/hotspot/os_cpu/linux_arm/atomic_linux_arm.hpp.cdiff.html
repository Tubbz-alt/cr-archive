<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/os_cpu/linux_arm/atomic_linux_arm.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../linux_aarch64/vm_version_linux_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="orderAccess_linux_arm.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_arm/atomic_linux_arm.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,11 ***</span>
  
  #ifndef OS_CPU_LINUX_ARM_ATOMIC_LINUX_ARM_HPP
  #define OS_CPU_LINUX_ARM_ATOMIC_LINUX_ARM_HPP
  
  #include &quot;runtime/os.hpp&quot;
<span class="line-modified">! #include &quot;vm_version_arm.hpp&quot;</span>
  
  // Implementation of class atomic
  
  /*
   * Atomic long operations on 32-bit ARM
<span class="line-new-header">--- 24,11 ---</span>
  
  #ifndef OS_CPU_LINUX_ARM_ATOMIC_LINUX_ARM_HPP
  #define OS_CPU_LINUX_ARM_ATOMIC_LINUX_ARM_HPP
  
  #include &quot;runtime/os.hpp&quot;
<span class="line-modified">! #include &quot;runtime/vm_version.hpp&quot;</span>
  
  // Implementation of class atomic
  
  /*
   * Atomic long operations on 32-bit ARM
</pre>
<hr />
<pre>
<span class="line-old-header">*** 52,12 ***</span>
      (*os::atomic_load_long_func)(reinterpret_cast&lt;const volatile int64_t*&gt;(src)));
  }
  
  template&lt;&gt;
  template&lt;typename T&gt;
<span class="line-modified">! inline void Atomic::PlatformStore&lt;8&gt;::operator()(T store_value,</span>
<span class="line-modified">!                                                  T volatile* dest) const {</span>
    STATIC_ASSERT(8 == sizeof(T));
    (*os::atomic_store_long_func)(
      PrimitiveConversions::cast&lt;int64_t&gt;(store_value), reinterpret_cast&lt;volatile int64_t*&gt;(dest));
  }
  
<span class="line-new-header">--- 52,12 ---</span>
      (*os::atomic_load_long_func)(reinterpret_cast&lt;const volatile int64_t*&gt;(src)));
  }
  
  template&lt;&gt;
  template&lt;typename T&gt;
<span class="line-modified">! inline void Atomic::PlatformStore&lt;8&gt;::operator()(T volatile* dest,</span>
<span class="line-modified">!                                                  T store_value) const {</span>
    STATIC_ASSERT(8 == sizeof(T));
    (*os::atomic_store_long_func)(
      PrimitiveConversions::cast&lt;int64_t&gt;(store_value), reinterpret_cast&lt;volatile int64_t*&gt;(dest));
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,34 ***</span>
  // barriers semantics.
  //
  // For ARMv7 we add explicit barriers in the stubs.
  
  template&lt;size_t byte_size&gt;
<span class="line-modified">! struct Atomic::PlatformAdd</span>
<span class="line-modified">!   : Atomic::AddAndFetch&lt;Atomic::PlatformAdd&lt;byte_size&gt; &gt;</span>
<span class="line-modified">! {</span>
<span class="line-modified">!   template&lt;typename I, typename D&gt;</span>
<span class="line-modified">!   D add_and_fetch(I add_value, D volatile* dest, atomic_memory_order order) const;</span>
  };
  
  template&lt;&gt;
<span class="line-modified">! template&lt;typename I, typename D&gt;</span>
<span class="line-modified">! inline D Atomic::PlatformAdd&lt;4&gt;::add_and_fetch(I add_value, D volatile* dest,</span>
                                                 atomic_memory_order order) const {
    STATIC_ASSERT(4 == sizeof(I));
    STATIC_ASSERT(4 == sizeof(D));
<span class="line-modified">!   return add_using_helper&lt;int32_t&gt;(os::atomic_add_func, add_value, dest);</span>
  }
  
  
  template&lt;&gt;
  template&lt;typename T&gt;
<span class="line-modified">! inline T Atomic::PlatformXchg&lt;4&gt;::operator()(T exchange_value,</span>
<span class="line-modified">!                                              T volatile* dest,</span>
                                               atomic_memory_order order) const {
    STATIC_ASSERT(4 == sizeof(T));
<span class="line-modified">!   return xchg_using_helper&lt;int32_t&gt;(os::atomic_xchg_func, exchange_value, dest);</span>
  }
  
  
  // The memory_order parameter is ignored - we always provide the strongest/most-conservative ordering
  
<span class="line-new-header">--- 65,37 ---</span>
  // barriers semantics.
  //
  // For ARMv7 we add explicit barriers in the stubs.
  
  template&lt;size_t byte_size&gt;
<span class="line-modified">! struct Atomic::PlatformAdd {</span>
<span class="line-modified">!   template&lt;typename D, typename I&gt;</span>
<span class="line-modified">!   D add_and_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   template&lt;typename D, typename I&gt;</span>
<span class="line-added">+   D fetch_and_add(D volatile* dest, I add_value, atomic_memory_order order) const {</span>
<span class="line-added">+     return add_and_fetch(dest, add_value, order) - add_value;</span>
<span class="line-added">+   }</span>
  };
  
  template&lt;&gt;
<span class="line-modified">! template&lt;typename D, typename I&gt;</span>
<span class="line-modified">! inline D Atomic::PlatformAdd&lt;4&gt;::add_and_fetch(D volatile* dest, I add_value,</span>
                                                 atomic_memory_order order) const {
    STATIC_ASSERT(4 == sizeof(I));
    STATIC_ASSERT(4 == sizeof(D));
<span class="line-modified">!   return add_using_helper&lt;int32_t&gt;(os::atomic_add_func, dest, add_value);</span>
  }
  
  
  template&lt;&gt;
  template&lt;typename T&gt;
<span class="line-modified">! inline T Atomic::PlatformXchg&lt;4&gt;::operator()(T volatile* dest,</span>
<span class="line-modified">!                                              T exchange_value,</span>
                                               atomic_memory_order order) const {
    STATIC_ASSERT(4 == sizeof(T));
<span class="line-modified">!   return xchg_using_helper&lt;int32_t&gt;(os::atomic_xchg_func, dest, exchange_value);</span>
  }
  
  
  // The memory_order parameter is ignored - we always provide the strongest/most-conservative ordering
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,24 ***</span>
  }
  
  
  template&lt;&gt;
  template&lt;typename T&gt;
<span class="line-modified">! inline T Atomic::PlatformCmpxchg&lt;4&gt;::operator()(T exchange_value,</span>
<span class="line-removed">-                                                 T volatile* dest,</span>
                                                  T compare_value,
                                                  atomic_memory_order order) const {
    STATIC_ASSERT(4 == sizeof(T));
<span class="line-modified">!   return cmpxchg_using_helper&lt;int32_t&gt;(reorder_cmpxchg_func, exchange_value, dest, compare_value);</span>
  }
  
  template&lt;&gt;
  template&lt;typename T&gt;
<span class="line-modified">! inline T Atomic::PlatformCmpxchg&lt;8&gt;::operator()(T exchange_value,</span>
<span class="line-removed">-                                                 T volatile* dest,</span>
                                                  T compare_value,
                                                  atomic_memory_order order) const {
    STATIC_ASSERT(8 == sizeof(T));
<span class="line-modified">!   return cmpxchg_using_helper&lt;int64_t&gt;(reorder_cmpxchg_long_func, exchange_value, dest, compare_value);</span>
  }
  
  #endif // OS_CPU_LINUX_ARM_ATOMIC_LINUX_ARM_HPP
<span class="line-new-header">--- 120,24 ---</span>
  }
  
  
  template&lt;&gt;
  template&lt;typename T&gt;
<span class="line-modified">! inline T Atomic::PlatformCmpxchg&lt;4&gt;::operator()(T volatile* dest,</span>
                                                  T compare_value,
<span class="line-added">+                                                 T exchange_value,</span>
                                                  atomic_memory_order order) const {
    STATIC_ASSERT(4 == sizeof(T));
<span class="line-modified">!   return cmpxchg_using_helper&lt;int32_t&gt;(reorder_cmpxchg_func, dest, compare_value, exchange_value);</span>
  }
  
  template&lt;&gt;
  template&lt;typename T&gt;
<span class="line-modified">! inline T Atomic::PlatformCmpxchg&lt;8&gt;::operator()(T volatile* dest,</span>
                                                  T compare_value,
<span class="line-added">+                                                 T exchange_value,</span>
                                                  atomic_memory_order order) const {
    STATIC_ASSERT(8 == sizeof(T));
<span class="line-modified">!   return cmpxchg_using_helper&lt;int64_t&gt;(reorder_cmpxchg_long_func, dest, compare_value, exchange_value);</span>
  }
  
  #endif // OS_CPU_LINUX_ARM_ATOMIC_LINUX_ARM_HPP
</pre>
<center><a href="../linux_aarch64/vm_version_linux_aarch64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="orderAccess_linux_arm.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
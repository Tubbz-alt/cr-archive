<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess_linux_aarch64.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="prefetch_linux_aarch64.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
</pre>
<hr />
<pre>
<span class="line-old-header">*** 51,13 ***</span>
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/timer.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/events.hpp&quot;
  #include &quot;utilities/vmError.hpp&quot;
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">- #include &quot;../../../../../../simulator/simulator.hpp&quot;</span>
<span class="line-removed">- #endif</span>
  
  // put OS-includes here
  # include &lt;sys/types.h&gt;
  # include &lt;sys/mman.h&gt;
  # include &lt;pthread.h&gt;
<span class="line-new-header">--- 51,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,27 ***</span>
  # include &lt;pwd.h&gt;
  # include &lt;poll.h&gt;
  # include &lt;ucontext.h&gt;
  # include &lt;fpu_control.h&gt;
  
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">- #define REG_SP REG_RSP</span>
<span class="line-removed">- #define REG_PC REG_RIP</span>
<span class="line-removed">- #define REG_FP REG_RBP</span>
<span class="line-removed">- #define SPELL_REG_SP &quot;rsp&quot;</span>
<span class="line-removed">- #define SPELL_REG_FP &quot;rbp&quot;</span>
<span class="line-removed">- #else</span>
  #define REG_FP 29
  #define REG_LR 30
  
<span class="line-modified">! #define SPELL_REG_SP &quot;sp&quot;</span>
<span class="line-modified">! #define SPELL_REG_FP &quot;x29&quot;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- address os::current_stack_pointer() {</span>
<span class="line-removed">-   register void *esp __asm__ (SPELL_REG_SP);</span>
<span class="line-removed">-   return (address) esp;</span>
  }
  
  char* os::non_memory_address_word() {
    // Must never look like an address returned by reserve_memory,
    // even in its subfields (as defined by the CPU immediate fields,
<span class="line-new-header">--- 74,15 ---</span>
  # include &lt;pwd.h&gt;
  # include &lt;poll.h&gt;
  # include &lt;ucontext.h&gt;
  # include &lt;fpu_control.h&gt;
  
  #define REG_FP 29
  #define REG_LR 30
  
<span class="line-modified">! NOINLINE address os::current_stack_pointer() {</span>
<span class="line-modified">!   return (address)__builtin_frame_address(0);</span>
  }
  
  char* os::non_memory_address_word() {
    // Must never look like an address returned by reserve_memory,
    // even in its subfields (as defined by the CPU immediate fields,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,39 ***</span>
  
    return (char*) 0xffffffffffff;
  }
  
  address os::Linux::ucontext_get_pc(const ucontext_t * uc) {
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   return (address)uc-&gt;uc_mcontext.gregs[REG_PC];</span>
<span class="line-removed">- #else</span>
    return (address)uc-&gt;uc_mcontext.pc;
<span class="line-removed">- #endif</span>
  }
  
  void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   uc-&gt;uc_mcontext.gregs[REG_PC] = (intptr_t)pc;</span>
<span class="line-removed">- #else</span>
    uc-&gt;uc_mcontext.pc = (intptr_t)pc;
<span class="line-removed">- #endif</span>
  }
  
  intptr_t* os::Linux::ucontext_get_sp(const ucontext_t * uc) {
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_SP];</span>
<span class="line-removed">- #else</span>
    return (intptr_t*)uc-&gt;uc_mcontext.sp;
<span class="line-removed">- #endif</span>
  }
  
  intptr_t* os::Linux::ucontext_get_fp(const ucontext_t * uc) {
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_FP];</span>
<span class="line-removed">- #else</span>
    return (intptr_t*)uc-&gt;uc_mcontext.regs[REG_FP];
<span class="line-removed">- #endif</span>
  }
  
  // For Forte Analyzer AsyncGetCallTrace profiling support - thread
  // is currently interrupted by SIGPROF.
  // os::Solaris::fetch_frame_from_ucontext() tries to skip nested signal
<span class="line-new-header">--- 90,23 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,34 ***</span>
  }
  
  // By default, gcc always saves frame pointer rfp on this stack. This
  // may get turned off by -fomit-frame-pointer.
  frame os::get_sender_for_C_frame(frame* fr) {
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());</span>
<span class="line-removed">- #else</span>
    return frame(fr-&gt;link(), fr-&gt;link(), fr-&gt;sender_pc());
<span class="line-removed">- #endif</span>
  }
  
<span class="line-modified">! intptr_t* _get_previous_fp() {</span>
<span class="line-modified">!   register intptr_t **fp __asm__ (SPELL_REG_FP);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // fp is for this frame (_get_previous_fp). We want the fp for the</span>
<span class="line-removed">-   // caller of os::current_frame*(), so go up two frames. However, for</span>
<span class="line-removed">-   // optimized builds, _get_previous_fp() will be inlined, so only go</span>
<span class="line-removed">-   // up 1 frame in that case.</span>
<span class="line-removed">-   #ifdef _NMT_NOINLINE_</span>
<span class="line-removed">-     return **(intptr_t***)fp;</span>
<span class="line-removed">-   #else</span>
<span class="line-removed">-     return *fp;</span>
<span class="line-removed">-   #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- frame os::current_frame() {</span>
<span class="line-removed">-   intptr_t* fp = _get_previous_fp();</span>
    frame myframe((intptr_t*)os::current_stack_pointer(),
                  (intptr_t*)fp,
                  CAST_FROM_FN_PTR(address, os::current_frame));
    if (os::is_first_C_frame(&amp;myframe)) {
      // stack is not walkable
<span class="line-new-header">--- 190,15 ---</span>
  }
  
  // By default, gcc always saves frame pointer rfp on this stack. This
  // may get turned off by -fomit-frame-pointer.
  frame os::get_sender_for_C_frame(frame* fr) {
    return frame(fr-&gt;link(), fr-&gt;link(), fr-&gt;sender_pc());
  }
  
<span class="line-modified">! NOINLINE frame os::current_frame() {</span>
<span class="line-modified">!   intptr_t *fp = *(intptr_t **)__builtin_frame_address(0);</span>
    frame myframe((intptr_t*)os::current_stack_pointer(),
                  (intptr_t*)fp,
                  CAST_FROM_FN_PTR(address, os::current_frame));
    if (os::is_first_C_frame(&amp;myframe)) {
      // stack is not walkable
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,24 ***</span>
    } else {
      return os::get_sender_for_C_frame(&amp;myframe);
    }
  }
  
<span class="line-removed">- // Utility functions</span>
<span class="line-removed">- </span>
<span class="line-removed">- // From IA32 System Programming Guide</span>
<span class="line-removed">- enum {</span>
<span class="line-removed">-   trap_page_fault = 0xE</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">- extern &quot;C&quot; void Fetch32PFI () ;</span>
<span class="line-removed">- extern &quot;C&quot; void Fetch32Resume () ;</span>
<span class="line-removed">- extern &quot;C&quot; void FetchNPFI () ;</span>
<span class="line-removed">- extern &quot;C&quot; void FetchNResume () ;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  extern &quot;C&quot; JNIEXPORT int
  JVM_handle_linux_signal(int sig,
                          siginfo_t* info,
                          void* ucVoid,
                          int abort_if_unrecognized) {
<span class="line-new-header">--- 206,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,12 ***</span>
      }
    }
  
  #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
    if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
<span class="line-modified">!     handle_assert_poison_fault(ucVoid, info-&gt;si_addr);</span>
<span class="line-modified">!     return 1;</span>
    }
  #endif
  
    JavaThread* thread = NULL;
    VMThread* vmthread = NULL;
<span class="line-new-header">--- 240,13 ---</span>
      }
    }
  
  #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
    if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
<span class="line-modified">!     if (handle_assert_poison_fault(ucVoid, info-&gt;si_addr)) {</span>
<span class="line-modified">!       return 1;</span>
<span class="line-added">+     }</span>
    }
  #endif
  
    JavaThread* thread = NULL;
    VMThread* vmthread = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 339,25 ***</span>
  
    //%note os_trap_1
    if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
      pc = (address) os::Linux::ucontext_get_pc(uc);
  
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-     if (pc == (address) Fetch32PFI) {</span>
<span class="line-removed">-        uc-&gt;uc_mcontext.gregs[REG_PC] = intptr_t(Fetch32Resume) ;</span>
<span class="line-removed">-        return 1 ;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (pc == (address) FetchNPFI) {</span>
<span class="line-removed">-        uc-&gt;uc_mcontext.gregs[REG_PC] = intptr_t (FetchNResume) ;</span>
<span class="line-removed">-        return 1 ;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #else</span>
      if (StubRoutines::is_safefetch_fault(pc)) {
        os::Linux::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
        return 1;
      }
<span class="line-removed">- #endif</span>
  
      address addr = (address) info-&gt;si_addr;
  
      // Make sure the high order byte is sign extended, as it may be masked away by the hardware.
      if ((uintptr_t(addr) &amp; (uintptr_t(1) &lt;&lt; 55)) != 0) {
<span class="line-new-header">--- 276,14 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,12 ***</span>
          // BugId 4454115: A read from a MappedByteBuffer can fault
          // here if the underlying file has been truncated.
          // Do not crash the VM in such a case.
          CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
          CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
<span class="line-modified">!         if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {</span>
            address next_pc = pc + NativeCall::instruction_size;
            stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
          }
        }
        else
  
<span class="line-new-header">--- 370,16 ---</span>
          // BugId 4454115: A read from a MappedByteBuffer can fault
          // here if the underlying file has been truncated.
          // Do not crash the VM in such a case.
          CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
          CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
<span class="line-modified">!         bool is_unsafe_arraycopy = (thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc));</span>
<span class="line-added">+         if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {</span>
            address next_pc = pc + NativeCall::instruction_size;
<span class="line-added">+           if (is_unsafe_arraycopy) {</span>
<span class="line-added">+             next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">+           }</span>
            stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
          }
        }
        else
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 464,14 ***</span>
        } else if (sig == SIGSEGV &amp;&amp;
                   MacroAssembler::uses_implicit_null_check((void*)addr)) {
            // Determination of interpreter/vtable stub/compiled code null exception
            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
        }
<span class="line-modified">!     } else if (thread-&gt;thread_state() == _thread_in_vm &amp;&amp;</span>
                 sig == SIGBUS &amp;&amp; /* info-&gt;si_code == BUS_OBJERR &amp;&amp; */
                 thread-&gt;doing_unsafe_access()) {
        address next_pc = pc + NativeCall::instruction_size;
        stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
      }
  
      // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in
      // and the heap gets shrunk before the field access.
<span class="line-new-header">--- 394,18 ---</span>
        } else if (sig == SIGSEGV &amp;&amp;
                   MacroAssembler::uses_implicit_null_check((void*)addr)) {
            // Determination of interpreter/vtable stub/compiled code null exception
            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
        }
<span class="line-modified">!     } else if ((thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">+                  thread-&gt;thread_state() == _thread_in_native) &amp;&amp;</span>
                 sig == SIGBUS &amp;&amp; /* info-&gt;si_code == BUS_OBJERR &amp;&amp; */
                 thread-&gt;doing_unsafe_access()) {
        address next_pc = pc + NativeCall::instruction_size;
<span class="line-added">+       if (UnsafeCopyMemory::contains_pc(pc)) {</span>
<span class="line-added">+         next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">+       }</span>
        stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
      }
  
      // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in
      // and the heap gets shrunk before the field access.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 559,44 ***</span>
  void os::print_context(outputStream *st, const void *context) {
    if (context == NULL) return;
  
    const ucontext_t *uc = (const ucontext_t*)context;
    st-&gt;print_cr(&quot;Registers:&quot;);
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   st-&gt;print(  &quot;RAX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RAX]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, RBX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBX]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, RCX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RCX]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, RDX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDX]);</span>
<span class="line-removed">-   st-&gt;cr();</span>
<span class="line-removed">-   st-&gt;print(  &quot;RSP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSP]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, RBP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBP]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, RSI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSI]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, RDI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDI]);</span>
<span class="line-removed">-   st-&gt;cr();</span>
<span class="line-removed">-   st-&gt;print(  &quot;R8 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R8]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, R9 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R9]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, R10=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R10]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, R11=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R11]);</span>
<span class="line-removed">-   st-&gt;cr();</span>
<span class="line-removed">-   st-&gt;print(  &quot;R12=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R12]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, R13=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R13]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, R14=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R14]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, R15=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R15]);</span>
<span class="line-removed">-   st-&gt;cr();</span>
<span class="line-removed">-   st-&gt;print(  &quot;RIP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RIP]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, EFLAGS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_EFL]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, CSGSFS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_CSGSFS]);</span>
<span class="line-removed">-   st-&gt;print(&quot;, ERR=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_ERR]);</span>
<span class="line-removed">-   st-&gt;cr();</span>
<span class="line-removed">-   st-&gt;print(&quot;  TRAPNO=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_TRAPNO]);</span>
<span class="line-removed">-   st-&gt;cr();</span>
<span class="line-removed">- #else</span>
    for (int r = 0; r &lt; 31; r++) {
      st-&gt;print(&quot;R%-2d=&quot;, r);
      print_location(st, uc-&gt;uc_mcontext.regs[r]);
    }
<span class="line-removed">- #endif</span>
    st-&gt;cr();
  
    intptr_t *sp = (intptr_t *)os::Linux::ucontext_get_sp(uc);
    st-&gt;print_cr(&quot;Top of Stack: (sp=&quot; PTR_FORMAT &quot;)&quot;, p2i(sp));
    print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));
<span class="line-new-header">--- 493,14 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 622,31 ***</span>
    // context does not match how we defined our abstract Register set, so
    // we can&#39;t just iterate through the gregs area
  
    // this is only for the &quot;general purpose&quot; registers
  
<span class="line-removed">- #ifdef BUILTIN_SIM</span>
<span class="line-removed">-   st-&gt;print(&quot;RAX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RAX]);</span>
<span class="line-removed">-   st-&gt;print(&quot;RBX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RBX]);</span>
<span class="line-removed">-   st-&gt;print(&quot;RCX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RCX]);</span>
<span class="line-removed">-   st-&gt;print(&quot;RDX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RDX]);</span>
<span class="line-removed">-   st-&gt;print(&quot;RSP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RSP]);</span>
<span class="line-removed">-   st-&gt;print(&quot;RBP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RBP]);</span>
<span class="line-removed">-   st-&gt;print(&quot;RSI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RSI]);</span>
<span class="line-removed">-   st-&gt;print(&quot;RDI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RDI]);</span>
<span class="line-removed">-   st-&gt;print(&quot;R8 =&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R8]);</span>
<span class="line-removed">-   st-&gt;print(&quot;R9 =&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R9]);</span>
<span class="line-removed">-   st-&gt;print(&quot;R10=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R10]);</span>
<span class="line-removed">-   st-&gt;print(&quot;R11=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R11]);</span>
<span class="line-removed">-   st-&gt;print(&quot;R12=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R12]);</span>
<span class="line-removed">-   st-&gt;print(&quot;R13=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R13]);</span>
<span class="line-removed">-   st-&gt;print(&quot;R14=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R14]);</span>
<span class="line-removed">-   st-&gt;print(&quot;R15=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R15]);</span>
<span class="line-removed">- #else</span>
    for (int r = 0; r &lt; 31; r++)
      st-&gt;print_cr(  &quot;R%d=&quot; INTPTR_FORMAT, r, (uintptr_t)uc-&gt;uc_mcontext.regs[r]);
<span class="line-removed">- #endif</span>
    st-&gt;cr();
  }
  
  void os::setup_fpu() {
  }
<span class="line-new-header">--- 526,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 665,69 ***</span>
  extern &quot;C&quot; {
    int SpinPause() {
      return 0;
    }
  
<span class="line-modified">!   void _Copy_conjoint_jshorts_atomic(jshort* from, jshort* to, size_t count) {</span>
      if (from &gt; to) {
<span class="line-modified">!       jshort *end = from + count;</span>
        while (from &lt; end)
          *(to++) = *(from++);
      }
      else if (from &lt; to) {
<span class="line-modified">!       jshort *end = from;</span>
        from += count - 1;
        to   += count - 1;
        while (from &gt;= end)
          *(to--) = *(from--);
      }
    }
<span class="line-modified">!   void _Copy_conjoint_jints_atomic(jint* from, jint* to, size_t count) {</span>
      if (from &gt; to) {
<span class="line-modified">!       jint *end = from + count;</span>
        while (from &lt; end)
          *(to++) = *(from++);
      }
      else if (from &lt; to) {
<span class="line-modified">!       jint *end = from;</span>
        from += count - 1;
        to   += count - 1;
        while (from &gt;= end)
          *(to--) = *(from--);
      }
    }
<span class="line-modified">!   void _Copy_conjoint_jlongs_atomic(jlong* from, jlong* to, size_t count) {</span>
      if (from &gt; to) {
<span class="line-modified">!       jlong *end = from + count;</span>
        while (from &lt; end)
          os::atomic_copy64(from++, to++);
      }
      else if (from &lt; to) {
<span class="line-modified">!       jlong *end = from;</span>
        from += count - 1;
        to   += count - 1;
        while (from &gt;= end)
          os::atomic_copy64(from--, to--);
      }
    }
  
<span class="line-modified">!   void _Copy_arrayof_conjoint_bytes(HeapWord* from,</span>
                                      HeapWord* to,
                                      size_t    count) {
      memmove(to, from, count);
    }
<span class="line-modified">!   void _Copy_arrayof_conjoint_jshorts(HeapWord* from,</span>
                                        HeapWord* to,
                                        size_t    count) {
      memmove(to, from, count * 2);
    }
<span class="line-modified">!   void _Copy_arrayof_conjoint_jints(HeapWord* from,</span>
                                      HeapWord* to,
                                      size_t    count) {
      memmove(to, from, count * 4);
    }
<span class="line-modified">!   void _Copy_arrayof_conjoint_jlongs(HeapWord* from,</span>
                                       HeapWord* to,
                                       size_t    count) {
      memmove(to, from, count * 8);
    }
  };
<span class="line-new-header">--- 550,69 ---</span>
  extern &quot;C&quot; {
    int SpinPause() {
      return 0;
    }
  
<span class="line-modified">!   void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {</span>
      if (from &gt; to) {
<span class="line-modified">!       const jshort *end = from + count;</span>
        while (from &lt; end)
          *(to++) = *(from++);
      }
      else if (from &lt; to) {
<span class="line-modified">!       const jshort *end = from;</span>
        from += count - 1;
        to   += count - 1;
        while (from &gt;= end)
          *(to--) = *(from--);
      }
    }
<span class="line-modified">!   void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {</span>
      if (from &gt; to) {
<span class="line-modified">!       const jint *end = from + count;</span>
        while (from &lt; end)
          *(to++) = *(from++);
      }
      else if (from &lt; to) {
<span class="line-modified">!       const jint *end = from;</span>
        from += count - 1;
        to   += count - 1;
        while (from &gt;= end)
          *(to--) = *(from--);
      }
    }
<span class="line-modified">!   void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {</span>
      if (from &gt; to) {
<span class="line-modified">!       const jlong *end = from + count;</span>
        while (from &lt; end)
          os::atomic_copy64(from++, to++);
      }
      else if (from &lt; to) {
<span class="line-modified">!       const jlong *end = from;</span>
        from += count - 1;
        to   += count - 1;
        while (from &gt;= end)
          os::atomic_copy64(from--, to--);
      }
    }
  
<span class="line-modified">!   void _Copy_arrayof_conjoint_bytes(const HeapWord* from,</span>
                                      HeapWord* to,
                                      size_t    count) {
      memmove(to, from, count);
    }
<span class="line-modified">!   void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,</span>
                                        HeapWord* to,
                                        size_t    count) {
      memmove(to, from, count * 2);
    }
<span class="line-modified">!   void _Copy_arrayof_conjoint_jints(const HeapWord* from,</span>
                                      HeapWord* to,
                                      size_t    count) {
      memmove(to, from, count * 4);
    }
<span class="line-modified">!   void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,</span>
                                       HeapWord* to,
                                       size_t    count) {
      memmove(to, from, count * 8);
    }
  };
</pre>
<center><a href="orderAccess_linux_aarch64.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="prefetch_linux_aarch64.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 // no precompiled headers
 27 #include &quot;jvm.h&quot;
 28 #include &quot;asm/macroAssembler.hpp&quot;
 29 #include &quot;classfile/classLoader.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;classfile/vmSymbols.hpp&quot;
 32 #include &quot;code/codeCache.hpp&quot;
 33 #include &quot;code/icBuffer.hpp&quot;
 34 #include &quot;code/vtableStubs.hpp&quot;
 35 #include &quot;code/nativeInst.hpp&quot;
 36 #include &quot;interpreter/interpreter.hpp&quot;
 37 #include &quot;memory/allocation.inline.hpp&quot;
 38 #include &quot;os_share_linux.hpp&quot;
 39 #include &quot;prims/jniFastGetField.hpp&quot;
 40 #include &quot;prims/jvm_misc.hpp&quot;
 41 #include &quot;runtime/arguments.hpp&quot;
 42 #include &quot;runtime/extendedPC.hpp&quot;
 43 #include &quot;runtime/frame.inline.hpp&quot;
 44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 45 #include &quot;runtime/java.hpp&quot;
 46 #include &quot;runtime/javaCalls.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/osThread.hpp&quot;
 49 #include &quot;runtime/sharedRuntime.hpp&quot;
 50 #include &quot;runtime/stubRoutines.hpp&quot;
 51 #include &quot;runtime/thread.inline.hpp&quot;
 52 #include &quot;runtime/timer.hpp&quot;
 53 #include &quot;utilities/debug.hpp&quot;
 54 #include &quot;utilities/events.hpp&quot;
 55 #include &quot;utilities/vmError.hpp&quot;
 56 #ifdef BUILTIN_SIM
 57 #include &quot;../../../../../../simulator/simulator.hpp&quot;
 58 #endif
 59 
 60 // put OS-includes here
 61 # include &lt;sys/types.h&gt;
 62 # include &lt;sys/mman.h&gt;
 63 # include &lt;pthread.h&gt;
 64 # include &lt;signal.h&gt;
 65 # include &lt;errno.h&gt;
 66 # include &lt;dlfcn.h&gt;
 67 # include &lt;stdlib.h&gt;
 68 # include &lt;stdio.h&gt;
 69 # include &lt;unistd.h&gt;
 70 # include &lt;sys/resource.h&gt;
 71 # include &lt;pthread.h&gt;
 72 # include &lt;sys/stat.h&gt;
 73 # include &lt;sys/time.h&gt;
 74 # include &lt;sys/utsname.h&gt;
 75 # include &lt;sys/socket.h&gt;
 76 # include &lt;sys/wait.h&gt;
 77 # include &lt;pwd.h&gt;
 78 # include &lt;poll.h&gt;
 79 # include &lt;ucontext.h&gt;
 80 # include &lt;fpu_control.h&gt;
 81 
 82 #ifdef BUILTIN_SIM
 83 #define REG_SP REG_RSP
 84 #define REG_PC REG_RIP
 85 #define REG_FP REG_RBP
 86 #define SPELL_REG_SP &quot;rsp&quot;
 87 #define SPELL_REG_FP &quot;rbp&quot;
 88 #else
 89 #define REG_FP 29
 90 #define REG_LR 30
 91 
 92 #define SPELL_REG_SP &quot;sp&quot;
 93 #define SPELL_REG_FP &quot;x29&quot;
 94 #endif
 95 
 96 address os::current_stack_pointer() {
 97   register void *esp __asm__ (SPELL_REG_SP);
 98   return (address) esp;
 99 }
100 
101 char* os::non_memory_address_word() {
102   // Must never look like an address returned by reserve_memory,
103   // even in its subfields (as defined by the CPU immediate fields,
104   // if the CPU splits constants across multiple instructions).
105 
106   return (char*) 0xffffffffffff;
107 }
108 
109 address os::Linux::ucontext_get_pc(const ucontext_t * uc) {
110 #ifdef BUILTIN_SIM
111   return (address)uc-&gt;uc_mcontext.gregs[REG_PC];
112 #else
113   return (address)uc-&gt;uc_mcontext.pc;
114 #endif
115 }
116 
117 void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {
118 #ifdef BUILTIN_SIM
119   uc-&gt;uc_mcontext.gregs[REG_PC] = (intptr_t)pc;
120 #else
121   uc-&gt;uc_mcontext.pc = (intptr_t)pc;
122 #endif
123 }
124 
125 intptr_t* os::Linux::ucontext_get_sp(const ucontext_t * uc) {
126 #ifdef BUILTIN_SIM
127   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_SP];
128 #else
129   return (intptr_t*)uc-&gt;uc_mcontext.sp;
130 #endif
131 }
132 
133 intptr_t* os::Linux::ucontext_get_fp(const ucontext_t * uc) {
134 #ifdef BUILTIN_SIM
135   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_FP];
136 #else
137   return (intptr_t*)uc-&gt;uc_mcontext.regs[REG_FP];
138 #endif
139 }
140 
141 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
142 // is currently interrupted by SIGPROF.
143 // os::Solaris::fetch_frame_from_ucontext() tries to skip nested signal
144 // frames. Currently we don&#39;t do that on Linux, so it&#39;s the same as
145 // os::fetch_frame_from_context().
146 ExtendedPC os::Linux::fetch_frame_from_ucontext(Thread* thread,
147   const ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {
148 
149   assert(thread != NULL, &quot;just checking&quot;);
150   assert(ret_sp != NULL, &quot;just checking&quot;);
151   assert(ret_fp != NULL, &quot;just checking&quot;);
152 
153   return os::fetch_frame_from_context(uc, ret_sp, ret_fp);
154 }
155 
156 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
157                     intptr_t** ret_sp, intptr_t** ret_fp) {
158 
159   ExtendedPC  epc;
160   const ucontext_t* uc = (const ucontext_t*)ucVoid;
161 
162   if (uc != NULL) {
163     epc = ExtendedPC(os::Linux::ucontext_get_pc(uc));
164     if (ret_sp) *ret_sp = os::Linux::ucontext_get_sp(uc);
165     if (ret_fp) *ret_fp = os::Linux::ucontext_get_fp(uc);
166   } else {
167     // construct empty ExtendedPC for return value checking
168     epc = ExtendedPC(NULL);
169     if (ret_sp) *ret_sp = (intptr_t *)NULL;
170     if (ret_fp) *ret_fp = (intptr_t *)NULL;
171   }
172 
173   return epc;
174 }
175 
176 frame os::fetch_frame_from_context(const void* ucVoid) {
177   intptr_t* sp;
178   intptr_t* fp;
179   ExtendedPC epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);
180   return frame(sp, fp, epc.pc());
181 }
182 
183 bool os::Linux::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
184   address pc = (address) os::Linux::ucontext_get_pc(uc);
185   if (Interpreter::contains(pc)) {
186     // interpreter performs stack banging after the fixed frame header has
187     // been generated while the compilers perform it before. To maintain
188     // semantic consistency between interpreted and compiled frames, the
189     // method returns the Java sender of the current frame.
190     *fr = os::fetch_frame_from_context(uc);
191     if (!fr-&gt;is_first_java_frame()) {
192       assert(fr-&gt;safe_for_sender(thread), &quot;Safety check&quot;);
193       *fr = fr-&gt;java_sender();
194     }
195   } else {
196     // more complex code with compiled code
197     assert(!Interpreter::contains(pc), &quot;Interpreted methods should have been handled above&quot;);
198     CodeBlob* cb = CodeCache::find_blob(pc);
199     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {
200       // Not sure where the pc points to, fallback to default
201       // stack overflow handling
202       return false;
203     } else {
204       // In compiled code, the stack banging is performed before LR
205       // has been saved in the frame.  LR is live, and SP and FP
206       // belong to the caller.
207       intptr_t* fp = os::Linux::ucontext_get_fp(uc);
208       intptr_t* sp = os::Linux::ucontext_get_sp(uc);
209       address pc = (address)(uc-&gt;uc_mcontext.regs[REG_LR]
210                          - NativeInstruction::instruction_size);
211       *fr = frame(sp, fp, pc);
212       if (!fr-&gt;is_java_frame()) {
213         assert(fr-&gt;safe_for_sender(thread), &quot;Safety check&quot;);
214         assert(!fr-&gt;is_first_frame(), &quot;Safety check&quot;);
215         *fr = fr-&gt;java_sender();
216       }
217     }
218   }
219   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
220   return true;
221 }
222 
223 // By default, gcc always saves frame pointer rfp on this stack. This
224 // may get turned off by -fomit-frame-pointer.
225 frame os::get_sender_for_C_frame(frame* fr) {
226 #ifdef BUILTIN_SIM
227   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());
228 #else
229   return frame(fr-&gt;link(), fr-&gt;link(), fr-&gt;sender_pc());
230 #endif
231 }
232 
233 intptr_t* _get_previous_fp() {
234   register intptr_t **fp __asm__ (SPELL_REG_FP);
235 
236   // fp is for this frame (_get_previous_fp). We want the fp for the
237   // caller of os::current_frame*(), so go up two frames. However, for
238   // optimized builds, _get_previous_fp() will be inlined, so only go
239   // up 1 frame in that case.
240   #ifdef _NMT_NOINLINE_
241     return **(intptr_t***)fp;
242   #else
243     return *fp;
244   #endif
245 }
246 
247 
248 frame os::current_frame() {
249   intptr_t* fp = _get_previous_fp();
250   frame myframe((intptr_t*)os::current_stack_pointer(),
251                 (intptr_t*)fp,
252                 CAST_FROM_FN_PTR(address, os::current_frame));
253   if (os::is_first_C_frame(&amp;myframe)) {
254     // stack is not walkable
255     return frame();
256   } else {
257     return os::get_sender_for_C_frame(&amp;myframe);
258   }
259 }
260 
261 // Utility functions
262 
263 // From IA32 System Programming Guide
264 enum {
265   trap_page_fault = 0xE
266 };
267 
268 #ifdef BUILTIN_SIM
269 extern &quot;C&quot; void Fetch32PFI () ;
270 extern &quot;C&quot; void Fetch32Resume () ;
271 extern &quot;C&quot; void FetchNPFI () ;
272 extern &quot;C&quot; void FetchNResume () ;
273 #endif
274 
275 extern &quot;C&quot; JNIEXPORT int
276 JVM_handle_linux_signal(int sig,
277                         siginfo_t* info,
278                         void* ucVoid,
279                         int abort_if_unrecognized) {
280   ucontext_t* uc = (ucontext_t*) ucVoid;
281 
282   Thread* t = Thread::current_or_null_safe();
283 
284   // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away
285   // (no destructors can be run)
286   os::ThreadCrashProtection::check_crash_protection(sig, t);
287 
288   SignalHandlerMark shm(t);
289 
290   // Note: it&#39;s not uncommon that JNI code uses signal/sigset to install
291   // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
292   // or have a SIGILL handler when detecting CPU type). When that happens,
293   // JVM_handle_linux_signal() might be invoked with junk info/ucVoid. To
294   // avoid unnecessary crash when libjsig is not preloaded, try handle signals
295   // that do not require siginfo/ucontext first.
296 
297   if (sig == SIGPIPE || sig == SIGXFSZ) {
298     // allow chained handler to go first
299     if (os::Linux::chained_handler(sig, info, ucVoid)) {
300       return true;
301     } else {
302       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
303       return true;
304     }
305   }
306 
307 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
308   if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
309     handle_assert_poison_fault(ucVoid, info-&gt;si_addr);
310     return 1;
311   }
312 #endif
313 
314   JavaThread* thread = NULL;
315   VMThread* vmthread = NULL;
316   if (os::Linux::signal_handlers_are_installed) {
317     if (t != NULL ){
318       if(t-&gt;is_Java_thread()) {
319         thread = (JavaThread*)t;
320       }
321       else if(t-&gt;is_VM_thread()){
322         vmthread = (VMThread *)t;
323       }
324     }
325   }
326 /*
327   NOTE: does not seem to work on linux.
328   if (info == NULL || info-&gt;si_code &lt;= 0 || info-&gt;si_code == SI_NOINFO) {
329     // can&#39;t decode this kind of signal
330     info = NULL;
331   } else {
332     assert(sig == info-&gt;si_signo, &quot;bad siginfo&quot;);
333   }
334 */
335   // decide if this trap can be handled by a stub
336   address stub = NULL;
337 
338   address pc          = NULL;
339 
340   //%note os_trap_1
341   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
342     pc = (address) os::Linux::ucontext_get_pc(uc);
343 
344 #ifdef BUILTIN_SIM
345     if (pc == (address) Fetch32PFI) {
346        uc-&gt;uc_mcontext.gregs[REG_PC] = intptr_t(Fetch32Resume) ;
347        return 1 ;
348     }
349     if (pc == (address) FetchNPFI) {
350        uc-&gt;uc_mcontext.gregs[REG_PC] = intptr_t (FetchNResume) ;
351        return 1 ;
352     }
353 #else
354     if (StubRoutines::is_safefetch_fault(pc)) {
355       os::Linux::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
356       return 1;
357     }
358 #endif
359 
360     address addr = (address) info-&gt;si_addr;
361 
362     // Make sure the high order byte is sign extended, as it may be masked away by the hardware.
363     if ((uintptr_t(addr) &amp; (uintptr_t(1) &lt;&lt; 55)) != 0) {
364       addr = address(uintptr_t(addr) | (uintptr_t(0xFF) &lt;&lt; 56));
365     }
366 
367     // Handle ALL stack overflow variations here
368     if (sig == SIGSEGV) {
369       // check if fault address is within thread stack
370       if (thread-&gt;on_local_stack(addr)) {
371         // stack overflow
372         if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
373           if (thread-&gt;thread_state() == _thread_in_Java) {
374             if (thread-&gt;in_stack_reserved_zone(addr)) {
375               frame fr;
376               if (os::Linux::get_frame_at_stack_banging_point(thread, uc, &amp;fr)) {
377                 assert(fr.is_java_frame(), &quot;Must be a Java frame&quot;);
378                 frame activation =
379                   SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
380                 if (activation.sp() != NULL) {
381                   thread-&gt;disable_stack_reserved_zone();
382                   if (activation.is_interpreted_frame()) {
383                     thread-&gt;set_reserved_stack_activation((address)(
384                       activation.fp() + frame::interpreter_frame_initial_sp_offset));
385                   } else {
386                     thread-&gt;set_reserved_stack_activation((address)activation.unextended_sp());
387                   }
388                   return 1;
389                 }
390               }
391             }
392             // Throw a stack overflow exception.  Guard pages will be reenabled
393             // while unwinding the stack.
394             thread-&gt;disable_stack_yellow_reserved_zone();
395             stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
396           } else {
397             // Thread was in the vm or native code.  Return and try to finish.
398             thread-&gt;disable_stack_yellow_reserved_zone();
399             return 1;
400           }
401         } else if (thread-&gt;in_stack_red_zone(addr)) {
402           // Fatal red zone violation.  Disable the guard pages and fall through
403           // to handle_unexpected_exception way down below.
404           thread-&gt;disable_stack_red_zone();
405           tty-&gt;print_raw_cr(&quot;An irrecoverable stack overflow has occurred.&quot;);
406 
407           // This is a likely cause, but hard to verify. Let&#39;s just print
408           // it as a hint.
409           tty-&gt;print_raw_cr(&quot;Please check if any of your loaded .so files has &quot;
410                             &quot;enabled executable stack (see man page execstack(8))&quot;);
411         } else {
412           // Accessing stack address below sp may cause SEGV if current
413           // thread has MAP_GROWSDOWN stack. This should only happen when
414           // current thread was created by user code with MAP_GROWSDOWN flag
415           // and then attached to VM. See notes in os_linux.cpp.
416           if (thread-&gt;osthread()-&gt;expanding_stack() == 0) {
417              thread-&gt;osthread()-&gt;set_expanding_stack();
418              if (os::Linux::manually_expand_stack(thread, addr)) {
419                thread-&gt;osthread()-&gt;clear_expanding_stack();
420                return 1;
421              }
422              thread-&gt;osthread()-&gt;clear_expanding_stack();
423           } else {
424              fatal(&quot;recursive segv. expanding stack.&quot;);
425           }
426         }
427       }
428     }
429 
430     if (thread-&gt;thread_state() == _thread_in_Java) {
431       // Java thread running in Java code =&gt; find exception handler if any
432       // a fault inside compiled code, the interpreter, or a stub
433 
434       // Handle signal from NativeJump::patch_verified_entry().
435       if ((sig == SIGILL || sig == SIGTRAP)
436           &amp;&amp; nativeInstruction_at(pc)-&gt;is_sigill_zombie_not_entrant()) {
437         if (TraceTraps) {
438           tty-&gt;print_cr(&quot;trap: zombie_not_entrant (%s)&quot;, (sig == SIGTRAP) ? &quot;SIGTRAP&quot; : &quot;SIGILL&quot;);
439         }
440         stub = SharedRuntime::get_handle_wrong_method_stub();
441       } else if (sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {
442         stub = SharedRuntime::get_poll_stub(pc);
443       } else if (sig == SIGBUS /* &amp;&amp; info-&gt;si_code == BUS_OBJERR */) {
444         // BugId 4454115: A read from a MappedByteBuffer can fault
445         // here if the underlying file has been truncated.
446         // Do not crash the VM in such a case.
447         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
448         CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
449         if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {
450           address next_pc = pc + NativeCall::instruction_size;
451           stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
452         }
453       }
454       else
455 
456       if (sig == SIGFPE  &amp;&amp;
457           (info-&gt;si_code == FPE_INTDIV || info-&gt;si_code == FPE_FLTDIV)) {
458         stub =
459           SharedRuntime::
460           continuation_for_implicit_exception(thread,
461                                               pc,
462                                               SharedRuntime::
463                                               IMPLICIT_DIVIDE_BY_ZERO);
464       } else if (sig == SIGSEGV &amp;&amp;
465                  MacroAssembler::uses_implicit_null_check((void*)addr)) {
466           // Determination of interpreter/vtable stub/compiled code null exception
467           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
468       }
469     } else if (thread-&gt;thread_state() == _thread_in_vm &amp;&amp;
470                sig == SIGBUS &amp;&amp; /* info-&gt;si_code == BUS_OBJERR &amp;&amp; */
471                thread-&gt;doing_unsafe_access()) {
472       address next_pc = pc + NativeCall::instruction_size;
473       stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
474     }
475 
476     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in
477     // and the heap gets shrunk before the field access.
478     if ((sig == SIGSEGV) || (sig == SIGBUS)) {
479       address addr = JNI_FastGetField::find_slowcase_pc(pc);
480       if (addr != (address)-1) {
481         stub = addr;
482       }
483     }
484   }
485 
486   if (stub != NULL) {
487     // save all thread context in case we need to restore it
488     if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);
489 
490     os::Linux::ucontext_set_pc(uc, stub);
491     return true;
492   }
493 
494   // signal-chaining
495   if (os::Linux::chained_handler(sig, info, ucVoid)) {
496      return true;
497   }
498 
499   if (!abort_if_unrecognized) {
500     // caller wants another chance, so give it to him
501     return false;
502   }
503 
504   if (pc == NULL &amp;&amp; uc != NULL) {
505     pc = os::Linux::ucontext_get_pc(uc);
506   }
507 
508   // unmask current signal
509   sigset_t newset;
510   sigemptyset(&amp;newset);
511   sigaddset(&amp;newset, sig);
512   sigprocmask(SIG_UNBLOCK, &amp;newset, NULL);
513 
514   VMError::report_and_die(t, sig, pc, info, ucVoid);
515 
516   ShouldNotReachHere();
517   return true; // Mute compiler
518 }
519 
520 void os::Linux::init_thread_fpu_state(void) {
521 }
522 
523 int os::Linux::get_fpu_control_word(void) {
524   return 0;
525 }
526 
527 void os::Linux::set_fpu_control_word(int fpu_control) {
528 }
529 
530 // Check that the linux kernel version is 2.4 or higher since earlier
531 // versions do not support SSE without patches.
532 bool os::supports_sse() {
533   return true;
534 }
535 
536 bool os::is_allocatable(size_t bytes) {
537   return true;
538 }
539 
540 ////////////////////////////////////////////////////////////////////////////////
541 // thread stack
542 
543 // Minimum usable stack sizes required to get to user code. Space for
544 // HotSpot guard pages is added later.
545 size_t os::Posix::_compiler_thread_min_stack_allowed = 72 * K;
546 size_t os::Posix::_java_thread_min_stack_allowed = 72 * K;
547 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 72 * K;
548 
549 // return default stack size for thr_type
550 size_t os::Posix::default_stack_size(os::ThreadType thr_type) {
551   // default stack size (compiler thread needs larger stack)
552   size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);
553   return s;
554 }
555 
556 /////////////////////////////////////////////////////////////////////////////
557 // helper functions for fatal error handler
558 
559 void os::print_context(outputStream *st, const void *context) {
560   if (context == NULL) return;
561 
562   const ucontext_t *uc = (const ucontext_t*)context;
563   st-&gt;print_cr(&quot;Registers:&quot;);
564 #ifdef BUILTIN_SIM
565   st-&gt;print(  &quot;RAX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RAX]);
566   st-&gt;print(&quot;, RBX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBX]);
567   st-&gt;print(&quot;, RCX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RCX]);
568   st-&gt;print(&quot;, RDX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDX]);
569   st-&gt;cr();
570   st-&gt;print(  &quot;RSP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSP]);
571   st-&gt;print(&quot;, RBP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBP]);
572   st-&gt;print(&quot;, RSI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSI]);
573   st-&gt;print(&quot;, RDI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDI]);
574   st-&gt;cr();
575   st-&gt;print(  &quot;R8 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R8]);
576   st-&gt;print(&quot;, R9 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R9]);
577   st-&gt;print(&quot;, R10=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R10]);
578   st-&gt;print(&quot;, R11=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R11]);
579   st-&gt;cr();
580   st-&gt;print(  &quot;R12=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R12]);
581   st-&gt;print(&quot;, R13=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R13]);
582   st-&gt;print(&quot;, R14=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R14]);
583   st-&gt;print(&quot;, R15=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R15]);
584   st-&gt;cr();
585   st-&gt;print(  &quot;RIP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RIP]);
586   st-&gt;print(&quot;, EFLAGS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_EFL]);
587   st-&gt;print(&quot;, CSGSFS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_CSGSFS]);
588   st-&gt;print(&quot;, ERR=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_ERR]);
589   st-&gt;cr();
590   st-&gt;print(&quot;  TRAPNO=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_TRAPNO]);
591   st-&gt;cr();
592 #else
593   for (int r = 0; r &lt; 31; r++) {
594     st-&gt;print(&quot;R%-2d=&quot;, r);
595     print_location(st, uc-&gt;uc_mcontext.regs[r]);
596   }
597 #endif
598   st-&gt;cr();
599 
600   intptr_t *sp = (intptr_t *)os::Linux::ucontext_get_sp(uc);
601   st-&gt;print_cr(&quot;Top of Stack: (sp=&quot; PTR_FORMAT &quot;)&quot;, p2i(sp));
602   print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));
603   st-&gt;cr();
604 
605   // Note: it may be unsafe to inspect memory near pc. For example, pc may
606   // point to garbage if entry point in an nmethod is corrupted. Leave
607   // this at the end, and hope for the best.
608   address pc = os::Linux::ucontext_get_pc(uc);
609   print_instructions(st, pc, sizeof(char));
610   st-&gt;cr();
611 }
612 
613 void os::print_register_info(outputStream *st, const void *context) {
614   if (context == NULL) return;
615 
616   const ucontext_t *uc = (const ucontext_t*)context;
617 
618   st-&gt;print_cr(&quot;Register to memory mapping:&quot;);
619   st-&gt;cr();
620 
621   // this is horrendously verbose but the layout of the registers in the
622   // context does not match how we defined our abstract Register set, so
623   // we can&#39;t just iterate through the gregs area
624 
625   // this is only for the &quot;general purpose&quot; registers
626 
627 #ifdef BUILTIN_SIM
628   st-&gt;print(&quot;RAX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RAX]);
629   st-&gt;print(&quot;RBX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RBX]);
630   st-&gt;print(&quot;RCX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RCX]);
631   st-&gt;print(&quot;RDX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RDX]);
632   st-&gt;print(&quot;RSP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RSP]);
633   st-&gt;print(&quot;RBP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RBP]);
634   st-&gt;print(&quot;RSI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RSI]);
635   st-&gt;print(&quot;RDI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RDI]);
636   st-&gt;print(&quot;R8 =&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R8]);
637   st-&gt;print(&quot;R9 =&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R9]);
638   st-&gt;print(&quot;R10=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R10]);
639   st-&gt;print(&quot;R11=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R11]);
640   st-&gt;print(&quot;R12=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R12]);
641   st-&gt;print(&quot;R13=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R13]);
642   st-&gt;print(&quot;R14=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R14]);
643   st-&gt;print(&quot;R15=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R15]);
644 #else
645   for (int r = 0; r &lt; 31; r++)
646     st-&gt;print_cr(  &quot;R%d=&quot; INTPTR_FORMAT, r, (uintptr_t)uc-&gt;uc_mcontext.regs[r]);
647 #endif
648   st-&gt;cr();
649 }
650 
651 void os::setup_fpu() {
652 }
653 
654 #ifndef PRODUCT
655 void os::verify_stack_alignment() {
656   assert(((intptr_t)os::current_stack_pointer() &amp; (StackAlignmentInBytes-1)) == 0, &quot;incorrect stack alignment&quot;);
657 }
658 #endif
659 
660 int os::extra_bang_size_in_bytes() {
661   // AArch64 does not require the additional stack bang.
662   return 0;
663 }
664 
665 extern &quot;C&quot; {
666   int SpinPause() {
667     return 0;
668   }
669 
670   void _Copy_conjoint_jshorts_atomic(jshort* from, jshort* to, size_t count) {
671     if (from &gt; to) {
672       jshort *end = from + count;
673       while (from &lt; end)
674         *(to++) = *(from++);
675     }
676     else if (from &lt; to) {
677       jshort *end = from;
678       from += count - 1;
679       to   += count - 1;
680       while (from &gt;= end)
681         *(to--) = *(from--);
682     }
683   }
684   void _Copy_conjoint_jints_atomic(jint* from, jint* to, size_t count) {
685     if (from &gt; to) {
686       jint *end = from + count;
687       while (from &lt; end)
688         *(to++) = *(from++);
689     }
690     else if (from &lt; to) {
691       jint *end = from;
692       from += count - 1;
693       to   += count - 1;
694       while (from &gt;= end)
695         *(to--) = *(from--);
696     }
697   }
698   void _Copy_conjoint_jlongs_atomic(jlong* from, jlong* to, size_t count) {
699     if (from &gt; to) {
700       jlong *end = from + count;
701       while (from &lt; end)
702         os::atomic_copy64(from++, to++);
703     }
704     else if (from &lt; to) {
705       jlong *end = from;
706       from += count - 1;
707       to   += count - 1;
708       while (from &gt;= end)
709         os::atomic_copy64(from--, to--);
710     }
711   }
712 
713   void _Copy_arrayof_conjoint_bytes(HeapWord* from,
714                                     HeapWord* to,
715                                     size_t    count) {
716     memmove(to, from, count);
717   }
718   void _Copy_arrayof_conjoint_jshorts(HeapWord* from,
719                                       HeapWord* to,
720                                       size_t    count) {
721     memmove(to, from, count * 2);
722   }
723   void _Copy_arrayof_conjoint_jints(HeapWord* from,
724                                     HeapWord* to,
725                                     size_t    count) {
726     memmove(to, from, count * 4);
727   }
728   void _Copy_arrayof_conjoint_jlongs(HeapWord* from,
729                                      HeapWord* to,
730                                      size_t    count) {
731     memmove(to, from, count * 8);
732   }
733 };
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess_linux_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="prefetch_linux_aarch64.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
 36 #include &quot;interpreter/interpreter.hpp&quot;
 37 #include &quot;memory/allocation.inline.hpp&quot;
 38 #include &quot;os_share_linux.hpp&quot;
 39 #include &quot;prims/jniFastGetField.hpp&quot;
 40 #include &quot;prims/jvm_misc.hpp&quot;
 41 #include &quot;runtime/arguments.hpp&quot;
 42 #include &quot;runtime/extendedPC.hpp&quot;
 43 #include &quot;runtime/frame.inline.hpp&quot;
 44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 45 #include &quot;runtime/java.hpp&quot;
 46 #include &quot;runtime/javaCalls.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/osThread.hpp&quot;
 49 #include &quot;runtime/sharedRuntime.hpp&quot;
 50 #include &quot;runtime/stubRoutines.hpp&quot;
 51 #include &quot;runtime/thread.inline.hpp&quot;
 52 #include &quot;runtime/timer.hpp&quot;
 53 #include &quot;utilities/debug.hpp&quot;
 54 #include &quot;utilities/events.hpp&quot;
 55 #include &quot;utilities/vmError.hpp&quot;
<span class="line-removed"> 56 #ifdef BUILTIN_SIM</span>
<span class="line-removed"> 57 #include &quot;../../../../../../simulator/simulator.hpp&quot;</span>
<span class="line-removed"> 58 #endif</span>
 59 
 60 // put OS-includes here
 61 # include &lt;sys/types.h&gt;
 62 # include &lt;sys/mman.h&gt;
 63 # include &lt;pthread.h&gt;
 64 # include &lt;signal.h&gt;
 65 # include &lt;errno.h&gt;
 66 # include &lt;dlfcn.h&gt;
 67 # include &lt;stdlib.h&gt;
 68 # include &lt;stdio.h&gt;
 69 # include &lt;unistd.h&gt;
 70 # include &lt;sys/resource.h&gt;
 71 # include &lt;pthread.h&gt;
 72 # include &lt;sys/stat.h&gt;
 73 # include &lt;sys/time.h&gt;
 74 # include &lt;sys/utsname.h&gt;
 75 # include &lt;sys/socket.h&gt;
 76 # include &lt;sys/wait.h&gt;
 77 # include &lt;pwd.h&gt;
 78 # include &lt;poll.h&gt;
 79 # include &lt;ucontext.h&gt;
 80 # include &lt;fpu_control.h&gt;
 81 
<span class="line-removed"> 82 #ifdef BUILTIN_SIM</span>
<span class="line-removed"> 83 #define REG_SP REG_RSP</span>
<span class="line-removed"> 84 #define REG_PC REG_RIP</span>
<span class="line-removed"> 85 #define REG_FP REG_RBP</span>
<span class="line-removed"> 86 #define SPELL_REG_SP &quot;rsp&quot;</span>
<span class="line-removed"> 87 #define SPELL_REG_FP &quot;rbp&quot;</span>
<span class="line-removed"> 88 #else</span>
 89 #define REG_FP 29
 90 #define REG_LR 30
 91 
<span class="line-modified"> 92 #define SPELL_REG_SP &quot;sp&quot;</span>
<span class="line-modified"> 93 #define SPELL_REG_FP &quot;x29&quot;</span>
<span class="line-removed"> 94 #endif</span>
<span class="line-removed"> 95 </span>
<span class="line-removed"> 96 address os::current_stack_pointer() {</span>
<span class="line-removed"> 97   register void *esp __asm__ (SPELL_REG_SP);</span>
<span class="line-removed"> 98   return (address) esp;</span>
 99 }
100 
101 char* os::non_memory_address_word() {
102   // Must never look like an address returned by reserve_memory,
103   // even in its subfields (as defined by the CPU immediate fields,
104   // if the CPU splits constants across multiple instructions).
105 
106   return (char*) 0xffffffffffff;
107 }
108 
109 address os::Linux::ucontext_get_pc(const ucontext_t * uc) {
<span class="line-removed">110 #ifdef BUILTIN_SIM</span>
<span class="line-removed">111   return (address)uc-&gt;uc_mcontext.gregs[REG_PC];</span>
<span class="line-removed">112 #else</span>
113   return (address)uc-&gt;uc_mcontext.pc;
<span class="line-removed">114 #endif</span>
115 }
116 
117 void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {
<span class="line-removed">118 #ifdef BUILTIN_SIM</span>
<span class="line-removed">119   uc-&gt;uc_mcontext.gregs[REG_PC] = (intptr_t)pc;</span>
<span class="line-removed">120 #else</span>
121   uc-&gt;uc_mcontext.pc = (intptr_t)pc;
<span class="line-removed">122 #endif</span>
123 }
124 
125 intptr_t* os::Linux::ucontext_get_sp(const ucontext_t * uc) {
<span class="line-removed">126 #ifdef BUILTIN_SIM</span>
<span class="line-removed">127   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_SP];</span>
<span class="line-removed">128 #else</span>
129   return (intptr_t*)uc-&gt;uc_mcontext.sp;
<span class="line-removed">130 #endif</span>
131 }
132 
133 intptr_t* os::Linux::ucontext_get_fp(const ucontext_t * uc) {
<span class="line-removed">134 #ifdef BUILTIN_SIM</span>
<span class="line-removed">135   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_FP];</span>
<span class="line-removed">136 #else</span>
137   return (intptr_t*)uc-&gt;uc_mcontext.regs[REG_FP];
<span class="line-removed">138 #endif</span>
139 }
140 
141 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
142 // is currently interrupted by SIGPROF.
143 // os::Solaris::fetch_frame_from_ucontext() tries to skip nested signal
144 // frames. Currently we don&#39;t do that on Linux, so it&#39;s the same as
145 // os::fetch_frame_from_context().
146 ExtendedPC os::Linux::fetch_frame_from_ucontext(Thread* thread,
147   const ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {
148 
149   assert(thread != NULL, &quot;just checking&quot;);
150   assert(ret_sp != NULL, &quot;just checking&quot;);
151   assert(ret_fp != NULL, &quot;just checking&quot;);
152 
153   return os::fetch_frame_from_context(uc, ret_sp, ret_fp);
154 }
155 
156 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
157                     intptr_t** ret_sp, intptr_t** ret_fp) {
158 
</pre>
<hr />
<pre>
206       // belong to the caller.
207       intptr_t* fp = os::Linux::ucontext_get_fp(uc);
208       intptr_t* sp = os::Linux::ucontext_get_sp(uc);
209       address pc = (address)(uc-&gt;uc_mcontext.regs[REG_LR]
210                          - NativeInstruction::instruction_size);
211       *fr = frame(sp, fp, pc);
212       if (!fr-&gt;is_java_frame()) {
213         assert(fr-&gt;safe_for_sender(thread), &quot;Safety check&quot;);
214         assert(!fr-&gt;is_first_frame(), &quot;Safety check&quot;);
215         *fr = fr-&gt;java_sender();
216       }
217     }
218   }
219   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
220   return true;
221 }
222 
223 // By default, gcc always saves frame pointer rfp on this stack. This
224 // may get turned off by -fomit-frame-pointer.
225 frame os::get_sender_for_C_frame(frame* fr) {
<span class="line-removed">226 #ifdef BUILTIN_SIM</span>
<span class="line-removed">227   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());</span>
<span class="line-removed">228 #else</span>
229   return frame(fr-&gt;link(), fr-&gt;link(), fr-&gt;sender_pc());
<span class="line-removed">230 #endif</span>
231 }
232 
<span class="line-modified">233 intptr_t* _get_previous_fp() {</span>
<span class="line-modified">234   register intptr_t **fp __asm__ (SPELL_REG_FP);</span>
<span class="line-removed">235 </span>
<span class="line-removed">236   // fp is for this frame (_get_previous_fp). We want the fp for the</span>
<span class="line-removed">237   // caller of os::current_frame*(), so go up two frames. However, for</span>
<span class="line-removed">238   // optimized builds, _get_previous_fp() will be inlined, so only go</span>
<span class="line-removed">239   // up 1 frame in that case.</span>
<span class="line-removed">240   #ifdef _NMT_NOINLINE_</span>
<span class="line-removed">241     return **(intptr_t***)fp;</span>
<span class="line-removed">242   #else</span>
<span class="line-removed">243     return *fp;</span>
<span class="line-removed">244   #endif</span>
<span class="line-removed">245 }</span>
<span class="line-removed">246 </span>
<span class="line-removed">247 </span>
<span class="line-removed">248 frame os::current_frame() {</span>
<span class="line-removed">249   intptr_t* fp = _get_previous_fp();</span>
250   frame myframe((intptr_t*)os::current_stack_pointer(),
251                 (intptr_t*)fp,
252                 CAST_FROM_FN_PTR(address, os::current_frame));
253   if (os::is_first_C_frame(&amp;myframe)) {
254     // stack is not walkable
255     return frame();
256   } else {
257     return os::get_sender_for_C_frame(&amp;myframe);
258   }
259 }
260 
<span class="line-removed">261 // Utility functions</span>
<span class="line-removed">262 </span>
<span class="line-removed">263 // From IA32 System Programming Guide</span>
<span class="line-removed">264 enum {</span>
<span class="line-removed">265   trap_page_fault = 0xE</span>
<span class="line-removed">266 };</span>
<span class="line-removed">267 </span>
<span class="line-removed">268 #ifdef BUILTIN_SIM</span>
<span class="line-removed">269 extern &quot;C&quot; void Fetch32PFI () ;</span>
<span class="line-removed">270 extern &quot;C&quot; void Fetch32Resume () ;</span>
<span class="line-removed">271 extern &quot;C&quot; void FetchNPFI () ;</span>
<span class="line-removed">272 extern &quot;C&quot; void FetchNResume () ;</span>
<span class="line-removed">273 #endif</span>
<span class="line-removed">274 </span>
275 extern &quot;C&quot; JNIEXPORT int
276 JVM_handle_linux_signal(int sig,
277                         siginfo_t* info,
278                         void* ucVoid,
279                         int abort_if_unrecognized) {
280   ucontext_t* uc = (ucontext_t*) ucVoid;
281 
282   Thread* t = Thread::current_or_null_safe();
283 
284   // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away
285   // (no destructors can be run)
286   os::ThreadCrashProtection::check_crash_protection(sig, t);
287 
288   SignalHandlerMark shm(t);
289 
290   // Note: it&#39;s not uncommon that JNI code uses signal/sigset to install
291   // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
292   // or have a SIGILL handler when detecting CPU type). When that happens,
293   // JVM_handle_linux_signal() might be invoked with junk info/ucVoid. To
294   // avoid unnecessary crash when libjsig is not preloaded, try handle signals
295   // that do not require siginfo/ucontext first.
296 
297   if (sig == SIGPIPE || sig == SIGXFSZ) {
298     // allow chained handler to go first
299     if (os::Linux::chained_handler(sig, info, ucVoid)) {
300       return true;
301     } else {
302       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
303       return true;
304     }
305   }
306 
307 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
308   if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
<span class="line-modified">309     handle_assert_poison_fault(ucVoid, info-&gt;si_addr);</span>
<span class="line-modified">310     return 1;</span>

311   }
312 #endif
313 
314   JavaThread* thread = NULL;
315   VMThread* vmthread = NULL;
316   if (os::Linux::signal_handlers_are_installed) {
317     if (t != NULL ){
318       if(t-&gt;is_Java_thread()) {
319         thread = (JavaThread*)t;
320       }
321       else if(t-&gt;is_VM_thread()){
322         vmthread = (VMThread *)t;
323       }
324     }
325   }
326 /*
327   NOTE: does not seem to work on linux.
328   if (info == NULL || info-&gt;si_code &lt;= 0 || info-&gt;si_code == SI_NOINFO) {
329     // can&#39;t decode this kind of signal
330     info = NULL;
331   } else {
332     assert(sig == info-&gt;si_signo, &quot;bad siginfo&quot;);
333   }
334 */
335   // decide if this trap can be handled by a stub
336   address stub = NULL;
337 
338   address pc          = NULL;
339 
340   //%note os_trap_1
341   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
342     pc = (address) os::Linux::ucontext_get_pc(uc);
343 
<span class="line-removed">344 #ifdef BUILTIN_SIM</span>
<span class="line-removed">345     if (pc == (address) Fetch32PFI) {</span>
<span class="line-removed">346        uc-&gt;uc_mcontext.gregs[REG_PC] = intptr_t(Fetch32Resume) ;</span>
<span class="line-removed">347        return 1 ;</span>
<span class="line-removed">348     }</span>
<span class="line-removed">349     if (pc == (address) FetchNPFI) {</span>
<span class="line-removed">350        uc-&gt;uc_mcontext.gregs[REG_PC] = intptr_t (FetchNResume) ;</span>
<span class="line-removed">351        return 1 ;</span>
<span class="line-removed">352     }</span>
<span class="line-removed">353 #else</span>
354     if (StubRoutines::is_safefetch_fault(pc)) {
355       os::Linux::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
356       return 1;
357     }
<span class="line-removed">358 #endif</span>
359 
360     address addr = (address) info-&gt;si_addr;
361 
362     // Make sure the high order byte is sign extended, as it may be masked away by the hardware.
363     if ((uintptr_t(addr) &amp; (uintptr_t(1) &lt;&lt; 55)) != 0) {
364       addr = address(uintptr_t(addr) | (uintptr_t(0xFF) &lt;&lt; 56));
365     }
366 
367     // Handle ALL stack overflow variations here
368     if (sig == SIGSEGV) {
369       // check if fault address is within thread stack
370       if (thread-&gt;on_local_stack(addr)) {
371         // stack overflow
372         if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
373           if (thread-&gt;thread_state() == _thread_in_Java) {
374             if (thread-&gt;in_stack_reserved_zone(addr)) {
375               frame fr;
376               if (os::Linux::get_frame_at_stack_banging_point(thread, uc, &amp;fr)) {
377                 assert(fr.is_java_frame(), &quot;Must be a Java frame&quot;);
378                 frame activation =
</pre>
<hr />
<pre>
429 
430     if (thread-&gt;thread_state() == _thread_in_Java) {
431       // Java thread running in Java code =&gt; find exception handler if any
432       // a fault inside compiled code, the interpreter, or a stub
433 
434       // Handle signal from NativeJump::patch_verified_entry().
435       if ((sig == SIGILL || sig == SIGTRAP)
436           &amp;&amp; nativeInstruction_at(pc)-&gt;is_sigill_zombie_not_entrant()) {
437         if (TraceTraps) {
438           tty-&gt;print_cr(&quot;trap: zombie_not_entrant (%s)&quot;, (sig == SIGTRAP) ? &quot;SIGTRAP&quot; : &quot;SIGILL&quot;);
439         }
440         stub = SharedRuntime::get_handle_wrong_method_stub();
441       } else if (sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {
442         stub = SharedRuntime::get_poll_stub(pc);
443       } else if (sig == SIGBUS /* &amp;&amp; info-&gt;si_code == BUS_OBJERR */) {
444         // BugId 4454115: A read from a MappedByteBuffer can fault
445         // here if the underlying file has been truncated.
446         // Do not crash the VM in such a case.
447         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
448         CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
<span class="line-modified">449         if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {</span>

450           address next_pc = pc + NativeCall::instruction_size;



451           stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
452         }
453       }
454       else
455 
456       if (sig == SIGFPE  &amp;&amp;
457           (info-&gt;si_code == FPE_INTDIV || info-&gt;si_code == FPE_FLTDIV)) {
458         stub =
459           SharedRuntime::
460           continuation_for_implicit_exception(thread,
461                                               pc,
462                                               SharedRuntime::
463                                               IMPLICIT_DIVIDE_BY_ZERO);
464       } else if (sig == SIGSEGV &amp;&amp;
465                  MacroAssembler::uses_implicit_null_check((void*)addr)) {
466           // Determination of interpreter/vtable stub/compiled code null exception
467           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
468       }
<span class="line-modified">469     } else if (thread-&gt;thread_state() == _thread_in_vm &amp;&amp;</span>

470                sig == SIGBUS &amp;&amp; /* info-&gt;si_code == BUS_OBJERR &amp;&amp; */
471                thread-&gt;doing_unsafe_access()) {
472       address next_pc = pc + NativeCall::instruction_size;



473       stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
474     }
475 
476     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in
477     // and the heap gets shrunk before the field access.
478     if ((sig == SIGSEGV) || (sig == SIGBUS)) {
479       address addr = JNI_FastGetField::find_slowcase_pc(pc);
480       if (addr != (address)-1) {
481         stub = addr;
482       }
483     }
484   }
485 
486   if (stub != NULL) {
487     // save all thread context in case we need to restore it
488     if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);
489 
490     os::Linux::ucontext_set_pc(uc, stub);
491     return true;
492   }
</pre>
<hr />
<pre>
544 // HotSpot guard pages is added later.
545 size_t os::Posix::_compiler_thread_min_stack_allowed = 72 * K;
546 size_t os::Posix::_java_thread_min_stack_allowed = 72 * K;
547 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 72 * K;
548 
549 // return default stack size for thr_type
550 size_t os::Posix::default_stack_size(os::ThreadType thr_type) {
551   // default stack size (compiler thread needs larger stack)
552   size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);
553   return s;
554 }
555 
556 /////////////////////////////////////////////////////////////////////////////
557 // helper functions for fatal error handler
558 
559 void os::print_context(outputStream *st, const void *context) {
560   if (context == NULL) return;
561 
562   const ucontext_t *uc = (const ucontext_t*)context;
563   st-&gt;print_cr(&quot;Registers:&quot;);
<span class="line-removed">564 #ifdef BUILTIN_SIM</span>
<span class="line-removed">565   st-&gt;print(  &quot;RAX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RAX]);</span>
<span class="line-removed">566   st-&gt;print(&quot;, RBX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBX]);</span>
<span class="line-removed">567   st-&gt;print(&quot;, RCX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RCX]);</span>
<span class="line-removed">568   st-&gt;print(&quot;, RDX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDX]);</span>
<span class="line-removed">569   st-&gt;cr();</span>
<span class="line-removed">570   st-&gt;print(  &quot;RSP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSP]);</span>
<span class="line-removed">571   st-&gt;print(&quot;, RBP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBP]);</span>
<span class="line-removed">572   st-&gt;print(&quot;, RSI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSI]);</span>
<span class="line-removed">573   st-&gt;print(&quot;, RDI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDI]);</span>
<span class="line-removed">574   st-&gt;cr();</span>
<span class="line-removed">575   st-&gt;print(  &quot;R8 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R8]);</span>
<span class="line-removed">576   st-&gt;print(&quot;, R9 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R9]);</span>
<span class="line-removed">577   st-&gt;print(&quot;, R10=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R10]);</span>
<span class="line-removed">578   st-&gt;print(&quot;, R11=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R11]);</span>
<span class="line-removed">579   st-&gt;cr();</span>
<span class="line-removed">580   st-&gt;print(  &quot;R12=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R12]);</span>
<span class="line-removed">581   st-&gt;print(&quot;, R13=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R13]);</span>
<span class="line-removed">582   st-&gt;print(&quot;, R14=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R14]);</span>
<span class="line-removed">583   st-&gt;print(&quot;, R15=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R15]);</span>
<span class="line-removed">584   st-&gt;cr();</span>
<span class="line-removed">585   st-&gt;print(  &quot;RIP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RIP]);</span>
<span class="line-removed">586   st-&gt;print(&quot;, EFLAGS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_EFL]);</span>
<span class="line-removed">587   st-&gt;print(&quot;, CSGSFS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_CSGSFS]);</span>
<span class="line-removed">588   st-&gt;print(&quot;, ERR=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_ERR]);</span>
<span class="line-removed">589   st-&gt;cr();</span>
<span class="line-removed">590   st-&gt;print(&quot;  TRAPNO=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_TRAPNO]);</span>
<span class="line-removed">591   st-&gt;cr();</span>
<span class="line-removed">592 #else</span>
593   for (int r = 0; r &lt; 31; r++) {
594     st-&gt;print(&quot;R%-2d=&quot;, r);
595     print_location(st, uc-&gt;uc_mcontext.regs[r]);
596   }
<span class="line-removed">597 #endif</span>
598   st-&gt;cr();
599 
600   intptr_t *sp = (intptr_t *)os::Linux::ucontext_get_sp(uc);
601   st-&gt;print_cr(&quot;Top of Stack: (sp=&quot; PTR_FORMAT &quot;)&quot;, p2i(sp));
602   print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));
603   st-&gt;cr();
604 
605   // Note: it may be unsafe to inspect memory near pc. For example, pc may
606   // point to garbage if entry point in an nmethod is corrupted. Leave
607   // this at the end, and hope for the best.
608   address pc = os::Linux::ucontext_get_pc(uc);
609   print_instructions(st, pc, sizeof(char));
610   st-&gt;cr();
611 }
612 
613 void os::print_register_info(outputStream *st, const void *context) {
614   if (context == NULL) return;
615 
616   const ucontext_t *uc = (const ucontext_t*)context;
617 
618   st-&gt;print_cr(&quot;Register to memory mapping:&quot;);
619   st-&gt;cr();
620 
621   // this is horrendously verbose but the layout of the registers in the
622   // context does not match how we defined our abstract Register set, so
623   // we can&#39;t just iterate through the gregs area
624 
625   // this is only for the &quot;general purpose&quot; registers
626 
<span class="line-removed">627 #ifdef BUILTIN_SIM</span>
<span class="line-removed">628   st-&gt;print(&quot;RAX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RAX]);</span>
<span class="line-removed">629   st-&gt;print(&quot;RBX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RBX]);</span>
<span class="line-removed">630   st-&gt;print(&quot;RCX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RCX]);</span>
<span class="line-removed">631   st-&gt;print(&quot;RDX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RDX]);</span>
<span class="line-removed">632   st-&gt;print(&quot;RSP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RSP]);</span>
<span class="line-removed">633   st-&gt;print(&quot;RBP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RBP]);</span>
<span class="line-removed">634   st-&gt;print(&quot;RSI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RSI]);</span>
<span class="line-removed">635   st-&gt;print(&quot;RDI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RDI]);</span>
<span class="line-removed">636   st-&gt;print(&quot;R8 =&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R8]);</span>
<span class="line-removed">637   st-&gt;print(&quot;R9 =&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R9]);</span>
<span class="line-removed">638   st-&gt;print(&quot;R10=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R10]);</span>
<span class="line-removed">639   st-&gt;print(&quot;R11=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R11]);</span>
<span class="line-removed">640   st-&gt;print(&quot;R12=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R12]);</span>
<span class="line-removed">641   st-&gt;print(&quot;R13=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R13]);</span>
<span class="line-removed">642   st-&gt;print(&quot;R14=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R14]);</span>
<span class="line-removed">643   st-&gt;print(&quot;R15=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R15]);</span>
<span class="line-removed">644 #else</span>
645   for (int r = 0; r &lt; 31; r++)
646     st-&gt;print_cr(  &quot;R%d=&quot; INTPTR_FORMAT, r, (uintptr_t)uc-&gt;uc_mcontext.regs[r]);
<span class="line-removed">647 #endif</span>
648   st-&gt;cr();
649 }
650 
651 void os::setup_fpu() {
652 }
653 
654 #ifndef PRODUCT
655 void os::verify_stack_alignment() {
656   assert(((intptr_t)os::current_stack_pointer() &amp; (StackAlignmentInBytes-1)) == 0, &quot;incorrect stack alignment&quot;);
657 }
658 #endif
659 
660 int os::extra_bang_size_in_bytes() {
661   // AArch64 does not require the additional stack bang.
662   return 0;
663 }
664 
665 extern &quot;C&quot; {
666   int SpinPause() {
667     return 0;
668   }
669 
<span class="line-modified">670   void _Copy_conjoint_jshorts_atomic(jshort* from, jshort* to, size_t count) {</span>
671     if (from &gt; to) {
<span class="line-modified">672       jshort *end = from + count;</span>
673       while (from &lt; end)
674         *(to++) = *(from++);
675     }
676     else if (from &lt; to) {
<span class="line-modified">677       jshort *end = from;</span>
678       from += count - 1;
679       to   += count - 1;
680       while (from &gt;= end)
681         *(to--) = *(from--);
682     }
683   }
<span class="line-modified">684   void _Copy_conjoint_jints_atomic(jint* from, jint* to, size_t count) {</span>
685     if (from &gt; to) {
<span class="line-modified">686       jint *end = from + count;</span>
687       while (from &lt; end)
688         *(to++) = *(from++);
689     }
690     else if (from &lt; to) {
<span class="line-modified">691       jint *end = from;</span>
692       from += count - 1;
693       to   += count - 1;
694       while (from &gt;= end)
695         *(to--) = *(from--);
696     }
697   }
<span class="line-modified">698   void _Copy_conjoint_jlongs_atomic(jlong* from, jlong* to, size_t count) {</span>
699     if (from &gt; to) {
<span class="line-modified">700       jlong *end = from + count;</span>
701       while (from &lt; end)
702         os::atomic_copy64(from++, to++);
703     }
704     else if (from &lt; to) {
<span class="line-modified">705       jlong *end = from;</span>
706       from += count - 1;
707       to   += count - 1;
708       while (from &gt;= end)
709         os::atomic_copy64(from--, to--);
710     }
711   }
712 
<span class="line-modified">713   void _Copy_arrayof_conjoint_bytes(HeapWord* from,</span>
714                                     HeapWord* to,
715                                     size_t    count) {
716     memmove(to, from, count);
717   }
<span class="line-modified">718   void _Copy_arrayof_conjoint_jshorts(HeapWord* from,</span>
719                                       HeapWord* to,
720                                       size_t    count) {
721     memmove(to, from, count * 2);
722   }
<span class="line-modified">723   void _Copy_arrayof_conjoint_jints(HeapWord* from,</span>
724                                     HeapWord* to,
725                                     size_t    count) {
726     memmove(to, from, count * 4);
727   }
<span class="line-modified">728   void _Copy_arrayof_conjoint_jlongs(HeapWord* from,</span>
729                                      HeapWord* to,
730                                      size_t    count) {
731     memmove(to, from, count * 8);
732   }
733 };
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
 36 #include &quot;interpreter/interpreter.hpp&quot;
 37 #include &quot;memory/allocation.inline.hpp&quot;
 38 #include &quot;os_share_linux.hpp&quot;
 39 #include &quot;prims/jniFastGetField.hpp&quot;
 40 #include &quot;prims/jvm_misc.hpp&quot;
 41 #include &quot;runtime/arguments.hpp&quot;
 42 #include &quot;runtime/extendedPC.hpp&quot;
 43 #include &quot;runtime/frame.inline.hpp&quot;
 44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 45 #include &quot;runtime/java.hpp&quot;
 46 #include &quot;runtime/javaCalls.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/osThread.hpp&quot;
 49 #include &quot;runtime/sharedRuntime.hpp&quot;
 50 #include &quot;runtime/stubRoutines.hpp&quot;
 51 #include &quot;runtime/thread.inline.hpp&quot;
 52 #include &quot;runtime/timer.hpp&quot;
 53 #include &quot;utilities/debug.hpp&quot;
 54 #include &quot;utilities/events.hpp&quot;
 55 #include &quot;utilities/vmError.hpp&quot;



 56 
 57 // put OS-includes here
 58 # include &lt;sys/types.h&gt;
 59 # include &lt;sys/mman.h&gt;
 60 # include &lt;pthread.h&gt;
 61 # include &lt;signal.h&gt;
 62 # include &lt;errno.h&gt;
 63 # include &lt;dlfcn.h&gt;
 64 # include &lt;stdlib.h&gt;
 65 # include &lt;stdio.h&gt;
 66 # include &lt;unistd.h&gt;
 67 # include &lt;sys/resource.h&gt;
 68 # include &lt;pthread.h&gt;
 69 # include &lt;sys/stat.h&gt;
 70 # include &lt;sys/time.h&gt;
 71 # include &lt;sys/utsname.h&gt;
 72 # include &lt;sys/socket.h&gt;
 73 # include &lt;sys/wait.h&gt;
 74 # include &lt;pwd.h&gt;
 75 # include &lt;poll.h&gt;
 76 # include &lt;ucontext.h&gt;
 77 # include &lt;fpu_control.h&gt;
 78 







 79 #define REG_FP 29
 80 #define REG_LR 30
 81 
<span class="line-modified"> 82 NOINLINE address os::current_stack_pointer() {</span>
<span class="line-modified"> 83   return (address)__builtin_frame_address(0);</span>





 84 }
 85 
 86 char* os::non_memory_address_word() {
 87   // Must never look like an address returned by reserve_memory,
 88   // even in its subfields (as defined by the CPU immediate fields,
 89   // if the CPU splits constants across multiple instructions).
 90 
 91   return (char*) 0xffffffffffff;
 92 }
 93 
 94 address os::Linux::ucontext_get_pc(const ucontext_t * uc) {



 95   return (address)uc-&gt;uc_mcontext.pc;

 96 }
 97 
 98 void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {



 99   uc-&gt;uc_mcontext.pc = (intptr_t)pc;

100 }
101 
102 intptr_t* os::Linux::ucontext_get_sp(const ucontext_t * uc) {



103   return (intptr_t*)uc-&gt;uc_mcontext.sp;

104 }
105 
106 intptr_t* os::Linux::ucontext_get_fp(const ucontext_t * uc) {



107   return (intptr_t*)uc-&gt;uc_mcontext.regs[REG_FP];

108 }
109 
110 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
111 // is currently interrupted by SIGPROF.
112 // os::Solaris::fetch_frame_from_ucontext() tries to skip nested signal
113 // frames. Currently we don&#39;t do that on Linux, so it&#39;s the same as
114 // os::fetch_frame_from_context().
115 ExtendedPC os::Linux::fetch_frame_from_ucontext(Thread* thread,
116   const ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {
117 
118   assert(thread != NULL, &quot;just checking&quot;);
119   assert(ret_sp != NULL, &quot;just checking&quot;);
120   assert(ret_fp != NULL, &quot;just checking&quot;);
121 
122   return os::fetch_frame_from_context(uc, ret_sp, ret_fp);
123 }
124 
125 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
126                     intptr_t** ret_sp, intptr_t** ret_fp) {
127 
</pre>
<hr />
<pre>
175       // belong to the caller.
176       intptr_t* fp = os::Linux::ucontext_get_fp(uc);
177       intptr_t* sp = os::Linux::ucontext_get_sp(uc);
178       address pc = (address)(uc-&gt;uc_mcontext.regs[REG_LR]
179                          - NativeInstruction::instruction_size);
180       *fr = frame(sp, fp, pc);
181       if (!fr-&gt;is_java_frame()) {
182         assert(fr-&gt;safe_for_sender(thread), &quot;Safety check&quot;);
183         assert(!fr-&gt;is_first_frame(), &quot;Safety check&quot;);
184         *fr = fr-&gt;java_sender();
185       }
186     }
187   }
188   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
189   return true;
190 }
191 
192 // By default, gcc always saves frame pointer rfp on this stack. This
193 // may get turned off by -fomit-frame-pointer.
194 frame os::get_sender_for_C_frame(frame* fr) {



195   return frame(fr-&gt;link(), fr-&gt;link(), fr-&gt;sender_pc());

196 }
197 
<span class="line-modified">198 NOINLINE frame os::current_frame() {</span>
<span class="line-modified">199   intptr_t *fp = *(intptr_t **)__builtin_frame_address(0);</span>















200   frame myframe((intptr_t*)os::current_stack_pointer(),
201                 (intptr_t*)fp,
202                 CAST_FROM_FN_PTR(address, os::current_frame));
203   if (os::is_first_C_frame(&amp;myframe)) {
204     // stack is not walkable
205     return frame();
206   } else {
207     return os::get_sender_for_C_frame(&amp;myframe);
208   }
209 }
210 














211 extern &quot;C&quot; JNIEXPORT int
212 JVM_handle_linux_signal(int sig,
213                         siginfo_t* info,
214                         void* ucVoid,
215                         int abort_if_unrecognized) {
216   ucontext_t* uc = (ucontext_t*) ucVoid;
217 
218   Thread* t = Thread::current_or_null_safe();
219 
220   // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away
221   // (no destructors can be run)
222   os::ThreadCrashProtection::check_crash_protection(sig, t);
223 
224   SignalHandlerMark shm(t);
225 
226   // Note: it&#39;s not uncommon that JNI code uses signal/sigset to install
227   // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
228   // or have a SIGILL handler when detecting CPU type). When that happens,
229   // JVM_handle_linux_signal() might be invoked with junk info/ucVoid. To
230   // avoid unnecessary crash when libjsig is not preloaded, try handle signals
231   // that do not require siginfo/ucontext first.
232 
233   if (sig == SIGPIPE || sig == SIGXFSZ) {
234     // allow chained handler to go first
235     if (os::Linux::chained_handler(sig, info, ucVoid)) {
236       return true;
237     } else {
238       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
239       return true;
240     }
241   }
242 
243 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
244   if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
<span class="line-modified">245     if (handle_assert_poison_fault(ucVoid, info-&gt;si_addr)) {</span>
<span class="line-modified">246       return 1;</span>
<span class="line-added">247     }</span>
248   }
249 #endif
250 
251   JavaThread* thread = NULL;
252   VMThread* vmthread = NULL;
253   if (os::Linux::signal_handlers_are_installed) {
254     if (t != NULL ){
255       if(t-&gt;is_Java_thread()) {
256         thread = (JavaThread*)t;
257       }
258       else if(t-&gt;is_VM_thread()){
259         vmthread = (VMThread *)t;
260       }
261     }
262   }
263 /*
264   NOTE: does not seem to work on linux.
265   if (info == NULL || info-&gt;si_code &lt;= 0 || info-&gt;si_code == SI_NOINFO) {
266     // can&#39;t decode this kind of signal
267     info = NULL;
268   } else {
269     assert(sig == info-&gt;si_signo, &quot;bad siginfo&quot;);
270   }
271 */
272   // decide if this trap can be handled by a stub
273   address stub = NULL;
274 
275   address pc          = NULL;
276 
277   //%note os_trap_1
278   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
279     pc = (address) os::Linux::ucontext_get_pc(uc);
280 










281     if (StubRoutines::is_safefetch_fault(pc)) {
282       os::Linux::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
283       return 1;
284     }

285 
286     address addr = (address) info-&gt;si_addr;
287 
288     // Make sure the high order byte is sign extended, as it may be masked away by the hardware.
289     if ((uintptr_t(addr) &amp; (uintptr_t(1) &lt;&lt; 55)) != 0) {
290       addr = address(uintptr_t(addr) | (uintptr_t(0xFF) &lt;&lt; 56));
291     }
292 
293     // Handle ALL stack overflow variations here
294     if (sig == SIGSEGV) {
295       // check if fault address is within thread stack
296       if (thread-&gt;on_local_stack(addr)) {
297         // stack overflow
298         if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
299           if (thread-&gt;thread_state() == _thread_in_Java) {
300             if (thread-&gt;in_stack_reserved_zone(addr)) {
301               frame fr;
302               if (os::Linux::get_frame_at_stack_banging_point(thread, uc, &amp;fr)) {
303                 assert(fr.is_java_frame(), &quot;Must be a Java frame&quot;);
304                 frame activation =
</pre>
<hr />
<pre>
355 
356     if (thread-&gt;thread_state() == _thread_in_Java) {
357       // Java thread running in Java code =&gt; find exception handler if any
358       // a fault inside compiled code, the interpreter, or a stub
359 
360       // Handle signal from NativeJump::patch_verified_entry().
361       if ((sig == SIGILL || sig == SIGTRAP)
362           &amp;&amp; nativeInstruction_at(pc)-&gt;is_sigill_zombie_not_entrant()) {
363         if (TraceTraps) {
364           tty-&gt;print_cr(&quot;trap: zombie_not_entrant (%s)&quot;, (sig == SIGTRAP) ? &quot;SIGTRAP&quot; : &quot;SIGILL&quot;);
365         }
366         stub = SharedRuntime::get_handle_wrong_method_stub();
367       } else if (sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {
368         stub = SharedRuntime::get_poll_stub(pc);
369       } else if (sig == SIGBUS /* &amp;&amp; info-&gt;si_code == BUS_OBJERR */) {
370         // BugId 4454115: A read from a MappedByteBuffer can fault
371         // here if the underlying file has been truncated.
372         // Do not crash the VM in such a case.
373         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
374         CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
<span class="line-modified">375         bool is_unsafe_arraycopy = (thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc));</span>
<span class="line-added">376         if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {</span>
377           address next_pc = pc + NativeCall::instruction_size;
<span class="line-added">378           if (is_unsafe_arraycopy) {</span>
<span class="line-added">379             next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">380           }</span>
381           stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
382         }
383       }
384       else
385 
386       if (sig == SIGFPE  &amp;&amp;
387           (info-&gt;si_code == FPE_INTDIV || info-&gt;si_code == FPE_FLTDIV)) {
388         stub =
389           SharedRuntime::
390           continuation_for_implicit_exception(thread,
391                                               pc,
392                                               SharedRuntime::
393                                               IMPLICIT_DIVIDE_BY_ZERO);
394       } else if (sig == SIGSEGV &amp;&amp;
395                  MacroAssembler::uses_implicit_null_check((void*)addr)) {
396           // Determination of interpreter/vtable stub/compiled code null exception
397           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
398       }
<span class="line-modified">399     } else if ((thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">400                  thread-&gt;thread_state() == _thread_in_native) &amp;&amp;</span>
401                sig == SIGBUS &amp;&amp; /* info-&gt;si_code == BUS_OBJERR &amp;&amp; */
402                thread-&gt;doing_unsafe_access()) {
403       address next_pc = pc + NativeCall::instruction_size;
<span class="line-added">404       if (UnsafeCopyMemory::contains_pc(pc)) {</span>
<span class="line-added">405         next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">406       }</span>
407       stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
408     }
409 
410     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in
411     // and the heap gets shrunk before the field access.
412     if ((sig == SIGSEGV) || (sig == SIGBUS)) {
413       address addr = JNI_FastGetField::find_slowcase_pc(pc);
414       if (addr != (address)-1) {
415         stub = addr;
416       }
417     }
418   }
419 
420   if (stub != NULL) {
421     // save all thread context in case we need to restore it
422     if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);
423 
424     os::Linux::ucontext_set_pc(uc, stub);
425     return true;
426   }
</pre>
<hr />
<pre>
478 // HotSpot guard pages is added later.
479 size_t os::Posix::_compiler_thread_min_stack_allowed = 72 * K;
480 size_t os::Posix::_java_thread_min_stack_allowed = 72 * K;
481 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 72 * K;
482 
483 // return default stack size for thr_type
484 size_t os::Posix::default_stack_size(os::ThreadType thr_type) {
485   // default stack size (compiler thread needs larger stack)
486   size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);
487   return s;
488 }
489 
490 /////////////////////////////////////////////////////////////////////////////
491 // helper functions for fatal error handler
492 
493 void os::print_context(outputStream *st, const void *context) {
494   if (context == NULL) return;
495 
496   const ucontext_t *uc = (const ucontext_t*)context;
497   st-&gt;print_cr(&quot;Registers:&quot;);





























498   for (int r = 0; r &lt; 31; r++) {
499     st-&gt;print(&quot;R%-2d=&quot;, r);
500     print_location(st, uc-&gt;uc_mcontext.regs[r]);
501   }

502   st-&gt;cr();
503 
504   intptr_t *sp = (intptr_t *)os::Linux::ucontext_get_sp(uc);
505   st-&gt;print_cr(&quot;Top of Stack: (sp=&quot; PTR_FORMAT &quot;)&quot;, p2i(sp));
506   print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));
507   st-&gt;cr();
508 
509   // Note: it may be unsafe to inspect memory near pc. For example, pc may
510   // point to garbage if entry point in an nmethod is corrupted. Leave
511   // this at the end, and hope for the best.
512   address pc = os::Linux::ucontext_get_pc(uc);
513   print_instructions(st, pc, sizeof(char));
514   st-&gt;cr();
515 }
516 
517 void os::print_register_info(outputStream *st, const void *context) {
518   if (context == NULL) return;
519 
520   const ucontext_t *uc = (const ucontext_t*)context;
521 
522   st-&gt;print_cr(&quot;Register to memory mapping:&quot;);
523   st-&gt;cr();
524 
525   // this is horrendously verbose but the layout of the registers in the
526   // context does not match how we defined our abstract Register set, so
527   // we can&#39;t just iterate through the gregs area
528 
529   // this is only for the &quot;general purpose&quot; registers
530 


















531   for (int r = 0; r &lt; 31; r++)
532     st-&gt;print_cr(  &quot;R%d=&quot; INTPTR_FORMAT, r, (uintptr_t)uc-&gt;uc_mcontext.regs[r]);

533   st-&gt;cr();
534 }
535 
536 void os::setup_fpu() {
537 }
538 
539 #ifndef PRODUCT
540 void os::verify_stack_alignment() {
541   assert(((intptr_t)os::current_stack_pointer() &amp; (StackAlignmentInBytes-1)) == 0, &quot;incorrect stack alignment&quot;);
542 }
543 #endif
544 
545 int os::extra_bang_size_in_bytes() {
546   // AArch64 does not require the additional stack bang.
547   return 0;
548 }
549 
550 extern &quot;C&quot; {
551   int SpinPause() {
552     return 0;
553   }
554 
<span class="line-modified">555   void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {</span>
556     if (from &gt; to) {
<span class="line-modified">557       const jshort *end = from + count;</span>
558       while (from &lt; end)
559         *(to++) = *(from++);
560     }
561     else if (from &lt; to) {
<span class="line-modified">562       const jshort *end = from;</span>
563       from += count - 1;
564       to   += count - 1;
565       while (from &gt;= end)
566         *(to--) = *(from--);
567     }
568   }
<span class="line-modified">569   void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {</span>
570     if (from &gt; to) {
<span class="line-modified">571       const jint *end = from + count;</span>
572       while (from &lt; end)
573         *(to++) = *(from++);
574     }
575     else if (from &lt; to) {
<span class="line-modified">576       const jint *end = from;</span>
577       from += count - 1;
578       to   += count - 1;
579       while (from &gt;= end)
580         *(to--) = *(from--);
581     }
582   }
<span class="line-modified">583   void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {</span>
584     if (from &gt; to) {
<span class="line-modified">585       const jlong *end = from + count;</span>
586       while (from &lt; end)
587         os::atomic_copy64(from++, to++);
588     }
589     else if (from &lt; to) {
<span class="line-modified">590       const jlong *end = from;</span>
591       from += count - 1;
592       to   += count - 1;
593       while (from &gt;= end)
594         os::atomic_copy64(from--, to--);
595     }
596   }
597 
<span class="line-modified">598   void _Copy_arrayof_conjoint_bytes(const HeapWord* from,</span>
599                                     HeapWord* to,
600                                     size_t    count) {
601     memmove(to, from, count);
602   }
<span class="line-modified">603   void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,</span>
604                                       HeapWord* to,
605                                       size_t    count) {
606     memmove(to, from, count * 2);
607   }
<span class="line-modified">608   void _Copy_arrayof_conjoint_jints(const HeapWord* from,</span>
609                                     HeapWord* to,
610                                     size_t    count) {
611     memmove(to, from, count * 4);
612   }
<span class="line-modified">613   void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,</span>
614                                      HeapWord* to,
615                                      size_t    count) {
616     memmove(to, from, count * 8);
617   }
618 };
</pre>
</td>
</tr>
</table>
<center><a href="orderAccess_linux_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="prefetch_linux_aarch64.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
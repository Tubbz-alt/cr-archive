<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/os_cpu/linux_s390/atomic_linux_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2016, 2019 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef OS_CPU_LINUX_S390_ATOMIC_LINUX_S390_HPP
 27 #define OS_CPU_LINUX_S390_ATOMIC_LINUX_S390_HPP
 28 
 29 #include &quot;runtime/atomic.hpp&quot;
 30 #include &quot;runtime/os.hpp&quot;
 31 #include &quot;runtime/vm_version.hpp&quot;
 32 
 33 // Note that the compare-and-swap instructions on System z perform
 34 // a serialization function before the storage operand is fetched
 35 // and again after the operation is completed.
 36 //
 37 // Used constraint modifiers:
 38 // = write-only access: Value on entry to inline-assembler code irrelevant.
 39 // + read/write access: Value on entry is used; on exit value is changed.
 40 //   read-only  access: Value on entry is used and never changed.
 41 // &amp; early-clobber access: Might be modified before all read-only operands
 42 //                         have been used.
 43 // a address register operand (not GR0).
 44 // d general register operand (including GR0)
 45 // Q memory operand w/o index register.
 46 // 0..9 operand reference (by operand position).
 47 //      Used for operands that fill multiple roles. One example would be a
 48 //      write-only operand receiving its initial value from a read-only operand.
 49 //      Refer to cmpxchg(..) operand #0 and variable cmp_val for a real-life example.
 50 //
 51 
 52 // On System z, all store operations are atomic if the address where the data is stored into
 53 // is an integer multiple of the data length. Furthermore, all stores are ordered:
 54 // a store which occurs conceptually before another store becomes visible to other CPUs
 55 // before the other store becomes visible.
 56 
 57 //------------
 58 // Atomic::add
 59 //------------
 60 // These methods force the value in memory to be augmented by the passed increment.
 61 // Both, memory value and increment, are treated as 32bit signed binary integers.
 62 // No overflow exceptions are recognized, and the condition code does not hold
 63 // information about the value in memory.
 64 //
 65 // The value in memory is updated by using a compare-and-swap instruction. The
 66 // instruction is retried as often as required.
 67 //
 68 // The return value of the method is the value that was successfully stored. At the
 69 // time the caller receives back control, the value in memory may have changed already.
 70 
 71 // New atomic operations only include specific-operand-serialization, not full
 72 // memory barriers. We can use the Fast-BCR-Serialization Facility for them.
 73 inline void z196_fast_sync() {
 74   __asm__ __volatile__ (&quot;bcr 14, 0&quot; : : : &quot;memory&quot;);
 75 }
 76 
 77 template&lt;size_t byte_size&gt;
 78 struct Atomic::PlatformAdd {
 79   template&lt;typename D, typename I&gt;
 80   D add_and_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;
 81 
 82   template&lt;typename D, typename I&gt;
 83   D fetch_and_add(D volatile* dest, I add_value, atomic_memory_order order) const {
 84     return add_and_fetch(dest, add_value, order) - add_value;
 85   }
 86 };
 87 
 88 template&lt;&gt;
 89 template&lt;typename D, typename I&gt;
 90 inline D Atomic::PlatformAdd&lt;4&gt;::add_and_fetch(D volatile* dest, I inc,
 91                                                atomic_memory_order order) const {
 92   STATIC_ASSERT(4 == sizeof(I));
 93   STATIC_ASSERT(4 == sizeof(D));
 94 
 95   D old, upd;
 96 
 97   if (VM_Version::has_LoadAndALUAtomicV1()) {
 98     if (order == memory_order_conservative) { z196_fast_sync(); }
 99     __asm__ __volatile__ (
100       &quot;   LGFR     0,%[inc]                \n\t&quot; // save increment
101       &quot;   LA       3,%[mem]                \n\t&quot; // force data address into ARG2
102 //    &quot;   LAA      %[upd],%[inc],%[mem]    \n\t&quot; // increment and get old value
103 //    &quot;   LAA      2,0,0(3)                \n\t&quot; // actually coded instruction
104       &quot;   .byte    0xeb                    \n\t&quot; // LAA main opcode
105       &quot;   .byte    0x20                    \n\t&quot; // R1,R3
106       &quot;   .byte    0x30                    \n\t&quot; // R2,disp1
107       &quot;   .byte    0x00                    \n\t&quot; // disp2,disp3
108       &quot;   .byte    0x00                    \n\t&quot; // disp4,disp5
109       &quot;   .byte    0xf8                    \n\t&quot; // LAA minor opcode
110       &quot;   AR       2,0                     \n\t&quot; // calc new value in register
111       &quot;   LR       %[upd],2                \n\t&quot; // move to result register
112       //---&lt;  outputs  &gt;---
113       : [upd]  &quot;=&amp;d&quot; (upd)    // write-only, updated counter value
114       , [mem]  &quot;+Q&quot;  (*dest)  // read/write, memory to be updated atomically
115       //---&lt;  inputs  &gt;---
116       : [inc]  &quot;a&quot;   (inc)    // read-only.
117       //---&lt;  clobbered  &gt;---
118       : &quot;cc&quot;, &quot;r0&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;memory&quot;
119     );
120     if (order == memory_order_conservative) { z196_fast_sync(); }
121   } else {
122     __asm__ __volatile__ (
123       &quot;   LLGF     %[old],%[mem]           \n\t&quot; // get old value
124       &quot;0: LA       %[upd],0(%[inc],%[old]) \n\t&quot; // calc result
125       &quot;   CS       %[old],%[upd],%[mem]    \n\t&quot; // try to xchg res with mem
126       &quot;   JNE      0b                      \n\t&quot; // no success? -&gt; retry
127       //---&lt;  outputs  &gt;---
128       : [old] &quot;=&amp;a&quot; (old)    // write-only, old counter value
129       , [upd] &quot;=&amp;d&quot; (upd)    // write-only, updated counter value
130       , [mem] &quot;+Q&quot;  (*dest)  // read/write, memory to be updated atomically
131       //---&lt;  inputs  &gt;---
132       : [inc] &quot;a&quot;   (inc)    // read-only.
133       //---&lt;  clobbered  &gt;---
134       : &quot;cc&quot;, &quot;memory&quot;
135     );
136   }
137 
138   return upd;
139 }
140 
141 
142 template&lt;&gt;
143 template&lt;typename D, typename I&gt;
144 inline D Atomic::PlatformAdd&lt;8&gt;::add_and_fetch(D volatile* dest, I inc,
145                                                atomic_memory_order order) const {
146   STATIC_ASSERT(8 == sizeof(I));
147   STATIC_ASSERT(8 == sizeof(D));
148 
149   D old, upd;
150 
151   if (VM_Version::has_LoadAndALUAtomicV1()) {
152     if (order == memory_order_conservative) { z196_fast_sync(); }
153     __asm__ __volatile__ (
154       &quot;   LGR      0,%[inc]                \n\t&quot; // save increment
155       &quot;   LA       3,%[mem]                \n\t&quot; // force data address into ARG2
156 //    &quot;   LAAG     %[upd],%[inc],%[mem]    \n\t&quot; // increment and get old value
157 //    &quot;   LAAG     2,0,0(3)                \n\t&quot; // actually coded instruction
158       &quot;   .byte    0xeb                    \n\t&quot; // LAA main opcode
159       &quot;   .byte    0x20                    \n\t&quot; // R1,R3
160       &quot;   .byte    0x30                    \n\t&quot; // R2,disp1
161       &quot;   .byte    0x00                    \n\t&quot; // disp2,disp3
162       &quot;   .byte    0x00                    \n\t&quot; // disp4,disp5
163       &quot;   .byte    0xe8                    \n\t&quot; // LAA minor opcode
164       &quot;   AGR      2,0                     \n\t&quot; // calc new value in register
165       &quot;   LGR      %[upd],2                \n\t&quot; // move to result register
166       //---&lt;  outputs  &gt;---
167       : [upd]  &quot;=&amp;d&quot; (upd)    // write-only, updated counter value
168       , [mem]  &quot;+Q&quot;  (*dest)  // read/write, memory to be updated atomically
169       //---&lt;  inputs  &gt;---
170       : [inc]  &quot;a&quot;   (inc)    // read-only.
171       //---&lt;  clobbered  &gt;---
172       : &quot;cc&quot;, &quot;r0&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;memory&quot;
173     );
174     if (order == memory_order_conservative) { z196_fast_sync(); }
175   } else {
176     __asm__ __volatile__ (
177       &quot;   LG       %[old],%[mem]           \n\t&quot; // get old value
178       &quot;0: LA       %[upd],0(%[inc],%[old]) \n\t&quot; // calc result
179       &quot;   CSG      %[old],%[upd],%[mem]    \n\t&quot; // try to xchg res with mem
180       &quot;   JNE      0b                      \n\t&quot; // no success? -&gt; retry
181       //---&lt;  outputs  &gt;---
182       : [old] &quot;=&amp;a&quot; (old)    // write-only, old counter value
183       , [upd] &quot;=&amp;d&quot; (upd)    // write-only, updated counter value
184       , [mem] &quot;+Q&quot;  (*dest)  // read/write, memory to be updated atomically
185       //---&lt;  inputs  &gt;---
186       : [inc] &quot;a&quot;   (inc)    // read-only.
187       //---&lt;  clobbered  &gt;---
188       : &quot;cc&quot;, &quot;memory&quot;
189     );
190   }
191 
192   return upd;
193 }
194 
195 
196 //-------------
197 // Atomic::xchg
198 //-------------
199 // These methods force the value in memory to be replaced by the new value passed
200 // in as argument.
201 //
202 // The value in memory is replaced by using a compare-and-swap instruction. The
203 // instruction is retried as often as required. This makes sure that the new
204 // value can be seen, at least for a very short period of time, by other CPUs.
205 //
206 // If we would use a normal &quot;load(old value) store(new value)&quot; sequence,
207 // the new value could be lost unnoticed, due to a store(new value) from
208 // another thread.
209 //
210 // The return value is the (unchanged) value from memory as it was when the
211 // replacement succeeded.
212 template&lt;&gt;
213 template&lt;typename T&gt;
214 inline T Atomic::PlatformXchg&lt;4&gt;::operator()(T volatile* dest,
215                                              T exchange_value,
216                                              atomic_memory_order unused) const {
217   STATIC_ASSERT(4 == sizeof(T));
218   T old;
219 
220   __asm__ __volatile__ (
221     &quot;   LLGF     %[old],%[mem]           \n\t&quot; // get old value
222     &quot;0: CS       %[old],%[upd],%[mem]    \n\t&quot; // try to xchg upd with mem
223     &quot;   JNE      0b                      \n\t&quot; // no success? -&gt; retry
224     //---&lt;  outputs  &gt;---
225     : [old] &quot;=&amp;d&quot; (old)      // write-only, prev value irrelevant
226     , [mem] &quot;+Q&quot;  (*dest)    // read/write, memory to be updated atomically
227     //---&lt;  inputs  &gt;---
228     : [upd] &quot;d&quot;   (exchange_value) // read-only, value to be written to memory
229     //---&lt;  clobbered  &gt;---
230     : &quot;cc&quot;, &quot;memory&quot;
231   );
232 
233   return old;
234 }
235 
236 template&lt;&gt;
237 template&lt;typename T&gt;
238 inline T Atomic::PlatformXchg&lt;8&gt;::operator()(T volatile* dest,
239                                              T exchange_value,
240                                              atomic_memory_order unused) const {
241   STATIC_ASSERT(8 == sizeof(T));
242   T old;
243 
244   __asm__ __volatile__ (
245     &quot;   LG       %[old],%[mem]           \n\t&quot; // get old value
246     &quot;0: CSG      %[old],%[upd],%[mem]    \n\t&quot; // try to xchg upd with mem
247     &quot;   JNE      0b                      \n\t&quot; // no success? -&gt; retry
248     //---&lt;  outputs  &gt;---
249     : [old] &quot;=&amp;d&quot; (old)      // write-only, init from memory
250     , [mem] &quot;+Q&quot;  (*dest)    // read/write, memory to be updated atomically
251     //---&lt;  inputs  &gt;---
252     : [upd] &quot;d&quot;   (exchange_value) // read-only, value to be written to memory
253     //---&lt;  clobbered  &gt;---
254     : &quot;cc&quot;, &quot;memory&quot;
255   );
256 
257   return old;
258 }
259 
260 //----------------
261 // Atomic::cmpxchg
262 //----------------
263 // These methods compare the value in memory with a given compare value.
264 // If both values compare equal, the value in memory is replaced with
265 // the exchange value.
266 //
267 // The value in memory is compared and replaced by using a compare-and-swap
268 // instruction. The instruction is NOT retried (one shot only).
269 //
270 // The return value is the (unchanged) value from memory as it was when the
271 // compare-and-swap instruction completed. A successful exchange operation
272 // is indicated by (return value == compare_value). If unsuccessful, a new
273 // exchange value can be calculated based on the return value which is the
274 // latest contents of the memory location.
275 //
276 // Inspecting the return value is the only way for the caller to determine
277 // if the compare-and-swap instruction was successful:
278 // - If return value and compare value compare equal, the compare-and-swap
279 //   instruction was successful and the value in memory was replaced by the
280 //   exchange value.
281 // - If return value and compare value compare unequal, the compare-and-swap
282 //   instruction was not successful. The value in memory was left unchanged.
283 //
284 // The s390 processors always fence before and after the csg instructions.
285 // Thus we ignore the memory ordering argument. The docu says: &quot;A serialization
286 // function is performed before the operand is fetched and again after the
287 // operation is completed.&quot;
288 
289 // No direct support for cmpxchg of bytes; emulate using int.
290 template&lt;&gt;
291 struct Atomic::PlatformCmpxchg&lt;1&gt; : Atomic::CmpxchgByteUsingInt {};
292 
293 template&lt;&gt;
294 template&lt;typename T&gt;
295 inline T Atomic::PlatformCmpxchg&lt;4&gt;::operator()(T volatile* dest,
296                                                 T cmp_val,
297                                                 T xchg_val,
298                                                 atomic_memory_order unused) const {
299   STATIC_ASSERT(4 == sizeof(T));
300   T old;
301 
302   __asm__ __volatile__ (
303     &quot;   CS       %[old],%[upd],%[mem]    \n\t&quot; // Try to xchg upd with mem.
304     // outputs
305     : [old] &quot;=&amp;d&quot; (old)      // Write-only, prev value irrelevant.
306     , [mem] &quot;+Q&quot;  (*dest)    // Read/write, memory to be updated atomically.
307     // inputs
308     : [upd] &quot;d&quot;   (xchg_val)
309     ,       &quot;0&quot;   (cmp_val)  // Read-only, initial value for [old] (operand #0).
310     // clobbered
311     : &quot;cc&quot;, &quot;memory&quot;
312   );
313 
314   return old;
315 }
316 
317 template&lt;&gt;
318 template&lt;typename T&gt;
319 inline T Atomic::PlatformCmpxchg&lt;8&gt;::operator()(T volatile* dest,
320                                                 T cmp_val,
321                                                 T xchg_val,
322                                                 atomic_memory_order unused) const {
323   STATIC_ASSERT(8 == sizeof(T));
324   T old;
325 
326   __asm__ __volatile__ (
327     &quot;   CSG      %[old],%[upd],%[mem]    \n\t&quot; // Try to xchg upd with mem.
328     // outputs
329     : [old] &quot;=&amp;d&quot; (old)      // Write-only, prev value irrelevant.
330     , [mem] &quot;+Q&quot;  (*dest)    // Read/write, memory to be updated atomically.
331     // inputs
332     : [upd] &quot;d&quot;   (xchg_val)
333     ,       &quot;0&quot;   (cmp_val)  // Read-only, initial value for [old] (operand #0).
334     // clobbered
335     : &quot;cc&quot;, &quot;memory&quot;
336   );
337 
338   return old;
339 }
340 
341 template&lt;size_t byte_size&gt;
342 struct Atomic::PlatformOrderedLoad&lt;byte_size, X_ACQUIRE&gt;
343 {
344   template &lt;typename T&gt;
345   T operator()(const volatile T* p) const { T t = *p; OrderAccess::acquire(); return t; }
346 };
347 
348 #endif // OS_CPU_LINUX_S390_ATOMIC_LINUX_S390_HPP
    </pre>
  </body>
</html>
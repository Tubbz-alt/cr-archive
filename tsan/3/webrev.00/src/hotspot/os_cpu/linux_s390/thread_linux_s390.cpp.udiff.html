<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/os_cpu/linux_s390/thread_linux_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_linux_s390.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../linux_sparc/atomic_linux_sparc.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_s390/thread_linux_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,8 +1,8 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016 SAP SE. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2019 SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61,24 +61,28 @@</span>
        return false;
      }
  
      if (ret_frame.is_interpreted_frame()) {
        frame::z_ijava_state* istate = ret_frame.ijava_state_unchecked();
<span class="udiff-line-modified-removed">-        if (!((Method*)(istate-&gt;method))-&gt;is_metaspace_object()) {</span>
<span class="udiff-line-modified-removed">-          return false;</span>
<span class="udiff-line-modified-removed">-        }</span>
<span class="udiff-line-modified-removed">-        uint64_t reg_bcp = uc-&gt;uc_mcontext.gregs[13/*Z_BCP*/];</span>
<span class="udiff-line-modified-removed">-        uint64_t istate_bcp = istate-&gt;bcp;</span>
<span class="udiff-line-modified-removed">-        uint64_t code_start = (uint64_t)(((Method*)(istate-&gt;method))-&gt;code_base());</span>
<span class="udiff-line-modified-removed">-        uint64_t code_end = (uint64_t)(((Method*)istate-&gt;method)-&gt;code_base() + ((Method*)istate-&gt;method)-&gt;code_size());</span>
<span class="udiff-line-modified-removed">-        if (istate_bcp &gt;= code_start &amp;&amp; istate_bcp &lt; code_end) {</span>
<span class="udiff-line-modified-removed">-          // we have a valid bcp, don&#39;t touch it, do nothing</span>
<span class="udiff-line-modified-removed">-        } else if (reg_bcp &gt;= code_start &amp;&amp; reg_bcp &lt; code_end) {</span>
<span class="udiff-line-modified-removed">-          istate-&gt;bcp = reg_bcp;</span>
<span class="udiff-line-modified-removed">-        } else {</span>
<span class="udiff-line-modified-removed">-          return false;</span>
<span class="udiff-line-modified-removed">-        }</span>
<span class="udiff-line-modified-added">+       if (on_local_stack((address)istate)) {</span>
<span class="udiff-line-modified-added">+         return false;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+       const Method *m = (const Method*)(istate-&gt;method);</span>
<span class="udiff-line-modified-added">+       if (!Method::is_valid_method(m)) return false;</span>
<span class="udiff-line-modified-added">+       if (!Metaspace::contains(m-&gt;constMethod())) return false;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       uint64_t reg_bcp = uc-&gt;uc_mcontext.gregs[13/*Z_BCP*/];</span>
<span class="udiff-line-modified-added">+       uint64_t istate_bcp = istate-&gt;bcp;</span>
<span class="udiff-line-modified-added">+       uint64_t code_start = (uint64_t)(m-&gt;code_base());</span>
<span class="udiff-line-modified-added">+       uint64_t code_end = (uint64_t)(m-&gt;code_base() + m-&gt;code_size());</span>
<span class="udiff-line-modified-added">+       if (istate_bcp &gt;= code_start &amp;&amp; istate_bcp &lt; code_end) {</span>
<span class="udiff-line-modified-added">+         // we have a valid bcp, don&#39;t touch it, do nothing</span>
<span class="udiff-line-modified-added">+       } else if (reg_bcp &gt;= code_start &amp;&amp; reg_bcp &lt; code_end) {</span>
<span class="udiff-line-added">+         istate-&gt;bcp = reg_bcp;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+       }</span>
      }
      if (!ret_frame.safe_for_sender(this)) {
        // nothing else to try if the frame isn&#39;t good
        return false;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -87,12 +91,11 @@</span>
    }
    // nothing else to try
    return false;
  }
  
<span class="udiff-line-modified-removed">- // Forte Analyzer AsyncGetCallTrace profiling support is not implemented on Linux/S390x.</span>
<span class="udiff-line-modified-added">+ // Forte Analyzer AsyncGetCallTrace profiling support.</span>
  bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext, bool isInJava) {
<span class="udiff-line-modified-removed">-   Unimplemented();</span>
<span class="udiff-line-removed">-   return false;</span>
<span class="udiff-line-modified-added">+   return pd_get_top_frame_for_profiling(fr_addr, ucontext, isInJava);</span>
  }
  
  void JavaThread::cache_global_variables() { }
</pre>
<center><a href="os_linux_s390.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../linux_sparc/atomic_linux_sparc.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
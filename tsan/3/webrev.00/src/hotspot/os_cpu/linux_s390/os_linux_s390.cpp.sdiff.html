<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/linux_s390/os_linux_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess_linux_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread_linux_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_s390/os_linux_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">  3  * Copyright (c) 2016, 2018 SAP SE. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
</pre>
<hr />
<pre>
253   // Note: it&#39;s not uncommon that JNI code uses signal/sigset to install
254   // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
255   // or have a SIGILL handler when detecting CPU type). When that happens,
256   // JVM_handle_linux_signal() might be invoked with junk info/ucVoid. To
257   // avoid unnecessary crash when libjsig is not preloaded, try handle signals
258   // that do not require siginfo/ucontext first.
259 
260   if (sig == SIGPIPE) {
261     if (os::Linux::chained_handler(sig, info, ucVoid)) {
262       return true;
263     } else {
264       if (PrintMiscellaneous &amp;&amp; (WizardMode || Verbose)) {
265         warning(&quot;Ignoring SIGPIPE - see bug 4229104&quot;);
266       }
267       return true;
268     }
269   }
270 
271 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
272   if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
<span class="line-modified">273     handle_assert_poison_fault(ucVoid, info-&gt;si_addr);</span>
<span class="line-modified">274     return 1;</span>

275   }
276 #endif
277 
278   JavaThread* thread = NULL;
279   VMThread* vmthread = NULL;
280   if (os::Linux::signal_handlers_are_installed) {
281     if (t != NULL) {
282       if(t-&gt;is_Java_thread()) {
283         thread = (JavaThread*)t;
284       } else if(t-&gt;is_VM_thread()) {
285         vmthread = (VMThread *)t;
286       }
287     }
288   }
289 
290   // Moved SafeFetch32 handling outside thread!=NULL conditional block to make
291   // it work if no associated JavaThread object exists.
292   if (uc) {
293     address const pc = os::Linux::ucontext_get_pc(uc);
294     if (pc &amp;&amp; StubRoutines::is_safefetch_fault(pc)) {
</pre>
<hr />
<pre>
408       // SIGTRAP-based implicit null check in compiled code.
409       else if ((sig == SIGFPE) &amp;&amp;
410                TrapBasedNullChecks &amp;&amp;
411                (trap_pc != NULL) &amp;&amp;
412                Assembler::is_sigtrap_zero_check(trap_pc)) {
413         if (TraceTraps) {
414           tty-&gt;print_cr(&quot;trap: NULL_CHECK at &quot; INTPTR_FORMAT &quot; (SIGFPE)&quot;, p2i(trap_pc));
415         }
416         stub = SharedRuntime::continuation_for_implicit_exception(thread, trap_pc, SharedRuntime::IMPLICIT_NULL);
417       }
418 
419       else if (sig == SIGSEGV &amp;&amp; ImplicitNullChecks &amp;&amp;
420                CodeCache::contains((void*) pc) &amp;&amp;
421                MacroAssembler::uses_implicit_null_check(info-&gt;si_addr)) {
422         if (TraceTraps) {
423           tty-&gt;print_cr(&quot;trap: null_check at &quot; INTPTR_FORMAT &quot; (SIGSEGV)&quot;, p2i(pc));
424         }
425         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
426       }
427 

428       // SIGTRAP-based implicit range check in compiled code.
429       else if (sig == SIGFPE &amp;&amp; TrapBasedRangeChecks &amp;&amp;
430                (trap_pc != NULL) &amp;&amp;
431                Assembler::is_sigtrap_range_check(trap_pc)) {
432         if (TraceTraps) {
433           tty-&gt;print_cr(&quot;trap: RANGE_CHECK at &quot; INTPTR_FORMAT &quot; (SIGFPE)&quot;, p2i(trap_pc));
434         }
435         stub = SharedRuntime::continuation_for_implicit_exception(thread, trap_pc, SharedRuntime::IMPLICIT_NULL);
436       }

437 
438       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_INTDIV) {
439         stub = SharedRuntime::continuation_for_implicit_exception(thread, trap_pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
440       }
441 
442       else if (sig == SIGBUS) {
443         // BugId 4454115: A read from a MappedByteBuffer can fault here if the
444         // underlying file has been truncated. Do not crash the VM in such a case.
445         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
446         CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
447         if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {
448           // We don&#39;t really need a stub here! Just set the pending exeption and
449           // continue at the next instruction after the faulting read. Returning
450           // garbage from this read is ok.
451           thread-&gt;set_pending_unsafe_access_error();
452           uc-&gt;uc_mcontext.psw.addr = ((unsigned long)pc) + Assembler::instr_len(pc);
453           return true;
454         }
455       }
456     }
457 
458     else { // thread-&gt;thread_state() != _thread_in_Java
459       if ((sig == SIGILL) &amp;&amp; VM_Version::is_determine_features_test_running()) {
460         // SIGILL must be caused by VM_Version::determine_features()
461         // when attempting to execute a non-existing instruction.
462         //*(int *) (pc-6)=0; // Patch instruction to 0 to indicate that it causes a SIGILL.
463                              // Flushing of icache is not necessary.
464         stub = pc; // Continue with next instruction.
465       } else if ((sig == SIGFPE) &amp;&amp; VM_Version::is_determine_features_test_running()) {
466         // SIGFPE is known to be caused by trying to execute a vector instruction
467         // when the vector facility is installed, but operating system support is missing.
468         VM_Version::reset_has_VectorFacility();
469         stub = pc; // Continue with next instruction.
<span class="line-modified">470       } else if (thread-&gt;thread_state() == _thread_in_vm &amp;&amp;</span>

471                  sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
472         // We don&#39;t really need a stub here! Just set the pending exeption and
473         // continue at the next instruction after the faulting read. Returning
474         // garbage from this read is ok.
475         thread-&gt;set_pending_unsafe_access_error();
476         os::Linux::ucontext_set_pc(uc, pc + Assembler::instr_len(pc));
477         return true;
478       }
479     }









480   }
481 
482   if (stub != NULL) {
483     // Save all thread context in case we need to restore it.
484     if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);
485     os::Linux::ucontext_set_pc(uc, stub);
486     return true;
487   }
488 
489   // signal-chaining
490   if (os::Linux::chained_handler(sig, info, ucVoid)) {
491     return true;
492   }
493 
494   if (!abort_if_unrecognized) {
495     // caller wants another chance, so give it to him
496     return false;
497   }
498 
499   if (pc == NULL &amp;&amp; uc != NULL) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">  3  * Copyright (c) 2016, 2019 SAP SE. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
</pre>
<hr />
<pre>
253   // Note: it&#39;s not uncommon that JNI code uses signal/sigset to install
254   // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
255   // or have a SIGILL handler when detecting CPU type). When that happens,
256   // JVM_handle_linux_signal() might be invoked with junk info/ucVoid. To
257   // avoid unnecessary crash when libjsig is not preloaded, try handle signals
258   // that do not require siginfo/ucontext first.
259 
260   if (sig == SIGPIPE) {
261     if (os::Linux::chained_handler(sig, info, ucVoid)) {
262       return true;
263     } else {
264       if (PrintMiscellaneous &amp;&amp; (WizardMode || Verbose)) {
265         warning(&quot;Ignoring SIGPIPE - see bug 4229104&quot;);
266       }
267       return true;
268     }
269   }
270 
271 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
272   if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
<span class="line-modified">273     if (handle_assert_poison_fault(ucVoid, info-&gt;si_addr)) {</span>
<span class="line-modified">274       return 1;</span>
<span class="line-added">275     }</span>
276   }
277 #endif
278 
279   JavaThread* thread = NULL;
280   VMThread* vmthread = NULL;
281   if (os::Linux::signal_handlers_are_installed) {
282     if (t != NULL) {
283       if(t-&gt;is_Java_thread()) {
284         thread = (JavaThread*)t;
285       } else if(t-&gt;is_VM_thread()) {
286         vmthread = (VMThread *)t;
287       }
288     }
289   }
290 
291   // Moved SafeFetch32 handling outside thread!=NULL conditional block to make
292   // it work if no associated JavaThread object exists.
293   if (uc) {
294     address const pc = os::Linux::ucontext_get_pc(uc);
295     if (pc &amp;&amp; StubRoutines::is_safefetch_fault(pc)) {
</pre>
<hr />
<pre>
409       // SIGTRAP-based implicit null check in compiled code.
410       else if ((sig == SIGFPE) &amp;&amp;
411                TrapBasedNullChecks &amp;&amp;
412                (trap_pc != NULL) &amp;&amp;
413                Assembler::is_sigtrap_zero_check(trap_pc)) {
414         if (TraceTraps) {
415           tty-&gt;print_cr(&quot;trap: NULL_CHECK at &quot; INTPTR_FORMAT &quot; (SIGFPE)&quot;, p2i(trap_pc));
416         }
417         stub = SharedRuntime::continuation_for_implicit_exception(thread, trap_pc, SharedRuntime::IMPLICIT_NULL);
418       }
419 
420       else if (sig == SIGSEGV &amp;&amp; ImplicitNullChecks &amp;&amp;
421                CodeCache::contains((void*) pc) &amp;&amp;
422                MacroAssembler::uses_implicit_null_check(info-&gt;si_addr)) {
423         if (TraceTraps) {
424           tty-&gt;print_cr(&quot;trap: null_check at &quot; INTPTR_FORMAT &quot; (SIGSEGV)&quot;, p2i(pc));
425         }
426         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
427       }
428 
<span class="line-added">429 #ifdef COMPILER2</span>
430       // SIGTRAP-based implicit range check in compiled code.
431       else if (sig == SIGFPE &amp;&amp; TrapBasedRangeChecks &amp;&amp;
432                (trap_pc != NULL) &amp;&amp;
433                Assembler::is_sigtrap_range_check(trap_pc)) {
434         if (TraceTraps) {
435           tty-&gt;print_cr(&quot;trap: RANGE_CHECK at &quot; INTPTR_FORMAT &quot; (SIGFPE)&quot;, p2i(trap_pc));
436         }
437         stub = SharedRuntime::continuation_for_implicit_exception(thread, trap_pc, SharedRuntime::IMPLICIT_NULL);
438       }
<span class="line-added">439 #endif</span>
440 
441       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_INTDIV) {
442         stub = SharedRuntime::continuation_for_implicit_exception(thread, trap_pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
443       }
444 
445       else if (sig == SIGBUS) {
446         // BugId 4454115: A read from a MappedByteBuffer can fault here if the
447         // underlying file has been truncated. Do not crash the VM in such a case.
448         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
449         CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
450         if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {
451           // We don&#39;t really need a stub here! Just set the pending exeption and
452           // continue at the next instruction after the faulting read. Returning
453           // garbage from this read is ok.
454           thread-&gt;set_pending_unsafe_access_error();
455           uc-&gt;uc_mcontext.psw.addr = ((unsigned long)pc) + Assembler::instr_len(pc);
456           return true;
457         }
458       }
459     }
460 
461     else { // thread-&gt;thread_state() != _thread_in_Java
462       if ((sig == SIGILL) &amp;&amp; VM_Version::is_determine_features_test_running()) {
463         // SIGILL must be caused by VM_Version::determine_features()
464         // when attempting to execute a non-existing instruction.
465         //*(int *) (pc-6)=0; // Patch instruction to 0 to indicate that it causes a SIGILL.
466                              // Flushing of icache is not necessary.
467         stub = pc; // Continue with next instruction.
468       } else if ((sig == SIGFPE) &amp;&amp; VM_Version::is_determine_features_test_running()) {
469         // SIGFPE is known to be caused by trying to execute a vector instruction
470         // when the vector facility is installed, but operating system support is missing.
471         VM_Version::reset_has_VectorFacility();
472         stub = pc; // Continue with next instruction.
<span class="line-modified">473       } else if ((thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">474                   thread-&gt;thread_state() == _thread_in_native) &amp;&amp;</span>
475                  sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
476         // We don&#39;t really need a stub here! Just set the pending exeption and
477         // continue at the next instruction after the faulting read. Returning
478         // garbage from this read is ok.
479         thread-&gt;set_pending_unsafe_access_error();
480         os::Linux::ucontext_set_pc(uc, pc + Assembler::instr_len(pc));
481         return true;
482       }
483     }
<span class="line-added">484 </span>
<span class="line-added">485     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in</span>
<span class="line-added">486     // and the heap gets shrunk before the field access.</span>
<span class="line-added">487     if ((sig == SIGSEGV) || (sig == SIGBUS)) {</span>
<span class="line-added">488       address addr = JNI_FastGetField::find_slowcase_pc(pc);</span>
<span class="line-added">489       if (addr != (address)-1) {</span>
<span class="line-added">490         stub = addr;</span>
<span class="line-added">491       }</span>
<span class="line-added">492     }</span>
493   }
494 
495   if (stub != NULL) {
496     // Save all thread context in case we need to restore it.
497     if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);
498     os::Linux::ucontext_set_pc(uc, stub);
499     return true;
500   }
501 
502   // signal-chaining
503   if (os::Linux::chained_handler(sig, info, ucVoid)) {
504     return true;
505   }
506 
507   if (!abort_if_unrecognized) {
508     // caller wants another chance, so give it to him
509     return false;
510   }
511 
512   if (pc == NULL &amp;&amp; uc != NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="orderAccess_linux_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread_linux_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
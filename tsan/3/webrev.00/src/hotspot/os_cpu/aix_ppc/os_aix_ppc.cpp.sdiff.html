<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/aix_ppc/os_aix_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess_aix_ppc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../bsd_x86/atomic_bsd_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/aix_ppc/os_aix_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
424           tty-&gt;print_cr(&quot;trap: range_check at &quot; INTPTR_FORMAT &quot; (SIGTRAP)&quot;, pc);
425         }
426         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
427         goto run_stub;
428       }
429 #endif
430 
431       else if (sig == SIGFPE /* &amp;&amp; info-&gt;si_code == FPE_INTDIV */) {
432         if (TraceTraps) {
433           tty-&gt;print_raw_cr(&quot;Fix SIGFPE handler, trying divide by zero handler.&quot;);
434         }
435         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
436         goto run_stub;
437       }
438 
439       else if (sig == SIGBUS) {
440         // BugId 4454115: A read from a MappedByteBuffer can fault here if the
441         // underlying file has been truncated. Do not crash the VM in such a case.
442         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
443         CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
<span class="line-modified">444         if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {</span>

445           address next_pc = pc + 4;



446           next_pc = SharedRuntime::handle_unsafe_access(thread, next_pc);
447           os::Aix::ucontext_set_pc(uc, next_pc);
448           return 1;
449         }
450       }
451     }
452 
453     else { // thread-&gt;thread_state() != _thread_in_Java
454       // Detect CPU features. This is only done at the very start of the VM. Later, the
455       // VM_Version::is_determine_features_test_running() flag should be false.
456 
457       if (sig == SIGILL &amp;&amp; VM_Version::is_determine_features_test_running()) {
458         // SIGILL must be caused by VM_Version::determine_features().
459         *(int *)pc = 0; // patch instruction to 0 to indicate that it causes a SIGILL,
460                         // flushing of icache is not necessary.
461         stub = pc + 4;  // continue with next instruction.
462         goto run_stub;
463       }
<span class="line-modified">464       else if (thread-&gt;thread_state() == _thread_in_vm &amp;&amp;</span>

465                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
466         address next_pc = pc + 4;



467         next_pc = SharedRuntime::handle_unsafe_access(thread, next_pc);
468         os::Aix::ucontext_set_pc(uc, next_pc);
469         return 1;
470       }
471     }









472   }
473 
474 run_stub:
475 
476   // One of the above code blocks ininitalized the stub, so we want to
477   // delegate control to that stub.
478   if (stub != NULL) {
479     // Save all thread context in case we need to restore it.
480     if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);
481     os::Aix::ucontext_set_pc(uc, stub);
482     return 1;
483   }
484 
485 run_chained_handler:
486 
487   // signal-chaining
488   if (os::Aix::chained_handler(sig, info, ucVoid)) {
489     return 1;
490   }
491   if (!abort_if_unrecognized) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
424           tty-&gt;print_cr(&quot;trap: range_check at &quot; INTPTR_FORMAT &quot; (SIGTRAP)&quot;, pc);
425         }
426         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
427         goto run_stub;
428       }
429 #endif
430 
431       else if (sig == SIGFPE /* &amp;&amp; info-&gt;si_code == FPE_INTDIV */) {
432         if (TraceTraps) {
433           tty-&gt;print_raw_cr(&quot;Fix SIGFPE handler, trying divide by zero handler.&quot;);
434         }
435         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
436         goto run_stub;
437       }
438 
439       else if (sig == SIGBUS) {
440         // BugId 4454115: A read from a MappedByteBuffer can fault here if the
441         // underlying file has been truncated. Do not crash the VM in such a case.
442         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
443         CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
<span class="line-modified">444         bool is_unsafe_arraycopy = (thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc));</span>
<span class="line-added">445         if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {</span>
446           address next_pc = pc + 4;
<span class="line-added">447           if (is_unsafe_arraycopy) {</span>
<span class="line-added">448             next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">449           }</span>
450           next_pc = SharedRuntime::handle_unsafe_access(thread, next_pc);
451           os::Aix::ucontext_set_pc(uc, next_pc);
452           return 1;
453         }
454       }
455     }
456 
457     else { // thread-&gt;thread_state() != _thread_in_Java
458       // Detect CPU features. This is only done at the very start of the VM. Later, the
459       // VM_Version::is_determine_features_test_running() flag should be false.
460 
461       if (sig == SIGILL &amp;&amp; VM_Version::is_determine_features_test_running()) {
462         // SIGILL must be caused by VM_Version::determine_features().
463         *(int *)pc = 0; // patch instruction to 0 to indicate that it causes a SIGILL,
464                         // flushing of icache is not necessary.
465         stub = pc + 4;  // continue with next instruction.
466         goto run_stub;
467       }
<span class="line-modified">468       else if ((thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">469                 thread-&gt;thread_state() == _thread_in_native) &amp;&amp;</span>
470                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
471         address next_pc = pc + 4;
<span class="line-added">472         if (UnsafeCopyMemory::contains_pc(pc)) {</span>
<span class="line-added">473           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">474         }</span>
475         next_pc = SharedRuntime::handle_unsafe_access(thread, next_pc);
476         os::Aix::ucontext_set_pc(uc, next_pc);
477         return 1;
478       }
479     }
<span class="line-added">480 </span>
<span class="line-added">481     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in</span>
<span class="line-added">482     // and the heap gets shrunk before the field access.</span>
<span class="line-added">483     if ((sig == SIGSEGV) || (sig == SIGBUS)) {</span>
<span class="line-added">484       address addr = JNI_FastGetField::find_slowcase_pc(pc);</span>
<span class="line-added">485       if (addr != (address)-1) {</span>
<span class="line-added">486         stub = addr;</span>
<span class="line-added">487       }</span>
<span class="line-added">488     }</span>
489   }
490 
491 run_stub:
492 
493   // One of the above code blocks ininitalized the stub, so we want to
494   // delegate control to that stub.
495   if (stub != NULL) {
496     // Save all thread context in case we need to restore it.
497     if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);
498     os::Aix::ucontext_set_pc(uc, stub);
499     return 1;
500   }
501 
502 run_chained_handler:
503 
504   // signal-chaining
505   if (os::Aix::chained_handler(sig, info, ucVoid)) {
506     return 1;
507   }
508   if (!abort_if_unrecognized) {
</pre>
</td>
</tr>
</table>
<center><a href="orderAccess_aix_ppc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../bsd_x86/atomic_bsd_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/linux_sparc/os_linux_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess_linux_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_linux_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_sparc/os_linux_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
368       }
369     }
370   }
371   return false;
372 }
373 
374 inline static bool checkPollingPage(address pc, address fault, address* stub) {
375   if (os::is_poll_address(fault)) {
376     *stub = SharedRuntime::get_poll_stub(pc);
377     return true;
378   }
379   return false;
380 }
381 
382 inline static bool checkByteBuffer(address pc, address npc, JavaThread * thread, address* stub) {
383   // BugId 4454115: A read from a MappedByteBuffer can fault
384   // here if the underlying file has been truncated.
385   // Do not crash the VM in such a case.
386   CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
387   CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
<span class="line-modified">388   if (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) {</span>




389     *stub = SharedRuntime::handle_unsafe_access(thread, npc);
390     return true;
391   }
392   return false;
393 }
394 
395 inline static bool checkVerifyOops(address pc, address fault, address* stub) {
396   if (pc &gt;= MacroAssembler::_verify_oop_implicit_branch[0]
397       &amp;&amp; pc &lt;  MacroAssembler::_verify_oop_implicit_branch[1] ) {
398     *stub     =  MacroAssembler::_verify_oop_implicit_branch[2];
399     warning(&quot;fixed up memory fault in +VerifyOops at address &quot;
400             INTPTR_FORMAT, p2i(fault));
401     return true;
402   }
403   return false;
404 }
405 
406 inline static bool checkFPFault(address pc, int code,
407                                 JavaThread* thread, address* stub) {
408   if (code == FPE_INTDIV || code == FPE_FLTDIV) {
</pre>
<hr />
<pre>
493 
494   // Note: it&#39;s not uncommon that JNI code uses signal/sigset to install
495   // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
496   // or have a SIGILL handler when detecting CPU type). When that happens,
497   // JVM_handle_linux_signal() might be invoked with junk info/ucVoid. To
498   // avoid unnecessary crash when libjsig is not preloaded, try handle signals
499   // that do not require siginfo/ucontext first.
500 
501   if (sig == SIGPIPE || sig == SIGXFSZ) {
502     // allow chained handler to go first
503     if (os::Linux::chained_handler(sig, info, ucVoid)) {
504       return true;
505     } else {
506       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
507       return true;
508     }
509   }
510 
511 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
512   if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
<span class="line-modified">513     handle_assert_poison_fault(ucVoid, info-&gt;si_addr);</span>
<span class="line-modified">514     return 1;</span>

515   }
516 #endif
517 
518   JavaThread* thread = NULL;
519   VMThread* vmthread = NULL;
520   if (os::Linux::signal_handlers_are_installed) {
521     if (t != NULL ){
522       if(t-&gt;is_Java_thread()) {
523         thread = (JavaThread*)t;
524       }
525       else if(t-&gt;is_VM_thread()){
526         vmthread = (VMThread *)t;
527       }
528     }
529   }
530 
531   // decide if this trap can be handled by a stub
532   address stub = NULL;
533   address pc = NULL;
534   address npc = NULL;
535 
536   //%note os_trap_1
537   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
538     pc = address(SIG_PC(uc));
539     npc = address(SIG_NPC(uc));
540 
541     if (checkPrefetch(uc, pc)) {
542       return 1;
543     }
544 
545     // Handle ALL stack overflow variations here
546     if (sig == SIGSEGV) {
547       if (checkOverflow(uc, pc, (address)info-&gt;si_addr, thread, &amp;stub)) {
548         return 1;
549       }
550     }
551 
552     if (sig == SIGBUS &amp;&amp;
<span class="line-modified">553         thread-&gt;thread_state() == _thread_in_vm &amp;&amp;</span>

554         thread-&gt;doing_unsafe_access()) {



555       stub = SharedRuntime::handle_unsafe_access(thread, npc);
556     }
557 
558     if (thread-&gt;thread_state() == _thread_in_Java) {
559       do {
560         // Java thread running in Java code =&gt; find exception handler if any
561         // a fault inside compiled code, the interpreter, or a stub
562 
563         if ((sig == SIGSEGV) &amp;&amp; checkPollingPage(pc, (address)info-&gt;si_addr, &amp;stub)) {
564           break;
565         }
566 
567         if ((sig == SIGBUS) &amp;&amp; checkByteBuffer(pc, npc, thread, &amp;stub)) {
568           break;
569         }
570 
571         if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp;
572             checkVerifyOops(pc, (address)info-&gt;si_addr, &amp;stub)) {
573           break;
574         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
368       }
369     }
370   }
371   return false;
372 }
373 
374 inline static bool checkPollingPage(address pc, address fault, address* stub) {
375   if (os::is_poll_address(fault)) {
376     *stub = SharedRuntime::get_poll_stub(pc);
377     return true;
378   }
379   return false;
380 }
381 
382 inline static bool checkByteBuffer(address pc, address npc, JavaThread * thread, address* stub) {
383   // BugId 4454115: A read from a MappedByteBuffer can fault
384   // here if the underlying file has been truncated.
385   // Do not crash the VM in such a case.
386   CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
387   CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
<span class="line-modified">388   bool is_unsafe_arraycopy = (thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc));</span>
<span class="line-added">389   if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {</span>
<span class="line-added">390     if (is_unsafe_arraycopy) {</span>
<span class="line-added">391       npc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">392     }</span>
393     *stub = SharedRuntime::handle_unsafe_access(thread, npc);
394     return true;
395   }
396   return false;
397 }
398 
399 inline static bool checkVerifyOops(address pc, address fault, address* stub) {
400   if (pc &gt;= MacroAssembler::_verify_oop_implicit_branch[0]
401       &amp;&amp; pc &lt;  MacroAssembler::_verify_oop_implicit_branch[1] ) {
402     *stub     =  MacroAssembler::_verify_oop_implicit_branch[2];
403     warning(&quot;fixed up memory fault in +VerifyOops at address &quot;
404             INTPTR_FORMAT, p2i(fault));
405     return true;
406   }
407   return false;
408 }
409 
410 inline static bool checkFPFault(address pc, int code,
411                                 JavaThread* thread, address* stub) {
412   if (code == FPE_INTDIV || code == FPE_FLTDIV) {
</pre>
<hr />
<pre>
497 
498   // Note: it&#39;s not uncommon that JNI code uses signal/sigset to install
499   // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
500   // or have a SIGILL handler when detecting CPU type). When that happens,
501   // JVM_handle_linux_signal() might be invoked with junk info/ucVoid. To
502   // avoid unnecessary crash when libjsig is not preloaded, try handle signals
503   // that do not require siginfo/ucontext first.
504 
505   if (sig == SIGPIPE || sig == SIGXFSZ) {
506     // allow chained handler to go first
507     if (os::Linux::chained_handler(sig, info, ucVoid)) {
508       return true;
509     } else {
510       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
511       return true;
512     }
513   }
514 
515 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
516   if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp; info != NULL &amp;&amp; info-&gt;si_addr == g_assert_poison) {
<span class="line-modified">517     if (handle_assert_poison_fault(ucVoid, info-&gt;si_addr)) {</span>
<span class="line-modified">518       return 1;</span>
<span class="line-added">519     }</span>
520   }
521 #endif
522 
523   JavaThread* thread = NULL;
524   VMThread* vmthread = NULL;
525   if (os::Linux::signal_handlers_are_installed) {
526     if (t != NULL ){
527       if(t-&gt;is_Java_thread()) {
528         thread = (JavaThread*)t;
529       }
530       else if(t-&gt;is_VM_thread()){
531         vmthread = (VMThread *)t;
532       }
533     }
534   }
535 
536   // decide if this trap can be handled by a stub
537   address stub = NULL;
538   address pc = NULL;
539   address npc = NULL;
540 
541   //%note os_trap_1
542   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
543     pc = address(SIG_PC(uc));
544     npc = address(SIG_NPC(uc));
545 
546     if (checkPrefetch(uc, pc)) {
547       return 1;
548     }
549 
550     // Handle ALL stack overflow variations here
551     if (sig == SIGSEGV) {
552       if (checkOverflow(uc, pc, (address)info-&gt;si_addr, thread, &amp;stub)) {
553         return 1;
554       }
555     }
556 
557     if (sig == SIGBUS &amp;&amp;
<span class="line-modified">558         (thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">559          thread-&gt;thread_state() == _thread_in_native) &amp;&amp;</span>
560         thread-&gt;doing_unsafe_access()) {
<span class="line-added">561       if (UnsafeCopyMemory::contains_pc(pc)) {</span>
<span class="line-added">562         npc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">563       }</span>
564       stub = SharedRuntime::handle_unsafe_access(thread, npc);
565     }
566 
567     if (thread-&gt;thread_state() == _thread_in_Java) {
568       do {
569         // Java thread running in Java code =&gt; find exception handler if any
570         // a fault inside compiled code, the interpreter, or a stub
571 
572         if ((sig == SIGSEGV) &amp;&amp; checkPollingPage(pc, (address)info-&gt;si_addr, &amp;stub)) {
573           break;
574         }
575 
576         if ((sig == SIGBUS) &amp;&amp; checkByteBuffer(pc, npc, thread, &amp;stub)) {
577           break;
578         }
579 
580         if ((sig == SIGSEGV || sig == SIGBUS) &amp;&amp;
581             checkVerifyOops(pc, (address)info-&gt;si_addr, &amp;stub)) {
582           break;
583         }
</pre>
</td>
</tr>
</table>
<center><a href="orderAccess_linux_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_linux_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
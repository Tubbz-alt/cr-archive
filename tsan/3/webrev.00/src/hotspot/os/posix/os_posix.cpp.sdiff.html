<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/posix/os_posix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../linux/waitBarrier_linux.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_posix.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/posix/os_posix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;jvm.h&quot;
  26 #include &quot;logging/log.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;os_posix.inline.hpp&quot;
  29 #include &quot;utilities/globalDefinitions.hpp&quot;
  30 #include &quot;runtime/frame.inline.hpp&quot;
  31 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  32 #include &quot;services/memTracker.hpp&quot;


  33 #include &quot;utilities/align.hpp&quot;
  34 #include &quot;utilities/events.hpp&quot;
  35 #include &quot;utilities/formatBuffer.hpp&quot;
  36 #include &quot;utilities/macros.hpp&quot;
  37 #include &quot;utilities/vmError.hpp&quot;
  38 
  39 #include &lt;dirent.h&gt;
  40 #include &lt;dlfcn.h&gt;
  41 #include &lt;grp.h&gt;
  42 #include &lt;pwd.h&gt;
  43 #include &lt;pthread.h&gt;
  44 #include &lt;signal.h&gt;
  45 #include &lt;sys/mman.h&gt;
  46 #include &lt;sys/resource.h&gt;
  47 #include &lt;sys/utsname.h&gt;
  48 #include &lt;time.h&gt;
  49 #include &lt;unistd.h&gt;

  50 
  51 // Todo: provide a os::get_max_process_id() or similar. Number of processes
  52 // may have been configured, can be read more accurately from proc fs etc.
  53 #ifndef MAX_PID
  54 #define MAX_PID INT_MAX
  55 #endif
  56 #define IS_VALID_PID(p) (p &gt; 0 &amp;&amp; p &lt; MAX_PID)
  57 
  58 #define ROOT_UID 0
  59 
  60 #ifndef MAP_ANONYMOUS
  61   #define MAP_ANONYMOUS MAP_ANON
  62 #endif
  63 
  64 #define check_with_errno(check_type, cond, msg)                             \
  65   do {                                                                      \
  66     int err = errno;                                                        \
  67     check_type(cond, &quot;%s; error=&#39;%s&#39; (errno=%s)&quot;, msg, os::strerror(err),   \
  68                os::errno_name(err));                                        \
  69 } while (false)
</pre>
<hr />
<pre>
 150   return (::unsetenv(name) == 0);
 151 }
 152 
 153 int os::get_last_error() {
 154   return errno;
 155 }
 156 
 157 size_t os::lasterror(char *buf, size_t len) {
 158   if (errno == 0)  return 0;
 159 
 160   const char *s = os::strerror(errno);
 161   size_t n = ::strlen(s);
 162   if (n &gt;= len) {
 163     n = len - 1;
 164   }
 165   ::strncpy(buf, s, n);
 166   buf[n] = &#39;\0&#39;;
 167   return n;
 168 }
 169 
<span class="line-removed"> 170 bool os::is_debugger_attached() {</span>
<span class="line-removed"> 171   // not implemented</span>
<span class="line-removed"> 172   return false;</span>
<span class="line-removed"> 173 }</span>
<span class="line-removed"> 174 </span>
 175 void os::wait_for_keypress_at_exit(void) {
 176   // don&#39;t do anything on posix platforms
 177   return;
 178 }
 179 
 180 int os::create_file_for_heap(const char* dir) {

 181 
<span class="line-modified"> 182   const char name_template[] = &quot;/jvmheap.XXXXXX&quot;;</span>
<span class="line-modified"> 183 </span>
<span class="line-modified"> 184   size_t fullname_len = strlen(dir) + strlen(name_template);</span>
<span class="line-modified"> 185   char *fullname = (char*)os::malloc(fullname_len + 1, mtInternal);</span>
<span class="line-removed"> 186   if (fullname == NULL) {</span>
<span class="line-removed"> 187     vm_exit_during_initialization(err_msg(&quot;Malloc failed during creation of backing file for heap (%s)&quot;, os::strerror(errno)));</span>
 188     return -1;
 189   }
<span class="line-modified"> 190   int n = snprintf(fullname, fullname_len + 1, &quot;%s%s&quot;, dir, name_template);</span>
<span class="line-modified"> 191   assert((size_t)n == fullname_len, &quot;Unexpected number of characters in string&quot;);</span>















 192 
<span class="line-modified"> 193   os::native_path(fullname);</span>
 194 
<span class="line-modified"> 195   // set the file creation mask.</span>
<span class="line-modified"> 196   mode_t file_mode = S_IRUSR | S_IWUSR;</span>
 197 
<span class="line-modified"> 198   // create a new file.</span>
<span class="line-modified"> 199   int fd = mkstemp(fullname);</span>







 200 
<span class="line-removed"> 201   if (fd &lt; 0) {</span>
<span class="line-removed"> 202     warning(&quot;Could not create file for heap with template %s&quot;, fullname);</span>
 203     os::free(fullname);
<span class="line-removed"> 204     return -1;</span>
 205   }
 206 
<span class="line-removed"> 207   // delete the name from the filesystem. When &#39;fd&#39; is closed, the file (and space) will be deleted.</span>
<span class="line-removed"> 208   int ret = unlink(fullname);</span>
<span class="line-removed"> 209   assert_with_errno(ret == 0, &quot;unlink returned error&quot;);</span>
<span class="line-removed"> 210 </span>
<span class="line-removed"> 211   os::free(fullname);</span>
 212   return fd;
 213 }
 214 
 215 static char* reserve_mmapped_memory(size_t bytes, char* requested_addr) {
 216   char * addr;
 217   int flags = MAP_PRIVATE NOT_AIX( | MAP_NORESERVE ) | MAP_ANONYMOUS;
 218   if (requested_addr != NULL) {
 219     assert((uintptr_t)requested_addr % os::vm_page_size() == 0, &quot;Requested address should be aligned to OS page size&quot;);
 220     flags |= MAP_FIXED;
 221   }
 222 
 223   // Map reserved/uncommitted pages PROT_NONE so we fail early if we
 224   // touch an uncommitted page. Otherwise, the read/write might
 225   // succeed if we have enough swap space to back the physical page.
 226   addr = (char*)::mmap(requested_addr, bytes, PROT_NONE,
 227                        flags, -1, 0);
 228 
 229   if (addr != MAP_FAILED) {
 230     MemTracker::record_virtual_memory_reserve((address)addr, bytes, CALLER_PC);
 231     return addr;
</pre>
<hr />
<pre>
 356   int result = ::vsnprintf(buf, len, fmt, args);
 357   // If an encoding error occurred (result &lt; 0) then it&#39;s not clear
 358   // whether the buffer is NUL terminated, so ensure it is.
 359   if ((result &lt; 0) &amp;&amp; (len &gt; 0)) {
 360     buf[len - 1] = &#39;\0&#39;;
 361   }
 362   return result;
 363 }
 364 
 365 int os::get_fileno(FILE* fp) {
 366   return NOT_AIX(::)fileno(fp);
 367 }
 368 
 369 struct tm* os::gmtime_pd(const time_t* clock, struct tm*  res) {
 370   return gmtime_r(clock, res);
 371 }
 372 
 373 void os::Posix::print_load_average(outputStream* st) {
 374   st-&gt;print(&quot;load average:&quot;);
 375   double loadavg[3];
<span class="line-modified"> 376   os::loadavg(loadavg, 3);</span>
<span class="line-modified"> 377   st-&gt;print(&quot;%0.02f %0.02f %0.02f&quot;, loadavg[0], loadavg[1], loadavg[2]);</span>




 378   st-&gt;cr();
 379 }
 380 





















 381 void os::Posix::print_rlimit_info(outputStream* st) {
 382   st-&gt;print(&quot;rlimit:&quot;);
 383   struct rlimit rlim;
 384 
 385   st-&gt;print(&quot; STACK &quot;);
 386   getrlimit(RLIMIT_STACK, &amp;rlim);
 387   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 388   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 389 
 390   st-&gt;print(&quot;, CORE &quot;);
 391   getrlimit(RLIMIT_CORE, &amp;rlim);
 392   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 393   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 394 
 395   // Isn&#39;t there on solaris
 396 #if defined(AIX)
 397   st-&gt;print(&quot;, NPROC &quot;);
 398   st-&gt;print(&quot;%d&quot;, sysconf(_SC_CHILD_MAX));




 399 #elif !defined(SOLARIS)
 400   st-&gt;print(&quot;, NPROC &quot;);
 401   getrlimit(RLIMIT_NPROC, &amp;rlim);
 402   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 403   else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));
 404 #endif
 405 
 406   st-&gt;print(&quot;, NOFILE &quot;);
 407   getrlimit(RLIMIT_NOFILE, &amp;rlim);
 408   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 409   else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));
 410 
 411   st-&gt;print(&quot;, AS &quot;);
 412   getrlimit(RLIMIT_AS, &amp;rlim);
 413   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 414   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 415 





 416   st-&gt;print(&quot;, DATA &quot;);
 417   getrlimit(RLIMIT_DATA, &amp;rlim);
 418   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 419   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 420 
 421   st-&gt;print(&quot;, FSIZE &quot;);
 422   getrlimit(RLIMIT_FSIZE, &amp;rlim);
 423   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 424   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 425 
 426   st-&gt;cr();
 427 }
 428 
 429 void os::Posix::print_uname_info(outputStream* st) {
 430   // kernel
 431   st-&gt;print(&quot;uname:&quot;);
 432   struct utsname name;
 433   uname(&amp;name);
 434   st-&gt;print(&quot;%s &quot;, name.sysname);
 435 #ifdef ASSERT
</pre>
<hr />
<pre>
 607       if (strlen(lib_name) &lt;= (prefix_len + suffix_len)) {
 608         return NULL;
 609       }
 610       lib_name += prefix_len;
 611       name_len = strlen(lib_name) - suffix_len;
 612     }
 613   }
 614   len = (lib_name != NULL ? name_len : 0) + strlen(sym_name) + 2;
 615   agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);
 616   if (agent_entry_name == NULL) {
 617     return NULL;
 618   }
 619   strcpy(agent_entry_name, sym_name);
 620   if (lib_name != NULL) {
 621     strcat(agent_entry_name, &quot;_&quot;);
 622     strncat(agent_entry_name, lib_name, name_len);
 623   }
 624   return agent_entry_name;
 625 }
 626 
<span class="line-removed"> 627 int os::sleep(Thread* thread, jlong millis, bool interruptible) {</span>
<span class="line-removed"> 628   assert(thread == Thread::current(),  &quot;thread consistency check&quot;);</span>
<span class="line-removed"> 629 </span>
<span class="line-removed"> 630   ParkEvent * const slp = thread-&gt;_SleepEvent ;</span>
<span class="line-removed"> 631   slp-&gt;reset() ;</span>
<span class="line-removed"> 632   OrderAccess::fence() ;</span>
<span class="line-removed"> 633 </span>
<span class="line-removed"> 634   if (interruptible) {</span>
<span class="line-removed"> 635     jlong prevtime = javaTimeNanos();</span>
<span class="line-removed"> 636 </span>
<span class="line-removed"> 637     for (;;) {</span>
<span class="line-removed"> 638       if (os::is_interrupted(thread, true)) {</span>
<span class="line-removed"> 639         return OS_INTRPT;</span>
<span class="line-removed"> 640       }</span>
<span class="line-removed"> 641 </span>
<span class="line-removed"> 642       jlong newtime = javaTimeNanos();</span>
<span class="line-removed"> 643 </span>
<span class="line-removed"> 644       if (newtime - prevtime &lt; 0) {</span>
<span class="line-removed"> 645         // time moving backwards, should only happen if no monotonic clock</span>
<span class="line-removed"> 646         // not a guarantee() because JVM should not abort on kernel/glibc bugs</span>
<span class="line-removed"> 647         assert(!os::supports_monotonic_clock(), &quot;unexpected time moving backwards detected in os::sleep(interruptible)&quot;);</span>
<span class="line-removed"> 648       } else {</span>
<span class="line-removed"> 649         millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;</span>
<span class="line-removed"> 650       }</span>
<span class="line-removed"> 651 </span>
<span class="line-removed"> 652       if (millis &lt;= 0) {</span>
<span class="line-removed"> 653         return OS_OK;</span>
<span class="line-removed"> 654       }</span>
<span class="line-removed"> 655 </span>
<span class="line-removed"> 656       prevtime = newtime;</span>
<span class="line-removed"> 657 </span>
<span class="line-removed"> 658       {</span>
<span class="line-removed"> 659         assert(thread-&gt;is_Java_thread(), &quot;sanity check&quot;);</span>
<span class="line-removed"> 660         JavaThread *jt = (JavaThread *) thread;</span>
<span class="line-removed"> 661         ThreadBlockInVM tbivm(jt);</span>
<span class="line-removed"> 662         OSThreadWaitState osts(jt-&gt;osthread(), false /* not Object.wait() */);</span>
<span class="line-removed"> 663 </span>
<span class="line-removed"> 664         jt-&gt;set_suspend_equivalent();</span>
<span class="line-removed"> 665         // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-removed"> 666         // java_suspend_self() via check_and_wait_while_suspended()</span>
<span class="line-removed"> 667 </span>
<span class="line-removed"> 668         slp-&gt;park(millis);</span>
<span class="line-removed"> 669 </span>
<span class="line-removed"> 670         // were we externally suspended while we were waiting?</span>
<span class="line-removed"> 671         jt-&gt;check_and_wait_while_suspended();</span>
<span class="line-removed"> 672       }</span>
<span class="line-removed"> 673     }</span>
<span class="line-removed"> 674   } else {</span>
<span class="line-removed"> 675     OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);</span>
<span class="line-removed"> 676     jlong prevtime = javaTimeNanos();</span>
<span class="line-removed"> 677 </span>
<span class="line-removed"> 678     for (;;) {</span>
<span class="line-removed"> 679       // It&#39;d be nice to avoid the back-to-back javaTimeNanos() calls on</span>
<span class="line-removed"> 680       // the 1st iteration ...</span>
<span class="line-removed"> 681       jlong newtime = javaTimeNanos();</span>
<span class="line-removed"> 682 </span>
<span class="line-removed"> 683       if (newtime - prevtime &lt; 0) {</span>
<span class="line-removed"> 684         // time moving backwards, should only happen if no monotonic clock</span>
<span class="line-removed"> 685         // not a guarantee() because JVM should not abort on kernel/glibc bugs</span>
<span class="line-removed"> 686         assert(!os::supports_monotonic_clock(), &quot;unexpected time moving backwards detected on os::sleep(!interruptible)&quot;);</span>
<span class="line-removed"> 687       } else {</span>
<span class="line-removed"> 688         millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;</span>
<span class="line-removed"> 689       }</span>
<span class="line-removed"> 690 </span>
<span class="line-removed"> 691       if (millis &lt;= 0) break ;</span>
<span class="line-removed"> 692 </span>
<span class="line-removed"> 693       prevtime = newtime;</span>
<span class="line-removed"> 694       slp-&gt;park(millis);</span>
<span class="line-removed"> 695     }</span>
<span class="line-removed"> 696     return OS_OK ;</span>
<span class="line-removed"> 697   }</span>
<span class="line-removed"> 698 }</span>
 699 
 700 void os::naked_short_nanosleep(jlong ns) {
 701   struct timespec req;
 702   assert(ns &gt; -1 &amp;&amp; ns &lt; NANOUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
 703   req.tv_sec = 0;
 704   req.tv_nsec = ns;
 705   ::nanosleep(&amp;req, NULL);
 706   return;
 707 }
 708 
 709 void os::naked_short_sleep(jlong ms) {
 710   assert(ms &lt; MILLIUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
<span class="line-modified"> 711   os::naked_short_nanosleep(ms * (NANOUNITS / MILLIUNITS));</span>
 712   return;
 713 }
 714 
<span class="line-removed"> 715 ////////////////////////////////////////////////////////////////////////////////</span>
<span class="line-removed"> 716 // interrupt support</span>
<span class="line-removed"> 717 </span>
<span class="line-removed"> 718 void os::interrupt(Thread* thread) {</span>
<span class="line-removed"> 719   debug_only(Thread::check_for_dangling_thread_pointer(thread);)</span>
<span class="line-removed"> 720 </span>
<span class="line-removed"> 721   OSThread* osthread = thread-&gt;osthread();</span>
<span class="line-removed"> 722 </span>
<span class="line-removed"> 723   if (!osthread-&gt;interrupted()) {</span>
<span class="line-removed"> 724     osthread-&gt;set_interrupted(true);</span>
<span class="line-removed"> 725     // More than one thread can get here with the same value of osthread,</span>
<span class="line-removed"> 726     // resulting in multiple notifications.  We do, however, want the store</span>
<span class="line-removed"> 727     // to interrupted() to be visible to other threads before we execute unpark().</span>
<span class="line-removed"> 728     OrderAccess::fence();</span>
<span class="line-removed"> 729     ParkEvent * const slp = thread-&gt;_SleepEvent ;</span>
<span class="line-removed"> 730     if (slp != NULL) slp-&gt;unpark() ;</span>
<span class="line-removed"> 731   }</span>
<span class="line-removed"> 732 </span>
<span class="line-removed"> 733   // For JSR166. Unpark even if interrupt status already was set</span>
<span class="line-removed"> 734   if (thread-&gt;is_Java_thread())</span>
<span class="line-removed"> 735     ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span>
<span class="line-removed"> 736 </span>
<span class="line-removed"> 737   ParkEvent * ev = thread-&gt;_ParkEvent ;</span>
<span class="line-removed"> 738   if (ev != NULL) ev-&gt;unpark() ;</span>
<span class="line-removed"> 739 }</span>
<span class="line-removed"> 740 </span>
<span class="line-removed"> 741 bool os::is_interrupted(Thread* thread, bool clear_interrupted) {</span>
<span class="line-removed"> 742   debug_only(Thread::check_for_dangling_thread_pointer(thread);)</span>
<span class="line-removed"> 743 </span>
<span class="line-removed"> 744   OSThread* osthread = thread-&gt;osthread();</span>
<span class="line-removed"> 745 </span>
<span class="line-removed"> 746   bool interrupted = osthread-&gt;interrupted();</span>
<span class="line-removed"> 747 </span>
<span class="line-removed"> 748   // NOTE that since there is no &quot;lock&quot; around the interrupt and</span>
<span class="line-removed"> 749   // is_interrupted operations, there is the possibility that the</span>
<span class="line-removed"> 750   // interrupted flag (in osThread) will be &quot;false&quot; but that the</span>
<span class="line-removed"> 751   // low-level events will be in the signaled state. This is</span>
<span class="line-removed"> 752   // intentional. The effect of this is that Object.wait() and</span>
<span class="line-removed"> 753   // LockSupport.park() will appear to have a spurious wakeup, which</span>
<span class="line-removed"> 754   // is allowed and not harmful, and the possibility is so rare that</span>
<span class="line-removed"> 755   // it is not worth the added complexity to add yet another lock.</span>
<span class="line-removed"> 756   // For the sleep event an explicit reset is performed on entry</span>
<span class="line-removed"> 757   // to os::sleep, so there is no early return. It has also been</span>
<span class="line-removed"> 758   // recommended not to put the interrupted flag into the &quot;event&quot;</span>
<span class="line-removed"> 759   // structure because it hides the issue.</span>
<span class="line-removed"> 760   if (interrupted &amp;&amp; clear_interrupted) {</span>
<span class="line-removed"> 761     osthread-&gt;set_interrupted(false);</span>
<span class="line-removed"> 762     // consider thread-&gt;_SleepEvent-&gt;reset() ... optional optimization</span>
<span class="line-removed"> 763   }</span>
<span class="line-removed"> 764 </span>
<span class="line-removed"> 765   return interrupted;</span>
<span class="line-removed"> 766 }</span>
<span class="line-removed"> 767 </span>
<span class="line-removed"> 768 </span>
<span class="line-removed"> 769 </span>
 770 static const struct {
 771   int sig; const char* name;
 772 }
 773  g_signal_info[] =
 774   {
 775   {  SIGABRT,     &quot;SIGABRT&quot; },
 776 #ifdef SIGAIO
 777   {  SIGAIO,      &quot;SIGAIO&quot; },
 778 #endif
 779   {  SIGALRM,     &quot;SIGALRM&quot; },
 780 #ifdef SIGALRM1
 781   {  SIGALRM1,    &quot;SIGALRM1&quot; },
 782 #endif
 783   {  SIGBUS,      &quot;SIGBUS&quot; },
 784 #ifdef SIGCANCEL
 785   {  SIGCANCEL,   &quot;SIGCANCEL&quot; },
 786 #endif
 787   {  SIGCHLD,     &quot;SIGCHLD&quot; },
 788 #ifdef SIGCLD
 789   {  SIGCLD,      &quot;SIGCLD&quot; },
</pre>
<hr />
<pre>
 796   {  SIGDANGER,   &quot;SIGDANGER&quot; },
 797 #endif
 798 #ifdef SIGDIL
 799   {  SIGDIL,      &quot;SIGDIL&quot; },
 800 #endif
 801 #ifdef SIGEMT
 802   {  SIGEMT,      &quot;SIGEMT&quot; },
 803 #endif
 804   {  SIGFPE,      &quot;SIGFPE&quot; },
 805 #ifdef SIGFREEZE
 806   {  SIGFREEZE,   &quot;SIGFREEZE&quot; },
 807 #endif
 808 #ifdef SIGGFAULT
 809   {  SIGGFAULT,   &quot;SIGGFAULT&quot; },
 810 #endif
 811 #ifdef SIGGRANT
 812   {  SIGGRANT,    &quot;SIGGRANT&quot; },
 813 #endif
 814   {  SIGHUP,      &quot;SIGHUP&quot; },
 815   {  SIGILL,      &quot;SIGILL&quot; },



 816   {  SIGINT,      &quot;SIGINT&quot; },
 817 #ifdef SIGIO
 818   {  SIGIO,       &quot;SIGIO&quot; },
 819 #endif
 820 #ifdef SIGIOINT
 821   {  SIGIOINT,    &quot;SIGIOINT&quot; },
 822 #endif
 823 #ifdef SIGIOT
 824 // SIGIOT is there for BSD compatibility, but on most Unices just a
 825 // synonym for SIGABRT. The result should be &quot;SIGABRT&quot;, not
 826 // &quot;SIGIOT&quot;.
 827 #if (SIGIOT != SIGABRT )
 828   {  SIGIOT,      &quot;SIGIOT&quot; },
 829 #endif
 830 #endif
 831 #ifdef SIGKAP
 832   {  SIGKAP,      &quot;SIGKAP&quot; },
 833 #endif
 834   {  SIGKILL,     &quot;SIGKILL&quot; },
 835 #ifdef SIGLOST
</pre>
<hr />
<pre>
1433       outbuf[outbuflen - 1] = &#39;\0&#39;;
1434       p = ::realpath(filename, outbuf);
1435       if (p != NULL) {
1436         guarantee(outbuf[outbuflen - 1] == &#39;\0&#39;, &quot;realpath buffer overwrite detected.&quot;);
1437         result = p;
1438       }
1439     }
1440   }
1441   return result;
1442 
1443 }
1444 
1445 int os::stat(const char *path, struct stat *sbuf) {
1446   return ::stat(path, sbuf);
1447 }
1448 
1449 char * os::native_path(char *path) {
1450   return path;
1451 }
1452 
























1453 // Check minimum allowable stack sizes for thread creation and to initialize
1454 // the java system classes, including StackOverflowError - depends on page
1455 // size.
1456 // The space needed for frames during startup is platform dependent. It
1457 // depends on word size, platform calling conventions, C frame layout and
1458 // interpreter/C1/C2 design decisions. Therefore this is given in a
1459 // platform (os/cpu) dependent constant.
1460 // To this, space for guard mechanisms is added, which depends on the
1461 // page size which again depends on the concrete system the VM is running
1462 // on. Space for libc guard pages is not included in this size.
1463 jint os::Posix::set_minimum_stack_sizes() {
1464   size_t os_min_stack_allowed = SOLARIS_ONLY(thr_min_stack()) NOT_SOLARIS(PTHREAD_STACK_MIN);
1465 
1466   _java_thread_min_stack_allowed = _java_thread_min_stack_allowed +
1467                                    JavaThread::stack_guard_zone_size() +
1468                                    JavaThread::stack_shadow_zone_size();
1469 
1470   _java_thread_min_stack_allowed = align_up(_java_thread_min_stack_allowed, vm_page_size());
1471   _java_thread_min_stack_allowed = MAX2(_java_thread_min_stack_allowed, os_min_stack_allowed);
1472 
</pre>
<hr />
<pre>
1654 // but otherwise whatever default is used by the platform - generally the
1655 // time-of-day clock.
1656 static pthread_condattr_t _condAttr[1];
1657 
1658 // Shared mutexattr to explicitly set the type to PTHREAD_MUTEX_NORMAL as not
1659 // all systems (e.g. FreeBSD) map the default to &quot;normal&quot;.
1660 static pthread_mutexattr_t _mutexAttr[1];
1661 
1662 // common basic initialization that is always supported
1663 static void pthread_init_common(void) {
1664   int status;
1665   if ((status = pthread_condattr_init(_condAttr)) != 0) {
1666     fatal(&quot;pthread_condattr_init: %s&quot;, os::strerror(status));
1667   }
1668   if ((status = pthread_mutexattr_init(_mutexAttr)) != 0) {
1669     fatal(&quot;pthread_mutexattr_init: %s&quot;, os::strerror(status));
1670   }
1671   if ((status = pthread_mutexattr_settype(_mutexAttr, PTHREAD_MUTEX_NORMAL)) != 0) {
1672     fatal(&quot;pthread_mutexattr_settype: %s&quot;, os::strerror(status));
1673   }


1674 }
1675 
1676 #ifndef SOLARIS
1677 sigset_t sigs;
1678 struct sigaction sigact[NSIG];
1679 
1680 struct sigaction* os::Posix::get_preinstalled_handler(int sig) {
1681   if (sigismember(&amp;sigs, sig)) {
1682     return &amp;sigact[sig];
1683   }
1684   return NULL;
1685 }
1686 
1687 void os::Posix::save_preinstalled_handler(int sig, struct sigaction&amp; oldAct) {
1688   assert(sig &gt; 0 &amp;&amp; sig &lt; NSIG, &quot;vm signal out of expected range&quot;);
1689   sigact[sig] = oldAct;
1690   sigaddset(&amp;sigs, sig);
1691 }
1692 #endif
1693 
</pre>
<hr />
<pre>
1869     }
1870     abstime-&gt;tv_nsec = nanos;
1871   }
1872 }
1873 
1874 // Unpack the given deadline in milliseconds since the epoch, into the given timespec.
1875 // The current time in seconds is also passed in to enforce an upper bound as discussed above.
1876 // This is only used with gettimeofday, when clock_gettime is not available.
1877 static void unpack_abs_time(timespec* abstime, jlong deadline, jlong now_sec) {
1878   time_t max_secs = now_sec + MAX_SECS;
1879 
1880   jlong seconds = deadline / MILLIUNITS;
1881   jlong millis = deadline % MILLIUNITS;
1882 
1883   if (seconds &gt;= max_secs) {
1884     // Absolute seconds exceeds allowed max, so pin to max_secs.
1885     abstime-&gt;tv_sec = max_secs;
1886     abstime-&gt;tv_nsec = 0;
1887   } else {
1888     abstime-&gt;tv_sec = seconds;
<span class="line-modified">1889     abstime-&gt;tv_nsec = millis * (NANOUNITS / MILLIUNITS);</span>
1890   }
1891 }
1892 
<span class="line-modified">1893 static jlong millis_to_nanos(jlong millis) {</span>
1894   // We have to watch for overflow when converting millis to nanos,
1895   // but if millis is that large then we will end up limiting to
1896   // MAX_SECS anyway, so just do that here.
1897   if (millis / MILLIUNITS &gt; MAX_SECS) {
1898     millis = jlong(MAX_SECS) * MILLIUNITS;
1899   }
<span class="line-modified">1900   return millis * (NANOUNITS / MILLIUNITS);</span>
1901 }
1902 
1903 static void to_abstime(timespec* abstime, jlong timeout,
1904                        bool isAbsolute, bool isRealtime) {
1905   DEBUG_ONLY(int max_secs = MAX_SECS;)
1906 
1907   if (timeout &lt; 0) {
1908     timeout = 0;
1909   }
1910 
1911 #ifdef SUPPORTS_CLOCK_MONOTONIC
1912 
1913   clockid_t clock = CLOCK_MONOTONIC;
1914   // need to ensure we have a runtime check for clock_gettime support
1915   if (!isAbsolute &amp;&amp; os::Posix::supports_monotonic_clock()) {
1916     if (!_use_clock_monotonic_condattr || isRealtime) {
1917       clock = CLOCK_REALTIME;
1918     }
1919     struct timespec now;
1920     int status = os::Posix::clock_gettime(clock, &amp;now);
</pre>
<hr />
<pre>
1933     struct timeval now;
1934     int status = gettimeofday(&amp;now, NULL);
1935     assert_status(status == 0, errno, &quot;gettimeofday&quot;);
1936     if (isAbsolute) {
1937       unpack_abs_time(abstime, timeout, now.tv_sec);
1938     } else {
1939       calc_rel_time(abstime, timeout, now.tv_sec, now.tv_usec, MICROUNITS);
1940     }
1941     DEBUG_ONLY(max_secs += now.tv_sec;)
1942   }
1943 
1944   assert(abstime-&gt;tv_sec &gt;= 0, &quot;tv_sec &lt; 0&quot;);
1945   assert(abstime-&gt;tv_sec &lt;= max_secs, &quot;tv_sec &gt; max_secs&quot;);
1946   assert(abstime-&gt;tv_nsec &gt;= 0, &quot;tv_nsec &lt; 0&quot;);
1947   assert(abstime-&gt;tv_nsec &lt; NANOUNITS, &quot;tv_nsec &gt;= NANOUNITS&quot;);
1948 }
1949 
1950 // Create an absolute time &#39;millis&#39; milliseconds in the future, using the
1951 // real-time (time-of-day) clock. Used by PosixSemaphore.
1952 void os::Posix::to_RTC_abstime(timespec* abstime, int64_t millis) {
<span class="line-modified">1953   to_abstime(abstime, millis_to_nanos(millis),</span>
1954              false /* not absolute */,
1955              true  /* use real-time clock */);
1956 }
1957 
1958 // Shared pthread_mutex/cond based PlatformEvent implementation.
1959 // Not currently usable by Solaris.
1960 
1961 #ifndef SOLARIS
1962 
1963 // PlatformEvent
1964 //
1965 // Assumption:
1966 //    Only one parker can exist on an event, which is why we allocate
1967 //    them per-thread. Multiple unparkers can coexist.
1968 //
1969 // _event serves as a restricted-range semaphore.
1970 //   -1 : thread is blocked, i.e. there is a waiter
1971 //    0 : neutral: thread is running or ready,
1972 //        could have been signaled after a wait started
1973 //    1 : signaled - thread is running or ready
</pre>
<hr />
<pre>
1982   assert_status(status == 0, status, &quot;mutex_init&quot;);
1983   _event   = 0;
1984   _nParked = 0;
1985 }
1986 
1987 void os::PlatformEvent::park() {       // AKA &quot;down()&quot;
1988   // Transitions for _event:
1989   //   -1 =&gt; -1 : illegal
1990   //    1 =&gt;  0 : pass - return immediately
1991   //    0 =&gt; -1 : block; then set _event to 0 before returning
1992 
1993   // Invariant: Only the thread associated with the PlatformEvent
1994   // may call park().
1995   assert(_nParked == 0, &quot;invariant&quot;);
1996 
1997   int v;
1998 
1999   // atomically decrement _event
2000   for (;;) {
2001     v = _event;
<span class="line-modified">2002     if (Atomic::cmpxchg(v - 1, &amp;_event, v) == v) break;</span>
2003   }
2004   guarantee(v &gt;= 0, &quot;invariant&quot;);
2005 
2006   if (v == 0) { // Do this the hard way by blocking ...
2007     int status = pthread_mutex_lock(_mutex);
2008     assert_status(status == 0, status, &quot;mutex_lock&quot;);
2009     guarantee(_nParked == 0, &quot;invariant&quot;);
2010     ++_nParked;
2011     while (_event &lt; 0) {
2012       // OS-level &quot;spurious wakeups&quot; are ignored
2013       status = pthread_cond_wait(_cond, _mutex);
2014       assert_status(status == 0, status, &quot;cond_wait&quot;);
2015     }
2016     --_nParked;
2017 
2018     _event = 0;
2019     status = pthread_mutex_unlock(_mutex);
2020     assert_status(status == 0, status, &quot;mutex_unlock&quot;);
2021     // Paranoia to ensure our locked and lock-free paths interact
2022     // correctly with each other.
2023     OrderAccess::fence();
2024   }
2025   guarantee(_event &gt;= 0, &quot;invariant&quot;);
2026 }
2027 
2028 int os::PlatformEvent::park(jlong millis) {
2029   // Transitions for _event:
2030   //   -1 =&gt; -1 : illegal
2031   //    1 =&gt;  0 : pass - return immediately
2032   //    0 =&gt; -1 : block; then set _event to 0 before returning
2033 
2034   // Invariant: Only the thread associated with the Event/PlatformEvent
2035   // may call park().
2036   assert(_nParked == 0, &quot;invariant&quot;);
2037 
2038   int v;
2039   // atomically decrement _event
2040   for (;;) {
2041     v = _event;
<span class="line-modified">2042     if (Atomic::cmpxchg(v - 1, &amp;_event, v) == v) break;</span>
2043   }
2044   guarantee(v &gt;= 0, &quot;invariant&quot;);
2045 
2046   if (v == 0) { // Do this the hard way by blocking ...
2047     struct timespec abst;
<span class="line-modified">2048     to_abstime(&amp;abst, millis_to_nanos(millis), false, false);</span>
2049 
2050     int ret = OS_TIMEOUT;
2051     int status = pthread_mutex_lock(_mutex);
2052     assert_status(status == 0, status, &quot;mutex_lock&quot;);
2053     guarantee(_nParked == 0, &quot;invariant&quot;);
2054     ++_nParked;
2055 
2056     while (_event &lt; 0) {
2057       status = pthread_cond_timedwait(_cond, _mutex, &amp;abst);
2058       assert_status(status == 0 || status == ETIMEDOUT,
2059                     status, &quot;cond_timedwait&quot;);
2060       // OS-level &quot;spurious wakeups&quot; are ignored unless the archaic
2061       // FilterSpuriousWakeups is set false. That flag should be obsoleted.
2062       if (!FilterSpuriousWakeups) break;
2063       if (status == ETIMEDOUT) break;
2064     }
2065     --_nParked;
2066 
2067     if (_event &gt;= 0) {
2068       ret = OS_OK;
</pre>
<hr />
<pre>
2078   }
2079   return OS_OK;
2080 }
2081 
2082 void os::PlatformEvent::unpark() {
2083   // Transitions for _event:
2084   //    0 =&gt; 1 : just return
2085   //    1 =&gt; 1 : just return
2086   //   -1 =&gt; either 0 or 1; must signal target thread
2087   //         That is, we can safely transition _event from -1 to either
2088   //         0 or 1.
2089   // See also: &quot;Semaphores in Plan 9&quot; by Mullender &amp; Cox
2090   //
2091   // Note: Forcing a transition from &quot;-1&quot; to &quot;1&quot; on an unpark() means
2092   // that it will take two back-to-back park() calls for the owning
2093   // thread to block. This has the benefit of forcing a spurious return
2094   // from the first park() call after an unpark() call which will help
2095   // shake out uses of park() and unpark() without checking state conditions
2096   // properly. This spurious return doesn&#39;t manifest itself in any user code
2097   // but only in the correctly written condition checking loops of ObjectMonitor,
<span class="line-modified">2098   // Mutex/Monitor, Thread::muxAcquire and os::sleep</span>
2099 
<span class="line-modified">2100   if (Atomic::xchg(1, &amp;_event) &gt;= 0) return;</span>
2101 
2102   int status = pthread_mutex_lock(_mutex);
2103   assert_status(status == 0, status, &quot;mutex_lock&quot;);
2104   int anyWaiters = _nParked;
2105   assert(anyWaiters == 0 || anyWaiters == 1, &quot;invariant&quot;);
2106   status = pthread_mutex_unlock(_mutex);
2107   assert_status(status == 0, status, &quot;mutex_unlock&quot;);
2108 
2109   // Note that we signal() *after* dropping the lock for &quot;immortal&quot; Events.
2110   // This is safe and avoids a common class of futile wakeups.  In rare
2111   // circumstances this can cause a thread to return prematurely from
2112   // cond_{timed}wait() but the spurious wakeup is benign and the victim
2113   // will simply re-test the condition and re-park itself.
2114   // This provides particular benefit if the underlying platform does not
2115   // provide wait morphing.
2116 
2117   if (anyWaiters != 0) {
2118     status = pthread_cond_signal(_cond);
2119     assert_status(status == 0, status, &quot;cond_signal&quot;);
2120   }
</pre>
<hr />
<pre>
2128   assert_status(status == 0, status, &quot;cond_init rel&quot;);
2129   status = pthread_cond_init(&amp;_cond[ABS_INDEX], NULL);
2130   assert_status(status == 0, status, &quot;cond_init abs&quot;);
2131   status = pthread_mutex_init(_mutex, _mutexAttr);
2132   assert_status(status == 0, status, &quot;mutex_init&quot;);
2133   _cur_index = -1; // mark as unused
2134 }
2135 
2136 // Parker::park decrements count if &gt; 0, else does a condvar wait.  Unpark
2137 // sets count to 1 and signals condvar.  Only one thread ever waits
2138 // on the condvar. Contention seen when trying to park implies that someone
2139 // is unparking you, so don&#39;t wait. And spurious returns are fine, so there
2140 // is no need to track notifications.
2141 
2142 void Parker::park(bool isAbsolute, jlong time) {
2143 
2144   // Optional fast-path check:
2145   // Return immediately if a permit is available.
2146   // We depend on Atomic::xchg() having full barrier semantics
2147   // since we are doing a lock-free update to _counter.
<span class="line-modified">2148   if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;</span>
2149 
2150   Thread* thread = Thread::current();
2151   assert(thread-&gt;is_Java_thread(), &quot;Must be JavaThread&quot;);
2152   JavaThread *jt = (JavaThread *)thread;
2153 
2154   // Optional optimization -- avoid state transitions if there&#39;s
2155   // an interrupt pending.
<span class="line-modified">2156   if (Thread::is_interrupted(thread, false)) {</span>
2157     return;
2158   }
2159 
2160   // Next, demultiplex/decode time arguments
2161   struct timespec absTime;
2162   if (time &lt; 0 || (isAbsolute &amp;&amp; time == 0)) { // don&#39;t wait at all
2163     return;
2164   }
2165   if (time &gt; 0) {
2166     to_abstime(&amp;absTime, time, isAbsolute, false);
2167   }
2168 
2169   // Enter safepoint region
2170   // Beware of deadlocks such as 6317397.
2171   // The per-thread Parker:: mutex is a classic leaf-lock.
2172   // In particular a thread must never block on the Threads_lock while
2173   // holding the Parker:: mutex.  If safepoints are pending both the
2174   // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.
2175   ThreadBlockInVM tbivm(jt);
2176 



2177   // Don&#39;t wait if cannot get lock since interference arises from
<span class="line-modified">2178   // unparking. Also re-check interrupt before trying wait.</span>
<span class="line-modified">2179   if (Thread::is_interrupted(thread, false) ||</span>
<span class="line-removed">2180       pthread_mutex_trylock(_mutex) != 0) {</span>
2181     return;
2182   }
2183 
2184   int status;
2185   if (_counter &gt; 0)  { // no wait needed
2186     _counter = 0;
2187     status = pthread_mutex_unlock(_mutex);
2188     assert_status(status == 0, status, &quot;invariant&quot;);
2189     // Paranoia to ensure our locked and lock-free paths interact
2190     // correctly with each other and Java-level accesses.
2191     OrderAccess::fence();
2192     return;
2193   }
2194 
2195   OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);
2196   jt-&gt;set_suspend_equivalent();
2197   // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
2198 
2199   assert(_cur_index == -1, &quot;invariant&quot;);
2200   if (time == 0) {
</pre>
<hr />
<pre>
2231   // must capture correct index before unlocking
2232   int index = _cur_index;
2233   status = pthread_mutex_unlock(_mutex);
2234   assert_status(status == 0, status, &quot;invariant&quot;);
2235 
2236   // Note that we signal() *after* dropping the lock for &quot;immortal&quot; Events.
2237   // This is safe and avoids a common class of futile wakeups.  In rare
2238   // circumstances this can cause a thread to return prematurely from
2239   // cond_{timed}wait() but the spurious wakeup is benign and the victim
2240   // will simply re-test the condition and re-park itself.
2241   // This provides particular benefit if the underlying platform does not
2242   // provide wait morphing.
2243 
2244   if (s &lt; 1 &amp;&amp; index != -1) {
2245     // thread is definitely parked
2246     status = pthread_cond_signal(&amp;_cond[index]);
2247     assert_status(status == 0, status, &quot;invariant&quot;);
2248   }
2249 }
2250 
<span class="line-modified">2251 // Platform Monitor implementation</span>
2252 
<span class="line-modified">2253 os::PlatformMonitor::PlatformMonitor() {</span>




















































2254   int status = pthread_cond_init(&amp;_cond, _condAttr);
2255   assert_status(status == 0, status, &quot;cond_init&quot;);
<span class="line-modified">2256   status = pthread_mutex_init(&amp;_mutex, _mutexAttr);</span>
































2257   assert_status(status == 0, status, &quot;mutex_init&quot;);
2258 }
2259 










2260 os::PlatformMonitor::~PlatformMonitor() {
2261   int status = pthread_cond_destroy(&amp;_cond);
2262   assert_status(status == 0, status, &quot;cond_destroy&quot;);
<span class="line-removed">2263   status = pthread_mutex_destroy(&amp;_mutex);</span>
<span class="line-removed">2264   assert_status(status == 0, status, &quot;mutex_destroy&quot;);</span>
2265 }
2266 


2267 // Must already be locked
2268 int os::PlatformMonitor::wait(jlong millis) {
2269   assert(millis &gt;= 0, &quot;negative timeout&quot;);
2270   if (millis &gt; 0) {
2271     struct timespec abst;
2272     // We have to watch for overflow when converting millis to nanos,
2273     // but if millis is that large then we will end up limiting to
2274     // MAX_SECS anyway, so just do that here.
2275     if (millis / MILLIUNITS &gt; MAX_SECS) {
2276       millis = jlong(MAX_SECS) * MILLIUNITS;
2277     }
<span class="line-modified">2278     to_abstime(&amp;abst, millis * (NANOUNITS / MILLIUNITS), false, false);</span>
2279 
2280     int ret = OS_TIMEOUT;
<span class="line-modified">2281     int status = pthread_cond_timedwait(&amp;_cond, &amp;_mutex, &amp;abst);</span>
2282     assert_status(status == 0 || status == ETIMEDOUT,
2283                   status, &quot;cond_timedwait&quot;);
2284     if (status == 0) {
2285       ret = OS_OK;
2286     }
2287     return ret;
2288   } else {
<span class="line-modified">2289     int status = pthread_cond_wait(&amp;_cond, &amp;_mutex);</span>
2290     assert_status(status == 0, status, &quot;cond_wait&quot;);
2291     return OS_OK;
2292   }
2293 }
2294 
2295 #endif // !SOLARIS
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;jvm.h&quot;
  26 #include &quot;logging/log.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;os_posix.inline.hpp&quot;
  29 #include &quot;utilities/globalDefinitions.hpp&quot;
  30 #include &quot;runtime/frame.inline.hpp&quot;
  31 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  32 #include &quot;services/memTracker.hpp&quot;
<span class="line-added">  33 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">  34 #include &quot;runtime/orderAccess.hpp&quot;</span>
  35 #include &quot;utilities/align.hpp&quot;
  36 #include &quot;utilities/events.hpp&quot;
  37 #include &quot;utilities/formatBuffer.hpp&quot;
  38 #include &quot;utilities/macros.hpp&quot;
  39 #include &quot;utilities/vmError.hpp&quot;
  40 
  41 #include &lt;dirent.h&gt;
  42 #include &lt;dlfcn.h&gt;
  43 #include &lt;grp.h&gt;
  44 #include &lt;pwd.h&gt;
  45 #include &lt;pthread.h&gt;
  46 #include &lt;signal.h&gt;
  47 #include &lt;sys/mman.h&gt;
  48 #include &lt;sys/resource.h&gt;
  49 #include &lt;sys/utsname.h&gt;
  50 #include &lt;time.h&gt;
  51 #include &lt;unistd.h&gt;
<span class="line-added">  52 #include &lt;utmpx.h&gt;</span>
  53 
  54 // Todo: provide a os::get_max_process_id() or similar. Number of processes
  55 // may have been configured, can be read more accurately from proc fs etc.
  56 #ifndef MAX_PID
  57 #define MAX_PID INT_MAX
  58 #endif
  59 #define IS_VALID_PID(p) (p &gt; 0 &amp;&amp; p &lt; MAX_PID)
  60 
  61 #define ROOT_UID 0
  62 
  63 #ifndef MAP_ANONYMOUS
  64   #define MAP_ANONYMOUS MAP_ANON
  65 #endif
  66 
  67 #define check_with_errno(check_type, cond, msg)                             \
  68   do {                                                                      \
  69     int err = errno;                                                        \
  70     check_type(cond, &quot;%s; error=&#39;%s&#39; (errno=%s)&quot;, msg, os::strerror(err),   \
  71                os::errno_name(err));                                        \
  72 } while (false)
</pre>
<hr />
<pre>
 153   return (::unsetenv(name) == 0);
 154 }
 155 
 156 int os::get_last_error() {
 157   return errno;
 158 }
 159 
 160 size_t os::lasterror(char *buf, size_t len) {
 161   if (errno == 0)  return 0;
 162 
 163   const char *s = os::strerror(errno);
 164   size_t n = ::strlen(s);
 165   if (n &gt;= len) {
 166     n = len - 1;
 167   }
 168   ::strncpy(buf, s, n);
 169   buf[n] = &#39;\0&#39;;
 170   return n;
 171 }
 172 





 173 void os::wait_for_keypress_at_exit(void) {
 174   // don&#39;t do anything on posix platforms
 175   return;
 176 }
 177 
 178 int os::create_file_for_heap(const char* dir) {
<span class="line-added"> 179   int fd;</span>
 180 
<span class="line-modified"> 181 #if defined(LINUX) &amp;&amp; defined(O_TMPFILE)</span>
<span class="line-modified"> 182   char* native_dir = os::strdup(dir);</span>
<span class="line-modified"> 183   if (native_dir == NULL) {</span>
<span class="line-modified"> 184     vm_exit_during_initialization(err_msg(&quot;strdup failed during creation of backing file for heap (%s)&quot;, os::strerror(errno)));</span>


 185     return -1;
 186   }
<span class="line-modified"> 187   os::native_path(native_dir);</span>
<span class="line-modified"> 188   fd = os::open(dir, O_TMPFILE | O_RDWR, S_IRUSR | S_IWUSR);</span>
<span class="line-added"> 189   os::free(native_dir);</span>
<span class="line-added"> 190 </span>
<span class="line-added"> 191   if (fd == -1)</span>
<span class="line-added"> 192 #endif</span>
<span class="line-added"> 193   {</span>
<span class="line-added"> 194     const char name_template[] = &quot;/jvmheap.XXXXXX&quot;;</span>
<span class="line-added"> 195 </span>
<span class="line-added"> 196     size_t fullname_len = strlen(dir) + strlen(name_template);</span>
<span class="line-added"> 197     char *fullname = (char*)os::malloc(fullname_len + 1, mtInternal);</span>
<span class="line-added"> 198     if (fullname == NULL) {</span>
<span class="line-added"> 199       vm_exit_during_initialization(err_msg(&quot;Malloc failed during creation of backing file for heap (%s)&quot;, os::strerror(errno)));</span>
<span class="line-added"> 200       return -1;</span>
<span class="line-added"> 201     }</span>
<span class="line-added"> 202     int n = snprintf(fullname, fullname_len + 1, &quot;%s%s&quot;, dir, name_template);</span>
<span class="line-added"> 203     assert((size_t)n == fullname_len, &quot;Unexpected number of characters in string&quot;);</span>
 204 
<span class="line-modified"> 205     os::native_path(fullname);</span>
 206 
<span class="line-modified"> 207     // create a new file.</span>
<span class="line-modified"> 208     fd = mkstemp(fullname);</span>
 209 
<span class="line-modified"> 210     if (fd &lt; 0) {</span>
<span class="line-modified"> 211       warning(&quot;Could not create file for heap with template %s&quot;, fullname);</span>
<span class="line-added"> 212       os::free(fullname);</span>
<span class="line-added"> 213       return -1;</span>
<span class="line-added"> 214     } else {</span>
<span class="line-added"> 215       // delete the name from the filesystem. When &#39;fd&#39; is closed, the file (and space) will be deleted.</span>
<span class="line-added"> 216       int ret = unlink(fullname);</span>
<span class="line-added"> 217       assert_with_errno(ret == 0, &quot;unlink returned error&quot;);</span>
<span class="line-added"> 218     }</span>
 219 


 220     os::free(fullname);

 221   }
 222 





 223   return fd;
 224 }
 225 
 226 static char* reserve_mmapped_memory(size_t bytes, char* requested_addr) {
 227   char * addr;
 228   int flags = MAP_PRIVATE NOT_AIX( | MAP_NORESERVE ) | MAP_ANONYMOUS;
 229   if (requested_addr != NULL) {
 230     assert((uintptr_t)requested_addr % os::vm_page_size() == 0, &quot;Requested address should be aligned to OS page size&quot;);
 231     flags |= MAP_FIXED;
 232   }
 233 
 234   // Map reserved/uncommitted pages PROT_NONE so we fail early if we
 235   // touch an uncommitted page. Otherwise, the read/write might
 236   // succeed if we have enough swap space to back the physical page.
 237   addr = (char*)::mmap(requested_addr, bytes, PROT_NONE,
 238                        flags, -1, 0);
 239 
 240   if (addr != MAP_FAILED) {
 241     MemTracker::record_virtual_memory_reserve((address)addr, bytes, CALLER_PC);
 242     return addr;
</pre>
<hr />
<pre>
 367   int result = ::vsnprintf(buf, len, fmt, args);
 368   // If an encoding error occurred (result &lt; 0) then it&#39;s not clear
 369   // whether the buffer is NUL terminated, so ensure it is.
 370   if ((result &lt; 0) &amp;&amp; (len &gt; 0)) {
 371     buf[len - 1] = &#39;\0&#39;;
 372   }
 373   return result;
 374 }
 375 
 376 int os::get_fileno(FILE* fp) {
 377   return NOT_AIX(::)fileno(fp);
 378 }
 379 
 380 struct tm* os::gmtime_pd(const time_t* clock, struct tm*  res) {
 381   return gmtime_r(clock, res);
 382 }
 383 
 384 void os::Posix::print_load_average(outputStream* st) {
 385   st-&gt;print(&quot;load average:&quot;);
 386   double loadavg[3];
<span class="line-modified"> 387   int res = os::loadavg(loadavg, 3);</span>
<span class="line-modified"> 388   if (res != -1) {</span>
<span class="line-added"> 389     st-&gt;print(&quot;%0.02f %0.02f %0.02f&quot;, loadavg[0], loadavg[1], loadavg[2]);</span>
<span class="line-added"> 390   } else {</span>
<span class="line-added"> 391     st-&gt;print(&quot; Unavailable&quot;);</span>
<span class="line-added"> 392   }</span>
 393   st-&gt;cr();
 394 }
 395 
<span class="line-added"> 396 // boot/uptime information;</span>
<span class="line-added"> 397 // unfortunately it does not work on macOS and Linux because the utx chain has no entry</span>
<span class="line-added"> 398 // for reboot at least on my test machines</span>
<span class="line-added"> 399 void os::Posix::print_uptime_info(outputStream* st) {</span>
<span class="line-added"> 400   int bootsec = -1;</span>
<span class="line-added"> 401   int currsec = time(NULL);</span>
<span class="line-added"> 402   struct utmpx* ent;</span>
<span class="line-added"> 403   setutxent();</span>
<span class="line-added"> 404   while ((ent = getutxent())) {</span>
<span class="line-added"> 405     if (!strcmp(&quot;system boot&quot;, ent-&gt;ut_line)) {</span>
<span class="line-added"> 406       bootsec = ent-&gt;ut_tv.tv_sec;</span>
<span class="line-added"> 407       break;</span>
<span class="line-added"> 408     }</span>
<span class="line-added"> 409   }</span>
<span class="line-added"> 410 </span>
<span class="line-added"> 411   if (bootsec != -1) {</span>
<span class="line-added"> 412     os::print_dhm(st, &quot;OS uptime:&quot;, (long) (currsec-bootsec));</span>
<span class="line-added"> 413   }</span>
<span class="line-added"> 414 }</span>
<span class="line-added"> 415 </span>
<span class="line-added"> 416 </span>
 417 void os::Posix::print_rlimit_info(outputStream* st) {
 418   st-&gt;print(&quot;rlimit:&quot;);
 419   struct rlimit rlim;
 420 
 421   st-&gt;print(&quot; STACK &quot;);
 422   getrlimit(RLIMIT_STACK, &amp;rlim);
 423   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 424   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 425 
 426   st-&gt;print(&quot;, CORE &quot;);
 427   getrlimit(RLIMIT_CORE, &amp;rlim);
 428   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 429   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 430 
 431   // Isn&#39;t there on solaris
 432 #if defined(AIX)
 433   st-&gt;print(&quot;, NPROC &quot;);
 434   st-&gt;print(&quot;%d&quot;, sysconf(_SC_CHILD_MAX));
<span class="line-added"> 435   st-&gt;print(&quot;, THREADS &quot;);</span>
<span class="line-added"> 436   getrlimit(RLIMIT_THREADS, &amp;rlim);</span>
<span class="line-added"> 437   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);</span>
<span class="line-added"> 438   else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));</span>
 439 #elif !defined(SOLARIS)
 440   st-&gt;print(&quot;, NPROC &quot;);
 441   getrlimit(RLIMIT_NPROC, &amp;rlim);
 442   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 443   else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));
 444 #endif
 445 
 446   st-&gt;print(&quot;, NOFILE &quot;);
 447   getrlimit(RLIMIT_NOFILE, &amp;rlim);
 448   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 449   else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));
 450 
 451   st-&gt;print(&quot;, AS &quot;);
 452   getrlimit(RLIMIT_AS, &amp;rlim);
 453   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 454   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 455 
<span class="line-added"> 456   st-&gt;print(&quot;, CPU &quot;);</span>
<span class="line-added"> 457   getrlimit(RLIMIT_CPU, &amp;rlim);</span>
<span class="line-added"> 458   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);</span>
<span class="line-added"> 459   else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));</span>
<span class="line-added"> 460 </span>
 461   st-&gt;print(&quot;, DATA &quot;);
 462   getrlimit(RLIMIT_DATA, &amp;rlim);
 463   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 464   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 465 
 466   st-&gt;print(&quot;, FSIZE &quot;);
 467   getrlimit(RLIMIT_FSIZE, &amp;rlim);
 468   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 469   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 470 
 471   st-&gt;cr();
 472 }
 473 
 474 void os::Posix::print_uname_info(outputStream* st) {
 475   // kernel
 476   st-&gt;print(&quot;uname:&quot;);
 477   struct utsname name;
 478   uname(&amp;name);
 479   st-&gt;print(&quot;%s &quot;, name.sysname);
 480 #ifdef ASSERT
</pre>
<hr />
<pre>
 652       if (strlen(lib_name) &lt;= (prefix_len + suffix_len)) {
 653         return NULL;
 654       }
 655       lib_name += prefix_len;
 656       name_len = strlen(lib_name) - suffix_len;
 657     }
 658   }
 659   len = (lib_name != NULL ? name_len : 0) + strlen(sym_name) + 2;
 660   agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);
 661   if (agent_entry_name == NULL) {
 662     return NULL;
 663   }
 664   strcpy(agent_entry_name, sym_name);
 665   if (lib_name != NULL) {
 666     strcat(agent_entry_name, &quot;_&quot;);
 667     strncat(agent_entry_name, lib_name, name_len);
 668   }
 669   return agent_entry_name;
 670 }
 671 








































































 672 
 673 void os::naked_short_nanosleep(jlong ns) {
 674   struct timespec req;
 675   assert(ns &gt; -1 &amp;&amp; ns &lt; NANOUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
 676   req.tv_sec = 0;
 677   req.tv_nsec = ns;
 678   ::nanosleep(&amp;req, NULL);
 679   return;
 680 }
 681 
 682 void os::naked_short_sleep(jlong ms) {
 683   assert(ms &lt; MILLIUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
<span class="line-modified"> 684   os::naked_short_nanosleep(millis_to_nanos(ms));</span>
 685   return;
 686 }
 687 























































 688 static const struct {
 689   int sig; const char* name;
 690 }
 691  g_signal_info[] =
 692   {
 693   {  SIGABRT,     &quot;SIGABRT&quot; },
 694 #ifdef SIGAIO
 695   {  SIGAIO,      &quot;SIGAIO&quot; },
 696 #endif
 697   {  SIGALRM,     &quot;SIGALRM&quot; },
 698 #ifdef SIGALRM1
 699   {  SIGALRM1,    &quot;SIGALRM1&quot; },
 700 #endif
 701   {  SIGBUS,      &quot;SIGBUS&quot; },
 702 #ifdef SIGCANCEL
 703   {  SIGCANCEL,   &quot;SIGCANCEL&quot; },
 704 #endif
 705   {  SIGCHLD,     &quot;SIGCHLD&quot; },
 706 #ifdef SIGCLD
 707   {  SIGCLD,      &quot;SIGCLD&quot; },
</pre>
<hr />
<pre>
 714   {  SIGDANGER,   &quot;SIGDANGER&quot; },
 715 #endif
 716 #ifdef SIGDIL
 717   {  SIGDIL,      &quot;SIGDIL&quot; },
 718 #endif
 719 #ifdef SIGEMT
 720   {  SIGEMT,      &quot;SIGEMT&quot; },
 721 #endif
 722   {  SIGFPE,      &quot;SIGFPE&quot; },
 723 #ifdef SIGFREEZE
 724   {  SIGFREEZE,   &quot;SIGFREEZE&quot; },
 725 #endif
 726 #ifdef SIGGFAULT
 727   {  SIGGFAULT,   &quot;SIGGFAULT&quot; },
 728 #endif
 729 #ifdef SIGGRANT
 730   {  SIGGRANT,    &quot;SIGGRANT&quot; },
 731 #endif
 732   {  SIGHUP,      &quot;SIGHUP&quot; },
 733   {  SIGILL,      &quot;SIGILL&quot; },
<span class="line-added"> 734 #ifdef SIGINFO</span>
<span class="line-added"> 735   {  SIGINFO,     &quot;SIGINFO&quot; },</span>
<span class="line-added"> 736 #endif</span>
 737   {  SIGINT,      &quot;SIGINT&quot; },
 738 #ifdef SIGIO
 739   {  SIGIO,       &quot;SIGIO&quot; },
 740 #endif
 741 #ifdef SIGIOINT
 742   {  SIGIOINT,    &quot;SIGIOINT&quot; },
 743 #endif
 744 #ifdef SIGIOT
 745 // SIGIOT is there for BSD compatibility, but on most Unices just a
 746 // synonym for SIGABRT. The result should be &quot;SIGABRT&quot;, not
 747 // &quot;SIGIOT&quot;.
 748 #if (SIGIOT != SIGABRT )
 749   {  SIGIOT,      &quot;SIGIOT&quot; },
 750 #endif
 751 #endif
 752 #ifdef SIGKAP
 753   {  SIGKAP,      &quot;SIGKAP&quot; },
 754 #endif
 755   {  SIGKILL,     &quot;SIGKILL&quot; },
 756 #ifdef SIGLOST
</pre>
<hr />
<pre>
1354       outbuf[outbuflen - 1] = &#39;\0&#39;;
1355       p = ::realpath(filename, outbuf);
1356       if (p != NULL) {
1357         guarantee(outbuf[outbuflen - 1] == &#39;\0&#39;, &quot;realpath buffer overwrite detected.&quot;);
1358         result = p;
1359       }
1360     }
1361   }
1362   return result;
1363 
1364 }
1365 
1366 int os::stat(const char *path, struct stat *sbuf) {
1367   return ::stat(path, sbuf);
1368 }
1369 
1370 char * os::native_path(char *path) {
1371   return path;
1372 }
1373 
<span class="line-added">1374 bool os::same_files(const char* file1, const char* file2) {</span>
<span class="line-added">1375   if (strcmp(file1, file2) == 0) {</span>
<span class="line-added">1376     return true;</span>
<span class="line-added">1377   }</span>
<span class="line-added">1378 </span>
<span class="line-added">1379   bool is_same = false;</span>
<span class="line-added">1380   struct stat st1;</span>
<span class="line-added">1381   struct stat st2;</span>
<span class="line-added">1382 </span>
<span class="line-added">1383   if (os::stat(file1, &amp;st1) &lt; 0) {</span>
<span class="line-added">1384     return false;</span>
<span class="line-added">1385   }</span>
<span class="line-added">1386 </span>
<span class="line-added">1387   if (os::stat(file2, &amp;st2) &lt; 0) {</span>
<span class="line-added">1388     return false;</span>
<span class="line-added">1389   }</span>
<span class="line-added">1390 </span>
<span class="line-added">1391   if (st1.st_dev == st2.st_dev &amp;&amp; st1.st_ino == st2.st_ino) {</span>
<span class="line-added">1392     // same files</span>
<span class="line-added">1393     is_same = true;</span>
<span class="line-added">1394   }</span>
<span class="line-added">1395   return is_same;</span>
<span class="line-added">1396 }</span>
<span class="line-added">1397 </span>
1398 // Check minimum allowable stack sizes for thread creation and to initialize
1399 // the java system classes, including StackOverflowError - depends on page
1400 // size.
1401 // The space needed for frames during startup is platform dependent. It
1402 // depends on word size, platform calling conventions, C frame layout and
1403 // interpreter/C1/C2 design decisions. Therefore this is given in a
1404 // platform (os/cpu) dependent constant.
1405 // To this, space for guard mechanisms is added, which depends on the
1406 // page size which again depends on the concrete system the VM is running
1407 // on. Space for libc guard pages is not included in this size.
1408 jint os::Posix::set_minimum_stack_sizes() {
1409   size_t os_min_stack_allowed = SOLARIS_ONLY(thr_min_stack()) NOT_SOLARIS(PTHREAD_STACK_MIN);
1410 
1411   _java_thread_min_stack_allowed = _java_thread_min_stack_allowed +
1412                                    JavaThread::stack_guard_zone_size() +
1413                                    JavaThread::stack_shadow_zone_size();
1414 
1415   _java_thread_min_stack_allowed = align_up(_java_thread_min_stack_allowed, vm_page_size());
1416   _java_thread_min_stack_allowed = MAX2(_java_thread_min_stack_allowed, os_min_stack_allowed);
1417 
</pre>
<hr />
<pre>
1599 // but otherwise whatever default is used by the platform - generally the
1600 // time-of-day clock.
1601 static pthread_condattr_t _condAttr[1];
1602 
1603 // Shared mutexattr to explicitly set the type to PTHREAD_MUTEX_NORMAL as not
1604 // all systems (e.g. FreeBSD) map the default to &quot;normal&quot;.
1605 static pthread_mutexattr_t _mutexAttr[1];
1606 
1607 // common basic initialization that is always supported
1608 static void pthread_init_common(void) {
1609   int status;
1610   if ((status = pthread_condattr_init(_condAttr)) != 0) {
1611     fatal(&quot;pthread_condattr_init: %s&quot;, os::strerror(status));
1612   }
1613   if ((status = pthread_mutexattr_init(_mutexAttr)) != 0) {
1614     fatal(&quot;pthread_mutexattr_init: %s&quot;, os::strerror(status));
1615   }
1616   if ((status = pthread_mutexattr_settype(_mutexAttr, PTHREAD_MUTEX_NORMAL)) != 0) {
1617     fatal(&quot;pthread_mutexattr_settype: %s&quot;, os::strerror(status));
1618   }
<span class="line-added">1619   // Solaris has it&#39;s own PlatformMutex, distinct from the one for POSIX.</span>
<span class="line-added">1620   NOT_SOLARIS(os::PlatformMutex::init();)</span>
1621 }
1622 
1623 #ifndef SOLARIS
1624 sigset_t sigs;
1625 struct sigaction sigact[NSIG];
1626 
1627 struct sigaction* os::Posix::get_preinstalled_handler(int sig) {
1628   if (sigismember(&amp;sigs, sig)) {
1629     return &amp;sigact[sig];
1630   }
1631   return NULL;
1632 }
1633 
1634 void os::Posix::save_preinstalled_handler(int sig, struct sigaction&amp; oldAct) {
1635   assert(sig &gt; 0 &amp;&amp; sig &lt; NSIG, &quot;vm signal out of expected range&quot;);
1636   sigact[sig] = oldAct;
1637   sigaddset(&amp;sigs, sig);
1638 }
1639 #endif
1640 
</pre>
<hr />
<pre>
1816     }
1817     abstime-&gt;tv_nsec = nanos;
1818   }
1819 }
1820 
1821 // Unpack the given deadline in milliseconds since the epoch, into the given timespec.
1822 // The current time in seconds is also passed in to enforce an upper bound as discussed above.
1823 // This is only used with gettimeofday, when clock_gettime is not available.
1824 static void unpack_abs_time(timespec* abstime, jlong deadline, jlong now_sec) {
1825   time_t max_secs = now_sec + MAX_SECS;
1826 
1827   jlong seconds = deadline / MILLIUNITS;
1828   jlong millis = deadline % MILLIUNITS;
1829 
1830   if (seconds &gt;= max_secs) {
1831     // Absolute seconds exceeds allowed max, so pin to max_secs.
1832     abstime-&gt;tv_sec = max_secs;
1833     abstime-&gt;tv_nsec = 0;
1834   } else {
1835     abstime-&gt;tv_sec = seconds;
<span class="line-modified">1836     abstime-&gt;tv_nsec = millis_to_nanos(millis);</span>
1837   }
1838 }
1839 
<span class="line-modified">1840 static jlong millis_to_nanos_bounded(jlong millis) {</span>
1841   // We have to watch for overflow when converting millis to nanos,
1842   // but if millis is that large then we will end up limiting to
1843   // MAX_SECS anyway, so just do that here.
1844   if (millis / MILLIUNITS &gt; MAX_SECS) {
1845     millis = jlong(MAX_SECS) * MILLIUNITS;
1846   }
<span class="line-modified">1847   return millis_to_nanos(millis);</span>
1848 }
1849 
1850 static void to_abstime(timespec* abstime, jlong timeout,
1851                        bool isAbsolute, bool isRealtime) {
1852   DEBUG_ONLY(int max_secs = MAX_SECS;)
1853 
1854   if (timeout &lt; 0) {
1855     timeout = 0;
1856   }
1857 
1858 #ifdef SUPPORTS_CLOCK_MONOTONIC
1859 
1860   clockid_t clock = CLOCK_MONOTONIC;
1861   // need to ensure we have a runtime check for clock_gettime support
1862   if (!isAbsolute &amp;&amp; os::Posix::supports_monotonic_clock()) {
1863     if (!_use_clock_monotonic_condattr || isRealtime) {
1864       clock = CLOCK_REALTIME;
1865     }
1866     struct timespec now;
1867     int status = os::Posix::clock_gettime(clock, &amp;now);
</pre>
<hr />
<pre>
1880     struct timeval now;
1881     int status = gettimeofday(&amp;now, NULL);
1882     assert_status(status == 0, errno, &quot;gettimeofday&quot;);
1883     if (isAbsolute) {
1884       unpack_abs_time(abstime, timeout, now.tv_sec);
1885     } else {
1886       calc_rel_time(abstime, timeout, now.tv_sec, now.tv_usec, MICROUNITS);
1887     }
1888     DEBUG_ONLY(max_secs += now.tv_sec;)
1889   }
1890 
1891   assert(abstime-&gt;tv_sec &gt;= 0, &quot;tv_sec &lt; 0&quot;);
1892   assert(abstime-&gt;tv_sec &lt;= max_secs, &quot;tv_sec &gt; max_secs&quot;);
1893   assert(abstime-&gt;tv_nsec &gt;= 0, &quot;tv_nsec &lt; 0&quot;);
1894   assert(abstime-&gt;tv_nsec &lt; NANOUNITS, &quot;tv_nsec &gt;= NANOUNITS&quot;);
1895 }
1896 
1897 // Create an absolute time &#39;millis&#39; milliseconds in the future, using the
1898 // real-time (time-of-day) clock. Used by PosixSemaphore.
1899 void os::Posix::to_RTC_abstime(timespec* abstime, int64_t millis) {
<span class="line-modified">1900   to_abstime(abstime, millis_to_nanos_bounded(millis),</span>
1901              false /* not absolute */,
1902              true  /* use real-time clock */);
1903 }
1904 
1905 // Shared pthread_mutex/cond based PlatformEvent implementation.
1906 // Not currently usable by Solaris.
1907 
1908 #ifndef SOLARIS
1909 
1910 // PlatformEvent
1911 //
1912 // Assumption:
1913 //    Only one parker can exist on an event, which is why we allocate
1914 //    them per-thread. Multiple unparkers can coexist.
1915 //
1916 // _event serves as a restricted-range semaphore.
1917 //   -1 : thread is blocked, i.e. there is a waiter
1918 //    0 : neutral: thread is running or ready,
1919 //        could have been signaled after a wait started
1920 //    1 : signaled - thread is running or ready
</pre>
<hr />
<pre>
1929   assert_status(status == 0, status, &quot;mutex_init&quot;);
1930   _event   = 0;
1931   _nParked = 0;
1932 }
1933 
1934 void os::PlatformEvent::park() {       // AKA &quot;down()&quot;
1935   // Transitions for _event:
1936   //   -1 =&gt; -1 : illegal
1937   //    1 =&gt;  0 : pass - return immediately
1938   //    0 =&gt; -1 : block; then set _event to 0 before returning
1939 
1940   // Invariant: Only the thread associated with the PlatformEvent
1941   // may call park().
1942   assert(_nParked == 0, &quot;invariant&quot;);
1943 
1944   int v;
1945 
1946   // atomically decrement _event
1947   for (;;) {
1948     v = _event;
<span class="line-modified">1949     if (Atomic::cmpxchg(&amp;_event, v, v - 1) == v) break;</span>
1950   }
1951   guarantee(v &gt;= 0, &quot;invariant&quot;);
1952 
1953   if (v == 0) { // Do this the hard way by blocking ...
1954     int status = pthread_mutex_lock(_mutex);
1955     assert_status(status == 0, status, &quot;mutex_lock&quot;);
1956     guarantee(_nParked == 0, &quot;invariant&quot;);
1957     ++_nParked;
1958     while (_event &lt; 0) {
1959       // OS-level &quot;spurious wakeups&quot; are ignored
1960       status = pthread_cond_wait(_cond, _mutex);
1961       assert_status(status == 0, status, &quot;cond_wait&quot;);
1962     }
1963     --_nParked;
1964 
1965     _event = 0;
1966     status = pthread_mutex_unlock(_mutex);
1967     assert_status(status == 0, status, &quot;mutex_unlock&quot;);
1968     // Paranoia to ensure our locked and lock-free paths interact
1969     // correctly with each other.
1970     OrderAccess::fence();
1971   }
1972   guarantee(_event &gt;= 0, &quot;invariant&quot;);
1973 }
1974 
1975 int os::PlatformEvent::park(jlong millis) {
1976   // Transitions for _event:
1977   //   -1 =&gt; -1 : illegal
1978   //    1 =&gt;  0 : pass - return immediately
1979   //    0 =&gt; -1 : block; then set _event to 0 before returning
1980 
1981   // Invariant: Only the thread associated with the Event/PlatformEvent
1982   // may call park().
1983   assert(_nParked == 0, &quot;invariant&quot;);
1984 
1985   int v;
1986   // atomically decrement _event
1987   for (;;) {
1988     v = _event;
<span class="line-modified">1989     if (Atomic::cmpxchg(&amp;_event, v, v - 1) == v) break;</span>
1990   }
1991   guarantee(v &gt;= 0, &quot;invariant&quot;);
1992 
1993   if (v == 0) { // Do this the hard way by blocking ...
1994     struct timespec abst;
<span class="line-modified">1995     to_abstime(&amp;abst, millis_to_nanos_bounded(millis), false, false);</span>
1996 
1997     int ret = OS_TIMEOUT;
1998     int status = pthread_mutex_lock(_mutex);
1999     assert_status(status == 0, status, &quot;mutex_lock&quot;);
2000     guarantee(_nParked == 0, &quot;invariant&quot;);
2001     ++_nParked;
2002 
2003     while (_event &lt; 0) {
2004       status = pthread_cond_timedwait(_cond, _mutex, &amp;abst);
2005       assert_status(status == 0 || status == ETIMEDOUT,
2006                     status, &quot;cond_timedwait&quot;);
2007       // OS-level &quot;spurious wakeups&quot; are ignored unless the archaic
2008       // FilterSpuriousWakeups is set false. That flag should be obsoleted.
2009       if (!FilterSpuriousWakeups) break;
2010       if (status == ETIMEDOUT) break;
2011     }
2012     --_nParked;
2013 
2014     if (_event &gt;= 0) {
2015       ret = OS_OK;
</pre>
<hr />
<pre>
2025   }
2026   return OS_OK;
2027 }
2028 
2029 void os::PlatformEvent::unpark() {
2030   // Transitions for _event:
2031   //    0 =&gt; 1 : just return
2032   //    1 =&gt; 1 : just return
2033   //   -1 =&gt; either 0 or 1; must signal target thread
2034   //         That is, we can safely transition _event from -1 to either
2035   //         0 or 1.
2036   // See also: &quot;Semaphores in Plan 9&quot; by Mullender &amp; Cox
2037   //
2038   // Note: Forcing a transition from &quot;-1&quot; to &quot;1&quot; on an unpark() means
2039   // that it will take two back-to-back park() calls for the owning
2040   // thread to block. This has the benefit of forcing a spurious return
2041   // from the first park() call after an unpark() call which will help
2042   // shake out uses of park() and unpark() without checking state conditions
2043   // properly. This spurious return doesn&#39;t manifest itself in any user code
2044   // but only in the correctly written condition checking loops of ObjectMonitor,
<span class="line-modified">2045   // Mutex/Monitor, Thread::muxAcquire and JavaThread::sleep</span>
2046 
<span class="line-modified">2047   if (Atomic::xchg(&amp;_event, 1) &gt;= 0) return;</span>
2048 
2049   int status = pthread_mutex_lock(_mutex);
2050   assert_status(status == 0, status, &quot;mutex_lock&quot;);
2051   int anyWaiters = _nParked;
2052   assert(anyWaiters == 0 || anyWaiters == 1, &quot;invariant&quot;);
2053   status = pthread_mutex_unlock(_mutex);
2054   assert_status(status == 0, status, &quot;mutex_unlock&quot;);
2055 
2056   // Note that we signal() *after* dropping the lock for &quot;immortal&quot; Events.
2057   // This is safe and avoids a common class of futile wakeups.  In rare
2058   // circumstances this can cause a thread to return prematurely from
2059   // cond_{timed}wait() but the spurious wakeup is benign and the victim
2060   // will simply re-test the condition and re-park itself.
2061   // This provides particular benefit if the underlying platform does not
2062   // provide wait morphing.
2063 
2064   if (anyWaiters != 0) {
2065     status = pthread_cond_signal(_cond);
2066     assert_status(status == 0, status, &quot;cond_signal&quot;);
2067   }
</pre>
<hr />
<pre>
2075   assert_status(status == 0, status, &quot;cond_init rel&quot;);
2076   status = pthread_cond_init(&amp;_cond[ABS_INDEX], NULL);
2077   assert_status(status == 0, status, &quot;cond_init abs&quot;);
2078   status = pthread_mutex_init(_mutex, _mutexAttr);
2079   assert_status(status == 0, status, &quot;mutex_init&quot;);
2080   _cur_index = -1; // mark as unused
2081 }
2082 
2083 // Parker::park decrements count if &gt; 0, else does a condvar wait.  Unpark
2084 // sets count to 1 and signals condvar.  Only one thread ever waits
2085 // on the condvar. Contention seen when trying to park implies that someone
2086 // is unparking you, so don&#39;t wait. And spurious returns are fine, so there
2087 // is no need to track notifications.
2088 
2089 void Parker::park(bool isAbsolute, jlong time) {
2090 
2091   // Optional fast-path check:
2092   // Return immediately if a permit is available.
2093   // We depend on Atomic::xchg() having full barrier semantics
2094   // since we are doing a lock-free update to _counter.
<span class="line-modified">2095   if (Atomic::xchg(&amp;_counter, 0) &gt; 0) return;</span>
2096 
2097   Thread* thread = Thread::current();
2098   assert(thread-&gt;is_Java_thread(), &quot;Must be JavaThread&quot;);
2099   JavaThread *jt = (JavaThread *)thread;
2100 
2101   // Optional optimization -- avoid state transitions if there&#39;s
2102   // an interrupt pending.
<span class="line-modified">2103   if (jt-&gt;is_interrupted(false)) {</span>
2104     return;
2105   }
2106 
2107   // Next, demultiplex/decode time arguments
2108   struct timespec absTime;
2109   if (time &lt; 0 || (isAbsolute &amp;&amp; time == 0)) { // don&#39;t wait at all
2110     return;
2111   }
2112   if (time &gt; 0) {
2113     to_abstime(&amp;absTime, time, isAbsolute, false);
2114   }
2115 
2116   // Enter safepoint region
2117   // Beware of deadlocks such as 6317397.
2118   // The per-thread Parker:: mutex is a classic leaf-lock.
2119   // In particular a thread must never block on the Threads_lock while
2120   // holding the Parker:: mutex.  If safepoints are pending both the
2121   // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.
2122   ThreadBlockInVM tbivm(jt);
2123 
<span class="line-added">2124   // Can&#39;t access interrupt state now that we are _thread_blocked. If we&#39;ve</span>
<span class="line-added">2125   // been interrupted since we checked above then _counter will be &gt; 0.</span>
<span class="line-added">2126 </span>
2127   // Don&#39;t wait if cannot get lock since interference arises from
<span class="line-modified">2128   // unparking.</span>
<span class="line-modified">2129   if (pthread_mutex_trylock(_mutex) != 0) {</span>

2130     return;
2131   }
2132 
2133   int status;
2134   if (_counter &gt; 0)  { // no wait needed
2135     _counter = 0;
2136     status = pthread_mutex_unlock(_mutex);
2137     assert_status(status == 0, status, &quot;invariant&quot;);
2138     // Paranoia to ensure our locked and lock-free paths interact
2139     // correctly with each other and Java-level accesses.
2140     OrderAccess::fence();
2141     return;
2142   }
2143 
2144   OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);
2145   jt-&gt;set_suspend_equivalent();
2146   // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
2147 
2148   assert(_cur_index == -1, &quot;invariant&quot;);
2149   if (time == 0) {
</pre>
<hr />
<pre>
2180   // must capture correct index before unlocking
2181   int index = _cur_index;
2182   status = pthread_mutex_unlock(_mutex);
2183   assert_status(status == 0, status, &quot;invariant&quot;);
2184 
2185   // Note that we signal() *after* dropping the lock for &quot;immortal&quot; Events.
2186   // This is safe and avoids a common class of futile wakeups.  In rare
2187   // circumstances this can cause a thread to return prematurely from
2188   // cond_{timed}wait() but the spurious wakeup is benign and the victim
2189   // will simply re-test the condition and re-park itself.
2190   // This provides particular benefit if the underlying platform does not
2191   // provide wait morphing.
2192 
2193   if (s &lt; 1 &amp;&amp; index != -1) {
2194     // thread is definitely parked
2195     status = pthread_cond_signal(&amp;_cond[index]);
2196     assert_status(status == 0, status, &quot;invariant&quot;);
2197   }
2198 }
2199 
<span class="line-modified">2200 // Platform Mutex/Monitor implementation</span>
2201 
<span class="line-modified">2202 #if PLATFORM_MONITOR_IMPL_INDIRECT</span>
<span class="line-added">2203 </span>
<span class="line-added">2204 os::PlatformMutex::Mutex::Mutex() : _next(NULL) {</span>
<span class="line-added">2205   int status = pthread_mutex_init(&amp;_mutex, _mutexAttr);</span>
<span class="line-added">2206   assert_status(status == 0, status, &quot;mutex_init&quot;);</span>
<span class="line-added">2207 }</span>
<span class="line-added">2208 </span>
<span class="line-added">2209 os::PlatformMutex::Mutex::~Mutex() {</span>
<span class="line-added">2210   int status = pthread_mutex_destroy(&amp;_mutex);</span>
<span class="line-added">2211   assert_status(status == 0, status, &quot;mutex_destroy&quot;);</span>
<span class="line-added">2212 }</span>
<span class="line-added">2213 </span>
<span class="line-added">2214 pthread_mutex_t os::PlatformMutex::_freelist_lock;</span>
<span class="line-added">2215 os::PlatformMutex::Mutex* os::PlatformMutex::_mutex_freelist = NULL;</span>
<span class="line-added">2216 </span>
<span class="line-added">2217 void os::PlatformMutex::init() {</span>
<span class="line-added">2218   int status = pthread_mutex_init(&amp;_freelist_lock, _mutexAttr);</span>
<span class="line-added">2219   assert_status(status == 0, status, &quot;freelist lock init&quot;);</span>
<span class="line-added">2220 }</span>
<span class="line-added">2221 </span>
<span class="line-added">2222 struct os::PlatformMutex::WithFreeListLocked : public StackObj {</span>
<span class="line-added">2223   WithFreeListLocked() {</span>
<span class="line-added">2224     int status = pthread_mutex_lock(&amp;_freelist_lock);</span>
<span class="line-added">2225     assert_status(status == 0, status, &quot;freelist lock&quot;);</span>
<span class="line-added">2226   }</span>
<span class="line-added">2227 </span>
<span class="line-added">2228   ~WithFreeListLocked() {</span>
<span class="line-added">2229     int status = pthread_mutex_unlock(&amp;_freelist_lock);</span>
<span class="line-added">2230     assert_status(status == 0, status, &quot;freelist unlock&quot;);</span>
<span class="line-added">2231   }</span>
<span class="line-added">2232 };</span>
<span class="line-added">2233 </span>
<span class="line-added">2234 os::PlatformMutex::PlatformMutex() {</span>
<span class="line-added">2235   {</span>
<span class="line-added">2236     WithFreeListLocked wfl;</span>
<span class="line-added">2237     _impl = _mutex_freelist;</span>
<span class="line-added">2238     if (_impl != NULL) {</span>
<span class="line-added">2239       _mutex_freelist = _impl-&gt;_next;</span>
<span class="line-added">2240       _impl-&gt;_next = NULL;</span>
<span class="line-added">2241       return;</span>
<span class="line-added">2242     }</span>
<span class="line-added">2243   }</span>
<span class="line-added">2244   _impl = new Mutex();</span>
<span class="line-added">2245 }</span>
<span class="line-added">2246 </span>
<span class="line-added">2247 os::PlatformMutex::~PlatformMutex() {</span>
<span class="line-added">2248   WithFreeListLocked wfl;</span>
<span class="line-added">2249   assert(_impl-&gt;_next == NULL, &quot;invariant&quot;);</span>
<span class="line-added">2250   _impl-&gt;_next = _mutex_freelist;</span>
<span class="line-added">2251   _mutex_freelist = _impl;</span>
<span class="line-added">2252 }</span>
<span class="line-added">2253 </span>
<span class="line-added">2254 os::PlatformMonitor::Cond::Cond() : _next(NULL) {</span>
2255   int status = pthread_cond_init(&amp;_cond, _condAttr);
2256   assert_status(status == 0, status, &quot;cond_init&quot;);
<span class="line-modified">2257 }</span>
<span class="line-added">2258 </span>
<span class="line-added">2259 os::PlatformMonitor::Cond::~Cond() {</span>
<span class="line-added">2260   int status = pthread_cond_destroy(&amp;_cond);</span>
<span class="line-added">2261   assert_status(status == 0, status, &quot;cond_destroy&quot;);</span>
<span class="line-added">2262 }</span>
<span class="line-added">2263 </span>
<span class="line-added">2264 os::PlatformMonitor::Cond* os::PlatformMonitor::_cond_freelist = NULL;</span>
<span class="line-added">2265 </span>
<span class="line-added">2266 os::PlatformMonitor::PlatformMonitor() {</span>
<span class="line-added">2267   {</span>
<span class="line-added">2268     WithFreeListLocked wfl;</span>
<span class="line-added">2269     _impl = _cond_freelist;</span>
<span class="line-added">2270     if (_impl != NULL) {</span>
<span class="line-added">2271       _cond_freelist = _impl-&gt;_next;</span>
<span class="line-added">2272       _impl-&gt;_next = NULL;</span>
<span class="line-added">2273       return;</span>
<span class="line-added">2274     }</span>
<span class="line-added">2275   }</span>
<span class="line-added">2276   _impl = new Cond();</span>
<span class="line-added">2277 }</span>
<span class="line-added">2278 </span>
<span class="line-added">2279 os::PlatformMonitor::~PlatformMonitor() {</span>
<span class="line-added">2280   WithFreeListLocked wfl;</span>
<span class="line-added">2281   assert(_impl-&gt;_next == NULL, &quot;invariant&quot;);</span>
<span class="line-added">2282   _impl-&gt;_next = _cond_freelist;</span>
<span class="line-added">2283   _cond_freelist = _impl;</span>
<span class="line-added">2284 }</span>
<span class="line-added">2285 </span>
<span class="line-added">2286 #else</span>
<span class="line-added">2287 </span>
<span class="line-added">2288 os::PlatformMutex::PlatformMutex() {</span>
<span class="line-added">2289   int status = pthread_mutex_init(&amp;_mutex, _mutexAttr);</span>
2290   assert_status(status == 0, status, &quot;mutex_init&quot;);
2291 }
2292 
<span class="line-added">2293 os::PlatformMutex::~PlatformMutex() {</span>
<span class="line-added">2294   int status = pthread_mutex_destroy(&amp;_mutex);</span>
<span class="line-added">2295   assert_status(status == 0, status, &quot;mutex_destroy&quot;);</span>
<span class="line-added">2296 }</span>
<span class="line-added">2297 </span>
<span class="line-added">2298 os::PlatformMonitor::PlatformMonitor() {</span>
<span class="line-added">2299   int status = pthread_cond_init(&amp;_cond, _condAttr);</span>
<span class="line-added">2300   assert_status(status == 0, status, &quot;cond_init&quot;);</span>
<span class="line-added">2301 }</span>
<span class="line-added">2302 </span>
2303 os::PlatformMonitor::~PlatformMonitor() {
2304   int status = pthread_cond_destroy(&amp;_cond);
2305   assert_status(status == 0, status, &quot;cond_destroy&quot;);


2306 }
2307 
<span class="line-added">2308 #endif // PLATFORM_MONITOR_IMPL_INDIRECT</span>
<span class="line-added">2309 </span>
2310 // Must already be locked
2311 int os::PlatformMonitor::wait(jlong millis) {
2312   assert(millis &gt;= 0, &quot;negative timeout&quot;);
2313   if (millis &gt; 0) {
2314     struct timespec abst;
2315     // We have to watch for overflow when converting millis to nanos,
2316     // but if millis is that large then we will end up limiting to
2317     // MAX_SECS anyway, so just do that here.
2318     if (millis / MILLIUNITS &gt; MAX_SECS) {
2319       millis = jlong(MAX_SECS) * MILLIUNITS;
2320     }
<span class="line-modified">2321     to_abstime(&amp;abst, millis_to_nanos(millis), false, false);</span>
2322 
2323     int ret = OS_TIMEOUT;
<span class="line-modified">2324     int status = pthread_cond_timedwait(cond(), mutex(), &amp;abst);</span>
2325     assert_status(status == 0 || status == ETIMEDOUT,
2326                   status, &quot;cond_timedwait&quot;);
2327     if (status == 0) {
2328       ret = OS_OK;
2329     }
2330     return ret;
2331   } else {
<span class="line-modified">2332     int status = pthread_cond_wait(cond(), mutex());</span>
2333     assert_status(status == 0, status, &quot;cond_wait&quot;);
2334     return OS_OK;
2335   }
2336 }
2337 
2338 #endif // !SOLARIS
</pre>
</td>
</tr>
</table>
<center><a href="../linux/waitBarrier_linux.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_posix.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
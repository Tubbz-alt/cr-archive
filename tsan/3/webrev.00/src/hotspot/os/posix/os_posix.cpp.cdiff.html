<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/os/posix/os_posix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../linux/waitBarrier_linux.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_posix.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/posix/os_posix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,12 ---</span>
  #include &quot;os_posix.inline.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;services/memTracker.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/events.hpp&quot;
  #include &quot;utilities/formatBuffer.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/vmError.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,10 ***</span>
<span class="line-new-header">--- 47,11 ---</span>
  #include &lt;sys/mman.h&gt;
  #include &lt;sys/resource.h&gt;
  #include &lt;sys/utsname.h&gt;
  #include &lt;time.h&gt;
  #include &lt;unistd.h&gt;
<span class="line-added">+ #include &lt;utmpx.h&gt;</span>
  
  // Todo: provide a os::get_max_process_id() or similar. Number of processes
  // may have been configured, can be read more accurately from proc fs etc.
  #ifndef MAX_PID
  #define MAX_PID INT_MAX
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,52 ***</span>
    ::strncpy(buf, s, n);
    buf[n] = &#39;\0&#39;;
    return n;
  }
  
<span class="line-removed">- bool os::is_debugger_attached() {</span>
<span class="line-removed">-   // not implemented</span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void os::wait_for_keypress_at_exit(void) {
    // don&#39;t do anything on posix platforms
    return;
  }
  
  int os::create_file_for_heap(const char* dir) {
  
<span class="line-modified">!   const char name_template[] = &quot;/jvmheap.XXXXXX&quot;;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   size_t fullname_len = strlen(dir) + strlen(name_template);</span>
<span class="line-modified">!   char *fullname = (char*)os::malloc(fullname_len + 1, mtInternal);</span>
<span class="line-removed">-   if (fullname == NULL) {</span>
<span class="line-removed">-     vm_exit_during_initialization(err_msg(&quot;Malloc failed during creation of backing file for heap (%s)&quot;, os::strerror(errno)));</span>
      return -1;
    }
<span class="line-modified">!   int n = snprintf(fullname, fullname_len + 1, &quot;%s%s&quot;, dir, name_template);</span>
<span class="line-modified">!   assert((size_t)n == fullname_len, &quot;Unexpected number of characters in string&quot;);</span>
  
<span class="line-modified">!   os::native_path(fullname);</span>
  
<span class="line-modified">!   // set the file creation mask.</span>
<span class="line-modified">!   mode_t file_mode = S_IRUSR | S_IWUSR;</span>
  
<span class="line-modified">!   // create a new file.</span>
<span class="line-modified">!   int fd = mkstemp(fullname);</span>
  
<span class="line-removed">-   if (fd &lt; 0) {</span>
<span class="line-removed">-     warning(&quot;Could not create file for heap with template %s&quot;, fullname);</span>
      os::free(fullname);
<span class="line-removed">-     return -1;</span>
    }
  
<span class="line-removed">-   // delete the name from the filesystem. When &#39;fd&#39; is closed, the file (and space) will be deleted.</span>
<span class="line-removed">-   int ret = unlink(fullname);</span>
<span class="line-removed">-   assert_with_errno(ret == 0, &quot;unlink returned error&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   os::free(fullname);</span>
    return fd;
  }
  
  static char* reserve_mmapped_memory(size_t bytes, char* requested_addr) {
    char * addr;
<span class="line-new-header">--- 168,60 ---</span>
    ::strncpy(buf, s, n);
    buf[n] = &#39;\0&#39;;
    return n;
  }
  
  void os::wait_for_keypress_at_exit(void) {
    // don&#39;t do anything on posix platforms
    return;
  }
  
  int os::create_file_for_heap(const char* dir) {
<span class="line-added">+   int fd;</span>
  
<span class="line-modified">! #if defined(LINUX) &amp;&amp; defined(O_TMPFILE)</span>
<span class="line-modified">!   char* native_dir = os::strdup(dir);</span>
<span class="line-modified">!   if (native_dir == NULL) {</span>
<span class="line-modified">!     vm_exit_during_initialization(err_msg(&quot;strdup failed during creation of backing file for heap (%s)&quot;, os::strerror(errno)));</span>
      return -1;
    }
<span class="line-modified">!   os::native_path(native_dir);</span>
<span class="line-modified">!   fd = os::open(dir, O_TMPFILE | O_RDWR, S_IRUSR | S_IWUSR);</span>
<span class="line-added">+   os::free(native_dir);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (fd == -1)</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+   {</span>
<span class="line-added">+     const char name_template[] = &quot;/jvmheap.XXXXXX&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     size_t fullname_len = strlen(dir) + strlen(name_template);</span>
<span class="line-added">+     char *fullname = (char*)os::malloc(fullname_len + 1, mtInternal);</span>
<span class="line-added">+     if (fullname == NULL) {</span>
<span class="line-added">+       vm_exit_during_initialization(err_msg(&quot;Malloc failed during creation of backing file for heap (%s)&quot;, os::strerror(errno)));</span>
<span class="line-added">+       return -1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     int n = snprintf(fullname, fullname_len + 1, &quot;%s%s&quot;, dir, name_template);</span>
<span class="line-added">+     assert((size_t)n == fullname_len, &quot;Unexpected number of characters in string&quot;);</span>
  
<span class="line-modified">!     os::native_path(fullname);</span>
  
<span class="line-modified">!     // create a new file.</span>
<span class="line-modified">!     fd = mkstemp(fullname);</span>
  
<span class="line-modified">!     if (fd &lt; 0) {</span>
<span class="line-modified">!       warning(&quot;Could not create file for heap with template %s&quot;, fullname);</span>
<span class="line-added">+       os::free(fullname);</span>
<span class="line-added">+       return -1;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // delete the name from the filesystem. When &#39;fd&#39; is closed, the file (and space) will be deleted.</span>
<span class="line-added">+       int ret = unlink(fullname);</span>
<span class="line-added">+       assert_with_errno(ret == 0, &quot;unlink returned error&quot;);</span>
<span class="line-added">+     }</span>
  
      os::free(fullname);
    }
  
    return fd;
  }
  
  static char* reserve_mmapped_memory(size_t bytes, char* requested_addr) {
    char * addr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 371,15 ***</span>
  }
  
  void os::Posix::print_load_average(outputStream* st) {
    st-&gt;print(&quot;load average:&quot;);
    double loadavg[3];
<span class="line-modified">!   os::loadavg(loadavg, 3);</span>
<span class="line-modified">!   st-&gt;print(&quot;%0.02f %0.02f %0.02f&quot;, loadavg[0], loadavg[1], loadavg[2]);</span>
    st-&gt;cr();
  }
  
  void os::Posix::print_rlimit_info(outputStream* st) {
    st-&gt;print(&quot;rlimit:&quot;);
    struct rlimit rlim;
  
    st-&gt;print(&quot; STACK &quot;);
<span class="line-new-header">--- 382,40 ---</span>
  }
  
  void os::Posix::print_load_average(outputStream* st) {
    st-&gt;print(&quot;load average:&quot;);
    double loadavg[3];
<span class="line-modified">!   int res = os::loadavg(loadavg, 3);</span>
<span class="line-modified">!   if (res != -1) {</span>
<span class="line-added">+     st-&gt;print(&quot;%0.02f %0.02f %0.02f&quot;, loadavg[0], loadavg[1], loadavg[2]);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     st-&gt;print(&quot; Unavailable&quot;);</span>
<span class="line-added">+   }</span>
    st-&gt;cr();
  }
  
<span class="line-added">+ // boot/uptime information;</span>
<span class="line-added">+ // unfortunately it does not work on macOS and Linux because the utx chain has no entry</span>
<span class="line-added">+ // for reboot at least on my test machines</span>
<span class="line-added">+ void os::Posix::print_uptime_info(outputStream* st) {</span>
<span class="line-added">+   int bootsec = -1;</span>
<span class="line-added">+   int currsec = time(NULL);</span>
<span class="line-added">+   struct utmpx* ent;</span>
<span class="line-added">+   setutxent();</span>
<span class="line-added">+   while ((ent = getutxent())) {</span>
<span class="line-added">+     if (!strcmp(&quot;system boot&quot;, ent-&gt;ut_line)) {</span>
<span class="line-added">+       bootsec = ent-&gt;ut_tv.tv_sec;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (bootsec != -1) {</span>
<span class="line-added">+     os::print_dhm(st, &quot;OS uptime:&quot;, (long) (currsec-bootsec));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  void os::Posix::print_rlimit_info(outputStream* st) {
    st-&gt;print(&quot;rlimit:&quot;);
    struct rlimit rlim;
  
    st-&gt;print(&quot; STACK &quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 394,10 ***</span>
<span class="line-new-header">--- 430,14 ---</span>
  
    // Isn&#39;t there on solaris
  #if defined(AIX)
    st-&gt;print(&quot;, NPROC &quot;);
    st-&gt;print(&quot;%d&quot;, sysconf(_SC_CHILD_MAX));
<span class="line-added">+   st-&gt;print(&quot;, THREADS &quot;);</span>
<span class="line-added">+   getrlimit(RLIMIT_THREADS, &amp;rlim);</span>
<span class="line-added">+   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);</span>
<span class="line-added">+   else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));</span>
  #elif !defined(SOLARIS)
    st-&gt;print(&quot;, NPROC &quot;);
    getrlimit(RLIMIT_NPROC, &amp;rlim);
    if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
    else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,10 ***</span>
<span class="line-new-header">--- 451,15 ---</span>
    st-&gt;print(&quot;, AS &quot;);
    getrlimit(RLIMIT_AS, &amp;rlim);
    if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
    else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
  
<span class="line-added">+   st-&gt;print(&quot;, CPU &quot;);</span>
<span class="line-added">+   getrlimit(RLIMIT_CPU, &amp;rlim);</span>
<span class="line-added">+   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);</span>
<span class="line-added">+   else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));</span>
<span class="line-added">+ </span>
    st-&gt;print(&quot;, DATA &quot;);
    getrlimit(RLIMIT_DATA, &amp;rlim);
    if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
    else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 622,82 ***</span>
      strncat(agent_entry_name, lib_name, name_len);
    }
    return agent_entry_name;
  }
  
<span class="line-removed">- int os::sleep(Thread* thread, jlong millis, bool interruptible) {</span>
<span class="line-removed">-   assert(thread == Thread::current(),  &quot;thread consistency check&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ParkEvent * const slp = thread-&gt;_SleepEvent ;</span>
<span class="line-removed">-   slp-&gt;reset() ;</span>
<span class="line-removed">-   OrderAccess::fence() ;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (interruptible) {</span>
<span class="line-removed">-     jlong prevtime = javaTimeNanos();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (;;) {</span>
<span class="line-removed">-       if (os::is_interrupted(thread, true)) {</span>
<span class="line-removed">-         return OS_INTRPT;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       jlong newtime = javaTimeNanos();</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (newtime - prevtime &lt; 0) {</span>
<span class="line-removed">-         // time moving backwards, should only happen if no monotonic clock</span>
<span class="line-removed">-         // not a guarantee() because JVM should not abort on kernel/glibc bugs</span>
<span class="line-removed">-         assert(!os::supports_monotonic_clock(), &quot;unexpected time moving backwards detected in os::sleep(interruptible)&quot;);</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (millis &lt;= 0) {</span>
<span class="line-removed">-         return OS_OK;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       prevtime = newtime;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         assert(thread-&gt;is_Java_thread(), &quot;sanity check&quot;);</span>
<span class="line-removed">-         JavaThread *jt = (JavaThread *) thread;</span>
<span class="line-removed">-         ThreadBlockInVM tbivm(jt);</span>
<span class="line-removed">-         OSThreadWaitState osts(jt-&gt;osthread(), false /* not Object.wait() */);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         jt-&gt;set_suspend_equivalent();</span>
<span class="line-removed">-         // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-removed">-         // java_suspend_self() via check_and_wait_while_suspended()</span>
<span class="line-removed">- </span>
<span class="line-removed">-         slp-&gt;park(millis);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // were we externally suspended while we were waiting?</span>
<span class="line-removed">-         jt-&gt;check_and_wait_while_suspended();</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);</span>
<span class="line-removed">-     jlong prevtime = javaTimeNanos();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (;;) {</span>
<span class="line-removed">-       // It&#39;d be nice to avoid the back-to-back javaTimeNanos() calls on</span>
<span class="line-removed">-       // the 1st iteration ...</span>
<span class="line-removed">-       jlong newtime = javaTimeNanos();</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (newtime - prevtime &lt; 0) {</span>
<span class="line-removed">-         // time moving backwards, should only happen if no monotonic clock</span>
<span class="line-removed">-         // not a guarantee() because JVM should not abort on kernel/glibc bugs</span>
<span class="line-removed">-         assert(!os::supports_monotonic_clock(), &quot;unexpected time moving backwards detected on os::sleep(!interruptible)&quot;);</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (millis &lt;= 0) break ;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       prevtime = newtime;</span>
<span class="line-removed">-       slp-&gt;park(millis);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return OS_OK ;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
  
  void os::naked_short_nanosleep(jlong ns) {
    struct timespec req;
    assert(ns &gt; -1 &amp;&amp; ns &lt; NANOUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
    req.tv_sec = 0;
<span class="line-new-header">--- 667,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 706,69 ***</span>
    return;
  }
  
  void os::naked_short_sleep(jlong ms) {
    assert(ms &lt; MILLIUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
<span class="line-modified">!   os::naked_short_nanosleep(ms * (NANOUNITS / MILLIUNITS));</span>
    return;
  }
  
<span class="line-removed">- ////////////////////////////////////////////////////////////////////////////////</span>
<span class="line-removed">- // interrupt support</span>
<span class="line-removed">- </span>
<span class="line-removed">- void os::interrupt(Thread* thread) {</span>
<span class="line-removed">-   debug_only(Thread::check_for_dangling_thread_pointer(thread);)</span>
<span class="line-removed">- </span>
<span class="line-removed">-   OSThread* osthread = thread-&gt;osthread();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (!osthread-&gt;interrupted()) {</span>
<span class="line-removed">-     osthread-&gt;set_interrupted(true);</span>
<span class="line-removed">-     // More than one thread can get here with the same value of osthread,</span>
<span class="line-removed">-     // resulting in multiple notifications.  We do, however, want the store</span>
<span class="line-removed">-     // to interrupted() to be visible to other threads before we execute unpark().</span>
<span class="line-removed">-     OrderAccess::fence();</span>
<span class="line-removed">-     ParkEvent * const slp = thread-&gt;_SleepEvent ;</span>
<span class="line-removed">-     if (slp != NULL) slp-&gt;unpark() ;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // For JSR166. Unpark even if interrupt status already was set</span>
<span class="line-removed">-   if (thread-&gt;is_Java_thread())</span>
<span class="line-removed">-     ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ParkEvent * ev = thread-&gt;_ParkEvent ;</span>
<span class="line-removed">-   if (ev != NULL) ev-&gt;unpark() ;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool os::is_interrupted(Thread* thread, bool clear_interrupted) {</span>
<span class="line-removed">-   debug_only(Thread::check_for_dangling_thread_pointer(thread);)</span>
<span class="line-removed">- </span>
<span class="line-removed">-   OSThread* osthread = thread-&gt;osthread();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool interrupted = osthread-&gt;interrupted();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // NOTE that since there is no &quot;lock&quot; around the interrupt and</span>
<span class="line-removed">-   // is_interrupted operations, there is the possibility that the</span>
<span class="line-removed">-   // interrupted flag (in osThread) will be &quot;false&quot; but that the</span>
<span class="line-removed">-   // low-level events will be in the signaled state. This is</span>
<span class="line-removed">-   // intentional. The effect of this is that Object.wait() and</span>
<span class="line-removed">-   // LockSupport.park() will appear to have a spurious wakeup, which</span>
<span class="line-removed">-   // is allowed and not harmful, and the possibility is so rare that</span>
<span class="line-removed">-   // it is not worth the added complexity to add yet another lock.</span>
<span class="line-removed">-   // For the sleep event an explicit reset is performed on entry</span>
<span class="line-removed">-   // to os::sleep, so there is no early return. It has also been</span>
<span class="line-removed">-   // recommended not to put the interrupted flag into the &quot;event&quot;</span>
<span class="line-removed">-   // structure because it hides the issue.</span>
<span class="line-removed">-   if (interrupted &amp;&amp; clear_interrupted) {</span>
<span class="line-removed">-     osthread-&gt;set_interrupted(false);</span>
<span class="line-removed">-     // consider thread-&gt;_SleepEvent-&gt;reset() ... optional optimization</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return interrupted;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  static const struct {
    int sig; const char* name;
  }
   g_signal_info[] =
    {
<span class="line-new-header">--- 679,14 ---</span>
    return;
  }
  
  void os::naked_short_sleep(jlong ms) {
    assert(ms &lt; MILLIUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
<span class="line-modified">!   os::naked_short_nanosleep(millis_to_nanos(ms));</span>
    return;
  }
  
  static const struct {
    int sig; const char* name;
  }
   g_signal_info[] =
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 811,10 ***</span>
<span class="line-new-header">--- 729,13 ---</span>
  #ifdef SIGGRANT
    {  SIGGRANT,    &quot;SIGGRANT&quot; },
  #endif
    {  SIGHUP,      &quot;SIGHUP&quot; },
    {  SIGILL,      &quot;SIGILL&quot; },
<span class="line-added">+ #ifdef SIGINFO</span>
<span class="line-added">+   {  SIGINFO,     &quot;SIGINFO&quot; },</span>
<span class="line-added">+ #endif</span>
    {  SIGINT,      &quot;SIGINT&quot; },
  #ifdef SIGIO
    {  SIGIO,       &quot;SIGIO&quot; },
  #endif
  #ifdef SIGIOINT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1448,10 ***</span>
<span class="line-new-header">--- 1369,34 ---</span>
  
  char * os::native_path(char *path) {
    return path;
  }
  
<span class="line-added">+ bool os::same_files(const char* file1, const char* file2) {</span>
<span class="line-added">+   if (strcmp(file1, file2) == 0) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool is_same = false;</span>
<span class="line-added">+   struct stat st1;</span>
<span class="line-added">+   struct stat st2;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (os::stat(file1, &amp;st1) &lt; 0) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (os::stat(file2, &amp;st2) &lt; 0) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (st1.st_dev == st2.st_dev &amp;&amp; st1.st_ino == st2.st_ino) {</span>
<span class="line-added">+     // same files</span>
<span class="line-added">+     is_same = true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return is_same;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Check minimum allowable stack sizes for thread creation and to initialize
  // the java system classes, including StackOverflowError - depends on page
  // size.
  // The space needed for frames during startup is platform dependent. It
  // depends on word size, platform calling conventions, C frame layout and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1669,10 ***</span>
<span class="line-new-header">--- 1614,12 ---</span>
      fatal(&quot;pthread_mutexattr_init: %s&quot;, os::strerror(status));
    }
    if ((status = pthread_mutexattr_settype(_mutexAttr, PTHREAD_MUTEX_NORMAL)) != 0) {
      fatal(&quot;pthread_mutexattr_settype: %s&quot;, os::strerror(status));
    }
<span class="line-added">+   // Solaris has it&#39;s own PlatformMutex, distinct from the one for POSIX.</span>
<span class="line-added">+   NOT_SOLARIS(os::PlatformMutex::init();)</span>
  }
  
  #ifndef SOLARIS
  sigset_t sigs;
  struct sigaction sigact[NSIG];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1884,22 ***</span>
      // Absolute seconds exceeds allowed max, so pin to max_secs.
      abstime-&gt;tv_sec = max_secs;
      abstime-&gt;tv_nsec = 0;
    } else {
      abstime-&gt;tv_sec = seconds;
<span class="line-modified">!     abstime-&gt;tv_nsec = millis * (NANOUNITS / MILLIUNITS);</span>
    }
  }
  
<span class="line-modified">! static jlong millis_to_nanos(jlong millis) {</span>
    // We have to watch for overflow when converting millis to nanos,
    // but if millis is that large then we will end up limiting to
    // MAX_SECS anyway, so just do that here.
    if (millis / MILLIUNITS &gt; MAX_SECS) {
      millis = jlong(MAX_SECS) * MILLIUNITS;
    }
<span class="line-modified">!   return millis * (NANOUNITS / MILLIUNITS);</span>
  }
  
  static void to_abstime(timespec* abstime, jlong timeout,
                         bool isAbsolute, bool isRealtime) {
    DEBUG_ONLY(int max_secs = MAX_SECS;)
<span class="line-new-header">--- 1831,22 ---</span>
      // Absolute seconds exceeds allowed max, so pin to max_secs.
      abstime-&gt;tv_sec = max_secs;
      abstime-&gt;tv_nsec = 0;
    } else {
      abstime-&gt;tv_sec = seconds;
<span class="line-modified">!     abstime-&gt;tv_nsec = millis_to_nanos(millis);</span>
    }
  }
  
<span class="line-modified">! static jlong millis_to_nanos_bounded(jlong millis) {</span>
    // We have to watch for overflow when converting millis to nanos,
    // but if millis is that large then we will end up limiting to
    // MAX_SECS anyway, so just do that here.
    if (millis / MILLIUNITS &gt; MAX_SECS) {
      millis = jlong(MAX_SECS) * MILLIUNITS;
    }
<span class="line-modified">!   return millis_to_nanos(millis);</span>
  }
  
  static void to_abstime(timespec* abstime, jlong timeout,
                         bool isAbsolute, bool isRealtime) {
    DEBUG_ONLY(int max_secs = MAX_SECS;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1948,11 ***</span>
  }
  
  // Create an absolute time &#39;millis&#39; milliseconds in the future, using the
  // real-time (time-of-day) clock. Used by PosixSemaphore.
  void os::Posix::to_RTC_abstime(timespec* abstime, int64_t millis) {
<span class="line-modified">!   to_abstime(abstime, millis_to_nanos(millis),</span>
               false /* not absolute */,
               true  /* use real-time clock */);
  }
  
  // Shared pthread_mutex/cond based PlatformEvent implementation.
<span class="line-new-header">--- 1895,11 ---</span>
  }
  
  // Create an absolute time &#39;millis&#39; milliseconds in the future, using the
  // real-time (time-of-day) clock. Used by PosixSemaphore.
  void os::Posix::to_RTC_abstime(timespec* abstime, int64_t millis) {
<span class="line-modified">!   to_abstime(abstime, millis_to_nanos_bounded(millis),</span>
               false /* not absolute */,
               true  /* use real-time clock */);
  }
  
  // Shared pthread_mutex/cond based PlatformEvent implementation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1997,11 ***</span>
    int v;
  
    // atomically decrement _event
    for (;;) {
      v = _event;
<span class="line-modified">!     if (Atomic::cmpxchg(v - 1, &amp;_event, v) == v) break;</span>
    }
    guarantee(v &gt;= 0, &quot;invariant&quot;);
  
    if (v == 0) { // Do this the hard way by blocking ...
      int status = pthread_mutex_lock(_mutex);
<span class="line-new-header">--- 1944,11 ---</span>
    int v;
  
    // atomically decrement _event
    for (;;) {
      v = _event;
<span class="line-modified">!     if (Atomic::cmpxchg(&amp;_event, v, v - 1) == v) break;</span>
    }
    guarantee(v &gt;= 0, &quot;invariant&quot;);
  
    if (v == 0) { // Do this the hard way by blocking ...
      int status = pthread_mutex_lock(_mutex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2037,17 ***</span>
  
    int v;
    // atomically decrement _event
    for (;;) {
      v = _event;
<span class="line-modified">!     if (Atomic::cmpxchg(v - 1, &amp;_event, v) == v) break;</span>
    }
    guarantee(v &gt;= 0, &quot;invariant&quot;);
  
    if (v == 0) { // Do this the hard way by blocking ...
      struct timespec abst;
<span class="line-modified">!     to_abstime(&amp;abst, millis_to_nanos(millis), false, false);</span>
  
      int ret = OS_TIMEOUT;
      int status = pthread_mutex_lock(_mutex);
      assert_status(status == 0, status, &quot;mutex_lock&quot;);
      guarantee(_nParked == 0, &quot;invariant&quot;);
<span class="line-new-header">--- 1984,17 ---</span>
  
    int v;
    // atomically decrement _event
    for (;;) {
      v = _event;
<span class="line-modified">!     if (Atomic::cmpxchg(&amp;_event, v, v - 1) == v) break;</span>
    }
    guarantee(v &gt;= 0, &quot;invariant&quot;);
  
    if (v == 0) { // Do this the hard way by blocking ...
      struct timespec abst;
<span class="line-modified">!     to_abstime(&amp;abst, millis_to_nanos_bounded(millis), false, false);</span>
  
      int ret = OS_TIMEOUT;
      int status = pthread_mutex_lock(_mutex);
      assert_status(status == 0, status, &quot;mutex_lock&quot;);
      guarantee(_nParked == 0, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2093,13 ***</span>
    // thread to block. This has the benefit of forcing a spurious return
    // from the first park() call after an unpark() call which will help
    // shake out uses of park() and unpark() without checking state conditions
    // properly. This spurious return doesn&#39;t manifest itself in any user code
    // but only in the correctly written condition checking loops of ObjectMonitor,
<span class="line-modified">!   // Mutex/Monitor, Thread::muxAcquire and os::sleep</span>
  
<span class="line-modified">!   if (Atomic::xchg(1, &amp;_event) &gt;= 0) return;</span>
  
    int status = pthread_mutex_lock(_mutex);
    assert_status(status == 0, status, &quot;mutex_lock&quot;);
    int anyWaiters = _nParked;
    assert(anyWaiters == 0 || anyWaiters == 1, &quot;invariant&quot;);
<span class="line-new-header">--- 2040,13 ---</span>
    // thread to block. This has the benefit of forcing a spurious return
    // from the first park() call after an unpark() call which will help
    // shake out uses of park() and unpark() without checking state conditions
    // properly. This spurious return doesn&#39;t manifest itself in any user code
    // but only in the correctly written condition checking loops of ObjectMonitor,
<span class="line-modified">!   // Mutex/Monitor, Thread::muxAcquire and JavaThread::sleep</span>
  
<span class="line-modified">!   if (Atomic::xchg(&amp;_event, 1) &gt;= 0) return;</span>
  
    int status = pthread_mutex_lock(_mutex);
    assert_status(status == 0, status, &quot;mutex_lock&quot;);
    int anyWaiters = _nParked;
    assert(anyWaiters == 0 || anyWaiters == 1, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2143,19 ***</span>
  
    // Optional fast-path check:
    // Return immediately if a permit is available.
    // We depend on Atomic::xchg() having full barrier semantics
    // since we are doing a lock-free update to _counter.
<span class="line-modified">!   if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;</span>
  
    Thread* thread = Thread::current();
    assert(thread-&gt;is_Java_thread(), &quot;Must be JavaThread&quot;);
    JavaThread *jt = (JavaThread *)thread;
  
    // Optional optimization -- avoid state transitions if there&#39;s
    // an interrupt pending.
<span class="line-modified">!   if (Thread::is_interrupted(thread, false)) {</span>
      return;
    }
  
    // Next, demultiplex/decode time arguments
    struct timespec absTime;
<span class="line-new-header">--- 2090,19 ---</span>
  
    // Optional fast-path check:
    // Return immediately if a permit is available.
    // We depend on Atomic::xchg() having full barrier semantics
    // since we are doing a lock-free update to _counter.
<span class="line-modified">!   if (Atomic::xchg(&amp;_counter, 0) &gt; 0) return;</span>
  
    Thread* thread = Thread::current();
    assert(thread-&gt;is_Java_thread(), &quot;Must be JavaThread&quot;);
    JavaThread *jt = (JavaThread *)thread;
  
    // Optional optimization -- avoid state transitions if there&#39;s
    // an interrupt pending.
<span class="line-modified">!   if (jt-&gt;is_interrupted(false)) {</span>
      return;
    }
  
    // Next, demultiplex/decode time arguments
    struct timespec absTime;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2172,14 ***</span>
    // In particular a thread must never block on the Threads_lock while
    // holding the Parker:: mutex.  If safepoints are pending both the
    // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.
    ThreadBlockInVM tbivm(jt);
  
    // Don&#39;t wait if cannot get lock since interference arises from
<span class="line-modified">!   // unparking. Also re-check interrupt before trying wait.</span>
<span class="line-modified">!   if (Thread::is_interrupted(thread, false) ||</span>
<span class="line-removed">-       pthread_mutex_trylock(_mutex) != 0) {</span>
      return;
    }
  
    int status;
    if (_counter &gt; 0)  { // no wait needed
<span class="line-new-header">--- 2119,16 ---</span>
    // In particular a thread must never block on the Threads_lock while
    // holding the Parker:: mutex.  If safepoints are pending both the
    // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.
    ThreadBlockInVM tbivm(jt);
  
<span class="line-added">+   // Can&#39;t access interrupt state now that we are _thread_blocked. If we&#39;ve</span>
<span class="line-added">+   // been interrupted since we checked above then _counter will be &gt; 0.</span>
<span class="line-added">+ </span>
    // Don&#39;t wait if cannot get lock since interference arises from
<span class="line-modified">!   // unparking.</span>
<span class="line-modified">!   if (pthread_mutex_trylock(_mutex) != 0) {</span>
      return;
    }
  
    int status;
    if (_counter &gt; 0)  { // no wait needed
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2246,26 ***</span>
      status = pthread_cond_signal(&amp;_cond[index]);
      assert_status(status == 0, status, &quot;invariant&quot;);
    }
  }
  
<span class="line-modified">! // Platform Monitor implementation</span>
  
<span class="line-modified">! os::PlatformMonitor::PlatformMonitor() {</span>
    int status = pthread_cond_init(&amp;_cond, _condAttr);
    assert_status(status == 0, status, &quot;cond_init&quot;);
<span class="line-modified">!   status = pthread_mutex_init(&amp;_mutex, _mutexAttr);</span>
    assert_status(status == 0, status, &quot;mutex_init&quot;);
  }
  
  os::PlatformMonitor::~PlatformMonitor() {
    int status = pthread_cond_destroy(&amp;_cond);
    assert_status(status == 0, status, &quot;cond_destroy&quot;);
<span class="line-removed">-   status = pthread_mutex_destroy(&amp;_mutex);</span>
<span class="line-removed">-   assert_status(status == 0, status, &quot;mutex_destroy&quot;);</span>
  }
  
  // Must already be locked
  int os::PlatformMonitor::wait(jlong millis) {
    assert(millis &gt;= 0, &quot;negative timeout&quot;);
    if (millis &gt; 0) {
      struct timespec abst;
<span class="line-new-header">--- 2195,120 ---</span>
      status = pthread_cond_signal(&amp;_cond[index]);
      assert_status(status == 0, status, &quot;invariant&quot;);
    }
  }
  
<span class="line-modified">! // Platform Mutex/Monitor implementation</span>
  
<span class="line-modified">! #if PLATFORM_MONITOR_IMPL_INDIRECT</span>
<span class="line-added">+ </span>
<span class="line-added">+ os::PlatformMutex::Mutex::Mutex() : _next(NULL) {</span>
<span class="line-added">+   int status = pthread_mutex_init(&amp;_mutex, _mutexAttr);</span>
<span class="line-added">+   assert_status(status == 0, status, &quot;mutex_init&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ os::PlatformMutex::Mutex::~Mutex() {</span>
<span class="line-added">+   int status = pthread_mutex_destroy(&amp;_mutex);</span>
<span class="line-added">+   assert_status(status == 0, status, &quot;mutex_destroy&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ pthread_mutex_t os::PlatformMutex::_freelist_lock;</span>
<span class="line-added">+ os::PlatformMutex::Mutex* os::PlatformMutex::_mutex_freelist = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+ void os::PlatformMutex::init() {</span>
<span class="line-added">+   int status = pthread_mutex_init(&amp;_freelist_lock, _mutexAttr);</span>
<span class="line-added">+   assert_status(status == 0, status, &quot;freelist lock init&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ struct os::PlatformMutex::WithFreeListLocked : public StackObj {</span>
<span class="line-added">+   WithFreeListLocked() {</span>
<span class="line-added">+     int status = pthread_mutex_lock(&amp;_freelist_lock);</span>
<span class="line-added">+     assert_status(status == 0, status, &quot;freelist lock&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ~WithFreeListLocked() {</span>
<span class="line-added">+     int status = pthread_mutex_unlock(&amp;_freelist_lock);</span>
<span class="line-added">+     assert_status(status == 0, status, &quot;freelist unlock&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ os::PlatformMutex::PlatformMutex() {</span>
<span class="line-added">+   {</span>
<span class="line-added">+     WithFreeListLocked wfl;</span>
<span class="line-added">+     _impl = _mutex_freelist;</span>
<span class="line-added">+     if (_impl != NULL) {</span>
<span class="line-added">+       _mutex_freelist = _impl-&gt;_next;</span>
<span class="line-added">+       _impl-&gt;_next = NULL;</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   _impl = new Mutex();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ os::PlatformMutex::~PlatformMutex() {</span>
<span class="line-added">+   WithFreeListLocked wfl;</span>
<span class="line-added">+   assert(_impl-&gt;_next == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   _impl-&gt;_next = _mutex_freelist;</span>
<span class="line-added">+   _mutex_freelist = _impl;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ os::PlatformMonitor::Cond::Cond() : _next(NULL) {</span>
    int status = pthread_cond_init(&amp;_cond, _condAttr);
    assert_status(status == 0, status, &quot;cond_init&quot;);
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ os::PlatformMonitor::Cond::~Cond() {</span>
<span class="line-added">+   int status = pthread_cond_destroy(&amp;_cond);</span>
<span class="line-added">+   assert_status(status == 0, status, &quot;cond_destroy&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ os::PlatformMonitor::Cond* os::PlatformMonitor::_cond_freelist = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+ os::PlatformMonitor::PlatformMonitor() {</span>
<span class="line-added">+   {</span>
<span class="line-added">+     WithFreeListLocked wfl;</span>
<span class="line-added">+     _impl = _cond_freelist;</span>
<span class="line-added">+     if (_impl != NULL) {</span>
<span class="line-added">+       _cond_freelist = _impl-&gt;_next;</span>
<span class="line-added">+       _impl-&gt;_next = NULL;</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   _impl = new Cond();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ os::PlatformMonitor::~PlatformMonitor() {</span>
<span class="line-added">+   WithFreeListLocked wfl;</span>
<span class="line-added">+   assert(_impl-&gt;_next == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   _impl-&gt;_next = _cond_freelist;</span>
<span class="line-added">+   _cond_freelist = _impl;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #else</span>
<span class="line-added">+ </span>
<span class="line-added">+ os::PlatformMutex::PlatformMutex() {</span>
<span class="line-added">+   int status = pthread_mutex_init(&amp;_mutex, _mutexAttr);</span>
    assert_status(status == 0, status, &quot;mutex_init&quot;);
  }
  
<span class="line-added">+ os::PlatformMutex::~PlatformMutex() {</span>
<span class="line-added">+   int status = pthread_mutex_destroy(&amp;_mutex);</span>
<span class="line-added">+   assert_status(status == 0, status, &quot;mutex_destroy&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ os::PlatformMonitor::PlatformMonitor() {</span>
<span class="line-added">+   int status = pthread_cond_init(&amp;_cond, _condAttr);</span>
<span class="line-added">+   assert_status(status == 0, status, &quot;cond_init&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  os::PlatformMonitor::~PlatformMonitor() {
    int status = pthread_cond_destroy(&amp;_cond);
    assert_status(status == 0, status, &quot;cond_destroy&quot;);
  }
  
<span class="line-added">+ #endif // PLATFORM_MONITOR_IMPL_INDIRECT</span>
<span class="line-added">+ </span>
  // Must already be locked
  int os::PlatformMonitor::wait(jlong millis) {
    assert(millis &gt;= 0, &quot;negative timeout&quot;);
    if (millis &gt; 0) {
      struct timespec abst;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2273,22 ***</span>
      // but if millis is that large then we will end up limiting to
      // MAX_SECS anyway, so just do that here.
      if (millis / MILLIUNITS &gt; MAX_SECS) {
        millis = jlong(MAX_SECS) * MILLIUNITS;
      }
<span class="line-modified">!     to_abstime(&amp;abst, millis * (NANOUNITS / MILLIUNITS), false, false);</span>
  
      int ret = OS_TIMEOUT;
<span class="line-modified">!     int status = pthread_cond_timedwait(&amp;_cond, &amp;_mutex, &amp;abst);</span>
      assert_status(status == 0 || status == ETIMEDOUT,
                    status, &quot;cond_timedwait&quot;);
      if (status == 0) {
        ret = OS_OK;
      }
      return ret;
    } else {
<span class="line-modified">!     int status = pthread_cond_wait(&amp;_cond, &amp;_mutex);</span>
      assert_status(status == 0, status, &quot;cond_wait&quot;);
      return OS_OK;
    }
  }
  
<span class="line-new-header">--- 2316,22 ---</span>
      // but if millis is that large then we will end up limiting to
      // MAX_SECS anyway, so just do that here.
      if (millis / MILLIUNITS &gt; MAX_SECS) {
        millis = jlong(MAX_SECS) * MILLIUNITS;
      }
<span class="line-modified">!     to_abstime(&amp;abst, millis_to_nanos(millis), false, false);</span>
  
      int ret = OS_TIMEOUT;
<span class="line-modified">!     int status = pthread_cond_timedwait(cond(), mutex(), &amp;abst);</span>
      assert_status(status == 0 || status == ETIMEDOUT,
                    status, &quot;cond_timedwait&quot;);
      if (status == 0) {
        ret = OS_OK;
      }
      return ret;
    } else {
<span class="line-modified">!     int status = pthread_cond_wait(cond(), mutex());</span>
      assert_status(status == 0, status, &quot;cond_wait&quot;);
      return OS_OK;
    }
  }
  
</pre>
<center><a href="../linux/waitBarrier_linux.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_posix.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
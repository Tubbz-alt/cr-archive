<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/os/solaris/os_solaris.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_perf_solaris.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_solaris.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/solaris/os_solaris.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,12 ***</span>
<span class="line-new-header">--- 31,14 ---</span>
  #include &quot;code/vtableStubs.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/disassembler.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;logging/log.hpp&quot;
<span class="line-added">+ #include &quot;logging/logStream.hpp&quot;</span>
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/filemap.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;os_share_solaris.hpp&quot;
  #include &quot;os_solaris.inline.hpp&quot;
  #include &quot;prims/jniFastGetField.hpp&quot;
  #include &quot;prims/jvm_misc.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,12 ***</span>
    if (enabler) {
      enabler(-1, -1);
    }
  }
  
<span class="line-removed">- static int _processors_online = 0;</span>
<span class="line-removed">- </span>
  jint os::Solaris::_os_thread_limit = 0;
  volatile jint os::Solaris::_os_thread_count = 0;
  
  julong os::available_memory() {
    return Solaris::available_memory();
<span class="line-new-header">--- 263,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 287,11 ***</span>
  static volatile hrtime_t max_hrtime = 0;
  
  
  void os::Solaris::initialize_system_info() {
    set_processor_count(sysconf(_SC_NPROCESSORS_CONF));
<span class="line-removed">-   _processors_online = sysconf(_SC_NPROCESSORS_ONLN);</span>
    _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) *
                                       (julong)sysconf(_SC_PAGESIZE);
  }
  
  uint os::processor_id() {
<span class="line-new-header">--- 287,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,150 ***</span>
    if (pset_bind(PS_QUERY, P_PID, pid, &amp;pset) == 0) {
      uint_t pset_cpus;
      // Query the number of cpus available to us.
      if (pset_info(pset, NULL, &amp;pset_cpus, NULL) == 0) {
        assert(pset_cpus &gt; 0 &amp;&amp; pset_cpus &lt;= online_cpus, &quot;sanity check&quot;);
<span class="line-removed">-       _processors_online = pset_cpus;</span>
        return pset_cpus;
      }
    }
    // Otherwise return number of online cpus
    return online_cpus;
  }
  
<span class="line-removed">- static bool find_processors_in_pset(psetid_t        pset,</span>
<span class="line-removed">-                                     processorid_t** id_array,</span>
<span class="line-removed">-                                     uint_t*         id_length) {</span>
<span class="line-removed">-   bool result = false;</span>
<span class="line-removed">-   // Find the number of processors in the processor set.</span>
<span class="line-removed">-   if (pset_info(pset, NULL, id_length, NULL) == 0) {</span>
<span class="line-removed">-     // Make up an array to hold their ids.</span>
<span class="line-removed">-     *id_array = NEW_C_HEAP_ARRAY(processorid_t, *id_length, mtInternal);</span>
<span class="line-removed">-     // Fill in the array with their processor ids.</span>
<span class="line-removed">-     if (pset_info(pset, NULL, id_length, *id_array) == 0) {</span>
<span class="line-removed">-       result = true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return result;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Callers of find_processors_online() must tolerate imprecise results --</span>
<span class="line-removed">- // the system configuration can change asynchronously because of DR</span>
<span class="line-removed">- // or explicit psradm operations.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // We also need to take care that the loop (below) terminates as the</span>
<span class="line-removed">- // number of processors online can change between the _SC_NPROCESSORS_ONLN</span>
<span class="line-removed">- // request and the loop that builds the list of processor ids.   Unfortunately</span>
<span class="line-removed">- // there&#39;s no reliable way to determine the maximum valid processor id,</span>
<span class="line-removed">- // so we use a manifest constant, MAX_PROCESSOR_ID, instead.  See p_online</span>
<span class="line-removed">- // man pages, which claim the processor id set is &quot;sparse, but</span>
<span class="line-removed">- // not too sparse&quot;.  MAX_PROCESSOR_ID is used to ensure that we eventually</span>
<span class="line-removed">- // exit the loop.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // In the future we&#39;ll be able to use sysconf(_SC_CPUID_MAX), but that&#39;s</span>
<span class="line-removed">- // not available on S8.0.</span>
<span class="line-removed">- </span>
<span class="line-removed">- static bool find_processors_online(processorid_t** id_array,</span>
<span class="line-removed">-                                    uint*           id_length) {</span>
<span class="line-removed">-   const processorid_t MAX_PROCESSOR_ID = 100000;</span>
<span class="line-removed">-   // Find the number of processors online.</span>
<span class="line-removed">-   *id_length = sysconf(_SC_NPROCESSORS_ONLN);</span>
<span class="line-removed">-   // Make up an array to hold their ids.</span>
<span class="line-removed">-   *id_array = NEW_C_HEAP_ARRAY(processorid_t, *id_length, mtInternal);</span>
<span class="line-removed">-   // Processors need not be numbered consecutively.</span>
<span class="line-removed">-   long found = 0;</span>
<span class="line-removed">-   processorid_t next = 0;</span>
<span class="line-removed">-   while (found &lt; *id_length &amp;&amp; next &lt; MAX_PROCESSOR_ID) {</span>
<span class="line-removed">-     processor_info_t info;</span>
<span class="line-removed">-     if (processor_info(next, &amp;info) == 0) {</span>
<span class="line-removed">-       // NB, PI_NOINTR processors are effectively online ...</span>
<span class="line-removed">-       if (info.pi_state == P_ONLINE || info.pi_state == P_NOINTR) {</span>
<span class="line-removed">-         (*id_array)[found] = next;</span>
<span class="line-removed">-         found += 1;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     next += 1;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (found &lt; *id_length) {</span>
<span class="line-removed">-     // The loop above didn&#39;t identify the expected number of processors.</span>
<span class="line-removed">-     // We could always retry the operation, calling sysconf(_SC_NPROCESSORS_ONLN)</span>
<span class="line-removed">-     // and re-running the loop, above, but there&#39;s no guarantee of progress</span>
<span class="line-removed">-     // if the system configuration is in flux.  Instead, we just return what</span>
<span class="line-removed">-     // we&#39;ve got.  Note that in the worst case find_processors_online() could</span>
<span class="line-removed">-     // return an empty set.  (As a fall-back in the case of the empty set we</span>
<span class="line-removed">-     // could just return the ID of the current processor).</span>
<span class="line-removed">-     *id_length = found;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static bool assign_distribution(processorid_t* id_array,</span>
<span class="line-removed">-                                 uint           id_length,</span>
<span class="line-removed">-                                 uint*          distribution,</span>
<span class="line-removed">-                                 uint           distribution_length) {</span>
<span class="line-removed">-   // We assume we can assign processorid_t&#39;s to uint&#39;s.</span>
<span class="line-removed">-   assert(sizeof(processorid_t) == sizeof(uint),</span>
<span class="line-removed">-          &quot;can&#39;t convert processorid_t to uint&quot;);</span>
<span class="line-removed">-   // Quick check to see if we won&#39;t succeed.</span>
<span class="line-removed">-   if (id_length &lt; distribution_length) {</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // Assign processor ids to the distribution.</span>
<span class="line-removed">-   // Try to shuffle processors to distribute work across boards,</span>
<span class="line-removed">-   // assuming 4 processors per board.</span>
<span class="line-removed">-   const uint processors_per_board = ProcessDistributionStride;</span>
<span class="line-removed">-   // Find the maximum processor id.</span>
<span class="line-removed">-   processorid_t max_id = 0;</span>
<span class="line-removed">-   for (uint m = 0; m &lt; id_length; m += 1) {</span>
<span class="line-removed">-     max_id = MAX2(max_id, id_array[m]);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // The next id, to limit loops.</span>
<span class="line-removed">-   const processorid_t limit_id = max_id + 1;</span>
<span class="line-removed">-   // Make up markers for available processors.</span>
<span class="line-removed">-   bool* available_id = NEW_C_HEAP_ARRAY(bool, limit_id, mtInternal);</span>
<span class="line-removed">-   for (uint c = 0; c &lt; limit_id; c += 1) {</span>
<span class="line-removed">-     available_id[c] = false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   for (uint a = 0; a &lt; id_length; a += 1) {</span>
<span class="line-removed">-     available_id[id_array[a]] = true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // Step by &quot;boards&quot;, then by &quot;slot&quot;, copying to &quot;assigned&quot;.</span>
<span class="line-removed">-   // NEEDS_CLEANUP: The assignment of processors should be stateful,</span>
<span class="line-removed">-   //                remembering which processors have been assigned by</span>
<span class="line-removed">-   //                previous calls, etc., so as to distribute several</span>
<span class="line-removed">-   //                independent calls of this method.  What we&#39;d like is</span>
<span class="line-removed">-   //                It would be nice to have an API that let us ask</span>
<span class="line-removed">-   //                how many processes are bound to a processor,</span>
<span class="line-removed">-   //                but we don&#39;t have that, either.</span>
<span class="line-removed">-   //                In the short term, &quot;board&quot; is static so that</span>
<span class="line-removed">-   //                subsequent distributions don&#39;t all start at board 0.</span>
<span class="line-removed">-   static uint board = 0;</span>
<span class="line-removed">-   uint assigned = 0;</span>
<span class="line-removed">-   // Until we&#39;ve found enough processors ....</span>
<span class="line-removed">-   while (assigned &lt; distribution_length) {</span>
<span class="line-removed">-     // ... find the next available processor in the board.</span>
<span class="line-removed">-     for (uint slot = 0; slot &lt; processors_per_board; slot += 1) {</span>
<span class="line-removed">-       uint try_id = board * processors_per_board + slot;</span>
<span class="line-removed">-       if ((try_id &lt; limit_id) &amp;&amp; (available_id[try_id] == true)) {</span>
<span class="line-removed">-         distribution[assigned] = try_id;</span>
<span class="line-removed">-         available_id[try_id] = false;</span>
<span class="line-removed">-         assigned += 1;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     board += 1;</span>
<span class="line-removed">-     if (board * processors_per_board + 0 &gt;= limit_id) {</span>
<span class="line-removed">-       board = 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (available_id != NULL) {</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(bool, available_id);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void os::set_native_thread_name(const char *name) {
    if (Solaris::_pthread_setname_np != NULL) {
      // Only the first 31 bytes of &#39;name&#39; are processed by pthread_setname_np
      // but we explicitly copy into a size-limited buffer to avoid any
      // possible overflow.
<span class="line-new-header">--- 315,17 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 468,37 ***</span>
      buf[sizeof(buf) - 1] = &#39;\0&#39;;
      Solaris::_pthread_setname_np(pthread_self(), buf);
    }
  }
  
<span class="line-removed">- bool os::distribute_processes(uint length, uint* distribution) {</span>
<span class="line-removed">-   bool result = false;</span>
<span class="line-removed">-   // Find the processor id&#39;s of all the available CPUs.</span>
<span class="line-removed">-   processorid_t* id_array  = NULL;</span>
<span class="line-removed">-   uint           id_length = 0;</span>
<span class="line-removed">-   // There are some races between querying information and using it,</span>
<span class="line-removed">-   // since processor sets can change dynamically.</span>
<span class="line-removed">-   psetid_t pset = PS_NONE;</span>
<span class="line-removed">-   // Are we running in a processor set?</span>
<span class="line-removed">-   if ((pset_bind(PS_QUERY, P_PID, P_MYID, &amp;pset) == 0) &amp;&amp; pset != PS_NONE) {</span>
<span class="line-removed">-     result = find_processors_in_pset(pset, &amp;id_array, &amp;id_length);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     result = find_processors_online(&amp;id_array, &amp;id_length);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (result == true) {</span>
<span class="line-removed">-     if (id_length &gt;= length) {</span>
<span class="line-removed">-       result = assign_distribution(id_array, id_length, distribution, length);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       result = false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (id_array != NULL) {</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(processorid_t, id_array);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return result;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool os::bind_to_processor(uint processor_id) {
    // We assume that a processorid_t can be stored in a uint.
    assert(sizeof(uint) == sizeof(processorid_t),
           &quot;can&#39;t convert uint to processorid_t&quot;);
    int bind_result =
<span class="line-new-header">--- 334,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 558,11 ***</span>
    // by the nulls included by the sizeof operator.
    const size_t bufsize =
      MAX3((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
           sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;), // invariant ld_library_path
           (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="line-modified">!   char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
  
    // sysclasspath, java_home, dll_dir
    {
      char *pslash;
      os::jvm_path(buf, bufsize);
<span class="line-new-header">--- 397,11 ---</span>
    // by the nulls included by the sizeof operator.
    const size_t bufsize =
      MAX3((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
           sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;), // invariant ld_library_path
           (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="line-modified">!   char *buf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
  
    // sysclasspath, java_home, dll_dir
    {
      char *pslash;
      os::jvm_path(buf, bufsize);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 644,11 ***</span>
  
      // Struct size is more than sufficient for the path components obtained
      // through the dlinfo() call, so only add additional space for the path
      // components explicitly added here.
      size_t library_path_size = info-&gt;dls_size + strlen(common_path);
<span class="line-modified">!     library_path = (char *)NEW_C_HEAP_ARRAY(char, library_path_size, mtInternal);</span>
      library_path[0] = &#39;\0&#39;;
  
      // Construct the desired Java library path from the linker&#39;s library
      // search path.
      //
<span class="line-new-header">--- 483,11 ---</span>
  
      // Struct size is more than sufficient for the path components obtained
      // through the dlinfo() call, so only add additional space for the path
      // components explicitly added here.
      size_t library_path_size = info-&gt;dls_size + strlen(common_path);
<span class="line-modified">!     library_path = NEW_C_HEAP_ARRAY(char, library_path_size, mtInternal);</span>
      library_path[0] = &#39;\0&#39;;
  
      // Construct the desired Java library path from the linker&#39;s library
      // search path.
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 990,10 ***</span>
<span class="line-new-header">--- 829,15 ---</span>
      log_info(os, thread)(&quot;Thread started (tid: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
        (uintx) tid, describe_thr_create_attributes(buf, sizeof(buf), stack_size, flags));
    } else {
      log_warning(os, thread)(&quot;Failed to start thread - thr_create failed (%s) for attributes: %s.&quot;,
        os::errno_name(status), describe_thr_create_attributes(buf, sizeof(buf), stack_size, flags));
<span class="line-added">+     // Log some OS information which might explain why creating the thread failed.</span>
<span class="line-added">+     log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());</span>
<span class="line-added">+     LogStream st(Log(os, thread)::info());</span>
<span class="line-added">+     os::Posix::print_rlimit_info(&amp;st);</span>
<span class="line-added">+     os::print_memory_info(&amp;st);</span>
    }
  
    if (status != 0) {
      thread-&gt;set_osthread(NULL);
      // Need to clean up stuff we&#39;ve allocated so far
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1178,11 ***</span>
    const hrtime_t now = gethrtime();
    const hrtime_t prev = max_hrtime;
    if (now &lt;= prev) {
      return prev;   // same or retrograde time;
    }
<span class="line-modified">!   const hrtime_t obsv = Atomic::cmpxchg(now, &amp;max_hrtime, prev);</span>
    assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
    // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
    // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
    // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
    // some other thread raced this thread and installed a new value, in which case
<span class="line-new-header">--- 1022,11 ---</span>
    const hrtime_t now = gethrtime();
    const hrtime_t prev = max_hrtime;
    if (now &lt;= prev) {
      return prev;   // same or retrograde time;
    }
<span class="line-modified">!   const hrtime_t obsv = Atomic::cmpxchg(&amp;max_hrtime, prev, now);</span>
    assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
    // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
    // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
    // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
    // some other thread raced this thread and installed a new value, in which case
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1232,12 ***</span>
      return true;
    }
  }
  
  bool os::supports_vtime() { return true; }
<span class="line-removed">- bool os::enable_vtime() { return false; }</span>
<span class="line-removed">- bool os::vtime_enabled() { return false; }</span>
  
  double os::elapsedVTime() {
    return (double)gethrvtime() / (double)hrtime_hz;
  }
  
<span class="line-new-header">--- 1076,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1325,12 ***</span>
  
    ::exit(1);
  }
  
  // Die immediately, no exit hook, no abort hook, no cleanup.
  void os::die() {
<span class="line-modified">!   ::abort(); // dump core (for debugging)</span>
  }
  
  // DLL functions
  
  const char* os::dll_file_extension() { return &quot;.so&quot;; }
<span class="line-new-header">--- 1167,19 ---</span>
  
    ::exit(1);
  }
  
  // Die immediately, no exit hook, no abort hook, no cleanup.
<span class="line-added">+ // Dump a core file, if possible, for debugging.</span>
  void os::die() {
<span class="line-modified">!   if (TestUnresponsiveErrorHandler &amp;&amp; !CreateCoredumpOnCrash) {</span>
<span class="line-added">+     // For TimeoutInErrorHandlingTest.java, we just kill the VM</span>
<span class="line-added">+     // and don&#39;t take the time to generate a core file.</span>
<span class="line-added">+     os::signal_raise(SIGKILL);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     ::abort();</span>
<span class="line-added">+   }</span>
  }
  
  // DLL functions
  
  const char* os::dll_file_extension() { return &quot;.so&quot;; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1504,27 ***</span>
    if (get_loaded_modules_info(_print_dll_info_cb, (void *)st)) {
      st-&gt;print_cr(&quot;Error: Cannot print dynamic libraries.&quot;);
    }
  }
  
  // Loads .dll/.so and
  // in case of error it checks if .dll/.so was built for the
  // same architecture as Hotspot is running on
  
  void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
    void * result= ::dlopen(filename, RTLD_LAZY);
    if (result != NULL) {
      // Successful loading
      return result;
    }
  
    Elf32_Ehdr elf_head;
  
<span class="line-removed">-   // Read system error message into ebuf</span>
<span class="line-removed">-   // It may or may not be overwritten below</span>
<span class="line-removed">-   ::strncpy(ebuf, ::dlerror(), ebuflen-1);</span>
<span class="line-removed">-   ebuf[ebuflen-1]=&#39;\0&#39;;</span>
    int diag_msg_max_length=ebuflen-strlen(ebuf);
    char* diag_msg_buf=ebuf+strlen(ebuf);
  
    if (diag_msg_max_length==0) {
      // No more space in ebuf for additional diagnostics message
<span class="line-new-header">--- 1353,45 ---</span>
    if (get_loaded_modules_info(_print_dll_info_cb, (void *)st)) {
      st-&gt;print_cr(&quot;Error: Cannot print dynamic libraries.&quot;);
    }
  }
  
<span class="line-added">+ static void change_endianness(Elf32_Half&amp; val) {</span>
<span class="line-added">+   unsigned char *ptr = (unsigned char *)&amp;val;</span>
<span class="line-added">+   unsigned char swp = ptr[0];</span>
<span class="line-added">+   ptr[0] = ptr[1];</span>
<span class="line-added">+   ptr[1] = swp;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Loads .dll/.so and
  // in case of error it checks if .dll/.so was built for the
  // same architecture as Hotspot is running on
  
  void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
<span class="line-added">+   log_info(os)(&quot;attempting shared library load of %s&quot;, filename);</span>
<span class="line-added">+ </span>
    void * result= ::dlopen(filename, RTLD_LAZY);
    if (result != NULL) {
      // Successful loading
<span class="line-added">+     Events::log(NULL, &quot;Loaded shared library %s&quot;, filename);</span>
<span class="line-added">+     log_info(os)(&quot;shared library load of %s was successful&quot;, filename);</span>
      return result;
    }
  
    Elf32_Ehdr elf_head;
<span class="line-added">+   const char* error_report = ::dlerror();</span>
<span class="line-added">+   if (error_report == NULL) {</span>
<span class="line-added">+     error_report = &quot;dlerror returned no error description&quot;;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (ebuf != NULL &amp;&amp; ebuflen &gt; 0) {</span>
<span class="line-added">+     ::strncpy(ebuf, error_report, ebuflen-1);</span>
<span class="line-added">+     ebuf[ebuflen-1]=&#39;\0&#39;;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Events::log(NULL, &quot;Loading shared library %s failed, %s&quot;, filename, error_report);</span>
<span class="line-added">+   log_info(os)(&quot;shared library load of %s failed, %s&quot;, filename, error_report);</span>
  
    int diag_msg_max_length=ebuflen-strlen(ebuf);
    char* diag_msg_buf=ebuf+strlen(ebuf);
  
    if (diag_msg_max_length==0) {
      // No more space in ebuf for additional diagnostics message
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1547,29 ***</span>
    if (failed_to_read_elf_head) {
      // file i/o error - report dlerror() msg
      return NULL;
    }
  
    typedef struct {
      Elf32_Half    code;         // Actual value as defined in elf.h
      Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
      unsigned char elf_class;    // 32 or 64 bit
      unsigned char endianess;    // MSB or LSB
      char*         name;         // String representation
    } arch_t;
  
    static const arch_t arch_array[]={
      {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
      {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
      {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
      {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
      {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
      {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
      {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
      {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
      {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)&quot;Power PC 64&quot;},
<span class="line-modified">!     {EM_ARM,         EM_ARM,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;ARM 32&quot;}</span>
    };
  
  #if  (defined IA32)
    static  Elf32_Half running_arch_code=EM_386;
  #elif   (defined AMD64)
<span class="line-new-header">--- 1414,44 ---</span>
    if (failed_to_read_elf_head) {
      // file i/o error - report dlerror() msg
      return NULL;
    }
  
<span class="line-added">+   if (elf_head.e_ident[EI_DATA] != LITTLE_ENDIAN_ONLY(ELFDATA2LSB) BIG_ENDIAN_ONLY(ELFDATA2MSB)) {</span>
<span class="line-added">+     // handle invalid/out of range endianness values</span>
<span class="line-added">+     if (elf_head.e_ident[EI_DATA] == 0 || elf_head.e_ident[EI_DATA] &gt; 2) {</span>
<span class="line-added">+       return NULL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     change_endianness(elf_head.e_machine);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    typedef struct {
      Elf32_Half    code;         // Actual value as defined in elf.h
      Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
      unsigned char elf_class;    // 32 or 64 bit
      unsigned char endianess;    // MSB or LSB
      char*         name;         // String representation
    } arch_t;
  
<span class="line-added">+ #ifndef EM_AARCH64</span>
<span class="line-added">+   #define EM_AARCH64    183               /* ARM AARCH64 */</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
    static const arch_t arch_array[]={
      {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
      {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
      {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
      {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
      {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
      {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
      {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
      {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
      {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)&quot;Power PC 64&quot;},
<span class="line-modified">!     {EM_ARM,         EM_ARM,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;ARM&quot;},</span>
<span class="line-added">+     // we only support 64 bit z architecture</span>
<span class="line-added">+     {EM_S390,        EM_S390,    ELFCLASS64, ELFDATA2MSB, (char*)&quot;IBM System/390&quot;},</span>
<span class="line-added">+     {EM_AARCH64,     EM_AARCH64, ELFCLASS64, ELFDATA2LSB, (char*)&quot;AARCH64&quot;}</span>
    };
  
  #if  (defined IA32)
    static  Elf32_Half running_arch_code=EM_386;
  #elif   (defined AMD64)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1589,11 ***</span>
  #else
    #error Method os::dll_load requires that one of following is defined:\
         IA32, AMD64, IA64, __sparc, __powerpc__, ARM, ARM
  #endif
  
<span class="line-modified">!   // Identify compatability class for VM&#39;s architecture and library&#39;s architecture</span>
    // Obtain string descriptions for architectures
  
    arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};
    int running_arch_index=-1;
  
<span class="line-new-header">--- 1471,11 ---</span>
  #else
    #error Method os::dll_load requires that one of following is defined:\
         IA32, AMD64, IA64, __sparc, __powerpc__, ARM, ARM
  #endif
  
<span class="line-modified">!   // Identify compatibility class for VM&#39;s architecture and library&#39;s architecture</span>
    // Obtain string descriptions for architectures
  
    arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};
    int running_arch_index=-1;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1613,31 ***</span>
      // Even though running architecture detection failed
      // we may still continue with reporting dlerror() message
      return NULL;
    }
  
    if (lib_arch.endianess != arch_array[running_arch_index].endianess) {
      ::snprintf(diag_msg_buf, diag_msg_max_length-1,&quot; (Possible cause: endianness mismatch)&quot;);
      return NULL;
    }
  
<span class="line-modified">!   if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {</span>
<span class="line-modified">!     ::snprintf(diag_msg_buf, diag_msg_max_length-1,&quot; (Possible cause: architecture word width mismatch)&quot;);</span>
      return NULL;
    }
  
<span class="line-modified">!   if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {</span>
<span class="line-modified">!     if (lib_arch.name!=NULL) {</span>
<span class="line-modified">!       ::snprintf(diag_msg_buf, diag_msg_max_length-1,</span>
<span class="line-modified">!                  &quot; (Possible cause: can&#39;t load %s-bit .so on a %s-bit platform)&quot;,</span>
<span class="line-modified">!                  lib_arch.name, arch_array[running_arch_index].name);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       ::snprintf(diag_msg_buf, diag_msg_max_length-1,</span>
<span class="line-removed">-                  &quot; (Possible cause: can&#39;t load this .so (machine code=0x%x) on a %s-bit platform)&quot;,</span>
<span class="line-removed">-                  lib_arch.code,</span>
<span class="line-removed">-                  arch_array[running_arch_index].name);</span>
<span class="line-removed">-     }</span>
    }
  
    return NULL;
  }
  
<span class="line-new-header">--- 1495,39 ---</span>
      // Even though running architecture detection failed
      // we may still continue with reporting dlerror() message
      return NULL;
    }
  
<span class="line-added">+   if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {</span>
<span class="line-added">+     if (lib_arch.name != NULL) {</span>
<span class="line-added">+       ::snprintf(diag_msg_buf, diag_msg_max_length-1,</span>
<span class="line-added">+                  &quot; (Possible cause: can&#39;t load %s .so on a %s platform)&quot;,</span>
<span class="line-added">+                  lib_arch.name, arch_array[running_arch_index].name);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       ::snprintf(diag_msg_buf, diag_msg_max_length-1,</span>
<span class="line-added">+                  &quot; (Possible cause: can&#39;t load this .so (machine code=0x%x) on a %s platform)&quot;,</span>
<span class="line-added">+                  lib_arch.code, arch_array[running_arch_index].name);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (lib_arch.endianess != arch_array[running_arch_index].endianess) {
      ::snprintf(diag_msg_buf, diag_msg_max_length-1,&quot; (Possible cause: endianness mismatch)&quot;);
      return NULL;
    }
  
<span class="line-modified">!   // ELF file class/capacity : 0 - invalid, 1 - 32bit, 2 - 64bit</span>
<span class="line-modified">!   if (lib_arch.elf_class &gt; 2 || lib_arch.elf_class &lt; 1) {</span>
<span class="line-added">+     ::snprintf(diag_msg_buf, diag_msg_max_length-1, &quot; (Possible cause: invalid ELF file class)&quot;);</span>
      return NULL;
    }
  
<span class="line-modified">!   if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {</span>
<span class="line-modified">!     ::snprintf(diag_msg_buf, diag_msg_max_length-1,</span>
<span class="line-modified">!                &quot; (Possible cause: architecture word width mismatch, can&#39;t load %d-bit .so on a %d-bit platform)&quot;,</span>
<span class="line-modified">!                (int) lib_arch.elf_class * 32, arch_array[running_arch_index].elf_class * 32);</span>
<span class="line-modified">!     return NULL;</span>
    }
  
    return NULL;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1692,10 ***</span>
<span class="line-new-header">--- 1582,12 ---</span>
  
    os::Solaris::print_distro_info(st);
  
    os::Posix::print_uname_info(st);
  
<span class="line-added">+   os::Posix::print_uptime_info(st);</span>
<span class="line-added">+ </span>
    os::Solaris::print_libversion_info(st);
  
    os::Posix::print_rlimit_info(st);
  
    os::Posix::print_load_average(st);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2018,10 ***</span>
<span class="line-new-header">--- 1910,11 ---</span>
  
  void* os::signal(int signal_number, void* handler) {
    struct sigaction sigAct, oldSigAct;
    sigfillset(&amp;(sigAct.sa_mask));
    sigAct.sa_flags = SA_RESTART &amp; ~SA_RESETHAND;
<span class="line-added">+   sigAct.sa_flags |= SA_SIGINFO;</span>
    sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);
  
    if (sigaction(signal_number, &amp;sigAct, &amp;oldSigAct)) {
      // -1 means registration failed
      return (void *)-1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2091,11 ***</span>
  static int check_pending_signals() {
    int ret;
    while (true) {
      for (int i = 0; i &lt; Sigexit + 1; i++) {
        jint n = pending_signals[i];
<span class="line-modified">!       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(n - 1, &amp;pending_signals[i], n)) {</span>
          return i;
        }
      }
      JavaThread *thread = JavaThread::current();
      ThreadBlockInVM tbivm(thread);
<span class="line-new-header">--- 1984,11 ---</span>
  static int check_pending_signals() {
    int ret;
    while (true) {
      for (int i = 0; i &lt; Sigexit + 1; i++) {
        jint n = pending_signals[i];
<span class="line-modified">!       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {</span>
          return i;
        }
      }
      JavaThread *thread = JavaThread::current();
      ThreadBlockInVM tbivm(thread);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2179,11 ***</span>
    int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
    size_t size = bytes;
    char *res = Solaris::mmap_chunk(addr, size, MAP_PRIVATE|MAP_FIXED, prot);
    if (res != NULL) {
      if (UseNUMAInterleaving) {
<span class="line-modified">!       numa_make_global(addr, bytes);</span>
      }
      return 0;
    }
  
    int err = errno;  // save errno from mmap() call in mmap_chunk()
<span class="line-new-header">--- 2072,11 ---</span>
    int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
    size_t size = bytes;
    char *res = Solaris::mmap_chunk(addr, size, MAP_PRIVATE|MAP_FIXED, prot);
    if (res != NULL) {
      if (UseNUMAInterleaving) {
<span class="line-modified">!         numa_make_global(addr, bytes);</span>
      }
      return 0;
    }
  
    int err = errno;  // save errno from mmap() call in mmap_chunk()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2374,10 ***</span>
<span class="line-new-header">--- 2267,14 ---</span>
      return 0;
    }
    return ids[os::random() % r];
  }
  
<span class="line-added">+ int os::numa_get_group_id_for_address(const void* address) {</span>
<span class="line-added">+   return 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Request information about the page.
  bool os::get_page_info(char *start, page_info* info) {
    const uint_t info_types[] = { MEMINFO_VLGRP, MEMINFO_VPAGESIZE };
    uint64_t addr = (uintptr_t)start;
    uint64_t outdata[2];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2529,138 ***</span>
  
  // Reserve memory at an arbitrary address, only if that area is
  // available (and not reserved for something else).
  
  char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
<span class="line-removed">-   const int max_tries = 10;</span>
<span class="line-removed">-   char* base[max_tries];</span>
<span class="line-removed">-   size_t size[max_tries];</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Solaris adds a gap between mmap&#39;ed regions.  The size of the gap</span>
<span class="line-removed">-   // is dependent on the requested size and the MMU.  Our initial gap</span>
<span class="line-removed">-   // value here is just a guess and will be corrected later.</span>
<span class="line-removed">-   bool had_top_overlap = false;</span>
<span class="line-removed">-   bool have_adjusted_gap = false;</span>
<span class="line-removed">-   size_t gap = 0x400000;</span>
<span class="line-removed">- </span>
    // Assert only that the size is a multiple of the page size, since
    // that&#39;s all that mmap requires, and since that&#39;s all we really know
    // about at this low abstraction level.  If we need higher alignment,
    // we can either pass an alignment to this method or verify alignment
    // in one of the methods further up the call chain.  See bug 5044738.
    assert(bytes % os::vm_page_size() == 0, &quot;reserving unexpected size block&quot;);
  
    // Since snv_84, Solaris attempts to honor the address hint - see 5003415.
<span class="line-removed">-   // Give it a try, if the kernel honors the hint we can return immediately.</span>
    char* addr = Solaris::anon_mmap(requested_addr, bytes, 0, false);
  
    volatile int err = errno;
    if (addr == requested_addr) {
      return addr;
<span class="line-removed">-   } else if (addr != NULL) {</span>
<span class="line-removed">-     pd_unmap_memory(addr, bytes);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (log_is_enabled(Warning, os)) {</span>
<span class="line-removed">-     char buf[256];</span>
<span class="line-removed">-     buf[0] = &#39;\0&#39;;</span>
<span class="line-removed">-     if (addr == NULL) {</span>
<span class="line-removed">-       jio_snprintf(buf, sizeof(buf), &quot;: %s&quot;, os::strerror(err));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     log_info(os)(&quot;attempt_reserve_memory_at: couldn&#39;t reserve &quot; SIZE_FORMAT &quot; bytes at &quot;</span>
<span class="line-removed">-             PTR_FORMAT &quot;: reserve_memory_helper returned &quot; PTR_FORMAT</span>
<span class="line-removed">-             &quot;%s&quot;, bytes, requested_addr, addr, buf);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Address hint method didn&#39;t work.  Fall back to the old method.</span>
<span class="line-removed">-   // In theory, once SNV becomes our oldest supported platform, this</span>
<span class="line-removed">-   // code will no longer be needed.</span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   // Repeatedly allocate blocks until the block is allocated at the</span>
<span class="line-removed">-   // right spot. Give up after max_tries.</span>
<span class="line-removed">-   int i;</span>
<span class="line-removed">-   for (i = 0; i &lt; max_tries; ++i) {</span>
<span class="line-removed">-     base[i] = reserve_memory(bytes);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (base[i] != NULL) {</span>
<span class="line-removed">-       // Is this the block we wanted?</span>
<span class="line-removed">-       if (base[i] == requested_addr) {</span>
<span class="line-removed">-         size[i] = bytes;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // check that the gap value is right</span>
<span class="line-removed">-       if (had_top_overlap &amp;&amp; !have_adjusted_gap) {</span>
<span class="line-removed">-         size_t actual_gap = base[i-1] - base[i] - bytes;</span>
<span class="line-removed">-         if (gap != actual_gap) {</span>
<span class="line-removed">-           // adjust the gap value and retry the last 2 allocations</span>
<span class="line-removed">-           assert(i &gt; 0, &quot;gap adjustment code problem&quot;);</span>
<span class="line-removed">-           have_adjusted_gap = true;  // adjust the gap only once, just in case</span>
<span class="line-removed">-           gap = actual_gap;</span>
<span class="line-removed">-           log_info(os)(&quot;attempt_reserve_memory_at: adjusted gap to 0x%lx&quot;, gap);</span>
<span class="line-removed">-           unmap_memory(base[i], bytes);</span>
<span class="line-removed">-           unmap_memory(base[i-1], size[i-1]);</span>
<span class="line-removed">-           i-=2;</span>
<span class="line-removed">-           continue;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // Does this overlap the block we wanted? Give back the overlapped</span>
<span class="line-removed">-       // parts and try again.</span>
<span class="line-removed">-       //</span>
<span class="line-removed">-       // There is still a bug in this code: if top_overlap == bytes,</span>
<span class="line-removed">-       // the overlap is offset from requested region by the value of gap.</span>
<span class="line-removed">-       // In this case giving back the overlapped part will not work,</span>
<span class="line-removed">-       // because we&#39;ll give back the entire block at base[i] and</span>
<span class="line-removed">-       // therefore the subsequent allocation will not generate a new gap.</span>
<span class="line-removed">-       // This could be fixed with a new algorithm that used larger</span>
<span class="line-removed">-       // or variable size chunks to find the requested region -</span>
<span class="line-removed">-       // but such a change would introduce additional complications.</span>
<span class="line-removed">-       // It&#39;s rare enough that the planets align for this bug,</span>
<span class="line-removed">-       // so we&#39;ll just wait for a fix for 6204603/5003415 which</span>
<span class="line-removed">-       // will provide a mmap flag to allow us to avoid this business.</span>
<span class="line-removed">- </span>
<span class="line-removed">-       size_t top_overlap = requested_addr + (bytes + gap) - base[i];</span>
<span class="line-removed">-       if (top_overlap &gt;= 0 &amp;&amp; top_overlap &lt; bytes) {</span>
<span class="line-removed">-         had_top_overlap = true;</span>
<span class="line-removed">-         unmap_memory(base[i], top_overlap);</span>
<span class="line-removed">-         base[i] += top_overlap;</span>
<span class="line-removed">-         size[i] = bytes - top_overlap;</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         size_t bottom_overlap = base[i] + bytes - requested_addr;</span>
<span class="line-removed">-         if (bottom_overlap &gt;= 0 &amp;&amp; bottom_overlap &lt; bytes) {</span>
<span class="line-removed">-           if (bottom_overlap == 0) {</span>
<span class="line-removed">-             log_info(os)(&quot;attempt_reserve_memory_at: possible alignment bug&quot;);</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           unmap_memory(requested_addr, bottom_overlap);</span>
<span class="line-removed">-           size[i] = bytes - bottom_overlap;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           size[i] = bytes;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
    }
  
<span class="line-modified">!   // Give back the unused reserved pieces.</span>
<span class="line-modified">! </span>
<span class="line-removed">-   for (int j = 0; j &lt; i; ++j) {</span>
<span class="line-removed">-     if (base[j] != NULL) {</span>
<span class="line-removed">-       unmap_memory(base[j], size[j]);</span>
<span class="line-removed">-     }</span>
    }
  
<span class="line-modified">!   return (i &lt; max_tries) ? requested_addr : NULL;</span>
  }
  
  bool os::pd_release_memory(char* addr, size_t bytes) {
    size_t size = bytes;
    return munmap(addr, size) == 0;
  }
  
  static bool solaris_mprotect(char* addr, size_t bytes, int prot) {
    assert(addr == (char*)align_down((uintptr_t)addr, os::vm_page_size()),
           &quot;addr must be page aligned&quot;);
    int retVal = mprotect(addr, bytes, prot);
    return retVal == 0;
  }
  
  // Protect memory (Used to pass readonly pages through
<span class="line-new-header">--- 2426,41 ---</span>
  
  // Reserve memory at an arbitrary address, only if that area is
  // available (and not reserved for something else).
  
  char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
    // Assert only that the size is a multiple of the page size, since
    // that&#39;s all that mmap requires, and since that&#39;s all we really know
    // about at this low abstraction level.  If we need higher alignment,
    // we can either pass an alignment to this method or verify alignment
    // in one of the methods further up the call chain.  See bug 5044738.
    assert(bytes % os::vm_page_size() == 0, &quot;reserving unexpected size block&quot;);
  
    // Since snv_84, Solaris attempts to honor the address hint - see 5003415.
    char* addr = Solaris::anon_mmap(requested_addr, bytes, 0, false);
  
    volatile int err = errno;
    if (addr == requested_addr) {
      return addr;
    }
  
<span class="line-modified">!   if (addr != NULL) {</span>
<span class="line-modified">!     pd_unmap_memory(addr, bytes);</span>
    }
  
<span class="line-modified">!   return NULL;</span>
  }
  
  bool os::pd_release_memory(char* addr, size_t bytes) {
    size_t size = bytes;
    return munmap(addr, size) == 0;
  }
  
  static bool solaris_mprotect(char* addr, size_t bytes, int prot) {
    assert(addr == (char*)align_down((uintptr_t)addr, os::vm_page_size()),
           &quot;addr must be page aligned&quot;);
<span class="line-added">+   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(addr), p2i(addr+bytes), prot);</span>
    int retVal = mprotect(addr, bytes, prot);
    return retVal == 0;
  }
  
  // Protect memory (Used to pass readonly pages through
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3888,19 ***</span>
    // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
    // and if UserSignalHandler is installed all bets are off.
    // Log that signal checking is off only if -verbose:jni is specified.
    if (CheckJNICalls) {
      if (libjsig_is_loaded) {
<span class="line-modified">!       if (PrintJNIResolving) {</span>
<span class="line-removed">-         tty-&gt;print_cr(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>
<span class="line-removed">-       }</span>
        check_signals = false;
      }
      if (AllowUserSignalHandlers) {
<span class="line-modified">!       if (PrintJNIResolving) {</span>
<span class="line-removed">-         tty-&gt;print_cr(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>
<span class="line-removed">-       }</span>
        check_signals = false;
      }
    }
  }
  
<span class="line-new-header">--- 3688,15 ---</span>
    // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
    // and if UserSignalHandler is installed all bets are off.
    // Log that signal checking is off only if -verbose:jni is specified.
    if (CheckJNICalls) {
      if (libjsig_is_loaded) {
<span class="line-modified">!       log_debug(jni, resolve)(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>
        check_signals = false;
      }
      if (AllowUserSignalHandlers) {
<span class="line-modified">!       log_debug(jni, resolve)(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>
        check_signals = false;
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4220,17 ***</span>
<span class="line-new-header">--- 4016,19 ---</span>
    return JNI_OK;
  }
  
  // Mark the polling page as unreadable
  void os::make_polling_page_unreadable(void) {
<span class="line-added">+   Events::log(NULL, &quot;Protecting polling page &quot; INTPTR_FORMAT &quot; with PROT_NONE&quot;, p2i(_polling_page));</span>
    if (mprotect((char *)_polling_page, page_size, PROT_NONE) != 0) {
      fatal(&quot;Could not disable polling page&quot;);
    }
  }
  
  // Mark the polling page as readable
  void os::make_polling_page_readable(void) {
<span class="line-added">+   Events::log(NULL, &quot;Protecting polling page &quot; INTPTR_FORMAT &quot; with PROT_READ&quot;, p2i(_polling_page));</span>
    if (mprotect((char *)_polling_page, page_size, PROT_READ) != 0) {
      fatal(&quot;Could not enable polling page&quot;);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4469,11 ***</span>
  }
  
  void os::pause() {
    char filename[MAX_PATH];
    if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">!     jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);</span>
    } else {
      jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
    }
  
    int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
<span class="line-new-header">--- 4267,11 ---</span>
  }
  
  void os::pause() {
    char filename[MAX_PATH];
    if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">!     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);</span>
    } else {
      jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
    }
  
    int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4912,11 ***</span>
    assert(_nParked == 0, &quot;invariant&quot;);
  
    int v;
    for (;;) {
      v = _Event;
<span class="line-modified">!     if (Atomic::cmpxchg(v-1, &amp;_Event, v) == v) break;</span>
    }
    guarantee(v &gt;= 0, &quot;invariant&quot;);
    if (v == 0) {
      // Do this the hard way by blocking ...
      // See http://monaco.sfbay/detail.jsf?cr=5094058.
<span class="line-new-header">--- 4710,11 ---</span>
    assert(_nParked == 0, &quot;invariant&quot;);
  
    int v;
    for (;;) {
      v = _Event;
<span class="line-modified">!     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;</span>
    }
    guarantee(v &gt;= 0, &quot;invariant&quot;);
    if (v == 0) {
      // Do this the hard way by blocking ...
      // See http://monaco.sfbay/detail.jsf?cr=5094058.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4950,11 ***</span>
  
    guarantee(_nParked == 0, &quot;invariant&quot;);
    int v;
    for (;;) {
      v = _Event;
<span class="line-modified">!     if (Atomic::cmpxchg(v-1, &amp;_Event, v) == v) break;</span>
    }
    guarantee(v &gt;= 0, &quot;invariant&quot;);
    if (v != 0) return OS_OK;
  
    int ret = OS_TIMEOUT;
<span class="line-new-header">--- 4748,11 ---</span>
  
    guarantee(_nParked == 0, &quot;invariant&quot;);
    int v;
    for (;;) {
      v = _Event;
<span class="line-modified">!     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;</span>
    }
    guarantee(v &gt;= 0, &quot;invariant&quot;);
    if (v != 0) return OS_OK;
  
    int ret = OS_TIMEOUT;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4999,11 ***</span>
    // that it will take two back-to-back park() calls for the owning
    // thread to block. This has the benefit of forcing a spurious return
    // from the first park() call after an unpark() call which will help
    // shake out uses of park() and unpark() without condition variables.
  
<span class="line-modified">!   if (Atomic::xchg(1, &amp;_Event) &gt;= 0) return;</span>
  
    // If the thread associated with the event was parked, wake it.
    // Wait for the thread assoc with the PlatformEvent to vacate.
    int status = os::Solaris::mutex_lock(_mutex);
    assert_status(status == 0, status, &quot;mutex_lock&quot;);
<span class="line-new-header">--- 4797,11 ---</span>
    // that it will take two back-to-back park() calls for the owning
    // thread to block. This has the benefit of forcing a spurious return
    // from the first park() call after an unpark() call which will help
    // shake out uses of park() and unpark() without condition variables.
  
<span class="line-modified">!   if (Atomic::xchg(&amp;_Event, 1) &gt;= 0) return;</span>
  
    // If the thread associated with the event was parked, wake it.
    // Wait for the thread assoc with the PlatformEvent to vacate.
    int status = os::Solaris::mutex_lock(_mutex);
    assert_status(status == 0, status, &quot;mutex_lock&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5098,17 ***</span>
  
    // Optional fast-path check:
    // Return immediately if a permit is available.
    // We depend on Atomic::xchg() having full barrier semantics
    // since we are doing a lock-free update to _counter.
<span class="line-modified">!   if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;</span>
  
    // Optional fast-exit: Check interrupt before trying to wait
    Thread* thread = Thread::current();
    assert(thread-&gt;is_Java_thread(), &quot;Must be JavaThread&quot;);
    JavaThread *jt = (JavaThread *)thread;
<span class="line-modified">!   if (Thread::is_interrupted(thread, false)) {</span>
      return;
    }
  
    // First, demultiplex/decode time arguments
    timespec absTime;
<span class="line-new-header">--- 4896,17 ---</span>
  
    // Optional fast-path check:
    // Return immediately if a permit is available.
    // We depend on Atomic::xchg() having full barrier semantics
    // since we are doing a lock-free update to _counter.
<span class="line-modified">!   if (Atomic::xchg(&amp;_counter, 0) &gt; 0) return;</span>
  
    // Optional fast-exit: Check interrupt before trying to wait
    Thread* thread = Thread::current();
    assert(thread-&gt;is_Java_thread(), &quot;Must be JavaThread&quot;);
    JavaThread *jt = (JavaThread *)thread;
<span class="line-modified">!   if (jt-&gt;is_interrupted(false)) {</span>
      return;
    }
  
    // First, demultiplex/decode time arguments
    timespec absTime;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5127,14 ***</span>
    // In particular a thread must never block on the Threads_lock while
    // holding the Parker:: mutex.  If safepoints are pending both the
    // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.
    ThreadBlockInVM tbivm(jt);
  
    // Don&#39;t wait if cannot get lock since interference arises from
<span class="line-modified">!   // unblocking.  Also. check interrupt before trying wait</span>
<span class="line-modified">!   if (Thread::is_interrupted(thread, false) ||</span>
<span class="line-removed">-       os::Solaris::mutex_trylock(_mutex) != 0) {</span>
      return;
    }
  
    int status;
  
<span class="line-new-header">--- 4925,16 ---</span>
    // In particular a thread must never block on the Threads_lock while
    // holding the Parker:: mutex.  If safepoints are pending both the
    // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.
    ThreadBlockInVM tbivm(jt);
  
<span class="line-added">+   // Can&#39;t access interrupt state now that we are _thread_blocked. If we&#39;ve</span>
<span class="line-added">+   // been interrupted since we checked above then _counter will be &gt; 0.</span>
<span class="line-added">+ </span>
    // Don&#39;t wait if cannot get lock since interference arises from
<span class="line-modified">!   // unblocking.</span>
<span class="line-modified">!   if (os::Solaris::mutex_trylock(_mutex) != 0) {</span>
      return;
    }
  
    int status;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5190,42 ***</span>
      status = os::Solaris::cond_signal(_cond);
      assert(status == 0, &quot;invariant&quot;);
    }
  }
  
<span class="line-modified">! // Platform Monitor implementation</span>
  
<span class="line-modified">! os::PlatformMonitor::PlatformMonitor() {</span>
<span class="line-modified">!   int status = os::Solaris::cond_init(&amp;_cond);</span>
<span class="line-removed">-   assert_status(status == 0, status, &quot;cond_init&quot;);</span>
<span class="line-removed">-   status = os::Solaris::mutex_init(&amp;_mutex);</span>
    assert_status(status == 0, status, &quot;mutex_init&quot;);
  }
  
<span class="line-modified">! os::PlatformMonitor::~PlatformMonitor() {</span>
<span class="line-modified">!   int status = os::Solaris::cond_destroy(&amp;_cond);</span>
<span class="line-removed">-   assert_status(status == 0, status, &quot;cond_destroy&quot;);</span>
<span class="line-removed">-   status = os::Solaris::mutex_destroy(&amp;_mutex);</span>
    assert_status(status == 0, status, &quot;mutex_destroy&quot;);
  }
  
<span class="line-modified">! void os::PlatformMonitor::lock() {</span>
    int status = os::Solaris::mutex_lock(&amp;_mutex);
    assert_status(status == 0, status, &quot;mutex_lock&quot;);
  }
  
<span class="line-modified">! void os::PlatformMonitor::unlock() {</span>
    int status = os::Solaris::mutex_unlock(&amp;_mutex);
    assert_status(status == 0, status, &quot;mutex_unlock&quot;);
  }
  
<span class="line-modified">! bool os::PlatformMonitor::try_lock() {</span>
    int status = os::Solaris::mutex_trylock(&amp;_mutex);
    assert_status(status == 0 || status == EBUSY, status, &quot;mutex_trylock&quot;);
    return status == 0;
  }
  
  // Must already be locked
  int os::PlatformMonitor::wait(jlong millis) {
    assert(millis &gt;= 0, &quot;negative timeout&quot;);
    if (millis &gt; 0) {
      timestruc_t abst;
<span class="line-new-header">--- 4990,48 ---</span>
      status = os::Solaris::cond_signal(_cond);
      assert(status == 0, &quot;invariant&quot;);
    }
  }
  
<span class="line-modified">! // Platform Mutex/Monitor implementations</span>
  
<span class="line-modified">! os::PlatformMutex::PlatformMutex() {</span>
<span class="line-modified">!   int status = os::Solaris::mutex_init(&amp;_mutex);</span>
    assert_status(status == 0, status, &quot;mutex_init&quot;);
  }
  
<span class="line-modified">! os::PlatformMutex::~PlatformMutex() {</span>
<span class="line-modified">!   int status = os::Solaris::mutex_destroy(&amp;_mutex);</span>
    assert_status(status == 0, status, &quot;mutex_destroy&quot;);
  }
  
<span class="line-modified">! void os::PlatformMutex::lock() {</span>
    int status = os::Solaris::mutex_lock(&amp;_mutex);
    assert_status(status == 0, status, &quot;mutex_lock&quot;);
  }
  
<span class="line-modified">! void os::PlatformMutex::unlock() {</span>
    int status = os::Solaris::mutex_unlock(&amp;_mutex);
    assert_status(status == 0, status, &quot;mutex_unlock&quot;);
  }
  
<span class="line-modified">! bool os::PlatformMutex::try_lock() {</span>
    int status = os::Solaris::mutex_trylock(&amp;_mutex);
    assert_status(status == 0 || status == EBUSY, status, &quot;mutex_trylock&quot;);
    return status == 0;
  }
  
<span class="line-added">+ os::PlatformMonitor::PlatformMonitor() {</span>
<span class="line-added">+   int status = os::Solaris::cond_init(&amp;_cond);</span>
<span class="line-added">+   assert_status(status == 0, status, &quot;cond_init&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ os::PlatformMonitor::~PlatformMonitor() {</span>
<span class="line-added">+   int status = os::Solaris::cond_destroy(&amp;_cond);</span>
<span class="line-added">+   assert_status(status == 0, status, &quot;cond_destroy&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Must already be locked
  int os::PlatformMonitor::wait(jlong millis) {
    assert(millis &gt;= 0, &quot;negative timeout&quot;);
    if (millis &gt; 0) {
      timestruc_t abst;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5415,10 ***</span>
<span class="line-new-header">--- 5221,14 ---</span>
                                                p, current_process_id());
  
    return strlen(buffer);
  }
  
<span class="line-added">+ bool os::supports_map_sync() {</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #ifndef PRODUCT
  void TestReserveMemorySpecial_test() {
    // No tests available for this platform
  }
  #endif
</pre>
<center><a href="os_perf_solaris.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_solaris.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
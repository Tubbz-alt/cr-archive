<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/os/solaris/attachListener_solaris.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 28 #include &quot;runtime/os.inline.hpp&quot;
 29 #include &quot;services/attachListener.hpp&quot;
 30 #include &quot;services/dtraceAttacher.hpp&quot;
 31 #include &quot;utilities/vmError.hpp&quot;
 32 
 33 #include &lt;door.h&gt;
 34 #include &lt;limits.h&gt;
 35 #include &lt;string.h&gt;
 36 #include &lt;signal.h&gt;
 37 #include &lt;sys/types.h&gt;
 38 #include &lt;sys/socket.h&gt;
 39 #include &lt;sys/stat.h&gt;
 40 
 41 // stropts.h uses STR in stream ioctl defines
 42 #undef STR
 43 #include &lt;stropts.h&gt;
 44 #undef STR
 45 #define STR(a) #a
 46 
 47 // The attach mechanism on Solaris is implemented using the Doors IPC
 48 // mechanism. The first tool to attempt to attach causes the attach
 49 // listener thread to startup. This thread creats a door that is
 50 // associated with a function that enqueues an operation to the attach
 51 // listener. The door is attached to a file in the file system so that
 52 // client (tools) can locate it. To enqueue an operation to the VM the
 53 // client calls through the door which invokes the enqueue function in
 54 // this process. The credentials of the client are checked and if the
 55 // effective uid matches this process then the operation is enqueued.
 56 // When an operation completes the attach listener is required to send the
 57 // operation result and any result data to the client. In this implementation
 58 // the result is returned via a UNIX domain socket. A pair of connected
 59 // sockets (socketpair) is created in the enqueue function and the file
 60 // descriptor for one of the sockets is returned to the client as the
 61 // return from the door call. The other end is retained in this process.
 62 // When the operation completes the result is sent to the client and
 63 // the socket is closed.
 64 
 65 // forward reference
 66 class SolarisAttachOperation;
 67 
 68 class SolarisAttachListener: AllStatic {
 69  private:
 70 
 71   // the path to which we attach the door file descriptor
 72   static char _door_path[PATH_MAX+1];
 73   static volatile bool _has_door_path;
 74 
 75   // door descriptor returned by door_create
 76   static int _door_descriptor;
 77 
 78   static void set_door_path(char* path) {
 79     if (path == NULL) {
 80       _has_door_path = false;
 81     } else {
 82       strncpy(_door_path, path, PATH_MAX);
 83       _door_path[PATH_MAX] = &#39;\0&#39;;      // ensure it&#39;s nul terminated
 84       _has_door_path = true;
 85     }
 86   }
 87 
 88   static void set_door_descriptor(int dd)               { _door_descriptor = dd; }
 89 
 90   // mutex to protect operation list
 91   static mutex_t _mutex;
 92 
 93   // semaphore to wakeup listener thread
 94   static sema_t _wakeup;
 95 
 96   static mutex_t* mutex()                               { return &amp;_mutex; }
 97   static sema_t* wakeup()                               { return &amp;_wakeup; }
 98 
 99   // enqueued operation list
100   static SolarisAttachOperation* _head;
101   static SolarisAttachOperation* _tail;
102 
103   static SolarisAttachOperation* head()                 { return _head; }
104   static void set_head(SolarisAttachOperation* head)    { _head = head; }
105 
106   static SolarisAttachOperation* tail()                 { return _tail; }
107   static void set_tail(SolarisAttachOperation* tail)    { _tail = tail; }
108 
109   // create the door
110   static int create_door();
111 
112  public:
113   enum {
114     ATTACH_PROTOCOL_VER = 1                             // protocol version
115   };
116   enum {
117     ATTACH_ERROR_BADREQUEST     = 100,                  // error code returned by
118     ATTACH_ERROR_BADVERSION     = 101,                  // the door call
119     ATTACH_ERROR_RESOURCE       = 102,
120     ATTACH_ERROR_INTERNAL       = 103,
121     ATTACH_ERROR_DENIED         = 104
122   };
123 
124   // initialize the listener
125   static int init();
126 
127   static bool has_door_path()                           { return _has_door_path; }
128   static char* door_path()                              { return _door_path; }
129   static int door_descriptor()                          { return _door_descriptor; }
130 
131   // enqueue an operation
132   static void enqueue(SolarisAttachOperation* op);
133 
134   // dequeue an operation
135   static SolarisAttachOperation* dequeue();
136 };
137 
138 
139 // SolarisAttachOperation is an AttachOperation that additionally encapsulates
140 // a socket connection to the requesting client/tool. SolarisAttachOperation
141 // can additionally be held in a linked list.
142 
143 class SolarisAttachOperation: public AttachOperation {
144  private:
145   friend class SolarisAttachListener;
146 
147   // connection to client
148   int _socket;
149 
150   // linked list support
151   SolarisAttachOperation* _next;
152 
153   SolarisAttachOperation* next()                         { return _next; }
154   void set_next(SolarisAttachOperation* next)            { _next = next; }
155 
156  public:
157   void complete(jint res, bufferedStream* st);
158 
159   int socket() const                                     { return _socket; }
160   void set_socket(int s)                                 { _socket = s; }
161 
162   SolarisAttachOperation(char* name) : AttachOperation(name) {
163     set_socket(-1);
164     set_next(NULL);
165   }
166 };
167 
168 // statics
169 char SolarisAttachListener::_door_path[PATH_MAX+1];
170 volatile bool SolarisAttachListener::_has_door_path;
171 int SolarisAttachListener::_door_descriptor = -1;
172 mutex_t SolarisAttachListener::_mutex;
173 sema_t SolarisAttachListener::_wakeup;
174 SolarisAttachOperation* SolarisAttachListener::_head = NULL;
175 SolarisAttachOperation* SolarisAttachListener::_tail = NULL;
176 
177 // Supporting class to help split a buffer into individual components
178 class ArgumentIterator : public StackObj {
179  private:
180   char* _pos;
181   char* _end;
182  public:
183   ArgumentIterator(char* arg_buffer, size_t arg_size) {
184     _pos = arg_buffer;
185     _end = _pos + arg_size - 1;
186   }
187   char* next() {
188     if (*_pos == &#39;\0&#39;) {
189       // advance the iterator if possible (null arguments)
190       if (_pos &lt; _end) {
191         _pos += 1;
192       }
193       return NULL;
194     }
195     char* res = _pos;
196     char* next_pos = strchr(_pos, &#39;\0&#39;);
197     if (next_pos &lt; _end)  {
198       next_pos++;
199     }
200     _pos = next_pos;
201     return res;
202   }
203 };
204 
205 // Calls from the door function to check that the client credentials
206 // match this process. Returns 0 if credentials okay, otherwise -1.
207 static int check_credentials() {
208   ucred_t *cred_info = NULL;
209   int ret = -1; // deny by default
210 
211   // get client credentials
212   if (door_ucred(&amp;cred_info) == -1) {
213     return -1; // unable to get them, deny
214   }
215 
216   // get euid/egid from ucred_free
217   uid_t ucred_euid = ucred_geteuid(cred_info);
218   gid_t ucred_egid = ucred_getegid(cred_info);
219 
220   // check that the effective uid/gid matches
221   if (os::Posix::matches_effective_uid_and_gid_or_root(ucred_euid, ucred_egid)) {
222     ret =  0;  // allow
223   }
224 
225   ucred_free(cred_info);
226   return ret;
227 }
228 
229 
230 // Parses the argument buffer to create an AttachOperation that we should
231 // enqueue to the attach listener.
232 // The buffer is expected to be formatted as follows:
233 // &lt;ver&gt;0&lt;cmd&gt;0&lt;arg&gt;0&lt;arg&gt;0&lt;arg&gt;0
234 // where &lt;ver&gt; is the version number (must be &quot;1&quot;), &lt;cmd&gt; is the command
235 // name (&quot;load, &quot;datadump&quot;, ...) and &lt;arg&gt; is an argument.
236 //
237 static SolarisAttachOperation* create_operation(char* argp, size_t arg_size, int* err) {
238   // assume bad request until parsed
239   *err = SolarisAttachListener::ATTACH_ERROR_BADREQUEST;
240 
241   if (arg_size &lt; 2 || argp[arg_size-1] != &#39;\0&#39;) {
242     return NULL;   // no ver or not null terminated
243   }
244 
245   // Use supporting class to iterate over the buffer
246   ArgumentIterator args(argp, arg_size);
247 
248   // First check the protocol version
249   char* ver = args.next();
250   if (ver == NULL) {
251     return NULL;
252   }
253   if (atoi(ver) != SolarisAttachListener::ATTACH_PROTOCOL_VER) {
254     *err = SolarisAttachListener::ATTACH_ERROR_BADVERSION;
255     return NULL;
256   }
257 
258   // Get command name and create the operation
259   char* name = args.next();
260   if (name == NULL || strlen(name) &gt; AttachOperation::name_length_max) {
261     return NULL;
262   }
263   SolarisAttachOperation* op = new SolarisAttachOperation(name);
264 
265   // Iterate over the arguments
266   for (int i=0; i&lt;AttachOperation::arg_count_max; i++) {
267     char* arg = args.next();
268     if (arg == NULL) {
269       op-&gt;set_arg(i, NULL);
270     } else {
271       if (strlen(arg) &gt; AttachOperation::arg_length_max) {
272         delete op;
273         return NULL;
274       }
275       op-&gt;set_arg(i, arg);
276     }
277   }
278 
279   // return operation
280   *err = 0;
281   return op;
282 }
283 
284 // create special operation to indicate all clients have detached
285 static SolarisAttachOperation* create_detachall_operation() {
286   return new SolarisAttachOperation(AttachOperation::detachall_operation_name());
287 }
288 
289 // This is door function which the client executes via a door_call.
290 extern &quot;C&quot; {
291   static void enqueue_proc(void* cookie, char* argp, size_t arg_size,
292                            door_desc_t* dt, uint_t n_desc)
293   {
294     int return_fd = -1;
295     SolarisAttachOperation* op = NULL;
296 
297     // wait up to 10 seconds for listener to be up and running
298     jint res = 0;
299     int sleep_count = 0;
300     while (!AttachListener::is_initialized()) {
301       sleep(1); // 1 second
302       sleep_count++;
303       if (sleep_count &gt; 10) { // try for 10 seconds
304         debug_only(warning(&quot;door_call when not enabled&quot;));
305         res = (jint)SolarisAttachListener::ATTACH_ERROR_INTERNAL;
306         break;
307       }
308     }
309 
310     // check client credentials
311     if (res == 0) {
312       if (check_credentials() != 0) {
313         res = (jint)SolarisAttachListener::ATTACH_ERROR_DENIED;
314       }
315     }
316 
317     // if we are stopped at ShowMessageBoxOnError then maybe we can
318     // load a diagnostic library
319     if (res == 0 &amp;&amp; VMError::is_error_reported()) {
320       if (ShowMessageBoxOnError) {
321         // TBD - support loading of diagnostic library here
322       }
323 
324       // can&#39;t enqueue operation after fatal error
325       res = (jint)SolarisAttachListener::ATTACH_ERROR_RESOURCE;
326     }
327 
328     // create the operation
329     if (res == 0) {
330       int err;
331       op = create_operation(argp, arg_size, &amp;err);
332       res = (op == NULL) ? (jint)err : 0;
333     }
334 
335     // create a pair of connected sockets. Store the file descriptor
336     // for one end in the operation and enqueue the operation. The
337     // file descriptor for the other end wil be returned to the client.
338     if (res == 0) {
339       int s[2];
340       if (socketpair(PF_UNIX, SOCK_STREAM, 0, s) &lt; 0) {
341         delete op;
342         res = (jint)SolarisAttachListener::ATTACH_ERROR_RESOURCE;
343       } else {
344         op-&gt;set_socket(s[0]);
345         return_fd = s[1];
346         SolarisAttachListener::enqueue(op);
347       }
348     }
349 
350     // Return 0 (success) + file descriptor, or non-0 (error)
351     if (res == 0) {
352       door_desc_t desc;
353       // DOOR_RELEASE flag makes sure fd is closed after passing it to
354       // the client.  See door_return(3DOOR) man page.
355       desc.d_attributes = DOOR_DESCRIPTOR | DOOR_RELEASE;
356       desc.d_data.d_desc.d_descriptor = return_fd;
357       door_return((char*)&amp;res, sizeof(res), &amp;desc, 1);
358     } else {
359       door_return((char*)&amp;res, sizeof(res), NULL, 0);
360     }
361   }
362 }
363 
364 // atexit hook to detach the door and remove the file
365 extern &quot;C&quot; {
366   static void listener_cleanup() {
367     static int cleanup_done;
368     if (!cleanup_done) {
369       cleanup_done = 1;
370       int dd = SolarisAttachListener::door_descriptor();
371       if (dd &gt;= 0) {
372         ::close(dd);
373       }
374       if (SolarisAttachListener::has_door_path()) {
375         char* path = SolarisAttachListener::door_path();
376         ::fdetach(path);
377         ::unlink(path);
378       }
379     }
380   }
381 }
382 
383 // Create the door
384 int SolarisAttachListener::create_door() {
385   char door_path[PATH_MAX+1];
386   char initial_path[PATH_MAX+1];
387   int fd, res;
388 
389   // register exit function
390   ::atexit(listener_cleanup);
391 
392   // create the door descriptor
393   int dd = ::door_create(enqueue_proc, NULL, 0);
394   if (dd &lt; 0) {
395     return -1;
396   }
397 
398   // create initial file to attach door descriptor
399   snprintf(door_path, sizeof(door_path), &quot;%s/.java_pid%d&quot;,
400            os::get_temp_directory(), os::current_process_id());
401   snprintf(initial_path, sizeof(initial_path), &quot;%s.tmp&quot;, door_path);
402   RESTARTABLE(::creat(initial_path, S_IRUSR | S_IWUSR), fd);
403   if (fd == -1) {
404     log_debug(attach)(&quot;attempt to create door file %s failed (%d)&quot;, initial_path, errno);
405     ::door_revoke(dd);
406     return -1;
407   }
408   assert(fd &gt;= 0, &quot;bad file descriptor&quot;);
409   ::close(fd);
410 
411   // attach the door descriptor to the file
412   if ((res = ::fattach(dd, initial_path)) == -1) {
413     // if busy then detach and try again
414     if (errno == EBUSY) {
415       ::fdetach(initial_path);
416       res = ::fattach(dd, initial_path);
417     }
418     if (res == -1) {
419       log_debug(attach)(&quot;unable to create door - fattach failed (%d)&quot;, errno);
420       ::door_revoke(dd);
421       dd = -1;
422     }
423   }
424 
425   // rename file so that clients can attach
426   if (dd &gt;= 0) {
427     if (::rename(initial_path, door_path) == -1) {
428         ::close(dd);
429         ::fdetach(initial_path);
430         log_debug(attach)(&quot;unable to create door - rename %s to %s failed (%d)&quot;, errno);
431         dd = -1;
432     }
433   }
434   if (dd &gt;= 0) {
435     set_door_descriptor(dd);
436     set_door_path(door_path);
437     log_trace(attach)(&quot;door file %s created succesfully&quot;, door_path);
438   } else {
439     // unable to create door, attach it to file, or rename file into place
440     ::unlink(initial_path);
441     return -1;
442   }
443 
444   return 0;
445 }
446 
447 // Initialization - create the door, locks, and other initialization
448 int SolarisAttachListener::init() {
449   if (create_door()) {
450     return -1;
451   }
452 
453   int status = os::Solaris::mutex_init(&amp;_mutex);
454   assert_status(status==0, status, &quot;mutex_init&quot;);
455 
456   status = ::sema_init(&amp;_wakeup, 0, NULL, NULL);
457   assert_status(status==0, status, &quot;sema_init&quot;);
458 
459   set_head(NULL);
460   set_tail(NULL);
461 
462   return 0;
463 }
464 
465 // Dequeue an operation
466 SolarisAttachOperation* SolarisAttachListener::dequeue() {
467   for (;;) {
468     int res;
469 
470     // wait for somebody to enqueue something
471     while ((res = ::sema_wait(wakeup())) == EINTR)
472       ;
473     if (res) {
474       warning(&quot;sema_wait failed: %s&quot;, os::strerror(res));
475       return NULL;
476     }
477 
478     // lock the list
479     res = os::Solaris::mutex_lock(mutex());
480     assert(res == 0, &quot;mutex_lock failed&quot;);
481 
482     // remove the head of the list
483     SolarisAttachOperation* op = head();
484     if (op != NULL) {
485       set_head(op-&gt;next());
486       if (head() == NULL) {
487         set_tail(NULL);
488       }
489     }
490 
491     // unlock
492     os::Solaris::mutex_unlock(mutex());
493 
494     // if we got an operation when return it.
495     if (op != NULL) {
496       return op;
497     }
498   }
499 }
500 
501 // Enqueue an operation
502 void SolarisAttachListener::enqueue(SolarisAttachOperation* op) {
503   // lock list
504   int res = os::Solaris::mutex_lock(mutex());
505   assert(res == 0, &quot;mutex_lock failed&quot;);
506 
507   // enqueue at tail
508   op-&gt;set_next(NULL);
509   if (head() == NULL) {
510     set_head(op);
511   } else {
512     tail()-&gt;set_next(op);
513   }
514   set_tail(op);
515 
516   // wakeup the attach listener
517   RESTARTABLE(::sema_post(wakeup()), res);
518   assert(res == 0, &quot;sema_post failed&quot;);
519 
520   // unlock
521   os::Solaris::mutex_unlock(mutex());
522 }
523 
524 
525 // support function - writes the (entire) buffer to a socket
526 static int write_fully(int s, char* buf, int len) {
527   do {
528     int n = ::write(s, buf, len);
529     if (n == -1) {
530       if (errno != EINTR) return -1;
531     } else {
532       buf += n;
533       len -= n;
534     }
535   }
536   while (len &gt; 0);
537   return 0;
538 }
539 
540 // Complete an operation by sending the operation result and any result
541 // output to the client. At this time the socket is in blocking mode so
542 // potentially we can block if there is a lot of data and the client is
543 // non-responsive. For most operations this is a non-issue because the
544 // default send buffer is sufficient to buffer everything. In the future
545 // if there are operations that involves a very big reply then it the
546 // socket could be made non-blocking and a timeout could be used.
547 
548 void SolarisAttachOperation::complete(jint res, bufferedStream* st) {
549   if (this-&gt;socket() &gt;= 0) {
550     JavaThread* thread = JavaThread::current();
551     ThreadBlockInVM tbivm(thread);
552 
553     thread-&gt;set_suspend_equivalent();
554     // cleared by handle_special_suspend_equivalent_condition() or
555     // java_suspend_self() via check_and_wait_while_suspended()
556 
557     // write operation result
558     char msg[32];
559     sprintf(msg, &quot;%d\n&quot;, res);
560     int rc = write_fully(this-&gt;socket(), msg, strlen(msg));
561 
562     // write any result data
563     if (rc == 0) {
564       write_fully(this-&gt;socket(), (char*) st-&gt;base(), st-&gt;size());
565       ::shutdown(this-&gt;socket(), 2);
566     }
567 
568     // close socket and we&#39;re done
569     ::close(this-&gt;socket());
570 
571     // were we externally suspended while we were waiting?
572     thread-&gt;check_and_wait_while_suspended();
573   }
574   delete this;
575 }
576 
577 
578 // AttachListener functions
579 
580 AttachOperation* AttachListener::dequeue() {
581   JavaThread* thread = JavaThread::current();
582   ThreadBlockInVM tbivm(thread);
583 
584   thread-&gt;set_suspend_equivalent();
585   // cleared by handle_special_suspend_equivalent_condition() or
586   // java_suspend_self() via check_and_wait_while_suspended()
587 
588   AttachOperation* op = SolarisAttachListener::dequeue();
589 
590   // were we externally suspended while we were waiting?
591   thread-&gt;check_and_wait_while_suspended();
592 
593   return op;
594 }
595 
596 
597 // Performs initialization at vm startup
598 // For Solaris we remove any stale .java_pid file which could cause
599 // an attaching process to think we are ready to receive a door_call
600 // before we are properly initialized
601 
602 void AttachListener::vm_start() {
603   char fn[PATH_MAX+1];
604   struct stat64 st;
605   int ret;
606 
607   int n = snprintf(fn, sizeof(fn), &quot;%s/.java_pid%d&quot;,
608            os::get_temp_directory(), os::current_process_id());
609   assert(n &lt; sizeof(fn), &quot;java_pid file name buffer overflow&quot;);
610 
611   RESTARTABLE(::stat64(fn, &amp;st), ret);
612   if (ret == 0) {
613     ret = ::unlink(fn);
614     if (ret == -1) {
615       log_debug(attach)(&quot;Failed to remove stale attach pid file at %s&quot;, fn);
616     }
617   }
618 }
619 
620 int AttachListener::pd_init() {
621   JavaThread* thread = JavaThread::current();
622   ThreadBlockInVM tbivm(thread);
623 
624   thread-&gt;set_suspend_equivalent();
625   // cleared by handle_special_suspend_equivalent_condition() or
626   // java_suspend_self()
627 
628   int ret_code = SolarisAttachListener::init();
629 
630   // were we externally suspended while we were waiting?
631   thread-&gt;check_and_wait_while_suspended();
632 
633   return ret_code;
634 }
635 
636 // Attach Listener is started lazily except in the case when
637 // +ReduseSignalUsage is used
638 bool AttachListener::init_at_startup() {
639   if (ReduceSignalUsage) {
640     return true;
641   } else {
642     return false;
643   }
644 }
645 
646 // If the file .attach_pid&lt;pid&gt; exists in the working directory
647 // or /tmp then this is the trigger to start the attach mechanism
648 bool AttachListener::is_init_trigger() {
649   if (init_at_startup() || is_initialized()) {
650     return false;               // initialized at startup or already initialized
651   }
652   char fn[PATH_MAX + 1];
653   int ret;
654   struct stat64 st;
655   sprintf(fn, &quot;.attach_pid%d&quot;, os::current_process_id());
656   RESTARTABLE(::stat64(fn, &amp;st), ret);
657   if (ret == -1) {
658     log_trace(attach)(&quot;Failed to find attach file: %s, trying alternate&quot;, fn);
659     snprintf(fn, sizeof(fn), &quot;%s/.attach_pid%d&quot;,
660              os::get_temp_directory(), os::current_process_id());
661     RESTARTABLE(::stat64(fn, &amp;st), ret);
662     if (ret == -1) {
663       log_debug(attach)(&quot;Failed to find attach file: %s&quot;, fn);
664     }
665   }
666   if (ret == 0) {
667     // simple check to avoid starting the attach mechanism when
668     // a bogus non-root user creates the file
669     if (os::Posix::matches_effective_uid_or_root(st.st_uid)) {
670       init();
671       log_trace(attach)(&quot;Attach triggered by %s&quot;, fn);
672       return true;
673     } else {
674       log_debug(attach)(&quot;File %s has wrong user id %d (vs %d). Attach is not triggered&quot;, fn, st.st_uid, geteuid());
675     }
676   }
677   return false;
678 }
679 
680 // if VM aborts then detach/cleanup
681 void AttachListener::abort() {
682   listener_cleanup();
683 }
684 
685 void AttachListener::pd_data_dump() {
686   os::signal_notify(SIGQUIT);
687 }
688 
689 static jint enable_dprobes(AttachOperation* op, outputStream* out) {
690   const char* probe = op-&gt;arg(0);
691   if (probe == NULL || probe[0] == &#39;\0&#39;) {
692     out-&gt;print_cr(&quot;No probe specified&quot;);
693     return JNI_ERR;
694   } else {
695     char *end;
696     long val = strtol(probe, &amp;end, 10);
697     if (end == probe || val &lt; 0 || val &gt; INT_MAX) {
698       out-&gt;print_cr(&quot;invalid probe type&quot;);
699       return JNI_ERR;
700     } else {
701       int probe_typess = (int) val;
702       DTrace::enable_dprobes(probe_typess);
703       return JNI_OK;
704     }
705   }
706 }
707 
708 // platform specific operations table
709 static AttachOperationFunctionInfo funcs[] = {
710   { &quot;enabledprobes&quot;, enable_dprobes },
711   { NULL, NULL }
712 };
713 
714 AttachOperationFunctionInfo* AttachListener::pd_find_operation(const char* name) {
715   int i;
716   for (i = 0; funcs[i].name != NULL; i++) {
717     if (strcmp(funcs[i].name, name) == 0) {
718       return &amp;funcs[i];
719     }
720   }
721   return NULL;
722 }
723 
724 // Solaris specific global flag set. Currently, we support only
725 // changing ExtendedDTraceProbes flag.
726 jint AttachListener::pd_set_flag(AttachOperation* op, outputStream* out) {
727   const char* name = op-&gt;arg(0);
728   assert(name != NULL, &quot;flag name should not be null&quot;);
729   bool flag = true;
730   const char* arg1;
731   if ((arg1 = op-&gt;arg(1)) != NULL) {
732     char *end;
733     flag = (strtol(arg1, &amp;end, 10) != 0);
734     if (arg1 == end) {
735       out-&gt;print_cr(&quot;flag value has to be an integer&quot;);
736       return JNI_ERR;
737     }
738   }
739 
740   if (strcmp(name, &quot;ExtendedDTraceProbes&quot;) == 0) {
741     DTrace::set_extended_dprobes(flag);
742     return JNI_OK;
743   }
744 
745   if (strcmp(name, &quot;DTraceMonitorProbes&quot;) == 0) {
746     DTrace::set_monitor_dprobes(flag);
747     return JNI_OK;
748   }
749 
750   out-&gt;print_cr(&quot;flag &#39;%s&#39; cannot be changed&quot;, name);
751   return JNI_ERR;
752 }
753 
754 void AttachListener::pd_detachall() {
755   DTrace::detach_all_clients();
756 }
    </pre>
  </body>
</html>
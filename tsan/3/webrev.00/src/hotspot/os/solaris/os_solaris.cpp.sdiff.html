<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/solaris/os_solaris.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_perf_solaris.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_solaris.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/solaris/os_solaris.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // no precompiled headers
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;

  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/filemap.hpp&quot;

  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;os_share_solaris.hpp&quot;
  40 #include &quot;os_solaris.inline.hpp&quot;
  41 #include &quot;prims/jniFastGetField.hpp&quot;
  42 #include &quot;prims/jvm_misc.hpp&quot;
  43 #include &quot;runtime/arguments.hpp&quot;
  44 #include &quot;runtime/atomic.hpp&quot;
  45 #include &quot;runtime/extendedPC.hpp&quot;
  46 #include &quot;runtime/globals.hpp&quot;
  47 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  48 #include &quot;runtime/java.hpp&quot;
  49 #include &quot;runtime/javaCalls.hpp&quot;
  50 #include &quot;runtime/mutexLocker.hpp&quot;
  51 #include &quot;runtime/objectMonitor.hpp&quot;
  52 #include &quot;runtime/orderAccess.hpp&quot;
  53 #include &quot;runtime/osThread.hpp&quot;
  54 #include &quot;runtime/perfMemory.hpp&quot;
  55 #include &quot;runtime/sharedRuntime.hpp&quot;
  56 #include &quot;runtime/statSampler.hpp&quot;
  57 #include &quot;runtime/stubRoutines.hpp&quot;
</pre>
<hr />
<pre>
 246 
 247 struct tm* os::localtime_pd(const time_t* clock, struct tm*  res) {
 248   return localtime_r(clock, res);
 249 }
 250 
 251 void os::Solaris::try_enable_extended_io() {
 252   typedef int (*enable_extended_FILE_stdio_t)(int, int);
 253 
 254   if (!UseExtendedFileIO) {
 255     return;
 256   }
 257 
 258   enable_extended_FILE_stdio_t enabler =
 259     (enable_extended_FILE_stdio_t) dlsym(RTLD_DEFAULT,
 260                                          &quot;enable_extended_FILE_stdio&quot;);
 261   if (enabler) {
 262     enabler(-1, -1);
 263   }
 264 }
 265 
<span class="line-removed"> 266 static int _processors_online = 0;</span>
<span class="line-removed"> 267 </span>
 268 jint os::Solaris::_os_thread_limit = 0;
 269 volatile jint os::Solaris::_os_thread_count = 0;
 270 
 271 julong os::available_memory() {
 272   return Solaris::available_memory();
 273 }
 274 
 275 julong os::Solaris::available_memory() {
 276   return (julong)sysconf(_SC_AVPHYS_PAGES) * os::vm_page_size();
 277 }
 278 
 279 julong os::Solaris::_physical_memory = 0;
 280 
 281 julong os::physical_memory() {
 282   return Solaris::physical_memory();
 283 }
 284 
 285 static hrtime_t first_hrtime = 0;
 286 static const hrtime_t hrtime_hz = 1000*1000*1000;
 287 static volatile hrtime_t max_hrtime = 0;
 288 
 289 
 290 void os::Solaris::initialize_system_info() {
 291   set_processor_count(sysconf(_SC_NPROCESSORS_CONF));
<span class="line-removed"> 292   _processors_online = sysconf(_SC_NPROCESSORS_ONLN);</span>
 293   _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) *
 294                                      (julong)sysconf(_SC_PAGESIZE);
 295 }
 296 
 297 uint os::processor_id() {
 298   const processorid_t id = ::getcpuid();
 299   assert(id &gt;= 0 &amp;&amp; id &lt; _processor_count, &quot;Invalid processor id&quot;);
 300   return (uint)id;
 301 }
 302 
 303 int os::active_processor_count() {
 304   // User has overridden the number of active processors
 305   if (ActiveProcessorCount &gt; 0) {
 306     log_trace(os)(&quot;active_processor_count: &quot;
 307                   &quot;active processor count set by user : %d&quot;,
 308                   ActiveProcessorCount);
 309     return ActiveProcessorCount;
 310   }
 311 
 312   int online_cpus = sysconf(_SC_NPROCESSORS_ONLN);
 313   pid_t pid = getpid();
 314   psetid_t pset = PS_NONE;
 315   // Are we running in a processor set or is there any processor set around?
 316   if (pset_bind(PS_QUERY, P_PID, pid, &amp;pset) == 0) {
 317     uint_t pset_cpus;
 318     // Query the number of cpus available to us.
 319     if (pset_info(pset, NULL, &amp;pset_cpus, NULL) == 0) {
 320       assert(pset_cpus &gt; 0 &amp;&amp; pset_cpus &lt;= online_cpus, &quot;sanity check&quot;);
<span class="line-removed"> 321       _processors_online = pset_cpus;</span>
 322       return pset_cpus;
 323     }
 324   }
 325   // Otherwise return number of online cpus
 326   return online_cpus;
 327 }
 328 
<span class="line-removed"> 329 static bool find_processors_in_pset(psetid_t        pset,</span>
<span class="line-removed"> 330                                     processorid_t** id_array,</span>
<span class="line-removed"> 331                                     uint_t*         id_length) {</span>
<span class="line-removed"> 332   bool result = false;</span>
<span class="line-removed"> 333   // Find the number of processors in the processor set.</span>
<span class="line-removed"> 334   if (pset_info(pset, NULL, id_length, NULL) == 0) {</span>
<span class="line-removed"> 335     // Make up an array to hold their ids.</span>
<span class="line-removed"> 336     *id_array = NEW_C_HEAP_ARRAY(processorid_t, *id_length, mtInternal);</span>
<span class="line-removed"> 337     // Fill in the array with their processor ids.</span>
<span class="line-removed"> 338     if (pset_info(pset, NULL, id_length, *id_array) == 0) {</span>
<span class="line-removed"> 339       result = true;</span>
<span class="line-removed"> 340     }</span>
<span class="line-removed"> 341   }</span>
<span class="line-removed"> 342   return result;</span>
<span class="line-removed"> 343 }</span>
<span class="line-removed"> 344 </span>
<span class="line-removed"> 345 // Callers of find_processors_online() must tolerate imprecise results --</span>
<span class="line-removed"> 346 // the system configuration can change asynchronously because of DR</span>
<span class="line-removed"> 347 // or explicit psradm operations.</span>
<span class="line-removed"> 348 //</span>
<span class="line-removed"> 349 // We also need to take care that the loop (below) terminates as the</span>
<span class="line-removed"> 350 // number of processors online can change between the _SC_NPROCESSORS_ONLN</span>
<span class="line-removed"> 351 // request and the loop that builds the list of processor ids.   Unfortunately</span>
<span class="line-removed"> 352 // there&#39;s no reliable way to determine the maximum valid processor id,</span>
<span class="line-removed"> 353 // so we use a manifest constant, MAX_PROCESSOR_ID, instead.  See p_online</span>
<span class="line-removed"> 354 // man pages, which claim the processor id set is &quot;sparse, but</span>
<span class="line-removed"> 355 // not too sparse&quot;.  MAX_PROCESSOR_ID is used to ensure that we eventually</span>
<span class="line-removed"> 356 // exit the loop.</span>
<span class="line-removed"> 357 //</span>
<span class="line-removed"> 358 // In the future we&#39;ll be able to use sysconf(_SC_CPUID_MAX), but that&#39;s</span>
<span class="line-removed"> 359 // not available on S8.0.</span>
<span class="line-removed"> 360 </span>
<span class="line-removed"> 361 static bool find_processors_online(processorid_t** id_array,</span>
<span class="line-removed"> 362                                    uint*           id_length) {</span>
<span class="line-removed"> 363   const processorid_t MAX_PROCESSOR_ID = 100000;</span>
<span class="line-removed"> 364   // Find the number of processors online.</span>
<span class="line-removed"> 365   *id_length = sysconf(_SC_NPROCESSORS_ONLN);</span>
<span class="line-removed"> 366   // Make up an array to hold their ids.</span>
<span class="line-removed"> 367   *id_array = NEW_C_HEAP_ARRAY(processorid_t, *id_length, mtInternal);</span>
<span class="line-removed"> 368   // Processors need not be numbered consecutively.</span>
<span class="line-removed"> 369   long found = 0;</span>
<span class="line-removed"> 370   processorid_t next = 0;</span>
<span class="line-removed"> 371   while (found &lt; *id_length &amp;&amp; next &lt; MAX_PROCESSOR_ID) {</span>
<span class="line-removed"> 372     processor_info_t info;</span>
<span class="line-removed"> 373     if (processor_info(next, &amp;info) == 0) {</span>
<span class="line-removed"> 374       // NB, PI_NOINTR processors are effectively online ...</span>
<span class="line-removed"> 375       if (info.pi_state == P_ONLINE || info.pi_state == P_NOINTR) {</span>
<span class="line-removed"> 376         (*id_array)[found] = next;</span>
<span class="line-removed"> 377         found += 1;</span>
<span class="line-removed"> 378       }</span>
<span class="line-removed"> 379     }</span>
<span class="line-removed"> 380     next += 1;</span>
<span class="line-removed"> 381   }</span>
<span class="line-removed"> 382   if (found &lt; *id_length) {</span>
<span class="line-removed"> 383     // The loop above didn&#39;t identify the expected number of processors.</span>
<span class="line-removed"> 384     // We could always retry the operation, calling sysconf(_SC_NPROCESSORS_ONLN)</span>
<span class="line-removed"> 385     // and re-running the loop, above, but there&#39;s no guarantee of progress</span>
<span class="line-removed"> 386     // if the system configuration is in flux.  Instead, we just return what</span>
<span class="line-removed"> 387     // we&#39;ve got.  Note that in the worst case find_processors_online() could</span>
<span class="line-removed"> 388     // return an empty set.  (As a fall-back in the case of the empty set we</span>
<span class="line-removed"> 389     // could just return the ID of the current processor).</span>
<span class="line-removed"> 390     *id_length = found;</span>
<span class="line-removed"> 391   }</span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393   return true;</span>
<span class="line-removed"> 394 }</span>
<span class="line-removed"> 395 </span>
<span class="line-removed"> 396 static bool assign_distribution(processorid_t* id_array,</span>
<span class="line-removed"> 397                                 uint           id_length,</span>
<span class="line-removed"> 398                                 uint*          distribution,</span>
<span class="line-removed"> 399                                 uint           distribution_length) {</span>
<span class="line-removed"> 400   // We assume we can assign processorid_t&#39;s to uint&#39;s.</span>
<span class="line-removed"> 401   assert(sizeof(processorid_t) == sizeof(uint),</span>
<span class="line-removed"> 402          &quot;can&#39;t convert processorid_t to uint&quot;);</span>
<span class="line-removed"> 403   // Quick check to see if we won&#39;t succeed.</span>
<span class="line-removed"> 404   if (id_length &lt; distribution_length) {</span>
<span class="line-removed"> 405     return false;</span>
<span class="line-removed"> 406   }</span>
<span class="line-removed"> 407   // Assign processor ids to the distribution.</span>
<span class="line-removed"> 408   // Try to shuffle processors to distribute work across boards,</span>
<span class="line-removed"> 409   // assuming 4 processors per board.</span>
<span class="line-removed"> 410   const uint processors_per_board = ProcessDistributionStride;</span>
<span class="line-removed"> 411   // Find the maximum processor id.</span>
<span class="line-removed"> 412   processorid_t max_id = 0;</span>
<span class="line-removed"> 413   for (uint m = 0; m &lt; id_length; m += 1) {</span>
<span class="line-removed"> 414     max_id = MAX2(max_id, id_array[m]);</span>
<span class="line-removed"> 415   }</span>
<span class="line-removed"> 416   // The next id, to limit loops.</span>
<span class="line-removed"> 417   const processorid_t limit_id = max_id + 1;</span>
<span class="line-removed"> 418   // Make up markers for available processors.</span>
<span class="line-removed"> 419   bool* available_id = NEW_C_HEAP_ARRAY(bool, limit_id, mtInternal);</span>
<span class="line-removed"> 420   for (uint c = 0; c &lt; limit_id; c += 1) {</span>
<span class="line-removed"> 421     available_id[c] = false;</span>
<span class="line-removed"> 422   }</span>
<span class="line-removed"> 423   for (uint a = 0; a &lt; id_length; a += 1) {</span>
<span class="line-removed"> 424     available_id[id_array[a]] = true;</span>
<span class="line-removed"> 425   }</span>
<span class="line-removed"> 426   // Step by &quot;boards&quot;, then by &quot;slot&quot;, copying to &quot;assigned&quot;.</span>
<span class="line-removed"> 427   // NEEDS_CLEANUP: The assignment of processors should be stateful,</span>
<span class="line-removed"> 428   //                remembering which processors have been assigned by</span>
<span class="line-removed"> 429   //                previous calls, etc., so as to distribute several</span>
<span class="line-removed"> 430   //                independent calls of this method.  What we&#39;d like is</span>
<span class="line-removed"> 431   //                It would be nice to have an API that let us ask</span>
<span class="line-removed"> 432   //                how many processes are bound to a processor,</span>
<span class="line-removed"> 433   //                but we don&#39;t have that, either.</span>
<span class="line-removed"> 434   //                In the short term, &quot;board&quot; is static so that</span>
<span class="line-removed"> 435   //                subsequent distributions don&#39;t all start at board 0.</span>
<span class="line-removed"> 436   static uint board = 0;</span>
<span class="line-removed"> 437   uint assigned = 0;</span>
<span class="line-removed"> 438   // Until we&#39;ve found enough processors ....</span>
<span class="line-removed"> 439   while (assigned &lt; distribution_length) {</span>
<span class="line-removed"> 440     // ... find the next available processor in the board.</span>
<span class="line-removed"> 441     for (uint slot = 0; slot &lt; processors_per_board; slot += 1) {</span>
<span class="line-removed"> 442       uint try_id = board * processors_per_board + slot;</span>
<span class="line-removed"> 443       if ((try_id &lt; limit_id) &amp;&amp; (available_id[try_id] == true)) {</span>
<span class="line-removed"> 444         distribution[assigned] = try_id;</span>
<span class="line-removed"> 445         available_id[try_id] = false;</span>
<span class="line-removed"> 446         assigned += 1;</span>
<span class="line-removed"> 447         break;</span>
<span class="line-removed"> 448       }</span>
<span class="line-removed"> 449     }</span>
<span class="line-removed"> 450     board += 1;</span>
<span class="line-removed"> 451     if (board * processors_per_board + 0 &gt;= limit_id) {</span>
<span class="line-removed"> 452       board = 0;</span>
<span class="line-removed"> 453     }</span>
<span class="line-removed"> 454   }</span>
<span class="line-removed"> 455   if (available_id != NULL) {</span>
<span class="line-removed"> 456     FREE_C_HEAP_ARRAY(bool, available_id);</span>
<span class="line-removed"> 457   }</span>
<span class="line-removed"> 458   return true;</span>
<span class="line-removed"> 459 }</span>
<span class="line-removed"> 460 </span>
 461 void os::set_native_thread_name(const char *name) {
 462   if (Solaris::_pthread_setname_np != NULL) {
 463     // Only the first 31 bytes of &#39;name&#39; are processed by pthread_setname_np
 464     // but we explicitly copy into a size-limited buffer to avoid any
 465     // possible overflow.
 466     char buf[32];
 467     snprintf(buf, sizeof(buf), &quot;%s&quot;, name);
 468     buf[sizeof(buf) - 1] = &#39;\0&#39;;
 469     Solaris::_pthread_setname_np(pthread_self(), buf);
 470   }
 471 }
 472 
<span class="line-removed"> 473 bool os::distribute_processes(uint length, uint* distribution) {</span>
<span class="line-removed"> 474   bool result = false;</span>
<span class="line-removed"> 475   // Find the processor id&#39;s of all the available CPUs.</span>
<span class="line-removed"> 476   processorid_t* id_array  = NULL;</span>
<span class="line-removed"> 477   uint           id_length = 0;</span>
<span class="line-removed"> 478   // There are some races between querying information and using it,</span>
<span class="line-removed"> 479   // since processor sets can change dynamically.</span>
<span class="line-removed"> 480   psetid_t pset = PS_NONE;</span>
<span class="line-removed"> 481   // Are we running in a processor set?</span>
<span class="line-removed"> 482   if ((pset_bind(PS_QUERY, P_PID, P_MYID, &amp;pset) == 0) &amp;&amp; pset != PS_NONE) {</span>
<span class="line-removed"> 483     result = find_processors_in_pset(pset, &amp;id_array, &amp;id_length);</span>
<span class="line-removed"> 484   } else {</span>
<span class="line-removed"> 485     result = find_processors_online(&amp;id_array, &amp;id_length);</span>
<span class="line-removed"> 486   }</span>
<span class="line-removed"> 487   if (result == true) {</span>
<span class="line-removed"> 488     if (id_length &gt;= length) {</span>
<span class="line-removed"> 489       result = assign_distribution(id_array, id_length, distribution, length);</span>
<span class="line-removed"> 490     } else {</span>
<span class="line-removed"> 491       result = false;</span>
<span class="line-removed"> 492     }</span>
<span class="line-removed"> 493   }</span>
<span class="line-removed"> 494   if (id_array != NULL) {</span>
<span class="line-removed"> 495     FREE_C_HEAP_ARRAY(processorid_t, id_array);</span>
<span class="line-removed"> 496   }</span>
<span class="line-removed"> 497   return result;</span>
<span class="line-removed"> 498 }</span>
<span class="line-removed"> 499 </span>
 500 bool os::bind_to_processor(uint processor_id) {
 501   // We assume that a processorid_t can be stored in a uint.
 502   assert(sizeof(uint) == sizeof(processorid_t),
 503          &quot;can&#39;t convert uint to processorid_t&quot;);
 504   int bind_result =
 505     processor_bind(P_LWPID,                       // bind LWP.
 506                    P_MYID,                        // bind current LWP.
 507                    (processorid_t) processor_id,  // id.
 508                    NULL);                         // don&#39;t return old binding.
 509   return (bind_result == 0);
 510 }
 511 
 512 // Return true if user is running as root.
 513 
 514 bool os::have_special_privileges() {
 515   static bool init = false;
 516   static bool privileges = false;
 517   if (!init) {
 518     privileges = (getuid() != geteuid()) || (getgid() != getegid());
 519     init = true;
</pre>
<hr />
<pre>
 543   // then we append a fake suffix &quot;hotspot/libjvm.so&quot; to this path so
 544   // it looks like libjvm.so is installed there
 545   // &lt;JAVA_HOME&gt;/jre/lib/&lt;arch&gt;/hotspot/libjvm.so.
 546   //
 547   // Otherwise exit.
 548   //
 549   // Important note: if the location of libjvm.so changes this
 550   // code needs to be changed accordingly.
 551 
 552 // Base path of extensions installed on the system.
 553 #define SYS_EXT_DIR     &quot;/usr/jdk/packages&quot;
 554 #define EXTENSIONS_DIR  &quot;/lib/ext&quot;
 555 
 556   // Buffer that fits several sprintfs.
 557   // Note that the space for the colon and the trailing null are provided
 558   // by the nulls included by the sizeof operator.
 559   const size_t bufsize =
 560     MAX3((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
 561          sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;), // invariant ld_library_path
 562          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="line-modified"> 563   char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 564 
 565   // sysclasspath, java_home, dll_dir
 566   {
 567     char *pslash;
 568     os::jvm_path(buf, bufsize);
 569 
 570     // Found the full path to libjvm.so.
 571     // Now cut the path to &lt;java_home&gt;/jre if we can.
 572     *(strrchr(buf, &#39;/&#39;)) = &#39;\0&#39;; // Get rid of /libjvm.so.
 573     pslash = strrchr(buf, &#39;/&#39;);
 574     if (pslash != NULL) {
 575       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 576     }
 577     Arguments::set_dll_dir(buf);
 578 
 579     if (pslash != NULL) {
 580       pslash = strrchr(buf, &#39;/&#39;);
 581       if (pslash != NULL) {
 582         *pslash = &#39;\0&#39;;        // Get rid of /lib.
 583       }
</pre>
<hr />
<pre>
 629       vm_exit_during_initialization(&quot;dlinfo SERINFO request&quot;, dlerror());
 630     }
 631 
 632     path = &amp;info-&gt;dls_serpath[0];
 633 
 634     // Note: Due to a legacy implementation, most of the library path
 635     // is set in the launcher. This was to accomodate linking restrictions
 636     // on legacy Solaris implementations (which are no longer supported).
 637     // Eventually, all the library path setting will be done here.
 638     //
 639     // However, to prevent the proliferation of improperly built native
 640     // libraries, the new path component /usr/jdk/packages is added here.
 641 
 642     // Construct the invariant part of ld_library_path.
 643     sprintf(common_path, SYS_EXT_DIR &quot;/lib&quot;);
 644 
 645     // Struct size is more than sufficient for the path components obtained
 646     // through the dlinfo() call, so only add additional space for the path
 647     // components explicitly added here.
 648     size_t library_path_size = info-&gt;dls_size + strlen(common_path);
<span class="line-modified"> 649     library_path = (char *)NEW_C_HEAP_ARRAY(char, library_path_size, mtInternal);</span>
 650     library_path[0] = &#39;\0&#39;;
 651 
 652     // Construct the desired Java library path from the linker&#39;s library
 653     // search path.
 654     //
 655     // For compatibility, it is optimal that we insert the additional path
 656     // components specific to the Java VM after those components specified
 657     // in LD_LIBRARY_PATH (if any) but before those added by the ld.so
 658     // infrastructure.
 659     if (info-&gt;dls_cnt == 0) { // Not sure this can happen, but allow for it.
 660       strcpy(library_path, common_path);
 661     } else {
 662       int inserted = 0;
 663       int i;
 664       for (i = 0; i &lt; info-&gt;dls_cnt; i++, path++) {
 665         uint_t flags = path-&gt;dls_flags &amp; LA_SER_MASK;
 666         if (((flags &amp; LA_SER_LIBPATH) == 0) &amp;&amp; !inserted) {
 667           strcat(library_path, common_path);
 668           strcat(library_path, os::path_separator());
 669           inserted = 1;
</pre>
<hr />
<pre>
 975 
 976   // Create the Solaris thread
 977   thread_t tid = 0;
 978   long     flags = (UseDetachedThreads ? THR_DETACHED : 0) | THR_SUSPENDED;
 979   int      status;
 980 
 981   // Mark that we don&#39;t have an lwp or thread id yet.
 982   // In case we attempt to set the priority before the thread starts.
 983   osthread-&gt;set_lwp_id(-1);
 984   osthread-&gt;set_thread_id(-1);
 985 
 986   status = thr_create(NULL, stack_size, thread_native_entry, thread, flags, &amp;tid);
 987 
 988   char buf[64];
 989   if (status == 0) {
 990     log_info(os, thread)(&quot;Thread started (tid: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
 991       (uintx) tid, describe_thr_create_attributes(buf, sizeof(buf), stack_size, flags));
 992   } else {
 993     log_warning(os, thread)(&quot;Failed to start thread - thr_create failed (%s) for attributes: %s.&quot;,
 994       os::errno_name(status), describe_thr_create_attributes(buf, sizeof(buf), stack_size, flags));





 995   }
 996 
 997   if (status != 0) {
 998     thread-&gt;set_osthread(NULL);
 999     // Need to clean up stuff we&#39;ve allocated so far
1000     delete osthread;
1001     return false;
1002   }
1003 
1004   Atomic::inc(&amp;os::Solaris::_os_thread_count);
1005 
1006   // Store info on the Solaris thread into the OSThread
1007   osthread-&gt;set_thread_id(tid);
1008 
1009   // Remember that we created this thread so we can set priority on it
1010   osthread-&gt;set_vm_created();
1011 
1012   // Most thread types will set an explicit priority before starting the thread,
1013   // but for those that don&#39;t we need a valid value to read back in thread_native_entry.
1014   osthread-&gt;set_native_priority(NormPriority);
</pre>
<hr />
<pre>
1163 intx os::current_thread_id() {
1164   return (intx)thr_self();
1165 }
1166 
1167 static pid_t _initial_pid = 0;
1168 
1169 int os::current_process_id() {
1170   return (int)(_initial_pid ? _initial_pid : getpid());
1171 }
1172 
1173 // gethrtime() should be monotonic according to the documentation,
1174 // but some virtualized platforms are known to break this guarantee.
1175 // getTimeNanos() must be guaranteed not to move backwards, so we
1176 // are forced to add a check here.
1177 inline hrtime_t getTimeNanos() {
1178   const hrtime_t now = gethrtime();
1179   const hrtime_t prev = max_hrtime;
1180   if (now &lt;= prev) {
1181     return prev;   // same or retrograde time;
1182   }
<span class="line-modified">1183   const hrtime_t obsv = Atomic::cmpxchg(now, &amp;max_hrtime, prev);</span>
1184   assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
1185   // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
1186   // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
1187   // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
1188   // some other thread raced this thread and installed a new value, in which case
1189   // we could either (a) retry the entire operation, (b) retry trying to install now
1190   // or (c) just return obsv.  We use (c).   No loop is required although in some cases
1191   // we might discard a higher &quot;now&quot; value in deference to a slightly lower but freshly
1192   // installed obsv value.   That&#39;s entirely benign -- it admits no new orderings compared
1193   // to (a) or (b) -- and greatly reduces coherence traffic.
1194   // We might also condition (c) on the magnitude of the delta between obsv and now.
1195   // Avoiding excessive CAS operations to hot RW locations is critical.
1196   // See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate
1197   return (prev == obsv) ? now : obsv;
1198 }
1199 
1200 // Time since start-up in seconds to a fine granularity.
1201 // Used by VMSelfDestructTimer and the MemProfiler.
1202 double os::elapsedTime() {
1203   return (double)(getTimeNanos() - first_hrtime) / (double)hrtime_hz;
</pre>
<hr />
<pre>
1217                       double* process_user_time,
1218                       double* process_system_time) {
1219   struct tms ticks;
1220   clock_t real_ticks = times(&amp;ticks);
1221 
1222   if (real_ticks == (clock_t) (-1)) {
1223     return false;
1224   } else {
1225     double ticks_per_second = (double) clock_tics_per_sec;
1226     *process_user_time = ((double) ticks.tms_utime) / ticks_per_second;
1227     *process_system_time = ((double) ticks.tms_stime) / ticks_per_second;
1228     // For consistency return the real time from getTimeNanos()
1229     // converted to seconds.
1230     *process_real_time = ((double) getTimeNanos()) / ((double) NANOUNITS);
1231 
1232     return true;
1233   }
1234 }
1235 
1236 bool os::supports_vtime() { return true; }
<span class="line-removed">1237 bool os::enable_vtime() { return false; }</span>
<span class="line-removed">1238 bool os::vtime_enabled() { return false; }</span>
1239 
1240 double os::elapsedVTime() {
1241   return (double)gethrvtime() / (double)hrtime_hz;
1242 }
1243 
1244 // Must return millis since Jan 1 1970 for JVM_CurrentTimeMillis
1245 jlong os::javaTimeMillis() {
1246   timeval t;
1247   if (gettimeofday(&amp;t, NULL) == -1) {
1248     fatal(&quot;os::javaTimeMillis: gettimeofday (%s)&quot;, os::strerror(errno));
1249   }
1250   return jlong(t.tv_sec) * 1000  +  jlong(t.tv_usec) / 1000;
1251 }
1252 
1253 // Must return seconds+nanos since Jan 1 1970. This must use the same
1254 // time source as javaTimeMillis and can&#39;t use get_nsec_fromepoch as
1255 // we need better than 1ms accuracy
1256 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
1257   timeval t;
1258   if (gettimeofday(&amp;t, NULL) == -1) {
</pre>
<hr />
<pre>
1310 // called from signal handler. Before adding something to os::abort(), make
1311 // sure it is async-safe and can handle partially initialized VM.
1312 void os::abort(bool dump_core, void* siginfo, const void* context) {
1313   os::shutdown();
1314   if (dump_core) {
1315 #ifndef PRODUCT
1316     fdStream out(defaultStream::output_fd());
1317     out.print_raw(&quot;Current thread is &quot;);
1318     char buf[16];
1319     jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());
1320     out.print_raw_cr(buf);
1321     out.print_raw_cr(&quot;Dumping core ...&quot;);
1322 #endif
1323     ::abort(); // dump core (for debugging)
1324   }
1325 
1326   ::exit(1);
1327 }
1328 
1329 // Die immediately, no exit hook, no abort hook, no cleanup.

1330 void os::die() {
<span class="line-modified">1331   ::abort(); // dump core (for debugging)</span>






1332 }
1333 
1334 // DLL functions
1335 
1336 const char* os::dll_file_extension() { return &quot;.so&quot;; }
1337 
1338 // This must be hard coded because it&#39;s the system&#39;s temporary
1339 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1340 const char* os::get_temp_directory() { return &quot;/tmp&quot;; }
1341 
1342 // check if addr is inside libjvm.so
1343 bool os::address_is_in_vm(address addr) {
1344   static address libjvm_base_addr;
1345   Dl_info dlinfo;
1346 
1347   if (libjvm_base_addr == NULL) {
1348     if (dladdr(CAST_FROM_FN_PTR(void *, os::address_is_in_vm), &amp;dlinfo) != 0) {
1349       libjvm_base_addr = (address)dlinfo.dli_fbase;
1350     }
1351     assert(libjvm_base_addr !=NULL, &quot;Cannot obtain base address for libjvm&quot;);
</pre>
<hr />
<pre>
1489     map = map-&gt;l_next;
1490   }
1491 
1492   dlclose(handle);
1493   return 0;
1494 }
1495 
1496 int _print_dll_info_cb(const char * name, address base_address, address top_address, void * param) {
1497   outputStream * out = (outputStream *) param;
1498   out-&gt;print_cr(PTR_FORMAT &quot; \t%s&quot;, base_address, name);
1499   return 0;
1500 }
1501 
1502 void os::print_dll_info(outputStream * st) {
1503   st-&gt;print_cr(&quot;Dynamic libraries:&quot;); st-&gt;flush();
1504   if (get_loaded_modules_info(_print_dll_info_cb, (void *)st)) {
1505     st-&gt;print_cr(&quot;Error: Cannot print dynamic libraries.&quot;);
1506   }
1507 }
1508 







1509 // Loads .dll/.so and
1510 // in case of error it checks if .dll/.so was built for the
1511 // same architecture as Hotspot is running on
1512 
1513 void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {


1514   void * result= ::dlopen(filename, RTLD_LAZY);
1515   if (result != NULL) {
1516     // Successful loading


1517     return result;
1518   }
1519 
1520   Elf32_Ehdr elf_head;











1521 
<span class="line-removed">1522   // Read system error message into ebuf</span>
<span class="line-removed">1523   // It may or may not be overwritten below</span>
<span class="line-removed">1524   ::strncpy(ebuf, ::dlerror(), ebuflen-1);</span>
<span class="line-removed">1525   ebuf[ebuflen-1]=&#39;\0&#39;;</span>
1526   int diag_msg_max_length=ebuflen-strlen(ebuf);
1527   char* diag_msg_buf=ebuf+strlen(ebuf);
1528 
1529   if (diag_msg_max_length==0) {
1530     // No more space in ebuf for additional diagnostics message
1531     return NULL;
1532   }
1533 
1534 
1535   int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);
1536 
1537   if (file_descriptor &lt; 0) {
1538     // Can&#39;t open library, report dlerror() message
1539     return NULL;
1540   }
1541 
1542   bool failed_to_read_elf_head=
1543     (sizeof(elf_head)!=
1544      (::read(file_descriptor, &amp;elf_head,sizeof(elf_head))));
1545 
1546   ::close(file_descriptor);
1547   if (failed_to_read_elf_head) {
1548     // file i/o error - report dlerror() msg
1549     return NULL;
1550   }
1551 








1552   typedef struct {
1553     Elf32_Half    code;         // Actual value as defined in elf.h
1554     Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
1555     unsigned char elf_class;    // 32 or 64 bit
1556     unsigned char endianess;    // MSB or LSB
1557     char*         name;         // String representation
1558   } arch_t;
1559 




1560   static const arch_t arch_array[]={
1561     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1562     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1563     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1564     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
1565     {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1566     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1567     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
1568     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1569     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)&quot;Power PC 64&quot;},
<span class="line-modified">1570     {EM_ARM,         EM_ARM,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;ARM 32&quot;}</span>



1571   };
1572 
1573 #if  (defined IA32)
1574   static  Elf32_Half running_arch_code=EM_386;
1575 #elif   (defined AMD64)
1576   static  Elf32_Half running_arch_code=EM_X86_64;
1577 #elif  (defined IA64)
1578   static  Elf32_Half running_arch_code=EM_IA_64;
1579 #elif  (defined __sparc) &amp;&amp; (defined _LP64)
1580   static  Elf32_Half running_arch_code=EM_SPARCV9;
1581 #elif  (defined __sparc) &amp;&amp; (!defined _LP64)
1582   static  Elf32_Half running_arch_code=EM_SPARC;
1583 #elif  (defined __powerpc64__)
1584   static  Elf32_Half running_arch_code=EM_PPC64;
1585 #elif  (defined __powerpc__)
1586   static  Elf32_Half running_arch_code=EM_PPC;
1587 #elif (defined ARM)
1588   static  Elf32_Half running_arch_code=EM_ARM;
1589 #else
1590   #error Method os::dll_load requires that one of following is defined:\
1591        IA32, AMD64, IA64, __sparc, __powerpc__, ARM, ARM
1592 #endif
1593 
<span class="line-modified">1594   // Identify compatability class for VM&#39;s architecture and library&#39;s architecture</span>
1595   // Obtain string descriptions for architectures
1596 
1597   arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};
1598   int running_arch_index=-1;
1599 
1600   for (unsigned int i=0; i &lt; ARRAY_SIZE(arch_array); i++) {
1601     if (running_arch_code == arch_array[i].code) {
1602       running_arch_index    = i;
1603     }
1604     if (lib_arch.code == arch_array[i].code) {
1605       lib_arch.compat_class = arch_array[i].compat_class;
1606       lib_arch.name         = arch_array[i].name;
1607     }
1608   }
1609 
1610   assert(running_arch_index != -1,
1611          &quot;Didn&#39;t find running architecture code (running_arch_code) in arch_array&quot;);
1612   if (running_arch_index == -1) {
1613     // Even though running architecture detection failed
1614     // we may still continue with reporting dlerror() message
1615     return NULL;
1616   }
1617 













1618   if (lib_arch.endianess != arch_array[running_arch_index].endianess) {
1619     ::snprintf(diag_msg_buf, diag_msg_max_length-1,&quot; (Possible cause: endianness mismatch)&quot;);
1620     return NULL;
1621   }
1622 
<span class="line-modified">1623   if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {</span>
<span class="line-modified">1624     ::snprintf(diag_msg_buf, diag_msg_max_length-1,&quot; (Possible cause: architecture word width mismatch)&quot;);</span>

1625     return NULL;
1626   }
1627 
<span class="line-modified">1628   if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {</span>
<span class="line-modified">1629     if (lib_arch.name!=NULL) {</span>
<span class="line-modified">1630       ::snprintf(diag_msg_buf, diag_msg_max_length-1,</span>
<span class="line-modified">1631                  &quot; (Possible cause: can&#39;t load %s-bit .so on a %s-bit platform)&quot;,</span>
<span class="line-modified">1632                  lib_arch.name, arch_array[running_arch_index].name);</span>
<span class="line-removed">1633     } else {</span>
<span class="line-removed">1634       ::snprintf(diag_msg_buf, diag_msg_max_length-1,</span>
<span class="line-removed">1635                  &quot; (Possible cause: can&#39;t load this .so (machine code=0x%x) on a %s-bit platform)&quot;,</span>
<span class="line-removed">1636                  lib_arch.code,</span>
<span class="line-removed">1637                  arch_array[running_arch_index].name);</span>
<span class="line-removed">1638     }</span>
1639   }
1640 
1641   return NULL;
1642 }
1643 
1644 void* os::dll_lookup(void* handle, const char* name) {
1645   return dlsym(handle, name);
1646 }
1647 
1648 void* os::get_default_process_handle() {
1649   return (void*)::dlopen(NULL, RTLD_LAZY);
1650 }
1651 
1652 static inline time_t get_mtime(const char* filename) {
1653   struct stat st;
1654   int ret = os::stat(filename, &amp;st);
1655   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
1656   return st.st_mtime;
1657 }
1658 
</pre>
<hr />
<pre>
1677   ::close(fd);
1678 
1679   return true;
1680 }
1681 
1682 void os::print_os_info_brief(outputStream* st) {
1683   os::Solaris::print_distro_info(st);
1684 
1685   os::Posix::print_uname_info(st);
1686 
1687   os::Solaris::print_libversion_info(st);
1688 }
1689 
1690 void os::print_os_info(outputStream* st) {
1691   st-&gt;print(&quot;OS:&quot;);
1692 
1693   os::Solaris::print_distro_info(st);
1694 
1695   os::Posix::print_uname_info(st);
1696 


1697   os::Solaris::print_libversion_info(st);
1698 
1699   os::Posix::print_rlimit_info(st);
1700 
1701   os::Posix::print_load_average(st);
1702 }
1703 
1704 void os::Solaris::print_distro_info(outputStream* st) {
1705   if (!_print_ascii_file(&quot;/etc/release&quot;, st)) {
1706     st-&gt;print(&quot;Solaris&quot;);
1707   }
1708   st-&gt;cr();
1709 }
1710 
1711 void os::get_summary_os_info(char* buf, size_t buflen) {
1712   strncpy(buf, &quot;Solaris&quot;, buflen);  // default to plain solaris
1713   FILE* fp = fopen(&quot;/etc/release&quot;, &quot;r&quot;);
1714   if (fp != NULL) {
1715     char tmp[256];
1716     // Only get the first line and chop out everything but the os name.
</pre>
<hr />
<pre>
2003     }
2004 
2005     os::signal_notify(sig);
2006     // We do not need to reinstate the signal handler each time...
2007   }
2008 }
2009 
2010 void* os::user_handler() {
2011   return CAST_FROM_FN_PTR(void*, UserHandler);
2012 }
2013 
2014 extern &quot;C&quot; {
2015   typedef void (*sa_handler_t)(int);
2016   typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);
2017 }
2018 
2019 void* os::signal(int signal_number, void* handler) {
2020   struct sigaction sigAct, oldSigAct;
2021   sigfillset(&amp;(sigAct.sa_mask));
2022   sigAct.sa_flags = SA_RESTART &amp; ~SA_RESETHAND;

2023   sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);
2024 
2025   if (sigaction(signal_number, &amp;sigAct, &amp;oldSigAct)) {
2026     // -1 means registration failed
2027     return (void *)-1;
2028   }
2029 
2030   return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);
2031 }
2032 
2033 void os::signal_raise(int signal_number) {
2034   raise(signal_number);
2035 }
2036 
2037 // The following code is moved from os.cpp for making this
2038 // code platform specific, which it is by its very nature.
2039 
2040 // a counter for each possible signal value
2041 static int Sigexit = 0;
2042 static jint *pending_signals = NULL;
</pre>
<hr />
<pre>
2076   // Initialize signal semaphore
2077   sig_sem = new Semaphore();
2078 }
2079 
2080 void os::signal_notify(int sig) {
2081   if (sig_sem != NULL) {
2082     Atomic::inc(&amp;pending_signals[sig]);
2083     sig_sem-&gt;signal();
2084   } else {
2085     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
2086     // initialization isn&#39;t called.
2087     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
2088   }
2089 }
2090 
2091 static int check_pending_signals() {
2092   int ret;
2093   while (true) {
2094     for (int i = 0; i &lt; Sigexit + 1; i++) {
2095       jint n = pending_signals[i];
<span class="line-modified">2096       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(n - 1, &amp;pending_signals[i], n)) {</span>
2097         return i;
2098       }
2099     }
2100     JavaThread *thread = JavaThread::current();
2101     ThreadBlockInVM tbivm(thread);
2102 
2103     bool threadIsSuspended;
2104     do {
2105       thread-&gt;set_suspend_equivalent();
2106       sig_sem-&gt;wait();
2107 
2108       // were we externally suspended while we were waiting?
2109       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
2110       if (threadIsSuspended) {
2111         // The semaphore has been incremented, but while we were waiting
2112         // another thread suspended us. We don&#39;t want to continue running
2113         // while suspended because that would surprise the thread that
2114         // suspended us.
2115         sig_sem-&gt;signal();
2116 
</pre>
<hr />
<pre>
2164                                     int err) {
2165   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
2166           &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, addr, bytes, exec,
2167           os::strerror(err), err);
2168 }
2169 
2170 static void warn_fail_commit_memory(char* addr, size_t bytes,
2171                                     size_t alignment_hint, bool exec,
2172                                     int err) {
2173   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
2174           &quot;, &quot; SIZE_FORMAT &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, addr, bytes,
2175           alignment_hint, exec, os::strerror(err), err);
2176 }
2177 
2178 int os::Solaris::commit_memory_impl(char* addr, size_t bytes, bool exec) {
2179   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
2180   size_t size = bytes;
2181   char *res = Solaris::mmap_chunk(addr, size, MAP_PRIVATE|MAP_FIXED, prot);
2182   if (res != NULL) {
2183     if (UseNUMAInterleaving) {
<span class="line-modified">2184       numa_make_global(addr, bytes);</span>
2185     }
2186     return 0;
2187   }
2188 
2189   int err = errno;  // save errno from mmap() call in mmap_chunk()
2190 
2191   if (!recoverable_mmap_error(err)) {
2192     warn_fail_commit_memory(addr, bytes, exec, err);
2193     vm_exit_out_of_memory(bytes, OOM_MMAP_ERROR, &quot;committing reserved memory.&quot;);
2194   }
2195 
2196   return err;
2197 }
2198 
2199 bool os::pd_commit_memory(char* addr, size_t bytes, bool exec) {
2200   return Solaris::commit_memory_impl(addr, bytes, exec) == 0;
2201 }
2202 
2203 void os::pd_commit_memory_or_exit(char* addr, size_t bytes, bool exec,
2204                                   const char* mesg) {
</pre>
<hr />
<pre>
2359 }
2360 
2361 // Get the group id of the current LWP.
2362 int os::numa_get_group_id() {
2363   int lgrp_id = Solaris::lgrp_home(P_LWPID, P_MYID);
2364   if (lgrp_id == -1) {
2365     return 0;
2366   }
2367   const int size = os::numa_get_groups_num();
2368   int *ids = (int*)alloca(size * sizeof(int));
2369 
2370   // Get the ids of all lgroups with memory; r is the count.
2371   int r = Solaris::lgrp_resources(Solaris::lgrp_cookie(), lgrp_id,
2372                                   (Solaris::lgrp_id_t*)ids, size, LGRP_RSRC_MEM);
2373   if (r &lt;= 0) {
2374     return 0;
2375   }
2376   return ids[os::random() % r];
2377 }
2378 




2379 // Request information about the page.
2380 bool os::get_page_info(char *start, page_info* info) {
2381   const uint_t info_types[] = { MEMINFO_VLGRP, MEMINFO_VPAGESIZE };
2382   uint64_t addr = (uintptr_t)start;
2383   uint64_t outdata[2];
2384   uint_t validity = 0;
2385 
2386   if (meminfo(&amp;addr, 1, info_types, 2, outdata, &amp;validity) &lt; 0) {
2387     return false;
2388   }
2389 
2390   info-&gt;size = 0;
2391   info-&gt;lgrp_id = -1;
2392 
2393   if ((validity &amp; 1) != 0) {
2394     if ((validity &amp; 2) != 0) {
2395       info-&gt;lgrp_id = outdata[0];
2396     }
2397     if ((validity &amp; 4) != 0) {
2398       info-&gt;size = outdata[1];
</pre>
<hr />
<pre>
2514   guarantee(requested_addr == NULL || requested_addr == addr,
2515             &quot;OS failed to return requested mmap address.&quot;);
2516   return addr;
2517 }
2518 
2519 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
2520   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
2521   char* result = pd_attempt_reserve_memory_at(bytes, requested_addr);
2522   if (result != NULL) {
2523     if (replace_existing_mapping_with_file_mapping(result, bytes, file_desc) == NULL) {
2524       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
2525     }
2526   }
2527   return result;
2528 }
2529 
2530 // Reserve memory at an arbitrary address, only if that area is
2531 // available (and not reserved for something else).
2532 
2533 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
<span class="line-removed">2534   const int max_tries = 10;</span>
<span class="line-removed">2535   char* base[max_tries];</span>
<span class="line-removed">2536   size_t size[max_tries];</span>
<span class="line-removed">2537 </span>
<span class="line-removed">2538   // Solaris adds a gap between mmap&#39;ed regions.  The size of the gap</span>
<span class="line-removed">2539   // is dependent on the requested size and the MMU.  Our initial gap</span>
<span class="line-removed">2540   // value here is just a guess and will be corrected later.</span>
<span class="line-removed">2541   bool had_top_overlap = false;</span>
<span class="line-removed">2542   bool have_adjusted_gap = false;</span>
<span class="line-removed">2543   size_t gap = 0x400000;</span>
<span class="line-removed">2544 </span>
2545   // Assert only that the size is a multiple of the page size, since
2546   // that&#39;s all that mmap requires, and since that&#39;s all we really know
2547   // about at this low abstraction level.  If we need higher alignment,
2548   // we can either pass an alignment to this method or verify alignment
2549   // in one of the methods further up the call chain.  See bug 5044738.
2550   assert(bytes % os::vm_page_size() == 0, &quot;reserving unexpected size block&quot;);
2551 
2552   // Since snv_84, Solaris attempts to honor the address hint - see 5003415.
<span class="line-removed">2553   // Give it a try, if the kernel honors the hint we can return immediately.</span>
2554   char* addr = Solaris::anon_mmap(requested_addr, bytes, 0, false);
2555 
2556   volatile int err = errno;
2557   if (addr == requested_addr) {
2558     return addr;
<span class="line-removed">2559   } else if (addr != NULL) {</span>
<span class="line-removed">2560     pd_unmap_memory(addr, bytes);</span>
<span class="line-removed">2561   }</span>
<span class="line-removed">2562 </span>
<span class="line-removed">2563   if (log_is_enabled(Warning, os)) {</span>
<span class="line-removed">2564     char buf[256];</span>
<span class="line-removed">2565     buf[0] = &#39;\0&#39;;</span>
<span class="line-removed">2566     if (addr == NULL) {</span>
<span class="line-removed">2567       jio_snprintf(buf, sizeof(buf), &quot;: %s&quot;, os::strerror(err));</span>
<span class="line-removed">2568     }</span>
<span class="line-removed">2569     log_info(os)(&quot;attempt_reserve_memory_at: couldn&#39;t reserve &quot; SIZE_FORMAT &quot; bytes at &quot;</span>
<span class="line-removed">2570             PTR_FORMAT &quot;: reserve_memory_helper returned &quot; PTR_FORMAT</span>
<span class="line-removed">2571             &quot;%s&quot;, bytes, requested_addr, addr, buf);</span>
<span class="line-removed">2572   }</span>
<span class="line-removed">2573 </span>
<span class="line-removed">2574   // Address hint method didn&#39;t work.  Fall back to the old method.</span>
<span class="line-removed">2575   // In theory, once SNV becomes our oldest supported platform, this</span>
<span class="line-removed">2576   // code will no longer be needed.</span>
<span class="line-removed">2577   //</span>
<span class="line-removed">2578   // Repeatedly allocate blocks until the block is allocated at the</span>
<span class="line-removed">2579   // right spot. Give up after max_tries.</span>
<span class="line-removed">2580   int i;</span>
<span class="line-removed">2581   for (i = 0; i &lt; max_tries; ++i) {</span>
<span class="line-removed">2582     base[i] = reserve_memory(bytes);</span>
<span class="line-removed">2583 </span>
<span class="line-removed">2584     if (base[i] != NULL) {</span>
<span class="line-removed">2585       // Is this the block we wanted?</span>
<span class="line-removed">2586       if (base[i] == requested_addr) {</span>
<span class="line-removed">2587         size[i] = bytes;</span>
<span class="line-removed">2588         break;</span>
<span class="line-removed">2589       }</span>
<span class="line-removed">2590 </span>
<span class="line-removed">2591       // check that the gap value is right</span>
<span class="line-removed">2592       if (had_top_overlap &amp;&amp; !have_adjusted_gap) {</span>
<span class="line-removed">2593         size_t actual_gap = base[i-1] - base[i] - bytes;</span>
<span class="line-removed">2594         if (gap != actual_gap) {</span>
<span class="line-removed">2595           // adjust the gap value and retry the last 2 allocations</span>
<span class="line-removed">2596           assert(i &gt; 0, &quot;gap adjustment code problem&quot;);</span>
<span class="line-removed">2597           have_adjusted_gap = true;  // adjust the gap only once, just in case</span>
<span class="line-removed">2598           gap = actual_gap;</span>
<span class="line-removed">2599           log_info(os)(&quot;attempt_reserve_memory_at: adjusted gap to 0x%lx&quot;, gap);</span>
<span class="line-removed">2600           unmap_memory(base[i], bytes);</span>
<span class="line-removed">2601           unmap_memory(base[i-1], size[i-1]);</span>
<span class="line-removed">2602           i-=2;</span>
<span class="line-removed">2603           continue;</span>
<span class="line-removed">2604         }</span>
<span class="line-removed">2605       }</span>
<span class="line-removed">2606 </span>
<span class="line-removed">2607       // Does this overlap the block we wanted? Give back the overlapped</span>
<span class="line-removed">2608       // parts and try again.</span>
<span class="line-removed">2609       //</span>
<span class="line-removed">2610       // There is still a bug in this code: if top_overlap == bytes,</span>
<span class="line-removed">2611       // the overlap is offset from requested region by the value of gap.</span>
<span class="line-removed">2612       // In this case giving back the overlapped part will not work,</span>
<span class="line-removed">2613       // because we&#39;ll give back the entire block at base[i] and</span>
<span class="line-removed">2614       // therefore the subsequent allocation will not generate a new gap.</span>
<span class="line-removed">2615       // This could be fixed with a new algorithm that used larger</span>
<span class="line-removed">2616       // or variable size chunks to find the requested region -</span>
<span class="line-removed">2617       // but such a change would introduce additional complications.</span>
<span class="line-removed">2618       // It&#39;s rare enough that the planets align for this bug,</span>
<span class="line-removed">2619       // so we&#39;ll just wait for a fix for 6204603/5003415 which</span>
<span class="line-removed">2620       // will provide a mmap flag to allow us to avoid this business.</span>
<span class="line-removed">2621 </span>
<span class="line-removed">2622       size_t top_overlap = requested_addr + (bytes + gap) - base[i];</span>
<span class="line-removed">2623       if (top_overlap &gt;= 0 &amp;&amp; top_overlap &lt; bytes) {</span>
<span class="line-removed">2624         had_top_overlap = true;</span>
<span class="line-removed">2625         unmap_memory(base[i], top_overlap);</span>
<span class="line-removed">2626         base[i] += top_overlap;</span>
<span class="line-removed">2627         size[i] = bytes - top_overlap;</span>
<span class="line-removed">2628       } else {</span>
<span class="line-removed">2629         size_t bottom_overlap = base[i] + bytes - requested_addr;</span>
<span class="line-removed">2630         if (bottom_overlap &gt;= 0 &amp;&amp; bottom_overlap &lt; bytes) {</span>
<span class="line-removed">2631           if (bottom_overlap == 0) {</span>
<span class="line-removed">2632             log_info(os)(&quot;attempt_reserve_memory_at: possible alignment bug&quot;);</span>
<span class="line-removed">2633           }</span>
<span class="line-removed">2634           unmap_memory(requested_addr, bottom_overlap);</span>
<span class="line-removed">2635           size[i] = bytes - bottom_overlap;</span>
<span class="line-removed">2636         } else {</span>
<span class="line-removed">2637           size[i] = bytes;</span>
<span class="line-removed">2638         }</span>
<span class="line-removed">2639       }</span>
<span class="line-removed">2640     }</span>
2641   }
2642 
<span class="line-modified">2643   // Give back the unused reserved pieces.</span>
<span class="line-modified">2644 </span>
<span class="line-removed">2645   for (int j = 0; j &lt; i; ++j) {</span>
<span class="line-removed">2646     if (base[j] != NULL) {</span>
<span class="line-removed">2647       unmap_memory(base[j], size[j]);</span>
<span class="line-removed">2648     }</span>
2649   }
2650 
<span class="line-modified">2651   return (i &lt; max_tries) ? requested_addr : NULL;</span>
2652 }
2653 
2654 bool os::pd_release_memory(char* addr, size_t bytes) {
2655   size_t size = bytes;
2656   return munmap(addr, size) == 0;
2657 }
2658 
2659 static bool solaris_mprotect(char* addr, size_t bytes, int prot) {
2660   assert(addr == (char*)align_down((uintptr_t)addr, os::vm_page_size()),
2661          &quot;addr must be page aligned&quot;);

2662   int retVal = mprotect(addr, bytes, prot);
2663   return retVal == 0;
2664 }
2665 
2666 // Protect memory (Used to pass readonly pages through
2667 // JNI GetArray&lt;type&gt;Elements with empty arrays.)
2668 // Also, used for serialization page and for compressed oops null pointer
2669 // checking.
2670 bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
2671                         bool is_committed) {
2672   unsigned int p = 0;
2673   switch (prot) {
2674   case MEM_PROT_NONE: p = PROT_NONE; break;
2675   case MEM_PROT_READ: p = PROT_READ; break;
2676   case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;
2677   case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;
2678   default:
2679     ShouldNotReachHere();
2680   }
2681   // is_committed is unused.
</pre>
<hr />
<pre>
3873   }
3874 
3875   set_signal_handler(SIGSEGV, true, true);
3876   set_signal_handler(SIGPIPE, true, true);
3877   set_signal_handler(SIGXFSZ, true, true);
3878   set_signal_handler(SIGBUS, true, true);
3879   set_signal_handler(SIGILL, true, true);
3880   set_signal_handler(SIGFPE, true, true);
3881   set_signal_handler(ASYNC_SIGNAL, true, true);
3882 
3883   if (libjsig_is_loaded) {
3884     // Tell libjsig jvm finishes setting signal handlers
3885     (*end_signal_setting)();
3886   }
3887 
3888   // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
3889   // and if UserSignalHandler is installed all bets are off.
3890   // Log that signal checking is off only if -verbose:jni is specified.
3891   if (CheckJNICalls) {
3892     if (libjsig_is_loaded) {
<span class="line-modified">3893       if (PrintJNIResolving) {</span>
<span class="line-removed">3894         tty-&gt;print_cr(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>
<span class="line-removed">3895       }</span>
3896       check_signals = false;
3897     }
3898     if (AllowUserSignalHandlers) {
<span class="line-modified">3899       if (PrintJNIResolving) {</span>
<span class="line-removed">3900         tty-&gt;print_cr(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>
<span class="line-removed">3901       }</span>
3902       check_signals = false;
3903     }
3904   }
3905 }
3906 
3907 
3908 void report_error(const char* file_name, int line_no, const char* title,
3909                   const char* format, ...);
3910 
3911 // (Static) wrappers for the liblgrp API
3912 os::Solaris::lgrp_home_func_t os::Solaris::_lgrp_home;
3913 os::Solaris::lgrp_init_func_t os::Solaris::_lgrp_init;
3914 os::Solaris::lgrp_fini_func_t os::Solaris::_lgrp_fini;
3915 os::Solaris::lgrp_root_func_t os::Solaris::_lgrp_root;
3916 os::Solaris::lgrp_children_func_t os::Solaris::_lgrp_children;
3917 os::Solaris::lgrp_resources_func_t os::Solaris::_lgrp_resources;
3918 os::Solaris::lgrp_nlgrps_func_t os::Solaris::_lgrp_nlgrps;
3919 os::Solaris::lgrp_cookie_stale_func_t os::Solaris::_lgrp_cookie_stale;
3920 os::Solaris::lgrp_cookie_t os::Solaris::_lgrp_cookie = 0;
3921 
</pre>
<hr />
<pre>
4205 
4206     // note: perfMemory_exit_helper atexit function may be removed in
4207     // the future if the appropriate cleanup code can be added to the
4208     // VM_Exit VMOperation&#39;s doit method.
4209     if (atexit(perfMemory_exit_helper) != 0) {
4210       warning(&quot;os::init2 atexit(perfMemory_exit_helper) failed&quot;);
4211     }
4212   }
4213 
4214   // Init pset_loadavg function pointer
4215   init_pset_getloadavg_ptr();
4216 
4217   // Shared Posix initialization
4218   os::Posix::init_2();
4219 
4220   return JNI_OK;
4221 }
4222 
4223 // Mark the polling page as unreadable
4224 void os::make_polling_page_unreadable(void) {

4225   if (mprotect((char *)_polling_page, page_size, PROT_NONE) != 0) {
4226     fatal(&quot;Could not disable polling page&quot;);
4227   }
4228 }
4229 
4230 // Mark the polling page as readable
4231 void os::make_polling_page_readable(void) {

4232   if (mprotect((char *)_polling_page, page_size, PROT_READ) != 0) {
4233     fatal(&quot;Could not enable polling page&quot;);
4234   }
4235 }
4236 
4237 // Is a (classpath) directory empty?
4238 bool os::dir_is_empty(const char* path) {
4239   DIR *dir = NULL;
4240   struct dirent *ptr;
4241 
4242   dir = opendir(path);
4243   if (dir == NULL) return true;
4244 
4245   // Scan the directory
4246   bool result = true;
4247   while (result &amp;&amp; (ptr = readdir(dir)) != NULL) {
4248     if (strcmp(ptr-&gt;d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(ptr-&gt;d_name, &quot;..&quot;) != 0) {
4249       result = false;
4250     }
4251   }
</pre>
<hr />
<pre>
4454 
4455 
4456 // Remap a block of memory.
4457 char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
4458                           char *addr, size_t bytes, bool read_only,
4459                           bool allow_exec) {
4460   // same as map_memory() on this OS
4461   return os::map_memory(fd, file_name, file_offset, addr, bytes, read_only,
4462                         allow_exec);
4463 }
4464 
4465 
4466 // Unmap a block of memory.
4467 bool os::pd_unmap_memory(char* addr, size_t bytes) {
4468   return munmap(addr, bytes) == 0;
4469 }
4470 
4471 void os::pause() {
4472   char filename[MAX_PATH];
4473   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">4474     jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);</span>
4475   } else {
4476     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
4477   }
4478 
4479   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
4480   if (fd != -1) {
4481     struct stat buf;
4482     ::close(fd);
4483     while (::stat(filename, &amp;buf) == 0) {
4484       (void)::poll(NULL, 0, 100);
4485     }
4486   } else {
4487     jio_fprintf(stderr,
4488                 &quot;Could not open pause file &#39;%s&#39;, continuing immediately.\n&quot;, filename);
4489   }
4490 }
4491 
4492 #ifndef PRODUCT
4493 #ifdef INTERPOSE_ON_SYSTEM_SYNCH_FUNCTIONS
4494 // Turn this on if you need to trace synch operations.
</pre>
<hr />
<pre>
4897     abstime-&gt;tv_sec += 1;
4898     usec -= 1000000;
4899   }
4900   abstime-&gt;tv_nsec = usec * 1000;
4901   return abstime;
4902 }
4903 
4904 void os::PlatformEvent::park() {           // AKA: down()
4905   // Transitions for _Event:
4906   //   -1 =&gt; -1 : illegal
4907   //    1 =&gt;  0 : pass - return immediately
4908   //    0 =&gt; -1 : block; then set _Event to 0 before returning
4909 
4910   // Invariant: Only the thread associated with the Event/PlatformEvent
4911   // may call park().
4912   assert(_nParked == 0, &quot;invariant&quot;);
4913 
4914   int v;
4915   for (;;) {
4916     v = _Event;
<span class="line-modified">4917     if (Atomic::cmpxchg(v-1, &amp;_Event, v) == v) break;</span>
4918   }
4919   guarantee(v &gt;= 0, &quot;invariant&quot;);
4920   if (v == 0) {
4921     // Do this the hard way by blocking ...
4922     // See http://monaco.sfbay/detail.jsf?cr=5094058.
4923     int status = os::Solaris::mutex_lock(_mutex);
4924     assert_status(status == 0, status, &quot;mutex_lock&quot;);
4925     guarantee(_nParked == 0, &quot;invariant&quot;);
4926     ++_nParked;
4927     while (_Event &lt; 0) {
4928       // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...
4929       // Treat this the same as if the wait was interrupted
4930       // With usr/lib/lwp going to kernel, always handle ETIME
4931       status = os::Solaris::cond_wait(_cond, _mutex);
4932       if (status == ETIME) status = EINTR;
4933       assert_status(status == 0 || status == EINTR, status, &quot;cond_wait&quot;);
4934     }
4935     --_nParked;
4936     _Event = 0;
4937     status = os::Solaris::mutex_unlock(_mutex);
4938     assert_status(status == 0, status, &quot;mutex_unlock&quot;);
4939     // Paranoia to ensure our locked and lock-free paths interact
4940     // correctly with each other.
4941     OrderAccess::fence();
4942   }
4943 }
4944 
4945 int os::PlatformEvent::park(jlong millis) {
4946   // Transitions for _Event:
4947   //   -1 =&gt; -1 : illegal
4948   //    1 =&gt;  0 : pass - return immediately
4949   //    0 =&gt; -1 : block; then set _Event to 0 before returning
4950 
4951   guarantee(_nParked == 0, &quot;invariant&quot;);
4952   int v;
4953   for (;;) {
4954     v = _Event;
<span class="line-modified">4955     if (Atomic::cmpxchg(v-1, &amp;_Event, v) == v) break;</span>
4956   }
4957   guarantee(v &gt;= 0, &quot;invariant&quot;);
4958   if (v != 0) return OS_OK;
4959 
4960   int ret = OS_TIMEOUT;
4961   timestruc_t abst;
4962   compute_abstime(&amp;abst, millis);
4963 
4964   // See http://monaco.sfbay/detail.jsf?cr=5094058.
4965   int status = os::Solaris::mutex_lock(_mutex);
4966   assert_status(status == 0, status, &quot;mutex_lock&quot;);
4967   guarantee(_nParked == 0, &quot;invariant&quot;);
4968   ++_nParked;
4969   while (_Event &lt; 0) {
4970     int status = os::Solaris::cond_timedwait(_cond, _mutex, &amp;abst);
4971     assert_status(status == 0 || status == EINTR ||
4972                   status == ETIME || status == ETIMEDOUT,
4973                   status, &quot;cond_timedwait&quot;);
4974     if (!FilterSpuriousWakeups) break;                // previous semantics
4975     if (status == ETIME || status == ETIMEDOUT) break;
</pre>
<hr />
<pre>
4984   // correctly with each other.
4985   OrderAccess::fence();
4986   return ret;
4987 }
4988 
4989 void os::PlatformEvent::unpark() {
4990   // Transitions for _Event:
4991   //    0 =&gt; 1 : just return
4992   //    1 =&gt; 1 : just return
4993   //   -1 =&gt; either 0 or 1; must signal target thread
4994   //         That is, we can safely transition _Event from -1 to either
4995   //         0 or 1.
4996   // See also: &quot;Semaphores in Plan 9&quot; by Mullender &amp; Cox
4997   //
4998   // Note: Forcing a transition from &quot;-1&quot; to &quot;1&quot; on an unpark() means
4999   // that it will take two back-to-back park() calls for the owning
5000   // thread to block. This has the benefit of forcing a spurious return
5001   // from the first park() call after an unpark() call which will help
5002   // shake out uses of park() and unpark() without condition variables.
5003 
<span class="line-modified">5004   if (Atomic::xchg(1, &amp;_Event) &gt;= 0) return;</span>
5005 
5006   // If the thread associated with the event was parked, wake it.
5007   // Wait for the thread assoc with the PlatformEvent to vacate.
5008   int status = os::Solaris::mutex_lock(_mutex);
5009   assert_status(status == 0, status, &quot;mutex_lock&quot;);
5010   int AnyWaiters = _nParked;
5011   status = os::Solaris::mutex_unlock(_mutex);
5012   assert_status(status == 0, status, &quot;mutex_unlock&quot;);
5013   guarantee(AnyWaiters == 0 || AnyWaiters == 1, &quot;invariant&quot;);
5014   if (AnyWaiters != 0) {
5015     // Note that we signal() *after* dropping the lock for &quot;immortal&quot; Events.
5016     // This is safe and avoids a common class of  futile wakeups.  In rare
5017     // circumstances this can cause a thread to return prematurely from
5018     // cond_{timed}wait() but the spurious wakeup is benign and the victim
5019     // will simply re-test the condition and re-park itself.
5020     // This provides particular benefit if the underlying platform does not
5021     // provide wait morphing.
5022     status = os::Solaris::cond_signal(_cond);
5023     assert_status(status == 0, status, &quot;cond_signal&quot;);
5024   }
</pre>
<hr />
<pre>
5083       if (absTime-&gt;tv_nsec &gt;= NANOSECS_PER_SEC) {
5084         absTime-&gt;tv_nsec -= NANOSECS_PER_SEC;
5085         ++absTime-&gt;tv_sec; // note: this must be &lt;= max_secs
5086       }
5087     }
5088   }
5089   assert(absTime-&gt;tv_sec &gt;= 0, &quot;tv_sec &lt; 0&quot;);
5090   assert(absTime-&gt;tv_sec &lt;= max_secs, &quot;tv_sec &gt; max_secs&quot;);
5091   assert(absTime-&gt;tv_nsec &gt;= 0, &quot;tv_nsec &lt; 0&quot;);
5092   assert(absTime-&gt;tv_nsec &lt; NANOSECS_PER_SEC, &quot;tv_nsec &gt;= nanos_per_sec&quot;);
5093 }
5094 
5095 void Parker::park(bool isAbsolute, jlong time) {
5096   // Ideally we&#39;d do something useful while spinning, such
5097   // as calling unpackTime().
5098 
5099   // Optional fast-path check:
5100   // Return immediately if a permit is available.
5101   // We depend on Atomic::xchg() having full barrier semantics
5102   // since we are doing a lock-free update to _counter.
<span class="line-modified">5103   if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;</span>
5104 
5105   // Optional fast-exit: Check interrupt before trying to wait
5106   Thread* thread = Thread::current();
5107   assert(thread-&gt;is_Java_thread(), &quot;Must be JavaThread&quot;);
5108   JavaThread *jt = (JavaThread *)thread;
<span class="line-modified">5109   if (Thread::is_interrupted(thread, false)) {</span>
5110     return;
5111   }
5112 
5113   // First, demultiplex/decode time arguments
5114   timespec absTime;
5115   if (time &lt; 0 || (isAbsolute &amp;&amp; time == 0)) { // don&#39;t wait at all
5116     return;
5117   }
5118   if (time &gt; 0) {
5119     // Warning: this code might be exposed to the old Solaris time
5120     // round-down bugs.  Grep &quot;roundingFix&quot; for details.
5121     unpackTime(&amp;absTime, isAbsolute, time);
5122   }
5123 
5124   // Enter safepoint region
5125   // Beware of deadlocks such as 6317397.
5126   // The per-thread Parker:: _mutex is a classic leaf-lock.
5127   // In particular a thread must never block on the Threads_lock while
5128   // holding the Parker:: mutex.  If safepoints are pending both the
5129   // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.
5130   ThreadBlockInVM tbivm(jt);
5131 



5132   // Don&#39;t wait if cannot get lock since interference arises from
<span class="line-modified">5133   // unblocking.  Also. check interrupt before trying wait</span>
<span class="line-modified">5134   if (Thread::is_interrupted(thread, false) ||</span>
<span class="line-removed">5135       os::Solaris::mutex_trylock(_mutex) != 0) {</span>
5136     return;
5137   }
5138 
5139   int status;
5140 
5141   if (_counter &gt; 0)  { // no wait needed
5142     _counter = 0;
5143     status = os::Solaris::mutex_unlock(_mutex);
5144     assert(status == 0, &quot;invariant&quot;);
5145     // Paranoia to ensure our locked and lock-free paths interact
5146     // correctly with each other and Java-level accesses.
5147     OrderAccess::fence();
5148     return;
5149   }
5150 
5151   OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);
5152   jt-&gt;set_suspend_equivalent();
5153   // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
5154 
5155   // Do this the hard way by blocking ...
</pre>
<hr />
<pre>
5175   // If externally suspended while waiting, re-suspend
5176   if (jt-&gt;handle_special_suspend_equivalent_condition()) {
5177     jt-&gt;java_suspend_self();
5178   }
5179 }
5180 
5181 void Parker::unpark() {
5182   int status = os::Solaris::mutex_lock(_mutex);
5183   assert(status == 0, &quot;invariant&quot;);
5184   const int s = _counter;
5185   _counter = 1;
5186   status = os::Solaris::mutex_unlock(_mutex);
5187   assert(status == 0, &quot;invariant&quot;);
5188 
5189   if (s &lt; 1) {
5190     status = os::Solaris::cond_signal(_cond);
5191     assert(status == 0, &quot;invariant&quot;);
5192   }
5193 }
5194 
<span class="line-modified">5195 // Platform Monitor implementation</span>
5196 
<span class="line-modified">5197 os::PlatformMonitor::PlatformMonitor() {</span>
<span class="line-modified">5198   int status = os::Solaris::cond_init(&amp;_cond);</span>
<span class="line-removed">5199   assert_status(status == 0, status, &quot;cond_init&quot;);</span>
<span class="line-removed">5200   status = os::Solaris::mutex_init(&amp;_mutex);</span>
5201   assert_status(status == 0, status, &quot;mutex_init&quot;);
5202 }
5203 
<span class="line-modified">5204 os::PlatformMonitor::~PlatformMonitor() {</span>
<span class="line-modified">5205   int status = os::Solaris::cond_destroy(&amp;_cond);</span>
<span class="line-removed">5206   assert_status(status == 0, status, &quot;cond_destroy&quot;);</span>
<span class="line-removed">5207   status = os::Solaris::mutex_destroy(&amp;_mutex);</span>
5208   assert_status(status == 0, status, &quot;mutex_destroy&quot;);
5209 }
5210 
<span class="line-modified">5211 void os::PlatformMonitor::lock() {</span>
5212   int status = os::Solaris::mutex_lock(&amp;_mutex);
5213   assert_status(status == 0, status, &quot;mutex_lock&quot;);
5214 }
5215 
<span class="line-modified">5216 void os::PlatformMonitor::unlock() {</span>
5217   int status = os::Solaris::mutex_unlock(&amp;_mutex);
5218   assert_status(status == 0, status, &quot;mutex_unlock&quot;);
5219 }
5220 
<span class="line-modified">5221 bool os::PlatformMonitor::try_lock() {</span>
5222   int status = os::Solaris::mutex_trylock(&amp;_mutex);
5223   assert_status(status == 0 || status == EBUSY, status, &quot;mutex_trylock&quot;);
5224   return status == 0;
5225 }
5226 










5227 // Must already be locked
5228 int os::PlatformMonitor::wait(jlong millis) {
5229   assert(millis &gt;= 0, &quot;negative timeout&quot;);
5230   if (millis &gt; 0) {
5231     timestruc_t abst;
5232     int ret = OS_TIMEOUT;
5233     compute_abstime(&amp;abst, millis);
5234     int status = os::Solaris::cond_timedwait(&amp;_cond, &amp;_mutex, &amp;abst);
5235     assert_status(status == 0 || status == EINTR ||
5236                   status == ETIME || status == ETIMEDOUT,
5237                   status, &quot;cond_timedwait&quot;);
5238     // EINTR acts as spurious wakeup - which is permitted anyway
5239     if (status == 0 || status == EINTR) {
5240       ret = OS_OK;
5241     }
5242     return ret;
5243   } else {
5244     int status = os::Solaris::cond_wait(&amp;_cond, &amp;_mutex);
5245     assert_status(status == 0 || status == EINTR,
5246                   status, &quot;cond_wait&quot;);
</pre>
<hr />
<pre>
5400   }
5401   return _result;
5402 }
5403 
5404 // Get the default path to the core file
5405 // Returns the length of the string
5406 int os::get_core_path(char* buffer, size_t bufferSize) {
5407   const char* p = get_current_directory(buffer, bufferSize);
5408 
5409   if (p == NULL) {
5410     assert(p != NULL, &quot;failed to get current directory&quot;);
5411     return 0;
5412   }
5413 
5414   jio_snprintf(buffer, bufferSize, &quot;%s/core or core.%d&quot;,
5415                                               p, current_process_id());
5416 
5417   return strlen(buffer);
5418 }
5419 




5420 #ifndef PRODUCT
5421 void TestReserveMemorySpecial_test() {
5422   // No tests available for this platform
5423 }
5424 #endif
5425 
5426 bool os::start_debugging(char *buf, int buflen) {
5427   int len = (int)strlen(buf);
5428   char *p = &amp;buf[len];
5429 
5430   jio_snprintf(p, buflen-len,
5431                &quot;\n\n&quot;
5432                &quot;Do you want to debug the problem?\n\n&quot;
5433                &quot;To debug, run &#39;dbx - %d&#39;; then switch to thread &quot; INTX_FORMAT &quot;\n&quot;
5434                &quot;Enter &#39;yes&#39; to launch dbx automatically (PATH must include dbx)\n&quot;
5435                &quot;Otherwise, press RETURN to abort...&quot;,
5436                os::current_process_id(), os::current_thread_id());
5437 
5438   bool yes = os::message_box(&quot;Unexpected Error&quot;, buf);
5439 
</pre>
</td>
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // no precompiled headers
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
<span class="line-added">  36 #include &quot;logging/logStream.hpp&quot;</span>
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/filemap.hpp&quot;
<span class="line-added">  39 #include &quot;memory/universe.hpp&quot;</span>
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;os_share_solaris.hpp&quot;
  42 #include &quot;os_solaris.inline.hpp&quot;
  43 #include &quot;prims/jniFastGetField.hpp&quot;
  44 #include &quot;prims/jvm_misc.hpp&quot;
  45 #include &quot;runtime/arguments.hpp&quot;
  46 #include &quot;runtime/atomic.hpp&quot;
  47 #include &quot;runtime/extendedPC.hpp&quot;
  48 #include &quot;runtime/globals.hpp&quot;
  49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  50 #include &quot;runtime/java.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/mutexLocker.hpp&quot;
  53 #include &quot;runtime/objectMonitor.hpp&quot;
  54 #include &quot;runtime/orderAccess.hpp&quot;
  55 #include &quot;runtime/osThread.hpp&quot;
  56 #include &quot;runtime/perfMemory.hpp&quot;
  57 #include &quot;runtime/sharedRuntime.hpp&quot;
  58 #include &quot;runtime/statSampler.hpp&quot;
  59 #include &quot;runtime/stubRoutines.hpp&quot;
</pre>
<hr />
<pre>
 248 
 249 struct tm* os::localtime_pd(const time_t* clock, struct tm*  res) {
 250   return localtime_r(clock, res);
 251 }
 252 
 253 void os::Solaris::try_enable_extended_io() {
 254   typedef int (*enable_extended_FILE_stdio_t)(int, int);
 255 
 256   if (!UseExtendedFileIO) {
 257     return;
 258   }
 259 
 260   enable_extended_FILE_stdio_t enabler =
 261     (enable_extended_FILE_stdio_t) dlsym(RTLD_DEFAULT,
 262                                          &quot;enable_extended_FILE_stdio&quot;);
 263   if (enabler) {
 264     enabler(-1, -1);
 265   }
 266 }
 267 


 268 jint os::Solaris::_os_thread_limit = 0;
 269 volatile jint os::Solaris::_os_thread_count = 0;
 270 
 271 julong os::available_memory() {
 272   return Solaris::available_memory();
 273 }
 274 
 275 julong os::Solaris::available_memory() {
 276   return (julong)sysconf(_SC_AVPHYS_PAGES) * os::vm_page_size();
 277 }
 278 
 279 julong os::Solaris::_physical_memory = 0;
 280 
 281 julong os::physical_memory() {
 282   return Solaris::physical_memory();
 283 }
 284 
 285 static hrtime_t first_hrtime = 0;
 286 static const hrtime_t hrtime_hz = 1000*1000*1000;
 287 static volatile hrtime_t max_hrtime = 0;
 288 
 289 
 290 void os::Solaris::initialize_system_info() {
 291   set_processor_count(sysconf(_SC_NPROCESSORS_CONF));

 292   _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) *
 293                                      (julong)sysconf(_SC_PAGESIZE);
 294 }
 295 
 296 uint os::processor_id() {
 297   const processorid_t id = ::getcpuid();
 298   assert(id &gt;= 0 &amp;&amp; id &lt; _processor_count, &quot;Invalid processor id&quot;);
 299   return (uint)id;
 300 }
 301 
 302 int os::active_processor_count() {
 303   // User has overridden the number of active processors
 304   if (ActiveProcessorCount &gt; 0) {
 305     log_trace(os)(&quot;active_processor_count: &quot;
 306                   &quot;active processor count set by user : %d&quot;,
 307                   ActiveProcessorCount);
 308     return ActiveProcessorCount;
 309   }
 310 
 311   int online_cpus = sysconf(_SC_NPROCESSORS_ONLN);
 312   pid_t pid = getpid();
 313   psetid_t pset = PS_NONE;
 314   // Are we running in a processor set or is there any processor set around?
 315   if (pset_bind(PS_QUERY, P_PID, pid, &amp;pset) == 0) {
 316     uint_t pset_cpus;
 317     // Query the number of cpus available to us.
 318     if (pset_info(pset, NULL, &amp;pset_cpus, NULL) == 0) {
 319       assert(pset_cpus &gt; 0 &amp;&amp; pset_cpus &lt;= online_cpus, &quot;sanity check&quot;);

 320       return pset_cpus;
 321     }
 322   }
 323   // Otherwise return number of online cpus
 324   return online_cpus;
 325 }
 326 




































































































































 327 void os::set_native_thread_name(const char *name) {
 328   if (Solaris::_pthread_setname_np != NULL) {
 329     // Only the first 31 bytes of &#39;name&#39; are processed by pthread_setname_np
 330     // but we explicitly copy into a size-limited buffer to avoid any
 331     // possible overflow.
 332     char buf[32];
 333     snprintf(buf, sizeof(buf), &quot;%s&quot;, name);
 334     buf[sizeof(buf) - 1] = &#39;\0&#39;;
 335     Solaris::_pthread_setname_np(pthread_self(), buf);
 336   }
 337 }
 338 



























 339 bool os::bind_to_processor(uint processor_id) {
 340   // We assume that a processorid_t can be stored in a uint.
 341   assert(sizeof(uint) == sizeof(processorid_t),
 342          &quot;can&#39;t convert uint to processorid_t&quot;);
 343   int bind_result =
 344     processor_bind(P_LWPID,                       // bind LWP.
 345                    P_MYID,                        // bind current LWP.
 346                    (processorid_t) processor_id,  // id.
 347                    NULL);                         // don&#39;t return old binding.
 348   return (bind_result == 0);
 349 }
 350 
 351 // Return true if user is running as root.
 352 
 353 bool os::have_special_privileges() {
 354   static bool init = false;
 355   static bool privileges = false;
 356   if (!init) {
 357     privileges = (getuid() != geteuid()) || (getgid() != getegid());
 358     init = true;
</pre>
<hr />
<pre>
 382   // then we append a fake suffix &quot;hotspot/libjvm.so&quot; to this path so
 383   // it looks like libjvm.so is installed there
 384   // &lt;JAVA_HOME&gt;/jre/lib/&lt;arch&gt;/hotspot/libjvm.so.
 385   //
 386   // Otherwise exit.
 387   //
 388   // Important note: if the location of libjvm.so changes this
 389   // code needs to be changed accordingly.
 390 
 391 // Base path of extensions installed on the system.
 392 #define SYS_EXT_DIR     &quot;/usr/jdk/packages&quot;
 393 #define EXTENSIONS_DIR  &quot;/lib/ext&quot;
 394 
 395   // Buffer that fits several sprintfs.
 396   // Note that the space for the colon and the trailing null are provided
 397   // by the nulls included by the sizeof operator.
 398   const size_t bufsize =
 399     MAX3((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
 400          sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;), // invariant ld_library_path
 401          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="line-modified"> 402   char *buf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 403 
 404   // sysclasspath, java_home, dll_dir
 405   {
 406     char *pslash;
 407     os::jvm_path(buf, bufsize);
 408 
 409     // Found the full path to libjvm.so.
 410     // Now cut the path to &lt;java_home&gt;/jre if we can.
 411     *(strrchr(buf, &#39;/&#39;)) = &#39;\0&#39;; // Get rid of /libjvm.so.
 412     pslash = strrchr(buf, &#39;/&#39;);
 413     if (pslash != NULL) {
 414       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 415     }
 416     Arguments::set_dll_dir(buf);
 417 
 418     if (pslash != NULL) {
 419       pslash = strrchr(buf, &#39;/&#39;);
 420       if (pslash != NULL) {
 421         *pslash = &#39;\0&#39;;        // Get rid of /lib.
 422       }
</pre>
<hr />
<pre>
 468       vm_exit_during_initialization(&quot;dlinfo SERINFO request&quot;, dlerror());
 469     }
 470 
 471     path = &amp;info-&gt;dls_serpath[0];
 472 
 473     // Note: Due to a legacy implementation, most of the library path
 474     // is set in the launcher. This was to accomodate linking restrictions
 475     // on legacy Solaris implementations (which are no longer supported).
 476     // Eventually, all the library path setting will be done here.
 477     //
 478     // However, to prevent the proliferation of improperly built native
 479     // libraries, the new path component /usr/jdk/packages is added here.
 480 
 481     // Construct the invariant part of ld_library_path.
 482     sprintf(common_path, SYS_EXT_DIR &quot;/lib&quot;);
 483 
 484     // Struct size is more than sufficient for the path components obtained
 485     // through the dlinfo() call, so only add additional space for the path
 486     // components explicitly added here.
 487     size_t library_path_size = info-&gt;dls_size + strlen(common_path);
<span class="line-modified"> 488     library_path = NEW_C_HEAP_ARRAY(char, library_path_size, mtInternal);</span>
 489     library_path[0] = &#39;\0&#39;;
 490 
 491     // Construct the desired Java library path from the linker&#39;s library
 492     // search path.
 493     //
 494     // For compatibility, it is optimal that we insert the additional path
 495     // components specific to the Java VM after those components specified
 496     // in LD_LIBRARY_PATH (if any) but before those added by the ld.so
 497     // infrastructure.
 498     if (info-&gt;dls_cnt == 0) { // Not sure this can happen, but allow for it.
 499       strcpy(library_path, common_path);
 500     } else {
 501       int inserted = 0;
 502       int i;
 503       for (i = 0; i &lt; info-&gt;dls_cnt; i++, path++) {
 504         uint_t flags = path-&gt;dls_flags &amp; LA_SER_MASK;
 505         if (((flags &amp; LA_SER_LIBPATH) == 0) &amp;&amp; !inserted) {
 506           strcat(library_path, common_path);
 507           strcat(library_path, os::path_separator());
 508           inserted = 1;
</pre>
<hr />
<pre>
 814 
 815   // Create the Solaris thread
 816   thread_t tid = 0;
 817   long     flags = (UseDetachedThreads ? THR_DETACHED : 0) | THR_SUSPENDED;
 818   int      status;
 819 
 820   // Mark that we don&#39;t have an lwp or thread id yet.
 821   // In case we attempt to set the priority before the thread starts.
 822   osthread-&gt;set_lwp_id(-1);
 823   osthread-&gt;set_thread_id(-1);
 824 
 825   status = thr_create(NULL, stack_size, thread_native_entry, thread, flags, &amp;tid);
 826 
 827   char buf[64];
 828   if (status == 0) {
 829     log_info(os, thread)(&quot;Thread started (tid: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
 830       (uintx) tid, describe_thr_create_attributes(buf, sizeof(buf), stack_size, flags));
 831   } else {
 832     log_warning(os, thread)(&quot;Failed to start thread - thr_create failed (%s) for attributes: %s.&quot;,
 833       os::errno_name(status), describe_thr_create_attributes(buf, sizeof(buf), stack_size, flags));
<span class="line-added"> 834     // Log some OS information which might explain why creating the thread failed.</span>
<span class="line-added"> 835     log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());</span>
<span class="line-added"> 836     LogStream st(Log(os, thread)::info());</span>
<span class="line-added"> 837     os::Posix::print_rlimit_info(&amp;st);</span>
<span class="line-added"> 838     os::print_memory_info(&amp;st);</span>
 839   }
 840 
 841   if (status != 0) {
 842     thread-&gt;set_osthread(NULL);
 843     // Need to clean up stuff we&#39;ve allocated so far
 844     delete osthread;
 845     return false;
 846   }
 847 
 848   Atomic::inc(&amp;os::Solaris::_os_thread_count);
 849 
 850   // Store info on the Solaris thread into the OSThread
 851   osthread-&gt;set_thread_id(tid);
 852 
 853   // Remember that we created this thread so we can set priority on it
 854   osthread-&gt;set_vm_created();
 855 
 856   // Most thread types will set an explicit priority before starting the thread,
 857   // but for those that don&#39;t we need a valid value to read back in thread_native_entry.
 858   osthread-&gt;set_native_priority(NormPriority);
</pre>
<hr />
<pre>
1007 intx os::current_thread_id() {
1008   return (intx)thr_self();
1009 }
1010 
1011 static pid_t _initial_pid = 0;
1012 
1013 int os::current_process_id() {
1014   return (int)(_initial_pid ? _initial_pid : getpid());
1015 }
1016 
1017 // gethrtime() should be monotonic according to the documentation,
1018 // but some virtualized platforms are known to break this guarantee.
1019 // getTimeNanos() must be guaranteed not to move backwards, so we
1020 // are forced to add a check here.
1021 inline hrtime_t getTimeNanos() {
1022   const hrtime_t now = gethrtime();
1023   const hrtime_t prev = max_hrtime;
1024   if (now &lt;= prev) {
1025     return prev;   // same or retrograde time;
1026   }
<span class="line-modified">1027   const hrtime_t obsv = Atomic::cmpxchg(&amp;max_hrtime, prev, now);</span>
1028   assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
1029   // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
1030   // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
1031   // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
1032   // some other thread raced this thread and installed a new value, in which case
1033   // we could either (a) retry the entire operation, (b) retry trying to install now
1034   // or (c) just return obsv.  We use (c).   No loop is required although in some cases
1035   // we might discard a higher &quot;now&quot; value in deference to a slightly lower but freshly
1036   // installed obsv value.   That&#39;s entirely benign -- it admits no new orderings compared
1037   // to (a) or (b) -- and greatly reduces coherence traffic.
1038   // We might also condition (c) on the magnitude of the delta between obsv and now.
1039   // Avoiding excessive CAS operations to hot RW locations is critical.
1040   // See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate
1041   return (prev == obsv) ? now : obsv;
1042 }
1043 
1044 // Time since start-up in seconds to a fine granularity.
1045 // Used by VMSelfDestructTimer and the MemProfiler.
1046 double os::elapsedTime() {
1047   return (double)(getTimeNanos() - first_hrtime) / (double)hrtime_hz;
</pre>
<hr />
<pre>
1061                       double* process_user_time,
1062                       double* process_system_time) {
1063   struct tms ticks;
1064   clock_t real_ticks = times(&amp;ticks);
1065 
1066   if (real_ticks == (clock_t) (-1)) {
1067     return false;
1068   } else {
1069     double ticks_per_second = (double) clock_tics_per_sec;
1070     *process_user_time = ((double) ticks.tms_utime) / ticks_per_second;
1071     *process_system_time = ((double) ticks.tms_stime) / ticks_per_second;
1072     // For consistency return the real time from getTimeNanos()
1073     // converted to seconds.
1074     *process_real_time = ((double) getTimeNanos()) / ((double) NANOUNITS);
1075 
1076     return true;
1077   }
1078 }
1079 
1080 bool os::supports_vtime() { return true; }


1081 
1082 double os::elapsedVTime() {
1083   return (double)gethrvtime() / (double)hrtime_hz;
1084 }
1085 
1086 // Must return millis since Jan 1 1970 for JVM_CurrentTimeMillis
1087 jlong os::javaTimeMillis() {
1088   timeval t;
1089   if (gettimeofday(&amp;t, NULL) == -1) {
1090     fatal(&quot;os::javaTimeMillis: gettimeofday (%s)&quot;, os::strerror(errno));
1091   }
1092   return jlong(t.tv_sec) * 1000  +  jlong(t.tv_usec) / 1000;
1093 }
1094 
1095 // Must return seconds+nanos since Jan 1 1970. This must use the same
1096 // time source as javaTimeMillis and can&#39;t use get_nsec_fromepoch as
1097 // we need better than 1ms accuracy
1098 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
1099   timeval t;
1100   if (gettimeofday(&amp;t, NULL) == -1) {
</pre>
<hr />
<pre>
1152 // called from signal handler. Before adding something to os::abort(), make
1153 // sure it is async-safe and can handle partially initialized VM.
1154 void os::abort(bool dump_core, void* siginfo, const void* context) {
1155   os::shutdown();
1156   if (dump_core) {
1157 #ifndef PRODUCT
1158     fdStream out(defaultStream::output_fd());
1159     out.print_raw(&quot;Current thread is &quot;);
1160     char buf[16];
1161     jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());
1162     out.print_raw_cr(buf);
1163     out.print_raw_cr(&quot;Dumping core ...&quot;);
1164 #endif
1165     ::abort(); // dump core (for debugging)
1166   }
1167 
1168   ::exit(1);
1169 }
1170 
1171 // Die immediately, no exit hook, no abort hook, no cleanup.
<span class="line-added">1172 // Dump a core file, if possible, for debugging.</span>
1173 void os::die() {
<span class="line-modified">1174   if (TestUnresponsiveErrorHandler &amp;&amp; !CreateCoredumpOnCrash) {</span>
<span class="line-added">1175     // For TimeoutInErrorHandlingTest.java, we just kill the VM</span>
<span class="line-added">1176     // and don&#39;t take the time to generate a core file.</span>
<span class="line-added">1177     os::signal_raise(SIGKILL);</span>
<span class="line-added">1178   } else {</span>
<span class="line-added">1179     ::abort();</span>
<span class="line-added">1180   }</span>
1181 }
1182 
1183 // DLL functions
1184 
1185 const char* os::dll_file_extension() { return &quot;.so&quot;; }
1186 
1187 // This must be hard coded because it&#39;s the system&#39;s temporary
1188 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1189 const char* os::get_temp_directory() { return &quot;/tmp&quot;; }
1190 
1191 // check if addr is inside libjvm.so
1192 bool os::address_is_in_vm(address addr) {
1193   static address libjvm_base_addr;
1194   Dl_info dlinfo;
1195 
1196   if (libjvm_base_addr == NULL) {
1197     if (dladdr(CAST_FROM_FN_PTR(void *, os::address_is_in_vm), &amp;dlinfo) != 0) {
1198       libjvm_base_addr = (address)dlinfo.dli_fbase;
1199     }
1200     assert(libjvm_base_addr !=NULL, &quot;Cannot obtain base address for libjvm&quot;);
</pre>
<hr />
<pre>
1338     map = map-&gt;l_next;
1339   }
1340 
1341   dlclose(handle);
1342   return 0;
1343 }
1344 
1345 int _print_dll_info_cb(const char * name, address base_address, address top_address, void * param) {
1346   outputStream * out = (outputStream *) param;
1347   out-&gt;print_cr(PTR_FORMAT &quot; \t%s&quot;, base_address, name);
1348   return 0;
1349 }
1350 
1351 void os::print_dll_info(outputStream * st) {
1352   st-&gt;print_cr(&quot;Dynamic libraries:&quot;); st-&gt;flush();
1353   if (get_loaded_modules_info(_print_dll_info_cb, (void *)st)) {
1354     st-&gt;print_cr(&quot;Error: Cannot print dynamic libraries.&quot;);
1355   }
1356 }
1357 
<span class="line-added">1358 static void change_endianness(Elf32_Half&amp; val) {</span>
<span class="line-added">1359   unsigned char *ptr = (unsigned char *)&amp;val;</span>
<span class="line-added">1360   unsigned char swp = ptr[0];</span>
<span class="line-added">1361   ptr[0] = ptr[1];</span>
<span class="line-added">1362   ptr[1] = swp;</span>
<span class="line-added">1363 }</span>
<span class="line-added">1364 </span>
1365 // Loads .dll/.so and
1366 // in case of error it checks if .dll/.so was built for the
1367 // same architecture as Hotspot is running on
1368 
1369 void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
<span class="line-added">1370   log_info(os)(&quot;attempting shared library load of %s&quot;, filename);</span>
<span class="line-added">1371 </span>
1372   void * result= ::dlopen(filename, RTLD_LAZY);
1373   if (result != NULL) {
1374     // Successful loading
<span class="line-added">1375     Events::log(NULL, &quot;Loaded shared library %s&quot;, filename);</span>
<span class="line-added">1376     log_info(os)(&quot;shared library load of %s was successful&quot;, filename);</span>
1377     return result;
1378   }
1379 
1380   Elf32_Ehdr elf_head;
<span class="line-added">1381   const char* error_report = ::dlerror();</span>
<span class="line-added">1382   if (error_report == NULL) {</span>
<span class="line-added">1383     error_report = &quot;dlerror returned no error description&quot;;</span>
<span class="line-added">1384   }</span>
<span class="line-added">1385   if (ebuf != NULL &amp;&amp; ebuflen &gt; 0) {</span>
<span class="line-added">1386     ::strncpy(ebuf, error_report, ebuflen-1);</span>
<span class="line-added">1387     ebuf[ebuflen-1]=&#39;\0&#39;;</span>
<span class="line-added">1388   }</span>
<span class="line-added">1389 </span>
<span class="line-added">1390   Events::log(NULL, &quot;Loading shared library %s failed, %s&quot;, filename, error_report);</span>
<span class="line-added">1391   log_info(os)(&quot;shared library load of %s failed, %s&quot;, filename, error_report);</span>
1392 




1393   int diag_msg_max_length=ebuflen-strlen(ebuf);
1394   char* diag_msg_buf=ebuf+strlen(ebuf);
1395 
1396   if (diag_msg_max_length==0) {
1397     // No more space in ebuf for additional diagnostics message
1398     return NULL;
1399   }
1400 
1401 
1402   int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);
1403 
1404   if (file_descriptor &lt; 0) {
1405     // Can&#39;t open library, report dlerror() message
1406     return NULL;
1407   }
1408 
1409   bool failed_to_read_elf_head=
1410     (sizeof(elf_head)!=
1411      (::read(file_descriptor, &amp;elf_head,sizeof(elf_head))));
1412 
1413   ::close(file_descriptor);
1414   if (failed_to_read_elf_head) {
1415     // file i/o error - report dlerror() msg
1416     return NULL;
1417   }
1418 
<span class="line-added">1419   if (elf_head.e_ident[EI_DATA] != LITTLE_ENDIAN_ONLY(ELFDATA2LSB) BIG_ENDIAN_ONLY(ELFDATA2MSB)) {</span>
<span class="line-added">1420     // handle invalid/out of range endianness values</span>
<span class="line-added">1421     if (elf_head.e_ident[EI_DATA] == 0 || elf_head.e_ident[EI_DATA] &gt; 2) {</span>
<span class="line-added">1422       return NULL;</span>
<span class="line-added">1423     }</span>
<span class="line-added">1424     change_endianness(elf_head.e_machine);</span>
<span class="line-added">1425   }</span>
<span class="line-added">1426 </span>
1427   typedef struct {
1428     Elf32_Half    code;         // Actual value as defined in elf.h
1429     Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
1430     unsigned char elf_class;    // 32 or 64 bit
1431     unsigned char endianess;    // MSB or LSB
1432     char*         name;         // String representation
1433   } arch_t;
1434 
<span class="line-added">1435 #ifndef EM_AARCH64</span>
<span class="line-added">1436   #define EM_AARCH64    183               /* ARM AARCH64 */</span>
<span class="line-added">1437 #endif</span>
<span class="line-added">1438 </span>
1439   static const arch_t arch_array[]={
1440     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1441     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1442     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1443     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
1444     {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1445     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1446     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
1447     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1448     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)&quot;Power PC 64&quot;},
<span class="line-modified">1449     {EM_ARM,         EM_ARM,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;ARM&quot;},</span>
<span class="line-added">1450     // we only support 64 bit z architecture</span>
<span class="line-added">1451     {EM_S390,        EM_S390,    ELFCLASS64, ELFDATA2MSB, (char*)&quot;IBM System/390&quot;},</span>
<span class="line-added">1452     {EM_AARCH64,     EM_AARCH64, ELFCLASS64, ELFDATA2LSB, (char*)&quot;AARCH64&quot;}</span>
1453   };
1454 
1455 #if  (defined IA32)
1456   static  Elf32_Half running_arch_code=EM_386;
1457 #elif   (defined AMD64)
1458   static  Elf32_Half running_arch_code=EM_X86_64;
1459 #elif  (defined IA64)
1460   static  Elf32_Half running_arch_code=EM_IA_64;
1461 #elif  (defined __sparc) &amp;&amp; (defined _LP64)
1462   static  Elf32_Half running_arch_code=EM_SPARCV9;
1463 #elif  (defined __sparc) &amp;&amp; (!defined _LP64)
1464   static  Elf32_Half running_arch_code=EM_SPARC;
1465 #elif  (defined __powerpc64__)
1466   static  Elf32_Half running_arch_code=EM_PPC64;
1467 #elif  (defined __powerpc__)
1468   static  Elf32_Half running_arch_code=EM_PPC;
1469 #elif (defined ARM)
1470   static  Elf32_Half running_arch_code=EM_ARM;
1471 #else
1472   #error Method os::dll_load requires that one of following is defined:\
1473        IA32, AMD64, IA64, __sparc, __powerpc__, ARM, ARM
1474 #endif
1475 
<span class="line-modified">1476   // Identify compatibility class for VM&#39;s architecture and library&#39;s architecture</span>
1477   // Obtain string descriptions for architectures
1478 
1479   arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};
1480   int running_arch_index=-1;
1481 
1482   for (unsigned int i=0; i &lt; ARRAY_SIZE(arch_array); i++) {
1483     if (running_arch_code == arch_array[i].code) {
1484       running_arch_index    = i;
1485     }
1486     if (lib_arch.code == arch_array[i].code) {
1487       lib_arch.compat_class = arch_array[i].compat_class;
1488       lib_arch.name         = arch_array[i].name;
1489     }
1490   }
1491 
1492   assert(running_arch_index != -1,
1493          &quot;Didn&#39;t find running architecture code (running_arch_code) in arch_array&quot;);
1494   if (running_arch_index == -1) {
1495     // Even though running architecture detection failed
1496     // we may still continue with reporting dlerror() message
1497     return NULL;
1498   }
1499 
<span class="line-added">1500   if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {</span>
<span class="line-added">1501     if (lib_arch.name != NULL) {</span>
<span class="line-added">1502       ::snprintf(diag_msg_buf, diag_msg_max_length-1,</span>
<span class="line-added">1503                  &quot; (Possible cause: can&#39;t load %s .so on a %s platform)&quot;,</span>
<span class="line-added">1504                  lib_arch.name, arch_array[running_arch_index].name);</span>
<span class="line-added">1505     } else {</span>
<span class="line-added">1506       ::snprintf(diag_msg_buf, diag_msg_max_length-1,</span>
<span class="line-added">1507                  &quot; (Possible cause: can&#39;t load this .so (machine code=0x%x) on a %s platform)&quot;,</span>
<span class="line-added">1508                  lib_arch.code, arch_array[running_arch_index].name);</span>
<span class="line-added">1509     }</span>
<span class="line-added">1510     return NULL;</span>
<span class="line-added">1511   }</span>
<span class="line-added">1512 </span>
1513   if (lib_arch.endianess != arch_array[running_arch_index].endianess) {
1514     ::snprintf(diag_msg_buf, diag_msg_max_length-1,&quot; (Possible cause: endianness mismatch)&quot;);
1515     return NULL;
1516   }
1517 
<span class="line-modified">1518   // ELF file class/capacity : 0 - invalid, 1 - 32bit, 2 - 64bit</span>
<span class="line-modified">1519   if (lib_arch.elf_class &gt; 2 || lib_arch.elf_class &lt; 1) {</span>
<span class="line-added">1520     ::snprintf(diag_msg_buf, diag_msg_max_length-1, &quot; (Possible cause: invalid ELF file class)&quot;);</span>
1521     return NULL;
1522   }
1523 
<span class="line-modified">1524   if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {</span>
<span class="line-modified">1525     ::snprintf(diag_msg_buf, diag_msg_max_length-1,</span>
<span class="line-modified">1526                &quot; (Possible cause: architecture word width mismatch, can&#39;t load %d-bit .so on a %d-bit platform)&quot;,</span>
<span class="line-modified">1527                (int) lib_arch.elf_class * 32, arch_array[running_arch_index].elf_class * 32);</span>
<span class="line-modified">1528     return NULL;</span>






1529   }
1530 
1531   return NULL;
1532 }
1533 
1534 void* os::dll_lookup(void* handle, const char* name) {
1535   return dlsym(handle, name);
1536 }
1537 
1538 void* os::get_default_process_handle() {
1539   return (void*)::dlopen(NULL, RTLD_LAZY);
1540 }
1541 
1542 static inline time_t get_mtime(const char* filename) {
1543   struct stat st;
1544   int ret = os::stat(filename, &amp;st);
1545   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
1546   return st.st_mtime;
1547 }
1548 
</pre>
<hr />
<pre>
1567   ::close(fd);
1568 
1569   return true;
1570 }
1571 
1572 void os::print_os_info_brief(outputStream* st) {
1573   os::Solaris::print_distro_info(st);
1574 
1575   os::Posix::print_uname_info(st);
1576 
1577   os::Solaris::print_libversion_info(st);
1578 }
1579 
1580 void os::print_os_info(outputStream* st) {
1581   st-&gt;print(&quot;OS:&quot;);
1582 
1583   os::Solaris::print_distro_info(st);
1584 
1585   os::Posix::print_uname_info(st);
1586 
<span class="line-added">1587   os::Posix::print_uptime_info(st);</span>
<span class="line-added">1588 </span>
1589   os::Solaris::print_libversion_info(st);
1590 
1591   os::Posix::print_rlimit_info(st);
1592 
1593   os::Posix::print_load_average(st);
1594 }
1595 
1596 void os::Solaris::print_distro_info(outputStream* st) {
1597   if (!_print_ascii_file(&quot;/etc/release&quot;, st)) {
1598     st-&gt;print(&quot;Solaris&quot;);
1599   }
1600   st-&gt;cr();
1601 }
1602 
1603 void os::get_summary_os_info(char* buf, size_t buflen) {
1604   strncpy(buf, &quot;Solaris&quot;, buflen);  // default to plain solaris
1605   FILE* fp = fopen(&quot;/etc/release&quot;, &quot;r&quot;);
1606   if (fp != NULL) {
1607     char tmp[256];
1608     // Only get the first line and chop out everything but the os name.
</pre>
<hr />
<pre>
1895     }
1896 
1897     os::signal_notify(sig);
1898     // We do not need to reinstate the signal handler each time...
1899   }
1900 }
1901 
1902 void* os::user_handler() {
1903   return CAST_FROM_FN_PTR(void*, UserHandler);
1904 }
1905 
1906 extern &quot;C&quot; {
1907   typedef void (*sa_handler_t)(int);
1908   typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);
1909 }
1910 
1911 void* os::signal(int signal_number, void* handler) {
1912   struct sigaction sigAct, oldSigAct;
1913   sigfillset(&amp;(sigAct.sa_mask));
1914   sigAct.sa_flags = SA_RESTART &amp; ~SA_RESETHAND;
<span class="line-added">1915   sigAct.sa_flags |= SA_SIGINFO;</span>
1916   sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);
1917 
1918   if (sigaction(signal_number, &amp;sigAct, &amp;oldSigAct)) {
1919     // -1 means registration failed
1920     return (void *)-1;
1921   }
1922 
1923   return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);
1924 }
1925 
1926 void os::signal_raise(int signal_number) {
1927   raise(signal_number);
1928 }
1929 
1930 // The following code is moved from os.cpp for making this
1931 // code platform specific, which it is by its very nature.
1932 
1933 // a counter for each possible signal value
1934 static int Sigexit = 0;
1935 static jint *pending_signals = NULL;
</pre>
<hr />
<pre>
1969   // Initialize signal semaphore
1970   sig_sem = new Semaphore();
1971 }
1972 
1973 void os::signal_notify(int sig) {
1974   if (sig_sem != NULL) {
1975     Atomic::inc(&amp;pending_signals[sig]);
1976     sig_sem-&gt;signal();
1977   } else {
1978     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
1979     // initialization isn&#39;t called.
1980     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
1981   }
1982 }
1983 
1984 static int check_pending_signals() {
1985   int ret;
1986   while (true) {
1987     for (int i = 0; i &lt; Sigexit + 1; i++) {
1988       jint n = pending_signals[i];
<span class="line-modified">1989       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {</span>
1990         return i;
1991       }
1992     }
1993     JavaThread *thread = JavaThread::current();
1994     ThreadBlockInVM tbivm(thread);
1995 
1996     bool threadIsSuspended;
1997     do {
1998       thread-&gt;set_suspend_equivalent();
1999       sig_sem-&gt;wait();
2000 
2001       // were we externally suspended while we were waiting?
2002       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
2003       if (threadIsSuspended) {
2004         // The semaphore has been incremented, but while we were waiting
2005         // another thread suspended us. We don&#39;t want to continue running
2006         // while suspended because that would surprise the thread that
2007         // suspended us.
2008         sig_sem-&gt;signal();
2009 
</pre>
<hr />
<pre>
2057                                     int err) {
2058   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
2059           &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, addr, bytes, exec,
2060           os::strerror(err), err);
2061 }
2062 
2063 static void warn_fail_commit_memory(char* addr, size_t bytes,
2064                                     size_t alignment_hint, bool exec,
2065                                     int err) {
2066   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
2067           &quot;, &quot; SIZE_FORMAT &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, addr, bytes,
2068           alignment_hint, exec, os::strerror(err), err);
2069 }
2070 
2071 int os::Solaris::commit_memory_impl(char* addr, size_t bytes, bool exec) {
2072   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
2073   size_t size = bytes;
2074   char *res = Solaris::mmap_chunk(addr, size, MAP_PRIVATE|MAP_FIXED, prot);
2075   if (res != NULL) {
2076     if (UseNUMAInterleaving) {
<span class="line-modified">2077         numa_make_global(addr, bytes);</span>
2078     }
2079     return 0;
2080   }
2081 
2082   int err = errno;  // save errno from mmap() call in mmap_chunk()
2083 
2084   if (!recoverable_mmap_error(err)) {
2085     warn_fail_commit_memory(addr, bytes, exec, err);
2086     vm_exit_out_of_memory(bytes, OOM_MMAP_ERROR, &quot;committing reserved memory.&quot;);
2087   }
2088 
2089   return err;
2090 }
2091 
2092 bool os::pd_commit_memory(char* addr, size_t bytes, bool exec) {
2093   return Solaris::commit_memory_impl(addr, bytes, exec) == 0;
2094 }
2095 
2096 void os::pd_commit_memory_or_exit(char* addr, size_t bytes, bool exec,
2097                                   const char* mesg) {
</pre>
<hr />
<pre>
2252 }
2253 
2254 // Get the group id of the current LWP.
2255 int os::numa_get_group_id() {
2256   int lgrp_id = Solaris::lgrp_home(P_LWPID, P_MYID);
2257   if (lgrp_id == -1) {
2258     return 0;
2259   }
2260   const int size = os::numa_get_groups_num();
2261   int *ids = (int*)alloca(size * sizeof(int));
2262 
2263   // Get the ids of all lgroups with memory; r is the count.
2264   int r = Solaris::lgrp_resources(Solaris::lgrp_cookie(), lgrp_id,
2265                                   (Solaris::lgrp_id_t*)ids, size, LGRP_RSRC_MEM);
2266   if (r &lt;= 0) {
2267     return 0;
2268   }
2269   return ids[os::random() % r];
2270 }
2271 
<span class="line-added">2272 int os::numa_get_group_id_for_address(const void* address) {</span>
<span class="line-added">2273   return 0;</span>
<span class="line-added">2274 }</span>
<span class="line-added">2275 </span>
2276 // Request information about the page.
2277 bool os::get_page_info(char *start, page_info* info) {
2278   const uint_t info_types[] = { MEMINFO_VLGRP, MEMINFO_VPAGESIZE };
2279   uint64_t addr = (uintptr_t)start;
2280   uint64_t outdata[2];
2281   uint_t validity = 0;
2282 
2283   if (meminfo(&amp;addr, 1, info_types, 2, outdata, &amp;validity) &lt; 0) {
2284     return false;
2285   }
2286 
2287   info-&gt;size = 0;
2288   info-&gt;lgrp_id = -1;
2289 
2290   if ((validity &amp; 1) != 0) {
2291     if ((validity &amp; 2) != 0) {
2292       info-&gt;lgrp_id = outdata[0];
2293     }
2294     if ((validity &amp; 4) != 0) {
2295       info-&gt;size = outdata[1];
</pre>
<hr />
<pre>
2411   guarantee(requested_addr == NULL || requested_addr == addr,
2412             &quot;OS failed to return requested mmap address.&quot;);
2413   return addr;
2414 }
2415 
2416 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
2417   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
2418   char* result = pd_attempt_reserve_memory_at(bytes, requested_addr);
2419   if (result != NULL) {
2420     if (replace_existing_mapping_with_file_mapping(result, bytes, file_desc) == NULL) {
2421       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
2422     }
2423   }
2424   return result;
2425 }
2426 
2427 // Reserve memory at an arbitrary address, only if that area is
2428 // available (and not reserved for something else).
2429 
2430 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {











2431   // Assert only that the size is a multiple of the page size, since
2432   // that&#39;s all that mmap requires, and since that&#39;s all we really know
2433   // about at this low abstraction level.  If we need higher alignment,
2434   // we can either pass an alignment to this method or verify alignment
2435   // in one of the methods further up the call chain.  See bug 5044738.
2436   assert(bytes % os::vm_page_size() == 0, &quot;reserving unexpected size block&quot;);
2437 
2438   // Since snv_84, Solaris attempts to honor the address hint - see 5003415.

2439   char* addr = Solaris::anon_mmap(requested_addr, bytes, 0, false);
2440 
2441   volatile int err = errno;
2442   if (addr == requested_addr) {
2443     return addr;


















































































2444   }
2445 
<span class="line-modified">2446   if (addr != NULL) {</span>
<span class="line-modified">2447     pd_unmap_memory(addr, bytes);</span>




2448   }
2449 
<span class="line-modified">2450   return NULL;</span>
2451 }
2452 
2453 bool os::pd_release_memory(char* addr, size_t bytes) {
2454   size_t size = bytes;
2455   return munmap(addr, size) == 0;
2456 }
2457 
2458 static bool solaris_mprotect(char* addr, size_t bytes, int prot) {
2459   assert(addr == (char*)align_down((uintptr_t)addr, os::vm_page_size()),
2460          &quot;addr must be page aligned&quot;);
<span class="line-added">2461   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(addr), p2i(addr+bytes), prot);</span>
2462   int retVal = mprotect(addr, bytes, prot);
2463   return retVal == 0;
2464 }
2465 
2466 // Protect memory (Used to pass readonly pages through
2467 // JNI GetArray&lt;type&gt;Elements with empty arrays.)
2468 // Also, used for serialization page and for compressed oops null pointer
2469 // checking.
2470 bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
2471                         bool is_committed) {
2472   unsigned int p = 0;
2473   switch (prot) {
2474   case MEM_PROT_NONE: p = PROT_NONE; break;
2475   case MEM_PROT_READ: p = PROT_READ; break;
2476   case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;
2477   case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;
2478   default:
2479     ShouldNotReachHere();
2480   }
2481   // is_committed is unused.
</pre>
<hr />
<pre>
3673   }
3674 
3675   set_signal_handler(SIGSEGV, true, true);
3676   set_signal_handler(SIGPIPE, true, true);
3677   set_signal_handler(SIGXFSZ, true, true);
3678   set_signal_handler(SIGBUS, true, true);
3679   set_signal_handler(SIGILL, true, true);
3680   set_signal_handler(SIGFPE, true, true);
3681   set_signal_handler(ASYNC_SIGNAL, true, true);
3682 
3683   if (libjsig_is_loaded) {
3684     // Tell libjsig jvm finishes setting signal handlers
3685     (*end_signal_setting)();
3686   }
3687 
3688   // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
3689   // and if UserSignalHandler is installed all bets are off.
3690   // Log that signal checking is off only if -verbose:jni is specified.
3691   if (CheckJNICalls) {
3692     if (libjsig_is_loaded) {
<span class="line-modified">3693       log_debug(jni, resolve)(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>


3694       check_signals = false;
3695     }
3696     if (AllowUserSignalHandlers) {
<span class="line-modified">3697       log_debug(jni, resolve)(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>


3698       check_signals = false;
3699     }
3700   }
3701 }
3702 
3703 
3704 void report_error(const char* file_name, int line_no, const char* title,
3705                   const char* format, ...);
3706 
3707 // (Static) wrappers for the liblgrp API
3708 os::Solaris::lgrp_home_func_t os::Solaris::_lgrp_home;
3709 os::Solaris::lgrp_init_func_t os::Solaris::_lgrp_init;
3710 os::Solaris::lgrp_fini_func_t os::Solaris::_lgrp_fini;
3711 os::Solaris::lgrp_root_func_t os::Solaris::_lgrp_root;
3712 os::Solaris::lgrp_children_func_t os::Solaris::_lgrp_children;
3713 os::Solaris::lgrp_resources_func_t os::Solaris::_lgrp_resources;
3714 os::Solaris::lgrp_nlgrps_func_t os::Solaris::_lgrp_nlgrps;
3715 os::Solaris::lgrp_cookie_stale_func_t os::Solaris::_lgrp_cookie_stale;
3716 os::Solaris::lgrp_cookie_t os::Solaris::_lgrp_cookie = 0;
3717 
</pre>
<hr />
<pre>
4001 
4002     // note: perfMemory_exit_helper atexit function may be removed in
4003     // the future if the appropriate cleanup code can be added to the
4004     // VM_Exit VMOperation&#39;s doit method.
4005     if (atexit(perfMemory_exit_helper) != 0) {
4006       warning(&quot;os::init2 atexit(perfMemory_exit_helper) failed&quot;);
4007     }
4008   }
4009 
4010   // Init pset_loadavg function pointer
4011   init_pset_getloadavg_ptr();
4012 
4013   // Shared Posix initialization
4014   os::Posix::init_2();
4015 
4016   return JNI_OK;
4017 }
4018 
4019 // Mark the polling page as unreadable
4020 void os::make_polling_page_unreadable(void) {
<span class="line-added">4021   Events::log(NULL, &quot;Protecting polling page &quot; INTPTR_FORMAT &quot; with PROT_NONE&quot;, p2i(_polling_page));</span>
4022   if (mprotect((char *)_polling_page, page_size, PROT_NONE) != 0) {
4023     fatal(&quot;Could not disable polling page&quot;);
4024   }
4025 }
4026 
4027 // Mark the polling page as readable
4028 void os::make_polling_page_readable(void) {
<span class="line-added">4029   Events::log(NULL, &quot;Protecting polling page &quot; INTPTR_FORMAT &quot; with PROT_READ&quot;, p2i(_polling_page));</span>
4030   if (mprotect((char *)_polling_page, page_size, PROT_READ) != 0) {
4031     fatal(&quot;Could not enable polling page&quot;);
4032   }
4033 }
4034 
4035 // Is a (classpath) directory empty?
4036 bool os::dir_is_empty(const char* path) {
4037   DIR *dir = NULL;
4038   struct dirent *ptr;
4039 
4040   dir = opendir(path);
4041   if (dir == NULL) return true;
4042 
4043   // Scan the directory
4044   bool result = true;
4045   while (result &amp;&amp; (ptr = readdir(dir)) != NULL) {
4046     if (strcmp(ptr-&gt;d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(ptr-&gt;d_name, &quot;..&quot;) != 0) {
4047       result = false;
4048     }
4049   }
</pre>
<hr />
<pre>
4252 
4253 
4254 // Remap a block of memory.
4255 char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
4256                           char *addr, size_t bytes, bool read_only,
4257                           bool allow_exec) {
4258   // same as map_memory() on this OS
4259   return os::map_memory(fd, file_name, file_offset, addr, bytes, read_only,
4260                         allow_exec);
4261 }
4262 
4263 
4264 // Unmap a block of memory.
4265 bool os::pd_unmap_memory(char* addr, size_t bytes) {
4266   return munmap(addr, bytes) == 0;
4267 }
4268 
4269 void os::pause() {
4270   char filename[MAX_PATH];
4271   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">4272     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);</span>
4273   } else {
4274     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
4275   }
4276 
4277   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
4278   if (fd != -1) {
4279     struct stat buf;
4280     ::close(fd);
4281     while (::stat(filename, &amp;buf) == 0) {
4282       (void)::poll(NULL, 0, 100);
4283     }
4284   } else {
4285     jio_fprintf(stderr,
4286                 &quot;Could not open pause file &#39;%s&#39;, continuing immediately.\n&quot;, filename);
4287   }
4288 }
4289 
4290 #ifndef PRODUCT
4291 #ifdef INTERPOSE_ON_SYSTEM_SYNCH_FUNCTIONS
4292 // Turn this on if you need to trace synch operations.
</pre>
<hr />
<pre>
4695     abstime-&gt;tv_sec += 1;
4696     usec -= 1000000;
4697   }
4698   abstime-&gt;tv_nsec = usec * 1000;
4699   return abstime;
4700 }
4701 
4702 void os::PlatformEvent::park() {           // AKA: down()
4703   // Transitions for _Event:
4704   //   -1 =&gt; -1 : illegal
4705   //    1 =&gt;  0 : pass - return immediately
4706   //    0 =&gt; -1 : block; then set _Event to 0 before returning
4707 
4708   // Invariant: Only the thread associated with the Event/PlatformEvent
4709   // may call park().
4710   assert(_nParked == 0, &quot;invariant&quot;);
4711 
4712   int v;
4713   for (;;) {
4714     v = _Event;
<span class="line-modified">4715     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;</span>
4716   }
4717   guarantee(v &gt;= 0, &quot;invariant&quot;);
4718   if (v == 0) {
4719     // Do this the hard way by blocking ...
4720     // See http://monaco.sfbay/detail.jsf?cr=5094058.
4721     int status = os::Solaris::mutex_lock(_mutex);
4722     assert_status(status == 0, status, &quot;mutex_lock&quot;);
4723     guarantee(_nParked == 0, &quot;invariant&quot;);
4724     ++_nParked;
4725     while (_Event &lt; 0) {
4726       // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...
4727       // Treat this the same as if the wait was interrupted
4728       // With usr/lib/lwp going to kernel, always handle ETIME
4729       status = os::Solaris::cond_wait(_cond, _mutex);
4730       if (status == ETIME) status = EINTR;
4731       assert_status(status == 0 || status == EINTR, status, &quot;cond_wait&quot;);
4732     }
4733     --_nParked;
4734     _Event = 0;
4735     status = os::Solaris::mutex_unlock(_mutex);
4736     assert_status(status == 0, status, &quot;mutex_unlock&quot;);
4737     // Paranoia to ensure our locked and lock-free paths interact
4738     // correctly with each other.
4739     OrderAccess::fence();
4740   }
4741 }
4742 
4743 int os::PlatformEvent::park(jlong millis) {
4744   // Transitions for _Event:
4745   //   -1 =&gt; -1 : illegal
4746   //    1 =&gt;  0 : pass - return immediately
4747   //    0 =&gt; -1 : block; then set _Event to 0 before returning
4748 
4749   guarantee(_nParked == 0, &quot;invariant&quot;);
4750   int v;
4751   for (;;) {
4752     v = _Event;
<span class="line-modified">4753     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;</span>
4754   }
4755   guarantee(v &gt;= 0, &quot;invariant&quot;);
4756   if (v != 0) return OS_OK;
4757 
4758   int ret = OS_TIMEOUT;
4759   timestruc_t abst;
4760   compute_abstime(&amp;abst, millis);
4761 
4762   // See http://monaco.sfbay/detail.jsf?cr=5094058.
4763   int status = os::Solaris::mutex_lock(_mutex);
4764   assert_status(status == 0, status, &quot;mutex_lock&quot;);
4765   guarantee(_nParked == 0, &quot;invariant&quot;);
4766   ++_nParked;
4767   while (_Event &lt; 0) {
4768     int status = os::Solaris::cond_timedwait(_cond, _mutex, &amp;abst);
4769     assert_status(status == 0 || status == EINTR ||
4770                   status == ETIME || status == ETIMEDOUT,
4771                   status, &quot;cond_timedwait&quot;);
4772     if (!FilterSpuriousWakeups) break;                // previous semantics
4773     if (status == ETIME || status == ETIMEDOUT) break;
</pre>
<hr />
<pre>
4782   // correctly with each other.
4783   OrderAccess::fence();
4784   return ret;
4785 }
4786 
4787 void os::PlatformEvent::unpark() {
4788   // Transitions for _Event:
4789   //    0 =&gt; 1 : just return
4790   //    1 =&gt; 1 : just return
4791   //   -1 =&gt; either 0 or 1; must signal target thread
4792   //         That is, we can safely transition _Event from -1 to either
4793   //         0 or 1.
4794   // See also: &quot;Semaphores in Plan 9&quot; by Mullender &amp; Cox
4795   //
4796   // Note: Forcing a transition from &quot;-1&quot; to &quot;1&quot; on an unpark() means
4797   // that it will take two back-to-back park() calls for the owning
4798   // thread to block. This has the benefit of forcing a spurious return
4799   // from the first park() call after an unpark() call which will help
4800   // shake out uses of park() and unpark() without condition variables.
4801 
<span class="line-modified">4802   if (Atomic::xchg(&amp;_Event, 1) &gt;= 0) return;</span>
4803 
4804   // If the thread associated with the event was parked, wake it.
4805   // Wait for the thread assoc with the PlatformEvent to vacate.
4806   int status = os::Solaris::mutex_lock(_mutex);
4807   assert_status(status == 0, status, &quot;mutex_lock&quot;);
4808   int AnyWaiters = _nParked;
4809   status = os::Solaris::mutex_unlock(_mutex);
4810   assert_status(status == 0, status, &quot;mutex_unlock&quot;);
4811   guarantee(AnyWaiters == 0 || AnyWaiters == 1, &quot;invariant&quot;);
4812   if (AnyWaiters != 0) {
4813     // Note that we signal() *after* dropping the lock for &quot;immortal&quot; Events.
4814     // This is safe and avoids a common class of  futile wakeups.  In rare
4815     // circumstances this can cause a thread to return prematurely from
4816     // cond_{timed}wait() but the spurious wakeup is benign and the victim
4817     // will simply re-test the condition and re-park itself.
4818     // This provides particular benefit if the underlying platform does not
4819     // provide wait morphing.
4820     status = os::Solaris::cond_signal(_cond);
4821     assert_status(status == 0, status, &quot;cond_signal&quot;);
4822   }
</pre>
<hr />
<pre>
4881       if (absTime-&gt;tv_nsec &gt;= NANOSECS_PER_SEC) {
4882         absTime-&gt;tv_nsec -= NANOSECS_PER_SEC;
4883         ++absTime-&gt;tv_sec; // note: this must be &lt;= max_secs
4884       }
4885     }
4886   }
4887   assert(absTime-&gt;tv_sec &gt;= 0, &quot;tv_sec &lt; 0&quot;);
4888   assert(absTime-&gt;tv_sec &lt;= max_secs, &quot;tv_sec &gt; max_secs&quot;);
4889   assert(absTime-&gt;tv_nsec &gt;= 0, &quot;tv_nsec &lt; 0&quot;);
4890   assert(absTime-&gt;tv_nsec &lt; NANOSECS_PER_SEC, &quot;tv_nsec &gt;= nanos_per_sec&quot;);
4891 }
4892 
4893 void Parker::park(bool isAbsolute, jlong time) {
4894   // Ideally we&#39;d do something useful while spinning, such
4895   // as calling unpackTime().
4896 
4897   // Optional fast-path check:
4898   // Return immediately if a permit is available.
4899   // We depend on Atomic::xchg() having full barrier semantics
4900   // since we are doing a lock-free update to _counter.
<span class="line-modified">4901   if (Atomic::xchg(&amp;_counter, 0) &gt; 0) return;</span>
4902 
4903   // Optional fast-exit: Check interrupt before trying to wait
4904   Thread* thread = Thread::current();
4905   assert(thread-&gt;is_Java_thread(), &quot;Must be JavaThread&quot;);
4906   JavaThread *jt = (JavaThread *)thread;
<span class="line-modified">4907   if (jt-&gt;is_interrupted(false)) {</span>
4908     return;
4909   }
4910 
4911   // First, demultiplex/decode time arguments
4912   timespec absTime;
4913   if (time &lt; 0 || (isAbsolute &amp;&amp; time == 0)) { // don&#39;t wait at all
4914     return;
4915   }
4916   if (time &gt; 0) {
4917     // Warning: this code might be exposed to the old Solaris time
4918     // round-down bugs.  Grep &quot;roundingFix&quot; for details.
4919     unpackTime(&amp;absTime, isAbsolute, time);
4920   }
4921 
4922   // Enter safepoint region
4923   // Beware of deadlocks such as 6317397.
4924   // The per-thread Parker:: _mutex is a classic leaf-lock.
4925   // In particular a thread must never block on the Threads_lock while
4926   // holding the Parker:: mutex.  If safepoints are pending both the
4927   // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.
4928   ThreadBlockInVM tbivm(jt);
4929 
<span class="line-added">4930   // Can&#39;t access interrupt state now that we are _thread_blocked. If we&#39;ve</span>
<span class="line-added">4931   // been interrupted since we checked above then _counter will be &gt; 0.</span>
<span class="line-added">4932 </span>
4933   // Don&#39;t wait if cannot get lock since interference arises from
<span class="line-modified">4934   // unblocking.</span>
<span class="line-modified">4935   if (os::Solaris::mutex_trylock(_mutex) != 0) {</span>

4936     return;
4937   }
4938 
4939   int status;
4940 
4941   if (_counter &gt; 0)  { // no wait needed
4942     _counter = 0;
4943     status = os::Solaris::mutex_unlock(_mutex);
4944     assert(status == 0, &quot;invariant&quot;);
4945     // Paranoia to ensure our locked and lock-free paths interact
4946     // correctly with each other and Java-level accesses.
4947     OrderAccess::fence();
4948     return;
4949   }
4950 
4951   OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);
4952   jt-&gt;set_suspend_equivalent();
4953   // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
4954 
4955   // Do this the hard way by blocking ...
</pre>
<hr />
<pre>
4975   // If externally suspended while waiting, re-suspend
4976   if (jt-&gt;handle_special_suspend_equivalent_condition()) {
4977     jt-&gt;java_suspend_self();
4978   }
4979 }
4980 
4981 void Parker::unpark() {
4982   int status = os::Solaris::mutex_lock(_mutex);
4983   assert(status == 0, &quot;invariant&quot;);
4984   const int s = _counter;
4985   _counter = 1;
4986   status = os::Solaris::mutex_unlock(_mutex);
4987   assert(status == 0, &quot;invariant&quot;);
4988 
4989   if (s &lt; 1) {
4990     status = os::Solaris::cond_signal(_cond);
4991     assert(status == 0, &quot;invariant&quot;);
4992   }
4993 }
4994 
<span class="line-modified">4995 // Platform Mutex/Monitor implementations</span>
4996 
<span class="line-modified">4997 os::PlatformMutex::PlatformMutex() {</span>
<span class="line-modified">4998   int status = os::Solaris::mutex_init(&amp;_mutex);</span>


4999   assert_status(status == 0, status, &quot;mutex_init&quot;);
5000 }
5001 
<span class="line-modified">5002 os::PlatformMutex::~PlatformMutex() {</span>
<span class="line-modified">5003   int status = os::Solaris::mutex_destroy(&amp;_mutex);</span>


5004   assert_status(status == 0, status, &quot;mutex_destroy&quot;);
5005 }
5006 
<span class="line-modified">5007 void os::PlatformMutex::lock() {</span>
5008   int status = os::Solaris::mutex_lock(&amp;_mutex);
5009   assert_status(status == 0, status, &quot;mutex_lock&quot;);
5010 }
5011 
<span class="line-modified">5012 void os::PlatformMutex::unlock() {</span>
5013   int status = os::Solaris::mutex_unlock(&amp;_mutex);
5014   assert_status(status == 0, status, &quot;mutex_unlock&quot;);
5015 }
5016 
<span class="line-modified">5017 bool os::PlatformMutex::try_lock() {</span>
5018   int status = os::Solaris::mutex_trylock(&amp;_mutex);
5019   assert_status(status == 0 || status == EBUSY, status, &quot;mutex_trylock&quot;);
5020   return status == 0;
5021 }
5022 
<span class="line-added">5023 os::PlatformMonitor::PlatformMonitor() {</span>
<span class="line-added">5024   int status = os::Solaris::cond_init(&amp;_cond);</span>
<span class="line-added">5025   assert_status(status == 0, status, &quot;cond_init&quot;);</span>
<span class="line-added">5026 }</span>
<span class="line-added">5027 </span>
<span class="line-added">5028 os::PlatformMonitor::~PlatformMonitor() {</span>
<span class="line-added">5029   int status = os::Solaris::cond_destroy(&amp;_cond);</span>
<span class="line-added">5030   assert_status(status == 0, status, &quot;cond_destroy&quot;);</span>
<span class="line-added">5031 }</span>
<span class="line-added">5032 </span>
5033 // Must already be locked
5034 int os::PlatformMonitor::wait(jlong millis) {
5035   assert(millis &gt;= 0, &quot;negative timeout&quot;);
5036   if (millis &gt; 0) {
5037     timestruc_t abst;
5038     int ret = OS_TIMEOUT;
5039     compute_abstime(&amp;abst, millis);
5040     int status = os::Solaris::cond_timedwait(&amp;_cond, &amp;_mutex, &amp;abst);
5041     assert_status(status == 0 || status == EINTR ||
5042                   status == ETIME || status == ETIMEDOUT,
5043                   status, &quot;cond_timedwait&quot;);
5044     // EINTR acts as spurious wakeup - which is permitted anyway
5045     if (status == 0 || status == EINTR) {
5046       ret = OS_OK;
5047     }
5048     return ret;
5049   } else {
5050     int status = os::Solaris::cond_wait(&amp;_cond, &amp;_mutex);
5051     assert_status(status == 0 || status == EINTR,
5052                   status, &quot;cond_wait&quot;);
</pre>
<hr />
<pre>
5206   }
5207   return _result;
5208 }
5209 
5210 // Get the default path to the core file
5211 // Returns the length of the string
5212 int os::get_core_path(char* buffer, size_t bufferSize) {
5213   const char* p = get_current_directory(buffer, bufferSize);
5214 
5215   if (p == NULL) {
5216     assert(p != NULL, &quot;failed to get current directory&quot;);
5217     return 0;
5218   }
5219 
5220   jio_snprintf(buffer, bufferSize, &quot;%s/core or core.%d&quot;,
5221                                               p, current_process_id());
5222 
5223   return strlen(buffer);
5224 }
5225 
<span class="line-added">5226 bool os::supports_map_sync() {</span>
<span class="line-added">5227   return false;</span>
<span class="line-added">5228 }</span>
<span class="line-added">5229 </span>
5230 #ifndef PRODUCT
5231 void TestReserveMemorySpecial_test() {
5232   // No tests available for this platform
5233 }
5234 #endif
5235 
5236 bool os::start_debugging(char *buf, int buflen) {
5237   int len = (int)strlen(buf);
5238   char *p = &amp;buf[len];
5239 
5240   jio_snprintf(p, buflen-len,
5241                &quot;\n\n&quot;
5242                &quot;Do you want to debug the problem?\n\n&quot;
5243                &quot;To debug, run &#39;dbx - %d&#39;; then switch to thread &quot; INTX_FORMAT &quot;\n&quot;
5244                &quot;Enter &#39;yes&#39; to launch dbx automatically (PATH must include dbx)\n&quot;
5245                &quot;Otherwise, press RETURN to abort...&quot;,
5246                os::current_process_id(), os::current_thread_id());
5247 
5248   bool yes = os::message_box(&quot;Unexpected Error&quot;, buf);
5249 
</pre>
</td>
</tr>
</table>
<center><a href="os_perf_solaris.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_solaris.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
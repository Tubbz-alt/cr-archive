<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/os/solaris/os_perf_solaris.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;runtime/os.hpp&quot;
 29 #include &quot;runtime/os_perf.hpp&quot;
 30 #include &quot;os_solaris.inline.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 #include CPU_HEADER(vm_version_ext)
 34 
 35 #include &lt;sys/types.h&gt;
 36 #include &lt;procfs.h&gt;
 37 #include &lt;dirent.h&gt;
 38 #include &lt;errno.h&gt;
 39 #include &lt;stdio.h&gt;
 40 #include &lt;stdlib.h&gt;
 41 #include &lt;strings.h&gt;
 42 #include &lt;unistd.h&gt;
 43 #include &lt;fcntl.h&gt;
 44 #include &lt;kstat.h&gt;
 45 #include &lt;unistd.h&gt;
 46 #include &lt;string.h&gt;
 47 #include &lt;sys/sysinfo.h&gt;
 48 #include &lt;sys/lwp.h&gt;
 49 #include &lt;pthread.h&gt;
 50 #include &lt;time.h&gt;
 51 #include &lt;utmpx.h&gt;
 52 #include &lt;dlfcn.h&gt;
 53 #include &lt;sys/loadavg.h&gt;
 54 #include &lt;limits.h&gt;
 55 
 56 static const double NANOS_PER_SEC = 1000000000.0;
 57 
 58 struct CPUPerfTicks {
 59   kstat_t* kstat;
 60   uint64_t last_idle;
 61   uint64_t last_total;
 62   double   last_ratio;
 63 };
 64 
 65 struct CPUPerfCounters {
 66   int           nProcs;
 67   CPUPerfTicks* jvmTicks;
 68   kstat_ctl_t*  kstat_ctrl;
 69 };
 70 
 71 static int get_info(const char* path, void* info, size_t s, off_t o) {
 72   assert(path != NULL, &quot;path is NULL!&quot;);
 73   assert(info != NULL, &quot;info is NULL!&quot;);
 74 
 75   int fd = -1;
 76 
 77   if ((fd = os::open(path, O_RDONLY, 0)) &lt; 0) {
 78     return OS_ERR;
 79   }
 80   if (pread(fd, info, s, o) != s) {
 81     close(fd);
 82     return OS_ERR;
 83   }
 84   close(fd);
 85   return OS_OK;
 86 }
 87 
 88 static int get_psinfo2(void* info, size_t s, off_t o) {
 89   return get_info(&quot;/proc/self/psinfo&quot;, info, s, o);
 90 }
 91 
 92 static int get_psinfo(psinfo_t* info) {
 93   return get_psinfo2(info, sizeof(*info), 0);
 94 }
 95 
 96 static int get_psinfo(char* file, psinfo_t* info) {
 97   assert(file != NULL, &quot;file is NULL!&quot;);
 98   assert(info != NULL, &quot;info is NULL!&quot;);
 99   return get_info(file, info, sizeof(*info), 0);
100 }
101 
102 
103 static int get_usage(prusage_t* usage) {
104   assert(usage != NULL, &quot;usage is NULL!&quot;);
105   return get_info(&quot;/proc/self/usage&quot;, usage, sizeof(*usage), 0);
106 }
107 
108 static int read_cpustat(kstat_ctl_t* kstat_ctrl, CPUPerfTicks* load, cpu_stat_t* cpu_stat) {
109   assert(kstat_ctrl != NULL, &quot;kstat_ctrl pointer is NULL!&quot;);
110   assert(load != NULL, &quot;load pointer is NULL!&quot;);
111   assert(cpu_stat != NULL, &quot;cpu_stat pointer is NULL!&quot;);
112 
113   if (load-&gt;kstat == NULL) {
114     // no handle.
115     return OS_ERR;
116   }
117   if (kstat_read(kstat_ctrl, load-&gt;kstat, cpu_stat) == OS_ERR) {
118     // disable handle for this CPU
119      load-&gt;kstat = NULL;
120      return OS_ERR;
121   }
122   return OS_OK;
123 }
124 
125 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters) {
126   assert(counters != NULL, &quot;counters pointer is NULL!&quot;);
127 
128   cpu_stat_t  cpu_stat = {0};
129 
130   if (which_logical_cpu &gt;= counters-&gt;nProcs) {
131     return .0;
132   }
133 
134   CPUPerfTicks load = counters-&gt;jvmTicks[which_logical_cpu];
135   if (read_cpustat(counters-&gt;kstat_ctrl, &amp;load, &amp;cpu_stat) != OS_OK) {
136     return .0;
137   }
138 
139   uint_t* usage = cpu_stat.cpu_sysinfo.cpu;
140   if (usage == NULL) {
141     return .0;
142   }
143 
144   uint64_t c_idle  = usage[CPU_IDLE];
145   uint64_t c_total = 0;
146 
147   for (int i = 0; i &lt; CPU_STATES; i++) {
148     c_total += usage[i];
149   }
150 
151   // Calculate diff against previous snapshot
152   uint64_t d_idle  = c_idle - load.last_idle;
153   uint64_t d_total = c_total - load.last_total;
154 
155   /** update if weve moved */
156   if (d_total &gt; 0) {
157     // Save current values for next time around
158     load.last_idle  = c_idle;
159     load.last_total = c_total;
160     load.last_ratio = (double) (d_total - d_idle) / d_total;
161   }
162 
163   return load.last_ratio;
164 }
165 
166 static int get_boot_time(uint64_t* time) {
167   assert(time != NULL, &quot;time pointer is NULL!&quot;);
168   setutxent();
169   for(;;) {
170     struct utmpx* u;
171     if ((u = getutxent()) == NULL) {
172       break;
173     }
174     if (u-&gt;ut_type == BOOT_TIME) {
175       *time = u-&gt;ut_xtime;
176       endutxent();
177       return OS_OK;
178     }
179   }
180   endutxent();
181   return OS_ERR;
182 }
183 
184 static int get_noof_context_switches(CPUPerfCounters* counters, uint64_t* switches) {
185   assert(switches != NULL, &quot;switches pointer is NULL!&quot;);
186   assert(counters != NULL, &quot;counter pointer is NULL!&quot;);
187   *switches = 0;
188   uint64_t s = 0;
189 
190   // Collect data from all CPUs
191   for (int i = 0; i &lt; counters-&gt;nProcs; i++) {
192     cpu_stat_t cpu_stat = {0};
193     CPUPerfTicks load = counters-&gt;jvmTicks[i];
194 
195     if (read_cpustat(counters-&gt;kstat_ctrl, &amp;load, &amp;cpu_stat) == OS_OK) {
196       s += cpu_stat.cpu_sysinfo.pswitch;
197     } else {
198       //fail fast...
199       return OS_ERR;
200     }
201   }
202   *switches = s;
203   return OS_OK;
204 }
205 
206 static int perf_context_switch_rate(CPUPerfCounters* counters, double* rate) {
207   assert(counters != NULL, &quot;counters is NULL!&quot;);
208   assert(rate != NULL, &quot;rate pointer is NULL!&quot;);
209   static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;
210   static uint64_t lastTime = 0;
211   static uint64_t lastSwitches = 0;
212   static double   lastRate = 0.0;
213 
214   uint64_t lt = 0;
215   int res = 0;
216 
217   if (lastTime == 0) {
218     uint64_t tmp;
219     if (get_boot_time(&amp;tmp) &lt; 0) {
220       return OS_ERR;
221     }
222     lt = tmp * 1000;
223   }
224 
225   res = OS_OK;
226 
227   pthread_mutex_lock(&amp;contextSwitchLock);
228   {
229 
230     uint64_t sw = 0;
231     clock_t t, d;
232 
233     if (lastTime == 0) {
234       lastTime = lt;
235     }
236 
237     t = clock();
238     d = t - lastTime;
239 
240     if (d == 0) {
241       *rate = lastRate;
242     } else if (get_noof_context_switches(counters, &amp;sw)== OS_OK) {
243       *rate      = ((double)(sw - lastSwitches) / d) * 1000;
244       lastRate     = *rate;
245       lastSwitches = sw;
246       lastTime     = t;
247     } else {
248       *rate = 0.0;
249       res   = OS_ERR;
250     }
251     if (*rate &lt; 0.0) {
252       *rate = 0.0;
253       lastRate = 0.0;
254     }
255   }
256   pthread_mutex_unlock(&amp;contextSwitchLock);
257   return res;
258  }
259 
260 
261 
262 class CPUPerformanceInterface::CPUPerformance : public CHeapObj&lt;mtInternal&gt; {
263    friend class CPUPerformanceInterface;
264  private:
265   CPUPerfCounters _counters;
266   int cpu_load(int which_logical_cpu, double* cpu_load);
267   int context_switch_rate(double* rate);
268   int cpu_load_total_process(double* cpu_load);
269   int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);
270 
271   CPUPerformance();
272   ~CPUPerformance();
273   bool initialize();
274 };
275 
276 CPUPerformanceInterface::CPUPerformance::CPUPerformance() {
277   _counters.nProcs = 0;
278   _counters.jvmTicks = NULL;
279   _counters.kstat_ctrl = NULL;
280 }
281 
282 bool CPUPerformanceInterface::CPUPerformance::initialize() {
283   // initialize kstat control structure,
284   _counters.kstat_ctrl = kstat_open();
285   assert(_counters.kstat_ctrl != NULL, &quot;error initializing kstat control structure!&quot;);
286 
287   if (NULL == _counters.kstat_ctrl) {
288     return false;
289   }
290 
291   // Get number of CPU(s)
292   if ((_counters.nProcs = sysconf(_SC_NPROCESSORS_ONLN)) == OS_ERR) {
293     // ignore error?
294     _counters.nProcs = 1;
295   }
296 
297   assert(_counters.nProcs &gt; 0, &quot;no CPUs detected in sysconf call!&quot;);
298   if (_counters.nProcs == 0) {
299     return false;
300   }
301 
302   // Data structure(s) for saving CPU load (one per CPU)
303   size_t tick_array_size = _counters.nProcs * sizeof(CPUPerfTicks);
304   _counters.jvmTicks = (CPUPerfTicks*)NEW_C_HEAP_ARRAY(char, tick_array_size, mtInternal);
305   if (NULL == _counters.jvmTicks) {
306     return false;
307   }
308   memset(_counters.jvmTicks, 0, tick_array_size);
309 
310   // Get kstat cpu_stat counters for every CPU
311   // loop over kstat to find our cpu_stat(s)
312   int i = 0;
313   for (kstat_t* kstat = _counters.kstat_ctrl-&gt;kc_chain; kstat != NULL; kstat = kstat-&gt;ks_next) {
314     if (strncmp(kstat-&gt;ks_module, &quot;cpu_stat&quot;, 8) == 0) {
315       if (kstat_read(_counters.kstat_ctrl, kstat, NULL) == OS_ERR) {
316         continue;
317       }
318       if (i == _counters.nProcs) {
319         // more cpu_stats than reported CPUs
320         break;
321       }
322       _counters.jvmTicks[i++].kstat = kstat;
323     }
324   }
325   return true;
326 }
327 
328 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
329   if (_counters.jvmTicks != NULL) {
330     FREE_C_HEAP_ARRAY(char, _counters.jvmTicks);
331   }
332   if (_counters.kstat_ctrl != NULL) {
333     kstat_close(_counters.kstat_ctrl);
334   }
335 }
336 
337 int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {
338   assert(cpu_load != NULL, &quot;cpu_load pointer is NULL!&quot;);
339   double t = .0;
340   if (-1 == which_logical_cpu) {
341     for (int i = 0; i &lt; _counters.nProcs; i++) {
342       t += get_cpu_load(i, &amp;_counters);
343     }
344     // Cap total systemload to 1.0
345     t = MIN2&lt;double&gt;((t / _counters.nProcs), 1.0);
346   } else {
347     t = MIN2&lt;double&gt;(get_cpu_load(which_logical_cpu, &amp;_counters), 1.0);
348   }
349 
350   *cpu_load = t;
351   return OS_OK;
352 }
353 
354 int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* cpu_load) {
355   assert(cpu_load != NULL, &quot;cpu_load pointer is NULL!&quot;);
356 
357   psinfo_t info;
358 
359   // Get the percentage of &quot;recent cpu usage&quot; from all the lwp:s in the JVM:s
360   // process. This is returned as a value between 0.0 and 1.0 multiplied by 0x8000.
361   if (get_psinfo2(&amp;info.pr_pctcpu, sizeof(info.pr_pctcpu), offsetof(psinfo_t, pr_pctcpu)) != 0) {
362     *cpu_load = 0.0;
363     return OS_ERR;
364   }
365   *cpu_load = (double) info.pr_pctcpu / 0x8000;
366   return OS_OK;
367 }
368 
369 int CPUPerformanceInterface::CPUPerformance::cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad) {
370   assert(pjvmUserLoad != NULL, &quot;pjvmUserLoad not inited&quot;);
371   assert(pjvmKernelLoad != NULL, &quot;pjvmKernelLoad not inited&quot;);
372   assert(psystemTotalLoad != NULL, &quot;psystemTotalLoad not inited&quot;);
373 
374   static uint64_t lastTime;
375   static uint64_t lastUser, lastKernel;
376   static double lastUserRes, lastKernelRes;
377 
378   pstatus_t pss;
379   psinfo_t  info;
380 
381   *pjvmKernelLoad = *pjvmUserLoad = *psystemTotalLoad = 0;
382   if (get_info(&quot;/proc/self/status&quot;, &amp;pss.pr_utime, sizeof(timestruc_t)*2, offsetof(pstatus_t, pr_utime)) != 0) {
383     return OS_ERR;
384   }
385 
386   if (get_psinfo(&amp;info) != 0) {
387     return OS_ERR;
388   }
389 
390   // get the total time in user, kernel and total time
391   // check ratios for &#39;lately&#39; and multiply the &#39;recent load&#39;.
392   uint64_t time   = (info.pr_time.tv_sec * NANOS_PER_SEC) + info.pr_time.tv_nsec;
393   uint64_t user   = (pss.pr_utime.tv_sec * NANOS_PER_SEC) + pss.pr_utime.tv_nsec;
394   uint64_t kernel = (pss.pr_stime.tv_sec * NANOS_PER_SEC) + pss.pr_stime.tv_nsec;
395   uint64_t diff   = time - lastTime;
396   double load     = (double) info.pr_pctcpu / 0x8000;
397 
398   if (diff &gt; 0) {
399     lastUserRes = (load * (user - lastUser)) / diff;
400     lastKernelRes = (load * (kernel - lastKernel)) / diff;
401 
402     // BUG9182835 - patch for clamping these values to sane ones.
403     lastUserRes   = MIN2&lt;double&gt;(1, lastUserRes);
404     lastUserRes   = MAX2&lt;double&gt;(0, lastUserRes);
405     lastKernelRes = MIN2&lt;double&gt;(1, lastKernelRes);
406     lastKernelRes = MAX2&lt;double&gt;(0, lastKernelRes);
407   }
408 
409   double t = .0;
410   cpu_load(-1, &amp;t);
411   // clamp at user+system and 1.0
412   if (lastUserRes + lastKernelRes &gt; t) {
413     t = MIN2&lt;double&gt;(lastUserRes + lastKernelRes, 1.0);
414   }
415 
416   *pjvmUserLoad   = lastUserRes;
417   *pjvmKernelLoad = lastKernelRes;
418   *psystemTotalLoad = t;
419 
420   lastTime   = time;
421   lastUser   = user;
422   lastKernel = kernel;
423 
424   return OS_OK;
425 }
426 
427 int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
428   return perf_context_switch_rate(&amp;_counters, rate);
429 }
430 
431 CPUPerformanceInterface::CPUPerformanceInterface() {
432   _impl = NULL;
433 }
434 
435 bool CPUPerformanceInterface::initialize() {
436   _impl = new CPUPerformanceInterface::CPUPerformance();
437   return _impl != NULL &amp;&amp; _impl-&gt;initialize();
438 }
439 
440 CPUPerformanceInterface::~CPUPerformanceInterface(void) {
441   if (_impl != NULL) {
442     delete _impl;
443   }
444 }
445 
446 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
447   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
448 }
449 
450 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
451   return _impl-&gt;cpu_load_total_process(cpu_load);
452 }
453 
454 int CPUPerformanceInterface::cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad) const {
455   return _impl-&gt;cpu_loads_process(pjvmUserLoad, pjvmKernelLoad, psystemTotalLoad);
456 }
457 
458 int CPUPerformanceInterface::context_switch_rate(double* rate) const {
459   return _impl-&gt;context_switch_rate(rate);
460 }
461 
462 class SystemProcessInterface::SystemProcesses : public CHeapObj&lt;mtInternal&gt; {
463   friend class SystemProcessInterface;
464  private:
465   class ProcessIterator : public CHeapObj&lt;mtInternal&gt; {
466     friend class SystemProcessInterface::SystemProcesses;
467    private:
468     DIR*           _dir;
469     struct dirent* _entry;
470     bool           _valid;
471 
472     ProcessIterator();
473     ~ProcessIterator();
474     bool initialize();
475 
476     bool is_valid() const { return _valid; }
477     bool is_valid_entry(struct dirent* const entry) const;
478     bool is_dir(const char* const name) const;
479     char* allocate_string(const char* const str) const;
480     int current(SystemProcess* const process_info);
481     int next_process();
482   };
483 
484   ProcessIterator* _iterator;
485   SystemProcesses();
486   bool initialize();
487   ~SystemProcesses();
488 
489   //information about system processes
490   int system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const;
491 };
492 
493 bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_dir(const char* name) const {
494   struct stat64 mystat;
495   int ret_val = 0;
496 
497   ret_val = ::stat64(name, &amp;mystat);
498 
499   if (ret_val &lt; 0) {
500     return false;
501   }
502   ret_val = S_ISDIR(mystat.st_mode);
503   return ret_val &gt; 0;
504 }
505 
506 // if it has a numeric name, is a directory and has a &#39;psinfo&#39; file in it
507 bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_valid_entry(struct dirent* entry) const {
508   // ignore the &quot;.&quot; and &quot;..&quot; directories
509   if ((strcmp(entry-&gt;d_name, &quot;.&quot;) == 0) ||
510       (strcmp(entry-&gt;d_name, &quot;..&quot;) == 0)) {
511     return false;
512   }
513 
514   char buffer[PATH_MAX] = {0};
515   uint64_t size = 0;
516   bool result = false;
517   FILE *fp = NULL;
518 
519   if (atoi(entry-&gt;d_name) != 0) {
520     jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s&quot;, entry-&gt;d_name);
521 
522     if (is_dir(buffer)) {
523       memset(buffer, 0, PATH_MAX);
524       jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/psinfo&quot;, entry-&gt;d_name);
525       if ((fp = fopen(buffer, &quot;r&quot;)) != NULL) {
526         int nread = 0;
527         psinfo_t psinfo_data;
528         if ((nread = fread(&amp;psinfo_data, 1, sizeof(psinfo_t), fp)) != -1) {
529           // only considering system process owned by root
530           if (psinfo_data.pr_uid == 0) {
531             result = true;
532           }
533         }
534       }
535     }
536   }
537 
538   if (fp != NULL) {
539     fclose(fp);
540   }
541 
542   return result;
543 }
544 
545 char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
546   if (str != NULL) {
547     return os::strdup_check_oom(str, mtInternal);
548   }
549   return NULL;
550 }
551 
552 int SystemProcessInterface::SystemProcesses::ProcessIterator::current(SystemProcess* process_info) {
553   if (!is_valid()) {
554     return OS_ERR;
555   }
556 
557   char psinfo_path[PATH_MAX] = {0};
558   jio_snprintf(psinfo_path, PATH_MAX, &quot;/proc/%s/psinfo&quot;, _entry-&gt;d_name);
559 
560   FILE *fp = NULL;
561   if ((fp = fopen(psinfo_path, &quot;r&quot;)) == NULL) {
562     return OS_ERR;
563   }
564 
565   int nread = 0;
566   psinfo_t psinfo_data;
567   if ((nread = fread(&amp;psinfo_data, 1, sizeof(psinfo_t), fp)) == -1) {
568     fclose(fp);
569     return OS_ERR;
570   }
571 
572   char *exe_path = NULL;
573   if ((psinfo_data.pr_fname != NULL) &amp;&amp;
574       (psinfo_data.pr_psargs != NULL)) {
575     char *path_substring = strstr(psinfo_data.pr_psargs, psinfo_data.pr_fname);
576     if (path_substring != NULL) {
577       int len = path_substring - psinfo_data.pr_psargs;
578       exe_path = NEW_C_HEAP_ARRAY(char, len+1, mtInternal);
579       if (exe_path != NULL) {
580         jio_snprintf(exe_path, len, &quot;%s&quot;, psinfo_data.pr_psargs);
581         exe_path[len] = &#39;\0&#39;;
582       }
583     }
584   }
585 
586   process_info-&gt;set_pid(atoi(_entry-&gt;d_name));
587   process_info-&gt;set_name(allocate_string(psinfo_data.pr_fname));
588   process_info-&gt;set_path(allocate_string(exe_path));
589   process_info-&gt;set_command_line(allocate_string(psinfo_data.pr_psargs));
590 
591   if (exe_path != NULL) {
592     FREE_C_HEAP_ARRAY(char, exe_path);
593   }
594 
595   if (fp != NULL) {
596     fclose(fp);
597   }
598 
599   return OS_OK;
600 }
601 
602 int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {
603   if (!is_valid()) {
604     return OS_ERR;
605   }
606 
607   do {
608     _entry = os::readdir(_dir);
609     if (_entry == NULL) {
610       // Error or reached end.  Could use errno to distinguish those cases.
611       _valid = false;
612       return OS_ERR;
613     }
614   } while(!is_valid_entry(_entry));
615 
616   _valid = true;
617   return OS_OK;
618 }
619 
620 SystemProcessInterface::SystemProcesses::ProcessIterator::ProcessIterator() {
621   _dir = NULL;
622   _entry = NULL;
623   _valid = false;
624 }
625 
626 bool SystemProcessInterface::SystemProcesses::ProcessIterator::initialize() {
627   _dir = os::opendir(&quot;/proc&quot;);
628   _entry = NULL;
629   _valid = true;
630   next_process();
631 
632   return true;
633 }
634 
635 SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {
636   if (_dir != NULL) {
637     os::closedir(_dir);
638   }
639 }
640 
641 SystemProcessInterface::SystemProcesses::SystemProcesses() {
642   _iterator = NULL;
643 }
644 
645 bool SystemProcessInterface::SystemProcesses::initialize() {
646   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
647   return _iterator != NULL &amp;&amp; _iterator-&gt;initialize();
648 }
649 
650 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
651   if (_iterator != NULL) {
652     delete _iterator;
653   }
654 }
655 
656 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {
657   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
658   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointer is NULL!&quot;);
659   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
660 
661   // initialize pointers
662   *no_of_sys_processes = 0;
663   *system_processes = NULL;
664 
665   while (_iterator-&gt;is_valid()) {
666     SystemProcess* tmp = new SystemProcess();
667     _iterator-&gt;current(tmp);
668 
669     //if already existing head
670     if (*system_processes != NULL) {
671       //move &quot;first to second&quot;
672       tmp-&gt;set_next(*system_processes);
673     }
674     // new head
675     *system_processes = tmp;
676     // increment
677     (*no_of_sys_processes)++;
678     // step forward
679     _iterator-&gt;next_process();
680   }
681   return OS_OK;
682 }
683 
684 int SystemProcessInterface::system_processes(SystemProcess** system_procs, int* no_of_sys_processes) const {
685   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
686 }
687 
688 SystemProcessInterface::SystemProcessInterface() {
689   _impl = NULL;
690 }
691 
692 bool SystemProcessInterface::initialize() {
693   _impl = new SystemProcessInterface::SystemProcesses();
694   return _impl != NULL &amp;&amp; _impl-&gt;initialize();
695 
696 }
697 
698 SystemProcessInterface::~SystemProcessInterface() {
699   if (_impl != NULL) {
700     delete _impl;
701   }
702 }
703 
704 CPUInformationInterface::CPUInformationInterface() {
705   _cpu_info = NULL;
706 }
707 
708 bool CPUInformationInterface::initialize() {
709   _cpu_info = new CPUInformation();
710   if (_cpu_info == NULL) {
711     return false;
712   }
713   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
714   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
715   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
716   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
717   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
718   return true;
719 }
720 
721 CPUInformationInterface::~CPUInformationInterface() {
722   if (_cpu_info != NULL) {
723     if (_cpu_info-&gt;cpu_name() != NULL) {
724       const char* cpu_name = _cpu_info-&gt;cpu_name();
725       FREE_C_HEAP_ARRAY(char, cpu_name);
726       _cpu_info-&gt;set_cpu_name(NULL);
727     }
728     if (_cpu_info-&gt;cpu_description() != NULL) {
729       const char* cpu_desc = _cpu_info-&gt;cpu_description();
730       FREE_C_HEAP_ARRAY(char, cpu_desc);
731       _cpu_info-&gt;set_cpu_description(NULL);
732     }
733     delete _cpu_info;
734   }
735 }
736 
737 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
738   if (_cpu_info == NULL) {
739     return OS_ERR;
740   }
741 
742   cpu_info = *_cpu_info; // shallow copy assignment
743   return OS_OK;
744 }
745 
746 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
747   friend class NetworkPerformanceInterface;
748  private:
749   NetworkPerformance();
750   NetworkPerformance(const NetworkPerformance&amp; rhs); // no impl
751   NetworkPerformance&amp; operator=(const NetworkPerformance&amp; rhs); // no impl
752   bool initialize();
753   ~NetworkPerformance();
754   int network_utilization(NetworkInterface** network_interfaces) const;
755 };
756 
757 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {
758 
759 }
760 
761 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
762   return true;
763 }
764 
765 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
766 
767 }
768 
769 int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const
770 {
771   kstat_ctl_t* ctl = kstat_open();
772   if (ctl == NULL) {
773     return OS_ERR;
774   }
775 
776   NetworkInterface* ret = NULL;
777   for (kstat_t* k = ctl-&gt;kc_chain; k != NULL; k = k-&gt;ks_next) {
778     if (strcmp(k-&gt;ks_class, &quot;net&quot;) != 0) {
779       continue;
780     }
781     if (strcmp(k-&gt;ks_module, &quot;link&quot;) != 0) {
782       continue;
783     }
784 
785     if (kstat_read(ctl, k, NULL) == -1) {
786       return OS_ERR;
787     }
788 
789     uint64_t bytes_in = UINT64_MAX;
790     uint64_t bytes_out = UINT64_MAX;
791     for (int i = 0; i &lt; k-&gt;ks_ndata; ++i) {
792       kstat_named_t* data = &amp;reinterpret_cast&lt;kstat_named_t*&gt;(k-&gt;ks_data)[i];
793       if (strcmp(data-&gt;name, &quot;rbytes64&quot;) == 0) {
794         bytes_in = data-&gt;value.ui64;
795       }
796       else if (strcmp(data-&gt;name, &quot;obytes64&quot;) == 0) {
797         bytes_out = data-&gt;value.ui64;
798       }
799     }
800 
801     if ((bytes_in != UINT64_MAX) &amp;&amp; (bytes_out != UINT64_MAX)) {
802       NetworkInterface* cur = new NetworkInterface(k-&gt;ks_name, bytes_in, bytes_out, ret);
803       ret = cur;
804     }
805   }
806 
807   kstat_close(ctl);
808   *network_interfaces = ret;
809 
810   return OS_OK;
811 }
812 
813 NetworkPerformanceInterface::NetworkPerformanceInterface() {
814   _impl = NULL;
815 }
816 
817 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
818   if (_impl != NULL) {
819     delete _impl;
820   }
821 }
822 
823 bool NetworkPerformanceInterface::initialize() {
824   _impl = new NetworkPerformanceInterface::NetworkPerformance();
825   return _impl != NULL &amp;&amp; _impl-&gt;initialize();
826 }
827 
828 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
829   return _impl-&gt;network_utilization(network_interfaces);
830 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/solaris/os_solaris.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_solaris.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_solaris.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/solaris/os_solaris.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
254                             lgrp_rsrc_t type) {
255     return _lgrp_resources != NULL ? _lgrp_resources(cookie, lgrp, lgrp_array, lgrp_array_size, type) : -1;
256   }
257 
258   static int lgrp_nlgrps(lgrp_cookie_t cookie)       { return _lgrp_nlgrps != NULL ? _lgrp_nlgrps(cookie) : -1; }
259   static int lgrp_cookie_stale(lgrp_cookie_t cookie) {
260     return _lgrp_cookie_stale != NULL ? _lgrp_cookie_stale(cookie) : -1;
261   }
262   static lgrp_cookie_t lgrp_cookie()                 { return _lgrp_cookie; }
263 
264   static sigset_t* unblocked_signals();
265   static sigset_t* vm_signals();
266 
267   // %%% Following should be promoted to os.hpp:
268   // Trace number of created threads
269   static          jint  _os_thread_limit;
270   static volatile jint  _os_thread_count;
271 
272   static void correct_stack_boundaries_for_primordial_thread(Thread* thr);
273 
<span class="line-removed">274   // Stack overflow handling</span>
<span class="line-removed">275 </span>
<span class="line-removed">276   static int max_register_window_saves_before_flushing();</span>
<span class="line-removed">277 </span>
278   // Stack repair handling
279 
280   // none present
281 
282 };
283 
284 class PlatformEvent : public CHeapObj&lt;mtSynchronizer&gt; {
285  private:
286   double CachePad[4];   // increase odds that _mutex is sole occupant of cache line
287   volatile int _Event;
288   int _nParked;
289   int _pipev[2];
290   mutex_t _mutex[1];
291   cond_t  _cond[1];
292   double PostPad[2];
293 
294  protected:
295   // Defining a protected ctor effectively gives us an abstract base class.
296   // That is, a PlatformEvent can never be instantiated &quot;naked&quot; but only
297   // as a part of a ParkEvent (recall that ParkEvent extends PlatformEvent).
</pre>
<hr />
<pre>
318 };
319 
320 class PlatformParker : public CHeapObj&lt;mtSynchronizer&gt; {
321  protected:
322   mutex_t _mutex[1];
323   cond_t  _cond[1];
324 
325  public:       // TODO-FIXME: make dtor private
326   ~PlatformParker() { guarantee(0, &quot;invariant&quot;); }
327 
328  public:
329   PlatformParker() {
330     int status;
331     status = os::Solaris::cond_init(_cond);
332     assert_status(status == 0, status, &quot;cond_init&quot;);
333     status = os::Solaris::mutex_init(_mutex);
334     assert_status(status == 0, status, &quot;mutex_init&quot;);
335   }
336 };
337 
<span class="line-modified">338 // Platform specific implementation that underpins VM Monitor/Mutex class</span>
<span class="line-modified">339 class PlatformMonitor : public CHeapObj&lt;mtSynchronizer&gt; {</span>
<span class="line-modified">340  private:</span>



341   mutex_t _mutex; // Native mutex for locking
<span class="line-removed">342   cond_t  _cond;  // Native condition variable for blocking</span>
343 
344  public:
<span class="line-modified">345   PlatformMonitor();</span>
<span class="line-modified">346   ~PlatformMonitor();</span>
347   void lock();
348   void unlock();
349   bool try_lock();











350   int wait(jlong millis);
351   void notify();
352   void notify_all();
353 };
354 
355 #endif // OS_SOLARIS_OS_SOLARIS_HPP
</pre>
</td>
<td>
<hr />
<pre>
254                             lgrp_rsrc_t type) {
255     return _lgrp_resources != NULL ? _lgrp_resources(cookie, lgrp, lgrp_array, lgrp_array_size, type) : -1;
256   }
257 
258   static int lgrp_nlgrps(lgrp_cookie_t cookie)       { return _lgrp_nlgrps != NULL ? _lgrp_nlgrps(cookie) : -1; }
259   static int lgrp_cookie_stale(lgrp_cookie_t cookie) {
260     return _lgrp_cookie_stale != NULL ? _lgrp_cookie_stale(cookie) : -1;
261   }
262   static lgrp_cookie_t lgrp_cookie()                 { return _lgrp_cookie; }
263 
264   static sigset_t* unblocked_signals();
265   static sigset_t* vm_signals();
266 
267   // %%% Following should be promoted to os.hpp:
268   // Trace number of created threads
269   static          jint  _os_thread_limit;
270   static volatile jint  _os_thread_count;
271 
272   static void correct_stack_boundaries_for_primordial_thread(Thread* thr);
273 




274   // Stack repair handling
275 
276   // none present
277 
278 };
279 
280 class PlatformEvent : public CHeapObj&lt;mtSynchronizer&gt; {
281  private:
282   double CachePad[4];   // increase odds that _mutex is sole occupant of cache line
283   volatile int _Event;
284   int _nParked;
285   int _pipev[2];
286   mutex_t _mutex[1];
287   cond_t  _cond[1];
288   double PostPad[2];
289 
290  protected:
291   // Defining a protected ctor effectively gives us an abstract base class.
292   // That is, a PlatformEvent can never be instantiated &quot;naked&quot; but only
293   // as a part of a ParkEvent (recall that ParkEvent extends PlatformEvent).
</pre>
<hr />
<pre>
314 };
315 
316 class PlatformParker : public CHeapObj&lt;mtSynchronizer&gt; {
317  protected:
318   mutex_t _mutex[1];
319   cond_t  _cond[1];
320 
321  public:       // TODO-FIXME: make dtor private
322   ~PlatformParker() { guarantee(0, &quot;invariant&quot;); }
323 
324  public:
325   PlatformParker() {
326     int status;
327     status = os::Solaris::cond_init(_cond);
328     assert_status(status == 0, status, &quot;cond_init&quot;);
329     status = os::Solaris::mutex_init(_mutex);
330     assert_status(status == 0, status, &quot;mutex_init&quot;);
331   }
332 };
333 
<span class="line-modified">334 // Platform specific implementations that underpin VM Mutex/Monitor classes</span>
<span class="line-modified">335 </span>
<span class="line-modified">336 class PlatformMutex : public CHeapObj&lt;mtSynchronizer&gt; {</span>
<span class="line-added">337   NONCOPYABLE(PlatformMutex);</span>
<span class="line-added">338 </span>
<span class="line-added">339  protected:</span>
340   mutex_t _mutex; // Native mutex for locking

341 
342  public:
<span class="line-modified">343   PlatformMutex();</span>
<span class="line-modified">344   ~PlatformMutex();</span>
345   void lock();
346   void unlock();
347   bool try_lock();
<span class="line-added">348 };</span>
<span class="line-added">349 </span>
<span class="line-added">350 class PlatformMonitor : public PlatformMutex {</span>
<span class="line-added">351  private:</span>
<span class="line-added">352   cond_t  _cond;  // Native condition variable for blocking</span>
<span class="line-added">353 </span>
<span class="line-added">354   NONCOPYABLE(PlatformMonitor);</span>
<span class="line-added">355 </span>
<span class="line-added">356  public:</span>
<span class="line-added">357   PlatformMonitor();</span>
<span class="line-added">358   ~PlatformMonitor();</span>
359   int wait(jlong millis);
360   void notify();
361   void notify_all();
362 };
363 
364 #endif // OS_SOLARIS_OS_SOLARIS_HPP
</pre>
</td>
</tr>
</table>
<center><a href="os_solaris.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_solaris.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
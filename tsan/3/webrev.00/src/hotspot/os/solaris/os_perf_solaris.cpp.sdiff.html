<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/solaris/os_perf_solaris.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals_solaris.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_solaris.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/solaris/os_perf_solaris.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;runtime/os.hpp&quot;
 29 #include &quot;runtime/os_perf.hpp&quot;
 30 #include &quot;os_solaris.inline.hpp&quot;

 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 #include CPU_HEADER(vm_version_ext)
 34 
 35 #include &lt;sys/types.h&gt;
 36 #include &lt;procfs.h&gt;
 37 #include &lt;dirent.h&gt;
 38 #include &lt;errno.h&gt;
 39 #include &lt;stdio.h&gt;
 40 #include &lt;stdlib.h&gt;
 41 #include &lt;strings.h&gt;
 42 #include &lt;unistd.h&gt;
 43 #include &lt;fcntl.h&gt;
 44 #include &lt;kstat.h&gt;
 45 #include &lt;unistd.h&gt;
 46 #include &lt;string.h&gt;
 47 #include &lt;sys/sysinfo.h&gt;
 48 #include &lt;sys/lwp.h&gt;
 49 #include &lt;pthread.h&gt;
 50 #include &lt;time.h&gt;
</pre>
<hr />
<pre>
283   // initialize kstat control structure,
284   _counters.kstat_ctrl = kstat_open();
285   assert(_counters.kstat_ctrl != NULL, &quot;error initializing kstat control structure!&quot;);
286 
287   if (NULL == _counters.kstat_ctrl) {
288     return false;
289   }
290 
291   // Get number of CPU(s)
292   if ((_counters.nProcs = sysconf(_SC_NPROCESSORS_ONLN)) == OS_ERR) {
293     // ignore error?
294     _counters.nProcs = 1;
295   }
296 
297   assert(_counters.nProcs &gt; 0, &quot;no CPUs detected in sysconf call!&quot;);
298   if (_counters.nProcs == 0) {
299     return false;
300   }
301 
302   // Data structure(s) for saving CPU load (one per CPU)
<span class="line-modified">303   size_t tick_array_size = _counters.nProcs * sizeof(CPUPerfTicks);</span>
<span class="line-modified">304   _counters.jvmTicks = (CPUPerfTicks*)NEW_C_HEAP_ARRAY(char, tick_array_size, mtInternal);</span>
<span class="line-modified">305   if (NULL == _counters.jvmTicks) {</span>
<span class="line-removed">306     return false;</span>
<span class="line-removed">307   }</span>
<span class="line-removed">308   memset(_counters.jvmTicks, 0, tick_array_size);</span>
309 
310   // Get kstat cpu_stat counters for every CPU
311   // loop over kstat to find our cpu_stat(s)
312   int i = 0;
313   for (kstat_t* kstat = _counters.kstat_ctrl-&gt;kc_chain; kstat != NULL; kstat = kstat-&gt;ks_next) {
314     if (strncmp(kstat-&gt;ks_module, &quot;cpu_stat&quot;, 8) == 0) {
315       if (kstat_read(_counters.kstat_ctrl, kstat, NULL) == OS_ERR) {
316         continue;
317       }
318       if (i == _counters.nProcs) {
319         // more cpu_stats than reported CPUs
320         break;
321       }
322       _counters.jvmTicks[i++].kstat = kstat;
323     }
324   }
325   return true;
326 }
327 
328 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
<span class="line-modified">329   if (_counters.jvmTicks != NULL) {</span>
<span class="line-removed">330     FREE_C_HEAP_ARRAY(char, _counters.jvmTicks);</span>
<span class="line-removed">331   }</span>
332   if (_counters.kstat_ctrl != NULL) {
333     kstat_close(_counters.kstat_ctrl);
334   }
335 }
336 
337 int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {
338   assert(cpu_load != NULL, &quot;cpu_load pointer is NULL!&quot;);
339   double t = .0;
340   if (-1 == which_logical_cpu) {
341     for (int i = 0; i &lt; _counters.nProcs; i++) {
342       t += get_cpu_load(i, &amp;_counters);
343     }
344     // Cap total systemload to 1.0
345     t = MIN2&lt;double&gt;((t / _counters.nProcs), 1.0);
346   } else {
347     t = MIN2&lt;double&gt;(get_cpu_load(which_logical_cpu, &amp;_counters), 1.0);
348   }
349 
350   *cpu_load = t;
351   return OS_OK;
</pre>
<hr />
<pre>
417   *pjvmKernelLoad = lastKernelRes;
418   *psystemTotalLoad = t;
419 
420   lastTime   = time;
421   lastUser   = user;
422   lastKernel = kernel;
423 
424   return OS_OK;
425 }
426 
427 int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
428   return perf_context_switch_rate(&amp;_counters, rate);
429 }
430 
431 CPUPerformanceInterface::CPUPerformanceInterface() {
432   _impl = NULL;
433 }
434 
435 bool CPUPerformanceInterface::initialize() {
436   _impl = new CPUPerformanceInterface::CPUPerformance();
<span class="line-modified">437   return _impl != NULL &amp;&amp; _impl-&gt;initialize();</span>
438 }
439 
440 CPUPerformanceInterface::~CPUPerformanceInterface(void) {
441   if (_impl != NULL) {
442     delete _impl;
443   }
444 }
445 
446 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
447   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
448 }
449 
450 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
451   return _impl-&gt;cpu_load_total_process(cpu_load);
452 }
453 
454 int CPUPerformanceInterface::cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad) const {
455   return _impl-&gt;cpu_loads_process(pjvmUserLoad, pjvmKernelLoad, psystemTotalLoad);
456 }
457 
</pre>
<hr />
<pre>
559 
560   FILE *fp = NULL;
561   if ((fp = fopen(psinfo_path, &quot;r&quot;)) == NULL) {
562     return OS_ERR;
563   }
564 
565   int nread = 0;
566   psinfo_t psinfo_data;
567   if ((nread = fread(&amp;psinfo_data, 1, sizeof(psinfo_t), fp)) == -1) {
568     fclose(fp);
569     return OS_ERR;
570   }
571 
572   char *exe_path = NULL;
573   if ((psinfo_data.pr_fname != NULL) &amp;&amp;
574       (psinfo_data.pr_psargs != NULL)) {
575     char *path_substring = strstr(psinfo_data.pr_psargs, psinfo_data.pr_fname);
576     if (path_substring != NULL) {
577       int len = path_substring - psinfo_data.pr_psargs;
578       exe_path = NEW_C_HEAP_ARRAY(char, len+1, mtInternal);
<span class="line-modified">579       if (exe_path != NULL) {</span>
<span class="line-modified">580         jio_snprintf(exe_path, len, &quot;%s&quot;, psinfo_data.pr_psargs);</span>
<span class="line-removed">581         exe_path[len] = &#39;\0&#39;;</span>
<span class="line-removed">582       }</span>
583     }
584   }
585 
586   process_info-&gt;set_pid(atoi(_entry-&gt;d_name));
587   process_info-&gt;set_name(allocate_string(psinfo_data.pr_fname));
588   process_info-&gt;set_path(allocate_string(exe_path));
589   process_info-&gt;set_command_line(allocate_string(psinfo_data.pr_psargs));
590 
591   if (exe_path != NULL) {
592     FREE_C_HEAP_ARRAY(char, exe_path);
593   }
594 
595   if (fp != NULL) {
596     fclose(fp);
597   }
598 
599   return OS_OK;
600 }
601 
602 int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {
</pre>
<hr />
<pre>
627   _dir = os::opendir(&quot;/proc&quot;);
628   _entry = NULL;
629   _valid = true;
630   next_process();
631 
632   return true;
633 }
634 
635 SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {
636   if (_dir != NULL) {
637     os::closedir(_dir);
638   }
639 }
640 
641 SystemProcessInterface::SystemProcesses::SystemProcesses() {
642   _iterator = NULL;
643 }
644 
645 bool SystemProcessInterface::SystemProcesses::initialize() {
646   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<span class="line-modified">647   return _iterator != NULL &amp;&amp; _iterator-&gt;initialize();</span>
648 }
649 
650 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
651   if (_iterator != NULL) {
652     delete _iterator;
653   }
654 }
655 
656 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {
657   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
658   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointer is NULL!&quot;);
659   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
660 
661   // initialize pointers
662   *no_of_sys_processes = 0;
663   *system_processes = NULL;
664 
665   while (_iterator-&gt;is_valid()) {
666     SystemProcess* tmp = new SystemProcess();
667     _iterator-&gt;current(tmp);
</pre>
<hr />
<pre>
674     // new head
675     *system_processes = tmp;
676     // increment
677     (*no_of_sys_processes)++;
678     // step forward
679     _iterator-&gt;next_process();
680   }
681   return OS_OK;
682 }
683 
684 int SystemProcessInterface::system_processes(SystemProcess** system_procs, int* no_of_sys_processes) const {
685   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
686 }
687 
688 SystemProcessInterface::SystemProcessInterface() {
689   _impl = NULL;
690 }
691 
692 bool SystemProcessInterface::initialize() {
693   _impl = new SystemProcessInterface::SystemProcesses();
<span class="line-modified">694   return _impl != NULL &amp;&amp; _impl-&gt;initialize();</span>
695 
696 }
697 
698 SystemProcessInterface::~SystemProcessInterface() {
699   if (_impl != NULL) {
700     delete _impl;
701   }
702 }
703 
704 CPUInformationInterface::CPUInformationInterface() {
705   _cpu_info = NULL;
706 }
707 
708 bool CPUInformationInterface::initialize() {
709   _cpu_info = new CPUInformation();
<span class="line-removed">710   if (_cpu_info == NULL) {</span>
<span class="line-removed">711     return false;</span>
<span class="line-removed">712   }</span>
713   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
714   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
715   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
716   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
717   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
718   return true;
719 }
720 
721 CPUInformationInterface::~CPUInformationInterface() {
722   if (_cpu_info != NULL) {
723     if (_cpu_info-&gt;cpu_name() != NULL) {
724       const char* cpu_name = _cpu_info-&gt;cpu_name();
725       FREE_C_HEAP_ARRAY(char, cpu_name);
726       _cpu_info-&gt;set_cpu_name(NULL);
727     }
728     if (_cpu_info-&gt;cpu_description() != NULL) {
729       const char* cpu_desc = _cpu_info-&gt;cpu_description();
730       FREE_C_HEAP_ARRAY(char, cpu_desc);
731       _cpu_info-&gt;set_cpu_description(NULL);
732     }
733     delete _cpu_info;
734   }
735 }
736 
737 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
738   if (_cpu_info == NULL) {
739     return OS_ERR;
740   }
741 
742   cpu_info = *_cpu_info; // shallow copy assignment
743   return OS_OK;
744 }
745 
746 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
747   friend class NetworkPerformanceInterface;
748  private:
749   NetworkPerformance();
<span class="line-modified">750   NetworkPerformance(const NetworkPerformance&amp; rhs); // no impl</span>
<span class="line-removed">751   NetworkPerformance&amp; operator=(const NetworkPerformance&amp; rhs); // no impl</span>
752   bool initialize();
753   ~NetworkPerformance();
754   int network_utilization(NetworkInterface** network_interfaces) const;
755 };
756 
757 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {
758 
759 }
760 
761 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
762   return true;
763 }
764 
765 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
766 
767 }
768 
769 int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const
770 {
771   kstat_ctl_t* ctl = kstat_open();
</pre>
<hr />
<pre>
805   }
806 
807   kstat_close(ctl);
808   *network_interfaces = ret;
809 
810   return OS_OK;
811 }
812 
813 NetworkPerformanceInterface::NetworkPerformanceInterface() {
814   _impl = NULL;
815 }
816 
817 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
818   if (_impl != NULL) {
819     delete _impl;
820   }
821 }
822 
823 bool NetworkPerformanceInterface::initialize() {
824   _impl = new NetworkPerformanceInterface::NetworkPerformance();
<span class="line-modified">825   return _impl != NULL &amp;&amp; _impl-&gt;initialize();</span>
826 }
827 
828 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
829   return _impl-&gt;network_utilization(network_interfaces);
830 }
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;runtime/os.hpp&quot;
 29 #include &quot;runtime/os_perf.hpp&quot;
 30 #include &quot;os_solaris.inline.hpp&quot;
<span class="line-added"> 31 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
 32 #include &quot;utilities/macros.hpp&quot;
 33 
 34 #include CPU_HEADER(vm_version_ext)
 35 
 36 #include &lt;sys/types.h&gt;
 37 #include &lt;procfs.h&gt;
 38 #include &lt;dirent.h&gt;
 39 #include &lt;errno.h&gt;
 40 #include &lt;stdio.h&gt;
 41 #include &lt;stdlib.h&gt;
 42 #include &lt;strings.h&gt;
 43 #include &lt;unistd.h&gt;
 44 #include &lt;fcntl.h&gt;
 45 #include &lt;kstat.h&gt;
 46 #include &lt;unistd.h&gt;
 47 #include &lt;string.h&gt;
 48 #include &lt;sys/sysinfo.h&gt;
 49 #include &lt;sys/lwp.h&gt;
 50 #include &lt;pthread.h&gt;
 51 #include &lt;time.h&gt;
</pre>
<hr />
<pre>
284   // initialize kstat control structure,
285   _counters.kstat_ctrl = kstat_open();
286   assert(_counters.kstat_ctrl != NULL, &quot;error initializing kstat control structure!&quot;);
287 
288   if (NULL == _counters.kstat_ctrl) {
289     return false;
290   }
291 
292   // Get number of CPU(s)
293   if ((_counters.nProcs = sysconf(_SC_NPROCESSORS_ONLN)) == OS_ERR) {
294     // ignore error?
295     _counters.nProcs = 1;
296   }
297 
298   assert(_counters.nProcs &gt; 0, &quot;no CPUs detected in sysconf call!&quot;);
299   if (_counters.nProcs == 0) {
300     return false;
301   }
302 
303   // Data structure(s) for saving CPU load (one per CPU)
<span class="line-modified">304   size_t array_entry_count = _counters.nProcs;</span>
<span class="line-modified">305   _counters.jvmTicks = NEW_C_HEAP_ARRAY(CPUPerfTicks, array_entry_count, mtInternal);</span>
<span class="line-modified">306   memset(_counters.jvmTicks, 0, array_entry_count * sizeof(*_counters.jvmTicks));</span>



307 
308   // Get kstat cpu_stat counters for every CPU
309   // loop over kstat to find our cpu_stat(s)
310   int i = 0;
311   for (kstat_t* kstat = _counters.kstat_ctrl-&gt;kc_chain; kstat != NULL; kstat = kstat-&gt;ks_next) {
312     if (strncmp(kstat-&gt;ks_module, &quot;cpu_stat&quot;, 8) == 0) {
313       if (kstat_read(_counters.kstat_ctrl, kstat, NULL) == OS_ERR) {
314         continue;
315       }
316       if (i == _counters.nProcs) {
317         // more cpu_stats than reported CPUs
318         break;
319       }
320       _counters.jvmTicks[i++].kstat = kstat;
321     }
322   }
323   return true;
324 }
325 
326 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
<span class="line-modified">327   FREE_C_HEAP_ARRAY(char, _counters.jvmTicks);</span>


328   if (_counters.kstat_ctrl != NULL) {
329     kstat_close(_counters.kstat_ctrl);
330   }
331 }
332 
333 int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {
334   assert(cpu_load != NULL, &quot;cpu_load pointer is NULL!&quot;);
335   double t = .0;
336   if (-1 == which_logical_cpu) {
337     for (int i = 0; i &lt; _counters.nProcs; i++) {
338       t += get_cpu_load(i, &amp;_counters);
339     }
340     // Cap total systemload to 1.0
341     t = MIN2&lt;double&gt;((t / _counters.nProcs), 1.0);
342   } else {
343     t = MIN2&lt;double&gt;(get_cpu_load(which_logical_cpu, &amp;_counters), 1.0);
344   }
345 
346   *cpu_load = t;
347   return OS_OK;
</pre>
<hr />
<pre>
413   *pjvmKernelLoad = lastKernelRes;
414   *psystemTotalLoad = t;
415 
416   lastTime   = time;
417   lastUser   = user;
418   lastKernel = kernel;
419 
420   return OS_OK;
421 }
422 
423 int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
424   return perf_context_switch_rate(&amp;_counters, rate);
425 }
426 
427 CPUPerformanceInterface::CPUPerformanceInterface() {
428   _impl = NULL;
429 }
430 
431 bool CPUPerformanceInterface::initialize() {
432   _impl = new CPUPerformanceInterface::CPUPerformance();
<span class="line-modified">433   return _impl-&gt;initialize();</span>
434 }
435 
436 CPUPerformanceInterface::~CPUPerformanceInterface(void) {
437   if (_impl != NULL) {
438     delete _impl;
439   }
440 }
441 
442 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
443   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
444 }
445 
446 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
447   return _impl-&gt;cpu_load_total_process(cpu_load);
448 }
449 
450 int CPUPerformanceInterface::cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad) const {
451   return _impl-&gt;cpu_loads_process(pjvmUserLoad, pjvmKernelLoad, psystemTotalLoad);
452 }
453 
</pre>
<hr />
<pre>
555 
556   FILE *fp = NULL;
557   if ((fp = fopen(psinfo_path, &quot;r&quot;)) == NULL) {
558     return OS_ERR;
559   }
560 
561   int nread = 0;
562   psinfo_t psinfo_data;
563   if ((nread = fread(&amp;psinfo_data, 1, sizeof(psinfo_t), fp)) == -1) {
564     fclose(fp);
565     return OS_ERR;
566   }
567 
568   char *exe_path = NULL;
569   if ((psinfo_data.pr_fname != NULL) &amp;&amp;
570       (psinfo_data.pr_psargs != NULL)) {
571     char *path_substring = strstr(psinfo_data.pr_psargs, psinfo_data.pr_fname);
572     if (path_substring != NULL) {
573       int len = path_substring - psinfo_data.pr_psargs;
574       exe_path = NEW_C_HEAP_ARRAY(char, len+1, mtInternal);
<span class="line-modified">575       jio_snprintf(exe_path, len, &quot;%s&quot;, psinfo_data.pr_psargs);</span>
<span class="line-modified">576       exe_path[len] = &#39;\0&#39;;</span>


577     }
578   }
579 
580   process_info-&gt;set_pid(atoi(_entry-&gt;d_name));
581   process_info-&gt;set_name(allocate_string(psinfo_data.pr_fname));
582   process_info-&gt;set_path(allocate_string(exe_path));
583   process_info-&gt;set_command_line(allocate_string(psinfo_data.pr_psargs));
584 
585   if (exe_path != NULL) {
586     FREE_C_HEAP_ARRAY(char, exe_path);
587   }
588 
589   if (fp != NULL) {
590     fclose(fp);
591   }
592 
593   return OS_OK;
594 }
595 
596 int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {
</pre>
<hr />
<pre>
621   _dir = os::opendir(&quot;/proc&quot;);
622   _entry = NULL;
623   _valid = true;
624   next_process();
625 
626   return true;
627 }
628 
629 SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {
630   if (_dir != NULL) {
631     os::closedir(_dir);
632   }
633 }
634 
635 SystemProcessInterface::SystemProcesses::SystemProcesses() {
636   _iterator = NULL;
637 }
638 
639 bool SystemProcessInterface::SystemProcesses::initialize() {
640   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<span class="line-modified">641   return _iterator-&gt;initialize();</span>
642 }
643 
644 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
645   if (_iterator != NULL) {
646     delete _iterator;
647   }
648 }
649 
650 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {
651   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
652   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointer is NULL!&quot;);
653   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
654 
655   // initialize pointers
656   *no_of_sys_processes = 0;
657   *system_processes = NULL;
658 
659   while (_iterator-&gt;is_valid()) {
660     SystemProcess* tmp = new SystemProcess();
661     _iterator-&gt;current(tmp);
</pre>
<hr />
<pre>
668     // new head
669     *system_processes = tmp;
670     // increment
671     (*no_of_sys_processes)++;
672     // step forward
673     _iterator-&gt;next_process();
674   }
675   return OS_OK;
676 }
677 
678 int SystemProcessInterface::system_processes(SystemProcess** system_procs, int* no_of_sys_processes) const {
679   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
680 }
681 
682 SystemProcessInterface::SystemProcessInterface() {
683   _impl = NULL;
684 }
685 
686 bool SystemProcessInterface::initialize() {
687   _impl = new SystemProcessInterface::SystemProcesses();
<span class="line-modified">688   return _impl-&gt;initialize();</span>
689 
690 }
691 
692 SystemProcessInterface::~SystemProcessInterface() {
693   if (_impl != NULL) {
694     delete _impl;
695   }
696 }
697 
698 CPUInformationInterface::CPUInformationInterface() {
699   _cpu_info = NULL;
700 }
701 
702 bool CPUInformationInterface::initialize() {
703   _cpu_info = new CPUInformation();



704   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
705   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
706   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
707   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
708   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
709   return true;
710 }
711 
712 CPUInformationInterface::~CPUInformationInterface() {
713   if (_cpu_info != NULL) {
714     if (_cpu_info-&gt;cpu_name() != NULL) {
715       const char* cpu_name = _cpu_info-&gt;cpu_name();
716       FREE_C_HEAP_ARRAY(char, cpu_name);
717       _cpu_info-&gt;set_cpu_name(NULL);
718     }
719     if (_cpu_info-&gt;cpu_description() != NULL) {
720       const char* cpu_desc = _cpu_info-&gt;cpu_description();
721       FREE_C_HEAP_ARRAY(char, cpu_desc);
722       _cpu_info-&gt;set_cpu_description(NULL);
723     }
724     delete _cpu_info;
725   }
726 }
727 
728 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
729   if (_cpu_info == NULL) {
730     return OS_ERR;
731   }
732 
733   cpu_info = *_cpu_info; // shallow copy assignment
734   return OS_OK;
735 }
736 
737 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
738   friend class NetworkPerformanceInterface;
739  private:
740   NetworkPerformance();
<span class="line-modified">741   NONCOPYABLE(NetworkPerformance);</span>

742   bool initialize();
743   ~NetworkPerformance();
744   int network_utilization(NetworkInterface** network_interfaces) const;
745 };
746 
747 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {
748 
749 }
750 
751 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
752   return true;
753 }
754 
755 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
756 
757 }
758 
759 int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const
760 {
761   kstat_ctl_t* ctl = kstat_open();
</pre>
<hr />
<pre>
795   }
796 
797   kstat_close(ctl);
798   *network_interfaces = ret;
799 
800   return OS_OK;
801 }
802 
803 NetworkPerformanceInterface::NetworkPerformanceInterface() {
804   _impl = NULL;
805 }
806 
807 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
808   if (_impl != NULL) {
809     delete _impl;
810   }
811 }
812 
813 bool NetworkPerformanceInterface::initialize() {
814   _impl = new NetworkPerformanceInterface::NetworkPerformance();
<span class="line-modified">815   return _impl-&gt;initialize();</span>
816 }
817 
818 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
819   return _impl-&gt;network_utilization(network_interfaces);
820 }
</pre>
</td>
</tr>
</table>
<center><a href="globals_solaris.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_solaris.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
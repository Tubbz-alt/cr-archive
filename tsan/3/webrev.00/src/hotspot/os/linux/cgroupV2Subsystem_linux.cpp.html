<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/os/linux/cgroupV2Subsystem_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Red Hat Inc.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;cgroupV2Subsystem_linux.hpp&quot;
 26 
 27 /* cpu_shares
 28  *
 29  * Return the amount of cpu shares available to the process
 30  *
 31  * return:
 32  *    Share number (typically a number relative to 1024)
 33  *                 (2048 typically expresses 2 CPUs worth of processing)
 34  *    -1 for no share setup
 35  *    OSCONTAINER_ERROR for not supported
 36  */
 37 int CgroupV2Subsystem::cpu_shares() {
 38   GET_CONTAINER_INFO(int, _unified, &quot;/cpu.weight&quot;,
 39                      &quot;Raw value for CPU shares is: %d&quot;, &quot;%d&quot;, shares);
 40   // Convert default value of 100 to no shares setup
 41   if (shares == 100) {
 42     log_debug(os, container)(&quot;CPU Shares is: %d&quot;, -1);
 43     return -1;
 44   }
 45 
 46   // CPU shares (OCI) value needs to get translated into
 47   // a proper Cgroups v2 value. See:
 48   // https://github.com/containers/crun/blob/master/crun.1.md#cpu-controller
 49   //
 50   // Use the inverse of (x == OCI value, y == cgroupsv2 value):
 51   // ((262142 * y - 1)/9999) + 2 = x
 52   //
 53   int x = 262142 * shares - 1;
 54   double frac = x/9999.0;
 55   x = ((int)frac) + 2;
 56   log_trace(os, container)(&quot;Scaled CPU shares value is: %d&quot;, x);
 57   // Since the scaled value is not precise, return the closest
 58   // multiple of PER_CPU_SHARES for a more conservative mapping
 59   if ( x &lt;= PER_CPU_SHARES ) {
 60      // will always map to 1 CPU
 61      log_debug(os, container)(&quot;CPU Shares is: %d&quot;, x);
 62      return x;
 63   }
 64   int f = x/PER_CPU_SHARES;
 65   int lower_multiple = f * PER_CPU_SHARES;
 66   int upper_multiple = (f + 1) * PER_CPU_SHARES;
 67   int distance_lower = MAX2(lower_multiple, x) - MIN2(lower_multiple, x);
 68   int distance_upper = MAX2(upper_multiple, x) - MIN2(upper_multiple, x);
 69   x = distance_lower &lt;= distance_upper ? lower_multiple : upper_multiple;
 70   log_trace(os, container)(&quot;Closest multiple of %d of the CPU Shares value is: %d&quot;, PER_CPU_SHARES, x);
 71   log_debug(os, container)(&quot;CPU Shares is: %d&quot;, x);
 72   return x;
 73 }
 74 
 75 /* cpu_quota
 76  *
 77  * Return the number of milliseconds per period
 78  * process is guaranteed to run.
 79  *
 80  * return:
 81  *    quota time in milliseconds
 82  *    -1 for no quota
 83  *    OSCONTAINER_ERROR for not supported
 84  */
 85 int CgroupV2Subsystem::cpu_quota() {
 86   char * cpu_quota_str = cpu_quota_val();
 87   int limit = (int)limit_from_str(cpu_quota_str);
 88   log_trace(os, container)(&quot;CPU Quota is: %d&quot;, limit);
 89   return limit;
 90 }
 91 
 92 char * CgroupV2Subsystem::cpu_cpuset_cpus() {
 93   GET_CONTAINER_INFO_CPTR(cptr, _unified, &quot;/cpuset.cpus&quot;,
 94                      &quot;cpuset.cpus is: %s&quot;, &quot;%1023s&quot;, cpus, 1024);
 95   if (cpus == NULL) {
 96     return NULL;
 97   }
 98   return os::strdup(cpus);
 99 }
100 
101 char* CgroupV2Subsystem::cpu_quota_val() {
102   GET_CONTAINER_INFO_CPTR(cptr, _unified, &quot;/cpu.max&quot;,
103                      &quot;Raw value for CPU quota is: %s&quot;, &quot;%s %*d&quot;, quota, 1024);
104   if (quota == NULL) {
105     return NULL;
106   }
107   return os::strdup(quota);
108 }
109 
110 char * CgroupV2Subsystem::cpu_cpuset_memory_nodes() {
111   GET_CONTAINER_INFO_CPTR(cptr, _unified, &quot;/cpuset.mems&quot;,
112                      &quot;cpuset.mems is: %s&quot;, &quot;%1023s&quot;, mems, 1024);
113   if (mems == NULL) {
114     return NULL;
115   }
116   return os::strdup(mems);
117 }
118 
119 int CgroupV2Subsystem::cpu_period() {
120   GET_CONTAINER_INFO(int, _unified, &quot;/cpu.max&quot;,
121                      &quot;CPU Period is: %d&quot;, &quot;%*s %d&quot;, period);
122   return period;
123 }
124 
125 /* memory_usage_in_bytes
126  *
127  * Return the amount of used memory used by this cgroup and decendents
128  *
129  * return:
130  *    memory usage in bytes or
131  *    -1 for unlimited
132  *    OSCONTAINER_ERROR for not supported
133  */
134 jlong CgroupV2Subsystem::memory_usage_in_bytes() {
135   GET_CONTAINER_INFO(jlong, _unified, &quot;/memory.current&quot;,
136                      &quot;Memory Usage is: &quot; JLONG_FORMAT, JLONG_FORMAT, memusage);
137   return memusage;
138 }
139 
140 jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {
141   char* mem_soft_limit_str = mem_soft_limit_val();
142   return limit_from_str(mem_soft_limit_str);
143 }
144 
145 jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {
146   // Log this string at trace level so as to make tests happy.
147   log_trace(os, container)(&quot;Maximum Memory Usage is not supported.&quot;);
148   return OSCONTAINER_ERROR; // not supported
149 }
150 
151 char* CgroupV2Subsystem::mem_soft_limit_val() {
152   GET_CONTAINER_INFO_CPTR(cptr, _unified, &quot;/memory.high&quot;,
153                          &quot;Memory Soft Limit is: %s&quot;, &quot;%s&quot;, mem_soft_limit_str, 1024);
154   if (mem_soft_limit_str == NULL) {
155     return NULL;
156   }
157   return os::strdup(mem_soft_limit_str);
158 }
159 
160 jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {
161   char* mem_swp_limit_str = mem_swp_limit_val();
162   return limit_from_str(mem_swp_limit_str);
163 }
164 
165 char* CgroupV2Subsystem::mem_swp_limit_val() {
166   GET_CONTAINER_INFO_CPTR(cptr, _unified, &quot;/memory.swap.max&quot;,
167                          &quot;Memory and Swap Limit is: %s&quot;, &quot;%s&quot;, mem_swp_limit_str, 1024);
168   if (mem_swp_limit_str == NULL) {
169     return NULL;
170   }
171   return os::strdup(mem_swp_limit_str);
172 }
173 
174 /* memory_limit_in_bytes
175  *
176  * Return the limit of available memory for this process.
177  *
178  * return:
179  *    memory limit in bytes or
180  *    -1 for unlimited, OSCONTAINER_ERROR for an error
181  */
182 jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {
183   char * mem_limit_str = mem_limit_val();
184   jlong limit = limit_from_str(mem_limit_str);
185   if (log_is_enabled(Trace, os, container)) {
186     if (limit == -1) {
187       log_trace(os, container)(&quot;Memory Limit is: Unlimited&quot;);
188     } else {
189       log_trace(os, container)(&quot;Memory Limit is: &quot; JLONG_FORMAT, limit);
190     }
191   }
192   return limit;
193 }
194 
195 jlong CgroupV2Subsystem::limit_from_str(char* limit_str) {
196   if (limit_str == NULL) {
197     return OSCONTAINER_ERROR;
198   }
199   // Unlimited memory in Cgroups V2 is the literal string &#39;max&#39;
200   if (strcmp(&quot;max&quot;, limit_str) == 0) {
201     os::free(limit_str);
202     return (jlong)-1;
203   }
204   julong limit;
205   if (sscanf(limit_str, JULONG_FORMAT, &amp;limit) != 1) {
206     os::free(limit_str);
207     return OSCONTAINER_ERROR;
208   }
209   os::free(limit_str);
210   return (jlong)limit;
211 }
212 
213 char* CgroupV2Subsystem::mem_limit_val() {
214   GET_CONTAINER_INFO_CPTR(cptr, _unified, &quot;/memory.max&quot;,
215                          &quot;Raw value for memory limit is: %s&quot;, &quot;%s&quot;, mem_limit_str, 1024);
216   if (mem_limit_str == NULL) {
217     return NULL;
218   }
219   return os::strdup(mem_limit_str);
220 }
221 
222 char* CgroupV2Controller::construct_path(char* mount_path, char *cgroup_path) {
223   char buf[MAXPATHLEN+1];
224   int buflen;
225   strncpy(buf, mount_path, MAXPATHLEN);
226   buf[MAXPATHLEN] = &#39;\0&#39;;
227   buflen = strlen(buf);
228   if ((buflen + strlen(cgroup_path)) &gt; MAXPATHLEN) {
229     return NULL;
230   }
231   strncat(buf, cgroup_path, MAXPATHLEN-buflen);
232   buf[MAXPATHLEN] = &#39;\0&#39;;
233   return os::strdup(buf);
234 }
235 
    </pre>
  </body>
</html>
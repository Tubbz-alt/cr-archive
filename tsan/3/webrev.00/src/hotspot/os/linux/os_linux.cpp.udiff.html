<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="osContainer_linux.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -51,20 +51,20 @@</span>
  #include &quot;runtime/init.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/objectMonitor.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/osThread.hpp&quot;
  #include &quot;runtime/perfMemory.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/statSampler.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/threadCritical.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
  #include &quot;runtime/timer.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/vm_version.hpp&quot;</span>
  #include &quot;semaphore_posix.hpp&quot;
  #include &quot;services/attachListener.hpp&quot;
  #include &quot;services/memTracker.hpp&quot;
  #include &quot;services/runtimeService.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -72,19 +72,21 @@</span>
  #include &quot;utilities/defaultStream.hpp&quot;
  #include &quot;utilities/events.hpp&quot;
  #include &quot;utilities/elfFile.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;utilities/vmError.hpp&quot;
  
  // put OS-includes here
  # include &lt;sys/types.h&gt;
  # include &lt;sys/mman.h&gt;
  # include &lt;sys/stat.h&gt;
  # include &lt;sys/select.h&gt;
  # include &lt;pthread.h&gt;
  # include &lt;signal.h&gt;
<span class="udiff-line-added">+ # include &lt;endian.h&gt;</span>
  # include &lt;errno.h&gt;
  # include &lt;dlfcn.h&gt;
  # include &lt;stdio.h&gt;
  # include &lt;unistd.h&gt;
  # include &lt;sys/resource.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -144,15 +146,13 @@</span>
  address   os::Linux::_initial_thread_stack_bottom = NULL;
  uintptr_t os::Linux::_initial_thread_stack_size   = 0;
  
  int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
  int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
<span class="udiff-line-removed">- Mutex* os::Linux::_createThread_lock = NULL;</span>
  pthread_t os::Linux::_main_thread;
  int os::Linux::_page_size = -1;
  bool os::Linux::_supports_fast_thread_cpu_time = false;
<span class="udiff-line-removed">- uint32_t os::Linux::_os_version = 0;</span>
  const char * os::Linux::_glibc_version = NULL;
  const char * os::Linux::_libpthread_version = NULL;
  
  static jlong initial_time_count=0;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -225,10 +225,86 @@</span>
    phys_mem = Linux::physical_memory();
    log_trace(os)(&quot;total system memory: &quot; JLONG_FORMAT, phys_mem);
    return phys_mem;
  }
  
<span class="udiff-line-added">+ static uint64_t initial_total_ticks = 0;</span>
<span class="udiff-line-added">+ static uint64_t initial_steal_ticks = 0;</span>
<span class="udiff-line-added">+ static bool     has_initial_tick_info = false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void next_line(FILE *f) {</span>
<span class="udiff-line-added">+   int c;</span>
<span class="udiff-line-added">+   do {</span>
<span class="udiff-line-added">+     c = fgetc(f);</span>
<span class="udiff-line-added">+   } while (c != &#39;\n&#39; &amp;&amp; c != EOF);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool os::Linux::get_tick_information(CPUPerfTicks* pticks, int which_logical_cpu) {</span>
<span class="udiff-line-added">+   FILE*         fh;</span>
<span class="udiff-line-added">+   uint64_t      userTicks, niceTicks, systemTicks, idleTicks;</span>
<span class="udiff-line-added">+   // since at least kernel 2.6 : iowait: time waiting for I/O to complete</span>
<span class="udiff-line-added">+   // irq: time  servicing interrupts; softirq: time servicing softirqs</span>
<span class="udiff-line-added">+   uint64_t      iowTicks = 0, irqTicks = 0, sirqTicks= 0;</span>
<span class="udiff-line-added">+   // steal (since kernel 2.6.11): time spent in other OS when running in a virtualized environment</span>
<span class="udiff-line-added">+   uint64_t      stealTicks = 0;</span>
<span class="udiff-line-added">+   // guest (since kernel 2.6.24): time spent running a virtual CPU for guest OS under the</span>
<span class="udiff-line-added">+   // control of the Linux kernel</span>
<span class="udiff-line-added">+   uint64_t      guestNiceTicks = 0;</span>
<span class="udiff-line-added">+   int           logical_cpu = -1;</span>
<span class="udiff-line-added">+   const int     required_tickinfo_count = (which_logical_cpu == -1) ? 4 : 5;</span>
<span class="udiff-line-added">+   int           n;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   memset(pticks, 0, sizeof(CPUPerfTicks));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if ((fh = fopen(&quot;/proc/stat&quot;, &quot;r&quot;)) == NULL) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (which_logical_cpu == -1) {</span>
<span class="udiff-line-added">+     n = fscanf(fh, &quot;cpu &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="udiff-line-added">+             UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="udiff-line-added">+             UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;,</span>
<span class="udiff-line-added">+             &amp;userTicks, &amp;niceTicks, &amp;systemTicks, &amp;idleTicks,</span>
<span class="udiff-line-added">+             &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks,</span>
<span class="udiff-line-added">+             &amp;stealTicks, &amp;guestNiceTicks);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // Move to next line</span>
<span class="udiff-line-added">+     next_line(fh);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // find the line for requested cpu faster to just iterate linefeeds?</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; which_logical_cpu; i++) {</span>
<span class="udiff-line-added">+       next_line(fh);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     n = fscanf(fh, &quot;cpu%u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="udiff-line-added">+                UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="udiff-line-added">+                UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;,</span>
<span class="udiff-line-added">+                &amp;logical_cpu, &amp;userTicks, &amp;niceTicks,</span>
<span class="udiff-line-added">+                &amp;systemTicks, &amp;idleTicks, &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks,</span>
<span class="udiff-line-added">+                &amp;stealTicks, &amp;guestNiceTicks);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   fclose(fh);</span>
<span class="udiff-line-added">+   if (n &lt; required_tickinfo_count || logical_cpu != which_logical_cpu) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   pticks-&gt;used       = userTicks + niceTicks;</span>
<span class="udiff-line-added">+   pticks-&gt;usedKernel = systemTicks + irqTicks + sirqTicks;</span>
<span class="udiff-line-added">+   pticks-&gt;total      = userTicks + niceTicks + systemTicks + idleTicks +</span>
<span class="udiff-line-added">+                        iowTicks + irqTicks + sirqTicks + stealTicks + guestNiceTicks;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (n &gt; required_tickinfo_count + 3) {</span>
<span class="udiff-line-added">+     pticks-&gt;steal = stealTicks;</span>
<span class="udiff-line-added">+     pticks-&gt;has_steal_ticks = true;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     pticks-&gt;steal = 0;</span>
<span class="udiff-line-added">+     pticks-&gt;has_steal_ticks = false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Return true if user is running as root.
  
  bool os::have_special_privileges() {
    static bool init = false;
    static bool privileges = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -348,11 +424,11 @@</span>
    // Note that the space for the colon and the trailing null are provided
    // by the nulls included by the sizeof operator.
    const size_t bufsize =
      MAX2((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
           (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="udiff-line-modified-removed">-   char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
<span class="udiff-line-modified-added">+   char *buf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
  
    // sysclasspath, java_home, dll_dir
    {
      char *pslash;
      os::jvm_path(buf, bufsize);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -397,14 +473,14 @@</span>
      // addressed).
      const char *v = ::getenv(&quot;LD_LIBRARY_PATH&quot;);
      const char *v_colon = &quot;:&quot;;
      if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
      // That&#39;s +1 for the colon and +1 for the trailing &#39;\0&#39;.
<span class="udiff-line-modified-removed">-     char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,</span>
<span class="udiff-line-modified-removed">-                                                      strlen(v) + 1 +</span>
<span class="udiff-line-modified-removed">-                                                      sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;) + sizeof(DEFAULT_LIBPATH) + 1,</span>
<span class="udiff-line-modified-removed">-                                                      mtInternal);</span>
<span class="udiff-line-modified-added">+     char *ld_library_path = NEW_C_HEAP_ARRAY(char,</span>
<span class="udiff-line-modified-added">+                                              strlen(v) + 1 +</span>
<span class="udiff-line-modified-added">+                                              sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;) + sizeof(DEFAULT_LIBPATH) + 1,</span>
<span class="udiff-line-modified-added">+                                              mtInternal);</span>
      sprintf(ld_library_path, &quot;%s%s&quot; SYS_EXT_DIR &quot;/lib:&quot; DEFAULT_LIBPATH, v, v_colon);
      Arguments::set_library_path(ld_library_path);
      FREE_C_HEAP_ARRAY(char, ld_library_path);
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -642,11 +718,11 @@</span>
  bool os::Linux::manually_expand_stack(JavaThread * t, address addr) {
    assert(t!=NULL, &quot;just checking&quot;);
    assert(t-&gt;osthread()-&gt;expanding_stack(), &quot;expand should be set&quot;);
    assert(t-&gt;stack_base() != NULL, &quot;stack_base was not initialized&quot;);
  
<span class="udiff-line-modified-removed">-   if (addr &lt;  t-&gt;stack_base() &amp;&amp; addr &gt;= t-&gt;stack_reserved_zone_base()) {</span>
<span class="udiff-line-modified-added">+   if (t-&gt;is_in_usable_stack(addr)) {</span>
      sigset_t mask_all, old_sigset;
      sigfillset(&amp;mask_all);
      pthread_sigmask(SIG_SETMASK, &amp;mask_all, &amp;old_sigset);
      _expand_stack_to(addr);
      pthread_sigmask(SIG_SETMASK, &amp;old_sigset, NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -694,19 +770,19 @@</span>
    // initialize floating point control register
    os::Linux::init_thread_fpu_state();
  
    // handshaking with parent thread
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker ml(sync, Mutex::_no_safepoint_check_flag);</span>
  
      // notify parent thread
      osthread-&gt;set_state(INITIALIZED);
      sync-&gt;notify_all();
  
      // wait until os::start_thread()
      while (osthread-&gt;get_state() == INITIALIZED) {
<span class="udiff-line-modified-removed">-       sync-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+       sync-&gt;wait_without_safepoint_check();</span>
      }
    }
  
    assert(osthread-&gt;pthread_id() != 0, &quot;pthread_id was not set as expected&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -721,10 +797,77 @@</span>
      os::current_thread_id(), (uintx) pthread_self());
  
    return 0;
  }
  
<span class="udiff-line-added">+ // On Linux, glibc places static TLS blocks (for __thread variables) on</span>
<span class="udiff-line-added">+ // the thread stack. This decreases the stack size actually available</span>
<span class="udiff-line-added">+ // to threads.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // For large static TLS sizes, this may cause threads to malfunction due</span>
<span class="udiff-line-added">+ // to insufficient stack space. This is a well-known issue in glibc:</span>
<span class="udiff-line-added">+ // http://sourceware.org/bugzilla/show_bug.cgi?id=11787.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // As a workaround, we call a private but assumed-stable glibc function,</span>
<span class="udiff-line-added">+ // __pthread_get_minstack() to obtain the minstack size and derive the</span>
<span class="udiff-line-added">+ // static TLS size from it. We then increase the user requested stack</span>
<span class="udiff-line-added">+ // size by this TLS size.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Due to compatibility concerns, this size adjustment is opt-in and</span>
<span class="udiff-line-added">+ // controlled via AdjustStackSizeForTLS.</span>
<span class="udiff-line-added">+ typedef size_t (*GetMinStack)(const pthread_attr_t *attr);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ GetMinStack _get_minstack_func = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void get_minstack_init() {</span>
<span class="udiff-line-added">+   _get_minstack_func =</span>
<span class="udiff-line-added">+         (GetMinStack)dlsym(RTLD_DEFAULT, &quot;__pthread_get_minstack&quot;);</span>
<span class="udiff-line-added">+   log_info(os, thread)(&quot;Lookup of __pthread_get_minstack %s&quot;,</span>
<span class="udiff-line-added">+                        _get_minstack_func == NULL ? &quot;failed&quot; : &quot;succeeded&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Returns the size of the static TLS area glibc puts on thread stacks.</span>
<span class="udiff-line-added">+ // The value is cached on first use, which occurs when the first thread</span>
<span class="udiff-line-added">+ // is created during VM initialization.</span>
<span class="udiff-line-added">+ static size_t get_static_tls_area_size(const pthread_attr_t *attr) {</span>
<span class="udiff-line-added">+   size_t tls_size = 0;</span>
<span class="udiff-line-added">+   if (_get_minstack_func != NULL) {</span>
<span class="udiff-line-added">+     // Obtain the pthread minstack size by calling __pthread_get_minstack.</span>
<span class="udiff-line-added">+     size_t minstack_size = _get_minstack_func(attr);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Remove non-TLS area size included in minstack size returned</span>
<span class="udiff-line-added">+     // by __pthread_get_minstack() to get the static TLS size.</span>
<span class="udiff-line-added">+     // In glibc before 2.27, minstack size includes guard_size.</span>
<span class="udiff-line-added">+     // In glibc 2.27 and later, guard_size is automatically added</span>
<span class="udiff-line-added">+     // to the stack size by pthread_create and is no longer included</span>
<span class="udiff-line-added">+     // in minstack size. In both cases, the guard_size is taken into</span>
<span class="udiff-line-added">+     // account, so there is no need to adjust the result for that.</span>
<span class="udiff-line-added">+     //</span>
<span class="udiff-line-added">+     // Although __pthread_get_minstack() is a private glibc function,</span>
<span class="udiff-line-added">+     // it is expected to have a stable behavior across future glibc</span>
<span class="udiff-line-added">+     // versions while glibc still allocates the static TLS blocks off</span>
<span class="udiff-line-added">+     // the stack. Following is glibc 2.28 __pthread_get_minstack():</span>
<span class="udiff-line-added">+     //</span>
<span class="udiff-line-added">+     // size_t</span>
<span class="udiff-line-added">+     // __pthread_get_minstack (const pthread_attr_t *attr)</span>
<span class="udiff-line-added">+     // {</span>
<span class="udiff-line-added">+     //   return GLRO(dl_pagesize) + __static_tls_size + PTHREAD_STACK_MIN;</span>
<span class="udiff-line-added">+     // }</span>
<span class="udiff-line-added">+     //</span>
<span class="udiff-line-added">+     //</span>
<span class="udiff-line-added">+     // The following &#39;minstack_size &gt; os::vm_page_size() + PTHREAD_STACK_MIN&#39;</span>
<span class="udiff-line-added">+     // if check is done for precaution.</span>
<span class="udiff-line-added">+     if (minstack_size &gt; (size_t)os::vm_page_size() + PTHREAD_STACK_MIN) {</span>
<span class="udiff-line-added">+       tls_size = minstack_size - os::vm_page_size() - PTHREAD_STACK_MIN;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   log_info(os, thread)(&quot;Stack size adjustment for TLS is &quot; SIZE_FORMAT,</span>
<span class="udiff-line-added">+                        tls_size);</span>
<span class="udiff-line-added">+   return tls_size;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  bool os::create_thread(Thread* thread, ThreadType thr_type,
                         size_t req_stack_size) {
    assert(thread-&gt;osthread() == NULL, &quot;caller responsible&quot;);
  
    // Allocate the OSThread object
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -746,29 +889,39 @@</span>
    pthread_attr_init(&amp;attr);
    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
  
    // Calculate stack size if it&#39;s not specified by caller.
    size_t stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);
<span class="udiff-line-modified-removed">-   // In the Linux NPTL pthread implementation the guard size mechanism</span>
<span class="udiff-line-modified-added">+   // In glibc versions prior to 2.7 the guard size mechanism</span>
    // is not implemented properly. The posix standard requires adding
    // the size of the guard pages to the stack size, instead Linux
    // takes the space out of &#39;stacksize&#39;. Thus we adapt the requested
    // stack_size by the size of the guard pages to mimick proper
    // behaviour. However, be careful not to end up with a size
    // of zero due to overflow. Don&#39;t add the guard page in that case.
    size_t guard_size = os::Linux::default_guard_size(thr_type);
<span class="udiff-line-modified-removed">-   if (stack_size &lt;= SIZE_MAX - guard_size) {</span>
<span class="udiff-line-modified-removed">-     stack_size += guard_size;</span>
<span class="udiff-line-modified-added">+   // Configure glibc guard page. Must happen before calling</span>
<span class="udiff-line-modified-added">+   // get_static_tls_area_size(), which uses the guard_size.</span>
<span class="udiff-line-added">+   pthread_attr_setguardsize(&amp;attr, guard_size);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t stack_adjust_size = 0;</span>
<span class="udiff-line-added">+   if (AdjustStackSizeForTLS) {</span>
<span class="udiff-line-added">+     // Adjust the stack_size for on-stack TLS - see get_static_tls_area_size().</span>
<span class="udiff-line-added">+     stack_adjust_size += get_static_tls_area_size(&amp;attr);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     stack_adjust_size += guard_size;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   stack_adjust_size = align_up(stack_adjust_size, os::vm_page_size());</span>
<span class="udiff-line-added">+   if (stack_size &lt;= SIZE_MAX - stack_adjust_size) {</span>
<span class="udiff-line-added">+     stack_size += stack_adjust_size;</span>
    }
    assert(is_aligned(stack_size, os::vm_page_size()), &quot;stack_size not aligned&quot;);
  
    int status = pthread_attr_setstacksize(&amp;attr, stack_size);
    assert_status(status == 0, status, &quot;pthread_attr_setstacksize&quot;);
  
<span class="udiff-line-removed">-   // Configure glibc guard page.</span>
<span class="udiff-line-removed">-   pthread_attr_setguardsize(&amp;attr, os::Linux::default_guard_size(thr_type));</span>
<span class="udiff-line-removed">- </span>
    ThreadState state;
  
    {
      pthread_t tid;
      int ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) thread_native_entry, thread);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -778,10 +931,17 @@</span>
        log_info(os, thread)(&quot;Thread started (pthread id: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
          (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
      } else {
        log_warning(os, thread)(&quot;Failed to start thread - pthread_create failed (%s) for attributes: %s.&quot;,
          os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
<span class="udiff-line-added">+       // Log some OS information which might explain why creating the thread failed.</span>
<span class="udiff-line-added">+       log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());</span>
<span class="udiff-line-added">+       LogStream st(Log(os, thread)::info());</span>
<span class="udiff-line-added">+       os::Posix::print_rlimit_info(&amp;st);</span>
<span class="udiff-line-added">+       os::print_memory_info(&amp;st);</span>
<span class="udiff-line-added">+       os::Linux::print_proc_sys_info(&amp;st);</span>
<span class="udiff-line-added">+       os::Linux::print_container_info(&amp;st);</span>
      }
  
      pthread_attr_destroy(&amp;attr);
  
      if (ret != 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -795,13 +955,13 @@</span>
      osthread-&gt;set_pthread_id(tid);
  
      // Wait until child thread is either initialized or aborted
      {
        Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="udiff-line-modified-removed">-       MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+       MutexLocker ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
        while ((state = osthread-&gt;get_state()) == ALLOCATED) {
<span class="udiff-line-modified-removed">-         sync_with_child-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+         sync_with_child-&gt;wait_without_safepoint_check();</span>
        }
      }
    }
  
    // Aborted due to thread limit being reached
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -889,11 +1049,11 @@</span>
  
  void os::pd_start_thread(Thread* thread) {
    OSThread * osthread = thread-&gt;osthread();
    assert(osthread-&gt;get_state() != INITIALIZED, &quot;just checking&quot;);
    Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="udiff-line-modified-removed">-   MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MutexLocker ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
    sync_with_child-&gt;notify();
  }
  
  // Free Linux resources related to the OSThread
  void os::free_thread(OSThread* osthread) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1200,12 +1360,10 @@</span>
  jlong os::elapsed_frequency() {
    return NANOSECS_PER_SEC; // nanosecond resolution
  }
  
  bool os::supports_vtime() { return true; }
<span class="udiff-line-removed">- bool os::enable_vtime()   { return false; }</span>
<span class="udiff-line-removed">- bool os::vtime_enabled()  { return false; }</span>
  
  double os::elapsedVTime() {
    struct rusage usage;
    int retval = getrusage(RUSAGE_THREAD, &amp;usage);
    if (retval == 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1375,12 +1533,19 @@</span>
  
    ::exit(1);
  }
  
  // Die immediately, no exit hook, no abort hook, no cleanup.
<span class="udiff-line-added">+ // Dump a core file, if possible, for debugging.</span>
  void os::die() {
<span class="udiff-line-modified-removed">-   ::abort();</span>
<span class="udiff-line-modified-added">+   if (TestUnresponsiveErrorHandler &amp;&amp; !CreateCoredumpOnCrash) {</span>
<span class="udiff-line-added">+     // For TimeoutInErrorHandlingTest.java, we just kill the VM</span>
<span class="udiff-line-added">+     // and don&#39;t take the time to generate a core file.</span>
<span class="udiff-line-added">+     os::signal_raise(SIGKILL);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     ::abort();</span>
<span class="udiff-line-added">+   }</span>
  }
  
  // thread_id is kernel thread id (similar to Solaris LWP id)
  intx os::current_thread_id() { return os::Linux::gettid(); }
  int os::current_process_id() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1568,10 +1733,12 @@</span>
  
  void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
    void * result = NULL;
    bool load_attempted = false;
  
<span class="udiff-line-added">+   log_info(os)(&quot;attempting shared library load of %s&quot;, filename);</span>
<span class="udiff-line-added">+ </span>
    // Check whether the library to load might change execution rights
    // of the stack. If they are changed, the protection of the stack
    // guard pages will be lost. We need a safepoint to fix this.
    //
    // See Linux man page execstack(8) for more info.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1654,15 +1821,30 @@</span>
    if (failed_to_read_elf_head) {
      // file i/o error - report dlerror() msg
      return NULL;
    }
  
<span class="udiff-line-added">+   if (elf_head.e_ident[EI_DATA] != LITTLE_ENDIAN_ONLY(ELFDATA2LSB) BIG_ENDIAN_ONLY(ELFDATA2MSB)) {</span>
<span class="udiff-line-added">+     // handle invalid/out of range endianness values</span>
<span class="udiff-line-added">+     if (elf_head.e_ident[EI_DATA] == 0 || elf_head.e_ident[EI_DATA] &gt; 2) {</span>
<span class="udiff-line-added">+       return NULL;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if defined(VM_LITTLE_ENDIAN)</span>
<span class="udiff-line-added">+     // VM is LE, shared object BE</span>
<span class="udiff-line-added">+     elf_head.e_machine = be16toh(elf_head.e_machine);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     // VM is BE, shared object LE</span>
<span class="udiff-line-added">+     elf_head.e_machine = le16toh(elf_head.e_machine);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    typedef struct {
      Elf32_Half    code;         // Actual value as defined in elf.h
      Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
      unsigned char elf_class;    // 32 or 64 bit
<span class="udiff-line-modified-removed">-     unsigned char endianess;    // MSB or LSB</span>
<span class="udiff-line-modified-added">+     unsigned char endianness;   // MSB or LSB</span>
      char*         name;         // String representation
    } arch_t;
  
  #ifndef EM_486
    #define EM_486          6               /* Intel 80486 */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1685,12 +1867,13 @@</span>
      {EM_SH,          EM_SH,      ELFCLASS32, ELFDATA2LSB, (char*)&quot;SuperH&quot;},
  #else
      {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)&quot;Power PC 64&quot;},
      {EM_SH,          EM_SH,      ELFCLASS32, ELFDATA2MSB, (char*)&quot;SuperH BE&quot;},
  #endif
<span class="udiff-line-modified-removed">-     {EM_ARM,         EM_ARM,     ELFCLASS32,   ELFDATA2LSB, (char*)&quot;ARM&quot;},</span>
<span class="udiff-line-modified-removed">-     {EM_S390,        EM_S390,    ELFCLASSNONE, ELFDATA2MSB, (char*)&quot;IBM System/390&quot;},</span>
<span class="udiff-line-modified-added">+     {EM_ARM,         EM_ARM,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;ARM&quot;},</span>
<span class="udiff-line-modified-added">+     // we only support 64 bit z architecture</span>
<span class="udiff-line-added">+     {EM_S390,        EM_S390,    ELFCLASS64, ELFDATA2MSB, (char*)&quot;IBM System/390&quot;},</span>
      {EM_ALPHA,       EM_ALPHA,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;Alpha&quot;},
      {EM_MIPS_RS3_LE, EM_MIPS_RS3_LE, ELFCLASS32, ELFDATA2LSB, (char*)&quot;MIPSel&quot;},
      {EM_MIPS,        EM_MIPS,    ELFCLASS32, ELFDATA2MSB, (char*)&quot;MIPS&quot;},
      {EM_PARISC,      EM_PARISC,  ELFCLASS32, ELFDATA2MSB, (char*)&quot;PARISC&quot;},
      {EM_68K,         EM_68K,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;M68k&quot;},
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1732,11 +1915,11 @@</span>
  #else
      #error Method os::dll_load requires that one of following is defined:\
          AARCH64, ALPHA, ARM, AMD64, IA32, IA64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, S390, SH, __sparc
  #endif
  
<span class="udiff-line-modified-removed">-   // Identify compatability class for VM&#39;s architecture and library&#39;s architecture</span>
<span class="udiff-line-modified-added">+   // Identify compatibility class for VM&#39;s architecture and library&#39;s architecture</span>
    // Obtain string descriptions for architectures
  
    arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};
    int running_arch_index=-1;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1756,44 +1939,61 @@</span>
      // Even though running architecture detection failed
      // we may still continue with reporting dlerror() message
      return NULL;
    }
  
<span class="udiff-line-removed">-   if (lib_arch.endianess != arch_array[running_arch_index].endianess) {</span>
<span class="udiff-line-removed">-     ::snprintf(diag_msg_buf, diag_msg_max_length-1,&quot; (Possible cause: endianness mismatch)&quot;);</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifndef S390</span>
<span class="udiff-line-removed">-   if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {</span>
<span class="udiff-line-removed">-     ::snprintf(diag_msg_buf, diag_msg_max_length-1,&quot; (Possible cause: architecture word width mismatch)&quot;);</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif // !S390</span>
<span class="udiff-line-removed">- </span>
    if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {
<span class="udiff-line-modified-removed">-     if (lib_arch.name!=NULL) {</span>
<span class="udiff-line-modified-added">+     if (lib_arch.name != NULL) {</span>
        ::snprintf(diag_msg_buf, diag_msg_max_length-1,
<span class="udiff-line-modified-removed">-                  &quot; (Possible cause: can&#39;t load %s-bit .so on a %s-bit platform)&quot;,</span>
<span class="udiff-line-modified-added">+                  &quot; (Possible cause: can&#39;t load %s .so on a %s platform)&quot;,</span>
                   lib_arch.name, arch_array[running_arch_index].name);
      } else {
        ::snprintf(diag_msg_buf, diag_msg_max_length-1,
<span class="udiff-line-modified-removed">-                  &quot; (Possible cause: can&#39;t load this .so (machine code=0x%x) on a %s-bit platform)&quot;,</span>
<span class="udiff-line-modified-removed">-                  lib_arch.code,</span>
<span class="udiff-line-removed">-                  arch_array[running_arch_index].name);</span>
<span class="udiff-line-modified-added">+                  &quot; (Possible cause: can&#39;t load this .so (machine code=0x%x) on a %s platform)&quot;,</span>
<span class="udiff-line-modified-added">+                  lib_arch.code, arch_array[running_arch_index].name);</span>
      }
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (lib_arch.endianness != arch_array[running_arch_index].endianness) {</span>
<span class="udiff-line-added">+     ::snprintf(diag_msg_buf, diag_msg_max_length-1, &quot; (Possible cause: endianness mismatch)&quot;);</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // ELF file class/capacity : 0 - invalid, 1 - 32bit, 2 - 64bit</span>
<span class="udiff-line-added">+   if (lib_arch.elf_class &gt; 2 || lib_arch.elf_class &lt; 1) {</span>
<span class="udiff-line-added">+     ::snprintf(diag_msg_buf, diag_msg_max_length-1, &quot; (Possible cause: invalid ELF file class)&quot;);</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {</span>
<span class="udiff-line-added">+     ::snprintf(diag_msg_buf, diag_msg_max_length-1,</span>
<span class="udiff-line-added">+                &quot; (Possible cause: architecture word width mismatch, can&#39;t load %d-bit .so on a %d-bit platform)&quot;,</span>
<span class="udiff-line-added">+                (int) lib_arch.elf_class * 32, arch_array[running_arch_index].elf_class * 32);</span>
<span class="udiff-line-added">+     return NULL;</span>
    }
  
    return NULL;
  }
  
  void * os::Linux::dlopen_helper(const char *filename, char *ebuf,
                                  int ebuflen) {
    void * result = ::dlopen(filename, RTLD_LAZY);
    if (result == NULL) {
<span class="udiff-line-modified-removed">-     ::strncpy(ebuf, ::dlerror(), ebuflen - 1);</span>
<span class="udiff-line-modified-removed">-     ebuf[ebuflen-1] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-added">+     const char* error_report = ::dlerror();</span>
<span class="udiff-line-modified-added">+     if (error_report == NULL) {</span>
<span class="udiff-line-added">+       error_report = &quot;dlerror returned no error description&quot;;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (ebuf != NULL &amp;&amp; ebuflen &gt; 0) {</span>
<span class="udiff-line-added">+       ::strncpy(ebuf, error_report, ebuflen-1);</span>
<span class="udiff-line-added">+       ebuf[ebuflen-1]=&#39;\0&#39;;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     Events::log(NULL, &quot;Loading shared library %s failed, %s&quot;, filename, error_report);</span>
<span class="udiff-line-added">+     log_info(os)(&quot;shared library load of %s failed, %s&quot;, filename, error_report);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     Events::log(NULL, &quot;Loaded shared library %s&quot;, filename);</span>
<span class="udiff-line-added">+     log_info(os)(&quot;shared library load of %s was successful&quot;, filename);</span>
    }
    return result;
  }
  
  void * os::Linux::dll_load_in_vmthread(const char *filename, char *ebuf,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1854,39 +2054,10 @@</span>
    ::close(fd);
  
    return true;
  }
  
<span class="udiff-line-removed">- #if defined(S390) || defined(PPC64)</span>
<span class="udiff-line-removed">- // keywords_to_match - NULL terminated array of keywords</span>
<span class="udiff-line-removed">- static bool print_matching_lines_from_file(const char* filename, outputStream* st, const char* keywords_to_match[]) {</span>
<span class="udiff-line-removed">-   char* line = NULL;</span>
<span class="udiff-line-removed">-   size_t length = 0;</span>
<span class="udiff-line-removed">-   FILE* fp = fopen(filename, &quot;r&quot;);</span>
<span class="udiff-line-removed">-   if (fp == NULL) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   st-&gt;print_cr(&quot;Virtualization information:&quot;);</span>
<span class="udiff-line-removed">-   while (getline(&amp;line, &amp;length, fp) != -1) {</span>
<span class="udiff-line-removed">-     int i = 0;</span>
<span class="udiff-line-removed">-     while (keywords_to_match[i] != NULL) {</span>
<span class="udiff-line-removed">-       if (strncmp(line, keywords_to_match[i], strlen(keywords_to_match[i])) == 0) {</span>
<span class="udiff-line-removed">-         st-&gt;print(&quot;%s&quot;, line);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       i++;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   free(line);</span>
<span class="udiff-line-removed">-   fclose(fp);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  void os::print_dll_info(outputStream *st) {
    st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
  
    char fname[32];
    pid_t pid = os::Linux::gettid();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1909,15 +2080,18 @@</span>
      // Read line by line from &#39;file&#39;
      while (fgets(line, sizeof(line), procmapsFile) != NULL) {
        u8 base, top, offset, inode;
        char permissions[5];
        char device[6];
<span class="udiff-line-modified-removed">-       char name[PATH_MAX + 1];</span>
<span class="udiff-line-modified-added">+       char name[sizeof(line)];</span>
  
        // Parse fields from line
<span class="udiff-line-modified-removed">-       sscanf(line, UINT64_FORMAT_X &quot;-&quot; UINT64_FORMAT_X &quot; %4s &quot; UINT64_FORMAT_X &quot; %7s &quot; INT64_FORMAT &quot; %s&quot;,</span>
<span class="udiff-line-modified-added">+       int matches = sscanf(line, UINT64_FORMAT_X &quot;-&quot; UINT64_FORMAT_X &quot; %4s &quot; UINT64_FORMAT_X &quot; %5s &quot; INT64_FORMAT &quot; %s&quot;,</span>
               &amp;base, &amp;top, permissions, &amp;offset, device, &amp;inode, name);
<span class="udiff-line-added">+       // the last entry &#39;name&#39; is empty for some entries, so we might have 6 matches instead of 7 for some lines</span>
<span class="udiff-line-added">+       if (matches &lt; 6) continue;</span>
<span class="udiff-line-added">+       if (matches == 6) name[0] = &#39;\0&#39;;</span>
  
        // Filter by device id &#39;00:00&#39; so that we only get file system mapped files.
        if (strcmp(device, &quot;00:00&quot;) != 0) {
  
          // Call callback with the fields of interest
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1947,10 +2121,12 @@</span>
  
    os::Linux::print_distro_info(st);
  
    os::Posix::print_uname_info(st);
  
<span class="udiff-line-added">+   os::Linux::print_uptime_info(st);</span>
<span class="udiff-line-added">+ </span>
    // Print warning if unsafe chroot environment detected
    if (unsafe_chroot_detected) {
      st-&gt;print(&quot;WARNING!! &quot;);
      st-&gt;print_cr(&quot;%s&quot;, unstable_chroot_error);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1967,11 +2143,13 @@</span>
  
    os::Linux::print_ld_preload_file(st);
  
    os::Linux::print_container_info(st);
  
<span class="udiff-line-modified-removed">-   os::Linux::print_virtualization_info(st);</span>
<span class="udiff-line-modified-added">+   VM_Version::print_platform_virtualization_info(st);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   os::Linux::print_steal_info(st);</span>
  }
  
  // Try to identify popular distros.
  // Most Linux distributions have a /etc/XXX-release file, which contains
  // the OS version string. Newer Linux distributions have a /etc/lsb-release
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2130,93 +2308,127 @@</span>
  void os::Linux::print_ld_preload_file(outputStream* st) {
    _print_ascii_file(&quot;/etc/ld.so.preload&quot;, st, &quot;\n/etc/ld.so.preload:&quot;);
    st-&gt;cr();
  }
  
<span class="udiff-line-added">+ void os::Linux::print_uptime_info(outputStream* st) {</span>
<span class="udiff-line-added">+   struct sysinfo sinfo;</span>
<span class="udiff-line-added">+   int ret = sysinfo(&amp;sinfo);</span>
<span class="udiff-line-added">+   if (ret == 0) {</span>
<span class="udiff-line-added">+     os::print_dhm(st, &quot;OS uptime:&quot;, (long) sinfo.uptime);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  void os::Linux::print_container_info(outputStream* st) {
    if (!OSContainer::is_containerized()) {
      return;
    }
  
    st-&gt;print(&quot;container (cgroup) information:\n&quot;);
  
    const char *p_ct = OSContainer::container_type();
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;container_type: %s\n&quot;, p_ct != NULL ? p_ct : &quot;failed&quot;);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;container_type: %s\n&quot;, p_ct != NULL ? p_ct : &quot;not supported&quot;);</span>
  
    char *p = OSContainer::cpu_cpuset_cpus();
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;cpu_cpuset_cpus: %s\n&quot;, p != NULL ? p : &quot;failed&quot;);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;cpu_cpuset_cpus: %s\n&quot;, p != NULL ? p : &quot;not supported&quot;);</span>
    free(p);
  
    p = OSContainer::cpu_cpuset_memory_nodes();
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;cpu_memory_nodes: %s\n&quot;, p != NULL ? p : &quot;failed&quot;);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;cpu_memory_nodes: %s\n&quot;, p != NULL ? p : &quot;not supported&quot;);</span>
    free(p);
  
    int i = OSContainer::active_processor_count();
<span class="udiff-line-added">+   st-&gt;print(&quot;active_processor_count: &quot;);</span>
    if (i &gt; 0) {
<span class="udiff-line-modified-removed">-     st-&gt;print(&quot;active_processor_count: %d\n&quot;, i);</span>
<span class="udiff-line-modified-added">+     st-&gt;print(&quot;%d\n&quot;, i);</span>
    } else {
<span class="udiff-line-modified-removed">-     st-&gt;print(&quot;active_processor_count: failed\n&quot;);</span>
<span class="udiff-line-modified-added">+     st-&gt;print(&quot;not supported\n&quot;);</span>
    }
  
    i = OSContainer::cpu_quota();
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;cpu_quota: %d\n&quot;, i);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;cpu_quota: &quot;);</span>
<span class="udiff-line-added">+   if (i &gt; 0) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;%d\n&quot;, i);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;%s\n&quot;, i == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;no quota&quot;);</span>
<span class="udiff-line-added">+   }</span>
  
    i = OSContainer::cpu_period();
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;cpu_period: %d\n&quot;, i);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;cpu_period: &quot;);</span>
<span class="udiff-line-added">+   if (i &gt; 0) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;%d\n&quot;, i);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;%s\n&quot;, i == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;no period&quot;);</span>
<span class="udiff-line-added">+   }</span>
  
    i = OSContainer::cpu_shares();
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;cpu_shares: %d\n&quot;, i);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;cpu_shares: &quot;);</span>
<span class="udiff-line-added">+   if (i &gt; 0) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;%d\n&quot;, i);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;%s\n&quot;, i == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;no shares&quot;);</span>
<span class="udiff-line-added">+   }</span>
  
    jlong j = OSContainer::memory_limit_in_bytes();
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;memory_limit_in_bytes: &quot; JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;memory_limit_in_bytes: &quot;);</span>
<span class="udiff-line-added">+   if (j &gt; 0) {</span>
<span class="udiff-line-added">+     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
<span class="udiff-line-added">+   }</span>
  
    j = OSContainer::memory_and_swap_limit_in_bytes();
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;memory_and_swap_limit_in_bytes: &quot; JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;memory_and_swap_limit_in_bytes: &quot;);</span>
<span class="udiff-line-added">+   if (j &gt; 0) {</span>
<span class="udiff-line-added">+     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
<span class="udiff-line-added">+   }</span>
  
    j = OSContainer::memory_soft_limit_in_bytes();
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;memory_soft_limit_in_bytes: &quot; JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;memory_soft_limit_in_bytes: &quot;);</span>
<span class="udiff-line-added">+   if (j &gt; 0) {</span>
<span class="udiff-line-added">+     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
<span class="udiff-line-added">+   }</span>
  
    j = OSContainer::OSContainer::memory_usage_in_bytes();
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;memory_usage_in_bytes: &quot; JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;memory_usage_in_bytes: &quot;);</span>
<span class="udiff-line-added">+   if (j &gt; 0) {</span>
<span class="udiff-line-added">+     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
<span class="udiff-line-added">+   }</span>
  
    j = OSContainer::OSContainer::memory_max_usage_in_bytes();
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;memory_max_usage_in_bytes: &quot; JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;memory_max_usage_in_bytes: &quot;);</span>
<span class="udiff-line-added">+   if (j &gt; 0) {</span>
<span class="udiff-line-added">+     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
<span class="udiff-line-added">+   }</span>
    st-&gt;cr();
  }
  
<span class="udiff-line-modified-removed">- void os::Linux::print_virtualization_info(outputStream* st) {</span>
<span class="udiff-line-modified-removed">- #if defined(S390)</span>
<span class="udiff-line-modified-removed">-   // /proc/sysinfo contains interesting information about</span>
<span class="udiff-line-modified-removed">-   // - LPAR</span>
<span class="udiff-line-removed">-   // - whole &quot;Box&quot; (CPUs )</span>
<span class="udiff-line-removed">-   // - z/VM / KVM (VM&lt;nn&gt;); this is not available in an LPAR-only setup</span>
<span class="udiff-line-removed">-   const char* kw[] = { &quot;LPAR&quot;, &quot;CPUs&quot;, &quot;VM&quot;, NULL };</span>
<span class="udiff-line-removed">-   const char* info_file = &quot;/proc/sysinfo&quot;;</span>
<span class="udiff-line-modified-added">+ void os::Linux::print_steal_info(outputStream* st) {</span>
<span class="udiff-line-modified-added">+   if (has_initial_tick_info) {</span>
<span class="udiff-line-modified-added">+     CPUPerfTicks pticks;</span>
<span class="udiff-line-modified-added">+     bool res = os::Linux::get_tick_information(&amp;pticks, -1);</span>
  
<span class="udiff-line-modified-removed">-   if (!print_matching_lines_from_file(info_file, st, kw)) {</span>
<span class="udiff-line-modified-removed">-     st-&gt;print_cr(&quot;  &lt;%s Not Available&gt;&quot;, info_file);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">- #elif defined(PPC64)</span>
<span class="udiff-line-modified-removed">-   const char* info_file = &quot;/proc/ppc64/lparcfg&quot;;</span>
<span class="udiff-line-modified-removed">-   const char* kw[] = { &quot;system_type=&quot;, // qemu indicates PowerKVM</span>
<span class="udiff-line-modified-removed">-                        &quot;partition_entitled_capacity=&quot;, // entitled processor capacity percentage</span>
<span class="udiff-line-modified-removed">-                        &quot;partition_max_entitled_capacity=&quot;,</span>
<span class="udiff-line-modified-removed">-                        &quot;capacity_weight=&quot;, // partition CPU weight</span>
<span class="udiff-line-modified-removed">-                        &quot;partition_active_processors=&quot;,</span>
<span class="udiff-line-removed">-                        &quot;partition_potential_processors=&quot;,</span>
<span class="udiff-line-removed">-                        &quot;entitled_proc_capacity_available=&quot;,</span>
<span class="udiff-line-removed">-                        &quot;capped=&quot;, // 0 - uncapped, 1 - vcpus capped at entitled processor capacity percentage</span>
<span class="udiff-line-removed">-                        &quot;shared_processor_mode=&quot;, // (non)dedicated partition</span>
<span class="udiff-line-removed">-                        &quot;system_potential_processors=&quot;,</span>
<span class="udiff-line-removed">-                        &quot;pool=&quot;, // CPU-pool number</span>
<span class="udiff-line-removed">-                        &quot;pool_capacity=&quot;,</span>
<span class="udiff-line-removed">-                        &quot;NumLpars=&quot;, // on non-KVM machines, NumLpars is not found for full partition mode machines</span>
<span class="udiff-line-removed">-                        NULL };</span>
<span class="udiff-line-removed">-   if (!print_matching_lines_from_file(info_file, st, kw)) {</span>
<span class="udiff-line-removed">-     st-&gt;print_cr(&quot;  &lt;%s Not Available&gt;&quot;, info_file);</span>
<span class="udiff-line-modified-added">+     if (res &amp;&amp; pticks.has_steal_ticks) {</span>
<span class="udiff-line-modified-added">+       uint64_t steal_ticks_difference = pticks.steal - initial_steal_ticks;</span>
<span class="udiff-line-modified-added">+       uint64_t total_ticks_difference = pticks.total - initial_total_ticks;</span>
<span class="udiff-line-modified-added">+       double steal_ticks_perc = 0.0;</span>
<span class="udiff-line-modified-added">+       if (total_ticks_difference != 0) {</span>
<span class="udiff-line-modified-added">+         steal_ticks_perc = (double) steal_ticks_difference / total_ticks_difference;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+       st-&gt;print_cr(&quot;Steal ticks since vm start: &quot; UINT64_FORMAT, steal_ticks_difference);</span>
<span class="udiff-line-modified-added">+       st-&gt;print_cr(&quot;Steal ticks percentage since vm start:%7.3f&quot;, steal_ticks_perc);</span>
<span class="udiff-line-modified-added">+     }</span>
    }
<span class="udiff-line-removed">- #endif</span>
  }
  
  void os::print_memory_info(outputStream* st) {
  
    st-&gt;print(&quot;Memory:&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2290,11 +2502,11 @@</span>
  #elif defined(M68K)
  const char* search_string = &quot;CPU&quot;;
  #elif defined(PPC64)
  const char* search_string = &quot;cpu&quot;;
  #elif defined(S390)
<span class="udiff-line-modified-removed">- const char* search_string = &quot;processor&quot;;</span>
<span class="udiff-line-modified-added">+ const char* search_string = &quot;machine =&quot;;</span>
  #elif defined(SPARC)
  const char* search_string = &quot;cpu&quot;;
  #else
  const char* search_string = &quot;Processor&quot;;
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2476,20 +2688,11 @@</span>
  }
  
  ////////////////////////////////////////////////////////////////////////////////
  // sun.misc.Signal support
  
<span class="udiff-line-removed">- static volatile jint sigint_count = 0;</span>
<span class="udiff-line-removed">- </span>
  static void UserHandler(int sig, void *siginfo, void *context) {
<span class="udiff-line-removed">-   // 4511530 - sem_post is serialized and handled by the manager thread. When</span>
<span class="udiff-line-removed">-   // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We</span>
<span class="udiff-line-removed">-   // don&#39;t want to flood the manager thread with sem_post requests.</span>
<span class="udiff-line-removed">-   if (sig == SIGINT &amp;&amp; Atomic::add(1, &amp;sigint_count) &gt; 1) {</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    // Ctrl-C is pressed during error reporting, likely because the error
    // handler fails to abort. Let VM die immediately.
    if (sig == SIGINT &amp;&amp; VMError::is_error_reported()) {
      os::die();
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2558,15 +2761,14 @@</span>
      assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
    }
  }
  
  static int check_pending_signals() {
<span class="udiff-line-removed">-   Atomic::store(0, &amp;sigint_count);</span>
    for (;;) {
      for (int i = 0; i &lt; NSIG + 1; i++) {
        jint n = pending_signals[i];
<span class="udiff-line-modified-removed">-       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(n - 1, &amp;pending_signals[i], n)) {</span>
<span class="udiff-line-modified-added">+       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {</span>
          return i;
        }
      }
      JavaThread *thread = JavaThread::current();
      ThreadBlockInVM tbivm(thread);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2623,11 +2825,11 @@</span>
    if (!UseOprofile) {
      return;
    }
  
    char buf[PATH_MAX+1];
<span class="udiff-line-modified-removed">-   int num = Atomic::add(1, &amp;cnt);</span>
<span class="udiff-line-modified-added">+   int num = Atomic::add(&amp;cnt, 1);</span>
  
    snprintf(buf, sizeof(buf), &quot;%s/hs-vm-%d-%d&quot;,
             os::get_temp_directory(), os::current_process_id(), num);
    unlink(buf);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2817,10 +3019,23 @@</span>
      }
    }
    return 0;
  }
  
<span class="udiff-line-added">+ int os::numa_get_group_id_for_address(const void* address) {</span>
<span class="udiff-line-added">+   void** pages = const_cast&lt;void**&gt;(&amp;address);</span>
<span class="udiff-line-added">+   int id = -1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (os::Linux::numa_move_pages(0, 1, pages, NULL, &amp;id, 0) == -1) {</span>
<span class="udiff-line-added">+     return -1;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (id &lt; 0) {</span>
<span class="udiff-line-added">+     return -1;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return id;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  int os::Linux::get_existing_num_nodes() {
    int node;
    int highest_node_number = Linux::numa_max_node();
    int num_nodes = 0;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2945,10 +3160,14 @@</span>
                                         libnuma_dlsym(handle, &quot;numa_distance&quot;)));
        set_numa_get_membind(CAST_TO_FN_PTR(numa_get_membind_func_t,
                                            libnuma_v2_dlsym(handle, &quot;numa_get_membind&quot;)));
        set_numa_get_interleave_mask(CAST_TO_FN_PTR(numa_get_interleave_mask_func_t,
                                                    libnuma_v2_dlsym(handle, &quot;numa_get_interleave_mask&quot;)));
<span class="udiff-line-added">+       set_numa_move_pages(CAST_TO_FN_PTR(numa_move_pages_func_t,</span>
<span class="udiff-line-added">+                                          libnuma_dlsym(handle, &quot;numa_move_pages&quot;)));</span>
<span class="udiff-line-added">+       set_numa_set_preferred(CAST_TO_FN_PTR(numa_set_preferred_func_t,</span>
<span class="udiff-line-added">+                                             libnuma_dlsym(handle, &quot;numa_set_preferred&quot;)));</span>
  
        if (numa_available() != -1) {
          set_numa_all_nodes((unsigned long*)libnuma_dlsym(handle, &quot;numa_all_nodes&quot;));
          set_numa_all_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_all_nodes_ptr&quot;));
          set_numa_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_nodes_ptr&quot;));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3079,10 +3298,12 @@</span>
  os::Linux::numa_set_bind_policy_func_t os::Linux::_numa_set_bind_policy;
  os::Linux::numa_bitmask_isbitset_func_t os::Linux::_numa_bitmask_isbitset;
  os::Linux::numa_distance_func_t os::Linux::_numa_distance;
  os::Linux::numa_get_membind_func_t os::Linux::_numa_get_membind;
  os::Linux::numa_get_interleave_mask_func_t os::Linux::_numa_get_interleave_mask;
<span class="udiff-line-added">+ os::Linux::numa_move_pages_func_t os::Linux::_numa_move_pages;</span>
<span class="udiff-line-added">+ os::Linux::numa_set_preferred_func_t os::Linux::_numa_set_preferred;</span>
  os::Linux::NumaAllocationPolicy os::Linux::_current_numa_policy;
  unsigned long* os::Linux::_numa_all_nodes;
  struct bitmask* os::Linux::_numa_all_nodes_ptr;
  struct bitmask* os::Linux::_numa_nodes_ptr;
  struct bitmask* os::Linux::_numa_interleave_bitmask;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3366,10 +3587,11 @@</span>
    // protection of malloc&#39;ed or statically allocated memory). Check the
    // caller if you hit this assert.
    assert(addr == bottom, &quot;sanity check&quot;);
  
    size = align_up(pointer_delta(addr, bottom, 1) + size, os::Linux::page_size());
<span class="udiff-line-added">+   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(bottom), p2i(bottom+size), prot);</span>
    return ::mprotect(bottom, size, prot) == 0;
  }
  
  // Set protections specified
  bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4004,15 +4226,10 @@</span>
  
  // Reserve memory at an arbitrary address, only if that area is
  // available (and not reserved for something else).
  
  char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
<span class="udiff-line-removed">-   const int max_tries = 10;</span>
<span class="udiff-line-removed">-   char* base[max_tries];</span>
<span class="udiff-line-removed">-   size_t size[max_tries];</span>
<span class="udiff-line-removed">-   const size_t gap = 0x000000;</span>
<span class="udiff-line-removed">- </span>
    // Assert only that the size is a multiple of the page size, since
    // that&#39;s all that mmap requires, and since that&#39;s all we really know
    // about at this low abstraction level.  If we need higher alignment,
    // we can either pass an alignment to this method or verify alignment
    // in one of the methods further up the call chain.  See bug 5044738.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4031,54 +4248,11 @@</span>
    if (addr != NULL) {
      // mmap() is successful but it fails to reserve at the requested address
      anon_munmap(addr, bytes);
    }
  
<span class="udiff-line-modified-removed">-   int i;</span>
<span class="udiff-line-removed">-   for (i = 0; i &lt; max_tries; ++i) {</span>
<span class="udiff-line-removed">-     base[i] = reserve_memory(bytes);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (base[i] != NULL) {</span>
<span class="udiff-line-removed">-       // Is this the block we wanted?</span>
<span class="udiff-line-removed">-       if (base[i] == requested_addr) {</span>
<span class="udiff-line-removed">-         size[i] = bytes;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Does this overlap the block we wanted? Give back the overlapped</span>
<span class="udiff-line-removed">-       // parts and try again.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       ptrdiff_t top_overlap = requested_addr + (bytes + gap) - base[i];</span>
<span class="udiff-line-removed">-       if (top_overlap &gt;= 0 &amp;&amp; (size_t)top_overlap &lt; bytes) {</span>
<span class="udiff-line-removed">-         unmap_memory(base[i], top_overlap);</span>
<span class="udiff-line-removed">-         base[i] += top_overlap;</span>
<span class="udiff-line-removed">-         size[i] = bytes - top_overlap;</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         ptrdiff_t bottom_overlap = base[i] + bytes - requested_addr;</span>
<span class="udiff-line-removed">-         if (bottom_overlap &gt;= 0 &amp;&amp; (size_t)bottom_overlap &lt; bytes) {</span>
<span class="udiff-line-removed">-           unmap_memory(requested_addr, bottom_overlap);</span>
<span class="udiff-line-removed">-           size[i] = bytes - bottom_overlap;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           size[i] = bytes;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Give back the unused reserved pieces.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   for (int j = 0; j &lt; i; ++j) {</span>
<span class="udiff-line-removed">-     if (base[j] != NULL) {</span>
<span class="udiff-line-removed">-       unmap_memory(base[j], size[j]);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (i &lt; max_tries) {</span>
<span class="udiff-line-removed">-     return requested_addr;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   return NULL;</span>
  }
  
  // Sleep forever; naked call to OS-specific sleep; use with CAUTION
  void os::infinite_sleep() {
    while (true) {    // sleep forever ...
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4646,19 +4820,15 @@</span>
      // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
      // and if UserSignalHandler is installed all bets are off.
      // Log that signal checking is off only if -verbose:jni is specified.
      if (CheckJNICalls) {
        if (libjsig_is_loaded) {
<span class="udiff-line-modified-removed">-         if (PrintJNIResolving) {</span>
<span class="udiff-line-removed">-           tty-&gt;print_cr(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         log_debug(jni, resolve)(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>
          check_signals = false;
        }
        if (AllowUserSignalHandlers) {
<span class="udiff-line-modified-removed">-         if (PrintJNIResolving) {</span>
<span class="udiff-line-removed">-           tty-&gt;print_cr(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         log_debug(jni, resolve)(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>
          check_signals = false;
        }
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4676,52 +4846,10 @@</span>
    assert(rc == 0, &quot;clock_gettime is expected to return 0 code&quot;);
  
    return (tp.tv_sec * NANOSECS_PER_SEC) + tp.tv_nsec;
  }
  
<span class="udiff-line-removed">- void os::Linux::initialize_os_info() {</span>
<span class="udiff-line-removed">-   assert(_os_version == 0, &quot;OS info already initialized&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   struct utsname _uname;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   uint32_t major;</span>
<span class="udiff-line-removed">-   uint32_t minor;</span>
<span class="udiff-line-removed">-   uint32_t fix;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int rc;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Kernel version is unknown if</span>
<span class="udiff-line-removed">-   // verification below fails.</span>
<span class="udiff-line-removed">-   _os_version = 0x01000000;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   rc = uname(&amp;_uname);</span>
<span class="udiff-line-removed">-   if (rc != -1) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     rc = sscanf(_uname.release,&quot;%d.%d.%d&quot;, &amp;major, &amp;minor, &amp;fix);</span>
<span class="udiff-line-removed">-     if (rc == 3) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (major &lt; 256 &amp;&amp; minor &lt; 256 &amp;&amp; fix &lt; 256) {</span>
<span class="udiff-line-removed">-         // Kernel version format is as expected,</span>
<span class="udiff-line-removed">-         // set it overriding unknown state.</span>
<span class="udiff-line-removed">-         _os_version = (major &lt;&lt; 16) |</span>
<span class="udiff-line-removed">-                       (minor &lt;&lt; 8 ) |</span>
<span class="udiff-line-removed">-                       (fix   &lt;&lt; 0 ) ;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- uint32_t os::Linux::os_version() {</span>
<span class="udiff-line-removed">-   assert(_os_version != 0, &quot;not initialized&quot;);</span>
<span class="udiff-line-removed">-   return _os_version &amp; 0x00FFFFFF;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool os::Linux::os_version_is_known() {</span>
<span class="udiff-line-removed">-   assert(_os_version != 0, &quot;not initialized&quot;);</span>
<span class="udiff-line-removed">-   return _os_version &amp; 0x01000000 ? false : true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  /////
  // glibc on Linux platform uses non-documented flag
  // to indicate, that some special sort of signal
  // trampoline is used.
  // We will never set this flag, and we should
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4937,11 +5065,18 @@</span>
    }
    init_page_sizes((size_t) Linux::page_size());
  
    Linux::initialize_system_info();
  
<span class="udiff-line-modified-removed">-   Linux::initialize_os_info();</span>
<span class="udiff-line-modified-added">+   os::Linux::CPUPerfTicks pticks;</span>
<span class="udiff-line-added">+   bool res = os::Linux::get_tick_information(&amp;pticks, -1);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (res &amp;&amp; pticks.has_steal_ticks) {</span>
<span class="udiff-line-added">+     has_initial_tick_info = true;</span>
<span class="udiff-line-added">+     initial_total_ticks = pticks.total;</span>
<span class="udiff-line-added">+     initial_steal_ticks = pticks.steal;</span>
<span class="udiff-line-added">+   }</span>
  
    // _main_thread points to the thread that created/loaded the JVM.
    Linux::_main_thread = pthread_self();
  
    // retrieve entry point for pthread_setname_np
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5060,22 +5195,29 @@</span>
    // Initialize data for jdk.internal.misc.Signal
    if (!ReduceSignalUsage) {
      jdk_misc_signal_init();
    }
  
<span class="udiff-line-added">+   if (AdjustStackSizeForTLS) {</span>
<span class="udiff-line-added">+     get_minstack_init();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // Check and sets minimum stack sizes against command line options
    if (Posix::set_minimum_stack_sizes() == JNI_ERR) {
      return JNI_ERR;
    }
  
<span class="udiff-line-added">+ #if defined(IA32)</span>
<span class="udiff-line-added">+   // Need to ensure we&#39;ve determined the process&#39;s initial stack to</span>
<span class="udiff-line-added">+   // perform the workaround</span>
<span class="udiff-line-added">+   Linux::capture_initial_stack(JavaThread::stack_size_at_create());</span>
<span class="udiff-line-added">+   workaround_expand_exec_shield_cs_limit();</span>
<span class="udiff-line-added">+ #else</span>
    suppress_primordial_thread_resolution = Arguments::created_by_java_launcher();
    if (!suppress_primordial_thread_resolution) {
      Linux::capture_initial_stack(JavaThread::stack_size_at_create());
    }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if defined(IA32)</span>
<span class="udiff-line-removed">-   workaround_expand_exec_shield_cs_limit();</span>
  #endif
  
    Linux::libpthread_init();
    Linux::sched_getcpu_init();
    log_info(os)(&quot;HotSpot is running with %s, %s&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5099,13 +5241,10 @@</span>
          log_info(os)(&quot;os::init_2 setrlimit failed: %s&quot;, os::strerror(errno));
        }
      }
    }
  
<span class="udiff-line-removed">-   // Initialize lock used to serialize thread creation (see os::create_thread)</span>
<span class="udiff-line-removed">-   Linux::set_createThread_lock(new Mutex(Mutex::leaf, &quot;createThread_lock&quot;, false));</span>
<span class="udiff-line-removed">- </span>
    // at-exit methods are called in the reverse order of their registration.
    // atexit functions are called on return from main or as a result of a
    // call to exit(3C). There can be only 32 of these functions registered
    // and atexit() does not set errno.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5302,15 +5441,10 @@</span>
      // ERANGE should not happen; all other errors should just be ignored.
      assert(rc != ERANGE, &quot;pthread_setname_np failed&quot;);
    }
  }
  
<span class="udiff-line-removed">- bool os::distribute_processes(uint length, uint* distribution) {</span>
<span class="udiff-line-removed">-   // Not yet implemented.</span>
<span class="udiff-line-removed">-   return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool os::bind_to_processor(uint processor_id) {
    // Not yet implemented.
    return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6022,10 +6156,14 @@</span>
      return filetime1.tv_nsec - filetime2.tv_nsec;
    }
    return diff;
  }
  
<span class="udiff-line-added">+ bool os::supports_map_sync() {</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /////////////// Unit tests ///////////////
  
  #ifndef PRODUCT
  
  class TestReserveMemorySpecial : AllStatic {
</pre>
<center><a href="osContainer_linux.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
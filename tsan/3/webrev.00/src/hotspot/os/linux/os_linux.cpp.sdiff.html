<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="osContainer_linux.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/filemap.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;os_linux.inline.hpp&quot;
  41 #include &quot;os_posix.inline.hpp&quot;
  42 #include &quot;os_share_linux.hpp&quot;
  43 #include &quot;osContainer_linux.hpp&quot;
  44 #include &quot;prims/jniFastGetField.hpp&quot;
  45 #include &quot;prims/jvm_misc.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/atomic.hpp&quot;
  48 #include &quot;runtime/extendedPC.hpp&quot;
  49 #include &quot;runtime/globals.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/init.hpp&quot;
  52 #include &quot;runtime/java.hpp&quot;
  53 #include &quot;runtime/javaCalls.hpp&quot;
  54 #include &quot;runtime/mutexLocker.hpp&quot;
  55 #include &quot;runtime/objectMonitor.hpp&quot;
<span class="line-removed">  56 #include &quot;runtime/orderAccess.hpp&quot;</span>
  57 #include &quot;runtime/osThread.hpp&quot;
  58 #include &quot;runtime/perfMemory.hpp&quot;
  59 #include &quot;runtime/sharedRuntime.hpp&quot;
  60 #include &quot;runtime/statSampler.hpp&quot;
  61 #include &quot;runtime/stubRoutines.hpp&quot;
  62 #include &quot;runtime/thread.inline.hpp&quot;
  63 #include &quot;runtime/threadCritical.hpp&quot;
  64 #include &quot;runtime/threadSMR.hpp&quot;
  65 #include &quot;runtime/timer.hpp&quot;

  66 #include &quot;semaphore_posix.hpp&quot;
  67 #include &quot;services/attachListener.hpp&quot;
  68 #include &quot;services/memTracker.hpp&quot;
  69 #include &quot;services/runtimeService.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/decoder.hpp&quot;
  72 #include &quot;utilities/defaultStream.hpp&quot;
  73 #include &quot;utilities/events.hpp&quot;
  74 #include &quot;utilities/elfFile.hpp&quot;
  75 #include &quot;utilities/growableArray.hpp&quot;
  76 #include &quot;utilities/macros.hpp&quot;

  77 #include &quot;utilities/vmError.hpp&quot;
  78 
  79 // put OS-includes here
  80 # include &lt;sys/types.h&gt;
  81 # include &lt;sys/mman.h&gt;
  82 # include &lt;sys/stat.h&gt;
  83 # include &lt;sys/select.h&gt;
  84 # include &lt;pthread.h&gt;
  85 # include &lt;signal.h&gt;

  86 # include &lt;errno.h&gt;
  87 # include &lt;dlfcn.h&gt;
  88 # include &lt;stdio.h&gt;
  89 # include &lt;unistd.h&gt;
  90 # include &lt;sys/resource.h&gt;
  91 # include &lt;pthread.h&gt;
  92 # include &lt;sys/stat.h&gt;
  93 # include &lt;sys/time.h&gt;
  94 # include &lt;sys/times.h&gt;
  95 # include &lt;sys/utsname.h&gt;
  96 # include &lt;sys/socket.h&gt;
  97 # include &lt;sys/wait.h&gt;
  98 # include &lt;pwd.h&gt;
  99 # include &lt;poll.h&gt;
 100 # include &lt;fcntl.h&gt;
 101 # include &lt;string.h&gt;
 102 # include &lt;syscall.h&gt;
 103 # include &lt;sys/sysinfo.h&gt;
 104 # include &lt;gnu/libc-version.h&gt;
 105 # include &lt;sys/ipc.h&gt;
</pre>
<hr />
<pre>
 129 
 130 // for timer info max values which include all bits
 131 #define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)
 132 
 133 enum CoredumpFilterBit {
 134   FILE_BACKED_PVT_BIT = 1 &lt;&lt; 2,
 135   FILE_BACKED_SHARED_BIT = 1 &lt;&lt; 3,
 136   LARGEPAGES_BIT = 1 &lt;&lt; 6,
 137   DAX_SHARED_BIT = 1 &lt;&lt; 8
 138 };
 139 
 140 ////////////////////////////////////////////////////////////////////////////////
 141 // global variables
 142 julong os::Linux::_physical_memory = 0;
 143 
 144 address   os::Linux::_initial_thread_stack_bottom = NULL;
 145 uintptr_t os::Linux::_initial_thread_stack_size   = 0;
 146 
 147 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 148 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
<span class="line-removed"> 149 Mutex* os::Linux::_createThread_lock = NULL;</span>
 150 pthread_t os::Linux::_main_thread;
 151 int os::Linux::_page_size = -1;
 152 bool os::Linux::_supports_fast_thread_cpu_time = false;
<span class="line-removed"> 153 uint32_t os::Linux::_os_version = 0;</span>
 154 const char * os::Linux::_glibc_version = NULL;
 155 const char * os::Linux::_libpthread_version = NULL;
 156 
 157 static jlong initial_time_count=0;
 158 
 159 static int clock_tics_per_sec = 100;
 160 
 161 // If the VM might have been created on the primordial thread, we need to resolve the
 162 // primordial thread stack bounds and check if the current thread might be the
 163 // primordial thread in places. If we know that the primordial thread is never used,
 164 // such as when the VM was created by one of the standard java launchers, we can
 165 // avoid this
 166 static bool suppress_primordial_thread_resolution = false;
 167 
 168 // For diagnostics to print a message once. see run_periodic_checks
 169 static sigset_t check_signal_done;
 170 static bool check_signals = true;
 171 
 172 // Signal number used to suspend/resume a thread
 173 
</pre>
<hr />
<pre>
 210   return avail_mem;
 211 }
 212 
 213 julong os::physical_memory() {
 214   jlong phys_mem = 0;
 215   if (OSContainer::is_containerized()) {
 216     jlong mem_limit;
 217     if ((mem_limit = OSContainer::memory_limit_in_bytes()) &gt; 0) {
 218       log_trace(os)(&quot;total container memory: &quot; JLONG_FORMAT, mem_limit);
 219       return mem_limit;
 220     }
 221     log_debug(os, container)(&quot;container memory limit %s: &quot; JLONG_FORMAT &quot;, using host value&quot;,
 222                             mem_limit == OSCONTAINER_ERROR ? &quot;failed&quot; : &quot;unlimited&quot;, mem_limit);
 223   }
 224 
 225   phys_mem = Linux::physical_memory();
 226   log_trace(os)(&quot;total system memory: &quot; JLONG_FORMAT, phys_mem);
 227   return phys_mem;
 228 }
 229 












































































 230 // Return true if user is running as root.
 231 
 232 bool os::have_special_privileges() {
 233   static bool init = false;
 234   static bool privileges = false;
 235   if (!init) {
 236     privileges = (getuid() != geteuid()) || (getgid() != getegid());
 237     init = true;
 238   }
 239   return privileges;
 240 }
 241 
 242 
 243 #ifndef SYS_gettid
 244 // i386: 224, ia64: 1105, amd64: 186, sparc 143
 245   #ifdef __ia64__
 246     #define SYS_gettid 1105
 247   #else
 248     #ifdef __i386__
 249       #define SYS_gettid 224
</pre>
<hr />
<pre>
 333 #ifndef OVERRIDE_LIBPATH
 334   #if defined(AMD64) || (defined(_LP64) &amp;&amp; defined(SPARC)) || defined(PPC64) || defined(S390)
 335     #define DEFAULT_LIBPATH &quot;/usr/lib64:/lib64:/lib:/usr/lib&quot;
 336   #else
 337     #define DEFAULT_LIBPATH &quot;/lib:/usr/lib&quot;
 338   #endif
 339 #else
 340   #define DEFAULT_LIBPATH OVERRIDE_LIBPATH
 341 #endif
 342 
 343 // Base path of extensions installed on the system.
 344 #define SYS_EXT_DIR     &quot;/usr/java/packages&quot;
 345 #define EXTENSIONS_DIR  &quot;/lib/ext&quot;
 346 
 347   // Buffer that fits several sprintfs.
 348   // Note that the space for the colon and the trailing null are provided
 349   // by the nulls included by the sizeof operator.
 350   const size_t bufsize =
 351     MAX2((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
 352          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="line-modified"> 353   char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 354 
 355   // sysclasspath, java_home, dll_dir
 356   {
 357     char *pslash;
 358     os::jvm_path(buf, bufsize);
 359 
 360     // Found the full path to libjvm.so.
 361     // Now cut the path to &lt;java_home&gt;/jre if we can.
 362     pslash = strrchr(buf, &#39;/&#39;);
 363     if (pslash != NULL) {
 364       *pslash = &#39;\0&#39;;            // Get rid of /libjvm.so.
 365     }
 366     pslash = strrchr(buf, &#39;/&#39;);
 367     if (pslash != NULL) {
 368       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 369     }
 370     Arguments::set_dll_dir(buf);
 371 
 372     if (pslash != NULL) {
 373       pslash = strrchr(buf, &#39;/&#39;);
</pre>
<hr />
<pre>
 382   }
 383 
 384   // Where to look for native libraries.
 385   //
 386   // Note: Due to a legacy implementation, most of the library path
 387   // is set in the launcher. This was to accomodate linking restrictions
 388   // on legacy Linux implementations (which are no longer supported).
 389   // Eventually, all the library path setting will be done here.
 390   //
 391   // However, to prevent the proliferation of improperly built native
 392   // libraries, the new path component /usr/java/packages is added here.
 393   // Eventually, all the library path setting will be done here.
 394   {
 395     // Get the user setting of LD_LIBRARY_PATH, and prepended it. It
 396     // should always exist (until the legacy problem cited above is
 397     // addressed).
 398     const char *v = ::getenv(&quot;LD_LIBRARY_PATH&quot;);
 399     const char *v_colon = &quot;:&quot;;
 400     if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
 401     // That&#39;s +1 for the colon and +1 for the trailing &#39;\0&#39;.
<span class="line-modified"> 402     char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,</span>
<span class="line-modified"> 403                                                      strlen(v) + 1 +</span>
<span class="line-modified"> 404                                                      sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;) + sizeof(DEFAULT_LIBPATH) + 1,</span>
<span class="line-modified"> 405                                                      mtInternal);</span>
 406     sprintf(ld_library_path, &quot;%s%s&quot; SYS_EXT_DIR &quot;/lib:&quot; DEFAULT_LIBPATH, v, v_colon);
 407     Arguments::set_library_path(ld_library_path);
 408     FREE_C_HEAP_ARRAY(char, ld_library_path);
 409   }
 410 
 411   // Extensions directories.
 412   sprintf(buf, &quot;%s&quot; EXTENSIONS_DIR &quot;:&quot; SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());
 413   Arguments::set_ext_dirs(buf);
 414 
 415   FREE_C_HEAP_ARRAY(char, buf);
 416 
 417 #undef DEFAULT_LIBPATH
 418 #undef SYS_EXT_DIR
 419 #undef EXTENSIONS_DIR
 420 }
 421 
 422 ////////////////////////////////////////////////////////////////////////////////
 423 // breakpoint support
 424 
 425 void os::breakpoint() {
</pre>
<hr />
<pre>
 627   // stack pointer, causing us to not alloca enough to reach &quot;bottom&quot;.
 628   sp = (address)&amp;sp;
 629 
 630   if (sp &gt; bottom) {
 631     size = sp - bottom;
 632     p = (volatile char *)alloca(size);
 633     assert(p != NULL &amp;&amp; p &lt;= (volatile char *)bottom, &quot;alloca problem?&quot;);
 634     p[0] = &#39;\0&#39;;
 635   }
 636 }
 637 
 638 void os::Linux::expand_stack_to(address bottom) {
 639   _expand_stack_to(bottom);
 640 }
 641 
 642 bool os::Linux::manually_expand_stack(JavaThread * t, address addr) {
 643   assert(t!=NULL, &quot;just checking&quot;);
 644   assert(t-&gt;osthread()-&gt;expanding_stack(), &quot;expand should be set&quot;);
 645   assert(t-&gt;stack_base() != NULL, &quot;stack_base was not initialized&quot;);
 646 
<span class="line-modified"> 647   if (addr &lt;  t-&gt;stack_base() &amp;&amp; addr &gt;= t-&gt;stack_reserved_zone_base()) {</span>
 648     sigset_t mask_all, old_sigset;
 649     sigfillset(&amp;mask_all);
 650     pthread_sigmask(SIG_SETMASK, &amp;mask_all, &amp;old_sigset);
 651     _expand_stack_to(addr);
 652     pthread_sigmask(SIG_SETMASK, &amp;old_sigset, NULL);
 653     return true;
 654   }
 655   return false;
 656 }
 657 
 658 //////////////////////////////////////////////////////////////////////////////
 659 // create new thread
 660 
 661 // Thread start routine for all newly created threads
 662 static void *thread_native_entry(Thread *thread) {
 663 
 664   thread-&gt;record_stack_base_and_size();
 665 
 666   // Try to randomize the cache line index of hot stack frames.
 667   // This helps when threads of the same stack traces evict each other&#39;s
</pre>
<hr />
<pre>
 679 
 680   osthread-&gt;set_thread_id(os::current_thread_id());
 681 
 682   log_info(os, thread)(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 683     os::current_thread_id(), (uintx) pthread_self());
 684 
 685   if (UseNUMA) {
 686     int lgrp_id = os::numa_get_group_id();
 687     if (lgrp_id != -1) {
 688       thread-&gt;set_lgrp_id(lgrp_id);
 689     }
 690   }
 691   // initialize signal mask for this thread
 692   os::Linux::hotspot_sigmask(thread);
 693 
 694   // initialize floating point control register
 695   os::Linux::init_thread_fpu_state();
 696 
 697   // handshaking with parent thread
 698   {
<span class="line-modified"> 699     MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);</span>
 700 
 701     // notify parent thread
 702     osthread-&gt;set_state(INITIALIZED);
 703     sync-&gt;notify_all();
 704 
 705     // wait until os::start_thread()
 706     while (osthread-&gt;get_state() == INITIALIZED) {
<span class="line-modified"> 707       sync-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
 708     }
 709   }
 710 
 711   assert(osthread-&gt;pthread_id() != 0, &quot;pthread_id was not set as expected&quot;);
 712 
 713   // call one more level start routine
 714   thread-&gt;call_run();
 715 
 716   // Note: at this point the thread object may already have deleted itself.
 717   // Prevent dereferencing it from here on out.
 718   thread = NULL;
 719 
 720   log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 721     os::current_thread_id(), (uintx) pthread_self());
 722 
 723   return 0;
 724 }
 725 



































































 726 bool os::create_thread(Thread* thread, ThreadType thr_type,
 727                        size_t req_stack_size) {
 728   assert(thread-&gt;osthread() == NULL, &quot;caller responsible&quot;);
 729 
 730   // Allocate the OSThread object
 731   OSThread* osthread = new OSThread(NULL, NULL);
 732   if (osthread == NULL) {
 733     return false;
 734   }
 735 
 736   // set the correct thread state
 737   osthread-&gt;set_thread_type(thr_type);
 738 
 739   // Initial state is ALLOCATED but not INITIALIZED
 740   osthread-&gt;set_state(ALLOCATED);
 741 
 742   thread-&gt;set_osthread(osthread);
 743 
 744   // init thread attributes
 745   pthread_attr_t attr;
 746   pthread_attr_init(&amp;attr);
 747   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
 748 
 749   // Calculate stack size if it&#39;s not specified by caller.
 750   size_t stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);
<span class="line-modified"> 751   // In the Linux NPTL pthread implementation the guard size mechanism</span>
 752   // is not implemented properly. The posix standard requires adding
 753   // the size of the guard pages to the stack size, instead Linux
 754   // takes the space out of &#39;stacksize&#39;. Thus we adapt the requested
 755   // stack_size by the size of the guard pages to mimick proper
 756   // behaviour. However, be careful not to end up with a size
 757   // of zero due to overflow. Don&#39;t add the guard page in that case.
 758   size_t guard_size = os::Linux::default_guard_size(thr_type);
<span class="line-modified"> 759   if (stack_size &lt;= SIZE_MAX - guard_size) {</span>
<span class="line-modified"> 760     stack_size += guard_size;</span>













 761   }
 762   assert(is_aligned(stack_size, os::vm_page_size()), &quot;stack_size not aligned&quot;);
 763 
 764   int status = pthread_attr_setstacksize(&amp;attr, stack_size);
 765   assert_status(status == 0, status, &quot;pthread_attr_setstacksize&quot;);
 766 
<span class="line-removed"> 767   // Configure glibc guard page.</span>
<span class="line-removed"> 768   pthread_attr_setguardsize(&amp;attr, os::Linux::default_guard_size(thr_type));</span>
<span class="line-removed"> 769 </span>
 770   ThreadState state;
 771 
 772   {
 773     pthread_t tid;
 774     int ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) thread_native_entry, thread);
 775 
 776     char buf[64];
 777     if (ret == 0) {
 778       log_info(os, thread)(&quot;Thread started (pthread id: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
 779         (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
 780     } else {
 781       log_warning(os, thread)(&quot;Failed to start thread - pthread_create failed (%s) for attributes: %s.&quot;,
 782         os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));







 783     }
 784 
 785     pthread_attr_destroy(&amp;attr);
 786 
 787     if (ret != 0) {
 788       // Need to clean up stuff we&#39;ve allocated so far
 789       thread-&gt;set_osthread(NULL);
 790       delete osthread;
 791       return false;
 792     }
 793 
 794     // Store pthread info into the OSThread
 795     osthread-&gt;set_pthread_id(tid);
 796 
 797     // Wait until child thread is either initialized or aborted
 798     {
 799       Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="line-modified"> 800       MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
 801       while ((state = osthread-&gt;get_state()) == ALLOCATED) {
<span class="line-modified"> 802         sync_with_child-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
 803       }
 804     }
 805   }
 806 
 807   // Aborted due to thread limit being reached
 808   if (state == ZOMBIE) {
 809     thread-&gt;set_osthread(NULL);
 810     delete osthread;
 811     return false;
 812   }
 813 
 814   // The thread is returned suspended (in state INITIALIZED),
 815   // and is started higher up in the call chain
 816   assert(state == INITIALIZED, &quot;race condition&quot;);
 817   return true;
 818 }
 819 
 820 /////////////////////////////////////////////////////////////////////////////
 821 // attach existing thread
 822 
</pre>
<hr />
<pre>
 874 
 875     osthread-&gt;set_expanding_stack();
 876     os::Linux::manually_expand_stack(jt, addr);
 877     osthread-&gt;clear_expanding_stack();
 878   }
 879 
 880   // initialize signal mask for this thread
 881   // and save the caller&#39;s signal mask
 882   os::Linux::hotspot_sigmask(thread);
 883 
 884   log_info(os, thread)(&quot;Thread attached (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 885     os::current_thread_id(), (uintx) pthread_self());
 886 
 887   return true;
 888 }
 889 
 890 void os::pd_start_thread(Thread* thread) {
 891   OSThread * osthread = thread-&gt;osthread();
 892   assert(osthread-&gt;get_state() != INITIALIZED, &quot;just checking&quot;);
 893   Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="line-modified"> 894   MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
 895   sync_with_child-&gt;notify();
 896 }
 897 
 898 // Free Linux resources related to the OSThread
 899 void os::free_thread(OSThread* osthread) {
 900   assert(osthread != NULL, &quot;osthread not set&quot;);
 901 
 902   // We are told to free resources of the argument thread,
 903   // but we can only really operate on the current thread.
 904   assert(Thread::current()-&gt;osthread() == osthread,
 905          &quot;os::free_thread but not current thread&quot;);
 906 
 907 #ifdef ASSERT
 908   sigset_t current;
 909   sigemptyset(&amp;current);
 910   pthread_sigmask(SIG_SETMASK, NULL, &amp;current);
 911   assert(!sigismember(&amp;current, SR_signum), &quot;SR signal should not be blocked!&quot;);
 912 #endif
 913 
 914   // Restore caller&#39;s signal mask
</pre>
<hr />
<pre>
1185 #ifndef SUPPORTS_CLOCK_MONOTONIC
1186 #error &quot;Build platform doesn&#39;t support clock_gettime and related functionality&quot;
1187 #endif
1188 
1189 // Time since start-up in seconds to a fine granularity.
1190 // Used by VMSelfDestructTimer and the MemProfiler.
1191 double os::elapsedTime() {
1192 
1193   return ((double)os::elapsed_counter()) / os::elapsed_frequency(); // nanosecond resolution
1194 }
1195 
1196 jlong os::elapsed_counter() {
1197   return javaTimeNanos() - initial_time_count;
1198 }
1199 
1200 jlong os::elapsed_frequency() {
1201   return NANOSECS_PER_SEC; // nanosecond resolution
1202 }
1203 
1204 bool os::supports_vtime() { return true; }
<span class="line-removed">1205 bool os::enable_vtime()   { return false; }</span>
<span class="line-removed">1206 bool os::vtime_enabled()  { return false; }</span>
1207 
1208 double os::elapsedVTime() {
1209   struct rusage usage;
1210   int retval = getrusage(RUSAGE_THREAD, &amp;usage);
1211   if (retval == 0) {
1212     return (double) (usage.ru_utime.tv_sec + usage.ru_stime.tv_sec) + (double) (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) / (1000 * 1000);
1213   } else {
1214     // better than nothing, but not much
1215     return elapsedTime();
1216   }
1217 }
1218 
1219 jlong os::javaTimeMillis() {
1220   timeval time;
1221   int status = gettimeofday(&amp;time, NULL);
1222   assert(status != -1, &quot;linux error&quot;);
1223   return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec / 1000);
1224 }
1225 
1226 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
</pre>
<hr />
<pre>
1360   os::shutdown();
1361   if (dump_core) {
1362     if (DumpPrivateMappingsInCore) {
1363       ClassLoader::close_jrt_image();
1364     }
1365 #ifndef PRODUCT
1366     fdStream out(defaultStream::output_fd());
1367     out.print_raw(&quot;Current thread is &quot;);
1368     char buf[16];
1369     jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());
1370     out.print_raw_cr(buf);
1371     out.print_raw_cr(&quot;Dumping core ...&quot;);
1372 #endif
1373     ::abort(); // dump core
1374   }
1375 
1376   ::exit(1);
1377 }
1378 
1379 // Die immediately, no exit hook, no abort hook, no cleanup.

1380 void os::die() {
<span class="line-modified">1381   ::abort();</span>






1382 }
1383 
1384 // thread_id is kernel thread id (similar to Solaris LWP id)
1385 intx os::current_thread_id() { return os::Linux::gettid(); }
1386 int os::current_process_id() {
1387   return ::getpid();
1388 }
1389 
1390 // DLL functions
1391 
1392 const char* os::dll_file_extension() { return &quot;.so&quot;; }
1393 
1394 // This must be hard coded because it&#39;s the system&#39;s temporary
1395 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1396 const char* os::get_temp_directory() { return &quot;/tmp&quot;; }
1397 
1398 static bool file_exists(const char* filename) {
1399   struct stat statbuf;
1400   if (filename == NULL || strlen(filename) == 0) {
1401     return false;
</pre>
<hr />
<pre>
1553  private:
1554   const char *_filename;
1555   char *_ebuf;
1556   int _ebuflen;
1557   void *_lib;
1558  public:
1559   VM_LinuxDllLoad(const char *fn, char *ebuf, int ebuflen) :
1560     _filename(fn), _ebuf(ebuf), _ebuflen(ebuflen), _lib(NULL) {}
1561   VMOp_Type type() const { return VMOp_LinuxDllLoad; }
1562   void doit() {
1563     _lib = os::Linux::dll_load_in_vmthread(_filename, _ebuf, _ebuflen);
1564     os::Linux::_stack_is_executable = true;
1565   }
1566   void* loaded_library() { return _lib; }
1567 };
1568 
1569 void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
1570   void * result = NULL;
1571   bool load_attempted = false;
1572 


1573   // Check whether the library to load might change execution rights
1574   // of the stack. If they are changed, the protection of the stack
1575   // guard pages will be lost. We need a safepoint to fix this.
1576   //
1577   // See Linux man page execstack(8) for more info.
1578   if (os::uses_stack_guard_pages() &amp;&amp; !os::Linux::_stack_is_executable) {
1579     if (!ElfFile::specifies_noexecstack(filename)) {
1580       if (!is_init_completed()) {
1581         os::Linux::_stack_is_executable = true;
1582         // This is OK - No Java threads have been created yet, and hence no
1583         // stack guard pages to fix.
1584         //
1585         // Dynamic loader will make all stacks executable after
1586         // this function returns, and will not do that again.
1587         assert(Threads::number_of_threads() == 0, &quot;no Java threads should exist yet.&quot;);
1588       } else {
1589         warning(&quot;You have loaded library %s which might have disabled stack guard. &quot;
1590                 &quot;The VM will try to fix the stack guard now.\n&quot;
1591                 &quot;It&#39;s highly recommended that you fix the library with &quot;
1592                 &quot;&#39;execstack -c &lt;libfile&gt;&#39;, or link it with &#39;-z noexecstack&#39;.&quot;,
</pre>
<hr />
<pre>
1639   }
1640 
1641 
1642   int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);
1643 
1644   if (file_descriptor &lt; 0) {
1645     // Can&#39;t open library, report dlerror() message
1646     return NULL;
1647   }
1648 
1649   bool failed_to_read_elf_head=
1650     (sizeof(elf_head)!=
1651      (::read(file_descriptor, &amp;elf_head,sizeof(elf_head))));
1652 
1653   ::close(file_descriptor);
1654   if (failed_to_read_elf_head) {
1655     // file i/o error - report dlerror() msg
1656     return NULL;
1657   }
1658 















1659   typedef struct {
1660     Elf32_Half    code;         // Actual value as defined in elf.h
1661     Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
1662     unsigned char elf_class;    // 32 or 64 bit
<span class="line-modified">1663     unsigned char endianess;    // MSB or LSB</span>
1664     char*         name;         // String representation
1665   } arch_t;
1666 
1667 #ifndef EM_486
1668   #define EM_486          6               /* Intel 80486 */
1669 #endif
1670 #ifndef EM_AARCH64
1671   #define EM_AARCH64    183               /* ARM AARCH64 */
1672 #endif
1673 
1674   static const arch_t arch_array[]={
1675     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1676     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1677     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1678     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
1679     {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1680     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1681     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
1682     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1683 #if defined(VM_LITTLE_ENDIAN)
1684     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;Power PC 64 LE&quot;},
1685     {EM_SH,          EM_SH,      ELFCLASS32, ELFDATA2LSB, (char*)&quot;SuperH&quot;},
1686 #else
1687     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)&quot;Power PC 64&quot;},
1688     {EM_SH,          EM_SH,      ELFCLASS32, ELFDATA2MSB, (char*)&quot;SuperH BE&quot;},
1689 #endif
<span class="line-modified">1690     {EM_ARM,         EM_ARM,     ELFCLASS32,   ELFDATA2LSB, (char*)&quot;ARM&quot;},</span>
<span class="line-modified">1691     {EM_S390,        EM_S390,    ELFCLASSNONE, ELFDATA2MSB, (char*)&quot;IBM System/390&quot;},</span>

1692     {EM_ALPHA,       EM_ALPHA,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;Alpha&quot;},
1693     {EM_MIPS_RS3_LE, EM_MIPS_RS3_LE, ELFCLASS32, ELFDATA2LSB, (char*)&quot;MIPSel&quot;},
1694     {EM_MIPS,        EM_MIPS,    ELFCLASS32, ELFDATA2MSB, (char*)&quot;MIPS&quot;},
1695     {EM_PARISC,      EM_PARISC,  ELFCLASS32, ELFDATA2MSB, (char*)&quot;PARISC&quot;},
1696     {EM_68K,         EM_68K,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;M68k&quot;},
1697     {EM_AARCH64,     EM_AARCH64, ELFCLASS64, ELFDATA2LSB, (char*)&quot;AARCH64&quot;},
1698   };
1699 
1700 #if  (defined IA32)
1701   static  Elf32_Half running_arch_code=EM_386;
1702 #elif   (defined AMD64) || (defined X32)
1703   static  Elf32_Half running_arch_code=EM_X86_64;
1704 #elif  (defined IA64)
1705   static  Elf32_Half running_arch_code=EM_IA_64;
1706 #elif  (defined __sparc) &amp;&amp; (defined _LP64)
1707   static  Elf32_Half running_arch_code=EM_SPARCV9;
1708 #elif  (defined __sparc) &amp;&amp; (!defined _LP64)
1709   static  Elf32_Half running_arch_code=EM_SPARC;
1710 #elif  (defined __powerpc64__)
1711   static  Elf32_Half running_arch_code=EM_PPC64;
</pre>
<hr />
<pre>
1717   static  Elf32_Half running_arch_code=EM_ARM;
1718 #elif  (defined S390)
1719   static  Elf32_Half running_arch_code=EM_S390;
1720 #elif  (defined ALPHA)
1721   static  Elf32_Half running_arch_code=EM_ALPHA;
1722 #elif  (defined MIPSEL)
1723   static  Elf32_Half running_arch_code=EM_MIPS_RS3_LE;
1724 #elif  (defined PARISC)
1725   static  Elf32_Half running_arch_code=EM_PARISC;
1726 #elif  (defined MIPS)
1727   static  Elf32_Half running_arch_code=EM_MIPS;
1728 #elif  (defined M68K)
1729   static  Elf32_Half running_arch_code=EM_68K;
1730 #elif  (defined SH)
1731   static  Elf32_Half running_arch_code=EM_SH;
1732 #else
1733     #error Method os::dll_load requires that one of following is defined:\
1734         AARCH64, ALPHA, ARM, AMD64, IA32, IA64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, S390, SH, __sparc
1735 #endif
1736 
<span class="line-modified">1737   // Identify compatability class for VM&#39;s architecture and library&#39;s architecture</span>
1738   // Obtain string descriptions for architectures
1739 
1740   arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};
1741   int running_arch_index=-1;
1742 
1743   for (unsigned int i=0; i &lt; ARRAY_SIZE(arch_array); i++) {
1744     if (running_arch_code == arch_array[i].code) {
1745       running_arch_index    = i;
1746     }
1747     if (lib_arch.code == arch_array[i].code) {
1748       lib_arch.compat_class = arch_array[i].compat_class;
1749       lib_arch.name         = arch_array[i].name;
1750     }
1751   }
1752 
1753   assert(running_arch_index != -1,
1754          &quot;Didn&#39;t find running architecture code (running_arch_code) in arch_array&quot;);
1755   if (running_arch_index == -1) {
1756     // Even though running architecture detection failed
1757     // we may still continue with reporting dlerror() message
1758     return NULL;
1759   }
1760 
<span class="line-removed">1761   if (lib_arch.endianess != arch_array[running_arch_index].endianess) {</span>
<span class="line-removed">1762     ::snprintf(diag_msg_buf, diag_msg_max_length-1,&quot; (Possible cause: endianness mismatch)&quot;);</span>
<span class="line-removed">1763     return NULL;</span>
<span class="line-removed">1764   }</span>
<span class="line-removed">1765 </span>
<span class="line-removed">1766 #ifndef S390</span>
<span class="line-removed">1767   if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {</span>
<span class="line-removed">1768     ::snprintf(diag_msg_buf, diag_msg_max_length-1,&quot; (Possible cause: architecture word width mismatch)&quot;);</span>
<span class="line-removed">1769     return NULL;</span>
<span class="line-removed">1770   }</span>
<span class="line-removed">1771 #endif // !S390</span>
<span class="line-removed">1772 </span>
1773   if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {
<span class="line-modified">1774     if (lib_arch.name!=NULL) {</span>
1775       ::snprintf(diag_msg_buf, diag_msg_max_length-1,
<span class="line-modified">1776                  &quot; (Possible cause: can&#39;t load %s-bit .so on a %s-bit platform)&quot;,</span>
1777                  lib_arch.name, arch_array[running_arch_index].name);
1778     } else {
1779       ::snprintf(diag_msg_buf, diag_msg_max_length-1,
<span class="line-modified">1780                  &quot; (Possible cause: can&#39;t load this .so (machine code=0x%x) on a %s-bit platform)&quot;,</span>
<span class="line-modified">1781                  lib_arch.code,</span>
<span class="line-removed">1782                  arch_array[running_arch_index].name);</span>
1783     }



















1784   }
1785 
1786   return NULL;
1787 }
1788 
1789 void * os::Linux::dlopen_helper(const char *filename, char *ebuf,
1790                                 int ebuflen) {
1791   void * result = ::dlopen(filename, RTLD_LAZY);
1792   if (result == NULL) {
<span class="line-modified">1793     ::strncpy(ebuf, ::dlerror(), ebuflen - 1);</span>
<span class="line-modified">1794     ebuf[ebuflen-1] = &#39;\0&#39;;</span>











1795   }
1796   return result;
1797 }
1798 
1799 void * os::Linux::dll_load_in_vmthread(const char *filename, char *ebuf,
1800                                        int ebuflen) {
1801   void * result = NULL;
1802   if (LoadExecStackDllInVMThread) {
1803     result = dlopen_helper(filename, ebuf, ebuflen);
1804   }
1805 
1806   // Since 7019808, libjvm.so is linked with -noexecstack. If the VM loads a
1807   // library that requires an executable stack, or which does not have this
1808   // stack attribute set, dlopen changes the stack attribute to executable. The
1809   // read protection of the guard pages gets lost.
1810   //
1811   // Need to check _stack_is_executable again as multiple VM_LinuxDllLoad
1812   // may have been queued at the same time.
1813 
1814   if (!_stack_is_executable) {
</pre>
<hr />
<pre>
1839   if (fd == -1) {
1840     return false;
1841   }
1842 
1843   if (hdr != NULL) {
1844     st-&gt;print_cr(&quot;%s&quot;, hdr);
1845   }
1846 
1847   char buf[33];
1848   int bytes;
1849   buf[32] = &#39;\0&#39;;
1850   while ((bytes = ::read(fd, buf, sizeof(buf)-1)) &gt; 0) {
1851     st-&gt;print_raw(buf, bytes);
1852   }
1853 
1854   ::close(fd);
1855 
1856   return true;
1857 }
1858 
<span class="line-removed">1859 #if defined(S390) || defined(PPC64)</span>
<span class="line-removed">1860 // keywords_to_match - NULL terminated array of keywords</span>
<span class="line-removed">1861 static bool print_matching_lines_from_file(const char* filename, outputStream* st, const char* keywords_to_match[]) {</span>
<span class="line-removed">1862   char* line = NULL;</span>
<span class="line-removed">1863   size_t length = 0;</span>
<span class="line-removed">1864   FILE* fp = fopen(filename, &quot;r&quot;);</span>
<span class="line-removed">1865   if (fp == NULL) {</span>
<span class="line-removed">1866     return false;</span>
<span class="line-removed">1867   }</span>
<span class="line-removed">1868 </span>
<span class="line-removed">1869   st-&gt;print_cr(&quot;Virtualization information:&quot;);</span>
<span class="line-removed">1870   while (getline(&amp;line, &amp;length, fp) != -1) {</span>
<span class="line-removed">1871     int i = 0;</span>
<span class="line-removed">1872     while (keywords_to_match[i] != NULL) {</span>
<span class="line-removed">1873       if (strncmp(line, keywords_to_match[i], strlen(keywords_to_match[i])) == 0) {</span>
<span class="line-removed">1874         st-&gt;print(&quot;%s&quot;, line);</span>
<span class="line-removed">1875         break;</span>
<span class="line-removed">1876       }</span>
<span class="line-removed">1877       i++;</span>
<span class="line-removed">1878     }</span>
<span class="line-removed">1879   }</span>
<span class="line-removed">1880 </span>
<span class="line-removed">1881   free(line);</span>
<span class="line-removed">1882   fclose(fp);</span>
<span class="line-removed">1883 </span>
<span class="line-removed">1884   return true;</span>
<span class="line-removed">1885 }</span>
<span class="line-removed">1886 #endif</span>
<span class="line-removed">1887 </span>
1888 void os::print_dll_info(outputStream *st) {
1889   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
1890 
1891   char fname[32];
1892   pid_t pid = os::Linux::gettid();
1893 
1894   jio_snprintf(fname, sizeof(fname), &quot;/proc/%d/maps&quot;, pid);
1895 
1896   if (!_print_ascii_file(fname, st)) {
1897     st-&gt;print(&quot;Can not get library information for pid = %d\n&quot;, pid);
1898   }
1899 }
1900 
1901 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
1902   FILE *procmapsFile = NULL;
1903 
1904   // Open the procfs maps file for the current process
1905   if ((procmapsFile = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;)) != NULL) {
1906     // Allocate PATH_MAX for file name plus a reasonable size for other fields.
1907     char line[PATH_MAX + 100];
1908 
1909     // Read line by line from &#39;file&#39;
1910     while (fgets(line, sizeof(line), procmapsFile) != NULL) {
1911       u8 base, top, offset, inode;
1912       char permissions[5];
1913       char device[6];
<span class="line-modified">1914       char name[PATH_MAX + 1];</span>
1915 
1916       // Parse fields from line
<span class="line-modified">1917       sscanf(line, UINT64_FORMAT_X &quot;-&quot; UINT64_FORMAT_X &quot; %4s &quot; UINT64_FORMAT_X &quot; %7s &quot; INT64_FORMAT &quot; %s&quot;,</span>
1918              &amp;base, &amp;top, permissions, &amp;offset, device, &amp;inode, name);



1919 
1920       // Filter by device id &#39;00:00&#39; so that we only get file system mapped files.
1921       if (strcmp(device, &quot;00:00&quot;) != 0) {
1922 
1923         // Call callback with the fields of interest
1924         if(callback(name, (address)base, (address)top, param)) {
1925           // Oops abort, callback aborted
1926           fclose(procmapsFile);
1927           return 1;
1928         }
1929       }
1930     }
1931     fclose(procmapsFile);
1932   }
1933   return 0;
1934 }
1935 
1936 void os::print_os_info_brief(outputStream* st) {
1937   os::Linux::print_distro_info(st);
1938 
1939   os::Posix::print_uname_info(st);
1940 
1941   os::Linux::print_libversion_info(st);
1942 
1943 }
1944 
1945 void os::print_os_info(outputStream* st) {
1946   st-&gt;print(&quot;OS:&quot;);
1947 
1948   os::Linux::print_distro_info(st);
1949 
1950   os::Posix::print_uname_info(st);
1951 


1952   // Print warning if unsafe chroot environment detected
1953   if (unsafe_chroot_detected) {
1954     st-&gt;print(&quot;WARNING!! &quot;);
1955     st-&gt;print_cr(&quot;%s&quot;, unstable_chroot_error);
1956   }
1957 
1958   os::Linux::print_libversion_info(st);
1959 
1960   os::Posix::print_rlimit_info(st);
1961 
1962   os::Posix::print_load_average(st);
1963 
1964   os::Linux::print_full_memory_info(st);
1965 
1966   os::Linux::print_proc_sys_info(st);
1967 
1968   os::Linux::print_ld_preload_file(st);
1969 
1970   os::Linux::print_container_info(st);
1971 
<span class="line-modified">1972   os::Linux::print_virtualization_info(st);</span>


1973 }
1974 
1975 // Try to identify popular distros.
1976 // Most Linux distributions have a /etc/XXX-release file, which contains
1977 // the OS version string. Newer Linux distributions have a /etc/lsb-release
1978 // file that also contains the OS version string. Some have more than one
1979 // /etc/XXX-release file (e.g. Mandrake has both /etc/mandrake-release and
1980 // /etc/redhat-release.), so the order is important.
1981 // Any Linux that is based on Redhat (i.e. Oracle, Mandrake, Sun JDS...) have
1982 // their own specific XXX-release file as well as a redhat-release file.
1983 // Because of this the XXX-release file needs to be searched for before the
1984 // redhat-release file.
1985 // Since Red Hat and SuSE have an lsb-release file that is not very descriptive the
1986 // search for redhat-release / SuSE-release needs to be before lsb-release.
1987 // Since the lsb-release file is the new standard it needs to be searched
1988 // before the older style release files.
1989 // Searching system-release (Red Hat) and os-release (other Linuxes) are a
1990 // next to last resort.  The os-release file is a new standard that contains
1991 // distribution information and the system-release file seems to be an old
1992 // standard that has been replaced by the lsb-release and os-release files.
</pre>
<hr />
<pre>
2115   st-&gt;cr();
2116   st-&gt;cr();
2117 
2118   st-&gt;print_cr(&quot;/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers):&quot;);
2119   _print_ascii_file(&quot;/proc/sys/kernel/pid_max&quot;, st);
2120   st-&gt;cr();
2121   st-&gt;cr();
2122 }
2123 
2124 void os::Linux::print_full_memory_info(outputStream* st) {
2125   st-&gt;print(&quot;\n/proc/meminfo:\n&quot;);
2126   _print_ascii_file(&quot;/proc/meminfo&quot;, st);
2127   st-&gt;cr();
2128 }
2129 
2130 void os::Linux::print_ld_preload_file(outputStream* st) {
2131   _print_ascii_file(&quot;/etc/ld.so.preload&quot;, st, &quot;\n/etc/ld.so.preload:&quot;);
2132   st-&gt;cr();
2133 }
2134 









2135 void os::Linux::print_container_info(outputStream* st) {
2136   if (!OSContainer::is_containerized()) {
2137     return;
2138   }
2139 
2140   st-&gt;print(&quot;container (cgroup) information:\n&quot;);
2141 
2142   const char *p_ct = OSContainer::container_type();
<span class="line-modified">2143   st-&gt;print(&quot;container_type: %s\n&quot;, p_ct != NULL ? p_ct : &quot;failed&quot;);</span>
2144 
2145   char *p = OSContainer::cpu_cpuset_cpus();
<span class="line-modified">2146   st-&gt;print(&quot;cpu_cpuset_cpus: %s\n&quot;, p != NULL ? p : &quot;failed&quot;);</span>
2147   free(p);
2148 
2149   p = OSContainer::cpu_cpuset_memory_nodes();
<span class="line-modified">2150   st-&gt;print(&quot;cpu_memory_nodes: %s\n&quot;, p != NULL ? p : &quot;failed&quot;);</span>
2151   free(p);
2152 
2153   int i = OSContainer::active_processor_count();

2154   if (i &gt; 0) {
<span class="line-modified">2155     st-&gt;print(&quot;active_processor_count: %d\n&quot;, i);</span>
2156   } else {
<span class="line-modified">2157     st-&gt;print(&quot;active_processor_count: failed\n&quot;);</span>
2158   }
2159 
2160   i = OSContainer::cpu_quota();
<span class="line-modified">2161   st-&gt;print(&quot;cpu_quota: %d\n&quot;, i);</span>





2162 
2163   i = OSContainer::cpu_period();
<span class="line-modified">2164   st-&gt;print(&quot;cpu_period: %d\n&quot;, i);</span>





2165 
2166   i = OSContainer::cpu_shares();
<span class="line-modified">2167   st-&gt;print(&quot;cpu_shares: %d\n&quot;, i);</span>





2168 
2169   jlong j = OSContainer::memory_limit_in_bytes();
<span class="line-modified">2170   st-&gt;print(&quot;memory_limit_in_bytes: &quot; JLONG_FORMAT &quot;\n&quot;, j);</span>





2171 
2172   j = OSContainer::memory_and_swap_limit_in_bytes();
<span class="line-modified">2173   st-&gt;print(&quot;memory_and_swap_limit_in_bytes: &quot; JLONG_FORMAT &quot;\n&quot;, j);</span>





2174 
2175   j = OSContainer::memory_soft_limit_in_bytes();
<span class="line-modified">2176   st-&gt;print(&quot;memory_soft_limit_in_bytes: &quot; JLONG_FORMAT &quot;\n&quot;, j);</span>





2177 
2178   j = OSContainer::OSContainer::memory_usage_in_bytes();
<span class="line-modified">2179   st-&gt;print(&quot;memory_usage_in_bytes: &quot; JLONG_FORMAT &quot;\n&quot;, j);</span>





2180 
2181   j = OSContainer::OSContainer::memory_max_usage_in_bytes();
<span class="line-modified">2182   st-&gt;print(&quot;memory_max_usage_in_bytes: &quot; JLONG_FORMAT &quot;\n&quot;, j);</span>





2183   st-&gt;cr();
2184 }
2185 
<span class="line-modified">2186 void os::Linux::print_virtualization_info(outputStream* st) {</span>
<span class="line-modified">2187 #if defined(S390)</span>
<span class="line-modified">2188   // /proc/sysinfo contains interesting information about</span>
<span class="line-modified">2189   // - LPAR</span>
<span class="line-removed">2190   // - whole &quot;Box&quot; (CPUs )</span>
<span class="line-removed">2191   // - z/VM / KVM (VM&lt;nn&gt;); this is not available in an LPAR-only setup</span>
<span class="line-removed">2192   const char* kw[] = { &quot;LPAR&quot;, &quot;CPUs&quot;, &quot;VM&quot;, NULL };</span>
<span class="line-removed">2193   const char* info_file = &quot;/proc/sysinfo&quot;;</span>
2194 
<span class="line-modified">2195   if (!print_matching_lines_from_file(info_file, st, kw)) {</span>
<span class="line-modified">2196     st-&gt;print_cr(&quot;  &lt;%s Not Available&gt;&quot;, info_file);</span>
<span class="line-modified">2197   }</span>
<span class="line-modified">2198 #elif defined(PPC64)</span>
<span class="line-modified">2199   const char* info_file = &quot;/proc/ppc64/lparcfg&quot;;</span>
<span class="line-modified">2200   const char* kw[] = { &quot;system_type=&quot;, // qemu indicates PowerKVM</span>
<span class="line-modified">2201                        &quot;partition_entitled_capacity=&quot;, // entitled processor capacity percentage</span>
<span class="line-modified">2202                        &quot;partition_max_entitled_capacity=&quot;,</span>
<span class="line-modified">2203                        &quot;capacity_weight=&quot;, // partition CPU weight</span>
<span class="line-modified">2204                        &quot;partition_active_processors=&quot;,</span>
<span class="line-removed">2205                        &quot;partition_potential_processors=&quot;,</span>
<span class="line-removed">2206                        &quot;entitled_proc_capacity_available=&quot;,</span>
<span class="line-removed">2207                        &quot;capped=&quot;, // 0 - uncapped, 1 - vcpus capped at entitled processor capacity percentage</span>
<span class="line-removed">2208                        &quot;shared_processor_mode=&quot;, // (non)dedicated partition</span>
<span class="line-removed">2209                        &quot;system_potential_processors=&quot;,</span>
<span class="line-removed">2210                        &quot;pool=&quot;, // CPU-pool number</span>
<span class="line-removed">2211                        &quot;pool_capacity=&quot;,</span>
<span class="line-removed">2212                        &quot;NumLpars=&quot;, // on non-KVM machines, NumLpars is not found for full partition mode machines</span>
<span class="line-removed">2213                        NULL };</span>
<span class="line-removed">2214   if (!print_matching_lines_from_file(info_file, st, kw)) {</span>
<span class="line-removed">2215     st-&gt;print_cr(&quot;  &lt;%s Not Available&gt;&quot;, info_file);</span>
2216   }
<span class="line-removed">2217 #endif</span>
2218 }
2219 
2220 void os::print_memory_info(outputStream* st) {
2221 
2222   st-&gt;print(&quot;Memory:&quot;);
2223   st-&gt;print(&quot; %dk page&quot;, os::vm_page_size()&gt;&gt;10);
2224 
2225   // values in struct sysinfo are &quot;unsigned long&quot;
2226   struct sysinfo si;
2227   sysinfo(&amp;si);
2228 
2229   st-&gt;print(&quot;, physical &quot; UINT64_FORMAT &quot;k&quot;,
2230             os::physical_memory() &gt;&gt; 10);
2231   st-&gt;print(&quot;(&quot; UINT64_FORMAT &quot;k free)&quot;,
2232             os::available_memory() &gt;&gt; 10);
2233   st-&gt;print(&quot;, swap &quot; UINT64_FORMAT &quot;k&quot;,
2234             ((jlong)si.totalswap * si.mem_unit) &gt;&gt; 10);
2235   st-&gt;print(&quot;(&quot; UINT64_FORMAT &quot;k free)&quot;,
2236             ((jlong)si.freeswap * si.mem_unit) &gt;&gt; 10);
2237   st-&gt;cr();
</pre>
<hr />
<pre>
2275   return false;
2276 }
2277 
2278 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
2279   // Only print the model name if the platform provides this as a summary
2280   if (!print_model_name_and_flags(st, buf, buflen)) {
2281     st-&gt;print(&quot;\n/proc/cpuinfo:\n&quot;);
2282     if (!_print_ascii_file(&quot;/proc/cpuinfo&quot;, st)) {
2283       st-&gt;print_cr(&quot;  &lt;Not Available&gt;&quot;);
2284     }
2285   }
2286 }
2287 
2288 #if defined(AMD64) || defined(IA32) || defined(X32)
2289 const char* search_string = &quot;model name&quot;;
2290 #elif defined(M68K)
2291 const char* search_string = &quot;CPU&quot;;
2292 #elif defined(PPC64)
2293 const char* search_string = &quot;cpu&quot;;
2294 #elif defined(S390)
<span class="line-modified">2295 const char* search_string = &quot;processor&quot;;</span>
2296 #elif defined(SPARC)
2297 const char* search_string = &quot;cpu&quot;;
2298 #else
2299 const char* search_string = &quot;Processor&quot;;
2300 #endif
2301 
2302 // Parses the cpuinfo file for string representing the model name.
2303 void os::get_summary_cpu_info(char* cpuinfo, size_t length) {
2304   FILE* fp = fopen(&quot;/proc/cpuinfo&quot;, &quot;r&quot;);
2305   if (fp != NULL) {
2306     while (!feof(fp)) {
2307       char buf[256];
2308       if (fgets(buf, sizeof(buf), fp)) {
2309         char* start = strstr(buf, search_string);
2310         if (start != NULL) {
2311           char *ptr = start + strlen(search_string);
2312           char *end = buf + strlen(buf);
2313           while (ptr != end) {
2314              // skip whitespace and colon for the rest of the name.
2315              if (*ptr != &#39; &#39; &amp;&amp; *ptr != &#39;\t&#39; &amp;&amp; *ptr != &#39;:&#39;) {
</pre>
<hr />
<pre>
2461         }
2462       }
2463     }
2464   }
2465 
2466   strncpy(saved_jvm_path, buf, MAXPATHLEN);
2467   saved_jvm_path[MAXPATHLEN - 1] = &#39;\0&#39;;
2468 }
2469 
2470 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
2471   // no prefix required, not even &quot;_&quot;
2472 }
2473 
2474 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
2475   // no suffix required
2476 }
2477 
2478 ////////////////////////////////////////////////////////////////////////////////
2479 // sun.misc.Signal support
2480 
<span class="line-removed">2481 static volatile jint sigint_count = 0;</span>
<span class="line-removed">2482 </span>
2483 static void UserHandler(int sig, void *siginfo, void *context) {
<span class="line-removed">2484   // 4511530 - sem_post is serialized and handled by the manager thread. When</span>
<span class="line-removed">2485   // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We</span>
<span class="line-removed">2486   // don&#39;t want to flood the manager thread with sem_post requests.</span>
<span class="line-removed">2487   if (sig == SIGINT &amp;&amp; Atomic::add(1, &amp;sigint_count) &gt; 1) {</span>
<span class="line-removed">2488     return;</span>
<span class="line-removed">2489   }</span>
<span class="line-removed">2490 </span>
2491   // Ctrl-C is pressed during error reporting, likely because the error
2492   // handler fails to abort. Let VM die immediately.
2493   if (sig == SIGINT &amp;&amp; VMError::is_error_reported()) {
2494     os::die();
2495   }
2496 
2497   os::signal_notify(sig);
2498 }
2499 
2500 void* os::user_handler() {
2501   return CAST_FROM_FN_PTR(void*, UserHandler);
2502 }
2503 
2504 extern &quot;C&quot; {
2505   typedef void (*sa_handler_t)(int);
2506   typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);
2507 }
2508 
2509 void* os::signal(int signal_number, void* handler) {
2510   struct sigaction sigAct, oldSigAct;
</pre>
<hr />
<pre>
2543 static void jdk_misc_signal_init() {
2544   // Initialize signal structures
2545   ::memset((void*)pending_signals, 0, sizeof(pending_signals));
2546 
2547   // Initialize signal semaphore
2548   sig_sem = new Semaphore();
2549 }
2550 
2551 void os::signal_notify(int sig) {
2552   if (sig_sem != NULL) {
2553     Atomic::inc(&amp;pending_signals[sig]);
2554     sig_sem-&gt;signal();
2555   } else {
2556     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
2557     // initialization isn&#39;t called.
2558     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
2559   }
2560 }
2561 
2562 static int check_pending_signals() {
<span class="line-removed">2563   Atomic::store(0, &amp;sigint_count);</span>
2564   for (;;) {
2565     for (int i = 0; i &lt; NSIG + 1; i++) {
2566       jint n = pending_signals[i];
<span class="line-modified">2567       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(n - 1, &amp;pending_signals[i], n)) {</span>
2568         return i;
2569       }
2570     }
2571     JavaThread *thread = JavaThread::current();
2572     ThreadBlockInVM tbivm(thread);
2573 
2574     bool threadIsSuspended;
2575     do {
2576       thread-&gt;set_suspend_equivalent();
2577       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
2578       sig_sem-&gt;wait();
2579 
2580       // were we externally suspended while we were waiting?
2581       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
2582       if (threadIsSuspended) {
2583         // The semaphore has been incremented, but while we were waiting
2584         // another thread suspended us. We don&#39;t want to continue running
2585         // while suspended because that would surprise the thread that
2586         // suspended us.
2587         sig_sem-&gt;signal();
</pre>
<hr />
<pre>
2608 // Solaris allocates memory by pages.
2609 int os::vm_allocation_granularity() {
2610   assert(os::Linux::page_size() != -1, &quot;must call os::init&quot;);
2611   return os::Linux::page_size();
2612 }
2613 
2614 // Rationale behind this function:
2615 //  current (Mon Apr 25 20:12:18 MSD 2005) oprofile drops samples without executable
2616 //  mapping for address (see lookup_dcookie() in the kernel module), thus we cannot get
2617 //  samples for JITted code. Here we create private executable mapping over the code cache
2618 //  and then we can use standard (well, almost, as mapping can change) way to provide
2619 //  info for the reporting script by storing timestamp and location of symbol
2620 void linux_wrap_code(char* base, size_t size) {
2621   static volatile jint cnt = 0;
2622 
2623   if (!UseOprofile) {
2624     return;
2625   }
2626 
2627   char buf[PATH_MAX+1];
<span class="line-modified">2628   int num = Atomic::add(1, &amp;cnt);</span>
2629 
2630   snprintf(buf, sizeof(buf), &quot;%s/hs-vm-%d-%d&quot;,
2631            os::get_temp_directory(), os::current_process_id(), num);
2632   unlink(buf);
2633 
2634   int fd = ::open(buf, O_CREAT | O_RDWR, S_IRWXU);
2635 
2636   if (fd != -1) {
2637     off_t rv = ::lseek(fd, size-2, SEEK_SET);
2638     if (rv != (off_t)-1) {
2639       if (::write(fd, &quot;&quot;, 1) == 1) {
2640         mmap(base, size,
2641              PROT_READ|PROT_WRITE|PROT_EXEC,
2642              MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);
2643       }
2644     }
2645     ::close(fd);
2646     unlink(buf);
2647   }
2648 }
</pre>
<hr />
<pre>
2802 
2803 bool os::numa_topology_changed() { return false; }
2804 
2805 size_t os::numa_get_groups_num() {
2806   // Return just the number of nodes in which it&#39;s possible to allocate memory
2807   // (in numa terminology, configured nodes).
2808   return Linux::numa_num_configured_nodes();
2809 }
2810 
2811 int os::numa_get_group_id() {
2812   int cpu_id = Linux::sched_getcpu();
2813   if (cpu_id != -1) {
2814     int lgrp_id = Linux::get_node_by_cpu(cpu_id);
2815     if (lgrp_id != -1) {
2816       return lgrp_id;
2817     }
2818   }
2819   return 0;
2820 }
2821 













2822 int os::Linux::get_existing_num_nodes() {
2823   int node;
2824   int highest_node_number = Linux::numa_max_node();
2825   int num_nodes = 0;
2826 
2827   // Get the total number of nodes in the system including nodes without memory.
2828   for (node = 0; node &lt;= highest_node_number; node++) {
2829     if (is_node_in_existing_nodes(node)) {
2830       num_nodes++;
2831     }
2832   }
2833   return num_nodes;
2834 }
2835 
2836 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
2837   int highest_node_number = Linux::numa_max_node();
2838   size_t i = 0;
2839 
2840   // Map all node ids in which it is possible to allocate memory. Also nodes are
2841   // not always consecutively available, i.e. available from 0 to the highest
</pre>
<hr />
<pre>
2930       set_numa_num_configured_nodes(CAST_TO_FN_PTR(numa_num_configured_nodes_func_t,
2931                                                    libnuma_dlsym(handle, &quot;numa_num_configured_nodes&quot;)));
2932       set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,
2933                                         libnuma_dlsym(handle, &quot;numa_available&quot;)));
2934       set_numa_tonode_memory(CAST_TO_FN_PTR(numa_tonode_memory_func_t,
2935                                             libnuma_dlsym(handle, &quot;numa_tonode_memory&quot;)));
2936       set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,
2937                                                 libnuma_dlsym(handle, &quot;numa_interleave_memory&quot;)));
2938       set_numa_interleave_memory_v2(CAST_TO_FN_PTR(numa_interleave_memory_v2_func_t,
2939                                                 libnuma_v2_dlsym(handle, &quot;numa_interleave_memory&quot;)));
2940       set_numa_set_bind_policy(CAST_TO_FN_PTR(numa_set_bind_policy_func_t,
2941                                               libnuma_dlsym(handle, &quot;numa_set_bind_policy&quot;)));
2942       set_numa_bitmask_isbitset(CAST_TO_FN_PTR(numa_bitmask_isbitset_func_t,
2943                                                libnuma_dlsym(handle, &quot;numa_bitmask_isbitset&quot;)));
2944       set_numa_distance(CAST_TO_FN_PTR(numa_distance_func_t,
2945                                        libnuma_dlsym(handle, &quot;numa_distance&quot;)));
2946       set_numa_get_membind(CAST_TO_FN_PTR(numa_get_membind_func_t,
2947                                           libnuma_v2_dlsym(handle, &quot;numa_get_membind&quot;)));
2948       set_numa_get_interleave_mask(CAST_TO_FN_PTR(numa_get_interleave_mask_func_t,
2949                                                   libnuma_v2_dlsym(handle, &quot;numa_get_interleave_mask&quot;)));




2950 
2951       if (numa_available() != -1) {
2952         set_numa_all_nodes((unsigned long*)libnuma_dlsym(handle, &quot;numa_all_nodes&quot;));
2953         set_numa_all_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_all_nodes_ptr&quot;));
2954         set_numa_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_nodes_ptr&quot;));
2955         set_numa_interleave_bitmask(_numa_get_interleave_mask());
2956         set_numa_membind_bitmask(_numa_get_membind());
2957         // Create an index -&gt; node mapping, since nodes are not always consecutive
2958         _nindex_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;int&gt;(0, true);
2959         rebuild_nindex_to_node_map();
2960         // Create a cpu -&gt; node mapping
2961         _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;int&gt;(0, true);
2962         rebuild_cpu_to_node_map();
2963         return true;
2964       }
2965     }
2966   }
2967   return false;
2968 }
2969 
</pre>
<hr />
<pre>
3064     return cpu_to_node()-&gt;at(cpu_id);
3065   }
3066   return -1;
3067 }
3068 
3069 GrowableArray&lt;int&gt;* os::Linux::_cpu_to_node;
3070 GrowableArray&lt;int&gt;* os::Linux::_nindex_to_node;
3071 os::Linux::sched_getcpu_func_t os::Linux::_sched_getcpu;
3072 os::Linux::numa_node_to_cpus_func_t os::Linux::_numa_node_to_cpus;
3073 os::Linux::numa_max_node_func_t os::Linux::_numa_max_node;
3074 os::Linux::numa_num_configured_nodes_func_t os::Linux::_numa_num_configured_nodes;
3075 os::Linux::numa_available_func_t os::Linux::_numa_available;
3076 os::Linux::numa_tonode_memory_func_t os::Linux::_numa_tonode_memory;
3077 os::Linux::numa_interleave_memory_func_t os::Linux::_numa_interleave_memory;
3078 os::Linux::numa_interleave_memory_v2_func_t os::Linux::_numa_interleave_memory_v2;
3079 os::Linux::numa_set_bind_policy_func_t os::Linux::_numa_set_bind_policy;
3080 os::Linux::numa_bitmask_isbitset_func_t os::Linux::_numa_bitmask_isbitset;
3081 os::Linux::numa_distance_func_t os::Linux::_numa_distance;
3082 os::Linux::numa_get_membind_func_t os::Linux::_numa_get_membind;
3083 os::Linux::numa_get_interleave_mask_func_t os::Linux::_numa_get_interleave_mask;


3084 os::Linux::NumaAllocationPolicy os::Linux::_current_numa_policy;
3085 unsigned long* os::Linux::_numa_all_nodes;
3086 struct bitmask* os::Linux::_numa_all_nodes_ptr;
3087 struct bitmask* os::Linux::_numa_nodes_ptr;
3088 struct bitmask* os::Linux::_numa_interleave_bitmask;
3089 struct bitmask* os::Linux::_numa_membind_bitmask;
3090 
3091 bool os::pd_uncommit_memory(char* addr, size_t size) {
3092   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
3093                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
3094   return res  != (uintptr_t) MAP_FAILED;
3095 }
3096 
3097 static address get_stack_commited_bottom(address bottom, size_t size) {
3098   address nbot = bottom;
3099   address ntop = bottom + size;
3100 
3101   size_t page_sz = os::vm_page_size();
3102   unsigned pages = size / page_sz;
3103 
</pre>
<hr />
<pre>
3351                             size_t alignment_hint) {
3352   return anon_mmap(requested_addr, bytes, (requested_addr != NULL));
3353 }
3354 
3355 bool os::pd_release_memory(char* addr, size_t size) {
3356   return anon_munmap(addr, size);
3357 }
3358 
3359 static bool linux_mprotect(char* addr, size_t size, int prot) {
3360   // Linux wants the mprotect address argument to be page aligned.
3361   char* bottom = (char*)align_down((intptr_t)addr, os::Linux::page_size());
3362 
3363   // According to SUSv3, mprotect() should only be used with mappings
3364   // established by mmap(), and mmap() always maps whole pages. Unaligned
3365   // &#39;addr&#39; likely indicates problem in the VM (e.g. trying to change
3366   // protection of malloc&#39;ed or statically allocated memory). Check the
3367   // caller if you hit this assert.
3368   assert(addr == bottom, &quot;sanity check&quot;);
3369 
3370   size = align_up(pointer_delta(addr, bottom, 1) + size, os::Linux::page_size());

3371   return ::mprotect(bottom, size, prot) == 0;
3372 }
3373 
3374 // Set protections specified
3375 bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
3376                         bool is_committed) {
3377   unsigned int p = 0;
3378   switch (prot) {
3379   case MEM_PROT_NONE: p = PROT_NONE; break;
3380   case MEM_PROT_READ: p = PROT_READ; break;
3381   case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;
3382   case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;
3383   default:
3384     ShouldNotReachHere();
3385   }
3386   // is_committed is unused.
3387   return linux_mprotect(addr, bytes, p);
3388 }
3389 
3390 bool os::guard_memory(char* addr, size_t size) {
</pre>
<hr />
<pre>
3989 
3990 bool os::can_execute_large_page_memory() {
3991   return UseTransparentHugePages || UseHugeTLBFS;
3992 }
3993 
3994 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
3995   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
3996   char* result = pd_attempt_reserve_memory_at(bytes, requested_addr);
3997   if (result != NULL) {
3998     if (replace_existing_mapping_with_file_mapping(result, bytes, file_desc) == NULL) {
3999       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
4000     }
4001   }
4002   return result;
4003 }
4004 
4005 // Reserve memory at an arbitrary address, only if that area is
4006 // available (and not reserved for something else).
4007 
4008 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
<span class="line-removed">4009   const int max_tries = 10;</span>
<span class="line-removed">4010   char* base[max_tries];</span>
<span class="line-removed">4011   size_t size[max_tries];</span>
<span class="line-removed">4012   const size_t gap = 0x000000;</span>
<span class="line-removed">4013 </span>
4014   // Assert only that the size is a multiple of the page size, since
4015   // that&#39;s all that mmap requires, and since that&#39;s all we really know
4016   // about at this low abstraction level.  If we need higher alignment,
4017   // we can either pass an alignment to this method or verify alignment
4018   // in one of the methods further up the call chain.  See bug 5044738.
4019   assert(bytes % os::vm_page_size() == 0, &quot;reserving unexpected size block&quot;);
4020 
4021   // Repeatedly allocate blocks until the block is allocated at the
4022   // right spot.
4023 
4024   // Linux mmap allows caller to pass an address as hint; give it a try first,
4025   // if kernel honors the hint then we can return immediately.
4026   char * addr = anon_mmap(requested_addr, bytes, false);
4027   if (addr == requested_addr) {
4028     return requested_addr;
4029   }
4030 
4031   if (addr != NULL) {
4032     // mmap() is successful but it fails to reserve at the requested address
4033     anon_munmap(addr, bytes);
4034   }
4035 
<span class="line-modified">4036   int i;</span>
<span class="line-removed">4037   for (i = 0; i &lt; max_tries; ++i) {</span>
<span class="line-removed">4038     base[i] = reserve_memory(bytes);</span>
<span class="line-removed">4039 </span>
<span class="line-removed">4040     if (base[i] != NULL) {</span>
<span class="line-removed">4041       // Is this the block we wanted?</span>
<span class="line-removed">4042       if (base[i] == requested_addr) {</span>
<span class="line-removed">4043         size[i] = bytes;</span>
<span class="line-removed">4044         break;</span>
<span class="line-removed">4045       }</span>
<span class="line-removed">4046 </span>
<span class="line-removed">4047       // Does this overlap the block we wanted? Give back the overlapped</span>
<span class="line-removed">4048       // parts and try again.</span>
<span class="line-removed">4049 </span>
<span class="line-removed">4050       ptrdiff_t top_overlap = requested_addr + (bytes + gap) - base[i];</span>
<span class="line-removed">4051       if (top_overlap &gt;= 0 &amp;&amp; (size_t)top_overlap &lt; bytes) {</span>
<span class="line-removed">4052         unmap_memory(base[i], top_overlap);</span>
<span class="line-removed">4053         base[i] += top_overlap;</span>
<span class="line-removed">4054         size[i] = bytes - top_overlap;</span>
<span class="line-removed">4055       } else {</span>
<span class="line-removed">4056         ptrdiff_t bottom_overlap = base[i] + bytes - requested_addr;</span>
<span class="line-removed">4057         if (bottom_overlap &gt;= 0 &amp;&amp; (size_t)bottom_overlap &lt; bytes) {</span>
<span class="line-removed">4058           unmap_memory(requested_addr, bottom_overlap);</span>
<span class="line-removed">4059           size[i] = bytes - bottom_overlap;</span>
<span class="line-removed">4060         } else {</span>
<span class="line-removed">4061           size[i] = bytes;</span>
<span class="line-removed">4062         }</span>
<span class="line-removed">4063       }</span>
<span class="line-removed">4064     }</span>
<span class="line-removed">4065   }</span>
<span class="line-removed">4066 </span>
<span class="line-removed">4067   // Give back the unused reserved pieces.</span>
<span class="line-removed">4068 </span>
<span class="line-removed">4069   for (int j = 0; j &lt; i; ++j) {</span>
<span class="line-removed">4070     if (base[j] != NULL) {</span>
<span class="line-removed">4071       unmap_memory(base[j], size[j]);</span>
<span class="line-removed">4072     }</span>
<span class="line-removed">4073   }</span>
<span class="line-removed">4074 </span>
<span class="line-removed">4075   if (i &lt; max_tries) {</span>
<span class="line-removed">4076     return requested_addr;</span>
<span class="line-removed">4077   } else {</span>
<span class="line-removed">4078     return NULL;</span>
<span class="line-removed">4079   }</span>
4080 }
4081 
4082 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
4083 void os::infinite_sleep() {
4084   while (true) {    // sleep forever ...
4085     ::sleep(100);   // ... 100 seconds at a time
4086   }
4087 }
4088 
4089 // Used to convert frequent JVM_Yield() to nops
4090 bool os::dont_yield() {
4091   return DontYieldALot;
4092 }
4093 
4094 // Linux CFS scheduler (since 2.6.23) does not guarantee sched_yield(2) will
4095 // actually give up the CPU. Since skip buddy (v2.6.28):
4096 //
4097 // * Sets the yielding task as skip buddy for current CPU&#39;s run queue.
4098 // * Picks next from run queue, if empty, picks a skip buddy (can be the yielding task).
4099 // * Clears skip buddies for this run queue (yielding task no longer a skip buddy).
</pre>
<hr />
<pre>
4631     set_signal_handler(SIGSEGV, true);
4632     set_signal_handler(SIGPIPE, true);
4633     set_signal_handler(SIGBUS, true);
4634     set_signal_handler(SIGILL, true);
4635     set_signal_handler(SIGFPE, true);
4636 #if defined(PPC64)
4637     set_signal_handler(SIGTRAP, true);
4638 #endif
4639     set_signal_handler(SIGXFSZ, true);
4640 
4641     if (libjsig_is_loaded) {
4642       // Tell libjsig jvm finishes setting signal handlers
4643       (*end_signal_setting)();
4644     }
4645 
4646     // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
4647     // and if UserSignalHandler is installed all bets are off.
4648     // Log that signal checking is off only if -verbose:jni is specified.
4649     if (CheckJNICalls) {
4650       if (libjsig_is_loaded) {
<span class="line-modified">4651         if (PrintJNIResolving) {</span>
<span class="line-removed">4652           tty-&gt;print_cr(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>
<span class="line-removed">4653         }</span>
4654         check_signals = false;
4655       }
4656       if (AllowUserSignalHandlers) {
<span class="line-modified">4657         if (PrintJNIResolving) {</span>
<span class="line-removed">4658           tty-&gt;print_cr(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>
<span class="line-removed">4659         }</span>
4660         check_signals = false;
4661       }
4662     }
4663   }
4664 }
4665 
4666 // This is the fastest way to get thread cpu time on Linux.
4667 // Returns cpu time (user+sys) for any thread, not only for current.
4668 // POSIX compliant clocks are implemented in the kernels 2.6.16+.
4669 // It might work on 2.6.10+ with a special kernel/glibc patch.
4670 // For reference, please, see IEEE Std 1003.1-2004:
4671 //   http://www.unix.org/single_unix_specification
4672 
4673 jlong os::Linux::fast_thread_cpu_time(clockid_t clockid) {
4674   struct timespec tp;
4675   int rc = os::Posix::clock_gettime(clockid, &amp;tp);
4676   assert(rc == 0, &quot;clock_gettime is expected to return 0 code&quot;);
4677 
4678   return (tp.tv_sec * NANOSECS_PER_SEC) + tp.tv_nsec;
4679 }
4680 
<span class="line-removed">4681 void os::Linux::initialize_os_info() {</span>
<span class="line-removed">4682   assert(_os_version == 0, &quot;OS info already initialized&quot;);</span>
<span class="line-removed">4683 </span>
<span class="line-removed">4684   struct utsname _uname;</span>
<span class="line-removed">4685 </span>
<span class="line-removed">4686   uint32_t major;</span>
<span class="line-removed">4687   uint32_t minor;</span>
<span class="line-removed">4688   uint32_t fix;</span>
<span class="line-removed">4689 </span>
<span class="line-removed">4690   int rc;</span>
<span class="line-removed">4691 </span>
<span class="line-removed">4692   // Kernel version is unknown if</span>
<span class="line-removed">4693   // verification below fails.</span>
<span class="line-removed">4694   _os_version = 0x01000000;</span>
<span class="line-removed">4695 </span>
<span class="line-removed">4696   rc = uname(&amp;_uname);</span>
<span class="line-removed">4697   if (rc != -1) {</span>
<span class="line-removed">4698 </span>
<span class="line-removed">4699     rc = sscanf(_uname.release,&quot;%d.%d.%d&quot;, &amp;major, &amp;minor, &amp;fix);</span>
<span class="line-removed">4700     if (rc == 3) {</span>
<span class="line-removed">4701 </span>
<span class="line-removed">4702       if (major &lt; 256 &amp;&amp; minor &lt; 256 &amp;&amp; fix &lt; 256) {</span>
<span class="line-removed">4703         // Kernel version format is as expected,</span>
<span class="line-removed">4704         // set it overriding unknown state.</span>
<span class="line-removed">4705         _os_version = (major &lt;&lt; 16) |</span>
<span class="line-removed">4706                       (minor &lt;&lt; 8 ) |</span>
<span class="line-removed">4707                       (fix   &lt;&lt; 0 ) ;</span>
<span class="line-removed">4708       }</span>
<span class="line-removed">4709     }</span>
<span class="line-removed">4710   }</span>
<span class="line-removed">4711 }</span>
<span class="line-removed">4712 </span>
<span class="line-removed">4713 uint32_t os::Linux::os_version() {</span>
<span class="line-removed">4714   assert(_os_version != 0, &quot;not initialized&quot;);</span>
<span class="line-removed">4715   return _os_version &amp; 0x00FFFFFF;</span>
<span class="line-removed">4716 }</span>
<span class="line-removed">4717 </span>
<span class="line-removed">4718 bool os::Linux::os_version_is_known() {</span>
<span class="line-removed">4719   assert(_os_version != 0, &quot;not initialized&quot;);</span>
<span class="line-removed">4720   return _os_version &amp; 0x01000000 ? false : true;</span>
<span class="line-removed">4721 }</span>
<span class="line-removed">4722 </span>
4723 /////
4724 // glibc on Linux platform uses non-documented flag
4725 // to indicate, that some special sort of signal
4726 // trampoline is used.
4727 // We will never set this flag, and we should
4728 // ignore this flag in our diagnostic
4729 #ifdef SIGNIFICANT_SIGNAL_MASK
4730   #undef SIGNIFICANT_SIGNAL_MASK
4731 #endif
4732 #define SIGNIFICANT_SIGNAL_MASK (~0x04000000)
4733 
4734 static const char* get_signal_handler_name(address handler,
4735                                            char* buf, int buflen) {
4736   int offset = 0;
4737   bool found = os::dll_address_to_library_name(handler, buf, buflen, &amp;offset);
4738   if (found) {
4739     // skip directory names
4740     const char *p1, *p2;
4741     p1 = buf;
4742     size_t len = strlen(os::file_separator());
</pre>
<hr />
<pre>
4922 extern void report_error(char* file_name, int line_no, char* title,
4923                          char* format, ...);
4924 
4925 // this is called _before_ most of the global arguments have been parsed
4926 void os::init(void) {
4927   char dummy;   // used to get a guess on initial stack address
4928 
4929   clock_tics_per_sec = sysconf(_SC_CLK_TCK);
4930 
4931   init_random(1234567);
4932 
4933   Linux::set_page_size(sysconf(_SC_PAGESIZE));
4934   if (Linux::page_size() == -1) {
4935     fatal(&quot;os_linux.cpp: os::init: sysconf failed (%s)&quot;,
4936           os::strerror(errno));
4937   }
4938   init_page_sizes((size_t) Linux::page_size());
4939 
4940   Linux::initialize_system_info();
4941 
<span class="line-modified">4942   Linux::initialize_os_info();</span>







4943 
4944   // _main_thread points to the thread that created/loaded the JVM.
4945   Linux::_main_thread = pthread_self();
4946 
4947   // retrieve entry point for pthread_setname_np
4948   Linux::_pthread_setname_np =
4949     (int(*)(pthread_t, const char*))dlsym(RTLD_DEFAULT, &quot;pthread_setname_np&quot;);
4950 
4951   os::Posix::init();
4952 
4953   initial_time_count = javaTimeNanos();
4954 
4955   // Always warn if no monotonic clock available
4956   if (!os::Posix::supports_monotonic_clock()) {
4957     warning(&quot;No monotonic clock was available - timed services may &quot;    \
4958             &quot;be adversely affected if the time-of-day clock changes&quot;);
4959   }
4960 }
4961 
4962 // To install functions for atexit system call
</pre>
<hr />
<pre>
5045   // have to set it the same so we have to mirror Solaris.
5046   DEBUG_ONLY(os::set_mutex_init_done();)
5047 
5048   os::Posix::init_2();
5049 
5050   Linux::fast_thread_clock_init();
5051 
5052   // initialize suspend/resume support - must do this before signal_sets_init()
5053   if (SR_initialize() != 0) {
5054     perror(&quot;SR_initialize failed&quot;);
5055     return JNI_ERR;
5056   }
5057 
5058   Linux::signal_sets_init();
5059   Linux::install_signal_handlers();
5060   // Initialize data for jdk.internal.misc.Signal
5061   if (!ReduceSignalUsage) {
5062     jdk_misc_signal_init();
5063   }
5064 




5065   // Check and sets minimum stack sizes against command line options
5066   if (Posix::set_minimum_stack_sizes() == JNI_ERR) {
5067     return JNI_ERR;
5068   }
5069 






5070   suppress_primordial_thread_resolution = Arguments::created_by_java_launcher();
5071   if (!suppress_primordial_thread_resolution) {
5072     Linux::capture_initial_stack(JavaThread::stack_size_at_create());
5073   }
<span class="line-removed">5074 </span>
<span class="line-removed">5075 #if defined(IA32)</span>
<span class="line-removed">5076   workaround_expand_exec_shield_cs_limit();</span>
5077 #endif
5078 
5079   Linux::libpthread_init();
5080   Linux::sched_getcpu_init();
5081   log_info(os)(&quot;HotSpot is running with %s, %s&quot;,
5082                Linux::glibc_version(), Linux::libpthread_version());
5083 
5084   if (UseNUMA) {
5085     Linux::numa_init();
5086   }
5087 
5088   if (MaxFDLimit) {
5089     // set the number of file descriptors to max. print out error
5090     // if getrlimit/setrlimit fails but continue regardless.
5091     struct rlimit nbr_files;
5092     int status = getrlimit(RLIMIT_NOFILE, &amp;nbr_files);
5093     if (status != 0) {
5094       log_info(os)(&quot;os::init_2 getrlimit failed: %s&quot;, os::strerror(errno));
5095     } else {
5096       nbr_files.rlim_cur = nbr_files.rlim_max;
5097       status = setrlimit(RLIMIT_NOFILE, &amp;nbr_files);
5098       if (status != 0) {
5099         log_info(os)(&quot;os::init_2 setrlimit failed: %s&quot;, os::strerror(errno));
5100       }
5101     }
5102   }
5103 
<span class="line-removed">5104   // Initialize lock used to serialize thread creation (see os::create_thread)</span>
<span class="line-removed">5105   Linux::set_createThread_lock(new Mutex(Mutex::leaf, &quot;createThread_lock&quot;, false));</span>
<span class="line-removed">5106 </span>
5107   // at-exit methods are called in the reverse order of their registration.
5108   // atexit functions are called on return from main or as a result of a
5109   // call to exit(3C). There can be only 32 of these functions registered
5110   // and atexit() does not set errno.
5111 
5112   if (PerfAllowAtExitRegistration) {
5113     // only register atexit functions if PerfAllowAtExitRegistration is set.
5114     // atexit functions can be delayed until process exit time, which
5115     // can be problematic for embedded VM situations. Embedded VMs should
5116     // call DestroyJavaVM() to assure that VM resources are released.
5117 
5118     // note: perfMemory_exit_helper atexit function may be removed in
5119     // the future if the appropriate cleanup code can be added to the
5120     // VM_Exit VMOperation&#39;s doit method.
5121     if (atexit(perfMemory_exit_helper) != 0) {
5122       warning(&quot;os::init_2 atexit(perfMemory_exit_helper) failed&quot;);
5123     }
5124   }
5125 
5126   // initialize thread priority policy
</pre>
<hr />
<pre>
5287   return active_cpus;
5288 }
5289 
5290 uint os::processor_id() {
5291   const int id = Linux::sched_getcpu();
5292   assert(id &gt;= 0 &amp;&amp; id &lt; _processor_count, &quot;Invalid processor id&quot;);
5293   return (uint)id;
5294 }
5295 
5296 void os::set_native_thread_name(const char *name) {
5297   if (Linux::_pthread_setname_np) {
5298     char buf [16]; // according to glibc manpage, 16 chars incl. &#39;/0&#39;
5299     snprintf(buf, sizeof(buf), &quot;%s&quot;, name);
5300     buf[sizeof(buf) - 1] = &#39;\0&#39;;
5301     const int rc = Linux::_pthread_setname_np(pthread_self(), buf);
5302     // ERANGE should not happen; all other errors should just be ignored.
5303     assert(rc != ERANGE, &quot;pthread_setname_np failed&quot;);
5304   }
5305 }
5306 
<span class="line-removed">5307 bool os::distribute_processes(uint length, uint* distribution) {</span>
<span class="line-removed">5308   // Not yet implemented.</span>
<span class="line-removed">5309   return false;</span>
<span class="line-removed">5310 }</span>
<span class="line-removed">5311 </span>
5312 bool os::bind_to_processor(uint processor_id) {
5313   // Not yet implemented.
5314   return false;
5315 }
5316 
5317 ///
5318 
5319 void os::SuspendedThreadTask::internal_do_task() {
5320   if (do_suspend(_thread-&gt;osthread())) {
5321     SuspendedThreadTaskContext context(_thread, _thread-&gt;osthread()-&gt;ucontext());
5322     do_task(context);
5323     do_resume(_thread-&gt;osthread());
5324   }
5325 }
5326 
5327 ////////////////////////////////////////////////////////////////////////////////
5328 // debug support
5329 
5330 bool os::find(address addr, outputStream* st) {
5331   Dl_info dlinfo;
</pre>
<hr />
<pre>
6007 }
6008 #endif
6009 
6010 static inline struct timespec get_mtime(const char* filename) {
6011   struct stat st;
6012   int ret = os::stat(filename, &amp;st);
6013   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
6014   return st.st_mtim;
6015 }
6016 
6017 int os::compare_file_modified_times(const char* file1, const char* file2) {
6018   struct timespec filetime1 = get_mtime(file1);
6019   struct timespec filetime2 = get_mtime(file2);
6020   int diff = filetime1.tv_sec - filetime2.tv_sec;
6021   if (diff == 0) {
6022     return filetime1.tv_nsec - filetime2.tv_nsec;
6023   }
6024   return diff;
6025 }
6026 




6027 /////////////// Unit tests ///////////////
6028 
6029 #ifndef PRODUCT
6030 
6031 class TestReserveMemorySpecial : AllStatic {
6032  public:
6033   static void small_page_write(void* addr, size_t size) {
6034     size_t page_size = os::vm_page_size();
6035 
6036     char* end = (char*)addr + size;
6037     for (char* p = (char*)addr; p &lt; end; p += page_size) {
6038       *p = 1;
6039     }
6040   }
6041 
6042   static void test_reserve_memory_special_huge_tlbfs_only(size_t size) {
6043     if (!UseHugeTLBFS) {
6044       return;
6045     }
6046 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/filemap.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;os_linux.inline.hpp&quot;
  41 #include &quot;os_posix.inline.hpp&quot;
  42 #include &quot;os_share_linux.hpp&quot;
  43 #include &quot;osContainer_linux.hpp&quot;
  44 #include &quot;prims/jniFastGetField.hpp&quot;
  45 #include &quot;prims/jvm_misc.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/atomic.hpp&quot;
  48 #include &quot;runtime/extendedPC.hpp&quot;
  49 #include &quot;runtime/globals.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/init.hpp&quot;
  52 #include &quot;runtime/java.hpp&quot;
  53 #include &quot;runtime/javaCalls.hpp&quot;
  54 #include &quot;runtime/mutexLocker.hpp&quot;
  55 #include &quot;runtime/objectMonitor.hpp&quot;

  56 #include &quot;runtime/osThread.hpp&quot;
  57 #include &quot;runtime/perfMemory.hpp&quot;
  58 #include &quot;runtime/sharedRuntime.hpp&quot;
  59 #include &quot;runtime/statSampler.hpp&quot;
  60 #include &quot;runtime/stubRoutines.hpp&quot;
  61 #include &quot;runtime/thread.inline.hpp&quot;
  62 #include &quot;runtime/threadCritical.hpp&quot;
  63 #include &quot;runtime/threadSMR.hpp&quot;
  64 #include &quot;runtime/timer.hpp&quot;
<span class="line-added">  65 #include &quot;runtime/vm_version.hpp&quot;</span>
  66 #include &quot;semaphore_posix.hpp&quot;
  67 #include &quot;services/attachListener.hpp&quot;
  68 #include &quot;services/memTracker.hpp&quot;
  69 #include &quot;services/runtimeService.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/decoder.hpp&quot;
  72 #include &quot;utilities/defaultStream.hpp&quot;
  73 #include &quot;utilities/events.hpp&quot;
  74 #include &quot;utilities/elfFile.hpp&quot;
  75 #include &quot;utilities/growableArray.hpp&quot;
  76 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  77 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  78 #include &quot;utilities/vmError.hpp&quot;
  79 
  80 // put OS-includes here
  81 # include &lt;sys/types.h&gt;
  82 # include &lt;sys/mman.h&gt;
  83 # include &lt;sys/stat.h&gt;
  84 # include &lt;sys/select.h&gt;
  85 # include &lt;pthread.h&gt;
  86 # include &lt;signal.h&gt;
<span class="line-added">  87 # include &lt;endian.h&gt;</span>
  88 # include &lt;errno.h&gt;
  89 # include &lt;dlfcn.h&gt;
  90 # include &lt;stdio.h&gt;
  91 # include &lt;unistd.h&gt;
  92 # include &lt;sys/resource.h&gt;
  93 # include &lt;pthread.h&gt;
  94 # include &lt;sys/stat.h&gt;
  95 # include &lt;sys/time.h&gt;
  96 # include &lt;sys/times.h&gt;
  97 # include &lt;sys/utsname.h&gt;
  98 # include &lt;sys/socket.h&gt;
  99 # include &lt;sys/wait.h&gt;
 100 # include &lt;pwd.h&gt;
 101 # include &lt;poll.h&gt;
 102 # include &lt;fcntl.h&gt;
 103 # include &lt;string.h&gt;
 104 # include &lt;syscall.h&gt;
 105 # include &lt;sys/sysinfo.h&gt;
 106 # include &lt;gnu/libc-version.h&gt;
 107 # include &lt;sys/ipc.h&gt;
</pre>
<hr />
<pre>
 131 
 132 // for timer info max values which include all bits
 133 #define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)
 134 
 135 enum CoredumpFilterBit {
 136   FILE_BACKED_PVT_BIT = 1 &lt;&lt; 2,
 137   FILE_BACKED_SHARED_BIT = 1 &lt;&lt; 3,
 138   LARGEPAGES_BIT = 1 &lt;&lt; 6,
 139   DAX_SHARED_BIT = 1 &lt;&lt; 8
 140 };
 141 
 142 ////////////////////////////////////////////////////////////////////////////////
 143 // global variables
 144 julong os::Linux::_physical_memory = 0;
 145 
 146 address   os::Linux::_initial_thread_stack_bottom = NULL;
 147 uintptr_t os::Linux::_initial_thread_stack_size   = 0;
 148 
 149 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 150 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;

 151 pthread_t os::Linux::_main_thread;
 152 int os::Linux::_page_size = -1;
 153 bool os::Linux::_supports_fast_thread_cpu_time = false;

 154 const char * os::Linux::_glibc_version = NULL;
 155 const char * os::Linux::_libpthread_version = NULL;
 156 
 157 static jlong initial_time_count=0;
 158 
 159 static int clock_tics_per_sec = 100;
 160 
 161 // If the VM might have been created on the primordial thread, we need to resolve the
 162 // primordial thread stack bounds and check if the current thread might be the
 163 // primordial thread in places. If we know that the primordial thread is never used,
 164 // such as when the VM was created by one of the standard java launchers, we can
 165 // avoid this
 166 static bool suppress_primordial_thread_resolution = false;
 167 
 168 // For diagnostics to print a message once. see run_periodic_checks
 169 static sigset_t check_signal_done;
 170 static bool check_signals = true;
 171 
 172 // Signal number used to suspend/resume a thread
 173 
</pre>
<hr />
<pre>
 210   return avail_mem;
 211 }
 212 
 213 julong os::physical_memory() {
 214   jlong phys_mem = 0;
 215   if (OSContainer::is_containerized()) {
 216     jlong mem_limit;
 217     if ((mem_limit = OSContainer::memory_limit_in_bytes()) &gt; 0) {
 218       log_trace(os)(&quot;total container memory: &quot; JLONG_FORMAT, mem_limit);
 219       return mem_limit;
 220     }
 221     log_debug(os, container)(&quot;container memory limit %s: &quot; JLONG_FORMAT &quot;, using host value&quot;,
 222                             mem_limit == OSCONTAINER_ERROR ? &quot;failed&quot; : &quot;unlimited&quot;, mem_limit);
 223   }
 224 
 225   phys_mem = Linux::physical_memory();
 226   log_trace(os)(&quot;total system memory: &quot; JLONG_FORMAT, phys_mem);
 227   return phys_mem;
 228 }
 229 
<span class="line-added"> 230 static uint64_t initial_total_ticks = 0;</span>
<span class="line-added"> 231 static uint64_t initial_steal_ticks = 0;</span>
<span class="line-added"> 232 static bool     has_initial_tick_info = false;</span>
<span class="line-added"> 233 </span>
<span class="line-added"> 234 static void next_line(FILE *f) {</span>
<span class="line-added"> 235   int c;</span>
<span class="line-added"> 236   do {</span>
<span class="line-added"> 237     c = fgetc(f);</span>
<span class="line-added"> 238   } while (c != &#39;\n&#39; &amp;&amp; c != EOF);</span>
<span class="line-added"> 239 }</span>
<span class="line-added"> 240 </span>
<span class="line-added"> 241 bool os::Linux::get_tick_information(CPUPerfTicks* pticks, int which_logical_cpu) {</span>
<span class="line-added"> 242   FILE*         fh;</span>
<span class="line-added"> 243   uint64_t      userTicks, niceTicks, systemTicks, idleTicks;</span>
<span class="line-added"> 244   // since at least kernel 2.6 : iowait: time waiting for I/O to complete</span>
<span class="line-added"> 245   // irq: time  servicing interrupts; softirq: time servicing softirqs</span>
<span class="line-added"> 246   uint64_t      iowTicks = 0, irqTicks = 0, sirqTicks= 0;</span>
<span class="line-added"> 247   // steal (since kernel 2.6.11): time spent in other OS when running in a virtualized environment</span>
<span class="line-added"> 248   uint64_t      stealTicks = 0;</span>
<span class="line-added"> 249   // guest (since kernel 2.6.24): time spent running a virtual CPU for guest OS under the</span>
<span class="line-added"> 250   // control of the Linux kernel</span>
<span class="line-added"> 251   uint64_t      guestNiceTicks = 0;</span>
<span class="line-added"> 252   int           logical_cpu = -1;</span>
<span class="line-added"> 253   const int     required_tickinfo_count = (which_logical_cpu == -1) ? 4 : 5;</span>
<span class="line-added"> 254   int           n;</span>
<span class="line-added"> 255 </span>
<span class="line-added"> 256   memset(pticks, 0, sizeof(CPUPerfTicks));</span>
<span class="line-added"> 257 </span>
<span class="line-added"> 258   if ((fh = fopen(&quot;/proc/stat&quot;, &quot;r&quot;)) == NULL) {</span>
<span class="line-added"> 259     return false;</span>
<span class="line-added"> 260   }</span>
<span class="line-added"> 261 </span>
<span class="line-added"> 262   if (which_logical_cpu == -1) {</span>
<span class="line-added"> 263     n = fscanf(fh, &quot;cpu &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-added"> 264             UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-added"> 265             UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;,</span>
<span class="line-added"> 266             &amp;userTicks, &amp;niceTicks, &amp;systemTicks, &amp;idleTicks,</span>
<span class="line-added"> 267             &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks,</span>
<span class="line-added"> 268             &amp;stealTicks, &amp;guestNiceTicks);</span>
<span class="line-added"> 269   } else {</span>
<span class="line-added"> 270     // Move to next line</span>
<span class="line-added"> 271     next_line(fh);</span>
<span class="line-added"> 272 </span>
<span class="line-added"> 273     // find the line for requested cpu faster to just iterate linefeeds?</span>
<span class="line-added"> 274     for (int i = 0; i &lt; which_logical_cpu; i++) {</span>
<span class="line-added"> 275       next_line(fh);</span>
<span class="line-added"> 276     }</span>
<span class="line-added"> 277 </span>
<span class="line-added"> 278     n = fscanf(fh, &quot;cpu%u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-added"> 279                UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-added"> 280                UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;,</span>
<span class="line-added"> 281                &amp;logical_cpu, &amp;userTicks, &amp;niceTicks,</span>
<span class="line-added"> 282                &amp;systemTicks, &amp;idleTicks, &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks,</span>
<span class="line-added"> 283                &amp;stealTicks, &amp;guestNiceTicks);</span>
<span class="line-added"> 284   }</span>
<span class="line-added"> 285 </span>
<span class="line-added"> 286   fclose(fh);</span>
<span class="line-added"> 287   if (n &lt; required_tickinfo_count || logical_cpu != which_logical_cpu) {</span>
<span class="line-added"> 288     return false;</span>
<span class="line-added"> 289   }</span>
<span class="line-added"> 290   pticks-&gt;used       = userTicks + niceTicks;</span>
<span class="line-added"> 291   pticks-&gt;usedKernel = systemTicks + irqTicks + sirqTicks;</span>
<span class="line-added"> 292   pticks-&gt;total      = userTicks + niceTicks + systemTicks + idleTicks +</span>
<span class="line-added"> 293                        iowTicks + irqTicks + sirqTicks + stealTicks + guestNiceTicks;</span>
<span class="line-added"> 294 </span>
<span class="line-added"> 295   if (n &gt; required_tickinfo_count + 3) {</span>
<span class="line-added"> 296     pticks-&gt;steal = stealTicks;</span>
<span class="line-added"> 297     pticks-&gt;has_steal_ticks = true;</span>
<span class="line-added"> 298   } else {</span>
<span class="line-added"> 299     pticks-&gt;steal = 0;</span>
<span class="line-added"> 300     pticks-&gt;has_steal_ticks = false;</span>
<span class="line-added"> 301   }</span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303   return true;</span>
<span class="line-added"> 304 }</span>
<span class="line-added"> 305 </span>
 306 // Return true if user is running as root.
 307 
 308 bool os::have_special_privileges() {
 309   static bool init = false;
 310   static bool privileges = false;
 311   if (!init) {
 312     privileges = (getuid() != geteuid()) || (getgid() != getegid());
 313     init = true;
 314   }
 315   return privileges;
 316 }
 317 
 318 
 319 #ifndef SYS_gettid
 320 // i386: 224, ia64: 1105, amd64: 186, sparc 143
 321   #ifdef __ia64__
 322     #define SYS_gettid 1105
 323   #else
 324     #ifdef __i386__
 325       #define SYS_gettid 224
</pre>
<hr />
<pre>
 409 #ifndef OVERRIDE_LIBPATH
 410   #if defined(AMD64) || (defined(_LP64) &amp;&amp; defined(SPARC)) || defined(PPC64) || defined(S390)
 411     #define DEFAULT_LIBPATH &quot;/usr/lib64:/lib64:/lib:/usr/lib&quot;
 412   #else
 413     #define DEFAULT_LIBPATH &quot;/lib:/usr/lib&quot;
 414   #endif
 415 #else
 416   #define DEFAULT_LIBPATH OVERRIDE_LIBPATH
 417 #endif
 418 
 419 // Base path of extensions installed on the system.
 420 #define SYS_EXT_DIR     &quot;/usr/java/packages&quot;
 421 #define EXTENSIONS_DIR  &quot;/lib/ext&quot;
 422 
 423   // Buffer that fits several sprintfs.
 424   // Note that the space for the colon and the trailing null are provided
 425   // by the nulls included by the sizeof operator.
 426   const size_t bufsize =
 427     MAX2((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
 428          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="line-modified"> 429   char *buf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 430 
 431   // sysclasspath, java_home, dll_dir
 432   {
 433     char *pslash;
 434     os::jvm_path(buf, bufsize);
 435 
 436     // Found the full path to libjvm.so.
 437     // Now cut the path to &lt;java_home&gt;/jre if we can.
 438     pslash = strrchr(buf, &#39;/&#39;);
 439     if (pslash != NULL) {
 440       *pslash = &#39;\0&#39;;            // Get rid of /libjvm.so.
 441     }
 442     pslash = strrchr(buf, &#39;/&#39;);
 443     if (pslash != NULL) {
 444       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 445     }
 446     Arguments::set_dll_dir(buf);
 447 
 448     if (pslash != NULL) {
 449       pslash = strrchr(buf, &#39;/&#39;);
</pre>
<hr />
<pre>
 458   }
 459 
 460   // Where to look for native libraries.
 461   //
 462   // Note: Due to a legacy implementation, most of the library path
 463   // is set in the launcher. This was to accomodate linking restrictions
 464   // on legacy Linux implementations (which are no longer supported).
 465   // Eventually, all the library path setting will be done here.
 466   //
 467   // However, to prevent the proliferation of improperly built native
 468   // libraries, the new path component /usr/java/packages is added here.
 469   // Eventually, all the library path setting will be done here.
 470   {
 471     // Get the user setting of LD_LIBRARY_PATH, and prepended it. It
 472     // should always exist (until the legacy problem cited above is
 473     // addressed).
 474     const char *v = ::getenv(&quot;LD_LIBRARY_PATH&quot;);
 475     const char *v_colon = &quot;:&quot;;
 476     if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
 477     // That&#39;s +1 for the colon and +1 for the trailing &#39;\0&#39;.
<span class="line-modified"> 478     char *ld_library_path = NEW_C_HEAP_ARRAY(char,</span>
<span class="line-modified"> 479                                              strlen(v) + 1 +</span>
<span class="line-modified"> 480                                              sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;) + sizeof(DEFAULT_LIBPATH) + 1,</span>
<span class="line-modified"> 481                                              mtInternal);</span>
 482     sprintf(ld_library_path, &quot;%s%s&quot; SYS_EXT_DIR &quot;/lib:&quot; DEFAULT_LIBPATH, v, v_colon);
 483     Arguments::set_library_path(ld_library_path);
 484     FREE_C_HEAP_ARRAY(char, ld_library_path);
 485   }
 486 
 487   // Extensions directories.
 488   sprintf(buf, &quot;%s&quot; EXTENSIONS_DIR &quot;:&quot; SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());
 489   Arguments::set_ext_dirs(buf);
 490 
 491   FREE_C_HEAP_ARRAY(char, buf);
 492 
 493 #undef DEFAULT_LIBPATH
 494 #undef SYS_EXT_DIR
 495 #undef EXTENSIONS_DIR
 496 }
 497 
 498 ////////////////////////////////////////////////////////////////////////////////
 499 // breakpoint support
 500 
 501 void os::breakpoint() {
</pre>
<hr />
<pre>
 703   // stack pointer, causing us to not alloca enough to reach &quot;bottom&quot;.
 704   sp = (address)&amp;sp;
 705 
 706   if (sp &gt; bottom) {
 707     size = sp - bottom;
 708     p = (volatile char *)alloca(size);
 709     assert(p != NULL &amp;&amp; p &lt;= (volatile char *)bottom, &quot;alloca problem?&quot;);
 710     p[0] = &#39;\0&#39;;
 711   }
 712 }
 713 
 714 void os::Linux::expand_stack_to(address bottom) {
 715   _expand_stack_to(bottom);
 716 }
 717 
 718 bool os::Linux::manually_expand_stack(JavaThread * t, address addr) {
 719   assert(t!=NULL, &quot;just checking&quot;);
 720   assert(t-&gt;osthread()-&gt;expanding_stack(), &quot;expand should be set&quot;);
 721   assert(t-&gt;stack_base() != NULL, &quot;stack_base was not initialized&quot;);
 722 
<span class="line-modified"> 723   if (t-&gt;is_in_usable_stack(addr)) {</span>
 724     sigset_t mask_all, old_sigset;
 725     sigfillset(&amp;mask_all);
 726     pthread_sigmask(SIG_SETMASK, &amp;mask_all, &amp;old_sigset);
 727     _expand_stack_to(addr);
 728     pthread_sigmask(SIG_SETMASK, &amp;old_sigset, NULL);
 729     return true;
 730   }
 731   return false;
 732 }
 733 
 734 //////////////////////////////////////////////////////////////////////////////
 735 // create new thread
 736 
 737 // Thread start routine for all newly created threads
 738 static void *thread_native_entry(Thread *thread) {
 739 
 740   thread-&gt;record_stack_base_and_size();
 741 
 742   // Try to randomize the cache line index of hot stack frames.
 743   // This helps when threads of the same stack traces evict each other&#39;s
</pre>
<hr />
<pre>
 755 
 756   osthread-&gt;set_thread_id(os::current_thread_id());
 757 
 758   log_info(os, thread)(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 759     os::current_thread_id(), (uintx) pthread_self());
 760 
 761   if (UseNUMA) {
 762     int lgrp_id = os::numa_get_group_id();
 763     if (lgrp_id != -1) {
 764       thread-&gt;set_lgrp_id(lgrp_id);
 765     }
 766   }
 767   // initialize signal mask for this thread
 768   os::Linux::hotspot_sigmask(thread);
 769 
 770   // initialize floating point control register
 771   os::Linux::init_thread_fpu_state();
 772 
 773   // handshaking with parent thread
 774   {
<span class="line-modified"> 775     MutexLocker ml(sync, Mutex::_no_safepoint_check_flag);</span>
 776 
 777     // notify parent thread
 778     osthread-&gt;set_state(INITIALIZED);
 779     sync-&gt;notify_all();
 780 
 781     // wait until os::start_thread()
 782     while (osthread-&gt;get_state() == INITIALIZED) {
<span class="line-modified"> 783       sync-&gt;wait_without_safepoint_check();</span>
 784     }
 785   }
 786 
 787   assert(osthread-&gt;pthread_id() != 0, &quot;pthread_id was not set as expected&quot;);
 788 
 789   // call one more level start routine
 790   thread-&gt;call_run();
 791 
 792   // Note: at this point the thread object may already have deleted itself.
 793   // Prevent dereferencing it from here on out.
 794   thread = NULL;
 795 
 796   log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 797     os::current_thread_id(), (uintx) pthread_self());
 798 
 799   return 0;
 800 }
 801 
<span class="line-added"> 802 // On Linux, glibc places static TLS blocks (for __thread variables) on</span>
<span class="line-added"> 803 // the thread stack. This decreases the stack size actually available</span>
<span class="line-added"> 804 // to threads.</span>
<span class="line-added"> 805 //</span>
<span class="line-added"> 806 // For large static TLS sizes, this may cause threads to malfunction due</span>
<span class="line-added"> 807 // to insufficient stack space. This is a well-known issue in glibc:</span>
<span class="line-added"> 808 // http://sourceware.org/bugzilla/show_bug.cgi?id=11787.</span>
<span class="line-added"> 809 //</span>
<span class="line-added"> 810 // As a workaround, we call a private but assumed-stable glibc function,</span>
<span class="line-added"> 811 // __pthread_get_minstack() to obtain the minstack size and derive the</span>
<span class="line-added"> 812 // static TLS size from it. We then increase the user requested stack</span>
<span class="line-added"> 813 // size by this TLS size.</span>
<span class="line-added"> 814 //</span>
<span class="line-added"> 815 // Due to compatibility concerns, this size adjustment is opt-in and</span>
<span class="line-added"> 816 // controlled via AdjustStackSizeForTLS.</span>
<span class="line-added"> 817 typedef size_t (*GetMinStack)(const pthread_attr_t *attr);</span>
<span class="line-added"> 818 </span>
<span class="line-added"> 819 GetMinStack _get_minstack_func = NULL;</span>
<span class="line-added"> 820 </span>
<span class="line-added"> 821 static void get_minstack_init() {</span>
<span class="line-added"> 822   _get_minstack_func =</span>
<span class="line-added"> 823         (GetMinStack)dlsym(RTLD_DEFAULT, &quot;__pthread_get_minstack&quot;);</span>
<span class="line-added"> 824   log_info(os, thread)(&quot;Lookup of __pthread_get_minstack %s&quot;,</span>
<span class="line-added"> 825                        _get_minstack_func == NULL ? &quot;failed&quot; : &quot;succeeded&quot;);</span>
<span class="line-added"> 826 }</span>
<span class="line-added"> 827 </span>
<span class="line-added"> 828 // Returns the size of the static TLS area glibc puts on thread stacks.</span>
<span class="line-added"> 829 // The value is cached on first use, which occurs when the first thread</span>
<span class="line-added"> 830 // is created during VM initialization.</span>
<span class="line-added"> 831 static size_t get_static_tls_area_size(const pthread_attr_t *attr) {</span>
<span class="line-added"> 832   size_t tls_size = 0;</span>
<span class="line-added"> 833   if (_get_minstack_func != NULL) {</span>
<span class="line-added"> 834     // Obtain the pthread minstack size by calling __pthread_get_minstack.</span>
<span class="line-added"> 835     size_t minstack_size = _get_minstack_func(attr);</span>
<span class="line-added"> 836 </span>
<span class="line-added"> 837     // Remove non-TLS area size included in minstack size returned</span>
<span class="line-added"> 838     // by __pthread_get_minstack() to get the static TLS size.</span>
<span class="line-added"> 839     // In glibc before 2.27, minstack size includes guard_size.</span>
<span class="line-added"> 840     // In glibc 2.27 and later, guard_size is automatically added</span>
<span class="line-added"> 841     // to the stack size by pthread_create and is no longer included</span>
<span class="line-added"> 842     // in minstack size. In both cases, the guard_size is taken into</span>
<span class="line-added"> 843     // account, so there is no need to adjust the result for that.</span>
<span class="line-added"> 844     //</span>
<span class="line-added"> 845     // Although __pthread_get_minstack() is a private glibc function,</span>
<span class="line-added"> 846     // it is expected to have a stable behavior across future glibc</span>
<span class="line-added"> 847     // versions while glibc still allocates the static TLS blocks off</span>
<span class="line-added"> 848     // the stack. Following is glibc 2.28 __pthread_get_minstack():</span>
<span class="line-added"> 849     //</span>
<span class="line-added"> 850     // size_t</span>
<span class="line-added"> 851     // __pthread_get_minstack (const pthread_attr_t *attr)</span>
<span class="line-added"> 852     // {</span>
<span class="line-added"> 853     //   return GLRO(dl_pagesize) + __static_tls_size + PTHREAD_STACK_MIN;</span>
<span class="line-added"> 854     // }</span>
<span class="line-added"> 855     //</span>
<span class="line-added"> 856     //</span>
<span class="line-added"> 857     // The following &#39;minstack_size &gt; os::vm_page_size() + PTHREAD_STACK_MIN&#39;</span>
<span class="line-added"> 858     // if check is done for precaution.</span>
<span class="line-added"> 859     if (minstack_size &gt; (size_t)os::vm_page_size() + PTHREAD_STACK_MIN) {</span>
<span class="line-added"> 860       tls_size = minstack_size - os::vm_page_size() - PTHREAD_STACK_MIN;</span>
<span class="line-added"> 861     }</span>
<span class="line-added"> 862   }</span>
<span class="line-added"> 863 </span>
<span class="line-added"> 864   log_info(os, thread)(&quot;Stack size adjustment for TLS is &quot; SIZE_FORMAT,</span>
<span class="line-added"> 865                        tls_size);</span>
<span class="line-added"> 866   return tls_size;</span>
<span class="line-added"> 867 }</span>
<span class="line-added"> 868 </span>
 869 bool os::create_thread(Thread* thread, ThreadType thr_type,
 870                        size_t req_stack_size) {
 871   assert(thread-&gt;osthread() == NULL, &quot;caller responsible&quot;);
 872 
 873   // Allocate the OSThread object
 874   OSThread* osthread = new OSThread(NULL, NULL);
 875   if (osthread == NULL) {
 876     return false;
 877   }
 878 
 879   // set the correct thread state
 880   osthread-&gt;set_thread_type(thr_type);
 881 
 882   // Initial state is ALLOCATED but not INITIALIZED
 883   osthread-&gt;set_state(ALLOCATED);
 884 
 885   thread-&gt;set_osthread(osthread);
 886 
 887   // init thread attributes
 888   pthread_attr_t attr;
 889   pthread_attr_init(&amp;attr);
 890   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
 891 
 892   // Calculate stack size if it&#39;s not specified by caller.
 893   size_t stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);
<span class="line-modified"> 894   // In glibc versions prior to 2.7 the guard size mechanism</span>
 895   // is not implemented properly. The posix standard requires adding
 896   // the size of the guard pages to the stack size, instead Linux
 897   // takes the space out of &#39;stacksize&#39;. Thus we adapt the requested
 898   // stack_size by the size of the guard pages to mimick proper
 899   // behaviour. However, be careful not to end up with a size
 900   // of zero due to overflow. Don&#39;t add the guard page in that case.
 901   size_t guard_size = os::Linux::default_guard_size(thr_type);
<span class="line-modified"> 902   // Configure glibc guard page. Must happen before calling</span>
<span class="line-modified"> 903   // get_static_tls_area_size(), which uses the guard_size.</span>
<span class="line-added"> 904   pthread_attr_setguardsize(&amp;attr, guard_size);</span>
<span class="line-added"> 905 </span>
<span class="line-added"> 906   size_t stack_adjust_size = 0;</span>
<span class="line-added"> 907   if (AdjustStackSizeForTLS) {</span>
<span class="line-added"> 908     // Adjust the stack_size for on-stack TLS - see get_static_tls_area_size().</span>
<span class="line-added"> 909     stack_adjust_size += get_static_tls_area_size(&amp;attr);</span>
<span class="line-added"> 910   } else {</span>
<span class="line-added"> 911     stack_adjust_size += guard_size;</span>
<span class="line-added"> 912   }</span>
<span class="line-added"> 913 </span>
<span class="line-added"> 914   stack_adjust_size = align_up(stack_adjust_size, os::vm_page_size());</span>
<span class="line-added"> 915   if (stack_size &lt;= SIZE_MAX - stack_adjust_size) {</span>
<span class="line-added"> 916     stack_size += stack_adjust_size;</span>
 917   }
 918   assert(is_aligned(stack_size, os::vm_page_size()), &quot;stack_size not aligned&quot;);
 919 
 920   int status = pthread_attr_setstacksize(&amp;attr, stack_size);
 921   assert_status(status == 0, status, &quot;pthread_attr_setstacksize&quot;);
 922 



 923   ThreadState state;
 924 
 925   {
 926     pthread_t tid;
 927     int ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) thread_native_entry, thread);
 928 
 929     char buf[64];
 930     if (ret == 0) {
 931       log_info(os, thread)(&quot;Thread started (pthread id: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
 932         (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
 933     } else {
 934       log_warning(os, thread)(&quot;Failed to start thread - pthread_create failed (%s) for attributes: %s.&quot;,
 935         os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
<span class="line-added"> 936       // Log some OS information which might explain why creating the thread failed.</span>
<span class="line-added"> 937       log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());</span>
<span class="line-added"> 938       LogStream st(Log(os, thread)::info());</span>
<span class="line-added"> 939       os::Posix::print_rlimit_info(&amp;st);</span>
<span class="line-added"> 940       os::print_memory_info(&amp;st);</span>
<span class="line-added"> 941       os::Linux::print_proc_sys_info(&amp;st);</span>
<span class="line-added"> 942       os::Linux::print_container_info(&amp;st);</span>
 943     }
 944 
 945     pthread_attr_destroy(&amp;attr);
 946 
 947     if (ret != 0) {
 948       // Need to clean up stuff we&#39;ve allocated so far
 949       thread-&gt;set_osthread(NULL);
 950       delete osthread;
 951       return false;
 952     }
 953 
 954     // Store pthread info into the OSThread
 955     osthread-&gt;set_pthread_id(tid);
 956 
 957     // Wait until child thread is either initialized or aborted
 958     {
 959       Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="line-modified"> 960       MutexLocker ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
 961       while ((state = osthread-&gt;get_state()) == ALLOCATED) {
<span class="line-modified"> 962         sync_with_child-&gt;wait_without_safepoint_check();</span>
 963       }
 964     }
 965   }
 966 
 967   // Aborted due to thread limit being reached
 968   if (state == ZOMBIE) {
 969     thread-&gt;set_osthread(NULL);
 970     delete osthread;
 971     return false;
 972   }
 973 
 974   // The thread is returned suspended (in state INITIALIZED),
 975   // and is started higher up in the call chain
 976   assert(state == INITIALIZED, &quot;race condition&quot;);
 977   return true;
 978 }
 979 
 980 /////////////////////////////////////////////////////////////////////////////
 981 // attach existing thread
 982 
</pre>
<hr />
<pre>
1034 
1035     osthread-&gt;set_expanding_stack();
1036     os::Linux::manually_expand_stack(jt, addr);
1037     osthread-&gt;clear_expanding_stack();
1038   }
1039 
1040   // initialize signal mask for this thread
1041   // and save the caller&#39;s signal mask
1042   os::Linux::hotspot_sigmask(thread);
1043 
1044   log_info(os, thread)(&quot;Thread attached (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
1045     os::current_thread_id(), (uintx) pthread_self());
1046 
1047   return true;
1048 }
1049 
1050 void os::pd_start_thread(Thread* thread) {
1051   OSThread * osthread = thread-&gt;osthread();
1052   assert(osthread-&gt;get_state() != INITIALIZED, &quot;just checking&quot;);
1053   Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="line-modified">1054   MutexLocker ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
1055   sync_with_child-&gt;notify();
1056 }
1057 
1058 // Free Linux resources related to the OSThread
1059 void os::free_thread(OSThread* osthread) {
1060   assert(osthread != NULL, &quot;osthread not set&quot;);
1061 
1062   // We are told to free resources of the argument thread,
1063   // but we can only really operate on the current thread.
1064   assert(Thread::current()-&gt;osthread() == osthread,
1065          &quot;os::free_thread but not current thread&quot;);
1066 
1067 #ifdef ASSERT
1068   sigset_t current;
1069   sigemptyset(&amp;current);
1070   pthread_sigmask(SIG_SETMASK, NULL, &amp;current);
1071   assert(!sigismember(&amp;current, SR_signum), &quot;SR signal should not be blocked!&quot;);
1072 #endif
1073 
1074   // Restore caller&#39;s signal mask
</pre>
<hr />
<pre>
1345 #ifndef SUPPORTS_CLOCK_MONOTONIC
1346 #error &quot;Build platform doesn&#39;t support clock_gettime and related functionality&quot;
1347 #endif
1348 
1349 // Time since start-up in seconds to a fine granularity.
1350 // Used by VMSelfDestructTimer and the MemProfiler.
1351 double os::elapsedTime() {
1352 
1353   return ((double)os::elapsed_counter()) / os::elapsed_frequency(); // nanosecond resolution
1354 }
1355 
1356 jlong os::elapsed_counter() {
1357   return javaTimeNanos() - initial_time_count;
1358 }
1359 
1360 jlong os::elapsed_frequency() {
1361   return NANOSECS_PER_SEC; // nanosecond resolution
1362 }
1363 
1364 bool os::supports_vtime() { return true; }


1365 
1366 double os::elapsedVTime() {
1367   struct rusage usage;
1368   int retval = getrusage(RUSAGE_THREAD, &amp;usage);
1369   if (retval == 0) {
1370     return (double) (usage.ru_utime.tv_sec + usage.ru_stime.tv_sec) + (double) (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) / (1000 * 1000);
1371   } else {
1372     // better than nothing, but not much
1373     return elapsedTime();
1374   }
1375 }
1376 
1377 jlong os::javaTimeMillis() {
1378   timeval time;
1379   int status = gettimeofday(&amp;time, NULL);
1380   assert(status != -1, &quot;linux error&quot;);
1381   return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec / 1000);
1382 }
1383 
1384 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
</pre>
<hr />
<pre>
1518   os::shutdown();
1519   if (dump_core) {
1520     if (DumpPrivateMappingsInCore) {
1521       ClassLoader::close_jrt_image();
1522     }
1523 #ifndef PRODUCT
1524     fdStream out(defaultStream::output_fd());
1525     out.print_raw(&quot;Current thread is &quot;);
1526     char buf[16];
1527     jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());
1528     out.print_raw_cr(buf);
1529     out.print_raw_cr(&quot;Dumping core ...&quot;);
1530 #endif
1531     ::abort(); // dump core
1532   }
1533 
1534   ::exit(1);
1535 }
1536 
1537 // Die immediately, no exit hook, no abort hook, no cleanup.
<span class="line-added">1538 // Dump a core file, if possible, for debugging.</span>
1539 void os::die() {
<span class="line-modified">1540   if (TestUnresponsiveErrorHandler &amp;&amp; !CreateCoredumpOnCrash) {</span>
<span class="line-added">1541     // For TimeoutInErrorHandlingTest.java, we just kill the VM</span>
<span class="line-added">1542     // and don&#39;t take the time to generate a core file.</span>
<span class="line-added">1543     os::signal_raise(SIGKILL);</span>
<span class="line-added">1544   } else {</span>
<span class="line-added">1545     ::abort();</span>
<span class="line-added">1546   }</span>
1547 }
1548 
1549 // thread_id is kernel thread id (similar to Solaris LWP id)
1550 intx os::current_thread_id() { return os::Linux::gettid(); }
1551 int os::current_process_id() {
1552   return ::getpid();
1553 }
1554 
1555 // DLL functions
1556 
1557 const char* os::dll_file_extension() { return &quot;.so&quot;; }
1558 
1559 // This must be hard coded because it&#39;s the system&#39;s temporary
1560 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1561 const char* os::get_temp_directory() { return &quot;/tmp&quot;; }
1562 
1563 static bool file_exists(const char* filename) {
1564   struct stat statbuf;
1565   if (filename == NULL || strlen(filename) == 0) {
1566     return false;
</pre>
<hr />
<pre>
1718  private:
1719   const char *_filename;
1720   char *_ebuf;
1721   int _ebuflen;
1722   void *_lib;
1723  public:
1724   VM_LinuxDllLoad(const char *fn, char *ebuf, int ebuflen) :
1725     _filename(fn), _ebuf(ebuf), _ebuflen(ebuflen), _lib(NULL) {}
1726   VMOp_Type type() const { return VMOp_LinuxDllLoad; }
1727   void doit() {
1728     _lib = os::Linux::dll_load_in_vmthread(_filename, _ebuf, _ebuflen);
1729     os::Linux::_stack_is_executable = true;
1730   }
1731   void* loaded_library() { return _lib; }
1732 };
1733 
1734 void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
1735   void * result = NULL;
1736   bool load_attempted = false;
1737 
<span class="line-added">1738   log_info(os)(&quot;attempting shared library load of %s&quot;, filename);</span>
<span class="line-added">1739 </span>
1740   // Check whether the library to load might change execution rights
1741   // of the stack. If they are changed, the protection of the stack
1742   // guard pages will be lost. We need a safepoint to fix this.
1743   //
1744   // See Linux man page execstack(8) for more info.
1745   if (os::uses_stack_guard_pages() &amp;&amp; !os::Linux::_stack_is_executable) {
1746     if (!ElfFile::specifies_noexecstack(filename)) {
1747       if (!is_init_completed()) {
1748         os::Linux::_stack_is_executable = true;
1749         // This is OK - No Java threads have been created yet, and hence no
1750         // stack guard pages to fix.
1751         //
1752         // Dynamic loader will make all stacks executable after
1753         // this function returns, and will not do that again.
1754         assert(Threads::number_of_threads() == 0, &quot;no Java threads should exist yet.&quot;);
1755       } else {
1756         warning(&quot;You have loaded library %s which might have disabled stack guard. &quot;
1757                 &quot;The VM will try to fix the stack guard now.\n&quot;
1758                 &quot;It&#39;s highly recommended that you fix the library with &quot;
1759                 &quot;&#39;execstack -c &lt;libfile&gt;&#39;, or link it with &#39;-z noexecstack&#39;.&quot;,
</pre>
<hr />
<pre>
1806   }
1807 
1808 
1809   int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);
1810 
1811   if (file_descriptor &lt; 0) {
1812     // Can&#39;t open library, report dlerror() message
1813     return NULL;
1814   }
1815 
1816   bool failed_to_read_elf_head=
1817     (sizeof(elf_head)!=
1818      (::read(file_descriptor, &amp;elf_head,sizeof(elf_head))));
1819 
1820   ::close(file_descriptor);
1821   if (failed_to_read_elf_head) {
1822     // file i/o error - report dlerror() msg
1823     return NULL;
1824   }
1825 
<span class="line-added">1826   if (elf_head.e_ident[EI_DATA] != LITTLE_ENDIAN_ONLY(ELFDATA2LSB) BIG_ENDIAN_ONLY(ELFDATA2MSB)) {</span>
<span class="line-added">1827     // handle invalid/out of range endianness values</span>
<span class="line-added">1828     if (elf_head.e_ident[EI_DATA] == 0 || elf_head.e_ident[EI_DATA] &gt; 2) {</span>
<span class="line-added">1829       return NULL;</span>
<span class="line-added">1830     }</span>
<span class="line-added">1831 </span>
<span class="line-added">1832 #if defined(VM_LITTLE_ENDIAN)</span>
<span class="line-added">1833     // VM is LE, shared object BE</span>
<span class="line-added">1834     elf_head.e_machine = be16toh(elf_head.e_machine);</span>
<span class="line-added">1835 #else</span>
<span class="line-added">1836     // VM is BE, shared object LE</span>
<span class="line-added">1837     elf_head.e_machine = le16toh(elf_head.e_machine);</span>
<span class="line-added">1838 #endif</span>
<span class="line-added">1839   }</span>
<span class="line-added">1840 </span>
1841   typedef struct {
1842     Elf32_Half    code;         // Actual value as defined in elf.h
1843     Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
1844     unsigned char elf_class;    // 32 or 64 bit
<span class="line-modified">1845     unsigned char endianness;   // MSB or LSB</span>
1846     char*         name;         // String representation
1847   } arch_t;
1848 
1849 #ifndef EM_486
1850   #define EM_486          6               /* Intel 80486 */
1851 #endif
1852 #ifndef EM_AARCH64
1853   #define EM_AARCH64    183               /* ARM AARCH64 */
1854 #endif
1855 
1856   static const arch_t arch_array[]={
1857     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1858     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1859     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1860     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
1861     {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1862     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1863     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
1864     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1865 #if defined(VM_LITTLE_ENDIAN)
1866     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;Power PC 64 LE&quot;},
1867     {EM_SH,          EM_SH,      ELFCLASS32, ELFDATA2LSB, (char*)&quot;SuperH&quot;},
1868 #else
1869     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)&quot;Power PC 64&quot;},
1870     {EM_SH,          EM_SH,      ELFCLASS32, ELFDATA2MSB, (char*)&quot;SuperH BE&quot;},
1871 #endif
<span class="line-modified">1872     {EM_ARM,         EM_ARM,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;ARM&quot;},</span>
<span class="line-modified">1873     // we only support 64 bit z architecture</span>
<span class="line-added">1874     {EM_S390,        EM_S390,    ELFCLASS64, ELFDATA2MSB, (char*)&quot;IBM System/390&quot;},</span>
1875     {EM_ALPHA,       EM_ALPHA,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;Alpha&quot;},
1876     {EM_MIPS_RS3_LE, EM_MIPS_RS3_LE, ELFCLASS32, ELFDATA2LSB, (char*)&quot;MIPSel&quot;},
1877     {EM_MIPS,        EM_MIPS,    ELFCLASS32, ELFDATA2MSB, (char*)&quot;MIPS&quot;},
1878     {EM_PARISC,      EM_PARISC,  ELFCLASS32, ELFDATA2MSB, (char*)&quot;PARISC&quot;},
1879     {EM_68K,         EM_68K,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;M68k&quot;},
1880     {EM_AARCH64,     EM_AARCH64, ELFCLASS64, ELFDATA2LSB, (char*)&quot;AARCH64&quot;},
1881   };
1882 
1883 #if  (defined IA32)
1884   static  Elf32_Half running_arch_code=EM_386;
1885 #elif   (defined AMD64) || (defined X32)
1886   static  Elf32_Half running_arch_code=EM_X86_64;
1887 #elif  (defined IA64)
1888   static  Elf32_Half running_arch_code=EM_IA_64;
1889 #elif  (defined __sparc) &amp;&amp; (defined _LP64)
1890   static  Elf32_Half running_arch_code=EM_SPARCV9;
1891 #elif  (defined __sparc) &amp;&amp; (!defined _LP64)
1892   static  Elf32_Half running_arch_code=EM_SPARC;
1893 #elif  (defined __powerpc64__)
1894   static  Elf32_Half running_arch_code=EM_PPC64;
</pre>
<hr />
<pre>
1900   static  Elf32_Half running_arch_code=EM_ARM;
1901 #elif  (defined S390)
1902   static  Elf32_Half running_arch_code=EM_S390;
1903 #elif  (defined ALPHA)
1904   static  Elf32_Half running_arch_code=EM_ALPHA;
1905 #elif  (defined MIPSEL)
1906   static  Elf32_Half running_arch_code=EM_MIPS_RS3_LE;
1907 #elif  (defined PARISC)
1908   static  Elf32_Half running_arch_code=EM_PARISC;
1909 #elif  (defined MIPS)
1910   static  Elf32_Half running_arch_code=EM_MIPS;
1911 #elif  (defined M68K)
1912   static  Elf32_Half running_arch_code=EM_68K;
1913 #elif  (defined SH)
1914   static  Elf32_Half running_arch_code=EM_SH;
1915 #else
1916     #error Method os::dll_load requires that one of following is defined:\
1917         AARCH64, ALPHA, ARM, AMD64, IA32, IA64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, S390, SH, __sparc
1918 #endif
1919 
<span class="line-modified">1920   // Identify compatibility class for VM&#39;s architecture and library&#39;s architecture</span>
1921   // Obtain string descriptions for architectures
1922 
1923   arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};
1924   int running_arch_index=-1;
1925 
1926   for (unsigned int i=0; i &lt; ARRAY_SIZE(arch_array); i++) {
1927     if (running_arch_code == arch_array[i].code) {
1928       running_arch_index    = i;
1929     }
1930     if (lib_arch.code == arch_array[i].code) {
1931       lib_arch.compat_class = arch_array[i].compat_class;
1932       lib_arch.name         = arch_array[i].name;
1933     }
1934   }
1935 
1936   assert(running_arch_index != -1,
1937          &quot;Didn&#39;t find running architecture code (running_arch_code) in arch_array&quot;);
1938   if (running_arch_index == -1) {
1939     // Even though running architecture detection failed
1940     // we may still continue with reporting dlerror() message
1941     return NULL;
1942   }
1943 












1944   if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {
<span class="line-modified">1945     if (lib_arch.name != NULL) {</span>
1946       ::snprintf(diag_msg_buf, diag_msg_max_length-1,
<span class="line-modified">1947                  &quot; (Possible cause: can&#39;t load %s .so on a %s platform)&quot;,</span>
1948                  lib_arch.name, arch_array[running_arch_index].name);
1949     } else {
1950       ::snprintf(diag_msg_buf, diag_msg_max_length-1,
<span class="line-modified">1951                  &quot; (Possible cause: can&#39;t load this .so (machine code=0x%x) on a %s platform)&quot;,</span>
<span class="line-modified">1952                  lib_arch.code, arch_array[running_arch_index].name);</span>

1953     }
<span class="line-added">1954     return NULL;</span>
<span class="line-added">1955   }</span>
<span class="line-added">1956 </span>
<span class="line-added">1957   if (lib_arch.endianness != arch_array[running_arch_index].endianness) {</span>
<span class="line-added">1958     ::snprintf(diag_msg_buf, diag_msg_max_length-1, &quot; (Possible cause: endianness mismatch)&quot;);</span>
<span class="line-added">1959     return NULL;</span>
<span class="line-added">1960   }</span>
<span class="line-added">1961 </span>
<span class="line-added">1962   // ELF file class/capacity : 0 - invalid, 1 - 32bit, 2 - 64bit</span>
<span class="line-added">1963   if (lib_arch.elf_class &gt; 2 || lib_arch.elf_class &lt; 1) {</span>
<span class="line-added">1964     ::snprintf(diag_msg_buf, diag_msg_max_length-1, &quot; (Possible cause: invalid ELF file class)&quot;);</span>
<span class="line-added">1965     return NULL;</span>
<span class="line-added">1966   }</span>
<span class="line-added">1967 </span>
<span class="line-added">1968   if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {</span>
<span class="line-added">1969     ::snprintf(diag_msg_buf, diag_msg_max_length-1,</span>
<span class="line-added">1970                &quot; (Possible cause: architecture word width mismatch, can&#39;t load %d-bit .so on a %d-bit platform)&quot;,</span>
<span class="line-added">1971                (int) lib_arch.elf_class * 32, arch_array[running_arch_index].elf_class * 32);</span>
<span class="line-added">1972     return NULL;</span>
1973   }
1974 
1975   return NULL;
1976 }
1977 
1978 void * os::Linux::dlopen_helper(const char *filename, char *ebuf,
1979                                 int ebuflen) {
1980   void * result = ::dlopen(filename, RTLD_LAZY);
1981   if (result == NULL) {
<span class="line-modified">1982     const char* error_report = ::dlerror();</span>
<span class="line-modified">1983     if (error_report == NULL) {</span>
<span class="line-added">1984       error_report = &quot;dlerror returned no error description&quot;;</span>
<span class="line-added">1985     }</span>
<span class="line-added">1986     if (ebuf != NULL &amp;&amp; ebuflen &gt; 0) {</span>
<span class="line-added">1987       ::strncpy(ebuf, error_report, ebuflen-1);</span>
<span class="line-added">1988       ebuf[ebuflen-1]=&#39;\0&#39;;</span>
<span class="line-added">1989     }</span>
<span class="line-added">1990     Events::log(NULL, &quot;Loading shared library %s failed, %s&quot;, filename, error_report);</span>
<span class="line-added">1991     log_info(os)(&quot;shared library load of %s failed, %s&quot;, filename, error_report);</span>
<span class="line-added">1992   } else {</span>
<span class="line-added">1993     Events::log(NULL, &quot;Loaded shared library %s&quot;, filename);</span>
<span class="line-added">1994     log_info(os)(&quot;shared library load of %s was successful&quot;, filename);</span>
1995   }
1996   return result;
1997 }
1998 
1999 void * os::Linux::dll_load_in_vmthread(const char *filename, char *ebuf,
2000                                        int ebuflen) {
2001   void * result = NULL;
2002   if (LoadExecStackDllInVMThread) {
2003     result = dlopen_helper(filename, ebuf, ebuflen);
2004   }
2005 
2006   // Since 7019808, libjvm.so is linked with -noexecstack. If the VM loads a
2007   // library that requires an executable stack, or which does not have this
2008   // stack attribute set, dlopen changes the stack attribute to executable. The
2009   // read protection of the guard pages gets lost.
2010   //
2011   // Need to check _stack_is_executable again as multiple VM_LinuxDllLoad
2012   // may have been queued at the same time.
2013 
2014   if (!_stack_is_executable) {
</pre>
<hr />
<pre>
2039   if (fd == -1) {
2040     return false;
2041   }
2042 
2043   if (hdr != NULL) {
2044     st-&gt;print_cr(&quot;%s&quot;, hdr);
2045   }
2046 
2047   char buf[33];
2048   int bytes;
2049   buf[32] = &#39;\0&#39;;
2050   while ((bytes = ::read(fd, buf, sizeof(buf)-1)) &gt; 0) {
2051     st-&gt;print_raw(buf, bytes);
2052   }
2053 
2054   ::close(fd);
2055 
2056   return true;
2057 }
2058 





























2059 void os::print_dll_info(outputStream *st) {
2060   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
2061 
2062   char fname[32];
2063   pid_t pid = os::Linux::gettid();
2064 
2065   jio_snprintf(fname, sizeof(fname), &quot;/proc/%d/maps&quot;, pid);
2066 
2067   if (!_print_ascii_file(fname, st)) {
2068     st-&gt;print(&quot;Can not get library information for pid = %d\n&quot;, pid);
2069   }
2070 }
2071 
2072 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
2073   FILE *procmapsFile = NULL;
2074 
2075   // Open the procfs maps file for the current process
2076   if ((procmapsFile = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;)) != NULL) {
2077     // Allocate PATH_MAX for file name plus a reasonable size for other fields.
2078     char line[PATH_MAX + 100];
2079 
2080     // Read line by line from &#39;file&#39;
2081     while (fgets(line, sizeof(line), procmapsFile) != NULL) {
2082       u8 base, top, offset, inode;
2083       char permissions[5];
2084       char device[6];
<span class="line-modified">2085       char name[sizeof(line)];</span>
2086 
2087       // Parse fields from line
<span class="line-modified">2088       int matches = sscanf(line, UINT64_FORMAT_X &quot;-&quot; UINT64_FORMAT_X &quot; %4s &quot; UINT64_FORMAT_X &quot; %5s &quot; INT64_FORMAT &quot; %s&quot;,</span>
2089              &amp;base, &amp;top, permissions, &amp;offset, device, &amp;inode, name);
<span class="line-added">2090       // the last entry &#39;name&#39; is empty for some entries, so we might have 6 matches instead of 7 for some lines</span>
<span class="line-added">2091       if (matches &lt; 6) continue;</span>
<span class="line-added">2092       if (matches == 6) name[0] = &#39;\0&#39;;</span>
2093 
2094       // Filter by device id &#39;00:00&#39; so that we only get file system mapped files.
2095       if (strcmp(device, &quot;00:00&quot;) != 0) {
2096 
2097         // Call callback with the fields of interest
2098         if(callback(name, (address)base, (address)top, param)) {
2099           // Oops abort, callback aborted
2100           fclose(procmapsFile);
2101           return 1;
2102         }
2103       }
2104     }
2105     fclose(procmapsFile);
2106   }
2107   return 0;
2108 }
2109 
2110 void os::print_os_info_brief(outputStream* st) {
2111   os::Linux::print_distro_info(st);
2112 
2113   os::Posix::print_uname_info(st);
2114 
2115   os::Linux::print_libversion_info(st);
2116 
2117 }
2118 
2119 void os::print_os_info(outputStream* st) {
2120   st-&gt;print(&quot;OS:&quot;);
2121 
2122   os::Linux::print_distro_info(st);
2123 
2124   os::Posix::print_uname_info(st);
2125 
<span class="line-added">2126   os::Linux::print_uptime_info(st);</span>
<span class="line-added">2127 </span>
2128   // Print warning if unsafe chroot environment detected
2129   if (unsafe_chroot_detected) {
2130     st-&gt;print(&quot;WARNING!! &quot;);
2131     st-&gt;print_cr(&quot;%s&quot;, unstable_chroot_error);
2132   }
2133 
2134   os::Linux::print_libversion_info(st);
2135 
2136   os::Posix::print_rlimit_info(st);
2137 
2138   os::Posix::print_load_average(st);
2139 
2140   os::Linux::print_full_memory_info(st);
2141 
2142   os::Linux::print_proc_sys_info(st);
2143 
2144   os::Linux::print_ld_preload_file(st);
2145 
2146   os::Linux::print_container_info(st);
2147 
<span class="line-modified">2148   VM_Version::print_platform_virtualization_info(st);</span>
<span class="line-added">2149 </span>
<span class="line-added">2150   os::Linux::print_steal_info(st);</span>
2151 }
2152 
2153 // Try to identify popular distros.
2154 // Most Linux distributions have a /etc/XXX-release file, which contains
2155 // the OS version string. Newer Linux distributions have a /etc/lsb-release
2156 // file that also contains the OS version string. Some have more than one
2157 // /etc/XXX-release file (e.g. Mandrake has both /etc/mandrake-release and
2158 // /etc/redhat-release.), so the order is important.
2159 // Any Linux that is based on Redhat (i.e. Oracle, Mandrake, Sun JDS...) have
2160 // their own specific XXX-release file as well as a redhat-release file.
2161 // Because of this the XXX-release file needs to be searched for before the
2162 // redhat-release file.
2163 // Since Red Hat and SuSE have an lsb-release file that is not very descriptive the
2164 // search for redhat-release / SuSE-release needs to be before lsb-release.
2165 // Since the lsb-release file is the new standard it needs to be searched
2166 // before the older style release files.
2167 // Searching system-release (Red Hat) and os-release (other Linuxes) are a
2168 // next to last resort.  The os-release file is a new standard that contains
2169 // distribution information and the system-release file seems to be an old
2170 // standard that has been replaced by the lsb-release and os-release files.
</pre>
<hr />
<pre>
2293   st-&gt;cr();
2294   st-&gt;cr();
2295 
2296   st-&gt;print_cr(&quot;/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers):&quot;);
2297   _print_ascii_file(&quot;/proc/sys/kernel/pid_max&quot;, st);
2298   st-&gt;cr();
2299   st-&gt;cr();
2300 }
2301 
2302 void os::Linux::print_full_memory_info(outputStream* st) {
2303   st-&gt;print(&quot;\n/proc/meminfo:\n&quot;);
2304   _print_ascii_file(&quot;/proc/meminfo&quot;, st);
2305   st-&gt;cr();
2306 }
2307 
2308 void os::Linux::print_ld_preload_file(outputStream* st) {
2309   _print_ascii_file(&quot;/etc/ld.so.preload&quot;, st, &quot;\n/etc/ld.so.preload:&quot;);
2310   st-&gt;cr();
2311 }
2312 
<span class="line-added">2313 void os::Linux::print_uptime_info(outputStream* st) {</span>
<span class="line-added">2314   struct sysinfo sinfo;</span>
<span class="line-added">2315   int ret = sysinfo(&amp;sinfo);</span>
<span class="line-added">2316   if (ret == 0) {</span>
<span class="line-added">2317     os::print_dhm(st, &quot;OS uptime:&quot;, (long) sinfo.uptime);</span>
<span class="line-added">2318   }</span>
<span class="line-added">2319 }</span>
<span class="line-added">2320 </span>
<span class="line-added">2321 </span>
2322 void os::Linux::print_container_info(outputStream* st) {
2323   if (!OSContainer::is_containerized()) {
2324     return;
2325   }
2326 
2327   st-&gt;print(&quot;container (cgroup) information:\n&quot;);
2328 
2329   const char *p_ct = OSContainer::container_type();
<span class="line-modified">2330   st-&gt;print(&quot;container_type: %s\n&quot;, p_ct != NULL ? p_ct : &quot;not supported&quot;);</span>
2331 
2332   char *p = OSContainer::cpu_cpuset_cpus();
<span class="line-modified">2333   st-&gt;print(&quot;cpu_cpuset_cpus: %s\n&quot;, p != NULL ? p : &quot;not supported&quot;);</span>
2334   free(p);
2335 
2336   p = OSContainer::cpu_cpuset_memory_nodes();
<span class="line-modified">2337   st-&gt;print(&quot;cpu_memory_nodes: %s\n&quot;, p != NULL ? p : &quot;not supported&quot;);</span>
2338   free(p);
2339 
2340   int i = OSContainer::active_processor_count();
<span class="line-added">2341   st-&gt;print(&quot;active_processor_count: &quot;);</span>
2342   if (i &gt; 0) {
<span class="line-modified">2343     st-&gt;print(&quot;%d\n&quot;, i);</span>
2344   } else {
<span class="line-modified">2345     st-&gt;print(&quot;not supported\n&quot;);</span>
2346   }
2347 
2348   i = OSContainer::cpu_quota();
<span class="line-modified">2349   st-&gt;print(&quot;cpu_quota: &quot;);</span>
<span class="line-added">2350   if (i &gt; 0) {</span>
<span class="line-added">2351     st-&gt;print(&quot;%d\n&quot;, i);</span>
<span class="line-added">2352   } else {</span>
<span class="line-added">2353     st-&gt;print(&quot;%s\n&quot;, i == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;no quota&quot;);</span>
<span class="line-added">2354   }</span>
2355 
2356   i = OSContainer::cpu_period();
<span class="line-modified">2357   st-&gt;print(&quot;cpu_period: &quot;);</span>
<span class="line-added">2358   if (i &gt; 0) {</span>
<span class="line-added">2359     st-&gt;print(&quot;%d\n&quot;, i);</span>
<span class="line-added">2360   } else {</span>
<span class="line-added">2361     st-&gt;print(&quot;%s\n&quot;, i == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;no period&quot;);</span>
<span class="line-added">2362   }</span>
2363 
2364   i = OSContainer::cpu_shares();
<span class="line-modified">2365   st-&gt;print(&quot;cpu_shares: &quot;);</span>
<span class="line-added">2366   if (i &gt; 0) {</span>
<span class="line-added">2367     st-&gt;print(&quot;%d\n&quot;, i);</span>
<span class="line-added">2368   } else {</span>
<span class="line-added">2369     st-&gt;print(&quot;%s\n&quot;, i == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;no shares&quot;);</span>
<span class="line-added">2370   }</span>
2371 
2372   jlong j = OSContainer::memory_limit_in_bytes();
<span class="line-modified">2373   st-&gt;print(&quot;memory_limit_in_bytes: &quot;);</span>
<span class="line-added">2374   if (j &gt; 0) {</span>
<span class="line-added">2375     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="line-added">2376   } else {</span>
<span class="line-added">2377     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
<span class="line-added">2378   }</span>
2379 
2380   j = OSContainer::memory_and_swap_limit_in_bytes();
<span class="line-modified">2381   st-&gt;print(&quot;memory_and_swap_limit_in_bytes: &quot;);</span>
<span class="line-added">2382   if (j &gt; 0) {</span>
<span class="line-added">2383     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="line-added">2384   } else {</span>
<span class="line-added">2385     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
<span class="line-added">2386   }</span>
2387 
2388   j = OSContainer::memory_soft_limit_in_bytes();
<span class="line-modified">2389   st-&gt;print(&quot;memory_soft_limit_in_bytes: &quot;);</span>
<span class="line-added">2390   if (j &gt; 0) {</span>
<span class="line-added">2391     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="line-added">2392   } else {</span>
<span class="line-added">2393     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
<span class="line-added">2394   }</span>
2395 
2396   j = OSContainer::OSContainer::memory_usage_in_bytes();
<span class="line-modified">2397   st-&gt;print(&quot;memory_usage_in_bytes: &quot;);</span>
<span class="line-added">2398   if (j &gt; 0) {</span>
<span class="line-added">2399     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="line-added">2400   } else {</span>
<span class="line-added">2401     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
<span class="line-added">2402   }</span>
2403 
2404   j = OSContainer::OSContainer::memory_max_usage_in_bytes();
<span class="line-modified">2405   st-&gt;print(&quot;memory_max_usage_in_bytes: &quot;);</span>
<span class="line-added">2406   if (j &gt; 0) {</span>
<span class="line-added">2407     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
<span class="line-added">2408   } else {</span>
<span class="line-added">2409     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
<span class="line-added">2410   }</span>
2411   st-&gt;cr();
2412 }
2413 
<span class="line-modified">2414 void os::Linux::print_steal_info(outputStream* st) {</span>
<span class="line-modified">2415   if (has_initial_tick_info) {</span>
<span class="line-modified">2416     CPUPerfTicks pticks;</span>
<span class="line-modified">2417     bool res = os::Linux::get_tick_information(&amp;pticks, -1);</span>




2418 
<span class="line-modified">2419     if (res &amp;&amp; pticks.has_steal_ticks) {</span>
<span class="line-modified">2420       uint64_t steal_ticks_difference = pticks.steal - initial_steal_ticks;</span>
<span class="line-modified">2421       uint64_t total_ticks_difference = pticks.total - initial_total_ticks;</span>
<span class="line-modified">2422       double steal_ticks_perc = 0.0;</span>
<span class="line-modified">2423       if (total_ticks_difference != 0) {</span>
<span class="line-modified">2424         steal_ticks_perc = (double) steal_ticks_difference / total_ticks_difference;</span>
<span class="line-modified">2425       }</span>
<span class="line-modified">2426       st-&gt;print_cr(&quot;Steal ticks since vm start: &quot; UINT64_FORMAT, steal_ticks_difference);</span>
<span class="line-modified">2427       st-&gt;print_cr(&quot;Steal ticks percentage since vm start:%7.3f&quot;, steal_ticks_perc);</span>
<span class="line-modified">2428     }</span>











2429   }

2430 }
2431 
2432 void os::print_memory_info(outputStream* st) {
2433 
2434   st-&gt;print(&quot;Memory:&quot;);
2435   st-&gt;print(&quot; %dk page&quot;, os::vm_page_size()&gt;&gt;10);
2436 
2437   // values in struct sysinfo are &quot;unsigned long&quot;
2438   struct sysinfo si;
2439   sysinfo(&amp;si);
2440 
2441   st-&gt;print(&quot;, physical &quot; UINT64_FORMAT &quot;k&quot;,
2442             os::physical_memory() &gt;&gt; 10);
2443   st-&gt;print(&quot;(&quot; UINT64_FORMAT &quot;k free)&quot;,
2444             os::available_memory() &gt;&gt; 10);
2445   st-&gt;print(&quot;, swap &quot; UINT64_FORMAT &quot;k&quot;,
2446             ((jlong)si.totalswap * si.mem_unit) &gt;&gt; 10);
2447   st-&gt;print(&quot;(&quot; UINT64_FORMAT &quot;k free)&quot;,
2448             ((jlong)si.freeswap * si.mem_unit) &gt;&gt; 10);
2449   st-&gt;cr();
</pre>
<hr />
<pre>
2487   return false;
2488 }
2489 
2490 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
2491   // Only print the model name if the platform provides this as a summary
2492   if (!print_model_name_and_flags(st, buf, buflen)) {
2493     st-&gt;print(&quot;\n/proc/cpuinfo:\n&quot;);
2494     if (!_print_ascii_file(&quot;/proc/cpuinfo&quot;, st)) {
2495       st-&gt;print_cr(&quot;  &lt;Not Available&gt;&quot;);
2496     }
2497   }
2498 }
2499 
2500 #if defined(AMD64) || defined(IA32) || defined(X32)
2501 const char* search_string = &quot;model name&quot;;
2502 #elif defined(M68K)
2503 const char* search_string = &quot;CPU&quot;;
2504 #elif defined(PPC64)
2505 const char* search_string = &quot;cpu&quot;;
2506 #elif defined(S390)
<span class="line-modified">2507 const char* search_string = &quot;machine =&quot;;</span>
2508 #elif defined(SPARC)
2509 const char* search_string = &quot;cpu&quot;;
2510 #else
2511 const char* search_string = &quot;Processor&quot;;
2512 #endif
2513 
2514 // Parses the cpuinfo file for string representing the model name.
2515 void os::get_summary_cpu_info(char* cpuinfo, size_t length) {
2516   FILE* fp = fopen(&quot;/proc/cpuinfo&quot;, &quot;r&quot;);
2517   if (fp != NULL) {
2518     while (!feof(fp)) {
2519       char buf[256];
2520       if (fgets(buf, sizeof(buf), fp)) {
2521         char* start = strstr(buf, search_string);
2522         if (start != NULL) {
2523           char *ptr = start + strlen(search_string);
2524           char *end = buf + strlen(buf);
2525           while (ptr != end) {
2526              // skip whitespace and colon for the rest of the name.
2527              if (*ptr != &#39; &#39; &amp;&amp; *ptr != &#39;\t&#39; &amp;&amp; *ptr != &#39;:&#39;) {
</pre>
<hr />
<pre>
2673         }
2674       }
2675     }
2676   }
2677 
2678   strncpy(saved_jvm_path, buf, MAXPATHLEN);
2679   saved_jvm_path[MAXPATHLEN - 1] = &#39;\0&#39;;
2680 }
2681 
2682 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
2683   // no prefix required, not even &quot;_&quot;
2684 }
2685 
2686 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
2687   // no suffix required
2688 }
2689 
2690 ////////////////////////////////////////////////////////////////////////////////
2691 // sun.misc.Signal support
2692 


2693 static void UserHandler(int sig, void *siginfo, void *context) {







2694   // Ctrl-C is pressed during error reporting, likely because the error
2695   // handler fails to abort. Let VM die immediately.
2696   if (sig == SIGINT &amp;&amp; VMError::is_error_reported()) {
2697     os::die();
2698   }
2699 
2700   os::signal_notify(sig);
2701 }
2702 
2703 void* os::user_handler() {
2704   return CAST_FROM_FN_PTR(void*, UserHandler);
2705 }
2706 
2707 extern &quot;C&quot; {
2708   typedef void (*sa_handler_t)(int);
2709   typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);
2710 }
2711 
2712 void* os::signal(int signal_number, void* handler) {
2713   struct sigaction sigAct, oldSigAct;
</pre>
<hr />
<pre>
2746 static void jdk_misc_signal_init() {
2747   // Initialize signal structures
2748   ::memset((void*)pending_signals, 0, sizeof(pending_signals));
2749 
2750   // Initialize signal semaphore
2751   sig_sem = new Semaphore();
2752 }
2753 
2754 void os::signal_notify(int sig) {
2755   if (sig_sem != NULL) {
2756     Atomic::inc(&amp;pending_signals[sig]);
2757     sig_sem-&gt;signal();
2758   } else {
2759     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
2760     // initialization isn&#39;t called.
2761     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
2762   }
2763 }
2764 
2765 static int check_pending_signals() {

2766   for (;;) {
2767     for (int i = 0; i &lt; NSIG + 1; i++) {
2768       jint n = pending_signals[i];
<span class="line-modified">2769       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {</span>
2770         return i;
2771       }
2772     }
2773     JavaThread *thread = JavaThread::current();
2774     ThreadBlockInVM tbivm(thread);
2775 
2776     bool threadIsSuspended;
2777     do {
2778       thread-&gt;set_suspend_equivalent();
2779       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
2780       sig_sem-&gt;wait();
2781 
2782       // were we externally suspended while we were waiting?
2783       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
2784       if (threadIsSuspended) {
2785         // The semaphore has been incremented, but while we were waiting
2786         // another thread suspended us. We don&#39;t want to continue running
2787         // while suspended because that would surprise the thread that
2788         // suspended us.
2789         sig_sem-&gt;signal();
</pre>
<hr />
<pre>
2810 // Solaris allocates memory by pages.
2811 int os::vm_allocation_granularity() {
2812   assert(os::Linux::page_size() != -1, &quot;must call os::init&quot;);
2813   return os::Linux::page_size();
2814 }
2815 
2816 // Rationale behind this function:
2817 //  current (Mon Apr 25 20:12:18 MSD 2005) oprofile drops samples without executable
2818 //  mapping for address (see lookup_dcookie() in the kernel module), thus we cannot get
2819 //  samples for JITted code. Here we create private executable mapping over the code cache
2820 //  and then we can use standard (well, almost, as mapping can change) way to provide
2821 //  info for the reporting script by storing timestamp and location of symbol
2822 void linux_wrap_code(char* base, size_t size) {
2823   static volatile jint cnt = 0;
2824 
2825   if (!UseOprofile) {
2826     return;
2827   }
2828 
2829   char buf[PATH_MAX+1];
<span class="line-modified">2830   int num = Atomic::add(&amp;cnt, 1);</span>
2831 
2832   snprintf(buf, sizeof(buf), &quot;%s/hs-vm-%d-%d&quot;,
2833            os::get_temp_directory(), os::current_process_id(), num);
2834   unlink(buf);
2835 
2836   int fd = ::open(buf, O_CREAT | O_RDWR, S_IRWXU);
2837 
2838   if (fd != -1) {
2839     off_t rv = ::lseek(fd, size-2, SEEK_SET);
2840     if (rv != (off_t)-1) {
2841       if (::write(fd, &quot;&quot;, 1) == 1) {
2842         mmap(base, size,
2843              PROT_READ|PROT_WRITE|PROT_EXEC,
2844              MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);
2845       }
2846     }
2847     ::close(fd);
2848     unlink(buf);
2849   }
2850 }
</pre>
<hr />
<pre>
3004 
3005 bool os::numa_topology_changed() { return false; }
3006 
3007 size_t os::numa_get_groups_num() {
3008   // Return just the number of nodes in which it&#39;s possible to allocate memory
3009   // (in numa terminology, configured nodes).
3010   return Linux::numa_num_configured_nodes();
3011 }
3012 
3013 int os::numa_get_group_id() {
3014   int cpu_id = Linux::sched_getcpu();
3015   if (cpu_id != -1) {
3016     int lgrp_id = Linux::get_node_by_cpu(cpu_id);
3017     if (lgrp_id != -1) {
3018       return lgrp_id;
3019     }
3020   }
3021   return 0;
3022 }
3023 
<span class="line-added">3024 int os::numa_get_group_id_for_address(const void* address) {</span>
<span class="line-added">3025   void** pages = const_cast&lt;void**&gt;(&amp;address);</span>
<span class="line-added">3026   int id = -1;</span>
<span class="line-added">3027 </span>
<span class="line-added">3028   if (os::Linux::numa_move_pages(0, 1, pages, NULL, &amp;id, 0) == -1) {</span>
<span class="line-added">3029     return -1;</span>
<span class="line-added">3030   }</span>
<span class="line-added">3031   if (id &lt; 0) {</span>
<span class="line-added">3032     return -1;</span>
<span class="line-added">3033   }</span>
<span class="line-added">3034   return id;</span>
<span class="line-added">3035 }</span>
<span class="line-added">3036 </span>
3037 int os::Linux::get_existing_num_nodes() {
3038   int node;
3039   int highest_node_number = Linux::numa_max_node();
3040   int num_nodes = 0;
3041 
3042   // Get the total number of nodes in the system including nodes without memory.
3043   for (node = 0; node &lt;= highest_node_number; node++) {
3044     if (is_node_in_existing_nodes(node)) {
3045       num_nodes++;
3046     }
3047   }
3048   return num_nodes;
3049 }
3050 
3051 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
3052   int highest_node_number = Linux::numa_max_node();
3053   size_t i = 0;
3054 
3055   // Map all node ids in which it is possible to allocate memory. Also nodes are
3056   // not always consecutively available, i.e. available from 0 to the highest
</pre>
<hr />
<pre>
3145       set_numa_num_configured_nodes(CAST_TO_FN_PTR(numa_num_configured_nodes_func_t,
3146                                                    libnuma_dlsym(handle, &quot;numa_num_configured_nodes&quot;)));
3147       set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,
3148                                         libnuma_dlsym(handle, &quot;numa_available&quot;)));
3149       set_numa_tonode_memory(CAST_TO_FN_PTR(numa_tonode_memory_func_t,
3150                                             libnuma_dlsym(handle, &quot;numa_tonode_memory&quot;)));
3151       set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,
3152                                                 libnuma_dlsym(handle, &quot;numa_interleave_memory&quot;)));
3153       set_numa_interleave_memory_v2(CAST_TO_FN_PTR(numa_interleave_memory_v2_func_t,
3154                                                 libnuma_v2_dlsym(handle, &quot;numa_interleave_memory&quot;)));
3155       set_numa_set_bind_policy(CAST_TO_FN_PTR(numa_set_bind_policy_func_t,
3156                                               libnuma_dlsym(handle, &quot;numa_set_bind_policy&quot;)));
3157       set_numa_bitmask_isbitset(CAST_TO_FN_PTR(numa_bitmask_isbitset_func_t,
3158                                                libnuma_dlsym(handle, &quot;numa_bitmask_isbitset&quot;)));
3159       set_numa_distance(CAST_TO_FN_PTR(numa_distance_func_t,
3160                                        libnuma_dlsym(handle, &quot;numa_distance&quot;)));
3161       set_numa_get_membind(CAST_TO_FN_PTR(numa_get_membind_func_t,
3162                                           libnuma_v2_dlsym(handle, &quot;numa_get_membind&quot;)));
3163       set_numa_get_interleave_mask(CAST_TO_FN_PTR(numa_get_interleave_mask_func_t,
3164                                                   libnuma_v2_dlsym(handle, &quot;numa_get_interleave_mask&quot;)));
<span class="line-added">3165       set_numa_move_pages(CAST_TO_FN_PTR(numa_move_pages_func_t,</span>
<span class="line-added">3166                                          libnuma_dlsym(handle, &quot;numa_move_pages&quot;)));</span>
<span class="line-added">3167       set_numa_set_preferred(CAST_TO_FN_PTR(numa_set_preferred_func_t,</span>
<span class="line-added">3168                                             libnuma_dlsym(handle, &quot;numa_set_preferred&quot;)));</span>
3169 
3170       if (numa_available() != -1) {
3171         set_numa_all_nodes((unsigned long*)libnuma_dlsym(handle, &quot;numa_all_nodes&quot;));
3172         set_numa_all_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_all_nodes_ptr&quot;));
3173         set_numa_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_nodes_ptr&quot;));
3174         set_numa_interleave_bitmask(_numa_get_interleave_mask());
3175         set_numa_membind_bitmask(_numa_get_membind());
3176         // Create an index -&gt; node mapping, since nodes are not always consecutive
3177         _nindex_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;int&gt;(0, true);
3178         rebuild_nindex_to_node_map();
3179         // Create a cpu -&gt; node mapping
3180         _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;int&gt;(0, true);
3181         rebuild_cpu_to_node_map();
3182         return true;
3183       }
3184     }
3185   }
3186   return false;
3187 }
3188 
</pre>
<hr />
<pre>
3283     return cpu_to_node()-&gt;at(cpu_id);
3284   }
3285   return -1;
3286 }
3287 
3288 GrowableArray&lt;int&gt;* os::Linux::_cpu_to_node;
3289 GrowableArray&lt;int&gt;* os::Linux::_nindex_to_node;
3290 os::Linux::sched_getcpu_func_t os::Linux::_sched_getcpu;
3291 os::Linux::numa_node_to_cpus_func_t os::Linux::_numa_node_to_cpus;
3292 os::Linux::numa_max_node_func_t os::Linux::_numa_max_node;
3293 os::Linux::numa_num_configured_nodes_func_t os::Linux::_numa_num_configured_nodes;
3294 os::Linux::numa_available_func_t os::Linux::_numa_available;
3295 os::Linux::numa_tonode_memory_func_t os::Linux::_numa_tonode_memory;
3296 os::Linux::numa_interleave_memory_func_t os::Linux::_numa_interleave_memory;
3297 os::Linux::numa_interleave_memory_v2_func_t os::Linux::_numa_interleave_memory_v2;
3298 os::Linux::numa_set_bind_policy_func_t os::Linux::_numa_set_bind_policy;
3299 os::Linux::numa_bitmask_isbitset_func_t os::Linux::_numa_bitmask_isbitset;
3300 os::Linux::numa_distance_func_t os::Linux::_numa_distance;
3301 os::Linux::numa_get_membind_func_t os::Linux::_numa_get_membind;
3302 os::Linux::numa_get_interleave_mask_func_t os::Linux::_numa_get_interleave_mask;
<span class="line-added">3303 os::Linux::numa_move_pages_func_t os::Linux::_numa_move_pages;</span>
<span class="line-added">3304 os::Linux::numa_set_preferred_func_t os::Linux::_numa_set_preferred;</span>
3305 os::Linux::NumaAllocationPolicy os::Linux::_current_numa_policy;
3306 unsigned long* os::Linux::_numa_all_nodes;
3307 struct bitmask* os::Linux::_numa_all_nodes_ptr;
3308 struct bitmask* os::Linux::_numa_nodes_ptr;
3309 struct bitmask* os::Linux::_numa_interleave_bitmask;
3310 struct bitmask* os::Linux::_numa_membind_bitmask;
3311 
3312 bool os::pd_uncommit_memory(char* addr, size_t size) {
3313   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
3314                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
3315   return res  != (uintptr_t) MAP_FAILED;
3316 }
3317 
3318 static address get_stack_commited_bottom(address bottom, size_t size) {
3319   address nbot = bottom;
3320   address ntop = bottom + size;
3321 
3322   size_t page_sz = os::vm_page_size();
3323   unsigned pages = size / page_sz;
3324 
</pre>
<hr />
<pre>
3572                             size_t alignment_hint) {
3573   return anon_mmap(requested_addr, bytes, (requested_addr != NULL));
3574 }
3575 
3576 bool os::pd_release_memory(char* addr, size_t size) {
3577   return anon_munmap(addr, size);
3578 }
3579 
3580 static bool linux_mprotect(char* addr, size_t size, int prot) {
3581   // Linux wants the mprotect address argument to be page aligned.
3582   char* bottom = (char*)align_down((intptr_t)addr, os::Linux::page_size());
3583 
3584   // According to SUSv3, mprotect() should only be used with mappings
3585   // established by mmap(), and mmap() always maps whole pages. Unaligned
3586   // &#39;addr&#39; likely indicates problem in the VM (e.g. trying to change
3587   // protection of malloc&#39;ed or statically allocated memory). Check the
3588   // caller if you hit this assert.
3589   assert(addr == bottom, &quot;sanity check&quot;);
3590 
3591   size = align_up(pointer_delta(addr, bottom, 1) + size, os::Linux::page_size());
<span class="line-added">3592   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(bottom), p2i(bottom+size), prot);</span>
3593   return ::mprotect(bottom, size, prot) == 0;
3594 }
3595 
3596 // Set protections specified
3597 bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
3598                         bool is_committed) {
3599   unsigned int p = 0;
3600   switch (prot) {
3601   case MEM_PROT_NONE: p = PROT_NONE; break;
3602   case MEM_PROT_READ: p = PROT_READ; break;
3603   case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;
3604   case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;
3605   default:
3606     ShouldNotReachHere();
3607   }
3608   // is_committed is unused.
3609   return linux_mprotect(addr, bytes, p);
3610 }
3611 
3612 bool os::guard_memory(char* addr, size_t size) {
</pre>
<hr />
<pre>
4211 
4212 bool os::can_execute_large_page_memory() {
4213   return UseTransparentHugePages || UseHugeTLBFS;
4214 }
4215 
4216 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
4217   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
4218   char* result = pd_attempt_reserve_memory_at(bytes, requested_addr);
4219   if (result != NULL) {
4220     if (replace_existing_mapping_with_file_mapping(result, bytes, file_desc) == NULL) {
4221       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
4222     }
4223   }
4224   return result;
4225 }
4226 
4227 // Reserve memory at an arbitrary address, only if that area is
4228 // available (and not reserved for something else).
4229 
4230 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {





4231   // Assert only that the size is a multiple of the page size, since
4232   // that&#39;s all that mmap requires, and since that&#39;s all we really know
4233   // about at this low abstraction level.  If we need higher alignment,
4234   // we can either pass an alignment to this method or verify alignment
4235   // in one of the methods further up the call chain.  See bug 5044738.
4236   assert(bytes % os::vm_page_size() == 0, &quot;reserving unexpected size block&quot;);
4237 
4238   // Repeatedly allocate blocks until the block is allocated at the
4239   // right spot.
4240 
4241   // Linux mmap allows caller to pass an address as hint; give it a try first,
4242   // if kernel honors the hint then we can return immediately.
4243   char * addr = anon_mmap(requested_addr, bytes, false);
4244   if (addr == requested_addr) {
4245     return requested_addr;
4246   }
4247 
4248   if (addr != NULL) {
4249     // mmap() is successful but it fails to reserve at the requested address
4250     anon_munmap(addr, bytes);
4251   }
4252 
<span class="line-modified">4253   return NULL;</span>











































4254 }
4255 
4256 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
4257 void os::infinite_sleep() {
4258   while (true) {    // sleep forever ...
4259     ::sleep(100);   // ... 100 seconds at a time
4260   }
4261 }
4262 
4263 // Used to convert frequent JVM_Yield() to nops
4264 bool os::dont_yield() {
4265   return DontYieldALot;
4266 }
4267 
4268 // Linux CFS scheduler (since 2.6.23) does not guarantee sched_yield(2) will
4269 // actually give up the CPU. Since skip buddy (v2.6.28):
4270 //
4271 // * Sets the yielding task as skip buddy for current CPU&#39;s run queue.
4272 // * Picks next from run queue, if empty, picks a skip buddy (can be the yielding task).
4273 // * Clears skip buddies for this run queue (yielding task no longer a skip buddy).
</pre>
<hr />
<pre>
4805     set_signal_handler(SIGSEGV, true);
4806     set_signal_handler(SIGPIPE, true);
4807     set_signal_handler(SIGBUS, true);
4808     set_signal_handler(SIGILL, true);
4809     set_signal_handler(SIGFPE, true);
4810 #if defined(PPC64)
4811     set_signal_handler(SIGTRAP, true);
4812 #endif
4813     set_signal_handler(SIGXFSZ, true);
4814 
4815     if (libjsig_is_loaded) {
4816       // Tell libjsig jvm finishes setting signal handlers
4817       (*end_signal_setting)();
4818     }
4819 
4820     // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
4821     // and if UserSignalHandler is installed all bets are off.
4822     // Log that signal checking is off only if -verbose:jni is specified.
4823     if (CheckJNICalls) {
4824       if (libjsig_is_loaded) {
<span class="line-modified">4825         log_debug(jni, resolve)(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>


4826         check_signals = false;
4827       }
4828       if (AllowUserSignalHandlers) {
<span class="line-modified">4829         log_debug(jni, resolve)(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>


4830         check_signals = false;
4831       }
4832     }
4833   }
4834 }
4835 
4836 // This is the fastest way to get thread cpu time on Linux.
4837 // Returns cpu time (user+sys) for any thread, not only for current.
4838 // POSIX compliant clocks are implemented in the kernels 2.6.16+.
4839 // It might work on 2.6.10+ with a special kernel/glibc patch.
4840 // For reference, please, see IEEE Std 1003.1-2004:
4841 //   http://www.unix.org/single_unix_specification
4842 
4843 jlong os::Linux::fast_thread_cpu_time(clockid_t clockid) {
4844   struct timespec tp;
4845   int rc = os::Posix::clock_gettime(clockid, &amp;tp);
4846   assert(rc == 0, &quot;clock_gettime is expected to return 0 code&quot;);
4847 
4848   return (tp.tv_sec * NANOSECS_PER_SEC) + tp.tv_nsec;
4849 }
4850 










































4851 /////
4852 // glibc on Linux platform uses non-documented flag
4853 // to indicate, that some special sort of signal
4854 // trampoline is used.
4855 // We will never set this flag, and we should
4856 // ignore this flag in our diagnostic
4857 #ifdef SIGNIFICANT_SIGNAL_MASK
4858   #undef SIGNIFICANT_SIGNAL_MASK
4859 #endif
4860 #define SIGNIFICANT_SIGNAL_MASK (~0x04000000)
4861 
4862 static const char* get_signal_handler_name(address handler,
4863                                            char* buf, int buflen) {
4864   int offset = 0;
4865   bool found = os::dll_address_to_library_name(handler, buf, buflen, &amp;offset);
4866   if (found) {
4867     // skip directory names
4868     const char *p1, *p2;
4869     p1 = buf;
4870     size_t len = strlen(os::file_separator());
</pre>
<hr />
<pre>
5050 extern void report_error(char* file_name, int line_no, char* title,
5051                          char* format, ...);
5052 
5053 // this is called _before_ most of the global arguments have been parsed
5054 void os::init(void) {
5055   char dummy;   // used to get a guess on initial stack address
5056 
5057   clock_tics_per_sec = sysconf(_SC_CLK_TCK);
5058 
5059   init_random(1234567);
5060 
5061   Linux::set_page_size(sysconf(_SC_PAGESIZE));
5062   if (Linux::page_size() == -1) {
5063     fatal(&quot;os_linux.cpp: os::init: sysconf failed (%s)&quot;,
5064           os::strerror(errno));
5065   }
5066   init_page_sizes((size_t) Linux::page_size());
5067 
5068   Linux::initialize_system_info();
5069 
<span class="line-modified">5070   os::Linux::CPUPerfTicks pticks;</span>
<span class="line-added">5071   bool res = os::Linux::get_tick_information(&amp;pticks, -1);</span>
<span class="line-added">5072 </span>
<span class="line-added">5073   if (res &amp;&amp; pticks.has_steal_ticks) {</span>
<span class="line-added">5074     has_initial_tick_info = true;</span>
<span class="line-added">5075     initial_total_ticks = pticks.total;</span>
<span class="line-added">5076     initial_steal_ticks = pticks.steal;</span>
<span class="line-added">5077   }</span>
5078 
5079   // _main_thread points to the thread that created/loaded the JVM.
5080   Linux::_main_thread = pthread_self();
5081 
5082   // retrieve entry point for pthread_setname_np
5083   Linux::_pthread_setname_np =
5084     (int(*)(pthread_t, const char*))dlsym(RTLD_DEFAULT, &quot;pthread_setname_np&quot;);
5085 
5086   os::Posix::init();
5087 
5088   initial_time_count = javaTimeNanos();
5089 
5090   // Always warn if no monotonic clock available
5091   if (!os::Posix::supports_monotonic_clock()) {
5092     warning(&quot;No monotonic clock was available - timed services may &quot;    \
5093             &quot;be adversely affected if the time-of-day clock changes&quot;);
5094   }
5095 }
5096 
5097 // To install functions for atexit system call
</pre>
<hr />
<pre>
5180   // have to set it the same so we have to mirror Solaris.
5181   DEBUG_ONLY(os::set_mutex_init_done();)
5182 
5183   os::Posix::init_2();
5184 
5185   Linux::fast_thread_clock_init();
5186 
5187   // initialize suspend/resume support - must do this before signal_sets_init()
5188   if (SR_initialize() != 0) {
5189     perror(&quot;SR_initialize failed&quot;);
5190     return JNI_ERR;
5191   }
5192 
5193   Linux::signal_sets_init();
5194   Linux::install_signal_handlers();
5195   // Initialize data for jdk.internal.misc.Signal
5196   if (!ReduceSignalUsage) {
5197     jdk_misc_signal_init();
5198   }
5199 
<span class="line-added">5200   if (AdjustStackSizeForTLS) {</span>
<span class="line-added">5201     get_minstack_init();</span>
<span class="line-added">5202   }</span>
<span class="line-added">5203 </span>
5204   // Check and sets minimum stack sizes against command line options
5205   if (Posix::set_minimum_stack_sizes() == JNI_ERR) {
5206     return JNI_ERR;
5207   }
5208 
<span class="line-added">5209 #if defined(IA32)</span>
<span class="line-added">5210   // Need to ensure we&#39;ve determined the process&#39;s initial stack to</span>
<span class="line-added">5211   // perform the workaround</span>
<span class="line-added">5212   Linux::capture_initial_stack(JavaThread::stack_size_at_create());</span>
<span class="line-added">5213   workaround_expand_exec_shield_cs_limit();</span>
<span class="line-added">5214 #else</span>
5215   suppress_primordial_thread_resolution = Arguments::created_by_java_launcher();
5216   if (!suppress_primordial_thread_resolution) {
5217     Linux::capture_initial_stack(JavaThread::stack_size_at_create());
5218   }



5219 #endif
5220 
5221   Linux::libpthread_init();
5222   Linux::sched_getcpu_init();
5223   log_info(os)(&quot;HotSpot is running with %s, %s&quot;,
5224                Linux::glibc_version(), Linux::libpthread_version());
5225 
5226   if (UseNUMA) {
5227     Linux::numa_init();
5228   }
5229 
5230   if (MaxFDLimit) {
5231     // set the number of file descriptors to max. print out error
5232     // if getrlimit/setrlimit fails but continue regardless.
5233     struct rlimit nbr_files;
5234     int status = getrlimit(RLIMIT_NOFILE, &amp;nbr_files);
5235     if (status != 0) {
5236       log_info(os)(&quot;os::init_2 getrlimit failed: %s&quot;, os::strerror(errno));
5237     } else {
5238       nbr_files.rlim_cur = nbr_files.rlim_max;
5239       status = setrlimit(RLIMIT_NOFILE, &amp;nbr_files);
5240       if (status != 0) {
5241         log_info(os)(&quot;os::init_2 setrlimit failed: %s&quot;, os::strerror(errno));
5242       }
5243     }
5244   }
5245 



5246   // at-exit methods are called in the reverse order of their registration.
5247   // atexit functions are called on return from main or as a result of a
5248   // call to exit(3C). There can be only 32 of these functions registered
5249   // and atexit() does not set errno.
5250 
5251   if (PerfAllowAtExitRegistration) {
5252     // only register atexit functions if PerfAllowAtExitRegistration is set.
5253     // atexit functions can be delayed until process exit time, which
5254     // can be problematic for embedded VM situations. Embedded VMs should
5255     // call DestroyJavaVM() to assure that VM resources are released.
5256 
5257     // note: perfMemory_exit_helper atexit function may be removed in
5258     // the future if the appropriate cleanup code can be added to the
5259     // VM_Exit VMOperation&#39;s doit method.
5260     if (atexit(perfMemory_exit_helper) != 0) {
5261       warning(&quot;os::init_2 atexit(perfMemory_exit_helper) failed&quot;);
5262     }
5263   }
5264 
5265   // initialize thread priority policy
</pre>
<hr />
<pre>
5426   return active_cpus;
5427 }
5428 
5429 uint os::processor_id() {
5430   const int id = Linux::sched_getcpu();
5431   assert(id &gt;= 0 &amp;&amp; id &lt; _processor_count, &quot;Invalid processor id&quot;);
5432   return (uint)id;
5433 }
5434 
5435 void os::set_native_thread_name(const char *name) {
5436   if (Linux::_pthread_setname_np) {
5437     char buf [16]; // according to glibc manpage, 16 chars incl. &#39;/0&#39;
5438     snprintf(buf, sizeof(buf), &quot;%s&quot;, name);
5439     buf[sizeof(buf) - 1] = &#39;\0&#39;;
5440     const int rc = Linux::_pthread_setname_np(pthread_self(), buf);
5441     // ERANGE should not happen; all other errors should just be ignored.
5442     assert(rc != ERANGE, &quot;pthread_setname_np failed&quot;);
5443   }
5444 }
5445 





5446 bool os::bind_to_processor(uint processor_id) {
5447   // Not yet implemented.
5448   return false;
5449 }
5450 
5451 ///
5452 
5453 void os::SuspendedThreadTask::internal_do_task() {
5454   if (do_suspend(_thread-&gt;osthread())) {
5455     SuspendedThreadTaskContext context(_thread, _thread-&gt;osthread()-&gt;ucontext());
5456     do_task(context);
5457     do_resume(_thread-&gt;osthread());
5458   }
5459 }
5460 
5461 ////////////////////////////////////////////////////////////////////////////////
5462 // debug support
5463 
5464 bool os::find(address addr, outputStream* st) {
5465   Dl_info dlinfo;
</pre>
<hr />
<pre>
6141 }
6142 #endif
6143 
6144 static inline struct timespec get_mtime(const char* filename) {
6145   struct stat st;
6146   int ret = os::stat(filename, &amp;st);
6147   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
6148   return st.st_mtim;
6149 }
6150 
6151 int os::compare_file_modified_times(const char* file1, const char* file2) {
6152   struct timespec filetime1 = get_mtime(file1);
6153   struct timespec filetime2 = get_mtime(file2);
6154   int diff = filetime1.tv_sec - filetime2.tv_sec;
6155   if (diff == 0) {
6156     return filetime1.tv_nsec - filetime2.tv_nsec;
6157   }
6158   return diff;
6159 }
6160 
<span class="line-added">6161 bool os::supports_map_sync() {</span>
<span class="line-added">6162   return true;</span>
<span class="line-added">6163 }</span>
<span class="line-added">6164 </span>
6165 /////////////// Unit tests ///////////////
6166 
6167 #ifndef PRODUCT
6168 
6169 class TestReserveMemorySpecial : AllStatic {
6170  public:
6171   static void small_page_write(void* addr, size_t size) {
6172     size_t page_size = os::vm_page_size();
6173 
6174     char* end = (char*)addr + size;
6175     for (char* p = (char*)addr; p &lt; end; p += page_size) {
6176       *p = 1;
6177     }
6178   }
6179 
6180   static void test_reserve_memory_special_huge_tlbfs_only(size_t size) {
6181     if (!UseHugeTLBFS) {
6182       return;
6183     }
6184 
</pre>
</td>
</tr>
</table>
<center><a href="osContainer_linux.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
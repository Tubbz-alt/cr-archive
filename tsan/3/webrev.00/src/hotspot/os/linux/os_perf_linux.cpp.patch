diff a/src/hotspot/os/linux/os_perf_linux.cpp b/src/hotspot/os/linux/os_perf_linux.cpp
--- a/src/hotspot/os/linux/os_perf_linux.cpp
+++ b/src/hotspot/os/linux/os_perf_linux.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,10 +26,11 @@
 #include "jvm.h"
 #include "memory/allocation.inline.hpp"
 #include "os_linux.inline.hpp"
 #include "runtime/os.hpp"
 #include "runtime/os_perf.hpp"
+#include "utilities/globalDefinitions.hpp"
 
 #include CPU_HEADER(vm_version_ext)
 
 #include <stdio.h>
 #include <stdarg.h>
@@ -204,17 +205,10 @@
 
 #ifndef _SCANFMT_
 #  define _SCANFMT_
 #endif
 
-
-struct CPUPerfTicks {
-  uint64_t  used;
-  uint64_t  usedKernel;
-  uint64_t  total;
-};
-
 typedef enum {
   CPU_LOAD_VM_ONLY,
   CPU_LOAD_GLOBAL,
 } CpuLoadTarget;
 
@@ -225,12 +219,12 @@
   BAREMETAL
 };
 
 struct CPUPerfCounters {
   int   nProcs;
-  CPUPerfTicks jvmTicks;
-  CPUPerfTicks* cpus;
+  os::Linux::CPUPerfTicks jvmTicks;
+  os::Linux::CPUPerfTicks* cpus;
 };
 
 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target);
 
 /** reads /proc/<pid>/stat data, with some checks and some skips.
@@ -285,84 +279,10 @@
     }
   }
   return f;
 }
 
-static void
-next_line(FILE *f) {
-  int c;
-  do {
-    c = fgetc(f);
-  } while (c != '\n' && c != EOF);
-}
-
-/**
- * Return the total number of ticks since the system was booted.
- * If the usedTicks parameter is not NULL, it will be filled with
- * the number of ticks spent on actual processes (user, system or
- * nice processes) since system boot. Note that this is the total number
- * of "executed" ticks on _all_ CPU:s, that is on a n-way system it is
- * n times the number of ticks that has passed in clock time.
- *
- * Returns a negative value if the reading of the ticks failed.
- */
-static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {
-  FILE*         fh;
-  uint64_t      userTicks, niceTicks, systemTicks, idleTicks;
-  uint64_t      iowTicks = 0, irqTicks = 0, sirqTicks= 0;
-  int           logical_cpu = -1;
-  const int     expected_assign_count = (-1 == which_logical_cpu) ? 4 : 5;
-  int           n;
-
-  if ((fh = open_statfile()) == NULL) {
-    return OS_ERR;
-  }
-  if (-1 == which_logical_cpu) {
-    n = fscanf(fh, "cpu " UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " "
-            UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT,
-            &userTicks, &niceTicks, &systemTicks, &idleTicks,
-            &iowTicks, &irqTicks, &sirqTicks);
-  } else {
-    // Move to next line
-    next_line(fh);
-
-    // find the line for requested cpu faster to just iterate linefeeds?
-    for (int i = 0; i < which_logical_cpu; i++) {
-      next_line(fh);
-    }
-
-    n = fscanf(fh, "cpu%u " UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " "
-               UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT,
-               &logical_cpu, &userTicks, &niceTicks,
-               &systemTicks, &idleTicks, &iowTicks, &irqTicks, &sirqTicks);
-  }
-
-  fclose(fh);
-  if (n < expected_assign_count || logical_cpu != which_logical_cpu) {
-#ifdef DEBUG_LINUX_PROC_STAT
-    vm_fprintf(stderr, "[stat] read failed");
-#endif
-    return OS_ERR;
-  }
-
-#ifdef DEBUG_LINUX_PROC_STAT
-  vm_fprintf(stderr, "[stat] read "
-          UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " "
-          UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " \n",
-          userTicks, niceTicks, systemTicks, idleTicks,
-          iowTicks, irqTicks, sirqTicks);
-#endif
-
-  pticks->used       = userTicks + niceTicks;
-  pticks->usedKernel = systemTicks + irqTicks + sirqTicks;
-  pticks->total      = userTicks + niceTicks + systemTicks + idleTicks +
-                       iowTicks + irqTicks + sirqTicks;
-
-  return OS_OK;
-}
-
-
 static int get_systemtype(void) {
   static int procEntriesType = UNDETECTED;
   DIR *taskDir;
 
   if (procEntriesType != UNDETECTED) {
@@ -389,11 +309,11 @@
 
 /**
  * Return the number of ticks spent in any of the processes belonging
  * to the JVM on any CPU.
  */
-static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {
+static OSReturn get_jvm_ticks(os::Linux::CPUPerfTicks* pticks) {
   uint64_t userTicks;
   uint64_t systemTicks;
 
   if (get_systemtype() != LINUX26_NPTL) {
     return OS_ERR;
@@ -402,11 +322,11 @@
   if (read_ticks("/proc/self/stat", &userTicks, &systemTicks) != 2) {
     return OS_ERR;
   }
 
   // get the total
-  if (get_total_ticks(-1, pticks) != OS_OK) {
+  if (! os::Linux::get_tick_information(pticks, -1)) {
     return OS_ERR;
   }
 
   pticks->used       = userTicks;
   pticks->usedKernel = systemTicks;
@@ -421,12 +341,12 @@
  *
  * Returns a negative value if there is a problem in determining the CPU load.
  */
 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target) {
   uint64_t udiff, kdiff, tdiff;
-  CPUPerfTicks* pticks;
-  CPUPerfTicks  tmp;
+  os::Linux::CPUPerfTicks* pticks;
+  os::Linux::CPUPerfTicks  tmp;
   double user_load;
 
   *pkernelLoad = 0.0;
 
   if (target == CPU_LOAD_VM_ONLY) {
@@ -441,11 +361,11 @@
 
   if (target == CPU_LOAD_VM_ONLY) {
     if (get_jvm_ticks(pticks) != OS_OK) {
       return -1.0;
     }
-  } else if (get_total_ticks(which_logical_cpu, pticks) != OS_OK) {
+  } else if (! os::Linux::get_tick_information(pticks, which_logical_cpu)) {
     return -1.0;
   }
 
   // seems like we sometimes end up with less kernel ticks when
   // reading /proc/self/stat a second time, timing issue between cpus?
@@ -509,55 +429,70 @@
   return parse_stat("btime " UINT64_FORMAT "\n", time);
 }
 
 static int perf_context_switch_rate(double* rate) {
   static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;
-  static uint64_t      lastTime;
+  static uint64_t      bootTime;
+  static uint64_t      lastTimeNanos;
   static uint64_t      lastSwitches;
   static double        lastRate;
 
-  uint64_t lt = 0;
+  uint64_t bt = 0;
   int res = 0;
 
-  if (lastTime == 0) {
+  // First time through bootTime will be zero.
+  if (bootTime == 0) {
     uint64_t tmp;
     if (get_boot_time(&tmp) < 0) {
       return OS_ERR;
     }
-    lt = tmp * 1000;
+    bt = tmp * 1000;
   }
 
   res = OS_OK;
 
   pthread_mutex_lock(&contextSwitchLock);
   {
 
     uint64_t sw;
     s8 t, d;
 
-    if (lastTime == 0) {
-      lastTime = lt;
+    if (bootTime == 0) {
+      // First interval is measured from boot time which is
+      // seconds since the epoch. Thereafter we measure the
+      // elapsed time using javaTimeNanos as it is monotonic-
+      // non-decreasing.
+      lastTimeNanos = os::javaTimeNanos();
+      t = os::javaTimeMillis();
+      d = t - bt;
+      // keep bootTime zero for now to use as a first-time-through flag
+    } else {
+      t = os::javaTimeNanos();
+      d = nanos_to_millis(t - lastTimeNanos);
     }
 
-    t = os::javaTimeMillis();
-    d = t - lastTime;
-
     if (d == 0) {
       *rate = lastRate;
-    } else if (!get_noof_context_switches(&sw)) {
+    } else if (get_noof_context_switches(&sw) == 0) {
       *rate      = ( (double)(sw - lastSwitches) / d ) * 1000;
       lastRate     = *rate;
       lastSwitches = sw;
-      lastTime     = t;
+      if (bootTime != 0) {
+        lastTimeNanos = t;
+      }
     } else {
       *rate = 0;
       res   = OS_ERR;
     }
     if (*rate <= 0) {
       *rate = 0;
       lastRate = 0;
     }
+
+    if (bootTime == 0) {
+      bootTime = bt;
+    }
   }
   pthread_mutex_unlock(&contextSwitchLock);
 
   return res;
 }
@@ -582,23 +517,20 @@
   _counters.nProcs = os::active_processor_count();
   _counters.cpus = NULL;
 }
 
 bool CPUPerformanceInterface::CPUPerformance::initialize() {
-  size_t tick_array_size = (_counters.nProcs +1) * sizeof(CPUPerfTicks);
-  _counters.cpus = (CPUPerfTicks*)NEW_C_HEAP_ARRAY(char, tick_array_size, mtInternal);
-  if (NULL == _counters.cpus) {
-    return false;
-  }
-  memset(_counters.cpus, 0, tick_array_size);
+  size_t array_entry_count = _counters.nProcs + 1;
+  _counters.cpus = NEW_C_HEAP_ARRAY(os::Linux::CPUPerfTicks, array_entry_count, mtInternal);
+  memset(_counters.cpus, 0, array_entry_count * sizeof(*_counters.cpus));
 
   // For the CPU load total
-  get_total_ticks(-1, &_counters.cpus[_counters.nProcs]);
+  os::Linux::get_tick_information(&_counters.cpus[_counters.nProcs], -1);
 
   // For each CPU
   for (int i = 0; i < _counters.nProcs; i++) {
-    get_total_ticks(i, &_counters.cpus[i]);
+    os::Linux::get_tick_information(&_counters.cpus[i], i);
   }
   // For JVM load
   get_jvm_ticks(&_counters.jvmTicks);
 
   // initialize context switch system
@@ -674,11 +606,11 @@
   _impl = NULL;
 }
 
 bool CPUPerformanceInterface::initialize() {
   _impl = new CPUPerformanceInterface::CPUPerformance();
-  return NULL == _impl ? false : _impl->initialize();
+  return _impl->initialize();
 }
 
 CPUPerformanceInterface::~CPUPerformanceInterface() {
   if (_impl != NULL) {
     delete _impl;
@@ -827,23 +759,21 @@
     while (fread(&dummy, 1, 1, fp) == 1) {
       size++;
     }
     if (size > 0) {
       cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);
-      if (cmdline != NULL) {
-        cmdline[0] = '\0';
-        if (fseek(fp, 0, SEEK_SET) == 0) {
-          if (fread(cmdline, 1, size, fp) == size) {
-            // the file has the arguments separated by '\0',
-            // so we translate '\0' to ' '
-            for (size_t i = 0; i < size; i++) {
-              if (cmdline[i] == '\0') {
-                cmdline[i] = ' ';
-              }
+      cmdline[0] = '\0';
+      if (fseek(fp, 0, SEEK_SET) == 0) {
+        if (fread(cmdline, 1, size, fp) == size) {
+          // the file has the arguments separated by '\0',
+          // so we translate '\0' to ' '
+          for (size_t i = 0; i < size; i++) {
+            if (cmdline[i] == '\0') {
+              cmdline[i] = ' ';
             }
-            cmdline[size] = '\0';
           }
+          cmdline[size] = '\0';
         }
       }
     }
     fclose(fp);
   }
@@ -933,11 +863,11 @@
   _iterator = NULL;
 }
 
 bool SystemProcessInterface::SystemProcesses::initialize() {
   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
-  return NULL == _iterator ? false : _iterator->initialize();
+  return _iterator->initialize();
 }
 
 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
   if (_iterator != NULL) {
     delete _iterator;
@@ -980,11 +910,11 @@
   _impl = NULL;
 }
 
 bool SystemProcessInterface::initialize() {
   _impl = new SystemProcessInterface::SystemProcesses();
-  return NULL == _impl ? false : _impl->initialize();
+  return _impl->initialize();
 }
 
 SystemProcessInterface::~SystemProcessInterface() {
   if (_impl != NULL) {
     delete _impl;
@@ -995,19 +925,15 @@
   _cpu_info = NULL;
 }
 
 bool CPUInformationInterface::initialize() {
   _cpu_info = new CPUInformation();
-  if (NULL == _cpu_info) {
-    return false;
-  }
   _cpu_info->set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
   _cpu_info->set_number_of_cores(VM_Version_Ext::number_of_cores());
   _cpu_info->set_number_of_sockets(VM_Version_Ext::number_of_sockets());
   _cpu_info->set_cpu_name(VM_Version_Ext::cpu_name());
   _cpu_info->set_cpu_description(VM_Version_Ext::cpu_description());
-
   return true;
 }
 
 CPUInformationInterface::~CPUInformationInterface() {
   if (_cpu_info != NULL) {
@@ -1036,12 +962,11 @@
 
 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj<mtInternal> {
   friend class NetworkPerformanceInterface;
  private:
   NetworkPerformance();
-  NetworkPerformance(const NetworkPerformance& rhs); // no impl
-  NetworkPerformance& operator=(const NetworkPerformance& rhs); // no impl
+  NONCOPYABLE(NetworkPerformance);
   bool initialize();
   ~NetworkPerformance();
   int64_t read_counter(const char* iface, const char* counter) const;
   int network_utilization(NetworkInterface** network_interfaces) const;
 };
@@ -1117,11 +1042,11 @@
   }
 }
 
 bool NetworkPerformanceInterface::initialize() {
   _impl = new NetworkPerformanceInterface::NetworkPerformance();
-  return _impl != NULL && _impl->initialize();
+  return _impl->initialize();
 }
 
 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
   return _impl->network_utilization(network_interfaces);
 }

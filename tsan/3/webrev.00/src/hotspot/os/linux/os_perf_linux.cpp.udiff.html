<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/os/linux/os_perf_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_linux.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="perfMemory_linux.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_perf_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,10 +26,11 @@</span>
  #include &quot;jvm.h&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;os_linux.inline.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/os_perf.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  
  #include CPU_HEADER(vm_version_ext)
  
  #include &lt;stdio.h&gt;
  #include &lt;stdarg.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -204,17 +205,10 @@</span>
  
  #ifndef _SCANFMT_
  #  define _SCANFMT_
  #endif
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- struct CPUPerfTicks {</span>
<span class="udiff-line-removed">-   uint64_t  used;</span>
<span class="udiff-line-removed">-   uint64_t  usedKernel;</span>
<span class="udiff-line-removed">-   uint64_t  total;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
  typedef enum {
    CPU_LOAD_VM_ONLY,
    CPU_LOAD_GLOBAL,
  } CpuLoadTarget;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -225,12 +219,12 @@</span>
    BAREMETAL
  };
  
  struct CPUPerfCounters {
    int   nProcs;
<span class="udiff-line-modified-removed">-   CPUPerfTicks jvmTicks;</span>
<span class="udiff-line-modified-removed">-   CPUPerfTicks* cpus;</span>
<span class="udiff-line-modified-added">+   os::Linux::CPUPerfTicks jvmTicks;</span>
<span class="udiff-line-modified-added">+   os::Linux::CPUPerfTicks* cpus;</span>
  };
  
  static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target);
  
  /** reads /proc/&lt;pid&gt;/stat data, with some checks and some skips.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -285,84 +279,10 @@</span>
      }
    }
    return f;
  }
  
<span class="udiff-line-removed">- static void</span>
<span class="udiff-line-removed">- next_line(FILE *f) {</span>
<span class="udiff-line-removed">-   int c;</span>
<span class="udiff-line-removed">-   do {</span>
<span class="udiff-line-removed">-     c = fgetc(f);</span>
<span class="udiff-line-removed">-   } while (c != &#39;\n&#39; &amp;&amp; c != EOF);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /**</span>
<span class="udiff-line-removed">-  * Return the total number of ticks since the system was booted.</span>
<span class="udiff-line-removed">-  * If the usedTicks parameter is not NULL, it will be filled with</span>
<span class="udiff-line-removed">-  * the number of ticks spent on actual processes (user, system or</span>
<span class="udiff-line-removed">-  * nice processes) since system boot. Note that this is the total number</span>
<span class="udiff-line-removed">-  * of &quot;executed&quot; ticks on _all_ CPU:s, that is on a n-way system it is</span>
<span class="udiff-line-removed">-  * n times the number of ticks that has passed in clock time.</span>
<span class="udiff-line-removed">-  *</span>
<span class="udiff-line-removed">-  * Returns a negative value if the reading of the ticks failed.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {</span>
<span class="udiff-line-removed">-   FILE*         fh;</span>
<span class="udiff-line-removed">-   uint64_t      userTicks, niceTicks, systemTicks, idleTicks;</span>
<span class="udiff-line-removed">-   uint64_t      iowTicks = 0, irqTicks = 0, sirqTicks= 0;</span>
<span class="udiff-line-removed">-   int           logical_cpu = -1;</span>
<span class="udiff-line-removed">-   const int     expected_assign_count = (-1 == which_logical_cpu) ? 4 : 5;</span>
<span class="udiff-line-removed">-   int           n;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if ((fh = open_statfile()) == NULL) {</span>
<span class="udiff-line-removed">-     return OS_ERR;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (-1 == which_logical_cpu) {</span>
<span class="udiff-line-removed">-     n = fscanf(fh, &quot;cpu &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="udiff-line-removed">-             UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,</span>
<span class="udiff-line-removed">-             &amp;userTicks, &amp;niceTicks, &amp;systemTicks, &amp;idleTicks,</span>
<span class="udiff-line-removed">-             &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // Move to next line</span>
<span class="udiff-line-removed">-     next_line(fh);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // find the line for requested cpu faster to just iterate linefeeds?</span>
<span class="udiff-line-removed">-     for (int i = 0; i &lt; which_logical_cpu; i++) {</span>
<span class="udiff-line-removed">-       next_line(fh);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     n = fscanf(fh, &quot;cpu%u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="udiff-line-removed">-                UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,</span>
<span class="udiff-line-removed">-                &amp;logical_cpu, &amp;userTicks, &amp;niceTicks,</span>
<span class="udiff-line-removed">-                &amp;systemTicks, &amp;idleTicks, &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   fclose(fh);</span>
<span class="udiff-line-removed">-   if (n &lt; expected_assign_count || logical_cpu != which_logical_cpu) {</span>
<span class="udiff-line-removed">- #ifdef DEBUG_LINUX_PROC_STAT</span>
<span class="udiff-line-removed">-     vm_fprintf(stderr, &quot;[stat] read failed&quot;);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     return OS_ERR;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef DEBUG_LINUX_PROC_STAT</span>
<span class="udiff-line-removed">-   vm_fprintf(stderr, &quot;[stat] read &quot;</span>
<span class="udiff-line-removed">-           UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="udiff-line-removed">-           UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; \n&quot;,</span>
<span class="udiff-line-removed">-           userTicks, niceTicks, systemTicks, idleTicks,</span>
<span class="udiff-line-removed">-           iowTicks, irqTicks, sirqTicks);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   pticks-&gt;used       = userTicks + niceTicks;</span>
<span class="udiff-line-removed">-   pticks-&gt;usedKernel = systemTicks + irqTicks + sirqTicks;</span>
<span class="udiff-line-removed">-   pticks-&gt;total      = userTicks + niceTicks + systemTicks + idleTicks +</span>
<span class="udiff-line-removed">-                        iowTicks + irqTicks + sirqTicks;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return OS_OK;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  static int get_systemtype(void) {
    static int procEntriesType = UNDETECTED;
    DIR *taskDir;
  
    if (procEntriesType != UNDETECTED) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -389,11 +309,11 @@</span>
  
  /**
   * Return the number of ticks spent in any of the processes belonging
   * to the JVM on any CPU.
   */
<span class="udiff-line-modified-removed">- static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {</span>
<span class="udiff-line-modified-added">+ static OSReturn get_jvm_ticks(os::Linux::CPUPerfTicks* pticks) {</span>
    uint64_t userTicks;
    uint64_t systemTicks;
  
    if (get_systemtype() != LINUX26_NPTL) {
      return OS_ERR;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -402,11 +322,11 @@</span>
    if (read_ticks(&quot;/proc/self/stat&quot;, &amp;userTicks, &amp;systemTicks) != 2) {
      return OS_ERR;
    }
  
    // get the total
<span class="udiff-line-modified-removed">-   if (get_total_ticks(-1, pticks) != OS_OK) {</span>
<span class="udiff-line-modified-added">+   if (! os::Linux::get_tick_information(pticks, -1)) {</span>
      return OS_ERR;
    }
  
    pticks-&gt;used       = userTicks;
    pticks-&gt;usedKernel = systemTicks;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -421,12 +341,12 @@</span>
   *
   * Returns a negative value if there is a problem in determining the CPU load.
   */
  static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target) {
    uint64_t udiff, kdiff, tdiff;
<span class="udiff-line-modified-removed">-   CPUPerfTicks* pticks;</span>
<span class="udiff-line-modified-removed">-   CPUPerfTicks  tmp;</span>
<span class="udiff-line-modified-added">+   os::Linux::CPUPerfTicks* pticks;</span>
<span class="udiff-line-modified-added">+   os::Linux::CPUPerfTicks  tmp;</span>
    double user_load;
  
    *pkernelLoad = 0.0;
  
    if (target == CPU_LOAD_VM_ONLY) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -441,11 +361,11 @@</span>
  
    if (target == CPU_LOAD_VM_ONLY) {
      if (get_jvm_ticks(pticks) != OS_OK) {
        return -1.0;
      }
<span class="udiff-line-modified-removed">-   } else if (get_total_ticks(which_logical_cpu, pticks) != OS_OK) {</span>
<span class="udiff-line-modified-added">+   } else if (! os::Linux::get_tick_information(pticks, which_logical_cpu)) {</span>
      return -1.0;
    }
  
    // seems like we sometimes end up with less kernel ticks when
    // reading /proc/self/stat a second time, timing issue between cpus?
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -509,55 +429,70 @@</span>
    return parse_stat(&quot;btime &quot; UINT64_FORMAT &quot;\n&quot;, time);
  }
  
  static int perf_context_switch_rate(double* rate) {
    static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;
<span class="udiff-line-modified-removed">-   static uint64_t      lastTime;</span>
<span class="udiff-line-modified-added">+   static uint64_t      bootTime;</span>
<span class="udiff-line-added">+   static uint64_t      lastTimeNanos;</span>
    static uint64_t      lastSwitches;
    static double        lastRate;
  
<span class="udiff-line-modified-removed">-   uint64_t lt = 0;</span>
<span class="udiff-line-modified-added">+   uint64_t bt = 0;</span>
    int res = 0;
  
<span class="udiff-line-modified-removed">-   if (lastTime == 0) {</span>
<span class="udiff-line-modified-added">+   // First time through bootTime will be zero.</span>
<span class="udiff-line-added">+   if (bootTime == 0) {</span>
      uint64_t tmp;
      if (get_boot_time(&amp;tmp) &lt; 0) {
        return OS_ERR;
      }
<span class="udiff-line-modified-removed">-     lt = tmp * 1000;</span>
<span class="udiff-line-modified-added">+     bt = tmp * 1000;</span>
    }
  
    res = OS_OK;
  
    pthread_mutex_lock(&amp;contextSwitchLock);
    {
  
      uint64_t sw;
      s8 t, d;
  
<span class="udiff-line-modified-removed">-     if (lastTime == 0) {</span>
<span class="udiff-line-modified-removed">-       lastTime = lt;</span>
<span class="udiff-line-modified-added">+     if (bootTime == 0) {</span>
<span class="udiff-line-modified-added">+       // First interval is measured from boot time which is</span>
<span class="udiff-line-added">+       // seconds since the epoch. Thereafter we measure the</span>
<span class="udiff-line-added">+       // elapsed time using javaTimeNanos as it is monotonic-</span>
<span class="udiff-line-added">+       // non-decreasing.</span>
<span class="udiff-line-added">+       lastTimeNanos = os::javaTimeNanos();</span>
<span class="udiff-line-added">+       t = os::javaTimeMillis();</span>
<span class="udiff-line-added">+       d = t - bt;</span>
<span class="udiff-line-added">+       // keep bootTime zero for now to use as a first-time-through flag</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       t = os::javaTimeNanos();</span>
<span class="udiff-line-added">+       d = nanos_to_millis(t - lastTimeNanos);</span>
      }
  
<span class="udiff-line-removed">-     t = os::javaTimeMillis();</span>
<span class="udiff-line-removed">-     d = t - lastTime;</span>
<span class="udiff-line-removed">- </span>
      if (d == 0) {
        *rate = lastRate;
<span class="udiff-line-modified-removed">-     } else if (!get_noof_context_switches(&amp;sw)) {</span>
<span class="udiff-line-modified-added">+     } else if (get_noof_context_switches(&amp;sw) == 0) {</span>
        *rate      = ( (double)(sw - lastSwitches) / d ) * 1000;
        lastRate     = *rate;
        lastSwitches = sw;
<span class="udiff-line-modified-removed">-       lastTime     = t;</span>
<span class="udiff-line-modified-added">+       if (bootTime != 0) {</span>
<span class="udiff-line-added">+         lastTimeNanos = t;</span>
<span class="udiff-line-added">+       }</span>
      } else {
        *rate = 0;
        res   = OS_ERR;
      }
      if (*rate &lt;= 0) {
        *rate = 0;
        lastRate = 0;
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (bootTime == 0) {</span>
<span class="udiff-line-added">+       bootTime = bt;</span>
<span class="udiff-line-added">+     }</span>
    }
    pthread_mutex_unlock(&amp;contextSwitchLock);
  
    return res;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -582,23 +517,20 @@</span>
    _counters.nProcs = os::active_processor_count();
    _counters.cpus = NULL;
  }
  
  bool CPUPerformanceInterface::CPUPerformance::initialize() {
<span class="udiff-line-modified-removed">-   size_t tick_array_size = (_counters.nProcs +1) * sizeof(CPUPerfTicks);</span>
<span class="udiff-line-modified-removed">-   _counters.cpus = (CPUPerfTicks*)NEW_C_HEAP_ARRAY(char, tick_array_size, mtInternal);</span>
<span class="udiff-line-modified-removed">-   if (NULL == _counters.cpus) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   memset(_counters.cpus, 0, tick_array_size);</span>
<span class="udiff-line-modified-added">+   size_t array_entry_count = _counters.nProcs + 1;</span>
<span class="udiff-line-modified-added">+   _counters.cpus = NEW_C_HEAP_ARRAY(os::Linux::CPUPerfTicks, array_entry_count, mtInternal);</span>
<span class="udiff-line-modified-added">+   memset(_counters.cpus, 0, array_entry_count * sizeof(*_counters.cpus));</span>
  
    // For the CPU load total
<span class="udiff-line-modified-removed">-   get_total_ticks(-1, &amp;_counters.cpus[_counters.nProcs]);</span>
<span class="udiff-line-modified-added">+   os::Linux::get_tick_information(&amp;_counters.cpus[_counters.nProcs], -1);</span>
  
    // For each CPU
    for (int i = 0; i &lt; _counters.nProcs; i++) {
<span class="udiff-line-modified-removed">-     get_total_ticks(i, &amp;_counters.cpus[i]);</span>
<span class="udiff-line-modified-added">+     os::Linux::get_tick_information(&amp;_counters.cpus[i], i);</span>
    }
    // For JVM load
    get_jvm_ticks(&amp;_counters.jvmTicks);
  
    // initialize context switch system
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -674,11 +606,11 @@</span>
    _impl = NULL;
  }
  
  bool CPUPerformanceInterface::initialize() {
    _impl = new CPUPerformanceInterface::CPUPerformance();
<span class="udiff-line-modified-removed">-   return NULL == _impl ? false : _impl-&gt;initialize();</span>
<span class="udiff-line-modified-added">+   return _impl-&gt;initialize();</span>
  }
  
  CPUPerformanceInterface::~CPUPerformanceInterface() {
    if (_impl != NULL) {
      delete _impl;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -827,23 +759,21 @@</span>
      while (fread(&amp;dummy, 1, 1, fp) == 1) {
        size++;
      }
      if (size &gt; 0) {
        cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);
<span class="udiff-line-modified-removed">-       if (cmdline != NULL) {</span>
<span class="udiff-line-modified-removed">-         cmdline[0] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-removed">-         if (fseek(fp, 0, SEEK_SET) == 0) {</span>
<span class="udiff-line-modified-removed">-           if (fread(cmdline, 1, size, fp) == size) {</span>
<span class="udiff-line-modified-removed">-             // the file has the arguments separated by &#39;\0&#39;,</span>
<span class="udiff-line-modified-removed">-             // so we translate &#39;\0&#39; to &#39; &#39;</span>
<span class="udiff-line-modified-removed">-             for (size_t i = 0; i &lt; size; i++) {</span>
<span class="udiff-line-modified-removed">-               if (cmdline[i] == &#39;\0&#39;) {</span>
<span class="udiff-line-removed">-                 cmdline[i] = &#39; &#39;;</span>
<span class="udiff-line-removed">-               }</span>
<span class="udiff-line-modified-added">+       cmdline[0] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-added">+       if (fseek(fp, 0, SEEK_SET) == 0) {</span>
<span class="udiff-line-modified-added">+         if (fread(cmdline, 1, size, fp) == size) {</span>
<span class="udiff-line-modified-added">+           // the file has the arguments separated by &#39;\0&#39;,</span>
<span class="udiff-line-modified-added">+           // so we translate &#39;\0&#39; to &#39; &#39;</span>
<span class="udiff-line-modified-added">+           for (size_t i = 0; i &lt; size; i++) {</span>
<span class="udiff-line-modified-added">+             if (cmdline[i] == &#39;\0&#39;) {</span>
<span class="udiff-line-modified-added">+               cmdline[i] = &#39; &#39;;</span>
              }
<span class="udiff-line-removed">-             cmdline[size] = &#39;\0&#39;;</span>
            }
<span class="udiff-line-added">+           cmdline[size] = &#39;\0&#39;;</span>
          }
        }
      }
      fclose(fp);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -933,11 +863,11 @@</span>
    _iterator = NULL;
  }
  
  bool SystemProcessInterface::SystemProcesses::initialize() {
    _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<span class="udiff-line-modified-removed">-   return NULL == _iterator ? false : _iterator-&gt;initialize();</span>
<span class="udiff-line-modified-added">+   return _iterator-&gt;initialize();</span>
  }
  
  SystemProcessInterface::SystemProcesses::~SystemProcesses() {
    if (_iterator != NULL) {
      delete _iterator;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -980,11 +910,11 @@</span>
    _impl = NULL;
  }
  
  bool SystemProcessInterface::initialize() {
    _impl = new SystemProcessInterface::SystemProcesses();
<span class="udiff-line-modified-removed">-   return NULL == _impl ? false : _impl-&gt;initialize();</span>
<span class="udiff-line-modified-added">+   return _impl-&gt;initialize();</span>
  }
  
  SystemProcessInterface::~SystemProcessInterface() {
    if (_impl != NULL) {
      delete _impl;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -995,19 +925,15 @@</span>
    _cpu_info = NULL;
  }
  
  bool CPUInformationInterface::initialize() {
    _cpu_info = new CPUInformation();
<span class="udiff-line-removed">-   if (NULL == _cpu_info) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
    _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
    _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
    _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
    _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
    _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
<span class="udiff-line-removed">- </span>
    return true;
  }
  
  CPUInformationInterface::~CPUInformationInterface() {
    if (_cpu_info != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1036,12 +962,11 @@</span>
  
  class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
    friend class NetworkPerformanceInterface;
   private:
    NetworkPerformance();
<span class="udiff-line-modified-removed">-   NetworkPerformance(const NetworkPerformance&amp; rhs); // no impl</span>
<span class="udiff-line-removed">-   NetworkPerformance&amp; operator=(const NetworkPerformance&amp; rhs); // no impl</span>
<span class="udiff-line-modified-added">+   NONCOPYABLE(NetworkPerformance);</span>
    bool initialize();
    ~NetworkPerformance();
    int64_t read_counter(const char* iface, const char* counter) const;
    int network_utilization(NetworkInterface** network_interfaces) const;
  };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1117,11 +1042,11 @@</span>
    }
  }
  
  bool NetworkPerformanceInterface::initialize() {
    _impl = new NetworkPerformanceInterface::NetworkPerformance();
<span class="udiff-line-modified-removed">-   return _impl != NULL &amp;&amp; _impl-&gt;initialize();</span>
<span class="udiff-line-modified-added">+   return _impl-&gt;initialize();</span>
  }
  
  int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
    return _impl-&gt;network_utilization(network_interfaces);
  }
</pre>
<center><a href="os_linux.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="perfMemory_linux.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>